# Simplified Chinese translations for Git Manual Pages.
# Copyright (C) 2019 Free Software Foundation, Inc.
# This file is distributed under the same license as the Git package.
# Matthias Aßhauer <mha1993@live.de>, 2019.
msgid ""
msgstr ""
"Project-Id-Version: git documentation\n"
"Report-Msgid-Bugs-To: jn.avila@free.fr\n"
"POT-Creation-Date: 2024-02-10 18:59+0100\n"
"PO-Revision-Date: 2024-03-31 17:02+0000\n"
"Last-Translator: 秃头灯笼鱼 <ttdlyu@163.com>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_HANS-CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Weblate 5.5-dev\n"

#. type: Labeled list
#: en/blame-options.txt:1 en/diff-options.txt:780 en/git-instaweb.txt:45 en/git-mailinfo.txt:49 en/git-mailsplit.txt:35 en/git-repack.txt:180 en/git-status.txt:31
#, ignore-same, no-wrap, priority:280
msgid "-b"
msgstr "-b"

#. type: Plain text
#: en/blame-options.txt:4
#, placeholders:'blame.blankBoundary', priority:100
msgid "Show blank SHA-1 for boundary commits. This can also be controlled via the `blame.blankBoundary` config option."
msgstr "为边界提交显示空白的 SHA-1。 这也可以通过 `blame.blankBoundary` 配置选项来控制。"

#. type: Labeled list
#: en/blame-options.txt:5 en/git-diff-tree.txt:42 en/git-format-patch.txt:405 en/git-fsck.txt:38 en/git-rebase.txt:583
#, ignore-same, no-wrap, priority:100
msgid "--root"
msgstr "--root"

#. type: Plain text
#: en/blame-options.txt:8
#, placeholders:'blame.showRoot', priority:100
msgid "Do not treat root commits as boundaries. This can also be controlled via the `blame.showRoot` config option."
msgstr "不把根提交当作边界。 这也可以通过 `blame.showRoot` 配置选项来控制。"

#. type: Labeled list
#: en/blame-options.txt:9
#, ignore-same, no-wrap, priority:100
msgid "--show-stats"
msgstr "--show-stats"

#. type: Plain text
#: en/blame-options.txt:11
#, priority:100
msgid "Include additional statistics at the end of blame output."
msgstr "在历史追溯输出的结尾处包括额外的统计数据。"

#. type: Labeled list
#: en/blame-options.txt:12
#, no-wrap, priority:100
msgid "-L <start>,<end>"
msgstr "-L <start>,<end>"

#. type: Labeled list
#: en/blame-options.txt:13
#, no-wrap, priority:100
msgid "-L :<funcname>"
msgstr "-L :<funcname>"

#. type: Plain text
#: en/blame-options.txt:17
#, priority:100
msgid "Annotate only the line range given by '<start>,<end>', or by the function name regex '<funcname>'. May be specified multiple times. Overlapping ranges are allowed."
msgstr "仅注释由'<start>，<end>'或功能名称正则表达式'<funcname>'给出的行范围。 可以指定多次。 允许重叠范围。"

#. type: Plain text
#: en/blame-options.txt:20
#, priority:100
msgid "'<start>' and '<end>' are optional. `-L <start>` or `-L <start>,` spans from '<start>' to end of file. `-L ,<end>` spans from start of file to '<end>'."
msgstr "'<start>' 和 '<end>' 是可选的 `-L <start>` 或 `-L <start>,` 范围从 '<start>' 到文件末尾。 `-L ,<end>` 从文件开始到 '<end>'."

#. type: Labeled list
#: en/blame-options.txt:23 en/git-archive.txt:45 en/git-branch.txt:181 en/git-checkout.txt:207 en/git-clone.txt:45 en/git-config.txt:181 en/git-grep.txt:156 en/git-instaweb.txt:23 en/git-ls-tree.txt:51 en/git-repack.txt:94 en/git-svn.txt:244 en/git-tag.txt:99 en/git-var.txt:21
#, ignore-same, no-wrap, priority:300
msgid "-l"
msgstr "-l"

#. type: Plain text
#: en/blame-options.txt:25
#, priority:100
msgid "Show long rev (Default: off)."
msgstr "显示长转（默认值：关闭）。"

#. type: Labeled list
#: en/blame-options.txt:26 en/diff-options.txt:163 en/fetch-options.txt:195 en/git-branch.txt:217 en/git-cat-file.txt:40 en/git-checkout.txt:164 en/git-diff-tree.txt:39 en/git-ls-files.txt:142 en/git-ls-remote.txt:26 en/git-ls-tree.txt:47 en/git-svn.txt:312 en/git-switch.txt:158
#, ignore-same, no-wrap, priority:280
msgid "-t"
msgstr "-t"

#. type: Plain text
#: en/blame-options.txt:28
#, priority:100
msgid "Show raw timestamp (Default: off)."
msgstr "显示原始时间戳（默认值：关闭）。"

#. type: Labeled list
#: en/blame-options.txt:29
#, no-wrap, priority:100
msgid "-S <revs-file>"
msgstr "-S <修订文件>"

#. type: Plain text
#: en/blame-options.txt:31
#, placeholders:'linkgit:git-rev-list[1]', priority:100
msgid "Use revisions from revs-file instead of calling linkgit:git-rev-list[1]."
msgstr "使用revs-file中的修订，而不是调用 linkgit:git-rev-list[1]。"

#. type: Labeled list
#: en/blame-options.txt:32
#, no-wrap, placeholders:'--reverse', priority:100
msgid "--reverse <rev>..<rev>"
msgstr "--reverse <修订>..<修订>"

#. type: Plain text
#: en/blame-options.txt:39
#, placeholders:'--reverse':'--reverse':'HEAD', priority:100
msgid "Walk history forward instead of backward. Instead of showing the revision in which a line appeared, this shows the last revision in which a line has existed. This requires a range of revision like START..END where the path to blame exists in START. `git blame --reverse START` is taken as `git blame --reverse START..HEAD` for convenience."
msgstr "向前调用历史记录，而不向后调用历史记录。 与其显示行所在的修订，不显示行所在的最后一个修订。 这就需要进行一系列修订，例如START..END，其中的归咎路径在START中。 为方便起见，将git blame --reverse START。当作git blame --reverse START..HEAD。"

#. type: Labeled list
#: en/blame-options.txt:40 en/git-bisect.txt:373 en/git-describe.txt:122 en/rev-list-options.txt:129
#, ignore-same, no-wrap, priority:260
msgid "--first-parent"
msgstr "--first-parent"

#. type: Plain text
#: en/blame-options.txt:45
#, priority:100
msgid "Follow only the first parent commit upon seeing a merge commit. This option can be used to determine when a line was introduced to a particular integration branch, rather than when it was introduced to the history overall."
msgstr "在看到合并提交时只关注第一个父提交。这个选项可以用来确定某一行何时被引入某个特定的集成分支，而不是何时被引入整个历史中。"

#. type: Labeled list
#: en/blame-options.txt:46 en/diff-options.txt:16 en/diff-options.txt:22 en/fetch-options.txt:136 en/git-add.txt:96 en/git-cat-file.txt:55 en/git-checkout.txt:278 en/git-commit.txt:73 en/git-cvsexportcommit.txt:41 en/git-grep.txt:209 en/git-instaweb.txt:41 en/git-merge-file.txt:76 en/git-request-pull.txt:29 en/git-restore.txt:48 en/git-stash.txt:196 en/git-svn.txt:535 en/git-svn.txt:679 en/git.txt:128
#, ignore-same, no-wrap, priority:300
msgid "-p"
msgstr "-p"

#. type: Labeled list
#: en/blame-options.txt:47 en/fetch-options.txt:82 en/git-commit.txt:149 en/git-push.txt:177 en/git-worktree.txt:239
#, ignore-same, no-wrap, priority:280
msgid "--porcelain"
msgstr "--porcelain"

#. type: Plain text
#: en/blame-options.txt:49
#, priority:100
msgid "Show in a format designed for machine consumption."
msgstr "以适合机器使用的格式显示。"

#. type: Labeled list
#: en/blame-options.txt:50
#, ignore-same, no-wrap, priority:100
msgid "--line-porcelain"
msgstr "--line-porcelain"

#. type: Plain text
#: en/blame-options.txt:54
#, placeholders:'--porcelain', priority:100
msgid "Show the porcelain format, but output commit information for each line, not just the first time a commit is referenced. Implies --porcelain."
msgstr "显示上层命令格式，但输出每一行的提交信息，而不仅仅是第一次引用提交时的信息。 意味着 --porcelain。"

#. type: Labeled list
#: en/blame-options.txt:55 en/git-pack-objects.txt:176 en/git-svn.txt:373
#, ignore-same, no-wrap, priority:100
msgid "--incremental"
msgstr "--incremental"

#. type: Plain text
#: en/blame-options.txt:58
#, priority:100
msgid "Show the result incrementally in a format designed for machine consumption."
msgstr "以适合机器使用的格式逐步显示结果。"

#. type: Labeled list
#: en/blame-options.txt:59 en/git-mailinfo.txt:64 en/pretty-options.txt:35
#, no-wrap, placeholders:'--encoding=', priority:260
msgid "--encoding=<encoding>"
msgstr "--encoding=<编码>"

#. type: Plain text
#: en/blame-options.txt:65
#, placeholders:'linkgit:git-log[1]', priority:100
msgid "Specifies the encoding used to output author names and commit summaries. Setting it to `none` makes blame output unconverted data. For more information see the discussion about encoding in the linkgit:git-log[1] manual page."
msgstr "指定用于输出作者姓名和提交摘要的编码。设置为 `none` 会使历史追溯输出未转换的数据。更多信息见 linkgit:git-log[1] 手册页中关于编码的讨论。"

#. type: Labeled list
#: en/blame-options.txt:66
#, no-wrap, placeholders:'--contents', priority:100
msgid "--contents <file>"
msgstr "--contents <文件>"

#. type: Plain text
#: en/blame-options.txt:70
#, placeholders:'HEAD', priority:100
msgid "Annotate using the contents from the named file, starting from <rev> if it is specified, and HEAD otherwise. You may specify '-' to make the command read from the standard input for the file contents."
msgstr "使用指定文件中的内容进行注释，如果指定了 <rev>，则从 <rev> 开始，否则从 HEAD 开始。你可以指定 '-' 来使命令从标准输入中读取文件内容。"

#. type: Labeled list
#: en/blame-options.txt:71
#, no-wrap, placeholders:'--date', priority:100
msgid "--date <format>"
msgstr "--date <格式>"

#. type: Plain text
#: en/blame-options.txt:77
#, placeholders:'--date':'blame.date':'blame.date':'--date':'linkgit:git-log[1]', priority:100
msgid "Specifies the format used to output dates. If --date is not provided, the value of the blame.date config variable is used. If the blame.date config variable is also not set, the iso format is used. For supported values, see the discussion of the --date option at linkgit:git-log[1]."
msgstr "指定用于输出日期的格式。如果没有提供 --date，则使用 blame.date 配置变量的值。如果 blame.date 配置变量也没有设置，则使用 iso 格式。关于支持的值，请参见 linkgit:git-log[1] 中关于 --date 选项的讨论。"

#. type: Labeled list
#: en/blame-options.txt:78 en/git-fsck.txt:100
#, ignore-same, no-wrap, priority:100
msgid "--[no-]progress"
msgstr "--[no-]progress"

#. type: Plain text
#: en/blame-options.txt:84
#, placeholders:'`--progress`':'`--porcelain`':'`--incremental`', priority:100
msgid "Progress status is reported on the standard error stream by default when it is attached to a terminal. This flag enables progress reporting even if not attached to a terminal. Can't use `--progress` together with `--porcelain` or `--incremental`."
msgstr "当它连接到一个终端时，默认情况下进度状态会在标准错误流中报告。这个标志可以使进度报告即使没有连接到终端。`--porcelain`或`--incremental` 不能与 `--progress` 一起使用。"

#. type: Labeled list
#: en/blame-options.txt:85
#, no-wrap, priority:100
msgid "-M[<num>]"
msgstr "-M[<数量>]"

#. type: Plain text
#: en/blame-options.txt:95
#, priority:100
msgid "Detect moved or copied lines within a file. When a commit moves or copies a block of lines (e.g. the original file has A and then B, and the commit changes it to B and then A), the traditional 'blame' algorithm notices only half of the movement and typically blames the lines that were moved up (i.e. B) to the parent and assigns blame to the lines that were moved down (i.e. A) to the child commit. With this option, both groups of lines are blamed on the parent by running extra passes of inspection."
msgstr "检测文件中移动或复制的行。当一次提交移动或复制一个行块时（例如，原始文件有 A，然后是 B，而提交将其改为 B，然后是 A），传统的 'blame' 算法只注意到一半的移动，通常将向上移动的行（即 B ）归咎于父代，而将向下移动的行（即 A ）归咎于子代提交。 有了这个选项，通过运行额外的检查，两组行都会被归咎于父代。"

#. type: Plain text
#: en/blame-options.txt:100
#, priority:100
msgid "<num> is optional but it is the lower bound on the number of alphanumeric characters that Git must detect as moving/copying within a file for it to associate those lines with the parent commit. The default value is 20."
msgstr "<num> 是可选的，但它是 Git 必须检测到的在文件中移动或复制的字母数字字符的数量的下限，以便它将这些行与父提交相关联。默认值是20。"

#. type: Labeled list
#: en/blame-options.txt:101
#, no-wrap, priority:100
msgid "-C[<num>]"
msgstr "-C[<数量>]"

#. type: Plain text
#: en/blame-options.txt:110
#, placeholders:'`-M`', priority:100
msgid "In addition to `-M`, detect lines moved or copied from other files that were modified in the same commit. This is useful when you reorganize your program and move code around across files. When this option is given twice, the command additionally looks for copies from other files in the commit that creates the file. When this option is given three times, the command additionally looks for copies from other files in any commit."
msgstr "除了`-M`之外，还可以检测在同一提交中被修改的其他文件中移动或复制的行。 这在你重新组织程序并在不同文件间移动代码时很有用。 当这个选项被赋予两次时，命令会在创建文件的提交中额外寻找其他文件的拷贝。当这个选项出现三次时，命令会在任何一次提交中额外寻找其他文件的副本。"

# ERROR: `-C` not found in translation
# ERROR: `-C` not found in translation
#. type: Plain text
#: en/blame-options.txt:117
#, placeholders:'`-C`':'`-C`', priority:100
msgid "<num> is optional but it is the lower bound on the number of alphanumeric characters that Git must detect as moving/copying between files for it to associate those lines with the parent commit. And the default value is 40. If there are more than one `-C` options given, the <num> argument of the last `-C` will take effect."
msgstr "<num> 是可选的，但它是 Git 必须检测到的在文件之间移动或复制的字母数字字符的数量的下限，以便它将这些行与父提交关联起来。而默认值是 40。如果有一个以上的 `-C` 选项，只有最后一个 `-C` 的 <num> 参数起作用。"

#. type: Labeled list
#: en/blame-options.txt:118
#, no-wrap, placeholders:'--ignore-rev', priority:100
msgid "--ignore-rev <rev>"
msgstr "--ignore-rev <修订>"

#. type: Plain text
#: en/blame-options.txt:129
#, placeholders:'blame.markIgnoredLines':'blame.markUnblamableLines', priority:100
msgid "Ignore changes made by the revision when assigning blame, as if the change never happened. Lines that were changed or added by an ignored commit will be blamed on the previous commit that changed that line or nearby lines. This option may be specified multiple times to ignore more than one revision. If the `blame.markIgnoredLines` config option is set, then lines that were changed by an ignored commit and attributed to another commit will be marked with a `?` in the blame output. If the `blame.markUnblamableLines` config option is set, then those lines touched by an ignored commit that we could not attribute to another revision are marked with a '*'."
msgstr "在分配责任时忽略修订版所做的修改，就像该修改从未发生过一样。 被忽略的提交所改变或增加的行将被归咎于改变该行或附近行的前一个提交。 这个选项可以多次指定，以忽略一个以上的修订。 如果设置了 `blame.markIgnoredLines` 配置选项，那么被忽略的提交所改变的行将被归咎于另一个提交，在归咎输出中会标上`?` 如果设置了 `blame.markUnblamableLines` 配置选项，那么那些被忽略的提交所触及的、我们无法归因于另一个修订版的行将被标记为 '*'。"

#. type: Labeled list
#: en/blame-options.txt:130
#, no-wrap, placeholders:'--ignore-revs-file', priority:100
msgid "--ignore-revs-file <file>"
msgstr "--ignore-revs-file <文件>"

#. type: Plain text
#: en/blame-options.txt:136
#, placeholders:'fsck.skipList':'blame.ignoreRevsFile', priority:100
msgid "Ignore revisions listed in `file`, which must be in the same format as an `fsck.skipList`. This option may be repeated, and these files will be processed after any files specified with the `blame.ignoreRevsFile` config option. An empty file name, `\"\"`, will clear the list of revs from previously processed files."
msgstr "忽略 `file` 中列出的修订，其格式必须与 `fsck.skipList` 相同。 这个选项可以重复使用，这些文件将在任何用 `blame.ignoreRevsFile` 配置选项指定的文件之后被处理。 一个空的文件名，`\"\"`，将清除以前处理的文件的 Revs 列表。"

#. type: Labeled list
#: en/blame-options.txt:137
#, ignore-same, no-wrap, priority:100
msgid "--color-lines"
msgstr "--color-lines"

#. type: Plain text
#: en/blame-options.txt:142
#, placeholders:'color.blame.repeatedLines', priority:100
msgid "Color line annotations in the default format differently if they come from the same commit as the preceding line. This makes it easier to distinguish code blocks introduced by different commits. The color defaults to cyan and can be adjusted using the `color.blame.repeatedLines` config option."
msgstr "在默认格式下，如果行注释与前一行来自同一提交，则颜色不同。这可以让我们更容易区分不同提交的代码块。颜色默认为青色，可以使用 `color.blame.repeatedLines` 配置选项进行调整。"

#. type: Labeled list
#: en/blame-options.txt:143
#, ignore-same, no-wrap, priority:100
msgid "--color-by-age"
msgstr "--color-by-age"

#. type: Plain text
#: en/blame-options.txt:147
#, placeholders:'color.blame.highlightRecent', priority:100
msgid "Color line annotations depending on the age of the line in the default format. The `color.blame.highlightRecent` config option controls what color is used for each range of age."
msgstr "根据默认格式的行的阶段，给行的注释着色。 `color.blame.highlightRecent` 配置选项控制每个阶段范围使用什么颜色。"

#. type: Labeled list
#: en/blame-options.txt:148 en/git-archimport.txt:71 en/git-cvsimport.txt:184 en/git-cvsserver.txt:60 en/git-grep.txt:114 en/git-ls-remote.txt:24 en/git.txt:49
#, ignore-same, no-wrap, priority:100
msgid "-h"
msgstr "-h"

#. type: Plain text
#: en/blame-options.txt:149
#, priority:100
msgid "Show help message."
msgstr "显示帮助信息。"

#. type: Plain text
#: en/cmds-ancillaryinterrogators.txt:1 en/git-blame.txt:254
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-annotate[1]"
msgstr "linkgit:git-annotate[1]"

#. type: Plain text
#: en/cmds-ancillaryinterrogators.txt:3
#, priority:100
msgid "Annotate file lines with commit information."
msgstr "用提交信息来注释文件行。"

#. type: Plain text
#: en/cmds-ancillaryinterrogators.txt:4 en/git-annotate.txt:30
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-blame[1]"
msgstr "linkgit:git-blame[1]"

#. type: Plain text
#: en/cmds-ancillaryinterrogators.txt:6
#, priority:100
msgid "Show what revision and author last modified each line of a file."
msgstr "显示文件的每一行最后修改的版本和作者。"

#. type: Labeled list
#: en/cmds-ancillaryinterrogators.txt:7
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-bugreport[1]"
msgstr "linkgit:git-bugreport[1]"

#. type: Plain text
#: en/cmds-ancillaryinterrogators.txt:9
#, priority:100
msgid "Collect information for user to file a bug report."
msgstr "收集信息，以便用户提交错误报告。"

#. type: Labeled list
#: en/cmds-ancillaryinterrogators.txt:10
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-count-objects[1]"
msgstr "linkgit:git-count-objects[1]"

#. type: Plain text
#: en/cmds-ancillaryinterrogators.txt:12
#, priority:100
msgid "Count unpacked number of objects and their disk consumption."
msgstr "计数对象的解包数量和它们的磁盘消耗。"

#. type: Labeled list
#: en/cmds-ancillaryinterrogators.txt:13
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-diagnose[1]"
msgstr "linkgit:git-diagnose[1]"

#. type: Plain text
#: en/cmds-ancillaryinterrogators.txt:15
#, priority:100
msgid "Generate a zip archive of diagnostic information."
msgstr "生成一个诊断信息的压缩文件。"

#. type: Labeled list
#: en/cmds-ancillaryinterrogators.txt:16
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-difftool[1]"
msgstr "linkgit:git-difftool[1]"

#. type: Plain text
#: en/cmds-ancillaryinterrogators.txt:18
#, priority:100
msgid "Show changes using common diff tools."
msgstr "使用常见的差异工具显示变化。"

#. type: Labeled list
#: en/cmds-ancillaryinterrogators.txt:19
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-fsck[1]"
msgstr "linkgit:git-fsck[1]"

#. type: Plain text
#: en/cmds-ancillaryinterrogators.txt:21 en/git-fsck.txt:20
#, priority:100
msgid "Verifies the connectivity and validity of the objects in the database."
msgstr "验证数据库中的对象的连接性和有效性。"

#. type: Labeled list
#: en/cmds-ancillaryinterrogators.txt:22
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-help[1]"
msgstr "linkgit:git-help[1]"

#. type: Plain text
#: en/cmds-ancillaryinterrogators.txt:24
#, priority:100
msgid "Display help information about Git."
msgstr "显示有关 Git 的帮助信息。"

#. type: Labeled list
#: en/cmds-ancillaryinterrogators.txt:25
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-instaweb[1]"
msgstr "linkgit:git-instaweb[1]"

#. type: Plain text
#: en/cmds-ancillaryinterrogators.txt:27
#, priority:100
msgid "Instantly browse your working repository in gitweb."
msgstr "在gitweb中浏览您的工作存储库。"

#. type: Labeled list
#: en/cmds-ancillaryinterrogators.txt:28
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-merge-tree[1]"
msgstr "linkgit:git-merge-tree[1]"

#. type: Plain text
#: en/cmds-ancillaryinterrogators.txt:30
#, priority:100
msgid "Perform merge without touching index or working tree."
msgstr "执行合并时无需触及索引或工作目录树。"

#. type: Labeled list
#: en/cmds-ancillaryinterrogators.txt:31
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-rerere[1]"
msgstr "linkgit:git-rerere[1]"

#. type: Plain text
#: en/cmds-ancillaryinterrogators.txt:33
#, priority:100
msgid "Reuse recorded resolution of conflicted merges."
msgstr "重新使用记录的冲突合并的解决方案。"

#. type: Labeled list
#: en/cmds-ancillaryinterrogators.txt:34
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-show-branch[1]"
msgstr "linkgit:git-show-branch[1]"

#. type: Plain text
#: en/cmds-ancillaryinterrogators.txt:36
#, priority:100
msgid "Show branches and their commits."
msgstr "显示分支和它们的提交。"

#. type: Labeled list
#: en/cmds-ancillaryinterrogators.txt:37
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-verify-commit[1]"
msgstr "linkgit:git-verify-commit[1]"

#. type: Plain text
#: en/cmds-ancillaryinterrogators.txt:39
#, priority:100
msgid "Check the GPG signature of commits."
msgstr "检查提交的 GPG 签名。"

#. type: Labeled list
#: en/cmds-ancillaryinterrogators.txt:40
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-verify-tag[1]"
msgstr "linkgit:git-verify-tag[1]"

#. type: Plain text
#: en/cmds-ancillaryinterrogators.txt:42
#, priority:100
msgid "Check the GPG signature of tags."
msgstr "检查标签的 GPG 签名。"

#. type: Labeled list
#: en/cmds-ancillaryinterrogators.txt:43
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-version[1]"
msgstr "linkgit:git-version[1]"

#. type: Plain text
#: en/cmds-ancillaryinterrogators.txt:45
#, priority:100
msgid "Display version information about Git."
msgstr "显示 Git 的版本信息。"

#. type: Labeled list
#: en/cmds-ancillaryinterrogators.txt:46
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-whatchanged[1]"
msgstr "linkgit:git-whatchanged[1]"

#. type: Plain text
#: en/cmds-ancillaryinterrogators.txt:48
#, priority:100
msgid "Show logs with difference each commit introduces."
msgstr "显示每次提交带来的差异的日志。"

#. type: Plain text
#: en/cmds-ancillaryinterrogators.txt:49 en/git-instaweb.txt:91
#, ignore-same, no-wrap, priority:100
msgid "linkgit:gitweb[1]"
msgstr "linkgit:gitweb[1]"

#. type: Plain text
#: en/cmds-ancillaryinterrogators.txt:51
#, priority:100
msgid "Git web interface (web frontend to Git repositories)."
msgstr "Git web 接口（Git 仓库的 web 前端）。"

#. type: Labeled list
#: en/cmds-ancillarymanipulators.txt:1 en/git-difftool.txt:135
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-config[1]"
msgstr "linkgit:git-config[1]"

#. type: Plain text
#: en/cmds-ancillarymanipulators.txt:3
#, priority:100
msgid "Get and set repository or global options."
msgstr "获取和设置存储库或全局选项。"

#. type: Plain text
#: en/cmds-ancillarymanipulators.txt:4 en/git-fast-import.txt:1577
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-fast-export[1]"
msgstr "linkgit:git-fast-export[1]"

#. type: Plain text
#: en/cmds-ancillarymanipulators.txt:6
#, priority:100
msgid "Git data exporter."
msgstr "Git 数据导出器。"

#. type: Plain text
#: en/cmds-ancillarymanipulators.txt:7 en/git-fast-export.txt:281
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-fast-import[1]"
msgstr "linkgit:git-fast-import[1]"

#. type: Plain text
#: en/cmds-ancillarymanipulators.txt:9
#, priority:100
msgid "Backend for fast Git data importers."
msgstr "快速 Git 数据导入器的后端。"

#. type: Labeled list
#: en/cmds-ancillarymanipulators.txt:10
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-filter-branch[1]"
msgstr "linkgit:git-filter-branch[1]"

#. type: Plain text
#: en/cmds-ancillarymanipulators.txt:12
#, priority:100
msgid "Rewrite branches."
msgstr "重写分支。"

#. type: Labeled list
#: en/cmds-ancillarymanipulators.txt:13 en/git-difftool.txt:132
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-mergetool[1]"
msgstr "linkgit:git-mergetool[1]"

#. type: Plain text
#: en/cmds-ancillarymanipulators.txt:15
#, priority:100
msgid "Run merge conflict resolution tools to resolve merge conflicts."
msgstr "运行合并冲突解决工具来解决合并冲突。"

#. type: Labeled list
#: en/cmds-ancillarymanipulators.txt:16
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-pack-refs[1]"
msgstr "linkgit:git-pack-refs[1]"

#. type: Plain text
#: en/cmds-ancillarymanipulators.txt:18
#, priority:100
msgid "Pack heads and tags for efficient repository access."
msgstr "包装头和标签用于有效的仓库访问。"

#. type: Labeled list
#: en/cmds-ancillarymanipulators.txt:19
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-prune[1]"
msgstr "linkgit:git-prune[1]"

#. type: Plain text
#: en/cmds-ancillarymanipulators.txt:21
#, priority:100
msgid "Prune all unreachable objects from the object database."
msgstr "从对象数据库中修剪所有不可达的对象。"

#. type: Labeled list
#: en/cmds-ancillarymanipulators.txt:22
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-reflog[1]"
msgstr "linkgit:git-reflog[1]"

#. type: Plain text
#: en/cmds-ancillarymanipulators.txt:24
#, priority:100
msgid "Manage reflog information."
msgstr "管理reflog信息。"

#. type: Labeled list
#: en/cmds-ancillarymanipulators.txt:25
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-remote[1]"
msgstr "linkgit:git-remote[1]"

#. type: Plain text
#: en/cmds-ancillarymanipulators.txt:27
#, priority:100
msgid "Manage set of tracked repositories."
msgstr "管理一组被跟踪的仓库。"

#. type: Labeled list
#: en/cmds-ancillarymanipulators.txt:28
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-repack[1]"
msgstr "linkgit:git-repack[1]"

#. type: Plain text
#: en/cmds-ancillarymanipulators.txt:30
#, priority:100
msgid "Pack unpacked objects in a repository."
msgstr "在存储库中打包未打包的对象。"

#. type: Labeled list
#: en/cmds-ancillarymanipulators.txt:31
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-replace[1]"
msgstr "linkgit:git-replace[1]"

#. type: Plain text
#: en/cmds-ancillarymanipulators.txt:33
#, priority:100
msgid "Create, list, delete refs to replace objects."
msgstr "创建、列出、删除替换对象的引用。"

#. type: Labeled list
#: en/cmds-developerinterfaces.txt:1
#, ignore-same, no-wrap, priority:100
msgid "linkgit:gitformat-bundle[5]"
msgstr "linkgit:gitformat-bundle[5]"

#. type: Plain text
#: en/cmds-developerinterfaces.txt:3
#, priority:100
msgid "The bundle file format."
msgstr "捆绑文件格式。"

#. type: Labeled list
#: en/cmds-developerinterfaces.txt:4
#, ignore-same, no-wrap, priority:100
msgid "linkgit:gitformat-chunk[5]"
msgstr "linkgit:gitformat-chunk[5]"

#. type: Plain text
#: en/cmds-developerinterfaces.txt:6
#, priority:100
msgid "Chunk-based file formats."
msgstr "基于块的文件格式。"

#. type: Labeled list
#: en/cmds-developerinterfaces.txt:7
#, ignore-same, no-wrap, priority:100
msgid "linkgit:gitformat-commit-graph[5]"
msgstr "linkgit:gitformat-commit-graph[5]"

#. type: Plain text
#: en/cmds-developerinterfaces.txt:9
#, priority:100
msgid "Git commit-graph format."
msgstr "Git 提交图格式。"

#. type: Labeled list
#: en/cmds-developerinterfaces.txt:10
#, ignore-same, no-wrap, priority:100
msgid "linkgit:gitformat-index[5]"
msgstr "linkgit:gitformat-index[5]"

#. type: Plain text
#: en/cmds-developerinterfaces.txt:12
#, priority:100
msgid "Git index format."
msgstr "Git 索引格式。"

#. type: Labeled list
#: en/cmds-developerinterfaces.txt:13
#, ignore-same, no-wrap, priority:100
msgid "linkgit:gitformat-pack[5]"
msgstr "linkgit:gitformat-pack[5]"

#. type: Plain text
#: en/cmds-developerinterfaces.txt:15
#, priority:100
msgid "Git pack format."
msgstr "Git 包格式。"

#. type: Labeled list
#: en/cmds-developerinterfaces.txt:16
#, ignore-same, no-wrap, priority:100
msgid "linkgit:gitformat-signature[5]"
msgstr "linkgit:gitformat-signature[5]"

#. type: Plain text
#: en/cmds-developerinterfaces.txt:18
#, priority:100
msgid "Git cryptographic signature formats."
msgstr "Git 加密签名格式。"

#. type: Labeled list
#: en/cmds-developerinterfaces.txt:19
#, ignore-same, no-wrap, priority:100
msgid "linkgit:gitprotocol-capabilities[5]"
msgstr "linkgit:gitprotocol-capabilities[5]"

#. type: Plain text
#: en/cmds-developerinterfaces.txt:21
#, priority:100
msgid "Protocol v0 and v1 capabilities."
msgstr "协议 v0 和 v1 功能。"

#. type: Labeled list
#: en/cmds-developerinterfaces.txt:22
#, ignore-same, no-wrap, priority:100
msgid "linkgit:gitprotocol-common[5]"
msgstr "linkgit:gitprotocol-common[5]"

#. type: Plain text
#: en/cmds-developerinterfaces.txt:24
#, priority:100
msgid "Things common to various protocols."
msgstr "各种协议的共同点。"

#. type: Labeled list
#: en/cmds-developerinterfaces.txt:25
#, ignore-same, no-wrap, priority:100
msgid "linkgit:gitprotocol-http[5]"
msgstr "linkgit:gitprotocol-http[5]"

#. type: Plain text
#: en/cmds-developerinterfaces.txt:27
#, priority:100
msgid "Git HTTP-based protocols."
msgstr "Git 基于 HTTP 的协议。"

#. type: Labeled list
#: en/cmds-developerinterfaces.txt:28
#, ignore-same, no-wrap, priority:100
msgid "linkgit:gitprotocol-pack[5]"
msgstr "linkgit:gitprotocol-pack[5]"

#. type: Plain text
#: en/cmds-developerinterfaces.txt:30
#, priority:100
msgid "How packs are transferred over-the-wire."
msgstr "数据包如何通过网络传输。"

#. type: Labeled list
#: en/cmds-developerinterfaces.txt:31
#, ignore-same, no-wrap, priority:100
msgid "linkgit:gitprotocol-v2[5]"
msgstr "linkgit:gitprotocol-v2[5]"

#. type: Plain text
#: en/cmds-developerinterfaces.txt:33
#, priority:100
msgid "Git Wire Protocol, Version 2."
msgstr "Git Wire 协议第 2 版。"

#. type: Labeled list
#: en/cmds-foreignscminterface.txt:1
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-archimport[1]"
msgstr "linkgit:git-archimport[1]"

#. type: Plain text
#: en/cmds-foreignscminterface.txt:3
#, priority:100
msgid "Import a GNU Arch repository into Git."
msgstr "导入一个 GNU Arch 仓库到 Git。"

#. type: Labeled list
#: en/cmds-foreignscminterface.txt:4
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-cvsexportcommit[1]"
msgstr "linkgit:git-cvsexportcommit[1]"

#. type: Plain text
#: en/cmds-foreignscminterface.txt:6
#, priority:100
msgid "Export a single commit to a CVS checkout."
msgstr "将单个提交导出到 CVS 检出。"

#. type: Labeled list
#: en/cmds-foreignscminterface.txt:7
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-cvsimport[1]"
msgstr "linkgit:git-cvsimport[1]"

#. type: Plain text
#: en/cmds-foreignscminterface.txt:9
#, priority:100
msgid "Salvage your data out of another SCM people love to hate."
msgstr "把你的数据从另一个人们爱恨交加的 SCM 中解救出来。"

#. type: Labeled list
#: en/cmds-foreignscminterface.txt:10
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-cvsserver[1]"
msgstr "linkgit:git-cvsserver[1]"

#. type: Plain text
#: en/cmds-foreignscminterface.txt:12
#, priority:100
msgid "A CVS server emulator for Git."
msgstr "用于 Git 的 CVS 服务模拟器。"

#. type: Labeled list
#: en/cmds-foreignscminterface.txt:13
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-imap-send[1]"
msgstr "linkgit:git-imap-send[1]"

#. type: Plain text
#: en/cmds-foreignscminterface.txt:15
#, priority:100
msgid "Send a collection of patches from stdin to an IMAP folder."
msgstr "从标准输入流向 IMAP 文件夹发送补丁集。"

#. type: Labeled list
#: en/cmds-foreignscminterface.txt:16
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-p4[1]"
msgstr "linkgit:git-p4[1]"

#. type: Plain text
#: en/cmds-foreignscminterface.txt:18
#, priority:100
msgid "Import from and submit to Perforce repositories."
msgstr "从 Perforce 仓库导入和提交。"

#. type: Labeled list
#: en/cmds-foreignscminterface.txt:19
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-quiltimport[1]"
msgstr "linkgit:git-quiltimport[1]"

#. type: Plain text
#: en/cmds-foreignscminterface.txt:21
#, priority:100
msgid "Applies a quilt patchset onto the current branch."
msgstr "将 quilt 补丁集应用到当前分支。"

#. type: Labeled list
#: en/cmds-foreignscminterface.txt:22
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-request-pull[1]"
msgstr "linkgit:git-request-pull[1]"

#. type: Plain text
#: en/cmds-foreignscminterface.txt:24
#, priority:100
msgid "Generates a summary of pending changes."
msgstr "生成一个待处理更改摘要。"

#. type: Labeled list
#: en/cmds-foreignscminterface.txt:25
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-send-email[1]"
msgstr "linkgit:git-send-email[1]"

#. type: Plain text
#: en/cmds-foreignscminterface.txt:27
#, priority:100
msgid "Send a collection of patches as emails."
msgstr "以电子邮件的形式发送补丁集合。"

#. type: Labeled list
#: en/cmds-foreignscminterface.txt:28
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-svn[1]"
msgstr "linkgit:git-svn[1]"

#. type: Plain text
#: en/cmds-foreignscminterface.txt:30
#, priority:100
msgid "Bidirectional operation between a Subversion repository and Git."
msgstr "Subversion 仓库和 Git 之间的双向操作。"

#. type: Labeled list
#: en/cmds-guide.txt:1
#, ignore-same, no-wrap, priority:100
msgid "linkgit:gitcore-tutorial[7]"
msgstr "linkgit:gitcore-tutorial[7]"

#. type: Plain text
#: en/cmds-guide.txt:3
#, priority:100
msgid "A Git core tutorial for developers."
msgstr "面向开发者的 Git 核心教程。"

#. type: Labeled list
#: en/cmds-guide.txt:4
#, ignore-same, no-wrap, priority:100
msgid "linkgit:gitcredentials[7]"
msgstr "linkgit:gitcredentials[7]"

#. type: Plain text
#: en/cmds-guide.txt:6
#, priority:100
msgid "Providing usernames and passwords to Git."
msgstr "向 Git 提供用户名和密码。"

#. type: Labeled list
#: en/cmds-guide.txt:7
#, ignore-same, no-wrap, priority:100
msgid "linkgit:gitcvs-migration[7]"
msgstr "linkgit:gitcvs-migration[7]"

#. type: Plain text
#: en/cmds-guide.txt:9
#, priority:100
msgid "Git for CVS users."
msgstr "为 CVS 用户提供的 Git。"

#. type: Labeled list
#: en/cmds-guide.txt:10
#, ignore-same, no-wrap, priority:100
msgid "linkgit:gitdiffcore[7]"
msgstr "linkgit:gitdiffcore[7]"

#. type: Plain text
#: en/cmds-guide.txt:12
#, priority:100
msgid "Tweaking diff output."
msgstr "调整差异输出。"

#. type: Labeled list
#: en/cmds-guide.txt:13
#, ignore-same, no-wrap, priority:100
msgid "linkgit:giteveryday[7]"
msgstr "linkgit:giteveryday[7]"

#. type: Plain text
#: en/cmds-guide.txt:15
#, priority:100
msgid "A useful minimum set of commands for Everyday Git."
msgstr "一套有用的最小化 Git 命令集。"

#. type: Labeled list
#: en/cmds-guide.txt:16
#, ignore-same, no-wrap, priority:100
msgid "linkgit:gitfaq[7]"
msgstr "linkgit:gitfaq[7]"

#. type: Plain text
#: en/cmds-guide.txt:18
#, priority:100
msgid "Frequently asked questions about using Git."
msgstr "关于使用 Git 的常见问题。"

#. type: Labeled list
#: en/cmds-guide.txt:19
#, ignore-same, no-wrap, priority:100
msgid "linkgit:gitglossary[7]"
msgstr "linkgit:gitglossary[7]"

#. type: Plain text
#: en/cmds-guide.txt:21
#, priority:100
msgid "A Git Glossary."
msgstr "Git 术语表。"

#. type: Plain text
#: en/cmds-guide.txt:22 en/git-upload-pack.txt:61
#, ignore-same, no-wrap, priority:100
msgid "linkgit:gitnamespaces[7]"
msgstr "linkgit:gitnamespaces[7]"

#. type: Plain text
#: en/cmds-guide.txt:24
#, priority:100
msgid "Git namespaces."
msgstr "Git 命名空间。"

#. type: Plain text
#: en/cmds-guide.txt:25 en/git-remote-ext.txt:122 en/git-remote-fd.txt:56
#, ignore-same, no-wrap, priority:100
msgid "linkgit:gitremote-helpers[7]"
msgstr "linkgit:gitremote-helpers[7]"

#. type: Plain text
#: en/cmds-guide.txt:27
#, priority:100
msgid "Helper programs to interact with remote repositories."
msgstr "与远程仓库互动的辅助程序。"

#. type: Labeled list
#: en/cmds-guide.txt:28
#, ignore-same, no-wrap, priority:100
msgid "linkgit:gitsubmodules[7]"
msgstr "linkgit:gitsubmodules[7]"

#. type: Plain text
#: en/cmds-guide.txt:30
#, priority:100
msgid "Mounting one repository inside another."
msgstr "将一个仓库挂载在另一个仓库内。"

#. type: Labeled list
#: en/cmds-guide.txt:31
#, ignore-same, no-wrap, priority:100
msgid "linkgit:gittutorial[7]"
msgstr "linkgit:gittutorial[7]"

#. type: Plain text
#: en/cmds-guide.txt:33
#, priority:100
msgid "A tutorial introduction to Git."
msgstr "Git 入门教程。"

#. type: Labeled list
#: en/cmds-guide.txt:34
#, ignore-same, no-wrap, priority:100
msgid "linkgit:gittutorial-2[7]"
msgstr "linkgit:gittutorial-2[7]"

#. type: Plain text
#: en/cmds-guide.txt:36
#, priority:100
msgid "A tutorial introduction to Git: part two."
msgstr "Git 的教程介绍：第二部分。"

#. type: Labeled list
#: en/cmds-guide.txt:37
#, ignore-same, no-wrap, priority:100
msgid "linkgit:gitworkflows[7]"
msgstr "linkgit:gitworkflows[7]"

#. type: Plain text
#: en/cmds-guide.txt:39
#, priority:100
msgid "An overview of recommended workflows with Git."
msgstr "推荐使用 Git 的工作流程概述。"

#. type: Plain text
#: en/cmds-mainporcelain.txt:1 en/git-rm.txt:201
#, ignore-same, no-wrap, priority:280
msgid "linkgit:git-add[1]"
msgstr "linkgit:git-add[1]"

#. type: Plain text
#: en/cmds-mainporcelain.txt:3
#, priority:100
msgid "Add file contents to the index."
msgstr "将文件内容添加到索引中。"

#. type: Labeled list
#: en/cmds-mainporcelain.txt:4
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-am[1]"
msgstr "linkgit:git-am[1]"

#. type: Plain text
#: en/cmds-mainporcelain.txt:6
#, priority:100
msgid "Apply a series of patches from a mailbox."
msgstr "从一个邮箱中应用一系列的补丁。"

#. type: Labeled list
#: en/cmds-mainporcelain.txt:7
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-archive[1]"
msgstr "linkgit:git-archive[1]"

#. type: Plain text
#: en/cmds-mainporcelain.txt:9
#, priority:100
msgid "Create an archive of files from a named tree."
msgstr "从一个命名的目录中创建一个文件档案。"

#. type: Labeled list
#: en/cmds-mainporcelain.txt:10
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-bisect[1]"
msgstr "linkgit:git-bisect[1]"

#. type: Plain text
#: en/cmds-mainporcelain.txt:12
#, priority:100
msgid "Use binary search to find the commit that introduced a bug."
msgstr "使用二进制搜索查找引入错误的提交。"

#. type: Labeled list
#: en/cmds-mainporcelain.txt:13
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-branch[1]"
msgstr "linkgit:git-branch[1]"

#. type: Plain text
#: en/cmds-mainporcelain.txt:15
#, priority:100
msgid "List, create, or delete branches."
msgstr "列出、创建或删除分支。"

#. type: Labeled list
#: en/cmds-mainporcelain.txt:16
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-bundle[1]"
msgstr "linkgit:git-bundle[1]"

#. type: Plain text
#: en/cmds-mainporcelain.txt:18
#, priority:100
msgid "Move objects and refs by archive."
msgstr "通过存档移动对象和引用。"

#. type: Labeled list
#: en/cmds-mainporcelain.txt:19
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-checkout[1]"
msgstr "linkgit:git-checkout[1]"

#. type: Plain text
#: en/cmds-mainporcelain.txt:21
#, priority:100
msgid "Switch branches or restore working tree files."
msgstr "切换分支或恢复工作区文件。"

#. type: Plain text
#: en/cmds-mainporcelain.txt:22 en/git-revert.txt:165
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-cherry-pick[1]"
msgstr "linkgit:git-cherry-pick[1]"

#. type: Plain text
#: en/cmds-mainporcelain.txt:24
#, priority:100
msgid "Apply the changes introduced by some existing commits."
msgstr "应用一些现有的提交所带来的变化。"

#. type: Labeled list
#: en/cmds-mainporcelain.txt:25
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-citool[1]"
msgstr "linkgit:git-citool[1]"

#. type: Plain text
#: en/cmds-mainporcelain.txt:27
#, placeholders:'git-commit', priority:100
msgid "Graphical alternative to git-commit."
msgstr "git-commit 的图形化替代方案。"

#. type: Labeled list
#: en/cmds-mainporcelain.txt:28
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-clean[1]"
msgstr "linkgit:git-clean[1]"

#. type: Plain text
#: en/cmds-mainporcelain.txt:30
#, priority:100
msgid "Remove untracked files from the working tree."
msgstr "从工作区上删除未跟踪的文件。"

#. type: Labeled list
#: en/cmds-mainporcelain.txt:31
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-clone[1]"
msgstr "linkgit:git-clone[1]"

#. type: Plain text
#: en/cmds-mainporcelain.txt:33
#, priority:100
msgid "Clone a repository into a new directory."
msgstr "将版本库克隆到一个新目录中。"

#. type: Labeled list
#: en/cmds-mainporcelain.txt:34
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-commit[1]"
msgstr "linkgit:git-commit[1]"

#. type: Plain text
#: en/cmds-mainporcelain.txt:36
#, priority:100
msgid "Record changes to the repository."
msgstr "记录对仓库的更改。"

#. type: Labeled list
#: en/cmds-mainporcelain.txt:37
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-describe[1]"
msgstr "linkgit:git-describe[1]"

#. type: Plain text
#: en/cmds-mainporcelain.txt:39
#, priority:100
msgid "Give an object a human readable name based on an available ref."
msgstr "根据一个可用的引用，给一个对象易于理解的名字。"

#. type: Labeled list
#: en/cmds-mainporcelain.txt:40 en/git-difftool.txt:129
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-diff[1]"
msgstr "linkgit:git-diff[1]"

#. type: Plain text
#: en/cmds-mainporcelain.txt:42
#, priority:100
msgid "Show changes between commits, commit and working tree, etc."
msgstr "显示提交之间的变化，提交和工作区，等。"

#. type: Plain text
#: en/cmds-mainporcelain.txt:43 en/git-fetch-pack.txt:133
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-fetch[1]"
msgstr "linkgit:git-fetch[1]"

#. type: Plain text
#: en/cmds-mainporcelain.txt:45
#, priority:100
msgid "Download objects and refs from another repository."
msgstr "从另一个仓库下载对象和引用。"

#. type: Labeled list
#: en/cmds-mainporcelain.txt:46
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-format-patch[1]"
msgstr "linkgit:git-format-patch[1]"

#. type: Plain text
#: en/cmds-mainporcelain.txt:48
#, priority:100
msgid "Prepare patches for e-mail submission."
msgstr "为提交电子邮件准备补丁。"

#. type: Labeled list
#: en/cmds-mainporcelain.txt:49
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-gc[1]"
msgstr "linkgit:git-gc[1]"

#. type: Plain text
#: en/cmds-mainporcelain.txt:51
#, priority:100
msgid "Cleanup unnecessary files and optimize the local repository."
msgstr "清理不必要的文件，优化本地仓库。"

#. type: Labeled list
#: en/cmds-mainporcelain.txt:52
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-grep[1]"
msgstr "linkgit:git-grep[1]"

#. type: Plain text
#: en/cmds-mainporcelain.txt:54
#, priority:100
msgid "Print lines matching a pattern."
msgstr "打印符合模式的行。"

#. type: Labeled list
#: en/cmds-mainporcelain.txt:55
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-gui[1]"
msgstr "linkgit:git-gui[1]"

#. type: Plain text
#: en/cmds-mainporcelain.txt:57
#, priority:100
msgid "A portable graphical interface to Git."
msgstr "Git的可移植图形界面。"

#. type: Labeled list
#: en/cmds-mainporcelain.txt:58
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-init[1]"
msgstr "linkgit:git-init[1]"

#. type: Plain text
#: en/cmds-mainporcelain.txt:60
#, priority:100
msgid "Create an empty Git repository or reinitialize an existing one."
msgstr "创建一个空的 Git 仓库或重新初始化现有仓库。"

#. type: Plain text
#: en/cmds-mainporcelain.txt:61 en/git-range-diff.txt:294
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-log[1]"
msgstr "linkgit:git-log[1]"

#. type: Plain text
#: en/cmds-mainporcelain.txt:63
#, priority:100
msgid "Show commit logs."
msgstr "展示提交日志。"

#. type: Labeled list
#: en/cmds-mainporcelain.txt:64
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-maintenance[1]"
msgstr "linkgit:git-maintenance[1]"

#. type: Plain text
#: en/cmds-mainporcelain.txt:66
#, priority:100
msgid "Run tasks to optimize Git repository data."
msgstr "运行任务来优化Git存储库的数据。"

#. type: Plain text
#: en/cmds-mainporcelain.txt:67 en/git-fmt-merge-msg.txt:79
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-merge[1]"
msgstr "linkgit:git-merge[1]"

#. type: Plain text
#: en/cmds-mainporcelain.txt:69
#, priority:100
msgid "Join two or more development histories together."
msgstr "将两个或更多的开发历史连接在一起。"

#. type: Labeled list
#: en/cmds-mainporcelain.txt:70
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-mv[1]"
msgstr "linkgit:git-mv[1]"

#. type: Plain text
#: en/cmds-mainporcelain.txt:72
#, priority:100
msgid "Move or rename a file, a directory, or a symlink."
msgstr "移动或重命名一个文件、一个目录或一个符号链接。"

#. type: Labeled list
#: en/cmds-mainporcelain.txt:73
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-notes[1]"
msgstr "linkgit:git-notes[1]"

#. type: Plain text
#: en/cmds-mainporcelain.txt:75
#, priority:100
msgid "Add or inspect object notes."
msgstr "添加或检查对象注释。"

#. type: Plain text
#: en/cmds-mainporcelain.txt:76 en/git-fetch.txt:314
#, ignore-same, no-wrap, priority:220
msgid "linkgit:git-pull[1]"
msgstr "linkgit:git-pull[1]"

#. type: Plain text
#: en/cmds-mainporcelain.txt:78
#, priority:100
msgid "Fetch from and integrate with another repository or a local branch."
msgstr "从另一个仓库或本地分支获取并整合。"

#. type: Labeled list
#: en/cmds-mainporcelain.txt:79
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-push[1]"
msgstr "linkgit:git-push[1]"

#. type: Plain text
#: en/cmds-mainporcelain.txt:81
#, priority:100
msgid "Update remote refs along with associated objects."
msgstr "更新远程仓库引用和相关对象。"

#. type: Labeled list
#: en/cmds-mainporcelain.txt:82
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-range-diff[1]"
msgstr "linkgit:git-range-diff[1]"

#. type: Plain text
#: en/cmds-mainporcelain.txt:84
#, priority:100
msgid "Compare two commit ranges (e.g. two versions of a branch)."
msgstr "比较两个提交范围（例如一个分支的两个版本）。"

#. type: Plain text
#: en/cmds-mainporcelain.txt:85 en/git-svn.txt:1171
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-rebase[1]"
msgstr "linkgit:git-rebase[1]"

#. type: Plain text
#: en/cmds-mainporcelain.txt:87
#, priority:100
msgid "Reapply commits on top of another base tip."
msgstr "在另一个基础提示的基础上重新提交。"

#. type: Labeled list
#: en/cmds-mainporcelain.txt:88
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-reset[1]"
msgstr "linkgit:git-reset[1]"

#. type: Plain text
#: en/cmds-mainporcelain.txt:90
#, placeholders:'HEAD', priority:100
msgid "Reset current HEAD to the specified state."
msgstr "重置当前HEAD到指定状态。"

#. type: Labeled list
#: en/cmds-mainporcelain.txt:91
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-restore[1]"
msgstr "linkgit:git-restore[1]"

#. type: Plain text
#: en/cmds-mainporcelain.txt:93
#, priority:100
msgid "Restore working tree files."
msgstr "恢复工作区文件。"

#. type: Plain text
#: en/cmds-mainporcelain.txt:94 en/git-cherry-pick.txt:240
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-revert[1]"
msgstr "linkgit:git-revert[1]"

#. type: Plain text
#: en/cmds-mainporcelain.txt:96
#, priority:100
msgid "Revert some existing commits."
msgstr "还原一些现有的提交。"

#. type: Labeled list
#: en/cmds-mainporcelain.txt:97
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-rm[1]"
msgstr "linkgit:git-rm[1]"

#. type: Plain text
#: en/cmds-mainporcelain.txt:99
#, priority:100
msgid "Remove files from the working tree and from the index."
msgstr "从工作区和索引中删除文件。"

#. type: Labeled list
#: en/cmds-mainporcelain.txt:100
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-shortlog[1]"
msgstr "linkgit:git-shortlog[1]"

#. type: Plain text
#: en/cmds-mainporcelain.txt:102
#, priority:100
msgid "Summarize 'git log' output."
msgstr "汇总 'git log' 输出。"

#. type: Labeled list
#: en/cmds-mainporcelain.txt:103
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-show[1]"
msgstr "linkgit:git-show[1]"

#. type: Plain text
#: en/cmds-mainporcelain.txt:105
#, priority:100
msgid "Show various types of objects."
msgstr "展示各种类型的对象。"

#. type: Labeled list
#: en/cmds-mainporcelain.txt:106
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-sparse-checkout[1]"
msgstr "linkgit:git-sparse-checkout[1]"

#. type: Plain text
#: en/cmds-mainporcelain.txt:108
#, priority:100
msgid "Reduce your working tree to a subset of tracked files."
msgstr "将你的工作区减少到一个被跟踪的文件子集。"

#. type: Labeled list
#: en/cmds-mainporcelain.txt:109
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-stash[1]"
msgstr "linkgit:git-stash[1]"

#. type: Plain text
#: en/cmds-mainporcelain.txt:111
#, priority:100
msgid "Stash the changes in a dirty working directory away."
msgstr "把这些变化贮藏在一个脏工作目录中。"

#. type: Labeled list
#: en/cmds-mainporcelain.txt:112
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-status[1]"
msgstr "linkgit:git-status[1]"

#. type: Plain text
#: en/cmds-mainporcelain.txt:114
#, priority:100
msgid "Show the working tree status."
msgstr "显示工作区状态。"

#. type: Labeled list
#: en/cmds-mainporcelain.txt:115
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-submodule[1]"
msgstr "linkgit:git-submodule[1]"

#. type: Plain text
#: en/cmds-mainporcelain.txt:117
#, priority:100
msgid "Initialize, update or inspect submodules."
msgstr "初始化、更新或检查子模块。"

#. type: Labeled list
#: en/cmds-mainporcelain.txt:118
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-switch[1]"
msgstr "linkgit:git-switch[1]"

#. type: Plain text
#: en/cmds-mainporcelain.txt:120
#, priority:100
msgid "Switch branches."
msgstr "切换分支。"

#. type: Labeled list
#: en/cmds-mainporcelain.txt:121
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-tag[1]"
msgstr "linkgit:git-tag[1]"

#. type: Plain text
#: en/cmds-mainporcelain.txt:123
#, priority:100
msgid "Create, list, delete or verify a tag object signed with GPG."
msgstr "创建、列出、删除或校验以 GPG 签名的标签对象。"

#. type: Labeled list
#: en/cmds-mainporcelain.txt:124
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-worktree[1]"
msgstr "linkgit:git-worktree[1]"

#. type: Plain text
#: en/cmds-mainporcelain.txt:126
#, priority:100
msgid "Manage multiple working trees."
msgstr "管理多个工作区。"

#. type: Labeled list
#: en/cmds-mainporcelain.txt:127 en/git-gui.txt:104
#, ignore-same, no-wrap, priority:100
msgid "linkgit:gitk[1]"
msgstr "linkgit:gitk[1]"

#. type: Plain text
#: en/cmds-mainporcelain.txt:129
#, priority:100
msgid "The Git repository browser."
msgstr "Git 仓库浏览器。"

#. type: Labeled list
#: en/cmds-mainporcelain.txt:130
#, no-wrap, placeholders:'linkgit:scalar[1]', priority:100
msgid "linkgit:scalar[1]"
msgstr "linkgit:scalar[1]"

#. type: Plain text
#: en/cmds-mainporcelain.txt:132
#, priority:100
msgid "A tool for managing large Git repositories."
msgstr "管理大型 Git 仓库的工具。"

#. type: Labeled list
#: en/cmds-plumbinginterrogators.txt:1
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-cat-file[1]"
msgstr "linkgit:git-cat-file[1]"

#. type: Plain text
#: en/cmds-plumbinginterrogators.txt:3
#, priority:100
msgid "Provide content or type and size information for repository objects."
msgstr "为仓库对象提供内容或类型和大小信息。"

#. type: Labeled list
#: en/cmds-plumbinginterrogators.txt:4
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-cherry[1]"
msgstr "linkgit:git-cherry[1]"

#. type: Plain text
#: en/cmds-plumbinginterrogators.txt:6
#, priority:100
msgid "Find commits yet to be applied to upstream."
msgstr "查找尚未应用于上游仓库的提交。"

#. type: Labeled list
#: en/cmds-plumbinginterrogators.txt:7
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-diff-files[1]"
msgstr "linkgit:git-diff-files[1]"

#. type: Plain text
#: en/cmds-plumbinginterrogators.txt:9
#, priority:100
msgid "Compares files in the working tree and the index."
msgstr "比较工作区和索引中的文件。"

#. type: Labeled list
#: en/cmds-plumbinginterrogators.txt:10
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-diff-index[1]"
msgstr "linkgit:git-diff-index[1]"

#. type: Plain text
#: en/cmds-plumbinginterrogators.txt:12
#, priority:100
msgid "Compare a tree to the working tree or index."
msgstr "将目录树与工作目录或索引进行比较。"

#. type: Labeled list
#: en/cmds-plumbinginterrogators.txt:13
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-diff-tree[1]"
msgstr "linkgit:git-diff-tree[1]"

#. type: Plain text
#: en/cmds-plumbinginterrogators.txt:15
#, priority:100
msgid "Compares the content and mode of blobs found via two tree objects."
msgstr "比较两个树对象中发现的 blob 的内容和模式。"

#. type: Labeled list
#: en/cmds-plumbinginterrogators.txt:16
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-for-each-ref[1]"
msgstr "linkgit:git-for-each-ref[1]"

#. type: Plain text
#: en/cmds-plumbinginterrogators.txt:18
#, priority:100
msgid "Output information on each ref."
msgstr "输出每个引用的信息。"

#. type: Labeled list
#: en/cmds-plumbinginterrogators.txt:19
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-for-each-repo[1]"
msgstr "linkgit:git-for-each-repo[1]"

#. type: Plain text
#: en/cmds-plumbinginterrogators.txt:21
#, priority:100
msgid "Run a Git command on a list of repositories."
msgstr "在一个仓库列表上运行一个 Git 命令。"

#. type: Labeled list
#: en/cmds-plumbinginterrogators.txt:22
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-get-tar-commit-id[1]"
msgstr "linkgit:git-get-tar-commit-id[1]"

#. type: Plain text
#: en/cmds-plumbinginterrogators.txt:24
#, placeholders:'git-archive', priority:100
msgid "Extract commit ID from an archive created using git-archive."
msgstr "从使用 git-archive 创建的存档中提取提交 ID。"

#. type: Labeled list
#: en/cmds-plumbinginterrogators.txt:25
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-ls-files[1]"
msgstr "linkgit:git-ls-files[1]"

#. type: Plain text
#: en/cmds-plumbinginterrogators.txt:27
#, priority:100
msgid "Show information about files in the index and the working tree."
msgstr "显示索引和工作区中的文件信息。"

#. type: Labeled list
#: en/cmds-plumbinginterrogators.txt:28
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-ls-remote[1]"
msgstr "linkgit:git-ls-remote[1]"

#. type: Plain text
#: en/cmds-plumbinginterrogators.txt:30
#, priority:100
msgid "List references in a remote repository."
msgstr "列出远程仓库中的引用。"

#. type: Labeled list
#: en/cmds-plumbinginterrogators.txt:31
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-ls-tree[1]"
msgstr "linkgit:git-ls-tree[1]"

#. type: Plain text
#: en/cmds-plumbinginterrogators.txt:33
#, priority:100
msgid "List the contents of a tree object."
msgstr "列出一个树对象的内容。"

#. type: Labeled list
#: en/cmds-plumbinginterrogators.txt:34
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-merge-base[1]"
msgstr "linkgit:git-merge-base[1]"

#. type: Plain text
#: en/cmds-plumbinginterrogators.txt:36
#, priority:100
msgid "Find as good common ancestors as possible for a merge."
msgstr "尽可能找到好的共同祖先进行合并。"

#. type: Labeled list
#: en/cmds-plumbinginterrogators.txt:37
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-name-rev[1]"
msgstr "linkgit:git-name-rev[1]"

# 查找给定版本的符号名称
#. type: Plain text
#: en/cmds-plumbinginterrogators.txt:39
#, priority:100
msgid "Find symbolic names for given revs."
msgstr "为给定的 revs 寻找符号名称。"

#. type: Labeled list
#: en/cmds-plumbinginterrogators.txt:40
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-pack-redundant[1]"
msgstr "linkgit:git-pack-redundant[1]"

#. type: Plain text
#: en/cmds-plumbinginterrogators.txt:42
#, priority:100
msgid "Find redundant pack files."
msgstr "寻找多余的包文件。"

#. type: Labeled list
#: en/cmds-plumbinginterrogators.txt:43
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-rev-list[1]"
msgstr "linkgit:git-rev-list[1]"

#. type: Plain text
#: en/cmds-plumbinginterrogators.txt:45
#, priority:100
msgid "Lists commit objects in reverse chronological order."
msgstr "按时间顺序倒序列出提交对象。"

#. type: Labeled list
#: en/cmds-plumbinginterrogators.txt:46
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-rev-parse[1]"
msgstr "linkgit:git-rev-parse[1]"

#. type: Plain text
#: en/cmds-plumbinginterrogators.txt:48
#, priority:100
msgid "Pick out and massage parameters."
msgstr "挑选并调整参数。"

#. type: Labeled list
#: en/cmds-plumbinginterrogators.txt:49
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-show-index[1]"
msgstr "linkgit:git-show-index[1]"

#. type: Plain text
#: en/cmds-plumbinginterrogators.txt:51
#, priority:100
msgid "Show packed archive index."
msgstr "显示打包的档案索引。"

#. type: Plain text
#: en/cmds-plumbinginterrogators.txt:52 en/git-for-each-ref.txt:499
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-show-ref[1]"
msgstr "linkgit:git-show-ref[1]"

#. type: Plain text
#: en/cmds-plumbinginterrogators.txt:54
#, priority:100
msgid "List references in a local repository."
msgstr "列出本地仓库中的引用。"

#. type: Labeled list
#: en/cmds-plumbinginterrogators.txt:55
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-unpack-file[1]"
msgstr "linkgit:git-unpack-file[1]"

#. type: Plain text
#: en/cmds-plumbinginterrogators.txt:57
#, priority:100
msgid "Creates a temporary file with a blob's contents."
msgstr "创建包含 blob 内容的临时文件。"

#. type: Labeled list
#: en/cmds-plumbinginterrogators.txt:58
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-var[1]"
msgstr "linkgit:git-var[1]"

#. type: Plain text
#: en/cmds-plumbinginterrogators.txt:60
#, priority:100
msgid "Show a Git logical variable."
msgstr "显示 Git 逻辑变量。"

#. type: Labeled list
#: en/cmds-plumbinginterrogators.txt:61
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-verify-pack[1]"
msgstr "linkgit:git-verify-pack[1]"

#. type: Plain text
#: en/cmds-plumbinginterrogators.txt:63
#, priority:100
msgid "Validate packed Git archive files."
msgstr "验证打包的 Git 存档文件。"

#. type: Labeled list
#: en/cmds-plumbingmanipulators.txt:1
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-apply[1]"
msgstr "linkgit:git-apply[1]"

#. type: Plain text
#: en/cmds-plumbingmanipulators.txt:3
#, priority:100
msgid "Apply a patch to files and/or to the index."
msgstr "对文件和/或索引打补丁。"

#. type: Labeled list
#: en/cmds-plumbingmanipulators.txt:4
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-checkout-index[1]"
msgstr "linkgit:git-checkout-index[1]"

#. type: Plain text
#: en/cmds-plumbingmanipulators.txt:6
#, priority:100
msgid "Copy files from the index to the working tree."
msgstr "从索引中复制文件到工作目录。"

#. type: Labeled list
#: en/cmds-plumbingmanipulators.txt:7
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-commit-graph[1]"
msgstr "linkgit:git-commit-graph[1]"

#. type: Plain text
#: en/cmds-plumbingmanipulators.txt:9
#, priority:100
msgid "Write and verify Git commit-graph files."
msgstr "编写并验证 Git commit-graph 文件。"

#. type: Labeled list
#: en/cmds-plumbingmanipulators.txt:10
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-commit-tree[1]"
msgstr "linkgit:git-commit-tree[1]"

#. type: Plain text
#: en/cmds-plumbingmanipulators.txt:12
#, priority:100
msgid "Create a new commit object."
msgstr "创建一个新的提交对象。"

#. type: Labeled list
#: en/cmds-plumbingmanipulators.txt:13
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-hash-object[1]"
msgstr "linkgit:git-hash-object[1]"

#. type: Plain text
#: en/cmds-plumbingmanipulators.txt:15
#, priority:100
msgid "Compute object ID and optionally creates a blob from a file."
msgstr "计算对象 ID，根据文件创建 blob（可选）。"

#. type: Labeled list
#: en/cmds-plumbingmanipulators.txt:16
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-index-pack[1]"
msgstr "linkgit:git-index-pack[1]"

#. type: Plain text
#: en/cmds-plumbingmanipulators.txt:18
#, priority:100
msgid "Build pack index file for an existing packed archive."
msgstr "为现有的打包档案建立打包索引文件。"

#. type: Labeled list
#: en/cmds-plumbingmanipulators.txt:19
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-merge-file[1]"
msgstr "linkgit:git-merge-file[1]"

#. type: Plain text
#: en/cmds-plumbingmanipulators.txt:21
#, priority:100
msgid "Run a three-way file merge."
msgstr "运行一个三向文件合并。"

#. type: Labeled list
#: en/cmds-plumbingmanipulators.txt:22
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-merge-index[1]"
msgstr "linkgit:git-merge-index[1]"

#. type: Plain text
#: en/cmds-plumbingmanipulators.txt:24
#, priority:100
msgid "Run a merge for files needing merging."
msgstr "为需要合并的文件运行合并程序。"

#. type: Labeled list
#: en/cmds-plumbingmanipulators.txt:25
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-mktag[1]"
msgstr "linkgit:git-mktag[1]"

#. type: Plain text
#: en/cmds-plumbingmanipulators.txt:27
#, priority:100
msgid "Creates a tag object with extra validation."
msgstr "创建一个具有额外验证功能的标签对象。"

#. type: Labeled list
#: en/cmds-plumbingmanipulators.txt:28
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-mktree[1]"
msgstr "linkgit:git-mktree[1]"

#. type: Plain text
#: en/cmds-plumbingmanipulators.txt:30
#, priority:100
msgid "Build a tree-object from ls-tree formatted text."
msgstr "根据 ls-tree 格式的文本构建目录树对象（tree-object）。"

#. type: Labeled list
#: en/cmds-plumbingmanipulators.txt:31
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-multi-pack-index[1]"
msgstr "linkgit:git-multi-pack-index[1]"

#. type: Plain text
#: en/cmds-plumbingmanipulators.txt:33
#, priority:100
msgid "Write and verify multi-pack-indexes."
msgstr "编写和验证多包索引。"

#. type: Labeled list
#: en/cmds-plumbingmanipulators.txt:34
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-pack-objects[1]"
msgstr "linkgit:git-pack-objects[1]"

#. type: Plain text
#: en/cmds-plumbingmanipulators.txt:36
#, priority:100
msgid "Create a packed archive of objects."
msgstr "创建一个打包的对象档案。"

#. type: Labeled list
#: en/cmds-plumbingmanipulators.txt:37
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-prune-packed[1]"
msgstr "linkgit:git-prune-packed[1]"

#. type: Plain text
#: en/cmds-plumbingmanipulators.txt:39
#, priority:100
msgid "Remove extra objects that are already in pack files."
msgstr "删除已经存在于包文件中的额外对象。"

#. type: Labeled list
#: en/cmds-plumbingmanipulators.txt:40
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-read-tree[1]"
msgstr "linkgit:git-read-tree[1]"

#. type: Plain text
#: en/cmds-plumbingmanipulators.txt:42
#, priority:100
msgid "Reads tree information into the index."
msgstr "将目录树的信息读入索引。"

#. type: Labeled list
#: en/cmds-plumbingmanipulators.txt:43
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-symbolic-ref[1]"
msgstr "linkgit:git-symbolic-ref[1]"

#. type: Plain text
#: en/cmds-plumbingmanipulators.txt:45
#, priority:100
msgid "Read, modify and delete symbolic refs."
msgstr "读取、修改和删除符号引用。"

#. type: Labeled list
#: en/cmds-plumbingmanipulators.txt:46
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-unpack-objects[1]"
msgstr "linkgit:git-unpack-objects[1]"

#. type: Plain text
#: en/cmds-plumbingmanipulators.txt:48
#, priority:100
msgid "Unpack objects from a packed archive."
msgstr "从打包的档案中解压对象。"

#. type: Labeled list
#: en/cmds-plumbingmanipulators.txt:49
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-update-index[1]"
msgstr "linkgit:git-update-index[1]"

#. type: Plain text
#: en/cmds-plumbingmanipulators.txt:51
#, priority:100
msgid "Register file contents in the working tree to the index."
msgstr "将工作区中的文件内容登记到索引中。"

#. type: Labeled list
#: en/cmds-plumbingmanipulators.txt:52
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-update-ref[1]"
msgstr "linkgit:git-update-ref[1]"

#. type: Plain text
#: en/cmds-plumbingmanipulators.txt:54
#, priority:100
msgid "Update the object name stored in a ref safely."
msgstr "安全地更新存储在引用中的对象名称。"

#. type: Labeled list
#: en/cmds-plumbingmanipulators.txt:55
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-write-tree[1]"
msgstr "linkgit:git-write-tree[1]"

#. type: Plain text
#: en/cmds-plumbingmanipulators.txt:57
#, priority:100
msgid "Create a tree object from the current index."
msgstr "从当前索引创建一个树对象。"

#. type: Labeled list
#: en/cmds-purehelpers.txt:1
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-check-attr[1]"
msgstr "linkgit:git-check-attr[1]"

#. type: Plain text
#: en/cmds-purehelpers.txt:3
#, priority:100
msgid "Display gitattributes information."
msgstr "显示属性信息。"

#. type: Labeled list
#: en/cmds-purehelpers.txt:4
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-check-ignore[1]"
msgstr "linkgit:git-check-ignore[1]"

#. type: Plain text
#: en/cmds-purehelpers.txt:6
#, priority:100
msgid "Debug gitignore / exclude files."
msgstr "调试 gitignore / 排除文件。"

#. type: Labeled list
#: en/cmds-purehelpers.txt:7
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-check-mailmap[1]"
msgstr "linkgit:git-check-mailmap[1]"

#. type: Plain text
#: en/cmds-purehelpers.txt:9
#, priority:100
msgid "Show canonical names and email addresses of contacts."
msgstr "显示联系人的规范名称和电子邮件地址。"

#. type: Labeled list
#: en/cmds-purehelpers.txt:10
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-check-ref-format[1]"
msgstr "linkgit:git-check-ref-format[1]"

#. type: Plain text
#: en/cmds-purehelpers.txt:12
#, priority:100
msgid "Ensures that a reference name is well formed."
msgstr "确保一个引用名称是否规范。"

#. type: Labeled list
#: en/cmds-purehelpers.txt:13
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-column[1]"
msgstr "linkgit:git-column[1]"

#. type: Plain text
#: en/cmds-purehelpers.txt:15
#, priority:100
msgid "Display data in columns."
msgstr "以列显示数据。"

#. type: Labeled list
#: en/cmds-purehelpers.txt:16
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-credential[1]"
msgstr "linkgit:git-credential[1]"

#. type: Plain text
#: en/cmds-purehelpers.txt:18
#, priority:100
msgid "Retrieve and store user credentials."
msgstr "检索和存储用户凭证。"

#. type: Labeled list
#: en/cmds-purehelpers.txt:19
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-credential-cache[1]"
msgstr "linkgit:git-credential-cache[1]"

#. type: Plain text
#: en/cmds-purehelpers.txt:21
#, priority:100
msgid "Helper to temporarily store passwords in memory."
msgstr "用于在内存中临时存储密码的助手。"

#. type: Labeled list
#: en/cmds-purehelpers.txt:22
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-credential-store[1]"
msgstr "linkgit:git-credential-store[1]"

#. type: Plain text
#: en/cmds-purehelpers.txt:24
#, priority:100
msgid "Helper to store credentials on disk."
msgstr "帮助在磁盘上存储凭证。"

#. type: Labeled list
#: en/cmds-purehelpers.txt:25
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-fmt-merge-msg[1]"
msgstr "linkgit:git-fmt-merge-msg[1]"

#. type: Plain text
#: en/cmds-purehelpers.txt:27
#, priority:100
msgid "Produce a merge commit message."
msgstr "产生一个合并提交信息。"

#. type: Labeled list
#: en/cmds-purehelpers.txt:28
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-hook[1]"
msgstr "linkgit:git-hook[1]"

#. type: Plain text
#: en/cmds-purehelpers.txt:30
#, priority:100
msgid "Run git hooks."
msgstr "运行 git hooks。"

#. type: Labeled list
#: en/cmds-purehelpers.txt:31
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-interpret-trailers[1]"
msgstr "linkgit:git-interpret-trailers[1]"

#. type: Plain text
#: en/cmds-purehelpers.txt:33
#, priority:100
msgid "Add or parse structured information in commit messages."
msgstr "在提交信息中添加或解析结构化信息。"

#. type: Labeled list
#: en/cmds-purehelpers.txt:34
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-mailinfo[1]"
msgstr "linkgit:git-mailinfo[1]"

#. type: Plain text
#: en/cmds-purehelpers.txt:36
#, priority:100
msgid "Extracts patch and authorship from a single e-mail message."
msgstr "从单一的电子邮件中提取补丁和作者。"

#. type: Labeled list
#: en/cmds-purehelpers.txt:37
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-mailsplit[1]"
msgstr "linkgit:git-mailsplit[1]"

#. type: Plain text
#: en/cmds-purehelpers.txt:39
#, priority:100
msgid "Simple UNIX mbox splitter program."
msgstr "简单的 UNIX mbox 拆分器程序。"

#. type: Labeled list
#: en/cmds-purehelpers.txt:40
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-merge-one-file[1]"
msgstr "linkgit:git-merge-one-file[1]"

#. type: Plain text
#: en/cmds-purehelpers.txt:42
#, placeholders:'git-merge-index', priority:100
msgid "The standard helper program to use with git-merge-index."
msgstr "与 git-merge-index 一起使用的标准帮助程序。"

#. type: Plain text
#: en/cmds-purehelpers.txt:43 en/git-cherry.txt:142
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-patch-id[1]"
msgstr "linkgit:git-patch-id[1]"

#. type: Plain text
#: en/cmds-purehelpers.txt:45
#, priority:100
msgid "Compute unique ID for a patch."
msgstr "为补丁计算唯一的主键 ID。"

#. type: Labeled list
#: en/cmds-purehelpers.txt:46
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-sh-i18n[1]"
msgstr "linkgit:git-sh-i18n[1]"

#. type: Plain text
#: en/cmds-purehelpers.txt:48
#, priority:100
msgid "Git's i18n setup code for shell scripts."
msgstr "Git 的 i18n (国际化)安装代码- shell 脚本."

#. type: Labeled list
#: en/cmds-purehelpers.txt:49
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-sh-setup[1]"
msgstr "linkgit:git-sh-setup[1]"

#. type: Plain text
#: en/cmds-purehelpers.txt:51
#, priority:100
msgid "Common Git shell script setup code."
msgstr "通用 Git shell 脚本安装代码。"

#. type: Labeled list
#: en/cmds-purehelpers.txt:52
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-stripspace[1]"
msgstr "linkgit:git-stripspace[1]"

#. type: Plain text
#: en/cmds-purehelpers.txt:54
#, priority:100
msgid "Remove unnecessary whitespace."
msgstr "删除不必要的空白。"

#. type: Labeled list
#: en/cmds-synchelpers.txt:1
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-http-fetch[1]"
msgstr "linkgit:git-http-fetch[1]"

#. type: Plain text
#: en/cmds-synchelpers.txt:3
#, priority:100
msgid "Download from a remote Git repository via HTTP."
msgstr "通过HTTP从远程Git存储库下载。"

#. type: Labeled list
#: en/cmds-synchelpers.txt:4
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-http-push[1]"
msgstr "linkgit:git-http-push[1]"

#. type: Plain text
#: en/cmds-synchelpers.txt:6
#, priority:100
msgid "Push objects over HTTP/DAV to another repository."
msgstr "通过HTTP/DAV将对象推送到另一个存储库。"

#. type: Labeled list
#: en/cmds-synchelpers.txt:7
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-receive-pack[1]"
msgstr "linkgit:git-receive-pack[1]"

#. type: Plain text
#: en/cmds-synchelpers.txt:9
#, priority:100
msgid "Receive what is pushed into the repository."
msgstr "接收推送到仓库的内容。"

#. type: Labeled list
#: en/cmds-synchelpers.txt:10
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-shell[1]"
msgstr "linkgit:git-shell[1]"

#. type: Plain text
#: en/cmds-synchelpers.txt:12
#, priority:100
msgid "Restricted login shell for Git-only SSH access."
msgstr "Git-only SSH 通道使用的限制登录脚本。"

#. type: Labeled list
#: en/cmds-synchelpers.txt:13
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-upload-archive[1]"
msgstr "linkgit:git-upload-archive[1]"

#. type: Plain text
#: en/cmds-synchelpers.txt:15
#, placeholders:'git-archive', priority:100
msgid "Send archive back to git-archive."
msgstr "将归档文件发送回git-archive。"

#. type: Labeled list
#: en/cmds-synchelpers.txt:16
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-upload-pack[1]"
msgstr "linkgit:git-upload-pack[1]"

#. type: Plain text
#: en/cmds-synchelpers.txt:18
#, placeholders:'git-fetch-pack', priority:100
msgid "Send objects packed back to git-fetch-pack."
msgstr "将打包的对象发送回git-fetch-pack。"

#. type: Labeled list
#: en/cmds-synchingrepositories.txt:1
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-daemon[1]"
msgstr "linkgit:git-daemon[1]"

#. type: Plain text
#: en/cmds-synchingrepositories.txt:3
#, priority:100
msgid "A really simple server for Git repositories."
msgstr "一个非常简单的Git存储库服务器。"

#. type: Labeled list
#: en/cmds-synchingrepositories.txt:4
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-fetch-pack[1]"
msgstr "linkgit:git-fetch-pack[1]"

#. type: Plain text
#: en/cmds-synchingrepositories.txt:6
#, priority:100
msgid "Receive missing objects from another repository."
msgstr "从另一个仓库接收丢失的对象。"

#. type: Labeled list
#: en/cmds-synchingrepositories.txt:7
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-http-backend[1]"
msgstr "linkgit:git-http-backend[1]"

#. type: Plain text
#: en/cmds-synchingrepositories.txt:9
#, priority:100
msgid "Server side implementation of Git over HTTP."
msgstr "通过 HTTP 实现 Git 的服务器端功能。"

#. type: Labeled list
#: en/cmds-synchingrepositories.txt:10
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-send-pack[1]"
msgstr "linkgit:git-send-pack[1]"

#. type: Plain text
#: en/cmds-synchingrepositories.txt:12
#, priority:100
msgid "Push objects over Git protocol to another repository."
msgstr "通过Git协议将对象推送到另一个存储库。"

#. type: Labeled list
#: en/cmds-synchingrepositories.txt:13
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-update-server-info[1]"
msgstr "linkgit:git-update-server-info[1]"

#. type: Plain text
#: en/cmds-synchingrepositories.txt:15
#, priority:100
msgid "Update auxiliary info file to help dumb servers."
msgstr "更新辅助信息文件以帮助哑服务器。"

#. type: Plain text
#: en/cmds-userinterfaces.txt:1 en/git-archive.txt:238
#, ignore-same, no-wrap, priority:100
msgid "linkgit:gitattributes[5]"
msgstr "linkgit:gitattributes[5]"

#. type: Plain text
#: en/cmds-userinterfaces.txt:3
#, priority:100
msgid "Defining attributes per path."
msgstr "按路径定义属性。"

#. type: Labeled list
#: en/cmds-userinterfaces.txt:4
#, ignore-same, no-wrap, priority:100
msgid "linkgit:gitcli[7]"
msgstr "linkgit:gitcli[7]"

#. type: Plain text
#: en/cmds-userinterfaces.txt:6
#, priority:100
msgid "Git command-line interface and conventions."
msgstr "Git 命令行界面和约定。"

#. type: Labeled list
#: en/cmds-userinterfaces.txt:7
#, ignore-same, no-wrap, priority:100
msgid "linkgit:githooks[5]"
msgstr "linkgit:githooks[5]"

#. type: Plain text
#: en/cmds-userinterfaces.txt:9
#, priority:100
msgid "Hooks used by Git."
msgstr "Git 使用的钩子。"

#. type: Plain text
#: en/cmds-userinterfaces.txt:10 en/git-clean.txt:146 en/git-status.txt:524
#, ignore-same, no-wrap, priority:280
msgid "linkgit:gitignore[5]"
msgstr "linkgit:gitignore[5]"

#. type: Plain text
#: en/cmds-userinterfaces.txt:12
#, priority:100
msgid "Specifies intentionally untracked files to ignore."
msgstr "指定有意忽略的未跟踪文件。"

#. type: Labeled list
#: en/cmds-userinterfaces.txt:13
#, ignore-same, no-wrap, priority:100
msgid "linkgit:gitmailmap[5]"
msgstr "linkgit:gitmailmap[5]"

#. type: Plain text
#: en/cmds-userinterfaces.txt:15
#, priority:100
msgid "Map author/committer names and/or E-Mail addresses."
msgstr "地图作者/修订者姓名和/或电子邮件地址。"

#. type: Labeled list
#: en/cmds-userinterfaces.txt:16
#, ignore-same, no-wrap, priority:100
msgid "linkgit:gitmodules[5]"
msgstr "linkgit:gitmodules[5]"

#. type: Plain text
#: en/cmds-userinterfaces.txt:18
#, priority:100
msgid "Defining submodule properties."
msgstr "定义子模块属性。"

#. type: Labeled list
#: en/cmds-userinterfaces.txt:19
#, ignore-same, no-wrap, priority:100
msgid "linkgit:gitrepository-layout[5]"
msgstr "linkgit:gitrepository-layout[5]"

#. type: Plain text
#: en/cmds-userinterfaces.txt:21
#, priority:100
msgid "Git Repository Layout."
msgstr "Git 仓库布局。"

#. type: Labeled list
#: en/cmds-userinterfaces.txt:22
#, ignore-same, no-wrap, priority:100
msgid "linkgit:gitrevisions[7]"
msgstr "linkgit:gitrevisions[7]"

#. type: Plain text
#: en/cmds-userinterfaces.txt:24
#, priority:100
msgid "Specifying revisions and ranges for Git."
msgstr "为 Git 指定修订版本和范围。"

#. type: Title -
#: en/config.txt:2 en/git-worktree.txt:309
#, no-wrap, priority:240
msgid "CONFIGURATION FILE"
msgstr "配置文件"

#. type: Plain text
#: en/config.txt:12
#, placeholders:'config.worktree':'linkgit:git-worktree[1]':'$HOME', priority:100
msgid "The Git configuration file contains a number of variables that affect the Git commands' behavior. The files `.git/config` and optionally `config.worktree` (see the \"CONFIGURATION FILE\" section of linkgit:git-worktree[1]) in each repository are used to store the configuration for that repository, and `$HOME/.gitconfig` is used to store a per-user configuration as fallback values for the `.git/config` file. The file `/etc/gitconfig` can be used to store a system-wide default configuration."
msgstr "Git 配置文件包含了一些影响 Git 命令行为的变量。每个仓库中的文件 `.git/config` 和可选的 `config.worktree`（见linkgit:git-worktree[1]的 “配置文件” 部分）用于存储该仓库的配置，`$HOME/.gitconfig` 用于存储每个用户的配置，作为 `.git/config` 文件的后退值。文件 `/etc/gitconfig` 可以用来存储全系统的默认配置。"

#. type: Plain text
#: en/config.txt:21
#, priority:100
msgid "The configuration variables are used by both the Git plumbing and the porcelain commands. The variables are divided into sections, wherein the fully qualified variable name of the variable itself is the last dot-separated segment and the section name is everything before the last dot. The variable names are case-insensitive, allow only alphanumeric characters and `-`, and must start with an alphabetic character. Some variables may appear multiple times; we say then that the variable is multivalued."
msgstr "配置变量同时被 Git 底层和上层命令使用。变量被分为几个部分，其中变量本身的完全合格的变量名是最后一个点分隔的部分，而部分名称是最后一个点之前的所有内容。变量名称不区分大小写，只允许使用字母数字字符和 `-`，并且必须以字母字符开头。 有些变量可能会出现多次；那么我们就说这个变量是多值的。"

#. type: Title ~
#: en/config.txt:23
#, no-wrap, priority:100
msgid "Syntax"
msgstr "语法"

#. type: Plain text
#: en/config.txt:28
#, priority:100
msgid "The syntax is fairly flexible and permissive; whitespaces are mostly ignored. The '#' and ';' characters begin comments to the end of line, blank lines are ignored."
msgstr "语法是相当灵活和宽松的；空白处大多被忽略。 '#' 和 ';' 字符开始注释到行末，空行被忽略。"

#. type: Plain text
#: en/config.txt:35
#, priority:100
msgid "The file consists of sections and variables. A section begins with the name of the section in square brackets and continues until the next section begins. Section names are case-insensitive. Only alphanumeric characters, `-` and `.` are allowed in section names. Each variable must belong to some section, which means that there must be a section header before the first setting of a variable."
msgstr "该文件由章节和变量组成。 一个章节以方括号中的章节名称开始，一直到下一个章节开始。 节的名称是不区分大小写的。 在章节名称中只允许使用字母数字字符、`-` 和 `.`。 每个变量都必须属于某个部分，这意味着在第一次设置变量之前必须有一个部分标题。"

#. type: Plain text
#: en/config.txt:39
#, priority:100
msgid "Sections can be further divided into subsections. To begin a subsection put its name in double quotes, separated by space from the section name, in the section header, like in the example below:"
msgstr "节可以进一步划分为子节。 要开始一个分节，请将其名称放在双引号中，与节的名称用空格隔开，放在节的标题中，如下面的例子："

#. type: delimited block -
#: en/config.txt:42
#, no-wrap, priority:100
msgid "\t[section \"subsection\"]\n"
msgstr "\t[section \"小节\"]\n"

#. type: Plain text
#: en/config.txt:53
#, priority:100
msgid "Subsection names are case sensitive and can contain any characters except newline and the null byte. Doublequote `\"` and backslash can be included by escaping them as `\\\"` and `\\\\`, respectively. Backslashes preceding other characters are dropped when reading; for example, `\\t` is read as `t` and `\\0` is read as `0`. Section headers cannot span multiple lines. Variables may belong directly to a section or to a given subsection. You can have `[section]` if you have `[section \"subsection\"]`, but you don't need to."
msgstr "分节名称是区分大小写的，可以包含任何字符，除了换行和空字节。双引号 `\"` 和反斜杠可以分别通过转义为 `\\\"` 和 `\\\\` 来包含。读取时，其他字符前面的反斜杠将被删除；例如，`\\t` 被读作 `t`，`\\0` 被读作 `0`。章节标题不能跨越多行。 变量可以直接属于某一节或某一小节。如果你有 `[section \"小节\"]`，你可以有 `[section]`，但不需要这样。"

#. type: Plain text
#: en/config.txt:58
#, priority:100
msgid "There is also a deprecated `[section.subsection]` syntax. With this syntax, the subsection name is converted to lower-case and is also compared case sensitively. These subsection names follow the same restrictions as section names."
msgstr "还有一种废弃的 `[section.subsection]` 语法。在这种语法中，分节名称被转换为小写字母，并且也会敏感地比较大小写。这些分节名称遵循与章节名称相同的限制。"

#. type: Plain text
#: en/config.txt:65
#, priority:100
msgid "All the other lines (and the remainder of the line after the section header) are recognized as setting variables, in the form 'name = value' (or just 'name', which is a short-hand to say that the variable is the boolean \"true\"). The variable names are case-insensitive, allow only alphanumeric characters and `-`, and must start with an alphabetic character."
msgstr "所有其他行（以及部分标题之后的剩余行）都被认为是设置变量，形式为 'name = value'（或者只是 'name'，这是一个简写，表示变量是布尔值 \"true\"）。 变量名称不区分大小写，只允许使用字母数字字符和 `-`，并且必须以字母字符开头。"

#. type: Plain text
#: en/config.txt:73
#, priority:100
msgid "A line that defines a value can be continued to the next line by ending it with a `\\`; the backslash and the end-of-line are stripped. Leading whitespaces after 'name =', the remainder of the line after the first comment character '#' or ';', and trailing whitespaces of the line are discarded unless they are enclosed in double quotes. Internal whitespaces within the value are retained verbatim."
msgstr "定义一个值的行可以通过以 `\\` 结束来延续到下一行；反斜杠和行尾被剥离。 在 'name =' 之后的前导空白，在第一个注释字符 '#' 或 ';' 之后的剩余行，以及该行的尾部空白都会被丢弃，除非它们被包含在双引号中。 值中的内部空白将被逐字保留。"

#. type: Plain text
#: en/config.txt:76
#, priority:100
msgid "Inside double quotes, double quote `\"` and backslash `\\` characters must be escaped: use `\\\"` for `\"` and `\\\\` for `\\`."
msgstr "在双引号内，双引号 `\"` 和反斜杠 `\\` 字符必须被转义：用 `\\\"` 表示 `\"`，用 `\\\\` 表示 `\\`。"

#. type: Plain text
#: en/config.txt:81
#, priority:100
msgid "The following escape sequences (beside `\\\"` and `\\\\`) are recognized: `\\n` for newline character (NL), `\\t` for horizontal tabulation (HT, TAB) and `\\b` for backspace (BS). Other char escape sequences (including octal escape sequences) are invalid."
msgstr "以下转义序列（除了 `\\\"` 和 `\\\\`）可以被识别：`\\n` 表示换行符（NL），`\\t` 表示水平制表（HT，TAB），`\\b` 表示退格（BS）。 其他字符转义序列（包括八进制转义序列）是无效的。"

#. type: Title ~
#: en/config.txt:84
#, no-wrap, priority:100
msgid "Includes"
msgstr "包括"

#. type: Plain text
#: en/config.txt:91
#, priority:100
msgid "The `include` and `includeIf` sections allow you to include config directives from another source. These sections behave identically to each other with the exception that `includeIf` sections may be ignored if their condition does not evaluate to true; see \"Conditional includes\" below."
msgstr "`include` 和 `includeIf` 部分允许你从另一个来源包含配置指令。这些部分的行为与其他部分相同，但如果 `includeIf` 部分的条件没有评估为真，则可以忽略；见下面的 “有条件的包含”。"

#. type: Plain text
#: en/config.txt:96
#, placeholders:'include.path', priority:100
msgid "You can include a config file from another by setting the special `include.path` (or `includeIf.*.path`) variable to the name of the file to be included. The variable takes a pathname as its value, and is subject to tilde expansion. These variables can be given multiple times."
msgstr "你可以通过设置特殊的 `include.path`（或 `includeIf.*.path` ）变量来包含另一个配置文件，即要包含的文件名。该变量将路径名作为其值，并接受 tilde 扩展。这些变量可以被多次赋予。"

#. type: Plain text
#: en/config.txt:102
#, priority:100
msgid "The contents of the included file are inserted immediately, as if they had been found at the location of the include directive. If the value of the variable is a relative path, the path is considered to be relative to the configuration file in which the include directive was found. See below for examples."
msgstr "被包含的文件的内容会被立即插入，就像它们是在 include 指令的位置被发现的一样。如果该变量的值是一个相对路径，则该路径被认为是相对于发现 include 指令的配置文件。 请看下面的例子。"

#. type: Title ~
#: en/config.txt:104
#, no-wrap, priority:100
msgid "Conditional includes"
msgstr "有条件的包括"

#. type: Plain text
#: en/config.txt:109
#, priority:100
msgid "You can conditionally include a config file from another by setting an `includeIf.<condition>.path` variable to the name of the file to be included."
msgstr "你可以通过设置 `includeIf.<条件>.path` 变量来有条件地包含另一个配置文件，即要包含的文件名称。"

#. type: Plain text
#: en/config.txt:113
#, priority:100
msgid "The condition starts with a keyword followed by a colon and some data whose format and meaning depends on the keyword. Supported keywords are:"
msgstr "条件以一个关键词开始，后面是冒号和一些数据，其格式和含义取决于关键词。支持的关键词有："

#. type: Labeled list
#: en/config.txt:114
#, ignore-same, no-wrap, priority:100
msgid "`gitdir`"
msgstr "`gitdir`"

#. type: Plain text
#: en/config.txt:119
#, priority:100
msgid "The data that follows the keyword `gitdir:` is used as a glob pattern. If the location of the .git directory matches the pattern, the include condition is met."
msgstr "关键字 `gitdir:` 后面的数据被用作匹配模式。如果. git 目录的位置与该模式相匹配，则满足包含条件。"

#. type: Plain text
#: en/config.txt:125
#, placeholders:'$GIT_DIR', priority:100
msgid "The .git location may be auto-discovered, or come from `$GIT_DIR` environment variable. If the repository is auto-discovered via a .git file (e.g. from submodules, or a linked worktree), the .git location would be the final location where the .git directory is, not where the .git file is."
msgstr ".git 位置可以是自动发现的，也可以来自 `$GIT_DIR` 环境变量。如果仓库是通过 .git 文件自动发现的（例如从子模块或链接的工作目录树），.git 位置将是 .git 目录的最终位置，而不是 .git 文件的位置。"

#. type: Plain text
#: en/config.txt:129
#, placeholders:'linkgit:gitignore[5]', priority:100
msgid "The pattern can contain standard globbing wildcards and two additional ones, `**/` and `/**`, that can match multiple path components. Please refer to linkgit:gitignore[5] for details. For convenience:"
msgstr "该模式可以包含标准的通配符和两个额外的通配符，`**/` 和 `/**`，可以匹配多个路径组件。详情请参考 linkgit:gitignore[5]。为了方便起见："

#. type: Plain text
#: en/config.txt:132
#, priority:100
msgid "If the pattern starts with `~/`, `~` will be substituted with the content of the environment variable `HOME`."
msgstr "如果该模式以 `~/` 开头，`~` 将被替换为环境变量 `HOME` 的内容。"

#. type: Plain text
#: en/config.txt:135
#, priority:100
msgid "If the pattern starts with `./`, it is replaced with the directory containing the current config file."
msgstr "如果模式以 `./` 开头，它将被替换为包含当前配置文件的目录。"

#. type: Plain text
#: en/config.txt:139
#, priority:100
msgid "If the pattern does not start with either `~/`, `./` or `/`, `**/` will be automatically prepended. For example, the pattern `foo/bar` becomes `**/foo/bar` and would match `/any/path/to/foo/bar`."
msgstr "如果模式不以 `~/` 、`./` 或 `/` 开头，`**/` 将被自动添加。例如，模式 `foo/bar` 变成 `**/foo/bar`，将匹配 `/any/path/to/foo/bar`。"

#. type: Plain text
#: en/config.txt:143
#, priority:100
msgid "If the pattern ends with `/`, `**` will be automatically added. For example, the pattern `foo/` becomes `foo/**`. In other words, it matches \"foo\" and everything inside, recursively."
msgstr "如果模式以 `/` 结尾，`**` 将被自动添加。例如，模式 `foo/` 变成 `foo/**`。换句话说，它匹配 \"foo\" 和里面的所有内容，是递归的。"

#. type: Labeled list
#: en/config.txt:144
#, no-wrap, priority:100
msgid "`gitdir/i`"
msgstr "`gitdir/i`"

#. type: Plain text
#: en/config.txt:147
#, priority:100
msgid "This is the same as `gitdir` except that matching is done case-insensitively (e.g. on case-insensitive file systems)"
msgstr "这与 `gitdir` 相同，只是匹配时不区分大小写（例如，在不区分大小写的文件系统上）"

#. type: Labeled list
#: en/config.txt:148
#, ignore-same, no-wrap, priority:100
msgid "`onbranch`"
msgstr "`onbranch`"

#. type: Plain text
#: en/config.txt:155
#, priority:100
msgid "The data that follows the keyword `onbranch:` is taken to be a pattern with standard globbing wildcards and two additional ones, `**/` and `/**`, that can match multiple path components. If we are in a worktree where the name of the branch that is currently checked out matches the pattern, the include condition is met."
msgstr "关键词 `onbranch: ` 后面的数据被认为是一个带有标准通配符和两个额外的通配符的模式，`**/` 和 `/**`，可以匹配多个路径组件。 如果我们在一个工作树中，当前签出的分支的名称与该模式相匹配，则满足包含条件。"

#. type: Plain text
#: en/config.txt:161
#, priority:100
msgid "If the pattern ends with `/`, `**` will be automatically added. For example, the pattern `foo/` becomes `foo/**`. In other words, it matches all branches that begin with `foo/`. This is useful if your branches are organized hierarchically and you would like to apply a configuration to all the branches in that hierarchy."
msgstr "如果模式以 `/` 结尾，`**` 将被自动添加。例如，模式 `foo/` 变成 `foo/**`。换句话说，它匹配所有以 \"foo/\" 开头的分支。如果你的分支是分层组织的，而你想将一个配置应用于该层级中的所有分支，这就很有用了。"

#. type: Labeled list
#: en/config.txt:162
#, no-wrap, priority:100
msgid "`hasconfig:remote.*.url:`"
msgstr "`hasconfig:remote.*.url:`"

#. type: Plain text
#: en/config.txt:170
#, priority:100
msgid "The data that follows this keyword is taken to be a pattern with standard globbing wildcards and two additional ones, `**/` and `/**`, that can match multiple components. The first time this keyword is seen, the rest of the config files will be scanned for remote URLs (without applying any values). If there exists at least one remote URL that matches this pattern, the include condition is met."
msgstr "这个关键词后面的数据被认为是一个带有标准的通配符和两个额外的通配符的模式，`**/` 和 `/**`，可以匹配多个组件。第一次看到这个关键词时，其余的配置文件将被扫描以寻找远程 URL（不应用任何值）。如果存在至少一个匹配该模式的远程 URL，则满足包含条件。"

#. type: Plain text
#: en/config.txt:173
#, priority:100
msgid "Files included by this option (directly or indirectly) are not allowed to contain remote URLs."
msgstr "由该选项包含的文件（直接或间接）不允许包含远程 URLs。"

#. type: Plain text
#: en/config.txt:184
#, priority:100
msgid "Note that unlike other includeIf conditions, resolving this condition relies on information that is not yet known at the point of reading the condition. A typical use case is this option being present as a system-level or global-level config, and the remote URL being in a local-level config; hence the need to scan ahead when resolving this condition. In order to avoid the chicken-and-egg problem in which potentially-included files can affect whether such files are potentially included, Git breaks the cycle by prohibiting these files from affecting the resolution of these conditions (thus, prohibiting them from declaring remote URLs)."
msgstr "请注意，与其他 includeIf 条件不同，解决这个条件依赖于读取条件时还不知道的信息。一个典型的用例是这个选项作为系统级或全局级的配置出现，而远程 URL 在本地级配置中；因此在解决这个条件时需要提前扫描。为了避免鸡生蛋蛋生鸡的问题，即潜在包含的文件会影响这些文件是否被潜在包含，Git 通过禁止这些文件影响这些条件的解决来打破这个循环（因此，禁止它们声明远程 URLs）。"

#. type: Plain text
#: en/config.txt:188
#, priority:100
msgid "As for the naming of this keyword, it is for forwards compatibility with a naming scheme that supports more variable-based include conditions, but currently Git only supports the exact keyword described above."
msgstr "至于这个关键字的命名，是为了与支持更多基于变量的包含条件的命名方案相兼容，但目前 Git 只支持上述的确切关键字。"

#. type: Plain text
#: en/config.txt:190
#, priority:100
msgid "A few more notes on matching via `gitdir` and `gitdir/i`:"
msgstr "关于通过 `gitdir` 和 `gitdir/i` 进行匹配的一些补充说明："

#. type: Plain text
#: en/config.txt:192
#, placeholders:'$GIT_DIR', priority:100
msgid "Symlinks in `$GIT_DIR` are not resolved before matching."
msgstr "`$GIT_DIR` 中的符号链接在匹配前没有被解决。"

#. type: Plain text
#: en/config.txt:197
#, placeholders:'$GIT_DIR', priority:100
msgid "Both the symlink & realpath versions of paths will be matched outside of `$GIT_DIR`. E.g. if ~/git is a symlink to /mnt/storage/git, both `gitdir:~/git` and `gitdir:/mnt/storage/git` will match."
msgstr "在 `$GIT_DIR` 之外，符号链接和实际路径版本的路径都将被匹配。例如，如果 ~/git 是 /mnt/storage/git 的符号链接，`gitdir:~/git` 和 `gitdir:/mnt/storage/git` 都会匹配。"

#. type: Plain text
#: en/config.txt:202
#, priority:100
msgid "This was not the case in the initial release of this feature in v2.13.0, which only matched the realpath version. Configuration that wants to be compatible with the initial release of this feature needs to either specify only the realpath version, or both versions."
msgstr "在 v2.13.0 版本中，这个功能的初始版本不是这样的，它只匹配 realpath 版本。想要与这个功能的初始版本兼容的配置，要么只指定 realpath 版本，要么就指定两个版本。"

#. type: Plain text
#: en/config.txt:205
#, priority:100
msgid "Note that \"../\" is not special and will match literally, which is unlikely what you want."
msgstr "请注意，\"../\" 不是特殊的，将按字面意思匹配，这不太可能是你想要的。"

#. type: Title ~
#: en/config.txt:207 en/git-rev-parse.txt:396 en/git-rev-parse.txt:452
#, no-wrap, priority:100
msgid "Example"
msgstr "示例"

#. type: delimited block -
#: en/config.txt:214
#, no-wrap, priority:100
msgid ""
"# Core variables\n"
"[core]\n"
"\t; Don't trust file modes\n"
"\tfilemode = false\n"
msgstr ""
"# 核心变量\n"
"[core]\n"
"\t; 不信任文件模式\n"
"\tfilemode = false\n"

#. type: delimited block -
#: en/config.txt:219
#, no-wrap, priority:100
msgid ""
"# Our diff algorithm\n"
"[diff]\n"
"\texternal = /usr/local/bin/diff-wrapper\n"
"\trenames = true\n"
msgstr ""
"# 我们的差异算法\n"
"[diff]\n"
"\texternal = /usr/local/bin/diff-wrapper\n"
"\trenames = true\n"

#. type: delimited block -
#: en/config.txt:223
#, no-wrap, priority:100
msgid ""
"[branch \"devel\"]\n"
"\tremote = origin\n"
"\tmerge = refs/heads/devel\n"
msgstr ""
"[branch \"devel\"]\n"
"\tremote = origin\n"
"\tmerge = refs/heads/devel\n"

#. type: delimited block -
#: en/config.txt:228
#, no-wrap, placeholders:'kernel.org', priority:100
msgid ""
"# Proxy settings\n"
"[core]\n"
"\tgitProxy=\"ssh\" for \"kernel.org\"\n"
"\tgitProxy=default-proxy ; for the rest\n"
msgstr ""
"# 代理设置\n"
"[core]\n"
"\tgitProxy=\"ssh\" for \"kernel.org\"\n"
"\tgitProxy=default-proxy ; 其余为\n"

#. type: delimited block -
#: en/config.txt:233
#, no-wrap, placeholders:'foo.inc':'foo.inc':'foo.inc':'foo.inc':'foo.inc':'$HOME', priority:100
msgid ""
"[include]\n"
"\tpath = /path/to/foo.inc ; include by absolute path\n"
"\tpath = foo.inc ; find \"foo.inc\" relative to the current file\n"
"\tpath = ~/foo.inc ; find \"foo.inc\" in your `$HOME` directory\n"
msgstr ""
"[include]\n"
"\tpath = /path/to/foo.inc ; 按绝对路径包含\n"
"\tpath = foo.inc ; find \"foo.inc\" 相对于当前文件\n"
"\tpath = ~/foo.inc ; 在您的 `$HOME` 目录中找到 \"foo.inc\"\n"

#. type: delimited block -
#: en/config.txt:237
#, no-wrap, placeholders:'$GIT_DIR':'foo.inc', priority:100
msgid ""
"; include if $GIT_DIR is /path/to/foo/.git\n"
"[includeIf \"gitdir:/path/to/foo/.git\"]\n"
"\tpath = /path/to/foo.inc\n"
msgstr ""
";如果 $GIT_DIR 是 /path/to/foo/.git 就包含\n"
"[includeIf \"gitdir:/path/to/foo/.git\"]\n"
"\tpath = /path/to/foo.inc\n"

#. type: delimited block -
#: en/config.txt:241
#, no-wrap, placeholders:'foo.inc', priority:100
msgid ""
"; include for all repositories inside /path/to/group\n"
"[includeIf \"gitdir:/path/to/group/\"]\n"
"\tpath = /path/to/foo.inc\n"
msgstr ""
";包括 /path/to/group 内的所有仓库\n"
"[includeIf \"gitdir:/path/to/group/\"]\n"
"\tpath = /path/to/foo.inc\n"

#. type: delimited block -
#: en/config.txt:245
#, no-wrap, placeholders:'$HOME':'foo.inc', priority:100
msgid ""
"; include for all repositories inside $HOME/to/group\n"
"[includeIf \"gitdir:~/to/group/\"]\n"
"\tpath = /path/to/foo.inc\n"
msgstr ""
"; 包括 $HOME/to/group 内的所有仓库\n"
"[includeIf \"gitdir:~/to/group/\"]\n"
"\tpath = /path/to/foo.inc\n"

#. type: delimited block -
#: en/config.txt:251
#, no-wrap, placeholders:'foo.inc', priority:100
msgid ""
"; relative paths are always relative to the including\n"
"; file (if the condition is true); their location is not\n"
"; affected by the condition\n"
"[includeIf \"gitdir:/path/to/group/\"]\n"
"\tpath = foo.inc\n"
msgstr ""
"; 相对路径总是相对于包括\n"
"; 文件（如果条件为真）；其位置不受\n"
"; 的位置不受条件的影响。\n"
"[includeIf \"gitdir:/path/to/group/\"]\n"
"\tpath = foo.inc\n"

#. type: delimited block -
#: en/config.txt:256
#, no-wrap, placeholders:'foo.inc', priority:100
msgid ""
"; include only if we are in a worktree where foo-branch is\n"
"; currently checked out\n"
"[includeIf \"onbranch:foo-branch\"]\n"
"\tpath = foo.inc\n"
msgstr ""
"; 只有工作区当前检出了 foo-branch \n"
"; 才包括\n"
"[includeIf \"onbranch:foo-branch\"] 。\n"
"\t路径 = foo.inc\n"

#. type: delimited block -
#: en/config.txt:264
#, no-wrap, placeholders:'foo.inc', priority:100
msgid ""
"; include only if a remote with the given URL exists (note\n"
"; that such a URL may be provided later in a file or in a\n"
"; file read after this file is read, as seen in this example)\n"
"[includeIf \"hasconfig:remote.*.url:https://example.com/**\"]\n"
"\tpath = foo.inc\n"
"[remote \"origin\"]\n"
"\turl = https://example.com/git\n"
msgstr ""
"; 只有在给定 URL 的远程仓库存在的情况下才包括（注意\n"
"; 这样的URL可能在以后的文件中提供，或者在这个文件被读取后的一个\n"
"; 文件中提供，正如在这个例子中看到的那样)\n"
"[includeIf \"hasconfig:remote.*.url:https://example.com/*\" ]\n"
"\t路径 = foo.inc\n"
"[remote \"origin\"]\n"
"\turl = https://example.com/git\n"

#. type: Title ~
#: en/config.txt:267
#, no-wrap, priority:100
msgid "Values"
msgstr "值"

#. type: Plain text
#: en/config.txt:272
#, priority:100
msgid "Values of many variables are treated as a simple string, but there are variables that take values of specific types and there are rules as to how to spell them."
msgstr "许多变量的值都被当作一个简单的字符串，但有些变量取的是特定类型的值，对于如何拼写它们有一些规则。"

#. type: Labeled list
#: en/config.txt:273
#, no-wrap, priority:100
msgid "boolean"
msgstr "布尔"

#. type: Plain text
#: en/config.txt:278
#, priority:100
msgid "When a variable is said to take a boolean value, many synonyms are accepted for 'true' and 'false'; these are all case-insensitive."
msgstr "当一个变量被称为采取布尔值时，许多同义词被接受为 'true' 和 'false' ；这些都是不分大小写的。"

#. type: Labeled list
#: en/config.txt:279
#, no-wrap, priority:100
msgid "true"
msgstr "真"

#. type: Plain text
#: en/config.txt:282
#, priority:100
msgid "Boolean true literals are `yes`, `on`, `true`, and `1`. Also, a variable defined without `= <value>` is taken as true."
msgstr "布尔真值是 `yes`、`on`、`true`和 `1`。 此外，一个没有 `= <值>` 的变量被认为是真。"

#. type: Labeled list
#: en/config.txt:283
#, no-wrap, priority:100
msgid "false"
msgstr "假"

#. type: Plain text
#: en/config.txt:285
#, priority:100
msgid "Boolean false literals are `no`, `off`, `false`, `0` and the empty string."
msgstr "布尔假值是 `no`、`off`、`false`、`0` 和空字符串。"

#. type: Plain text
#: en/config.txt:289
#, placeholders:'`--type=bool`', priority:100
msgid "When converting a value to its canonical form using the `--type=bool` type specifier, 'git config' will ensure that the output is \"true\" or \"false\" (spelled in lowercase)."
msgstr "当使用 `--type=bool` 类型指定符将一个值转换为其规范形式时，'git config' 将确保输出为 \"true\" 或 \"false\"（用小写字母拼写）。"

#. type: Labeled list
#: en/config.txt:290
#, no-wrap, priority:100
msgid "integer"
msgstr "整数"

#. type: Plain text
#: en/config.txt:294
#, ignore-ellipsis, priority:100
msgid "The value for many variables that specify various sizes can be suffixed with `k`, `M`,... to mean \"scale the number by 1024\", \"by 1024x1024\", etc."
msgstr "许多指定各种尺寸的变量的值可以以 `k`、`M`...为后缀，表示 “以1024为比例的数字”、“以1024x1024为比例”，等等。"

#. type: Labeled list
#: en/config.txt:295 en/diff-options.txt:451 en/git-for-each-ref.txt:187
#, ignore-same, no-wrap, priority:280
msgid "color"
msgstr "color"

#. type: Plain text
#: en/config.txt:299
#, priority:100
msgid "The value for a variable that takes a color is a list of colors (at most two, one for foreground and one for background) and attributes (as many as you want), separated by spaces."
msgstr "接受颜色的变量的值是一个颜色（最多两个，一个用于前景，一个用于背景）和属性（你想要多少就有多少）的列表，用空格分隔。"

#. type: Plain text
#: en/config.txt:305
#, priority:100
msgid "The basic colors accepted are `normal`, `black`, `red`, `green`, `yellow`, `blue`, `magenta`, `cyan`, `white` and `default`. The first color given is the foreground; the second is the background. All the basic colors except `normal` and `default` have a bright variant that can be specified by prefixing the color with `bright`, like `brightred`."
msgstr "接受的基本颜色是 `normal`、`black`、`red`、`green`、`yellow`、`blue`、`magenta`、`cyan`、`white` 和 `default`。 给出的第一种颜色是前景；第二种是背景。 除了`normal'和`default'之外，所有的基本颜色都有一个明亮的变体，可以通过在颜色前面加上`bright'来指定，比如`brightred'。"

#. type: Plain text
#: en/config.txt:309
#, priority:100
msgid "The color `normal` makes no change to the color. It is the same as an empty string, but can be used as the foreground color when specifying a background color alone (for example, \"normal red\")."
msgstr "颜色`normal`不会使颜色发生变化。它与空字符串相同，但在单独指定背景颜色时可以作为前景颜色（例如，\"normal red\"）。"

#. type: Plain text
#: en/config.txt:313
#, priority:100
msgid "The color `default` explicitly resets the color to the terminal default, for example to specify a cleared background. Although it varies between terminals, this is usually not the same as setting to \"white black\"."
msgstr "颜色`default` 明确地将颜色重置为终端的默认值，例如，指定一个清除的背景。虽然不同的终端有差异，但这通常与设置为 \"white black\" 不一样。"

#. type: Plain text
#: en/config.txt:318
#, priority:100
msgid "Colors may also be given as numbers between 0 and 255; these use ANSI 256-color mode (but note that not all terminals may support this). If your terminal supports it, you may also specify 24-bit RGB values as hex, like `#ff0ab3`."
msgstr "颜色也可以用 0 到 255 之间的数字来表示；这些颜色使用 ANSI 256 色模式（但注意不是所有的终端都支持这个）。 如果你的终端支持，你也可以指定 24 位 RGB 值为十六进制，如 `#ff0ab3`。"

#. type: Plain text
#: en/config.txt:325
#, priority:100
msgid "The accepted attributes are `bold`, `dim`, `ul`, `blink`, `reverse`, `italic`, and `strike` (for crossed-out or \"strikethrough\" letters). The position of any attributes with respect to the colors (before, after, or in between), doesn't matter. Specific attributes may be turned off by prefixing them with `no` or `no-` (e.g., `noreverse`, `no-ul`, etc)."
msgstr "可接受的属性是 `bold`、`dim`、`ul`、`blink`、`reverse`、`italic` 和 `strike`（用于划掉的字母或 “删除线”）。 任何属性相对于颜色的位置（在前，在后，或在中间）并不重要。特定的属性可以通过在它们前面加上 `no` 或 `no-` 来关闭（例如，`noreverse`，`no-ul`，等等）。"

#. type: Plain text
#: en/config.txt:330
#, priority:100
msgid "The pseudo-attribute `reset` resets all colors and attributes before applying the specified coloring. For example, `reset green` will result in a green foreground and default background without any active attributes."
msgstr "伪属性 `reset` 在应用指定的着色之前重置所有颜色和属性。例如，`reset green` 将导致一个绿色的前景和默认的背景，没有任何激活的属性。"

#. type: Plain text
#: en/config.txt:333
#, priority:100
msgid "An empty color string produces no color effect at all. This can be used to avoid coloring specific elements without disabling color entirely."
msgstr "一个空的颜色字符串根本不会产生任何颜色效果。这可以用来避免给特定的元素上色而不完全禁用颜色。"

#. type: Plain text
#: en/config.txt:342
#, placeholders:'color.decorate.branch':'--decorate`', priority:100
msgid "For git's pre-defined color slots, the attributes are meant to be reset at the beginning of each item in the colored output. So setting `color.decorate.branch` to `black` will paint that branch name in a plain `black`, even if the previous thing on the same output line (e.g. opening parenthesis before the list of branch names in `log --decorate` output) is set to be painted with `bold` or some other attribute. However, custom log formats may do more complicated and layered coloring, and the negated forms may be useful there."
msgstr "对于 git 的预定义颜色槽，属性是为了在彩色输出的每一项开始时被重置。所以将 `color.decorate.branch` 设置为 `black` 会将该分支名称涂成普通的 `black`，即使同一输出行中的前一个东西（例如`log --decorate`输出中的分支名称列表前的括号）被设置为 `bold` 或其他属性。 然而，自定义的日志格式可能会做更复杂和分层的着色，而否定的形式在那里可能很有用。"

#. type: Labeled list
#: en/config.txt:343
#, no-wrap, priority:100
msgid "pathname"
msgstr "路径名"

#. type: Plain text
#: en/config.txt:349
#, placeholders:'$HOME', priority:100
msgid "A variable that takes a pathname value can be given a string that begins with \"`~/`\" or \"`~user/`\", and the usual tilde expansion happens to such a string: `~/` is expanded to the value of `$HOME`, and `~user/` to the specified user's home directory."
msgstr "一个获取路径名值的变量可以被赋予一个以 \"`~/`\" 或 \"`~user/`\" 开头的字符串，通常的 tilde 扩展会发生在这样一个字符串上： `~/` 被扩展为 `$HOME` 的值，而 `~user/` 被扩展为指定用户的主目录。"

#. type: Plain text
#: en/config.txt:358
#, priority:100
msgid "If a path starts with `%(prefix)/`, the remainder is interpreted as a path relative to Git's \"runtime prefix\", i.e. relative to the location where Git itself was installed. For example, `%(prefix)/bin/` refers to the directory in which the Git executable itself lives. If Git was compiled without runtime prefix support, the compiled-in prefix will be substituted instead. In the unlikely event that a literal path needs to be specified that should _not_ be expanded, it needs to be prefixed by `./`, like so: `./%(prefix)/bin`."
msgstr "如果一个路径以 `%(prefix)/` 开头，其余部分将被解释为相对于 Gi t的 \"运行时前缀\" 的路径，即相对于 Git 本身安装的位置。例如，`%(prefix)/bin/` 指的是 Git 可执行文件本身所在的目录。如果 Git 在编译时不支持运行时前缀，那么编译时的前缀将被替代。在不太可能的情况下，如果需要指定一个不应该被扩展的字面路径，需要以 `./` 为前缀，就像这样： `./%（前缀）/bin`。"

#. type: Title ~
#: en/config.txt:361
#, no-wrap, priority:100
msgid "Variables"
msgstr "变量"

#. type: Plain text
#: en/config.txt:366
#, priority:100
msgid "Note that this list is non-comprehensive and not necessarily complete. For command-specific variables, you will find a more detailed description in the appropriate manual page."
msgstr "请注意，这个列表并不全面，也不一定完整。 对于特定命令的变量，你会在相应的手册页中找到更详细的描述。"

#. type: Plain text
#: en/config.txt:371
#, priority:100
msgid "Other git-related tools may and do use their own variables. When inventing new variables for use in your own tool, make sure their names do not conflict with those that are used by Git itself and other popular tools, and describe them in your documentation."
msgstr "其他与 git 相关的工具可能也确实使用了他们自己的变量。 当发明新的变量用于自己的工具时，要确保它们的名字不与 Git 本身和其他流行的工具所使用的名字冲突，并在你的文档中描述它们。"

#. type: Labeled list
#: en/config/add.txt:1
#, no-wrap, placeholders:'add.ignoreErrors', priority:300
msgid "add.ignoreErrors"
msgstr "add.ignoreErrors"

#. type: Labeled list
#: en/config/add.txt:2
#, no-wrap, placeholders:'add.ignore', priority:300
msgid "add.ignore-errors (deprecated)"
msgstr "add.ignore-errors (deprecated 弃用)"

#. type: Plain text
#: en/config/add.txt:8
#, placeholders:'`--ignore-errors`':'linkgit:git-add[1]':'add.ignore', priority:300
msgid "Tells 'git add' to continue adding files when some files cannot be added due to indexing errors. Equivalent to the `--ignore-errors` option of linkgit:git-add[1]. `add.ignore-errors` is deprecated, as it does not follow the usual naming convention for configuration variables."
msgstr "当某些文件因索引错误而无法添加时，告诉 'git add' 继续添加。等同于 linkgit:git-add[1] 的 `--ignore-errors` 选项。 `add.ignore-errors` 已被弃用，因为它不符合配置变量的常规命名规则。"

#. type: Labeled list
#: en/config/add.txt:9
#, no-wrap, placeholders:'add.interactive.useBuiltin', priority:300
msgid "add.interactive.useBuiltin"
msgstr "add.interactive.useBuiltin"

#. type: Plain text
#: en/config/add.txt:13
#, placeholders:'linkgit:git-add[1]', priority:300
msgid "Unused configuration variable. Used in Git versions v2.25.0 to v2.36.0 to enable the built-in version of linkgit:git-add[1]'s interactive mode, which then became the default in Git versions v2.37.0 to v2.39.0."
msgstr "未使用的配置变量。在 Git v2.25.0 至 v2.36.0 版本中用于启用 linkgit:git-add[1] 的内置交互模式，在 Git v2.37.0 至 v2.39.0 版本中成为默认模式。"

#. type: Labeled list
#: en/config/clone.txt:1
#, no-wrap, placeholders:'clone.defaultRemoteName', priority:300
msgid "clone.defaultRemoteName"
msgstr "clone.defaultRemoteName"

#. type: Plain text
#: en/config/clone.txt:5
#, placeholders:'`--origin`':'linkgit:git-clone[1]', priority:300
msgid "The name of the remote to create when cloning a repository. Defaults to `origin`, and can be overridden by passing the `--origin` command-line option to linkgit:git-clone[1]."
msgstr "克隆仓库时创建的远程仓库的名称。默认为 `--origin`，可以通过 linkgit:git-clone[1] 的 `--origin` 命令行选项覆盖。"

#. type: Labeled list
#: en/config/clone.txt:6
#, no-wrap, placeholders:'clone.rejectShallow', priority:300
msgid "clone.rejectShallow"
msgstr "clone.rejectShallow"

#. type: Plain text
#: en/config/clone.txt:9
#, placeholders:'`--reject-shallow`':'linkgit:git-clone[1]', priority:300
msgid "Reject cloning a repository if it is a shallow one; this can be overridden by passing the `--reject-shallow` option on the command line. See linkgit:git-clone[1]"
msgstr "如果是浅层仓库，则拒绝克隆；可以通过在命令行中传递 `--reject-shallow` 选项来重写。参见 linkgit:git-clone[1]"

#. type: Labeled list
#: en/config/clone.txt:10
#, no-wrap, placeholders:'clone.filterSubmodules', priority:300
msgid "clone.filterSubmodules"
msgstr "clone.filterSubmodules"

#. type: Plain text
#: en/config/clone.txt:13
#, placeholders:'`--filter`':'linkgit:git-rev-list[1]':'`--recurse-submodules`', priority:300
msgid "If a partial clone filter is provided (see `--filter` in linkgit:git-rev-list[1]) and `--recurse-submodules` is used, also apply the filter to submodules."
msgstr "如果提供了部分克隆过滤器（参见 linkgit:git-rev-list[1] 中的 `--filter` 选项），并且如果使用了 `--recurse-submodules` 选项，也会将过滤器应用于子模块。"

#. type: Labeled list
#: en/config/commit.txt:1
#, ignore-same, no-wrap, priority:280
msgid "commit.cleanup"
msgstr "commit.cleanup"

#. type: Plain text
#: en/config/commit.txt:9
#, placeholders:'`--cleanup`':'linkgit:git-commit[1]':'commit.cleanup', priority:280
msgid "This setting overrides the default of the `--cleanup` option in `git commit`. See linkgit:git-commit[1] for details. Changing the default can be useful when you always want to keep lines that begin with the comment character `#` in your log message, in which case you would do `git config commit.cleanup whitespace` (note that you will have to remove the help lines that begin with `#` in the commit log template yourself, if you do this)."
msgstr "此设置会覆盖 `git commit` 中 `--cleanup` 选项的默认值。详见 linkgit:git-commit[1]。当您总是希望在日志信息中保留以注释字符 `#` 开头的行时，更改默认值会很有用，在这种情况下，您可以执行 `git config commit.cleanup whitespace` （注意，如果这样做，您必须自己删除提交日志模板中以 `#` 开头的帮助行）。"

#. type: Labeled list
#: en/config/commit.txt:10
#, ignore-same, no-wrap, priority:280
msgid "commit.gpgSign"
msgstr "commit.gpgSign"

#. type: Plain text
#: en/config/commit.txt:17
#, priority:280
msgid "A boolean to specify whether all commits should be GPG signed. Use of this option when doing operations such as rebase can result in a large number of commits being signed. It may be convenient to use an agent to avoid typing your GPG passphrase several times."
msgstr "布尔值，用于指定是否对所有提交进行 GPG 签名。在进行变基等操作时使用该选项可能会导致大量提交被签名。使用代理可以避免多次键入 GPG 密码。"

#. type: Labeled list
#: en/config/commit.txt:18
#, ignore-same, no-wrap, priority:280
msgid "commit.status"
msgstr "commit.status"

#. type: Plain text
#: en/config/commit.txt:22
#, priority:280
msgid "A boolean to enable/disable inclusion of status information in the commit message template when using an editor to prepare the commit message. Defaults to true."
msgstr "布尔值，用于在使用编辑器准备提交信息时，启用/禁用在提交信息模板中包含状态信息。默认为 true。"

#. type: Labeled list
#: en/config/commit.txt:23
#, ignore-same, no-wrap, priority:280
msgid "commit.template"
msgstr "commit.template"

#. type: Plain text
#: en/config/commit.txt:26
#, priority:280
msgid "Specify the pathname of a file to use as the template for new commit messages."
msgstr "指定要用作新提交信息模板的文件路径名。"

#. type: Labeled list
#: en/config/commit.txt:27
#, ignore-same, no-wrap, priority:280
msgid "commit.verbose"
msgstr "commit.verbose"

#. type: Plain text
#: en/config/commit.txt:29
#, placeholders:'linkgit:git-commit[1]', priority:280
msgid "A boolean or int to specify the level of verbosity with `git commit`. See linkgit:git-commit[1]."
msgstr "布尔值或 int 值，用于指定 `git commit` 的繁琐程度。参见 linkgit:git-commit[1]。"

#. type: Labeled list
#: en/config/diff.txt:1
#, ignore-same, no-wrap, priority:280
msgid "diff.autoRefreshIndex"
msgstr "diff.autoRefreshIndex"

#. type: Plain text
#: en/config/diff.txt:10
#, placeholders:'git update-index':'--refresh`':'git diff-files', priority:280
msgid "When using 'git diff' to compare with work tree files, do not consider stat-only changes as changed. Instead, silently run `git update-index --refresh` to update the cached stat information for paths whose contents in the work tree match the contents in the index. This option defaults to true. Note that this affects only 'git diff' Porcelain, and not lower level 'diff' commands such as 'git diff-files'."
msgstr "在使用 `git diff` 与工作树文件进行比较时，不要将仅统计信息的更改视为已更改。取而代之的是静默运行 `git update-index --refresh` 来更新工作树中内容与索引中内容匹配的路径的缓存统计信息。该选项默认为 true。请注意，这只会影响 'git diff' 命令，而不会影响更低级的 'diff' 命令，比如 \"git diff-files\"。"

#. type: Labeled list
#: en/config/diff.txt:11
#, ignore-same, no-wrap, priority:280
msgid "diff.dirstat"
msgstr "diff.dirstat"

#. type: Plain text
#: en/config/diff.txt:18
#, ignore-ellipsis, placeholders:'`--dirstat`':'`--dirstat`':'linkgit:git-diff[1]':'`--dirstat=':'diff.dirstat', priority:280
msgid "A comma separated list of `--dirstat` parameters specifying the default behavior of the `--dirstat` option to linkgit:git-diff[1] and friends. The defaults can be overridden on the command line (using `--dirstat=<param1,param2,...>`). The fallback defaults (when not changed by `diff.dirstat`) are `changes,noncumulative,3`. The following parameters are available:"
msgstr "以逗号分隔的 `--dirstat` 参数列表，用于指定 linkgit:git-diff[1] 和友集的 `--dirstat` 选项的默认行为。默认值可以在命令行中覆盖（使用 `--dirstat=<参数1,参数2,...>`）。后备默认值（当 `diff.dirstat` 没有更改时）是 `changes,noncumulative,3` 。以下参数可用："

#. type: Labeled list
#: en/config/diff.txt:20 en/diff-options.txt:263
#, ignore-same, no-wrap, priority:280
msgid "`changes`"
msgstr "`changes`"

#. type: Plain text
#: en/config/diff.txt:26 en/diff-options.txt:269
#, priority:280
msgid "Compute the dirstat numbers by counting the lines that have been removed from the source, or added to the destination. This ignores the amount of pure code movements within a file. In other words, rearranging lines in a file is not counted as much as other changes. This is the default behavior when no parameter is given."
msgstr "通过计算从源文件中删除的行数或添加到目标文件中的行数来计算分布状态的数字。这忽略了文件内的代码移动行为。也就是说，在文件中重新排列的行不会像其他变化一样被计算在内。这是在没有给出参数时的默认行为。"

#. type: Labeled list
#: en/config/diff.txt:26 en/diff-options.txt:269
#, ignore-same, no-wrap, priority:280
msgid "`lines`"
msgstr "`lines`"

#. type: Plain text
#: en/config/diff.txt:34 en/diff-options.txt:277
#, placeholders:'`--dirstat`', priority:280
msgid "Compute the dirstat numbers by doing the regular line-based diff analysis, and summing the removed/added line counts. (For binary files, count 64-byte chunks instead, since binary files have no natural concept of lines). This is a more expensive `--dirstat` behavior than the `changes` behavior, but it does count rearranged lines within a file as much as other changes. The resulting output is consistent with what you get from the other `--*stat` options."
msgstr "通过做常规基于行的差异分析，计算分布状态的数字，并将删除/添加的行数相加。(对于二进制文件，用 64 字节的块来计算，因为二进制文件没有行的概念)。在使用 `--dirstat` 时这个选项的行为开销比 `changes` 更大，但会对文件中重新排列的行进行计数。其得到的输出结果与其他的 `--*stat` 选项一致。"

#. type: Labeled list
#: en/config/diff.txt:34 en/diff-options.txt:277
#, ignore-same, no-wrap, priority:280
msgid "`files`"
msgstr "`files`"

#. type: Plain text
#: en/config/diff.txt:39 en/diff-options.txt:282
#, placeholders:'`--dirstat`', priority:280
msgid "Compute the dirstat numbers by counting the number of files changed. Each changed file counts equally in the dirstat analysis. This is the computationally cheapest `--dirstat` behavior, since it does not have to look at the file contents at all."
msgstr "通过计算被改变的文件数量来计算分布状态的数字。在分布状态分析中，每一个被改变的文件都会被平等地计算。这是计算上开销最小的 `--dirstat` 行为，因为它无需查看文件内容。"

#. type: Labeled list
#: en/config/diff.txt:39 en/diff-options.txt:282
#, ignore-same, no-wrap, priority:280
msgid "`cumulative`"
msgstr "`cumulative`"

#. type: Plain text
#: en/config/diff.txt:44 en/diff-options.txt:287
#, priority:280
msgid "Count changes in a child directory for the parent directory as well. Note that when using `cumulative`, the sum of the percentages reported may exceed 100%. The default (non-cumulative) behavior can be specified with the `noncumulative` parameter."
msgstr "子目录中的变化计算到父目录中。 注意，当使用 `cumulative` 选项时，报告的百分比之和可能超过 100%。默认的（非累积）行为可以用 `noncumulative` 参数指定。"

#. type: Labeled list
#: en/config/diff.txt:44 en/diff-options.txt:287 en/git-cherry.txt:39
#, no-wrap, priority:280
msgid "<limit>"
msgstr "<limit>"

#. type: Plain text
#: en/config/diff.txt:48 en/diff-options.txt:291
#, priority:280
msgid "An integer parameter specifies a cut-off percent (3% by default). Directories contributing less than this percentage of the changes are not shown in the output."
msgstr "一个整数参数，其指定一个截止百分比（默认为 3%）。贡献值小于这个百分比的目录不显示在输出中。"

#. type: Plain text
#: en/config/diff.txt:54
#, priority:280
msgid "Example: The following will count changed files, while ignoring directories with less than 10% of the total amount of changed files, and accumulating child directory counts in the parent directories: `files,10,cumulative`."
msgstr "例如：下面的参数会统计更改的文件，同时忽略占更改文件总数 10% 以下的目录，并累积父目录中的子目录计数：`files,10,cumulative`。"

#. type: Labeled list
#: en/config/diff.txt:55
#, ignore-same, no-wrap, priority:280
msgid "diff.statNameWidth"
msgstr "diff.statNameWidth"

#. type: Plain text
#: en/config/diff.txt:58
#, placeholders:'--stat':'--stat', priority:280
msgid "Limit the width of the filename part in --stat output. If set, applies to all commands generating --stat output except format-patch."
msgstr "限制 --stat 输出中文件名部分的宽度。如果设置，则适用于生成 --stat 输出的所有命令，format-patch 除外。"

#. type: Labeled list
#: en/config/diff.txt:59
#, ignore-same, no-wrap, priority:280
msgid "diff.statGraphWidth"
msgstr "diff.statGraphWidth"

#. type: Plain text
#: en/config/diff.txt:62
#, placeholders:'--stat':'--stat', priority:280
msgid "Limit the width of the graph part in --stat output. If set, applies to all commands generating --stat output except format-patch."
msgstr "限制 --stat 输出中图形部分的宽度。如果设置，则适用于生成 --stat 输出的所有命令，format-patch 除外。"

# 译者：末尾两个字节可能被删减，如果翻译为中文标点会出现半个汉字
#. type: Labeled list
#: en/config/diff.txt:63
#, ignore-same, no-wrap, priority:280
msgid "diff.context"
msgstr "diff.context"

#. type: Plain text
#: en/config/diff.txt:66
#, priority:280
msgid "Generate diffs with <n> lines of context instead of the default of 3. This value is overridden by the -U option."
msgstr "生成 <n> 行上下文差异，而不是默认的 3 行。 该值由 -U 选项覆盖。"

#. type: Labeled list
#: en/config/diff.txt:67
#, ignore-same, no-wrap, priority:280
msgid "diff.interHunkContext"
msgstr "diff.interHunkContext"

#. type: Plain text
#: en/config/diff.txt:72
#, placeholders:'`--inter-hunk-context`', priority:280
msgid "Show the context between diff hunks, up to the specified number of lines, thereby fusing the hunks that are close to each other. This value serves as the default for the `--inter-hunk-context` command line option."
msgstr "显示 diff hunk 之间的上下文，行数不超过指定行数，从而合并彼此相近的 hunk。此值是 `--inter-hunk-context` 命令行选项的默认值。"

#. type: Labeled list
#: en/config/diff.txt:73
#, ignore-same, no-wrap, priority:280
msgid "diff.external"
msgstr "diff.external"

#. type: Plain text
#: en/config/diff.txt:81
#, placeholders:'GIT_EXTERNAL_DIFF':'linkgit:git[1]':'linkgit:gitattributes[5]', priority:280
msgid "If this config variable is set, diff generation is not performed using the internal diff machinery, but using the given command. Can be overridden with the `GIT_EXTERNAL_DIFF' environment variable. The command is called with parameters as described under \"git Diffs\" in linkgit:git[1]. Note: if you want to use an external diff program only on a subset of your files, you might want to use linkgit:gitattributes[5] instead."
msgstr "如果设置了该配置变量，则不会使用内部 diff 机制生成 diff，而是使用给定的命令。可以用 `GIT_EXTERNAL_DIFF` 环境变量来覆盖。该命令的参数调用方式与 linkgit:git[1] 中 \"git Diffs\" 一节所述相同。注意：如果只想在部分文件上使用外部差异程序，可以用 linkgit:gitattributes[5] 代替。"

#. type: Labeled list
#: en/config/diff.txt:82
#, ignore-same, no-wrap, priority:280
msgid "diff.ignoreSubmodules"
msgstr "diff.ignoreSubmodules"

#. type: Plain text
#: en/config/diff.txt:94
#, placeholders:'--ignore-submodules':'git diff-files':'status.submoduleSummary':'--ignore-submodules', priority:280
msgid "Sets the default value of --ignore-submodules. Note that this affects only 'git diff' Porcelain, and not lower level 'diff' commands such as 'git diff-files'. 'git checkout' and 'git switch' also honor this setting when reporting uncommitted changes. Setting it to 'all' disables the submodule summary normally shown by 'git commit' and 'git status' when `status.submoduleSummary` is set unless it is overridden by using the --ignore-submodules command-line option. The 'git submodule' commands are not affected by this setting. By default this is set to untracked so that any untracked submodules are ignored."
msgstr "设置 --ignore-submodules 的默认值。请注意，这只会影响上层命令 'git diff'，而不会影响更底层的 'diff' 命令，如 'git diff-files'。'git checkout' 和 'git switch' 在报告未提交的改动时也会尊重这一设置。如果将其设置为 'all'，则 'git commit' 和 'git status' 在设置 `status.submoduleSummary` 时通常会显示子模块摘要，除非使用 --ignore-submodules 命令行选项将其覆盖。`git submodule` 命令不受此设置影响。默认设置为 untracked，因此任何未跟踪的子模块都会被忽略。"

#. type: Labeled list
#: en/config/diff.txt:95
#, ignore-same, no-wrap, priority:280
msgid "diff.mnemonicPrefix"
msgstr "diff.mnemonicPrefix"

#. type: Plain text
#: en/config/diff.txt:100
#, priority:280
msgid "If set, 'git diff' uses a prefix pair that is different from the standard \"a/\" and \"b/\" depending on what is being compared. When this configuration is in effect, reverse diff output also swaps the order of the prefixes:"
msgstr "如果设置了该选项，'git diff' 就会根据比较的内容使用不同于标准 \"a/\" 和 \"b/\" 的前缀对。当此配置生效时，反向 diff 输出也会交换前缀的顺序："

#. type: Labeled list
#: en/config/diff.txt:100
#, no-wrap, priority:280
msgid "`git diff`"
msgstr "`git diff`"

#. type: Plain text
#: en/config/diff.txt:102
#, priority:280
msgid "compares the (i)ndex and the (w)ork tree;"
msgstr "比较索引（i）和工作目录树（w）；"

#. type: Labeled list
#: en/config/diff.txt:102
#, no-wrap, placeholders:'HEAD', priority:280
msgid "`git diff HEAD`"
msgstr "`git diff HEAD`"

#. type: Plain text
#: en/config/diff.txt:104
#, priority:280
msgid "compares a (c)ommit and the (w)ork tree;"
msgstr "比较（c）提交（w）工作树；"

#. type: Labeled list
#: en/config/diff.txt:104
#, no-wrap, placeholders:'--cached`', priority:280
msgid "`git diff --cached`"
msgstr "`git diff --cached`"

#. type: Plain text
#: en/config/diff.txt:106
#, priority:280
msgid "compares a (c)ommit and the (i)ndex;"
msgstr "比较一个提交（c）和索引（i）；"

#. type: Labeled list
#: en/config/diff.txt:106
#, no-wrap, placeholders:'HEAD', priority:280
msgid "`git diff HEAD:file1 file2`"
msgstr "`git diff HEAD:文件 1 文件 2`"

#. type: Plain text
#: en/config/diff.txt:108
#, priority:280
msgid "compares an (o)bject and a (w)ork tree entity;"
msgstr "比较一个（o）对象和一个（w）工作树实体；"

#. type: Labeled list
#: en/config/diff.txt:108
#, no-wrap, placeholders:'--no-index', priority:280
msgid "`git diff --no-index a b`"
msgstr "`git diff --no-index a b`"

#. type: Plain text
#: en/config/diff.txt:110
#, priority:280
msgid "compares two non-git things (1) and (2)."
msgstr "比较了两个非 git 项目（1）和（2）。"

#. type: Labeled list
#: en/config/diff.txt:111
#, ignore-same, no-wrap, priority:280
msgid "diff.noprefix"
msgstr "diff.noprefix"

#. type: Plain text
#: en/config/diff.txt:113
#, priority:280
msgid "If set, 'git diff' does not show any source or destination prefix."
msgstr "如果设置了，'git diff' 不会显示任何源前缀或目标前缀。"

#. type: Labeled list
#: en/config/diff.txt:114
#, ignore-same, no-wrap, priority:280
msgid "diff.relative"
msgstr "diff.relative"

#. type: Plain text
#: en/config/diff.txt:117
#, priority:280
msgid "If set to 'true', 'git diff' does not show changes outside of the directory and show pathnames relative to the current directory."
msgstr "如果设置为 'true'，'git diff' 不会显示目录外的更改，而是显示相对于当前目录的路径名。"

#. type: Labeled list
#: en/config/diff.txt:118
#, ignore-same, no-wrap, priority:280
msgid "diff.orderFile"
msgstr "diff.orderFile"

#. type: Plain text
#: en/config/diff.txt:123
#, placeholders:'linkgit:git-diff[1]':'diff.orderFile', priority:280
msgid "File indicating how to order files within a diff. See the '-O' option to linkgit:git-diff[1] for details. If `diff.orderFile` is a relative pathname, it is treated as relative to the top of the working tree."
msgstr "指示如何在差异中排列文件顺序的文件。详见 linkgit:git-diff[1] 的 `-O` 选项。如果 `diff.orderFile` 是一个相对路径名，它将被视为相对于工作树的顶层。"

#. type: Labeled list
#: en/config/diff.txt:124
#, ignore-same, no-wrap, priority:280
msgid "diff.renameLimit"
msgstr "diff.renameLimit"

#. type: Plain text
#: en/config/diff.txt:129
#, placeholders:'`-l`', priority:280
msgid "The number of files to consider in the exhaustive portion of copy/rename detection; equivalent to the 'git diff' option `-l`. If not set, the default value is currently 1000. This setting has no effect if rename detection is turned off."
msgstr "在复制/重命名检测的穷举部分要考虑的文件数量；相当于 'git diff' 选项 `-l`。如果未设置，默认值为 1000。如果重命名检测已关闭，则此设置不会有任何影响。"

#. type: Labeled list
#: en/config/diff.txt:130
#, ignore-same, no-wrap, priority:280
msgid "diff.renames"
msgstr "diff.renames"

#. type: Plain text
#: en/config/diff.txt:138
#, placeholders:'linkgit:git-diff[1]':'linkgit:git-log[1]':'linkgit:git-diff-files[1]', priority:280
msgid "Whether and how Git detects renames. If set to \"false\", rename detection is disabled. If set to \"true\", basic rename detection is enabled. If set to \"copies\" or \"copy\", Git will detect copies, as well. Defaults to true. Note that this affects only 'git diff' Porcelain like linkgit:git-diff[1] and linkgit:git-log[1], and not lower level commands such as linkgit:git-diff-files[1]."
msgstr "Git 是否以及如何检测重命名。如果设置为 \"false\"，重命名检测将被禁用。如果设置为 \"true\"，则启用基本的重命名检测。如果设置为 \"copies\" 或 \"copy\"，Git 也会检测副本。默认为 true。需要注意的是，这只会影响 linkgit:git-diff[1] 和 linkgit:git-log[1] 等上层 'git diff' 命令，而不会影响 linkgit:git-diff-files[1] 等底层命令。"

#. type: Labeled list
#: en/config/diff.txt:139
#, ignore-same, no-wrap, priority:280
msgid "diff.suppressBlankEmpty"
msgstr "diff.suppressBlankEmpty"

#. type: Plain text
#: en/config/diff.txt:142
#, priority:280
msgid "A boolean to inhibit the standard behavior of printing a space before each empty output line. Defaults to false."
msgstr "一个布尔值，用于抑制在每个空输出行前打印空格的标准行为。默认为 false。"

#. type: Labeled list
#: en/config/diff.txt:143
#, ignore-same, no-wrap, priority:280
msgid "diff.submodule"
msgstr "diff.submodule"

#. type: Plain text
#: en/config/diff.txt:150
#, placeholders:'linkgit:git-submodule[1]', priority:280
msgid "Specify the format in which differences in submodules are shown. The \"short\" format just shows the names of the commits at the beginning and end of the range. The \"log\" format lists the commits in the range like linkgit:git-submodule[1] `summary` does. The \"diff\" format shows an inline diff of the changed contents of the submodule. Defaults to \"short\"."
msgstr "指定子模块差异的显示格式。\"short\" 格式只显示范围首尾的提交名称。\"log\" 格式会列出范围内的提交，就像 linkgit:git-submodule[1] `summary` 所做的那样。\"diff\" 格式显示子模块内容的内联差异。默认为 \"short\"。"

#. type: Labeled list
#: en/config/diff.txt:151
#, ignore-same, no-wrap, priority:280
msgid "diff.wordRegex"
msgstr "diff.wordRegex"

#. type: Plain text
#: en/config/diff.txt:156
#, priority:280
msgid "A POSIX Extended Regular Expression used to determine what is a \"word\" when performing word-by-word difference calculations. Character sequences that match the regular expression are \"words\", all other characters are *ignorable* whitespace."
msgstr "POSIX 扩展正则表达式，用于在进行逐字差异计算时确定什么是 \"字\"。符合正则表达式的字符序列为 \"字\"，所有其他字符均为 *不可忽略的* 空白。"

#. type: Labeled list
#: en/config/diff.txt:157
#, no-wrap, priority:280
msgid "diff.<driver>.command"
msgstr "diff.<驱动程序>.command"

#. type: Plain text
#: en/config/diff.txt:160
#, placeholders:'linkgit:gitattributes[5]', priority:280
msgid "The custom diff driver command. See linkgit:gitattributes[5] for details."
msgstr "自定义的 diff 驱动命令。详见 linkgit:gitattributes[5]。"

#. type: Labeled list
#: en/config/diff.txt:161
#, no-wrap, priority:280
msgid "diff.<driver>.xfuncname"
msgstr "diff.<驱动程序>.xfuncname"

#. type: Plain text
#: en/config/diff.txt:165
#, placeholders:'linkgit:gitattributes[5]', priority:280
msgid "The regular expression that the diff driver should use to recognize the hunk header. A built-in pattern may also be used. See linkgit:gitattributes[5] for details."
msgstr "正则表达式，diff 驱动程序应使用该正则表达式识别块状头。也可以使用内置模式。详见 linkgit:gitattributes[5]。"

#. type: Labeled list
#: en/config/diff.txt:166
#, no-wrap, priority:280
msgid "diff.<driver>.binary"
msgstr "diff.<驱动程序>.binary"

#. type: Plain text
#: en/config/diff.txt:169
#, placeholders:'linkgit:gitattributes[5]', priority:280
msgid "Set this option to true to make the diff driver treat files as binary. See linkgit:gitattributes[5] for details."
msgstr "将此选项设为 true，可使 diff 驱动程序将文件视为二进制文件。详情参见 linkgit:gitattributes[5]。"

#. type: Labeled list
#: en/config/diff.txt:170
#, no-wrap, priority:280
msgid "diff.<driver>.textconv"
msgstr "diff.<驱动程序>.textconv"

#. type: Plain text
#: en/config/diff.txt:175
#, placeholders:'linkgit:gitattributes[5]', priority:280
msgid "The command that the diff driver should call to generate the text-converted version of a file. The result of the conversion is used to generate a human-readable diff. See linkgit:gitattributes[5] for details."
msgstr "diff 驱动程序为生成文件的文本转换版本而调用的命令。转换结果用于生成易读形式的 diff 结果。详见 linkgit:gitattributes[5]。"

#. type: Labeled list
#: en/config/diff.txt:176
#, no-wrap, priority:280
msgid "diff.<driver>.wordRegex"
msgstr "diff.<驱动程序>.wordRegex"

#. type: Plain text
#: en/config/diff.txt:180
#, placeholders:'linkgit:gitattributes[5]', priority:280
msgid "The regular expression that the diff driver should use to split words in a line. See linkgit:gitattributes[5] for details."
msgstr "正则表达式，diff 驱动程序应使用它来分割一行中的单词。详见 linkgit:gitattributes[5]。"

#. type: Labeled list
#: en/config/diff.txt:181
#, no-wrap, priority:280
msgid "diff.<driver>.cachetextconv"
msgstr "diff.<驱动程序>.cachetextconv"

#. type: Plain text
#: en/config/diff.txt:184
#, placeholders:'linkgit:gitattributes[5]', priority:280
msgid "Set this option to true to make the diff driver cache the text conversion outputs. See linkgit:gitattributes[5] for details."
msgstr "将此选项设为 true 可使 diff 驱动程序缓存文本转换输出。详见 linkgit:gitattributes[5]。"

#. type: Labeled list
#: en/config/diff.txt:187
#, ignore-same, no-wrap, priority:280
msgid "diff.indentHeuristic"
msgstr "diff.indentHeuristic"

#. type: Plain text
#: en/config/diff.txt:190
#, priority:280
msgid "Set this option to `false` to disable the default heuristics that shift diff hunk boundaries to make patches easier to read."
msgstr "将此选项设为 `false`，可禁用默认的启发式方法，该方法会移动差异块边界，使补丁更容易读取。"

#. type: Labeled list
#: en/config/diff.txt:191
#, ignore-same, no-wrap, priority:280
msgid "diff.algorithm"
msgstr "diff.algorithm"

#. type: Plain text
#: en/config/diff.txt:193 en/diff-options.txt:196
#, priority:280
msgid "Choose a diff algorithm. The variants are as follows:"
msgstr "选择差异算法。有如下可选项："

#. type: Labeled list
#: en/config/diff.txt:195 en/diff-options.txt:198
#, ignore-same, no-wrap, priority:280
msgid "`default`, `myers`"
msgstr "`default`, `myers`"

#. type: Plain text
#: en/config/diff.txt:197 en/diff-options.txt:200
#, priority:280
msgid "The basic greedy diff algorithm. Currently, this is the default."
msgstr "基本的贪婪差异算法。当前是默认设置。"

#. type: Labeled list
#: en/config/diff.txt:197 en/diff-options.txt:200
#, ignore-same, no-wrap, priority:280
msgid "`minimal`"
msgstr "`minimal`"

#. type: Plain text
#: en/config/diff.txt:200 en/diff-options.txt:177 en/diff-options.txt:203
#, priority:280
msgid "Spend extra time to make sure the smallest possible diff is produced."
msgstr "花费额外的时间以确保生成尽可能小的差异。"

#. type: Labeled list
#: en/config/diff.txt:200 en/diff-options.txt:203
#, ignore-same, no-wrap, priority:280
msgid "`patience`"
msgstr "`patience`"

#. type: Plain text
#: en/config/diff.txt:202 en/diff-options.txt:205
#, priority:280
msgid "Use \"patience diff\" algorithm when generating patches."
msgstr "使用 \"patience diff\" 算法时产生的补丁。"

#. type: Labeled list
#: en/config/diff.txt:202 en/diff-options.txt:205
#, ignore-same, no-wrap, priority:280
msgid "`histogram`"
msgstr "`histogram`"

#. type: Plain text
#: en/config/diff.txt:205 en/diff-options.txt:208
#, priority:280
msgid "This algorithm extends the patience algorithm to \"support low-occurrence common elements\"."
msgstr "该算法将耐心算法扩展为 “支持低发生率的常见元素”。"

#. type: Labeled list
#: en/config/diff.txt:208
#, ignore-same, no-wrap, priority:280
msgid "diff.wsErrorHighlight"
msgstr "diff.wsErrorHighlight"

#. type: Plain text
#: en/config/diff.txt:216
#, placeholders:'color.diff.whitespace':'`--ws-error-highlight=', priority:280
msgid "Highlight whitespace errors in the `context`, `old` or `new` lines of the diff. Multiple values are separated by comma, `none` resets previous values, `default` reset the list to `new` and `all` is a shorthand for `old,new,context`. The whitespace errors are colored with `color.diff.whitespace`. The command line option `--ws-error-highlight=<kind>` overrides this setting."
msgstr "高亮显示 diff 的 `context`、`old` 或 `new` 行中的空白错误。多个值用逗号分隔，`none` 重置以前的值，`default` 重置为 `new`，`all` 是 `old,new,context` 的缩写。空白错误用 `color.diff.whitespace`着色。命令行选项 `--ws-error-highlight=<kind>` 可覆盖此设置。"

#. type: Labeled list
#: en/config/diff.txt:217
#, ignore-same, no-wrap, priority:280
msgid "diff.colorMoved"
msgstr "diff.colorMoved"

#. type: Plain text
#: en/config/diff.txt:223
#, placeholders:'--color-moved':'linkgit:git-diff[1]', priority:280
msgid "If set to either a valid `<mode>` or a true value, moved lines in a diff are colored differently, for details of valid modes see '--color-moved' in linkgit:git-diff[1]. If simply set to true the default color mode will be used. When set to false, moved lines are not colored."
msgstr "如果设置为有效的 `<模式>` 或 true 值，diff 中移动的行会以不同的方式着色，有关有效模式的详情，请参阅 linkgit:git-diff[1] 中的 '--color-moved' 选项。如果设置为 true，则使用默认颜色模式。设为 false 时，移动的行不会着色。"

#. type: Labeled list
#: en/config/diff.txt:224
#, ignore-same, no-wrap, priority:280
msgid "diff.colorMovedWS"
msgstr "diff.colorMovedWS"

#. type: Plain text
#: en/config/diff.txt:227
#, placeholders:'diff.colorMoved':'--color-moved-ws':'linkgit:git-diff[1]', priority:280
msgid "When moved lines are colored using e.g. the `diff.colorMoved` setting, this option controls the `<mode>` how spaces are treated for details of valid modes see '--color-moved-ws' in linkgit:git-diff[1]."
msgstr "当使用 `diff.colorMoved` 等设置为移动的行着色时，此选项控制 `<模式>` 如何处理空格，有关有效模式的详情，请参阅 linkgit:git-diff[1] 中的 '--color-moved-ws' 选项。"

#. type: Labeled list
#: en/config/init.txt:1
#, no-wrap, placeholders:'init.templateDir', priority:300
msgid "init.templateDir"
msgstr "init.templateDir"

#. type: Plain text
#: en/config/init.txt:4
#, placeholders:'linkgit:git-init[1]', priority:300
msgid "Specify the directory from which templates will be copied. (See the \"TEMPLATE DIRECTORY\" section of linkgit:git-init[1].)"
msgstr "指定将要复制模板的目录。（请参阅 linkgit:git-init[1] 的 “模板目录” 部分。）"

#. type: Labeled list
#: en/config/init.txt:5
#, no-wrap, placeholders:'init.defaultBranch', priority:300
msgid "init.defaultBranch"
msgstr "init.defaultBranch"

#. type: Plain text
#: en/config/init.txt:7
#, priority:300
msgid "Allows overriding the default branch name e.g. when initializing a new repository."
msgstr "允许覆盖默认分支名称，例如在初始化新仓库时。"

#. type: Labeled list
#: en/config/merge.txt:1
#, ignore-same, no-wrap, priority:240
msgid "merge.conflictStyle"
msgstr "merge.conflictStyle"

#. type: Plain text
#: en/config/merge.txt:15
#, priority:240
msgid "Specify the style in which conflicted hunks are written out to working tree files upon merge. The default is \"merge\", which shows a `<<<<<<<` conflict marker, changes made by one side, a `=======` marker, changes made by the other side, and then a `>>>>>>>` marker. An alternate style, \"diff3\", adds a `|||||||` marker and the original text before the `=======` marker. The \"merge\" style tends to produce smaller conflict regions than diff3, both because of the exclusion of the original text, and because when a subset of lines match on the two sides, they are just pulled out of the conflict region. Another alternate style, \"zdiff3\", is similar to diff3 but removes matching lines on the two sides from the conflict region when those matching lines appear near either the beginning or end of a conflict region."
msgstr "指定合并时将冲突块写入工作目录树文件的样式。 默认样式是 \"merge\"（合并），它会显示一个 `<<<<<<<` 冲突标记、一方所做的更改、一个 `=======` 标记、另一方所做的更改，然后是一个 `>>>>>>>` 标记。 另一种样式 \"diff3\" 会在 \"=======\" 标记前添加 \"|||||||\" 标记和原文。 “合并” 样式产生的冲突区域往往比 diff3 小，一是因为不包含原始文本，二是因为当双方有子集行匹配时，这些行会被从冲突区域中拉出。 另一种样式是 \"zdiff3\"，它与 diff3 类似，但会在冲突区域的开头或结尾附近出现匹配行时，将这些匹配行从冲突区域中移除。"

#. type: Labeled list
#: en/config/merge.txt:16
#, ignore-same, no-wrap, priority:240
msgid "merge.defaultToUpstream"
msgstr "merge.defaultToUpstream"

#. type: Plain text
#: en/config/merge.txt:25
#, priority:240
msgid "If merge is called without any commit argument, merge the upstream branches configured for the current branch by using their last observed values stored in their remote-tracking branches. The values of the `branch.<current branch>.merge` that name the branches at the remote named by `branch.<current branch>.remote` are consulted, and then they are mapped via `remote.<remote>.fetch` to their corresponding remote-tracking branches, and the tips of these tracking branches are merged. Defaults to true."
msgstr "如果调用 merge 时没有任何提交参数，则通过使用存储在其远程跟踪分支中的最后观察值来合并为当前分支配置的上游分支。 `branch.<当前分支>.merge` 的值会被查阅，这些值命名了由 `branch.<当前分支>.remote` 命名的远程分支，然后通过 `remote.<远程仓库>.fetch` 将它们映射到相应的远程跟踪分支，并合并这些跟踪分支的提示。默认为 true。"

#. type: Labeled list
#: en/config/merge.txt:26
#, ignore-same, no-wrap, priority:240
msgid "merge.ff"
msgstr "merge.ff"

#. type: Plain text
#: en/config/merge.txt:35
#, placeholders:'`--no-ff`':'`--ff-only`', priority:240
msgid "By default, Git does not create an extra merge commit when merging a commit that is a descendant of the current commit. Instead, the tip of the current branch is fast-forwarded. When set to `false`, this variable tells Git to create an extra merge commit in such a case (equivalent to giving the `--no-ff` option from the command line). When set to `only`, only such fast-forward merges are allowed (equivalent to giving the `--ff-only` option from the command line)."
msgstr "默认情况下，当合并当前提交的后裔提交时，Git 不会创建一个额外的合并提交。相反，当前分支的顶端会被快进。当设置为 \"false \"时，这个变量告诉Git在这种情况下创建一个额外的合并提交（相当于在命令行中给出 `--no-ff` 选项）。当设置为`only`时，只允许这种快进合并（相当于从命令行给出`--ff-only`选项）。"

#. type: Labeled list
#: en/config/merge.txt:36
#, ignore-same, no-wrap, priority:240
msgid "merge.verifySignatures"
msgstr "merge.verifySignatures"

#. type: Plain text
#: en/config/merge.txt:39
#, placeholders:'--verify-signatures':'linkgit:git-merge[1]', priority:240
msgid "If true, this is equivalent to the --verify-signatures command line option. See linkgit:git-merge[1] for details."
msgstr "如果为真，这等同于 --verify-signatures 命令行选项。详见 linkgit:git-merge[1]。"

#. type: Labeled list
#: en/config/merge.txt:42
#, ignore-same, no-wrap, priority:240
msgid "merge.renameLimit"
msgstr "merge.renameLimit"

#. type: Plain text
#: en/config/merge.txt:49
#, placeholders:'diff.renameLimit':'merge.renameLimit':'diff.renameLimit', priority:240
msgid "The number of files to consider in the exhaustive portion of rename detection during a merge. If not specified, defaults to the value of diff.renameLimit. If neither merge.renameLimit nor diff.renameLimit are specified, currently defaults to 7000. This setting has no effect if rename detection is turned off."
msgstr "合并过程中重命名检测穷举部分要考虑的文件数量。 如果未指定，默认值为 diff.renameLimit 的值。 如果既未指定 merge.renameLimit 也未指定 diff.renameLimit，则默认值为 7000。 如果重命名检测已关闭，则此设置无效。"

#. type: Labeled list
#: en/config/merge.txt:50
#, ignore-same, no-wrap, priority:240
msgid "merge.renames"
msgstr "merge.renames"

#. type: Plain text
#: en/config/merge.txt:54
#, placeholders:'diff.renames', priority:240
msgid "Whether Git detects renames. If set to \"false\", rename detection is disabled. If set to \"true\", basic rename detection is enabled. Defaults to the value of diff.renames."
msgstr "Git是否会检测重名。 如果设置为 \"false\"，重名检测被禁用。如果设置为 \"true\"，则启用基本重名检测。 默认为 diff.renames 的值。"

#. type: Labeled list
#: en/config/merge.txt:55
#, ignore-same, no-wrap, priority:240
msgid "merge.directoryRenames"
msgstr "merge.directoryRenames"

#. type: Plain text
#: en/config/merge.txt:67
#, placeholders:'merge.directoryRenames':'merge.renames':'merge.directoryRenames', priority:240
msgid "Whether Git detects directory renames, affecting what happens at merge time to new files added to a directory on one side of history when that directory was renamed on the other side of history. If merge.directoryRenames is set to \"false\", directory rename detection is disabled, meaning that such new files will be left behind in the old directory. If set to \"true\", directory rename detection is enabled, meaning that such new files will be moved into the new directory. If set to \"conflict\", a conflict will be reported for such paths. If merge.renames is false, merge.directoryRenames is ignored and treated as false. Defaults to \"conflict\"."
msgstr "Git是否检测目录重名，影响在合并时对历史一侧的目录被重命名时加入的新文件的处理。 如果merge.directoryRenames设置为 \"false\"，目录重名检测将被禁用，这意味着这些新文件将被遗留在旧目录中。 如果设置为 \"true\"，目录重名检测被启用，意味着这样的新文件将被移到新目录中。 如果设置为 \"冲突\"，将报告此类路径的冲突。 如果merge.renames为false，merge.directoryRenames将被忽略并被视为false。 默认为 \"冲突\"。"

#. type: Labeled list
#: en/config/merge.txt:68
#, ignore-same, no-wrap, priority:240
msgid "merge.renormalize"
msgstr "merge.renormalize"

#. type: Plain text
#: en/config/merge.txt:77
#, placeholders:'linkgit:gitattributes[5]', priority:240
msgid "Tell Git that canonical representation of files in the repository has changed over time (e.g. earlier commits record text files with CRLF line endings, but recent ones use LF line endings). In such a repository, Git can convert the data recorded in commits to a canonical form before performing a merge to reduce unnecessary conflicts. For more information, see section \"Merging branches with differing checkin/checkout attributes\" in linkgit:gitattributes[5]."
msgstr "告诉 Git 仓库中文件的正则表示法随着时间的推移而改变（例如，早期的提交记录文本文件使用 CRLF 行结尾，但最近的提交使用 LF 行结尾）。 在这样的仓库中，Git 可以在执行合并之前将提交的数据转换为规范的形式，以减少不必要的冲突。 更多信息，请参阅 linkgit:gitattributes[5] 中的 \"合并具有不同签入/签出属性的分支 \"一节。"

#. type: Labeled list
#: en/config/merge.txt:78
#, ignore-same, no-wrap, priority:240
msgid "merge.stat"
msgstr "merge.stat"

#. type: Plain text
#: en/config/merge.txt:81
#, placeholders:'ORIG_HEAD', priority:240
msgid "Whether to print the diffstat between ORIG_HEAD and the merge result at the end of the merge. True by default."
msgstr "是否在合并结束后打印ORIG_HEAD和合并结果之间的差异统计表。 默认为 \"真\"。"

#. type: Labeled list
#: en/config/merge.txt:82
#, ignore-same, no-wrap, priority:240
msgid "merge.autoStash"
msgstr "merge.autoStash"

#. type: Plain text
#: en/config/merge.txt:91
#, placeholders:'`--no-autostash`':'`--autostash`':'linkgit:git-merge[1]', priority:240
msgid "When set to true, automatically create a temporary stash entry before the operation begins, and apply it after the operation ends. This means that you can run merge on a dirty worktree. However, use with care: the final stash application after a successful merge might result in non-trivial conflicts. This option can be overridden by the `--no-autostash` and `--autostash` options of linkgit:git-merge[1]. Defaults to false."
msgstr "当设置为 \"true \"时，在操作开始前自动创建一个临时的储藏库条目，并在操作结束后应用它。 这意味着你可以在一个肮脏的工作树上运行merge。 然而，要小心使用：在成功的合并之后，最后的储藏库应用可能会导致非实质性的冲突。 这个选项可以被 linkgit:git-merge[1] 的 `--no-autostash` 和 `--autostash` 选项覆盖。 默认为false。"

#. type: Labeled list
#: en/config/merge.txt:92
#, ignore-same, no-wrap, priority:240
msgid "merge.tool"
msgstr "merge.tool"

#. type: Plain text
#: en/config/merge.txt:97
#, placeholders:'linkgit:git-mergetool[1]', priority:240
msgid "Controls which merge tool is used by linkgit:git-mergetool[1]. The list below shows the valid built-in values. Any other value is treated as a custom merge tool and requires that a corresponding mergetool.<tool>.cmd variable is defined."
msgstr "控制linkgit:git-mergetool[1]使用哪个合并工具。 下面的列表显示了有效的内置值。 任何其他值都被视为自定义的合并工具，需要定义一个相应的mergetool.<tool>.cmd变量。"

#. type: Labeled list
#: en/config/merge.txt:98
#, ignore-same, no-wrap, priority:240
msgid "merge.guitool"
msgstr "merge.guitool"

#. type: Plain text
#: en/config/merge.txt:103
#, placeholders:'linkgit:git-mergetool[1]':'--gui', priority:240
msgid "Controls which merge tool is used by linkgit:git-mergetool[1] when the -g/--gui flag is specified. The list below shows the valid built-in values. Any other value is treated as a custom merge tool and requires that a corresponding mergetool.<guitool>.cmd variable is defined."
msgstr "控制linkgit:git-mergetool[1]在指定-g/--gui标志时使用的合并工具。下面的列表显示了有效的内置值。 任何其他值都被视为自定义的合并工具，需要定义一个相应的mergetool.<guitool>.cmd变量。"

#. type: Labeled list
#: en/config/merge.txt:106
#, ignore-same, no-wrap, priority:240
msgid "merge.verbosity"
msgstr "merge.verbosity"

#. type: Plain text
#: en/config/merge.txt:113
#, placeholders:'GIT_MERGE_VERBOSITY', priority:240
msgid "Controls the amount of output shown by the recursive merge strategy. Level 0 outputs nothing except a final error message if conflicts were detected. Level 1 outputs only conflicts, 2 outputs conflicts and file changes. Level 5 and above outputs debugging information. The default is level 2. Can be overridden by the `GIT_MERGE_VERBOSITY` environment variable."
msgstr "控制递归合并策略所显示的输出量。 0级除了在检测到冲突时有一个最终的错误信息外，什么都不输出。1级只输出冲突，2级输出冲突和文件变化。 5级及以上输出调试信息。 默认是第2级。 可以通过`GIT_MERGE_VERBOSITY`环境变量覆盖。"

#. type: Labeled list
#: en/config/merge.txt:114
#, no-wrap, priority:240
msgid "merge.<driver>.name"
msgstr "合并.<driver>.name"

#. type: Plain text
#: en/config/merge.txt:117
#, placeholders:'linkgit:gitattributes[5]', priority:240
msgid "Defines a human-readable name for a custom low-level merge driver. See linkgit:gitattributes[5] for details."
msgstr "为自定义的低级合并驱动定义了一个具有可读性的名字。 详情见 linkgit:gitattributes[5]。"

#. type: Labeled list
#: en/config/merge.txt:118
#, no-wrap, priority:240
msgid "merge.<driver>.driver"
msgstr "merge.<driver>.driver"

#. type: Plain text
#: en/config/merge.txt:121
#, placeholders:'linkgit:gitattributes[5]', priority:240
msgid "Defines the command that implements a custom low-level merge driver. See linkgit:gitattributes[5] for details."
msgstr "定义实现自定义低级合并驱动程序的命令。详见链接 linkgit:gitattributes[5]。"

#. type: Labeled list
#: en/config/merge.txt:122
#, no-wrap, priority:240
msgid "merge.<driver>.recursive"
msgstr "merge.<驱动程序>.recursive"

#. type: Plain text
#: en/config/merge.txt:125
#, placeholders:'linkgit:gitattributes[5]', priority:240
msgid "Names a low-level merge driver to be used when performing an internal merge between common ancestors. See linkgit:gitattributes[5] for details."
msgstr "在执行共同祖先之间的内部合并时，命名一个低级别的合并驱动。 详情见 linkgit:gitattributes[5]。"

#. type: Labeled list
#: en/config/fmt-merge-msg.txt:1
#, ignore-same, no-wrap, priority:240
msgid "merge.branchdesc"
msgstr "merge.branchdesc"

#. type: Plain text
#: en/config/fmt-merge-msg.txt:5
#, priority:240
msgid "In addition to branch names, populate the log message with the branch description text associated with them. Defaults to false."
msgstr "除了分支名称之外，还使用与其关联的分支描述文本填充日志消息。默认为 false。"

#. type: Labeled list
#: en/config/fmt-merge-msg.txt:6
#, ignore-same, no-wrap, priority:240
msgid "merge.log"
msgstr "merge.log"

#. type: Plain text
#: en/config/fmt-merge-msg.txt:11
#, priority:240
msgid "In addition to branch names, populate the log message with at most the specified number of one-line descriptions from the actual commits that are being merged. Defaults to false, and true is a synonym for 20."
msgstr "除了分支名称外，在日志信息中最多加入指定数量的被合并的实际提交的单行描述。 默认为 false，true 是2 0 的同义词。"

#. type: Labeled list
#: en/config/fmt-merge-msg.txt:12
#, ignore-same, no-wrap, priority:240
msgid "merge.suppressDest"
msgstr "merge.suppressDest"

#. type: Plain text
#: en/config/fmt-merge-msg.txt:18
#, priority:240
msgid "By adding a glob that matches the names of integration branches to this multi-valued configuration variable, the default merge message computed for merges into these integration branches will omit \"into <branch name>\" from its title."
msgstr "通过向这个多值配置变量添加一个匹配集成分支名称的通配符，为合并到这些集成分支计算的默认合并消息将在其标题中省略 \"into <分支名>\"。"

#. type: Plain text
#: en/config/fmt-merge-msg.txt:22
#, placeholders:'merge.suppressDest', priority:240
msgid "An element with an empty value can be used to clear the list of globs accumulated from previous configuration entries. When there is no `merge.suppressDest` variable defined, the default value of `master` is used for backward compatibility."
msgstr "一个空值的元素可以用来清除以前配置项积累的globs列表。 当没有定义`merge.suppressDest`变量时，为了向后兼容，会使用默认值`master`。"

#. type: Title -
#: en/date-formats.txt:2
#, no-wrap, priority:280
msgid "DATE FORMATS"
msgstr "日期格式"

#. type: Plain text
#: en/date-formats.txt:6
#, placeholders:'GIT_AUTHOR_DATE':'GIT_COMMITTER_DATE', priority:280
msgid "The `GIT_AUTHOR_DATE` and `GIT_COMMITTER_DATE` environment variables support the following date formats:"
msgstr "`GIT_AUTHOR_DATE`, `GIT_COMMITTER_DATE` 环境变量："

#. type: Labeled list
#: en/date-formats.txt:7
#, no-wrap, priority:280
msgid "Git internal format"
msgstr "Git 内部格式"

#. type: Plain text
#: en/date-formats.txt:12
#, priority:280
msgid "It is `<unix-timestamp> <time-zone-offset>`, where `<unix-timestamp>` is the number of seconds since the UNIX epoch. `<time-zone-offset>` is a positive or negative offset from UTC. For example CET (which is 1 hour ahead of UTC) is `+0100`."
msgstr "`<unix 时间戳> <时区偏移量>`，其中 `<unix 时间戳>` 是自 UNIX epoch 以来的秒数。 `<时区偏移量>` 是相对于 UTC 的正或负偏移量。例如，CET（比 UTC 提前1小时）为 `+0100`。"

#. type: Labeled list
#: en/date-formats.txt:13
#, no-wrap, priority:280
msgid "RFC 2822"
msgstr "RFC 2822"

#. type: Plain text
#: en/date-formats.txt:16
#, priority:280
msgid "The standard email format as described by RFC 2822, for example `Thu, 07 Apr 2005 22:13:13 +0200`."
msgstr "由 RFC 2822 描述的标准电子邮件格式，例如 `Thu, 07 Apr 2005 22:13:13 +0200`。"

#. type: Labeled list
#: en/date-formats.txt:17
#, no-wrap, priority:280
msgid "ISO 8601"
msgstr "ISO 8601"

#. type: Plain text
#: en/date-formats.txt:23
#, priority:280
msgid "Time and date specified by the ISO 8601 standard, for example `2005-04-07T22:13:13`. The parser accepts a space instead of the `T` character as well. Fractional parts of a second will be ignored, for example `2005-04-07T22:13:13.019` will be treated as `2005-04-07T22:13:13`."
msgstr "按 ISO 8601 标准指定的时间和日期，例如 `2005-04-07T22:13:13`。解析器也接受空格代替 `T` 字符。秒的小数部分将被忽略，例如 `2005-04-07T22:13:13.019` 将被视为 `2005-04-07T22:13:13` 。"

#. type: Plain text
#: en/date-formats.txt:26
#, priority:280
msgid "In addition, the date part is accepted in the following formats: `YYYY.MM.DD`, `MM/DD/YYYY` and `DD.MM.YYYY`."
msgstr "此外，日期部分还接受以下格式：`YYYY.MM.DD`，`MM/DD/YYYY` 和 `DD.MM.YYYY`。"

#. type: Plain text
#: en/date-formats.txt:31
#, placeholders:'`--date`', priority:280
msgid "In addition to recognizing all date formats above, the `--date` option will also try to make sense of other, more human-centric date formats, such as relative dates like \"yesterday\" or \"last Friday at noon\"."
msgstr "除了识别上述所有日期格式外，`--date` 选项还将尝试理解其它非标准化的日期格式，如 “昨天” 或 “上周五中午” 等相对日期。"

#. type: Title -
#: en/diff-format.txt:2
#, no-wrap, priority:280
msgid "Raw output format"
msgstr "原始输出格式"

#. type: Plain text
#: en/diff-format.txt:6
#, placeholders:'git-diff-index':'git-diff-tree':'git-diff-files':'--raw', priority:280
msgid "The raw output format from \"git-diff-index\", \"git-diff-tree\", \"git-diff-files\" and \"git diff --raw\" are very similar."
msgstr "\"git-diff-index\"，\"git-diff-tree\"，\"git-diff-files\" 和 \"git diff --raw\" 的原始输出格式非常相似。"

#. type: Plain text
#: en/diff-format.txt:9
#, priority:280
msgid "These commands all compare two sets of things; what is compared differs:"
msgstr "这些命令都比较两组事物。但比较的内容有所不同："

#. type: Labeled list
#: en/diff-format.txt:10
#, no-wrap, placeholders:'git-diff-index', priority:280
msgid "git-diff-index <tree-ish>"
msgstr "git-diff-index <目录树对象>"

#. type: Plain text
#: en/diff-format.txt:12
#, priority:280
msgid "compares the <tree-ish> and the files on the filesystem."
msgstr "比较 <目录树对象> 和文件系统上的文件。"

#. type: Labeled list
#: en/diff-format.txt:13
#, no-wrap, placeholders:'git-diff-index':'--cached', priority:280
msgid "git-diff-index --cached <tree-ish>"
msgstr "git-diff-index --cached <目录树对象>"

#. type: Plain text
#: en/diff-format.txt:15
#, priority:280
msgid "compares the <tree-ish> and the index."
msgstr "比较 <目录树对象> 和索引。"

#. type: Labeled list
#: en/diff-format.txt:16
#, ignore-ellipsis, no-wrap, placeholders:'git-diff-tree', priority:280
msgid "git-diff-tree [-r] <tree-ish-1> <tree-ish-2> [<pattern>...]"
msgstr "git-diff-tree [-r] <目录树对象 1> <目录树对象 2> [<模式>...]"

#. type: Plain text
#: en/diff-format.txt:18
#, priority:280
msgid "compares the trees named by the two arguments."
msgstr "比较由两个参数传递的目录树。"

#. type: Labeled list
#: en/diff-format.txt:19
#, ignore-ellipsis, no-wrap, placeholders:'git-diff-files', priority:280
msgid "git-diff-files [<pattern>...]"
msgstr "git-diff-files [<模式>...]"

#. type: Plain text
#: en/diff-format.txt:21
#, priority:280
msgid "compares the index and the files on the filesystem."
msgstr "比较索引和文件系统上的文件。"

#. type: Plain text
#: en/diff-format.txt:25
#, placeholders:'git-diff-tree', priority:280
msgid "The \"git-diff-tree\" command begins its output by printing the hash of what is being compared. After that, all the commands print one output line per changed file."
msgstr "\"git-diff-tree\" 命令在最开始输出被比较对象的哈希值。之后，所有命令都会为每个更改的文件打印一个输出行。"

#. type: Plain text
#: en/diff-format.txt:27
#, priority:280
msgid "An output line is formatted this way:"
msgstr "输出行的格式如下："

#. type: delimited block -
#: en/diff-format.txt:35
#, no-wrap, priority:280
msgid ""
"in-place edit  :100644 100644 bcd1234 0123456 M file0\n"
"copy-edit      :100644 100644 abcd123 1234567 C68 file1 file2\n"
"rename-edit    :100644 100644 abcd123 1234567 R86 file1 file3\n"
"create         :000000 100644 0000000 1234567 A file4\n"
"delete         :100644 000000 1234567 0000000 D file5\n"
"unmerged       :000000 000000 0000000 0000000 U file6\n"
msgstr ""
"in-place edit  :100644 100644 bcd1234 0123456 M file0\n"
"copy-edit      :100644 100644 abcd123 1234567 C68 file1 file2\n"
"rename-edit    :100644 100644 abcd123 1234567 R86 file1 file3\n"
"create         :000000 100644 0000000 1234567 A file4\n"
"delete         :100644 000000 1234567 0000000 D file5\n"
"unmerged       :000000 000000 0000000 0000000 U file6\n"

#. type: Plain text
#: en/diff-format.txt:38
#, priority:280
msgid "That is, from the left to the right:"
msgstr "含义如下，从左到右依次："

#. type: Plain text
#: en/diff-format.txt:40
#, priority:280
msgid "a colon."
msgstr "冒号。"

#. type: Plain text
#: en/diff-format.txt:41
#, priority:280
msgid "mode for \"src\"; 000000 if creation or unmerged."
msgstr "\"src\"（源文件）的模式；如果是新建或是未合并的，则为 000000。"

#. type: Plain text
#: en/diff-format.txt:42 en/diff-format.txt:44 en/diff-format.txt:46 en/diff-format.txt:48
#, priority:280
msgid "a space."
msgstr "空格。"

#. type: Plain text
#: en/diff-format.txt:43
#, priority:280
msgid "mode for \"dst\"; 000000 if deletion or unmerged."
msgstr "\"dst\" (目标文件）的模式；如果被删除或未合并则为 000000。"

#. type: Plain text
#: en/diff-format.txt:45
#, priority:280
msgid "sha1 for \"src\"; 0\\{40\\} if creation or unmerged."
msgstr "\"src\"（源文件）的 sha1 值；如果为新建或未合并则为 0\\{40\\}。"

#. type: Plain text
#: en/diff-format.txt:47
#, priority:280
msgid "sha1 for \"dst\"; 0\\{40\\} if deletion, unmerged or \"work tree out of sync with the index\"."
msgstr "sha1 表示 \"dst\"（目标文件）；0\\{40\\} 表示删除、未合并或 “工作目录树与索引不同步”。"

#. type: Plain text
#: en/diff-format.txt:49
#, priority:280
msgid "status, followed by optional \"score\" number."
msgstr "状态，在可选值 \"score\" 之后。"

#. type: Plain text
#: en/diff-format.txt:50
#, placeholders:'`-z`', priority:280
msgid "a tab or a NUL when `-z` option is used."
msgstr "当使用 `-z` 选项时为制表符或 NUL。"

#. type: Plain text
#: en/diff-format.txt:51
#, priority:280
msgid "path for \"src\""
msgstr "\"src\" 的路径"

#. type: Plain text
#: en/diff-format.txt:52
#, placeholders:'`-z`', priority:280
msgid "a tab or a NUL when `-z` option is used; only exists for C or R."
msgstr "使用 `-z` 选项时为制表符或 NUL；仅当状态为 C 或 R 时存在。"

#. type: Plain text
#: en/diff-format.txt:53
#, priority:280
msgid "path for \"dst\"; only exists for C or R."
msgstr "\"dst\" 的路径；仅当状态为 C 或 R 时存在。"

#. type: Plain text
#: en/diff-format.txt:54
#, placeholders:'`-z`', priority:280
msgid "an LF or a NUL when `-z` option is used, to terminate the record."
msgstr "当使用 `-z` 选项时为 LF 或 NUL，用于终止记录。"

#. type: Plain text
#: en/diff-format.txt:56
#, priority:280
msgid "Possible status letters are:"
msgstr "可能的状态字母为："

#. type: Plain text
#: en/diff-format.txt:58
#, priority:280
msgid "A: addition of a file"
msgstr "A：文件新增部分"

#. type: Plain text
#: en/diff-format.txt:59
#, priority:280
msgid "C: copy of a file into a new one"
msgstr "C：复制到一个新文件"

#. type: Plain text
#: en/diff-format.txt:60
#, priority:280
msgid "D: deletion of a file"
msgstr "D：文件删除部分"

#. type: Plain text
#: en/diff-format.txt:61
#, priority:280
msgid "M: modification of the contents or mode of a file"
msgstr "M：文件内容或文件模式修改"

#. type: Plain text
#: en/diff-format.txt:62
#, priority:280
msgid "R: renaming of a file"
msgstr "R：文件重命名"

#. type: Plain text
#: en/diff-format.txt:63
#, priority:280
msgid "T: change in the type of the file (regular file, symbolic link or submodule)"
msgstr "T：文件类型改变"

#. type: Plain text
#: en/diff-format.txt:65
#, priority:280
msgid "U: file is unmerged (you must complete the merge before it can be committed)"
msgstr "U：文件未合并（你必须在提交之前完成合并）"

#. type: Plain text
#: en/diff-format.txt:66
#, priority:280
msgid "X: \"unknown\" change type (most probably a bug, please report it)"
msgstr "X：\"unknown\"（未知）更改类型（可能为错误，请报告）"

#. type: Plain text
#: en/diff-format.txt:71
#, priority:280
msgid "Status letters C and R are always followed by a score (denoting the percentage of similarity between the source and target of the move or copy). Status letter M may be followed by a score (denoting the percentage of dissimilarity) for file rewrites."
msgstr "状态字母 C 和 R 后面总是一个分数（表示移动或复制的源与目标之间的相似性百分比）。状态字母 M 后面可能有文件重写的分数（表示相异百分比）。"

#. type: Plain text
#: en/diff-format.txt:74
#, priority:280
msgid "The sha1 for \"dst\" is shown as all 0's if a file on the filesystem is out of sync with the index."
msgstr "如果文件是文件系统上的新文件，并且与索引不同步，则 <sha1> 将显示为全 0。"

#. type: Labeled list
#: en/diff-format.txt:76 en/git-svn.txt:499 en/git-svn.txt:539
#, no-wrap, priority:280
msgid "Example:"
msgstr "例如："

#. type: delimited block -
#: en/diff-format.txt:79
#, no-wrap, priority:280
msgid ":100644 100644 5be4a4a 0000000 M file.c\n"
msgstr ":100644 100644 5be4a4a 0000000 M file.c\n"

#. type: Plain text
#: en/diff-format.txt:85 en/git-ls-files.txt:257 en/git-ls-tree.txt:134
#, placeholders:'`-z`':'core.quotePath':'linkgit:git-config[1]':'`-z`', priority:280
msgid "Without the `-z` option, pathnames with \"unusual\" characters are quoted as explained for the configuration variable `core.quotePath` (see linkgit:git-config[1]). Using `-z` the filename is output verbatim and the line is terminated by a NUL byte."
msgstr "如果没有 `-z` 选项，带 “不常见” 字符的路径名会被加上引号，正如配置变量 `core.quotePath` 所解释的那样（参见 linkgit:git-config[1]）。 使用 `-z` 选项，文件名将被逐字输出，并以 NUL 字节结束。"

#. type: Title -
#: en/diff-format.txt:87
#, no-wrap, priority:280
msgid "diff format for merges"
msgstr "合并的差异格式"

#. type: Plain text
#: en/diff-format.txt:93
#, placeholders:'git-diff-tree':'git-diff-files':'git-diff':'--raw':'`-c`':'`--cc`', priority:280
msgid "\"git-diff-tree\", \"git-diff-files\" and \"git-diff --raw\" can take `-c` or `--cc` option to generate diff output also for merge commits. The output differs from the format described above in the following way:"
msgstr "\"git-diff-tree\"、\"git-diff-files\" 和 \"git-diff --raw\" 可以使用 `-c` 或 `--cc` 选项来生成差异输出，也可以用于合并提交。其输出与上面描述的格式有以下不同："

#. type: Plain text
#: en/diff-format.txt:95
#, priority:280
msgid "there is a colon for each parent"
msgstr "每个父提交都有一个冒号"

#. type: Plain text
#: en/diff-format.txt:96
#, priority:280
msgid "there are more \"src\" modes and \"src\" sha1"
msgstr "有更多的 \"src\" 文件模式和 \"src\" sha1"

#. type: Plain text
#: en/diff-format.txt:97
#, priority:280
msgid "status is concatenated status characters for each parent"
msgstr "状态是每个父提交的状态字符的合并"

#. type: Plain text
#: en/diff-format.txt:98
#, priority:280
msgid "no optional \"score\" number"
msgstr "无可选的分数（\"score\"）数字"

#. type: Plain text
#: en/diff-format.txt:99
#, priority:280
msgid "tab-separated pathname(s) of the file"
msgstr "以制表符分隔的文件路径名"

#. type: Plain text
#: en/diff-format.txt:104
#, placeholders:'`-c`':'`--cc`':'`--combined-all-paths`', priority:280
msgid "For `-c` and `--cc`, only the destination or final path is shown even if the file was renamed on any side of history. With `--combined-all-paths`, the name of the path in each parent is shown followed by the name of the path in the merge commit."
msgstr "对于 `-c` 和 `--cc` 选项，即使文件在历史中的任何一边被重命名，也只显示目标路径或最终路径。使用 `--combined-all-paths` 选项，则每个父提交中的路径名称会在合并提交中的路径名称后面显示。"

#. type: Plain text
#: en/diff-format.txt:106
#, placeholders:'`-c`':'`--cc`':'`--combined-all-paths`', priority:280
msgid "Examples for `-c` and `--cc` without `--combined-all-paths`:"
msgstr "以下为带 `-c` 和 `--cc` 选项且不带 `--combined-all-paths` 选项的示例："

#. type: delimited block -
#: en/diff-format.txt:110
#, no-wrap, placeholders:'bar.sh', priority:280
msgid ""
"::100644 100644 100644 fabadb8 cc95eb0 4866510 MM\tdesc.c\n"
"::100755 100755 100755 52b7a2d 6d1ac04 d2ac7d7 RM\tbar.sh\n"
"::100644 100644 100644 e07d6c5 9042e82 ee91881 RR\tphooey.c\n"
msgstr ""
"::100644 100644 100644 fabadb8 cc95eb0 4866510 MM\tdesc.c\n"
"::100755 100755 100755 52b7a2d 6d1ac04 d2ac7d7 RM\tbar.sh\n"
"::100644 100644 100644 e07d6c5 9042e82 ee91881 RR\tphooey.c\n"

#. type: Plain text
#: en/diff-format.txt:113
#, placeholders:'`--combined-all-paths`':'`-c`':'`--cc`', priority:280
msgid "Examples when `--combined-all-paths` added to either `-c` or `--cc`:"
msgstr "以下为使用 `--combined-all-paths` 选项且使用 `-c` 或 `--cc` 选项的示例:"

#. type: delimited block -
#: en/diff-format.txt:118
#, no-wrap, placeholders:'foo.sh':'bar.sh':'bar.sh', priority:280
msgid ""
"::100644 100644 100644 fabadb8 cc95eb0 4866510 MM\tdesc.c\tdesc.c\tdesc.c\n"
"::100755 100755 100755 52b7a2d 6d1ac04 d2ac7d7 RM\tfoo.sh\tbar.sh\tbar.sh\n"
"::100644 100644 100644 e07d6c5 9042e82 ee91881 RR\tfooey.c\tfuey.c\tphooey.c\n"
msgstr ""
"::100644 100644 100644 fabadb8 cc95eb0 4866510 MM\tdesc.c\tdesc.c\tdesc.c\n"
"::100755 100755 100755 52b7a2d 6d1ac04 d2ac7d7 RM\tfoo.sh\tbar.sh\tbar.sh\n"
"::100644 100644 100644 e07d6c5 9042e82 ee91881 RR\tfooey.c\tfuey.c\tphooey.c\n"

#. type: Plain text
#: en/diff-format.txt:122
#, priority:280
msgid "Note that 'combined diff' lists only files which were modified from all parents."
msgstr "请注意 'combined diff' 只列出了从所有父提交中修改过的文件。"

#. type: Title -
#: en/diff-format.txt:128
#, no-wrap, priority:280
msgid "other diff formats"
msgstr "其他差异格式"

#. type: Plain text
#: en/diff-format.txt:134
#, placeholders:'`--summary`':'`--stat`':'`-p`', priority:280
msgid "The `--summary` option describes newly added, deleted, renamed and copied files. The `--stat` option adds diffstat(1) graph to the output. These options can be combined with other options, such as `-p`, and are meant for human consumption."
msgstr "`--summary` 选项描述新添加、删除、重命名和复制的文件。`--stat` 选项将 diffstat(1) 图添加到输出中。这些选项可以与其他选项组合在一起，如 `-p` 选项可以提高可读性。"

#. type: Plain text
#: en/diff-format.txt:139
#, placeholders:'`--stat`', priority:280
msgid "When showing a change that involves a rename or a copy, `--stat` output formats the pathnames compactly by combining common prefix and suffix of the pathnames. For example, a change that moves `arch/i386/Makefile` to `arch/x86/Makefile` while modifying 4 lines will be shown like this:"
msgstr "当显示一个涉及到重命名或复制的更改时，`--stat` 输出会将路径名的前缀和后缀结合在一起，会以较紧凑的方式显示。例如，将 `arch/i386/Makefile` 移动到 `arch/x86/Makefile`，同时修改了 4 行，就会显示出这样的变化："

#. type: delimited block -
#: en/diff-format.txt:142
#, no-wrap, priority:280
msgid "arch/{i386 => x86}/Makefile    |   4 +--\n"
msgstr "arch/{i386 => x86}/Makefile    |   4 +--\n"

#. type: Plain text
#: en/diff-format.txt:147
#, placeholders:'`--numstat`':'`--numstat`', priority:280
msgid "The `--numstat` option gives the diffstat(1) information but is designed for easier machine consumption. An entry in `--numstat` output looks like this:"
msgstr "`--numstat` 选项提供了 diffstat(1) 的信息，但其是为了方便程序使用而设计的。`--numstat` 输出中的一个条目如下："

#. type: delimited block -
#: en/diff-format.txt:151
#, no-wrap, priority:280
msgid ""
"1\t2\tREADME\n"
"3\t1\tarch/{i386 => x86}/Makefile\n"
msgstr ""
"1\t2\tREADME\n"
"3\t1\tarch/{i386 => x86}/Makefile\n"

#. type: Plain text
#: en/diff-format.txt:154
#, priority:280
msgid "That is, from left to right:"
msgstr "从左至右依次是："

#. type: Plain text
#: en/diff-format.txt:156 en/diff-format.txt:172
#, priority:280
msgid "the number of added lines;"
msgstr "添加的行数；"

#. type: Plain text
#: en/diff-format.txt:157 en/diff-format.txt:159 en/diff-format.txt:173 en/diff-format.txt:175
#, priority:280
msgid "a tab;"
msgstr "制表符；"

#. type: Plain text
#: en/diff-format.txt:158 en/diff-format.txt:174
#, priority:280
msgid "the number of deleted lines;"
msgstr "已删除行数;"

#. type: Plain text
#: en/diff-format.txt:160
#, priority:280
msgid "pathname (possibly with rename/copy information);"
msgstr "路径名（可能有重命名/复制信息）；"

#. type: Plain text
#: en/diff-format.txt:161
#, priority:280
msgid "a newline."
msgstr "换行符。"

#. type: Plain text
#: en/diff-format.txt:163
#, placeholders:'`-z`', priority:280
msgid "When `-z` output option is in effect, the output is formatted this way:"
msgstr "当 `-z` 输出选项生效时，输出的格式如下："

#. type: delimited block -
#: en/diff-format.txt:167
#, no-wrap, priority:280
msgid ""
"1\t2\tREADME NUL\n"
"3\t1\tNUL arch/i386/Makefile NUL arch/x86/Makefile NUL\n"
msgstr ""
"1\t2\tREADME NUL\n"
"3\t1\tNUL arch/i386/Makefile NUL arch/x86/Makefile NUL\n"

#. type: Plain text
#: en/diff-format.txt:170
#, priority:280
msgid "That is:"
msgstr "依次是："

#. type: Plain text
#: en/diff-format.txt:176 en/diff-format.txt:178
#, priority:280
msgid "a NUL (only exists if renamed/copied);"
msgstr "NUL（仅在重命名/复制时存在）；"

#. type: Plain text
#: en/diff-format.txt:177
#, priority:280
msgid "pathname in preimage;"
msgstr "完整路径名；"

#. type: Plain text
#: en/diff-format.txt:179
#, priority:280
msgid "pathname in postimage (only exists if renamed/copied);"
msgstr "完整路径名（仅在重命名/复制时存在）；"

#. type: Plain text
#: en/diff-format.txt:180
#, priority:280
msgid "a NUL."
msgstr "一个 NUL 字符。"

#. type: Plain text
#: en/diff-format.txt:185
#, priority:280
msgid "The extra `NUL` before the preimage path in renamed case is to allow scripts that read the output to tell if the current record being read is a single-path record or a rename/copy record without reading ahead. After reading added and deleted lines, reading up to `NUL` would yield the pathname, but if that is `NUL`, the record will show two paths."
msgstr "在重命名的情况下，完整路径前多出的 `NUL` 为了让读取输出的脚本能够判断，当前被读取的记录是单路径记录还是重命名/复制记录，而不需要提前读取。在读完增删行数后，读至 `NUL` 会得到路径名，但如果先读到 `NUL`，记录将显示两个路径。"

#. type: Title -
#: en/diff-generate-patch.txt:3
#, no-wrap, priority:280
msgid "Generating patch text with -p"
msgstr "使用选项 `-p` 生成补丁文本"

#. type: Plain text
#: en/diff-generate-patch.txt:16
#, placeholders:'linkgit:git-diff[1]':'linkgit:git-log[1]':'linkgit:git-show[1]':'linkgit:git-diff-index[1]':'linkgit:git-diff-tree[1]':'linkgit:git-diff-files[1]':'`-p`':'GIT_EXTERNAL_DIFF':'GIT_DIFF_OPTS':'linkgit:git[1]':'linkgit:gitattributes[5]', priority:280
msgid "Running linkgit:git-diff[1], linkgit:git-log[1], linkgit:git-show[1], linkgit:git-diff-index[1], linkgit:git-diff-tree[1], or linkgit:git-diff-files[1] with the `-p` option produces patch text. You can customize the creation of patch text via the `GIT_EXTERNAL_DIFF` and the `GIT_DIFF_OPTS` environment variables (see linkgit:git[1]), and the `diff` attribute (see linkgit:gitattributes[5])."
msgstr "使用 `-p` 选项运行 linkgit:git-diff[1]、linkgit:git-log[1]、linkgit:git-show[1]、linkgit:git-diff-index[1]、linkgit:git-diff-tree[1] 或 linkgit:git-diff-files[1] 会生成补丁文本。 你可以通过 `GIT_EXTERNAL_DIFF` 和 `GIT_DIFF_OPTS` 环境变量（参见 linkgit:git[1]），以及 `diff` 属性（参见 linkgit:gitattributes[5]）自定义补丁文本的创建。"

#. type: Plain text
#: en/diff-generate-patch.txt:19
#, priority:280
msgid "What the -p option produces is slightly different from the traditional diff format:"
msgstr "-p 选项产生的内容与传统的差异格式略有不同："

#. type: Plain text
#: en/diff-generate-patch.txt:21
#, priority:280
msgid "It is preceded by a \"git diff\" header that looks like this:"
msgstr "它前面有一个 `git diff` 头，如下所示："

#. type: Plain text
#: en/diff-generate-patch.txt:23
#, no-wrap, placeholders:'--git', priority:280
msgid "diff --git a/file1 b/file2\n"
msgstr "diff --git a/file1 b/file2\n"

#. type: Plain text
#: en/diff-generate-patch.txt:27
#, priority:280
msgid "The `a/` and `b/` filenames are the same unless rename/copy is involved. Especially, even for a creation or a deletion, `/dev/null` is _not_ used in place of the `a/` or `b/` filenames."
msgstr "`a/` 和 `b/` 的文件名相同，除非涉及到重命名/复制。特别地，即使是创建或删除，也 _不_ 使用 `/dev/null` 来代替 `a/` 或 `b/` 文件名。"

#. type: Plain text
#: en/diff-generate-patch.txt:31
#, priority:280
msgid "When a rename/copy is involved, `file1` and `file2` show the name of the source file of the rename/copy and the name of the file that the rename/copy produces, respectively."
msgstr "当涉及重命名/复制时，`file1` 和 `file2` 分别显示重命名/复制的源文件名和重命名/复制产生的文件名。"

#. type: Plain text
#: en/diff-generate-patch.txt:33
#, priority:280
msgid "It is followed by one or more extended header lines:"
msgstr "它的后面是一个或多个扩展头信息行："

#. type: Plain text
#: en/diff-generate-patch.txt:45
#, no-wrap, priority:280
msgid ""
"old mode <mode>\n"
"new mode <mode>\n"
"deleted file mode <mode>\n"
"new file mode <mode>\n"
"copy from <path>\n"
"copy to <path>\n"
"rename from <path>\n"
"rename to <path>\n"
"similarity index <number>\n"
"dissimilarity index <number>\n"
"index <hash>..<hash> <mode>\n"
msgstr ""
"old mode <模式>\n"
"new mode <模式>\n"
"deleted file mode <模式>\n"
"new file mode <模式>\n"
"copy from <路径>\n"
"copy to <路径>\n"
"rename from <路径>\n"
"rename to <路径>\n"
"similarity index <数字>\n"
"dissimilarity index <数字>\n"
"index <哈希>..<哈希> <模式>\n"

#. type: Plain text
#: en/diff-generate-patch.txt:48
#, priority:280
msgid "File modes are printed as 6-digit octal numbers including the file type and file permission bits."
msgstr "文件模式被打印为 6 位八进制数字，包括文件类型和文件权限位。"

#. type: Plain text
#: en/diff-generate-patch.txt:50
#, priority:280
msgid "Path names in extended headers do not include the `a/` and `b/` prefixes."
msgstr "扩展头信息中的路径名称不包括 `a/` 和 `b/` 前缀。"

#. type: Plain text
#: en/diff-generate-patch.txt:57
#, priority:280
msgid "The similarity index is the percentage of unchanged lines, and the dissimilarity index is the percentage of changed lines. It is a rounded down integer, followed by a percent sign. The similarity index value of 100% is thus reserved for two equal files, while 100% dissimilarity means that no line from the old file made it into the new one."
msgstr "相似性指数是未改变的行占比，而不相似性指数是改变的行占比。它是四舍五入的整数，后有百分号。因此，100%的相似度指数指为两个文件相等，而 100% 的不相似度意味着入新文件中没有旧文件中的行。"

#. type: Plain text
#: en/diff-generate-patch.txt:61
#, priority:280
msgid "The index line includes the blob object names before and after the change. The <mode> is included if the file mode does not change; otherwise, separate lines indicate the old and the new mode."
msgstr "索引行包括改变前和改变后的 blob 对象名称。如果文件模式没有变化，则包含 <模式>；否则，分别显示新旧模式。"

#. type: Plain text
#: en/diff-generate-patch.txt:65
#, placeholders:'core.quotePath':'linkgit:git-config[1]', priority:280
msgid "Pathnames with \"unusual\" characters are quoted as explained for the configuration variable `core.quotePath` (see linkgit:git-config[1])."
msgstr "含有 \"不常见\" 字符的路径名会被引用，这一点在配置变量` core.quotePath` 中有所解释（见 linkgit:git-config[1]）。"

#. type: Plain text
#: en/diff-generate-patch.txt:70
#, priority:280
msgid "All the `file1` files in the output refer to files before the commit, and all the `file2` files refer to files after the commit. It is incorrect to apply each change to each file sequentially. For example, this patch will swap a and b:"
msgstr "输出中所有的 `file1` 文件都是指提交前的文件，而所有的 `file2` 文件都是指提交后的文件。按顺序对每个文件进行修改是不正确的。例如，这个补丁将交换文件 a 和 b："

#. type: Plain text
#: en/diff-generate-patch.txt:77
#, no-wrap, placeholders:'--git':'--git', priority:280
msgid ""
"diff --git a/a b/b\n"
"rename from a\n"
"rename to b\n"
"diff --git a/b b/a\n"
"rename from b\n"
"rename to a\n"
msgstr ""
"diff --git a/a b/b\n"
"rename from a\n"
"rename to b\n"
"diff --git a/b b/a\n"
"rename from b\n"
"rename to a\n"

#. type: Plain text
#: en/diff-generate-patch.txt:82
#, placeholders:'linkgit:gitattributes[5]', priority:280
msgid "Hunk headers mention the name of the function to which the hunk applies. See \"Defining a custom hunk-header\" in linkgit:gitattributes[5] for details of how to tailor this to specific languages."
msgstr "块头提到了块头所适用的函数的名称。 参见 linkgit:gitattributes[5] 中的 “定义自定义 hunk-header”，以了解如何针对特定语言进行定制。"

#. type: Title -
#: en/diff-generate-patch.txt:85
#, no-wrap, priority:280
msgid "Combined diff format"
msgstr "合并的差异格式"

# ERROR: --cc not found in translation
#. type: Plain text
#: en/diff-generate-patch.txt:93
#, placeholders:'`-c`':'`--cc`':'linkgit:git-diff[1]':'linkgit:git-show[1]':'`--diff-merges`', priority:280
msgid "Any diff-generating command can take the `-c` or `--cc` option to produce a 'combined diff' when showing a merge. This is the default format when showing merges with linkgit:git-diff[1] or linkgit:git-show[1]. Note also that you can give suitable `--diff-merges` option to any of these commands to force generation of diffs in a specific format."
msgstr "任何生成差异的命令都可以使用 `-c` 或 `--cc` 选项，在显示合并时产生一个 “合并差异”。当用 linkgit:git-diff[1] 或 linkgit:git-show[1] 显示合并时，这默认格式。还需要注意的是，你可以给这些命令适当的 `--diff-merges` 选项来强制生成特定格式的差异。"

#. type: Plain text
#: en/diff-generate-patch.txt:95
#, priority:280
msgid "A \"combined diff\" format looks like this:"
msgstr "\"合并的差异\" 的格式如下："

#. type: delimited block -
#: en/diff-generate-patch.txt:104
#, no-wrap, placeholders:'--combined':'---':'a_date':'b_date':'a_date':'b_date', priority:280
msgid ""
"diff --combined describe.c\n"
"index fabadb8,cc95eb0..4866510\n"
"--- a/describe.c\n"
"+++ b/describe.c\n"
"@@@ -98,20 -98,12 +98,20 @@@\n"
"\treturn (a_date > b_date) ? -1 : (a_date == b_date) ? 0 : 1;\n"
"  }\n"
msgstr ""
"diff --combined describe.c\n"
"index fabadb8,cc95eb0..4866510\n"
"--- a/describe.c\n"
"+++ b/describe.c\n"
"@@@ -98,20 -98,12 +98,20 @@@\n"
"\treturn (a_date > b_date) ? -1 : (a_date == b_date) ? 0 : 1;\n"
"  }\n"

#. type: delimited block -
#: en/diff-generate-patch.txt:114
#, no-wrap, placeholders:'last_one':'last_one':'commit_list':'commit_name', priority:280
msgid ""
"- static void describe(char *arg)\n"
" -static void describe(struct commit *cmit, int last_one)\n"
"++static void describe(char *arg, int last_one)\n"
"  {\n"
" +\tunsigned char sha1[20];\n"
" +\tstruct commit *cmit;\n"
"\tstruct commit_list *list;\n"
"\tstatic int initialized = 0;\n"
"\tstruct commit_name *n;\n"
msgstr ""
"- static void describe(char *arg)\n"
" -static void describe(struct commit *cmit, int last_one)\n"
"++static void describe(char *arg, int last_one)\n"
"  {\n"
" +\tunsigned char sha1[20];\n"
" +\tstruct commit *cmit;\n"
"\tstruct commit_list *list;\n"
"\tstatic int initialized = 0;\n"
"\tstruct commit_name *n;\n"

#. type: delimited block -
#: en/diff-generate-patch.txt:124
#, no-wrap, placeholders:'get_sha1':'describe_usage':'lookup_commit_reference':'describe_usage':'for_each_ref':'get_name', priority:280
msgid ""
" +\tif (get_sha1(arg, sha1) < 0)\n"
" +\t\tusage(describe_usage);\n"
" +\tcmit = lookup_commit_reference(sha1);\n"
" +\tif (!cmit)\n"
" +\t\tusage(describe_usage);\n"
" +\n"
"\tif (!initialized) {\n"
"\t\tinitialized = 1;\n"
"\t\tfor_each_ref(get_name);\n"
msgstr ""
" +\tif (get_sha1(arg, sha1) < 0)\n"
" +\t\tusage(describe_usage);\n"
" +\tcmit = lookup_commit_reference(sha1);\n"
" +\tif (!cmit)\n"
" +\t\tusage(describe_usage);\n"
" +\n"
"\tif (!initialized) {\n"
"\t\tinitialized = 1;\n"
"\t\tfor_each_ref(get_name);\n"

#. type: Plain text
#: en/diff-generate-patch.txt:128
#, placeholders:'`-c`', priority:280
msgid "It is preceded by a \"git diff\" header, that looks like this (when the `-c` option is used):"
msgstr "它前面有 \"git diff\" 头，如下（当使用 `-c` 选项时）："

#. type: Plain text
#: en/diff-generate-patch.txt:130
#, no-wrap, placeholders:'--combined', priority:280
msgid "diff --combined file\n"
msgstr "diff --combined file\n"

#. type: Plain text
#: en/diff-generate-patch.txt:132
#, placeholders:'`--cc`', priority:280
msgid "or like this (when the `--cc` option is used):"
msgstr "或如下（当使用 `--cc` 选项时）："

#. type: Plain text
#: en/diff-generate-patch.txt:134
#, no-wrap, placeholders:'--cc', priority:280
msgid "       diff --cc file\n"
msgstr "       diff --cc file\n"

#. type: Plain text
#: en/diff-generate-patch.txt:137
#, priority:280
msgid "It is followed by one or more extended header lines (this example shows a merge with two parents):"
msgstr "它的后面是一个或多个扩展头信息行（本例显示的是与两个父提交的合并）："

#. type: Plain text
#: en/diff-generate-patch.txt:142
#, no-wrap, priority:280
msgid ""
"index <hash>,<hash>..<hash>\n"
"mode <mode>,<mode>..<mode>\n"
"new file mode <mode>\n"
"deleted file mode <mode>,<mode>\n"
msgstr ""
"index <哈希>,<哈希>..<哈希>\n"
"mode <模式>,<模式>..<模式>\n"
"new file mode <模式>\n"
"deleted file mode <模式>,<模式>\n"

#. type: Plain text
#: en/diff-generate-patch.txt:148
#, priority:280
msgid "The `mode <mode>,<mode>..<mode>` line appears only if at least one of the <mode> is different from the rest. Extended headers with information about detected content movement (renames and copying detection) are designed to work with the diff of two <tree-ish> and are not used by combined diff format."
msgstr "`mode<模式>，<模式>..<模式>` 行仅在 <模式> 中至少有一个与其余的不同时才会出现。包含有关检测到的内容移动的信息 (重命名和复制检测) 的扩展标头设计为使用两个 <目录树对象> 的 diff，不能用于组合的 diff 格式。"

#. type: Plain text
#: en/diff-generate-patch.txt:150
#, priority:280
msgid "It is followed by a two-line from-file/to-file header:"
msgstr "它的后面是两行源文件/目标文件的头信息："

#. type: Plain text
#: en/diff-generate-patch.txt:152 en/diff-generate-patch.txt:163 en/diff-generate-patch.txt:164 en/diff-generate-patch.txt:165
#, priority:280
msgid "a/file"
msgstr "a/file"

#. type: Plain text
#: en/diff-generate-patch.txt:153 en/diff-generate-patch.txt:166
#, priority:280
msgid "b/file"
msgstr "b/file"

#. type: Plain text
#: en/diff-generate-patch.txt:157
#, priority:280
msgid "Similar to the two-line header for the traditional 'unified' diff format, `/dev/null` is used to signal created or deleted files."
msgstr "与传统 ‘统一’ diff 格式的双行标题类似，`/dev/null` 用于表示已创建或已删除的文件。"

#. type: Plain text
#: en/diff-generate-patch.txt:161
#, placeholders:'--combined-all-paths', priority:280
msgid "However, if the --combined-all-paths option is provided, instead of a two-line from-file/to-file, you get an N+1 line from-file/to-file header, where N is the number of parents in the merge commit:"
msgstr "但是，如果提供了 --combined-all-paths 选项，你就会得到一个 N+1 行的源文件/目标文件头，其中 N 是合并提交中的父提交数量："

#. type: Plain text
#: en/diff-generate-patch.txt:170
#, priority:280
msgid "This extended format can be useful if rename or copy detection is active, to allow you to see the original name of the file in different parents."
msgstr "如果重命名或复制检测处于活动状态，这种扩展格式可能很有用，可以让你在不同的父提交中看到文件的原始名称。"

#. type: Plain text
#: en/diff-generate-patch.txt:176
#, priority:280
msgid "Chunk header format is modified to prevent people from accidentally feeding it to `patch -p1`. Combined diff format was created for review of merge commit changes, and was not meant to be applied. The change is similar to the change in the extended 'index' header:"
msgstr "修改了文件块头信息的格式，以防止不小心将其送入 `patch -p1`。合并的差异格式是为审查合并提交的修改而创建的，并不是为了应用。这个变化类似于扩展的 \"索引\" 头信息的变化："

#. type: Plain text
#: en/diff-generate-patch.txt:178
#, no-wrap, priority:280
msgid "@@@ <from-file-range> <from-file-range> <to-file-range> @@@\n"
msgstr "@@@ <from-file-range> <from-file-range> <to-file-range> @@@\n"

#. type: Plain text
#: en/diff-generate-patch.txt:181
#, priority:280
msgid "There are (number of parents + 1) `@` characters in the chunk header for combined diff format."
msgstr "块中有（父提交数量+1）`@` 字符，用于合并的差异格式。"

#. type: Plain text
#: en/diff-generate-patch.txt:190
#, ignore-ellipsis, priority:280
msgid "Unlike the traditional 'unified' diff format, which shows two files A and B with a single column that has `-` (minus -- appears in A but removed in B), `+` (plus -- missing in A but added to B), or `\" \"` (space -- unchanged) prefix, this format compares two or more files file1, file2,... with one file X, and shows how X differs from each of fileN. One column for each of fileN is prepended to the output line to note how X's line is different from it."
msgstr "与传统的 \"统一\" 差异格式不同，这种格式显示两个文件 A 和 B 的列，其中有 `-`（减号 -- 在 A 中出现，但在 B 中删除），`+`（加号 -- 在 A 中缺少，但在 B 中增加），或 `\" \"`（空格 -- 不变）前缀，这种格式比较两个或多个文件与一个文件 X，并显示 X 与其中每个文件的差异。文件中的每一个都有一列被前置在输出行中，以指出 X 的行与它的不同之处。"

#. type: Plain text
#: en/diff-generate-patch.txt:196
#, priority:280
msgid "A `-` character in the column N means that the line appears in fileN but it does not appear in the result. A `+` character in the column N means that the line appears in the result, and fileN does not have that line (in other words, the line was added, from the point of view of that parent)."
msgstr "第 N 列中的 `-` 字符意味着该行出现在文件 N 中，但它没有出现在结果文件中。第 N 列中的 `+` 字符意味着该行出现在结果文件中，而文件 N 中没有该行（换句话说，从该父提交的角度来看，该行是被添加的）。"

#. type: Plain text
#: en/diff-generate-patch.txt:202
#, priority:280
msgid "In the above example output, the function signature was changed from both files (hence two `-` removals from both file1 and file2, plus `++` to mean one line that was added does not appear in either file1 or file2). Also, eight other lines are the same from file1 but do not appear in file2 (hence prefixed with `+`)."
msgstr "在上面的输出示例中，两个文件中的函数签名都被改变了（因此从文件 1 和文件 2 中都有表示删除的 `-`，而 `++` 表示被添加的一行没有出现在文件 1 或文件 2 中）。另外还有 8 行与文件 1 中的相同，但没有出现在文件 2 中（因此前缀为 `+`）。"

#. type: Plain text
#: en/diff-generate-patch.txt:208
#, placeholders:'git diff-tree':'git diff-files', priority:280
msgid "When shown by `git diff-tree -c`, it compares the parents of a merge commit with the merge result (i.e. file1..fileN are the parents). When shown by `git diff-files -c`, it compares the two unresolved merge parents with the working tree file (i.e. file1 is stage 2 aka \"our version\", file2 is stage 3 aka \"their version\")."
msgstr "当用 `git diff-tree -c` 显示时，它将合并提交的父提交文件与合并结果进行比较（即文件 1 ... 文件 N 是父提交文件）。当用 `git diff-files -c` 显示时，它将两个未解决的合并父提交文件与工作树文件进行比较（即文件 1 是阶段 2 ，又称 \"我们的版本\"，文件 2 是阶段 3，又称 \"他们的版本\"）。"

#. type: Labeled list
#: en/diff-options.txt:17 en/git-rebase.txt:420 en/merge-options.txt:109
#, ignore-same, no-wrap, priority:280
msgid "--no-stat"
msgstr "--no-stat"

#. type: Plain text
#: en/diff-options.txt:19
#, priority:280
msgid "Generate plain patches without any diffstats."
msgstr "生成没有任何差异状态 (diffstats) 的普通补丁。"

#. type: Labeled list
#: en/diff-options.txt:23 en/fetch-options.txt:265 en/git-add.txt:119 en/git-am.txt:92 en/git-checkout-index.txt:26 en/git-cvsexportcommit.txt:64 en/git-cvsimport.txt:98 en/git-ls-files.txt:80 en/git-mailinfo.txt:54 en/git-push.txt:373 en/git-read-tree.txt:45 en/git-stash.txt:166
#, ignore-same, no-wrap, priority:300
msgid "-u"
msgstr "-u"

#. type: Labeled list
#: en/diff-options.txt:24 en/git-add.txt:97 en/git-checkout.txt:279 en/git-commit.txt:74 en/git-restore.txt:49 en/git-stash.txt:197
#, ignore-same, no-wrap, priority:300
msgid "--patch"
msgstr "--patch"

#. type: Plain text
#: en/diff-options.txt:26
#, placeholders:'<<generate_patch_text_with_p>>', priority:280
msgid "Generate patch (see <<generate_patch_text_with_p>>)."
msgstr "生成补丁（请参阅 <<generate_patch_text_with_p>> ）。"

#. type: Plain text
#: en/diff-options.txt:28 en/diff-options.txt:146
#, no-wrap, priority:280
msgid "\tThis is the default.\n"
msgstr "\t这是默认设置。\n"

#. type: Labeled list
#: en/diff-options.txt:30 en/git-am.txt:38 en/git-blame.txt:75 en/git-cat-file.txt:44 en/git-cherry-pick.txt:105 en/git-clone.txt:76 en/git-diff-tree.txt:77 en/git-format-patch.txt:138 en/git-ls-files.txt:68 en/git-revert.txt:100 en/git-shortlog.txt:34 en/git-show-ref.txt:61 en/git-status.txt:27 en/git-stripspace.txt:38 en/git-svn.txt:46 en/git-tag.txt:64 en/git-verify-pack.txt:31 en/signoff-option.txt:2
#, ignore-same, no-wrap, priority:300
msgid "-s"
msgstr "-s"

#. type: Labeled list
#: en/diff-options.txt:31
#, ignore-same, no-wrap, priority:280
msgid "--no-patch"
msgstr "--no-patch"

# ERROR: --stat not found in translation
#. type: Plain text
#: en/diff-options.txt:36
#, placeholders:'`--patch`':'`--stat`', priority:280
msgid "Suppress all output from the diff machinery. Useful for commands like `git show` that show the patch by default to squelch their output, or to cancel the effect of options like `--patch`, `--stat` earlier on the command line in an alias."
msgstr "抑制差异（diff）工具的所有输出。 对于默认显示补丁的 `git show` 等命令，可以压制其输出，或在别名中取消命令行中的 `--patch`、`--stat` 等选项的效果。"

#. type: Labeled list
#: en/diff-options.txt:40 en/git-am.txt:77 en/git-branch.txt:131 en/git-checkout.txt:250 en/git-cvsexportcommit.txt:60 en/git-cvsimport.txt:118 en/git-diff-index.txt:37 en/git-diff-tree.txt:71 en/git-help.txt:96 en/git-instaweb.txt:36 en/git-ls-files.txt:48 en/git-mailinfo.txt:71 en/git-read-tree.txt:33 en/git-rebase.txt:363 en/git-repack.txt:247 en/git-restore.txt:88 en/git-svn.txt:308 en/git-svn.txt:675 en/git-switch.txt:126 en/git-symbolic-ref.txt:58
#, ignore-same, no-wrap, priority:280
msgid "-m"
msgstr "-m"

#. type: Plain text
#: en/diff-options.txt:44
#, placeholders:'--diff-merges=on':'`-m`':'`-p`', priority:280
msgid "Show diffs for merge commits in the default format. This is similar to '--diff-merges=on', except `-m` will produce no output unless `-p` is given as well."
msgstr "以默认格式显示合并提交的差异。这与 '--diff-merges=on' 类似，但除非同时给出 `-p`，否则 `-m` 不会产生任何输出。"

#. type: Labeled list
#: en/diff-options.txt:45 en/git-am.txt:57 en/git-blame.txt:53 en/git-branch.txt:138 en/git-cvsexportcommit.txt:37 en/git-diff-files.txt:37 en/git-diff-tree.txt:93 en/git-grep.txt:188 en/git-help.txt:65 en/git-ls-files.txt:38 en/git-shortlog.txt:87 en/git-stripspace.txt:42
#, ignore-same, no-wrap, priority:280
msgid "-c"
msgstr "-c"

#. type: Plain text
#: en/diff-options.txt:48
#, placeholders:'--diff-merges=combined', priority:280
msgid "Produce combined diff output for merge commits. Shortcut for '--diff-merges=combined -p'."
msgstr "生成合并提交的合并差异输出。 '--diff-merges=combined -p' 的快捷方式。"

#. type: Labeled list
#: en/diff-options.txt:49 en/git-diff-files.txt:38 en/git-diff-tree.txt:103
#, ignore-same, no-wrap, priority:280
msgid "--cc"
msgstr "--cc"

#. type: Plain text
#: en/diff-options.txt:52
#, placeholders:'--diff-merges=dense-combined', priority:280
msgid "Produce dense combined diff output for merge commits. Shortcut for '--diff-merges=dense-combined -p'."
msgstr "生成合并提交的密集合并差异输出。 '--diff-merges=dense-combined -p' 的快捷方式。"

#. type: Labeled list
#: en/diff-options.txt:53
#, ignore-same, no-wrap, priority:280
msgid "--dd"
msgstr "--dd"

#. type: Plain text
#: en/diff-options.txt:57
#, placeholders:'--diff-merges=first-parent', priority:280
msgid "Produce diff with respect to first parent for both merge and regular commits. Shortcut for '--diff-merges=first-parent -p'."
msgstr "为合并提交和常规提交生成与第一父提交的差异。 '--diff-merges=first-parent -p' 的快捷方式。"

#. type: Labeled list
#: en/diff-options.txt:58
#, ignore-same, no-wrap, priority:280
msgid "--remerge-diff"
msgstr "--remerge-diff"

#. type: Plain text
#: en/diff-options.txt:61
#, placeholders:'--diff-merges=remerge', priority:280
msgid "Produce remerge-diff output for merge commits. Shortcut for '--diff-merges=remerge -p'."
msgstr "生成合并提交的 remerge-diff 输出。 '--diff-merges=remerge -p' 的快捷方式。"

#. type: Labeled list
#: en/diff-options.txt:62
#, ignore-same, no-wrap, priority:280
msgid "--no-diff-merges"
msgstr "--no-diff-merges"

#. type: Plain text
#: en/diff-options.txt:64
#, placeholders:'--diff-merges=off', priority:280
msgid "Synonym for '--diff-merges=off'."
msgstr "'--diff-merges=off' 的同义词。"

#. type: Labeled list
#: en/diff-options.txt:65
#, no-wrap, placeholders:'--diff-merges=', priority:280
msgid "--diff-merges=<format>"
msgstr "--diff-merges=<格式>"

#. type: Plain text
#: en/diff-options.txt:69
#, placeholders:'{diff-merges-default}':'`--first-parent`', priority:280
msgid "Specify diff format to be used for merge commits. Default is {diff-merges-default} unless `--first-parent` is in use, in which case `first-parent` is the default."
msgstr "指定合并提交时使用的差异格式。默认为 {diff-merges-default}，但当使用 `--first-parent` 选项时，默认为 `first-parent`。"

#. type: Plain text
#: en/diff-options.txt:71
#, priority:280
msgid "The following formats are supported:"
msgstr "支持以下格式："

#. type: Labeled list
#: en/diff-options.txt:73
#, no-wrap, priority:280
msgid "off, none"
msgstr "off, none"

#. type: Plain text
#: en/diff-options.txt:76
#, priority:280
msgid "Disable output of diffs for merge commits. Useful to override implied value."
msgstr "禁用合并提交时的差异输出。对覆盖隐含值很有用。"

#. type: Labeled list
#: en/diff-options.txt:77
#, no-wrap, priority:280
msgid "on, m"
msgstr "on, m"

#. type: Plain text
#: en/diff-options.txt:82
#, placeholders:'log.diffMerges', priority:280
msgid "Make diff output for merge commits to be shown in the default format. The default format can be changed using `log.diffMerges` configuration variable, whose default value is `separate`."
msgstr "该选项使合并提交的差异输出以默认格式显示。`-m` 只有在 `-p` 的情况下才会产生输出。默认格式可以通过 `log.diffMerges` 配置参数改变，默认值为 `separate` 。"

#. type: Labeled list
#: en/diff-options.txt:83
#, no-wrap, priority:280
msgid "first-parent, 1"
msgstr "first-parent, 1"

#. type: Plain text
#: en/diff-options.txt:86
#, placeholders:'`--patch`', priority:280
msgid "Show full diff with respect to first parent. This is the same format as `--patch` produces for non-merge commits."
msgstr "显示与第一个父提交的完整差异。这与 `--patch` 为非合并提交生成的格式相同。"

#. type: Labeled list
#: en/diff-options.txt:87
#, no-wrap, priority:280
msgid "separate"
msgstr "separate"

#. type: Plain text
#: en/diff-options.txt:90
#, priority:280
msgid "Show full diff with respect to each of parents. Separate log entry and diff is generated for each parent."
msgstr "显示每个父代的完整差异。 每个父代都会生成单独的日志条目和差异。"

#. type: Labeled list
#: en/diff-options.txt:91
#, no-wrap, priority:280
msgid "combined, c"
msgstr "combined, c"

#. type: Plain text
#: en/diff-options.txt:96
#, priority:280
msgid "Show differences from each of the parents to the merge result simultaneously instead of showing pairwise diff between a parent and the result one at a time. Furthermore, it lists only files which were modified from all parents."
msgstr "同时显示每个父文件与合并结果之间的差异，而不是逐个显示父文件与合并结果之间的成对差异。此外，它只列出从所有父文件修改过的文件。"

#. type: Labeled list
#: en/diff-options.txt:97
#, no-wrap, priority:280
msgid "dense-combined, cc"
msgstr "dense-combined, cc"

#. type: Plain text
#: en/diff-options.txt:102
#, placeholders:'`--diff-merges=combined`', priority:280
msgid "Further compress output produced by `--diff-merges=combined` by omitting uninteresting hunks whose contents in the parents have only two variants and the merge result picks one of them without modification."
msgstr "使用该选项，通过省略不感兴趣的块，进一步压缩 `--diff-merges=combined` 产生的输出，这类块在父提交中的内容只有两个变体，并且合并结果选择了其中一个而没有修改。 `--cc` 选项暗含 `-p`。"

#. type: Labeled list
#: en/diff-options.txt:103
#, no-wrap, priority:280
msgid "remerge, r"
msgstr "remerge, r"

#. type: Plain text
#: en/diff-options.txt:108
#, priority:280
msgid "Remerge two-parent merge commits to create a temporary tree object--potentially containing files with conflict markers and such. A diff is then shown between that temporary tree and the actual merge commit."
msgstr "重合双亲合并提交以创建临时目录树对象——可能包含冲突标记等文件。 然后会显示临时目录树与实际合并提交之间的差异。"

#. type: Plain text
#: en/diff-options.txt:112
#, priority:280
msgid "The output emitted when this option is used is subject to change, and so is its interaction with other options (unless explicitly documented)."
msgstr "使用该选项时发出的输出是可以改变的，它与其他选项的互动也是可以改变的（除非有明确的记录）。"

#. type: Labeled list
#: en/diff-options.txt:114 en/git-diff-tree.txt:113
#, ignore-same, no-wrap, priority:280
msgid "--combined-all-paths"
msgstr "--combined-all-paths"

#. type: Plain text
#: en/diff-options.txt:120
#, placeholders:'`--diff-merges=[dense-]combined`', priority:280
msgid "This flag causes combined diffs (used for merge commits) to list the name of the file from all parents. It thus only has effect when `--diff-merges=[dense-]combined` is in use, and is likely only useful if filename changes are detected (i.e. when either rename or copy detection have been requested)."
msgstr "这个标志会使合并后的差异文件（用于合并提交）列出所有父提交的名称。，因此它只在使用 `--diff-merges=[dense-]combined` 时有效。其可能在检测到文件名变化时有用（例如，当要求检测重命名或复制时）。"

#. type: Labeled list
#: en/diff-options.txt:122
#, no-wrap, priority:280
msgid "-U<n>"
msgstr "-U<n>"

#. type: Labeled list
#: en/diff-options.txt:123
#, no-wrap, placeholders:'--unified=', priority:280
msgid "--unified=<n>"
msgstr "--unified=<n>"

#. type: Plain text
#: en/diff-options.txt:126
#, priority:280
msgid "Generate diffs with <n> lines of context instead of the usual three."
msgstr "生成带有 <n> 行上下文的差异，而不是通常的 3 行。暗含 `--patch` 选项。"

#. type: Plain text
#: en/diff-options.txt:128 en/diff-options.txt:537
#, no-wrap, placeholders:'`--patch`', priority:280
msgid "\tImplies `--patch`.\n"
msgstr "\t暗含 `--patch` 选项。\n"

#. type: Labeled list
#: en/diff-options.txt:130 en/git-archive.txt:59
#, no-wrap, placeholders:'--output=', priority:280
msgid "--output=<file>"
msgstr "--output=<文件>"

#. type: Plain text
#: en/diff-options.txt:132
#, priority:280
msgid "Output to a specific file instead of stdout."
msgstr "输出到一个特定的文件，而不是标准输出。"

#. type: Labeled list
#: en/diff-options.txt:133
#, no-wrap, placeholders:'--output-indicator-new=', priority:280
msgid "--output-indicator-new=<char>"
msgstr "--output-indicator-new=<字符>"

#. type: Labeled list
#: en/diff-options.txt:134
#, no-wrap, placeholders:'--output-indicator-old=', priority:280
msgid "--output-indicator-old=<char>"
msgstr "--output-indicator-old=<字符>"

#. type: Labeled list
#: en/diff-options.txt:135
#, no-wrap, placeholders:'--output-indicator-context=', priority:280
msgid "--output-indicator-context=<char>"
msgstr "--output-indicator-context=<字符>"

#. type: Plain text
#: en/diff-options.txt:139
#, priority:280
msgid "Specify the character used to indicate new, old or context lines in the generated patch. Normally they are '+', '-' and ' ' respectively."
msgstr "指定在生成的补丁中用来表示新、旧或上下文行的字符。通常它们分别是 '+'、'-' 和 ' '（空格）。"

#. type: Labeled list
#: en/diff-options.txt:141 en/git-replace.txt:78 en/git-verify-commit.txt:19 en/git-verify-tag.txt:19
#, ignore-same, no-wrap, priority:280
msgid "--raw"
msgstr "--raw"

#. type: Plain text
#: en/diff-options.txt:144
#, no-wrap, priority:280
msgid "\tGenerate the diff in raw format.\n"
msgstr "\t生成原始格式的差异。\n"

#. type: Plain text
#: en/diff-options.txt:154
#, no-wrap, placeholders:'linkgit:git-diff[1]':'`--format=raw`', priority:280
msgid ""
"\tFor each commit, show a summary of changes using the raw diff\n"
"\tformat. See the \"RAW OUTPUT FORMAT\" section of\n"
"\tlinkgit:git-diff[1]. This is different from showing the log\n"
"\titself in raw format, which you can achieve with\n"
"\t`--format=raw`.\n"
msgstr ""
"\t对于每一个提交，使用原始的差异格式\n"
"\t请参见 linkgit:git-diff[1] 中\n"
"\t“原始输出格式” 一节 。\n"
"\t这与显示日志中的本身的原始格式不同\n"
"\t你可以用 `--format=raw` 来实现。\n"

#. type: Labeled list
#: en/diff-options.txt:158
#, ignore-same, no-wrap, priority:280
msgid "--patch-with-raw"
msgstr "--patch-with-raw"

# ERROR: --raw not found in translation
#. type: Plain text
#: en/diff-options.txt:160
#, placeholders:'--raw`', priority:280
msgid "Synonym for `-p --raw`."
msgstr "`-p--raw` 的同义词。"

#. type: Plain text
#: en/diff-options.txt:165
#, priority:280
msgid "Show the tree objects in the diff output."
msgstr "在差异输出中显示目录树对象。"

#. type: Labeled list
#: en/diff-options.txt:167
#, ignore-same, no-wrap, priority:280
msgid "--indent-heuristic"
msgstr "--indent-heuristic"

#. type: Plain text
#: en/diff-options.txt:170
#, priority:280
msgid "Enable the heuristic that shifts diff hunk boundaries to make patches easier to read. This is the default."
msgstr "启用启发式的缩进区块的方法，使得补丁更易读。这是默认选项。"

#. type: Labeled list
#: en/diff-options.txt:171
#, ignore-same, no-wrap, priority:280
msgid "--no-indent-heuristic"
msgstr "--no-indent-heuristic"

#. type: Plain text
#: en/diff-options.txt:173
#, priority:280
msgid "Disable the indent heuristic."
msgstr "禁用启发式缩进。"

#. type: Labeled list
#: en/diff-options.txt:174
#, ignore-same, no-wrap, priority:280
msgid "--minimal"
msgstr "--minimal"

#. type: Labeled list
#: en/diff-options.txt:178
#, ignore-same, no-wrap, priority:280
msgid "--patience"
msgstr "--patience"

#. type: Plain text
#: en/diff-options.txt:180
#, priority:280
msgid "Generate a diff using the \"patience diff\" algorithm."
msgstr "使用 \"patience diff\" 算法生成差异。"

#. type: Labeled list
#: en/diff-options.txt:181
#, ignore-same, no-wrap, priority:280
msgid "--histogram"
msgstr "--histogram"

#. type: Plain text
#: en/diff-options.txt:183
#, priority:280
msgid "Generate a diff using the \"histogram diff\" algorithm."
msgstr "使用 \"histogram diff\" 算法生成差异。"

#. type: Labeled list
#: en/diff-options.txt:184
#, no-wrap, placeholders:'--anchored=', priority:280
msgid "--anchored=<text>"
msgstr "--anchored=<文本>"

#. type: Plain text
#: en/diff-options.txt:186
#, priority:280
msgid "Generate a diff using the \"anchored diff\" algorithm."
msgstr "使用 \"anchored diff\" 算法生成差异。"

#. type: Plain text
#: en/diff-options.txt:188
#, priority:280
msgid "This option may be specified more than once."
msgstr "这个选项可以被指定多次。"

#. type: Plain text
#: en/diff-options.txt:193
#, priority:280
msgid "If a line exists in both the source and destination, exists only once, and starts with this text, this algorithm attempts to prevent it from appearing as a deletion or addition in the output. It uses the \"patience diff\" algorithm internally."
msgstr "如果某一个行同时存在于来源和目标中，各只出现一次，以这个文本开头，这个算法试图防止它在输出中以删除或添加的形式出现。它在内部使用了 \"patience diff\" 算法。"

#. type: Labeled list
#: en/diff-options.txt:194 en/git-merge-file.txt:95
#, no-wrap, placeholders:'--diff-algorithm=', priority:280
msgid "--diff-algorithm={patience|minimal|histogram|myers}"
msgstr "--diff-algorithm={patience|minimal|histogram|myers}"

#. type: Plain text
#: en/diff-options.txt:213
#, placeholders:'diff.algorithm':'`--diff-algorithm=default`', priority:280
msgid "For instance, if you configured the `diff.algorithm` variable to a non-default value and want to use the default one, then you have to use `--diff-algorithm=default` option."
msgstr "例如，如果你将 `diff.algorithm` 变量配置为非默认值，但希望使用默认值，那么你必须使用 `--diff-algorithm=default` 选项。"

#. type: Labeled list
#: en/diff-options.txt:214
#, no-wrap, placeholders:'--stat', priority:280
msgid "--stat[=<width>[,<name-width>[,<count>]]]"
msgstr "--stat[=<宽度>[,<名称宽度>[,<数值>]]]"

# ERROR: diff.statNameWidth not found in translation
# ERROR: diff.statNameWidth not found in translation
#. type: Plain text
#: en/diff-options.txt:229
#, ignore-ellipsis, placeholders:'diff.statNameWidth':'`--stat-graph-width=':'diff.statGraphWidth':'`--stat`':'`--stat-graph-width`':'diff.statNameWidth':'diff.statGraphWidth':'git format-patch', priority:280
msgid "Generate a diffstat. By default, as much space as necessary will be used for the filename part, and the rest for the graph part. Maximum width defaults to terminal width, or 80 columns if not connected to a terminal, and can be overridden by `<width>`. The width of the filename part can be limited by giving another width `<name-width>` after a comma or by setting `diff.statNameWidth=<width>`. The width of the graph part can be limited by using `--stat-graph-width=<width>` or by setting `diff.statGraphWidth=<width>`. Using `--stat` or `--stat-graph-width` affects all commands generating a stat graph, while setting `diff.statNameWidth` or `diff.statGraphWidth` does not affect `git format-patch`. By giving a third parameter `<count>`, you can limit the output to the first `<count>` lines, followed by `...` if there are more."
msgstr "生成差异统计（diffstat）。默认情况下，文件名部分将使用尽可能多的空间，其余空间用于图表部分。最大宽度默认为终端宽度，如果未连接终端，则为 80 列，可以用 `<最大宽度>`覆盖。文件名部分的宽度可以通过在逗号后另加宽度 `<文件名宽度>`或设置 `diff.statNameWidth=<文件名宽度>`来限制。图形部分的宽度可以通过使用 `--stat-graph-width=<图形宽度>`或设置 `diff.statGraphWidth=<图像宽度>` 来限制。使用 `--stat` 或 `--stat-graph-width` 选项会影响所有生成统计图的命令，而设置 `diff.statNameWidth` 或 `diff.statGraphWidth` 则不会影响 `git format-patch`。 通过给出第三个参数 `<行数>`，可以将输出限制在前 `<行数>`行，如果行数更多，则在后面加上 `...`。"

#. type: Plain text
#: en/diff-options.txt:232
#, placeholders:'`--stat-width=':'`--stat-name-width=':'`--stat-count=', priority:280
msgid "These parameters can also be set individually with `--stat-width=<width>`, `--stat-name-width=<name-width>` and `--stat-count=<count>`."
msgstr "这些参数也可以用 `--stat-width=<宽度>`，`--stat-name-width=<名称宽度>` 和 `--stat-count=<数量>` 单独设置。"

#. type: Labeled list
#: en/diff-options.txt:233
#, ignore-same, no-wrap, priority:280
msgid "--compact-summary"
msgstr "--compact-summary"

#. type: Plain text
#: en/diff-options.txt:240
#, placeholders:'`--stat`', priority:280
msgid "Output a condensed summary of extended header information such as file creations or deletions (\"new\" or \"gone\", optionally \"+l\" if it's a symlink) and mode changes (\"+x\" or \"-x\" for adding or removing executable bit respectively) in diffstat. The information is put between the filename part and the graph part. Implies `--stat`."
msgstr "在差异状态中输出扩展头信息的压缩摘要，如文件的创建或删除（\"new\" 或 \"good\"。如果是符号链接，则为 \"+l\"）和模式变化（\"+x\" 或 \"-x\" 分别用于添加或删除可执行位）。这些信息被放在文件名部分和图形部分之间。暗含 `--stat` 选项。"

#. type: Labeled list
#: en/diff-options.txt:241 en/git-apply.txt:45
#, ignore-same, no-wrap, priority:280
msgid "--numstat"
msgstr "--numstat"

#. type: Plain text
#: en/diff-options.txt:247
#, placeholders:'`--stat`', priority:280
msgid "Similar to `--stat`, but shows number of added and deleted lines in decimal notation and pathname without abbreviation, to make it more machine friendly. For binary files, outputs two `-` instead of saying `0 0`."
msgstr "类似于 `--stat`，但是使用小数点和不含缩写的路径名显示添加和删除的行数，使其对程序更友好。对于二进制文件，输出两个 `-`，而不是 `0 0`。"

#. type: Labeled list
#: en/diff-options.txt:248
#, ignore-same, no-wrap, priority:280
msgid "--shortstat"
msgstr "--shortstat"

#. type: Plain text
#: en/diff-options.txt:252
#, placeholders:'`--stat`', priority:280
msgid "Output only the last line of the `--stat` format containing total number of modified files, as well as number of added and deleted lines."
msgstr "只输出使用 `--stat` 选项输出的最后一行，包含修改的文件总数，添加和删除的行数。"

#. type: Labeled list
#: en/diff-options.txt:253
#, ignore-ellipsis, no-wrap, priority:280
msgid "-X[<param1,param2,...>]"
msgstr "-X[<参数1,参数2,...>]"

#. type: Labeled list
#: en/diff-options.txt:254
#, ignore-ellipsis, no-wrap, placeholders:'--dirstat', priority:280
msgid "--dirstat[=<param1,param2,...>]"
msgstr "--dirstat[=<参数1,参数2,...>]"

#. type: Plain text
#: en/diff-options.txt:261
#, placeholders:'`--dirstat`':'diff.dirstat':'linkgit:git-config[1]', priority:280
msgid "Output the distribution of relative amount of changes for each sub-directory. The behavior of `--dirstat` can be customized by passing it a comma separated list of parameters. The defaults are controlled by the `diff.dirstat` configuration variable (see linkgit:git-config[1]). The following parameters are available:"
msgstr "输出每个子目录的相对变化量的分布。`--dirstat` 的行为可以通过传递一个以逗号分隔的参数列表来自定义。默认值由`diff.dirstat` 配置变量控制 (参见 linkgit:git-config[1])。以下是可用的参数："

#. type: Plain text
#: en/diff-options.txt:297
#, placeholders:'`--dirstat=files', priority:280
msgid "Example: The following will count changed files, while ignoring directories with less than 10% of the total amount of changed files, and accumulating child directory counts in the parent directories: `--dirstat=files,10,cumulative`."
msgstr "例如：下面的参数会统计更改的文件，同时忽略占更改文件总数 10% 以下的目录，并累积父目录中的子目录计数：`--dirstat=files,10,cumulative`。"

#. type: Labeled list
#: en/diff-options.txt:298
#, ignore-same, no-wrap, priority:280
msgid "--cumulative"
msgstr "--cumulative"

#. type: Plain text
#: en/diff-options.txt:300
#, placeholders:'--dirstat=cumulative', priority:280
msgid "Synonym for --dirstat=cumulative"
msgstr "--dirstat=cumulative 同义"

# ERROR: --dirstat-by-file not found in translation
#. type: Labeled list
#: en/diff-options.txt:301
#, ignore-ellipsis, no-wrap, placeholders:'--dirstat-by-file', priority:280
msgid "--dirstat-by-file[=<param1,param2>...]"
msgstr "--dirstat-by-file[=<参数1,参数2>...]"

#. type: Plain text
#: en/diff-options.txt:303
#, ignore-ellipsis, placeholders:'--dirstat=files', priority:280
msgid "Synonym for --dirstat=files,<param1>,<param2>..."
msgstr "与 --dirstat=files,<参数 1>,<参数 2> 同义"

#. type: Labeled list
#: en/diff-options.txt:304 en/git-apply.txt:52 en/git-shortlog.txt:35 en/merge-options.txt:168
#, ignore-same, no-wrap, priority:280
msgid "--summary"
msgstr "--summary"

#. type: Plain text
#: en/diff-options.txt:307
#, priority:280
msgid "Output a condensed summary of extended header information such as creations, renames and mode changes."
msgstr "输出扩展头信息，如创建、重命名和模式变化等，的压缩摘要。"

#. type: Labeled list
#: en/diff-options.txt:309
#, ignore-same, no-wrap, priority:280
msgid "--patch-with-stat"
msgstr "--patch-with-stat"

# ERROR: --stat` not found in translation
#. type: Plain text
#: en/diff-options.txt:311
#, placeholders:'--stat`', priority:280
msgid "Synonym for `-p --stat`."
msgstr "同义词 `-p --stat`。"

#. type: Labeled list
#: en/diff-options.txt:315 en/git-apply.txt:116 en/git-cat-file.txt:249 en/git-check-attr.txt:34 en/git-check-ignore.txt:47 en/git-checkout-index.txt:73 en/git-commit.txt:158 en/git-config.txt:229 en/git-grep.txt:176 en/git-ls-files.txt:99 en/git-ls-tree.txt:55 en/git-merge-tree.txt:43 en/git-mktree.txt:23 en/git-status.txt:126 en/git-update-index.txt:179 en/git-worktree.txt:245
#, ignore-same, no-wrap, priority:280
msgid "-z"
msgstr "-z"

#. type: Plain text
#: en/diff-options.txt:318
#, no-wrap, priority:280
msgid "\tSeparate the commits with NULs instead of newlines.\n"
msgstr "\t用 NUL 而不是用换行来分隔提交。\n"

#. type: Plain text
#: en/diff-options.txt:321
#, placeholders:'`--raw`':'`--numstat`', priority:280
msgid "Also, when `--raw` or `--numstat` has been given, do not munge pathnames and use NULs as output field terminators."
msgstr "另外，当给出 `--raw` 或 `--numstat` 时，不合并路径名，并使用 NUL 作为输出字段终止符。"

# ERROR: --name-only not found in translation
# ERROR: --name-status not found in translation
#. type: Plain text
#: en/diff-options.txt:325
#, no-wrap, placeholders:'`--raw`':'`--numstat`':'`--name-only`':'`--name-status`', priority:280
msgid ""
"\tWhen `--raw`, `--numstat`, `--name-only` or `--name-status` has been\n"
"\tgiven, do not munge pathnames and use NULs as output field terminators.\n"
msgstr ""
"\t另外，当给出 `--raw`、`--numstat`、 `--name-only` 或 `--name-status` 选项时，\n"
"\t不合并路径名，并使用 NUL 作为输出字段终止符。\n"

#. type: Plain text
#: en/diff-options.txt:330 en/git-apply.txt:123
#, placeholders:'core.quotePath':'linkgit:git-config[1]', priority:280
msgid "Without this option, pathnames with \"unusual\" characters are quoted as explained for the configuration variable `core.quotePath` (see linkgit:git-config[1])."
msgstr "如果没有这个选项，带 “不常见” 字符的路径名会被引用，正如配置变量 `core.quotePath` 所解释的那样（参见 linkgit:git-config[1]）。"

#. type: Labeled list
#: en/diff-options.txt:331 en/git-config.txt:238 en/git-grep.txt:158 en/git-ls-tree.txt:59 en/git-merge-tree.txt:49 en/git-name-rev.txt:74
#, ignore-same, no-wrap, priority:280
msgid "--name-only"
msgstr "--name-only"

#. type: Plain text
#: en/diff-options.txt:335
#, placeholders:'linkgit:git-log[1]', priority:280
msgid "Show only names of changed files. The file names are often encoded in UTF-8. For more information see the discussion about encoding in the linkgit:git-log[1] manual page."
msgstr "只显示更改过的文件的名称。文件名通常以 UTF-8 编码。 更多信息见 linkgit:git-log[1] 手册页中关于编码的讨论。"

#. type: Labeled list
#: en/diff-options.txt:336 en/git-ls-tree.txt:60
#, ignore-same, no-wrap, priority:280
msgid "--name-status"
msgstr "--name-status"

# ERROR: --name-only not found in translation
#. type: Plain text
#: en/diff-options.txt:340
#, placeholders:'`--diff-filter`':'`--name-only`', priority:280
msgid "Show only names and status of changed files. See the description of the `--diff-filter` option on what the status letters mean. Just like `--name-only` the file names are often encoded in UTF-8."
msgstr "仅显示已更改文件的名称和状态。有关状态字母的含义，请参阅 `--diff-filter` 选项的说明。 与 `--name-only` 一样，文件名通常使用 UTF-8 编码。"

#. type: Labeled list
#: en/diff-options.txt:341
#, no-wrap, placeholders:'--submodule', priority:280
msgid "--submodule[=<format>]"
msgstr "--submodule[=<格式>]"

# ERROR: `--submodule` not found in translation
#. type: Plain text
#: en/diff-options.txt:352
#, placeholders:'`--submodule=short`':'`--submodule`':'`--submodule=log`':'linkgit:git-submodule[1]':'`--submodule=diff`':'diff.submodule', priority:280
msgid "Specify how differences in submodules are shown. When specifying `--submodule=short` the 'short' format is used. This format just shows the names of the commits at the beginning and end of the range. When `--submodule` or `--submodule=log` is specified, the 'log' format is used. This format lists the commits in the range like linkgit:git-submodule[1] `summary` does. When `--submodule=diff` is specified, the 'diff' format is used. This format shows an inline diff of the changes in the submodule contents between the commit range. Defaults to `diff.submodule` or the 'short' format if the config option is unset."
msgstr "指定子模块中的差异如何显示。当指定 `--submodule=short` 选项时，会使用 'short' 格式。这种格式只显示范围的开头和结尾处的提交名称。当指定了 `--submodule` 或 `--submodule=log` 时，会使用 'log' 格式。这种格式会像 linkgit:git-submodule[1] `summary` 那样，列出该范围内的提交。当指定了 `--submodule=diff` 时，会使用 'diff' 格式。这个格式显示的是子模块内在提交范围之间的变化差异。默认为 `diff.submodule`，如果配置选项未设置， 则为 `short` 格式。"

#. type: Labeled list
#: en/diff-options.txt:353 en/git-branch.txt:145 en/git-for-each-ref.txt:63 en/git-grep.txt:193 en/git-show-branch.txt:118 en/git-tag.txt:125
#, no-wrap, placeholders:'--color', priority:280
msgid "--color[=<when>]"
msgstr "--color[=<when>]"

#. type: Plain text
#: en/diff-options.txt:357
#, placeholders:'`--color`':'`--color=always`', priority:280
msgid "Show colored diff. `--color` (i.e. without '=<when>') is the same as `--color=always`. '<when>' can be one of `always`, `never`, or `auto`."
msgstr "显示有颜色的差异。`--color`（即不含 '=<何时>'）与 `--color=always` 相同。'<何时>' 可以是 `always`、`never` 或 `auto`。"

#. type: Plain text
#: en/diff-options.txt:360
#, no-wrap, placeholders:'color.ui':'color.diff', priority:280
msgid ""
"\tIt can be changed by the `color.ui` and `color.diff`\n"
"\tconfiguration settings.\n"
msgstr ""
"\t它可以通过 `color.ui` 和 `color.diff` 来改变\n"
"\t配置设置。\n"

#. type: Labeled list
#: en/diff-options.txt:362 en/git-branch.txt:150 en/git-grep.txt:197 en/git-show-branch.txt:123
#, ignore-same, no-wrap, priority:280
msgid "--no-color"
msgstr "--no-color"

#. type: Plain text
#: en/diff-options.txt:364
#, priority:280
msgid "Turn off colored diff."
msgstr "关掉带彩色显示的差异。"

#. type: Plain text
#: en/diff-options.txt:366
#, no-wrap, priority:280
msgid "\tThis can be used to override configuration settings.\n"
msgstr "\t这可以用来覆盖配置设置。\n"

#. type: Plain text
#: en/diff-options.txt:368
#, no-wrap, placeholders:'`--color=never`', priority:280
msgid "\tIt is the same as `--color=never`.\n"
msgstr "\t这和 `--color=never` 相同。\n"

#. type: Labeled list
#: en/diff-options.txt:369
#, no-wrap, placeholders:'--color-moved', priority:280
msgid "--color-moved[=<mode>]"
msgstr "--color-moved[=<模式>]"

#. type: Plain text
#: en/diff-options.txt:371
#, priority:280
msgid "Moved lines of code are colored differently."
msgstr "移动的代码行的颜色不同。"

#. type: Plain text
#: en/diff-options.txt:373
#, no-wrap, placeholders:'diff.colorMoved', priority:280
msgid "\tIt can be changed by the `diff.colorMoved` configuration setting.\n"
msgstr "\t它可以通过 `diff.colorMoved` 配置设置来改变。\n"

#. type: Plain text
#: en/diff-options.txt:377
#, no-wrap, priority:280
msgid ""
"\tThe <mode> defaults to 'no' if the option is not given\n"
"\tand to 'zebra' if the option with no mode is given.\n"
"\tThe mode must be one of:\n"
msgstr ""
"\t如果没有给出该选项，<模式> 默认为 'no'\n"
"\t如果没有给定模式选项，则为 'zebra'。\n"
"\t该模式必须以下其中之一：\n"

#. type: Labeled list
#: en/diff-options.txt:379 en/diff-options.txt:421
#, ignore-same, no-wrap, priority:280
msgid "no"
msgstr "no"

#. type: Plain text
#: en/diff-options.txt:381
#, priority:280
msgid "Moved lines are not highlighted."
msgstr "被移动的行不突出显示。"

#. type: Labeled list
#: en/diff-options.txt:381 en/git-commit.txt:252
#, ignore-same, no-wrap, priority:280
msgid "default"
msgstr "default"

#. type: Plain text
#: en/diff-options.txt:384
#, priority:280
msgid "Is a synonym for `zebra`. This may change to a more sensible mode in the future."
msgstr "是 `zebra` 的同义词。今后可能会改成更合理的模式。"

#. type: Labeled list
#: en/diff-options.txt:384 en/diff-options.txt:453
#, ignore-same, no-wrap, priority:280
msgid "plain"
msgstr "plain"

#. type: Plain text
#: en/diff-options.txt:391
#, placeholders:'color.diff.newMoved':'color.diff.oldMoved', priority:280
msgid "Any line that is added in one location and was removed in another location will be colored with 'color.diff.newMoved'. Similarly 'color.diff.oldMoved' will be used for removed lines that are added somewhere else in the diff. This mode picks up any moved line, but it is not very useful in a review to determine if a block of code was moved without permutation."
msgstr "任何在某个位置被添加，且在另一个位置被删除的行，都会被用 'color.diff.newMoved' 着色。同样的，在差异中在某处删除且在其它地方添加的行会使用 'color.diff.oldMoved' 着色。这种模式可以读取任何被移动的行，但在代码审查中，它不能确定一个代码块是否未经排列而进行了移动。"

#. type: Labeled list
#: en/diff-options.txt:391
#, ignore-same, no-wrap, priority:280
msgid "blocks"
msgstr "blocks"

#. type: Plain text
#: en/diff-options.txt:396
#, placeholders:'color.diff', priority:280
msgid "Blocks of moved text of at least 20 alphanumeric characters are detected greedily. The detected blocks are painted using either the 'color.diff.{old,new}Moved' color. Adjacent blocks cannot be told apart."
msgstr "使用贪心方法检测含至少 20 个字母数字字符的移动文本块。检测到的区块使用 'color.diff.{old,new}Moved' 的颜色。相邻的区块不能被区分开。"

#. type: Labeled list
#: en/diff-options.txt:396
#, ignore-same, no-wrap, priority:280
msgid "zebra"
msgstr "zebra"

#. type: Plain text
#: en/diff-options.txt:401
#, placeholders:'color.diff':'color.diff', priority:280
msgid "Blocks of moved text are detected as in 'blocks' mode. The blocks are painted using either the 'color.diff.{old,new}Moved' color or 'color.diff.{old,new}MovedAlternative'. The change between the two colors indicates that a new block was detected."
msgstr "在 ‘块’ 模式下检测到移动的文本块。块使用 'color.diff.{old,new}Moved' 颜色或 'color.diff.{old,new}MovedAlternative' 颜色。这两种颜色之间的变化表示检测到了新的块。"

#. type: Labeled list
#: en/diff-options.txt:401
#, ignore-same, no-wrap, priority:280
msgid "dimmed-zebra"
msgstr "dimmed-zebra"

#. type: Plain text
#: en/diff-options.txt:406
#, placeholders:'dimmed_zebra', priority:280
msgid "Similar to 'zebra', but additional dimming of uninteresting parts of moved code is performed. The bordering lines of two adjacent blocks are considered interesting, the rest is uninteresting. `dimmed_zebra` is a deprecated synonym."
msgstr "类似于 'zebra' 模式，但对使移动的代码中不关注的部分变暗。相邻两个区块的边界线被认为是重要，其余的部分是无关紧要的。`dimmed_zebra` 是一个被废弃的同义词。"

#. type: Labeled list
#: en/diff-options.txt:408
#, ignore-same, no-wrap, priority:280
msgid "--no-color-moved"
msgstr "--no-color-moved"

#. type: Plain text
#: en/diff-options.txt:411
#, placeholders:'`--color-moved=no`', priority:280
msgid "Turn off move detection. This can be used to override configuration settings. It is the same as `--color-moved=no`."
msgstr "关闭移动检测。这可以用来覆盖配置设置。它与 `--color-moved=no` 相同。"

#. type: Labeled list
#: en/diff-options.txt:412
#, no-wrap, placeholders:'--color-moved-ws=', priority:280
msgid "--color-moved-ws=<modes>"
msgstr "--color-moved-ws=<模式>"

#. type: Plain text
#: en/diff-options.txt:415
#, placeholders:'`--color-moved`', priority:280
msgid "This configures how whitespace is ignored when performing the move detection for `--color-moved`."
msgstr "这将配置在执行 `--color-moved` 选项的移动检测时如何忽略空格。"

#. type: Plain text
#: en/diff-options.txt:417
#, no-wrap, placeholders:'diff.colorMovedWS', priority:280
msgid "\tIt can be set by the `diff.colorMovedWS` configuration setting.\n"
msgstr "\t可以通过 `diff.colorMovedWS` 来设置。\n"

#. type: Plain text
#: en/diff-options.txt:419
#, no-wrap, priority:280
msgid "\tThese modes can be given as a comma separated list:\n"
msgstr "\t这些模式可以通过以逗号分隔的列表给出：\n"

#. type: Plain text
#: en/diff-options.txt:423
#, priority:280
msgid "Do not ignore whitespace when performing move detection."
msgstr "执行移动检测时不忽略空格。"

#. type: Labeled list
#: en/diff-options.txt:423 en/merge-strategies.txt:43
#, ignore-same, no-wrap, priority:280
msgid "ignore-space-at-eol"
msgstr "ignore-space-at-eol"

#. type: Plain text
#: en/diff-options.txt:425 en/diff-options.txt:779
#, priority:280
msgid "Ignore changes in whitespace at EOL."
msgstr "忽略行尾空格的变化。"

#. type: Labeled list
#: en/diff-options.txt:425 en/merge-strategies.txt:41
#, ignore-same, no-wrap, priority:280
msgid "ignore-space-change"
msgstr "ignore-space-change"

#. type: Plain text
#: en/diff-options.txt:429 en/diff-options.txt:785
#, priority:280
msgid "Ignore changes in amount of whitespace. This ignores whitespace at line end, and considers all other sequences of one or more whitespace characters to be equivalent."
msgstr "忽略空格数量的变化。这会忽略行尾的空格，并认为包含一个或多个空格字符的其他序列都是等同的。"

#. type: Labeled list
#: en/diff-options.txt:429 en/merge-strategies.txt:42
#, ignore-same, no-wrap, priority:280
msgid "ignore-all-space"
msgstr "ignore-all-space"

#. type: Plain text
#: en/diff-options.txt:432 en/diff-options.txt:791
#, priority:280
msgid "Ignore whitespace when comparing lines. This ignores differences even if one line has whitespace where the other line has none."
msgstr "比较行时忽略空格。即使一行有空格而另一行没有空格，也会忽略差异。"

#. type: Labeled list
#: en/diff-options.txt:432
#, ignore-same, no-wrap, priority:280
msgid "allow-indentation-change"
msgstr "allow-indentation-change"

#. type: Plain text
#: en/diff-options.txt:437
#, priority:280
msgid "Initially ignore any whitespace in the move detection, then group the moved code blocks only into a block if the change in whitespace is the same per line. This is incompatible with the other modes."
msgstr "在最初移动检测中忽略的任何空格，然后只在每行的空格变化相同的情况下，将移动的代码块归为一个块。这与其他模式是不兼容的。"

#. type: Labeled list
#: en/diff-options.txt:439
#, ignore-same, no-wrap, priority:280
msgid "--no-color-moved-ws"
msgstr "--no-color-moved-ws"

#. type: Plain text
#: en/diff-options.txt:443
#, placeholders:'`--color-moved-ws=no`', priority:280
msgid "Do not ignore whitespace when performing move detection. This can be used to override configuration settings. It is the same as `--color-moved-ws=no`."
msgstr "执行移动检测时，不忽略空格。这可以用来覆盖配置。它与 `--color-moved-ws=no` 相同。"

#. type: Labeled list
#: en/diff-options.txt:444
#, no-wrap, placeholders:'--word-diff', priority:280
msgid "--word-diff[=<mode>]"
msgstr "--word-diff[=<模式>]"

#. type: Plain text
#: en/diff-options.txt:449
#, placeholders:'`--word-diff-regex`', priority:280
msgid "Show a word diff, using the <mode> to delimit changed words. By default, words are delimited by whitespace; see `--word-diff-regex` below. The <mode> defaults to 'plain', and must be one of:"
msgstr "显示词的差异，用 <模式> 来分隔已更改的词。默认情况下，单词是以空格分隔；请参考 `--word-diff-regex`。<模式> 默认为 `plain`，并且必须是以下其中之一："

#. type: Plain text
#: en/diff-options.txt:453
#, placeholders:'`--color`', priority:280
msgid "Highlight changed words using only colors. Implies `--color`."
msgstr "只用颜色突出显示已更改的单词。暗含 `--color` 选项。"

#. type: Plain text
#: en/diff-options.txt:457
#, priority:280
msgid "Show words as `[-removed-]` and `{+added+}`. Makes no attempts to escape the delimiters if they appear in the input, so the output may be ambiguous."
msgstr "显示更改的词为 `[-removed-]` 和 `{+added+}`。如果在输入中出现定界符，则不尝试转义，所以输出可能是多义的。"

#. type: Labeled list
#: en/diff-options.txt:457
#, ignore-same, no-wrap, priority:280
msgid "porcelain"
msgstr "porcelain"

#. type: Plain text
#: en/diff-options.txt:464
#, priority:280
msgid "Use a special line-based format intended for script consumption. Added/removed/unchanged runs are printed in the usual unified diff format, starting with a `+`/`-`/` ` character at the beginning of the line and extending to the end of the line. Newlines in the input are represented by a tilde `~` on a line of its own."
msgstr "使用一种特殊的、基于行的格式，供脚本使用。添加/删除/未更改的运行数据以通常的统一的差异格式输出，行的开头以 `+` / `-` / ` ` 字符开始，一直到行的结尾。输入中的新行用单行上的 `~`表示。"

#. type: Labeled list
#: en/diff-options.txt:464 en/git-daemon.txt:131 en/git-submodule.txt:178
#, ignore-same, no-wrap, priority:280
msgid "none"
msgstr "none"

#. type: Plain text
#: en/diff-options.txt:466
#, priority:280
msgid "Disable word diff again."
msgstr "再次禁用单词差异模式。"

#. type: Plain text
#: en/diff-options.txt:470
#, priority:280
msgid "Note that despite the name of the first mode, color is used to highlight the changed parts in all modes if enabled."
msgstr "请注意，无论第一个模式的名称是什么，如果启用该选项，将在所有模式中使用颜色，以高亮显示更改的部分。"

#. type: Labeled list
#: en/diff-options.txt:471
#, no-wrap, placeholders:'--word-diff-regex=', priority:280
msgid "--word-diff-regex=<regex>"
msgstr "--word-diff-regex=<正则表达式>"

#. type: Plain text
#: en/diff-options.txt:475
#, placeholders:'`--word-diff`', priority:280
msgid "Use <regex> to decide what a word is, instead of considering runs of non-whitespace to be a word. Also implies `--word-diff` unless it was already enabled."
msgstr "使用 <正则表达式> 来确定单词的格式，而不是将一串非空白行视为单词。除非已启用，否则还暗含 `--word-diff` 选项。"

#. type: Plain text
#: en/diff-options.txt:483
#, priority:280
msgid "Every non-overlapping match of the <regex> is considered a word. Anything between these matches is considered whitespace and ignored(!) for the purposes of finding differences. You may want to append `|[^[:space:]]` to your regular expression to make sure that it matches all non-whitespace characters. A match that contains a newline is silently truncated(!) at the newline."
msgstr "<正则表达式> 匹配的的每一个非重叠的匹配都被视为一个单词。在这些匹配项之间的任何内容都被认为是空白，并且在查找差异时被忽略(!)。您可能需要在您的正则表达式中附加 `|[^[:space:]]`，以确保它匹配所有非空格字符。包含换行的匹配会在换行处被截断(!)。"

#. type: Plain text
#: en/diff-options.txt:486
#, placeholders:'`--word-diff-regex=', priority:280
msgid "For example, `--word-diff-regex=.` will treat each character as a word and, correspondingly, show differences character by character."
msgstr "例如，`--word-diff-regex=.` 将把每个字符当作一个单词，并相应地逐个字符显示差异。"

#. type: Plain text
#: en/diff-options.txt:491
#, placeholders:'linkgit:gitattributes[5]':'linkgit:git-config[1]', priority:280
msgid "The regex can also be set via a diff driver or configuration option, see linkgit:gitattributes[5] or linkgit:git-config[1]. Giving it explicitly overrides any diff driver or configuration setting. Diff drivers override configuration settings."
msgstr "正则表达式也可以通过差异程序或配置选项来设置，参见 linkgit:gitattributes[5] 或 linkgit:git-config[1]。显式指明会覆盖任何程序或配置。差异程序会覆盖配置。"

#. type: Labeled list
#: en/diff-options.txt:492
#, no-wrap, placeholders:'--color-words', priority:280
msgid "--color-words[=<regex>]"
msgstr "--color-words[=<正则表达式>]"

#. type: Plain text
#: en/diff-options.txt:495
#, placeholders:'`--word-diff=color`':'`--word-diff-regex=', priority:280
msgid "Equivalent to `--word-diff=color` plus (if a regex was specified) `--word-diff-regex=<regex>`."
msgstr "与 `--word-diff=color` 和（如果指明了正则表达式）`--word-diff-regex=<正则表达式>` 两个选项含义相同。"

#. type: Labeled list
#: en/diff-options.txt:497 en/git-status.txt:143
#, ignore-same, no-wrap, priority:280
msgid "--no-renames"
msgstr "--no-renames"

#. type: Plain text
#: en/diff-options.txt:500
#, priority:280
msgid "Turn off rename detection, even when the configuration file gives the default to do so."
msgstr "关闭重命名检测，即使配置文件给出的默认是这样做。"

#. type: Labeled list
#: en/diff-options.txt:501
#, ignore-same, no-wrap, priority:280
msgid "--[no-]rename-empty"
msgstr "--[no-]rename-empty"

#. type: Plain text
#: en/diff-options.txt:503
#, priority:280
msgid "Whether to use empty blobs as rename source."
msgstr "是否使用空的数据对象作为重命名源。"

#. type: Labeled list
#: en/diff-options.txt:505 en/git-apply.txt:58
#, ignore-same, no-wrap, priority:280
msgid "--check"
msgstr "--check"

#. type: Plain text
#: en/diff-options.txt:514
#, placeholders:'core.whitespace':'--exit-code', priority:280
msgid "Warn if changes introduce conflict markers or whitespace errors. What are considered whitespace errors is controlled by `core.whitespace` configuration. By default, trailing whitespaces (including lines that consist solely of whitespaces) and a space character that is immediately followed by a tab character inside the initial indent of the line are considered whitespace errors. Exits with non-zero status if problems are found. Not compatible with --exit-code."
msgstr "如果更改引入冲突标记或空格错误，则发出警告。哪些被认为是空格错误是由 `core.whitespace` 配置控制的。默认情况下，行尾部的空格字符（包括仅由空格字符组成的行）和紧跟在行初缩进内 tab 字符后的空格字符，都被认为是空格字符错误。如果发现问题，则以非零状态退出。与 --exit-code 选项不兼容。"

#. type: Labeled list
#: en/diff-options.txt:515
#, no-wrap, placeholders:'--ws-error-highlight=', priority:280
msgid "--ws-error-highlight=<kind>"
msgstr "--ws-error-highlight=<种类>"

#. type: Plain text
#: en/diff-options.txt:524
#, placeholders:'diff.wsErrorHighlight':'color.diff.whitespace', priority:280
msgid "Highlight whitespace errors in the `context`, `old` or `new` lines of the diff. Multiple values are separated by comma, `none` resets previous values, `default` reset the list to `new` and `all` is a shorthand for `old,new,context`. When this option is not given, and the configuration variable `diff.wsErrorHighlight` is not set, only whitespace errors in `new` lines are highlighted. The whitespace errors are colored with `color.diff.whitespace`."
msgstr "突出显示差异中 `context`（上下文）、`old`（旧）或 `new`（新）行中的空格错误。多个值用逗号隔开，`none` 选项会重置以前的值，`default` 重置列表为 `new`，`all` 是 `old,new,context` 的简写。当没有给定这个选项，并且配置变量 `diff.wsErrorHighlight` 没有设置时，只有 `new` 行中的空格错误会被高亮显示。空格错误会用 `color.diff.whitespace` 配置进行着色。"

#. type: Labeled list
#: en/diff-options.txt:527
#, ignore-same, no-wrap, priority:280
msgid "--full-index"
msgstr "--full-index"

#. type: Plain text
#: en/diff-options.txt:531
#, priority:280
msgid "Instead of the first handful of characters, show the full pre- and post-image blob object names on the \"index\" line when generating patch format output."
msgstr "在生成补丁格式输出时，在 `index`（索引）行上显示完整的图像前和图像后数据对象名称，而不仅是前几个字符。"

#. type: Labeled list
#: en/diff-options.txt:532 en/git-apply.txt:161
#, ignore-same, no-wrap, priority:280
msgid "--binary"
msgstr "--binary"

#. type: Plain text
#: en/diff-options.txt:535
#, placeholders:'`--full-index`':'git-apply', priority:280
msgid "In addition to `--full-index`, output a binary diff that can be applied with `git-apply`."
msgstr "除了 `--full-index` 输出的差异之外，输出二进制的差异。其可以用 `git-apply` 命令来应用。暗含 `--patch` 选项。"

#. type: Labeled list
#: en/diff-options.txt:539 en/git-ls-files.txt:186 en/git-ls-tree.txt:72 en/git-show-ref.txt:79
#, no-wrap, placeholders:'--abbrev', priority:280
msgid "--abbrev[=<n>]"
msgstr "--abbrev[=<n>]"

#. type: Plain text
#: en/diff-options.txt:548
#, placeholders:'`--full-index`':'`--full-index`':'`--abbrev`':'`--abbrev=', priority:280
msgid "Instead of showing the full 40-byte hexadecimal object name in diff-raw format output and diff-tree header lines, show the shortest prefix that is at least '<n>' hexdigits long that uniquely refers the object. In diff-patch output format, `--full-index` takes higher precedence, i.e. if `--full-index` is specified, full blob names will be shown regardless of `--abbrev`. Non default number of digits can be specified with `--abbrev=<n>`."
msgstr "在 diff-raw 格式输出和 diff-tree 头文件行中，不显示完整的 40 字节十六进制对象名称，而是显示唯一指向对象的最短前缀，长度至少为 '<n>' 位十六进制数字。 在 diff-patch 输出格式中，`--full-index` 优先，也就是说，如果指定了 `--full-index`，则无论 `--abbrev` 如何，都会显示完整的 blob 名称。 可以使用 `--abbrev=<n>` 指定非默认位数。"

#. type: Labeled list
#: en/diff-options.txt:549
#, no-wrap, priority:280
msgid "-B[<n>][/<m>]"
msgstr "-B[<n>][/<m>]"

#. type: Labeled list
#: en/diff-options.txt:550
#, no-wrap, placeholders:'--break-rewrites', priority:280
msgid "--break-rewrites[=[<n>][/<m>]]"
msgstr "--break-rewrites[=[<n>][/<m>]]"

#. type: Plain text
#: en/diff-options.txt:553
#, priority:280
msgid "Break complete rewrite changes into pairs of delete and create. This serves two purposes:"
msgstr "将完整的重写更改切分成删除和创建对（pair）。这有两个目的："

#. type: Plain text
#: en/diff-options.txt:563
#, priority:280
msgid "It affects the way a change that amounts to a total rewrite of a file not as a series of deletion and insertion mixed together with a very few lines that happen to match textually as the context, but as a single deletion of everything old followed by a single insertion of everything new, and the number `m` controls this aspect of the -B option (defaults to 60%). `-B/70%` specifies that less than 30% of the original should remain in the result for Git to consider it a total rewrite (i.e. otherwise the resulting patch will be a series of deletion and insertion mixed together with context lines)."
msgstr "它会影响决定更改形式的阈值，当单个文件内修改总量达到一定值时，会认为该文件进行了完全重写，而不是将一系列删除和插入操作视为修改。如果视为多个删除和插入修改，修改中的行可能会碰巧在文本上与原文一致，从而被当作上下文。选项中的数字 `m` 控制 -B 选项的这一方面（默认为 60％）。`-B/70％` 表示，如果在结果中保留的原始内容少于原始内容的 30％，则 Git 认为它是完全重写的（否则，生成的补丁将是一系列删除和插入，并与上下文行混合在一起）。"

#. type: Plain text
#: en/diff-options.txt:571
#, priority:280
msgid "When used with -M, a totally-rewritten file is also considered as the source of a rename (usually -M only considers a file that disappeared as the source of a rename), and the number `n` controls this aspect of the -B option (defaults to 50%). `-B20%` specifies that a change with addition and deletion compared to 20% or more of the file's size are eligible for being picked up as a possible source of a rename to another file."
msgstr "使用 -M 选项时，一个完全改写的文件也被认为是重命名文件的来源（通常 -M 只考查一个消失文件作为重命名的来源)。选项中的数量 `n` 控制 -B 选项的这一方面（默认为 50％)。`-B20%` 表明，当插入与删除比 20％ 的文件大小更多，该文件可作为重命名到另一文件的可能来源。"

#. type: Labeled list
#: en/diff-options.txt:572
#, no-wrap, priority:280
msgid "-M[<n>]"
msgstr "-M[<n>]"

#. type: Labeled list
#: en/diff-options.txt:573 en/git-status.txt:147
#, no-wrap, placeholders:'--find-renames', priority:280
msgid "--find-renames[=<n>]"
msgstr "--find-renames[=<n>]"

#. type: Plain text
#: en/diff-options.txt:576
#, no-wrap, priority:280
msgid "\tDetect renames.\n"
msgstr "\t重命名检测。\n"

#. type: Plain text
#: en/diff-options.txt:581
#, no-wrap, placeholders:'`--follow`', priority:280
msgid ""
"\tIf generating diffs, detect and report renames for each commit.\n"
"\tFor following files across renames while traversing history, see\n"
"\t`--follow`.\n"
msgstr ""
"\t如果制成差异，检测并报告每个提交中的重命名。\n"
"\t对于每个在遍历历史时重命名的文件，参见\n"
"\t`--follow`。\n"

#. type: Plain text
#: en/diff-options.txt:591
#, no-wrap, priority:280
msgid ""
"\tIf `n` is specified, it is a threshold on the similarity\n"
"\tindex (i.e. amount of addition/deletions compared to the\n"
"\tfile's size). For example, `-M90%` means Git should consider a\n"
"\tdelete/add pair to be a rename if more than 90% of the file\n"
"\thasn't changed.  Without a `%` sign, the number is to be read as\n"
"\ta fraction, with a decimal point before it.  I.e., `-M5` becomes\n"
"\t0.5, and is thus the same as `-M50%`.  Similarly, `-M05` is\n"
"\tthe same as `-M5%`.  To limit detection to exact renames, use\n"
"\t`-M100%`.  The default similarity index is 50%.\n"
msgstr ""
"\t如果指定了 `n`，则其为相似度指数阈值（即相比于文件大小的增/删量）。\n"
"\t例如，`-M90％` 表示如果文件90％以上的内容没有更改，则 Git 应将删除/添加对视为重命名。\n"
"\t如果没有 `％` 符号，则该数字应作为小数读取，并在其前面加上小数点。\n"
" \t即 `-M5` 变为 0.5，因此与 `-M50％` 相同。 同样，`-M05` 与 `-M5％` 相同。\n"
" \t要将检测限制为精确的重命名，请使用 `-M100％`。 默认相似度指数为50％。\n"

#. type: Labeled list
#: en/diff-options.txt:592
#, no-wrap, priority:280
msgid "-C[<n>]"
msgstr "-C[<n>]"

#. type: Labeled list
#: en/diff-options.txt:593
#, no-wrap, placeholders:'--find-copies', priority:280
msgid "--find-copies[=<n>]"
msgstr "--find-copies[=<n>]"

#. type: Plain text
#: en/diff-options.txt:596
#, placeholders:'`--find-copies-harder`', priority:280
msgid "Detect copies as well as renames. See also `--find-copies-harder`. If `n` is specified, it has the same meaning as for `-M<n>`."
msgstr "检测复制与重命名。参见 `--find-copies-harder`。如果指定了 `n`，则其与 `-M<n>` 含义相同。"

#. type: Labeled list
#: en/diff-options.txt:597 en/git-svn.txt:626
#, ignore-same, no-wrap, priority:280
msgid "--find-copies-harder"
msgstr "--find-copies-harder"

#. type: Plain text
#: en/diff-options.txt:605
#, placeholders:'`-C`':'`-C`', priority:280
msgid "For performance reasons, by default, `-C` option finds copies only if the original file of the copy was modified in the same changeset. This flag makes the command inspect unmodified files as candidates for the source of copy. This is a very expensive operation for large projects, so use it with caution. Giving more than one `-C` option has the same effect."
msgstr "出于性能考虑，默认情况下，`-C` 选项只在复制的原始文件在相同的变更集中被修改时才会查找复制。这个标志使命令检查未修改的文件作为复制源的候选文件。 对于大型项目来说，这是一个非常耗时的操作，所以要谨慎使用。 给出一个以上的 `-C` 选项有同样的效果。"

#. type: Labeled list
#: en/diff-options.txt:606 en/git-branch.txt:104 en/git-http-push.txt:45
#, ignore-same, no-wrap, priority:280
msgid "-D"
msgstr "-D"

#. type: Labeled list
#: en/diff-options.txt:607
#, ignore-same, no-wrap, priority:280
msgid "--irreversible-delete"
msgstr "--irreversible-delete"

#. type: Plain text
#: en/diff-options.txt:615
#, priority:280
msgid "Omit the preimage for deletes, i.e. print only the header but not the diff between the preimage and `/dev/null`. The resulting patch is not meant to be applied with `patch` or `git apply`; this is solely for people who want to just concentrate on reviewing the text after the change. In addition, the output obviously lacks enough information to apply such a patch in reverse, even manually, hence the name of the option."
msgstr "删除时省略原内容，即只打印头信息，而不打原内容和 `/dev/null` 之间的差异。所产生的补丁并不是要用于 `patch` 或 `git apply`；这只是为了让人们只专注于审查修改后的文本。此外，输出结果显然缺乏足够的信息来反转，或手动应用这样一个补丁，因此这个选项的名称如此。"

#. type: Plain text
#: en/diff-options.txt:618
#, placeholders:'`-B`', priority:280
msgid "When used together with `-B`, omit also the preimage in the deletion part of a delete/create pair."
msgstr "当与 `-B` 一起使用时，也省略删除/创建对中删除部分的原内容。"

#. type: Labeled list
#: en/diff-options.txt:619 en/git-svn.txt:625
#, no-wrap, priority:280
msgid "-l<num>"
msgstr "-l<数量>"

#. type: Plain text
#: en/diff-options.txt:631
#, placeholders:'`-M`':'`-C`':'diff.renameLimit', priority:280
msgid "The `-M` and `-C` options involve some preliminary steps that can detect subsets of renames/copies cheaply, followed by an exhaustive fallback portion that compares all remaining unpaired destinations to all relevant sources. (For renames, only remaining unpaired sources are relevant; for copies, all original sources are relevant.) For N sources and destinations, this exhaustive check is O(N^2). This option prevents the exhaustive portion of rename/copy detection from running if the number of source/destination files involved exceeds the specified number. Defaults to diff.renameLimit. Note that a value of 0 is treated as unlimited."
msgstr "`-M` 和 `-C` 选项涉及一些初步步骤，可以廉价地检测重命名/副本的子集，然后是详尽的后备部分，将所有剩余的未配对目的地与所有相关源进行比较。 （对于重命名，只有剩余的未配对源是相关的；对于副本，所有原始源都是相关的。）对于 N 个源和目的地，这个详尽的检查是 O(N^2)。如果涉及的源/目标文件数量超过指定数量，则此选项可防止重命名/复制检测的详尽部分运行。默认为 diff.renameLimit。请注意，值 0 被视为无限制。"

#. type: Labeled list
#: en/diff-options.txt:633
#, ignore-ellipsis, no-wrap, placeholders:'--diff-filter=[(A|C|D|M|R|T|U|X|B)', priority:280
msgid "--diff-filter=[(A|C|D|M|R|T|U|X|B)...[*]]"
msgstr "--diff-filter=[(A|C|D|M|R|T|U|X|B)...[*]]"

#. type: Plain text
#: en/diff-options.txt:644
#, ignore-ellipsis, priority:280
msgid "Select only files that are Added (`A`), Copied (`C`), Deleted (`D`), Modified (`M`), Renamed (`R`), have their type (i.e. regular file, symlink, submodule, ...) changed (`T`), are Unmerged (`U`), are Unknown (`X`), or have had their pairing Broken (`B`). Any combination of the filter characters (including none) can be used. When `*` (All-or-none) is added to the combination, all paths are selected if there is any file that matches other criteria in the comparison; if there is no file that matches other criteria, nothing is selected."
msgstr "只选择添加（`A`）、复制（`C`）、删除（`D`）、修改（`M`）、重命名（`R`）、类型（即常规文件、符号链接、子模块......）改变（`T`）、未合并（`U`）、未知（`X`）或配对被破坏（`B`）的文件。可以使用过滤字符的任何组合（包括空）。当组合中加入 `*`（全部或空）时，如果在比较中有任何文件与其他条件匹配，则选择所有路径；如果没有符合其他条件的文件，则不会选择任何内容。"

#. type: Plain text
#: en/diff-options.txt:647
#, placeholders:'`--diff-filter=ad`', priority:280
msgid "Also, these upper-case letters can be downcased to exclude. E.g. `--diff-filter=ad` excludes added and deleted paths."
msgstr "另外，这些大写字母也可以通过使用小写排除。例如：`--diff-filter=ad` 排除添加和删除的路径。"

#. type: Plain text
#: en/diff-options.txt:650
#, priority:280
msgid "Note that not all diffs can feature all types. For instance, copied and renamed entries cannot appear if detection for those types is disabled."
msgstr "请注意，并非所有差异都能显示所有类型。例如，如果禁用了复制和重命名条目类型的检测，这些条目就不会出现。"

#. type: Labeled list
#: en/diff-options.txt:651
#, no-wrap, priority:280
msgid "-S<string>"
msgstr "-S<string>"

#. type: Plain text
#: en/diff-options.txt:655
#, priority:280
msgid "Look for differences that change the number of occurrences of the specified string (i.e. addition/deletion) in a file. Intended for the scripter's use."
msgstr "寻找改变文件中指定字符串出现次数的差异（即增加/删除）。供脚本编写者使用。"

#. type: Plain text
#: en/diff-options.txt:661
#, placeholders:'`-S`', priority:280
msgid "It is useful when you're looking for an exact block of code (like a struct), and want to know the history of that block since it first came into being: use the feature iteratively to feed the interesting block in the preimage back into `-S`, and keep going until you get the very first version of the block."
msgstr "当您正在寻找确切的代码块（如结构体），并且想知道该块自首次出现以来的历史记录时，这将非常有用：通过 `-S` 选项迭代，将原文件中的感兴趣的块显示出，并继续进行，直到获得该块的第一个版本。"

#. type: Plain text
#: en/diff-options.txt:663
#, priority:280
msgid "Binary files are searched as well."
msgstr "二进制文件也会被搜索到。"

#. type: Labeled list
#: en/diff-options.txt:664
#, no-wrap, priority:280
msgid "-G<regex>"
msgstr "-G<正则表达式>"

#. type: Plain text
#: en/diff-options.txt:667
#, priority:280
msgid "Look for differences whose patch text contains added/removed lines that match <regex>."
msgstr "查找其补丁文本包含与 <正则表达式> 匹配的添加/删除行的差异。"

#. type: Plain text
#: en/diff-options.txt:671
#, placeholders:'--pickaxe-regex`', priority:280
msgid "To illustrate the difference between `-S<regex> --pickaxe-regex` and `-G<regex>`, consider a commit with the following diff in the same file:"
msgstr "为了说明 `-S<正则表达式> --pickaxe-regex` 和 `-G<正则表达式>` 之间的区别，假设某次提交在同一文件中有以下差异："

#. type: delimited block -
#: en/diff-options.txt:676
#, ignore-ellipsis, no-wrap, priority:280
msgid ""
"+    return frotz(nitfol, two->ptr, 1, 0);\n"
"...\n"
"-    hit = frotz(nitfol, mf2.ptr, 1, 0);\n"
msgstr ""
"+    return frotz(nitfol, two->ptr, 1, 0);\n"
"...\n"
"-    hit = frotz(nitfol, mf2.ptr, 1, 0);\n"

#. type: Plain text
#: en/diff-options.txt:681
#, placeholders:'--pickaxe-regex`', priority:280
msgid "While `git log -G\"frotz\\(nitfol\"` will show this commit, `git log -S\"frotz\\(nitfol\" --pickaxe-regex` will not (because the number of occurrences of that string did not change)."
msgstr "`git log -G \"frotz\\(nitfol\"` 会显示这次提交，但 `git log -S \"frotz\\(nitfol\" --pickaxe-regex` 不会显示（因为该字符串的出现次数没有改变）。"

#. type: Plain text
#: en/diff-options.txt:684
#, placeholders:'`--text`', priority:280
msgid "Unless `--text` is supplied patches of binary files without a textconv filter will be ignored."
msgstr "除非提供 `--text`，否则没有 textconv 过滤器的二进制文件补丁将被忽略。"

#. type: Plain text
#: en/diff-options.txt:687
#, placeholders:'linkgit:gitdiffcore[7]', priority:280
msgid "See the 'pickaxe' entry in linkgit:gitdiffcore[7] for more information."
msgstr "更多信息请参见 linkgit:gitdiffcore[7] 中的 'pickaxe' 条目。"

#. type: Labeled list
#: en/diff-options.txt:688
#, no-wrap, placeholders:'--find-object=', priority:280
msgid "--find-object=<object-id>"
msgstr "--find-object=<对象ID>"

#. type: Plain text
#: en/diff-options.txt:693
#, placeholders:'`-S`', priority:280
msgid "Look for differences that change the number of occurrences of the specified object. Similar to `-S`, just the argument is different in that it doesn't search for a specific string but for a specific object id."
msgstr "查找指定对象出现次数的差异。与 `-S` 类似，只是参数不同：它不搜索特定的字符串，而是搜索特定的对象 id。"

#. type: Plain text
#: en/diff-options.txt:696
#, placeholders:'`-t`':'git-log', priority:280
msgid "The object can be a blob or a submodule commit. It implies the `-t` option in `git-log` to also find trees."
msgstr "该对象可以是一个 blob 或一个子模块提交。它意味着 `git-log` 中的 `-t` 选项也能找到工作树。"

#. type: Labeled list
#: en/diff-options.txt:697
#, ignore-same, no-wrap, priority:280
msgid "--pickaxe-all"
msgstr "--pickaxe-all"

#. type: Plain text
#: en/diff-options.txt:701
#, placeholders:'`-S`':'`-G`', priority:280
msgid "When `-S` or `-G` finds a change, show all the changes in that changeset, not just the files that contain the change in <string>."
msgstr "当使用 `-S` 或 `-G` 选项找到一个更改时，显示该更改集中的所有更改，而不仅仅是显示包含 <string> 更改的文件。"

#. type: Labeled list
#: en/diff-options.txt:702
#, ignore-same, no-wrap, priority:280
msgid "--pickaxe-regex"
msgstr "--pickaxe-regex"

#. type: Plain text
#: en/diff-options.txt:705
#, placeholders:'`-S`', priority:280
msgid "Treat the <string> given to `-S` as an extended POSIX regular expression to match."
msgstr "将 `-S` 选项的 <string> 参数当作扩展的 POSIX 正则表达式来匹配。"

#. type: Labeled list
#: en/diff-options.txt:708 en/git-mergetool.txt:96
#, no-wrap, priority:280
msgid "-O<orderfile>"
msgstr "-O<顺序控制文件>"

#. type: Plain text
#: en/diff-options.txt:713
#, placeholders:'diff.orderFile':'linkgit:git-config[1]':'diff.orderFile', priority:280
msgid "Control the order in which files appear in the output. This overrides the `diff.orderFile` configuration variable (see linkgit:git-config[1]). To cancel `diff.orderFile`, use `-O/dev/null`."
msgstr "控制文件在输出中出现的顺序。这将覆盖 `diff.orderFile` 配置变量（参见 linkgit:git-config[1]）。要取消 `diff.orderFile`，请使用 `-O/dev/null`。"

#. type: Plain text
#: en/diff-options.txt:725
#, priority:280
msgid "The output order is determined by the order of glob patterns in <orderfile>. All files with pathnames that match the first pattern are output first, all files with pathnames that match the second pattern (but not the first) are output next, and so on. All files with pathnames that do not match any pattern are output last, as if there was an implicit match-all pattern at the end of the file. If multiple pathnames have the same rank (they match the same pattern but no earlier patterns), their output order relative to each other is the normal order."
msgstr "输出顺序由 <顺序控制文件> 中的 glob 模式的顺序决定。所有路径名与第一个模式匹配的文件首先输出，路径名与第二个模式匹配（但不与第一个模式匹配）的文件其次输出，以此类推。所有路径名与任何模式匹配的文件会最后输出，就像在文件末尾有一个隐含的全部匹配模式。如果多个路径名具有相同的等级（它们匹配相同的模式，但没有匹配先前的模式），它们相对于彼此的输出顺序是正常的。"

#. type: Plain text
#: en/diff-options.txt:727
#, priority:280
msgid "<orderfile> is parsed as follows:"
msgstr "<顺序控制文件> 格式如下："

#. type: Plain text
#: en/diff-options.txt:731
#, priority:280
msgid "Blank lines are ignored, so they can be used as separators for readability."
msgstr "空白行会被忽略，因此可以用它们作为分隔符，以保证可读性。"

#. type: Plain text
#: en/diff-options.txt:735
#, priority:280
msgid "Lines starting with a hash (\"`#`\") are ignored, so they can be used for comments. Add a backslash (\"`\\`\") to the beginning of the pattern if it starts with a hash."
msgstr "以井号（\"`#`\"）开头的行会被忽略，所以它们可以用来做注释。如果模式以井号开头，则需要在模式的开头加上反斜杠（\"`\\`\"）。"

#. type: Plain text
#: en/diff-options.txt:737
#, priority:280
msgid "Each other line contains a single pattern."
msgstr "每一行都包含一个模式。"

#. type: Plain text
#: en/diff-options.txt:744
#, placeholders:'FNM_PATHNAME', priority:280
msgid "Patterns have the same syntax and semantics as patterns used for fnmatch(3) without the FNM_PATHNAME flag, except a pathname also matches a pattern if removing any number of the final pathname components matches the pattern. For example, the pattern \"`foo*bar`\" matches \"`fooasdfbar`\" and \"`foo/bar/baz/asdf`\" but not \"`foobarx`\"."
msgstr "模式的语法和语义与 fnmatch(3) 中使用的相同，不包括 FNM_PATHNAME 标志，但在删除路径名中结尾任意几个成分后匹配的情况下例外。例如，模式 \"`foo*bar`\" 匹配 \"`fooasdfbar`\" 和 \"`foo/bar/baz/asdf`\"，但不匹配 \"`foobarx`\"。"

# ERROR: --skip-to= not found in translation
#. type: Labeled list
#: en/diff-options.txt:745 en/git-difftool.txt:41
#, no-wrap, placeholders:'--skip-to=', priority:280
msgid "--skip-to=<file>"
msgstr "--skip-to=<文件>"

#. type: Labeled list
#: en/diff-options.txt:746 en/git-difftool.txt:37
#, no-wrap, placeholders:'--rotate-to=', priority:280
msgid "--rotate-to=<file>"
msgstr "--rotate-to=<文件>"

#. type: Plain text
#: en/diff-options.txt:752
#, priority:280
msgid "Discard the files before the named <file> from the output (i.e. 'skip to'), or move them to the end of the output (i.e. 'rotate to'). These options were invented primarily for the use of the `git difftool` command, and may not be very useful otherwise."
msgstr "从输出中丢弃命名 <文件> 之前的文件（即 'skip to'），或将它们移到输出的末尾（即 'rotate to'）。 这些选项主要是为使用 `git difftool` 命令而发明的，在其他情况下可能用处不大。"

#. type: Labeled list
#: en/diff-options.txt:754 en/git-apply.txt:105 en/git-cvsimport.txt:168
#, ignore-same, no-wrap, priority:280
msgid "-R"
msgstr "-R"

#. type: Plain text
#: en/diff-options.txt:757
#, priority:280
msgid "Swap two inputs; that is, show differences from index or on-disk file to tree contents."
msgstr "交换两个输入；即显示从索引或磁盘文件到目录树内容的差异。"

#. type: Labeled list
#: en/diff-options.txt:759
#, no-wrap, placeholders:'--relative', priority:280
msgid "--relative[=<path>]"
msgstr "--relative[=<路径>]"

#. type: Labeled list
#: en/diff-options.txt:760
#, ignore-same, no-wrap, priority:280
msgid "--no-relative"
msgstr "--no-relative"

#. type: Plain text
#: en/diff-options.txt:769
#, placeholders:'`--no-relative`':'diff.relative':'`--relative`', priority:280
msgid "When run from a subdirectory of the project, it can be told to exclude changes outside the directory and show pathnames relative to it with this option. When you are not in a subdirectory (e.g. in a bare repository), you can name which subdirectory to make the output relative to by giving a <path> as an argument. `--no-relative` can be used to countermand both `diff.relative` config option and previous `--relative`."
msgstr "当从项目的子目录中运行时，可以排除目录外的变化，并通过这个选项显示相对于它的路径名。当你不在子目录中时（例如在纯仓库中），你可以通过 <路径> 参数来指明要使输出相对于哪个子目录。`--no-relative` 可以用来取消 `diff.relative`配置选项和之前的 `--relative` 选项。"

#. type: Labeled list
#: en/diff-options.txt:770 en/fetch-options.txt:5 en/git-archimport.txt:99 en/git-branch.txt:176 en/git-checkout-index.txt:39 en/git-commit.txt:67 en/git-cvsexportcommit.txt:45 en/git-cvsimport.txt:135 en/git-grep.txt:71 en/git-help.txt:49 en/git-merge-base.txt:71 en/git-merge-index.txt:26 en/git-repack.txt:31 en/git-show-branch.txt:47 en/git-stash.txt:159 en/git-tag.txt:60
#, ignore-same, no-wrap, priority:280
msgid "-a"
msgstr "-a"

#. type: Labeled list
#: en/diff-options.txt:771 en/git-grep.txt:72
#, ignore-same, no-wrap, priority:280
msgid "--text"
msgstr "--text"

#. type: Plain text
#: en/diff-options.txt:773
#, priority:280
msgid "Treat all files as text."
msgstr "将一切输入文件视为文本。"

#. type: Labeled list
#: en/diff-options.txt:774
#, ignore-same, no-wrap, priority:280
msgid "--ignore-cr-at-eol"
msgstr "--ignore-cr-at-eol"

#. type: Plain text
#: en/diff-options.txt:776
#, priority:280
msgid "Ignore carriage-return at the end of line when doing a comparison."
msgstr "在进行比较时，忽略行末的回车。"

#. type: Labeled list
#: en/diff-options.txt:777
#, ignore-same, no-wrap, priority:280
msgid "--ignore-space-at-eol"
msgstr "--ignore-space-at-eol"

#. type: Labeled list
#: en/diff-options.txt:781 en/git-am.txt:119 en/git-apply.txt:183
#, ignore-same, no-wrap, priority:280
msgid "--ignore-space-change"
msgstr "--ignore-space-change"

#. type: Labeled list
#: en/diff-options.txt:786 en/git-blame.txt:84 en/git-cvsexportcommit.txt:71 en/git-grep.txt:104 en/git-hash-object.txt:31 en/git-help.txt:106
#, ignore-same, no-wrap, priority:280
msgid "-w"
msgstr "-w"

#. type: Labeled list
#: en/diff-options.txt:787
#, ignore-same, no-wrap, priority:280
msgid "--ignore-all-space"
msgstr "--ignore-all-space"

#. type: Labeled list
#: en/diff-options.txt:792
#, ignore-same, no-wrap, priority:280
msgid "--ignore-blank-lines"
msgstr "--ignore-blank-lines"

#. type: Plain text
#: en/diff-options.txt:794
#, priority:280
msgid "Ignore changes whose lines are all blank."
msgstr "忽略空白行的变化。"

#. type: Labeled list
#: en/diff-options.txt:795
#, no-wrap, priority:280
msgid "-I<regex>"
msgstr "-I<正则表达式>"

# ERROR: --ignore-matching-lines= not found in translation
#. type: Labeled list
#: en/diff-options.txt:796
#, no-wrap, placeholders:'--ignore-matching-lines=', priority:280
msgid "--ignore-matching-lines=<regex>"
msgstr "--ignore-matching-lines=<正则表达式>"

#. type: Plain text
#: en/diff-options.txt:799
#, priority:280
msgid "Ignore changes whose all lines match <regex>. This option may be specified more than once."
msgstr "忽略所有行均匹配 <正则表达式> 的更改。 此选项可指定多次。"

#. type: Labeled list
#: en/diff-options.txt:800
#, no-wrap, placeholders:'--inter-hunk-context=', priority:280
msgid "--inter-hunk-context=<lines>"
msgstr "--inter-hunk-context=<行数>"

#. type: Plain text
#: en/diff-options.txt:805
#, placeholders:'diff.interHunkContext', priority:280
msgid "Show the context between diff hunks, up to the specified number of lines, thereby fusing hunks that are close to each other. Defaults to `diff.interHunkContext` or 0 if the config option is unset."
msgstr "显示块差异之间的上下文，最多显示指定的行数，从而合并彼此接近的块。 默认认为 `diff.interHunkContext`，如果配置选项未设置，则默认为0。"

#. type: Labeled list
#: en/diff-options.txt:806 en/git-cvsexportcommit.txt:77 en/git-grep.txt:233 en/git-restore.txt:58
#, ignore-same, no-wrap, priority:280
msgid "-W"
msgstr "-W"

#. type: Labeled list
#: en/diff-options.txt:807 en/git-grep.txt:234
#, ignore-same, no-wrap, priority:280
msgid "--function-context"
msgstr "--function-context"

#. type: Plain text
#: en/diff-options.txt:812
#, placeholders:'linkgit:gitattributes[5]', priority:280
msgid "Show whole function as context lines for each change. The function names are determined in the same way as `git diff` works out patch hunk headers (see 'Defining a custom hunk-header' in linkgit:gitattributes[5])."
msgstr "在每个修改中的上下文行显示整个函数。函数名称的确定方式与 `git diff` 计算补丁头的方式相同（参见 linkgit:gitattributes[5] 中的 '自定义区块头' ）。"

#. type: Labeled list
#: en/diff-options.txt:815 en/git-ls-remote.txt:48
#, ignore-same, no-wrap, priority:280
msgid "--exit-code"
msgstr "--exit-code"

#. type: Plain text
#: en/diff-options.txt:819
#, priority:280
msgid "Make the program exit with codes similar to diff(1). That is, it exits with 1 if there were differences and 0 means no differences."
msgstr "让程序以类似 diff(1) 的代码退出。也就是说，如果有差异则返回1，否则返回0。"

#. type: Labeled list
#: en/diff-options.txt:820 en/fetch-options.txt:283 en/git-am.txt:89 en/git-apply.txt:232 en/git-branch.txt:203 en/git-bundle.txt:127 en/git-checkout-index.txt:32 en/git-checkout.txt:112 en/git-clean.txt:54 en/git-clone.txt:130 en/git-commit.txt:370 en/git-fast-import.txt:42 en/git-fetch-pack.txt:49 en/git-format-patch.txt:385 en/git-gc.txt:80 en/git-grep.txt:295 en/git-imap-send.txt:37 en/git-init.txt:45 en/git-ls-remote.txt:39 en/git-notes.txt:231 en/git-prune-packed.txt:37 en/git-pull.txt:81 en/git-push.txt:387 en/git-read-tree.txt:118 en/git-rebase.txt:408 en/git-repack.txt:107 en/git-reset.txt:108 en/git-restore.txt:67 en/git-rev-parse.txt:118 en/git-rm.txt:82 en/git-send-email.txt:443 en/git-show-ref.txt:85 en/git-stash.txt:239 en/git-submodule.txt:277 en/git-svn.txt:671 en/git-switch.txt:148 en/git-symbolic-ref.txt:40 en/git-worktree.txt:252 en/merge-options.txt:175 en/rev-list-options.txt:252
#, ignore-same, no-wrap, priority:300
msgid "--quiet"
msgstr "--quiet"

#. type: Plain text
#: en/diff-options.txt:822
#, placeholders:'`--exit-code`', priority:280
msgid "Disable all output of the program. Implies `--exit-code`."
msgstr "禁用程序的所有输出。暗含 `--exit-code`。"

#. type: Labeled list
#: en/diff-options.txt:825
#, ignore-same, no-wrap, priority:280
msgid "--ext-diff"
msgstr "--ext-diff"

#. type: Plain text
#: en/diff-options.txt:829
#, placeholders:'linkgit:gitattributes[5]':'linkgit:git-log[1]', priority:280
msgid "Allow an external diff helper to be executed. If you set an external diff driver with linkgit:gitattributes[5], you need to use this option with linkgit:git-log[1] and friends."
msgstr "允许执行外部差异器。如果你用 linkgit:gitattributes[5] 设置了一个外部差异驱动程序，你需要在 linkgit:git-log[1] 和相关命令中使用这个选项。"

#. type: Labeled list
#: en/diff-options.txt:830
#, ignore-same, no-wrap, priority:280
msgid "--no-ext-diff"
msgstr "--no-ext-diff"

#. type: Plain text
#: en/diff-options.txt:832
#, priority:280
msgid "Disallow external diff drivers."
msgstr "禁止使用外部差异器。"

#. type: Labeled list
#: en/diff-options.txt:833 en/git-cat-file.txt:72 en/git-grep.txt:75
#, ignore-same, no-wrap, priority:280
msgid "--textconv"
msgstr "--textconv"

#. type: Labeled list
#: en/diff-options.txt:834 en/git-grep.txt:78
#, ignore-same, no-wrap, priority:280
msgid "--no-textconv"
msgstr "--no-textconv"

#. type: Plain text
#: en/diff-options.txt:843
#, placeholders:'linkgit:gitattributes[5]':'linkgit:git-diff[1]':'linkgit:git-log[1]':'linkgit:git-format-patch[1]', priority:280
msgid "Allow (or disallow) external text conversion filters to be run when comparing binary files. See linkgit:gitattributes[5] for details. Because textconv filters are typically a one-way conversion, the resulting diff is suitable for human consumption, but cannot be applied. For this reason, textconv filters are enabled by default only for linkgit:git-diff[1] and linkgit:git-log[1], but not for linkgit:git-format-patch[1] or diff plumbing commands."
msgstr "允许（或不允许）在比较二进制文件时运行外部文本转换过滤器。详情请参见 linkgit:gitattributes[5] 。由于文本转换过滤器通常是单向转换，因此产生的差异适合人类用户使用，但不能应用（apply）。因此默认情况下，只有 linkgit:git-diff[1] 和 linkgit:git-log[1] 启用文本转换过滤器，而 linkgit:git-format-patch[1] 或 diff plumbing 命令则不启用。"

#. type: Labeled list
#: en/diff-options.txt:844 en/git-status.txt:87
#, no-wrap, placeholders:'--ignore-submodules', priority:280
msgid "--ignore-submodules[=<when>]"
msgstr "--ignore-submodules[=<when>]"

#. type: Plain text
#: en/diff-options.txt:856
#, placeholders:'HEAD':'linkgit:git-config[1]':'linkgit:gitmodules[5]', priority:280
msgid "Ignore changes to submodules in the diff generation. <when> can be either \"none\", \"untracked\", \"dirty\" or \"all\", which is the default. Using \"none\" will consider the submodule modified when it either contains untracked or modified files or its HEAD differs from the commit recorded in the superproject and can be used to override any settings of the 'ignore' option in linkgit:git-config[1] or linkgit:gitmodules[5]. When \"untracked\" is used submodules are not considered dirty when they only contain untracked content (but they are still scanned for modified content). Using \"dirty\" ignores all changes to the work tree of submodules, only changes to the commits stored in the superproject are shown (this was the behavior until 1.7.0). Using \"all\" hides all changes to submodules."
msgstr "在生成差异时忽略子模块的修改。<when> 可以是 \"none\"、\"untracked\"、\"dirty \" 或 \"all\"，\"all\" 是默认选项。使用 \"none\" 会在子模块包含未跟踪或修改的文件，或者它的HEAD 与上级项目中记录的提交不同时，认为它被修改了，并且可以用来覆盖 linkgit:git-config[1] 或 linkgit:gitmodules[5] 中 '忽略' 选项的设置。当使用 \"untracked\" 时，当子模块只包含未跟踪的内容时，它们不会被认为是有改动的（但它们仍然会被扫描是否有被修改的内容）。使用 \"dirty\" 会忽略所有对子模块工作树的修改，只有存储在上级项目中的提交的修改才会被显示出来（这是在1.7.0之前的行为）。使用 \"all\" 会隐藏所有对子模块的修改。"

#. type: Labeled list
#: en/diff-options.txt:857
#, no-wrap, placeholders:'--src-prefix=', priority:280
msgid "--src-prefix=<prefix>"
msgstr "--src-prefix=<前缀>"

#. type: Plain text
#: en/diff-options.txt:859
#, priority:280
msgid "Show the given source prefix instead of \"a/\"."
msgstr "显示给定的源前缀而不是 \"a/\"。"

#. type: Labeled list
#: en/diff-options.txt:860
#, no-wrap, placeholders:'--dst-prefix=', priority:280
msgid "--dst-prefix=<prefix>"
msgstr "--dst-prefix=<前缀>"

#. type: Plain text
#: en/diff-options.txt:862
#, priority:280
msgid "Show the given destination prefix instead of \"b/\"."
msgstr "显示给定的目标前缀，而不是“b/”。"

#. type: Labeled list
#: en/diff-options.txt:863
#, ignore-same, no-wrap, priority:280
msgid "--no-prefix"
msgstr "--no-prefix"

#. type: Plain text
#: en/diff-options.txt:865
#, priority:280
msgid "Do not show any source or destination prefix."
msgstr "不显示任何源或目的前缀。"

#. type: Labeled list
#: en/diff-options.txt:866
#, ignore-same, no-wrap, priority:280
msgid "--default-prefix"
msgstr "--default-prefix"

#. type: Plain text
#: en/diff-options.txt:870
#, placeholders:'diff.noprefix', priority:280
msgid "Use the default source and destination prefixes (\"a/\" and \"b/\"). This is usually the default already, but may be used to override config such as `diff.noprefix`."
msgstr "使用默认的源和目标前缀（\"a/\"和 \"b/\"）。 这通常已经是默认的，但可以用来覆盖配置，如 `diff.noprefix`。"

#. type: Labeled list
#: en/diff-options.txt:871
#, no-wrap, placeholders:'--line-prefix=', priority:280
msgid "--line-prefix=<prefix>"
msgstr "--line-prefix=<prefix>"

#. type: Plain text
#: en/diff-options.txt:873
#, priority:280
msgid "Prepend an additional prefix to every line of output."
msgstr "在每一行输出前加上一个额外的前缀。"

#. type: Labeled list
#: en/diff-options.txt:874
#, ignore-same, no-wrap, priority:280
msgid "--ita-invisible-in-index"
msgstr "--ita-invisible-in-index"

#. type: Plain text
#: en/diff-options.txt:881
#, placeholders:'--cached':'--cached':'`--ita-visible-in-index`', priority:280
msgid "By default entries added by \"git add -N\" appear as an existing empty file in \"git diff\" and a new file in \"git diff --cached\". This option makes the entry appear as a new file in \"git diff\" and non-existent in \"git diff --cached\". This option could be reverted with `--ita-visible-in-index`. Both options are experimental and could be removed in future."
msgstr "默认情况下，通过 \"git add -N\" 添加的条目在 \"git diff\" 中显示为现有的空文件，在 \"git diff --cached\" 中显示为新文件。这个选项使得条目在 \"git diff\" 中显示为一个新文件，而在 \"git diff --cached\" 中显示为不存在的文件。这个选项可以用 `--ita-visible-in-index` 来还原。这两个选项都是试验性的，将来可能会被删除。"

#. type: Plain text
#: en/diff-options.txt:883
#, placeholders:'linkgit:gitdiffcore[7]', priority:280
msgid "For more detailed explanation on these common options, see also linkgit:gitdiffcore[7]."
msgstr "关于这些常用选项的更多解释，请参见 linkgit:gitdiffcore[7]。"

#. type: Labeled list
#: en/fetch-options.txt:1
#, ignore-same, no-wrap, priority:220
msgid "--[no-]all"
msgstr "--[no-]all"

#. type: Plain text
#: en/fetch-options.txt:4
#, placeholders:'fetch.all', priority:220
msgid "Fetch all remotes. This overrides the configuration variable `fetch.all`."
msgstr "获取所有远程控制。这将覆盖配置变量 `fetch.all`。"

#. type: Labeled list
#: en/fetch-options.txt:6
#, ignore-same, no-wrap, priority:220
msgid "--append"
msgstr "--append"

#. type: Plain text
#: en/fetch-options.txt:10
#, placeholders:'.git/FETCH_HEAD':'.git/FETCH_HEAD', priority:220
msgid "Append ref names and object names of fetched refs to the existing contents of `.git/FETCH_HEAD`. Without this option old data in `.git/FETCH_HEAD` will be overwritten."
msgstr "在 `.git/FETCH_HEAD` 的现有内容中添加获取的引用名称和对象名称。 如果没有这个选项，`.git/FETCH_HEAD` 中的旧数据将被覆盖。"

#. type: Labeled list
#: en/fetch-options.txt:11 en/git-send-pack.txt:69
#, ignore-same, no-wrap, priority:220
msgid "--atomic"
msgstr "--atomic"

#. type: Plain text
#: en/fetch-options.txt:14
#, priority:220
msgid "Use an atomic transaction to update local refs. Either all refs are updated, or on error, no refs are updated."
msgstr "使用一个原子事务来更新本地索引。要么所有的引用都被更新，要么在出错时，没有引用被更新。"

#. type: Labeled list
#: en/fetch-options.txt:15
#, no-wrap, placeholders:'--depth=', priority:220
msgid "--depth=<depth>"
msgstr "--depth=<深度>"

#. type: Plain text
#: en/fetch-options.txt:21
#, placeholders:'`--depth=':'linkgit:git-clone[1]', priority:220
msgid "Limit fetching to the specified number of commits from the tip of each remote branch history. If fetching to a 'shallow' repository created by `git clone` with `--depth=<depth>` option (see linkgit:git-clone[1]), deepen or shorten the history to the specified number of commits. Tags for the deepened commits are not fetched."
msgstr "限制从每个远程分支历史的顶端获取指定数量的提交。如果获取的是由 `git clone` 创建的 '浅层' 仓库，并使用 `--depth=<depth>` 选项（见 linkgit:git-clone[1]），则加深或缩短历史，达到指定数量的提交。深化后的提交的标签不会被获取。"

#. type: Labeled list
#: en/fetch-options.txt:22
#, no-wrap, placeholders:'--deepen=', priority:220
msgid "--deepen=<depth>"
msgstr "--deepen=<深度>"

#. type: Plain text
#: en/fetch-options.txt:26
#, placeholders:'--depth', priority:220
msgid "Similar to --depth, except it specifies the number of commits from the current shallow boundary instead of from the tip of each remote branch history."
msgstr "与--depth类似，只是它指定了从当前浅层边界开始的提交数量，而不是从每个远程分支历史的顶端开始。"

#. type: Labeled list
#: en/fetch-options.txt:27 en/git-clone.txt:252 en/git-fetch-pack.txt:90
#, no-wrap, placeholders:'--shallow-since=', priority:300
msgid "--shallow-since=<date>"
msgstr "--shallow-since=<日期>"

#. type: Plain text
#: en/fetch-options.txt:30 en/git-fetch-pack.txt:93
#, priority:220
msgid "Deepen or shorten the history of a shallow repository to include all reachable commits after <date>."
msgstr "加深或缩短浅层仓库的历史，包括<日期>之后所有可触及的提交。"

#. type: Labeled list
#: en/fetch-options.txt:31 en/git-clone.txt:255 en/git-fetch-pack.txt:94
#, no-wrap, placeholders:'--shallow-exclude=', priority:300
msgid "--shallow-exclude=<revision>"
msgstr "--shallow-exclude=<修订版本>"

#. type: Plain text
#: en/fetch-options.txt:35 en/git-fetch-pack.txt:98
#, priority:220
msgid "Deepen or shorten the history of a shallow repository to exclude commits reachable from a specified remote branch or tag. This option can be specified multiple times."
msgstr "深化或缩短浅层版本库的历史，以排除从指定的远程分支或标记中可以到达的提交。 这个选项可以指定多次。"

#. type: Labeled list
#: en/fetch-options.txt:36
#, ignore-same, no-wrap, priority:220
msgid "--unshallow"
msgstr "--unshallow"

#. type: Plain text
#: en/fetch-options.txt:40
#, priority:220
msgid "If the source repository is complete, convert a shallow repository to a complete one, removing all the limitations imposed by shallow repositories."
msgstr "如果源仓库是完整的，将浅层资源库转换为完整的仓库，消除浅层仓库带来的所有限制。"

#. type: Plain text
#: en/fetch-options.txt:43
#, priority:220
msgid "If the source repository is shallow, fetch as much as possible so that the current repository has the same history as the source repository."
msgstr "如果源仓库是浅层的，尽可能多的获取，使当前仓库的历史与源仓库相同。"

#. type: Labeled list
#: en/fetch-options.txt:44
#, ignore-same, no-wrap, priority:220
msgid "--update-shallow"
msgstr "--update-shallow"

#. type: Plain text
#: en/fetch-options.txt:49
#, priority:220
msgid "By default when fetching from a shallow repository, `git fetch` refuses refs that require updating .git/shallow. This option updates .git/shallow and accepts such refs."
msgstr "默认情况下，当从浅层仓库获取时，`git fetch` 会拒绝需要更新 .git/shallow 的引用。这个选项更新了 .git/shallow 并接受这样的引用。"

#. type: Labeled list
#: en/fetch-options.txt:50
#, no-wrap, placeholders:'--negotiation-tip=', priority:220
msgid "--negotiation-tip=<commit|glob>"
msgstr "--negotiation-tip=<提交|通配符>"

#. type: Plain text
#: en/fetch-options.txt:58
#, priority:220
msgid "By default, Git will report, to the server, commits reachable from all local refs to find common commits in an attempt to reduce the size of the to-be-received packfile. If specified, Git will only report commits reachable from the given tips. This is useful to speed up fetches when the user knows which local ref is likely to have commits in common with the upstream ref being fetched."
msgstr "默认情况下，Git 会向服务器报告从所有本地引用中可触及的提交，以寻找共同的提交，试图减少待接收的打包文件的大小。如果指定的话，Git将只报告从给定提示中的可达提交。 当用户知道哪个本地引用可能与被获取的上游引用有共同的提交时，这会加快抓取文件的速度。"

#. type: Plain text
#: en/fetch-options.txt:61
#, priority:220
msgid "This option may be specified more than once; if so, Git will report commits reachable from any of the given commits."
msgstr "这个选项可以指定多次；如果是这样，Git将报告从任何一个给定的提交中可达提交。"

#. type: Plain text
#: en/fetch-options.txt:65
#, priority:220
msgid "The argument to this option may be a glob on ref names, a ref, or the (possibly abbreviated) SHA-1 of a commit. Specifying a glob is equivalent to specifying this option multiple times, one for each matching ref name."
msgstr "这个选项的参数可以是一个引用名称的通配符，一个引用，或者一个提交的SHA-1（可能是缩写的）。指定一个通配符相当于多次指定这个选项，为每个匹配的引用名称指定该选项。"

#. type: Plain text
#: en/fetch-options.txt:69
#, placeholders:'fetch.negotiationAlgorithm':'push.negotiate':'linkgit:git-config[1]':'`--negotiate-only`', priority:220
msgid "See also the `fetch.negotiationAlgorithm` and `push.negotiate` configuration variables documented in linkgit:git-config[1], and the `--negotiate-only` option below."
msgstr "参见 linkgit:git-config[1] 中记录的 `fetch.negotiationAlgorithm` 和 `push.negotiate` 配置变量，以及下面的 `--negotiate-only` 选项。"

#. type: Labeled list
#: en/fetch-options.txt:70
#, ignore-same, no-wrap, priority:220
msgid "--negotiate-only"
msgstr "--negotiate-only"

#. type: Plain text
#: en/fetch-options.txt:74
#, placeholders:'`--negotiation-tip=', priority:220
msgid "Do not fetch anything from the server, and instead print the ancestors of the provided `--negotiation-tip=*` arguments, which we have in common with the server."
msgstr "不从服务器获取任何东西，而是打印所提供的 `--negotiation-tip=*` 参数与服务器上的共同祖先。"

#. type: Plain text
#: en/fetch-options.txt:78
#, placeholders:'`--recurse-submodules=[yes|on-demand]`':'push.negotiate':'linkgit:git-config[1]', priority:220
msgid "This is incompatible with `--recurse-submodules=[yes|on-demand]`. Internally this is used to implement the `push.negotiate` option, see linkgit:git-config[1]."
msgstr "这与 `--recurse-submodules=[yes|on-demand]` 不兼容。 在内部，这被用来实现 `push.negotiate` 选项，见linkgit:git-config[1]。"

#. type: Labeled list
#: en/fetch-options.txt:79 en/git-add.txt:70 en/git-clean.txt:50 en/git-commit.txt:373 en/git-http-push.txt:37 en/git-mv.txt:40 en/git-notes.txt:203 en/git-p4.txt:332 en/git-prune-packed.txt:32 en/git-prune.txt:37 en/git-push.txt:174 en/git-quiltimport.txt:35 en/git-read-tree.txt:59 en/git-reflog.txt:117 en/git-rm.txt:53 en/git-send-email.txt:434 en/git-send-pack.txt:52 en/git-svn.txt:687 en/git-worktree.txt:231
#, ignore-same, no-wrap, priority:300
msgid "--dry-run"
msgstr "--dry-run"

#. type: Plain text
#: en/fetch-options.txt:81
#, priority:220
msgid "Show what would be done, without making any changes."
msgstr "显示会做什么，而不做任何改变。"

#. type: Plain text
#: en/fetch-options.txt:85
#, placeholders:'linkgit:git-fetch[1]', priority:220
msgid "Print the output to standard output in an easy-to-parse format for scripts. See section OUTPUT in linkgit:git-fetch[1] for details."
msgstr "将输出结果以易于解析的格式打印到标准输出，供脚本使用。详情见 linkgit:git-fetch[1] 中的输出部分。"

#. type: Plain text
#: en/fetch-options.txt:88
#, placeholders:'`--recurse-submodules=[yes|on-demand]`':'fetch.output', priority:220
msgid "This is incompatible with `--recurse-submodules=[yes|on-demand]` and takes precedence over the `fetch.output` config option."
msgstr "这与 `--recurse-submodules=[yes|on-demand]` 选项不兼容，并且优先于 `fetch.output` 配置选项。"

#. type: Labeled list
#: en/fetch-options.txt:90
#, ignore-same, no-wrap, priority:220
msgid "--[no-]write-fetch-head"
msgstr "--[no-]write-fetch-head"

#. type: Plain text
#: en/fetch-options.txt:96
#, placeholders:'FETCH_HEAD':'$GIT_DIR':'`--no-write-fetch-head`':'`--dry-run`', priority:220
msgid "Write the list of remote refs fetched in the `FETCH_HEAD` file directly under `$GIT_DIR`. This is the default. Passing `--no-write-fetch-head` from the command line tells Git not to write the file. Under `--dry-run` option, the file is never written."
msgstr "直接在`$GIT_DIR`下的`FETCH_HEAD`文件中写入获取的远程引用列表。 这是默认的。 从命令行传递`--no-write-fetch-head`，告诉Git不要写入该文件。 在`--dry-run`选项下，该文件永远不会被写入。"

#. type: Labeled list
#: en/fetch-options.txt:98 en/git-add.txt:78 en/git-archimport.txt:81 en/git-blame.txt:65 en/git-branch.txt:117 en/git-checkout-index.txt:35 en/git-checkout.txt:122 en/git-clean.txt:36 en/git-cvsexportcommit.txt:54 en/git-filter-branch.txt:208 en/git-ls-files.txt:171 en/git-mv.txt:31 en/git-notes.txt:133 en/git-push.txt:333 en/git-rebase.txt:440 en/git-repack.txt:98 en/git-replace.txt:60 en/git-rm.txt:48 en/git-submodule.txt:300 en/git-switch.txt:115 en/git-tag.txt:79 en/git-update-server-info.txt:24 en/git-worktree.txt:172
#, ignore-same, no-wrap, priority:300
msgid "-f"
msgstr "-f"

#. type: Labeled list
#: en/fetch-options.txt:99 en/git-add.txt:79 en/git-branch.txt:118 en/git-checkout-index.txt:36 en/git-checkout.txt:123 en/git-clean.txt:37 en/git-fast-import.txt:37 en/git-filter-branch.txt:209 en/git-gc.txt:83 en/git-http-push.txt:30 en/git-mv.txt:32 en/git-notes.txt:134 en/git-push.txt:334 en/git-replace.txt:61 en/git-rm.txt:49 en/git-send-email.txt:463 en/git-send-pack.txt:55 en/git-submodule.txt:301 en/git-switch.txt:116 en/git-tag.txt:80 en/git-update-server-info.txt:25 en/git-worktree.txt:173
#, ignore-same, no-wrap, priority:300
msgid "--force"
msgstr "--force"

#. type: Plain text
#: en/fetch-options.txt:102
#, priority:220
msgid "When 'git fetch' is used with `<src>:<dst>` refspec, it may refuse to update the local branch as discussed"
msgstr "正如讨论的那样，当 'git fetch' 与 `<源>:<目标>` 引用规范一起使用时，它可能会拒绝更新本地分支"

#. type: Plain text
#: en/fetch-options.txt:105
#, no-wrap, placeholders:'linkgit:git-fetch[1]', priority:220
msgid ""
"\tin the `<refspec>` part of the linkgit:git-fetch[1]\n"
"\tdocumentation.\n"
msgstr ""
"\t在linkgit:git-fetch[1]的`<引用规范>`部分。\n"
"\t文档中。\n"

#. type: Plain text
#: en/fetch-options.txt:108
#, no-wrap, priority:220
msgid "\tin the `<refspec>` part below.\n"
msgstr "\t在下面的 `<引用规范>` 部分。\n"

#. type: Plain text
#: en/fetch-options.txt:110
#, no-wrap, priority:220
msgid "\tThis option overrides that check.\n"
msgstr "\t这个选项覆盖了这个检查。\n"

#. type: Labeled list
#: en/fetch-options.txt:111 en/git-am.txt:44 en/git-cvsexportcommit.txt:67 en/git-cvsimport.txt:93 en/git-fetch-pack.txt:53 en/git-format-patch.txt:133 en/git-ls-files.txt:86 en/git-mailinfo.txt:29 en/git-mv.txt:34 en/git-repack.txt:211 en/git-stash.txt:189
#, ignore-same, no-wrap, priority:280
msgid "-k"
msgstr "-k"

#. type: Labeled list
#: en/fetch-options.txt:112 en/git-am.txt:45 en/git-fetch-pack.txt:54 en/git-index-pack.txt:62 en/git-reset.txt:87
#, ignore-same, no-wrap, priority:280
msgid "--keep"
msgstr "--keep"

#. type: Plain text
#: en/fetch-options.txt:114
#, priority:220
msgid "Keep downloaded pack."
msgstr "保存下载的包。"

#. type: Labeled list
#: en/fetch-options.txt:116
#, ignore-same, no-wrap, priority:220
msgid "--multiple"
msgstr "--multiple"

#. type: Plain text
#: en/fetch-options.txt:119
#, priority:220
msgid "Allow several <repository> and <group> arguments to be specified. No <refspec>s may be specified."
msgstr "允许指定几个 <仓库> 和 <group> 参数。不可以指定 <引用规范>。"

#. type: Labeled list
#: en/fetch-options.txt:120
#, ignore-same, no-wrap, priority:220
msgid "--[no-]auto-maintenance"
msgstr "--[no-]auto-maintenance"

#. type: Labeled list
#: en/fetch-options.txt:121
#, ignore-same, no-wrap, priority:220
msgid "--[no-]auto-gc"
msgstr "--[no-]auto-gc"

#. type: Plain text
#: en/fetch-options.txt:125
#, placeholders:'--auto`', priority:220
msgid "Run `git maintenance run --auto` at the end to perform automatic repository maintenance if needed. (`--[no-]auto-gc` is a synonym.) This is enabled by default."
msgstr "在最后运行 `git maintenance run --auto`，以在需要时执行自动仓库维护。（与 \"--[no-]auto-gc\" 选项效果一样。）这个功能默认启用。"

#. type: Labeled list
#: en/fetch-options.txt:126
#, ignore-same, no-wrap, priority:220
msgid "--[no-]write-commit-graph"
msgstr "--[no-]write-commit-graph"

#. type: Plain text
#: en/fetch-options.txt:129
#, placeholders:'fetch.writeCommitGraph', priority:220
msgid "Write a commit-graph after fetching. This overrides the config setting `fetch.writeCommitGraph`."
msgstr "在获取后写一个提交图。这会覆盖 `fetch.writeCommitGraph` 配置选项。"

#. type: Labeled list
#: en/fetch-options.txt:131
#, ignore-same, no-wrap, priority:220
msgid "--prefetch"
msgstr "--prefetch"

#. type: Plain text
#: en/fetch-options.txt:135
#, placeholders:'linkgit:git-maintenance[1]', priority:220
msgid "Modify the configured refspec to place all refs into the `refs/prefetch/` namespace. See the `prefetch` task in linkgit:git-maintenance[1]."
msgstr "修改配置的引用规范，将所有引用放到 `refs/prefetch/` 命名空间中。参见 linkgit:git-maintenance[1] 中的 `prefetch` 任务。"

#. type: Labeled list
#: en/fetch-options.txt:137 en/git-push.txt:154
#, ignore-same, no-wrap, priority:220
msgid "--prune"
msgstr "--prune"

#. type: Plain text
#: en/fetch-options.txt:147
#, placeholders:'--tags':'--mirror':'`--prune-tags`', priority:220
msgid "Before fetching, remove any remote-tracking references that no longer exist on the remote. Tags are not subject to pruning if they are fetched only because of the default tag auto-following or due to a --tags option. However, if tags are fetched due to an explicit refspec (either on the command line or in the remote configuration, for example if the remote was cloned with the --mirror option), then they are also subject to pruning. Supplying `--prune-tags` is a shorthand for providing the tag refspec."
msgstr "在获取之前，删除任何不再存在于远程的远程跟踪引用。 如果只是因为默认的标签自动跟踪或者因为 --tags 选项而获取标签，则不需要剪枝。 然而，如果标签是由于明确的引用规范（无论是在命令行还是在远程配置中，例如，如果远程是用 --mirror 选项克隆的）而被获取的，那么它们也会被剪除。提供 `--prune-tags` 是提供标签引用规范的速记方法。"

#. type: Plain text
#: en/fetch-options.txt:150 en/fetch-options.txt:161
#, priority:220
msgid "See the PRUNING section below for more details."
msgstr "更多细节见下面的 剪枝 部分。"

#. type: Labeled list
#: en/fetch-options.txt:151 en/git-cvsexportcommit.txt:57 en/git-grep.txt:135 en/git.txt:135 en/rev-list-options.txt:97
#, ignore-same, no-wrap, priority:260
msgid "-P"
msgstr "-P"

#. type: Labeled list
#: en/fetch-options.txt:152
#, ignore-same, no-wrap, priority:220
msgid "--prune-tags"
msgstr "--prune-tags"

#. type: Plain text
#: en/fetch-options.txt:159
#, placeholders:'`--prune`':'`--prune`':'`--prune`', priority:220
msgid "Before fetching, remove any local tags that no longer exist on the remote if `--prune` is enabled. This option should be used more carefully, unlike `--prune` it will remove any local references (local tags) that have been created. This option is a shorthand for providing the explicit tag refspec along with `--prune`, see the discussion about that in its documentation."
msgstr "在获取之前，如果 `--prune` 被启用，则删除任何不再存在于远程的本地标签。这个选项应该更谨慎使用，与`--prune`不同，它将删除任何已经创建的本地引用（本地标签）。这个选项是与`--prune`一起提供明确的标签引用规范的速记形式，见其文档中关于这个的讨论。"

#. type: Labeled list
#: en/fetch-options.txt:165 en/git-add.txt:69 en/git-am.txt:143 en/git-blame.txt:71 en/git-checkout-index.txt:45 en/git-cherry-pick.txt:92 en/git-clean.txt:49 en/git-clone.txt:153 en/git-commit.txt:214 en/git-format-patch.txt:118 en/git-grep.txt:148 en/git-mailinfo.txt:68 en/git-mv.txt:39 en/git-notes.txt:202 en/git-p4.txt:331 en/git-prune-packed.txt:31 en/git-prune.txt:36 en/git-push.txt:173 en/git-quiltimport.txt:34 en/git-read-tree.txt:58 en/git-rebase.txt:419 en/git-reflog.txt:116 en/git-repack.txt:111 en/git-revert.txt:77 en/git-rm.txt:52 en/git-shortlog.txt:29 en/git-submodule.txt:323 en/git-svn.txt:686 en/git-unpack-objects.txt:30 en/git-worktree.txt:230 en/merge-options.txt:108
#, ignore-same, no-wrap, priority:300
msgid "-n"
msgstr "-n"

#. type: Labeled list
#: en/fetch-options.txt:167 en/git-clone.txt:270
#, ignore-same, no-wrap, priority:300
msgid "--no-tags"
msgstr "--no-tags"

#. type: Plain text
#: en/fetch-options.txt:173
#, placeholders:'linkgit:git-config[1]', priority:220
msgid "By default, tags that point at objects that are downloaded from the remote repository are fetched and stored locally. This option disables this automatic tag following. The default behavior for a remote may be specified with the remote.<name>.tagOpt setting. See linkgit:git-config[1]."
msgstr "默认情况下，指向从远程仓库下载的对象的标签会被获取并存储到本地。 这个选项禁用了这种自动标记跟踪。远程的默认行为可以通过 remote.<远程名称>.tagOpt 设置来指定。参见 linkgit:git-config[1]。"

#. type: Labeled list
#: en/fetch-options.txt:175 en/git-fetch-pack.txt:104
#, ignore-same, no-wrap, priority:220
msgid "--refetch"
msgstr "--refetch"

#. type: Plain text
#: en/fetch-options.txt:182
#, placeholders:'`--filter=`', priority:220
msgid "Instead of negotiating with the server to avoid transferring commits and associated objects that are already present locally, this option fetches all objects as a fresh clone would. Use this to reapply a partial clone filter from configuration or using `--filter=` when the filter definition has changed. Automatic post-fetch maintenance will perform object database pack consolidation to remove any duplicate objects."
msgstr "这个选项不是与服务器协商以避免传输本地已经存在的提交和相关对象，而是像一个新的克隆那样获取所有对象。当过滤器定义发生变化时，使用此选项重新应用配置中的部分克隆过滤器或使用 `--filter=`。自动获取后的维护将执行对象数据库包的整合，以删除任何重复的对象。"

#. type: Labeled list
#: en/fetch-options.txt:184
#, no-wrap, placeholders:'--refmap=', priority:220
msgid "--refmap=<refspec>"
msgstr "--refmap=<引用规范>"

#. type: Plain text
#: en/fetch-options.txt:194
#, placeholders:'`--refmap`', priority:220
msgid "When fetching refs listed on the command line, use the specified refspec (can be given more than once) to map the refs to remote-tracking branches, instead of the values of `remote.*.fetch` configuration variables for the remote repository. Providing an empty `<refspec>` to the `--refmap` option causes Git to ignore the configured refspecs and rely entirely on the refspecs supplied as command-line arguments. See section on \"Configured Remote-tracking Branches\" for details."
msgstr "当获取命令行上列出的引用时，使用指定的引用规范（可以是多个）来映射引用到远程跟踪分支，而不是远程仓库的 `remote.*.fetch` 配置变量的值。 为 `--refmap` 选项提供一个空的 `<引用规范>` 会导致Git忽略配置的引用规范，而完全依赖作为命令行参数提供的引用规范。详见 \"配置的远程跟踪分支\" 一节。"

#. type: Labeled list
#: en/fetch-options.txt:196 en/git-describe.txt:55 en/git-fsck.txt:41 en/git-ls-remote.txt:27 en/git-name-rev.txt:24 en/git-push.txt:187 en/git-show-ref.txt:49
#, ignore-same, no-wrap, priority:260
msgid "--tags"
msgstr "--tags"

#. type: Plain text
#: en/fetch-options.txt:203
#, placeholders:'--prune':'`--prune`', priority:220
msgid "Fetch all tags from the remote (i.e., fetch remote tags `refs/tags/*` into local tags with the same name), in addition to whatever else would otherwise be fetched. Using this option alone does not subject tags to pruning, even if --prune is used (though tags may be pruned anyway if they are also the destination of an explicit refspec; see `--prune`)."
msgstr "从远程获取所有标签（即，将远程标签 `refs/tags/*` 获取为同名的本地标签），除此之外，还可以获取其他东西。 单独使用这个选项，即使使用了 --prune，也不会对标签进行修剪（尽管标签是一个明确了无论如何也要删除的引用规范目标，见 `--prune` 选项）。"

#. type: Labeled list
#: en/fetch-options.txt:205
#, ignore-same, no-wrap, priority:220
msgid "--recurse-submodules[=yes|on-demand|no]"
msgstr "--recurse-submodules[=yes|on-demand|no]"

#. type: Plain text
#: en/fetch-options.txt:215
#, placeholders:'$GIT_DIR':'linkgit:gitsubmodules[7]', priority:220
msgid "This option controls if and under what conditions new commits of submodules should be fetched too. When recursing through submodules, `git fetch` always attempts to fetch \"changed\" submodules, that is, a submodule that has commits that are referenced by a newly fetched superproject commit but are missing in the local submodule clone. A changed submodule can be fetched as long as it is present locally e.g. in `$GIT_DIR/modules/` (see linkgit:gitsubmodules[7]); if the upstream adds a new submodule, that submodule cannot be fetched until it is cloned e.g. by `git submodule update`."
msgstr "这个选项控制是否以及在什么条件下，子模块的新提交也应该被获取。当遍历子模块时，`git fetch` 总是试图获取 \"改变的\" 子模块，也就是说，一个子模块的提交被新获取的父项目提交所引用，但在本地的子模块克隆中却没有。一个改变了的子模块可以被获取，只要它在本地存在，例如在`$GIT_DIR/modules/`（见linkgit:gitsubmodules[7]）；如果上游添加了一个新的子模块，该子模块不能被获取，直到它被克隆，例如通过`git submodule update`。"

#. type: Plain text
#: en/fetch-options.txt:220
#, priority:220
msgid "When set to 'on-demand', only changed submodules are fetched. When set to 'yes', all populated submodules are fetched and submodules that are both unpopulated and changed are fetched. When set to 'no', submodules are never fetched."
msgstr "当设置为 'on-demand' 时，只取回已改变的子模块。当设置为 'yes' 时，所有已填充的子模块都被获取，同时未填充和已改变的子模块也被获取。当设置为 'no' 时，子模块永远不会被获取。"

#. type: Plain text
#: en/fetch-options.txt:224
#, placeholders:'fetch.recurseSubmodules':'linkgit:git-config[1]', priority:220
msgid "When unspecified, this uses the value of `fetch.recurseSubmodules` if it is set (see linkgit:git-config[1]), defaulting to 'on-demand' if unset. When this option is used without any value, it defaults to 'yes'."
msgstr "当未指定时，如果设置了 `fetch.recurseSubmodules`，则使用该值（见linkgit:git-config[1]），如果未设置则默认为 'on-demand'。 当这个选项被使用而没有任何值时，它默认为 'yes'。"

#. type: Labeled list
#: en/fetch-options.txt:226
#, ignore-same, no-wrap, priority:220
msgid "-j"
msgstr "-j"

#. type: Labeled list
#: en/fetch-options.txt:227
#, no-wrap, placeholders:'--jobs=', priority:220
msgid "--jobs=<n>"
msgstr "--jobs=<n>"

#. type: Plain text
#: en/fetch-options.txt:229
#, priority:220
msgid "Number of parallel children to be used for all forms of fetching."
msgstr "用于所有形式的获取的并行子进程的数量。"

#. type: Plain text
#: en/fetch-options.txt:234
#, placeholders:'`--multiple`':'fetch.parallel':'submodule.fetchJobs':'linkgit:git-config[1]', priority:220
msgid "If the `--multiple` option was specified, the different remotes will be fetched in parallel. If multiple submodules are fetched, they will be fetched in parallel. To control them independently, use the config settings `fetch.parallel` and `submodule.fetchJobs` (see linkgit:git-config[1])."
msgstr "如果指定了 `--multiple` 选项，不同的远程将被并行获取。如果多个子模块被取走，它们将并行获取。要独立控制它们，使用配置 `fetch.parallel` 和 `submodule.fetchJobs`（见linkgit:git-config[1]）。"

#. type: Plain text
#: en/fetch-options.txt:237
#, priority:220
msgid "Typically, parallel recursive and multi-remote fetches will be faster. By default fetches are performed sequentially, not in parallel."
msgstr "通常情况下，并行的递归和多远程的提取会更快。默认情况下，检索是按顺序进行的，而不是并行的。"

#. type: Labeled list
#: en/fetch-options.txt:239 en/git-checkout.txt:305 en/git-push.txt:402 en/git-restore.txt:115 en/git-switch.txt:189
#, ignore-same, no-wrap, priority:280
msgid "--no-recurse-submodules"
msgstr "--no-recurse-submodules"

#. type: Plain text
#: en/fetch-options.txt:242
#, placeholders:'`--recurse-submodules=no`', priority:220
msgid "Disable recursive fetching of submodules (this has the same effect as using the `--recurse-submodules=no` option)."
msgstr "禁用子模块的递归获取（这与使用 `--recurse-submodules=no` 选项的效果相同）。"

#. type: Labeled list
#: en/fetch-options.txt:244 en/git-branch.txt:267 en/git-push.txt:374
#, ignore-same, no-wrap, priority:260
msgid "--set-upstream"
msgstr "--set-upstream"

#. type: Plain text
#: en/fetch-options.txt:250
#, placeholders:'linkgit:git-pull[1]':'linkgit:git-config[1]', priority:220
msgid "If the remote is fetched successfully, add upstream (tracking) reference, used by argument-less linkgit:git-pull[1] and other commands. For more information, see `branch.<name>.merge` and `branch.<name>.remote` in linkgit:git-config[1]."
msgstr "如果远程被成功获取，添加上游（跟踪）引用，由无参数的 linkgit:git-pull[1] 和其他命令使用。更多信息，见 linkgit:git-config[1] 中的 `branch.<名称>.merge` 和 `branch.<名称>.remote`。"

#. type: Labeled list
#: en/fetch-options.txt:252
#, no-wrap, placeholders:'--submodule-prefix=', priority:220
msgid "--submodule-prefix=<path>"
msgstr "--submodule-prefix=<路径>"

#. type: Plain text
#: en/fetch-options.txt:256
#, priority:220
msgid "Prepend <path> to paths printed in informative messages such as \"Fetching submodule foo\". This option is used internally when recursing over submodules."
msgstr "将 <路径> 添加到信息性消息中打印的路径，例如“获取子模块 foo”。递归子模块时在内部使用此选项。"

#. type: Labeled list
#: en/fetch-options.txt:257
#, ignore-same, no-wrap, priority:220
msgid "--recurse-submodules-default=[yes|on-demand]"
msgstr "--recurse-submodules-default=[yes|on-demand]"

#. type: Plain text
#: en/fetch-options.txt:264
#, placeholders:'--recurse-submodules':'linkgit:gitmodules[5]':'linkgit:git-config[1]', priority:220
msgid "This option is used internally to temporarily provide a non-negative default value for the --recurse-submodules option. All other methods of configuring fetch's submodule recursion (such as settings in linkgit:gitmodules[5] and linkgit:git-config[1]) override this option, as does specifying --[no-]recurse-submodules directly."
msgstr "这个选项在内部被用来为 --recurse-submodules 选项暂时提供一个非负的默认值。 所有其他配置获取子模块递归的方法（比如 linkgit:gitmodules[5] 和 linkgit:git-config[1] 中的设置）都覆盖这个选项，直接指定 --[no-]recurse-submodules 也是如此。"

#. type: Labeled list
#: en/fetch-options.txt:266
#, ignore-same, no-wrap, priority:220
msgid "--update-head-ok"
msgstr "--update-head-ok"

#. type: Plain text
#: en/fetch-options.txt:273
#, priority:220
msgid "By default 'git fetch' refuses to update the head which corresponds to the current branch. This flag disables the check. This is purely for the internal use for 'git pull' to communicate with 'git fetch', and unless you are implementing your own Porcelain you are not supposed to use it."
msgstr "默认情况下，\"git fetch\" 拒绝更新与当前分支相对应的头部。 这个标志禁用了这种检查。 这纯粹是为了让 'git pull' 与 'git fetch' 沟通的内部使用，除非你正在实现你自己的上层命令，否则你不应该使用它。"

#. type: Labeled list
#: en/fetch-options.txt:275 en/git-clone.txt:219
#, no-wrap, placeholders:'--upload-pack', priority:300
msgid "--upload-pack <upload-pack>"
msgstr "--upload-pack <upload-pack>"

#. type: Plain text
#: en/fetch-options.txt:280
#, placeholders:'git fetch-pack':'`--exec=', priority:220
msgid "When given, and the repository to fetch from is handled by 'git fetch-pack', `--exec=<upload-pack>` is passed to the command to specify non-default path for the command run on the other end."
msgstr "当给出时，并且要获取的仓库是由 'git fetch-pack' 处理的，`--exec=<upload-pack>` 被传递到命令中，为另一端运行的命令指定非默认路径。"

#. type: Labeled list
#: en/fetch-options.txt:282 en/git-am.txt:88 en/git-apply.txt:231 en/git-branch.txt:202 en/git-bundle.txt:126 en/git-checkout-index.txt:31 en/git-checkout.txt:111 en/git-clean.txt:53 en/git-clone.txt:129 en/git-commit.txt:369 en/git-diff-files.txt:44 en/git-fetch-pack.txt:48 en/git-format-patch.txt:384 en/git-grep.txt:294 en/git-imap-send.txt:36 en/git-init.txt:44 en/git-ls-remote.txt:38 en/git-merge-file.txt:80 en/git-merge-index.txt:35 en/git-notes.txt:230 en/git-pack-objects.txt:211 en/git-prune-packed.txt:36 en/git-pull.txt:80 en/git-push.txt:386 en/git-read-tree.txt:117 en/git-rebase.txt:407 en/git-repack.txt:106 en/git-reset.txt:107 en/git-restore.txt:66 en/git-rev-parse.txt:117 en/git-rm.txt:81 en/git-show-ref.txt:84 en/git-stash.txt:238 en/git-submodule.txt:276 en/git-svn.txt:670 en/git-switch.txt:147 en/git-symbolic-ref.txt:39 en/git-unpack-objects.txt:34 en/git-update-index.txt:58 en/git-worktree.txt:251 en/merge-options.txt:174
#, ignore-same, no-wrap, priority:300
msgid "-q"
msgstr "-q"

#. type: Plain text
#: en/fetch-options.txt:287
#, placeholders:'--quiet':'git-fetch-pack', priority:220
msgid "Pass --quiet to git-fetch-pack and silence any other internally used git commands. Progress is not reported to the standard error stream."
msgstr "将 --quiet 传递给 git-fetch-pack，并使任何其他内部使用的 git 命令保持沉默。进度不会报告给标准错误流。"

#. type: Labeled list
#: en/fetch-options.txt:288 en/git-add.txt:74 en/git-apply.txt:225 en/git-archimport.txt:74 en/git-archive.txt:49 en/git-branch.txt:191 en/git-cherry.txt:29 en/git-clone.txt:134 en/git-commit.txt:354 en/git-count-objects.txt:21 en/git-cvsexportcommit.txt:82 en/git-cvsimport.txt:52 en/git-diff-tree.txt:83 en/git-fetch-pack.txt:115 en/git-grep.txt:110 en/git-http-fetch.txt:30 en/git-imap-send.txt:32 en/git-index-pack.txt:28 en/git-ls-files.txt:166 en/git-mv.txt:43 en/git-notes.txt:234 en/git-p4.txt:208 en/git-prune.txt:41 en/git-pull.txt:86 en/git-push.txt:392 en/git-read-tree.txt:63 en/git-rebase.txt:411 en/git-remote.txt:35 en/git-status.txt:50 en/git-svn.txt:366 en/git-tag.txt:87 en/git.txt:41 en/git-verify-commit.txt:23 en/git-verify-pack.txt:26 en/git-verify-tag.txt:23 en/git-worktree.txt:255 en/merge-options.txt:178
#, ignore-same, no-wrap, priority:300
msgid "-v"
msgstr "-v"

#. type: Labeled list
#: en/fetch-options.txt:289 en/git-add.txt:75 en/git-apply.txt:226 en/git-archive.txt:50 en/git-branch.txt:193 en/git-clone.txt:135 en/git-commit.txt:355 en/git-count-objects.txt:22 en/git-daemon.txt:148 en/git-fsck.txt:85 en/git-help.txt:61 en/git-http-push.txt:40 en/git-imap-send.txt:33 en/git-mv.txt:44 en/git-notes.txt:235 en/git-p4.txt:209 en/git-pack-redundant.txt:53 en/git-prune.txt:42 en/git-pull.txt:87 en/git-push.txt:393 en/git-rebase.txt:412 en/git-reflog.txt:121 en/git-remote.txt:36 en/git-send-pack.txt:62 en/git-status.txt:51 en/git-svn.txt:367 en/git-update-index.txt:158 en/git-verify-commit.txt:24 en/git-verify-pack.txt:27 en/git-verify-tag.txt:24 en/git-worktree.txt:256 en/merge-options.txt:179
#, ignore-same, no-wrap, priority:300
msgid "--verbose"
msgstr "--verbose"

#. type: Plain text
#: en/fetch-options.txt:291 en/git-add.txt:77 en/git-imap-send.txt:35 en/merge-options.txt:181
#, priority:300
msgid "Be verbose."
msgstr "详细日志。"

#. type: Labeled list
#: en/fetch-options.txt:293 en/git-bundle.txt:114 en/git-checkout.txt:115 en/git-clone.txt:139 en/git-format-patch.txt:412 en/git-pack-objects.txt:189 en/git-prune.txt:45 en/git-push.txt:396 en/git-restore.txt:70 en/git-submodule.txt:280 en/git-switch.txt:151 en/merge-options.txt:182
#, ignore-same, no-wrap, priority:300
msgid "--progress"
msgstr "--progress"

#. type: Plain text
#: en/fetch-options.txt:298 en/git-bundle.txt:119 en/git-pack-objects.txt:194 en/git-push.txt:401
#, priority:220
msgid "Progress status is reported on the standard error stream by default when it is attached to a terminal, unless -q is specified. This flag forces progress status even if the standard error stream is not directed to a terminal."
msgstr "当标准错误流连接到终端时，除非指定了 -q，否则默认情况下会在标准错误流上报告进展状态。即使标准错误流没有指向终端，这个标志也会强制显示进度状态。"

#. type: Labeled list
#: en/fetch-options.txt:299 en/git-ls-remote.txt:75 en/git-push.txt:216
#, no-wrap, priority:220
msgid "-o <option>"
msgstr "-o <选项>"

#. type: Labeled list
#: en/fetch-options.txt:300 en/git-clone.txt:145 en/git-ls-remote.txt:76
#, no-wrap, placeholders:'--server-option=', priority:300
msgid "--server-option=<option>"
msgstr "--server-option=<选项>"

#. type: Plain text
#: en/fetch-options.txt:307 en/git-clone.txt:152
#, placeholders:'`--server-option=', priority:300
msgid "Transmit the given string to the server when communicating using protocol version 2. The given string must not contain a NUL or LF character. The server's handling of server options, including unknown ones, is server-specific. When multiple `--server-option=<option>` are given, they are all sent to the other side in the order listed on the command line."
msgstr "使用协议版本2进行通信时，将给定的字符串传输到服务器。给定的字符串不得包含NUL或LF字符。服务器对服务器选项（包括未知选项）的处理是取决于服务器。当给出多个`--server-option=<option>`时，它们都按照命令行中列出的顺序发送到另一端。"

#. type: Labeled list
#: en/fetch-options.txt:308
#, ignore-same, no-wrap, priority:220
msgid "--show-forced-updates"
msgstr "--show-forced-updates"

#. type: Plain text
#: en/fetch-options.txt:313
#, placeholders:'fetch.showForcedUpdates':'--show-forced-updates':'linkgit:git-config[1]', priority:220
msgid "By default, git checks if a branch is force-updated during fetch. This can be disabled through fetch.showForcedUpdates, but the --show-forced-updates option guarantees this check occurs. See linkgit:git-config[1]."
msgstr "默认情况下，git 在获取过程中会检查一个分支是否被强制更新了。这可以通过 fetch.showForcedUpdates 禁用，但 --show-forced-updates 选项保证了这种检查的发生。 参见 linkgit:git-config[1]。"

#. type: Labeled list
#: en/fetch-options.txt:314
#, ignore-same, no-wrap, priority:220
msgid "--no-show-forced-updates"
msgstr "--no-show-forced-updates"

#. type: Plain text
#: en/fetch-options.txt:320
#, placeholders:'--no-show-forced-updates':'fetch.showForcedUpdates':'git-pull':'--ff-only':'linkgit:git-config[1]', priority:220
msgid "By default, git checks if a branch is force-updated during fetch. Pass --no-show-forced-updates or set fetch.showForcedUpdates to false to skip this check for performance reasons. If used during 'git-pull' the --ff-only option will still check for forced updates before attempting a fast-forward update. See linkgit:git-config[1]."
msgstr "默认情况下，git 会在获取过程中检查一个分支是否被强制更新了。通过 --no-show-forced-updates 或将 fetch.showForcedUpdates 设置为 false 来跳过这个检查，以保证性能。如果在 'git-pull' 中使用 --ff-only 选项，在尝试快速更新前仍会检查强制更新。见 linkgit:git-config[1]。"

#. type: Labeled list
#: en/fetch-options.txt:321 en/git-push.txt:427
#, ignore-same, no-wrap, priority:220
msgid "-4"
msgstr "-4"

#. type: Labeled list
#: en/fetch-options.txt:322 en/git-push.txt:428
#, ignore-same, no-wrap, priority:220
msgid "--ipv4"
msgstr "--ipv4"

#. type: Plain text
#: en/fetch-options.txt:324 en/git-push.txt:430
#, priority:220
msgid "Use IPv4 addresses only, ignoring IPv6 addresses."
msgstr "仅使用 IPv4 地址，忽略 IPv6 地址。"

#. type: Labeled list
#: en/fetch-options.txt:325 en/git-push.txt:431
#, ignore-same, no-wrap, priority:220
msgid "-6"
msgstr "-6"

#. type: Labeled list
#: en/fetch-options.txt:326 en/git-push.txt:432
#, ignore-same, no-wrap, priority:220
msgid "--ipv6"
msgstr "--ipv6"

#. type: Plain text
#: en/fetch-options.txt:327 en/git-push.txt:434
#, priority:220
msgid "Use IPv6 addresses only, ignoring IPv4 addresses."
msgstr "仅使用 IPv6 地址，忽略 IPv4 地址。"

#. type: Title =
#: en/gitignore.txt:2
#, ignore-same, no-wrap, priority:100
msgid "gitignore(5)"
msgstr "gitignore(5)"

#. type: Title -
#: en/gitignore.txt:5 en/git-add.txt:5 en/git-am.txt:5 en/git-annotate.txt:5 en/git-apply.txt:5 en/git-archimport.txt:5 en/git-archive.txt:5 en/git-bisect.txt:5 en/git-blame.txt:5 en/git-branch.txt:5 en/git-bugreport.txt:5 en/git-bundle.txt:5 en/git-cat-file.txt:5 en/git-check-attr.txt:5 en/git-check-ignore.txt:5 en/git-check-mailmap.txt:5 en/git-checkout-index.txt:5 en/git-checkout.txt:5 en/git-check-ref-format.txt:5 en/git-cherry-pick.txt:5 en/git-cherry.txt:5 en/git-citool.txt:5 en/git-clean.txt:5 en/git-clone.txt:5 en/git-column.txt:5 en/git-commit-tree.txt:5 en/git-commit.txt:5 en/git-config.txt:5 en/git-count-objects.txt:5 en/git-credential-cache--daemon.txt:5 en/git-credential-cache.txt:5 en/git-credential-store.txt:5 en/git-credential.txt:5 en/git-cvsexportcommit.txt:5 en/git-cvsimport.txt:5 en/git-cvsserver.txt:5 en/git-daemon.txt:5 en/git-describe.txt:5 en/git-diff-files.txt:5 en/git-diff-index.txt:5 en/git-difftool.txt:5 en/git-diff-tree.txt:5 en/git-diff.txt:5 en/git-fast-export.txt:5 en/git-fast-import.txt:5 en/git-fetch-pack.txt:5 en/git-fetch.txt:5 en/git-filter-branch.txt:5 en/git-fmt-merge-msg.txt:5 en/git-for-each-ref.txt:5 en/git-format-patch.txt:5 en/git-fsck-objects.txt:5 en/git-fsck.txt:5 en/git-gc.txt:5 en/git-get-tar-commit-id.txt:5 en/git-grep.txt:5 en/git-gui.txt:5 en/git-hash-object.txt:5 en/git-help.txt:5 en/git-http-backend.txt:5 en/git-http-fetch.txt:5 en/git-http-push.txt:5 en/git-imap-send.txt:5 en/git-index-pack.txt:5 en/git-init-db.txt:5 en/git-init.txt:5 en/git-instaweb.txt:5 en/git-interpret-trailers.txt:5 en/git-log.txt:5 en/git-ls-files.txt:5 en/git-ls-remote.txt:5 en/git-ls-tree.txt:5 en/git-mailinfo.txt:5 en/git-mailsplit.txt:5 en/git-merge-base.txt:5 en/git-merge-file.txt:5 en/git-merge-index.txt:5 en/git-merge-one-file.txt:5 en/git-mergetool--lib.txt:5 en/git-mergetool.txt:5 en/git-merge-tree.txt:5 en/git-merge.txt:5 en/git-mktag.txt:5 en/git-mktree.txt:5 en/git-mv.txt:5 en/git-name-rev.txt:5 en/git-notes.txt:5 en/git-p4.txt:5 en/git-pack-objects.txt:5 en/git-pack-redundant.txt:5 en/git-pack-refs.txt:5 en/git-patch-id.txt:5 en/git-prune-packed.txt:5 en/git-prune.txt:5 en/git-pull.txt:5 en/git-push.txt:5 en/git-quiltimport.txt:5 en/git-range-diff.txt:5 en/git-read-tree.txt:5 en/git-rebase.txt:5 en/git-receive-pack.txt:5 en/git-reflog.txt:5 en/git-remote-ext.txt:5 en/git-remote-fd.txt:5 en/git-remote.txt:5 en/git-repack.txt:5 en/git-replace.txt:5 en/git-request-pull.txt:5 en/git-rerere.txt:5 en/git-reset.txt:5 en/git-restore.txt:5 en/git-revert.txt:5 en/git-rev-list.txt:5 en/git-rev-parse.txt:5 en/git-rm.txt:5 en/git-send-email.txt:5 en/git-send-pack.txt:5 en/git-shell.txt:5 en/git-sh-i18n--envsubst.txt:5 en/git-sh-i18n.txt:5 en/git-shortlog.txt:5 en/git-show-branch.txt:5 en/git-show-index.txt:5 en/git-show-ref.txt:5 en/git-show.txt:5 en/git-sh-setup.txt:5 en/git-stage.txt:5 en/git-stash.txt:5 en/git-status.txt:5 en/git-stripspace.txt:5 en/git-submodule.txt:5 en/git-svn.txt:5 en/git-switch.txt:5 en/git-symbolic-ref.txt:5 en/git-tag.txt:5 en/git.txt:5 en/git-unpack-file.txt:5 en/git-unpack-objects.txt:5 en/git-update-index.txt:5 en/git-update-ref.txt:5 en/git-update-server-info.txt:5 en/git-upload-archive.txt:5 en/git-upload-pack.txt:5 en/git-var.txt:5 en/git-verify-commit.txt:5 en/git-verify-pack.txt:5 en/git-verify-tag.txt:5 en/git-web--browse.txt:5 en/git-whatchanged.txt:5 en/git-worktree.txt:5 en/git-write-tree.txt:5 en/gitglossary.txt:5
#, no-wrap, priority:310
msgid "NAME"
msgstr "名称"

#. type: Plain text
#: en/gitignore.txt:7
#, priority:100
msgid "gitignore - Specifies intentionally untracked files to ignore"
msgstr "gitignore - 指定有意不跟踪的文件"

#. type: Title -
#: en/gitignore.txt:9 en/git-add.txt:9 en/git-am.txt:10 en/git-annotate.txt:9 en/git-apply.txt:10 en/git-archimport.txt:10 en/git-archive.txt:10 en/git-bisect.txt:10 en/git-blame.txt:9 en/git-branch.txt:9 en/git-bugreport.txt:9 en/git-bundle.txt:10 en/git-cat-file.txt:9 en/git-check-attr.txt:10 en/git-check-ignore.txt:10 en/git-check-mailmap.txt:10 en/git-checkout-index.txt:10 en/git-checkout.txt:9 en/git-check-ref-format.txt:9 en/git-cherry-pick.txt:9 en/git-cherry.txt:9 en/git-citool.txt:9 en/git-clean.txt:9 en/git-clone.txt:10 en/git-column.txt:9 en/git-commit-tree.txt:10 en/git-commit.txt:9 en/git-config.txt:10 en/git-count-objects.txt:9 en/git-credential-cache--daemon.txt:9 en/git-credential-cache.txt:9 en/git-credential-store.txt:9 en/git-credential.txt:9 en/git-cvsexportcommit.txt:10 en/git-cvsimport.txt:10 en/git-cvsserver.txt:9 en/git-daemon.txt:9 en/git-describe.txt:9 en/git-diff-files.txt:10 en/git-diff-index.txt:10 en/git-difftool.txt:9 en/git-diff-tree.txt:10 en/git-diff.txt:10 en/git-fast-export.txt:10 en/git-fast-import.txt:10 en/git-fetch-pack.txt:10 en/git-fetch.txt:10 en/git-filter-branch.txt:9 en/git-fmt-merge-msg.txt:10 en/git-for-each-ref.txt:9 en/git-format-patch.txt:10 en/git-fsck-objects.txt:10 en/git-fsck.txt:10 en/git-gc.txt:10 en/git-get-tar-commit-id.txt:10 en/git-grep.txt:10 en/git-gui.txt:9 en/git-hash-object.txt:10 en/git-help.txt:9 en/git-http-backend.txt:9 en/git-http-fetch.txt:10 en/git-http-push.txt:10 en/git-imap-send.txt:10 en/git-index-pack.txt:10 en/git-init-db.txt:10 en/git-init.txt:10 en/git-instaweb.txt:9 en/git-interpret-trailers.txt:9 en/git-log.txt:10 en/git-ls-files.txt:10 en/git-ls-remote.txt:10 en/git-ls-tree.txt:10 en/git-mailinfo.txt:10 en/git-mailsplit.txt:9 en/git-merge-base.txt:10 en/git-merge-file.txt:10 en/git-merge-index.txt:10 en/git-merge-one-file.txt:10 en/git-mergetool--lib.txt:9 en/git-mergetool.txt:9 en/git-merge-tree.txt:10 en/git-merge.txt:10 en/git-mktag.txt:10 en/git-mktree.txt:10 en/git-mv.txt:10 en/git-name-rev.txt:10 en/git-notes.txt:9 en/git-p4.txt:10 en/git-pack-objects.txt:10 en/git-pack-redundant.txt:10 en/git-pack-refs.txt:9 en/git-patch-id.txt:9 en/git-prune-packed.txt:10 en/git-prune.txt:10 en/git-pull.txt:10 en/git-push.txt:10 en/git-quiltimport.txt:10 en/git-range-diff.txt:9 en/git-read-tree.txt:10 en/git-rebase.txt:9 en/git-receive-pack.txt:10 en/git-reflog.txt:10 en/git-remote-ext.txt:9 en/git-remote-fd.txt:9 en/git-remote.txt:10 en/git-repack.txt:10 en/git-replace.txt:9 en/git-request-pull.txt:9 en/git-rerere.txt:9 en/git-reset.txt:9 en/git-restore.txt:9 en/git-revert.txt:9 en/git-rev-list.txt:10 en/git-rev-parse.txt:10 en/git-rm.txt:9 en/git-send-email.txt:10 en/git-send-pack.txt:10 en/git-shell.txt:10 en/git-sh-i18n--envsubst.txt:9 en/git-sh-i18n.txt:9 en/git-shortlog.txt:9 en/git-show-branch.txt:9 en/git-show-index.txt:10 en/git-show-ref.txt:9 en/git-show.txt:10 en/git-sh-setup.txt:9 en/git-stage.txt:10 en/git-stash.txt:9 en/git-status.txt:10 en/git-stripspace.txt:10 en/git-submodule.txt:10 en/git-svn.txt:9 en/git-switch.txt:9 en/git-symbolic-ref.txt:9 en/git-tag.txt:10 en/git.txt:10 en/git-unpack-file.txt:11 en/git-unpack-objects.txt:10 en/git-update-index.txt:10 en/git-update-ref.txt:9 en/git-update-server-info.txt:10 en/git-upload-archive.txt:10 en/git-upload-pack.txt:10 en/git-var.txt:10 en/git-verify-commit.txt:9 en/git-verify-pack.txt:10 en/git-verify-tag.txt:9 en/git-web--browse.txt:9 en/git-whatchanged.txt:10 en/git-worktree.txt:10 en/git-write-tree.txt:10 en/gitglossary.txt:9
#, no-wrap, priority:310
msgid "SYNOPSIS"
msgstr "概述"

#. type: Plain text
#: en/gitignore.txt:11
#, placeholders:'$XDG_CONFIG_HOME':'$GIT_DIR':'.gitignore', priority:100
msgid "$XDG_CONFIG_HOME/git/ignore, $GIT_DIR/info/exclude, .gitignore"
msgstr "$XDG_CONFIG_HOME/git/ignore, $GIT_DIR/info/exclude, .gitignore"

#. type: Title -
#: en/gitignore.txt:13 en/git-add.txt:18 en/git-am.txt:24 en/git-annotate.txt:14 en/git-apply.txt:22 en/git-archimport.txt:16 en/git-archive.txt:18 en/git-bisect.txt:15 en/git-blame.txt:18 en/git-branch.txt:29 en/git-bugreport.txt:15 en/git-bundle.txt:19 en/git-cat-file.txt:21 en/git-check-attr.txt:16 en/git-check-ignore.txt:16 en/git-check-mailmap.txt:16 en/git-checkout-index.txt:20 en/git-checkout.txt:22 en/git-check-ref-format.txt:17 en/git-cherry-pick.txt:16 en/git-cherry.txt:14 en/git-citool.txt:14 en/git-clean.txt:14 en/git-clone.txt:23 en/git-column.txt:15 en/git-commit-tree.txt:18 en/git-commit.txt:21 en/git-config.txt:29 en/git-count-objects.txt:14 en/git-credential-cache--daemon.txt:14 en/git-credential-cache.txt:15 en/git-credential-store.txt:15 en/git-credential.txt:15 en/git-cvsexportcommit.txt:17 en/git-cvsimport.txt:20 en/git-cvsserver.txt:28 en/git-daemon.txt:27 en/git-describe.txt:16 en/git-diff-files.txt:15 en/git-diff-index.txt:15 en/git-difftool.txt:14 en/git-diff-tree.txt:17 en/git-diff.txt:20 en/git-fast-export.txt:15 en/git-fast-import.txt:15 en/git-fetch-pack.txt:18 en/git-fetch.txt:19 en/git-filter-branch.txt:33 en/git-fmt-merge-msg.txt:16 en/git-for-each-ref.txt:20 en/git-format-patch.txt:37 en/git-fsck-objects.txt:15 en/git-fsck.txt:18 en/git-gc.txt:15 en/git-get-tar-commit-id.txt:16 en/git-grep.txt:35 en/git-gui.txt:14 en/git-hash-object.txt:17 en/git-help.txt:19 en/git-http-backend.txt:14 en/git-http-fetch.txt:15 en/git-http-push.txt:15 en/git-imap-send.txt:16 en/git-index-pack.txt:18 en/git-init-db.txt:16 en/git-init.txt:20 en/git-instaweb.txt:16 en/git-interpret-trailers.txt:16 en/git-log.txt:15 en/git-ls-files.txt:27 en/git-ls-remote.txt:17 en/git-ls-tree.txt:17 en/git-mailinfo.txt:18 en/git-mailsplit.txt:15 en/git-merge-base.txt:19 en/git-merge-file.txt:18 en/git-merge-index.txt:15 en/git-merge-one-file.txt:15 en/git-mergetool--lib.txt:14 en/git-mergetool.txt:14 en/git-merge-tree.txt:17 en/git-merge.txt:20 en/git-mktag.txt:15 en/git-mktree.txt:15 en/git-mv.txt:15 en/git-name-rev.txt:16 en/git-notes.txt:26 en/git-p4.txt:19 en/git-pack-objects.txt:22 en/git-pack-redundant.txt:29 en/git-pack-refs.txt:14 en/git-patch-id.txt:14 en/git-prune-packed.txt:16 en/git-prune.txt:15 en/git-pull.txt:16 en/git-push.txt:20 en/git-quiltimport.txt:17 en/git-range-diff.txt:18 en/git-read-tree.txt:18 en/git-rebase.txt:18 en/git-receive-pack.txt:15 en/git-reflog.txt:21 en/git-remote-ext.txt:14 en/git-remote-fd.txt:13 en/git-remote.txt:27 en/git-repack.txt:15 en/git-replace.txt:19 en/git-request-pull.txt:14 en/git-rerere.txt:14 en/git-reset.txt:17 en/git-restore.txt:16 en/git-revert.txt:15 en/git-rev-list.txt:15 en/git-rev-parse.txt:15 en/git-rm.txt:16 en/git-send-email.txt:18 en/git-send-pack.txt:19 en/git-shell.txt:17 en/git-sh-i18n--envsubst.txt:19 en/git-sh-i18n.txt:14 en/git-shortlog.txt:15 en/git-show-branch.txt:19 en/git-show-index.txt:16 en/git-show-ref.txt:21 en/git-show.txt:15 en/git-sh-setup.txt:14 en/git-stage.txt:16 en/git-stash.txt:28 en/git-status.txt:15 en/git-stripspace.txt:16 en/git-submodule.txt:27 en/git-svn.txt:14 en/git-switch.txt:17 en/git-symbolic-ref.txt:16 en/git-tag.txt:22 en/git.txt:19 en/git-unpack-file.txt:16 en/git-unpack-objects.txt:16 en/git-update-index.txt:32 en/git-update-ref.txt:14 en/git-update-server-info.txt:15 en/git-upload-archive.txt:15 en/git-upload-pack.txt:16 en/git-var.txt:15 en/git-verify-commit.txt:14 en/git-verify-pack.txt:16 en/git-verify-tag.txt:14 en/git-web--browse.txt:14 en/git-whatchanged.txt:15 en/git-worktree.txt:23 en/git-write-tree.txt:15 en/gitglossary.txt:13
#, no-wrap, priority:310
msgid "DESCRIPTION"
msgstr "描述"

#. type: Plain text
#: en/gitignore.txt:19
#, priority:100
msgid "A `gitignore` file specifies intentionally untracked files that Git should ignore. Files already tracked by Git are not affected; see the NOTES below for details."
msgstr "`gitignore` 文件指定了 Git 追踪时应忽略的文件。 已被 Git 追踪的文件不受影响，详见下面的注释。"

#. type: Plain text
#: en/gitignore.txt:25
#, priority:100
msgid "Each line in a `gitignore` file specifies a pattern. When deciding whether to ignore a path, Git normally checks `gitignore` patterns from multiple sources, with the following order of precedence, from highest to lowest (within one level of precedence, the last matching pattern decides the outcome):"
msgstr "`gitignore` 文件中的每一行都指定了一个模式。 在决定是否忽略路径时，Git 通常会检查多个来源的 `gitignore` 模式，优先级从高到低（在一个优先级内，由最后匹配的模式决定结果）："

#. type: Plain text
#: en/gitignore.txt:28
#, priority:100
msgid "Patterns read from the command line for those commands that support them."
msgstr "从支持这些模式的命令行中读取的模式。"

#. type: Plain text
#: en/gitignore.txt:36
#, placeholders:'.gitignore':'.gitignore':'.gitignore', priority:100
msgid "Patterns read from a `.gitignore` file in the same directory as the path, or in any parent directory (up to the top-level of the working tree), with patterns in the higher level files being overridden by those in lower level files down to the directory containing the file. These patterns match relative to the location of the `.gitignore` file. A project normally includes such `.gitignore` files in its repository, containing patterns for files generated as part of the project build."
msgstr "模式从与路径相同目录下的 `.gitignore` 文件或任何父目录（直到工作树的顶层）中读取，上层文件中的模式会被下层文件中的模式覆盖，直到包含该文件的目录。这些模式相对于 `.gitignore` 文件的位置进行匹配。 项目通常会在其资源库中包含此类 `.gitignore` 文件，其中包含项目构建过程中生成的文件的模式。"

#. type: Plain text
#: en/gitignore.txt:38
#, placeholders:'$GIT_DIR', priority:100
msgid "Patterns read from `$GIT_DIR/info/exclude`."
msgstr "从 `$GIT_DIR/info/exclude` 中读取的模式。"

#. type: Plain text
#: en/gitignore.txt:41
#, placeholders:'core.excludesFile', priority:100
msgid "Patterns read from the file specified by the configuration variable `core.excludesFile`."
msgstr "从配置变量 `core.excludesFile` 指定的文件中读取的模式。"

#. type: Plain text
#: en/gitignore.txt:44
#, priority:100
msgid "Which file to place a pattern in depends on how the pattern is meant to be used."
msgstr "将模式放入哪个文件取决于模式的使用方式。"

#. type: Plain text
#: en/gitignore.txt:48
#, placeholders:'.gitignore', priority:100
msgid "Patterns which should be version-controlled and distributed to other repositories via clone (i.e., files that all developers will want to ignore) should go into a `.gitignore` file."
msgstr "应受版本控制并通过克隆分发到其他仓库的模式（即所有开发人员都想忽略的文件）应放入 `.gitignore` 文件。"

#. type: Plain text
#: en/gitignore.txt:54
#, placeholders:'$GIT_DIR', priority:100
msgid "Patterns which are specific to a particular repository but which do not need to be shared with other related repositories (e.g., auxiliary files that live inside the repository but are specific to one user's workflow) should go into the `$GIT_DIR/info/exclude` file."
msgstr "特定于某个仓库但无需与其他相关仓库共享的模式（例如，存在于仓库内部但特定于某个用户工作流程的辅助文件）应放入 `$GIT_DIR/info/exclude` 文件。"

#. type: Plain text
#: en/gitignore.txt:61
#, placeholders:'core.excludesFile':'$XDG_CONFIG_HOME':'$XDG_CONFIG_HOME':'$HOME', priority:100
msgid "Patterns which a user wants Git to ignore in all situations (e.g., backup or temporary files generated by the user's editor of choice) generally go into a file specified by `core.excludesFile` in the user's `~/.gitconfig`. Its default value is $XDG_CONFIG_HOME/git/ignore. If $XDG_CONFIG_HOME is either not set or empty, $HOME/.config/git/ignore is used instead."
msgstr "用户希望 Git 在任何情况下都忽略的模式（例如，由用户选择的编辑器生成的备份或临时文件），一般会放入用户的 `~/.gitconfig` 中由 `core.excludesFile` 指定的文件。它的默认值是 $XDG_CONFIG_HOME/git/ignore。如果 $XDG_CONFIG_HOME 未设置或为空，则使用 $HOME/.config/git/ignore 代替。"

#. type: Plain text
#: en/gitignore.txt:68
#, placeholders:'git ls-files':'git read-tree', priority:100
msgid "The underlying Git plumbing tools, such as 'git ls-files' and 'git read-tree', read `gitignore` patterns specified by command-line options, or from files specified by command-line options. Higher-level Git tools, such as 'git status' and 'git add', use patterns from the sources specified above."
msgstr "底层的 Git 工具，如 'git ls-files' 和 'git read-tree'，会读取命令行选项指定的 'gitignore' 模式，或从命 令行选项指定的文件中读取。 更高层次的 Git 工具，如 'git status' 和 'git add'，会使用上述指定来源的模式。"

#. type: Title -
#: en/gitignore.txt:70
#, no-wrap, priority:100
msgid "PATTERN FORMAT"
msgstr "日期格式"

#. type: Plain text
#: en/gitignore.txt:74
#, priority:100
msgid "A blank line matches no files, so it can serve as a separator for readability."
msgstr "空行不匹配任何文件，因此可以作为分隔符，以提高可读性。"

#. type: Plain text
#: en/gitignore.txt:78
#, priority:100
msgid "A line starting with # serves as a comment. Put a backslash (\"`\\`\") in front of the first hash for patterns that begin with a hash."
msgstr "以 # 开头的一行为注释。 对于以散列开头的模式，在第一个散列前面加上反斜杠（ \"`\\`\" ）。"

#. type: Plain text
#: en/gitignore.txt:81
#, priority:100
msgid "Trailing spaces are ignored unless they are quoted with backslash (\"`\\`\")."
msgstr "除非使用反斜线（\"`\\`\"）引号，否则尾部空格将被忽略。"

#. type: Plain text
#: en/gitignore.txt:90
#, priority:100
msgid "An optional prefix \"`!`\" which negates the pattern; any matching file excluded by a previous pattern will become included again. It is not possible to re-include a file if a parent directory of that file is excluded. Git doesn't list excluded directories for performance reasons, so any patterns on contained files have no effect, no matter where they are defined. Put a backslash (\"`\\`\") in front of the first \"`!`\" for patterns that begin with a literal \"`!`\", for example, \"`\\!important!.txt`\"."
msgstr "一个可选的前缀 \"`!``\"，用于否定模式；任何被先前模式排除的匹配文件都将被重新包含。如果文件的父目录已被排除，则无法重新包含该文件。出于性能考虑，Git 不会列出排除的目录，因此无论在哪里定义，任何包含文件的模式都不会产生影响。 对于以 \"`!`\" 开头的模式，在第一个 \"`!`\" 前面加反斜杠（\"`\\`\"），例如 \"`\\!important!.txt`\"。"

#. type: Plain text
#: en/gitignore.txt:93
#, placeholders:'.gitignore', priority:100
msgid "The slash \"`/`\" is used as the directory separator. Separators may occur at the beginning, middle or end of the `.gitignore` search pattern."
msgstr "斜线 \"`/`\" 用作目录分隔符。分隔符可以出现在 `.gitignore` 搜索模式的开头、中间或结尾。"

#. type: Plain text
#: en/gitignore.txt:98
#, placeholders:'.gitignore':'.gitignore', priority:100
msgid "If there is a separator at the beginning or middle (or both) of the pattern, then the pattern is relative to the directory level of the particular `.gitignore` file itself. Otherwise the pattern may also match at any level below the `.gitignore` level."
msgstr "如果在模式的开头或中间（或两者都有）有分隔符，则该模式是相对于特定 `.gitignore` 文件本身的目录层级而言的。否则，该模式也可能匹配 `.gitignore` 层级以下的任何层级。"

#. type: Plain text
#: en/gitignore.txt:102
#, priority:100
msgid "If there is a separator at the end of the pattern then the pattern will only match directories, otherwise the pattern can match both files and directories."
msgstr "如果模式末尾有分隔符，则模式只能匹配目录，否则模式既可以匹配文件，也可以匹配目录。"

#. type: Plain text
#: en/gitignore.txt:107
#, placeholders:'.gitignore', priority:100
msgid "For example, a pattern `doc/frotz/` matches `doc/frotz` directory, but not `a/doc/frotz` directory; however `frotz/` matches `frotz` and `a/frotz` that is a directory (all paths are relative from the `.gitignore` file)."
msgstr "例如，模式 `doc/frotz/` 匹配 `doc/frotz` 目录，但不匹配 `a/doc/frotz` 目录；而 `frotz/` 则匹配 `frotz` 和 `a/frotz` 这两个目录（所有路径都是从 `.gitignore` 文件开始的相对路径）。"

#. type: Plain text
#: en/gitignore.txt:113
#, placeholders:'FNM_PATHNAME', priority:100
msgid "An asterisk \"`*`\" matches anything except a slash. The character \"`?`\" matches any one character except \"`/`\". The range notation, e.g. `[a-zA-Z]`, can be used to match one of the characters in a range. See fnmatch(3) and the FNM_PATHNAME flag for a more detailed description."
msgstr "星号 \"`*`\" 匹配斜线以外的任何字符。 字符 \"`?`\" 匹配除 \"`/`\" 以外的任何一个字符。 范围符号，如 \"`[a-zA-Z]`\"，可用于匹配范围中的一个字符。更详细的说明请参见 fnmatch(3) 和 FNM_PATHNAME 标志。"

#. type: Plain text
#: en/gitignore.txt:116 en/glossary-content.txt:418
#, priority:310
msgid "Two consecutive asterisks (\"`**`\") in patterns matched against full pathname may have special meaning:"
msgstr "在与全路径名匹配的模式中，两个连续的星号（\"`**`\"）可能有特殊含义："

#. type: Plain text
#: en/gitignore.txt:122 en/glossary-content.txt:424
#, priority:310
msgid "A leading \"`**`\" followed by a slash means match in all directories. For example, \"`**/foo`\" matches file or directory \"`foo`\" anywhere, the same as pattern \"`foo`\". \"`**/foo/bar`\" matches file or directory \"`bar`\" anywhere that is directly under directory \"`foo`\"."
msgstr "\"`**`\"在带斜杠目录之前，表示在所有目录中匹配。例如，\"`**/foo`\"匹配任何文件或目录的\"`foo`\"，与模式\"`foo`\"相同。\"`**/foo/bar`\"匹配任何文件或目录中直接位于目录\"`foo`\"之下的\"`bar`\"。"

#. type: Plain text
#: en/gitignore.txt:126
#, placeholders:'.gitignore', priority:100
msgid "A trailing \"`/**`\" matches everything inside. For example, \"`abc/**`\" matches all files inside directory \"`abc`\", relative to the location of the `.gitignore` file, with infinite depth."
msgstr "路径后跟有 \"`/**`\" 表示匹配这个目录里面的所有文件。例如，\"`abc/**`\" 匹配相对于 `.gitignore` 文件的位置中目录 \"`abc`\" 内的所有文件，深度无限。"

#. type: Plain text
#: en/gitignore.txt:130 en/glossary-content.txt:432
#, priority:310
msgid "A slash followed by two consecutive asterisks then a slash matches zero or more directories. For example, \"`a/**/b`\" matches \"`a/b`\", \"`a/x/b`\", \"`a/x/y/b`\" and so on."
msgstr "一个斜杠后面是两个连续的星号再接上一个斜杠，匹配零个或多个目录。例如，\"`a/**/b`\" 匹配 \"`a/b`\"、\"`a/x/b`\"、\"`a/x/y/b`\"，等等，依此类推。"

#. type: Plain text
#: en/gitignore.txt:133
#, priority:100
msgid "Other consecutive asterisks are considered regular asterisks and will match according to the previous rules."
msgstr "其他连续星号被视为普通星号，将根据前面的规则进行匹配。"

#. type: Title -
#: en/gitignore.txt:135 en/git-add.txt:437 en/git-am.txt:270 en/git-apply.txt:264 en/git-archive.txt:137 en/git-blame.txt:245 en/git-branch.txt:343 en/git-check-mailmap.txt:40 en/git-checkout.txt:613 en/git-clean.txt:137 en/git-clone.txt:385 en/git-column.txt:78 en/git-config.txt:291 en/git-cvsexportcommit.txt:86 en/git-difftool.txt:119 en/git-diff.txt:224 en/git-fast-import.txt:1568 en/git-fetch.txt:298 en/git-fmt-merge-msg.txt:57 en/git-format-patch.txt:416 en/git-fsck.txt:108 en/git-gc.txt:120 en/git-grep.txt:344 en/git-imap-send.txt:52 en/git-init.txt:180 en/git-instaweb.txt:70 en/git-log.txt:198 en/git-mailinfo.txt:119 en/git-mergetool.txt:104 en/git-merge.txt:391 en/git-notes.txt:336 en/git-pack-objects.txt:443 en/git-push.txt:701 en/git-range-diff.txt:128 en/git-rebase.txt:1287 en/git-repack.txt:253 en/git-revert.txt:156 en/git-send-email.txt:478 en/git-show-branch.txt:203 en/git-stash.txt:389 en/git-status.txt:426 en/git-svn.txt:1064 en/git-switch.txt:274 en/git-tag.txt:219 en/git-update-index.txt:561
#, no-wrap, priority:300
msgid "CONFIGURATION"
msgstr "配置"

#. type: Plain text
#: en/gitignore.txt:141
#, placeholders:'core.excludesFile':'$GIT_DIR':'$GIT_DIR', priority:100
msgid "The optional configuration variable `core.excludesFile` indicates a path to a file containing patterns of file names to exclude, similar to `$GIT_DIR/info/exclude`. Patterns in the exclude file are used in addition to those in `$GIT_DIR/info/exclude`."
msgstr "可选的配置变量 `core.excludesFile` 表示包含要排除的文件名模式的文件路径，类似于 `$GIT_DIR/info/exclude`。 除 `$GIT_DIR/info/exclude` 中的模式外，还将使用排除文件中的模式。"

#. type: Title -
#: en/gitignore.txt:143 en/git-branch.txt:396 en/git-for-each-ref.txt:492 en/git-gc.txt:127 en/git-index-pack.txt:144 en/git-prune.txt:71 en/git-rebase.txt:823 en/git-symbolic-ref.txt:63 en/git-tag.txt:395 en/git-update-index.txt:589
#, no-wrap, priority:260
msgid "NOTES"
msgstr "注释"

#. type: Plain text
#: en/gitignore.txt:147
#, priority:100
msgid "The purpose of gitignore files is to ensure that certain files not tracked by Git remain untracked."
msgstr "使用 gitignore 文件的目的是确保某些不被 Git 追踪的文件不被追踪。"

#. type: Plain text
#: en/gitignore.txt:152
#, placeholders:'--cached':'.gitignore', priority:100
msgid "To stop tracking a file that is currently tracked, use 'git rm --cached' to remove the file from the index. The filename can then be added to the `.gitignore` file to stop the file from being reintroduced in later commits."
msgstr "要停止跟踪当前已被跟踪的文件，可使用 'git rm --cached' 从索引中移除该文件。文件名随后会被添加到 `.gitignore` 文件中，以防止该文件在以后的提交中被重新引入。"

#. type: Plain text
#: en/gitignore.txt:156
#, placeholders:'.gitignore', priority:100
msgid "Git does not follow symbolic links when accessing a `.gitignore` file in the working tree. This keeps behavior consistent when the file is accessed from the index or a tree versus from the filesystem."
msgstr "访问工作树中的 `.gitignore` 文件时，Git 不会跟踪符号链接。这样，当从索引或工作树访问文件时，与从文件系统访问文件时的行为保持一致。"

#. type: Title -
#: en/gitignore.txt:158 en/git-add.txt:220 en/git-archive.txt:187 en/git-bisect.txt:385 en/git-branch.txt:353 en/git-bundle.txt:217 en/git-check-attr.txt:76 en/git-checkout-index.txt:149 en/git-checkout.txt:522 en/git-check-ref-format.txt:123 en/git-cherry-pick.txt:166 en/git-cherry.txt:43 en/git-clone.txt:348 en/git-column.txt:50 en/git-commit.txt:410 en/git-config.txt:435 en/git-credential-cache.txt:58 en/git-credential-store.txt:71 en/git-cvsexportcommit.txt:91 en/git-daemon.txt:259 en/git-describe.txt:128 en/git-diff.txt:151 en/git-fast-export.txt:167 en/git-fetch.txt:255 en/git-filter-branch.txt:247 en/git-fmt-merge-msg.txt:65 en/git-for-each-ref.txt:376 en/git-format-patch.txt:723 en/git-grep.txt:315 en/git-http-backend.txt:69 en/git-imap-send.txt:62 en/git-init.txt:164 en/git-interpret-trailers.txt:327 en/git-log.txt:136 en/git-ls-remote.txt:114 en/git-merge-file.txt:103 en/git-merge.txt:357 en/git-name-rev.txt:88 en/git-notes.txt:302 en/git-p4.txt:33 en/git-prune.txt:60 en/git-pull.txt:202 en/git-push.txt:599 en/git-range-diff.txt:135 en/git-remote-ext.txt:77 en/git-remote-fd.txt:37 en/git-remote.txt:220 en/git-request-pull.txt:50 en/git-reset.txt:137 en/git-restore.txt:154 en/git-revert.txt:131 en/git-rev-list.txt:35 en/git-rev-parse.txt:467 en/git-rm.txt:175 en/git-send-email.txt:485 en/git-shell.txt:66 en/git-show-branch.txt:177 en/git-show-ref.txt:150 en/git-show.txt:61 en/git-stash.txt:286 en/git-stripspace.txt:49 en/git-switch.txt:198 en/git-update-index.txt:366 en/git-var.txt:28 en/git-worktree.txt:494
#, no-wrap, priority:300
msgid "EXAMPLES"
msgstr "实例"

#. type: Plain text
#: en/gitignore.txt:166
#, placeholders:'hello.txt':'hello.java', priority:100
msgid "The pattern `hello.*` matches any file or directory whose name begins with `hello.`. If one wants to restrict this only to the directory and not in its subdirectories, one can prepend the pattern with a slash, i.e. `/hello.*`; the pattern now matches `hello.txt`, `hello.c` but not `a/hello.java`."
msgstr "模式 `hello.*` 匹配名称以 `hello.` 开头的任何文件或目录。如果只想将其限制在目录中，而不限制在其子目录中，则可以在模式前加上斜线，即 `/hello.*`；现在该模式可匹配 `hello.txt` 和 `hello.c` 但不匹配 `a/hello.java`。"

#. type: Plain text
#: en/gitignore.txt:171
#, priority:100
msgid "The pattern `foo/` will match a directory `foo` and paths underneath it, but will not match a regular file or a symbolic link `foo` (this is consistent with the way how pathspec works in general in Git)"
msgstr "模式 `foo/` 将匹配目录 `foo` 及其下的路径，但不会匹配常规文件或符号链接 `foo`（这与 Git 中 pathspec 的一般工作方式一致）"

#. type: Plain text
#: en/gitignore.txt:176
#, placeholders:'.gitignore', priority:100
msgid "The pattern `doc/frotz` and `/doc/frotz` have the same effect in any `.gitignore` file. In other words, a leading slash is not relevant if there is already a middle slash in the pattern."
msgstr "`doc/frotz` 和 `/doc/frotz` 模式在任何 `.gitignore` 文件中都有同样的效果。换句话说，如果模式中已经有中间斜线，那么前导斜线就无关紧要了。"

#. type: Plain text
#: en/gitignore.txt:181
#, placeholders:'test.json', priority:100
msgid "The pattern `foo/*`, matches `foo/test.json` (a regular file), `foo/bar` (a directory), but it does not match `foo/bar/hello.c` (a regular file), as the asterisk in the pattern does not match `bar/hello.c` which has a slash in it."
msgstr "模式 `foo/*` 匹配 `foo/test.json`（一个正则文件）和 `foo/bar`（一个目录），但不匹配 `foo/bar/hello.c`（一个正则文件），因为模式中的星号不匹配 `bar/hello.c`，因为 `bar/hello.c` 中含有斜线。"

#. type: delimited block -
#: en/gitignore.txt:207
#, ignore-ellipsis, no-wrap, placeholders:'foo.html':'gitignore.html':'.git/info/exclude':'.gitignore':'foo.html':'foo.html':'foo.html', priority:100
msgid ""
"    $ git status\n"
"    [...]\n"
"    # Untracked files:\n"
"    [...]\n"
"    #       Documentation/foo.html\n"
"    #       Documentation/gitignore.html\n"
"    #       file.o\n"
"    #       lib.a\n"
"    #       src/internal.o\n"
"    [...]\n"
"    $ cat .git/info/exclude\n"
"    # ignore objects and archives, anywhere in the tree.\n"
"    *.[oa]\n"
"    $ cat Documentation/.gitignore\n"
"    # ignore generated html files,\n"
"    *.html\n"
"    # except foo.html which is maintained by hand\n"
"    !foo.html\n"
"    $ git status\n"
"    [...]\n"
"    # Untracked files:\n"
"    [...]\n"
"    #       Documentation/foo.html\n"
"    [...]\n"
msgstr ""
"    $ git status\n"
"    [...]\n"
"    # 未追踪的文件:\n"
"    [...]\n"
"    #       Documentation/foo.html\n"
"    #       Documentation/gitignore.html\n"
"    #       file.o\n"
"    #       lib.a\n"
"    #       src/internal.o\n"
"    [...]\n"
"    $ cat .git/info/exclude\n"
"    # 忽略在目录树中的所有对象和存档文件\n"
"    *.[oa]\n"
"    $ cat Documentation/.gitignore\n"
"    # 忽略 html 文件,\n"
"    *.html\n"
"    # 但追踪自己写的 foo.html\n"
"    !foo.html\n"
"    $ git status\n"
"    [...]\n"
"    # 未追踪的文件:\n"
"    [...]\n"
"    #       Documentation/foo.html\n"
"    [...]\n"

#. type: Plain text
#: en/gitignore.txt:210
#, priority:100
msgid "Another example:"
msgstr "再举一个例子："

#. type: delimited block -
#: en/gitignore.txt:217
#, no-wrap, placeholders:'.gitignore':'vmlinux.lds':'.gitignore', priority:100
msgid ""
"    $ cat .gitignore\n"
"    vmlinux*\n"
"    $ ls arch/foo/kernel/vm*\n"
"    arch/foo/kernel/vmlinux.lds.S\n"
"    $ echo '!/vmlinux*' >arch/foo/kernel/.gitignore\n"
msgstr ""
"    $ cat .gitignore\n"
"    vmlinux*\n"
"    $ ls arch/foo/kernel/vm*\n"
"    arch/foo/kernel/vmlinux.lds.S\n"
"    $ echo '!/vmlinux*' >arch/foo/kernel/.gitignore\n"

#. type: Plain text
#: en/gitignore.txt:221
#, placeholders:'.gitignore':'vmlinux.lds', priority:100
msgid "The second .gitignore prevents Git from ignoring `arch/foo/kernel/vmlinux.lds.S`."
msgstr "第二个 .gitignore 阻止 Git 忽略 `arch/foo/kernel/vmlinux.lds.S`。"

#. type: Plain text
#: en/gitignore.txt:225
#, priority:100
msgid "Example to exclude everything except a specific directory `foo/bar` (note the `/*` - without the slash, the wildcard would also exclude everything within `foo/bar`):"
msgstr "示例排除除特定目录 `foo/bar` 以外的所有内容（注意 `/*` - 如果没有斜线，通配符也会排除 `foo/bar` 中的所有内容）："

#. type: delimited block -
#: en/gitignore.txt:233
#, no-wrap, placeholders:'.gitignore', priority:100
msgid ""
"    $ cat .gitignore\n"
"    # exclude everything except directory foo/bar\n"
"    /*\n"
"    !/foo\n"
"    /foo/*\n"
"    !/foo/bar\n"
msgstr ""
"    $ cat .gitignore\n"
"    # 排除 foo/bar 以外的所有内容\n"
"    /*\n"
"    !/foo\n"
"    /foo/*\n"
"    !/foo/bar\n"

#. type: Title -
#: en/gitignore.txt:236 en/git-add.txt:444 en/git-am.txt:277 en/git-annotate.txt:28 en/git-apply.txt:286 en/git-archive.txt:236 en/git-bisect.txt:509 en/git-blame.txt:252 en/git-branch.txt:421 en/git-check-attr.txt:120 en/git-check-ignore.txt:119 en/git-checkout.txt:620 en/git-cherry-pick.txt:238 en/git-cherry.txt:140 en/git-clean.txt:144 en/git-commit-tree.txt:95 en/git-commit.txt:581 en/git-difftool.txt:128 en/git-diff.txt:231 en/git-fast-export.txt:279 en/git-fast-import.txt:1575 en/git-fetch-pack.txt:131 en/git-fetch.txt:312 en/git-fmt-merge-msg.txt:77 en/git-for-each-ref.txt:497 en/git-format-patch.txt:776 en/git-gc.txt:167 en/git-gui.txt:103 en/git-imap-send.txt:141 en/git-instaweb.txt:89 en/git-interpret-trailers.txt:518 en/git-ls-files.txt:339 en/git-ls-remote.txt:147 en/git-merge.txt:403 en/git-pack-objects.txt:453 en/git-pack-redundant.txt:57 en/git-prune-packed.txt:41 en/git-prune.txt:81 en/git-pull.txt:249 en/git-range-diff.txt:292 en/git-read-tree.txt:431 en/git-receive-pack.txt:256 en/git-remote-ext.txt:120 en/git-remote-fd.txt:54 en/git-remote.txt:262 en/git-repack.txt:273 en/git-replace.txt:149 en/git-restore.txt:216 en/git-revert.txt:163 en/git-rm.txt:199 en/git-send-email.txt:523 en/git-shell.txt:99 en/git-show-ref.txt:204 en/git-stash.txt:397 en/git-status.txt:522 en/git-submodule.txt:462 en/git-svn.txt:1169 en/git-switch.txt:281 en/git-tag.txt:400 en/git.txt:1099 en/git-update-index.txt:605 en/git-upload-pack.txt:59 en/git-var.txt:98 en/gitglossary.txt:18
#, no-wrap, priority:310
msgid "SEE ALSO"
msgstr "参见"

#. type: Plain text
#: en/gitignore.txt:240
#, ignore-same, priority:100
msgid "linkgit:git-rm[1], linkgit:gitrepository-layout[5], linkgit:git-check-ignore[1]"
msgstr "linkgit:git-rm[1], linkgit:gitrepository-layout[5], linkgit:git-check-ignore[1]"

#. type: Title -
#: en/gitignore.txt:242 en/git-add.txt:453 en/git-am.txt:282 en/git-annotate.txt:32 en/git-apply.txt:290 en/git-archimport.txt:112 en/git-archive.txt:240 en/git-bisect.txt:514 en/git-blame.txt:256 en/git-branch.txt:429 en/git-bugreport.txt:72 en/git-bundle.txt:330 en/git-cat-file.txt:411 en/git-check-attr.txt:124 en/git-check-ignore.txt:125 en/git-check-mailmap.txt:53 en/git-checkout-index.txt:182 en/git-checkout.txt:625 en/git-check-ref-format.txt:139 en/git-cherry-pick.txt:242 en/git-cherry.txt:144 en/git-citool.txt:24 en/git-clean.txt:148 en/git-clone.txt:395 en/git-column.txt:85 en/git-commit-tree.txt:100 en/git-commit.txt:589 en/git-config.txt:591 en/git-count-objects.txt:53 en/git-credential-cache--daemon.txt:29 en/git-credential-cache.txt:82 en/git-credential-store.txt:109 en/git-credential.txt:195 en/git-cvsexportcommit.txt:117 en/git-cvsimport.txt:227 en/git-cvsserver.txt:432 en/git-daemon.txt:340 en/git-describe.txt:210 en/git-diff-files.txt:51 en/git-diff-index.txt:126 en/git-difftool.txt:139 en/git-diff-tree.txt:130 en/git-diff.txt:241 en/git-fast-export.txt:283 en/git-fast-import.txt:1579 en/git-fetch-pack.txt:135 en/git-fetch.txt:316 en/git-filter-branch.txt:702 en/git-fmt-merge-msg.txt:81 en/git-for-each-ref.txt:501 en/git-format-patch.txt:780 en/git-fsck-objects.txt:21 en/git-fsck.txt:180 en/git-gc.txt:174 en/git-get-tar-commit-id.txt:29 en/git-grep.txt:351 en/git-gui.txt:120 en/git-hash-object.txt:64 en/git-help.txt:230 en/git-http-backend.txt:300 en/git-http-fetch.txt:61 en/git-http-push.txt:95 en/git-imap-send.txt:145 en/git-index-pack.txt:154 en/git-init-db.txt:22 en/git-init.txt:187 en/git-instaweb.txt:93 en/git-interpret-trailers.txt:522 en/git-log.txt:219 en/git-ls-files.txt:343 en/git-ls-remote.txt:151 en/git-ls-tree.txt:164 en/git-mailinfo.txt:126 en/git-mailsplit.txt:56 en/git-merge-base.txt:246 en/git-merge-file.txt:121 en/git-merge-index.txt:82 en/git-merge-one-file.txt:20 en/git-mergetool--lib.txt:52 en/git-mergetool.txt:129 en/git-merge-tree.txt:315 en/git-merge.txt:412 en/git-mktag.txt:65 en/git-mktree.txt:39 en/git-mv.txt:68 en/git-name-rev.txt:111 en/git-notes.txt:381 en/git-p4.txt:802 en/git-pack-objects.txt:459 en/git-pack-redundant.txt:63 en/git-pack-refs.txt:95 en/git-patch-id.txt:68 en/git-prune-packed.txt:46 en/git-prune.txt:88 en/git-pull.txt:253 en/git-push.txt:708 en/git-quiltimport.txt:63 en/git-range-diff.txt:296 en/git-read-tree.txt:436 en/git-rebase.txt:1295 en/git-receive-pack.txt:260 en/git-reflog.txt:134 en/git-remote-ext.txt:124 en/git-remote-fd.txt:58 en/git-remote.txt:268 en/git-repack.txt:278 en/git-replace.txt:160 en/git-request-pull.txt:78 en/git-rerere.txt:221 en/git-reset.txt:505 en/git-restore.txt:221 en/git-revert.txt:167 en/git-rev-list.txt:128 en/git-rev-parse.txt:492 en/git-rm.txt:203 en/git-send-email.txt:527 en/git-send-pack.txt:156 en/git-shell.txt:105 en/git-sh-i18n--envsubst.txt:35 en/git-sh-i18n.txt:42 en/git-shortlog.txt:129 en/git-show-branch.txt:210 en/git-show-index.txt:51 en/git-show-ref.txt:211 en/git-show.txt:89 en/git-sh-setup.txt:94 en/git-stage.txt:22 en/git-stash.txt:405 en/git-status.txt:526 en/git-stripspace.txt:93 en/git-submodule.txt:466 en/git-svn.txt:1173 en/git-switch.txt:286 en/git-symbolic-ref.txt:77 en/git-tag.txt:405 en/git.txt:1107 en/git-unpack-file.txt:27 en/git-unpack-objects.txt:51 en/git-update-index.txt:611 en/git-update-ref.txt:179 en/git-update-server-info.txt:40 en/git-upload-archive.txt:61 en/git-upload-pack.txt:63 en/git-var.txt:104 en/git-verify-commit.txt:31 en/git-verify-pack.txt:52 en/git-verify-tag.txt:31 en/git-web--browse.txt:123 en/git-whatchanged.txt:42 en/git-worktree.txt:520 en/git-write-tree.txt:41 en/gitglossary.txt:26
#, no-wrap, priority:310
msgid "GIT"
msgstr "GIT"

#. type: Plain text
#: en/gitignore.txt:243 en/git-add.txt:454 en/git-am.txt:283 en/git-annotate.txt:33 en/git-apply.txt:291 en/git-archimport.txt:113 en/git-archive.txt:241 en/git-bisect.txt:515 en/git-blame.txt:257 en/git-branch.txt:430 en/git-bugreport.txt:73 en/git-bundle.txt:331 en/git-cat-file.txt:412 en/git-check-attr.txt:125 en/git-check-ignore.txt:126 en/git-check-mailmap.txt:54 en/git-checkout-index.txt:183 en/git-checkout.txt:626 en/git-check-ref-format.txt:140 en/git-cherry-pick.txt:243 en/git-cherry.txt:145 en/git-citool.txt:25 en/git-clean.txt:149 en/git-clone.txt:396 en/git-column.txt:86 en/git-commit-tree.txt:101 en/git-commit.txt:590 en/git-config.txt:592 en/git-count-objects.txt:54 en/git-credential-cache--daemon.txt:30 en/git-credential-cache.txt:83 en/git-credential-store.txt:110 en/git-credential.txt:196 en/git-cvsexportcommit.txt:118 en/git-cvsimport.txt:228 en/git-cvsserver.txt:433 en/git-daemon.txt:341 en/git-describe.txt:211 en/git-diff-files.txt:52 en/git-diff-index.txt:127 en/git-difftool.txt:140 en/git-diff-tree.txt:131 en/git-diff.txt:242 en/git-fast-export.txt:284 en/git-fast-import.txt:1580 en/git-fetch-pack.txt:136 en/git-fetch.txt:317 en/git-filter-branch.txt:703 en/git-fmt-merge-msg.txt:82 en/git-for-each-ref.txt:502 en/git-format-patch.txt:781 en/git-fsck-objects.txt:22 en/git-fsck.txt:181 en/git-gc.txt:175 en/git-get-tar-commit-id.txt:30 en/git-grep.txt:352 en/git-gui.txt:121 en/git-hash-object.txt:65 en/git-help.txt:231 en/git-http-backend.txt:301 en/git-http-fetch.txt:62 en/git-http-push.txt:96 en/git-imap-send.txt:146 en/git-index-pack.txt:155 en/git-init-db.txt:23 en/git-init.txt:188 en/git-instaweb.txt:94 en/git-interpret-trailers.txt:523 en/git-log.txt:220 en/git-ls-files.txt:344 en/git-ls-remote.txt:152 en/git-ls-tree.txt:165 en/git-mailinfo.txt:127 en/git-mailsplit.txt:57 en/git-merge-base.txt:247 en/git-merge-file.txt:122 en/git-merge-index.txt:83 en/git-merge-one-file.txt:21 en/git-mergetool--lib.txt:53 en/git-mergetool.txt:130 en/git-merge-tree.txt:316 en/git-merge.txt:413 en/git-mktag.txt:66 en/git-mktree.txt:40 en/git-mv.txt:69 en/git-name-rev.txt:112 en/git-notes.txt:382 en/git-p4.txt:803 en/git-pack-objects.txt:460 en/git-pack-redundant.txt:64 en/git-pack-refs.txt:96 en/git-patch-id.txt:69 en/git-prune-packed.txt:47 en/git-prune.txt:89 en/git-pull.txt:254 en/git-push.txt:709 en/git-quiltimport.txt:64 en/git-range-diff.txt:297 en/git-read-tree.txt:437 en/git-rebase.txt:1296 en/git-receive-pack.txt:261 en/git-reflog.txt:135 en/git-remote-ext.txt:125 en/git-remote-fd.txt:59 en/git-remote.txt:269 en/git-repack.txt:279 en/git-replace.txt:161 en/git-request-pull.txt:79 en/git-rerere.txt:222 en/git-reset.txt:506 en/git-restore.txt:222 en/git-revert.txt:168 en/git-rev-list.txt:129 en/git-rev-parse.txt:493 en/git-rm.txt:204 en/git-send-email.txt:528 en/git-send-pack.txt:157 en/git-shell.txt:106 en/git-sh-i18n--envsubst.txt:36 en/git-sh-i18n.txt:43 en/git-shortlog.txt:130 en/git-show-branch.txt:211 en/git-show-index.txt:52 en/git-show-ref.txt:212 en/git-show.txt:90 en/git-sh-setup.txt:95 en/git-stage.txt:23 en/git-stash.txt:406 en/git-status.txt:527 en/git-stripspace.txt:94 en/git-submodule.txt:467 en/git-svn.txt:1174 en/git-switch.txt:287 en/git-symbolic-ref.txt:78 en/git-tag.txt:406 en/git.txt:1108 en/git-unpack-file.txt:28 en/git-unpack-objects.txt:52 en/git-update-index.txt:612 en/git-update-ref.txt:180 en/git-update-server-info.txt:41 en/git-upload-archive.txt:62 en/git-upload-pack.txt:64 en/git-var.txt:105 en/git-verify-commit.txt:32 en/git-verify-pack.txt:53 en/git-verify-tag.txt:32 en/git-web--browse.txt:124 en/git-whatchanged.txt:43 en/git-worktree.txt:521 en/git-write-tree.txt:42 en/gitglossary.txt:27
#, placeholders:'linkgit:git[1]', priority:310
msgid "Part of the linkgit:git[1] suite"
msgstr "属于 linkgit:git[1] 文档"

#. type: Title =
#: en/git-add.txt:2
#, ignore-same, no-wrap, priority:300
msgid "git-add(1)"
msgstr "git-add(1)"

#. type: Plain text
#: en/git-add.txt:7
#, placeholders:'git-add', priority:300
msgid "git-add - Add file contents to the index"
msgstr "git-add - 添加文件内容到索引"

#. type: Plain text
#: en/git-add.txt:16
#, ignore-ellipsis, no-wrap, placeholders:'[--verbose':'[--dry-run':'[--force':'[--interactive':'[--patch':'[--edit':'[--update':'[--sparse]':'[--intent-to-add':'[--refresh]':'[--ignore-errors]':'[--ignore-missing]':'[--renormalize]':'[--chmod=(+|-)x]':'[--pathspec-from-file=':'[--pathspec-file-nul]', priority:300
msgid ""
"'git add' [--verbose | -v] [--dry-run | -n] [--force | -f] [--interactive | -i] [--patch | -p]\n"
"\t  [--edit | -e] [--[no-]all | -A | --[no-]ignore-removal | [--update | -u]] [--sparse]\n"
"\t  [--intent-to-add | -N] [--refresh] [--ignore-errors] [--ignore-missing] [--renormalize]\n"
"\t  [--chmod=(+|-)x] [--pathspec-from-file=<file> [--pathspec-file-nul]]\n"
"\t  [--] [<pathspec>...]\n"
msgstr ""
"'git add' [--verbose | -v] [--dry-run | -n] [--force | -f] [--interactive | -i] [--patch | -p]\n"
"\t  [--edit | -e] [--[no-]all | -A | --[no-]ignore-removal | [--update | -u]] [--sparse]\n"
"\t  [--intent-to-add | -N] [--refresh] [--ignore-errors] [--ignore-missing] [--renormalize]\n"
"\t  [--chmod=(+|-)x] [--pathspec-from-file=<文件> [--pathspec-file-nul]]\n"
"\t  [--] [<路径规范>...]\n"

#. type: Plain text
#: en/git-add.txt:25
#, priority:300
msgid "This command updates the index using the current content found in the working tree, to prepare the content staged for the next commit. It typically adds the current content of existing paths as a whole, but with some options it can also be used to add content with only part of the changes made to the working tree files applied, or remove paths that do not exist in the working tree anymore."
msgstr "该命令使用工作区的内容来更新索引，为下一次提交准备暂存的内容。通常情况下会添加当前目录的所有内容到索引，但是通过某些选项，它也可以用于仅添加对工作树文件所做的部分更改，或删除工作树中不存在的路径。"

#. type: Plain text
#: en/git-add.txt:31
#, priority:300
msgid "The \"index\" holds a snapshot of the content of the working tree, and it is this snapshot that is taken as the contents of the next commit. Thus after making any changes to the working tree, and before running the commit command, you must use the `add` command to add any new or modified files to the index."
msgstr "索引区中储存着一份工作区的快照，在下次提交时这份快照会被保存到 Git 仓库中。因此在工作区做过修改后以及在运行下一次提交命令前，你必须通过 `add` 命令来添加新创建的文件或者保存新的改动到索引中。"

#. type: Plain text
#: en/git-add.txt:36
#, priority:300
msgid "This command can be performed multiple times before a commit. It only adds the content of the specified file(s) at the time the add command is run; if you want subsequent changes included in the next commit, then you must run `git add` again to add the new content to the index."
msgstr "提交前可以多次执行此命令。它仅在运行add命令时添加指定文件的内容；如果要在下一次提交中包含后续更改，则必须再次运行`git add`将新内容添加到索引中。"

#. type: Plain text
#: en/git-add.txt:39
#, priority:300
msgid "The `git status` command can be used to obtain a summary of which files have changes that are staged for the next commit."
msgstr "`git status` 命令可用于获取摘要，说明哪些变化的文件已暂存，准备下一次提交。"

# ERROR: `-f` not found in translation
#. type: Plain text
#: en/git-add.txt:46
#, placeholders:'`-f`', priority:300
msgid "The `git add` command will not add ignored files by default. If any ignored files were explicitly specified on the command line, `git add` will fail with a list of ignored files. Ignored files reached by directory recursion or filename globbing performed by Git (quote your globs before the shell) will be silently ignored. The 'git add' command can be used to add ignored files with the `-f` (force) option."
msgstr "`git add` 命令默认不会添加被忽略的文件。如果在命令行上明确指定了任何被忽略的文件，则 `git add` 会失败，并显示被忽略文件的列表。由目录递归或 Git 执行的文件名通配符（在 shell 之前引用的通配符）所涉及的忽略文件将被静默忽略。 'git add' 命令可用于通过 `-f` 选项（force）强制添加忽略的文件。"

#. type: Plain text
#: en/git-add.txt:49
#, placeholders:'linkgit:git-commit[1]', priority:300
msgid "Please see linkgit:git-commit[1] for alternative ways to add content to a commit."
msgstr "请参阅 linkgit:git-commit[1] 了解将内容添加到提交的其他替代方法。"

#. type: Title -
#: en/git-add.txt:52 en/git-am.txt:32 en/git-annotate.txt:24 en/git-apply.txt:36 en/git-archimport.txt:69 en/git-archive.txt:34 en/git-bisect.txt:361 en/git-blame.txt:50 en/git-branch.txt:97 en/git-bugreport.txt:46 en/git-bundle.txt:63 en/git-cat-file.txt:34 en/git-check-attr.txt:21 en/git-check-ignore.txt:27 en/git-check-mailmap.txt:25 en/git-checkout-index.txt:25 en/git-checkout.txt:110 en/git-check-ref-format.txt:100 en/git-cherry-pick.txt:42 en/git-cherry.txt:28 en/git-clean.txt:27 en/git-clone.txt:44 en/git-column.txt:22 en/git-commit-tree.txt:46 en/git-commit.txt:66 en/git-config.txt:79 en/git-count-objects.txt:20 en/git-credential-cache.txt:30 en/git-credential-store.txt:30 en/git-cvsexportcommit.txt:35 en/git-cvsimport.txt:51 en/git-cvsserver.txt:40 en/git-daemon.txt:48 en/git-describe.txt:36 en/git-diff-files.txt:22 en/git-diff-index.txt:23 en/git-difftool.txt:21 en/git-diff-tree.txt:26 en/git-diff.txt:124 en/git-fast-export.txt:25 en/git-fast-import.txt:35 en/git-fetch-pack.txt:34 en/git-fetch.txt:46 en/git-filter-branch.txt:96 en/git-fmt-merge-msg.txt:25 en/git-for-each-ref.txt:30 en/git-format-patch.txt:106 en/git-fsck.txt:22 en/git-gc.txt:35 en/git-grep.txt:43 en/git-hash-object.txt:25 en/git-help.txt:48 en/git-http-fetch.txt:23 en/git-http-push.txt:24 en/git-imap-send.txt:30 en/git-index-pack.txt:27 en/git-init.txt:42 en/git-instaweb.txt:21 en/git-interpret-trailers.txt:113 en/git-log.txt:28 en/git-ls-files.txt:37 en/git-ls-remote.txt:23 en/git-ls-tree.txt:37 en/git-mailinfo.txt:28 en/git-mailsplit.txt:23 en/git-merge-base.txt:70 en/git-merge-file.txt:58 en/git-merge-index.txt:22 en/git-mergetool.txt:26 en/git-merge-tree.txt:41 en/git-merge.txt:65 en/git-mktag.txt:41 en/git-mktree.txt:22 en/git-mv.txt:30 en/git-name-rev.txt:22 en/git-notes.txt:132 en/git-p4.txt:199 en/git-pack-objects.txt:51 en/git-pack-redundant.txt:43 en/git-pack-refs.txt:46 en/git-patch-id.txt:31 en/git-prune-packed.txt:30 en/git-prune.txt:34 en/git-pull.txt:78 en/git-quiltimport.txt:32 en/git-range-diff.txt:49 en/git-read-tree.txt:32 en/git-rebase.txt:245 en/git-receive-pack.txt:40 en/git-reflog.txt:58 en/git-remote.txt:33 en/git-repack.txt:29 en/git-replace.txt:59 en/git-request-pull.txt:28 en/git-reset.txt:105 en/git-restore.txt:34 en/git-revert.txt:35 en/git-rev-list.txt:27 en/git-rev-parse.txt:26 en/git-rm.txt:32 en/git-send-email.txt:45 en/git-send-pack.txt:28 en/git-shortlog.txt:27 en/git-show-branch.txt:32 en/git-show-index.txt:40 en/git-show-ref.txt:42 en/git-show.txt:36 en/git-stash.txt:158 en/git-status.txt:25 en/git-stripspace.txt:37 en/git-submodule.txt:275 en/git-svn.txt:575 en/git-switch.txt:35 en/git-symbolic-ref.txt:33 en/git-tag.txt:59 en/git.txt:40 en/git-unpack-file.txt:22 en/git-unpack-objects.txt:29 en/git-update-index.txt:43 en/git-update-server-info.txt:23 en/git-upload-archive.txt:56 en/git-upload-pack.txt:26 en/git-var.txt:20 en/git-verify-commit.txt:18 en/git-verify-pack.txt:22 en/git-verify-tag.txt:18 en/git-web--browse.txt:43 en/git-worktree.txt:170 en/git-write-tree.txt:29
#, no-wrap, priority:300
msgid "OPTIONS"
msgstr "选项"

#. type: Labeled list
#: en/git-add.txt:53 en/git-checkout.txt:372 en/git-commit.txt:401 en/git-grep.txt:307 en/git-reset.txt:131 en/git-restore.txt:148 en/git-rm.txt:33 en/git-stash.txt:250 en/git-status.txt:152
#, ignore-ellipsis, no-wrap, priority:300
msgid "<pathspec>..."
msgstr "<路径规范>..."

#. type: Plain text
#: en/git-add.txt:65
#, placeholders:'`--no-all`', priority:300
msgid "Files to add content from. Fileglobs (e.g. `*.c`) can be given to add all matching files. Also a leading directory name (e.g. `dir` to add `dir/file1` and `dir/file2`) can be given to update the index to match the current state of the directory as a whole (e.g. specifying `dir` will record not just a file `dir/file1` modified in the working tree, a file `dir/file2` added to the working tree, but also a file `dir/file3` removed from the working tree). Note that older versions of Git used to ignore removed files; use `--no-all` option if you want to add modified or new files but ignore removed ones."
msgstr "要从中添加内容的文件。可以使用文件通配符（例如 `*.c`）来添加所有匹配的文件。此外，还可以提供一个前导目录名（例如，指定 `dir` 以添加 `dir/file1` 和 `dir/file2`）来更新索引，使其与整个目录的当前状态相匹配（例如，指定 `dir` 不仅会记录在工作树中修改的文件 `dir/file1`，还会记录在工作树中添加的文件 `dir/file2`，还有从工作树中删除的文件 `dir/file3`）。请注意，旧版本的 Git 会忽略已删除的文件；如果要添加已修改的文件或新文件，但忽略已删除的文件，请使用 `--no-all` 选项。"

#. type: Plain text
#: en/git-add.txt:68 en/git-grep.txt:313
#, placeholders:'linkgit:gitglossary[7]', priority:300
msgid "For more details about the <pathspec> syntax, see the 'pathspec' entry in linkgit:gitglossary[7]."
msgstr "有关 <指定路径> 格式的更多细节，请参考 linkgit:gitglossary[7]。"

#. type: Plain text
#: en/git-add.txt:73
#, priority:300
msgid "Don't actually add the file(s), just show if they exist and/or will be ignored."
msgstr "实际上不添加文件，仅展示文件是否存在或是否忽略。"

#. type: Plain text
#: en/git-add.txt:81
#, priority:300
msgid "Allow adding otherwise ignored files."
msgstr "允许添加已被忽略的文件。"

#. type: Labeled list
#: en/git-add.txt:82 en/git-clone.txt:174 en/git-ls-files.txt:215 en/git-rm.txt:75 en/git-show-branch.txt:67 en/rev-list-options.txt:402 en/rev-list-options.txt:537
#, ignore-same, no-wrap, priority:300
msgid "--sparse"
msgstr "--sparse"

#. type: Plain text
#: en/git-add.txt:88
#, placeholders:'linkgit:git-sparse-checkout[1]', priority:300
msgid "Allow updating index entries outside of the sparse-checkout cone. Normally, `git add` refuses to update index entries whose paths do not fit within the sparse-checkout cone, since those files might be removed from the working tree without warning. See linkgit:git-sparse-checkout[1] for more details."
msgstr "允许更新稀疏检出 cone 之外的索引条目。 通常，`git add` 拒绝更新其路径不适合稀疏检出 cone 的索引条目，因为这些文件可能会在没有警告的情况下从工作区中删除。有关更多详细信息，请参阅链接 linkgit:git-sparse-checkout[1]。"

#. type: Labeled list
#: en/git-add.txt:89 en/git-am.txt:139 en/git-branch.txt:155 en/git-clean.txt:44 en/git-commit.txt:301 en/git-cvsimport.txt:88 en/git-grep.txt:82 en/git-help.txt:91 en/git-ls-files.txt:57 en/git-read-tree.txt:49 en/git-rebase.txt:518 en/git-repack.txt:218 en/git-tag.txt:130 en/rev-list-options.txt:78
#, ignore-same, no-wrap, priority:300
msgid "-i"
msgstr "-i"

#. type: Labeled list
#: en/git-add.txt:90 en/git-am.txt:140 en/git-clean.txt:45 en/git-rebase.txt:519 en/git-rebase.txt:668 en/git-svn.txt:297
#, ignore-same, no-wrap, priority:300
msgid "--interactive"
msgstr "--interactive"

#. type: Plain text
#: en/git-add.txt:95
#, priority:300
msgid "Add modified contents in the working tree interactively to the index. Optional path arguments may be supplied to limit operation to a subset of the working tree. See ``Interactive mode'' for details."
msgstr "以交互方式将工作目录树中的修改内容添加到索引。可以提供可选的路径参数，以将操作限制为工作目录树的子集。有关详细信息，请参见 ''交互模式''。"

#. type: Plain text
#: en/git-add.txt:102
#, priority:300
msgid "Interactively choose hunks of patch between the index and the work tree and add them to the index. This gives the user a chance to review the difference before adding modified contents to the index."
msgstr "交互地在索引和工作目录之间选择补丁块并将它们添加到索引中。这让用户有机会在将修改后的内容添加到索引之前查看差异。"

#. type: Plain text
#: en/git-add.txt:106
#, placeholders:'--interactive`', priority:300
msgid "This effectively runs `add --interactive`, but bypasses the initial command menu and directly jumps to the `patch` subcommand. See ``Interactive mode'' for details."
msgstr "参见这可以有效地运行 `add --interactive`，但是会绕过初始命令菜单，而直接跳转到 `patch` 子命令。有关详细信息，请参见 ''交互模式''。"

#. type: Labeled list
#: en/git-add.txt:107 en/git-blame.txt:78 en/git-cat-file.txt:50 en/git-cherry-pick.txt:53 en/git-commit.txt:260 en/git-config.txt:275 en/git-grep.txt:274 en/git-revert.txt:44 en/git-shortlog.txt:38 en/git-svn.txt:614 en/git-tag.txt:181 en/merge-options.txt:19
#, ignore-same, no-wrap, priority:300
msgid "-e"
msgstr "-e"

#. type: Labeled list
#: en/git-add.txt:108 en/git-cherry-pick.txt:54 en/git-commit.txt:261 en/git-config.txt:276 en/git-revert.txt:45 en/git-svn.txt:615 en/git-tag.txt:182 en/merge-options.txt:18
#, ignore-same, no-wrap, priority:300
msgid "--edit"
msgstr "--edit"

#. type: Plain text
#: en/git-add.txt:112
#, priority:300
msgid "Open the diff vs. the index in an editor and let the user edit it. After the editor was closed, adjust the hunk headers and apply the patch to the index."
msgstr "在编辑器中打开与索引的差异，使用户进行编辑。关闭编辑器后，调整块补丁头并将其应用于索引。"

#. type: Plain text
#: en/git-add.txt:118
#, priority:300
msgid "The intent of this option is to pick and choose lines of the patch to apply, or even to modify the contents of lines to be staged. This can be quicker and more flexible than using the interactive hunk selector. However, it is easy to confuse oneself and create a patch that does not apply to the index. See EDITING PATCHES below."
msgstr "此选项的目的是选择并选择要应用的补丁的行，甚至修改要暂存的行的内容。与使用交互式补丁块选择器相比，其更快，更灵活。但是，很容易混淆自己并创建不应用于索引的补丁。请参阅下面的编辑补丁。"

#. type: Labeled list
#: en/git-add.txt:120
#, ignore-same, no-wrap, priority:300
msgid "--update"
msgstr "--update"

#. type: Plain text
#: en/git-add.txt:124
#, priority:300
msgid "Update the index just where it already has an entry matching <pathspec>. This removes as well as modifies index entries to match the working tree, but adds no new files."
msgstr "在索引已经有与 <路径规范> 匹配项的地方更新索引。这会删除和修改索引项以匹配工作目录树，但不添加新文件。"

#. type: Plain text
#: en/git-add.txt:129
#, placeholders:'`-u`', priority:300
msgid "If no <pathspec> is given when `-u` option is used, all tracked files in the entire working tree are updated (old versions of Git used to limit the update to the current directory and its subdirectories)."
msgstr "如果在使用 `-u` 选项时没有 <路径规范>，则整个工作目录树中的所有跟踪文件都将更新（旧版本 Git 会限制更新当前目录及其子目录）。"

#. type: Labeled list
#: en/git-add.txt:130 en/git-repack.txt:49 en/git-svn.txt:418
#, ignore-same, no-wrap, priority:300
msgid "-A"
msgstr "-A"

#. type: Labeled list
#: en/git-add.txt:131 en/git-branch.txt:177 en/git-checkout-index.txt:40 en/git-commit.txt:68 en/git-describe.txt:50 en/git-fetch-pack.txt:35 en/git-help.txt:50 en/git-http-push.txt:25 en/git-merge-base.txt:72 en/git-name-rev.txt:42 en/git-pack-objects.txt:78 en/git-pack-redundant.txt:46 en/git-pack-refs.txt:48 en/git-push.txt:149 en/git-reflog.txt:69 en/git-rev-parse.txt:165 en/git-send-pack.txt:38 en/git-show-branch.txt:48 en/git-stash.txt:160 en/git-submodule.txt:287 en/rev-list-options.txt:159
#, ignore-same, no-wrap, priority:300
msgid "--all"
msgstr "--all"

#. type: Labeled list
#: en/git-add.txt:132
#, ignore-same, no-wrap, priority:300
msgid "--no-ignore-removal"
msgstr "--no-ignore-removal"

#. type: Plain text
#: en/git-add.txt:137
#, priority:300
msgid "Update the index not only where the working tree has a file matching <pathspec> but also where the index already has an entry. This adds, modifies, and removes index entries to match the working tree."
msgstr "不仅在工作树中有与 <路径规范> 匹配的文件的地方更新索引，而且在索引中已经有一个项的地方更新索引。这将添加、修改和删除与工作目录树匹配的索引项。"

#. type: Plain text
#: en/git-add.txt:142
#, placeholders:'`-A`', priority:300
msgid "If no <pathspec> is given when `-A` option is used, all files in the entire working tree are updated (old versions of Git used to limit the update to the current directory and its subdirectories)."
msgstr "如果在使用 `-A` 选项时没有提供 <路径规范>，则整个工作目录树中的所有文件都将更新（旧版本的 Git 会限制当前目录及其子目录的更新）。"

#. type: Labeled list
#: en/git-add.txt:143
#, ignore-same, no-wrap, priority:300
msgid "--no-all"
msgstr "--no-all"

#. type: Labeled list
#: en/git-add.txt:144
#, ignore-same, no-wrap, priority:300
msgid "--ignore-removal"
msgstr "--ignore-removal"

#. type: Plain text
#: en/git-add.txt:149
#, priority:300
msgid "Update the index by adding new files that are unknown to the index and files modified in the working tree, but ignore files that have been removed from the working tree. This option is a no-op when no <pathspec> is used."
msgstr "通过添加索引未知的新文件和在工作树中修改的文件以更新索引，但忽略已从工作树中删除的文件。当不使用 <路径规范> 时，此选项是必须的。"

# ERROR: --no-all not found in translation
#. type: Plain text
#: en/git-add.txt:153
#, ignore-ellipsis, placeholders:'--no-all', priority:300
msgid "This option is primarily to help users who are used to older versions of Git, whose \"git add <pathspec>...\" was a synonym for \"git add --no-all <pathspec>...\", i.e. ignored removed files."
msgstr "此选项主要用于帮助那些习惯于较旧版本 Git 的用户。旧版本中的 \"Git add <路径规范>...\" 是 \"Git add --no-all <路径规范>...\" 的同义词，即忽略已删除的文件。"

#. type: Labeled list
#: en/git-add.txt:154 en/git-format-patch.txt:122 en/git-submodule.txt:362
#, ignore-same, no-wrap, priority:300
msgid "-N"
msgstr "-N"

#. type: Labeled list
#: en/git-add.txt:155 en/git-apply.txt:77
#, ignore-same, no-wrap, priority:300
msgid "--intent-to-add"
msgstr "--intent-to-add"

#. type: Plain text
#: en/git-add.txt:161
#, priority:300
msgid "Record only the fact that the path will be added later. An entry for the path is placed in the index with no content. This is useful for, among other things, showing the unstaged content of such files with `git diff` and committing them with `git commit -a`."
msgstr "只记录稍后将添加路径的事实。路径的项会被放置在索引中，但不包括改动的内容。这对于使用 `git diff` 显示文件的未暂存内容以及使 `git commit -a` 提交这些文件非常有用。"

#. type: Labeled list
#: en/git-add.txt:162 en/git-reset.txt:111 en/git-update-index.txt:54
#, ignore-same, no-wrap, priority:300
msgid "--refresh"
msgstr "--refresh"

#. type: Plain text
#: en/git-add.txt:165
#, priority:300
msgid "Don't add the file(s), but only refresh their stat() information in the index."
msgstr "不添加文件，只刷新索引中的 stat() 信息。"

#. type: Labeled list
#: en/git-add.txt:166
#, ignore-same, no-wrap, priority:300
msgid "--ignore-errors"
msgstr "--ignore-errors"

#. type: Plain text
#: en/git-add.txt:172
#, placeholders:'add.ignoreErrors', priority:300
msgid "If some files could not be added because of errors indexing them, do not abort the operation, but continue adding the others. The command shall still exit with non-zero status. The configuration variable `add.ignoreErrors` can be set to true to make this the default behaviour."
msgstr "如果由于索引错误而无法添加某些文件，请不要中止操作，而是继续添加其他文件。命令仍应以非零状态退出。可以将配置变量 `add.ignoreErrors` 设置为 true，使其成为默认行为。"

#. type: Labeled list
#: en/git-add.txt:173 en/git-notes.txt:193 en/git-update-index.txt:72 en/rev-list-options.txt:230
#, ignore-same, no-wrap, priority:300
msgid "--ignore-missing"
msgstr "--ignore-missing"

#. type: Plain text
#: en/git-add.txt:178
#, placeholders:'--dry-run', priority:300
msgid "This option can only be used together with --dry-run. By using this option the user can check if any of the given files would be ignored, no matter if they are already present in the work tree or not."
msgstr "此选项只能与 --dry-run 一起使用。通过使用此选项，用户可以检查是否会忽略任何给定的文件，无论它们是否已存在于工作树中。"

#. type: Labeled list
#: en/git-add.txt:179
#, ignore-same, no-wrap, priority:300
msgid "--no-warn-embedded-repo"
msgstr "--no-warn-embedded-repo"

#. type: Plain text
#: en/git-add.txt:185
#, priority:300
msgid "By default, `git add` will warn when adding an embedded repository to the index without using `git submodule add` to create an entry in `.gitmodules`. This option will suppress the warning (e.g., if you are manually performing operations on submodules)."
msgstr "默认情况下， `git add` 将在向索引添加嵌入式存储库时发出警告，而不使用 `git submodule add` 在 `.gitmodules` 中创建条目。此选项将抑制警告（例如，如果手动对子模块执行操作）。"

#. type: Labeled list
#: en/git-add.txt:186
#, ignore-same, no-wrap, priority:300
msgid "--renormalize"
msgstr "--renormalize"

#. type: Plain text
#: en/git-add.txt:194
#, placeholders:'core.autocrlf':'`-u`', priority:300
msgid "Apply the \"clean\" process freshly to all tracked files to forcibly add them again to the index. This is useful after changing `core.autocrlf` configuration or the `text` attribute in order to correct files added with wrong CRLF/LF line endings. This option implies `-u`. Lone CR characters are untouched, thus while a CRLF cleans to LF, a CRCRLF sequence is only partially cleaned to CRLF."
msgstr "对所有跟踪文件重新应用 “清除” 程序，将它们强制添加到索引中。 这在更改 `core.autocrlf` 配置或 `text` 属性后非常有用，可以纠正添加文件时错误的 CRLF/LF 行尾。 该选项意味着 `-u` 。由于 CRLF 字符不会被清除，因此 CRLF 会被清除为 LF，而 CRCRLF 序列只会被部分清除为 CRLF。"

#. type: Labeled list
#: en/git-add.txt:195 en/git-update-index.txt:85
#, ignore-same, no-wrap, priority:300
msgid "--chmod=(+|-)x"
msgstr "--chmod=(+|-)x"

#. type: Plain text
#: en/git-add.txt:199
#, priority:300
msgid "Override the executable bit of the added files. The executable bit is only changed in the index, the files on disk are left unchanged."
msgstr "重写添加文件的可执行位。可执行位仅在索引中更改，磁盘上的文件保持不变。"

#. type: Labeled list
#: en/git-add.txt:200 en/git-checkout.txt:322 en/git-commit.txt:322 en/git-reset.txt:115 en/git-restore.txt:132 en/git-rm.txt:86 en/git-stash.txt:221
#, no-wrap, placeholders:'--pathspec-from-file=', priority:300
msgid "--pathspec-from-file=<file>"
msgstr "--pathspec-from-file=<file>"

#. type: Plain text
#: en/git-add.txt:207 en/git-checkout.txt:329 en/git-commit.txt:329 en/git-reset.txt:122 en/git-restore.txt:139 en/git-rm.txt:93 en/git-stash.txt:230
#, placeholders:'core.quotePath':'linkgit:git-config[1]':'`--pathspec-file-nul`':'`--literal-pathspecs`', priority:300
msgid "Pathspec is passed in `<file>` instead of commandline args. If `<file>` is exactly `-` then standard input is used. Pathspec elements are separated by LF or CR/LF. Pathspec elements can be quoted as explained for the configuration variable `core.quotePath` (see linkgit:git-config[1]). See also `--pathspec-file-nul` and global `--literal-pathspecs`."
msgstr "Pathspec 在 `<文件>` 中传递，而不是在命令行参数中传递。如果 `<文件>` 正好是 `-`，则使用标准输入。路径规范元素由 LF 或 CR/LF 分隔。可以引用配置变量 `core.quotePath` 的路径规范元素（请参见 linkgit:git-config[1]）。另请参见 `--pathspec-file-nul` 和全局 `--literal-pathspecs`。"

#. type: Labeled list
#: en/git-add.txt:208 en/git-checkout.txt:330 en/git-commit.txt:330 en/git-reset.txt:123 en/git-restore.txt:140 en/git-rm.txt:94 en/git-stash.txt:231
#, ignore-same, no-wrap, priority:300
msgid "--pathspec-file-nul"
msgstr "--pathspec-file-nul"

#. type: Plain text
#: en/git-add.txt:212 en/git-checkout.txt:334 en/git-commit.txt:334 en/git-reset.txt:127 en/git-restore.txt:144 en/git-rm.txt:98 en/git-stash.txt:237
#, placeholders:'`--pathspec-from-file`', priority:300
msgid "Only meaningful with `--pathspec-from-file`. Pathspec elements are separated with NUL character and all other characters are taken literally (including newlines and quotes)."
msgstr "只有在使用 `--pathspec-from-file` 选项时才有意义。指定路径元素用 NUL 字符分隔，所有其他字符都按字面意思（包括换行符和引号）表示。"

#. type: Labeled list
#: en/git-add.txt:213 en/git-check-attr.txt:44 en/git-checkout-index.txt:77 en/git-checkout.txt:369 en/git-commit.txt:398 en/git-grep.txt:303 en/git-ls-files.txt:227 en/git-merge-index.txt:23 en/git-prune.txt:51 en/git-reset.txt:128 en/git-restore.txt:145 en/git-rm.txt:62 en/git-stash.txt:245 en/git-update-index.txt:232 en/git-verify-pack.txt:36
#, no-wrap, priority:300
msgid "\\--"
msgstr "\\--"

#. type: Plain text
#: en/git-add.txt:217 en/git-rm.txt:66
#, priority:300
msgid "This option can be used to separate command-line options from the list of files, (useful when filenames might be mistaken for command-line options)."
msgstr "此选项可用于分离命令行选项和文件列表（当文件名可能被误认为命令行选项时非常有用）。"

#. type: Plain text
#: en/git-add.txt:224
#, priority:300
msgid "Adds content from all `*.txt` files under `Documentation` directory and its subdirectories:"
msgstr "添加 `Documentation` 目录及其子目录下所有 `*.txt` 文件的内容："

#. type: delimited block -
#: en/git-add.txt:227
#, no-wrap, priority:300
msgid "$ git add Documentation/\\*.txt\n"
msgstr "$ git add Documentation/\\*.txt\n"

#. type: Plain text
#: en/git-add.txt:232
#, priority:300
msgid "Note that the asterisk `*` is quoted from the shell in this example; this lets the command include the files from subdirectories of `Documentation/` directory."
msgstr "注意，在本例中，星号 `*` 是从 shell 中引入的；这使得该命令可以包含 `Documentation/` 的子目录中的文件。"

#. type: Plain text
#: en/git-add.txt:234
#, priority:300
msgid "Considers adding content from all git-*.sh scripts:"
msgstr "从所有 git-*.sh 脚本中添加内容："

#. type: delimited block -
#: en/git-add.txt:237
#, no-wrap, priority:300
msgid "$ git add git-*.sh\n"
msgstr "$ git add git-*.sh\n"

#. type: Plain text
#: en/git-add.txt:242
#, priority:300
msgid "Because this example lets the shell expand the asterisk (i.e. you are listing the files explicitly), it does not consider `subdir/git-foo.sh`."
msgstr "因为这个示例允许 shell 扩展星号（即显式列出文件），所以它不包含 `subdir/git-foo.sh`。"

#. type: Title -
#: en/git-add.txt:244 en/git-rebase.txt:837
#, no-wrap, priority:300
msgid "INTERACTIVE MODE"
msgstr "交互模式"

#. type: Plain text
#: en/git-add.txt:248
#, priority:300
msgid "When the command enters the interactive mode, it shows the output of the 'status' subcommand, and then goes into its interactive command loop."
msgstr "当命令进入交互模式时，它将显示 `status` 子命令的输出，然后进入其交互命令循环。"

#. type: Plain text
#: en/git-add.txt:253 en/git-clean.txt:85
#, priority:300
msgid "The command loop shows the list of subcommands available, and gives a prompt \"What now> \". In general, when the prompt ends with a single '>', you can pick only one of the choices given and type return, like this:"
msgstr "命令循环显示可用的子命令列表，并提示 \"What now>\"。通常，当提示以单个 '>' 结尾时，您只能选择给定的一个选项并键入回车，如下所示："

#. type: delimited block -
#: en/git-add.txt:259
#, no-wrap, priority:300
msgid ""
"    *** Commands ***\n"
"      1: status       2: update       3: revert       4: add untracked\n"
"      5: patch        6: diff         7: quit         8: help\n"
"    What now> 1\n"
msgstr ""
"    *** Commands ***\n"
"      1: status       2: update       3: revert       4: add untracked\n"
"      5: patch        6: diff         7: quit         8: help\n"
"    What now> 1\n"

#. type: Plain text
#: en/git-add.txt:263
#, priority:300
msgid "You also could say `s` or `sta` or `status` above as long as the choice is unique."
msgstr "你也可以输入 `s`、`sta` 或 `status`，只要候选项是唯一的。"

#. type: Plain text
#: en/git-add.txt:265
#, priority:300
msgid "The main command loop has 6 subcommands (plus help and quit)."
msgstr "主命令循环有 6 个子命令（包括帮助和退出）。"

#. type: Labeled list
#: en/git-add.txt:266
#, no-wrap, priority:300
msgid "status"
msgstr "状态"

#. type: Plain text
#: en/git-add.txt:273
#, placeholders:'HEAD', priority:300
msgid "This shows the change between HEAD and index (i.e. what will be committed if you say `git commit`), and between index and working tree files (i.e. what you could stage further before `git commit` using `git add`) for each path. A sample output looks like this:"
msgstr "这将显示每个路径下 HEAD 和索引之间的更改（即，如果输入 `git commit`，将提交什么），以及索引和工作目录树文件之间的更改（即，在输入 `git commit` 之前，执行 `git add` 可以进一步暂存什么）。示例输出如下："

#. type: delimited block -
#: en/git-add.txt:278
#, no-wrap, placeholders:'foo.png', priority:300
msgid ""
"              staged     unstaged path\n"
"     1:       binary      nothing foo.png\n"
"     2:     +403/-35        +1/-1 add-interactive.c\n"
msgstr ""
"              staged     unstaged path\n"
"     1:       binary      nothing foo.png\n"
"     2:     +403/-35        +1/-1 git-add--interactive.perl\n"

#. type: Plain text
#: en/git-add.txt:289
#, placeholders:'foo.png':'HEAD', priority:300
msgid "It shows that foo.png has differences from HEAD (but that is binary so line count cannot be shown) and there is no difference between indexed copy and the working tree version (if the working tree version were also different, 'binary' would have been shown in place of 'nothing'). The other file, add-interactive.c, has 403 lines added and 35 lines deleted if you commit what is in the index, but working tree file has further modifications (one addition and one deletion)."
msgstr "它表明 foo.png 与 HEAD 有区别（但其是二进制的，因此无法显示行数），索引副本和工作目录树版本之间没有区别（如果工作目录树版本也不同，`nothing` 的位置上会显示 `binary` ）。另一个文件 git add-{litdd}interactive.perl 添加了403 行，如果提交索引中的内容，则删除了 35 行，但工作目录树文件有额外修改（一次添加一次删除）。"

#. type: Labeled list
#: en/git-add.txt:290 en/git-update-ref.txt:102
#, ignore-same, no-wrap, priority:300
msgid "update"
msgstr "update"

#. type: Plain text
#: en/git-add.txt:299
#, priority:300
msgid "This shows the status information and issues an \"Update>>\" prompt. When the prompt ends with double '>>', you can make more than one selection, concatenated with whitespace or comma. Also you can say ranges. E.g. \"2-5 7,9\" to choose 2,3,4,5,7,9 from the list. If the second number in a range is omitted, all remaining patches are taken. E.g. \"7-\" to choose 7,8,9 from the list. You can say '*' to choose everything."
msgstr "这将显示状态信息并发出 \"Update>>\" 提示。当提示以 '>>' 结尾时，可以进行多个选择，并用空格或逗号连接。你也可以输入范围。例如：\"2-5 7,9\" 将从列表中选择 2、3、4、5、7、9。如果省略一个范围中的第二个数字，则将获取所有剩余的补丁。例如：\"7-\" 从列表中选择 7、8、9。你可以输入 '*' 来选择全部补丁。"

#. type: Plain text
#: en/git-add.txt:302
#, priority:300
msgid "What you chose are then highlighted with '*', like this:"
msgstr "您选择的内容会用 '*' 突出显示，如下所示："

#. type: delimited block -
#: en/git-add.txt:307
#, no-wrap, placeholders:'foo.png', priority:300
msgid ""
"           staged     unstaged path\n"
"  1:       binary      nothing foo.png\n"
"* 2:     +403/-35        +1/-1 add-interactive.c\n"
msgstr ""
"           staged     unstaged path\n"
"  1:       binary      nothing foo.png\n"
"* 2:     +403/-35        +1/-1 git-add--interactive.perl\n"

#. type: Plain text
#: en/git-add.txt:311
#, priority:300
msgid "To remove selection, prefix the input with `-` like this:"
msgstr "要删除选定内容，请在输入前加上 `-`，如下所示："

#. type: delimited block -
#: en/git-add.txt:314
#, no-wrap, priority:300
msgid "Update>> -2\n"
msgstr "Update>> -2\n"

#. type: Plain text
#: en/git-add.txt:318
#, priority:300
msgid "After making the selection, answer with an empty line to stage the contents of working tree files for selected paths in the index."
msgstr "进行选择后，输入空行，以便为索引中选定的路径暂存工作目录文件的内容。"

#. type: Labeled list
#: en/git-add.txt:319
#, no-wrap, priority:300
msgid "revert"
msgstr "还原"

#. type: Plain text
#: en/git-add.txt:324
#, placeholders:'HEAD', priority:300
msgid "This has a very similar UI to 'update', and the staged information for selected paths are reverted to that of the HEAD version. Reverting new paths makes them untracked."
msgstr "它有一个与 'update' 非常相似的交互过程，所选路径的暂存信息将还原为 HEAD 版本。还原新路径将使它们不被追踪。"

#. type: Labeled list
#: en/git-add.txt:325
#, no-wrap, priority:300
msgid "add untracked"
msgstr "添加未跟踪文件"

#. type: Plain text
#: en/git-add.txt:329
#, priority:300
msgid "This has a very similar UI to 'update' and 'revert', and lets you add untracked paths to the index."
msgstr "它有一个与 'update' 和 'revert' 非常相似的交互过程，允许您向索引添加未跟踪的路径。"

#. type: Labeled list
#: en/git-add.txt:330
#, no-wrap, priority:300
msgid "patch"
msgstr "补丁"

#. type: Plain text
#: en/git-add.txt:337
#, priority:300
msgid "This lets you choose one path out of a 'status' like selection. After choosing the path, it presents the diff between the index and the working tree file and asks you if you want to stage the change of each hunk. You can select one of the following options and type return:"
msgstr "这允许您从类似 'status' 命令的选择中选择一条路径。在选择路径之后，它将显示索引和工作树文件之间的差异，并询问您是否要暂存每个块的更改。您可以选择以下选项之一并输入回车："

#. type: Plain text
#: en/git-add.txt:352
#, no-wrap, priority:300
msgid ""
"y - stage this hunk\n"
"n - do not stage this hunk\n"
"q - quit; do not stage this hunk or any of the remaining ones\n"
"a - stage this hunk and all later hunks in the file\n"
"d - do not stage this hunk or any of the later hunks in the file\n"
"g - select a hunk to go to\n"
"/ - search for a hunk matching the given regex\n"
"j - leave this hunk undecided, see next undecided hunk\n"
"J - leave this hunk undecided, see next hunk\n"
"k - leave this hunk undecided, see previous undecided hunk\n"
"K - leave this hunk undecided, see previous hunk\n"
"s - split the current hunk into smaller hunks\n"
"e - manually edit the current hunk\n"
"? - print help\n"
msgstr ""
"y - 暂存此区块\n"
"n - 不暂存此区块\n"
"q - 退出；不暂存包括此块在内的剩余的区块\n"
"a - 暂存此块与此文件后面所有的区块\n"
"d - 不暂存此块与此文件后面所有的 区块\n"
"g - 选择并跳转至一个区块\n"
"/ - 搜索与给定正则表达示匹配的区块\n"
"j - 暂不决定，转至下一个未决定的区块\n"
"J - 暂不决定，转至下一个区块\n"
"k - 暂不决定，转至上一个未决定的区块\n"
"K - 暂不决定，转至上一个区块\n"
"s - 将当前的区块分割成多个较小的区块\n"
"e - 手动编辑当前的区块\n"
"? - 输出帮助\n"

#. type: Plain text
#: en/git-add.txt:355
#, priority:300
msgid "After deciding the fate for all hunks, if there is any hunk that was chosen, the index is updated with the selected hunks."
msgstr "在决定了所有块的操作后，如果有选择的区块，则会使用其来更新索引。"

#. type: Plain text
#: en/git-add.txt:358
#, placeholders:'interactive.singleKey', priority:300
msgid "You can omit having to type return here, by setting the configuration variable `interactive.singleKey` to `true`."
msgstr "通过将配置变量 `interactive.singleKey` 设置为 `true`，在此处可以不必键入回车。"

#. type: Labeled list
#: en/git-add.txt:359
#, ignore-same, no-wrap, priority:300
msgid "diff"
msgstr "diff"

#. type: Plain text
#: en/git-add.txt:363
#, placeholders:'HEAD', priority:300
msgid "This lets you review what will be committed (i.e. between HEAD and index)."
msgstr "这使您可以查看要提交的内容（即，在 HEAD 和索引之间）。"

#. type: Title -
#: en/git-add.txt:366
#, no-wrap, priority:300
msgid "EDITING PATCHES"
msgstr "编辑补丁"

#. type: Plain text
#: en/git-add.txt:376
#, priority:300
msgid "Invoking `git add -e` or selecting `e` from the interactive hunk selector will open a patch in your editor; after the editor exits, the result is applied to the index. You are free to make arbitrary changes to the patch, but note that some changes may have confusing results, or even result in a patch that cannot be applied. If you want to abort the operation entirely (i.e., stage nothing new in the index), simply delete all lines of the patch. The list below describes some common things you may see in a patch, and which editing operations make sense on them."
msgstr "调用 `git add -e` 或从交互式块选择器中选择 `e` 命令，将在编辑器中打开一个补丁。编辑器退出后，结果将应用于索引。您可以随意对补丁进行任何更改，但是请注意，某些更改可能会导致混乱，甚至导致补丁无法使用。如果您想完全中止该操作（即不在索引中更新内容），只需删除补丁中的所有行。下面的列表描述了您可能会在补丁中看到的一些常见内容，以及对其进行哪些编辑操作才有意义。"

#. type: Labeled list
#: en/git-add.txt:378
#, no-wrap, priority:300
msgid "added content"
msgstr "添加的内容"

#. type: Plain text
#: en/git-add.txt:382
#, placeholders:'{plus}', priority:300
msgid "Added content is represented by lines beginning with \"{plus}\". You can prevent staging any addition lines by deleting them."
msgstr "添加的内容以 \"{plus}\" 开头的行表示。您可以删除它们以防止暂存。"

#. type: Labeled list
#: en/git-add.txt:383
#, no-wrap, priority:300
msgid "removed content"
msgstr "删除的内容"

#. type: Plain text
#: en/git-add.txt:387
#, priority:300
msgid "Removed content is represented by lines beginning with \"-\". You can prevent staging their removal by converting the \"-\" to a \" \" (space)."
msgstr "删除的内容以 \"-\" 开头的行表示。您可以通过将 \"-\" 转换为 \" \"（空格）来防止将其删除。"

# 译者：末尾两个字节可能被删减，如果翻译为中文标点会出现半个汉字
#. type: Labeled list
#: en/git-add.txt:388
#, no-wrap, priority:300
msgid "modified content"
msgstr "修改的内容"

#. type: Plain text
#: en/git-add.txt:395
#, placeholders:'{plus}':'{plus}', priority:300
msgid "Modified content is represented by \"-\" lines (removing the old content) followed by \"{plus}\" lines (adding the replacement content). You can prevent staging the modification by converting \"-\" lines to \" \", and removing \"{plus}\" lines. Beware that modifying only half of the pair is likely to introduce confusing changes to the index."
msgstr "修改后的内容由 \"-\" 行（删除旧内容）和 \"{plus}\" 行（添加替换内容）表示。通过将 \"-\" 行转换为 \" \"，并删除 \"{plus}\" 行，可以防止临时进行修改。请注意，只修改其中一个可能会给索引带来混乱的更改。"

#. type: Plain text
#: en/git-add.txt:403
#, placeholders:'HEAD', priority:300
msgid "There are also more complex operations that can be performed. But beware that because the patch is applied only to the index and not the working tree, the working tree will appear to \"undo\" the change in the index. For example, introducing a new line into the index that is in neither the HEAD nor the working tree will stage the new line for commit, but the line will appear to be reverted in the working tree."
msgstr "还可以执行更复杂的操作。但是请注意，由于补丁仅应用于索引而不是工作目录树，因此工作树似乎会 \"撤消\" 索引中的更改。例如，在索引中添加一行，而该行不在 HEAD 或工作目录树。此时会暂存其以进行提交，但是该行似乎在会在工作目录树中进行还原。"

#. type: Plain text
#: en/git-add.txt:405
#, priority:300
msgid "Avoid using these constructs, or do so with extreme caution."
msgstr "避免使用这些构造，除非格外小心。"

#. type: Labeled list
#: en/git-add.txt:407
#, no-wrap, priority:300
msgid "removing untouched content"
msgstr "删除未改动的内容"

#. type: Plain text
#: en/git-add.txt:413
#, priority:300
msgid "Content which does not differ between the index and working tree may be shown on context lines, beginning with a \" \" (space). You can stage context lines for removal by converting the space to a \"-\". The resulting working tree file will appear to re-add the content."
msgstr "索引和工作树之间没有区别的内容可能会显示在上下文行中，以 \" \"（空格）开头。您可以通过将空格转换为 \"-\" 来暂存要删除的上下文行。生成的工作目录树文件将重新添加内容。"

#. type: Labeled list
#: en/git-add.txt:414
#, no-wrap, priority:300
msgid "modifying existing content"
msgstr "修改现有的内容"

#. type: Plain text
#: en/git-add.txt:421
#, placeholders:'{plus}':'{plus}', priority:300
msgid "One can also modify context lines by staging them for removal (by converting \" \" to \"-\") and adding a \"{plus}\" line with the new content. Similarly, one can modify \"{plus}\" lines for existing additions or modifications. In all cases, the new modification will appear reverted in the working tree."
msgstr "也可以通过暂存上下文行（通过将 \" \" 转换为 \"-\"）以进行删除来修改上下文行，并在其中添加新内容的 \"{plus}\" 行。类似地，可以修改 \"{plus}\" 行以进行现有内容的添加或修改。在所有情况下，新的修改都将在工作目录树中还原。"

#. type: Labeled list
#: en/git-add.txt:422
#, no-wrap, priority:300
msgid "new content"
msgstr "新的内容"

#. type: Plain text
#: en/git-add.txt:427
#, placeholders:'{plus}', priority:300
msgid "You may also add new content that does not exist in the patch; simply add new lines, each starting with \"{plus}\". The addition will appear reverted in the working tree."
msgstr "您还可以添加补丁中不存在的新内容。只需添加新行，每行以 \"{plus}\" 开头。添加的内容将还原到工作目录树中。"

#. type: Plain text
#: en/git-add.txt:431
#, priority:300
msgid "There are also several operations which should be avoided entirely, as they will make the patch impossible to apply:"
msgstr "还有一些操作应完全避免，因为它们会使补丁无法应用："

#. type: Plain text
#: en/git-add.txt:433
#, priority:300
msgid "adding context (\" \") or removal (\"-\") lines"
msgstr "添加上下文（\" \"）行或添加删除（\"-\"）行"

#. type: Plain text
#: en/git-add.txt:434
#, priority:300
msgid "deleting context or removal lines"
msgstr "删除上下文行或删除标记为删除的行"

#. type: Plain text
#: en/git-add.txt:435
#, priority:300
msgid "modifying the contents of context or removal lines"
msgstr "修改上下文或删除行的内容"

#. type: Plain text
#: en/git-add.txt:451
#, ignore-same, priority:300
msgid "linkgit:git-status[1] linkgit:git-rm[1] linkgit:git-reset[1] linkgit:git-mv[1] linkgit:git-commit[1] linkgit:git-update-index[1]"
msgstr "linkgit:git-status[1] linkgit:git-rm[1] linkgit:git-reset[1] linkgit:git-mv[1] linkgit:git-commit[1] linkgit:git-update-index[1]"

#. type: Title =
#: en/git-am.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-am(1)"
msgstr "git-am(1)"

#. type: Plain text
#: en/git-am.txt:7
#, placeholders:'git-am', priority:100
msgid "git-am - Apply a series of patches from a mailbox"
msgstr "git-am - 从邮箱应用一系列修补程序"

#. type: Plain text
#: en/git-am.txt:22
#, ignore-ellipsis, no-wrap, placeholders:'[--signoff]':'[--keep]':'[--no-verify]':'[--interactive]':'[--committer-date-is-author-date]':'[--ignore-date]':'[--ignore-space-change':'--ignore-whitespace]':'[--whitespace=':'[--directory=':'[--exclude=':'[--include=':'[--reject]':'--quiet]':'[--patch-format=':'[--quoted-cr=':'[--empty=(stop|drop|keep)]':'--continue':'--skip':'--abort':'--quit':'--show-current-patch[=(diff|raw)]':'--allow-empty', priority:100
msgid ""
"'git am' [--signoff] [--keep] [--[no-]keep-cr] [--[no-]utf8] [--no-verify]\n"
"\t [--[no-]3way] [--interactive] [--committer-date-is-author-date]\n"
"\t [--ignore-date] [--ignore-space-change | --ignore-whitespace]\n"
"\t [--whitespace=<action>] [-C<n>] [-p<n>] [--directory=<dir>]\n"
"\t [--exclude=<path>] [--include=<path>] [--reject] [-q | --quiet]\n"
"\t [--[no-]scissors] [-S[<keyid>]] [--patch-format=<format>]\n"
"\t [--quoted-cr=<action>]\n"
"\t [--empty=(stop|drop|keep)]\n"
"\t [(<mbox> | <Maildir>)...]\n"
"'git am' (--continue | --skip | --abort | --quit | --show-current-patch[=(diff|raw)] | --allow-empty)\n"
msgstr ""
"'git am' [--signoff] [--keep] [--[no-]keep-cr] [--[no-]utf8] [--no-verify]\n"
"\t [--[no-]3way] [--interactive] [--committer-date-is-author-date]\n"
"\t [--ignore-date] [--ignore-space-change | --ignore-whitespace]\n"
"\t [--whitespace=<选项>] [-C<n>] [-p<n>] [--directory=<目录>]\n"
"\t [--exclude=<路径>] [--include=<路径>] [--reject] [-q | --quiet]\n"
"\t [--[no-]scissors] [-S[<键 ID>]] [--patch-format=<格式>]\n"
"\t [--quoted-cr=<行为>]\n"
"\t [--empty=(stop|drop|keep)]\n"
"\t [(<mbox> | <Maildir>)...]\n"
"'git am' (--continue | --skip | --abort | --quit | --show-current-patch[=(diff|raw)] | --allow-empty)\n"

#. type: Plain text
#: en/git-am.txt:30
#, placeholders:'linkgit:git-format-patch[1]', priority:100
msgid "Splits mail messages in a mailbox into commit log messages, authorship information, and patches, and applies them to the current branch. You could think of it as a reverse operation of linkgit:git-format-patch[1] run on a branch with a straight history without merges."
msgstr "将邮箱中的邮件信息拆分为提交日志信息、作者信息和补丁，并将其应用到当前分支。你可以把它看作是 linkgit:git-format-patch[1] 的反向操作，在一个没有合并历史的分支上运行。"

#. type: Labeled list
#: en/git-am.txt:33
#, ignore-ellipsis, no-wrap, priority:100
msgid "(<mbox>|<Maildir>)..."
msgstr "(<mbox>|<Maildir>)..."

#. type: Plain text
#: en/git-am.txt:37
#, priority:100
msgid "The list of mailbox files to read patches from. If you do not supply this argument, the command reads from the standard input. If you supply directories, they will be treated as Maildirs."
msgstr "要读取补丁的邮箱文件的列表。如果你不提供这个参数，命令将从标准输入中读取。 如果你提供目录，它们将被视为邮箱目录。"

#. type: Labeled list
#: en/git-am.txt:39 en/git-cherry-pick.txt:106 en/git-format-patch.txt:139 en/git-rebase.txt:511 en/git-revert.txt:101 en/signoff-option.txt:4
#, ignore-same, no-wrap, priority:280
msgid "--signoff"
msgstr "--signoff"

#. type: Plain text
#: en/git-am.txt:43 en/git-format-patch.txt:143
#, placeholders:'linkgit:git-commit[1]', priority:100
msgid "Add a `Signed-off-by` trailer to the commit message, using the committer identity of yourself. See the signoff option in linkgit:git-commit[1] for more information."
msgstr "在提交信息中加入 `Signed-off-by` 的尾注，使用自己的提交者身份。 更多信息见 linkgit:git-commit[1] 中的 signoff 选项。"

#. type: Plain text
#: en/git-am.txt:47
#, placeholders:'`-k`':'linkgit:git-mailinfo[1]', priority:100
msgid "Pass `-k` flag to 'git mailinfo' (see linkgit:git-mailinfo[1])."
msgstr "传递`-k` 标志给 'git mailinfo'（见linkgit:git-mailinfo[1]）。"

#. type: Labeled list
#: en/git-am.txt:48 en/git-quiltimport.txt:59
#, ignore-same, no-wrap, priority:100
msgid "--keep-non-patch"
msgstr "--keep-non-patch"

#. type: Plain text
#: en/git-am.txt:50 en/git-quiltimport.txt:61
#, placeholders:'`-b`':'linkgit:git-mailinfo[1]', priority:100
msgid "Pass `-b` flag to 'git mailinfo' (see linkgit:git-mailinfo[1])."
msgstr "将 `-b` 标志传递给 'git mailinfo'（见linkgit:git-mailinfo[1]）。"

#. type: Labeled list
#: en/git-am.txt:51
#, ignore-same, no-wrap, priority:100
msgid "--[no-]keep-cr"
msgstr "--[no-]keep-cr"

#. type: Plain text
#: en/git-am.txt:56
#, placeholders:'`--keep-cr`':'linkgit:git-mailsplit[1]':'am.keepcr':'`--no-keep-cr`':'am.keepcr', priority:100
msgid "With `--keep-cr`, call 'git mailsplit' (see linkgit:git-mailsplit[1]) with the same option, to prevent it from stripping CR at the end of lines. `am.keepcr` configuration variable can be used to specify the default behaviour. `--no-keep-cr` is useful to override `am.keepcr`."
msgstr "使用 `--keep-cr`，调用 'git mailsplit'（见linkgit:git-mailsplit[1]），并使用相同的选项，以防止它在行末剥离 CR。`am.keepcr` 配置变量可以用来指定默认行为。 `--no-keep-cr` 可以用来覆盖 `am.keepcr`。"

#. type: Labeled list
#: en/git-am.txt:58 en/git-mailinfo.txt:76
#, ignore-same, no-wrap, priority:100
msgid "--scissors"
msgstr "--scissors"

#. type: Plain text
#: en/git-am.txt:62
#, placeholders:'linkgit:git-mailinfo[1]':'mailinfo.scissors', priority:100
msgid "Remove everything in body before a scissors line (see linkgit:git-mailinfo[1]). Can be activated by default using the `mailinfo.scissors` configuration variable."
msgstr "移除正文中剪切行之前的所有内容（见linkgit:git-mailinfo[1]）。可以使用 `mailinfo.scissors` 配置变量来默认激活。"

#. type: Labeled list
#: en/git-am.txt:63 en/git-mailinfo.txt:91
#, ignore-same, no-wrap, priority:100
msgid "--no-scissors"
msgstr "--no-scissors"

#. type: Plain text
#: en/git-am.txt:65
#, placeholders:'linkgit:git-mailinfo[1]', priority:100
msgid "Ignore scissors lines (see linkgit:git-mailinfo[1])."
msgstr "忽略剪切线（见linkgit:git-mailinfo[1]）。"

# ERROR: --quoted-cr= not found in translation
#. type: Labeled list
#: en/git-am.txt:66 en/git-mailinfo.txt:94
#, no-wrap, placeholders:'--quoted-cr=', priority:100
msgid "--quoted-cr=<action>"
msgstr "--quoted-cr=<行为>"

#. type: Plain text
#: en/git-am.txt:68
#, placeholders:'linkgit:git-mailinfo[1]', priority:100
msgid "This flag will be passed down to 'git mailinfo' (see linkgit:git-mailinfo[1])."
msgstr "这个标志将被传递给 'git mailinfo'（见 linkgit:git-mailinfo[1]）。"

# ERROR: --empty=(stop|drop|keep) not found in translation
#. type: Labeled list
#: en/git-am.txt:69
#, ignore-same, no-wrap, priority:100
msgid "--empty=(stop|drop|keep)"
msgstr "--empty=(stop|drop|keep)"

#. type: Plain text
#: en/git-am.txt:76
#, priority:100
msgid "By default, or when the option is set to 'stop', the command errors out on an input e-mail message lacking a patch and stops in the middle of the current am session. When this option is set to 'drop', skip such an e-mail message instead. When this option is set to 'keep', create an empty commit, recording the contents of the e-mail message as its log."
msgstr "默认情况下，或者当该选项被设置为 'stop' 时，该命令在输入缺乏补丁的电子邮件时出错，并停止到当前 am 会话的中间。当这个选项被设置为 'drop' 时，跳过这样的电子邮件信息。 当这个选项被设置为 'keep' 时，会创建一个空的提交，将电子邮件的内容记录为日志。"

#. type: Labeled list
#: en/git-am.txt:78 en/git-mailinfo.txt:72
#, ignore-same, no-wrap, priority:100
msgid "--message-id"
msgstr "--message-id"

#. type: Plain text
#: en/git-am.txt:83
#, placeholders:'`-m`':'linkgit:git-mailinfo[1]':'am.messageid', priority:100
msgid "Pass the `-m` flag to 'git mailinfo' (see linkgit:git-mailinfo[1]), so that the Message-ID header is added to the commit message. The `am.messageid` configuration variable can be used to specify the default behaviour."
msgstr "传递 `-m` 标志给 'git mailinfo'（见 linkgit:git-mailinfo[1]），这样 Message-ID 头会被添加到提交信息中。 `am.messageid` 配置变量可以用来指定默认行为。"

#. type: Labeled list
#: en/git-am.txt:84
#, ignore-same, no-wrap, priority:100
msgid "--no-message-id"
msgstr "--no-message-id"

#. type: Plain text
#: en/git-am.txt:87
#, placeholders:'am.messageid', priority:100
msgid "Do not add the Message-ID header to the commit message. `no-message-id` is useful to override `am.messageid`."
msgstr "不要在提交信息中添加 Message-ID 头。 `no-message-id` 对于覆盖 `am.messageid` 很有用。"

#. type: Plain text
#: en/git-am.txt:91
#, priority:100
msgid "Be quiet. Only print error messages."
msgstr "保持安静。只打印错误信息。"

#. type: Labeled list
#: en/git-am.txt:93
#, ignore-same, no-wrap, priority:100
msgid "--utf8"
msgstr "--utf8"

#. type: Plain text
#: en/git-am.txt:99
#, placeholders:'`-u`':'linkgit:git-mailinfo[1]', priority:100
msgid "Pass `-u` flag to 'git mailinfo' (see linkgit:git-mailinfo[1]). The proposed commit log message taken from the e-mail is re-coded into UTF-8 encoding (configuration variable `i18n.commitEncoding` can be used to specify the project's preferred encoding if it is not UTF-8)."
msgstr "传递 `-u` 标志给 'git mailinfo'（见linkgit:git-mailinfo[1]）。 建议从邮件中提取的提交日志信息被重新编码为 UTF-8 编码（配置变量 `i18n.commitEncoding` 可以用来指定项目的首选编码，如果它不是 UTF-8）。"

#. type: Plain text
#: en/git-am.txt:102
#, placeholders:'`--no-utf8`', priority:100
msgid "This was optional in prior versions of git, but now it is the default. You can use `--no-utf8` to override this."
msgstr "这在以前的 git 版本中是可选的，但现在它是默认的。 你可以使用 `--no-utf8` 来覆盖它。"

#. type: Labeled list
#: en/git-am.txt:103
#, ignore-same, no-wrap, priority:100
msgid "--no-utf8"
msgstr "--no-utf8"

#. type: Plain text
#: en/git-am.txt:106
#, placeholders:'`-n`':'linkgit:git-mailinfo[1]', priority:100
msgid "Pass `-n` flag to 'git mailinfo' (see linkgit:git-mailinfo[1])."
msgstr "传递 `-n` 标志给 'git mailinfo'（见linkgit:git-mailinfo[1]）。"

#. type: Labeled list
#: en/git-am.txt:107 en/git-apply.txt:85
#, ignore-same, no-wrap, priority:100
msgid "-3"
msgstr "-3"

#. type: Labeled list
#: en/git-am.txt:108 en/git-apply.txt:86
#, ignore-same, no-wrap, priority:100
msgid "--3way"
msgstr "--3way"

#. type: Labeled list
#: en/git-am.txt:109
#, ignore-same, no-wrap, priority:100
msgid "--no-3way"
msgstr "--no-3way"

#. type: Plain text
#: en/git-am.txt:116
#, placeholders:'`--no-3way`':'am.threeWay':'am.threeWay':'linkgit:git-config[1]', priority:100
msgid "When the patch does not apply cleanly, fall back on 3-way merge if the patch records the identity of blobs it is supposed to apply to and we have those blobs available locally. `--no-3way` can be used to override am.threeWay configuration variable. For more information, see am.threeWay in linkgit:git-config[1]."
msgstr "当补丁不能干净地应用时，如果补丁记录了它应该应用到的二进制文件的身份，并且我们有这些二进制文件可以在本地使用，那么就退回到三路合并。`--no-3way` 可以用来覆盖 am.threeWay 配置变量。更多信息，见 linkgit:git-config[1] 中的 am.threeWay。"

#. type: Labeled list
#: en/git-am.txt:120 en/git-apply.txt:184 en/git-rebase.txt:473
#, ignore-same, no-wrap, priority:100
msgid "--ignore-whitespace"
msgstr "--ignore-whitespace"

#. type: Labeled list
#: en/git-am.txt:121 en/git-apply.txt:191
#, no-wrap, placeholders:'--whitespace=', priority:100
msgid "--whitespace=<action>"
msgstr "--whitespace=<行为>"

#. type: Labeled list
#: en/git-am.txt:122 en/git-apply.txt:130 en/git-rebase.txt:430
#, no-wrap, priority:100
msgid "-C<n>"
msgstr "-C<n>"

#. type: Labeled list
#: en/git-am.txt:123 en/git-apply.txt:124
#, no-wrap, priority:100
msgid "-p<n>"
msgstr "-p<n>"

#. type: Labeled list
#: en/git-am.txt:124
#, no-wrap, placeholders:'--directory=', priority:100
msgid "--directory=<dir>"
msgstr "--directory=<目录>"

#. type: Labeled list
#: en/git-am.txt:125
#, no-wrap, placeholders:'--exclude=', priority:100
msgid "--exclude=<path>"
msgstr "--exclude=<路径>"

#. type: Labeled list
#: en/git-am.txt:126
#, no-wrap, placeholders:'--include=', priority:100
msgid "--include=<path>"
msgstr "--include=<路径>"

#. type: Labeled list
#: en/git-am.txt:127 en/git-apply.txt:109
#, ignore-same, no-wrap, priority:100
msgid "--reject"
msgstr "--reject"

#. type: Plain text
#: en/git-am.txt:131
#, placeholders:'linkgit:git-apply[1]', priority:100
msgid "These flags are passed to the 'git apply' (see linkgit:git-apply[1]) program that applies the patch."
msgstr "这些标志会传递给应用补丁的 \"git apply\"（见 linkgit:git-apply[1]）程序。"

#. type: Labeled list
#: en/git-am.txt:132
#, ignore-same, no-wrap, priority:100
msgid "--patch-format"
msgstr "--patch-format"

#. type: Plain text
#: en/git-am.txt:138
#, priority:100
msgid "By default the command will try to detect the patch format automatically. This option allows the user to bypass the automatic detection and specify the patch format that the patch(es) should be interpreted as. Valid formats are mbox, mboxrd, stgit, stgit-series, and hg."
msgstr "默认情况下，该命令将尝试自动检测补丁格式。这个选项允许用户绕过自动检测，并指定补丁的格式，以便将其解释为补丁。有效的格式是 mbox、mboxrd、stgit、stgit-series 和 hg。"

#. type: Plain text
#: en/git-am.txt:142
#, priority:100
msgid "Run interactively."
msgstr "交互式运行。"

#. type: Labeled list
#: en/git-am.txt:144 en/git-rebase.txt:423
#, ignore-same, no-wrap, priority:100
msgid "--no-verify"
msgstr "--no-verify"

#. type: Plain text
#: en/git-am.txt:148
#, placeholders:'`--no-verify`':'`-n`':'linkgit:githooks[5]', priority:100
msgid "By default, the pre-applypatch and applypatch-msg hooks are run. When any of `--no-verify` or `-n` is given, these are bypassed. See also linkgit:githooks[5]."
msgstr "默认情况下，会运行 pre-commit 和 commit-msg 钩子。当给出任何 `--no-verify` 或 `-n` 时，这些都会被绕过。参见链接 linkgit:githooks[5]。"

#. type: Labeled list
#: en/git-am.txt:149 en/git-rebase.txt:498
#, ignore-same, no-wrap, priority:100
msgid "--committer-date-is-author-date"
msgstr "--committer-date-is-author-date"

#. type: Plain text
#: en/git-am.txt:155
#, priority:100
msgid "By default the command records the date from the e-mail message as the commit author date, and uses the time of commit creation as the committer date. This allows the user to lie about the committer date by using the same value as the author date."
msgstr "默认情况下，该命令将电子邮件中的日期作为提交者日期，并使用提交者的创建时间作为提交者日期。这使得用户可以通过使用与作者日期相同的值来谎报提交者日期。"

#. type: Labeled list
#: en/git-am.txt:156 en/git-rebase.txt:503
#, ignore-same, no-wrap, priority:100
msgid "--ignore-date"
msgstr "--ignore-date"

#. type: Plain text
#: en/git-am.txt:162
#, priority:100
msgid "By default the command records the date from the e-mail message as the commit author date, and uses the time of commit creation as the committer date. This allows the user to lie about the author date by using the same value as the committer date."
msgstr "默认情况下，该命令将电子邮件中的日期作为提交者日期，并使用提交者的创建时间作为提交者日期。这使得用户可以通过使用与提交者日期相同的值来谎报作者日期。"

#. type: Labeled list
#: en/git-am.txt:163 en/git-rebase.txt:220 en/sequencer.txt:6
#, ignore-same, no-wrap, priority:100
msgid "--skip"
msgstr "--skip"

#. type: Plain text
#: en/git-am.txt:166
#, priority:100
msgid "Skip the current patch. This is only meaningful when restarting an aborted patch."
msgstr "跳过当前的补丁。 这只有在重新启动一个中止的补丁时才有意义。"

#. type: Labeled list
#: en/git-am.txt:167 en/git-cherry-pick.txt:110 en/git-commit-tree.txt:62 en/git-commit.txt:389 en/git-rebase.txt:398 en/git-revert.txt:91 en/merge-options.txt:84
#, no-wrap, priority:280
msgid "-S[<keyid>]"
msgstr "-S[<keyid>]"

#. type: Labeled list
#: en/git-am.txt:168 en/git-cherry-pick.txt:111 en/git-commit-tree.txt:63 en/git-commit.txt:390 en/git-rebase.txt:399 en/git-revert.txt:92 en/merge-options.txt:85
#, no-wrap, placeholders:'--gpg-sign', priority:280
msgid "--gpg-sign[=<keyid>]"
msgstr "--gpg-sign[=<键 ID>]"

#. type: Labeled list
#: en/git-am.txt:169 en/git-cherry-pick.txt:112 en/git-commit-tree.txt:64 en/git-commit.txt:391 en/git-rebase.txt:400 en/git-revert.txt:93 en/merge-options.txt:86
#, ignore-same, no-wrap, priority:280
msgid "--no-gpg-sign"
msgstr "--no-gpg-sign"

#. type: Plain text
#: en/git-am.txt:175 en/git-cherry-pick.txt:118 en/git-commit.txt:397 en/git-rebase.txt:406 en/git-revert.txt:99
#, placeholders:'`--no-gpg-sign`':'commit.gpgSign':'`--gpg-sign`', priority:280
msgid "GPG-sign commits. The `keyid` argument is optional and defaults to the committer identity; if specified, it must be stuck to the option without a space. `--no-gpg-sign` is useful to countermand both `commit.gpgSign` configuration variable, and earlier `--gpg-sign`."
msgstr "GPG 签名提交。`keyid` 参数是可选的，默认为提交者身份；如果指定了，则必须与选项相连，不加空格。`--no-gpg-sign` 用于还原 `commit.gpgSign` 配置变量和先前的 `--gpg-sign`。"

#. type: Labeled list
#: en/git-am.txt:176 en/git-merge.txt:122 en/git-rebase.txt:217 en/sequencer.txt:1
#, ignore-same, no-wrap, priority:240
msgid "--continue"
msgstr "--continue"

#. type: Labeled list
#: en/git-am.txt:177 en/git-branch.txt:171 en/git-cherry-pick.txt:79 en/git-diff-tree.txt:36 en/git-grep.txt:97 en/git-ls-tree.txt:44 en/git-pull.txt:107 en/git-rebase.txt:530 en/git-rm.txt:58 en/git-show-branch.txt:43 en/git-unpack-objects.txt:38
#, ignore-same, no-wrap, priority:280
msgid "-r"
msgstr "-r"

#. type: Labeled list
#: en/git-am.txt:178
#, ignore-same, no-wrap, priority:100
msgid "--resolved"
msgstr "--resolved"

#. type: Plain text
#: en/git-am.txt:185
#, priority:100
msgid "After a patch failure (e.g. attempting to apply conflicting patch), the user has applied it by hand and the index file stores the result of the application. Make a commit using the authorship and commit log extracted from the e-mail message and the current index file, and continue."
msgstr "补丁失败后（如试图应用冲突的补丁），用户已经手工应用，索引文件存储了应用的结果。 使用从电子邮件中提取的作者和提交日志以及当前的索引文件进行提交，然后继续运行。"

#. type: Labeled list
#: en/git-am.txt:186
#, no-wrap, placeholders:'--resolvemsg=', priority:100
msgid "--resolvemsg=<msg>"
msgstr "--resolvemsg=<消息>"

#. type: Plain text
#: en/git-am.txt:192
#, placeholders:'`--continue`':'`--skip`', priority:100
msgid "When a patch failure occurs, <msg> will be printed to the screen before exiting. This overrides the standard message informing you to use `--continue` or `--skip` to handle the failure. This is solely for internal use between 'git rebase' and 'git am'."
msgstr "当发生补丁失败时，<信息> 将在退出前被打印到屏幕上。 这将覆盖标准信息，通知你使用 `--continue` 或 `--skip` 来处理失败。 这只是为了在 'git rebase' 和 'git am' 之间的内部使用。"

#. type: Labeled list
#: en/git-am.txt:193 en/git-merge.txt:101 en/git-notes.txt:225 en/git-rebase.txt:223 en/sequencer.txt:15
#, ignore-same, no-wrap, priority:280
msgid "--abort"
msgstr "--abort"

#. type: Plain text
#: en/git-am.txt:197
#, priority:100
msgid "Restore the original branch and abort the patching operation. Revert the contents of files involved in the am operation to their pre-am state."
msgstr "恢复原来的分支，放弃打补丁的操作。 将 am 操作中涉及的文件内容恢复到 am 前的状态。"

#. type: Labeled list
#: en/git-am.txt:198 en/git-merge.txt:117 en/git-rebase.txt:230 en/sequencer.txt:10
#, ignore-same, no-wrap, priority:240
msgid "--quit"
msgstr "--quit"

#. type: Plain text
#: en/git-am.txt:201
#, placeholders:'HEAD', priority:100
msgid "Abort the patching operation but keep HEAD and the index untouched."
msgstr "中止打补丁的操作，但保留 HEAD 和索引不被接触。"

#. type: Labeled list
#: en/git-am.txt:202
#, ignore-same, no-wrap, priority:100
msgid "--show-current-patch[=(diff|raw)]"
msgstr "--show-current-patch[=(diff|raw)]"

#. type: Plain text
#: en/git-am.txt:207
#, priority:100
msgid "Show the message at which `git am` has stopped due to conflicts. If `raw` is specified, show the raw contents of the e-mail message; if `diff`, show the diff portion only. Defaults to `raw`."
msgstr "显示`git am` 因冲突而停止的消息。 如果指定了 `raw`，显示电子邮件的原始内容；如果是 `diff`，只显示差异部分。 默认为 `raw`。"

#. type: Labeled list
#: en/git-am.txt:208 en/git-apply.txt:259 en/git-cherry-pick.txt:124 en/git-commit.txt:220 en/git-notes.txt:169
#, ignore-same, no-wrap, priority:280
msgid "--allow-empty"
msgstr "--allow-empty"

#. type: Plain text
#: en/git-am.txt:212
#, priority:100
msgid "After a patch failure on an input e-mail message lacking a patch, create an empty commit with the contents of the e-mail message as its log message."
msgstr "在对缺乏补丁的输入邮件信息进行补丁失败后，创建一个空的提交，将邮件信息的内容作为其日志信息。"

#. type: Title -
#: en/git-am.txt:214 en/git-commit.txt:541 en/git-format-patch.txt:440 en/git-fsck.txt:115 en/git-log.txt:193 en/git-merge-base.txt:76 en/git-notes.txt:242 en/git-remote.txt:202 en/git-rerere.txt:77 en/git-reset.txt:381 en/git-revert.txt:146 en/git-show.txt:84 en/git-stash.txt:268 en/git-tag.txt:235
#, no-wrap, priority:280
msgid "DISCUSSION"
msgstr "讨论"

#. type: Plain text
#: en/git-am.txt:222
#, priority:100
msgid "The commit author name is taken from the \"From: \" line of the message, and commit author date is taken from the \"Date: \" line of the message. The \"Subject: \" line is used as the title of the commit, after stripping common prefix \"[PATCH <anything>]\". The \"Subject: \" line is supposed to concisely describe what the commit is about in one line of text."
msgstr "提交者的名字取自信息的 \"From:\" 行，而提交者的日期则取自信息的 \"Date:\" 行。 \"Subject:\" 行是提交的标题，在去掉普通前缀 \"[PATCH <任何东西>]\" 之后。 \"Sbuject: \" 是为了用一行文字简洁地描述提交的内容。"

#. type: Plain text
#: en/git-am.txt:225
#, priority:100
msgid "\"From: \", \"Date: \", and \"Subject: \" lines starting the body override the respective commit author name and title values taken from the headers."
msgstr "\"From: \"、\"Date: \" 和 \"Subject: \" 行开始的正文覆盖了从标题中获取的各自的提交者名称和标题值。"

#. type: Plain text
#: en/git-am.txt:230
#, priority:100
msgid "The commit message is formed by the title taken from the \"Subject: \", a blank line and the body of the message up to where the patch begins. Excess whitespace at the end of each line is automatically stripped."
msgstr "提交信息由 \"Subject: \" 中的标题、一个空行和直到补丁开始的信息正文组成。 每行末尾多余的空格会被自动删除。"

#. type: Plain text
#: en/git-am.txt:233
#, priority:100
msgid "The patch is expected to be inline, directly following the message. Any line that is of the form:"
msgstr "补丁应该是内联的，直接跟在信息后面。 任何形式的行："

#. type: Plain text
#: en/git-am.txt:235
#, priority:100
msgid "three-dashes and end-of-line, or"
msgstr "三个破折号和行末，或"

#. type: Plain text
#: en/git-am.txt:236
#, priority:100
msgid "a line that begins with \"diff -\", or"
msgstr "以 \"diff - \" 开头的一行，或"

#. type: Plain text
#: en/git-am.txt:237
#, priority:100
msgid "a line that begins with \"Index: \""
msgstr "以 \"index: \" 开头的一行"

#. type: Plain text
#: en/git-am.txt:240
#, priority:100
msgid "is taken as the beginning of a patch, and the commit log message is terminated before the first occurrence of such a line."
msgstr "被认为是一个补丁的开始，提交日志信息在第一次出现这样的行之前就结束了。"

#. type: Plain text
#: en/git-am.txt:244
#, priority:100
msgid "When initially invoking `git am`, you give it the names of the mailboxes to process. Upon seeing the first patch that does not apply, it aborts in the middle. You can recover from this in one of two ways:"
msgstr "当最初调用 `git am` 时，你给了它要处理的邮箱的名字。 当看到第一个不适用的补丁时，它就会在中间中止。 你可以通过以下两种方式之一恢复："

#. type: Plain text
#: en/git-am.txt:247
#, placeholders:'`--skip`', priority:100
msgid "skip the current patch by re-running the command with the `--skip` option."
msgstr "通过重新运行带有 `--skip` 选项的命令，跳过当前补丁。"

#. type: Plain text
#: en/git-am.txt:251
#, placeholders:'`--continue`', priority:100
msgid "hand resolve the conflict in the working directory, and update the index file to bring it into a state that the patch should have produced. Then run the command with the `--continue` option."
msgstr "手解决工作目录中的冲突，并更新索引文件，使其进入补丁应该产生的状态。 然后用 `--continue` 选项运行该命令。"

#. type: Plain text
#: en/git-am.txt:256
#, placeholders:'--abort`', priority:100
msgid "The command refuses to process new mailboxes until the current operation is finished, so if you decide to start over from scratch, run `git am --abort` before running the command with mailbox names."
msgstr "在当前操作完成之前，该命令拒绝处理新的邮箱，所以如果你决定从头开始，在运行带有邮箱名称的命令之前，运行 `git am --abort`。"

#. type: Plain text
#: en/git-am.txt:262
#, placeholders:'ORIG_HEAD', priority:100
msgid "Before any patches are applied, ORIG_HEAD is set to the tip of the current branch. This is useful if you have problems with multiple commits, like running 'git am' on the wrong branch or an error in the commits that is more easily fixed by changing the mailbox (e.g. errors in the \"From:\" lines)."
msgstr "在应用任何补丁之前，ORIG_HEAD 被设置为当前分支的顶端。 如果你在多个提交中遇到问题，比如在错误的分支上运行 'git am'，或者提交中的错误更容易通过改变邮箱来解决（比如 \"From: \" 行中的错误），这就很有用了。"

#. type: Title -
#: en/git-am.txt:264 en/git-commit.txt:565 en/git-gc.txt:160
#, no-wrap, priority:280
msgid "HOOKS"
msgstr "钩子"

#. type: Plain text
#: en/git-am.txt:268
#, placeholders:'linkgit:githooks[5]', priority:100
msgid "This command can run `applypatch-msg`, `pre-applypatch`, and `post-applypatch` hooks. See linkgit:githooks[5] for more information."
msgstr "这个命令可以运行 `applypatch-msg`, `pre-applypatch`, 和 `post-applypatch` 钩子。 更多信息见 linkgit:githooks[5]。"

#. type: Plain text
#: en/git-am.txt:280
#, ignore-same, priority:100
msgid "linkgit:git-apply[1], linkgit:git-format-patch[1]."
msgstr "linkgit:git-apply[1], linkgit:git-format-patch[1]."

#. type: Title =
#: en/git-annotate.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-annotate(1)"
msgstr "git-annotate(1)"

#. type: Plain text
#: en/git-annotate.txt:7
#, placeholders:'git-annotate', priority:100
msgid "git-annotate - Annotate file lines with commit information"
msgstr "git-annotate - 用提交信息注释文件行"

# ERROR: --] not found in translation
#. type: Plain text
#: en/git-annotate.txt:12
#, no-wrap, priority:100
msgid "'git annotate' [<options>] [<rev-opts>] [<rev>] [--] <file>\n"
msgstr "'git annotate' [<选项>] [<修订选项>] [<修订>] [--] <文件>\n"

#. type: Plain text
#: en/git-annotate.txt:17
#, priority:100
msgid "Annotates each line in the given file with information from the commit which introduced the line. Optionally annotates from a given revision."
msgstr "用引入该行的提交信息来注释给定文件中的每一行。也可以选择从给定的修订版中进行注释。"

#. type: Plain text
#: en/git-annotate.txt:22
#, placeholders:'linkgit:git-blame[1]', priority:100
msgid "The only difference between this command and linkgit:git-blame[1] is that they use slightly different output formats, and this command exists only for backward compatibility to support existing scripts, and provide a more familiar command name for people coming from other SCM systems."
msgstr "这个命令和 linkgit:git-blame[1] 的唯一区别是，它们使用的输出格式略有不同，这个命令的存在只是为了向后兼容，以支持现有的脚本，并为来自其他 SCM 系统的人提供一个更熟悉的命令名称。"

#. type: Title =
#: en/git-apply.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-apply(1)"
msgstr "git-apply(1)"

#. type: Plain text
#: en/git-apply.txt:7
#, placeholders:'git-apply', priority:100
msgid "git-apply - Apply a patch to files and/or to the index"
msgstr "git-apply - 将补丁应用于文件和/或索引"

#. type: Plain text
#: en/git-apply.txt:20
#, ignore-ellipsis, no-wrap, placeholders:'[--stat]':'[--numstat]':'[--summary]':'[--check]':'[--index':'--intent-to-add]':'[--3way]':'[--apply]':'[--no-add]':'[--build-fake-ancestor=':'--reverse]':'[--allow-binary-replacement':'--binary]':'[--reject]':'[--inaccurate-eof]':'[--recount]':'[--cached]':'[--ignore-space-change':'--ignore-whitespace]':'[--whitespace=(nowarn|warn|fix|error|error-all)]':'[--exclude=':'[--include=':'[--directory=':'[--verbose':'--quiet]':'[--unsafe-paths]':'[--allow-empty]', priority:100
msgid ""
"'git apply' [--stat] [--numstat] [--summary] [--check] [--index | --intent-to-add] [--3way]\n"
"\t  [--apply] [--no-add] [--build-fake-ancestor=<file>] [-R | --reverse]\n"
"\t  [--allow-binary-replacement | --binary] [--reject] [-z]\n"
"\t  [-p<n>] [-C<n>] [--inaccurate-eof] [--recount] [--cached]\n"
"\t  [--ignore-space-change | --ignore-whitespace]\n"
"\t  [--whitespace=(nowarn|warn|fix|error|error-all)]\n"
"\t  [--exclude=<path>] [--include=<path>] [--directory=<root>]\n"
"\t  [--verbose | --quiet] [--unsafe-paths] [--allow-empty] [<patch>...]\n"
msgstr ""
"'git apply' [--stat] [--numstat] [--summary] [--check] [--index | --intent-to-add] [--3way]\n"
"\t  [--apply] [--no-add] [--build-fake-ancestor=<文件>] [-R | --reverse]\n"
"\t  [--allow-binary-replacement | --binary] [--reject] [-z]\n"
"\t  [-p<n>] [-C<n>] [--inaccurate-eof] [--recount] [--cached]\n"
"\t  [--ignore-space-change | --ignore-whitespace]\n"
"\t  [--whitespace=(nowarn|warn|fix|error|error-all)]\n"
"\t  [--exclude=<路径>] [--include=<路径>] [--directory=<根目录>]\n"
"\t  [--verbose | --quiet] [--unsafe-paths] [--allow-empty] [<补丁>...]\n"

# ERROR: `--index` not found in translation
#. type: Plain text
#: en/git-apply.txt:30
#, placeholders:'`--index`':'`--cached`', priority:100
msgid "Reads the supplied diff output (i.e. \"a patch\") and applies it to files. When running from a subdirectory in a repository, patched paths outside the directory are ignored. With the `--index` option, the patch is also applied to the index, and with the `--cached` option, the patch is only applied to the index. Without these options, the command applies the patch only to files, and does not require them to be in a Git repository."
msgstr "读取提供的差异输出（即 “一个补丁” ）并将其应用于文件。 当从版本库中的子目录运行时，目录外的补丁路径会被忽略。 使用 `--index` 选项，补丁也会应用到索引中，使用 `--cached` 选项，补丁只应用到索引中。 如果没有这些选项，该命令只对文件打补丁，而不要求它们在 Git 仓库中。"

#. type: Plain text
#: en/git-apply.txt:34
#, placeholders:'linkgit:git-am[1]':'linkgit:git-format-patch[1]', priority:100
msgid "This command applies the patch but does not create a commit. Use linkgit:git-am[1] to create commits from patches generated by linkgit:git-format-patch[1] and/or received by email."
msgstr "该命令会应用补丁，但不会创建提交。 使用 linkgit:git-am[1] 从 linkgit:git-format-patch[1] 生成的和/或通过电子邮件收到的补丁创建提交。"

#. type: Labeled list
#: en/git-apply.txt:37
#, ignore-ellipsis, no-wrap, priority:100
msgid "<patch>..."
msgstr "<补丁>..."

#. type: Plain text
#: en/git-apply.txt:40
#, priority:100
msgid "The files to read the patch from. '-' can be used to read from the standard input."
msgstr "要读取补丁的文件。 '-' 可以用来从标准输入中读取。"

#. type: Labeled list
#: en/git-apply.txt:41 en/git-rebase.txt:415 en/merge-options.txt:107
#, ignore-same, no-wrap, priority:240
msgid "--stat"
msgstr "--stat"

#. type: Plain text
#: en/git-apply.txt:44
#, priority:100
msgid "Instead of applying the patch, output diffstat for the input. Turns off \"apply\"."
msgstr "不应用补丁，而是输出输入的差异状态。 关掉 \"apply\"。"

#. type: Plain text
#: en/git-apply.txt:51
#, placeholders:'`--stat`', priority:100
msgid "Similar to `--stat`, but shows the number of added and deleted lines in decimal notation and the pathname without abbreviation, to make it more machine friendly. For binary files, outputs two `-` instead of saying `0 0`. Turns off \"apply\"."
msgstr "类似于 `--stat`，但是用十进制符号显示增加和删除的行数，路径名不加缩写，使其对机器更友好。 对于二进制文件，输出两个`-` 而不是 `0 0`。 关闭 \"apply\"。"

#. type: Plain text
#: en/git-apply.txt:57
#, priority:100
msgid "Instead of applying the patch, output a condensed summary of information obtained from git diff extended headers, such as creations, renames, and mode changes. Turns off \"apply\"."
msgstr "不应用补丁，而是输出从 git dif f扩展头文件中获得的信息的浓缩摘要，如创建、重命名和模式变化。 关闭 \"apply\"。"

#. type: Plain text
#: en/git-apply.txt:62
#, priority:100
msgid "Instead of applying the patch, see if the patch is applicable to the current working tree and/or the index file and detects errors. Turns off \"apply\"."
msgstr "看看该补丁是否适用于当前工作树和/或索引文件，并检测到错误，而不是应用该补丁。 关闭 \"apply\"。"

#. type: Labeled list
#: en/git-apply.txt:63 en/git-checkout-index.txt:27 en/git-stash.txt:181
#, ignore-same, no-wrap, priority:240
msgid "--index"
msgstr "--index"

#. type: Plain text
#: en/git-apply.txt:71
#, placeholders:'`--check`':'`--index`', priority:100
msgid "Apply the patch to both the index and the working tree (or merely check that it would apply cleanly to both if `--check` is in effect). Note that `--index` expects index entries and working tree copies for relevant paths to be identical (their contents and metadata such as file mode must match), and will raise an error if they are not, even if the patch would apply cleanly to both the index and the working tree in isolation."
msgstr "在索引和工作目录上都打上补丁（如果 `--check`生 效，则只需检查它是否能干净地应用于两者）。注意，`--index` 希望相关路径的索引条目和工作区副本是相同的（它们的内容和元数据，如文件模式必须匹配），如果它们不相同，将引发一个错误，即使该补丁可以干净地应用于索引和工作区。"

#. type: Labeled list
#: en/git-apply.txt:72 en/git-check-attr.txt:27 en/git-diff-index.txt:29 en/git-grep.txt:44 en/git-ls-files.txt:39 en/git-rm.txt:67 en/git-submodule.txt:313
#, ignore-same, no-wrap, priority:280
msgid "--cached"
msgstr "--cached"

#. type: Plain text
#: en/git-apply.txt:76
#, placeholders:'`--check`', priority:100
msgid "Apply the patch to just the index, without touching the working tree. If `--check` is in effect, merely check that it would apply cleanly to the index entry."
msgstr "将补丁只应用于索引，而不触及工作目录。如果 `--check` 是有效的，只需检查它是否能干净地应用于索引条目。"

#. type: Plain text
#: en/git-apply.txt:84
#, placeholders:'`--intent-to-add`':'linkgit:git-add[1]':'`--index`':'`--index`':'`--cached`':'`--3way`', priority:100
msgid "When applying the patch only to the working tree, mark new files to be added to the index later (see `--intent-to-add` option in linkgit:git-add[1]). This option is ignored unless running in a Git repository and `--index` is not specified. Note that `--index` could be implied by other options such as `--cached` or `--3way`."
msgstr "当只在工作树上应用补丁时，标记新的文件，以便以后添加到索引中（见 linkgit:git-add[1] 中的 `--intent-to-add` 选项）。除非在 Git 仓库中运行且没有指定 `--index`，否则该选项将被忽略。 请注意，`--index` 可能是由其他选项暗示的，如 `--cached` 或 `--3way`。"

#. type: Plain text
#: en/git-apply.txt:94
#, placeholders:'`--index`':'`--cached`':'`--reject`':'`--cached`', priority:100
msgid "Attempt 3-way merge if the patch records the identity of blobs it is supposed to apply to and we have those blobs available locally, possibly leaving the conflict markers in the files in the working tree for the user to resolve. This option implies the `--index` option unless the `--cached` option is used, and is incompatible with the `--reject` option. When used with the `--cached` option, any conflicts are left at higher stages in the cache."
msgstr "如果补丁记录了它应该应用到的二进制文件的身份，并且我们有这些二进制文件在本地可用，则尝试三方合并，可能会在工作树中的文件中留下冲突标记，由用户解决。 这个选项意味着 `--index` 选项，除非使用 `--cached` 选项，并且与 `--reject` 选项不兼容。 当与 `--cached` 选项一起使用时，任何冲突都被留在缓存的较高阶段。"

#. type: Labeled list
#: en/git-apply.txt:95
#, no-wrap, placeholders:'--build-fake-ancestor=', priority:100
msgid "--build-fake-ancestor=<file>"
msgstr "--build-fake-ancestor=<文件>"

#. type: Plain text
#: en/git-apply.txt:101
#, priority:100
msgid "Newer 'git diff' output has embedded 'index information' for each blob to help identify the original version that the patch applies to. When this flag is given, and if the original versions of the blobs are available locally, builds a temporary index containing those blobs."
msgstr "较新的 \"git diff\" 输出为每个 blob 嵌入了 \"索引信息\"，以帮助识别补丁所适用的原始版本。 当给出这个标志时，如果 blob 的原始版本在本地可用，则建立一个包含这些 blob 的临时索引。"

#. type: Plain text
#: en/git-apply.txt:104
#, priority:100
msgid "When a pure mode change is encountered (which has no index information), the information is read from the current index instead."
msgstr "当遇到一个纯粹的模式变化（没有索引信息）时，将从当前索引中读取信息。"

#. type: Labeled list
#: en/git-apply.txt:106 en/rev-list-options.txt:883
#, ignore-same, no-wrap, priority:260
msgid "--reverse"
msgstr "--reverse"

#. type: Plain text
#: en/git-apply.txt:108
#, priority:100
msgid "Apply the patch in reverse."
msgstr "反过来应用补丁。"

#. type: Plain text
#: en/git-apply.txt:115
#, priority:100
msgid "For atomicity, 'git apply' by default fails the whole patch and does not touch the working tree when some of the hunks do not apply. This option makes it apply the parts of the patch that are applicable, and leave the rejected hunks in corresponding *.rej files."
msgstr "为了保证原子性，'git apply' 默认情况下会使整个补丁失效，并且在某些目标不适用的情况下不会接触工作区。 这个选项让它应用补丁中适用的部分，并将被拒绝的目标留在相应的 *.rej 文件中。"

#. type: Plain text
#: en/git-apply.txt:119
#, placeholders:'`--numstat`', priority:100
msgid "When `--numstat` has been given, do not munge pathnames, but use a NUL-terminated machine-readable format."
msgstr "当 `--numstat` 被给出时，不对路径名进行编码，而是使用以 NUL 结尾的机器可读格式。"

#. type: Plain text
#: en/git-apply.txt:129
#, priority:100
msgid "Remove <n> leading path components (separated by slashes) from traditional diff paths. E.g., with `-p2`, a patch against `a/dir/file` will be applied directly to `file`. The default is 1."
msgstr "移除传统差异路径中的 <n> 前导路径成分（用斜线分隔）。例如，使用 `-p2`，针对 `a/dir/file` 的补丁将直接应用于 `file`。默认为 1。"

#. type: Plain text
#: en/git-apply.txt:135
#, priority:100
msgid "Ensure at least <n> lines of surrounding context match before and after each change. When fewer lines of surrounding context exist they all must match. By default no context is ever ignored."
msgstr "确保每次更改前后至少有 <n> 行的周围环境相匹配。 当周围环境的行数较少时，它们必须全部匹配。 在默认情况下，没有任何上下文被忽略。"

#. type: Labeled list
#: en/git-apply.txt:136
#, ignore-same, no-wrap, priority:100
msgid "--unidiff-zero"
msgstr "--unidiff-zero"

#. type: Plain text
#: en/git-apply.txt:142
#, placeholders:'`--unified=0`':'`--unidiff-zero`', priority:100
msgid "By default, 'git apply' expects that the patch being applied is a unified diff with at least one line of context. This provides good safety measures, but breaks down when applying a diff generated with `--unified=0`. To bypass these checks use `--unidiff-zero`."
msgstr "默认情况下，'git apply' 希望被应用的补丁是一个至少有一行上下文的统一差异。 这提供了很好的安全措施，但在应用以 `--unified=0` 生成的差异时，会出现问题。要绕过这些检查，请使用 `--unidiff-zero`。"

#. type: Plain text
#: en/git-apply.txt:145
#, priority:100
msgid "Note, for the reasons stated above, the usage of context-free patches is discouraged."
msgstr "请注意，由于上述原因，我们不鼓励使用无上下文修补程序。"

#. type: Plain text
#: en/git-apply.txt:146 en/git-rebase.txt:285 en/git-rebase.txt:657
#, ignore-same, no-wrap, priority:100
msgid "--apply"
msgstr "--apply"

#. type: Plain text
#: en/git-apply.txt:152
#, priority:100
msgid "If you use any of the options marked \"Turns off 'apply'\" above, 'git apply' reads and outputs the requested information without actually applying the patch. Give this flag after those flags to also apply the patch."
msgstr "如果您使用了上面标有 \"关闭 'apply' \" 的任何选项，'git apply' 会读取并输出所需的信息，而不会实际应用补丁。 在这些标志之后给出这个标志，也可以应用该补丁。"

#. type: Labeled list
#: en/git-apply.txt:153
#, ignore-same, no-wrap, priority:100
msgid "--no-add"
msgstr "--no-add"

#. type: Plain text
#: en/git-apply.txt:159
#, priority:100
msgid "When applying a patch, ignore additions made by the patch. This can be used to extract the common part between two files by first running 'diff' on them and applying the result with this option, which would apply the deletion part but not the addition part."
msgstr "当应用一个补丁时，忽略该补丁所做的添加内容。 这可以用来提取两个文件之间的共同部分，首先对它们运行 'diff'，然后用这个选项应用结果，这将应用删除的部分，但不应用增加的部分。"

#. type: Labeled list
#: en/git-apply.txt:160
#, ignore-same, no-wrap, priority:100
msgid "--allow-binary-replacement"
msgstr "--allow-binary-replacement"

#. type: Plain text
#: en/git-apply.txt:166
#, priority:100
msgid "Historically we did not allow binary patch application without an explicit permission from the user, and this flag was the way to do so. Currently, we always allow binary patch application, so this is a no-op."
msgstr "过去，我们不允许在没有用户明确许可的情况下使用二进制补丁程序，这个标志就是这样做的。 目前，我们始终允许二进制补丁的应用，所以这个标记是无效的。"

#. type: Labeled list
#: en/git-apply.txt:167
#, no-wrap, placeholders:'--exclude=', priority:100
msgid "--exclude=<path-pattern>"
msgstr "--exclude=<路径模式>"

#. type: Plain text
#: en/git-apply.txt:171
#, priority:100
msgid "Don't apply changes to files matching the given path pattern. This can be useful when importing patchsets, where you want to exclude certain files or directories."
msgstr "不要对符合给定路径模式的文件进行修改。这在导入补丁集时，你想把某些文件或目录排除在外的情况下很有用。"

#. type: Labeled list
#: en/git-apply.txt:172
#, no-wrap, placeholders:'--include=', priority:100
msgid "--include=<path-pattern>"
msgstr "--include=<路径模式>"

#. type: Plain text
#: en/git-apply.txt:176
#, priority:100
msgid "Apply changes to files matching the given path pattern. This can be useful when importing patchsets, where you want to include certain files or directories."
msgstr "将修改应用于与给定路径模式相匹配的文件。这在导入补丁集时，你想包括某些文件或目录的情况下很有用。"

#. type: Plain text
#: en/git-apply.txt:182
#, placeholders:'`--exclude`':'`--include`', priority:100
msgid "When `--exclude` and `--include` patterns are used, they are examined in the order they appear on the command line, and the first match determines if a patch to each path is used. A patch to a path that does not match any include/exclude pattern is used by default if there is no include pattern on the command line, and ignored if there is any include pattern."
msgstr "当使用 `--exclude` 和 `--include` 模式时，会按照它们在命令行中出现的顺序进行检查，第一个匹配项决定是否使用每个路径的补丁。 如果命令行上没有include模式，则默认使用不匹配任何 include/exclude 模式的路径的补丁，如果有任何 include 模式，则忽略。"

#. type: Plain text
#: en/git-apply.txt:190
#, placeholders:'`--whitespace`', priority:100
msgid "When applying a patch, ignore changes in whitespace in context lines if necessary. Context lines will preserve their whitespace, and they will not undergo whitespace fixing regardless of the value of the `--whitespace` option. New lines will still be fixed, though."
msgstr "当应用一个补丁时，如果有必要，请忽略上下文行中的空白变化。 上下文行将保留其空白，无论 `--whitespace` 选项的值是多少，它们都不会进行空白修正。不过，新的行仍然会被修复。"

#. type: Plain text
#: en/git-apply.txt:199
#, placeholders:'core.whitespace', priority:100
msgid "When applying a patch, detect a new or modified line that has whitespace errors. What are considered whitespace errors is controlled by `core.whitespace` configuration. By default, trailing whitespaces (including lines that solely consist of whitespaces) and a space character that is immediately followed by a tab character inside the initial indent of the line are considered whitespace errors."
msgstr "当应用一个补丁时，检测一个新的或修改过的行有空格错误。 什么是空格错误是由 `core.whitespace` 配置控制的。 默认情况下，尾部的空白（包括仅由空白组成的行）和紧跟在行的初始缩进内的 Tab 字符的空白字符被认为是空白错误。"

#. type: Plain text
#: en/git-apply.txt:203
#, placeholders:'git-apply', priority:100
msgid "By default, the command outputs warning messages but applies the patch. When `git-apply` is used for statistics and not applying a patch, it defaults to `nowarn`."
msgstr "默认情况下，该命令输出警告信息，但会应用补丁。 当 `git-apply` 被用于统计而不应用补丁时，它默认为 `nowarn`。"

#. type: Plain text
#: en/git-apply.txt:206
#, priority:100
msgid "You can use different `<action>` values to control this behavior:"
msgstr "你可以使用不同的 `<行为>` 值来控制这种行为："

#. type: Plain text
#: en/git-apply.txt:208
#, priority:100
msgid "`nowarn` turns off the trailing whitespace warning."
msgstr "`nowarn` 关闭尾部空白警告。"

#. type: Plain text
#: en/git-apply.txt:210
#, priority:100
msgid "`warn` outputs warnings for a few such errors, but applies the patch as-is (default)."
msgstr "`warn` 对少数此类错误输出警告，但按原样应用补丁（默认）。"

#. type: Plain text
#: en/git-apply.txt:214
#, priority:100
msgid "`fix` outputs warnings for a few such errors, and applies the patch after fixing them (`strip` is a synonym -- the tool used to consider only trailing whitespace characters as errors, and the fix involved 'stripping' them, but modern Gits do more)."
msgstr "`fix` 对一些这样的错误输出警告，并在修复后应用补丁（`strip` 是一个同义词--该工具过去只考虑尾部空白字符的错误，修复涉及 'stripping' 等，但现代 Gits 做得更多）。"

#. type: Plain text
#: en/git-apply.txt:216
#, priority:100
msgid "`error` outputs warnings for a few such errors, and refuses to apply the patch."
msgstr "`error` 对几个这样的错误输出警告，并拒绝应用补丁。"

#. type: Plain text
#: en/git-apply.txt:217
#, priority:100
msgid "`error-all` is similar to `error` but shows all errors."
msgstr "`error-all` 与 `error` 类似，但显示所有错误。"

#. type: Labeled list
#: en/git-apply.txt:218
#, ignore-same, no-wrap, priority:100
msgid "--inaccurate-eof"
msgstr "--inaccurate-eof"

#. type: Plain text
#: en/git-apply.txt:224
#, priority:100
msgid "Under certain circumstances, some versions of 'diff' do not correctly detect a missing new-line at the end of the file. As a result, patches created by such 'diff' programs do not record incomplete lines correctly. This option adds support for applying such patches by working around this bug."
msgstr "在某些情况下，某些版本的 'diff ' 不能正确检测到文件末尾缺少的换行。因此，由这类 'diff' 程序创建的补丁不能正确记录不完整的行。这个选项通过解决这个错误来增加对应用这种补丁的支持。"

#. type: Plain text
#: en/git-apply.txt:230
#, priority:100
msgid "Report progress to stderr. By default, only a message about the current patch being applied will be printed. This option will cause additional information to be reported."
msgstr "向标准错误流报告进度。默认情况下，只有关于当前正在应用的补丁的信息会被打印出来。这个选项将导致报告额外的信息。"

#. type: Plain text
#: en/git-apply.txt:235
#, priority:100
msgid "Suppress stderr output. Messages about patch status and progress will not be printed."
msgstr "抑制标准错误流输出。关于补丁状态和进度的信息将不被打印。"

#. type: Labeled list
#: en/git-apply.txt:236
#, ignore-same, no-wrap, priority:100
msgid "--recount"
msgstr "--recount"

#. type: Plain text
#: en/git-apply.txt:240
#, priority:100
msgid "Do not trust the line counts in the hunk headers, but infer them by inspecting the patch (e.g. after editing the patch without adjusting the hunk headers appropriately)."
msgstr "不信任组头中的行数，而是通过检查补丁来推断（例如，在编辑补丁后没有适当调整组头）。"

#. type: Labeled list
#: en/git-apply.txt:241
#, no-wrap, placeholders:'--directory=', priority:100
msgid "--directory=<root>"
msgstr "--directory=<root>"

#. type: Plain text
#: en/git-apply.txt:244
#, priority:100
msgid "Prepend <root> to all filenames. If a \"-p\" argument was also passed, it is applied before prepending the new root."
msgstr "将 <根目录> 预置到所有文件名中。 如果还传递了 \"-p \" 参数，则在预置新根目录之前应用。"

#. type: Plain text
#: en/git-apply.txt:248
#, placeholders:'git-gui':'git-gui':'git-gui':'git-gui':'--directory=modules':'git-gui', priority:100
msgid "For example, a patch that talks about updating `a/git-gui.sh` to `b/git-gui.sh` can be applied to the file in the working tree `modules/git-gui/git-gui.sh` by running `git apply --directory=modules/git-gui`."
msgstr "例如，一个关于将 `a/git-gui.sh` 更新为 `b/git-gui.sh` 的补丁可以通过运行 `git apply --directory=modules/git-gui` 来应用于工作区 `modules/git-gui/git-gui.sh` 中的文件。"

#. type: Labeled list
#: en/git-apply.txt:249
#, ignore-same, no-wrap, priority:100
msgid "--unsafe-paths"
msgstr "--unsafe-paths"

#. type: Plain text
#: en/git-apply.txt:254
#, priority:100
msgid "By default, a patch that affects outside the working area (either a Git controlled working tree, or the current working directory when \"git apply\" is used as a replacement of GNU patch) is rejected as a mistake (or a mischief)."
msgstr "默认情况下，影响到工作区域之外（无论是 Git 控制的工作区，还是用 \"git apply\" 替代 GNU patch 时的当前工作目录）的补丁会被当作错误（或恶作剧）而拒绝。"

#. type: Plain text
#: en/git-apply.txt:258
#, placeholders:'`--unsafe-paths`':'`--index`':'`--cached`', priority:100
msgid "When `git apply` is used as a \"better GNU patch\", the user can pass the `--unsafe-paths` option to override this safety check. This option has no effect when `--index` or `--cached` is in use."
msgstr "当 `git apply` 被用作 \"更好的 GNU 补丁\" 时，用户可以通过 `--unsafe-paths` 选项来覆盖这个安全检查。 当使用 `--index` 或 `--cached` 时，该选项没有作用。"

#. type: Plain text
#: en/git-apply.txt:262
#, priority:100
msgid "Don't return an error for patches containing no diff. This includes empty patches and patches with commit text only."
msgstr "对于不包含差异的补丁，不返回错误信息。这包括空补丁和只有提交文本的补丁。"

#. type: Title -
#: en/git-apply.txt:271 en/git-mv.txt:48 en/git-rm.txt:153
#, no-wrap, priority:280
msgid "SUBMODULES"
msgstr "子模块"

#. type: Plain text
#: en/git-apply.txt:274
#, priority:100
msgid "If the patch contains any changes to submodules then 'git apply' treats these changes as follows."
msgstr "如果该补丁包含对子模块的任何修改，那么 'git apply' 会对这些修改进行如下处理。"

#. type: Plain text
#: en/git-apply.txt:280
#, placeholders:'`--index`', priority:100
msgid "If `--index` is specified (explicitly or implicitly), then the submodule commits must match the index exactly for the patch to apply. If any of the submodules are checked-out, then these check-outs are completely ignored, i.e., they are not required to be up to date or clean and they are not updated."
msgstr "如果 `--index` 被指定（显式或隐式），那么子模块的提交必须与索引完全匹配，补丁才能应用。 如果任何一个子模块被检出，那么这些检出的模块将被完全忽略，也就是说，它们不需要是最新的或干净的，它们也不会被更新。"

#. type: Plain text
#: en/git-apply.txt:284
#, placeholders:'`--index`', priority:100
msgid "If `--index` is not specified, then the submodule commits in the patch are ignored and only the absence or presence of the corresponding subdirectory is checked and (if possible) updated."
msgstr "如果没有指定 `--index`，那么补丁中的子模块提交将被忽略，只检查相应的子目录是否存在，并（如果可能）更新。"

#. type: Plain text
#: en/git-apply.txt:288
#, ignore-same, priority:100
msgid "linkgit:git-am[1]."
msgstr "linkgit:git-am[1]."

#. type: Title =
#: en/git-archimport.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-archimport(1)"
msgstr "git-archimport(1)"

#. type: Plain text
#: en/git-archimport.txt:7
#, placeholders:'git-archimport', priority:100
msgid "git-archimport - Import a GNU Arch repository into Git"
msgstr "git-archimport - 将 GNU Arch 仓库导入 Git 中"

#. type: Plain text
#: en/git-archimport.txt:14
#, ignore-ellipsis, no-wrap, priority:100
msgid ""
"'git archimport' [-h] [-v] [-o] [-a] [-f] [-T] [-D <depth>] [-t <tempdir>]\n"
"\t       <archive>/<branch>[:<git-branch>]...\n"
msgstr ""
"'git archimport' [-h] [-v] [-o] [-a] [-f] [-T] [-D <深度>] [-t <缓存目录>]\n"
"\t       <归档>/<分支>[:<git 分支>]...\n"

#. type: Plain text
#: en/git-archimport.txt:23
#, priority:100
msgid "Imports a project from one or more GNU Arch repositories. It will follow branches and repositories within the namespaces defined by the <archive>/<branch> parameters supplied. If it cannot find the remote branch a merge comes from it will just import it as a regular commit. If it can find it, it will mark it as a merge whenever possible (see discussion below)."
msgstr "从一个或多个 GNU Arch 仓库导入一个项目。 它将在所提供的 <归档>/<分支> 参数所定义的命名空间内跟踪分支和仓库。如果它找不到合并后的远程分支，就会把它作为一个普通的提交导入。如果它能找到它，它会尽可能地将其标记为合并（见下面的讨论）。"

#. type: Plain text
#: en/git-archimport.txt:27
#, priority:100
msgid "The script expects you to provide the key roots where it can start the import from an 'initial import' or 'tag' type of Arch commit. It will follow and import new branches within the provided roots."
msgstr "该脚本希望你提供关键的根目录，它可以从 'initial' 或 'tag' 类型的 Arch 提交开始导入。它将跟踪并导入所提供的根目录下的新分支。"

#. type: Plain text
#: en/git-archimport.txt:32
#, priority:100
msgid "It expects to be dealing with one project only. If it sees branches that have different roots, it will refuse to run. In that case, edit your <archive>/<branch> parameters to define clearly the scope of the import."
msgstr "它希望只处理一个项目。如果它看到有不同根目录的分支，它将拒绝运行。在这种情况下，编辑你的 <归档>/<分支> 参数，以明确定义导入的范围。"

#. type: Plain text
#: en/git-archimport.txt:37
#, priority:100
msgid "'git archimport' uses `tla` extensively in the background to access the Arch repository. Make sure you have a recent version of `tla` available in the path. `tla` must know about the repositories you pass to 'git archimport'."
msgstr "'git archimport' 在后台广泛使用 `tla` 来访问 Arch 仓库。 确保你的路径中有一个最新版本的 `tla`。`tla` 必须知道你传递给 'git archimport' 的仓库。"

#. type: Plain text
#: en/git-archimport.txt:42
#, priority:100
msgid "For the initial import, 'git archimport' expects to find itself in an empty directory. To follow the development of a project that uses Arch, rerun 'git archimport' with the same parameters as the initial import to perform incremental imports."
msgstr "对于初始导入，'git archimport' 希望能在一个空目录中找到自己。要跟踪一个使用 Arch 的项目的发展，重新运行 'git archimport'，参数与初始导入相同，以执行增量导入。"

#. type: Plain text
#: en/git-archimport.txt:49
#, placeholders:'{litdd}':'{litdd}', priority:100
msgid "While 'git archimport' will try to create sensible branch names for the archives that it imports, it is also possible to specify Git branch names manually. To do so, write a Git branch name after each <archive>/<branch> parameter, separated by a colon. This way, you can shorten the Arch branch names and convert Arch jargon to Git jargon, for example mapping a \"PROJECT{litdd}devo{litdd}VERSION\" branch to \"master\"."
msgstr "虽然 'git archimport' 会尝试为它导入的档案创建合理的分支名，但也可以手动指定 Git 分支名。 要做到这一点，在每个 <归档>/<分支> 参数后面写一个 Git 分支名，用冒号隔开。 这样，你可以缩短 Arch 分支的名称，并将 Arch 的行话转换成 Git 的行话，例如将 \"PROJECT{litdd}devo{litdd}VERSION\" 分支映射为 \"master\"。"

#. type: Plain text
#: en/git-archimport.txt:54
#, priority:100
msgid "Associating multiple Arch branches to one Git branch is possible; the result will make the most sense only if no commits are made to the first branch, after the second branch is created. Still, this is useful to convert Arch repositories that had been rotated periodically."
msgstr "将多个 Arch 分支关联到一个 Git 分支是可能的；只有在创建第二个分支后没有向第一个分支提交的情况下，其结果才是最合理的。 不过，这对于转换定期轮换的 Arch 仓库还是很有用的。"

#. type: Title -
#: en/git-archimport.txt:57
#, no-wrap, priority:100
msgid "MERGES"
msgstr "合并"

#. type: Plain text
#: en/git-archimport.txt:63
#, priority:100
msgid "Patch merge data from Arch is used to mark merges in Git as well. Git does not care much about tracking patches, and only considers a merge when a branch incorporates all the commits since the point they forked. The end result is that Git will have a good idea of how far branches have diverged. So the import process does lose some patch-trading metadata."
msgstr "Arch 的补丁合并数据在 Git 中也被用来标记合并。Git 并不关心对补丁的追踪，只有当一个分支包含了自分叉点以来的所有提交时，才会考虑合并。最终的结果是，Git 会很好地了解分支的分歧程度。所以导入过程确实会丢失一些补丁交易的元数据。"

#. type: Plain text
#: en/git-archimport.txt:67
#, priority:100
msgid "Fortunately, when you try and merge branches imported from Arch, Git will find a good merge base, and it has a good chance of identifying patches that have been traded out-of-sequence between the branches."
msgstr "幸运的是，当你尝试合并从 Arch 导入的分支时，Git 会找到一个好的合并基础，而且它有很大的机会识别出在分支之间被交易的不符合顺序的补丁。"

#. type: Plain text
#: en/git-archimport.txt:73
#, priority:100
msgid "Display usage."
msgstr "显示用途。"

#. type: Plain text
#: en/git-archimport.txt:76
#, priority:100
msgid "Verbose output."
msgstr "详细输出。"

#. type: Labeled list
#: en/git-archimport.txt:77
#, ignore-same, no-wrap, priority:100
msgid "-T"
msgstr "-T"

#. type: Plain text
#: en/git-archimport.txt:80
#, priority:100
msgid "Many tags. Will create a tag for every commit, reflecting the commit name in the Arch repository."
msgstr "多标签。将为每个提交创建一个标签，反映 Arch 库中的提交名称。"

#. type: Plain text
#: en/git-archimport.txt:85
#, priority:100
msgid "Use the fast patchset import strategy. This can be significantly faster for large trees, but cannot handle directory renames or permissions changes. The default strategy is slow and safe."
msgstr "使用快速补丁集导入策略。 这对大目录树来说可以明显加快，但不能处理目录重名或权限变化。 默认策略是缓慢而安全的。"

#. type: Labeled list
#: en/git-archimport.txt:86 en/git-commit.txt:308 en/git-grep.txt:183 en/git-ls-files.txt:53 en/git-merge-index.txt:29
#, ignore-same, no-wrap, priority:280
msgid "-o"
msgstr "-o"

#. type: Plain text
#: en/git-archimport.txt:93
#, placeholders:'{litdd}':'{litdd}':'{litdd}', priority:100
msgid "Use this for compatibility with old-style branch names used by earlier versions of 'git archimport'. Old-style branch names were category{litdd}branch, whereas new-style branch names are archive,category{litdd}branch{litdd}version. In both cases, names given on the command-line will override the automatically-generated ones."
msgstr "为了与早期版本的 'git archimport' 所使用的旧式分支名兼容，使用这个名字。 旧式的分支名是 category{litdd}branch，而新式的分支名是 archive,category{litdd}branch{litdd}version。 在这两种情况下，在命令行中给出的名字将覆盖自动生成的名字。"

#. type: Labeled list
#: en/git-archimport.txt:94
#, no-wrap, priority:100
msgid "-D <depth>"
msgstr "-D <深度>"

#. type: Plain text
#: en/git-archimport.txt:98
#, priority:100
msgid "Follow merge ancestry and attempt to import trees that have been merged from. Specify a depth greater than 1 if patch logs have been pruned."
msgstr "遵循合并的祖先，并尝试导入已经合并的目录树。 如果补丁日志已经被修剪，则指定一个大于 1 的深度。"

#. type: Plain text
#: en/git-archimport.txt:102
#, placeholders:'mirrors.sourcecontrol.net', priority:100
msgid "Attempt to auto-register archives at `http://mirrors.sourcecontrol.net` This is particularly useful with the -D option."
msgstr "尝试在 `http://mirrors.sourcecontrol.net` 上自动注册档案，这在 -D 选项下特别有用。"

#. type: Labeled list
#: en/git-archimport.txt:103
#, no-wrap, priority:100
msgid "-t <tmpdir>"
msgstr "-t <缓存目录>"

#. type: Plain text
#: en/git-archimport.txt:105
#, priority:100
msgid "Override the default tempdir."
msgstr "重写默认缓存目录。"

#. type: Labeled list
#: en/git-archimport.txt:107
#, no-wrap, priority:100
msgid "<archive>/<branch>"
msgstr "<归档>/<分支>"

#. type: Plain text
#: en/git-archimport.txt:109
#, priority:100
msgid "<archive>/<branch> identifier in a format that `tla log` understands."
msgstr "<归档>/<分支> 标识符的格式是 `tla log` 能理解的。"

#. type: Title =
#: en/git-archive.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-archive(1)"
msgstr "git-archive(1)"

#. type: Plain text
#: en/git-archive.txt:7
#, placeholders:'git-archive', priority:100
msgid "git-archive - Create an archive of files from a named tree"
msgstr "git-archive - 从命名的目录树中创建一个归档文件"

#. type: Plain text
#: en/git-archive.txt:16
#, ignore-ellipsis, no-wrap, placeholders:'[--format=':'[--list]':'[--prefix=':'--output=':'[--worktree-attributes]':'[--remote=':'[--exec=', priority:100
msgid ""
"'git archive' [--format=<fmt>] [--list] [--prefix=<prefix>/] [<extra>]\n"
"\t      [-o <file> | --output=<file>] [--worktree-attributes]\n"
"\t      [--remote=<repo> [--exec=<git-upload-archive>]] <tree-ish>\n"
"\t      [<path>...]\n"
msgstr ""
"'git archive' [--format=<fmt>] [--list] [--prefix=<前缀>/] [<extra>]\n"
"\t      [-o <文件> | --output=<文件>] [--worktree-attributes]\n"
"\t      [--remote=<仓库> [--exec=<Git 上传归档>]] <树状对象>\n"
"\t      [<路径>...]\n"

#. type: Plain text
#: en/git-archive.txt:23
#, priority:100
msgid "Creates an archive of the specified format containing the tree structure for the named tree, and writes it out to the standard output. If <prefix> is specified it is prepended to the filenames in the archive."
msgstr "创建一个指定格式的档案，包含命名的目录树的结构，并将其写入标准输出。 如果 <前缀> 被指定，它将被预置在归档文件的文件名上。"

#. type: Plain text
#: en/git-archive.txt:32
#, placeholders:'git get-tar-commit-id', priority:100
msgid "'git archive' behaves differently when given a tree ID as opposed to a commit ID or tag ID. When a tree ID is provided, the current time is used as the modification time of each file in the archive. On the other hand, when a commit ID or tag ID is provided, the commit time as recorded in the referenced commit object is used instead. Additionally the commit ID is stored in a global extended pax header if the tar format is used; it can be extracted using 'git get-tar-commit-id'. In ZIP files it is stored as a file comment."
msgstr "与提交 ID 或标签 ID 相比，'git archive' 在提供目录树 ID 时的行为有所不同。提供树 ID 时，当前时间会被用作存档中每个文件的修改时间。另一方面，如果提供了提交 ID 或标记 ID，则会使用引用的提交对象中记录的提交时间。 此外，如果使用 tar 格式，提交 ID 会存储在全局扩展 pax 标头中；可以使用 'git get-tar-commit-id' 提取。在 ZIP 文件中，它被存储为文件注释。"

#. type: Labeled list
#: en/git-archive.txt:36
#, no-wrap, placeholders:'--format=', priority:100
msgid "--format=<fmt>"
msgstr "--format=<格式>"

#. type: Plain text
#: en/git-archive.txt:44
#, placeholders:'tar.gz':'`--format`':'foo.zip', priority:100
msgid "Format of the resulting archive. Possible values are `tar`, `zip`, `tar.gz`, `tgz`, and any format defined using the configuration option `tar.<format>.command`. If `--format` is not given, and the output file is specified, the format is inferred from the filename if possible (e.g. writing to `foo.zip` makes the output to be in the `zip` format). Otherwise the output format is `tar`."
msgstr "归档文件的格式。可能的值是 `tar`, `zip`, `tar.gz`, `tgz`, 以及使用配置选项 `tar.<格式>.command` 定义的任何格式。如果没有给出 `--format`，并且指定了输出文件，如果可能的话，将从文件名中推断出格式（例如，写入`foo.zip` 会使输出为`zip`格式）。否则，输出格式为`tar`。"

#. type: Labeled list
#: en/git-archive.txt:46 en/git-branch.txt:182 en/git-config.txt:182 en/git-show-branch.txt:79 en/git-tag.txt:100
#, ignore-same, no-wrap, priority:260
msgid "--list"
msgstr "--list"

#. type: Plain text
#: en/git-archive.txt:48
#, priority:100
msgid "Show all available formats."
msgstr "显示所有可用的格式。"

#. type: Plain text
#: en/git-archive.txt:52
#, priority:100
msgid "Report progress to stderr."
msgstr "向标准错误流报告进度。"

#. type: Labeled list
#: en/git-archive.txt:53 en/git-write-tree.txt:35
#, no-wrap, placeholders:'--prefix=', priority:100
msgid "--prefix=<prefix>/"
msgstr "--prefix=<前缀>/"

#. type: Plain text
#: en/git-archive.txt:57
#, placeholders:'`--add-file`':'`--add-virtual-file`', priority:100
msgid "Prepend <prefix>/ to paths in the archive. Can be repeated; its rightmost value is used for all tracked files. See below which value gets used by `--add-file` and `--add-virtual-file`."
msgstr "将 <前缀>/ 预置到存档中的路径。 可以重复使用；其最右边的值用于所有跟踪的文件。 请看下面的 `--add-file` 和 `--add-virtual-file` 所使用的值。"

#. type: Labeled list
#: en/git-archive.txt:58
#, no-wrap, priority:100
msgid "-o <file>"
msgstr "-o <文件>"

#. type: Plain text
#: en/git-archive.txt:61
#, priority:100
msgid "Write the archive to <file> instead of stdout."
msgstr "将存档写入 <文件> 而不是标准输出流。"

#. type: Labeled list
#: en/git-archive.txt:62
#, no-wrap, placeholders:'--add-file=', priority:100
msgid "--add-file=<file>"
msgstr "--add-file=<文件>"

#. type: Plain text
#: en/git-archive.txt:67
#, placeholders:'`--prefix`':'`--add-file`', priority:100
msgid "Add a non-tracked file to the archive. Can be repeated to add multiple files. The path of the file in the archive is built by concatenating the value of the last `--prefix` option (if any) before this `--add-file` and the basename of <file>."
msgstr "添加一个非跟踪的文件到存档。 可以重复添加多个文件。 归档文件的路径是由这个 `--add-file` 之前的最后一个 `--prefix` 选项（如果有的话）的值和 <文件> 的基本名称连接而成的。"

#. type: Labeled list
#: en/git-archive.txt:68
#, no-wrap, placeholders:'--add-virtual-file=', priority:100
msgid "--add-virtual-file=<path>:<content>"
msgstr "--add-virtual-file=<路径>:<内容>"

#. type: Plain text
#: en/git-archive.txt:73
#, placeholders:'`--prefix`':'`--add-virtual-file`', priority:100
msgid "Add the specified contents to the archive. Can be repeated to add multiple files. The path of the file in the archive is built by concatenating the value of the last `--prefix` option (if any) before this `--add-virtual-file` and `<path>`."
msgstr "将指定的内容添加到档案中。 可以重复添加多个文件。 归档文件的路径是由这个 `--add-virtual-file` 之前的最后一个 `--prefix` 选项（如果有的话）和 `<路径>` 相连而成的。"

#. type: Plain text
#: en/git-archive.txt:80
#, priority:100
msgid "The `<path>` argument can start and end with a literal double-quote character; the contained file name is interpreted as a C-style string, i.e. the backslash is interpreted as escape character. The path must be quoted if it contains a colon, to avoid the colon from being misinterpreted as the separator between the path and the contents, or if the path begins or ends with a double-quote character."
msgstr "`<路径>` 参数可以以字面的双引号字符开始和结束；包含的文件名被解释为 C 风格的字符串，即反斜杠被解释为转义字符。如果路径包含一个冒号，则必须加引号，以避免冒号被误解为路径和内容之间的分隔符，或者如果路径以双引号字符开始或结束。"

#. type: Plain text
#: en/git-archive.txt:84
#, placeholders:'`--add-file`', priority:100
msgid "The file mode is limited to a regular file, and the option may be subject to platform-dependent command-line limits. For non-trivial cases, write an untracked file and use `--add-file` instead."
msgstr "文件模式被限制为普通文件，该选项可能会受到依赖平台的命令行的限制。对于非复杂的情况，写一个非跟踪的文件并使用 `--add-file` 代替。"

#. type: Labeled list
#: en/git-archive.txt:85
#, ignore-same, no-wrap, priority:100
msgid "--worktree-attributes"
msgstr "--worktree-attributes"

#. type: Plain text
#: en/git-archive.txt:88
#, placeholders:'.gitattributes':'<<ATTRIBUTES>>', priority:100
msgid "Look for attributes in .gitattributes files in the working tree as well (see <<ATTRIBUTES>>)."
msgstr "也可以在工作区中的 .gitattributes 文件中寻找属性（见 <<ATTRIBUTES>>）。"

# ERROR: --mtime= not found in translation
#. type: Labeled list
#: en/git-archive.txt:89
#, no-wrap, placeholders:'--mtime=', priority:100
msgid "--mtime=<time>"
msgstr "--mtime=<时间>"

#. type: Plain text
#: en/git-archive.txt:93
#, priority:100
msgid "Set modification time of archive entries. Without this option the committer time is used if `<tree-ish>` is a commit or tag, and the current time if it is a tree."
msgstr "设置存档条目的修改时间。 如果没有这个选项，如果 `<树状对象>` 是一个提交或标签，则使用提交者的时间，如果是一个树，则使用当前时间。"

#. type: Labeled list
#: en/git-archive.txt:94
#, no-wrap, priority:100
msgid "<extra>"
msgstr "<extra>"

#. type: Plain text
#: en/git-archive.txt:97
#, priority:100
msgid "This can be any options that the archiver backend understands. See next section."
msgstr "这可以是存档器后端能理解的任何选项。 见下一节。"

#. type: Labeled list
#: en/git-archive.txt:98
#, no-wrap, placeholders:'--remote=', priority:100
msgid "--remote=<repo>"
msgstr "--remote=<仓库>"

#. type: Plain text
#: en/git-archive.txt:104
#, priority:100
msgid "Instead of making a tar archive from the local repository, retrieve a tar archive from a remote repository. Note that the remote repository may place restrictions on which sha1 expressions may be allowed in `<tree-ish>`. See linkgit:git-upload-archive[1] for details."
msgstr "与其从本地版本库制作一个 tar 归档，不如从远程版本库检索一个 tar 归档。注意，远程仓库可能会对 `<树状对象>` 中允许的 sha1 表达式进行限制。详情见 linkgit:git-upload-archive[1]。"

#. type: Labeled list
#: en/git-archive.txt:105
#, ignore-same, no-wrap, priority:100
msgid "--exec=<git-upload-archive>"
msgstr "--exec=<git-upload-archive>"

#. type: Plain text
#: en/git-archive.txt:108
#, placeholders:'--remote', priority:100
msgid "Used with --remote to specify the path to the 'git-upload-archive' on the remote side."
msgstr "与 --remote 一起使用，指定远程端的 \"git-upload-archive\" 的路径。"

#. type: Labeled list
#: en/git-archive.txt:109 en/git-checkout.txt:361 en/git-diff-index.txt:26 en/git-diff-tree.txt:29 en/git-ls-tree.txt:38 en/git.txt:402
#, no-wrap, priority:240
msgid "<tree-ish>"
msgstr "<tree-ish>"

#. type: Plain text
#: en/git-archive.txt:111
#, priority:100
msgid "The tree or commit to produce an archive for."
msgstr "要制作存档的树目录或提交。"

#. type: Labeled list
#: en/git-archive.txt:112
#, no-wrap, priority:100
msgid "<path>"
msgstr "<路径>"

#. type: Plain text
#: en/git-archive.txt:116
#, priority:100
msgid "Without an optional path parameter, all files and subdirectories of the current working directory are included in the archive. If one or more paths are specified, only these are included."
msgstr "如果没有可选的路径参数，当前工作目录下的所有文件和子目录都会包括在存档中。 如果指定了一个或多个路径，则只包括这些路径。"

#. type: Title -
#: en/git-archive.txt:118
#, no-wrap, priority:100
msgid "BACKEND EXTRA OPTIONS"
msgstr "后台额外选项"

#. type: Title ~
#: en/git-archive.txt:121
#, no-wrap, priority:100
msgid "zip"
msgstr "zip"

#. type: Labeled list
#: en/git-archive.txt:122
#, no-wrap, priority:100
msgid "-<digit>"
msgstr "-<数字 0-9>"

#. type: Plain text
#: en/git-archive.txt:127
#, priority:100
msgid "Specify compression level. Larger values allow the command to spend more time to compress to smaller size. Supported values are from `-0` (store-only) to `-9` (best ratio). Default is `-6` if not given."
msgstr "指定压缩级别。 较大的值允许命令花费更多的时间来压缩到较小的尺寸。 支持的值从 `-0`（只存储）到 `-9`（最佳比例）。 如果没有给出，默认为 `-6'。"

#. type: Title ~
#: en/git-archive.txt:129
#, no-wrap, priority:100
msgid "tar"
msgstr "tar"

#. type: Labeled list
#: en/git-archive.txt:130 en/rev-list-options.txt:16
#, no-wrap, priority:260
msgid "-<number>"
msgstr "-<数>"

#. type: Plain text
#: en/git-archive.txt:135
#, priority:100
msgid "Specify compression level. The value will be passed to the compression command configured in `tar.<format>.command`. See manual page of the configured command for the list of supported levels and the default level if this option isn't specified."
msgstr "指定压缩级别。该值将被传递给 `tar.<格式>.command` 中配置的压缩命令。如果没有指定这个选项，请参阅配置的命令的手册页，了解支持的级别和默认级别。"

#. type: Labeled list
#: en/git-archive.txt:139
#, no-wrap, placeholders:'tar.umask', priority:100
msgid "tar.umask"
msgstr "tar.umask"

#. type: Plain text
#: en/git-archive.txt:146
#, placeholders:'`--remote`', priority:100
msgid "This variable can be used to restrict the permission bits of tar archive entries. The default is 0002, which turns off the world write bit. The special value \"user\" indicates that the archiving user's umask will be used instead. See umask(2) for details. If `--remote` is used then only the configuration of the remote repository takes effect."
msgstr "这个变量可以用来限制 tar 存档条目的权限位。 默认值是 0002，它关闭了世界写入位。 特殊值 \"user\" 表示将使用归档用户的 umask 来代替。 详情见 umask(2)。 如果使用 `--remote`，那么只有远程仓库的配置才会生效。"

#. type: Labeled list
#: en/git-archive.txt:147
#, no-wrap, priority:100
msgid "tar.<format>.command"
msgstr "tar.<格式>.command"

#. type: Plain text
#: en/git-archive.txt:154
#, priority:100
msgid "This variable specifies a shell command through which the tar output generated by `git archive` should be piped. The command is executed using the shell with the generated tar file on its standard input, and should produce the final output on its standard output. Any compression-level options will be passed to the command (e.g., `-9`)."
msgstr "这个变量指定了一个 shel l命令，由 `git archive` 产生的 tar 输出应该通过管道。该命令使用 shell 执行，在其标准输入中生成 tar 文件，并应在其标准输出中产生最终输出。任何压缩级别的选项将被传递给该命令（例如，`-9'）。"

#. type: Plain text
#: en/git-archive.txt:158
#, placeholders:'tar.gz', priority:100
msgid "The `tar.gz` and `tgz` formats are defined automatically and use the magic command `git archive gzip` by default, which invokes an internal implementation of gzip."
msgstr "`tar.gz` 和 `tgz` 格式是自动定义的，默认使用神奇的命令 `git archive gzip`，它调用了 gzip 的内部实现。"

#. type: Labeled list
#: en/git-archive.txt:159
#, no-wrap, priority:100
msgid "tar.<format>.remote"
msgstr "tar.<格式>.remote"

#. type: Plain text
#: en/git-archive.txt:164
#, placeholders:'tar.gz', priority:100
msgid "If true, enable the format for use by remote clients via linkgit:git-upload-archive[1]. Defaults to false for user-defined formats, but true for the `tar.gz` and `tgz` formats."
msgstr "如果为真，则通过 linkgit:git-upload-archive[1] 启用该格式供远程客户端使用。对于用户定义的格式，默认为 false，但对于 `tar.gz` 和 `tgz` 格式为 true。"

#. type: Title -
#: en/git-archive.txt:167
#, no-wrap, priority:100
msgid "ATTRIBUTES"
msgstr "属性"

#. type: Labeled list
#: en/git-archive.txt:169
#, no-wrap, priority:100
msgid "export-ignore"
msgstr "export-ignore"

#. type: Plain text
#: en/git-archive.txt:172
#, placeholders:'linkgit:gitattributes[5]', priority:100
msgid "Files and directories with the attribute export-ignore won't be added to archive files. See linkgit:gitattributes[5] for details."
msgstr "带有 export-ignore 属性的文件和目录不会被添加到存档文件中。 详情见 linkgit:gitattributes[5]。"

#. type: Labeled list
#: en/git-archive.txt:173
#, no-wrap, priority:100
msgid "export-subst"
msgstr "export-subst"

#. type: Plain text
#: en/git-archive.txt:177
#, placeholders:'linkgit:gitattributes[5]', priority:100
msgid "If the attribute export-subst is set for a file then Git will expand several placeholders when adding this file to an archive. See linkgit:gitattributes[5] for details."
msgstr "如果为一个文件设置了 export-subst 属性，那么当把这个文件添加到存档时，Git 会展开几个占位符。 详情见 linkgit:gitattributes[5]。"

#. type: Plain text
#: en/git-archive.txt:185
#, placeholders:'.gitattributes':'.gitattributes':'.gitattributes':'`--worktree-attributes`':'$GIT_DIR', priority:100
msgid "Note that attributes are by default taken from the `.gitattributes` files in the tree that is being archived. If you want to tweak the way the output is generated after the fact (e.g. you committed without adding an appropriate export-ignore in its `.gitattributes`), adjust the checked out `.gitattributes` file as necessary and use `--worktree-attributes` option. Alternatively you can keep necessary attributes that should apply while archiving any tree in your `$GIT_DIR/info/attributes` file."
msgstr "注意，默认情况下，属性来自被归档的树中的 `.gitattributes` 文件。 如果你想在事后调整输出的方式（例如，你提交时没有在其 `.gitattributes` 中添加适当的 export-ignore ），请根据需要调整检查出来的 `.gitattributes` 文件并使用 `--worktree-attributes` 选项。 另外，你也可以在你的 `$GIT_DIR/info/attributes` 文件中保留归档任何树时应该适用的必要属性。"

#. type: Labeled list
#: en/git-archive.txt:188
#, no-wrap, placeholders:'--format=tar':'--prefix=junk':'HEAD', priority:100
msgid "`git archive --format=tar --prefix=junk/ HEAD | (cd /var/tmp/ && tar xf -)`"
msgstr "`git archive --format=tar --prefix=junk/ HEAD | (cd /var/tmp/ && tar xf -)`"

#. type: Plain text
#: en/git-archive.txt:193
#, priority:100
msgid "Create a tar archive that contains the contents of the latest commit on the current branch, and extract it in the `/var/tmp/junk` directory."
msgstr "创建一个包含当前分支上最新提交内容的 tar 归档文件，并将其解压到 `/var/tmp/junk` 目录中。"

#. type: Labeled list
#: en/git-archive.txt:194
#, no-wrap, placeholders:'--format=tar':'--prefix=git-1':'tar.gz', priority:100
msgid "`git archive --format=tar --prefix=git-1.4.0/ v1.4.0 | gzip >git-1.4.0.tar.gz`"
msgstr "`git archive --format=tar --prefix=git-1.4.0/ v1.4.0 | gzip >git-1.4.0.tar.gz`"

#. type: Plain text
#: en/git-archive.txt:197
#, priority:100
msgid "Create a compressed tarball for v1.4.0 release."
msgstr "为 v1.4.0 版本创建一个压缩的压缩包。"

#. type: Labeled list
#: en/git-archive.txt:198
#, no-wrap, placeholders:'--format=tar':'--prefix=git-1':'tar.gz', priority:100
msgid "`git archive --format=tar.gz --prefix=git-1.4.0/ v1.4.0 >git-1.4.0.tar.gz`"
msgstr "`git archive --format=tar.gz --prefix=git-1.4.0/ v1.4.0 >git-1.4.0.tar.gz`"

#. type: Plain text
#: en/git-archive.txt:201
#, placeholders:'tar.gz', priority:100
msgid "Same as above, but using the builtin tar.gz handling."
msgstr "和上面一样，但使用内置的 tar.gz 处理。"

#. type: Labeled list
#: en/git-archive.txt:202
#, no-wrap, placeholders:'--prefix=git-1':'tar.gz', priority:100
msgid "`git archive --prefix=git-1.4.0/ -o git-1.4.0.tar.gz v1.4.0`"
msgstr "`git archive --prefix=git-1.4.0/ -o git-1.4.0.tar.gz v1.4.0`"

#. type: Plain text
#: en/git-archive.txt:205
#, priority:100
msgid "Same as above, but the format is inferred from the output file."
msgstr "与上述相同，但格式是从输出文件中推断出来的。"

#. type: Labeled list
#: en/git-archive.txt:206
#, no-wrap, placeholders:'--format=tar':'--prefix=git-1':'{tree}':'tar.gz', priority:100
msgid "`git archive --format=tar --prefix=git-1.4.0/ v1.4.0^{tree} | gzip >git-1.4.0.tar.gz`"
msgstr "`git archive --format=tar --prefix=git-1.4.0/ v1.4.0^{tree} | gzip >git-1.4.0.tar.gz`"

#. type: Plain text
#: en/git-archive.txt:210
#, priority:100
msgid "Create a compressed tarball for v1.4.0 release, but without a global extended pax header."
msgstr "为 v1.4.0 版本创建一个压缩的 tarball，但没有全局扩展的 pax 头。"

#. type: Labeled list
#: en/git-archive.txt:211
#, no-wrap, placeholders:'--format=zip':'--prefix=git-docs':'HEAD':'docs.zip', priority:100
msgid "`git archive --format=zip --prefix=git-docs/ HEAD:Documentation/ > git-1.4.0-docs.zip`"
msgstr "`git archive --format=zip --prefix=git-docs/ HEAD:Documentation/ > git-1.4.0-docs.zip`"

#. type: Plain text
#: en/git-archive.txt:215
#, placeholders:'docs.zip':'git-docs', priority:100
msgid "Put everything in the current head's Documentation/ directory into 'git-1.4.0-docs.zip', with the prefix 'git-docs/'."
msgstr "将当前头文件或目录下的所有内容放入 'git-1.4.0-docs.zip'，前缀为 'git-docs/'。"

#. type: Labeled list
#: en/git-archive.txt:216
#, no-wrap, placeholders:'latest.zip':'HEAD', priority:100
msgid "`git archive -o latest.zip HEAD`"
msgstr "`git archive -o latest.zip HEAD`"

#. type: Plain text
#: en/git-archive.txt:221
#, priority:100
msgid "Create a Zip archive that contains the contents of the latest commit on the current branch. Note that the output format is inferred by the extension of the output file."
msgstr "创建一个包含当前分支上最新提交内容的 Zip 档案。注意，输出格式是由输出文件的扩展名推断出来的。"

#. type: Labeled list
#: en/git-archive.txt:222
#, no-wrap, placeholders:'latest.tar':'--prefix=build':'--add-file=configure':'--prefix=':'HEAD', priority:100
msgid "`git archive -o latest.tar --prefix=build/ --add-file=configure --prefix= HEAD`"
msgstr "`git archive -o latest.tar --prefix=build/ --add-file=configure --prefix= HEAD`"

#. type: Plain text
#: en/git-archive.txt:227
#, priority:100
msgid "Creates a tar archive that contains the contents of the latest commit on the current branch with no prefix and the untracked file 'configure' with the prefix 'build/'."
msgstr "创建一个 tar 归档文件，其中包含当前分支上的最新提交内容，无前缀，以及无跟踪的文件 'configure'，前缀为 'build/'。"

#. type: Labeled list
#: en/git-archive.txt:228
#, no-wrap, placeholders:'tar.tar.xz.command', priority:100
msgid "`git config tar.tar.xz.command \"xz -c\"`"
msgstr "`git config tar.tar.xz.command \"xz -c\"`"

#. type: Plain text
#: en/git-archive.txt:233
#, placeholders:'tar.xz':'`--format=tar':'foo.tar.xz', priority:100
msgid "Configure a \"tar.xz\" format for making LZMA-compressed tarfiles. You can use it specifying `--format=tar.xz`, or by creating an output file like `-o foo.tar.xz`."
msgstr "配置一个 \"tar.xz\" 格式来制作 LZMA 压缩的 tarf 文件。 你可以指定 `--format=tar.xz` 来使用它，或者通过创建一个像 `-o foo.tar.xz` 这样的输出文件。"

#. type: Title =
#: en/git-bisect.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-bisect(1)"
msgstr "git-bisect(1)"

#. type: Plain text
#: en/git-bisect.txt:7
#, placeholders:'git-bisect', priority:100
msgid "git-bisect - Use binary search to find the commit that introduced a bug"
msgstr "git-bisect - 使用二进制搜索查找引入错误的提交"

#. type: Plain text
#: en/git-bisect.txt:13
#, no-wrap, priority:100
msgid "'git bisect' <subcommand> <options>\n"
msgstr "'git bisect' <子命令> <选项>\n"

#. type: Plain text
#: en/git-bisect.txt:18 en/git-reflog.txt:34
#, priority:100
msgid "The command takes various subcommands, and different options depending on the subcommand:"
msgstr "该命令采取不同的子命令，并根据子命令有不同的选项："

#. type: Plain text
#: en/git-bisect.txt:31
#, ignore-ellipsis, no-wrap, placeholders:'[--term-':'--term-':'[--no-checkout]':'[--first-parent]':'[--term-good':'--term-bad]', priority:100
msgid ""
" git bisect start [--term-(new|bad)=<term-new> --term-(old|good)=<term-old>]\n"
"\t\t  [--no-checkout] [--first-parent] [<bad> [<good>...]] [--] [<pathspec>...]\n"
" git bisect (bad|new|<term-new>) [<rev>]\n"
" git bisect (good|old|<term-old>) [<rev>...]\n"
" git bisect terms [--term-good | --term-bad]\n"
" git bisect skip [(<rev>|<range>)...]\n"
" git bisect reset [<commit>]\n"
" git bisect (visualize|view)\n"
" git bisect replay <logfile>\n"
" git bisect log\n"
" git bisect run <cmd> [<arg>...]\n"
" git bisect help\n"
msgstr ""
" git bisect start [--term-{new,bad}=<term> --term-{old,good}=<term>]\n"
"\t\t  [--no-checkout] [--first-parent] [<坏的> [<好的>...]] [--] [<路径规范>...]\n"
" git bisect (bad|new|<新 term>) [<修订>]\n"
" git bisect (good|old|<旧 term>) [<修订>...]\n"
" git bisect terms [--term-good | --term-bad]\n"
" git bisect skip [(<修订>|<范围>)...]\n"
" git bisect reset [<提交>]\n"
" git bisect (visualize|view)\n"
" git bisect replay <日志文件>\n"
" git bisect log\n"
" git bisect run <命令>...\n"
" git bisect help\n"

#. type: Plain text
#: en/git-bisect.txt:40
#, priority:100
msgid "This command uses a binary search algorithm to find which commit in your project's history introduced a bug. You use it by first telling it a \"bad\" commit that is known to contain the bug, and a \"good\" commit that is known to be before the bug was introduced. Then `git bisect` picks a commit between those two endpoints and asks you whether the selected commit is \"good\" or \"bad\". It continues narrowing down the range until it finds the exact commit that introduced the change."
msgstr "这个命令使用二分搜索算法来查找项目历史中哪个提交引入了一个错误。使用该命令时，首先告诉它一个已知包含错误的 \"坏\" 提交，以及一个已知在错误出现之前的 \"好\" 提交。然后 `git bisect` 在这两个端点之间挑选一个提交，并询问你所选的提交是 \"好\" 还是 \"坏\"。它继续缩小范围，直到找到引入该修改的确切提交。"

#. type: Plain text
#: en/git-bisect.txt:47
#, priority:100
msgid "In fact, `git bisect` can be used to find the commit that changed *any* property of your project; e.g., the commit that fixed a bug, or the commit that caused a benchmark's performance to improve. To support this more general usage, the terms \"old\" and \"new\" can be used in place of \"good\" and \"bad\", or you can choose your own terms. See section \"Alternate terms\" below for more information."
msgstr "事实上，`git bisect` 可以用来查找改变项目 *任何* 属性的提交；例如，修复了一个 bug 的提交，或者使一个基准的性能得到改善的提交。为了支持这种更普遍的用法，可以用 \"old\" 和 \"new\" 来代替 \"good\" 和 \"bad\"，或者您可以选择自己的术语。更多信息见下文 \"替代术语 \"一节。"

#. type: Title ~
#: en/git-bisect.txt:49
#, no-wrap, priority:100
msgid "Basic bisect commands: start, bad, good"
msgstr "基本的二分命令：start, bad, good"

#. type: Plain text
#: en/git-bisect.txt:54
#, priority:100
msgid "As an example, suppose you are trying to find the commit that broke a feature that was known to work in version `v2.6.13-rc2` of your project. You start a bisect session as follows:"
msgstr "举个例子，假设你想找到破坏了一个已知在你的项目的 `v2.6.13-rc2` 版本中工作的特性的提交。你启动了一个 bisect 会话，如下所示："

#. type: delimited block -
#: en/git-bisect.txt:59
#, no-wrap, priority:100
msgid ""
"$ git bisect start\n"
"$ git bisect bad                 # Current version is bad\n"
"$ git bisect good v2.6.13-rc2    # v2.6.13-rc2 is known to be good\n"
msgstr ""
"$ git bisect start\n"
"$ git bisect bad                 # 当前版本是坏的\n"
"$ git bisect good v2.6.13-rc2    # v2.6.13-rc2 已知为好\n"

#. type: Plain text
#: en/git-bisect.txt:64
#, priority:100
msgid "Once you have specified at least one bad and one good commit, `git bisect` selects a commit in the middle of that range of history, checks it out, and outputs something similar to the following:"
msgstr "一旦你指定了至少一个坏的和一个好的提交，`git bisect` 就会在这个历史范围的中间选择一个提交，检查它，并输出类似于以下的内容："

#. type: delimited block -
#: en/git-bisect.txt:67
#, no-wrap, priority:100
msgid "Bisecting: 675 revisions left to test after this (roughly 10 steps)\n"
msgstr "Bisecting: 675 revisions left to test after this (roughly 10 steps) | 在这之后，还有675次修订需要测试（大约10步）\n"

#. type: Plain text
#: en/git-bisect.txt:71
#, priority:100
msgid "You should now compile the checked-out version and test it. If that version works correctly, type"
msgstr "你现在应该编译检出的版本并进行测试。如果该版本工作正常，请输入"

#. type: delimited block -
#: en/git-bisect.txt:74
#, no-wrap, priority:100
msgid "$ git bisect good\n"
msgstr "$ git bisect good\n"

#. type: Plain text
#: en/git-bisect.txt:77
#, priority:100
msgid "If that version is broken, type"
msgstr "如果该版本被破坏，请输入"

#. type: delimited block -
#: en/git-bisect.txt:80
#, no-wrap, priority:100
msgid "$ git bisect bad\n"
msgstr "$ git bisect bad\n"

#. type: Plain text
#: en/git-bisect.txt:83
#, priority:100
msgid "Then `git bisect` will respond with something like"
msgstr "然后，`git bisect`会做出如下反应"

#. type: delimited block -
#: en/git-bisect.txt:86
#, no-wrap, priority:100
msgid "Bisecting: 337 revisions left to test after this (roughly 9 steps)\n"
msgstr "Bisecting: 337 revisions left to test after this (roughly 9 steps) | 在这之后还有337个修订要测试（大约9个步骤）。\n"

#. type: Plain text
#: en/git-bisect.txt:91
#, priority:100
msgid "Keep repeating the process: compile the tree, test it, and depending on whether it is good or bad run `git bisect good` or `git bisect bad` to ask for the next commit that needs testing."
msgstr "不断重复这个过程：编译树，测试它，根据它是好是坏，运行 `git bisect good` 或 `git bisect bad` 来要求下一个需要测试的提交。"

#. type: Plain text
#: en/git-bisect.txt:95
#, priority:100
msgid "Eventually there will be no more revisions left to inspect, and the command will print out a description of the first bad commit. The reference `refs/bisect/bad` will be left pointing at that commit."
msgstr "最终，将没有更多的修订可以检查，该命令将打印出第一个坏提交的描述。引用 `refs/bisect/bad` 将被留在该提交处。"

#. type: Title ~
#: en/git-bisect.txt:98
#, no-wrap, priority:100
msgid "Bisect reset"
msgstr "重置二分查找"

#. type: Plain text
#: en/git-bisect.txt:102
#, placeholders:'HEAD', priority:100
msgid "After a bisect session, to clean up the bisection state and return to the original HEAD, issue the following command:"
msgstr "在一个二分查找会话之后，要清理二分查找状态并返回到原来的 HEAD，请发出以下命令："

#. type: delimited block -
#: en/git-bisect.txt:105
#, no-wrap, priority:100
msgid "$ git bisect reset\n"
msgstr "$ git bisect reset\n"

#. type: Plain text
#: en/git-bisect.txt:110
#, priority:100
msgid "By default, this will return your tree to the commit that was checked out before `git bisect start`. (A new `git bisect start` will also do that, as it cleans up the old bisection state.)"
msgstr "默认情况下，这将使你的树返回到 `git bisect start` 之前检查出来的提交。 (新的 `git bisect start` 也会这样做，因为它清理了旧的分界状态）"

#. type: Plain text
#: en/git-bisect.txt:113
#, priority:100
msgid "With an optional argument, you can return to a different commit instead:"
msgstr "通过一个可选参数，你可以返回到一个不同的提交，而不是："

#. type: delimited block -
#: en/git-bisect.txt:116
#, no-wrap, priority:100
msgid "$ git bisect reset <commit>\n"
msgstr "$ git bisect reset <提交>\n"

#. type: Plain text
#: en/git-bisect.txt:121
#, placeholders:'HEAD', priority:100
msgid "For example, `git bisect reset bisect/bad` will check out the first bad revision, while `git bisect reset HEAD` will leave you on the current bisection commit and avoid switching commits at all."
msgstr "例如，`git bisect reset bisect/bad` 会检查出第一个坏的修订，而 `git bisect reset HEAD` 会让你停留在当前的分界提交上，完全避免切换提交。"

#. type: Title ~
#: en/git-bisect.txt:124
#, no-wrap, priority:100
msgid "Alternate terms"
msgstr "替代条款"

#. type: Plain text
#: en/git-bisect.txt:132
#, priority:100
msgid "Sometimes you are not looking for the commit that introduced a breakage, but rather for a commit that caused a change between some other \"old\" state and \"new\" state. For example, you might be looking for the commit that introduced a particular fix. Or you might be looking for the first commit in which the source-code filenames were finally all converted to your company's naming standard. Or whatever."
msgstr "有时，您要找的不是引入断裂的提交，而是在其他 \"旧\" 状态和 \"新\" 状态之间引起变化的提交。例如，你可能要找的是引入某项修复的提交。或者你想找的是第一次提交，在这次提交中，源代码文件名最终都被转换为你公司的命名标准。或者其他什么。"

#. type: Plain text
#: en/git-bisect.txt:138
#, priority:100
msgid "In such cases it can be very confusing to use the terms \"good\" and \"bad\" to refer to \"the state before the change\" and \"the state after the change\". So instead, you can use the terms \"old\" and \"new\", respectively, in place of \"good\" and \"bad\". (But note that you cannot mix \"good\" and \"bad\" with \"old\" and \"new\" in a single session.)"
msgstr "在这种情况下，用 “好” 和 “坏” 来指代 “变化前的状态” 和 “变化后的状态” 会非常混乱。因此，你可以用 “旧” 和 “新” 来代替 “好” 和 “坏”。(但要注意，你不能在一个会话中把 “好” 和 “坏” 与 “旧” 和 “新” 混在一起。）"

#. type: Plain text
#: en/git-bisect.txt:145
#, priority:100
msgid "In this more general usage, you provide `git bisect` with a \"new\" commit that has some property and an \"old\" commit that doesn't have that property. Each time `git bisect` checks out a commit, you test if that commit has the property. If it does, mark the commit as \"new\"; otherwise, mark it as \"old\". When the bisection is done, `git bisect` will report which commit introduced the property."
msgstr "在这种更普遍的用法中，你向 `git bisect` 提供了一个具有某种属性的 \"新\" 提交和一个不具有该属性的 \"旧\" 提交。每次 `git bisect` 检查一个提交时，都要测试该提交是否具有该属性。如果有，则将该提交标记为 \"新\"；否则，标记为 \"旧\"。分割完成后，`git bisect` 会报告哪个提交引入了该属性。"

#. type: Plain text
#: en/git-bisect.txt:149
#, priority:100
msgid "To use \"old\" and \"new\" instead of \"good\" and bad, you must run `git bisect start` without commits as argument and then run the following commands to add the commits:"
msgstr "要使用 \"旧\" 和 \"新\"，而不是 \"好\" 和 \"坏\"，你必须运行 `git bisect start`，而不以提交为参数，然后运行以下命令来添加提交："

#. type: delimited block -
#: en/git-bisect.txt:152
#, no-wrap, priority:100
msgid "git bisect old [<rev>]\n"
msgstr "git bisect old [<修订>]\n"

#. type: Plain text
#: en/git-bisect.txt:155
#, priority:100
msgid "to indicate that a commit was before the sought change, or"
msgstr "表明提交时间在所寻求的变更之前，或"

#. type: delimited block -
#: en/git-bisect.txt:158
#, ignore-ellipsis, no-wrap, priority:100
msgid "git bisect new [<rev>...]\n"
msgstr "git bisect new [<修订>...]\n"

#. type: Plain text
#: en/git-bisect.txt:161
#, priority:100
msgid "to indicate that it was after."
msgstr "以表明它是在之后。"

#. type: Plain text
#: en/git-bisect.txt:163
#, priority:100
msgid "To get a reminder of the currently used terms, use"
msgstr "要获得当前使用的术语的提醒，请使用"

#. type: delimited block -
#: en/git-bisect.txt:166
#, no-wrap, priority:100
msgid "git bisect terms\n"
msgstr "git bisect terms\n"

#. type: Plain text
#: en/git-bisect.txt:170
#, placeholders:'--term-old`':'--term-good`', priority:100
msgid "You can get just the old (respectively new) term with `git bisect terms --term-old` or `git bisect terms --term-good`."
msgstr "你可以用 `git bisect terms --term-old` 或 `git bisect terms --term-good` 只得到旧的（分别是新的）术语。"

#. type: Plain text
#: en/git-bisect.txt:175
#, ignore-ellipsis, priority:100
msgid "If you would like to use your own terms instead of \"bad\"/\"good\" or \"new\"/\"old\", you can choose any names you like (except existing bisect subcommands like `reset`, `start`, ...) by starting the bisection using"
msgstr "如果你想使用你自己的术语，而不是 \"坏\" / \"好 \" 或 \"新\" / \"旧\"，你可以选择任何你喜欢的名字（除了现有的 bisect 子命令如 `reset`，`start`，......），通过使用以下命令启动 bisection"

#. type: delimited block -
#: en/git-bisect.txt:178
#, no-wrap, placeholders:'--term-old':'--term-new', priority:100
msgid "git bisect start --term-old <term-old> --term-new <term-new>\n"
msgstr "git bisect start --term-old <旧 term> --term-new <新 term>\n"

#. type: Plain text
#: en/git-bisect.txt:182
#, priority:100
msgid "For example, if you are looking for a commit that introduced a performance regression, you might use"
msgstr "例如，如果你要找一个引入性能回归的提交，你可以用"

#. type: delimited block -
#: en/git-bisect.txt:185
#, no-wrap, placeholders:'--term-old':'--term-new', priority:100
msgid "git bisect start --term-old fast --term-new slow\n"
msgstr "git bisect start --term-old fast --term-new slow\n"

#. type: Plain text
#: en/git-bisect.txt:188
#, priority:100
msgid "Or if you are looking for the commit that fixed a bug, you might use"
msgstr "或者，如果你要找的是修复了某个错误的提交，你可以使用"

#. type: delimited block -
#: en/git-bisect.txt:191
#, no-wrap, placeholders:'--term-new':'--term-old', priority:100
msgid "git bisect start --term-new fixed --term-old broken\n"
msgstr "git bisect start --term-new fixed --term-old broken\n"

#. type: Plain text
#: en/git-bisect.txt:195
#, priority:100
msgid "Then, use `git bisect <term-old>` and `git bisect <term-new>` instead of `git bisect good` and `git bisect bad` to mark commits."
msgstr "然后，用`git bisect <term-old>` 和 `git bisect <term-new>` 代替 `git bisect good` 和`git bisect bad` 来标记提交。"

#. type: Title ~
#: en/git-bisect.txt:197
#, no-wrap, priority:100
msgid "Bisect visualize/view"
msgstr "视觉化/视图的二分查找"

#. type: Plain text
#: en/git-bisect.txt:202
#, priority:100
msgid "To see the currently remaining suspects in 'gitk', issue the following command during the bisection process (the subcommand `view` can be used as an alternative to `visualize`):"
msgstr "要查看 'gitk' 中当前剩余的嫌疑人，在二分查找过程中发出以下命令（子命令`view`可以用来替代`visualize`）："

#. type: delimited block -
#: en/git-bisect.txt:205
#, no-wrap, priority:100
msgid "$ git bisect visualize\n"
msgstr "$ git bisect visualize\n"

#. type: Plain text
#: en/git-bisect.txt:212
#, priority:100
msgid "Git detects a graphical environment through various environment variables: `DISPLAY`, which is set in X Window System environments on Unix systems. `SESSIONNAME`, which is set under Cygwin in interactive desktop sessions. `MSYSTEM`, which is set under Msys2 and Git for Windows. `SECURITYSESSIONID`, which may be set on macOS in interactive desktop sessions."
msgstr "Git 通过各种环境变量检测图形环境：`DISPLAY`，在 Unix 系统的 X 窗口系统环境中设置。 `SESSIONNAME` （会话名），在 Cygwin 下的交互式桌面会话中设置。 `MSYSTEM`，在 Msys2 和 Git for Windows 下设置。 `SECURITYSESSIONID`，可在 macOS 上的交互式桌面会话中设置。"

#. type: Plain text
#: en/git-bisect.txt:215
#, placeholders:'`-p`':'`--stat`', priority:100
msgid "If none of these environment variables is set, 'git log' is used instead. You can also give command-line options such as `-p` and `--stat`."
msgstr "如果没有设置这些环境变量，则会使用 'git log'。 您也可以提供命令行选项，如 `-p` 和 `--stat`。"

#. type: delimited block -
#: en/git-bisect.txt:218
#, no-wrap, placeholders:'--stat', priority:100
msgid "$ git bisect visualize --stat\n"
msgstr "$ git bisect visualize --stat\n"

#. type: Title ~
#: en/git-bisect.txt:221
#, no-wrap, priority:100
msgid "Bisect log and bisect replay"
msgstr "二分查找日志和重放二分查找"

#. type: Plain text
#: en/git-bisect.txt:225
#, priority:100
msgid "After having marked revisions as good or bad, issue the following command to show what has been done so far:"
msgstr "在将修订标记为好的或坏的之后，发出以下命令来显示到目前为止所做的事情："

#. type: delimited block -
#: en/git-bisect.txt:228
#, no-wrap, priority:100
msgid "$ git bisect log\n"
msgstr "$ git bisect log\n"

#. type: Plain text
#: en/git-bisect.txt:234
#, priority:100
msgid "If you discover that you made a mistake in specifying the status of a revision, you can save the output of this command to a file, edit it to remove the incorrect entries, and then issue the following commands to return to a corrected state:"
msgstr "如果你发现你在指定修订版的状态时犯了错误，你可以把这个命令的输出保存到一个文件中，编辑它以删除不正确的条目，然后发出下面的命令来返回到一个正确的状态："

#. type: delimited block -
#: en/git-bisect.txt:238
#, no-wrap, priority:100
msgid ""
"$ git bisect reset\n"
"$ git bisect replay that-file\n"
msgstr ""
"$ git bisect reset\n"
"$ git bisect replay that-file\n"

#. type: Title ~
#: en/git-bisect.txt:241
#, no-wrap, priority:100
msgid "Avoiding testing a commit"
msgstr "避免测试一个提交"

#. type: Plain text
#: en/git-bisect.txt:248
#, priority:100
msgid "If, in the middle of a bisect session, you know that the suggested revision is not a good one to test (e.g. it fails to build and you know that the failure does not have anything to do with the bug you are chasing), you can manually select a nearby commit and test that one instead."
msgstr "如果在二分查找会话中，你知道建议的修订版不是一个好的测试对象（例如，它不能构建，而你知道这个失败与你正在追寻的错误无关），你可以手动选择一个附近的提交，并测试该提交。"

#. type: Plain text
#: en/git-bisect.txt:250 en/git-name-rev.txt:53 en/git-tag.txt:377 en/git-bisect-lk2009.txt:914 en/git-bisect-lk2009.txt:1136 en/git-bisect-lk2009.txt:1152 en/git-bisect-lk2009.txt:1175
#, priority:240
msgid "For example:"
msgstr "例如："

#. type: delimited block -
#: en/git-bisect.txt:257
#, no-wrap, placeholders:'--hard':'HEAD', priority:100
msgid ""
"$ git bisect good/bad\t\t\t# previous round was good or bad.\n"
"Bisecting: 337 revisions left to test after this (roughly 9 steps)\n"
"$ git bisect visualize\t\t\t# oops, that is uninteresting.\n"
"$ git reset --hard HEAD~3\t\t# try 3 revisions before what\n"
"\t\t\t\t\t# was suggested\n"
msgstr ""
"$ git bisect good/bad\t\t\t# 上一轮是好是坏。\n"
"Bisecting: 337 revisions left to test after this (roughly 9 steps)\n"
"$ git bisect visualize\t\t\t# 哎呀，真没意思。\n"
"$ git reset --hard HEAD~3\t\t# 尝试 3 次修改，然后再\n"
"\t\t\t\t\t# 建议\n"

#. type: Plain text
#: en/git-bisect.txt:261
#, priority:100
msgid "Then compile and test the chosen revision, and afterwards mark the revision as good or bad in the usual manner."
msgstr "然后编译和测试所选择的修订版，之后以通常的方式将修订版标记为好或坏。"

#. type: Title ~
#: en/git-bisect.txt:263
#, no-wrap, priority:100
msgid "Bisect skip"
msgstr "跳过二分查找"

#. type: Plain text
#: en/git-bisect.txt:267
#, priority:100
msgid "Instead of choosing a nearby commit by yourself, you can ask Git to do it for you by issuing the command:"
msgstr "与其自己选择附近的提交，你可以通过发布命令让 Git 为你做这件事："

#. type: delimited block -
#: en/git-bisect.txt:270
#, no-wrap, priority:100
msgid "$ git bisect skip                 # Current version cannot be tested\n"
msgstr "$ git bisect skip                                # 当前版本不能被测试\n"

#. type: Plain text
#: en/git-bisect.txt:275
#, priority:100
msgid "However, if you skip a commit adjacent to the one you are looking for, Git will be unable to tell exactly which of those commits was the first bad one."
msgstr "然而，如果你跳过了与你要找的提交相邻的提交，Git 将无法准确判断出哪个提交是第一个坏提交。"

#. type: Plain text
#: en/git-bisect.txt:278
#, priority:100
msgid "You can also skip a range of commits, instead of just one commit, using range notation. For example:"
msgstr "您也可以使用范围符号跳过一系列的提交，而不仅仅是一个提交。比如说："

#. type: delimited block -
#: en/git-bisect.txt:281
#, no-wrap, priority:100
msgid "$ git bisect skip v2.5..v2.6\n"
msgstr "$ git bisect skip v2.5..v2.6\n"

#. type: Plain text
#: en/git-bisect.txt:285
#, priority:100
msgid "This tells the bisect process that no commit after `v2.5`, up to and including `v2.6`, should be tested."
msgstr "这告诉二分查找进程，`v2.5` 之后的提交，包括 `v2.6`，都不应该被测试。"

#. type: Plain text
#: en/git-bisect.txt:288
#, priority:100
msgid "Note that if you also want to skip the first commit of the range you would issue the command:"
msgstr "请注意，如果你也想跳过范围内的第一个提交，你会发出这个命令："

#. type: delimited block -
#: en/git-bisect.txt:291
#, no-wrap, priority:100
msgid "$ git bisect skip v2.5 v2.5..v2.6\n"
msgstr "$ git bisect skip v2.5 v2.5..v2.6\n"

#. type: Plain text
#: en/git-bisect.txt:295
#, priority:100
msgid "This tells the bisect process that the commits between `v2.5` and `v2.6` (inclusive) should be skipped."
msgstr "这告诉二分查找进程，应该跳过 `v2.5` 和 `v2.6`（包括）之间的提交。"

#. type: Title ~
#: en/git-bisect.txt:298
#, no-wrap, priority:100
msgid "Cutting down bisection by giving more parameters to bisect start"
msgstr "通过提供更多的参数来削减二分查找的起点"

#. type: Plain text
#: en/git-bisect.txt:303
#, priority:100
msgid "You can further cut down the number of trials, if you know what part of the tree is involved in the problem you are tracking down, by specifying pathspec parameters when issuing the `bisect start` command:"
msgstr "如果你知道你要追踪的问题涉及到树的哪一部分，你可以通过在发出 `bisect start` 命令时指定路径参数来进一步减少试验的数量："

#. type: delimited block -
#: en/git-bisect.txt:306
#, no-wrap, priority:100
msgid "$ git bisect start -- arch/i386 include/asm-i386\n"
msgstr "$ git bisect start -- arch/i386 include/asm-i386\n"

#. type: Plain text
#: en/git-bisect.txt:311
#, priority:100
msgid "If you know beforehand more than one good commit, you can narrow the bisect space down by specifying all of the good commits immediately after the bad commit when issuing the `bisect start` command:"
msgstr "如果你事先知道有一个以上的好的提交，你可以在发出 `bisect start ` 命令时，指定坏的提交之后的所有好的提交，从而缩小二分查找的空间："

#. type: delimited block -
#: en/git-bisect.txt:316
#, no-wrap, priority:100
msgid ""
"$ git bisect start v2.6.20-rc6 v2.6.20-rc4 v2.6.20-rc1 --\n"
"                   # v2.6.20-rc6 is bad\n"
"                   # v2.6.20-rc4 and v2.6.20-rc1 are good\n"
msgstr ""
"$ git bisect start v2.6.20-rc6 v2.6.20-rc4 v2.6.20-rc1 --\n"
"                   # v2.6.20-rc6 是坏的\n"
"                   # v2.6.20-rc4 和 v2.6.20-rc1 都是好的\n"

#. type: Title ~
#: en/git-bisect.txt:319
#, no-wrap, priority:100
msgid "Bisect run"
msgstr "运行二分查找"

#. type: Plain text
#: en/git-bisect.txt:323
#, priority:100
msgid "If you have a script that can tell if the current source code is good or bad, you can bisect by issuing the command:"
msgstr "如果你有一个脚本，可以知道当前的源代码是好是坏，你可以通过发出命令来进行二分查找："

#. type: delimited block -
#: en/git-bisect.txt:326
#, no-wrap, priority:100
msgid "$ git bisect run my_script arguments\n"
msgstr "$ git bisect run my_script arguments\n"

#. type: Plain text
#: en/git-bisect.txt:332
#, priority:100
msgid "Note that the script (`my_script` in the above example) should exit with code 0 if the current source code is good/old, and exit with a code between 1 and 127 (inclusive), except 125, if the current source code is bad/new."
msgstr "注意，如果当前的源代码是好的或是旧的，脚本（上面例子中的 `my_script`）应该以代码 0 退出，如果当前的源代码是坏的或是新的，则以代码 1到 127（包括）之间退出，但 125 除外。"

#. type: Plain text
#: en/git-bisect.txt:336
#, priority:100
msgid "Any other exit code will abort the bisect process. It should be noted that a program that terminates via `exit(-1)` leaves $? = 255, (see the exit(3) manual page), as the value is chopped with `& 0377`."
msgstr "任何其他的退出代码都会中止二分查找进程。应该注意的是，通过 `exit(-1)` 终止的程序会留下 $? = 255，（见 exit(3) 手册页），因为这个值是用 `& 0377` 砍掉的。"

#. type: Plain text
#: en/git-bisect.txt:345
#, priority:100
msgid "The special exit code 125 should be used when the current source code cannot be tested. If the script exits with this code, the current revision will be skipped (see `git bisect skip` above). 125 was chosen as the highest sensible value to use for this purpose, because 126 and 127 are used by POSIX shells to signal specific error status (127 is for command not found, 126 is for command found but not executable--these details do not matter, as they are normal errors in the script, as far as `bisect run` is concerned)."
msgstr "当当前的源代码不能被测试时，应该使用特殊的退出代码 125。如果脚本以这个代码退出，当前的修订版将被跳过（见上面的 `git bisect skip`）。125 被选为用于此目的的最高合理值，因为 126 和 127 被 POSIX shells 用来表示特定的错误状态（127 表示未找到命令，126 表示找到命令但不可执行——这些细节并不重要，因为就 `bisect run` 而言，它们是脚本中的正常错误）。"

#. type: Plain text
#: en/git-bisect.txt:351
#, priority:100
msgid "You may often find that during a bisect session you want to have temporary modifications (e.g. s/#define DEBUG 0/#define DEBUG 1/ in a header file, or \"revision that does not have this commit needs this patch applied to work around another problem this bisection is not interested in\") applied to the revision being tested."
msgstr "你可能经常发现，在一个二分查找会话中，你想让临时的修改（例如，头文件中的 /#define DEBUG 0/#define DEBUG 1/，或者 “没有这个提交的版本需要应用这个补丁来解决这个查找不感兴趣的另一个问题”）应用到正在测试的版本中。"

#. type: Plain text
#: en/git-bisect.txt:359
#, priority:100
msgid "To cope with such a situation, after the inner 'git bisect' finds the next revision to test, the script can apply the patch before compiling, run the real test, and afterwards decide if the revision (possibly with the needed patch) passed the test and then rewind the tree to the pristine state. Finally the script should exit with the status of the real test to let the `git bisect run` command loop determine the eventual outcome of the bisect session."
msgstr "为了应对这种情况，在内部的 'git bisect' 找到要测试的下一个修订版后，脚本可以在编译前应用补丁，运行真正的测试，之后决定该修订版（可能有需要的补丁）是否通过测试，然后将树倒回原始状态。 最后，脚本应该以真实测试的状态退出，让 `git bisect run` 命令循环决定二分查找会话的最终结果。"

#. type: Labeled list
#: en/git-bisect.txt:362 en/git-clone.txt:154
#, ignore-same, no-wrap, priority:300
msgid "--no-checkout"
msgstr "--no-checkout"

#. type: Plain text
#: en/git-bisect.txt:367
#, placeholders:'BISECT_HEAD', priority:100
msgid "Do not checkout the new working tree at each iteration of the bisection process. Instead just update the reference named `BISECT_HEAD` to make it point to the commit that should be tested."
msgstr "在二分查找过程的每个迭代中，不要检出新的工作区。相反，只需更新一个名为 `BISECT_HEAD` 的引用，使其指向应被测试的提交。"

#. type: Plain text
#: en/git-bisect.txt:370
#, priority:100
msgid "This option may be useful when the test you would perform in each step does not require a checked out tree."
msgstr "当你在每个步骤中执行的测试不需要检查出来的目录树时，这个选项可能很有用。"

#. type: Plain text
#: en/git-bisect.txt:372
#, placeholders:'`--no-checkout`', priority:100
msgid "If the repository is bare, `--no-checkout` is assumed."
msgstr "如果版本库是裸仓库，则假定 `--no-checkout`。"

#. type: Plain text
#: en/git-bisect.txt:376
#, priority:100
msgid "Follow only the first parent commit upon seeing a merge commit."
msgstr "在看到合并提交时，只跟随第一个父提交。"

#. type: Plain text
#: en/git-bisect.txt:380
#, priority:100
msgid "In detecting regressions introduced through the merging of a branch, the merge commit will be identified as introduction of the bug and its ancestors will be ignored."
msgstr "在检测通过合并分支引入的回归时，合并后的提交将被识别为引入了该错误，其祖先将被忽略。"

#. type: Plain text
#: en/git-bisect.txt:383
#, priority:100
msgid "This option is particularly useful in avoiding false positives when a merged branch contained broken or non-buildable commits, but the merge itself was OK."
msgstr "这个选项在避免假阳性方面特别有用，当一个合并的分支包含有破损或不可构建的提交，但合并本身是正常的。"

#. type: Plain text
#: en/git-bisect.txt:388
#, placeholders:'HEAD', priority:100
msgid "Automatically bisect a broken build between v1.2 and HEAD:"
msgstr "自动将 V1.2 和 HEAD 之间的破损构建二分查找："

#. type: delimited block -
#: en/git-bisect.txt:393
#, no-wrap, placeholders:'HEAD':'HEAD', priority:100
msgid ""
"$ git bisect start HEAD v1.2 --      # HEAD is bad, v1.2 is good\n"
"$ git bisect run make                # \"make\" builds the app\n"
"$ git bisect reset                   # quit the bisect session\n"
msgstr ""
"$ git bisect start HEAD v1.2 --      # HEAD 是坏的，V1.2 是好的\n"
"$ git bisect run make                # \"make\" 构建应用程序\n"
"$ git bisect reset                   # 退出二分会话\n"

#. type: Plain text
#: en/git-bisect.txt:396
#, placeholders:'HEAD', priority:100
msgid "Automatically bisect a test failure between origin and HEAD:"
msgstr "在起源和HEAD之间自动二分查找失败测试："

#. type: delimited block -
#: en/git-bisect.txt:401
#, no-wrap, placeholders:'HEAD':'HEAD', priority:100
msgid ""
"$ git bisect start HEAD origin --    # HEAD is bad, origin is good\n"
"$ git bisect run make test           # \"make test\" builds and tests\n"
"$ git bisect reset                   # quit the bisect session\n"
msgstr ""
"$ git bisect start HEAD origin --    # HEAD 是坏的，origin 是好的\n"
"$ git bisect run make test           # \"make test\" 进行构建和测试\n"
"$ git bisect reset                   # 退出二分会话\n"

#. type: Plain text
#: en/git-bisect.txt:404 en/git-bisect.txt:458
#, priority:100
msgid "Automatically bisect a broken test case:"
msgstr "自动二分查找错误的的测试用例："

#. type: delimited block -
#: en/git-bisect.txt:413
#, no-wrap, placeholders:'test.sh':'check_test_case':'HEAD':'HEAD':'test.sh', priority:100
msgid ""
"$ cat ~/test.sh\n"
"#!/bin/sh\n"
"make || exit 125                     # this skips broken builds\n"
"~/check_test_case.sh                 # does the test case pass?\n"
"$ git bisect start HEAD HEAD~10 --   # culprit is among the last 10\n"
"$ git bisect run ~/test.sh\n"
"$ git bisect reset                   # quit the bisect session\n"
msgstr ""
"$ cat ~/test.sh\n"
"#!/bin/sh\n"
"make || exit 125                     # 跳过了错误构建\n"
"~/check_test_case.sh                 # 测试案例是否通过？\n"
"$ git bisect start HEAD HEAD~10 --   # 罪魁祸首就在最后10个中\n"
"$ git bisect run ~/test.sh\n"
"$ git bisect reset                   # 退出二分查找会话\n"

#. type: Plain text
#: en/git-bisect.txt:419
#, placeholders:'test.sh':'check_test_case', priority:100
msgid "Here we use a `test.sh` custom script. In this script, if `make` fails, we skip the current commit. `check_test_case.sh` should `exit 0` if the test case passes, and `exit 1` otherwise."
msgstr "这里我们使用一个 `test.sh `自定义脚本。在这个脚本中，如果 `make` 失败，我们就跳过当前的提交。 `check_test_case.sh` 如果测试用例通过，应该 `exit 0`，否则 `exit 1`。"

#. type: Plain text
#: en/git-bisect.txt:423
#, placeholders:'test.sh':'check_test_case', priority:100
msgid "It is safer if both `test.sh` and `check_test_case.sh` are outside the repository to prevent interactions between the bisect, make and test processes and the scripts."
msgstr "如果 `test.sh` 和 `check_test_case.sh `都在仓库之外，以防止 bisect、make 和 test 进程与脚本之间的相互作用，这样会更安全。"

#. type: Plain text
#: en/git-bisect.txt:425
#, priority:100
msgid "Automatically bisect with temporary modifications (hot-fix):"
msgstr "用临时修改的方式自动二分查找（热修复）："

#. type: delimited block -
#: en/git-bisect.txt:429
#, no-wrap, placeholders:'test.sh', priority:100
msgid ""
"$ cat ~/test.sh\n"
"#!/bin/sh\n"
msgstr ""
"$ cat ~/test.sh\n"
"#!/bin/sh\n"

#. type: delimited block -
#: en/git-bisect.txt:442
#, no-wrap, placeholders:'--no-commit':'--no-ff':'check_test_case', priority:100
msgid ""
"# tweak the working tree by merging the hot-fix branch\n"
"# and then attempt a build\n"
"if\tgit merge --no-commit --no-ff hot-fix &&\n"
"\tmake\n"
"then\n"
"\t# run project specific test and report its status\n"
"\t~/check_test_case.sh\n"
"\tstatus=$?\n"
"else\n"
"\t# tell the caller this is untestable\n"
"\tstatus=125\n"
"fi\n"
msgstr ""
"# 通过合并热修复来调整工作区\n"
"# 然后尝试构建\n"
"if\tgit merge --no-commit --no-ff hot-fix &&\n"
"\tmake\n"
"then\n"
"\t# 运行项目特定的测试并报告其状态\n"
"\t~/check_test_case.sh\n"
"\tstatus=$?\n"
"else\n"
"\t# 告知发起进程这是不可测试的\n"
"\tstatus=125\n"
"fi\n"

#. type: delimited block -
#: en/git-bisect.txt:445
#, no-wrap, placeholders:'--hard', priority:100
msgid ""
"# undo the tweak to allow clean flipping to the next commit\n"
"git reset --hard\n"
msgstr ""
"# 撤销调整，以便干净利落地翻转到下一次提交\n"
"git reset --hard\n"

#. type: delimited block -
#: en/git-bisect.txt:448
#, no-wrap, placeholders:'$status', priority:100
msgid ""
"# return control\n"
"exit $status\n"
msgstr ""
"# 交回控制权\n"
"exit $status\n"

#. type: Plain text
#: en/git-bisect.txt:456
#, placeholders:'git cherry-pick', priority:100
msgid "This applies modifications from a hot-fix branch before each test run, e.g. in case your build or test environment changed so that older revisions may need a fix which newer ones have already. (Make sure the hot-fix branch is based off a commit which is contained in all revisions which you are bisecting, so that the merge does not pull in too much, or use `git cherry-pick` instead of `git merge`.)"
msgstr "这是在每次测试前应用热修复分支的修改，例如，如果你的构建或测试环境发生变化，老版本可能需要一个新版本的修复。(确保热修复分支是基于一个包含在所有修订版中的提交，这样合并时就不会拉入太多，或者使用 `git cherry-pick` 代替 `git merge`。)"

#. type: delimited block -
#: en/git-bisect.txt:463
#, no-wrap, placeholders:'HEAD':'HEAD':'check_test_case', priority:100
msgid ""
"$ git bisect start HEAD HEAD~10 --   # culprit is among the last 10\n"
"$ git bisect run sh -c \"make || exit 125; ~/check_test_case.sh\"\n"
"$ git bisect reset                   # quit the bisect session\n"
msgstr ""
"$ git bisect start HEAD HEAD~10 --   # 罪魁祸首是最后 10 个\n"
"$ git bisect run sh -c \"make || exit 125; ~/check_test_case.sh\"\n"
"$ git bisect reset                   # 退出二分会话\n"

#. type: Plain text
#: en/git-bisect.txt:467
#, priority:100
msgid "This shows that you can do without a run script if you write the test on a single line."
msgstr "这表明，如果你把测试写在一行上，你可以不使用运行脚本。"

#. type: Plain text
#: en/git-bisect.txt:469
#, priority:100
msgid "Locate a good region of the object graph in a damaged repository"
msgstr "在受损的存储库中找到对象图的一个良好区域"

#. type: delimited block -
#: en/git-bisect.txt:479
#, ignore-ellipsis, no-wrap, placeholders:'HEAD':'--no-checkout':'git for-each-ref':'--format=':'git rev-list':'--objects':'BISECT_HEAD':'--not':'$GOOD':'git pack-objects':'--stdout':'$rc', priority:100
msgid ""
"$ git bisect start HEAD <known-good-commit> [ <boundary-commit> ... ] --no-checkout\n"
"$ git bisect run sh -c '\n"
"\tGOOD=$(git for-each-ref \"--format=%(objectname)\" refs/bisect/good-*) &&\n"
"\tgit rev-list --objects BISECT_HEAD --not $GOOD >tmp.$$ &&\n"
"\tgit pack-objects --stdout >/dev/null <tmp.$$\n"
"\trc=$?\n"
"\trm -f tmp.$$\n"
"\ttest $rc = 0'\n"
msgstr ""
"$ git bisect start HEAD <已知是好的提交> [ <边界提交> ... ] --no-checkout\n"
"$ git bisect run sh -c '\n"
"\tGOOD=$(git for-each-ref \"--format=%(对象名)\" refs/bisect/good-*) &&\n"
"\tgit rev-list --objects BISECT_HEAD --not $GOOD >tmp.$$ &&\n"
"\tgit pack-objects --stdout >/dev/null <tmp.$$\n"
"\trc=$?\n"
"\trm -f tmp.$$\n"
"\ttest $rc = 0'\n"

#. type: delimited block -
#: en/git-bisect.txt:481
#, no-wrap, priority:100
msgid "$ git bisect reset                   # quit the bisect session\n"
msgstr "$ git bisect reset                   # 退出二分会话\n"

#. type: Plain text
#: en/git-bisect.txt:486
#, priority:100
msgid "In this case, when 'git bisect run' finishes, bisect/bad will refer to a commit that has at least one parent whose reachable graph is fully traversable in the sense required by 'git pack objects'."
msgstr "在这种情况下，当 'git bisect run' 完成时，bisect/bad 将指的是至少有一个父级的提交，其可达图在 'git pack objects' 的意义上是完全可穿越的。"

#. type: Plain text
#: en/git-bisect.txt:488
#, priority:100
msgid "Look for a fix instead of a regression in the code"
msgstr "在代码中寻找修复而不是回归的方法"

#. type: delimited block -
#: en/git-bisect.txt:493
#, no-wrap, placeholders:'HEAD':'HEAD', priority:100
msgid ""
"$ git bisect start\n"
"$ git bisect new HEAD    # current commit is marked as new\n"
"$ git bisect old HEAD~10 # the tenth commit from now is marked as old\n"
msgstr ""
"$ git bisect start\n"
"$ git bisect new HEAD    # 当前提交被标记为新提交\n"
"$ git bisect old HEAD~10 # 从现在开始的第十次提交被标记为旧\n"

#. type: Plain text
#: en/git-bisect.txt:496
#, priority:100
msgid "or:"
msgstr "或："

#. type: delimited block -
#: en/git-bisect.txt:500
#, no-wrap, placeholders:'--term-old':'--term-new':'HEAD', priority:100
msgid ""
"$ git bisect start --term-old broken --term-new fixed\n"
"$ git bisect fixed\n"
"$ git bisect broken HEAD~10\n"
msgstr ""
"$ git bisect start --term-old broken --term-new fixed\n"
"$ git bisect fixed\n"
"$ git bisect broken HEAD~10\n"

#. type: Title ~
#: en/git-bisect.txt:503
#, no-wrap, priority:100
msgid "Getting help"
msgstr "获得帮助"

#. type: Plain text
#: en/git-bisect.txt:507
#, priority:100
msgid "Use `git bisect` to get a short usage description, and `git bisect help` or `git bisect -h` to get a long usage description."
msgstr "使用 `git bisect` 获得简短的使用说明，使用 `git bisect help` 或 `git bisect -h` 获得长的使用说明。"

# ERROR: link:git-bisect-lk2009.html[ not found in translation
#. type: Plain text
#: en/git-bisect.txt:512
#, placeholders:'link:git-bisect-lk2009.html[':'linkgit:git-blame[1]', priority:100
msgid "link:git-bisect-lk2009.html[Fighting regressions with git bisect], linkgit:git-blame[1]."
msgstr "link:git-bisect-lk2009.html[用 git bisect 对抗回归]，linkgit:git-blame[1]。"

#. type: Title =
#: en/git-blame.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-blame(1)"
msgstr "git-blame(1)"

#. type: Plain text
#: en/git-blame.txt:7
#, placeholders:'git-blame', priority:100
msgid "git-blame - Show what revision and author last modified each line of a file"
msgstr "git-blame - 显示文件每一行的最后修改版本和作者"

#. type: Plain text
#: en/git-blame.txt:16
#, no-wrap, placeholders:'[--root]':'[--incremental]':'[--since=':'[--ignore-rev':'[--ignore-revs-file':'[--color-lines]':'[--color-by-age]':'[--progress]':'[--abbrev=':'--contents':'--reverse', priority:100
msgid ""
"'git blame' [-c] [-b] [-l] [--root] [-t] [-f] [-n] [-s] [-e] [-p] [-w] [--incremental]\n"
"\t    [-L <range>] [-S <revs-file>] [-M] [-C] [-C] [-C] [--since=<date>]\n"
"\t    [--ignore-rev <rev>] [--ignore-revs-file <file>]\n"
"\t    [--color-lines] [--color-by-age] [--progress] [--abbrev=<n>]\n"
"\t    [ --contents <file> ] [<rev> | --reverse <rev>..<rev>] [--] <file>\n"
msgstr ""
"'git blame' [-c] [-b] [-l] [--root] [-t] [-f] [-n] [-s] [-e] [-p] [-w] [--incremental]\n"
"\t    [-L <范围i>] [-S <revs-file>] [-M] [-C] [-C] [-C] [--since=<日期>]\n"
"\t    [--ignore-rev <rev>] [--ignore-revs-file <文件>]\n"
"\t    [--color-lines] [--color-by-age] [--progress] [--abbrev=<n>]\n"
"\t    [ --contents <文件> ] [<rev> | --reverse <rev>..<rev>] [--] <文件>\n"

#. type: Plain text
#: en/git-blame.txt:22
#, priority:100
msgid "Annotates each line in the given file with information from the revision which last modified the line. Optionally, start annotating from the given revision."
msgstr "用最后一次修改该行的修订版的信息来注释给定文件中的每一行。可以选择从给定的修订版开始做注释。"

#. type: Plain text
#: en/git-blame.txt:25
#, placeholders:'`-L`', priority:100
msgid "When specified one or more times, `-L` restricts annotation to the requested lines."
msgstr "当指定一次或多次时，`-L` 将注释限制在要求的行中。"

#. type: Plain text
#: en/git-blame.txt:31
#, placeholders:'`-C`':'`-M`', priority:100
msgid "The origin of lines is automatically followed across whole-file renames (currently there is no option to turn the rename-following off). To follow lines moved from one file to another, or to follow lines that were copied and pasted from another file, etc., see the `-C` and `-M` options."
msgstr "在整个文件的重命名过程中，行的起源被自动跟踪（目前没有选项可以关闭重命名跟踪）。要跟踪从一个文件移到另一个文件的行，或者跟踪从另一个文件复制和粘贴的行，等等，请参见 `-C` 和 `-M` 选项。"

#. type: Plain text
#: en/git-blame.txt:35
#, priority:100
msgid "The report does not tell you anything about lines which have been deleted or replaced; you need to use a tool such as 'git diff' or the \"pickaxe\" interface briefly mentioned in the following paragraph."
msgstr "报告不会告诉你任何关于被删除或替换的行的信息；你需要使用一个工具，如 'git diff' 或下段中简要提到的 'pickaxe' 接口。"

#. type: Plain text
#: en/git-blame.txt:42
#, placeholders:'blame_usage', priority:100
msgid "Apart from supporting file annotation, Git also supports searching the development history for when a code snippet occurred in a change. This makes it possible to track when a code snippet was added to a file, moved or copied between files, and eventually deleted or replaced. It works by searching for a text string in the diff. A small example of the pickaxe interface that searches for `blame_usage`:"
msgstr "除了支持文件注释外，Git 还支持在开发历史中搜索代码片段何时发生变化。这使得追踪一个代码片段何时被添加到一个文件，在文件之间移动或复制，以及最终被删除或替换成为可能。它的工作原理是在差异中搜索一个文本字符串。一个搜索 `blame_usage` 的 pickaxe 界面的小例子："

#. type: delimited block -
#: en/git-blame.txt:47
#, no-wrap, placeholders:'--pretty=oneline':'blame_usage':'git-blame', priority:100
msgid ""
"$ git log --pretty=oneline -S'blame_usage'\n"
"5040f17eba15504bad66b14a645bddd9b015ebb7 blame -S <ancestry-file>\n"
"ea4c7f9bf69e781dd0cd88d2bccb2bf5cc15c9a7 git-blame: Make the output\n"
msgstr ""
"$ git log --pretty=oneline -S'blame_usage'\n"
"5040f17eba15504bad66b14a645bddd9b015ebb7 blame -S <祖先文件>\n"
"ea4c7f9bf69e781dd0cd88d2bccb2bf5cc15c9a7 git-blame: Make the output\n"

#. type: Plain text
#: en/git-blame.txt:55
#, placeholders:'linkgit:git-annotate[1]', priority:100
msgid "Use the same output mode as linkgit:git-annotate[1] (Default: off)."
msgstr "使用与 linkgit:git-annotate[1] 相同的输出模式（默认：关闭）。"

#. type: Labeled list
#: en/git-blame.txt:56
#, ignore-same, no-wrap, priority:100
msgid "--score-debug"
msgstr "--score-debug"

#. type: Plain text
#: en/git-blame.txt:64
#, placeholders:'`-C`':'`-M`', priority:100
msgid "Include debugging information related to the movement of lines between files (see `-C`) and lines moved within a file (see `-M`). The first number listed is the score. This is the number of alphanumeric characters detected as having been moved between or within files. This must be above a certain threshold for 'git blame' to consider those lines of code to have been moved."
msgstr "包括与文件之间行的移动（见 `-C`）和文件内行的移动（见 `-M`）有关的调试信息。 列出的第一个数字是分数。 这是检测到的在文件间或文件内移动的字母数字字符的数量。 这个数字必须超过一定的阈值，'git blame' 才会认为这些代码行被移动了。"

#. type: Labeled list
#: en/git-blame.txt:66
#, ignore-same, no-wrap, priority:100
msgid "--show-name"
msgstr "--show-name"

#. type: Plain text
#: en/git-blame.txt:70
#, priority:100
msgid "Show the filename in the original commit. By default the filename is shown if there is any line that came from a file with a different name, due to rename detection."
msgstr "显示原始提交中的文件名。 默认情况下，如果有任何一行来自不同名字的文件，由于重名检测，文件名会显示出来。"

#. type: Labeled list
#: en/git-blame.txt:72
#, ignore-same, no-wrap, priority:100
msgid "--show-number"
msgstr "--show-number"

#. type: Plain text
#: en/git-blame.txt:74
#, priority:100
msgid "Show the line number in the original commit (Default: off)."
msgstr "显示原始提交中的行号（默认：off）。"

#. type: Plain text
#: en/git-blame.txt:77
#, priority:100
msgid "Suppress the author name and timestamp from the output."
msgstr "抑制输出中的作者姓名和时间戳。"

#. type: Labeled list
#: en/git-blame.txt:79
#, ignore-same, no-wrap, priority:100
msgid "--show-email"
msgstr "--show-email"

#. type: Plain text
#: en/git-blame.txt:83
#, placeholders:'blame.showEmail', priority:100
msgid "Show the author email instead of the author name (Default: off). This can also be controlled via the `blame.showEmail` config option."
msgstr "显示作者的电子邮件而不是作者的名字（默认：off）。 这也可以通过 `blame.showEmail` 配置选项来控制。"

#. type: Plain text
#: en/git-blame.txt:87
#, priority:100
msgid "Ignore whitespace when comparing the parent's version and the child's to find where the lines came from."
msgstr "在比较父本和子本的版本时，忽略空白，以找到行的来源。"

#. type: Labeled list
#: en/git-blame.txt:88 en/git-branch.txt:207 en/git-describe.txt:65
#, no-wrap, placeholders:'--abbrev=', priority:260
msgid "--abbrev=<n>"
msgstr "--abbrev=<n>"

#. type: Plain text
#: en/git-blame.txt:94
#, priority:100
msgid "Instead of using the default 7+1 hexadecimal digits as the abbreviated object name, use <m>+1 digits, where <m> is at least <n> but ensures the commit object names are unique. Note that 1 column is used for a caret to mark the boundary commit."
msgstr "不要使用默认的7+1个十六进制数字作为对象的缩写，而是使用 <m>+1 个数字，其中 <m> 至少是 <n>，但确保提交对象的名称是唯一的。 请注意，有1列是用来标记边界提交的关健词。"

#. type: Title -
#: en/git-blame.txt:97
#, no-wrap, priority:100
msgid "THE DEFAULT FORMAT"
msgstr "默认格式"

#. type: Plain text
#: en/git-blame.txt:101
#, placeholders:'`--porcelain`':'`--incremental`', priority:100
msgid "When neither `--porcelain` nor `--incremental` option is specified, `git blame` will output annotation for each line with:"
msgstr "当既没有指定`--porcelain` 也没有指定`--incremental` 选项时，`git blame` 将为每一行输出注释："

#. type: Plain text
#: en/git-blame.txt:103
#, priority:100
msgid "abbreviated object name for the commit the line came from;"
msgstr "该行来自的提交的缩写对象名称；"

# ERROR: `-s` not found in translation
# ERROR: `-e` not found in translation
#. type: Plain text
#: en/git-blame.txt:105
#, placeholders:'`-s`':'`-e`', priority:100
msgid "author ident (by default the author name and date, unless `-s` or `-e` is specified); and"
msgstr "作者身份（默认为作者姓名和日期，除非指定 `-s` 或 `-e` 选项）；以及"

#. type: Plain text
#: en/git-blame.txt:106
#, priority:100
msgid "line number"
msgstr "--line-number"

#. type: Plain text
#: en/git-blame.txt:108
#, priority:100
msgid "before the line contents."
msgstr "在该行内容之前。"

#. type: Title -
#: en/git-blame.txt:110
#, no-wrap, priority:100
msgid "THE PORCELAIN FORMAT"
msgstr "上层命令格式"

#. type: Plain text
#: en/git-blame.txt:114
#, priority:100
msgid "In this format, each line is output after a header; the header at the minimum has the first line which has:"
msgstr "在这种格式中，每一行都是在页眉之后输出的；页眉至少有第一行，它有："

#. type: Plain text
#: en/git-blame.txt:116
#, priority:100
msgid "40-byte SHA-1 of the commit the line is attributed to;"
msgstr "该行所归属的提交的 40 字节 SHA-1；"

#. type: Plain text
#: en/git-blame.txt:117
#, priority:100
msgid "the line number of the line in the original file;"
msgstr "原始文件中该行的行号；"

#. type: Plain text
#: en/git-blame.txt:118
#, priority:100
msgid "the line number of the line in the final file;"
msgstr "最后文件中该行的行号；"

#. type: Plain text
#: en/git-blame.txt:121
#, priority:100
msgid "on a line that starts a group of lines from a different commit than the previous one, the number of lines in this group. On subsequent lines this field is absent."
msgstr "在开始一组与前一次不同的提交的行上，该组的行数。 在随后的行中，这个字段是不存在的。"

#. type: Plain text
#: en/git-blame.txt:124
#, priority:100
msgid "This header line is followed by the following information at least once for each commit:"
msgstr "这个标题行后面是以下信息，每次提交至少有一次："

#. type: Plain text
#: en/git-blame.txt:128
#, priority:100
msgid "the author name (\"author\"), email (\"author-mail\"), time (\"author-time\"), and time zone (\"author-tz\"); similarly for committer."
msgstr "作者姓名（\"author\"）、电子邮件（\"author-mail\"）、时间（\"author-time\"）和时区（\"author-tz\"）；对提交者也是如此。"

#. type: Plain text
#: en/git-blame.txt:129
#, priority:100
msgid "the filename in the commit that the line is attributed to."
msgstr "该行归属的提交中的文件名。"

#. type: Plain text
#: en/git-blame.txt:130
#, priority:100
msgid "the first line of the commit log message (\"summary\")."
msgstr "提交日志信息的第一行（\"摘要\"）。"

#. type: Plain text
#: en/git-blame.txt:134
#, priority:100
msgid "The contents of the actual line are output after the above header, prefixed by a TAB. This is to allow adding more header elements later."
msgstr "实际行的内容会在上述标题之后输出，前缀为 TAB。这是为了允许以后添加更多的标题元素。"

# ERROR: --line-porcelain not found in translation
# ERROR: --line-porcelain not found in translation
#. type: Plain text
#: en/git-blame.txt:142
#, placeholders:'`--line-porcelain`', priority:100
msgid "The porcelain format generally suppresses commit information that has already been seen. For example, two lines that are blamed to the same commit will both be shown, but the details for that commit will be shown only once. This is more efficient, but may require more state be kept by the reader. The `--line-porcelain` option can be used to output full commit information for each line, allowing simpler (but less efficient) usage like:"
msgstr "上层命令的格式通常会抑制已被查看过的提交信息。例如，归咎于同一提交的两行内容都会显示，但该提交的详细信息只显示一次。这样效率更高，但可能需要读者保留更多状态。可以使用 `--line-porcelain`选项来输出每一行的完整提交信息，这样的用法更简单（但效率较低），例如："

#. type: Plain text
#: en/git-blame.txt:147
#, no-wrap, placeholders:'--line-porcelain', priority:100
msgid ""
"\t# count the number of lines attributed to each author\n"
"\tgit blame --line-porcelain file |\n"
"\tsed -n 's/^author //p' |\n"
"\tsort | uniq -c | sort -rn\n"
msgstr ""
"\t# 统计每位作者的作品数\n"
"\tgit blame --line-porcelain file |\n"
"\tsed -n 's/^author //p' |\n"
"\tsort | uniq -c | sort -rn\n"

#. type: Title -
#: en/git-blame.txt:150 en/revisions.txt:265
#, no-wrap, priority:100
msgid "SPECIFYING RANGES"
msgstr "指定范围"

#. type: Plain text
#: en/git-blame.txt:156
#, placeholders:'`-L`', priority:100
msgid "Unlike 'git blame' and 'git annotate' in older versions of git, the extent of the annotation can be limited to both line ranges and revision ranges. The `-L` option, which limits annotation to a range of lines, may be specified multiple times."
msgstr "与旧版本的 \"git blame\" 和 \"git annotate\" 不同，注释的范围可以限制在行的范围和修订范围。`-L` 选项将注释限制在一个行的范围内，可以多次指定。"

#. type: Plain text
#: en/git-blame.txt:161
#, placeholders:'`-L`', priority:100
msgid "When you are interested in finding the origin for lines 40-60 for file `foo`, you can use the `-L` option like so (they mean the same thing -- both ask for 21 lines starting at line 40):"
msgstr "当你对查找文件 `foo` 的第 40-60 行的原点感兴趣时，你可以像这样使用 `-L` 选项（它们的意思是一样的--都要求从第 40 行开始的 21 行）："

#. type: Plain text
#: en/git-blame.txt:164
#, no-wrap, priority:100
msgid ""
"\tgit blame -L 40,60 foo\n"
"\tgit blame -L 40,+21 foo\n"
msgstr ""
"\tgit blame -L 40,60 foo\n"
"\tgit blame -L 40,+21 foo\n"

#. type: Plain text
#: en/git-blame.txt:166
#, priority:100
msgid "Also you can use a regular expression to specify the line range:"
msgstr "你也可以使用正则表达式来指定行的范围："

#. type: Plain text
#: en/git-blame.txt:168
#, no-wrap, priority:100
msgid "\tgit blame -L '/^sub hello {/,/^}$/' foo\n"
msgstr "\tgit blame -L '/^sub hello {/,/^}$/' foo\n"

#. type: Plain text
#: en/git-blame.txt:170
#, priority:100
msgid "which limits the annotation to the body of the `hello` subroutine."
msgstr "它将注释限制在 `hello` 子程序的主体中。"

#. type: Plain text
#: en/git-blame.txt:174
#, placeholders:'git rev-list', priority:100
msgid "When you are not interested in changes older than version v2.6.18, or changes older than 3 weeks, you can use revision range specifiers similar to 'git rev-list':"
msgstr "当你对超过 v2.6.18 版本的修改不感兴趣，或者超过 3 周的修改不感兴趣时，你可以使用类似于 `git rev-list` 的修订范围指定器："

#. type: Plain text
#: en/git-blame.txt:177
#, no-wrap, placeholders:'--since=3', priority:100
msgid ""
"\tgit blame v2.6.18.. -- foo\n"
"\tgit blame --since=3.weeks -- foo\n"
msgstr ""
"\tgit blame v2.6.18.. -- foo\n"
"\tgit blame --since=3.weeks -- foo\n"

#. type: Plain text
#: en/git-blame.txt:183
#, priority:100
msgid "When revision range specifiers are used to limit the annotation, lines that have not changed since the range boundary (either the commit v2.6.18 or the most recent commit that is more than 3 weeks old in the above example) are blamed for that range boundary commit."
msgstr "当修订范围指定符被用来限制注释时，自范围边界（在上面的例子中，提交 v2.6.18 或超过 3 周的最新提交）以来没有改变的行被指责为该范围边界提交。"

#. type: Plain text
#: en/git-blame.txt:189
#, priority:100
msgid "A particularly useful way is to see if an added file has lines created by copy-and-paste from existing files. Sometimes this indicates that the developer was being sloppy and did not refactor the code properly. You can first find the commit that introduced the file with:"
msgstr "一个特别有用的方法是看一个新增的文件是否有从现有文件中复制和粘贴的行。 有时，这表明开发人员很马虎，没有正确地重构代码。 你可以首先找到引入该文件的提交："

#. type: Plain text
#: en/git-blame.txt:191
#, no-wrap, placeholders:'--diff-filter=A':'--pretty=short', priority:100
msgid "\tgit log --diff-filter=A --pretty=short -- foo\n"
msgstr "\tgit log --diff-filter=A --pretty=short -- foo\n"

#. type: Plain text
#: en/git-blame.txt:194
#, priority:100
msgid "and then annotate the change between the commit and its parents, using `commit^!` notation:"
msgstr "然后用 'commit^!' 符号来注释该提交和其父辈之间的变化："

#. type: Plain text
#: en/git-blame.txt:196
#, no-wrap, placeholders:'$commit', priority:100
msgid "\tgit blame -C -C -f $commit^! -- foo\n"
msgstr "\tgit blame -C -C -f $commit^! -- foo\n"

#. type: Title -
#: en/git-blame.txt:199
#, no-wrap, priority:100
msgid "INCREMENTAL OUTPUT"
msgstr "增量输出"

#. type: Plain text
#: en/git-blame.txt:206
#, placeholders:'`--incremental`', priority:100
msgid "When called with `--incremental` option, the command outputs the result as it is built. The output generally will talk about lines touched by more recent commits first (i.e. the lines will be annotated out of order) and is meant to be used by interactive viewers."
msgstr "当调用 `--incremental` 选项时，该命令在构建过程中输出结果。 一般来说，输出结果会先谈及最近提交的行（也就是说，这些行会被不按顺序的注释），并且是为了给交互式浏览者使用。"

#. type: Plain text
#: en/git-blame.txt:210
#, priority:100
msgid "The output format is similar to the Porcelain format, but it does not contain the actual lines from the file that is being annotated."
msgstr "输出格式类似于上层命令格式，但它不包含被注释的文件的实际行数。"

#. type: Plain text
#: en/git-blame.txt:212
#, priority:100
msgid "Each blame entry always starts with a line of:"
msgstr "每个历史追溯条目总是以一行字开始："

#. type: Plain text
#: en/git-blame.txt:214
#, no-wrap, priority:100
msgid "<40-byte-hex-sha1> <sourceline> <resultline> <num-lines>\n"
msgstr "<40-byte-hex sha1> <源行> <结果行> <数量行>\n"

#. type: Plain text
#: en/git-blame.txt:216
#, priority:100
msgid "Line numbers count from 1."
msgstr "行数从 1 开始计算。"

#. type: Plain text
#: en/git-blame.txt:221
#, priority:100
msgid "The first time that a commit shows up in the stream, it has various other information about it printed out with a one-word tag at the beginning of each line describing the extra commit information (author, email, committer, dates, summary, etc.)."
msgstr "当一个提交首次出现在数据流中时，它的各种其他信息会被打印出来，每一行的开头都有一个单字标签，描述额外的提交信息（作者、电子邮件、提交者、日期、摘要等）。"

#. type: Plain text
#: en/git-blame.txt:224
#, priority:100
msgid "Unlike the Porcelain format, the filename information is always given and terminates the entry:"
msgstr "与上层命令格式不同，文件名信息总是给定的，并终止条目："

#. type: Plain text
#: en/git-blame.txt:226
#, no-wrap, priority:100
msgid "\"filename\" <whitespace-quoted-filename-goes-here>\n"
msgstr "\"filename\" <空白引号-片名-到此为止>\n"

#. type: Plain text
#: en/git-blame.txt:229
#, priority:100
msgid "and thus it is really quite easy to parse for some line- and word-oriented parser (which should be quite natural for most scripting languages)."
msgstr "因此，对于一些面向行和字的解析器来说，它确实很容易解析（这对于大多数脚本语言来说应该是很自然的）。"

#. type: Plain text
#: en/git-blame.txt:237
#, priority:100
msgid "For people who do parsing: to make it more robust, just ignore any lines between the first and last one (\"<sha1>\" and \"filename\" lines) where you do not recognize the tag words (or care about that particular one) at the beginning of the \"extended information\" lines. That way, if there is ever added information (like the commit encoding or extended commit commentary), a blame viewer will not care."
msgstr "对于做解析的人来说：为了使它更健壮，只要忽略第一和最后一个（\"<sha1>\" 和 \"filename\" 行）之间的任何行，在 \"扩展信息\" 行的开头，你不认识标签词（或关心那个特定的）。这样一来，如果有一天增加了信息（比如提交编码或扩展的提交注释），历史追溯查看者就不会在意。"

#. type: Title -
#: en/git-blame.txt:240 en/git-check-mailmap.txt:47 en/git-shortlog.txt:120
#, no-wrap, priority:260
msgid "MAPPING AUTHORS"
msgstr "制图作者"

#. type: Plain text
#: en/git-blame.txt:243 en/git-check-mailmap.txt:50 en/git-shortlog.txt:123
#, placeholders:'linkgit:gitmailmap[5]', priority:260
msgid "See linkgit:gitmailmap[5]."
msgstr "参见 linkgit:gitmailmap[5]。"

#. type: Title =
#: en/git-branch.txt:2
#, ignore-same, no-wrap, priority:260
msgid "git-branch(1)"
msgstr "git-branch(1)"

#. type: Plain text
#: en/git-branch.txt:7
#, priority:260
msgid "git-branch - List, create, or delete branches"
msgstr "git-branch - 列出、创建或删除分支"

#. type: Plain text
#: en/git-branch.txt:27
#, ignore-ellipsis, no-wrap, placeholders:'[--color':'--no-color]':'[--show-current]':'[--abbrev=':'--no-abbrev]':'[--column':'--no-column]':'[--sort=':'[--merged':'[--no-merged':'[--contains':'[--no-contains':'[--points-at':'[--format=':'--remotes':'--all':'[--list]':'[--track[=(direct|inherit)]':'--no-track]':'[--recurse-submodules]':'--set-upstream-to=':'--unset-upstream':'--edit-description', priority:260
msgid ""
"'git branch' [--color[=<when>] | --no-color] [--show-current]\n"
"\t[-v [--abbrev=<n> | --no-abbrev]]\n"
"\t[--column[=<options>] | --no-column] [--sort=<key>]\n"
"\t[--merged [<commit>]] [--no-merged [<commit>]]\n"
"\t[--contains [<commit>]] [--no-contains [<commit>]]\n"
"\t[--points-at <object>] [--format=<format>]\n"
"\t[(-r | --remotes) | (-a | --all)]\n"
"\t[--list] [<pattern>...]\n"
"'git branch' [--track[=(direct|inherit)] | --no-track] [-f]\n"
"\t[--recurse-submodules] <branchname> [<start-point>]\n"
"'git branch' (--set-upstream-to=<upstream> | -u <upstream>) [<branchname>]\n"
"'git branch' --unset-upstream [<branchname>]\n"
"'git branch' (-m | -M) [<oldbranch>] <newbranch>\n"
"'git branch' (-c | -C) [<oldbranch>] <newbranch>\n"
"'git branch' (-d | -D) [-r] <branchname>...\n"
"'git branch' --edit-description [<branchname>]\n"
msgstr ""
"'git branch' [--color[=<when>] | --no-color] [--show-current]\n"
"\t[-v [--abbrev=<n> | --no-abbrev]]\n"
"\t[--column[=<options>] | --no-column] [--sort=<key>]\n"
"\t[--merged [<commit>]] [--no-merged [<commit>]]\n"
"\t[--contains [<commit>]] [--no-contains [<commit>]]\n"
"\t[--points-at <object>] [--format=<format>]\n"
"\t[(-r | --remotes) | (-a | --all)]\n"
"\t[--list] [<pattern>...]\n"
"'git branch' [--track[=(direct|inherit)] | --no-track] [-f]\n"
"\t[--recurse-submodules] <分支名> [<起始点>]\n"
"'git branch' (--set-upstream-to=<上游> | -u <上游>) [<分支名>]\n"
"'git branch' --unset-upstream [<分支名>]\n"
"'git branch' (-m | -M) [<旧分支>] <新分支>\n"
"'git branch' (-c | -C) [<旧分支>] <新分支>\n"
"'git branch' (-d | -D) [-r] <分支名>...\n"
"'git branch' --edit-description [<分支名>]\n"

#. type: Plain text
#: en/git-branch.txt:37
#, placeholders:'`--list`':'`-r`':'`-a`', priority:260
msgid "If `--list` is given, or if there are no non-option arguments, existing branches are listed; the current branch will be highlighted in green and marked with an asterisk. Any branches checked out in linked worktrees will be highlighted in cyan and marked with a plus sign. Option `-r` causes the remote-tracking branches to be listed, and option `-a` shows both local and remote branches."
msgstr "如果给了`--list`，或者没有非选项参数，现有的分支将被列出；当前的分支将以绿色突出显示，并标有星号。 在链接的工作树中检查出来的任何分支将以青色突出显示，并标有加号。选项`-r`导致远程跟踪的分支被列出，选项`-a`显示本地和远程分支。"

#. type: Plain text
#: en/git-branch.txt:42
#, priority:260
msgid "If a `<pattern>` is given, it is used as a shell wildcard to restrict the output to matching branches. If multiple patterns are given, a branch is shown if it matches any of the patterns."
msgstr "如果给出了`<pattern>`，它被用作shell通配符，将输出限制在匹配的分支上。如果给出多个模式，如果一个分支与任何模式相匹配，就会显示出来。"

# ERROR: `--list` not found in translation
#. type: Plain text
#: en/git-branch.txt:46
#, placeholders:'`--list`', priority:260
msgid "Note that when providing a `<pattern>`, you must use `--list`; otherwise the command may be interpreted as branch creation."
msgstr "注意，当提供 `<pattern>` 时，必须使用 `--list`；否则命令可能被解释为创建分支。"

# ERROR: `--no-merged` not found in translation
#. type: Plain text
#: en/git-branch.txt:55
#, placeholders:'`--contains`':'`--no-contains`':'`--merged`':'`--no-merged`':'HEAD', priority:260
msgid "With `--contains`, shows only the branches that contain the named commit (in other words, the branches whose tip commits are descendants of the named commit), `--no-contains` inverts it. With `--merged`, only branches merged into the named commit (i.e. the branches whose tip commits are reachable from the named commit) will be listed. With `--no-merged` only branches not merged into the named commit will be listed. If the <commit> argument is missing it defaults to `HEAD` (i.e. the tip of the current branch)."
msgstr "使用 `--contains` 时，只显示包含指定提交的分支（换句话说，尖端提交是指定提交的后裔的分支），`--no-contains` 会反过来。如果使用 `--merged`，则只列出被合并到指定提交的分支（即其顶端提交可以从指定提交处到达的分支）。 如果使用 `--no-merged`，则只列出未被合并到指定提交的分支。 如果缺少 <commit> 参数，则默认为`HEAD`（即当前分支的顶端）。"

#. type: Plain text
#: en/git-branch.txt:62
#, ignore-ellipsis, placeholders:'HEAD':'HEAD', priority:260
msgid "The command's second form creates a new branch head named <branchname> which points to the current `HEAD`, or <start-point> if given. As a special case, for <start-point>, you may use `\"A...B\"` as a shortcut for the merge base of `A` and `B` if there is exactly one merge base. You can leave out at most one of `A` and `B`, in which case it defaults to `HEAD`."
msgstr "该命令的第二种形式是创建一个名为<branchname>的新分支头，该分支头指向当前的`HEAD`，如果给定的话，则指向<start-point>。作为一种特殊情况，对于<start-point>，你可以使用`\"A...B \"作为`A`和`B`的合并基础的快捷方式，如果正好有一个合并基础。你最多可以省略`A`和`B`中的一个，在这种情况下，它默认为`HEAD`。"

#. type: Plain text
#: en/git-branch.txt:66
#, priority:260
msgid "Note that this will create the new branch, but it will not switch the working tree to it; use \"git switch <newbranch>\" to switch to the new branch."
msgstr "注意，这将创建新的分支，但不会将工作树切换到它；使用 \"git switch <newbranch>\"来切换到新的分支。"

#. type: Plain text
#: en/git-branch.txt:74
#, placeholders:'branch.autoSetupMerge':'`--track`':'`--no-track`':'--set-upstream-to`', priority:260
msgid "When a local branch is started off a remote-tracking branch, Git sets up the branch (specifically the `branch.<name>.remote` and `branch.<name>.merge` configuration entries) so that 'git pull' will appropriately merge from the remote-tracking branch. This behavior may be changed via the global `branch.autoSetupMerge` configuration flag. That setting can be overridden by using the `--track` and `--no-track` options, and changed later using `git branch --set-upstream-to`."
msgstr "当一个本地分支从远程跟踪的分支开始时，Git 会设置该分支（特别是 `branch.<name>.remote` 和 `branch.<name>.merge` 配置项），以便 \"git pull \"能适当地从远程跟踪的分支合并。这种行为可以通过全局的 `branch.autoSetupMerge` 配置标志来改变。该设置可以通过使用`--track`和`--no-track`选项来覆盖，并在之后使用`git branch --set-upstream-to`来改变。"

#. type: Plain text
#: en/git-branch.txt:80
#, placeholders:'`-m`':'`-M`', priority:260
msgid "With a `-m` or `-M` option, <oldbranch> will be renamed to <newbranch>. If <oldbranch> had a corresponding reflog, it is renamed to match <newbranch>, and a reflog entry is created to remember the branch renaming. If <newbranch> exists, -M must be used to force the rename to happen."
msgstr "使用`-m`或`-M`选项，<oldbranch>将被重命名为<newbranch>。 如果 <oldbranch> 有相应的 reflog，它将被重命名以匹配 <newbranch>，并创建一个 reflog 条目以记住分支重命名。如果 <newbranch> 存在，必须使用 -M 来强制重命名。"

#. type: Plain text
#: en/git-branch.txt:84
#, placeholders:'`-c`':'`-C`':'`-m`':'`-M`', priority:260
msgid "The `-c` and `-C` options have the exact same semantics as `-m` and `-M`, except instead of the branch being renamed, it will be copied to a new name, along with its config and reflog."
msgstr "`-c`和`-C`选项的语义与`-m`和`-M`完全相同，只不过不是对分支进行重命名，而是将其连同其配置和日志一起复制到一个新的名称。"

#. type: Plain text
#: en/git-branch.txt:88
#, placeholders:'`-d`':'`-D`', priority:260
msgid "With a `-d` or `-D` option, `<branchname>` will be deleted. You may specify more than one branch for deletion. If the branch currently has a reflog then the reflog will also be deleted."
msgstr "使用`-d`或`-D`选项，`<branchname>`将被删除。 你可以指定一个以上的分支进行删除。 如果该分支目前有一个reflog，那么reflog也将被删除。"

#. type: Plain text
#: en/git-branch.txt:94
#, placeholders:'`-r`':'`-d`':'linkgit:git-remote[1]', priority:260
msgid "Use `-r` together with `-d` to delete remote-tracking branches. Note, that it only makes sense to delete remote-tracking branches if they no longer exist in the remote repository or if 'git fetch' was configured not to fetch them again. See also the 'prune' subcommand of linkgit:git-remote[1] for a way to clean up all obsolete remote-tracking branches."
msgstr "使用 `-r` 和 `-d` 来删除远程跟踪的分支。注意，只有当远程分支不再存在于远程仓库或 \"git fetch \"被配置为不再获取它们时，删除远程跟踪分支才有意义。参见 linkgit:git-remote[1] 的 \"prune \"子命令，它可以清理所有过时的远程跟踪分支。"

#. type: Labeled list
#: en/git-branch.txt:98 en/git-checkout.txt:211 en/git-clean.txt:28 en/git-cvsexportcommit.txt:49 en/git-difftool.txt:22 en/git-http-push.txt:44 en/git-instaweb.txt:27 en/git-ls-files.txt:44 en/git-ls-tree.txt:41 en/git-push.txt:182 en/git-repack.txt:60 en/git-replace.txt:65 en/git-show-ref.txt:55 en/git-switch.txt:86 en/git-symbolic-ref.txt:35 en/git-tag.txt:83 en/git-worktree.txt:198
#, ignore-same, no-wrap, priority:260
msgid "-d"
msgstr "-d"

#. type: Labeled list
#: en/git-branch.txt:99 en/git-push.txt:183 en/git-replace.txt:66 en/git-symbolic-ref.txt:36 en/git-tag.txt:84
#, ignore-same, no-wrap, priority:260
msgid "--delete"
msgstr "--delete"

#. type: Plain text
#: en/git-branch.txt:103
#, placeholders:'HEAD':'`--track`':'`--set-upstream-to`', priority:260
msgid "Delete a branch. The branch must be fully merged in its upstream branch, or in `HEAD` if no upstream was set with `--track` or `--set-upstream-to`."
msgstr "删除一个分支。该分支必须完全合并在其上游分支中，如果没有用`--track`或`--set-upstream-to`设置的上游分支，则必须在`HEAD`中。"

#. type: Plain text
#: en/git-branch.txt:106
#, placeholders:'`--delete':'--force`', priority:260
msgid "Shortcut for `--delete --force`."
msgstr "`--delete --force`的快捷方式。"

#. type: Labeled list
#: en/git-branch.txt:107 en/git-tag.txt:194
#, ignore-same, no-wrap, priority:260
msgid "--create-reflog"
msgstr "--create-reflog"

#. type: Plain text
#: en/git-branch.txt:116
#, placeholders:'{yesterday}':'core.logAllRefUpdates':'`--no-create-reflog`':'`--create-reflog`':'core.logAllRefUpdates', priority:260
msgid "Create the branch's reflog. This activates recording of all changes made to the branch ref, enabling use of date based sha1 expressions such as \"<branchname>@\\{yesterday}\". Note that in non-bare repositories, reflogs are usually enabled by default by the `core.logAllRefUpdates` config option. The negated form `--no-create-reflog` only overrides an earlier `--create-reflog`, but currently does not negate the setting of `core.logAllRefUpdates`."
msgstr "创建该分支的 reflog。 这将激活对该分支参考文献所做的所有修改的记录，使其能够使用基于日期的sha1表达式，如\"<branchname>@{yesterday}\"。 请注意，在非空白仓库中， reflogs通常由`core.logAllRefUpdates`配置选项默认启用。 否定的形式`--no-create-reflog`只覆盖先前的`--create-reflog`，但目前并不否定`core.logAllRefUpdates`的设置。"

#. type: Plain text
#: en/git-branch.txt:126
#, placeholders:'`-f`':'`-d`':'`--delete`':'`-m`':'`--move`':'`-c`':'`--copy`', priority:260
msgid "Reset <branchname> to <start-point>, even if <branchname> exists already. Without `-f`, 'git branch' refuses to change an existing branch. In combination with `-d` (or `--delete`), allow deleting the branch irrespective of its merged status, or whether it even points to a valid commit. In combination with `-m` (or `--move`), allow renaming the branch even if the new branch name already exists, the same applies for `-c` (or `--copy`)."
msgstr "将 <分支名> 重置为 <起始点>，即使 <分支名> 已经存在。如果没有 `-f`，'git branch' 会拒绝更改现有分支。 与 `-d`（或 `--delete`）结合使用时，允许删除分支，而不管其合并状态如何，也不管它是否指向一个有效的提交。结合 `-m`（或 `--move`），允许重命名分支，即使新的分支名称已经存在，这同样适用于 `-c`（或 `--copy`）。"

#. type: Plain text
#: en/git-branch.txt:130
#, priority:260
msgid "Note that 'git branch -f <branchname> [<start-point>]', even with '-f', refuses to change an existing branch `<branchname>` that is checked out in another worktree linked to the same repository."
msgstr "请注意，\"git branch -f <branchname> [<start-point>]\"命令，即使添加\"-f\"选项，该命令也会拒绝改变一个在链接到同一仓库的另一个工作树中被检查出来的现有分支`<branchname>`。"

#. type: Labeled list
#: en/git-branch.txt:132
#, ignore-same, no-wrap, priority:260
msgid "--move"
msgstr "--move"

#. type: Plain text
#: en/git-branch.txt:134
#, priority:260
msgid "Move/rename a branch, together with its config and reflog."
msgstr "移动/重命名分支及其配置和引用日志。"

#. type: Labeled list
#: en/git-branch.txt:135 en/git-fast-export.txt:53 en/git-p4.txt:317
#, ignore-same, no-wrap, priority:260
msgid "-M"
msgstr "-M"

#. type: Plain text
#: en/git-branch.txt:137
#, placeholders:'`--move':'--force`', priority:260
msgid "Shortcut for `--move --force`."
msgstr "`--move --force`的快捷方式。"

#. type: Labeled list
#: en/git-branch.txt:139
#, ignore-same, no-wrap, priority:260
msgid "--copy"
msgstr "--copy"

#. type: Plain text
#: en/git-branch.txt:141
#, priority:260
msgid "Copy a branch, together with its config and reflog."
msgstr "复制分支及其配置和引用日志。"

#. type: Plain text
#: en/git-branch.txt:142 en/git-fast-export.txt:54 en/git-rebase.txt:659
#, ignore-same, no-wrap, priority:260
msgid "-C"
msgstr "-C"

#. type: Plain text
#: en/git-branch.txt:144
#, placeholders:'`--copy':'--force`', priority:260
msgid "Shortcut for `--copy --force`."
msgstr "`--copy --force`的快捷方式。"

#. type: Plain text
#: en/git-branch.txt:149
#, priority:260
msgid "Color branches to highlight current, local, and remote-tracking branches. The value must be always (the default), never, or auto."
msgstr "给分支着色，以突出当前、本地和远程跟踪的分支。 该值必须是始终（默认）、从不或自动。"

#. type: Plain text
#: en/git-branch.txt:154
#, placeholders:'`--color=never`', priority:260
msgid "Turn off branch colors, even when the configuration file gives the default to color output. Same as `--color=never`."
msgstr "关闭分支的颜色，即使在配置文件中默认为彩色输出。 与`--color=never`相同。"

#. type: Labeled list
#: en/git-branch.txt:156 en/git-for-each-ref.txt:96 en/git-grep.txt:83 en/git-tag.txt:131
#, ignore-same, no-wrap, priority:260
msgid "--ignore-case"
msgstr "--ignore-case"

#. type: Plain text
#: en/git-branch.txt:158
#, priority:260
msgid "Sorting and filtering branches are case insensitive."
msgstr "排序和过滤分支是不分大小写的。"

#. type: Labeled list
#: en/git-branch.txt:159 en/git-for-each-ref.txt:99 en/git-tag.txt:134
#, ignore-same, no-wrap, priority:260
msgid "--omit-empty"
msgstr "--omit-empty"

#. type: Plain text
#: en/git-branch.txt:162 en/git-for-each-ref.txt:102 en/git-tag.txt:137
#, priority:260
msgid "Do not print a newline after formatted refs where the format expands to the empty string."
msgstr "在格式化的引用后不打印换行，因为格式化的引用会扩展为空字符串。"

#. type: Labeled list
#: en/git-branch.txt:163 en/git-status.txt:130 en/git-tag.txt:138
#, no-wrap, placeholders:'--column', priority:280
msgid "--column[=<options>]"
msgstr "--column[=<选项>]"

#. type: Labeled list
#: en/git-branch.txt:164 en/git-status.txt:131 en/git-tag.txt:139
#, ignore-same, no-wrap, priority:280
msgid "--no-column"
msgstr "--no-column"

#. type: Plain text
#: en/git-branch.txt:168
#, placeholders:'column.branch':'`--column`':'`--no-column`', priority:260
msgid "Display branch listing in columns. See configuration variable `column.branch` for option syntax. `--column` and `--no-column` without options are equivalent to 'always' and 'never' respectively."
msgstr "在列中显示分支列表。选项语法见配置变量`column.branch`。`--column`和`--no-column`没有选项，分别相当于'always'和'never'。"

#. type: Plain text
#: en/git-branch.txt:170
#, priority:260
msgid "This option is only applicable in non-verbose mode."
msgstr "这个选项只适用于非粗话模式。"

#. type: Labeled list
#: en/git-branch.txt:172 en/git-show-branch.txt:44
#, ignore-same, no-wrap, priority:260
msgid "--remotes"
msgstr "--remotes"

#. type: Plain text
#: en/git-branch.txt:175
#, placeholders:'`--list`', priority:260
msgid "List or delete (if used with -d) the remote-tracking branches. Combine with `--list` to match the optional pattern(s)."
msgstr "列出或删除（如果与-d一起使用）远程跟踪的分支。 与`--list`结合使用，以匹配可选的模式（s）。"

#. type: Plain text
#: en/git-branch.txt:180
#, placeholders:'`--list`', priority:260
msgid "List both remote-tracking branches and local branches. Combine with `--list` to match optional pattern(s)."
msgstr "列出远程跟踪的分支和本地分支。 与`--list`组合，以匹配可选的模式。"

#. type: Plain text
#: en/git-branch.txt:186
#, ignore-ellipsis, placeholders:'--list', priority:260
msgid "List branches. With optional `<pattern>...`, e.g. `git branch --list 'maint-*'`, list only the branches that match the pattern(s)."
msgstr "列出分支。 使用可选的\"<pattern>...\"，例如 \"git branch --list 'maint-*'\"，只列出符合该模式的分支。"

#. type: Labeled list
#: en/git-branch.txt:187
#, ignore-same, no-wrap, priority:260
msgid "--show-current"
msgstr "--show-current"

#. type: Plain text
#: en/git-branch.txt:190
#, placeholders:'HEAD', priority:260
msgid "Print the name of the current branch. In detached HEAD state, nothing is printed."
msgstr "打印当前分支的名称。在分离的HEAD状态下，不打印任何东西。"

#. type: Labeled list
#: en/git-branch.txt:192
#, ignore-same, no-wrap, priority:260
msgid "-vv"
msgstr "-vv"

#. type: Plain text
#: en/git-branch.txt:201
#, placeholders:'HEAD', priority:260
msgid "When in list mode, show sha1 and commit subject line for each head, along with relationship to upstream branch (if any). If given twice, print the path of the linked worktree (if any) and the name of the upstream branch, as well (see also `git remote show <remote>`). Note that the current worktree's HEAD will not have its path printed (it will always be your current directory)."
msgstr "当在列表模式下，显示每个头的sha1和提交主题行，以及与上游分支的关系（如果有的话）。如果给了两次，也会打印链接的工作树的路径（如果有的话）和上游分支的名称（也见 `git remote show <remote>`）。 请注意，当前工作树的HEAD不会打印其路径（它总是你的当前目录）。"

#. type: Plain text
#: en/git-branch.txt:206
#, priority:260
msgid "Be more quiet when creating or deleting a branch, suppressing non-error messages."
msgstr "在创建或删除一个分支时更加安静，抑制非错误信息。"

#. type: Plain text
#: en/git-branch.txt:213
#, placeholders:'core.abbrev', priority:260
msgid "In the verbose listing that show the commit object name, show the shortest prefix that is at least '<n>' hexdigits long that uniquely refers the object. The default value is 7 and can be overridden by the `core.abbrev` config option."
msgstr "在显示提交对象名称的冗长列表中，显示至少有'<n>'个六位数的最短前缀，以唯一地指代该对象。 默认值是7，可以通过`core.abbrev`配置选项覆盖。"

#. type: Labeled list
#: en/git-branch.txt:214
#, ignore-same, no-wrap, priority:260
msgid "--no-abbrev"
msgstr "--no-abbrev"

#. type: Plain text
#: en/git-branch.txt:216
#, priority:260
msgid "Display the full sha1s in the output listing rather than abbreviating them."
msgstr "在输出列表中显示完整的sha1，而不是缩写它们。"

# ERROR: --track[=(direct|inherit)] not found in translation
#. type: Labeled list
#: en/git-branch.txt:218 en/git-checkout.txt:165
#, ignore-same, no-wrap, priority:260
msgid "--track[=(direct|inherit)]"
msgstr "--track[=(direct|inherit)]"

#. type: Plain text
#: en/git-branch.txt:226
#, priority:260
msgid "When creating a new branch, set up `branch.<name>.remote` and `branch.<name>.merge` configuration entries to set \"upstream\" tracking configuration for the new branch. This configuration will tell git to show the relationship between the two branches in `git status` and `git branch -v`. Furthermore, it directs `git pull` without arguments to pull from the upstream when the new branch is checked out."
msgstr "在创建一个新分支时，设置 `branch.<name>.remote` 和 `branch.<name>.merge` 配置项来为新分支设置“上游”追踪。这个配置将告诉 git 在 `git status` 和 `git branch -v` 中显示这两个分支之间的关系（译者注：应该是 `git branch -vv` 命令而不是 `git branch -v` 命令，这样才会显示某一分支的上游）。此外，它还指示了在该新分支上运行不带参数的 `git pull` 命令时，将直接从上游拉取。"

#. type: Plain text
#: en/git-branch.txt:231
#, placeholders:'`-t`':'`--track`':'`--track=direct`':'`--track=inherit`', priority:260
msgid "The exact upstream branch is chosen depending on the optional argument: `-t`, `--track`, or `--track=direct` means to use the start-point branch itself as the upstream; `--track=inherit` means to copy the upstream configuration of the start-point branch."
msgstr "想要选择确切的上游分支可以使用可选参数：`-t`、`--track` 或 `--track=direct`，这些参数均表示使用 <start-point> 分支本身作为上游分支；`--track=inherit` 表示继承 <start-point> 分支的上游配置。"

#. type: Plain text
#: en/git-branch.txt:235
#, placeholders:'branch.autoSetupMerge':'`--track`':'`--no-track`', priority:260
msgid "The branch.autoSetupMerge configuration variable specifies how `git switch`, `git checkout` and `git branch` should behave when neither `--track` nor `--no-track` are specified:"
msgstr "branch.autoSetupMerge配置变量指定了当既不指定`--track`也不指定`--no-track`时，`git switch`、`git checkout`和`git branch`应如何运行："

# ERROR: `--track=inherit` not found in translation
#. type: Plain text
#: en/git-branch.txt:243
#, placeholders:'`--track=direct`':'`--no-track`':'`--track=direct`':'`--track=inherit`':'`--track=direct`', priority:260
msgid "The default option, `true`, behaves as though `--track=direct` were given whenever the start-point is a remote-tracking branch. `false` behaves as if `--no-track` were given. `always` behaves as though `--track=direct` were given. `inherit` behaves as though `--track=inherit` were given. `simple` behaves as though `--track=direct` were given only when the start-point is a remote-tracking branch and the new branch has the same name as the remote branch."
msgstr "默认选项 `true`，在起点是远程跟踪分支的情况下，就像给了 `--track=direct`。 `false` 的行为就像给了 `--no-track` 一样。`always`的行为就像给了 `--track=direct` 一样。继承(inherit)的行为就像给了 `--track=inherit` 一样。`simple`的行为就像给了`--track=direct`一样，只有当起点是远程跟踪的分支，并且新的分支与远程分支有相同的名字时，才会有这种行为。"

#. type: Plain text
#: en/git-branch.txt:246
#, placeholders:'linkgit:git-pull[1]':'linkgit:git-config[1]', priority:260
msgid "See linkgit:git-pull[1] and linkgit:git-config[1] for additional discussion on how the `branch.<name>.remote` and `branch.<name>.merge` options are used."
msgstr "有关如何使用 `branch.<名称>.remote` 和 `branch.<名称>.merge` 选项的更多讨论，请参见 linkgit:git-pull[1] 和 linkgit:git-config[1]。"

#. type: Labeled list
#: en/git-branch.txt:247 en/git-checkout.txt:179 en/git-switch.txt:174
#, ignore-same, no-wrap, priority:260
msgid "--no-track"
msgstr "--no-track"

#. type: Plain text
#: en/git-branch.txt:250
#, placeholders:'branch.autoSetupMerge', priority:260
msgid "Do not set up \"upstream\" configuration, even if the branch.autoSetupMerge configuration variable is set."
msgstr "不要设置 “上游仓库” 配置，即使 branch.autoSetupMerge 配置变量为 true。"

#. type: Labeled list
#: en/git-branch.txt:251 en/git-checkout.txt:304 en/git-grep.txt:64 en/git-ls-files.txt:182 en/git-restore.txt:114 en/git-switch.txt:188
#, ignore-same, no-wrap, priority:280
msgid "--recurse-submodules"
msgstr "--recurse-submodules"

#. type: Plain text
#: en/git-branch.txt:257
#, placeholders:'submodule.propagateBranches':'submodule.propagateBranches':'linkgit:git-config[1]', priority:260
msgid "THIS OPTION IS EXPERIMENTAL! Causes the current command to recurse into submodules if `submodule.propagateBranches` is enabled. See `submodule.propagateBranches` in linkgit:git-config[1]. Currently, only branch creation is supported."
msgstr "这个选项是实验性的！！！如果 `submodule.propagateBranches` 被启用，会导致当前命令递归到子模块。参见 linkgit:git-config[1] 中的 `submodule.propagateBranches`。目前，只支持创建分支。"

#. type: Plain text
#: en/git-branch.txt:266
#, placeholders:'--recurse-submodules', priority:260
msgid "When used in branch creation, a new branch <branchname> will be created in the superproject and all of the submodules in the superproject's <start-point>. In submodules, the branch will point to the submodule commit in the superproject's <start-point> but the branch's tracking information will be set up based on the submodule's branches and remotes e.g. `git branch --recurse-submodules topic origin/main` will create the submodule branch \"topic\" that points to the submodule commit in the superproject's \"origin/main\", but tracks the submodule's \"origin/main\"."
msgstr "当在分支创建中使用时，一个新的分支<branchname>将在父项目和父项目的<start-point>中的所有子模块中创建。在子模块中，该分支将指向超级项目的<start-point>中的子模块提交，但该分支的跟踪信息将根据子模块的分支和远程来设置，例如`git branch --recurse-submodules topic origin/main`将创建一个子模块分支 \"topic\"，指向父项目的 \"origin/main \"中的子模块提交，但跟踪子模块的 \"origin/main\"。"

#. type: Plain text
#: en/git-branch.txt:270
#, placeholders:'`--track`':'`--set-upstream-to`', priority:260
msgid "As this option had confusing syntax, it is no longer supported. Please use `--track` or `--set-upstream-to` instead."
msgstr "由于这个选项的语法混乱，不再支持。 请使用`--track`或`--set-upstream-to`代替。"

#. type: Labeled list
#: en/git-branch.txt:271
#, no-wrap, priority:260
msgid "-u <upstream>"
msgstr "-u <上行>"

#. type: Labeled list
#: en/git-branch.txt:272
#, no-wrap, placeholders:'--set-upstream-to=', priority:260
msgid "--set-upstream-to=<upstream>"
msgstr "--set-upstream-to=<上游仓库>"

#. type: Plain text
#: en/git-branch.txt:276
#, priority:260
msgid "Set up <branchname>'s tracking information so <upstream> is considered <branchname>'s upstream branch. If no <branchname> is specified, then it defaults to the current branch."
msgstr "设置<branchname>的跟踪信息，使<upstream>被视为<branchname>的上游分支。如果没有指定<branchname>，则默认为当前分支。"

#. type: Labeled list
#: en/git-branch.txt:277
#, ignore-same, no-wrap, priority:260
msgid "--unset-upstream"
msgstr "--unset-upstream"

#. type: Plain text
#: en/git-branch.txt:280
#, priority:260
msgid "Remove the upstream information for <branchname>. If no branch is specified it defaults to the current branch."
msgstr "删除<branchname>的上游信息。如果没有指定分支，则默认为当前分支。"

#. type: Labeled list
#: en/git-branch.txt:281
#, ignore-same, no-wrap, priority:260
msgid "--edit-description"
msgstr "--edit-description"

#. type: Plain text
#: en/git-branch.txt:286
#, priority:260
msgid "Open an editor and edit the text to explain what the branch is for, to be used by various other commands (e.g. `format-patch`, `request-pull`, and `merge` (if enabled)). Multi-line explanations may be used."
msgstr "打开一个编辑器，编辑文本，解释该分支的用途，以便被其他各种命令（如`format-patch`、`request-pull`和`merge`（如果启用））使用。可以使用多行解释。"

#. type: Labeled list
#: en/git-branch.txt:287 en/git-tag.txt:146
#, no-wrap, placeholders:'--contains', priority:260
msgid "--contains [<commit>]"
msgstr "--contains [<提交>]"

#. type: Plain text
#: en/git-branch.txt:290
#, placeholders:'HEAD':'`--list`', priority:260
msgid "Only list branches which contain the specified commit (HEAD if not specified). Implies `--list`."
msgstr "只列出包含指定提交的分支（如果没有指定则为HEAD）。意味着 `--list`。"

#. type: Labeled list
#: en/git-branch.txt:291 en/git-tag.txt:150
#, no-wrap, placeholders:'--no-contains', priority:260
msgid "--no-contains [<commit>]"
msgstr "--no-contains [<提交>]"

#. type: Plain text
#: en/git-branch.txt:294
#, placeholders:'HEAD':'`--list`', priority:260
msgid "Only list branches which don't contain the specified commit (HEAD if not specified). Implies `--list`."
msgstr "只列出不包含指定提交的分支（如果不指定则为HEAD）。意味着 `--list`。"

#. type: Labeled list
#: en/git-branch.txt:295 en/git-tag.txt:154
#, no-wrap, placeholders:'--merged', priority:260
msgid "--merged [<commit>]"
msgstr "--merged [<提交>]"

#. type: Plain text
#: en/git-branch.txt:298
#, placeholders:'HEAD':'`--list`', priority:260
msgid "Only list branches whose tips are reachable from the specified commit (HEAD if not specified). Implies `--list`."
msgstr "只列出从指定的提交（如果没有指定，则为HEAD）可以到达的分支的提示。意味着 `--list`。"

#. type: Labeled list
#: en/git-branch.txt:299 en/git-tag.txt:158
#, no-wrap, placeholders:'--no-merged', priority:260
msgid "--no-merged [<commit>]"
msgstr "--no-merged [<提交>]"

#. type: Plain text
#: en/git-branch.txt:302
#, placeholders:'HEAD':'`--list`', priority:260
msgid "Only list branches whose tips are not reachable from the specified commit (HEAD if not specified). Implies `--list`."
msgstr "只列出从指定的提交（如果没有指定，则为HEAD）中无法到达的分支。意味着 `--list`。"

#. type: Labeled list
#: en/git-branch.txt:303
#, no-wrap, priority:260
msgid "<branchname>"
msgstr "<branchname>"

#. type: Plain text
#: en/git-branch.txt:308
#, placeholders:'linkgit:git-check-ref-format[1]', priority:260
msgid "The name of the branch to create or delete. The new branch name must pass all checks defined by linkgit:git-check-ref-format[1]. Some of these checks may restrict the characters allowed in a branch name."
msgstr "要创建或删除的分支的名称。 新的分支名必须通过 linkgit:git-check-ref-format[1] 定义的所有检查。 其中一些检查可能会限制分支名称中允许的字符。"

#. type: Labeled list
#: en/git-branch.txt:309 en/git-checkout.txt:353 en/git-switch.txt:42
#, no-wrap, priority:260
msgid "<start-point>"
msgstr "<start-point>"

#. type: Plain text
#: en/git-branch.txt:313
#, placeholders:'HEAD', priority:260
msgid "The new branch head will point to this commit. It may be given as a branch name, a commit-id, or a tag. If this option is omitted, the current HEAD will be used instead."
msgstr "新的分支头将指向这个提交。 它可以是一个分支名，一个提交号，或者一个标签。 如果省略此选项，将使用当前的HEAD来代替。"

#. type: Labeled list
#: en/git-branch.txt:314
#, no-wrap, priority:260
msgid "<oldbranch>"
msgstr "<旧分支>"

#. type: Plain text
#: en/git-branch.txt:317
#, priority:260
msgid "The name of an existing branch. If this option is omitted, the name of the current branch will be used instead."
msgstr "新的分支头将指向这个提交。 它可以是一个分支名，一个提交号，或者一个标签。 如果省略此选项，将使用当前的HEAD来代替。"

#. type: Labeled list
#: en/git-branch.txt:318
#, no-wrap, priority:260
msgid "<newbranch>"
msgstr "<新分支>"

#. type: Plain text
#: en/git-branch.txt:321
#, priority:260
msgid "The new name for an existing branch. The same restrictions as for <branchname> apply."
msgstr "现有分支的新名称。与<branchname>的限制相同。"

#. type: Labeled list
#: en/git-branch.txt:322 en/git-for-each-ref.txt:46 en/git-ls-remote.txt:65 en/git-tag.txt:112
#, no-wrap, placeholders:'--sort=', priority:260
msgid "--sort=<key>"
msgstr "--sort=<键>"

#. type: Plain text
#: en/git-branch.txt:332
#, ignore-ellipsis, placeholders:'--sort=':'git for-each-ref':'branch.sort':'HEAD':'linkgit:git-config[1]', priority:260
msgid "Sort based on the key given. Prefix `-` to sort in descending order of the value. You may use the --sort=<key> option multiple times, in which case the last key becomes the primary key. The keys supported are the same as those in `git for-each-ref`. Sort order defaults to the value configured for the `branch.sort` variable if it exists, or to sorting based on the full refname (including `refs/...` prefix). This lists detached HEAD (if present) first, then local branches and finally remote-tracking branches. See linkgit:git-config[1]."
msgstr "根据给定的键进行排序。前缀\"-\"表示按照数值的降序排序。你可以多次使用 --sort=<键> 选项，在这种情况下，最后一个键成为主键。支持的键与 `git for-each-ref` 中的键相同。排序顺序默认为 `branch.sort` 变量的配置值（如果存在），或者基于完整的引用名（包括 `refs/...` 前缀）进行排序。这将首先列出分离的 HEAD（如果存在），然后是本地分支，最后是远程跟踪分支。参见 linkgit:git-config[1]。"

#. type: Labeled list
#: en/git-branch.txt:334 en/git-tag.txt:162
#, no-wrap, placeholders:'--points-at', priority:260
msgid "--points-at <object>"
msgstr "--points-at <对象>"

#. type: Plain text
#: en/git-branch.txt:336
#, priority:260
msgid "Only list branches of the given object."
msgstr "只列出给定对象的分支。"

#. type: Labeled list
#: en/git-branch.txt:337
#, no-wrap, placeholders:'--format', priority:260
msgid "--format <format>"
msgstr "--format <格式>"

#. type: Plain text
#: en/git-branch.txt:341
#, placeholders:'linkgit:git-for-each-ref[1]', priority:260
msgid "A string that interpolates `%(fieldname)` from a branch ref being shown and the object it points at. The format is the same as that of linkgit:git-for-each-ref[1]."
msgstr "一个字符串，从正在显示的分支参考文献和它所指向的对象中插值`%(fieldname)'。 其格式与linkgit:git-for-each-ref[1]的格式相同。"

#. type: Plain text
#: en/git-branch.txt:347
#, placeholders:'pager.branch':'`--list`':'linkgit:git-config[1]', priority:260
msgid "`pager.branch` is only respected when listing branches, i.e., when `--list` is used or implied. The default is to use a pager. See linkgit:git-config[1]."
msgstr "`pager.branch`只在列出分支时被尊重，即使用或暗示使用`--list`时。默认情况是使用 pager。 参见 linkgit:git-config[1]。"

#. type: Labeled list
#: en/git-branch.txt:355
#, no-wrap, priority:260
msgid "Start development from a known tag"
msgstr "从一个已知的标签开始开发"

#. type: delimited block -
#: en/git-branch.txt:362
#, ignore-ellipsis, no-wrap, placeholders:'git.kernel.org', priority:260
msgid ""
"$ git clone git://git.kernel.org/pub/scm/.../linux-2.6 my2.6\n"
"$ cd my2.6\n"
"$ git branch my2.6.14 v2.6.14   <1>\n"
"$ git switch my2.6.14\n"
msgstr ""
"$ git clone git://git.kernel.org/pub/scm/.../linux-2.6 my2.6\n"
"$ cd my2.6\n"
"$ git branch my2.6.14 v2.6.14 <1>.\n"
"$ git switch my2.6.14\n"

#. type: Plain text
#: en/git-branch.txt:366
#, priority:260
msgid "This step and the next one could be combined into a single step with \"checkout -b my2.6.14 v2.6.14\"."
msgstr "这一步和下一步可以用 \"checkout -b my2.6.14 v2.6.14 \"合并为一个步骤。"

#. type: Labeled list
#: en/git-branch.txt:367
#, no-wrap, priority:260
msgid "Delete an unneeded branch"
msgstr "删除一个不需要的分支"

#. type: delimited block -
#: en/git-branch.txt:374
#, ignore-ellipsis, no-wrap, placeholders:'git.kernel.org':'git.git':'my.git':'my.git', priority:260
msgid ""
"$ git clone git://git.kernel.org/.../git.git my.git\n"
"$ cd my.git\n"
"$ git branch -d -r origin/todo origin/html origin/man   <1>\n"
"$ git branch -D test                                    <2>\n"
msgstr ""
"$ git clone git://git.kernel.org/.../git.git my.git\n"
"$ cd my.git\n"
"$ git branch -d -r origin/todo origin/html origin/man   <1>\n"
"$ git branch -D test                                    <2>\n"

#. type: Plain text
#: en/git-branch.txt:379
#, placeholders:'linkgit:git-fetch[1]', priority:260
msgid "Delete the remote-tracking branches \"todo\", \"html\" and \"man\". The next 'fetch' or 'pull' will create them again unless you configure them not to. See linkgit:git-fetch[1]."
msgstr "删除远程跟踪的分支 \"todo\"、\"html \"和 \"man\"。下一次的 \"fetch \"或 \"pull \"会再次创建它们，除非你配置它们不这样做。 参见 linkgit:git-fetch[1]。"

#. type: Plain text
#: en/git-branch.txt:381
#, priority:260
msgid "Delete the \"test\" branch even if the \"master\" branch (or whichever branch is currently checked out) does not have all commits from the test branch."
msgstr "删除 \"测试 \"分支，即使 \"主 \"分支（或当前签出的任何一个分支）没有测试分支的所有提交。"

#. type: Labeled list
#: en/git-branch.txt:382
#, no-wrap, priority:260
msgid "Listing branches from a specific remote"
msgstr "从一个特定的远端列出分支"

#. type: delimited block -
#: en/git-branch.txt:387
#, no-wrap, placeholders:'git for-each-ref', priority:260
msgid ""
"$ git branch -r -l '<remote>/<pattern>'                 <1>\n"
"$ git for-each-ref 'refs/remotes/<remote>/<pattern>'    <2>\n"
msgstr ""
"$ git branch -r -l '<远程仓库>/<模式>'                 <1>\n"
"$ git for-each-ref 'refs/remotes/<远程仓库>/<模式>'    <2>\n"

#. type: Plain text
#: en/git-branch.txt:391
#, placeholders:'`-a`', priority:260
msgid "Using `-a` would conflate <remote> with any local branches you happen to have been prefixed with the same <remote> pattern."
msgstr "使用`-a`会将<remote>与任何你碰巧以相同的<remote>模式为前缀的本地分支混淆。"

#. type: Plain text
#: en/git-branch.txt:392
#, placeholders:'linkgit:git-for-each-ref[1]', priority:260
msgid "`for-each-ref` can take a wide range of options. See linkgit:git-for-each-ref[1]"
msgstr "`for-each-ref` 可以接受一系列的选项。参见 linkgit:git-for-each-ref[1]"

#. type: Plain text
#: en/git-branch.txt:394
#, priority:260
msgid "Patterns will normally need quoting."
msgstr "图案通常需要引证。"

#. type: Plain text
#: en/git-branch.txt:401
#, placeholders:'`-c`', priority:260
msgid "If you are creating a branch that you want to switch to immediately, it is easier to use the \"git switch\" command with its `-c` option to do the same thing with a single command."
msgstr "如果你正在创建一个你想立即切换到的分支，使用 \"git switch \"命令及其`-c`选项，用一条命令做同样的事情，会更容易。"

# ERROR: --contains not found in translation
# ERROR: --no-contains not found in translation
# ERROR: --merged not found in translation
# ERROR: --no-merged not found in translation
#. type: Plain text
#: en/git-branch.txt:404
#, placeholders:'`--contains`':'`--no-contains`':'`--merged`':'`--no-merged`', priority:260
msgid "The options `--contains`, `--no-contains`, `--merged` and `--no-merged` serve four related but different purposes:"
msgstr "选项 `--contains`, `--no-contains`, `--merged` 和 `--no-merged` 分别用于执行四个相关但不同的功能："

#. type: Plain text
#: en/git-branch.txt:408
#, placeholders:'`--contains', priority:260
msgid "`--contains <commit>` is used to find all branches which will need special attention if <commit> were to be rebased or amended, since those branches contain the specified <commit>."
msgstr "`--contains <commit>`用于查找所有在<commit>被重新编译或修改时需要特别关注的分支，因为这些分支包含指定的<commit>。"

#. type: Plain text
#: en/git-branch.txt:411
#, placeholders:'`--no-contains', priority:260
msgid "`--no-contains <commit>` is the inverse of that, i.e. branches that don't contain the specified <commit>."
msgstr "`--no-contains <commit>`是其反义词，即不包含指定<commit>的分支。"

#. type: Plain text
#: en/git-branch.txt:414
#, placeholders:'`--merged`':'HEAD', priority:260
msgid "`--merged` is used to find all branches which can be safely deleted, since those branches are fully contained by HEAD."
msgstr "`--merged`用于查找所有可以安全删除的分支，因为这些分支被HEAD完全包含。"

#. type: Plain text
#: en/git-branch.txt:417
#, placeholders:'`--no-merged`':'HEAD':'HEAD', priority:260
msgid "`--no-merged` is used to find branches which are candidates for merging into HEAD, since those branches are not fully contained by HEAD."
msgstr "`--no-merged`是用来寻找可以合并到HEAD的候选分支，因为这些分支没有被HEAD完全包含。"

#. type: Plain text
#: en/git-branch.txt:427
#, placeholders:'linkgit:git-check-ref-format[1]':'linkgit:git-fetch[1]':'linkgit:git-remote[1]':'link:user-manual.html#what-is-a-branch[', priority:260
msgid "linkgit:git-check-ref-format[1], linkgit:git-fetch[1], linkgit:git-remote[1], link:user-manual.html#what-is-a-branch[``Understanding history: What is a branch?''] in the Git User's Manual."
msgstr "linkgit:git-check-ref-format[1], linkgit:git-fetch[1], linkgit:git-remote[1], link:user-manual.html#what-is-a-branch[``了解历史：什么是分支？'] 在 Git User's Manual。"

#. type: Title =
#: en/git-bugreport.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-bugreport(1)"
msgstr "git-bugreport(1)"

#. type: Plain text
#: en/git-bugreport.txt:7
#, placeholders:'git-bugreport', priority:100
msgid "git-bugreport - Collect information for user to file a bug report"
msgstr "git-bugreport - 收集用户提交错误报告的信息"

#. type: Plain text
#: en/git-bugreport.txt:13
#, no-wrap, placeholders:'--output-directory':'--suffix':'[--diagnose', priority:100
msgid ""
"'git bugreport' [(-o | --output-directory) <path>] [(-s | --suffix) <format>]\n"
"\t\t[--diagnose[=<mode>]]\n"
msgstr ""
"'git bugreport' [(-o | --output-directory) <path>] [(-s | --suffix) <格式>]\n"
"\t\t[--diagnose[=<模式>]]\n"

#. type: Plain text
#: en/git-bugreport.txt:21
#, priority:100
msgid "Collects information about the user's machine, Git client, and repository state, in addition to a form requesting information about the behavior the user observed, and stores it in a single text file which the user can then share, for example to the Git mailing list, in order to report an observed bug."
msgstr "捕获关于用户的机器、Git 客户端和仓库状态的信息，以及要求提供用户观察到的行为信息的表格，并将其放入一个文本文件中，然后用户可以分享该文件，例如分享到 Git 邮件列表，以便报告观察到的错误。"

#. type: Plain text
#: en/git-bugreport.txt:23
#, priority:100
msgid "The following information is requested from the user:"
msgstr "要求用户提供以下信息："

#. type: Plain text
#: en/git-bugreport.txt:25
#, priority:100
msgid "Reproduction steps"
msgstr "再生产步骤"

#. type: Plain text
#: en/git-bugreport.txt:26
#, priority:100
msgid "Expected behavior"
msgstr "预期的行为"

#. type: Plain text
#: en/git-bugreport.txt:27
#, priority:100
msgid "Actual behavior"
msgstr "实际行为"

#. type: Plain text
#: en/git-bugreport.txt:29
#, priority:100
msgid "The following information is captured automatically:"
msgstr "以下信息是自动采集的："

#. type: Plain text
#: en/git-bugreport.txt:31
#, placeholders:'--build-options', priority:100
msgid "'git version --build-options'"
msgstr "'git version --build-options'"

#. type: Plain text
#: en/git-bugreport.txt:32
#, priority:100
msgid "uname sysname, release, version, and machine strings"
msgstr "uname 系统名、版本、版本和机器字符串"

#. type: Plain text
#: en/git-bugreport.txt:33
#, priority:100
msgid "Compiler-specific info string"
msgstr "编译器特定信息字符串"

#. type: Plain text
#: en/git-bugreport.txt:34
#, priority:100
msgid "A list of enabled hooks"
msgstr "启用的钩子的列表"

#. type: Plain text
#: en/git-bugreport.txt:35
#, placeholders:'$SHELL', priority:100
msgid "$SHELL"
msgstr "$SHELL"

#. type: Plain text
#: en/git-bugreport.txt:39
#, placeholders:'`--diagnose`', priority:100
msgid "Additional information may be gathered into a separate zip archive using the `--diagnose` option, and can be attached alongside the bugreport document to provide additional context to readers."
msgstr "额外的信息可以使用 `--diagnose` 选项收集到一个单独的压缩文件中，并可以与 bugreport 文件一起附上，为读者提供额外的上下文。"

#. type: Plain text
#: en/git-bugreport.txt:44
#, priority:100
msgid "This tool is invoked via the typical Git setup process, which means that in some cases, it might not be able to launch - for example, if a relevant config file is unreadable. In this kind of scenario, it may be helpful to manually gather the kind of information listed above when manually asking for help."
msgstr "这个工具是通过典型的 Git 设置过程调用的，这意味着在某些情况下，它可能无法启动——例如，如果相关的配置文件无法读取。在这种情况下，在手动请求帮助时，手动收集上面列出的那种信息可能会有帮助。"

#. type: Labeled list
#: en/git-bugreport.txt:47
#, no-wrap, priority:100
msgid "-o <path>"
msgstr "-o <路径>"

#. type: Labeled list
#: en/git-bugreport.txt:48
#, no-wrap, placeholders:'--output-directory', priority:100
msgid "--output-directory <path>"
msgstr "--output-directory <路径>"

#. type: Plain text
#: en/git-bugreport.txt:51
#, priority:100
msgid "Place the resulting bug report file in `<path>` instead of the current directory."
msgstr "将产生的错误报告文件放在 `<路径>` 而不是当前目录中。"

#. type: Labeled list
#: en/git-bugreport.txt:52
#, no-wrap, priority:100
msgid "-s <format>"
msgstr "-s <格式>"

#. type: Labeled list
#: en/git-bugreport.txt:53
#, no-wrap, placeholders:'--suffix', priority:100
msgid "--suffix <format>"
msgstr "--suffix <格式>"

#. type: Plain text
#: en/git-bugreport.txt:57
#, placeholders:'git-bugreport-', priority:100
msgid "Specify an alternate suffix for the bugreport name, to create a file named 'git-bugreport-<formatted-suffix>'. This should take the form of a strftime(3) format string; the current local time will be used."
msgstr "为 bugreport 名称指定一个备用后缀，以创建一个名为 \"git-bugreport-<格式化后缀>\"的文件。这应该采取 strftime(3) 格式字符串的形式；将使用当前的本地时间。"

#. type: Labeled list
#: en/git-bugreport.txt:58
#, ignore-same, no-wrap, priority:100
msgid "--no-diagnose"
msgstr "--no-diagnose"

# ERROR: --diagnose not found in translation
#. type: Labeled list
#: en/git-bugreport.txt:59
#, no-wrap, placeholders:'--diagnose', priority:100
msgid "--diagnose[=<mode>]"
msgstr "--diagnose[=<模式>]"

#. type: Plain text
#: en/git-bugreport.txt:64
#, placeholders:'git-diagnostics-', priority:100
msgid "Create a zip archive of supplemental information about the user's machine, Git client, and repository state. The archive is written to the same output directory as the bug report and is named 'git-diagnostics-<formatted-suffix>'."
msgstr "创建一个包含用户机器、Git 客户端和仓库状态等补充信息的 zip 档案。该归档文件与错误报告写入同一输出目录，并命名为 'git-diagnostics-<格式化后缀>'。"

#. type: Plain text
#: en/git-bugreport.txt:70
#, placeholders:'linkgit:git-diagnose[1]', priority:100
msgid "Without `mode` specified, the diagnostic archive will contain the default set of statistics reported by `git diagnose`. An optional `mode` value may be specified to change which information is included in the archive. See linkgit:git-diagnose[1] for the list of valid values for `mode` and details about their usage."
msgstr "如果没有指定`mode'，诊断档案将包含 `git diagnose` 报告的默认统计信息。可以指定一个可选的 `mode` 值来改变存档中包含的信息。参见 linkgit:git-diagnose[1]，了解 `mode` 的有效值列表及其使用细节。"

#. type: Title =
#: en/git-bundle.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-bundle(1)"
msgstr "git-bundle(1)"

#. type: Plain text
#: en/git-bundle.txt:7
#, placeholders:'git-bundle', priority:100
msgid "git-bundle - Move objects and refs by archive"
msgstr "git-bundle - 通过存档移动对象和引用"

#. type: Plain text
#: en/git-bundle.txt:17
#, ignore-ellipsis, no-wrap, placeholders:'--quiet':'--progress]':'[--version=':'--quiet]':'[--progress]', priority:100
msgid ""
"'git bundle' create [-q | --quiet | --progress]\n"
"\t\t    [--version=<version>] <file> <git-rev-list-args>\n"
"'git bundle' verify [-q | --quiet] <file>\n"
"'git bundle' list-heads <file> [<refname>...]\n"
"'git bundle' unbundle [--progress] <file> [<refname>...]\n"
msgstr ""
"'git bundle' create [-q | --quiet | --progress]\n"
"\t\t    [--version=<版本>] <文件> <git-rev-list-args>\n"
"'git bundle' verify [-q | --quiet] <文件>\n"
"'git bundle' list-heads <文件> [<引用名>...]\n"
"'git bundle' unbundle [--progress] <文件> [<引用名>...]\n"

#. type: Plain text
#: en/git-bundle.txt:24
#, priority:100
msgid "Create, unpack, and manipulate \"bundle\" files. Bundles are used for the \"offline\" transfer of Git objects without an active \"server\" sitting on the other side of the network connection."
msgstr "创建、解包和操作 “打包” 文件。捆绑文件用于 Git 对象的 “离线” 传输，而不需要在网络连接的另一端有一个活跃的 “服务器”。"

#. type: Plain text
#: en/git-bundle.txt:28
#, priority:100
msgid "They can be used to create both incremental and full backups of a repository, and to relay the state of the references in one repository to another."
msgstr "它们可以用来创建仓库的增量和完全备份，并将一个仓库中的引用状态传递给另一个版本库。"

#. type: Plain text
#: en/git-bundle.txt:36
#, placeholders:'linkgit:git-clone[1]':'linkgit:git-fetch[1]':'linkgit:git-ls-remote[1]', priority:100
msgid "Git commands that fetch or otherwise \"read\" via protocols such as `ssh://` and `https://` can also operate on bundle files. It is possible linkgit:git-clone[1] a new repository from a bundle, to use linkgit:git-fetch[1] to fetch from one, and to list the references contained within it with linkgit:git-ls-remote[1]. There's no corresponding \"write\" support, i.e.a 'git push' into a bundle is not supported."
msgstr "通过 `ssh://` 和 `https://` 等协议获取或以其他方式 “读取” 的 Git 命令也可以对打包文件进行操作。它可以通过 linkgit:git-clone[1] 从打包中建立新的仓库，用 linkgit:git-fetch[1] 从其中获取，并通过 linkgit:git-ls-remote[1] 列出其中的引用。没有相应的 \"写\" 支持，也就是说，不支持 'git push' 捆绑包。"

#. type: Plain text
#: en/git-bundle.txt:38
#, priority:100
msgid "See the \"EXAMPLES\" section below for examples of how to use bundles."
msgstr "关于如何使用捆绑包的例子，见下面的 “实例” 部分。"

#. type: Title -
#: en/git-bundle.txt:40
#, no-wrap, priority:100
msgid "BUNDLE FORMAT"
msgstr "捆绑包格式"

#. type: Plain text
#: en/git-bundle.txt:44
#, placeholders:'linkgit:git-pack-objects[1]', priority:100
msgid "Bundles are `.pack` files (see linkgit:git-pack-objects[1]) with a header indicating what references are contained within the bundle."
msgstr "捆绑包是 `.pack` 文件（见 linkgit:git-pack-objects[1]），有一个标头说明捆绑包中包含哪些引用。"

#. type: Plain text
#: en/git-bundle.txt:48
#, priority:100
msgid "Like the packed archive format itself bundles can either be self-contained, or be created using exclusions. See the \"OBJECT PREREQUISITES\" section below."
msgstr "就像打包的归档格式本身一样，捆绑包既可以是独立的，也可以使用排除法创建。 参见下面的 \"目标前提\" 部分。"

#. type: Plain text
#: en/git-bundle.txt:52
#, placeholders:'`--thin`':'linkgit:git-pack-objects[1]':'`--fix-thin`':'linkgit:git-index-pack[1]', priority:100
msgid "Bundles created using revision exclusions are \"thin packs\" created using the `--thin` option to linkgit:git-pack-objects[1], and unbundled using the `--fix-thin` option to linkgit:git-index-pack[1]."
msgstr "使用修订版排除法创建的捆绑包是使用 linkgit:git-pack-objects[1] 的 `--thin` 选项创建的 “轻量包”，并使用 linkgit:git-index-pack[1] 的 `--fix-thin` 选项解除捆绑。"

#. type: Plain text
#: en/git-bundle.txt:58
#, priority:100
msgid "There is no option to create a \"thick pack\" when using revision exclusions, and users should not be concerned about the difference. By using \"thin packs\", bundles created using exclusions are smaller in size. That they're \"thin\" under the hood is merely noted here as a curiosity, and as a reference to other documentation."
msgstr "在使用修订排除法时，没有创建 “复杂包” 的选项，用户不应该担心这种差异。通过使用 “轻量包”，使用排除法创建的捆绑文件尺寸较小。它们在引擎盖下是 “薄” 的，在此只是作为一种好奇，并作为其他文档的参考。"

#. type: Plain text
#: en/git-bundle.txt:61
#, placeholders:'linkgit:gitformat-bundle[5]':'linkgit:gitformat-pack[5]', priority:100
msgid "See linkgit:gitformat-bundle[5] for more details and the discussion of \"thin pack\" in linkgit:gitformat-pack[5] for further details."
msgstr "更多细节见 linkgit:gitformat-bundle[5] ，以及 linkgit:gitformat-pack[5] 中关于 “轻量包” 的讨论。"

#. type: Labeled list
#: en/git-bundle.txt:65
#, no-wrap, priority:100
msgid "create [options] <file> <git-rev-list-args>"
msgstr "create [options] <文件> <git-rev-list-args>"

#. type: Plain text
#: en/git-bundle.txt:70
#, priority:100
msgid "Used to create a bundle named 'file'. This requires the '<git-rev-list-args>' arguments to define the bundle contents. 'options' contains the options specific to the 'git bundle create' subcommand. If 'file' is `-`, the bundle is written to stdout."
msgstr "用来创建一个名为 '<文件>' 的捆绑包。 这需要 '<git-rev-list-args>' 参数来定义包的内容。 '选项' 包含 'git bundle create' 子命令的特定选项。如果 'file' 是 '-'，捆绑内容将被写入标准输出流。"

#. type: Labeled list
#: en/git-bundle.txt:71
#, no-wrap, priority:100
msgid "verify <file>"
msgstr "verify <文件>"

#. type: Plain text
#: en/git-bundle.txt:82
#, placeholders:'linkgit:gitformat-bundle[5]', priority:100
msgid "Used to check that a bundle file is valid and will apply cleanly to the current repository. This includes checks on the bundle format itself as well as checking that the prerequisite commits exist and are fully linked in the current repository. Then, 'git bundle' prints a list of missing commits, if any. Finally, information about additional capabilities, such as \"object filter\", is printed. See \"Capabilities\" in linkgit:gitformat-bundle[5] for more information. The exit code is zero for success, but will be nonzero if the bundle file is invalid. If 'file' is `-`, the bundle is read from stdin."
msgstr "用于检查捆绑包文件是否有效，是否能干净地应用到当前仓库。 这包括对捆绑包格式本身的检查，以及检查前提提交是否存在，并在当前版本库中被完全链接。 然后，'git bundle' 会打印出一个缺失提交的列表，如果有的话。 最后，打印出关于额外能力的信息，比如 “对象过滤器”。更多信息见 linkgit:gitformat-bundle[5] 中的 “能力”。成功时退出代码为零，但如果捆绑包文件无效，退出代码将为非零。如果 'file' 是 `-`，则从标准输入流读取捆绑包文件。"

#. type: Labeled list
#: en/git-bundle.txt:83
#, no-wrap, priority:100
msgid "list-heads <file>"
msgstr "list-heads <文件>"

#. type: Plain text
#: en/git-bundle.txt:87
#, priority:100
msgid "Lists the references defined in the bundle. If followed by a list of references, only references matching those given are printed out. If 'file' is `-`, the bundle is read from stdin."
msgstr "列出捆绑中定义的引用。 如果后面是引用列表，则只打印出与之匹配的引用。如果 'file' 是 `-`，则从标准输入流中读取捆绑包文件。"

#. type: Labeled list
#: en/git-bundle.txt:88
#, no-wrap, priority:100
msgid "unbundle <file>"
msgstr "unbundle <文件>"

#. type: Plain text
#: en/git-bundle.txt:95
#, placeholders:'git index-pack', priority:100
msgid "Passes the objects in the bundle to 'git index-pack' for storage in the repository, then prints the names of all defined references. If a list of references is given, only references matching those in the list are printed. This command is really plumbing, intended to be called only by 'git fetch'. If 'file' is `-`, the bundle is read from stdin."
msgstr "将捆绑包中的对象传递给 'git index-pack' 以存储在仓库中，然后打印出所有定义的引用的名称。如果给了一个引用列表，则只打印列表中匹配的引用。这个命令是真正的管道，只打算由 'git fetch' 调用。 如果 'file' 是 `-`，则从标准输入流读取捆绑包文件。"

#. type: Labeled list
#: en/git-bundle.txt:96
#, no-wrap, priority:100
msgid "<git-rev-list-args>"
msgstr "<git-rev-list-args>"

#. type: Plain text
#: en/git-bundle.txt:105
#, placeholders:'git rev-parse':'git rev-list', priority:100
msgid "A list of arguments, acceptable to 'git rev-parse' and 'git rev-list' (and containing a named ref, see SPECIFYING REFERENCES below), that specifies the specific objects and references to transport. For example, `master~10..master` causes the current master reference to be packaged along with all objects added since its 10th ancestor commit. There is no explicit limit to the number of references and objects that may be packaged."
msgstr "一个参数列表，可以被 'git rev-parse' 和 'git rev-list' 接受（并包含一个命名的引用，见下面的 指定引用），它指定了要传送的特定对象和引用。 例如，`master~10...master` 会导致当前的主引用与自其第 10 次祖先提交后添加的所有对象一起被打包。 对于可以打包的引用和对象的数量没有明确的限制。"

#. type: Labeled list
#: en/git-bundle.txt:107
#, ignore-ellipsis, no-wrap, priority:100
msgid "[<refname>...]"
msgstr "[<引用名>...]"

#. type: Plain text
#: en/git-bundle.txt:113
#, placeholders:'git fetch-pack', priority:100
msgid "A list of references used to limit the references reported as available. This is principally of use to 'git fetch', which expects to receive only those references asked for and not necessarily everything in the pack (in this case, 'git bundle' acts like 'git fetch-pack')."
msgstr "用于限制报告的可用引用的列表。这主要是对 'git fetch' 有用，它希望只收到那些要求的引用，而不一定是包中的所有内容（在这种情况下， 'git bundle' 就像 'git fetch-pack'）。"

#. type: Labeled list
#: en/git-bundle.txt:120
#, no-wrap, placeholders:'--version=', priority:100
msgid "--version=<version>"
msgstr "--version=<版本>"

#. type: Plain text
#: en/git-bundle.txt:125
#, priority:100
msgid "Specify the bundle version. Version 2 is the older format and can only be used with SHA-1 repositories; the newer version 3 contains capabilities that permit extensions. The default is the oldest supported format, based on the hash algorithm in use."
msgstr "指定捆绑包的版本。 版本 2 是较老的格式，只能用于 SHA-1 仓库；较新的版本 3 包含允许扩展的功能。默认是最古老的支持格式，基于使用中的哈希算法。"

#. type: Plain text
#: en/git-bundle.txt:130 en/git-pack-objects.txt:214
#, priority:100
msgid "This flag makes the command not to report its progress on the standard error stream."
msgstr "这个标志使命令不在标准错误流中报告其进度。"

#. type: Title -
#: en/git-bundle.txt:132
#, no-wrap, priority:100
msgid "SPECIFYING REFERENCES"
msgstr "指定引用"

#. type: Plain text
#: en/git-bundle.txt:136
#, priority:100
msgid "Revisions must be accompanied by reference names to be packaged in a bundle."
msgstr "修订必须附有引用名称，才能打包成捆绑包。"

#. type: Plain text
#: en/git-bundle.txt:140
#, priority:100
msgid "More than one reference may be packaged, and more than one set of prerequisite objects can be specified. The objects packaged are those not contained in the union of the prerequisites."
msgstr "可以打包一个以上的引用，也可以指定一组以上的先决条件对象。 被打包的对象是那些不包含在先决条件组合中的对象。"

# ERROR: --abbrev-ref=loose` not found in translation
#. type: Plain text
#: en/git-bundle.txt:145
#, placeholders:'git rev-parse':'--abbrev-ref=loose`':'`--since=10':'days.ago', priority:100
msgid "The 'git bundle create' command resolves the reference names for you using the same rules as `git rev-parse --abbrev-ref=loose`. Each prerequisite can be specified explicitly (e.g. `^master~10`), or implicitly (e.g. `master~10..master`, `--since=10.days.ago master`)."
msgstr "'git bundle create' 命令使用与 `git rev-parse --abbrev-ref=loose` 相同的规则为您解析引用名称。每个先决条件都可以明确指定（例如 `^master~10` ），或者隐含地指定（例如 `master~10...master`，`--since=10.days.ago master`）。"

#. type: Plain text
#: en/git-bundle.txt:148
#, priority:100
msgid "All of these simple cases are OK (assuming we have a \"master\" and \"next\" branch):"
msgstr "所有这些简单的情况都没有问题（假设我们有一个 \"master\" 和 \"next\" 分支）："

#. type: delimited block -
#: en/git-bundle.txt:154
#, no-wrap, placeholders:'master.bundle':'master.bundle':'--stdin':'next.bundle':'next.bundle':'--stdin', priority:100
msgid ""
"$ git bundle create master.bundle master\n"
"$ echo master | git bundle create master.bundle --stdin\n"
"$ git bundle create master-and-next.bundle master next\n"
"$ (echo master; echo next) | git bundle create master-and-next.bundle --stdin\n"
msgstr ""
"$ git bundle create master.bundle master\n"
"$ echo master | git bundle create master.bundle --stdin\n"
"$ git bundle create master-and-next.bundle master next\n"
"$ (echo master; echo next) | git bundle create master-and-next.bundle --stdin\n"

#. type: Plain text
#: en/git-bundle.txt:157
#, placeholders:'`--stdin`', priority:100
msgid "And so are these (and the same but omitted `--stdin` examples):"
msgstr "这些也是如此（还有相同的但省略了 `--stdin` 的例子）："

#. type: delimited block -
#: en/git-bundle.txt:161
#, no-wrap, placeholders:'master.bundle':'updates.bundle', priority:100
msgid ""
"$ git bundle create recent-master.bundle master~10..master\n"
"$ git bundle create recent-updates.bundle master~10..master next~5..next\n"
msgstr ""
"$ git bundle create recent-master.bundle master~10..master\n"
"$ git bundle create recent-updates.bundle master~10..master next~5..next\n"

#. type: Plain text
#: en/git-bundle.txt:165
#, priority:100
msgid "A revision name or a range whose right-hand-side cannot be resolved to a reference is not accepted:"
msgstr "不接受修订名称或其右侧不能被解析为引用的范围："

#. type: delimited block -
#: en/git-bundle.txt:171
#, no-wrap, placeholders:'HEAD.bundle':'git rev-parse':'HEAD':'yesterday.bundle', priority:100
msgid ""
"$ git bundle create HEAD.bundle $(git rev-parse HEAD)\n"
"fatal: Refusing to create empty bundle.\n"
"$ git bundle create master-yesterday.bundle master~10..master~5\n"
"fatal: Refusing to create empty bundle.\n"
msgstr ""
"$ git bundle create HEAD.bundle $(git rev-parse HEAD)\n"
"fatal: 拒绝产生空捆绑包。\n"
"$ git bundle create master-yesterday.bundle master~10..master~5\n"
"fatal: 拒绝产生空捆绑包。\n"

#. type: Title -
#: en/git-bundle.txt:174
#, no-wrap, priority:100
msgid "OBJECT PREREQUISITES"
msgstr "对象的先决条件"

#. type: Plain text
#: en/git-bundle.txt:180
#, priority:100
msgid "When creating bundles it is possible to create a self-contained bundle that can be unbundled in a repository with no common history, as well as providing negative revisions to exclude objects needed in the earlier parts of the history."
msgstr "在创建捆绑包时，可以创建一个独立的捆绑包，可以在没有共同历史的版本库中解绑，也可以提供负修订，以排除历史早期部分所需的对象。"

#. type: Plain text
#: en/git-bundle.txt:185
#, priority:100
msgid "Feeding a revision such as `new` to `git bundle create` will create a bundle file that contains all the objects reachable from the revision `new`. That bundle can be unbundled in any repository to obtain a full history that leads to the revision `new`:"
msgstr "向 `git bundle create` 输入诸如`new'这样的修订版将创建一个捆绑包文件，其中包含所有从 `new` 修订版可以到达的对象。捆绑文件可以在任何版本库中解绑，以获得通往 `new` 版本的完整历史："

#. type: delimited block -
#: en/git-bundle.txt:188
#, no-wrap, priority:100
msgid "$ git bundle create full.bundle new\n"
msgstr "$ git bundle create mybundle -10 master\n"

#. type: Plain text
#: en/git-bundle.txt:193
#, priority:100
msgid "A revision range such as `old..new` will produce a bundle file that will require the revision `old` (and any objects reachable from it) to exist for the bundle to be \"unbundle\"-able:"
msgstr "向`git bundle create` 输入诸如 `new` 这样的修订版将创建一个捆绑包文件，其中包含所有从 `new` 修订版可以到达的对象。捆绑包文件可以在任何仓库中解绑，以获得通往 `new` 版本的完整历史："

#. type: delimited block -
#: en/git-bundle.txt:196
#, no-wrap, priority:100
msgid "$ git bundle create full.bundle old..new\n"
msgstr "$ git bundle create mybundle v1.0.0..master\n"

#. type: Plain text
#: en/git-bundle.txt:201
#, priority:100
msgid "A self-contained bundle without any prerequisites can be extracted into anywhere, even into an empty repository, or be cloned from (i.e., `new`, but not `old..new`)."
msgstr "一个没有任何先决条件的独立软件包可以被提取到任何地方，甚至可以提取到一个空的仓库中，或者被克隆出来（即 `new`，但不是 `old..new`）。"

#. type: Plain text
#: en/git-bundle.txt:205
#, priority:100
msgid "It is okay to err on the side of caution, causing the bundle file to contain objects already in the destination, as these are ignored when unpacking at the destination."
msgstr "谨慎行事是可以的，使捆绑文件包含已经在目的地的对象，因为在目的地解包时这些对象会被忽略。"

#. type: Plain text
#: en/git-bundle.txt:211
#, placeholders:'--mirror`':'`--all`':'`--branches':'--tags`', priority:100
msgid "If you want to match `git clone --mirror`, which would include your refs such as `refs/remotes/*`, use `--all`. If you want to provide the same set of refs that a clone directly from the source repository would get, use `--branches --tags` for the `<git-rev-list-args>`."
msgstr "如果你想匹配 `git clone --mirror`，这将包括你的 refs 如 `refs/remotes/*`，使用 `--all`。 如果你想提供与直接从源码库克隆得到的相同的引用，使用 `--branches --tags` 作为 `<git-rev-list-args>`。"

#. type: Plain text
#: en/git-bundle.txt:215
#, priority:100
msgid "The 'git bundle verify' command can be used to check whether your recipient repository has the required prerequisite commits for a bundle."
msgstr "'git bundle verify' 命令可以用来检查你的接收库是否有一个捆绑包所需的先决条件提交。"

#. type: Plain text
#: en/git-bundle.txt:224
#, priority:100
msgid "Assume you want to transfer the history from a repository R1 on machine A to another repository R2 on machine B. For whatever reason, direct connection between A and B is not allowed, but we can move data from A to B via some mechanism (CD, email, etc.). We want to update R2 with development made on the branch master in R1."
msgstr "假设你想把 A 机器上的版本库 R1 的历史记录转移到 B 机器上的另一个版本库 R2。由于某种原因，A 和 B 之间不允许直接连接，但我们可以通过某种机制（CD、电子邮件等）把数据从 A 转移到 B。 我们想用 R1 中的分支 master 上的开发来更新 R2。"

#. type: Plain text
#: en/git-bundle.txt:229
#, priority:100
msgid "To bootstrap the process, you can first create a bundle that does not have any prerequisites. You can use a tag to remember up to what commit you last processed, in order to make it easy to later update the other repository with an incremental bundle:"
msgstr "为了启动这个过程，你可以先创建一个没有任何先决条件的捆绑包。你可以使用一个标签来记住你最后处理的提交，以方便以后用增量的捆绑包来更新其他仓库："

#. type: delimited block -
#: en/git-bundle.txt:234
#, no-wrap, priority:100
msgid ""
"machineA$ cd R1\n"
"machineA$ git bundle create file.bundle master\n"
"machineA$ git tag -f lastR2bundle master\n"
msgstr ""
"machineA$ cd R1\n"
"machineA$ git bundle create file.bundle master\n"
"machineA$ git tag -f lastR2bundle master\n"

#. type: Plain text
#: en/git-bundle.txt:239
#, priority:100
msgid "Then you transfer file.bundle to the target machine B. Because this bundle does not require any existing object to be extracted, you can create a new repository on machine B by cloning from it:"
msgstr "然后你把 file.bundle 传输到目标机器 B。因为这个捆绑包不需要提取任何现有的对象，你可以通过克隆它在机器 B 上创建一个新的仓库："

#. type: delimited block -
#: en/git-bundle.txt:242
#, no-wrap, priority:100
msgid "machineB$ git clone -b master /home/me/tmp/file.bundle R2\n"
msgstr "机器 B $ git clone -b master /home/me/tmp/file.bundle R2\n"

#. type: Plain text
#: en/git-bundle.txt:247
#, placeholders:'$GIT_DIR', priority:100
msgid "This will define a remote called \"origin\" in the resulting repository that lets you fetch and pull from the bundle. The $GIT_DIR/config file in R2 will have an entry like this:"
msgstr "这将在生成的版本库中定义一个名为 \"origin\" 的远程，让你从捆绑包中获取和拉取。R2 中的 $GIT_DIR/config 文件将有一个这样的条目："

#. type: delimited block -
#: en/git-bundle.txt:252
#, no-wrap, priority:100
msgid ""
"[remote \"origin\"]\n"
"    url = /home/me/tmp/file.bundle\n"
"    fetch = refs/heads/*:refs/remotes/origin/*\n"
msgstr ""
"[remote \"origin\"]\n"
"    url = /home/me/tmp/file.bundle\n"
"    fetch = refs/heads/*:refs/remotes/origin/*\n"

#. type: Plain text
#: en/git-bundle.txt:257
#, placeholders:'mine.git', priority:100
msgid "To update the resulting mine.git repository, you can fetch or pull after replacing the bundle stored at /home/me/tmp/file.bundle with incremental updates."
msgstr "要更新产生的 mine.git 仓库，你可以在用增量更新替换存储在 /home/me/tmp/file.bundle 的捆绑包后取用或拉取。"

#. type: Plain text
#: en/git-bundle.txt:260
#, priority:100
msgid "After working some more in the original repository, you can create an incremental bundle to update the other repository:"
msgstr "在原始仓库中再工作一段时间后，你可以创建一个增量包来更新另一个版本库："

#. type: delimited block -
#: en/git-bundle.txt:265
#, no-wrap, priority:100
msgid ""
"machineA$ cd R1\n"
"machineA$ git bundle create file.bundle lastR2bundle..master\n"
"machineA$ git tag -f lastR2bundle master\n"
msgstr ""
"机器 A $ cd R1\n"
"机器 A $ git bundle create file.bundle lastR2bundle..master\n"
"机器 A $ git tag -f lastR2bundle master\n"

#. type: Plain text
#: en/git-bundle.txt:269
#, priority:100
msgid "You then transfer the bundle to the other machine to replace /home/me/tmp/file.bundle, and pull from it."
msgstr "然后你把捆绑包转移到另一台机器上，以取代 /home/me/tmp/file.bundle，并从其中提取。"

#. type: delimited block -
#: en/git-bundle.txt:273
#, no-wrap, priority:100
msgid ""
"machineB$ cd R2\n"
"machineB$ git pull\n"
msgstr ""
"机器 B $ cd R2\n"
"机器 B $ git pull\n"

#. type: Plain text
#: en/git-bundle.txt:281
#, placeholders:'linkgit:git-log[1]', priority:100
msgid "If you know up to what commit the intended recipient repository should have the necessary objects, you can use that knowledge to specify the prerequisites, giving a cut-off point to limit the revisions and objects that go in the resulting bundle. The previous example used the lastR2bundle tag for this purpose, but you can use any other options that you would give to the linkgit:git-log[1] command. Here are more examples:"
msgstr "如果你知道预期的接收库应该在哪次提交中拥有必要的对象，你可以用这些知识来指定先决条件，给出一个截止点来限制产生的捆绑包中的修订和对象。前面的例子为此使用了 lastR2bundle 标签，但你也可以使用任何其他选项，就像你给 linkgit:git-log[1] 命令的那样。这里有更多的例子："

#. type: Plain text
#: en/git-bundle.txt:283
#, priority:100
msgid "You can use a tag that is present in both:"
msgstr "你可以使用一个在两者中都存在的标签："

#. type: delimited block -
#: en/git-bundle.txt:286
#, no-wrap, priority:100
msgid "$ git bundle create mybundle v1.0.0..master\n"
msgstr "$ git bundle create mybundle v1.0.0..master\n"

#. type: Plain text
#: en/git-bundle.txt:289
#, priority:100
msgid "You can use a prerequisite based on time:"
msgstr "你可以使用基于时间的先决条件："

#. type: delimited block -
#: en/git-bundle.txt:292
#, no-wrap, placeholders:'--since=10', priority:100
msgid "$ git bundle create mybundle --since=10.days master\n"
msgstr "$ git bundle create mybundle --since=10.days master\n"

#. type: Plain text
#: en/git-bundle.txt:295
#, priority:100
msgid "You can use the number of commits:"
msgstr "你可以使用提交的数量："

#. type: delimited block -
#: en/git-bundle.txt:298
#, no-wrap, priority:100
msgid "$ git bundle create mybundle -10 master\n"
msgstr "$ git bundle create mybundle -10 master\n"

#. type: Plain text
#: en/git-bundle.txt:302
#, placeholders:'git-bundle', priority:100
msgid "You can run `git-bundle verify` to see if you can extract from a bundle that was created with a prerequisite:"
msgstr "你可以运行 `git-bundle verify` 来看看你是否可以从一个用先决条件创建的包中提取："

#. type: delimited block -
#: en/git-bundle.txt:305
#, no-wrap, priority:100
msgid "$ git bundle verify mybundle\n"
msgstr "$ git bundle verify mybundle\n"

#. type: Plain text
#: en/git-bundle.txt:309
#, priority:100
msgid "This will list what commits you must have in order to extract from the bundle and will error out if you do not have them."
msgstr "这将列出你必须有哪些提交才能从捆绑包中提取，如果你没有这些提交就会出错。"

#. type: Plain text
#: en/git-bundle.txt:313
#, priority:100
msgid "A bundle from a recipient repository's point of view is just like a regular repository which it fetches or pulls from. You can, for example, map references when fetching:"
msgstr "从接收者仓库的角度来看，一个捆绑包就像一个普通的仓库，它从那里获取或拉取。例如，你可以在获取的时候映射引用："

#. type: delimited block -
#: en/git-bundle.txt:316
#, no-wrap, priority:100
msgid "$ git fetch mybundle master:localRef\n"
msgstr "$ git fetch mybundle master:localRef\n"

#. type: Plain text
#: en/git-bundle.txt:319
#, priority:100
msgid "You can also see what references it offers:"
msgstr "你也可以看看它提供哪些引用："

#. type: delimited block -
#: en/git-bundle.txt:322
#, no-wrap, placeholders:'git ls-remote', priority:100
msgid "$ git ls-remote mybundle\n"
msgstr "$ git ls-remote mybundle\n"

#. type: Title -
#: en/git-bundle.txt:325
#, no-wrap, priority:100
msgid "FILE FORMAT"
msgstr "文件格式"

#. type: Plain text
#: en/git-bundle.txt:328
#, placeholders:'linkgit:gitformat-bundle[5]', priority:100
msgid "See linkgit:gitformat-bundle[5]."
msgstr "参见 linkgit:gitformat-bundle[5]。"

#. type: Title =
#: en/git-cat-file.txt:2
#, ignore-same, no-wrap, priority:80
msgid "git-cat-file(1)"
msgstr "git-cat-file(1)"

#. type: Plain text
#: en/git-cat-file.txt:7
#, placeholders:'git-cat-file', priority:80
msgid "git-cat-file - Provide contents or details of repository objects"
msgstr "git-cat-file - 提供仓库对象的内容或详细信息"

#. type: Plain text
#: en/git-cat-file.txt:19
#, no-wrap, placeholders:'git cat-file':'git cat-file':'git cat-file':'[--allow-unknown-type]':'git cat-file':'--textconv':'--filters':'--path=':'git cat-file':'--batch':'--batch-check':'--batch-command':'[--batch-all-objects]':'[--buffer]':'[--follow-symlinks]':'[--unordered]':'[--textconv':'--filters]', priority:80
msgid ""
"'git cat-file' <type> <object>\n"
"'git cat-file' (-e | -p) <object>\n"
"'git cat-file' (-t | -s) [--allow-unknown-type] <object>\n"
"'git cat-file' (--textconv | --filters)\n"
"\t     [<rev>:<path|tree-ish> | --path=<path|tree-ish> <rev>]\n"
"'git cat-file' (--batch | --batch-check | --batch-command) [--batch-all-objects]\n"
"\t     [--buffer] [--follow-symlinks] [--unordered]\n"
"\t     [--textconv | --filters] [-Z]\n"
msgstr ""
"'git cat-file' <类型> <对象>\n"
"'git cat-file' (-e | -p) <对象>\n"
"'git cat-file' (-t | -s) [--allow-unknown-type] <对象>\n"
"'git cat-file' (--textconv | --filters)\n"
"\t     [<rev>:<path|tree-ish> | --path=<path|tree-ish> <rev>]\n"
"'git cat-file' (--batch | --batch-check | --batch-command) [--batch-all-objects]\n"
"\t     [--buffer] [--follow-symlinks] [--unordered]\n"
"\t     [--textconv | --filters] [-Z]\n"

#. type: Plain text
#: en/git-cat-file.txt:24
#, priority:80
msgid "Output the contents or other properties such as size, type or delta information of one or more objects."
msgstr "输出一个或多个对象的内容或其他属性，如大小、类型或 delta 信息。"

#. type: Plain text
#: en/git-cat-file.txt:27
#, placeholders:'`--batch`', priority:80
msgid "This command can operate in two modes, depending on whether an option from the `--batch` family is specified."
msgstr "该命令有两种运行模式，取决于是否指定了 `--batch` 系列选项。"

#. type: Plain text
#: en/git-cat-file.txt:30
#, priority:80
msgid "In non-batch mode, the command provides information on an object named on the command line."
msgstr "在非批处理模式下，该命令提供命令行中命名的对象的信息。"

#. type: Plain text
#: en/git-cat-file.txt:32
#, priority:80
msgid "In batch mode, arguments are read from standard input."
msgstr "在批处理模式下，参数从标准输入端读取。"

#. type: Labeled list
#: en/git-cat-file.txt:35 en/git-fsck.txt:23 en/git-tag.txt:214 en/git.txt:390
#, no-wrap, priority:240
msgid "<object>"
msgstr "<对象>"

#. type: Plain text
#: en/git-cat-file.txt:39
#, placeholders:'linkgit:gitrevisions[7]', priority:80
msgid "The name of the object to show. For a more complete list of ways to spell object names, see the \"SPECIFYING REVISIONS\" section in linkgit:gitrevisions[7]."
msgstr "要显示的对象名称。 有关拼写对象名称的更完整列表，请参阅 linkgit:gitrevisions[7] 中的 “指定修订” 部分。"

#. type: Plain text
#: en/git-cat-file.txt:43
#, priority:80
msgid "Instead of the content, show the object type identified by `<object>`."
msgstr "不显示内容，而是显示由 `<对象>` 标识的对象类型。"

#. type: Plain text
#: en/git-cat-file.txt:49
#, placeholders:'`--use-mailmap`', priority:80
msgid "Instead of the content, show the object size identified by `<object>`. If used with `--use-mailmap` option, will show the size of updated object after replacing idents using the mailmap mechanism."
msgstr "不显示内容，而是显示由 `<对象>` 标识的对象大小。如果与 `--use-mailmap` 选项一起使用，则会显示使用邮件映射机制替换标识符后更新对象的大小。"

#. type: Plain text
#: en/git-cat-file.txt:54
#, priority:80
msgid "Exit with zero status if `<object>` exists and is a valid object. If `<object>` is of an invalid format, exit with non-zero status and emit an error on stderr."
msgstr "如果 `<对象>` 存在且是有效对象，则以零状态退出。如果 `<对象>` 的格式无效，则以非零状态退出，并在标准错误流上显示错误信息。"

#. type: Plain text
#: en/git-cat-file.txt:57
#, priority:80
msgid "Pretty-print the contents of `<object>` based on its type."
msgstr "根据 `<对象>` 的类型漂亮地打印其内容。"

#. type: Labeled list
#: en/git-cat-file.txt:58 en/git.txt:414
#, no-wrap, priority:100
msgid "<type>"
msgstr "<类型>"

#. type: Plain text
#: en/git-cat-file.txt:65
#, priority:80
msgid "Typically this matches the real type of `<object>` but asking for a type that can trivially be dereferenced from the given `<object>` is also permitted. An example is to ask for a \"tree\" with `<object>` being a commit object that contains it, or to ask for a \"blob\" with `<object>` being a tag object that points at it."
msgstr "通常情况下，这与 `<对象>` 的真实类型相匹配，但也允许要求一个可以从给定的 `<对象>` 中简单地反向引用的类型。 例如，要求输入 “目录树”，而 `<对象>` 是包含它的提交对象，或者要求输入 \"blob\"，而 `<对象>` 是指向它的标记对象。"

#. type: Labeled list
#: en/git-cat-file.txt:66 en/git-log.txt:70
#, ignore-same, no-wrap, priority:260
msgid "--[no-]mailmap"
msgstr "--[no-]mailmap"

#. type: Labeled list
#: en/git-cat-file.txt:67 en/git-log.txt:71
#, ignore-same, no-wrap, priority:260
msgid "--[no-]use-mailmap"
msgstr "--[no-]use-mailmap"

#. type: Plain text
#: en/git-cat-file.txt:71
#, placeholders:'linkgit:git-shortlog[1]', priority:80
msgid "Use mailmap file to map author, committer and tagger names and email addresses to canonical real names and email addresses. See linkgit:git-shortlog[1]."
msgstr "使用 mailmap 文件将作者和提交者的名字和电子邮件地址映射为规范的真实姓名和电子邮件地址。参见 linkgit:git-shortlog[1]。"

#. type: Plain text
#: en/git-cat-file.txt:77
#, priority:80
msgid "Show the content as transformed by a textconv filter. In this case, `<object>` has to be of the form `<tree-ish>:<path>`, or `:<path>` in order to apply the filter to the content recorded in the index at `<path>`."
msgstr "显示经 textconv 过滤器转换的内容。在这种情况下，`<对象>` 必须是 `<目录树对象>:<路径>` 或 `:<路径>` 形式，以便将过滤器应用于 `<路径>` 处索引中记录的内容。"

#. type: Labeled list
#: en/git-cat-file.txt:78
#, ignore-same, no-wrap, priority:80
msgid "--filters"
msgstr "--filters"

#. type: Plain text
#: en/git-cat-file.txt:83
#, priority:80
msgid "Show the content as converted by the filters configured in the current working tree for the given `<path>` (i.e. smudge filters, end-of-line conversion, etc). In this case, `<object>` has to be of the form `<tree-ish>:<path>`, or `:<path>`."
msgstr "显示经当前工作树中为给定的 `<路径>` 配置的过滤器（即污点过滤器、行结束符转换等）转换后的内容。在这种情况下，`<对象>` 的形式必须是`<目录树对象>:<路径>`，或 `:<路径>`。"

#. type: Labeled list
#: en/git-cat-file.txt:84
#, no-wrap, placeholders:'--path=', priority:80
msgid "--path=<path>"
msgstr "--path=<路径>"

#. type: Plain text
#: en/git-cat-file.txt:88
#, placeholders:'`--textconv`':'`--filters`', priority:80
msgid "For use with `--textconv` or `--filters`, to allow specifying an object name and a path separately, e.g. when it is difficult to figure out the revision from which the blob came."
msgstr "与 `--textconv`或 `--filters`一起使用，允许分别指定对象名称和路径，例如，当难以确定 blob 来自哪个版本时。"

#. type: Labeled list
#: en/git-cat-file.txt:89 en/git-mktree.txt:32
#, ignore-same, no-wrap, priority:100
msgid "--batch"
msgstr "--batch"

#. type: Labeled list
#: en/git-cat-file.txt:90
#, no-wrap, placeholders:'--batch=', priority:80
msgid "--batch=<format>"
msgstr "--batch=<格式>"

#. type: Plain text
#: en/git-cat-file.txt:94
#, placeholders:'`--textconv`':'`--filters`':'`--use-mailmap`', priority:80
msgid "Print object information and contents for each object provided on stdin. May not be combined with any other options or arguments except `--textconv`, `--filters`, or `--use-mailmap`."
msgstr "为 标准输入流提供的每个对象打印对象信息和内容。除 `--textconv`、`--filters` 或 `--use-mailmap` 外，不得与任何其他选项或参数结合使用。"

# ERROR: --filters not found in translation
#. type: Plain text
#: en/git-cat-file.txt:99 en/git-cat-file.txt:133
#, placeholders:'`--textconv`':'`--filters`', priority:80
msgid "When used with `--textconv` or `--filters`, the input lines must specify the path, separated by whitespace. See the section `BATCH OUTPUT` below for details."
msgstr "与 `--textconv` 或 `--filters` 一起使用时，输入行必须指定路径，并用空格分隔。详情请参阅下面的 `批输出` 部分。"

#. type: Plain text
#: en/git-cat-file.txt:105
#, placeholders:'`--use-mailmap`', priority:80
msgid "When used with `--use-mailmap`, for commit and tag objects, the contents part of the output shows the identities replaced using the mailmap mechanism, while the information part of the output shows the size of the object as if it actually recorded the replacement identities."
msgstr "与 `--use-mailmap` 一起使用时，对于提交和标记对象，输出的内容部分显示使用邮件映射机制替换的身份，而输出的信息部分显示对象的大小，就像实际记录了替换的身份一样。"

#. type: Labeled list
#: en/git-cat-file.txt:107
#, ignore-same, no-wrap, priority:80
msgid "--batch-check"
msgstr "--batch-check"

#. type: Labeled list
#: en/git-cat-file.txt:108
#, no-wrap, placeholders:'--batch-check=', priority:80
msgid "--batch-check=<format>"
msgstr "--batch-check=<格式>"

#. type: Plain text
#: en/git-cat-file.txt:112
#, placeholders:'`--textconv`':'`--filters`':'`--use-mailmap`', priority:80
msgid "Print object information for each object provided on stdin. May not be combined with any other options or arguments except `--textconv`, `--filters` or `--use-mailmap`."
msgstr "为标准输入流上提供的每个对象打印对象信息。除 `--textconv`、`--filters` 或 `--use-mailmap` 外，不得与任何其他选项或参数结合使用。"

#. type: Plain text
#: en/git-cat-file.txt:115
#, placeholders:'`--textconv`':'`--filters`', priority:80
msgid "When used with `--textconv` or `--filters`, the input lines must"
msgstr "与 `--textconv` 或 `--filters` 一起使用时，输入行必须"

#. type: Plain text
#: en/git-cat-file.txt:117
#, no-wrap, priority:80
msgid ""
"specify the path, separated by whitespace. See the section\n"
"`BATCH OUTPUT` below for details.\n"
msgstr ""
"指定路径，以空格分隔。\n"
"详见下文 `批输出` 部分。\n"

#. type: Plain text
#: en/git-cat-file.txt:121
#, placeholders:'`--use-mailmap`', priority:80
msgid "When used with `--use-mailmap`, for commit and tag objects, the printed object information shows the size of the object as if the identities recorded in it were replaced by the mailmap mechanism."
msgstr "与 `--use-mailmap` 一起使用时，对于提交和标记对象，打印的对象信息会显示该对象的大小，就好像其中记录的身份信息被邮件映射机制替换了一样。"

#. type: Labeled list
#: en/git-cat-file.txt:123
#, ignore-same, no-wrap, priority:80
msgid "--batch-command"
msgstr "--batch-command"

#. type: Labeled list
#: en/git-cat-file.txt:124
#, no-wrap, placeholders:'--batch-command=', priority:80
msgid "--batch-command=<format>"
msgstr "--batch-command=<格式>"

# ERROR: --buffer not found in translation
# ERROR: --textconv not found in translation
# ERROR: --use-mailmap not found in translation
# ERROR: --filters not found in translation
# ERROR: --buffer not found in translation
# ERROR: --textconv not found in translation
# ERROR: --use-mailmap not found in translation
# ERROR: --filters not found in translation
#. type: Plain text
#: en/git-cat-file.txt:128
#, placeholders:'`--buffer`':'`--textconv`':'`--use-mailmap`':'`--filters`', priority:80
msgid "Enter a command mode that reads commands and arguments from stdin. May only be combined with `--buffer`, `--textconv`, `--use-mailmap` or `--filters`."
msgstr "进入命令模式，从标准输入流读取命令和参数。只能与 `--buffer`、`--textconv`、`--use-mailmap` 或 `--filters` 选项结合使用。"

#. type: Plain text
#: en/git-cat-file.txt:139
#, placeholders:'`--use-mailmap`', priority:80
msgid "When used with `--use-mailmap`, for commit and tag objects, the `contents` command shows the identities replaced using the mailmap mechanism, while the `info` command shows the size of the object as if it actually recorded the replacement identities."
msgstr "当与 `--use-mailmap`一起使用时，对于提交和标记对象，`contents` 命令会显示使用邮件映射机制替换的标识，而 `info` 命令则会显示对象的大小，就像实际记录了替换的标识一样。"

#. type: Plain text
#: en/git-cat-file.txt:142
#, placeholders:'`--batch-command`', priority:80
msgid "`--batch-command` recognizes the following commands:"
msgstr "`--batch-command` 可识别以下命令："

#. type: Labeled list
#: en/git-cat-file.txt:144
#, no-wrap, priority:80
msgid "contents <object>"
msgstr "contents <对象>"

#. type: Plain text
#: en/git-cat-file.txt:147
#, placeholders:'`--batch`', priority:80
msgid "Print object contents for object reference `<object>`. This corresponds to the output of `--batch`."
msgstr "打印对象引用 `<对象>` 的对象内容。这相当于 `--batch` 的输出。"

#. type: Labeled list
#: en/git-cat-file.txt:148
#, no-wrap, priority:80
msgid "info <object>"
msgstr "info <对象>"

#. type: Plain text
#: en/git-cat-file.txt:151
#, placeholders:'`--batch-check`', priority:80
msgid "Print object info for object reference `<object>`. This corresponds to the output of `--batch-check`."
msgstr "打印对象引用 `<对象>` 的对象信息。这相当于 `--batch-check` 的输出。"

#. type: Labeled list
#: en/git-cat-file.txt:152
#, no-wrap, priority:80
msgid "flush"
msgstr "flush （刷新）"

#. type: Plain text
#: en/git-cat-file.txt:157
#, placeholders:'`--buffer`':'`--buffer`':'`--buffer`', priority:80
msgid "Used with `--buffer` to execute all preceding commands that were issued since the beginning or since the last flush was issued. When `--buffer` is used, no output will come until a `flush` is issued. When `--buffer` is not used, commands are flushed each time without issuing `flush`."
msgstr "与 `--buffer` 一起使用时，执行自开始或上次刷新后发出的所有命令。使用 `--buffer` 时，在发出 `flush` 之前不会有输出。不使用 `--buffer` 时，每次刷新命令时都不会发出 `flush`。"

#. type: Labeled list
#: en/git-cat-file.txt:160
#, ignore-same, no-wrap, priority:80
msgid "--batch-all-objects"
msgstr "--batch-all-objects"

# ERROR: --batch-check not found in translation
#. type: Plain text
#: en/git-cat-file.txt:168
#, placeholders:'`--batch`':'`--batch-check`':'`--unordered`':'linkgit:git-replace[1]', priority:80
msgid "Instead of reading a list of objects on stdin, perform the requested batch operation on all objects in the repository and any alternate object stores (not just reachable objects). Requires `--batch` or `--batch-check` be specified. By default, the objects are visited in order sorted by their hashes; see also `--unordered` below. Objects are presented as-is, without respecting the \"replace\" mechanism of linkgit:git-replace[1]."
msgstr "不是从标准输入流读取对象列表，而是对仓库和任何备用对象存储区中的所有对象（不只是可访问对象）执行请求的批处理操作。 需要指定 `--batch` 或 `--batch-check`。默认情况下，将按哈希值排序访问对象；另请参阅下面的 `--unordered`。对象按原样显示，不遵守 linkgit:git-replace[1] 的 “替换” 机制。"

#. type: Labeled list
#: en/git-cat-file.txt:169
#, ignore-same, no-wrap, priority:80
msgid "--buffer"
msgstr "--buffer"

#. type: Plain text
#: en/git-cat-file.txt:175
#, placeholders:'`--batch-check`':'`--batch-command`', priority:80
msgid "Normally batch output is flushed after each object is output, so that a process can interactively read and write from `cat-file`. With this option, the output uses normal stdio buffering; this is much more efficient when invoking `--batch-check` or `--batch-command` on a large number of objects."
msgstr "通常情况下，批处理输出会在每个对象输出后刷新，以便进程可以交互式地从 `cat-file` 读写。使用此选项后，输出将使用正常的标准 IO 缓冲；在对大量对象调用 `--batch-check` 或 `--batch-command` 时，这种方式效率更高。"

#. type: Labeled list
#: en/git-cat-file.txt:176
#, ignore-same, no-wrap, priority:80
msgid "--unordered"
msgstr "--unordered"

#. type: Plain text
#: en/git-cat-file.txt:185
#, placeholders:'`--batch-all-objects`':'`--batch`', priority:80
msgid "When `--batch-all-objects` is in use, visit objects in an order which may be more efficient for accessing the object contents than hash order. The exact details of the order are unspecified, but if you do not require a specific order, this should generally result in faster output, especially with `--batch`. Note that `cat-file` will still show each object only once, even if it is stored multiple times in the repository."
msgstr "当使用 `--batch-all-objects` 时，访问对象的顺序可能比散列顺序更有效率。顺序的具体细节未作规定，但如果不需要特定顺序，通常会加快输出速度，特别是在使用 `--batch`时。 请注意，即使每个对象在仓库中存储了多次，`cat-file` 仍然只会显示一次。"

#. type: Labeled list
#: en/git-cat-file.txt:186
#, ignore-same, no-wrap, priority:80
msgid "--allow-unknown-type"
msgstr "--allow-unknown-type"

#. type: Plain text
#: en/git-cat-file.txt:188
#, placeholders:'`-s`':'`-t`', priority:80
msgid "Allow `-s` or `-t` to query broken/corrupt objects of unknown type."
msgstr "允许 `-s` 或 `-t` 查询已损坏/损坏的未知类型对象。"

#. type: Labeled list
#: en/git-cat-file.txt:189
#, ignore-same, no-wrap, priority:80
msgid "--follow-symlinks"
msgstr "--follow-symlinks"

# ERROR: --batch-check not found in translation
# ERROR: --batch-check not found in translation
#. type: Plain text
#: en/git-cat-file.txt:198
#, placeholders:'`--batch`':'`--batch-check`', priority:80
msgid "With `--batch` or `--batch-check`, follow symlinks inside the repository when requesting objects with extended SHA-1 expressions of the form tree-ish:path-in-tree. Instead of providing output about the link itself, provide output about the linked-to object. If a symlink points outside the tree-ish (e.g. a link to `/foo` or a root-level link to `../foo`), the portion of the link which is outside the tree will be printed."
msgstr "使用 `--batch` 或 `--batch-check` 选项，在请求使用 tree-ish:path-in-tree 形式的扩展 SHA-1 表达式的对象时，可跟踪仓库内部的符号链接。 与其提供链接本身的输出，不如提供链接对象的输出。 如果符号链接指向 tree-ish 以外（例如指向 `/foo` 的链接或指向 `../foo` 的根级链接），则会打印链接在目录树外的部分。"

#. type: Plain text
#: en/git-cat-file.txt:202
#, placeholders:'HEAD', priority:80
msgid "This option does not (currently) work correctly when an object in the index is specified (e.g. `:link` instead of `HEAD:link`) rather than one in the tree."
msgstr "如果指定的是索引中的对象（例如，`:link` 而不是 `HEAD:link`）而不是树中的对象，该选项（目前）无法正常工作。"

# ERROR: --batch-check not found in translation
# ERROR: --batch-check not found in translation
#. type: Plain text
#: en/git-cat-file.txt:205
#, placeholders:'`--batch`':'`--batch-check`', priority:80
msgid "This option cannot (currently) be used unless `--batch` or `--batch-check` is used."
msgstr "除非使用了 `--batch` 或 `--batch-check` 选项，否则（目前）不能使用该选项。"

#. type: Plain text
#: en/git-cat-file.txt:207
#, priority:80
msgid "For example, consider a git repository containing:"
msgstr "例如，考虑一个包含以下内容的 git 仓库："

#. type: Plain text
#: en/git-cat-file.txt:214
#, no-wrap, priority:80
msgid ""
"\tf: a file containing \"hello\\n\"\n"
"\tlink: a symlink to f\n"
"\tdir/link: a symlink to ../f\n"
"\tplink: a symlink to ../f\n"
"\talink: a symlink to /etc/passwd\n"
msgstr ""
"\tf: 包含 \"hello\\n\" 的文件\n"
"\tlink: 链接到 f 的符号链接\n"
"\tdir/link: 链接到 ../f 的符号连接\n"
"\tplink: 链接到 ../f 的符号连接\n"
"\talink: 链接到 /etc/passwd 的符号链接\n"

#. type: Plain text
#: en/git-cat-file.txt:217
#, placeholders:'HEAD':'git cat-file':'--batch`', priority:80
msgid "For a regular file `f`, `echo HEAD:f | git cat-file --batch` would print"
msgstr "对于普通文件 `f`, `echo HEAD:f | git cat-file --batch` 将打印"

#. type: Plain text
#: en/git-cat-file.txt:220
#, no-wrap, priority:80
msgid "\tce013625030ba8dba906f756967f9e9ca394464a blob 6\n"
msgstr "\tce013625030ba8dba906f756967f9e9ca394464a blob 6\n"

#. type: Plain text
#: en/git-cat-file.txt:225
#, placeholders:'HEAD':'git cat-file':'--batch':'--follow-symlinks`':'HEAD':'HEAD', priority:80
msgid "And `echo HEAD:link | git cat-file --batch --follow-symlinks` would print the same thing, as would `HEAD:dir/link`, as they both point at `HEAD:f`."
msgstr "而 `echo HEAD:link | git cat-file --batch --follow-symlinks` 会打印同样的内容，`HEAD:dir/link` 也会打印同样的内容，因为它们都指向 `HEAD:f`。"

# ERROR: --follow-symlinks not found in translation
#. type: Plain text
#: en/git-cat-file.txt:228
#, placeholders:'`--follow-symlinks`':'HEAD', priority:80
msgid "Without `--follow-symlinks`, these would print data about the symlink itself. In the case of `HEAD:link`, you would see"
msgstr "如果没有 `--follow-symlinks`，就会打印符号链接本身的数据。 在 `HEAD:link` 的情况下，你会看到"

#. type: Plain text
#: en/git-cat-file.txt:231
#, no-wrap, priority:80
msgid "\t4d1ae35ba2c8ec712fa2a379db44ad639ca277bd blob 1\n"
msgstr "\t4d1ae35ba2c8ec712fa2a379db44ad639ca277bd blob 1\n"

#. type: Plain text
#: en/git-cat-file.txt:235
#, priority:80
msgid "Both `plink` and `alink` point outside the tree, so they would respectively print:"
msgstr "`plink` 和 `alink` 都指向树外，因此将分别打印："

#. type: Plain text
#: en/git-cat-file.txt:239
#, no-wrap, priority:80
msgid ""
"\tsymlink 4\n"
"\t../f\n"
msgstr ""
"\tsymlink 4\n"
"\t../f\n"

#. type: Plain text
#: en/git-cat-file.txt:242
#, no-wrap, priority:80
msgid ""
"\tsymlink 11\n"
"\t/etc/passwd\n"
msgstr ""
"\tsymlink 11\n"
"\t/etc/passwd\n"

#. type: Labeled list
#: en/git-cat-file.txt:244
#, ignore-same, no-wrap, priority:80
msgid "-Z"
msgstr "-Z"

#. type: Plain text
#: en/git-cat-file.txt:248
#, placeholders:'`--batch`':'`--batch-check`':'`--batch-command`', priority:80
msgid "Only meaningful with `--batch`, `--batch-check`, or `--batch-command`; input and output is NUL-delimited instead of newline-delimited."
msgstr "只有在使用 `--batch`、`--batch-check` 或 `--batch-command` 时才有意义；输入和输出以 NUL 分隔，而不是换行分隔。"

#. type: Plain text
#: en/git-cat-file.txt:254
#, placeholders:'`--batch`':'`--batch-check`':'`--batch-command`':'`-Z`', priority:80
msgid "Only meaningful with `--batch`, `--batch-check`, or `--batch-command`; input is NUL-delimited instead of newline-delimited. This option is deprecated in favor of `-Z` as the output can otherwise be ambiguous."
msgstr "仅对 `--batch`、`--batch-check` 或 `--batch-command` 有效；输入以 NUL 分隔，而不是换行分隔。该选项已被弃用，改用 `-Z`，否则输出结果可能含糊不清。"

#. type: Title -
#: en/git-cat-file.txt:257 en/git-check-attr.txt:53 en/git-check-ignore.txt:66 en/git-check-mailmap.txt:32 en/git-cvsimport.txt:188 en/git-fetch.txt:194 en/git-ls-files.txt:235 en/git-ls-remote.txt:100 en/git-merge-tree.txt:74 en/git-push.txt:438 en/git-show-branch.txt:133 en/git-show-ref.txt:111 en/git-status.txt:156 en/git-update-server-info.txt:29
#, no-wrap, priority:280
msgid "OUTPUT"
msgstr "输出"

#. type: Plain text
#: en/git-cat-file.txt:259
#, placeholders:'`-t`', priority:80
msgid "If `-t` is specified, one of the `<type>`."
msgstr "如果指定了 `-t`，则是 `<类型>` 中的一个。"

#. type: Plain text
#: en/git-cat-file.txt:261
#, placeholders:'`-s`', priority:80
msgid "If `-s` is specified, the size of the `<object>` in bytes."
msgstr "如果指定了 `-s`，则是 `<对象>` 的大小（以字节为单位）。"

#. type: Plain text
#: en/git-cat-file.txt:263
#, placeholders:'`-e`', priority:80
msgid "If `-e` is specified, no output, unless the `<object>` is malformed."
msgstr "如果指定了 `-e`，则没有输出，除非 `<对象>` 是畸形的。"

#. type: Plain text
#: en/git-cat-file.txt:265
#, placeholders:'`-p`', priority:80
msgid "If `-p` is specified, the contents of `<object>` are pretty-printed."
msgstr "如果指定了 `-p`，则会对 `<对象>` 的内容进行漂亮打印。"

#. type: Plain text
#: en/git-cat-file.txt:268
#, priority:80
msgid "If `<type>` is specified, the raw (though uncompressed) contents of the `<object>` will be returned."
msgstr "如果指定了 `<类型>`，则将返回 `<对象>` 的原始内容（尽管未压缩）。"

#. type: Title -
#: en/git-cat-file.txt:270
#, no-wrap, priority:80
msgid "BATCH OUTPUT"
msgstr "批输出"

# ERROR: --batch-check not found in translation
# ERROR: --batch-check not found in translation
#. type: Plain text
#: en/git-cat-file.txt:276
#, placeholders:'`--batch`':'`--batch-check`':'linkgit:git-rev-parse[1]', priority:80
msgid "If `--batch` or `--batch-check` is given, `cat-file` will read objects from stdin, one per line, and print information about them. By default, the whole line is considered as an object, as if it were fed to linkgit:git-rev-parse[1]."
msgstr "如果给定了 `--batch` 或 `--batch-check`，`cat-file` 将从标准输入流读取对象，每行一个，并打印它们的相关信息。默认情况下，整行都会被视为一个对象，就像被送入 linkgit:git-rev-parse[1] 一样。"

# ERROR: --batch-check not found in translation
# ERROR: --batch-check not found in translation
#. type: Plain text
#: en/git-cat-file.txt:283
#, placeholders:'`--batch-command`':'`--batch-command`':'`--batch-check`':'`--batch`', priority:80
msgid "When `--batch-command` is given, `cat-file` will read commands from stdin, one per line, and print information based on the command given. With `--batch-command`, the `info` command followed by an object will print information about the object the same way `--batch-check` would, and the `contents` command followed by an object prints contents in the same way `--batch` would."
msgstr "当给出 `--batch-command` 时，`cat-file` 将从标准输入流读取命令，每行一条，并根据给出的命令打印信息。使用 `--batch-command`，对象后面的 `info` 命令将以与 `--batch-check`相同的方式打印该对象的信息，对象后面的 `contents` 命令将以与 `--batch`相同的方式打印内容。"

#. type: Plain text
#: en/git-cat-file.txt:288
#, priority:80
msgid "You can specify the information shown for each object by using a custom `<format>`. The `<format>` is copied literally to stdout for each object, with placeholders of the form `%(atom)` expanded, followed by a newline. The available atoms are:"
msgstr "您可以使用自定义的 `<format>`，指定每个对象显示的信息。每个对象的 `<format>` 都会按字面意思复制到标准输出流，并以 `%(atom)`形式展开占位符，然后换行。可用的原子项有："

#. type: Labeled list
#: en/git-cat-file.txt:289
#, ignore-same, no-wrap, priority:80
msgid "`objectname`"
msgstr "`objectname`"

#. type: Plain text
#: en/git-cat-file.txt:291
#, priority:80
msgid "The full hex representation of the object name."
msgstr "对象名称的十六进制全称。"

#. type: Labeled list
#: en/git-cat-file.txt:292
#, ignore-same, no-wrap, priority:80
msgid "`objecttype`"
msgstr "`objecttype`"

#. type: Plain text
#: en/git-cat-file.txt:294
#, priority:80
msgid "The type of the object (the same as `cat-file -t` reports)."
msgstr "对象的类型（与 `cat-file -t` 报告相同）。"

#. type: Labeled list
#: en/git-cat-file.txt:295
#, ignore-same, no-wrap, priority:80
msgid "`objectsize`"
msgstr "`objectsize`"

#. type: Plain text
#: en/git-cat-file.txt:298
#, priority:80
msgid "The size, in bytes, of the object (the same as `cat-file -s` reports)."
msgstr "对象的大小（以字节为单位）（与 `cat-file -s` 报告相同）。"

#. type: Labeled list
#: en/git-cat-file.txt:299
#, no-wrap, priority:80
msgid "`objectsize:disk`"
msgstr "`objectsize:disk`"

#. type: Plain text
#: en/git-cat-file.txt:302
#, priority:80
msgid "The size, in bytes, that the object takes up on disk. See the note about on-disk sizes in the `CAVEATS` section below."
msgstr "对象在磁盘上占用的大小（以字节为单位）。请参阅下文 `注意事项` 部分关于磁盘大小的说明。"

#. type: Labeled list
#: en/git-cat-file.txt:303
#, ignore-same, no-wrap, priority:80
msgid "`deltabase`"
msgstr "`deltabase`"

#. type: Plain text
#: en/git-cat-file.txt:308
#, priority:80
msgid "If the object is stored as a delta on-disk, this expands to the full hex representation of the delta base object name. Otherwise, expands to the null OID (all zeroes). See `CAVEATS` below."
msgstr "如果对象以 delta 格式存储在磁盘上，则扩展为 delta 基本对象名称的十六进制表示法。 否则，将扩展为空 OID（全部为零）。请参阅下面的 `注意事项`。"

#. type: Labeled list
#: en/git-cat-file.txt:309
#, ignore-same, no-wrap, priority:80
msgid "`rest`"
msgstr "`rest`"

#. type: Plain text
#: en/git-cat-file.txt:315
#, priority:80
msgid "If this atom is used in the output string, input lines are split at the first whitespace boundary. All characters before that whitespace are considered to be the object name; characters after that first run of whitespace (i.e., the \"rest\" of the line) are output in place of the `%(rest)` atom."
msgstr "如果在输出字符串中使用了该原子，输入行将在第一个空白边界处被分割。空格前的所有字符都被视为对象名称；空格后的字符（即该行的 “其余部分”）将代替 `%(rest)` 原子输出。"

#. type: Plain text
#: en/git-cat-file.txt:318
#, priority:80
msgid "If no format is specified, the default format is `%(objectname) %(objecttype) %(objectsize)`."
msgstr "如果未指定格式，默认格式为 `%（对象名）%（对象类型）%（对象大小）`。"

#. type: Plain text
#: en/git-cat-file.txt:322
#, placeholders:'`--batch`':'`--batch-command`', priority:80
msgid "If `--batch` is specified, or if `--batch-command` is used with the `contents` command, the object information is followed by the object contents (consisting of `%(objectsize)` bytes), followed by a newline."
msgstr "如果指定了 `--batch`，或者 `--batch-command`与 `内容` 命令一起使用，则对象信息之后是对象内容（由 `%(objectize)` 字节组成），之后是换行符。"

#. type: Plain text
#: en/git-cat-file.txt:324
#, placeholders:'`--batch`', priority:80
msgid "For example, `--batch` without a custom format would produce:"
msgstr "例如，不使用自定义格式的 `--batch` 会产生结果："

#. type: delimited block -
#: en/git-cat-file.txt:328
#, no-wrap, priority:80
msgid ""
"<oid> SP <type> SP <size> LF\n"
"<contents> LF\n"
msgstr ""
"<对象 ID> SP <类型> SP <尺寸> LF\n"
"<内容> LF\n"

#. type: Plain text
#: en/git-cat-file.txt:331
#, placeholders:'`--batch-check=', priority:80
msgid "Whereas `--batch-check='%(objectname) %(objecttype)'` would produce:"
msgstr "而 `--batch-check='%(objectname) %(objecttype)'` 则会产生："

#. type: delimited block -
#: en/git-cat-file.txt:334
#, no-wrap, priority:80
msgid "<oid> SP <type> LF\n"
msgstr "<对象 ID> SP <类型> LF\n"

#. type: Plain text
#: en/git-cat-file.txt:338
#, priority:80
msgid "If a name is specified on stdin that cannot be resolved to an object in the repository, then `cat-file` will ignore any custom format and print:"
msgstr "如果在标准输入流中指定的名称无法解析为版本库中的对象，那么 `cat-file` 将忽略任何自定义格式并打印："

#. type: delimited block -
#: en/git-cat-file.txt:341 en/git-cat-file.txt:367
#, no-wrap, priority:80
msgid "<object> SP missing LF\n"
msgstr "<对象> SP 丢失 LF\n"

#. type: Plain text
#: en/git-cat-file.txt:344
#, priority:80
msgid "If a name is specified that might refer to more than one object (an ambiguous short sha), then `cat-file` will ignore any custom format and print:"
msgstr "如果指定的名称可能指向多个对象（模棱两可的 短 sha），则 `cat-file` 将忽略任何自定义格式并打印："

#. type: delimited block -
#: en/git-cat-file.txt:347
#, no-wrap, priority:80
msgid "<object> SP ambiguous LF\n"
msgstr "<对象> SP ambiguous LF\n"

# ERROR: --follow-symlinks not found in translation
#. type: Plain text
#: en/git-cat-file.txt:352
#, placeholders:'`--follow-symlinks`', priority:80
msgid "If `--follow-symlinks` is used, and a symlink in the repository points outside the repository, then `cat-file` will ignore any custom format and print:"
msgstr "如果使用了 `--follow-symlinks`，并且仓库中的符号链接指向仓库之外，那么 `cat-file` 将忽略任何自定义格式并打印："

#. type: delimited block -
#: en/git-cat-file.txt:356
#, no-wrap, priority:80
msgid ""
"symlink SP <size> LF\n"
"<symlink> LF\n"
msgstr ""
"符号链接 SP <size> LF \n"
"<符号链接> LF\n"

#. type: Plain text
#: en/git-cat-file.txt:361
#, priority:80
msgid "The symlink will either be absolute (beginning with a `/`), or relative to the tree root. For instance, if dir/link points to `../../foo`, then `<symlink>` will be `../foo`. `<size>` is the size of the symlink in bytes."
msgstr "符号链接要么是绝对的（以 `/` 开头），要么是相对于树根的。 例如，如果 dir/link 指向 `.././foo`，那么 `<符号链接>` 将是 `../foo`。 `<尺寸>` 是符号链接的大小（以字节为单位）。"

#. type: Plain text
#: en/git-cat-file.txt:364
#, placeholders:'`--follow-symlinks`', priority:80
msgid "If `--follow-symlinks` is used, the following error messages will be displayed:"
msgstr "如果使用 `--follow-symlinks`，将显示以下错误信息："

#. type: Plain text
#: en/git-cat-file.txt:369
#, priority:80
msgid "is printed when the initial symlink requested does not exist."
msgstr "会在请求的初始符号链接不存在时打印出来。"

#. type: delimited block -
#: en/git-cat-file.txt:373
#, no-wrap, priority:80
msgid ""
"dangling SP <size> LF\n"
"<object> LF\n"
msgstr ""
"dangling SP <尺寸> LF\n"
"<对象> LF\n"

#. type: Plain text
#: en/git-cat-file.txt:376
#, priority:80
msgid "is printed when the initial symlink exists, but something that it (transitive-of) points to does not."
msgstr "会在初始符号链接存在，但它（transitive-of）指向的东西不存在时打印出来。"

#. type: delimited block -
#: en/git-cat-file.txt:380
#, no-wrap, priority:80
msgid ""
"loop SP <size> LF\n"
"<object> LF\n"
msgstr ""
"loop SP <尺寸> LF\n"
"<对象> LF\n"

#. type: Plain text
#: en/git-cat-file.txt:383
#, priority:80
msgid "is printed for symlink loops (or any symlinks that require more than 40 link resolutions to resolve)."
msgstr "会打印符号链接循环（或任何需要超过 40 个链接分辨率才能解析的符号链接）。"

#. type: delimited block -
#: en/git-cat-file.txt:387
#, no-wrap, priority:80
msgid ""
"notdir SP <size> LF\n"
"<object> LF\n"
msgstr ""
"notdir SP <尺寸> LF\n"
"<对象> LF\n"

#. type: Plain text
#: en/git-cat-file.txt:390
#, priority:80
msgid "is printed when, during symlink resolution, a file is used as a directory name."
msgstr "会被打印出来，因为在符号链接解析过程中，文件被用作目录名。"

#. type: Plain text
#: en/git-cat-file.txt:395
#, placeholders:'`-Z`', priority:80
msgid "Alternatively, when `-Z` is passed, the line feeds in any of the above examples are replaced with NUL terminators. This ensures that output will be parsable if the output itself would contain a linefeed and is thus recommended for scripting purposes."
msgstr "或者，当传递 `-Z` 时，上述任何示例中的换行符都会被 NUL 结束符取代。这样可以确保在输出本身包含换行符的情况下，输出仍可解析，因此推荐用于脚本目的。"

#. type: Title -
#: en/git-cat-file.txt:397 en/git-for-each-ref.txt:478 en/git-format-patch.txt:768 en/git-svn.txt:998
#, no-wrap, priority:100
msgid "CAVEATS"
msgstr "注意事项"

#. type: Plain text
#: en/git-cat-file.txt:405 en/git-for-each-ref.txt:486
#, priority:80
msgid "Note that the sizes of objects on disk are reported accurately, but care should be taken in drawing conclusions about which refs or objects are responsible for disk usage. The size of a packed non-delta object may be much larger than the size of objects which delta against it, but the choice of which object is the base and which is the delta is arbitrary and is subject to change during a repack."
msgstr "需要注意的是，磁盘上对象的大小会被准确地报告出来，但在得出哪些记录或对象造成了磁盘使用量的结论时应小心谨慎。打包的非 delta 对象的大小可能远大于与之相对的 delta 对象的大小，但选择哪个对象为基准对象，哪个对象为 delta 对象是任意的，在重新打包时可能会发生变化。"

#. type: Plain text
#: en/git-cat-file.txt:409 en/git-for-each-ref.txt:490
#, priority:80
msgid "Note also that multiple copies of an object may be present in the object database; in this case, it is undefined which copy's size or delta base will be reported."
msgstr "还请注意，对象数据库中可能存在一个对象的多个副本；在这种情况下，无法确定将报告哪个副本的大小或 delta 基数。"

#. type: Title =
#: en/git-check-attr.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-check-attr(1)"
msgstr "git-check-attr(1)"

#. type: Plain text
#: en/git-check-attr.txt:7
#, placeholders:'git-check-attr', priority:100
msgid "git-check-attr - Display gitattributes information"
msgstr "git-check-attr - 显示 gitattributes 信息"

#. type: Plain text
#: en/git-check-attr.txt:14
#, ignore-ellipsis, no-wrap, placeholders:'git check-attr':'[--source':'--all':'git check-attr':'--stdin':'[--source':'--all', priority:100
msgid ""
"'git check-attr' [--source <tree-ish>] [-a | --all | <attr>...] [--] <pathname>...\n"
"'git check-attr' --stdin [-z] [--source <tree-ish>] [-a | --all | <attr>...]\n"
msgstr ""
"'git check-attr' [--source <树状对象>] [-a | --all | <属性>...] [--] <路径名>...\n"
"'git check-attr' --stdin [-z] [--source <树状对象>] [-a | --all | <属性>...]\n"

#. type: Plain text
#: en/git-check-attr.txt:19
#, priority:100
msgid "For every pathname, this command will list if each attribute is 'unspecified', 'set', or 'unset' as a gitattribute on that pathname."
msgstr "对于每个路径名，该命令将列出每个属性是否为 “未指定”、“已设置” 或 “未设置”，作为该路径名的 gitattribute。"

#. type: Labeled list
#: en/git-check-attr.txt:22
#, no-wrap, placeholders:'--all', priority:100
msgid "-a, --all"
msgstr "-a, --all"

#. type: Plain text
#: en/git-check-attr.txt:26
#, priority:100
msgid "List all attributes that are associated with the specified paths. If this option is used, then 'unspecified' attributes will not be included in the output."
msgstr "列出与指定路径相关的所有属性。 如果使用这个选项，那么 “未指定的” 属性将不包括在输出中。"

#. type: Plain text
#: en/git-check-attr.txt:29
#, placeholders:'.gitattributes', priority:100
msgid "Consider `.gitattributes` in the index only, ignoring the working tree."
msgstr "只考虑索引中的 `.gitattributes`，忽略工作区。"

#. type: Labeled list
#: en/git-check-attr.txt:30 en/git-check-ignore.txt:43 en/git-check-mailmap.txt:26 en/git-checkout-index.txt:68 en/git-diff-tree.txt:51 en/git-fetch-pack.txt:38 en/git-fetch.txt:51 en/git-for-each-ref.txt:37 en/git-hash-object.txt:34 en/git-http-fetch.txt:37 en/git-index-pack.txt:46 en/git-notes.txt:197 en/git-send-pack.txt:42 en/git-svn.txt:595 en/git-update-index.txt:153 en/rev-list-options.txt:242
#, ignore-same, no-wrap, priority:280
msgid "--stdin"
msgstr "--stdin"

#. type: Plain text
#: en/git-check-attr.txt:33
#, priority:100
msgid "Read pathnames from the standard input, one per line, instead of from the command line."
msgstr "从标准输入中读取路径名，每行一个，而不是从命令行读取。"

#. type: Plain text
#: en/git-check-attr.txt:38
#, placeholders:'`--stdin`', priority:100
msgid "The output format is modified to be machine-parsable. If `--stdin` is also given, input paths are separated with a NUL character instead of a linefeed character."
msgstr "输出格式被修改为机器可解析的。 如果同时给出 `--stdin`，输入路径将用 NUL 字符而不是换行符来分隔。"

#. type: Labeled list
#: en/git-check-attr.txt:39
#, no-wrap, placeholders:'--source=', priority:100
msgid "--source=<tree-ish>"
msgstr "--source=<目录树对象>"

#. type: Plain text
#: en/git-check-attr.txt:43
#, priority:100
msgid "Check attributes against the specified tree-ish. It is common to specify the source tree by naming a commit, branch, or tag associated with it."
msgstr "根据指定的目录树型检查属性。通常通过命名与之相关的提交、分支或标记来指定源目录树。"

#. type: Plain text
#: en/git-check-attr.txt:47
#, priority:100
msgid "Interpret all preceding arguments as attributes and all following arguments as path names."
msgstr "将前面的所有参数解释为属性，后面的所有参数解释为路径名称。"

#. type: Plain text
#: en/git-check-attr.txt:51
#, placeholders:'`--stdin`':'`--all`', priority:100
msgid "If none of `--stdin`, `--all`, or `--` is used, the first argument will be treated as an attribute and the rest of the arguments as pathnames."
msgstr "如果没有使用 `--stdin`、`--all` 或 `--`，第一个参数将被视为一个属性，其余的参数将被视为路径名。"

#. type: Plain text
#: en/git-check-attr.txt:57
#, priority:100
msgid "The output is of the form: <path> COLON SP <attribute> COLON SP <info> LF"
msgstr "输出的形式是： <路径> COLON SP <属性> COLON SP <信息> LF"

#. type: Plain text
#: en/git-check-attr.txt:60
#, placeholders:'`-z`', priority:100
msgid "unless `-z` is in effect, in which case NUL is used as delimiter: <path> NUL <attribute> NUL <info> NUL"
msgstr "除非 `-z` 生效，在这种情况下，使用 NUL 作为分隔符： <路径> NUL <属性> NUL <信息> NUL"

#. type: Plain text
#: en/git-check-attr.txt:64
#, priority:100
msgid "<path> is the path of a file being queried, <attribute> is an attribute being queried, and <info> can be either:"
msgstr "<路径> 是被查询的文件的路径，<属性> 是被查询的属性，<信息> 可以是任何一种："

#. type: Labeled list
#: en/git-check-attr.txt:65
#, ignore-same, no-wrap, priority:100
msgid "'unspecified'"
msgstr "'unspecified'"

#. type: Plain text
#: en/git-check-attr.txt:66
#, priority:100
msgid "when the attribute is not defined for the path."
msgstr "当该属性未被定义为路径时。"

#. type: Labeled list
#: en/git-check-attr.txt:66
#, ignore-same, no-wrap, priority:100
msgid "'unset'"
msgstr "'unset'"

#. type: Plain text
#: en/git-check-attr.txt:67
#, priority:100
msgid "when the attribute is defined as false."
msgstr "当该属性被定义为 false 时。"

#. type: Labeled list
#: en/git-check-attr.txt:67
#, ignore-same, no-wrap, priority:100
msgid "'set'"
msgstr "'set'"

#. type: Plain text
#: en/git-check-attr.txt:68
#, priority:100
msgid "when the attribute is defined as true."
msgstr "当该属性被定义为真时。"

#. type: Labeled list
#: en/git-check-attr.txt:68
#, no-wrap, priority:100
msgid "<value>"
msgstr "<值>"

#. type: Plain text
#: en/git-check-attr.txt:69
#, priority:100
msgid "when a value has been assigned to the attribute."
msgstr "当一个值被分配给该属性时。"

#. type: Plain text
#: en/git-check-attr.txt:74 en/git-check-ignore.txt:105
#, placeholders:'GIT_FLUSH':'linkgit:git[1]', priority:100
msgid "Buffering happens as documented under the `GIT_FLUSH` option in linkgit:git[1]. The caller is responsible for avoiding deadlocks caused by overfilling an input buffer or reading from an empty output buffer."
msgstr "缓冲发生在 linkgit:git[1] 中的 `GIT_FLUSH` 选项下的记录。 调用者负责避免因过度填充输入缓冲区或从空的输出缓冲区读取而造成的死锁。"

#. type: Plain text
#: en/git-check-attr.txt:79
#, placeholders:'.gitattributes', priority:100
msgid "In the examples, the following '.gitattributes' file is used:"
msgstr "在例子中，使用了以下 '.gitattributes' 文件："

#. type: delimited block -
#: en/git-check-attr.txt:83
#, no-wrap, placeholders:'NoMyAttr.java', priority:100
msgid ""
"*.java diff=java -crlf myAttr\n"
"NoMyAttr.java !myAttr\n"
"README caveat=unspecified\n"
msgstr ""
"*.java diff=java -crlf myAttr\n"
"NoMyAttr.java !myAttr\n"
"README caveat=unspecified\n"

#. type: Plain text
#: en/git-check-attr.txt:86
#, priority:100
msgid "Listing a single attribute:"
msgstr "列出一个单一属性："

#. type: delimited block -
#: en/git-check-attr.txt:89
#, no-wrap, placeholders:'git check-attr':'MyClass.java':'MyClass.java', priority:100
msgid ""
"$ git check-attr diff org/example/MyClass.java\n"
"org/example/MyClass.java: diff: java\n"
msgstr ""
"$ git check-attr diff org/example/MyClass.java\n"
"org/example/MyClass.java: diff: java\n"

#. type: Plain text
#: en/git-check-attr.txt:92
#, priority:100
msgid "Listing multiple attributes for a file:"
msgstr "列出一个文件的多个属性："

#. type: delimited block -
#: en/git-check-attr.txt:97
#, no-wrap, placeholders:'git check-attr':'MyClass.java':'MyClass.java':'MyClass.java':'MyClass.java', priority:100
msgid ""
"$ git check-attr crlf diff myAttr -- org/example/MyClass.java\n"
"org/example/MyClass.java: crlf: unset\n"
"org/example/MyClass.java: diff: java\n"
"org/example/MyClass.java: myAttr: set\n"
msgstr ""
"$ git check-attr crlf diff myAttr -- org/example/MyClass.java\n"
"org/example/MyClass.java: crlf: unset\n"
"org/example/MyClass.java: diff: java\n"
"org/example/MyClass.java: myAttr: set\n"

#. type: Plain text
#: en/git-check-attr.txt:100
#, priority:100
msgid "Listing all attributes for a file:"
msgstr "列出一个文件的所有属性："

#. type: delimited block -
#: en/git-check-attr.txt:104
#, no-wrap, placeholders:'git check-attr':'--all':'MyClass.java':'MyClass.java':'MyClass.java', priority:100
msgid ""
"$ git check-attr --all -- org/example/MyClass.java\n"
"org/example/MyClass.java: diff: java\n"
"org/example/MyClass.java: myAttr: set\n"
msgstr ""
"$ git check-attr --all -- org/example/MyClass.java\n"
"org/example/MyClass.java: diff: java\n"
"org/example/MyClass.java: myAttr: set\n"

#. type: Plain text
#: en/git-check-attr.txt:107
#, priority:100
msgid "Listing an attribute for multiple files:"
msgstr "为多个文件列出一个属性："

#. type: delimited block -
#: en/git-check-attr.txt:111
#, no-wrap, placeholders:'git check-attr':'MyClass.java':'NoMyAttr.java':'MyClass.java':'NoMyAttr.java', priority:100
msgid ""
"$ git check-attr myAttr -- org/example/MyClass.java org/example/NoMyAttr.java\n"
"org/example/MyClass.java: myAttr: set\n"
"org/example/NoMyAttr.java: myAttr: unspecified\n"
msgstr ""
"$ git check-attr myAttr -- org/example/MyClass.java org/example/NoMyAttr.java\n"
"org/example/MyClass.java: myAttr: set\n"
"org/example/NoMyAttr.java: myAttr: unspecified\n"

#. type: Plain text
#: en/git-check-attr.txt:114
#, priority:100
msgid "Not all values are equally unambiguous:"
msgstr "并非所有的价值观都是同样明确的："

#. type: delimited block -
#: en/git-check-attr.txt:117
#, no-wrap, placeholders:'git check-attr', priority:100
msgid ""
"$ git check-attr caveat README\n"
"README: caveat: unspecified\n"
msgstr ""
"$ git check-attr caveat README\n"
"README: caveat: unspecified\n"

#. type: Plain text
#: en/git-check-attr.txt:122
#, ignore-same, priority:100
msgid "linkgit:gitattributes[5]."
msgstr "linkgit:gitattributes[5]."

#. type: Title =
#: en/git-check-ignore.txt:2
#, ignore-same, no-wrap, priority:80
msgid "git-check-ignore(1)"
msgstr "git-check-ignore(1)"

#. type: Plain text
#: en/git-check-ignore.txt:7
#, placeholders:'git-check-ignore', priority:80
msgid "git-check-ignore - Debug gitignore / exclude files"
msgstr "git-check-ignore - 调试 gitignore / 排除文件"

#. type: Plain text
#: en/git-check-ignore.txt:14
#, ignore-ellipsis, no-wrap, placeholders:'git check-ignore':'git check-ignore':'--stdin', priority:80
msgid ""
"'git check-ignore' [<options>] <pathname>...\n"
"'git check-ignore' [<options>] --stdin\n"
msgstr ""
"'git check-ignore' [<选项>] <路径名>...\n"
"'git check-ignore' [<选项>] --stdin\n"

#. type: Plain text
#: en/git-check-ignore.txt:22
#, placeholders:'`--stdin`':'.gitignore', priority:80
msgid "For each pathname given via the command-line or from a file via `--stdin`, check whether the file is excluded by .gitignore (or other input files to the exclude mechanism) and output the path if it is excluded."
msgstr "对于通过命令行或通过 `--stdin` 从文件中给出的每个路径名，检查该文件是否被 .gitignore（或排除机制的其他输入文件）排除，如果被排除，则输出路径。"

#. type: Plain text
#: en/git-check-ignore.txt:25
#, placeholders:'`--no-index', priority:80
msgid "By default, tracked files are not shown at all since they are not subject to exclude rules; but see `--no-index'."
msgstr "默认情况下，不显示跟踪文件，因为它们不受排除规则的限制；但请参阅 `--no-index`。"

#. type: Labeled list
#: en/git-check-ignore.txt:28
#, no-wrap, placeholders:'--quiet', priority:80
msgid "-q, --quiet"
msgstr "-q, --quiet"

#. type: Plain text
#: en/git-check-ignore.txt:31
#, priority:80
msgid "Don't output anything, just set exit status. This is only valid with a single pathname."
msgstr "不输出任何内容，只设置退出状态。 这只对单个路径名有效。"

#. type: Labeled list
#: en/git-check-ignore.txt:32
#, no-wrap, placeholders:'--verbose', priority:80
msgid "-v, --verbose"
msgstr "-v, --verbose"

#. type: Plain text
#: en/git-check-ignore.txt:39
#, priority:80
msgid "Instead of printing the paths that are excluded, for each path that matches an exclude pattern, print the exclude pattern together with the path. (Matching an exclude pattern usually means the path is excluded, but if the pattern begins with \"`!`\" then it is a negated pattern and matching it means the path is NOT excluded.)"
msgstr "对于与排除模式匹配的路径，不是打印被排除的路径，而是将排除模式与路径一起打印出来。 (与排除模式匹配通常意味着路径已被排除，但如果模式以 \"`!`\" 开头，则是一个否定模式，与之匹配意味着路径未被排除）。"

#. type: Plain text
#: en/git-check-ignore.txt:42
#, placeholders:'linkgit:gitignore[5]', priority:80
msgid "For precedence rules within and between exclude sources, see linkgit:gitignore[5]."
msgstr "关于排除源内部和排除源之间的优先级规则，请参见 linkgit:gitignore[5]。"

#. type: Plain text
#: en/git-check-ignore.txt:46
#, priority:80
msgid "Read pathnames from the standard input, one per line, instead of from the command-line."
msgstr "从标准输入中读取路径名，每行一个，而不是从命令行读取。"

#. type: Plain text
#: en/git-check-ignore.txt:51
#, placeholders:'`--stdin`', priority:80
msgid "The output format is modified to be machine-parsable (see below). If `--stdin` is also given, input paths are separated with a NUL character instead of a linefeed character."
msgstr "输出格式被修改为机器可解析格式（见下文）。 如果同时给出 `--stdin`，输入路径将以 NUL 字符分隔，而不是换行符。"

#. type: Labeled list
#: en/git-check-ignore.txt:52
#, no-wrap, placeholders:'--non-matching', priority:80
msgid "-n, --non-matching"
msgstr "-n, --non-matching"

#. type: Plain text
#: en/git-check-ignore.txt:57
#, placeholders:'`--verbose`', priority:80
msgid "Show given paths which don't match any pattern. This only makes sense when `--verbose` is enabled, otherwise it would not be possible to distinguish between paths which match a pattern and those which don't."
msgstr "显示不匹配任何模式的给定路径。 这只有在启用 `--verbose` 时才有意义，否则就无法区分与模式匹配的路径和不匹配的路径。"

#. type: Labeled list
#: en/git-check-ignore.txt:58 en/git-grep.txt:48
#, ignore-same, no-wrap, priority:100
msgid "--no-index"
msgstr "--no-index"

#. type: Plain text
#: en/git-check-ignore.txt:64
#, priority:80
msgid "Don't look in the index when undertaking the checks. This can be used to debug why a path became tracked by e.g. `git add .` and was not ignored by the rules as expected by the user or when developing patterns including negation to match a path previously added with `git add -f`."
msgstr "进行检查时不要查看索引。这可以用来调试为什么某个路径会被 `git add .` 追踪，而不是像用户期望的那样被规则忽略，或者在开发包括否定在内的模式以匹配之前用 `git add -f` 添加的路径时使用。"

#. type: Plain text
#: en/git-check-ignore.txt:72
#, priority:80
msgid "By default, any of the given pathnames which match an ignore pattern will be output, one per line. If no pattern matches a given path, nothing will be output for that path; this means that path will not be ignored."
msgstr "默认情况下，将输出与忽略模式匹配的任何给定路径名，每行一个。 如果没有模式匹配给定路径，则不会输出该路径的任何内容；这意味着该路径不会被忽略。"

#. type: Plain text
#: en/git-check-ignore.txt:74
#, placeholders:'`--verbose`', priority:80
msgid "If `--verbose` is specified, the output is a series of lines of the form:"
msgstr "如果指定了 `--verbose`，输出将是一系列格式的行："

#. type: Plain text
#: en/git-check-ignore.txt:76
#, priority:80
msgid "<source> <COLON> <linenum> <COLON> <pattern> <HT> <pathname>"
msgstr "<source> <COLON> <linenum> <COLON> <模式> <HT> <路径名>"

#. type: Plain text
#: en/git-check-ignore.txt:84
#, placeholders:'core.excludesFile':'.git/info/exclude', priority:80
msgid "<pathname> is the path of a file being queried, <pattern> is the matching pattern, <source> is the pattern's source file, and <linenum> is the line number of the pattern within that source. If the pattern contained a \"`!`\" prefix or \"`/`\" suffix, it will be preserved in the output. <source> will be an absolute path when referring to the file configured by `core.excludesFile`, or relative to the repository root when referring to `.git/info/exclude` or a per-directory exclude file."
msgstr "<路径名> 是被查询文件的路径，<模式> 是匹配模式，<source> 是模式的源文件，<linenum> 是源文件中模式的行号。 如果模式包含 \"`!`\" 前缀或 \"`/`\" 后缀，输出中将保留该前缀或后缀。 <source> 在指向 `core.excludesFile` 配置的文件时是绝对路径，在指向 `.git/info/exclude` 或每个目录的排除文件时是相对于仓库根目录的路径。"

#. type: Plain text
#: en/git-check-ignore.txt:88
#, placeholders:'`-z`':'`--verbose`', priority:80
msgid "If `-z` is specified, the pathnames in the output are delimited by the null character; if `--verbose` is also specified then null characters are also used instead of colons and hard tabs:"
msgstr "如果指定了 `-z`，输出中的路径名将以空字符分隔；如果还指定了 `--verbose`，则空字符也将取代冒号和硬制表符："

#. type: Plain text
#: en/git-check-ignore.txt:90
#, priority:80
msgid "<source> <NULL> <linenum> <NULL> <pattern> <NULL> <pathname> <NULL>"
msgstr "<source> <NULL> <linenum> <NULL> <模式> <NULL> <路径名> <NULL>"

#. type: Plain text
#: en/git-check-ignore.txt:100
#, placeholders:'`-n`':'`--non-matching`', priority:80
msgid "If `-n` or `--non-matching` are specified, non-matching pathnames will also be output, in which case all fields in each output record except for <pathname> will be empty. This can be useful when running non-interactively, so that files can be incrementally streamed to STDIN of a long-running check-ignore process, and for each of these files, STDOUT will indicate whether that file matched a pattern or not. (Without this option, it would be impossible to tell whether the absence of output for a given file meant that it didn't match any pattern, or that the output hadn't been generated yet.)"
msgstr "如果指定了 `-n` 或 `--non-matching`，则也会输出不匹配的路径名，在这种情况下，每条输出记录中除 < 路径名> 之外的所有字段都将为空。 这在非交互式运行时非常有用，可以将文件以增量方式流式传输到长期运行的忽略检查进程的 STDIN，而对于每个文件，STDOUT 都会显示该文件是否与模式匹配。 (如果没有这个选项，就无法判断某个文件没有输出是意味着它不匹配任何模式，还是意味着输出尚未生成。）"

#. type: Title -
#: en/git-check-ignore.txt:107 en/git-filter-branch.txt:239 en/git-merge-tree.txt:187 en/git-remote.txt:209
#, no-wrap, priority:220
msgid "EXIT STATUS"
msgstr "退出状态码"

#. type: Labeled list
#: en/git-check-ignore.txt:109
#, no-wrap, priority:80
msgid "0"
msgstr "0"

#. type: Plain text
#: en/git-check-ignore.txt:111
#, priority:80
msgid "One or more of the provided paths is ignored."
msgstr "一个或多个提供的路径被忽略。"

#. type: Labeled list
#: en/git-check-ignore.txt:112
#, no-wrap, priority:80
msgid "1"
msgstr "1"

#. type: Plain text
#: en/git-check-ignore.txt:114
#, priority:80
msgid "None of the provided paths are ignored."
msgstr "所提供的路径都不会被忽略。"

#. type: Labeled list
#: en/git-check-ignore.txt:115
#, no-wrap, priority:80
msgid "128"
msgstr "128"

#. type: Plain text
#: en/git-check-ignore.txt:117
#, priority:80
msgid "A fatal error was encountered."
msgstr "遇到致命错误。"

#. type: Plain text
#: en/git-check-ignore.txt:123
#, ignore-same, priority:80
msgid "linkgit:gitignore[5] linkgit:git-config[1] linkgit:git-ls-files[1]"
msgstr "linkgit:gitignore[5] linkgit:git-config[1] linkgit:git-ls-files[1]"

#. type: Title =
#: en/git-check-mailmap.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-check-mailmap(1)"
msgstr "git-check-mailmap(1)"

#. type: Plain text
#: en/git-check-mailmap.txt:7
#, placeholders:'git-check-mailmap', priority:100
msgid "git-check-mailmap - Show canonical names and email addresses of contacts"
msgstr "git-check-mailmap - 显示联系人的规范名称和电子邮件地址"

#. type: Plain text
#: en/git-check-mailmap.txt:13
#, ignore-ellipsis, no-wrap, placeholders:'git check-mailmap', priority:100
msgid "'git check-mailmap' [<options>] <contact>...\n"
msgstr "'git check-mailmap' [<选项>] <连接>...\n"

#. type: Plain text
#: en/git-check-mailmap.txt:22
#, placeholders:'`--stdin`', priority:100
msgid "For each ``Name $$<user@host>$$'' or ``$$<user@host>$$'' from the command-line or standard input (when using `--stdin`), look up the person's canonical name and email address (see \"Mapping Authors\" below). If found, print them; otherwise print the input as-is."
msgstr "对于每一个来自命令行或标准输入（当使用 `--stdin` 时）的 ``Name $$<user@host>$$\" 或 ``$$<user@host>$$'，查找该人的规范名称和电子邮件地址（见下面的 “映射作者”）。如果找到了，就打印出来；否则就按原样打印输入。"

#. type: Plain text
#: en/git-check-mailmap.txt:29
#, priority:100
msgid "Read contacts, one per line, from the standard input after exhausting contacts provided on the command-line."
msgstr "在用完命令行上提供的联系人后，从标准输入中读取联系人，每行一个。"

#. type: Plain text
#: en/git-check-mailmap.txt:37
#, priority:100
msgid "For each contact, a single line is output, terminated by a newline. If the name is provided or known to the 'mailmap', ``Name $$<user@host>$$'' is printed; otherwise only ``$$<user@host>$$'' is printed."
msgstr "对于每个联系人，都会输出一行，以换行结束。 如果名字被提供或被 'mailmap' 知道，``Name $$<user@host>$$'' 被打印；否则只有 ``$$<user@host>$$'' 被打印。"

#. type: Plain text
#: en/git-check-mailmap.txt:44
#, placeholders:'mailmap.file':'mailmap.blob':'linkgit:git-config[1]', priority:100
msgid "See `mailmap.file` and `mailmap.blob` in linkgit:git-config[1] for how to specify a custom `.mailmap` target file or object."
msgstr "参见 linkgit:git-config[1] 中的 `mailmap.file` 和 `mailmap.blob`，了解如何指定一个自定义的 `.mailmap` 目标文件或对象。"

#. type: Title =
#: en/git-checkout-index.txt:2
#, ignore-same, no-wrap, priority:80
msgid "git-checkout-index(1)"
msgstr "git-checkout-index(1)"

#. type: Plain text
#: en/git-checkout-index.txt:7
#, placeholders:'git-checkout-index', priority:80
msgid "git-checkout-index - Copy files from the index to the working tree"
msgstr "git-checkout-index - 将文件从索引复制到工作目录树"

#. type: Plain text
#: en/git-checkout-index.txt:18
#, ignore-ellipsis, no-wrap, placeholders:'git checkout-index':'[--prefix=':'[--stage=':'[--temp]':'[--ignore-skip-worktree-bits]':'[--stdin]', priority:80
msgid ""
"'git checkout-index' [-u] [-q] [-a] [-f] [-n] [--prefix=<string>]\n"
"\t\t   [--stage=<number>|all]\n"
"\t\t   [--temp]\n"
"\t\t   [--ignore-skip-worktree-bits]\n"
"\t\t   [-z] [--stdin]\n"
"\t\t   [--] [<file>...]\n"
msgstr ""
"'git checkout-index' [-u] [-q] [-a] [-f] [-n] [--prefix=<字符串>]\n"
"\t\t   [--stage=<数字>|all]\n"
"\t\t   [--temp]\n"
"\t\t   [--ignore-skip-worktree-bits]\n"
"\t\t   [-z] [--stdin]\n"
"\t\t   [--] [<文件>...]\n"

#. type: Plain text
#: en/git-checkout-index.txt:23
#, priority:80
msgid "Copies all listed files from the index to the working directory (not overwriting existing files)."
msgstr "将索引中列出的所有文件复制到工作目录（不会覆盖现有文件）。"

#. type: Plain text
#: en/git-checkout-index.txt:30
#, priority:80
msgid "update stat information for the checked out entries in the index file."
msgstr "更新索引文件中已签出条目的统计信息。"

#. type: Plain text
#: en/git-checkout-index.txt:34
#, priority:80
msgid "be quiet if files exist or are not in the index"
msgstr "如果文件存在或不在索引中，则保持安静"

#. type: Plain text
#: en/git-checkout-index.txt:38
#, priority:80
msgid "forces overwrite of existing files"
msgstr "强制覆盖现有文件"

#. type: Plain text
#: en/git-checkout-index.txt:44
#, placeholders:'`--ignore-skip-worktree-bits`', priority:80
msgid "checks out all files in the index except for those with the skip-worktree bit set (see `--ignore-skip-worktree-bits`). Cannot be used together with explicit filenames."
msgstr "检查索引中的所有文件，但设置了跳过工作树位的文件除外（参见 `--ignore-skip-worktree-bits`）。 不能与显式文件名一起使用。"

#. type: Labeled list
#: en/git-checkout-index.txt:46
#, ignore-same, no-wrap, priority:80
msgid "--no-create"
msgstr "--no-create"

#. type: Plain text
#: en/git-checkout-index.txt:49
#, priority:80
msgid "Don't checkout new files, only refresh files already checked out."
msgstr "不签出新文件，只刷新已签出的文件。"

#. type: Labeled list
#: en/git-checkout-index.txt:50
#, no-wrap, placeholders:'--prefix=', priority:80
msgid "--prefix=<string>"
msgstr "--prefix=<字符串>"

#. type: Plain text
#: en/git-checkout-index.txt:53
#, priority:80
msgid "When creating files, prepend <string> (usually a directory including a trailing /)"
msgstr "创建文件时，预输入 <字符串>（通常是目录，包括尾部的 /）"

#. type: Labeled list
#: en/git-checkout-index.txt:54
#, no-wrap, placeholders:'--stage=', priority:80
msgid "--stage=<number>|all"
msgstr "--stage=<数量>|all"

#. type: Plain text
#: en/git-checkout-index.txt:58
#, placeholders:'--stage=all':'--temp', priority:80
msgid "Instead of checking out unmerged entries, copy out the files from the named stage. <number> must be between 1 and 3. Note: --stage=all automatically implies --temp."
msgstr "不检查未合并的条目，而是从命名的阶段复制出文件。 <数字> 必须介于 1 和 3 之间。 注意：--stage=all 自动隐含 --temp。"

#. type: Labeled list
#: en/git-checkout-index.txt:59
#, ignore-same, no-wrap, priority:80
msgid "--temp"
msgstr "--temp"

#. type: Plain text
#: en/git-checkout-index.txt:63
#, priority:80
msgid "Instead of copying the files to the working directory, write the content to temporary files. The temporary name associations will be written to stdout."
msgstr "与其将文件复制到工作目录，不如将内容写入临时文件。 临时名称关联将写入标准输出流。"

#. type: Labeled list
#: en/git-checkout-index.txt:64 en/git-checkout.txt:244 en/git-restore.txt:107
#, ignore-same, no-wrap, priority:280
msgid "--ignore-skip-worktree-bits"
msgstr "--ignore-skip-worktree-bits"

#. type: Plain text
#: en/git-checkout-index.txt:67
#, priority:80
msgid "Check out all files, including those with the skip-worktree bit set."
msgstr "检查所有文件，包括设置了跳过工作树位的文件。"

#. type: Plain text
#: en/git-checkout-index.txt:72
#, priority:80
msgid "Instead of taking a list of paths from the command line, read the list of paths from the standard input. Paths are separated by LF (i.e. one path per line) by default."
msgstr "不从命令行中获取路径列表，而是从标准输入中读取路径列表。 默认情况下，路径之间用 LF 分隔（即每行一个路径）。"

#. type: Plain text
#: en/git-checkout-index.txt:76
#, placeholders:'`--stdin`', priority:80
msgid "Only meaningful with `--stdin`; paths are separated with NUL character instead of LF."
msgstr "只对 `--stdin` 有意义；路径用 NUL 字符分隔，而不用 LF。"

#. type: Plain text
#: en/git-checkout-index.txt:79 en/git-checkout.txt:371 en/git-commit.txt:400 en/git-ls-files.txt:229 en/git-merge-index.txt:25 en/git-prune.txt:53 en/git-reset.txt:130 en/git-restore.txt:147 en/git-update-index.txt:234 en/git-verify-pack.txt:38
#, priority:280
msgid "Do not interpret any more arguments as options."
msgstr "不将之后的参数解释为选项。"

#. type: Plain text
#: en/git-checkout-index.txt:81
#, priority:80
msgid "The order of the flags used to matter, but not anymore."
msgstr "标志的顺序曾经很重要，但现在已经不重要了。"

#. type: Plain text
#: en/git-checkout-index.txt:85
#, placeholders:'git checkout-index':'git checkout-index':'git checkout-index', priority:80
msgid "Just doing `git checkout-index` does nothing. You probably meant `git checkout-index -a`. And if you want to force it, you want `git checkout-index -f -a`."
msgstr "只做 `git checkout-index`什么也做不了。你可能是指 `git checkout-index -a`。如果你想强制执行，就需要 `git checkout-index -f -a`。"

#. type: Plain text
#: en/git-checkout-index.txt:89
#, priority:80
msgid "Intuitiveness is not the goal here. Repeatability is. The reason for the \"no arguments means no work\" behavior is that from scripts you are supposed to be able to do:"
msgstr "直观性不是目的。可重复性才是。“没有参数就意味着没有工作” 这一行为的原因是，脚本应该能够实现以下功能："

#. type: delimited block -
#: en/git-checkout-index.txt:92
#, no-wrap, placeholders:'git checkout-index', priority:80
msgid "$ find . -name '*.h' -print0 | xargs -0 git checkout-index -f --\n"
msgstr "$ find . -name '*.h' -print0 | xargs -0 git checkout-index -f --\n"

#. type: Plain text
#: en/git-checkout-index.txt:98
#, placeholders:'git checkout-index':'--stdin', priority:80
msgid "which will force all existing `*.h` files to be replaced with their cached copies. If an empty command line implied \"all\", then this would force-refresh everything in the index, which was not the point. But since 'git checkout-index' accepts --stdin it would be faster to use:"
msgstr "会强制将所有现有的 `*.h` 文件替换为其缓存副本。如果空命令行意味着 \"all\"，那么这将强制刷新索引中的所有内容，而这并不是重点。 但由于 \"git checkout-index\" 接受 --stdin，因此使用起来会更快："

#. type: delimited block -
#: en/git-checkout-index.txt:101
#, no-wrap, placeholders:'git checkout-index':'--stdin', priority:80
msgid "$ find . -name '*.h' -print0 | git checkout-index -f -z --stdin\n"
msgstr "$ find . -name '*.h' -print0 | git checkout-index -f -z --stdin\n"

#. type: Plain text
#: en/git-checkout-index.txt:106
#, placeholders:'`-a`', priority:80
msgid "The `--` is just a good idea when you know the rest will be filenames; it will prevent problems with a filename of, for example, `-a`. Using `--` is probably a good policy in scripts."
msgstr "当你知道其余的都是文件名时，`--` 是一个好主意；它可以防止出现文件名为 `-a` 的问题。 在脚本中使用 `--` 可能是个好主意。"

#. type: Title -
#: en/git-checkout-index.txt:109
#, no-wrap, placeholders:'--temp':'--stage=all', priority:80
msgid "Using --temp or --stage=all"
msgstr "使用 --temp 或 --stage=all"

#. type: Plain text
#: en/git-checkout-index.txt:116
#, placeholders:'`--temp`':'`--stage=all`':'git checkout-index', priority:80
msgid "When `--temp` is used (or implied by `--stage=all`) 'git checkout-index' will create a temporary file for each index entry being checked out. The index will not be updated with stat information. These options can be useful if the caller needs all stages of all unmerged entries so that the unmerged files can be processed by an external merge tool."
msgstr "当使用了 `--temp`（或由 `--stage=all`隐含）时，\"git checkout-index\" 将为每个被检出的索引条目创建一个临时文件。 索引不会更新统计信息。 如果调用者需要所有未合并条目的所有阶段，以便外部合并工具可以处理这些未合并文件，那么这些选项会很有用。"

#. type: Plain text
#: en/git-checkout-index.txt:120
#, priority:80
msgid "A listing will be written to stdout providing the association of temporary file names to tracked path names. The listing format has two variations:"
msgstr "将向标准输出流写入一个列表，提供临时文件名与跟踪路径名之间的关联。 列表格式有两种："

#. type: Plain text
#: en/git-checkout-index.txt:122
#, priority:80
msgid "tempname TAB path RS"
msgstr "临时名称 TAB 路径 RS"

#. type: Plain text
#: en/git-checkout-index.txt:127
#, placeholders:'`--stage`':'`--stage=all`', priority:80
msgid "The first format is what gets used when `--stage` is omitted or is not `--stage=all`. The field tempname is the temporary file name holding the file content and path is the tracked path name in the index. Only the requested entries are output."
msgstr "语类型：纯文本 第一种格式是省略 `--stage` 或不使用 `--stage=all` 时使用的格式。字段临时名称是保存文件内容的临时文件名，路劲是索引中的跟踪路径名。 只输出所请求的条目。"

#. type: Plain text
#: en/git-checkout-index.txt:129
#, priority:80
msgid "stage1temp SP stage2temp SP stage3tmp TAB path RS"
msgstr "阶段一缓存 SP 阶段二缓存 SP 阶段三缓存 TAB 路径 RS"

#. type: Plain text
#: en/git-checkout-index.txt:135
#, placeholders:'`--stage=all`', priority:80
msgid "The second format is what gets used when `--stage=all`. The three stage temporary fields (stage1temp, stage2temp, stage3temp) list the name of the temporary file if there is a stage entry in the index or `.` if there is no stage entry. Paths which only have a stage 0 entry will always be omitted from the output."
msgstr "第二种格式是在 `--stage=all` 时使用的格式。 如果索引中有阶段条目，三个阶段临时字段（阶段一缓存、阶段二缓存、阶段三换粗）会列出临时文件的名称；如果没有阶段条目，则会列出 `.`。 只有阶段 0 条目的路径将始终从输出中省略。"

#. type: Plain text
#: en/git-checkout-index.txt:142
#, priority:80
msgid "In both formats RS (the record separator) is newline by default but will be the null byte if -z was passed on the command line. The temporary file names are always safe strings; they will never contain directory separators or whitespace characters. The path field is always relative to the current directory and the temporary file names are always relative to the top level directory."
msgstr "在这两种格式中，RS（记录分隔符）默认都是换行符，但如果在命令行中输入了 -z，RS（记录分隔符）就会变成空字节。 临时文件名始终是安全字符串，绝不包含目录分隔符或空白字符。 路径字段始终相对于当前目录，临时文件名始终相对于顶层目录。"

#. type: Plain text
#: en/git-checkout-index.txt:146
#, priority:80
msgid "If the object being copied out to a temporary file is a symbolic link the content of the link will be written to a normal file. It is up to the end-user or the Porcelain to make use of this information."
msgstr "如果被复制到临时文件中的对象是一个符号链接，那么该链接的内容将被写入一个普通文件。 最终用户或 Porcelain 可自行决定是否使用这些信息。"

#. type: Labeled list
#: en/git-checkout-index.txt:150
#, no-wrap, priority:80
msgid "To update and refresh only the files already checked out"
msgstr "只更新和刷新已签出的文件"

#. type: delimited block -
#: en/git-checkout-index.txt:154 en/git-update-index.txt:371
#, no-wrap, placeholders:'git checkout-index':'git update-index':'--ignore-missing':'--refresh', priority:80
msgid "$ git checkout-index -n -f -a && git update-index --ignore-missing --refresh\n"
msgstr "$ git checkout-index -n -f -a && git update-index --ignore-missing --refresh\n"

#. type: Labeled list
#: en/git-checkout-index.txt:156
#, no-wrap, placeholders:'git checkout-index', priority:80
msgid "Using 'git checkout-index' to \"export an entire tree\""
msgstr "使用 'git checkout-index' 来 “导出整棵目录树”"

#. type: Plain text
#: en/git-checkout-index.txt:160
#, placeholders:'git checkout-index', priority:80
msgid "The prefix ability basically makes it trivial to use 'git checkout-index' as an \"export as tree\" function. Just read the desired tree into the index, and do:"
msgstr "有了前缀功能，使用 'git checkout-index' 作为 “导出为目录树” 功能就变得易如反掌了。 只需将所需的目录树读入索引，然后执行即可："

#. type: delimited block -
#: en/git-checkout-index.txt:163
#, no-wrap, placeholders:'git checkout-index':'--prefix=git-export-dir', priority:80
msgid "$ git checkout-index --prefix=git-export-dir/ -a\n"
msgstr "$ git checkout-index --prefix=git-export-dir/ -a\n"

#. type: Plain text
#: en/git-checkout-index.txt:167
#, placeholders:'git checkout-index', priority:80
msgid "`git checkout-index` will \"export\" the index into the specified directory."
msgstr "`git checkout-index` 会将索引 “导出” 到指定目录。"

#. type: Plain text
#: en/git-checkout-index.txt:171
#, priority:80
msgid "The final \"/\" is important. The exported name is literally just prefixed with the specified string. Contrast this with the following example."
msgstr "最后的 \"/\" 很重要。导出的名称实际上只是指定字符串的前缀。 这与下面的示例形成鲜明对比。"

#. type: Labeled list
#: en/git-checkout-index.txt:172
#, no-wrap, priority:80
msgid "Export files with a prefix"
msgstr "导出带前缀的文件"

#. type: delimited block -
#: en/git-checkout-index.txt:176
#, no-wrap, placeholders:'git checkout-index':'--prefix=', priority:80
msgid "$ git checkout-index --prefix=.merged- Makefile\n"
msgstr "$ git checkout-index --prefix=.merged- Makefile\n"

#. type: Plain text
#: en/git-checkout-index.txt:180
#, priority:80
msgid "This will check out the currently cached copy of `Makefile` into the file `.merged-Makefile`."
msgstr "这将把当前缓存的 `Makefile` 副本签出到文件 `.merged-Makefile` 中。"

#. type: Title =
#: en/git-checkout.txt:2
#, ignore-same, no-wrap, priority:240
msgid "git-checkout(1)"
msgstr "git-checkout(1)"

#. type: Plain text
#: en/git-checkout.txt:7
#, placeholders:'git-checkout', priority:240
msgid "git-checkout - Switch branches or restore working tree files"
msgstr "git-checkout - 切换分支或恢复工作目录树文件"

#. type: Plain text
#: en/git-checkout.txt:20
#, ignore-ellipsis, no-wrap, placeholders:'--detach':'[--detach]':'--orphan]':'--pathspec-from-file=':'[--pathspec-file-nul]':'--ours':'--theirs':'--conflict=':'--ours':'--theirs':'--conflict=':'--pathspec-from-file=':'[--pathspec-file-nul]':'--patch', priority:240
msgid ""
"'git checkout' [-q] [-f] [-m] [<branch>]\n"
"'git checkout' [-q] [-f] [-m] --detach [<branch>]\n"
"'git checkout' [-q] [-f] [-m] [--detach] <commit>\n"
"'git checkout' [-q] [-f] [-m] [[-b|-B|--orphan] <new-branch>] [<start-point>]\n"
"'git checkout' [-f] <tree-ish> [--] <pathspec>...\n"
"'git checkout' [-f] <tree-ish> --pathspec-from-file=<file> [--pathspec-file-nul]\n"
"'git checkout' [-f|--ours|--theirs|-m|--conflict=<style>] [--] <pathspec>...\n"
"'git checkout' [-f|--ours|--theirs|-m|--conflict=<style>] --pathspec-from-file=<file> [--pathspec-file-nul]\n"
"'git checkout' (-p|--patch) [<tree-ish>] [--] [<pathspec>...]\n"
msgstr ""
"'git checkout' [-q] [-f] [-m] [<分支>]\n"
"'git checkout' [-q] [-f] [-m] --detach [<分支>]\n"
"'git checkout' [-q] [-f] [-m] [--detach] <提交>\n"
"'git checkout' [-q] [-f] [-m] [[-b|-B|--orphan] <新分支>] [<起始点>]\n"
"'git checkout' [-f] <目录树对象> [--] <路径规范>...\n"
"'git checkout' [-f] <目录树对象> --pathspec-from-file=<文件> [--pathspec-file-nul]\n"
"'git checkout' [-f|--ours|--theirs|-m|--conflict=<样式>] [--] <路径规范>...\n"
"'git checkout' [-f|--ours|--theirs|-m|--conflict=<样式>] --pathspec-from-file=<文件> [--pathspec-file-nul]\n"
"'git checkout' (-p|--patch) [<目录树对象>] [--] [<路径规范>...]\n"

#. type: Plain text
#: en/git-checkout.txt:27
#, placeholders:'HEAD', priority:240
msgid "Updates files in the working tree to match the version in the index or the specified tree. If no pathspec was given, 'git checkout' will also update `HEAD` to set the specified branch as the current branch."
msgstr "更新工作区中的文件，使其与索引或指定的树中的版本一致。 如果没有给出pathspec，'git checkout'也将更新`HEAD`，将指定的分支设为当前分支。"

#. type: Labeled list
#: en/git-checkout.txt:28
#, no-wrap, priority:240
msgid "'git checkout' [<branch>]"
msgstr "'git checkout' [<分支>]"

#. type: Plain text
#: en/git-checkout.txt:34
#, placeholders:'HEAD', priority:240
msgid "To prepare for working on `<branch>`, switch to it by updating the index and the files in the working tree, and by pointing `HEAD` at the branch. Local modifications to the files in the working tree are kept, so that they can be committed to the `<branch>`."
msgstr "要准备在`<分支>`上工作，需要更新索引和工作区中的文件，以及将`HEAD`指向该分支来切换到该分支。对工作区中文件的本地修改会被保留，以便修改可以被提交到`<分支>`。"

#. type: Plain text
#: en/git-checkout.txt:38
#, placeholders:'`--no-guess`', priority:240
msgid "If `<branch>` is not found but there does exist a tracking branch in exactly one remote (call it `<remote>`) with a matching name and `--no-guess` is not specified, treat as equivalent to"
msgstr "如果没有找到该`<分支>`，但正好一个远程（称其为`<远程仓库>`）中确实存在一个名称相匹配的已跟踪分支，并且没有指定`--no-guess`，则视为等同于"

#. type: delimited block -
#: en/git-checkout.txt:41 en/git-checkout.txt:191
#, no-wrap, placeholders:'--track', priority:240
msgid "$ git checkout -b <branch> --track <remote>/<branch>\n"
msgstr "$ git checkout -b <分支> --track <远程仓库>/<分支>\n"

#. type: Plain text
#: en/git-checkout.txt:47
#, priority:240
msgid "You could omit `<branch>`, in which case the command degenerates to \"check out the current branch\", which is a glorified no-op with rather expensive side-effects to show only the tracking information, if it exists, for the current branch."
msgstr "你可以省略 `<分支>`，在这种情况下，该命令会退化为 “检出当前分支”，这是一个美化的无操作，具有非常大的副作用，如果存在当前分支的话，只显示当前分支的跟踪信息。"

#. type: Labeled list
#: en/git-checkout.txt:48
#, no-wrap, priority:240
msgid "'git checkout' -b|-B <new-branch> [<start-point>]"
msgstr "'git checkout' -b|-B <新分支> [<起始点>]"

#. type: Plain text
#: en/git-checkout.txt:56
#, placeholders:'`-b`':'`--track`':'`--no-track`':'`--track`':'`-b`':'`--track`', priority:240
msgid "Specifying `-b` causes a new branch to be created as if linkgit:git-branch[1] were called and then checked out. In this case you can use the `--track` or `--no-track` options, which will be passed to 'git branch'. As a convenience, `--track` without `-b` implies branch creation; see the description of `--track` below."
msgstr "指定 `-b` 会导致一个新的分支被创建，就像调用 linkgit:git-branch[1] 然后签出一样。 在这种情况下，你可以使用 `--track` 或 `--no-track` 选项，它们将被传递给 'git branch'。 为方便起见，`--track`不加`-b`意味着创建分支；见下文对`--track`的描述。"

# ERROR: `-B` not found in translation
#. type: Plain text
#: en/git-checkout.txt:59
#, placeholders:'`-B`', priority:240
msgid "If `-B` is given, `<new-branch>` is created if it doesn't exist; otherwise, it is reset. This is the transactional equivalent of"
msgstr "如果给定了 `-B`，如果不存在 `<新分支>`，就会创建；否则，就会重置。这在事务上等同于"

#. type: delimited block -
#: en/git-checkout.txt:63
#, no-wrap, priority:240
msgid ""
"$ git branch -f <branch> [<start-point>]\n"
"$ git checkout <branch>\n"
msgstr ""
"$ git branch -f <分支> [<起始点>]\n"
"$ git checkout <分支>\n"

#. type: Plain text
#: en/git-checkout.txt:69
#, priority:240
msgid "that is to say, the branch is not reset/created unless \"git checkout\" is successful (e.g., when the branch is in use in another worktree, not just the current branch stays the same, but the branch is not reset to the start-point, either)."
msgstr "也就是说，除非 \"git checkout\" 成功，否则不会重置/创建分支（例如，当分支在另一个工作树中使用时，不仅当前分支保持不变，分支也不会重置为起点）。"

#. type: Labeled list
#: en/git-checkout.txt:70
#, no-wrap, placeholders:'--detach', priority:240
msgid "'git checkout' --detach [<branch>]"
msgstr "'git checkout' --detach [<分支>]"

#. type: Labeled list
#: en/git-checkout.txt:71
#, no-wrap, placeholders:'[--detach]', priority:240
msgid "'git checkout' [--detach] <commit>"
msgstr "'git checkout' [--detach] <提交>"

#. type: Plain text
#: en/git-checkout.txt:79
#, placeholders:'HEAD':'HEAD', priority:240
msgid "Prepare to work on top of `<commit>`, by detaching `HEAD` at it (see \"DETACHED HEAD\" section), and updating the index and the files in the working tree. Local modifications to the files in the working tree are kept, so that the resulting working tree will be the state recorded in the commit plus the local modifications."
msgstr "准备在 `<提交>` 上工作，通过分离 `HEAD` 来实现（参见 \"DETACHED HEAD\" 部分），并更新工作区中的索引和文件。 对工作区中的文件的本地修改会被保留，所以最终的工作区将是提交时记录的状态加上本地的修改。"

#. type: Plain text
#: en/git-checkout.txt:83
#, placeholders:'`--detach`':'HEAD':'HEAD', priority:240
msgid "When the `<commit>` argument is a branch name, the `--detach` option can be used to detach `HEAD` at the tip of the branch (`git checkout <branch>` would check out that branch without detaching `HEAD`)."
msgstr "当`<提交>`参数是一个分支名称时，`--detach`选项可以用来分离分支顶端的`HEAD`（`git checkout <分支>`会签出该分支而不分离`HEAD`）。"

#. type: Plain text
#: en/git-checkout.txt:85
#, placeholders:'HEAD', priority:240
msgid "Omitting `<branch>` detaches `HEAD` at the tip of the current branch."
msgstr "省略`<分支>`会在当前分支的顶端分离`HEAD`。"

#. type: Labeled list
#: en/git-checkout.txt:86
#, ignore-ellipsis, no-wrap, placeholders:'--ours':'--theirs':'--conflict=', priority:240
msgid "'git checkout' [-f|--ours|--theirs|-m|--conflict=<style>] [<tree-ish>] [--] <pathspec>..."
msgstr "'git checkout' [-f|--ours|--theirs|-m|--conflict=<样式>] [<目录树对象>] [--] <路径规范>..."

#. type: Labeled list
#: en/git-checkout.txt:87
#, no-wrap, placeholders:'--ours':'--theirs':'--conflict=':'--pathspec-from-file=':'[--pathspec-file-nul]', priority:240
msgid "'git checkout' [-f|--ours|--theirs|-m|--conflict=<style>] [<tree-ish>] --pathspec-from-file=<file> [--pathspec-file-nul]"
msgstr "'git checkout' [-f|--ours|--theirs|-m|--conflict=<样式>] [<树状对象>] --pathspec-from-file=<文件> [--pathspec-file-nul]"

#. type: Plain text
#: en/git-checkout.txt:94
#, priority:240
msgid "Overwrite the contents of the files that match the pathspec. When the `<tree-ish>` (most often a commit) is not given, overwrite working tree with the contents in the index. When the `<tree-ish>` is given, overwrite both the index and the working tree with the contents at the `<tree-ish>`."
msgstr "覆盖符合路径对范文件的内容。 当没有给出`<树状对象>`（最常见的是提交），用索引中的内容覆盖工作区。 当`<树状对象>`被给出时，用`<树状对象>`处的内容覆盖索引和工作区。"

# ERROR: `--ours` not found in translation
# ERROR: `--theirs` not found in translation
#. type: Plain text
#: en/git-checkout.txt:102
#, placeholders:'`-f`':'`--ours`':'`--theirs`':'`-m`', priority:240
msgid "The index may contain unmerged entries because of a previous failed merge. By default, if you try to check out such an entry from the index, the checkout operation will fail and nothing will be checked out. Using `-f` will ignore these unmerged entries. The contents from a specific side of the merge can be checked out of the index by using `--ours` or `--theirs`. With `-m`, changes made to the working tree file can be discarded to re-create the original conflicted merge result."
msgstr "索引可能包含因之前合并失败导致的未合并条目。 默认情况下，如果你试图从索引中签出这样的条目，签出操作将失败，没有任何东西被签出。 使用 `-f` 将忽略这些未合并的条目。 通过使用 `--ours` 或 `--theirs` 选项，可以从索引中检出合并的特定一方的内容。 使用`-m`，对工作区文件的修改可以被丢弃，以重新创建原冲突合并的结果。"

#. type: Labeled list
#: en/git-checkout.txt:103
#, ignore-ellipsis, no-wrap, placeholders:'--patch', priority:240
msgid "'git checkout' (-p|--patch) [<tree-ish>] [--] [<pathspec>...]"
msgstr "'git checkout' (-p|--patch) [<树状对象>] [--] [<路径规范>...]"

#. type: Plain text
#: en/git-checkout.txt:108
#, placeholders:'`--patch`', priority:240
msgid "This is similar to the previous mode, but lets you use the interactive interface to show the \"diff\" output and choose which hunks to use in the result. See below for the description of `--patch` option."
msgstr "这与前面的模式类似，但让你使用交互式界面来显示 \"diff \"输出，并选择在结果中使用哪些代码块。 关于`--patch`选项的描述，见下文。"

#. type: Plain text
#: en/git-checkout.txt:114 en/git-read-tree.txt:120 en/git-stash.txt:244 en/git-switch.txt:150
#, priority:240
msgid "Quiet, suppress feedback messages."
msgstr "静默，压制反馈信息。"

#. type: Labeled list
#: en/git-checkout.txt:116 en/git-fetch-pack.txt:108 en/git-restore.txt:71 en/git-switch.txt:152 en/merge-options.txt:183
#, ignore-same, no-wrap, priority:280
msgid "--no-progress"
msgstr "--no-progress"

#. type: Plain text
#: en/git-checkout.txt:121 en/git-restore.txt:76 en/git-switch.txt:157
#, placeholders:'`--quiet`':'`--quiet`', priority:280
msgid "Progress status is reported on the standard error stream by default when it is attached to a terminal, unless `--quiet` is specified. This flag enables progress reporting even if not attached to a terminal, regardless of `--quiet`."
msgstr "当它附加到终端时，除非指定 `--quiet`，否则默认情况下会在标准错误流中报告进度状态。这个标志可以启用进度报告，即使没有附在到终端，而不管 `--quiet`。"

#. type: Plain text
#: en/git-checkout.txt:128
#, placeholders:'HEAD', priority:240
msgid "When switching branches, proceed even if the index or the working tree differs from `HEAD`, and even if there are untracked files in the way. This is used to throw away local changes and any untracked files or directories that are in the way."
msgstr "当切换分支时，即使索引或工作区与`HEAD`不同，即使有未追踪的文件挡住去路，也要继续。 这是用来丢弃本地修改和任何碍事的未追踪文件或目录的。"

#. type: Plain text
#: en/git-checkout.txt:131
#, priority:240
msgid "When checking out paths from the index, do not fail upon unmerged entries; instead, unmerged entries are ignored."
msgstr "当从索引中检查出路径时，不将未合并条目视为失败；相反，忽略未合并条目。"

#. type: Labeled list
#: en/git-checkout.txt:132 en/git-merge-file.txt:89 en/git-restore.txt:77
#, ignore-same, no-wrap, priority:280
msgid "--ours"
msgstr "--ours"

#. type: Labeled list
#: en/git-checkout.txt:133 en/git-merge-file.txt:90 en/git-restore.txt:78
#, ignore-same, no-wrap, priority:280
msgid "--theirs"
msgstr "--theirs"

#. type: Plain text
#: en/git-checkout.txt:136
#, priority:240
msgid "When checking out paths from the index, check out stage #2 ('ours') or #3 ('theirs') for unmerged paths."
msgstr "当从索引中检查出路径时，要检查第二阶段（'ours'）或第三阶段（'theirs'）的未合并路径。"

# ERROR: --rebase` not found in translation
# ERROR: `--ours` not found in translation
# ERROR: `--theirs` not found in translation
#. type: Plain text
#: en/git-checkout.txt:141
#, placeholders:'--rebase`':'`--ours`':'`--theirs`', priority:240
msgid "Note that during `git rebase` and `git pull --rebase`, 'ours' and 'theirs' may appear swapped; `--ours` gives the version from the branch the changes are rebased onto, while `--theirs` gives the version from the branch that holds your work that is being rebased."
msgstr "注意在 `git rebase` 和 `git pull --rebase` 过程中，\"ours\" 和 \"theirs\" 可能会互换；`--ours` 给出了分支变基后的版本，而 `--theirs` 则给出你即将变基的分支版本。"

#. type: Plain text
#: en/git-checkout.txt:151
#, priority:240
msgid "This is because `rebase` is used in a workflow that treats the history at the remote as the shared canonical one, and treats the work done on the branch you are rebasing as the third-party work to be integrated, and you are temporarily assuming the role of the keeper of the canonical history during the rebase. As the keeper of the canonical history, you need to view the history from the remote as `ours` (i.e. \"our shared canonical history\"), while what you did on your side branch as `theirs` (i.e. \"one contributor's work on top of it\")."
msgstr "这是因为 \"rebase\"在工作流程中使用，它将远程的历史视为共享的规范历史，并将在你重命名的分支上所做的工作视为需要整合的第三方工作，而你在重命名过程中暂时承担了规范历史守护者的角色。 作为规范历史的守护者，你需要将远程的历史视为 \"ours\"（即 \"我们共享的规范历史\"），而将你在侧边分支上的工作视为 \"their\"（即 \"一个贡献者在上面所作的工作\"）。"

#. type: Labeled list
#: en/git-checkout.txt:152 en/git-worktree.txt:189
#, no-wrap, priority:240
msgid "-b <new-branch>"
msgstr "-b <新分支>"

#. type: Plain text
#: en/git-checkout.txt:156
#, priority:240
msgid "Create a new branch named `<new-branch>`, start it at `<start-point>`, and check the resulting branch out; see linkgit:git-branch[1] for details."
msgstr "创建一个名为\"<新分支>\"的新分支，从\"<起点>\"开始，并检出产生的分支；详情见 linkgit:git-branch[1]。"

#. type: Labeled list
#: en/git-checkout.txt:157 en/git-worktree.txt:190
#, no-wrap, priority:240
msgid "-B <new-branch>"
msgstr "-B <新分支>"

#. type: Plain text
#: en/git-checkout.txt:163
#, priority:240
msgid "Creates the branch `<new-branch>`, start it at `<start-point>`; if it already exists, then reset it to `<start-point>`. And then check the resulting branch out. This is equivalent to running \"git branch\" with \"-f\" followed by \"git checkout\" of that branch; see linkgit:git-branch[1] for details."
msgstr "从`<起点>`开始，创建分支`<新分支>`；如果分支已经存在，则重置为`<起点>`。然后检出生成的分支。这相当于用 \"-f\"选项 运行 \"git branch\" ，然后用 \"git checkout\" 检出该分支；详见 linkgit:git-branch[1]。"

#. type: Plain text
#: en/git-checkout.txt:168
#, placeholders:'--track', priority:240
msgid "When creating a new branch, set up \"upstream\" configuration. See \"--track\" in linkgit:git-branch[1] for details."
msgstr "创建新分支时，要设置 \"上游\"配置。详情见 linkgit:git-branch[1] 中的 \"--track\"。"

#. type: Plain text
#: en/git-checkout.txt:178
#, placeholders:'`-b`':'`-b`', priority:240
msgid "If no `-b` option is given, the name of the new branch will be derived from the remote-tracking branch, by looking at the local part of the refspec configured for the corresponding remote, and then stripping the initial part up to the \"*\". This would tell us to use `hack` as the local branch when branching off of `origin/hack` (or `remotes/origin/hack`, or even `refs/remotes/origin/hack`). If the given name has no slash, or the above guessing results in an empty name, the guessing is aborted. You can explicitly give a name with `-b` in such a case."
msgstr "如果没有给出`-b`选项，新分支的名称将从远程跟踪分支中推导出来，方法是查看为相应的远程配置引用规范的本地部分，然后剥离初始部分，直至 \"*\"。由上述可得出，在从`origin/hack`（或`remotes/origin/hack`，甚至`refs/remotes/origin/hack`）分支时，将使用`hack`作为本地分支。如果给定的名字没有斜线，或者上述推测的结果是一个空名，则会终止推测。在这种情况下，你可以用`-b`明确地给出一个名字。"

#. type: Plain text
#: en/git-checkout.txt:182 en/git-switch.txt:177
#, placeholders:'branch.autoSetupMerge', priority:240
msgid "Do not set up \"upstream\" configuration, even if the `branch.autoSetupMerge` configuration variable is true."
msgstr "不设置 \"上游 \"配置，即使`branch.autoSetupMerge`配置变量为true。"

#. type: Labeled list
#: en/git-checkout.txt:183 en/git-switch.txt:92
#, ignore-same, no-wrap, priority:240
msgid "--guess"
msgstr "--guess"

#. type: Labeled list
#: en/git-checkout.txt:184 en/git-switch.txt:93
#, ignore-same, no-wrap, priority:240
msgid "--no-guess"
msgstr "--no-guess"

#. type: Plain text
#: en/git-checkout.txt:188 en/git-switch.txt:97
#, priority:240
msgid "If `<branch>` is not found but there does exist a tracking branch in exactly one remote (call it `<remote>`) with a matching name, treat as equivalent to"
msgstr "如果没有找到`<分支>`，但确实有一个远程分支（称为`<远程分支>`）的跟踪分支存在，且名称匹配，则视为等同于"

#. type: Plain text
#: en/git-checkout.txt:201 en/git-switch.txt:109
#, placeholders:'checkout.defaultRemote':'checkout.defaultRemote':'checkout.defaultRemote':'linkgit:git-config[1]', priority:240
msgid "If the branch exists in multiple remotes and one of them is named by the `checkout.defaultRemote` configuration variable, we'll use that one for the purposes of disambiguation, even if the `<branch>` isn't unique across all remotes. Set it to e.g. `checkout.defaultRemote=origin` to always checkout remote branches from there if `<branch>` is ambiguous but exists on the 'origin' remote. See also `checkout.defaultRemote` in linkgit:git-config[1]."
msgstr "如果该分支存在于多个远程，并且其中一个是由`checkout.defaultRemote`配置变量命名的，为了消除歧义，我们将使用该变量，即使`<分支>`在所有远程中并不唯一。将其设置为例如 `checkout.defaultRemote=origin`，以便在`<分支>`不明确但存在于'origin'远程时，总是从那里签出远程分支。参见 linkgit:git-config[1] 中的 `checkout.defaultRemote`。"

#. type: Plain text
#: en/git-checkout.txt:203 en/git-switch.txt:111
#, placeholders:'`--guess`':'`--no-guess`', priority:240
msgid "`--guess` is the default behavior. Use `--no-guess` to disable it."
msgstr "`--guess`是默认行为。使用`--no-guess`来禁用它。"

#. type: Plain text
#: en/git-checkout.txt:206 en/git-switch.txt:114
#, placeholders:'checkout.guess', priority:240
msgid "The default behavior can be set via the `checkout.guess` configuration variable."
msgstr "默认行为可以通过`checkout.guess`配置变量设置。"

#. type: Plain text
#: en/git-checkout.txt:210
#, priority:240
msgid "Create the new branch's reflog; see linkgit:git-branch[1] for details."
msgstr "创建新分支的引用日志；详见 linkgit:git-branch[1]。"

#. type: Labeled list
#: en/git-checkout.txt:212 en/git-daemon.txt:156 en/git-switch.txt:87 en/git-worktree.txt:199
#, ignore-same, no-wrap, priority:240
msgid "--detach"
msgstr "--detach"

#. type: Plain text
#: en/git-checkout.txt:218
#, placeholders:'HEAD', priority:240
msgid "Rather than checking out a branch to work on it, check out a commit for inspection and discardable experiments. This is the default behavior of `git checkout <commit>` when `<commit>` is not a branch name. See the \"DETACHED HEAD\" section below for details."
msgstr "与其签出一个分支来工作，不如签出一个提交来进行检查和可放弃的实验。当`<提交>`不是一个分支名时， 这是`git checkout <提交>`的默认行为，。 详见下面的 \"游离状态（DETACHED HEAD）\"部分。"

#. type: Labeled list
#: en/git-checkout.txt:219 en/git-switch.txt:178
#, no-wrap, placeholders:'--orphan', priority:240
msgid "--orphan <new-branch>"
msgstr "--orphan <新分支>"

#. type: Plain text
#: en/git-checkout.txt:225
#, priority:240
msgid "Create a new unborn branch, named `<new-branch>`, started from `<start-point>` and switch to it. The first commit made on this new branch will have no parents and it will be the root of a new history totally disconnected from all the other branches and commits."
msgstr "从`<起点>` 开始，创建一个新的 “未出生” 分支，命名为 `<新分支>`，并切换到该分支。 在这个新分支上的第一次提交将没有父分支，它将是一个新的历史起点，与所有其他的分支和提交完全断开。"

#. type: Plain text
#: en/git-checkout.txt:230
#, priority:240
msgid "The index and the working tree are adjusted as if you had previously run `git checkout <start-point>`. This allows you to start a new history that records a set of paths similar to `<start-point>` by easily running `git commit -a` to make the root commit."
msgstr "索引和工作区的调整就像你之前运行 `git checkout <起点>` 一样。 这允许你轻松地通过运行 `git commit -a` 来启动一个新的历史，记录一组类似于 `<新起点>` 的路径，进行根提交。"

#. type: Plain text
#: en/git-checkout.txt:236
#, priority:240
msgid "This can be useful when you want to publish the tree from a commit without exposing its full history. You might want to do this to publish an open source branch of a project whose current tree is \"clean\", but whose full history contains proprietary or otherwise encumbered bits of code."
msgstr "当你想发布一个提交树而不暴露其完整的历史时，这就很有用。你可能想这样做来发布一个项目的开源分支，这个分支的当前树是 \"干净的\"，但其完整的历史包含了专有的或其他一些代码。"

#. type: Plain text
#: en/git-checkout.txt:243
#, priority:240
msgid "If you want to start a disconnected history that records a set of paths that is totally different from the one of `<start-point>`, then you should clear the index and the working tree right after creating the orphan branch by running `git rm -rf .` from the top level of the working tree. Afterwards you will be ready to prepare your new files, repopulating the working tree, by copying them from elsewhere, extracting a tarball, etc."
msgstr "如果你想启动一个断开的历史，记录一组完全不同于`<起点>`的路径，那么你应该在创建孤儿分支后立即清除索引和工作区，从工作区的顶层运行`git rm -rf .`。 之后你就可以准备你的新文件了，重新填充工作区，办法是从其他地方复制它们，提取一个包，等等。"

#. type: Plain text
#: en/git-checkout.txt:249
#, placeholders:'$GIT_DIR', priority:240
msgid "In sparse checkout mode, `git checkout -- <paths>` would update only entries matched by `<paths>` and sparse patterns in `$GIT_DIR/info/sparse-checkout`. This option ignores the sparse patterns and adds back any files in `<paths>`."
msgstr "在稀疏签出模式下，`git checkout -- <路径>`将只更新由`<路径>`和`$GIT_DIR/info/sparse-checkout`中的稀疏模式匹配的条目。这个选项忽略了稀疏模式，并添加回`<路径>`中的任何文件。"

#. type: Labeled list
#: en/git-checkout.txt:251 en/git-rebase.txt:364 en/git-rebase.txt:663 en/git-reset.txt:76 en/git-restore.txt:89 en/git-submodule.txt:376 en/git-svn.txt:676 en/git-switch.txt:127 en/rev-list-options.txt:343
#, ignore-same, no-wrap, priority:280
msgid "--merge"
msgstr "--merge"

#. type: Plain text
#: en/git-checkout.txt:260
#, priority:240
msgid "When switching branches, if you have local modifications to one or more files that are different between the current branch and the branch to which you are switching, the command refuses to switch branches in order to preserve your modifications in context. However, with this option, a three-way merge between the current branch, your working tree contents, and the new branch is done, and you will be on the new branch."
msgstr "在切换分支时，如果你对一个或多个文件的本地修改在当前分支和你要切换的分支之间是不同的，命令会拒绝切换分支，以保留你的修改内容。 然而，使用这个选项后，就会在当前分支、你的工作区内容和新的分支之间进行三方合并，之后，你会处于新分支。"

#. type: Plain text
#: en/git-checkout.txt:265 en/git-switch.txt:140
#, priority:240
msgid "When a merge conflict happens, the index entries for conflicting paths are left unmerged, and you need to resolve the conflicts and mark the resolved paths with `git add` (or `git rm` if the merge should result in deletion of the path)."
msgstr "当合并冲突发生时，冲突路径的索引条目会被留下，你需要解决冲突，并用`git add`标记已解决的路径（如果合并应导致删除路径，则用`git rm`）。"

#. type: Plain text
#: en/git-checkout.txt:269
#, priority:240
msgid "When checking out paths from the index, this option lets you recreate the conflicted merge in the specified paths. This option cannot be used when checking out paths from a tree-ish."
msgstr "从索引中检出路径时，该选项可让你在指定路径中重新创建冲突的合并。 该选项不能用于从目录树对象路径中检出路径。"

#. type: Plain text
#: en/git-checkout.txt:271
#, placeholders:'`--merge`', priority:240
msgid "When switching branches with `--merge`, staged changes may be lost."
msgstr "当用`--merge`切换分支时，可能会丢失阶段性修改。"

#. type: Labeled list
#: en/git-checkout.txt:272 en/git-restore.txt:95 en/git-switch.txt:141
#, no-wrap, placeholders:'--conflict=', priority:280
msgid "--conflict=<style>"
msgstr "--conflict=<样式>"

#. type: Plain text
#: en/git-checkout.txt:277 en/git-restore.txt:100 en/git-switch.txt:146
#, placeholders:'`--merge`':'merge.conflictStyle', priority:280
msgid "The same as `--merge` option above, but changes the way the conflicting hunks are presented, overriding the `merge.conflictStyle` configuration variable. Possible values are \"merge\" (default), \"diff3\", and \"zdiff3\"."
msgstr "与上面的 `--merge` 选项相同，但改变了冲突块的显示方式，覆盖 `merge.conflictStyle` 配置变量。可能的值是 \"merge\"（默认）和 \"diff3\"（除了 \"merge\" 样式显示的内容外，还显示原始内容）。"

#. type: Plain text
#: en/git-checkout.txt:284
#, priority:240
msgid "Interactively select hunks in the difference between the `<tree-ish>` (or the index, if unspecified) and the working tree. The chosen hunks are then applied in reverse to the working tree (and if a `<tree-ish>` was specified, the index)."
msgstr "在 `<树状对象>`（或索引，如果没有指定）和工作区之间的差异中，交互式地选择目标。 选择的目标会被反向应用到工作区上（如果指定了 `<树状对象>`，则是索引）。"

#. type: Plain text
#: en/git-checkout.txt:288
#, placeholders:'linkgit:git-add[1]':'`--patch`', priority:240
msgid "This means that you can use `git checkout -p` to selectively discard edits from your current working tree. See the ``Interactive Mode'' section of linkgit:git-add[1] to learn how to operate the `--patch` mode."
msgstr "这意味着你可以使用 `git checkout -p` 来有选择地丢弃当前工作区上的编辑内容。参见 linkgit:git-add[1] 的 \"互动模式''部分，了解`--patch`模式如何操作。"

#. type: Plain text
#: en/git-checkout.txt:291
#, placeholders:'`--overlay`', priority:240
msgid "Note that this option uses the no overlay mode by default (see also `--overlay`), and currently doesn't support overlay mode."
msgstr "注意，这个选项默认使用无覆盖模式（另见`--overlay`），目前不支持覆盖模式。"

#. type: Labeled list
#: en/git-checkout.txt:292 en/git-switch.txt:182
#, ignore-same, no-wrap, priority:240
msgid "--ignore-other-worktrees"
msgstr "--ignore-other-worktrees"

#. type: Plain text
#: en/git-checkout.txt:297
#, priority:240
msgid "`git checkout` refuses when the wanted ref is already checked out by another worktree. This option makes it check the ref out anyway. In other words, the ref can be held by more than one worktree."
msgstr "`git checkout`在想要的引用已经被另一个工作区签出时拒绝。这个选项让它无论如何都要签出这个引用。换句话说，这个引用可能被多个工作区持有。"

#. type: Labeled list
#: en/git-checkout.txt:298 en/git-merge.txt:96
#, ignore-same, no-wrap, priority:240
msgid "--overwrite-ignore"
msgstr "--overwrite-ignore"

#. type: Labeled list
#: en/git-checkout.txt:299 en/git-merge.txt:97
#, ignore-same, no-wrap, priority:240
msgid "--no-overwrite-ignore"
msgstr "--no-overwrite-ignore"

#. type: Plain text
#: en/git-checkout.txt:303
#, placeholders:'`--no-overwrite-ignore`', priority:240
msgid "Silently overwrite ignored files when switching branches. This is the default behavior. Use `--no-overwrite-ignore` to abort the operation when the new branch contains ignored files."
msgstr "在切换分支时静默地覆盖被忽略的文件。这是默认行为。使用 `--no-overwrite-ignore` 可以在新的分支包含被忽略的文件时中止操作。"

#. type: Plain text
#: en/git-checkout.txt:313
#, placeholders:'`--recurse-submodules`':'`-f`':'`--no-recurse-submodules`':'linkgit:git-submodule[1]':'HEAD', priority:240
msgid "Using `--recurse-submodules` will update the content of all active submodules according to the commit recorded in the superproject. If local modifications in a submodule would be overwritten the checkout will fail unless `-f` is used. If nothing (or `--no-recurse-submodules`) is used, submodules working trees will not be updated. Just like linkgit:git-submodule[1], this will detach `HEAD` of the submodule."
msgstr "使用`--recurse-submodules`将根据父项目的提交记录更新所有活动的子模块的内容。如果子模块中的本地修改会被覆盖，除非使用`-f`，则会签出将失败。如果什么都不使用（或`--no-recurse-submodules`），子模块的工作区将不会被更新。 就像linkgit:git-submodule[1]，这将分离子模块的`HEAD`。"

#. type: Labeled list
#: en/git-checkout.txt:314 en/git-restore.txt:125
#, ignore-same, no-wrap, priority:280
msgid "--overlay"
msgstr "--overlay"

#. type: Labeled list
#: en/git-checkout.txt:315 en/git-restore.txt:126
#, ignore-same, no-wrap, priority:280
msgid "--no-overlay"
msgstr "--no-overlay"

#. type: Plain text
#: en/git-checkout.txt:321
#, placeholders:'`--no-overlay`', priority:240
msgid "In the default overlay mode, `git checkout` never removes files from the index or the working tree. When specifying `--no-overlay`, files that appear in the index and working tree, but not in `<tree-ish>` are removed, to make them match `<tree-ish>` exactly."
msgstr "在默认的覆盖模式下，`git checkout`不会从索引或工作区中删除文件。 当指定`--no-overlay`时，出现在索引和工作区中，但不在`<树状对象>`中的文件会被删除，以使它们与`<树状对象>`完全匹配。"

#. type: Labeled list
#: en/git-checkout.txt:335 en/git-rebase.txt:282 en/git-switch.txt:36
#, no-wrap, priority:240
msgid "<branch>"
msgstr "<分支>"

#. type: Plain text
#: en/git-checkout.txt:341
#, placeholders:'HEAD', priority:240
msgid "Branch to checkout; if it refers to a branch (i.e., a name that, when prepended with \"refs/heads/\", is a valid ref), then that branch is checked out. Otherwise, if it refers to a valid commit, your `HEAD` becomes \"detached\" and you are no longer on any branch (see below for details)."
msgstr "签出的分支；如果它指的是一个分支（即一个名字，在前面加上 \"refs/heads/\"时，是一个有效的 引用），那么这个分支就被签出。否则，如果它指的是一个有效的提交，你的`HEAD`就会\"分离\"，此时，你就不再在任何一个分支上了（详见下文）。"

#. type: Plain text
#: en/git-checkout.txt:345
#, placeholders:'{-N}':'{-1}', priority:240
msgid "You can use the `@{-N}` syntax to refer to the N-th last branch/commit checked out using \"git checkout\" operation. You may also specify `-` which is synonymous to `@{-1}`."
msgstr "你可以使用`@{-N}`语法来指代使用 \"git checkout \"操作检查出来的第N个最后的分支或是提交。你也可以指定`-`，它与`@{-1}`同义。"

#. type: Plain text
#: en/git-checkout.txt:349 en/git-switch.txt:58
#, ignore-ellipsis, placeholders:'HEAD', priority:240
msgid "As a special case, you may use `A...B` as a shortcut for the merge base of `A` and `B` if there is exactly one merge base. You can leave out at most one of `A` and `B`, in which case it defaults to `HEAD`."
msgstr "作为一种特殊情况，如果正好有一个合并基础，你可以使用`A...B`作为`A`和`B`的合并基础的快捷方式。你最多可以省略在`A`和`B`中默认为`HEAD`的一个分支。"

#. type: Labeled list
#: en/git-checkout.txt:350 en/git-switch.txt:39
#, no-wrap, priority:240
msgid "<new-branch>"
msgstr "<新分支>"

#. type: Plain text
#: en/git-checkout.txt:352 en/git-switch.txt:41
#, priority:240
msgid "Name for the new branch."
msgstr "新分支的名称。"

#. type: Plain text
#: en/git-checkout.txt:356
#, placeholders:'HEAD', priority:240
msgid "The name of a commit at which to start the new branch; see linkgit:git-branch[1] for details. Defaults to `HEAD`."
msgstr "启动新分支的提交名称；详见 linkgit:git-branch[1]。默认为 `HEAD`。"

#. type: Plain text
#: en/git-checkout.txt:360 en/git-checkout.txt:368 en/git-restore.txt:47
#, ignore-ellipsis, placeholders:'HEAD', priority:280
msgid "As a special case, you may use `\"A...B\"` as a shortcut for the merge base of `A` and `B` if there is exactly one merge base. You can leave out at most one of `A` and `B`, in which case it defaults to `HEAD`."
msgstr "作为一种特殊情况，如果正好有一个合并基数，你可以使用`\"A...B \"作为`A`和`B`的合并基数的快捷方式。你最多可以漏掉`A`和`B`中的一个，在这种情况下，它默认为`HEAD`。"

#. type: Plain text
#: en/git-checkout.txt:364
#, priority:240
msgid "Tree to checkout from (when paths are given). If not specified, the index will be used."
msgstr "签出的树（当路径给定时）。如果没有指定，将使用索引。"

#. type: Plain text
#: en/git-checkout.txt:374 en/git-reset.txt:133 en/git-restore.txt:150
#, priority:280
msgid "Limits the paths affected by the operation."
msgstr "限制受操作影响的路径。"

#. type: Plain text
#: en/git-checkout.txt:376 en/git-commit.txt:408 en/git-reset.txt:135 en/git-restore.txt:152 en/git-rm.txt:47 en/git-stash.txt:259
#, placeholders:'linkgit:gitglossary[7]', priority:280
msgid "For more details, see the 'pathspec' entry in linkgit:gitglossary[7]."
msgstr "更多细节请参见 linkgit:gitglossary[7] 中的 '路径规范' 条目。"

#. type: Title -
#: en/git-checkout.txt:378
#, no-wrap, placeholders:'HEAD', priority:240
msgid "DETACHED HEAD"
msgstr "游离状态（DETACHED HEAD）"

#. type: Plain text
#: en/git-checkout.txt:382
#, placeholders:'HEAD', priority:240
msgid "`HEAD` normally refers to a named branch (e.g. `master`). Meanwhile, each branch refers to a specific commit. Let's look at a repo with three commits, one of them tagged, and with branch `master` checked out:"
msgstr "`HEAD`通常指的是一个分支的引用（例如`master`）。同时，每个分支指的是一个特定的提交。让我们看看一个有三个提交的仓库，其中一个被标记了，并且分支`master`被检出："

#. type: delimited block -
#: en/git-checkout.txt:391
#, no-wrap, placeholders:'HEAD':'a---b---c', priority:240
msgid ""
"           HEAD (refers to branch 'master')\n"
"            |\n"
"            v\n"
"a---b---c  branch 'master' (refers to commit 'c')\n"
"    ^\n"
"    |\n"
"  tag 'v2.0' (refers to commit 'b')\n"
msgstr ""
"           HEAD（'master'分支的引用）\n"
"            |\n"
"            v\n"
"a---b---c  branch 'master'（'c' 提交的引用）\n"
"    ^\n"
"    |\n"
"  tag 'v2.0' （'b' 提交的引用）\n"

#. type: Plain text
#: en/git-checkout.txt:398
#, placeholders:'HEAD', priority:240
msgid "When a commit is created in this state, the branch is updated to refer to the new commit. Specifically, 'git commit' creates a new commit `d`, whose parent is commit `c`, and then updates branch `master` to refer to new commit `d`. `HEAD` still refers to branch `master` and so indirectly now refers to commit `d`:"
msgstr "当在这种状态下创建一个提交时，分支会被更新以引用新的提交。具体来说，'git commit'创建了一个新的提交`d`，其父级是提交`c`，然后更新分支`master`以引用新的提交`d`。`HEAD'仍指向`master'，所以现在间接地指向提交`d`："

#. type: delimited block -
#: en/git-checkout.txt:401 en/git-checkout.txt:436 en/git-checkout.txt:453
#, no-wrap, priority:240
msgid "$ edit; git add; git commit\n"
msgstr "$ edit; git add; git commit\n"

#. type: delimited block -
#: en/git-checkout.txt:409
#, no-wrap, placeholders:'HEAD':'a---b---c---d', priority:240
msgid ""
"               HEAD (refers to branch 'master')\n"
"                |\n"
"                v\n"
"a---b---c---d  branch 'master' (refers to commit 'd')\n"
"    ^\n"
"    |\n"
"  tag 'v2.0' (refers to commit 'b')\n"
msgstr ""
"               HEAD （指向'master'分支）\n"
"                |\n"
"                v\n"
"a---b---c---d  分支'master' （指向提交'd'）\n"
"    ^\n"
"    |\n"
"  tag 'v2.0' (指向提交'b')\n"

#. type: Plain text
#: en/git-checkout.txt:415
#, priority:240
msgid "It is sometimes useful to be able to checkout a commit that is not at the tip of any named branch, or even to create a new commit that is not referenced by a named branch. Let's look at what happens when we checkout commit `b` (here we show two ways this may be done):"
msgstr "有时能够签出一个不在任何命名分支顶端的提交，甚至创建一个不被命名分支引用的新提交，是很有用的。让我们来看看当我们签出提交 `b`时会发生什么（这里我们展示了两种方法）："

#. type: delimited block -
#: en/git-checkout.txt:419
#, no-wrap, priority:240
msgid ""
"$ git checkout v2.0  # or\n"
"$ git checkout master^^\n"
msgstr ""
"$ git checkout v2.0  # 或\n"
"$ git checkout master^^\n"

#. type: delimited block -
#: en/git-checkout.txt:427
#, no-wrap, placeholders:'HEAD':'a---b---c---d', priority:240
msgid ""
"   HEAD (refers to commit 'b')\n"
"    |\n"
"    v\n"
"a---b---c---d  branch 'master' (refers to commit 'd')\n"
"    ^\n"
"    |\n"
"  tag 'v2.0' (refers to commit 'b')\n"
msgstr ""
"   HEAD （指向提交'b'）\n"
"    |\n"
"    v\n"
"a---b---c---d  分支'master'（指向提交'd'）\n"
"    ^\n"
"    |\n"
"  tag 'v2.0' (指向提交'b')\n"

#. type: Plain text
#: en/git-checkout.txt:433
#, placeholders:'HEAD':'HEAD':'HEAD', priority:240
msgid "Notice that regardless of which checkout command we use, `HEAD` now refers directly to commit `b`. This is known as being in detached `HEAD` state. It means simply that `HEAD` refers to a specific commit, as opposed to referring to a named branch. Let's see what happens when we create a commit:"
msgstr "请注意，无论我们使用哪条结账命令，`HEAD`现在都直接指向提交`b`。这就是所谓的分离的`HEAD'状态。 这意味着，`HEAD`指向一个特定的提交，而不是指向一个命名的分支。让我们看看创建提交时发生了什么："

#. type: delimited block -
#: en/git-checkout.txt:446
#, no-wrap, placeholders:'HEAD':'a---b---c---d', priority:240
msgid ""
"     HEAD (refers to commit 'e')\n"
"      |\n"
"      v\n"
"      e\n"
"     /\n"
"a---b---c---d  branch 'master' (refers to commit 'd')\n"
"    ^\n"
"    |\n"
"  tag 'v2.0' (refers to commit 'b')\n"
msgstr ""
"     HEAD （指向提交'e'）\n"
"      |\n"
"      v\n"
"      e\n"
"     /\n"
"a---b---c---d  branch 'master' （指向提交'd'）\n"
"    ^\n"
"    |\n"
"  tag 'v2.0' （指向提交'b'）\n"

#. type: Plain text
#: en/git-checkout.txt:450
#, placeholders:'HEAD', priority:240
msgid "There is now a new commit `e`, but it is referenced only by `HEAD`. We can of course add yet another commit in this state:"
msgstr "现在有一个新的提交`e`，但它只被`HEAD`所引用。当然，我们可以在这个状态下再增加一个提交："

#. type: delimited block -
#: en/git-checkout.txt:463
#, no-wrap, placeholders:'HEAD':'e---f':'a---b---c---d', priority:240
msgid ""
"\t HEAD (refers to commit 'f')\n"
"\t  |\n"
"\t  v\n"
"      e---f\n"
"     /\n"
"a---b---c---d  branch 'master' (refers to commit 'd')\n"
"    ^\n"
"    |\n"
"  tag 'v2.0' (refers to commit 'b')\n"
msgstr ""
"\t HEAD（指向提交'f'）。\n"
"\t  |\n"
"\t  v\n"
"      e---f\n"
"     /\n"
"a---b---c---d 分支\"master\"（指向提交'd'）。\n"
"    ^\n"
"    |\n"
"  tag 'v2.0'（指向提交'b'）。\n"

#. type: Plain text
#: en/git-checkout.txt:467
#, priority:240
msgid "In fact, we can perform all the normal Git operations. But, let's look at what happens when we then checkout `master`:"
msgstr "事实上，我们可以执行所有正常的 Git 操作。但是，让我们看看当我们签出`master`时会发生什么："

#. type: delimited block -
#: en/git-checkout.txt:470
#, no-wrap, priority:240
msgid "$ git checkout master\n"
msgstr "$ git checkout master\n"

#. type: delimited block -
#: en/git-checkout.txt:478
#, no-wrap, placeholders:'HEAD':'e---f':'a---b---c---d', priority:240
msgid ""
"               HEAD (refers to branch 'master')\n"
"      e---f     |\n"
"     /          v\n"
"a---b---c---d  branch 'master' (refers to commit 'd')\n"
"    ^\n"
"    |\n"
"  tag 'v2.0' (refers to commit 'b')\n"
msgstr ""
"               HEAD（指向分支 'master'）\n"
"      e---f     |\n"
"     /          v\n"
"a---b---c---d  branch 'master' （指向提交 'd'）\n"
"    ^\n"
"    |\n"
"  tag 'v2.0' (指向提交 'b')\n"

#. type: Plain text
#: en/git-checkout.txt:485
#, priority:240
msgid "It is important to realize that at this point nothing refers to commit `f`. Eventually commit `f` (and by extension commit `e`) will be deleted by the routine Git garbage collection process, unless we create a reference before that happens. If we have not yet moved away from commit `f`, any of these will create a reference to it:"
msgstr "重要的是要意识到，在这一点上，没有任何引用是指向提交`f`的。最终，提交 `f`（以及提交 `e`）会被 Git 的例行垃圾回收程序删除，除非我们在这之前创建一个引用。如果我们还没有离开提交 `f`，以下任何一个操作都会创建一个对它的引用："

#. type: delimited block -
#: en/git-checkout.txt:490
#, no-wrap, priority:240
msgid ""
"$ git checkout -b foo  # or \"git switch -c foo\"  <1>\n"
"$ git branch foo                                 <2>\n"
"$ git tag foo                                    <3>\n"
msgstr ""
"$ git checkout -b foo   <1>\n"
"$ git branch foo        <2>\n"
"$ git tag foo           <3>\n"

#. type: Plain text
#: en/git-checkout.txt:494
#, placeholders:'HEAD':'HEAD', priority:240
msgid "creates a new branch `foo`, which refers to commit `f`, and then updates `HEAD` to refer to branch `foo`. In other words, we'll no longer be in detached `HEAD` state after this command."
msgstr "创建一个新的分支`foo`，指向提交`f`，然后更新`HEAD`，指向分支`foo`。换句话说，这条命令之后，我们将不再处于分离的`HEAD`状态。"

#. type: Plain text
#: en/git-checkout.txt:496
#, placeholders:'HEAD', priority:240
msgid "similarly creates a new branch `foo`, which refers to commit `f`, but leaves `HEAD` detached."
msgstr "类似的，创建一个新的分支`foo`，它指向提交`f`，但将`HEAD`分离出来。"

#. type: Plain text
#: en/git-checkout.txt:498
#, placeholders:'HEAD', priority:240
msgid "creates a new tag `foo`, which refers to commit `f`, leaving `HEAD` detached."
msgstr "创建一个新的标签`foo`，指向提交`f`，让`HEAD`处于分离状态。"

#. type: Plain text
#: en/git-checkout.txt:503
#, placeholders:'HEAD', priority:240
msgid "If we have moved away from commit `f`, then we must first recover its object name (typically by using git reflog), and then we can create a reference to it. For example, to see the last two commits to which `HEAD` referred, we can use either of these commands:"
msgstr "如果我们已经离开了`f'的提交，那么我们必须首先恢复它的对象名称（通常使用git reflog），然后我们可以创建一个对它的引用。例如，要查看`HEAD`指向的最后两个提交，我们可以使用以下任一命令："

#. type: delimited block -
#: en/git-checkout.txt:507
#, no-wrap, placeholders:'HEAD':'HEAD', priority:240
msgid ""
"$ git reflog -2 HEAD # or\n"
"$ git log -g -2 HEAD\n"
msgstr ""
"$ git reflog -2 HEAD # 或\n"
"$ git log -g -2 HEAD\n"

#. type: Title -
#: en/git-checkout.txt:510
#, no-wrap, priority:240
msgid "ARGUMENT DISAMBIGUATION"
msgstr "参数消歧义"

#. type: Plain text
#: en/git-checkout.txt:520
#, priority:240
msgid "When there is only one argument given and it is not `--` (e.g. `git checkout abc`), and when the argument is both a valid `<tree-ish>` (e.g. a branch `abc` exists) and a valid `<pathspec>` (e.g. a file or a directory whose name is \"abc\" exists), Git would usually ask you to disambiguate. Because checking out a branch is so common an operation, however, `git checkout abc` takes \"abc\" as a `<tree-ish>` in such a situation. Use `git checkout -- <pathspec>` if you want to checkout these paths out of the index."
msgstr "当只有一个参数且不是`--`时（例如`git checkout abc`），当参数既是有效的`<树状对象>`（例如分支`abc`存在）又是有效的`<路径规范>`（例如文件或目录的名称为 \"abc \"存在），Git通常会要求你进行区分。 因为签出分支是很常见的操作，`git checkout abc`在这种情况下把 \"abc \"作为`<树状对象>`。 如果你想从索引中签出这些路径，请使用`git checkout --<路径规范>`。"

#. type: Title ===
#: en/git-checkout.txt:524
#, no-wrap, priority:240
msgid "1. Paths"
msgstr "1.路径"

#. type: Plain text
#: en/git-checkout.txt:529
#, priority:240
msgid "The following sequence checks out the `master` branch, reverts the `Makefile` to two revisions back, deletes `hello.c` by mistake, and gets it back from the index."
msgstr "下面的序列检查了 \"master \"分支，将 \"Makefile \"恢复到两个修订版，错误地删除了 \"hello.c\"，并从索引中取回它。"

#. type: delimited block -
#: en/git-checkout.txt:535
#, no-wrap, priority:240
msgid ""
"$ git checkout master             <1>\n"
"$ git checkout master~2 Makefile  <2>\n"
"$ rm -f hello.c\n"
"$ git checkout hello.c            <3>\n"
msgstr ""
"$ git checkout master             <1>\n"
"$ git checkout master~2 Makefile  <2>\n"
"$ rm -f hello.c\n"
"$ git checkout hello.c            <3>\n"

#. type: Plain text
#: en/git-checkout.txt:537
#, priority:240
msgid "switch branch"
msgstr "选择分支"

#. type: Plain text
#: en/git-checkout.txt:538 en/git-restore.txt:168
#, priority:280
msgid "take a file out of another commit"
msgstr "将一个文件从另一个提交中取出"

#. type: Plain text
#: en/git-checkout.txt:539
#, priority:240
msgid "restore `hello.c` from the index"
msgstr "从索引中恢复`hello.c`"

#. type: Plain text
#: en/git-checkout.txt:542
#, priority:240
msgid "If you want to check out _all_ C source files out of the index, you can say"
msgstr "如果你想从索引中检出_所有_的C源文件，你可以这样"

#. type: delimited block -
#: en/git-checkout.txt:545
#, no-wrap, priority:240
msgid "$ git checkout -- '*.c'\n"
msgstr "$ git checkout -- '*.c'\n"

#. type: Plain text
#: en/git-checkout.txt:551
#, priority:240
msgid "Note the quotes around `*.c`. The file `hello.c` will also be checked out, even though it is no longer in the working tree, because the file globbing is used to match entries in the index (not in the working tree by the shell)."
msgstr "注意 `*.c `周围的引号。 文件`hello.c`也将被检出，尽管它已经不在工作树中了，因为文件通配符被用来匹配索引中的条目（不是工作区中的shell）。"

#. type: Plain text
#: en/git-checkout.txt:555
#, priority:240
msgid "If you have an unfortunate branch that is named `hello.c`, this step would be confused as an instruction to switch to that branch. You should instead write:"
msgstr "如果不幸你有一个分支被命名为 \"hello.c\"，这一步会误认为切换到该分支的指令。 你应该这样写："

#. type: delimited block -
#: en/git-checkout.txt:558
#, no-wrap, priority:240
msgid "$ git checkout -- hello.c\n"
msgstr "$ git checkout -- hello.c\n"

#. type: Title ===
#: en/git-checkout.txt:560
#, no-wrap, priority:240
msgid "2. Merge"
msgstr "2. Merge"

#. type: Plain text
#: en/git-checkout.txt:564 en/git-switch.txt:208
#, priority:240
msgid "After working in the wrong branch, switching to the correct branch would be done using:"
msgstr "在错误的分支工作后，切换到正确的分支将使用："

#. type: delimited block -
#: en/git-checkout.txt:567
#, no-wrap, priority:240
msgid "$ git checkout mytopic\n"
msgstr "$ git checkout mytopic\n"

#. type: Plain text
#: en/git-checkout.txt:572
#, priority:240
msgid "However, your \"wrong\" branch and correct `mytopic` branch may differ in files that you have modified locally, in which case the above checkout would fail like this:"
msgstr "然而，你的 \"错误\"分支和正确的`mytopic`分支可能在你本地修改的文件中存在差异，在这种情况下，上述检出会失败，像这样："

#. type: delimited block -
#: en/git-checkout.txt:576
#, no-wrap, priority:240
msgid ""
"$ git checkout mytopic\n"
"error: You have local changes to 'frotz'; not switching branches.\n"
msgstr ""
"$ git checkout mytopic\n"
"错误：您对 'footz' 有本地更改；未切换分支。\n"

#. type: Plain text
#: en/git-checkout.txt:580 en/git-switch.txt:224
#, placeholders:'`-m`', priority:240
msgid "You can give the `-m` flag to the command, which would try a three-way merge:"
msgstr "你可以给命令加上 `-m`标志，这样就可以尝试三方合并了："

#. type: delimited block -
#: en/git-checkout.txt:584
#, no-wrap, priority:240
msgid ""
"$ git checkout -m mytopic\n"
"Auto-merging frotz\n"
msgstr ""
"$ git checkout -m mytopic\n"
"自动合并 frotz 分支\n"

#. type: Plain text
#: en/git-checkout.txt:589 en/git-switch.txt:233
#, priority:240
msgid "After this three-way merge, the local modifications are _not_ registered in your index file, so `git diff` would show you what changes you made since the tip of the new branch."
msgstr "在这个三方合并之后，本地的修改并「没有」登记在你的索引文件中，所以`git diff`会显示你在新分支的提示下做了哪些修改。"

#. type: Title ===
#: en/git-checkout.txt:590
#, no-wrap, priority:240
msgid "3. Merge conflict"
msgstr "3. Merge 冲突"

#. type: Plain text
#: en/git-checkout.txt:594
#, placeholders:'`-m`', priority:240
msgid "When a merge conflict happens during switching branches with the `-m` option, you would see something like this:"
msgstr "当使用`-m`选项切换分支时发生合并冲突，你会看到类似这样的情况："

#. type: delimited block -
#: en/git-checkout.txt:600
#, no-wrap, priority:240
msgid ""
"$ git checkout -m mytopic\n"
"Auto-merging frotz\n"
"ERROR: Merge conflict in frotz\n"
"fatal: merge program failed\n"
msgstr ""
"$ git checkout -m mytopic\n"
"自动合并 frotz 分支\n"
"错误：对 frotz 分支的合并冲突\n"
"失败：merge 程序终止\n"

#. type: Plain text
#: en/git-checkout.txt:606
#, priority:240
msgid "At this point, `git diff` shows the changes cleanly merged as in the previous example, as well as the changes in the conflicted files. Edit and resolve the conflict and mark it resolved with `git add` as usual:"
msgstr "在这一点上，`git diff`显示了与前面的例子一样干净地合并的修改，以及冲突文件中的修改。 编辑并解决冲突，让后像往常一样用`git add`标记已解决："

#. type: delimited block -
#: en/git-checkout.txt:610
#, no-wrap, priority:240
msgid ""
"$ edit frotz\n"
"$ git add frotz\n"
msgstr ""
"$ 编辑 frotz\n"
"$ git add frotz\n"

#. type: Plain text
#: en/git-checkout.txt:623
#, ignore-same, priority:240
msgid "linkgit:git-switch[1], linkgit:git-restore[1]"
msgstr "linkgit:git-switch[1], linkgit:git-restore[1]"

#. type: Title =
#: en/git-check-ref-format.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-check-ref-format(1)"
msgstr "git-check-ref-format(1)"

#. type: Plain text
#: en/git-check-ref-format.txt:7
#, placeholders:'git-check-ref-format', priority:100
msgid "git-check-ref-format - Ensures that a reference name is well formed"
msgstr "git-check-ref-format - 确保引用名称的格式正确"

#. type: Plain text
#: en/git-check-ref-format.txt:15
#, no-wrap, placeholders:'git check-ref-format':'[--normalize]':'[--refspec-pattern]':'git check-ref-format':'--branch', priority:100
msgid ""
"'git check-ref-format' [--normalize]\n"
"       [--[no-]allow-onelevel] [--refspec-pattern]\n"
"       <refname>\n"
"'git check-ref-format' --branch <branchname-shorthand>\n"
msgstr ""
"'git check-ref-format' [--normalize]\n"
"       [--[no-]allow-onelevel] [--refspec-pattern]\n"
"       <引用名>\n"
"'git check-ref-format' --branch <branchname-shorthand>\n"

#. type: Plain text
#: en/git-check-ref-format.txt:20
#, priority:100
msgid "Checks if a given 'refname' is acceptable, and exits with a non-zero status if it is not."
msgstr "检查给定的 ‘引用名’ 是否可接受，如果不可接受，则以非零状态退出。"

#. type: Plain text
#: en/git-check-ref-format.txt:27
#, placeholders:'$GIT_DIR':'$GIT_DIR':'$GIT_DIR', priority:100
msgid "A reference is used in Git to specify branches and tags. A branch head is stored in the `refs/heads` hierarchy, while a tag is stored in the `refs/tags` hierarchy of the ref namespace (typically in `$GIT_DIR/refs/heads` and `$GIT_DIR/refs/tags` directories or, as entries in file `$GIT_DIR/packed-refs` if refs are packed by `git gc`)."
msgstr "在 Git 中，引用被用来指定分支和标签。 分支头存储在 `refs/heads` 层次结构中，而标签存储在引用命名空间的 `refs/tags` 层次结构中（通常在 `$GIT_DIR/refs/heads` 和 `$GIT_DIR/refs/tags` 目录中，或者，如果引用是由 `git gc` 打包的，则作为文件 `$GIT_DIR/packed-refs` 的条目）。"

#. type: Plain text
#: en/git-check-ref-format.txt:29
#, priority:100
msgid "Git imposes the following rules on how references are named:"
msgstr "Git 对引用的命名方式有以下规则："

#. type: Plain text
#: en/git-check-ref-format.txt:33
#, priority:100
msgid "They can include slash `/` for hierarchical (directory) grouping, but no slash-separated component can begin with a dot `.` or end with the sequence `.lock`."
msgstr "它们可以包括斜线`/`，用于分层（目录）分组，但任何斜线分隔的组件都不能以点`.`开头或以序列`.lock`结尾。"

# ERROR: --allow-onelevel not found in translation
# ERROR: --allow-onelevel not found in translation
#. type: Plain text
#: en/git-check-ref-format.txt:38
#, placeholders:'`--allow-onelevel`', priority:100
msgid "They must contain at least one `/`. This enforces the presence of a category like `heads/`, `tags/` etc. but the actual names are not restricted. If the `--allow-onelevel` option is used, this rule is waived."
msgstr "它们必须至少包含一个 `/`。这就强制要求存在一个类别，如 `heads/`、`tags/` 等，但实际名称不受限制。 如果使用了 `--allow-onelevel`（允许一级）选项，这条规则将被放弃。"

#. type: Plain text
#: en/git-check-ref-format.txt:40
#, priority:100
msgid "They cannot have two consecutive dots `..` anywhere."
msgstr "他们不能在任何地方有两个连续的点 `..`。"

#. type: Plain text
#: en/git-check-ref-format.txt:44
#, priority:100
msgid "They cannot have ASCII control characters (i.e. bytes whose values are lower than \\040, or \\177 `DEL`), space, tilde `~`, caret `^`, or colon `:` anywhere."
msgstr "它们不能有 ASCII 控制字符（即数值低于 \\040，或 177 `DEL` 的字节）、空格、斜体字 `~`、省略号 `^`，或冒号 `:` 的任何一个。"

#. type: Plain text
#: en/git-check-ref-format.txt:48
#, placeholders:'`--refspec-pattern`', priority:100
msgid "They cannot have question-mark `?`, asterisk `*`, or open bracket `[` anywhere. See the `--refspec-pattern` option below for an exception to this rule."
msgstr "它们不能有问号 `?`，星号 `*`，或大括号 `[`的地方。 参见下面的 `--refspec-pattern` 选项，以了解这一规则的例外情况。"

#. type: Plain text
#: en/git-check-ref-format.txt:52
#, placeholders:'`--normalize`', priority:100
msgid "They cannot begin or end with a slash `/` or contain multiple consecutive slashes (see the `--normalize` option below for an exception to this rule)."
msgstr "它们不能以斜线 `/` 开头或结尾，也不能包含多个连续的斜线（参见下面的 `--normalize` 选项，该规则的一个例外）。"

#. type: Plain text
#: en/git-check-ref-format.txt:54
#, priority:100
msgid "They cannot end with a dot `.`."
msgstr "它们不能以点 `.` 结尾。"

#. type: Plain text
#: en/git-check-ref-format.txt:56
#, priority:100
msgid "They cannot contain a sequence `@{`."
msgstr "它们不能包含一个序列 `@{`。"

#. type: Plain text
#: en/git-check-ref-format.txt:58
#, priority:100
msgid "They cannot be the single character `@`."
msgstr "它们不能是单个字符 `@`。"

#. type: Plain text
#: en/git-check-ref-format.txt:60
#, priority:100
msgid "They cannot contain a `\\`."
msgstr "它们不能包含一个 `\\`。"

#. type: Plain text
#: en/git-check-ref-format.txt:65
#, placeholders:'linkgit:gitrevisions[7]', priority:100
msgid "These rules make it easy for shell script based tools to parse reference names, pathname expansion by the shell when a reference name is used unquoted (by mistake), and also avoid ambiguities in certain reference name expressions (see linkgit:gitrevisions[7]):"
msgstr "这些规则使基于 shell 脚本的工具很容易解析引用名，当引用名未加引号（错误地）使用时由 shell 进行路径名扩展，同时也避免了某些引用名表达的歧义（见 linkgit:gitrevisions[7]）："

#. type: Plain text
#: en/git-check-ref-format.txt:69
#, priority:100
msgid "A double-dot `..` is often used as in `ref1..ref2`, and in some contexts this notation means `^ref1 ref2` (i.e. not in `ref1` and in `ref2`)."
msgstr "双点 `..` 经常被用作 `ref1..ref2`，在某些情况下，这个符号意味着 `^ref1 ref2`（即不在 `ref1` 和 `ref2` 中）。"

#. type: Plain text
#: en/git-check-ref-format.txt:72
#, priority:100
msgid "A tilde `~` and caret `^` are used to introduce the postfix 'nth parent' and 'peel onion' operation."
msgstr "省略号 `~` 和 `^` 符号用于介绍后缀 ‘第 n 个父亲’ 和 ‘剥洋葱’ 操作。"

#. type: Plain text
#: en/git-check-ref-format.txt:77
#, placeholders:'git cat-file':'git cat-file', priority:100
msgid "A colon `:` is used as in `srcref:dstref` to mean \"use srcref\\'s value and store it in dstref\" in fetch and push operations. It may also be used to select a specific object such as with 'git cat-file': \"git cat-file blob v1.3.3:refs.c\"."
msgstr "冒号 `:` 在获取和推送操作中被用于 `srcref:dstref`，表示 `使用 srcref（源引用）的值并将其存储在 dstref（目标引用）中。 它也可以用来选择一个特定的对象，如 'git cat-file': \"git cat-file blob v1.3.3:refs.c\"。"

#. type: Plain text
#: en/git-check-ref-format.txt:79
#, priority:100
msgid "at-open-brace `@{` is used as a notation to access a reflog entry."
msgstr "`@{` 被用来作为访问一个引用日志条目的符号。"

#. type: Plain text
#: en/git-check-ref-format.txt:98
#, placeholders:'`--branch`':'HEAD':'git check-ref-format':'--branch':'git check-ref-format':'`--branch`':'{-n}':'{-1}', priority:100
msgid "With the `--branch` option, the command takes a name and checks if it can be used as a valid branch name (e.g. when creating a new branch). But be cautious when using the previous checkout syntax that may refer to a detached HEAD state. The rule `git check-ref-format --branch $name` implements may be stricter than what `git check-ref-format refs/heads/$name` says (e.g. a dash may appear at the beginning of a ref component, but it is explicitly forbidden at the beginning of a branch name). When run with the `--branch` option in a repository, the input is first expanded for the ``previous checkout syntax'' `@{-n}`. For example, `@{-1}` is a way to refer the last thing that was checked out using \"git switch\" or \"git checkout\" operation. This option should be used by porcelains to accept this syntax anywhere a branch name is expected, so they can act as if you typed the branch name. As an exception note that, the ``previous checkout operation'' might result in a commit object name when the N-th last thing checked out was not a branch."
msgstr "使用 `--branch` 选项，该命令接收一个名字，并检查它是否可以作为一个有效的分支名称（例如在创建新的分支时）。但在使用之前的检查语法时要谨慎，因为它可能指的是一个分离的 HEAD 状态。 `git check-ref-format --branch $name` 实现的规则可能比` git check-ref-format refs/heads/$name` 说的更严格（例如，破折号可以出现在引用组件的开头，但在分支名的开头是明确禁止的）。 当在仓库中使用 `--branch` 选项运行时，输入的内容首先被扩展为 ``以前的检出语法\" `@{-n}`。 例如，`@{-1}` 是指使用 \"git switch\" 或 \"git checkout\" 操作签出的最后一件东西。 这个选项应该被上层命令用来在任何需要分支名的地方接受这个语法，这样他们就可以像你输入分支名一样行事。作为一个例外，请注意，当最后签出的第 N 个东西不是一个分支时，\"以前的签出操作\" 可能会导致一个提交对象的名字。"

#. type: Labeled list
#: en/git-check-ref-format.txt:101
#, ignore-same, no-wrap, priority:100
msgid "--[no-]allow-onelevel"
msgstr "--[no-]allow-onelevel"

#. type: Plain text
#: en/git-check-ref-format.txt:105
#, placeholders:'`--no-allow-onelevel`', priority:100
msgid "Controls whether one-level refnames are accepted (i.e., refnames that do not contain multiple `/`-separated components). The default is `--no-allow-onelevel`."
msgstr "控制是否接受单级参考名称（即不包含多个 `/` 分隔的参考名称）。 默认值是 `--no-allow-onelevel`。"

#. type: Labeled list
#: en/git-check-ref-format.txt:106
#, ignore-same, no-wrap, priority:100
msgid "--refspec-pattern"
msgstr "--refspec-pattern"

#. type: Plain text
#: en/git-check-ref-format.txt:112
#, priority:100
msgid "Interpret <refname> as a reference name pattern for a refspec (as used with remote repositories). If this option is enabled, <refname> is allowed to contain a single `*` in the refspec (e.g., `foo/bar*/baz` or `foo/bar*baz/` but not `foo/bar*/baz*`)."
msgstr "将 <引用名> 解释为引用规范的参考名称模式（如用于远程仓库）。 如果这个选项被启用，<引用名> 允许在引用规范中包含一个 `*`（例如， `foo/bar*/baz` 或 `foo/bar*baz/`，但不允许 `foo/bar*/baz*`）。"

#. type: Labeled list
#: en/git-check-ref-format.txt:113
#, ignore-same, no-wrap, priority:100
msgid "--normalize"
msgstr "--normalize"

#. type: Plain text
#: en/git-check-ref-format.txt:120
#, placeholders:'`--print`':'`--normalize`', priority:100
msgid "Normalize 'refname' by removing any leading slash (`/`) characters and collapsing runs of adjacent slashes between name components into a single slash. If the normalized refname is valid then print it to standard output and exit with a status of 0, otherwise exit with a non-zero status. (`--print` is a deprecated way to spell `--normalize`.)"
msgstr "将 ‘引用名’ 规范化，去掉任何前导斜线（`/`）字符，并将名称成分之间的相邻斜线折叠成一个斜线。 如果规范化后的引用名有效，则将其打印到标准输出，并以 0 的状态退出，否则以非零状态退出。 (`--print` 是 `--normalize` 的一种废弃的拼写方式。)"

#. type: Plain text
#: en/git-check-ref-format.txt:126
#, priority:100
msgid "Print the name of the previous thing checked out:"
msgstr "打印前一个检出的东西的名称："

#. type: delimited block -
#: en/git-check-ref-format.txt:129
#, no-wrap, placeholders:'git check-ref-format':'--branch':'{-1}', priority:100
msgid "$ git check-ref-format --branch @{-1}\n"
msgstr "$ git check-ref-format --branch @{-1}\n"

#. type: Plain text
#: en/git-check-ref-format.txt:132
#, priority:100
msgid "Determine the reference name to use for a new branch:"
msgstr "确定新分支要使用的引用名称："

#. type: delimited block -
#: en/git-check-ref-format.txt:136
#, no-wrap, placeholders:'git check-ref-format':'--normalize', priority:100
msgid ""
"$ ref=$(git check-ref-format --normalize \"refs/heads/$newbranch\")||\n"
"{ echo \"we do not like '$newbranch' as a branch name.\" >&2 ; exit 1 ; }\n"
msgstr ""
"$ ref=$(git check-ref-format --normalize \"refs/heads/$newbranch\")||\n"
"{ echo \"我们不喜欢将 '$newbranch' 作为分支名称。\" >&2 ; exit 1 ; }\n"

#. type: Title =
#: en/git-cherry-pick.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-cherry-pick(1)"
msgstr "git-cherry-pick(1)"

#. type: Plain text
#: en/git-cherry-pick.txt:7
#, placeholders:'git-cherry-pick', priority:100
msgid "git-cherry-pick - Apply the changes introduced by some existing commits"
msgstr "git-cherry-pick - 应用某些现有提交引入的更改"

#. type: Plain text
#: en/git-cherry-pick.txt:14
#, ignore-ellipsis, no-wrap, placeholders:'git cherry-pick':'[--edit]':'[--ff]':'git cherry-pick':'--continue':'--skip':'--abort':'--quit', priority:100
msgid ""
"'git cherry-pick' [--edit] [-n] [-m <parent-number>] [-s] [-x] [--ff]\n"
"\t\t  [-S[<keyid>]] <commit>...\n"
"'git cherry-pick' (--continue | --skip | --abort | --quit)\n"
msgstr ""
"'git cherry-pick' [--edit] [-n] [-m parent-number] [-s] [-x] [--ff]\n"
"\t\t  [-S[<键 ID>]] <提交>...\n"
"'git cherry-pick' (--continue | --skip | --abort | --quit)\n"

#. type: Plain text
#: en/git-cherry-pick.txt:21
#, placeholders:'HEAD', priority:100
msgid "Given one or more existing commits, apply the change each one introduces, recording a new commit for each. This requires your working tree to be clean (no modifications from the HEAD commit)."
msgstr "给出一个或多个现有的提交，应用每个提交所带来的变化，为每个提交记录一个新的提交。 这需要您的工作区是干净的（没有对 HEAD 提交的修改）。"

#. type: Plain text
#: en/git-cherry-pick.txt:24
#, priority:100
msgid "When it is not obvious how to apply a change, the following happens:"
msgstr "当如何应用一个变化不明显时，会发生以下情况："

#. type: Plain text
#: en/git-cherry-pick.txt:27
#, placeholders:'HEAD', priority:100
msgid "The current branch and `HEAD` pointer stay at the last commit successfully made."
msgstr "当前的分支和 `HEAD` 指针保持在最后一次成功提交的位置。"

#. type: Plain text
#: en/git-cherry-pick.txt:29
#, placeholders:'CHERRY_PICK_HEAD', priority:100
msgid "The `CHERRY_PICK_HEAD` ref is set to point at the commit that introduced the change that is difficult to apply."
msgstr "`CHERRY_PICK_HEAD` 引用被设置为指向引入难以应用的修改的提交。"

#. type: Plain text
#: en/git-cherry-pick.txt:31
#, priority:100
msgid "Paths in which the change applied cleanly are updated both in the index file and in your working tree."
msgstr "在索引文件和你的工作区中，更改应用得很干净的路径都被更新。"

#. type: Plain text
#: en/git-cherry-pick.txt:36
#, placeholders:'linkgit:git-merge[1]', priority:100
msgid "For conflicting paths, the index file records up to three versions, as described in the \"TRUE MERGE\" section of linkgit:git-merge[1]. The working tree files will include a description of the conflict bracketed by the usual conflict markers `<<<<<<<` and `>>>>>>>`."
msgstr "对于冲突的路径，索引文件最多记录三个版本，如 linkgit:git-merge[1] 的 “正确的合并” 部分所述。 工作区文件将包括对冲突的描述，括号里是通常的冲突标记 `<<<<<<<` 和 `>>>>>>>`。"

#. type: Plain text
#: en/git-cherry-pick.txt:37
#, priority:100
msgid "No other modifications are made."
msgstr "不做其他修改。"

#. type: Plain text
#: en/git-cherry-pick.txt:40
#, placeholders:'linkgit:git-merge[1]', priority:100
msgid "See linkgit:git-merge[1] for some hints on resolving such conflicts."
msgstr "参见 linkgit:git-merge[1] 以了解一些解决此类冲突的提示。"

#. type: Labeled list
#: en/git-cherry-pick.txt:43 en/git-merge.txt:127 en/git-revert.txt:36 en/git-verify-commit.txt:27
#, ignore-ellipsis, no-wrap, priority:240
msgid "<commit>..."
msgstr "<提交>..."

#. type: Plain text
#: en/git-cherry-pick.txt:52
#, ignore-ellipsis, placeholders:'linkgit:gitrevisions[7]':'`--no-walk`':'linkgit:git-rev-list[1]', priority:100
msgid "Commits to cherry-pick. For a more complete list of ways to spell commits, see linkgit:gitrevisions[7]. Sets of commits can be passed but no traversal is done by default, as if the `--no-walk` option was specified, see linkgit:git-rev-list[1]. Note that specifying a range will feed all <commit>... arguments to a single revision walk (see a later example that uses 'maint master..next')."
msgstr "拣选（cherry-pick）的提交。 更完整的拼写提交的方法列表，见 linkgit:gitrevisions[7]。 可以传递提交集，但默认不做遍历，就像指定了 `--no-walk` 选项一样，见 linkgit:git-rev-list[1]。注意，指定一个范围会把所有 <提交>... 参数送入一个单一的修订版（见后面的例子，使用 'maint master...next'）。"

#. type: Plain text
#: en/git-cherry-pick.txt:57
#, placeholders:'git cherry-pick', priority:100
msgid "With this option, 'git cherry-pick' will let you edit the commit message prior to committing."
msgstr "有了这个选项，'git cherry-pick' 会让你在提交前编辑提交信息。"

#. type: Labeled list
#: en/git-cherry-pick.txt:58 en/git-commit.txt:232 en/git-revert.txt:70 en/git-tag.txt:187 en/merge-options.txt:38
#, no-wrap, placeholders:'--cleanup=', priority:280
msgid "--cleanup=<mode>"
msgstr "--cleanup=<模式>"

#. type: Plain text
#: en/git-cherry-pick.txt:64 en/git-revert.txt:76
#, placeholders:'linkgit:git-commit[1]':'MERGE_MSG', priority:100
msgid "This option determines how the commit message will be cleaned up before being passed on to the commit machinery. See linkgit:git-commit[1] for more details. In particular, if the '<mode>' is given a value of `scissors`, scissors will be appended to `MERGE_MSG` before being passed on in the case of a conflict."
msgstr "这个选项决定了提交信息在传递给提交机制之前将如何进行清理。更多细节见 linkgit:git-commit[1]。特别是，如果 '<模式>' 的值为 `scissors`，那么在发生冲突时，`scissors` 将被附加到 `MERGE_MSG` 上。"

#. type: Labeled list
#: en/git-cherry-pick.txt:65 en/git-clean.txt:63
#, ignore-same, no-wrap, priority:100
msgid "-x"
msgstr "-x"

#. type: Plain text
#: en/git-cherry-pick.txt:78
#, ignore-ellipsis, priority:100
msgid "When recording the commit, append a line that says \"(cherry picked from commit ...)\" to the original commit message in order to indicate which commit this change was cherry-picked from. This is done only for cherry picks without conflicts. Do not use this option if you are cherry-picking from your private branch because the information is useless to the recipient. If on the other hand you are cherry-picking between two publicly visible branches (e.g. backporting a fix to a maintenance branch for an older release from a development branch), adding this information can be useful."
msgstr "在记录提交时，在原始提交信息中添加一行 \"(cherry picked from commit ...)\"，以表明这个改动是从哪个提交中拣选的。 这只适用于没有冲突的拣选。 如果你是从自己的私有分支中偷梁换柱，请不要使用这个选项，因为这个信息对接收者来说是无用的。 另一方面，如果您是在两个公开可见的分支之间进行拣选（例如，从开发分支向维护分支回传一个旧版本的修正），添加这一信息会很有用。"

#. type: Plain text
#: en/git-cherry-pick.txt:83
#, placeholders:'`-x`':'`-r`':'`-x`', priority:100
msgid "It used to be that the command defaulted to do `-x` described above, and `-r` was to disable it. Now the default is not to do `-x` so this option is a no-op."
msgstr "过去，该命令默认为做上述的 `-x`，`-r` 是禁用它。 现在默认是不做 `-x` ，所以这个选项是一个无用的选项。"

#. type: Labeled list
#: en/git-cherry-pick.txt:84
#, no-wrap, priority:100
msgid "-m <parent-number>"
msgstr "-m <父提交数量>"

#. type: Labeled list
#: en/git-cherry-pick.txt:85
#, no-wrap, placeholders:'--mainline', priority:100
msgid "--mainline <parent-number>"
msgstr "--mainline <父提交数量>"

#. type: Plain text
#: en/git-cherry-pick.txt:91
#, priority:100
msgid "Usually you cannot cherry-pick a merge because you do not know which side of the merge should be considered the mainline. This option specifies the parent number (starting from 1) of the mainline and allows cherry-pick to replay the change relative to the specified parent."
msgstr "通常你不能对一个合并进行拣选，因为你不知道合并的哪一边应该被视为主线。 这个选项指定了主线的父号（从 1 开始），允许拣选相对于指定的父号重放修改。"

#. type: Labeled list
#: en/git-cherry-pick.txt:93 en/git-revert.txt:78 en/merge-options.txt:2
#, ignore-same, no-wrap, priority:240
msgid "--no-commit"
msgstr "--no-commit"

#. type: Plain text
#: en/git-cherry-pick.txt:101
#, placeholders:'HEAD', priority:100
msgid "Usually the command automatically creates a sequence of commits. This flag applies the changes necessary to cherry-pick each named commit to your working tree and the index, without making any commit. In addition, when this option is used, your index does not have to match the HEAD commit. The cherry-pick is done against the beginning state of your index."
msgstr "通常该命令会自动创建一连串的提交。 这个标志会对您的工作树和索引进行必要的修改，以摘取每个命名的提交，而不做任何提交。 此外，使用这个选项时，您的索引不需要与 HEAD 提交相匹配。 挑拣是针对你的索引的起始状态进行的。"

#. type: Plain text
#: en/git-cherry-pick.txt:104
#, priority:100
msgid "This is useful when cherry-picking more than one commits' effect to your index in a row."
msgstr "这在连续摘取多个提交的效果给你的索引时很有用。"

#. type: Plain text
#: en/git-cherry-pick.txt:109 en/git-revert.txt:104
#, placeholders:'linkgit:git-commit[1]', priority:100
msgid "Add a `Signed-off-by` trailer at the end of the commit message. See the signoff option in linkgit:git-commit[1] for more information."
msgstr "在提交信息的末尾添加一个 `Signed-off-by` 的尾注。 更多信息见 linkgit:git-commit[1] 中的 signoff 选项。"

#. type: Labeled list
#: en/git-cherry-pick.txt:119 en/merge-options.txt:46 en/merge-options.txt:61
#, ignore-same, no-wrap, priority:240
msgid "--ff"
msgstr "--ff"

#. type: Plain text
#: en/git-cherry-pick.txt:123
#, placeholders:'HEAD', priority:100
msgid "If the current HEAD is the same as the parent of the cherry-pick'ed commit, then a fast forward to this commit will be performed."
msgstr "如果当前的 HEAD 与拣选的提交的父本相同，那么将执行快速合并到这个提交。"

#. type: Plain text
#: en/git-cherry-pick.txt:136
#, placeholders:'--allow-empty`':'--ff':'`--keep-redundant-commits`', priority:100
msgid "By default, cherry-picking an empty commit will fail, indicating that an explicit invocation of `git commit --allow-empty` is required. This option overrides that behavior, allowing empty commits to be preserved automatically in a cherry-pick. Note that when \"--ff\" is in effect, empty commits that meet the \"fast-forward\" requirement will be kept even without this option. Note also, that use of this option only keeps commits that were initially empty (i.e. the commit recorded the same tree as its parent). Commits which are made empty due to a previous commit are dropped. To force the inclusion of those commits use `--keep-redundant-commits`."
msgstr "默认情况下，对空提交的偷取会失败，表明需要明确调用 `git commit --allow-empty`。这个选项覆盖了这一行为，允许在偷取时自动保留空的提交。注意，当 \"--ff\" 生效时，即使没有这个选项，符合 “快速合并” 要求的空提交也会被保留。 还要注意的是，使用这个选项只保留最初为空的提交（即提交与它的父级记录在同一目录苏上）。 由于之前的提交而导致的空的提交会被放弃。 如果要强制包含这些提交，请使用 `--keep-redundant-commits`。"

#. type: Labeled list
#: en/git-cherry-pick.txt:137 en/git-commit.txt:226 en/git-rebase.txt:355
#, ignore-same, no-wrap, priority:280
msgid "--allow-empty-message"
msgstr "--allow-empty-message"

#. type: Plain text
#: en/git-cherry-pick.txt:141
#, priority:100
msgid "By default, cherry-picking a commit with an empty message will fail. This option overrides that behavior, allowing commits with empty messages to be cherry picked."
msgstr "默认情况下，对空信息的提交进行拣选会失败。 这个选项覆盖了这一行为，允许对空信息的提交进行拣选。"

#. type: Labeled list
#: en/git-cherry-pick.txt:142
#, ignore-same, no-wrap, priority:100
msgid "--keep-redundant-commits"
msgstr "--keep-redundant-commits"

#. type: Plain text
#: en/git-cherry-pick.txt:148
#, placeholders:'`--allow-empty`', priority:100
msgid "If a commit being cherry picked duplicates a commit already in the current history, it will become empty. By default these redundant commits cause `cherry-pick` to stop so the user can examine the commit. This option overrides that behavior and creates an empty commit object. Implies `--allow-empty`."
msgstr "如果被摘取的提交与当前历史中已有的提交重复，它将变成空的。 默认情况下，这些多余的提交会导致 `cherry-pick` 停止，以便用户能够检查提交。这个选项覆盖了这一行为，并创建一个空的提交对象。暗含 `--allow-empty`。"

#. type: Labeled list
#: en/git-cherry-pick.txt:149 en/git-notes.txt:208 en/git-rebase.txt:376 en/git-revert.txt:105 en/git-svn.txt:678 en/merge-options.txt:144
#, no-wrap, placeholders:'--strategy=', priority:280
msgid "--strategy=<strategy>"
msgstr "--strategy=<策略>"

#. type: Plain text
#: en/git-cherry-pick.txt:153 en/git-revert.txt:109
#, placeholders:'linkgit:git-merge[1]', priority:100
msgid "Use the given merge strategy. Should only be used once. See the MERGE STRATEGIES section in linkgit:git-merge[1] for details."
msgstr "使用给定的合并策略。 应该只使用一次。 详见 linkgit:git-merge[1] 中的合并策略部分。"

#. type: Labeled list
#: en/git-cherry-pick.txt:154 en/git-revert.txt:110
#, no-wrap, priority:100
msgid "-X<option>"
msgstr "-X<选项>"

#. type: Labeled list
#: en/git-cherry-pick.txt:155 en/git-revert.txt:111 en/merge-options.txt:152
#, no-wrap, placeholders:'--strategy-option=', priority:240
msgid "--strategy-option=<option>"
msgstr "--strategy-option=<选项>"

#. type: Plain text
#: en/git-cherry-pick.txt:158 en/git-revert.txt:114
#, placeholders:'linkgit:git-merge[1]', priority:100
msgid "Pass the merge strategy-specific option through to the merge strategy. See linkgit:git-merge[1] for details."
msgstr "将合并策略特有的选项传递给合并策略。 详见 linkgit:git-merge[1]。"

#. type: Title -
#: en/git-cherry-pick.txt:162 en/git-revert.txt:127
#, no-wrap, priority:100
msgid "SEQUENCER SUBCOMMANDS"
msgstr "序列器子命令"

#. type: Labeled list
#: en/git-cherry-pick.txt:167
#, no-wrap, placeholders:'git cherry-pick', priority:100
msgid "`git cherry-pick master`"
msgstr "`git cherry-pick master`"

#. type: Plain text
#: en/git-cherry-pick.txt:171
#, priority:100
msgid "Apply the change introduced by the commit at the tip of the master branch and create a new commit with this change."
msgstr "应用主分支顶端的提交所引入的修改，并以这个修改创建一个新的提交。"

#. type: Labeled list
#: en/git-cherry-pick.txt:172
#, no-wrap, placeholders:'git cherry-pick', priority:100
msgid "`git cherry-pick ..master`"
msgstr "`git cherry-pick ..master`"

#. type: Labeled list
#: en/git-cherry-pick.txt:173
#, no-wrap, placeholders:'git cherry-pick':'HEAD', priority:100
msgid "`git cherry-pick ^HEAD master`"
msgstr "`git cherry-pick ^HEAD master`"

#. type: Plain text
#: en/git-cherry-pick.txt:177
#, placeholders:'HEAD', priority:100
msgid "Apply the changes introduced by all commits that are ancestors of master but not of HEAD to produce new commits."
msgstr "应用所有属于 master 但不属于 HEAD 的祖先的提交所带来的变化，产生新的提交。"

#. type: Labeled list
#: en/git-cherry-pick.txt:178
#, no-wrap, placeholders:'git cherry-pick', priority:100
msgid "`git cherry-pick maint next ^master`"
msgstr "`git cherry-pick maint next ^master`"

#. type: Labeled list
#: en/git-cherry-pick.txt:179
#, no-wrap, placeholders:'git cherry-pick', priority:100
msgid "`git cherry-pick maint master..next`"
msgstr "`git cherry-pick maint master..next`"

#. type: Plain text
#: en/git-cherry-pick.txt:186
#, priority:100
msgid "Apply the changes introduced by all commits that are ancestors of maint or next, but not master or any of its ancestors. Note that the latter does not mean `maint` and everything between `master` and `next`; specifically, `maint` will not be used if it is included in `master`."
msgstr "应用所有属于 maint 或 next 的祖先的提交所带来的变化，但不包括 master 或其任何祖先。 注意，后者不是指 `maint` 和 `master` 与 `next` 之间的一切；具体来说，如果 `maint` 包含在 `master` 中，则不会被使用。"

#. type: Labeled list
#: en/git-cherry-pick.txt:187
#, no-wrap, placeholders:'git cherry-pick', priority:100
msgid "`git cherry-pick master~4 master~2`"
msgstr "`git cherry-pick master~4 master~2`"

#. type: Plain text
#: en/git-cherry-pick.txt:192
#, priority:100
msgid "Apply the changes introduced by the fifth and third last commits pointed to by master and create 2 new commits with these changes."
msgstr "应用 master 指向的第五次和最后第三次提交所带来的变化，并根据这些变化创建两个新的提交。"

#. type: Labeled list
#: en/git-cherry-pick.txt:193
#, no-wrap, placeholders:'git cherry-pick', priority:100
msgid "`git cherry-pick -n master~1 next`"
msgstr "`git cherry-pick -n master~1 next`"

#. type: Plain text
#: en/git-cherry-pick.txt:199
#, priority:100
msgid "Apply to the working tree and the index the changes introduced by the second last commit pointed to by master and by the last commit pointed to by next, but do not create any commit with these changes."
msgstr "在工作区和索引中应用 master 指向的倒数第二个提交和 next 指向的最后一个提交所带来的变化，但不要用这些变化创建任何提交。"

#. type: Labeled list
#: en/git-cherry-pick.txt:200
#, no-wrap, placeholders:'git cherry-pick':'--ff', priority:100
msgid "`git cherry-pick --ff ..next`"
msgstr "`git cherry-pick --ff ..next`"

#. type: Plain text
#: en/git-cherry-pick.txt:207
#, placeholders:'HEAD':'HEAD':'HEAD', priority:100
msgid "If history is linear and HEAD is an ancestor of next, update the working tree and advance the HEAD pointer to match next. Otherwise, apply the changes introduced by those commits that are in next but not HEAD to the current branch, creating a new commit for each new change."
msgstr "如果历史是线性的，并且 HEAD 是 next 的祖先，则更新工作区并将 HEAD 指针向前推进以匹配 next。 否则，将那些在 next 但不在 HEAD 中的提交所带来的变化应用到当前分支，为每个新变化创建一个新的提交。"

#. type: Labeled list
#: en/git-cherry-pick.txt:208
#, no-wrap, placeholders:'git rev-list':'--reverse':'git cherry-pick':'--stdin`', priority:100
msgid "`git rev-list --reverse master -- README | git cherry-pick -n --stdin`"
msgstr "`git rev-list --reverse master -- README | git cherry-pick -n --stdin`"

#. type: Plain text
#: en/git-cherry-pick.txt:214
#, priority:100
msgid "Apply the changes introduced by all commits on the master branch that touched README to the working tree and index, so the result can be inspected and made into a single new commit if suitable."
msgstr "将主干分支上所有触及 README 的提交所带来的变化应用到工作区和索引中，这样就可以检查结果，并在合适的时候做成一个新的提交。"

#. type: Plain text
#: en/git-cherry-pick.txt:218
#, priority:100
msgid "The following sequence attempts to backport a patch, bails out because the code the patch applies to has changed too much, and then tries again, this time exercising more care about matching up context lines."
msgstr "下面的序列试图回传一个补丁，因为补丁所适用的代码变化太大，所以放弃了，然后再试一次，这次对上下文行的匹配更加谨慎。"

# ERROR: --abort not found in translation
#. type: delimited block -
#: en/git-cherry-pick.txt:224
#, no-wrap, placeholders:'git cherry-pick':'git cherry-pick':'--abort':'git cherry-pick', priority:100
msgid ""
"$ git cherry-pick topic^             <1>\n"
"$ git diff                           <2>\n"
"$ git cherry-pick --abort            <3>\n"
"$ git cherry-pick -Xpatience topic^  <4>\n"
msgstr ""
"$ git cherry-pick topic^             <1>\n"
"$ git diff                           <2>\n"
"$ git cherry-pick --abort            <3>\n"
"$ git cherry-pick -Xpatience topic^  <4>\n"

#. type: Plain text
#: en/git-cherry-pick.txt:229
#, priority:100
msgid "apply the change that would be shown by `git show topic^`. In this example, the patch does not apply cleanly, so information about the conflict is written to the index and working tree and no new commit results."
msgstr "应用将由 `git show topic^` 显示的变化。 在这个例子中，补丁没有干净地应用，所以冲突的信息被写入索引和工作树，没有新的提交结果。"

#. type: Plain text
#: en/git-cherry-pick.txt:230
#, priority:100
msgid "summarize changes to be reconciled"
msgstr "总结需要调节的变化"

#. type: Plain text
#: en/git-cherry-pick.txt:233
#, priority:100
msgid "cancel the cherry-pick. In other words, return to the pre-cherry-pick state, preserving any local modifications you had in the working tree."
msgstr "取消 cherry-pick。 换句话说，返回到 cherry-pick 前的状态，保留你在工作区上的任何本地修改。"

#. type: Plain text
#: en/git-cherry-pick.txt:236
#, priority:100
msgid "try to apply the change introduced by `topic^` again, spending extra time to avoid mistakes based on incorrectly matching context lines."
msgstr "尝试再次应用由 `topic^` 引入的修改，花费额外的时间来避免基于不正确匹配的上下文行的错误。"

#. type: Title =
#: en/git-cherry.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-cherry(1)"
msgstr "git-cherry(1)"

#. type: Plain text
#: en/git-cherry.txt:7
#, placeholders:'git-cherry', priority:100
msgid "git-cherry - Find commits yet to be applied to upstream"
msgstr "git-cherry - 查找尚未应用于上游的提交内容"

#. type: Plain text
#: en/git-cherry.txt:12
#, no-wrap, priority:100
msgid "'git cherry' [-v] [<upstream> [<head> [<limit>]]]\n"
msgstr "'git cherry' [-v] [<上游仓库> [<头> [<限制>]]]\n"

#. type: Plain text
#: en/git-cherry.txt:17
#, priority:100
msgid "Determine whether there are commits in `<head>..<upstream>` that are equivalent to those in the range `<limit>..<head>`."
msgstr "确定 `<head>...<upstream>` 中是否有与 `<limit>...<head>` 范围内的提交相等。"

#. type: Plain text
#: en/git-cherry.txt:22
#, placeholders:'git-cherry':'linkgit:git-cherry-pick[1]':'linkgit:git-am[1]':'linkgit:git-rebase[1]', priority:100
msgid "The equivalence test is based on the diff, after removing whitespace and line numbers. git-cherry therefore detects when commits have been \"copied\" by means of linkgit:git-cherry-pick[1], linkgit:git-am[1] or linkgit:git-rebase[1]."
msgstr "因此，git-cherry 通过 linkgit:git-cherry-pick[1]、linkgit:git-am[1] 或 linkgit:git-rebase[1] 来检测提交是否被 “复制” 了。"

#. type: Plain text
#: en/git-cherry.txt:26
#, priority:100
msgid "Outputs the SHA1 of every commit in `<limit>..<head>`, prefixed with `-` for commits that have an equivalent in <upstream>, and `+` for commits that do not."
msgstr "输出 `<limit>...<head>` 中每个提交的 SHA1，对于在 <upstream> 中有对应的提交，以 `-` 为前缀，对于没有对应的提交，以 `+` 为前缀。"

#. type: Plain text
#: en/git-cherry.txt:31
#, priority:100
msgid "Show the commit subjects next to the SHA1s."
msgstr "在 SHA1 旁边显示提交主题。"

#. type: Labeled list
#: en/git-cherry.txt:32 en/git-rebase.txt:277
#, no-wrap, priority:100
msgid "<upstream>"
msgstr "<上游仓库>"

#. type: Plain text
#: en/git-cherry.txt:35
#, placeholders:'HEAD', priority:100
msgid "Upstream branch to search for equivalent commits. Defaults to the upstream branch of HEAD."
msgstr "上游分支，用于搜索等同提交。默认为 HEAD 的上游分支。"

#. type: Labeled list
#: en/git-cherry.txt:36 en/git.txt:434
#, no-wrap, priority:100
msgid "<head>"
msgstr "<head>"

#. type: Plain text
#: en/git-cherry.txt:38
#, placeholders:'HEAD', priority:100
msgid "Working branch; defaults to HEAD."
msgstr "工作分支；默认为 HEAD。"

#. type: Plain text
#: en/git-cherry.txt:41
#, priority:100
msgid "Do not report commits up to (and including) limit."
msgstr "不报告达到（和包括）极限的提交。"

#. type: Title ~
#: en/git-cherry.txt:46
#, no-wrap, priority:100
msgid "Patch workflows"
msgstr "补丁工作流程"

#. type: Plain text
#: en/git-cherry.txt:52
#, placeholders:'git-cherry':'linkgit:gitworkflows[7]', priority:100
msgid "git-cherry is frequently used in patch-based workflows (see linkgit:gitworkflows[7]) to determine if a series of patches has been applied by the upstream maintainer. In such a workflow you might create and send a topic branch like this:"
msgstr "git-cherry 常用于基于补丁的工作流程（见 linkgit:gitworkflows[7]），以确定一系列补丁是否已被上游维护者应用。 在这样的工作流程中，你可能会创建并发送一个类似这样的主题分支："

#. type: delimited block -
#: en/git-cherry.txt:58
#, ignore-ellipsis, no-wrap, placeholders:'git format-patch':'git send-email', priority:100
msgid ""
"$ git checkout -b topic origin/master\n"
"# work and create some commits\n"
"$ git format-patch origin/master\n"
"$ git send-email ... 00*\n"
msgstr ""
"$ git checkout -b topic origin/master\n"
"# 工作，并创建一些提交\n"
"$ git format-patch origin/master\n"
"$ git send-email ... 00*\n"

#. type: Plain text
#: en/git-cherry.txt:62
#, priority:100
msgid "Later, you can see whether your changes have been applied by saying (still on `topic`):"
msgstr "后来，你可以通过说（仍然是在 `topic`上）看到你的修改是否被应用："

#. type: delimited block -
#: en/git-cherry.txt:66
#, no-wrap, priority:100
msgid ""
"$ git fetch  # update your notion of origin/master\n"
"$ git cherry -v\n"
msgstr ""
"$ git fetch  # 更新您的 origin/master\n"
"$ git cherry -v\n"

#. type: Title ~
#: en/git-cherry.txt:69
#, no-wrap, priority:100
msgid "Concrete example"
msgstr "具体实例"

#. type: Plain text
#: en/git-cherry.txt:73
#, priority:100
msgid "In a situation where topic consisted of three commits, and the maintainer applied two of them, the situation might look like:"
msgstr "如果话题由三个提交组成，而维护者应用了其中的两个提交，情况可能是这样的："

#. type: delimited block -
#: en/git-cherry.txt:86
#, ignore-ellipsis, no-wrap, placeholders:'--graph':'--oneline':'--decorate':'--boundary', priority:100
msgid ""
"$ git log --graph --oneline --decorate --boundary origin/master...topic\n"
"* 7654321 (origin/master) upstream tip commit\n"
"[... snip some other commits ...]\n"
"* cccc111 cherry-pick of C\n"
"* aaaa111 cherry-pick of A\n"
"[... snip a lot more that has happened ...]\n"
"| * cccc000 (topic) commit C\n"
"| * bbbb000 commit B\n"
"| * aaaa000 commit A\n"
"|/\n"
"o 1234567 branch point\n"
msgstr ""
"$ git log --graph --oneline --decorate --boundary origin/master...topic\n"
"* 7654321 (origin/master) upstream tip commit\n"
"[... 摘录其他一些提交 ...]\n"
"* cccc111 cherry-pick of C\n"
"* aaaa111 cherry-pick of A\n"
"[... 摘录更多发生的事情...]\n"
"| * cccc000 (topic) commit C\n"
"| * bbbb000 commit B\n"
"| * aaaa000 commit A\n"
"|/\n"
"o 1234567 branch point\n"

#. type: Plain text
#: en/git-cherry.txt:90
#, placeholders:'git-cherry', priority:100
msgid "In such cases, git-cherry shows a concise summary of what has yet to be applied:"
msgstr "在这种情况下，git-cherry 会显示一个简明的摘要，说明还有哪些地方需要应用："

#. type: delimited block -
#: en/git-cherry.txt:96
#, ignore-ellipsis, no-wrap, priority:100
msgid ""
"$ git cherry origin/master topic\n"
"- cccc000... commit C\n"
"+ bbbb000... commit B\n"
"- aaaa000... commit A\n"
msgstr ""
"$ git cherry origin/master topic\n"
"- cccc000... commit C\n"
"+ bbbb000... commit B\n"
"- aaaa000... commit A\n"

#. type: Plain text
#: en/git-cherry.txt:102
#, priority:100
msgid "Here, we see that the commits A and C (marked with `-`) can be dropped from your `topic` branch when you rebase it on top of `origin/master`, while the commit B (marked with `+`) still needs to be kept so that it will be sent to be applied to `origin/master`."
msgstr "在这里，我们看到，当你在 `origin/master` 之上重新建立分支时，可以从 `topic` 分支中删除 A 和 C（标有 `-`），而 B（标有 `+`）仍然需要保留，这样它就会被发送到 `origin/master `上应用。"

#. type: Title ~
#: en/git-cherry.txt:105
#, no-wrap, priority:100
msgid "Using a limit"
msgstr "使用一个限制"

#. type: Plain text
#: en/git-cherry.txt:110
#, priority:100
msgid "The optional <limit> is useful in cases where your topic is based on other work that is not in upstream. Expanding on the previous example, this might look like:"
msgstr "可选的 <限制> 在你的主题是基于其他不在上游的工作的情况下很有用。 在前面的例子基础上扩展，这可能看起来像："

#. type: delimited block -
#: en/git-cherry.txt:126
#, ignore-ellipsis, no-wrap, placeholders:'--graph':'--oneline':'--decorate':'--boundary', priority:100
msgid ""
"$ git log --graph --oneline --decorate --boundary origin/master...topic\n"
"* 7654321 (origin/master) upstream tip commit\n"
"[... snip some other commits ...]\n"
"* cccc111 cherry-pick of C\n"
"* aaaa111 cherry-pick of A\n"
"[... snip a lot more that has happened ...]\n"
"| * cccc000 (topic) commit C\n"
"| * bbbb000 commit B\n"
"| * aaaa000 commit A\n"
"| * 0000fff (base) unpublished stuff F\n"
"[... snip ...]\n"
"| * 0000aaa unpublished stuff A\n"
"|/\n"
"o 1234567 merge-base between upstream and topic\n"
msgstr ""
"$ git log --graph --oneline --decorate --boundary origin/master...topic\n"
"* 7654321 (origin/master) upstream tip commit\n"
"[... 摘录其他一些提交 ...]\n"
"* cccc111 cherry-pick of C\n"
"* aaaa111 cherry-pick of A\n"
"[... 摘录更多发生的事情 ...]\n"
"| * cccc000 (topic) commit C\n"
"| * bbbb000 commit B\n"
"| * aaaa000 commit A\n"
"| * 0000fff (base) unpublished stuff F\n"
"[... snip ...]\n"
"| * 0000aaa unpublished stuff A\n"
"|/\n"
"o 1234567 merge-base between upstream and topic\n"

#. type: Plain text
#: en/git-cherry.txt:130
#, priority:100
msgid "By specifying `base` as the limit, you can avoid listing commits between `base` and `topic`:"
msgstr "通过指定 `base` 作为限制，你可以避免列出 `base` 和 `topic` 之间的提交："

#. type: delimited block -
#: en/git-cherry.txt:136
#, ignore-ellipsis, no-wrap, priority:100
msgid ""
"$ git cherry origin/master topic base\n"
"- cccc000... commit C\n"
"+ bbbb000... commit B\n"
"- aaaa000... commit A\n"
msgstr ""
"$ git cherry origin/master topic base\n"
"- cccc000... commit C\n"
"+ bbbb000... commit B\n"
"- aaaa000... commit A\n"

#. type: Title =
#: en/git-citool.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-citool(1)"
msgstr "git-citool(1)"

#. type: Plain text
#: en/git-citool.txt:7
#, placeholders:'git-citool':'git-commit', priority:100
msgid "git-citool - Graphical alternative to git-commit"
msgstr "git-citool —— 替代 git-commit 的图形化工具"

#. type: Plain text
#: en/git-citool.txt:12
#, no-wrap, priority:100
msgid "'git citool'\n"
msgstr "'git citool'\n"

#. type: Plain text
#: en/git-citool.txt:19
#, priority:100
msgid "A Tcl/Tk based graphical interface to review modified files, stage them into the index, enter a commit message and record the new commit onto the current branch. This interface is an alternative to the less interactive 'git commit' program."
msgstr "一个基于 Tcl/Tk 的图形界面，用于查看修改过的文件，将其放入索引，输入提交信息，并将新的提交记录到当前分支。 这个界面是对互动性较差的 'git commit' 程序的一种替代。"

#. type: Plain text
#: en/git-citool.txt:22
#, placeholders:'linkgit:git-gui[1]', priority:100
msgid "'git citool' is actually a standard alias for `git gui citool`. See linkgit:git-gui[1] for more details."
msgstr "'git citool' 实际上是 'git gui citool' 的标准别名。 详见 linkgit:git-gui[1]。"

#. type: Title =
#: en/git-clean.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-clean(1)"
msgstr "git-clean(1)"

#. type: Plain text
#: en/git-clean.txt:7
#, placeholders:'git-clean', priority:100
msgid "git-clean - Remove untracked files from the working tree"
msgstr "git-clean - 删除工作目录树中未跟踪的文件"

#. type: Plain text
#: en/git-clean.txt:12
#, ignore-ellipsis, no-wrap, priority:100
msgid "'git clean' [-d] [-f] [-i] [-n] [-q] [-e <pattern>] [-x | -X] [--] [<pathspec>...]\n"
msgstr "'git clean' [-d] [-f] [-i] [-n] [-q] [-e <模式>] [-x | -X] [--] <路径规范>...\n"

#. type: Plain text
#: en/git-clean.txt:18
#, priority:100
msgid "Cleans the working tree by recursively removing files that are not under version control, starting from the current directory."
msgstr "从当前目录开始，通过递归删除不在版本控制之下的文件来清理工作区。"

#. type: Plain text
#: en/git-clean.txt:22
#, placeholders:'`-x`', priority:100
msgid "Normally, only files unknown to Git are removed, but if the `-x` option is specified, ignored files are also removed. This can, for example, be useful to remove all build products."
msgstr "通常情况下，只有 Git 未知的文件会被删除，但如果指定了 `-x` 选项，被忽略的文件也会被删除。例如，这对删除所有构建产品很有用。"

#. type: Plain text
#: en/git-clean.txt:25
#, ignore-ellipsis, priority:100
msgid "If any optional `<pathspec>...` arguments are given, only those paths that match the pathspec are affected."
msgstr "如果给出任何可选的`<路径规范>...`参数，只有那些与路径规范相匹配的路径会受到影响。"

#. type: Plain text
#: en/git-clean.txt:35
#, placeholders:'`--force`', priority:100
msgid "Normally, when no <pathspec> is specified, git clean will not recurse into untracked directories to avoid removing too much. Specify -d to have it recurse into such directories as well. If a <pathspec> is specified, -d is irrelevant; all untracked files matching the specified paths (with exceptions for nested git directories mentioned under `--force`) will be removed."
msgstr "通常，当没有指定 <路径规范> 时，git clean 不会递归到未追踪的目录，以避免删除太多。 指定 -d 可以让它也递归到这些目录。 如果指定了<路径规范>，-d 就不重要了；所有符合指定路径的未追踪文件（`--force` 下提到的嵌套的 git 目录除外）将被删除。"

#. type: Plain text
#: en/git-clean.txt:43
#, placeholders:'clean.requireForce', priority:100
msgid "If the Git configuration variable clean.requireForce is not set to false, 'git clean' will refuse to delete files or directories unless given -f or -i. Git will refuse to modify untracked nested git repositories (directories with a .git subdirectory) unless a second -f is given."
msgstr "如果 Git 配置变量 clean.requireForce 没有设置为 false，'git clean' 将拒绝删除文件或目录，除非给出 -f 或 -i。 除非给出第二个 -f，否则 Git 将拒绝修改未跟踪的嵌套 git 仓库（有.git子目录的目录）。"

#. type: Plain text
#: en/git-clean.txt:48
#, priority:100
msgid "Show what would be done and clean files interactively. See ``Interactive mode'' for details."
msgstr "显示会做什么，并以交互方式清理文件。详见 “交互模式”。"

#. type: Plain text
#: en/git-clean.txt:52
#, priority:100
msgid "Don't actually remove anything, just show what would be done."
msgstr "实际上不要删除任何东西，只是显示会做什么。"

#. type: Plain text
#: en/git-clean.txt:57
#, priority:100
msgid "Be quiet, only report errors, but not the files that are successfully removed."
msgstr "要安静，只报告错误，但不报告成功删除的文件。"

#. type: Labeled list
#: en/git-clean.txt:58
#, no-wrap, priority:100
msgid "-e <pattern>"
msgstr "-e <模式>"

#. type: Labeled list
#: en/git-clean.txt:59 en/git-for-each-ref.txt:103 en/git-ls-files.txt:111 en/git-name-rev.txt:33
#, no-wrap, placeholders:'--exclude=', priority:100
msgid "--exclude=<pattern>"
msgstr "--exclude=<模式>"

#. type: Plain text
#: en/git-clean.txt:62
#, placeholders:'linkgit:gitignore[5]', priority:100
msgid "Use the given exclude pattern in addition to the standard ignore rules (see linkgit:gitignore[5])."
msgstr "在标准的忽略规则之外，使用给定的排除模式（见 linkgit:gitignore[5]）。"

#. type: Plain text
#: en/git-clean.txt:70
#, placeholders:'linkgit:gitignore[5]':'`-e`', priority:100
msgid "Don't use the standard ignore rules (see linkgit:gitignore[5]), but still use the ignore rules given with `-e` options from the command line. This allows removing all untracked files, including build products. This can be used (possibly in conjunction with 'git restore' or 'git reset') to create a pristine working directory to test a clean build."
msgstr "不要使用标准的忽略规则（见linkgit:gitignore[5]），但仍然使用命令行中用 `-e` 选项给出的忽略规则。 这允许删除所有未跟踪的文件，包括构建产品。 这可以用来（可能与 'git restore' 或 'git reset' 一起使用）创建一个原始的工作目录来测试一个干净的构建。"

#. type: Labeled list
#: en/git-clean.txt:71
#, ignore-same, no-wrap, priority:100
msgid "-X"
msgstr "-X"

#. type: Plain text
#: en/git-clean.txt:74
#, priority:100
msgid "Remove only files ignored by Git. This may be useful to rebuild everything from scratch, but keep manually created files."
msgstr "只删除被 Git 忽略的文件。 这对于从头开始重建一切，但保留手动创建的文件可能很有用。"

#. type: Title -
#: en/git-clean.txt:76
#, no-wrap, priority:100
msgid "Interactive mode"
msgstr "交互模式"

#. type: Plain text
#: en/git-clean.txt:80
#, priority:100
msgid "When the command enters the interactive mode, it shows the files and directories to be cleaned, and goes into its interactive command loop."
msgstr "当命令进入交互式模式时，它会显示要清理的文件和目录，并进入其交互式命令循环。"

#. type: delimited block -
#: en/git-clean.txt:91
#, no-wrap, priority:100
msgid ""
"    *** Commands ***\n"
"\t1: clean                2: filter by pattern    3: select by numbers\n"
"\t4: ask each             5: quit                 6: help\n"
"    What now> 1\n"
msgstr ""
"    *** Commands ***\n"
"\t1: clean                2: filter by pattern    3: select by numbers\n"
"\t4: ask each             5: quit                 6: help\n"
"    What now> 1\n"

#. type: Plain text
#: en/git-clean.txt:94
#, priority:100
msgid "You also could say `c` or `clean` above as long as the choice is unique."
msgstr "你也可以在上面输入 `c` 或 `clean`，只要选择是唯一的。"

#. type: Plain text
#: en/git-clean.txt:96
#, priority:100
msgid "The main command loop has 6 subcommands."
msgstr "主命令循环有 6 个子命令。"

#. type: Labeled list
#: en/git-clean.txt:97
#, no-wrap, priority:100
msgid "clean"
msgstr "清理"

#. type: Plain text
#: en/git-clean.txt:100
#, priority:100
msgid "Start cleaning files and directories, and then quit."
msgstr "开始清理文件和目录，然后退出。"

#. type: Labeled list
#: en/git-clean.txt:101
#, no-wrap, priority:100
msgid "filter by pattern"
msgstr "按模式过滤"

#. type: Plain text
#: en/git-clean.txt:109
#, priority:100
msgid "This shows the files and directories to be deleted and issues an \"Input ignore patterns>>\" prompt. You can input space-separated patterns to exclude files and directories from deletion. E.g. \"*.c *.h\" will exclude files ending with \".c\" and \".h\" from deletion. When you are satisfied with the filtered result, press ENTER (empty) back to the main menu."
msgstr "这将显示要删除的文件和目录，并发出 \"Input ignore patterns>>（输入忽略模式）\" 提示。你可以输入以空格分隔的模式来排除文件和目录的删除。 例如，\"*.c *.h \" 将排除以 \".c \" 和 \".h\" 结尾的文件不被删除。当你对过滤后的结果满意时，按回车（空）键回到主菜单。"

#. type: Labeled list
#: en/git-clean.txt:110
#, no-wrap, priority:100
msgid "select by numbers"
msgstr "按数字选择"

#. type: Plain text
#: en/git-clean.txt:121
#, priority:100
msgid "This shows the files and directories to be deleted and issues an \"Select items to delete>>\" prompt. When the prompt ends with double '>>' like this, you can make more than one selection, concatenated with whitespace or comma. Also you can say ranges. E.g. \"2-5 7,9\" to choose 2,3,4,5,7,9 from the list. If the second number in a range is omitted, all remaining items are selected. E.g. \"7-\" to choose 7,8,9 from the list. You can say '*' to choose everything. Also when you are satisfied with the filtered result, press ENTER (empty) back to the main menu."
msgstr "这显示了要删除的文件和目录，并发出 \"Select items to delete>>（选择要删除的项目）\"提示。当提示像这样以双 '>>' 结束时，你可以做一个以上的选择，用空格或逗号连接起来。 你也可以说范围。 例如，\"2-5 7,9\" 可以从列表中选择 2,3,4,5,7,9。 如果一个范围内的第二个数字被省略了，所有剩下的项目都会被选中。 例如：\"7-\" 从列表中选择 7、8、9。 你可以输入 '*' 来选择所有项目。 另外，当你对过滤后的结果满意时，按回车（空）键回到主菜单。"

#. type: Labeled list
#: en/git-clean.txt:122
#, no-wrap, priority:100
msgid "ask each"
msgstr "逐一询问"

#. type: Plain text
#: en/git-clean.txt:127
#, priority:100
msgid "This will start to clean, and you must confirm one by one in order to delete items. Please note that this action is not as efficient as the above two actions."
msgstr "这将开始进行清理，你必须逐一确认，以便删除项目。请注意，这个动作没有上述两个动作那么有效。"

#. type: Labeled list
#: en/git-clean.txt:128
#, no-wrap, priority:100
msgid "quit"
msgstr "退出"

#. type: Plain text
#: en/git-clean.txt:131
#, priority:100
msgid "This lets you quit without doing any cleaning."
msgstr "这样，您就可以在不做任何清洁的情况下退出。"

#. type: Labeled list
#: en/git-clean.txt:132
#, no-wrap, priority:100
msgid "help"
msgstr "帮助"

#. type: Plain text
#: en/git-clean.txt:135
#, placeholders:'git-clean', priority:100
msgid "Show brief usage of interactive git-clean."
msgstr "显示交互式 git-clean 的简要用法。"

#. type: Title =
#: en/git-clone.txt:2
#, ignore-same, no-wrap, priority:300
msgid "git-clone(1)"
msgstr "git-clone(1)"

#. type: Plain text
#: en/git-clone.txt:7
#, placeholders:'git-clone', priority:300
msgid "git-clone - Clone a repository into a new directory"
msgstr "git-clone - 克隆一个仓库到新目录"

#. type: Plain text
#: en/git-clone.txt:21
#, no-wrap, placeholders:'[--template=':'[--no-hardlinks]':'[--bare]':'[--mirror]':'[--reference':'[--dissociate]':'[--depth':'[--no-tags]':'[--recurse-submodules':'[--jobs':'[--sparse]':'[--filter=':'[--also-filter-submodules]', priority:300
msgid ""
"'git clone' [--template=<template-directory>]\n"
"\t  [-l] [-s] [--no-hardlinks] [-q] [-n] [--bare] [--mirror]\n"
"\t  [-o <name>] [-b <name>] [-u <upload-pack>] [--reference <repository>]\n"
"\t  [--dissociate] [--separate-git-dir <git-dir>]\n"
"\t  [--depth <depth>] [--[no-]single-branch] [--no-tags]\n"
"\t  [--recurse-submodules[=<pathspec>]] [--[no-]shallow-submodules]\n"
"\t  [--[no-]remote-submodules] [--jobs <n>] [--sparse] [--[no-]reject-shallow]\n"
"\t  [--filter=<filter> [--also-filter-submodules]] [--] <repository>\n"
"\t  [<directory>]\n"
msgstr ""
"'git clone' [--template=<模板目录>]\n"
"\t  [-l] [-s] [--no-hardlinks] [-q] [-n] [--bare] [--mirror]\n"
"\t  [-o <名称>] [-b <名称>] [-u <上传包>] [--reference <仓库>]\n"
"\t  [--dissociate] [--separate-git-dir <Git 目录>]\n"
"\t  [--depth <深度>] [--[no-]single-branch] [--no-tags]\n"
"\t  [--recurse-submodules[=<路径规范>]] [--[no-]shallow-submodules]\n"
"\t  [--[no-]remote-submodules] [--jobs <n>] [--sparse] [--[no-]reject-shallow]\n"
"\t  [--filter=<过滤器> [--also-filter-submodules]] [--] <仓库>\n"
"\t  [<目录>]\n"

#. type: Plain text
#: en/git-clone.txt:30
#, placeholders:'--remotes`', priority:300
msgid "Clones a repository into a newly created directory, creates remote-tracking branches for each branch in the cloned repository (visible using `git branch --remotes`), and creates and checks out an initial branch that is forked from the cloned repository's currently active branch."
msgstr "将仓库克隆到新创建的目录中，为克隆仓库中的每个分支创建远程跟踪分支（使用 `git branch --remotes` 可见），并创建、签出从克隆仓库当前活动的分支派生的初始分支。"

#. type: Plain text
#: en/git-clone.txt:36
#, placeholders:'--single-branch', priority:300
msgid "After the clone, a plain `git fetch` without arguments will update all the remote-tracking branches, and a `git pull` without arguments will in addition merge the remote master branch into the current master branch, if any (this is untrue when \"--single-branch\" is given; see below)."
msgstr "克隆后，执行不带参数的 `git fetch` 命令将更新所有远程跟踪的分支，执行不带参数的 `git pull` 命令将另把远程 master 分支合并到当前 master 分支（如果存在）（如果附加 \"--single-branch\" 参数，则情况不同；请参阅下文）。"

#. type: Plain text
#: en/git-clone.txt:41
#, placeholders:'remote.origin.url':'remote.origin.fetch', priority:300
msgid "This default configuration is achieved by creating references to the remote branch heads under `refs/remotes/origin` and by initializing `remote.origin.url` and `remote.origin.fetch` configuration variables."
msgstr "通过在 `refs/remotes/origin` 下创建对远程分支头的引用，并通过初始化 `remote.origin.url` 和 `remote.origin.fetch` 配置变量来创建此默认配置。"

#. type: Labeled list
#: en/git-clone.txt:46 en/git-config.txt:134 en/git-instaweb.txt:24 en/git-pack-objects.txt:180 en/git-svn.txt:245
#, ignore-same, no-wrap, priority:300
msgid "--local"
msgstr "--local"

#. type: Plain text
#: en/git-clone.txt:53
#, placeholders:'HEAD', priority:300
msgid "When the repository to clone from is on a local machine, this flag bypasses the normal \"Git aware\" transport mechanism and clones the repository by making a copy of HEAD and everything under objects and refs directories. The files under `.git/objects/` directory are hardlinked to save space when possible."
msgstr "当要从中进行克隆的仓库位于本地计算机上时，此标志会绕过常规的 “Git感知” 传输机制，并通过为 HEAD 以及对象和引用目录内的所有内容创建副本以克隆仓库。尽可能将 `.git / objects /` 目录下的文件进行硬链接以节省空间。"

#. type: Plain text
#: en/git-clone.txt:60
#, placeholders:'--local':'`--no-local`', priority:300
msgid "If the repository is specified as a local path (e.g., `/path/to/repo`), this is the default, and --local is essentially a no-op. If the repository is specified as a URL, then this flag is ignored (and we never use the local optimizations). Specifying `--no-local` will override the default when `/path/to/repo` is given, using the regular Git transport instead."
msgstr "如果将存储库指定为本地路径（例如，`/path/to/repo`），--local 参数实质上是不起作用的。如果将仓库指定为 URL，则忽略此标志（不使用本地优化）。指定 `--no-local` 将在给定 `/path/to/repo` 时覆盖默认值，而使用常规 Git 传输方式。"

#. type: Plain text
#: en/git-clone.txt:65
#, placeholders:'$GIT_DIR', priority:300
msgid "If the repository's `$GIT_DIR/objects` has symbolic links or is a symbolic link, the clone will fail. This is a security measure to prevent the unintentional copying of files by dereferencing the symbolic links."
msgstr "如果仓库的 `$GIT_DIR/objects` 有符号链接或者它就是符号链接，克隆将会失败。这是一项安全措施，以防止通过解读符号链接意外地复制文件。"

#. type: Plain text
#: en/git-clone.txt:69
#, priority:300
msgid "*NOTE*: this operation can race with concurrent modification to the source repository, similar to running `cp -r src dst` while modifying `src`."
msgstr "*注意*：此操作可能会与源仓库的并发修改发生冲突，类似于在修改 `src` 时运行 `cp -r src dst` 。"

#. type: Labeled list
#: en/git-clone.txt:70
#, ignore-same, no-wrap, priority:300
msgid "--no-hardlinks"
msgstr "--no-hardlinks"

#. type: Plain text
#: en/git-clone.txt:75
#, priority:300
msgid "Force the cloning process from a repository on a local filesystem to copy the files under the `.git/objects` directory instead of using hardlinks. This may be desirable if you are trying to make a back-up of your repository."
msgstr "从本地文件系统上的仓库进行克隆时，强制复制 `.git / objects` 目录下的文件，而不使用硬链接。如果您要备份仓库，则可能需要这样做。"

#. type: Labeled list
#: en/git-clone.txt:77
#, ignore-same, no-wrap, priority:300
msgid "--shared"
msgstr "--shared"

#. type: Plain text
#: en/git-clone.txt:83
#, priority:300
msgid "When the repository to clone is on the local machine, instead of using hard links, automatically setup `.git/objects/info/alternates` to share the objects with the source repository. The resulting repository starts out without any object of its own."
msgstr "当要克隆的仓库位于本地计算机上时，不使用硬链接，而是自动设置 `.git/objects/info/alternates` 与源仓库共享对象。生成的仓库开始时没有其自己的任何对象。"

#. type: Plain text
#: en/git-clone.txt:93
#, placeholders:'--auto`':'linkgit:git-maintenance[1]', priority:300
msgid "*NOTE*: this is a possibly dangerous operation; do *not* use it unless you understand what it does. If you clone your repository using this option and then delete branches (or use any other Git command that makes any existing commit unreferenced) in the source repository, some objects may become unreferenced (or dangling). These objects may be removed by normal Git operations (such as `git commit`) which automatically call `git maintenance run --auto`. (See linkgit:git-maintenance[1].) If these objects are removed and were referenced by the cloned repository, then the cloned repository will become corrupt."
msgstr "*注意*：这可能是一个危险的操作；除非你了解它的作用，否则*不要*使用它。如果使用该选项克隆源仓库，然后删除源仓库中的分支（或使用任何其他 Git 命令使现有提交不再被引用），一些对象可能会变得不再被引用（或悬空）。这些对象可能会被自动调用 `git maintenance run --auto` 的正常 Git 操作（如 `git commit`）移除。(参见 linkgit:git-maintenance[1]）如果这些对象被移除，并被克隆的版本库引用，那么克隆的版本库就会损坏。"

#. type: Plain text
#: en/git-clone.txt:99
#, placeholders:'`--local`':'`--shared`':'--shared`':'`--local`', priority:300
msgid "Note that running `git repack` without the `--local` option in a repository cloned with `--shared` will copy objects from the source repository into a pack in the cloned repository, removing the disk space savings of `clone --shared`. It is safe, however, to run `git gc`, which uses the `--local` option by default."
msgstr "请注意，在使用 `--shared` 选项克隆的仓库中运行不带 `--local` 选项的 `git repack` 命令会将源仓库中的对象复制到克隆存储库中的包中，从而消除使用 `clone --shared` 节省的磁盘空间。不过，运行 `git-gc` 是安全的，它默认使用 `--local` 选项。"

#. type: Plain text
#: en/git-clone.txt:103
#, placeholders:'`--shared`', priority:300
msgid "If you want to break the dependency of a repository cloned with `--shared` on its source repository, you can simply run `git repack -a` to copy all objects from the source repository into a pack in the cloned repository."
msgstr "如果要断开用 `--shared` 克隆的仓库对其源仓库的依赖关系，只需运行 `git repack -a` 即可将源仓库中的所有对象复制到克隆仓库中的一个包中。"

#. type: Labeled list
#: en/git-clone.txt:104
#, no-wrap, placeholders:'--reference', priority:300
msgid "--reference[-if-able] <repository>"
msgstr "--reference[-if-able] <仓库>"

#. type: Plain text
#: en/git-clone.txt:114
#, placeholders:'`--reference-if-able`', priority:300
msgid "If the reference repository is on the local machine, automatically setup `.git/objects/info/alternates` to obtain objects from the reference repository. Using an already existing repository as an alternate will require fewer objects to be copied from the repository being cloned, reducing network and local storage costs. When using the `--reference-if-able`, a non existing directory is skipped with a warning instead of aborting the clone."
msgstr "如果引用仓库位于本地计算机上，则自动设置 `.git / objects / info / alternates` 以从引用仓库重获取对象。使用现有的仓库作为备用仓库，则将需要从要克隆的仓库中复制较少的对象，从而降低了网络和本地存储成本。当使用 `--reference-if-able` 时，不存在的目录会被警告跳过，而不是中止克隆。"

#. type: Plain text
#: en/git-clone.txt:117
#, placeholders:'`--shared`':'`--dissociate`', priority:300
msgid "*NOTE*: see the NOTE for the `--shared` option, and also the `--dissociate` option."
msgstr "*注意*：请参阅 `--shared` 选项的注释，以及 `--dissociate` 选项。"

#. type: Labeled list
#: en/git-clone.txt:118 en/git-submodule.txt:414
#, ignore-same, no-wrap, priority:300
msgid "--dissociate"
msgstr "--dissociate"

#. type: Plain text
#: en/git-clone.txt:128
#, placeholders:'`--reference`', priority:300
msgid "Borrow the objects from reference repositories specified with the `--reference` options only to reduce network transfer, and stop borrowing from them after a clone is made by making necessary local copies of borrowed objects. This option can also be used when cloning locally from a repository that already borrows objects from another repository--the new repository will borrow objects from the same repository, and this option can be used to stop the borrowing."
msgstr "从用 `--reference` 选项指定的引用仓库中借用对象仅是为了减少网络传输，并在克隆后通过制作借用对象的必要本地副本来停止从对象借用。当从已经从另一个仓库借用对象的存储库进行本地克隆时，也可以使用此选项：新仓库将从同一个仓库借用对象，并且该选项可用于停止借用。"

#. type: Plain text
#: en/git-clone.txt:133
#, priority:300
msgid "Operate quietly. Progress is not reported to the standard error stream."
msgstr "静默操作。进度不会报告给标准错误流。"

#. type: Plain text
#: en/git-clone.txt:138
#, priority:300
msgid "Run verbosely. Does not affect the reporting of progress status to the standard error stream."
msgstr "冗余运行。不影响向标准错误流报告进度状态。"

#. type: Plain text
#: en/git-clone.txt:144
#, placeholders:'`--quiet`', priority:300
msgid "Progress status is reported on the standard error stream by default when it is attached to a terminal, unless `--quiet` is specified. This flag forces progress status even if the standard error stream is not directed to a terminal."
msgstr "默认情况下，附加到终端时，会将进度状态报告给标准错误流，除非指定了 `--quiet` 选项。即使标准错误流未定向到终端，该标志也会强制显示进度状态。"

#. type: Plain text
#: en/git-clone.txt:156
#, placeholders:'HEAD', priority:300
msgid "No checkout of HEAD is performed after the clone is complete."
msgstr "克隆完成后，不执行 HEAD 检出操作。"

#. type: Labeled list
#: en/git-clone.txt:157
#, ignore-same, no-wrap, priority:300
msgid "--[no-]reject-shallow"
msgstr "--[no-]reject-shallow"

#. type: Plain text
#: en/git-clone.txt:161
#, placeholders:'clone.rejectShallow', priority:300
msgid "Fail if the source repository is a shallow repository. The 'clone.rejectShallow' configuration variable can be used to specify the default."
msgstr "如果源仓库是一个浅层仓库，则失败。 'clone.rejectShallow' 配置变量可以用来指定默认值。"

#. type: Labeled list
#: en/git-clone.txt:162 en/git-init.txt:49 en/git-p4.txt:305 en/git.txt:171
#, ignore-same, no-wrap, priority:300
msgid "--bare"
msgstr "--bare"

#. type: Plain text
#: en/git-clone.txt:173
#, placeholders:'$GIT_DIR':'`--no-checkout`', priority:300
msgid "Make a 'bare' Git repository. That is, instead of creating `<directory>` and placing the administrative files in `<directory>/.git`, make the `<directory>` itself the `$GIT_DIR`. This obviously implies the `--no-checkout` because there is nowhere to check out the working tree. Also the branch heads at the remote are copied directly to corresponding local branch heads, without mapping them to `refs/remotes/origin/`. When this option is used, neither remote-tracking branches nor the related configuration variables are created."
msgstr "创建一个 ‘裸’ Git 仓库。也就是说，不要创建 `<目录>` 并将管理文件放在 `<目录>/.git`，而是将 `<目录>` 本身设为 `$GIT_DIR`。这显然暗含着 `--no-checkout` 选项，因为没有地方可以检出工作目录树。此外，远程的分支头直接复制到相应的本地分支头，而不将它们映射到 `refs/remotes/origin/`。使用此选项时，不会创建远程跟踪分支或相关配置变量。"

# ERROR: linkgit:git-sparse-checkout[1] not found in translation
#. type: Plain text
#: en/git-clone.txt:179
#, placeholders:'linkgit:git-sparse-checkout[1]', priority:300
msgid "Employ a sparse-checkout, with only files in the toplevel directory initially being present. The linkgit:git-sparse-checkout[1] command can be used to grow the working directory as needed."
msgstr "使用稀疏检出（sparse-checkout），最初只检出顶层目录中的文件。 linkgit:git-sparse-checkout[1] 命令可根据需要扩大工作目录。"

#. type: Labeled list
#: en/git-clone.txt:180 en/git-pack-objects.txt:298 en/git-repack.txt:157 en/rev-list-options.txt:943
#, no-wrap, placeholders:'--filter=', priority:300
msgid "--filter=<filter-spec>"
msgstr "--filter=<过滤器定义>"

#. type: Plain text
#: en/git-clone.txt:189
#, placeholders:'`--filter`':'`--filter=blob':'`--filter=blob':'`--filter`':'linkgit:git-rev-list[1]', priority:300
msgid "Use the partial clone feature and request that the server sends a subset of reachable objects according to a given object filter. When using `--filter`, the supplied `<filter-spec>` is used for the partial clone filter. For example, `--filter=blob:none` will filter out all blobs (file contents) until needed by Git. Also, `--filter=blob:limit=<size>` will filter out all blobs of size at least `<size>`. For more details on filter specifications, see the `--filter` option in linkgit:git-rev-list[1]."
msgstr "使用部分克隆功能，要求服务器根据给定的对象过滤器发送一个可到达的对象的子集。当使用 `--filter` 选项时，提供的 `<过滤规则>` 将被用于部分克隆过滤器。例如，`--filter=blob:none` 将过滤掉所有的数据对象（文件内容），直到 Git 需要相应的数据。另外，`--filter=blob:limit=<大小>` 将过滤掉所有文件大小至少为 `<大小>` 的数据对象。关于过滤器定义的更多细节，请参阅 linkgit:git-rev-list[1] 中的 `--filter` 选项。"

#. type: Labeled list
#: en/git-clone.txt:190
#, ignore-same, no-wrap, priority:300
msgid "--also-filter-submodules"
msgstr "--also-filter-submodules"

#. type: Plain text
#: en/git-clone.txt:194
#, placeholders:'`--filter`':'`--recurse-submodules`':'clone.filterSubmodules', priority:300
msgid "Also apply the partial clone filter to any submodules in the repository. Requires `--filter` and `--recurse-submodules`. This can be turned on by default by setting the `clone.filterSubmodules` config option."
msgstr "同时对仓库中的任何子模块应用部分克隆过滤器。 需要 `--filter` 和 `--recurse-submodules` 。这可以通过设置 `clone.filterSubmodules` 配置项来默认开启。"

#. type: Labeled list
#: en/git-clone.txt:195 en/git-push.txt:162
#, ignore-same, no-wrap, priority:300
msgid "--mirror"
msgstr "--mirror"

#. type: Plain text
#: en/git-clone.txt:202
#, placeholders:'`--bare`':'`--bare`':'`--mirror`', priority:300
msgid "Set up a mirror of the source repository. This implies `--bare`. Compared to `--bare`, `--mirror` not only maps local branches of the source to local branches of the target, it maps all refs (including remote-tracking branches, notes etc.) and sets up a refspec configuration such that all these refs are overwritten by a `git remote update` in the target repository."
msgstr "建立源存储库的镜像。这默认包含 `--bare` 选项。与 `--bare` 相比，`--mirror` 不仅将源的本地分支映射到目标的本地分支，还映射所有引用（包括远程跟踪分支，注释等）并设置了引用规范，因而在目标仓库中执行 `git remote update` 时，所有这些引用都会被覆盖。"

#. type: Labeled list
#: en/git-clone.txt:203
#, no-wrap, priority:300
msgid "-o <name>"
msgstr "-o <名称>"

#. type: Labeled list
#: en/git-clone.txt:204
#, no-wrap, placeholders:'--origin', priority:300
msgid "--origin <name>"
msgstr "--origin <名称>"

#. type: Plain text
#: en/git-clone.txt:208
#, placeholders:'clone.defaultRemoteName', priority:300
msgid "Instead of using the remote name `origin` to keep track of the upstream repository, use `<name>`. Overrides `clone.defaultRemoteName` from the config."
msgstr "不使用远程名称 `origin` 来跟踪远程仓库，而使用 `<name>` 值。 这会覆盖配置中 `clone.defaultRemoteName` 的设置。"

#. type: Labeled list
#: en/git-clone.txt:209
#, no-wrap, priority:300
msgid "-b <name>"
msgstr "-b <名称>"

#. type: Labeled list
#: en/git-clone.txt:210
#, no-wrap, placeholders:'--branch', priority:300
msgid "--branch <name>"
msgstr "--branch <分支名>"

#. type: Plain text
#: en/git-clone.txt:217
#, placeholders:'HEAD':'HEAD':'`--branch`':'HEAD', priority:300
msgid "Instead of pointing the newly created HEAD to the branch pointed to by the cloned repository's HEAD, point to `<name>` branch instead. In a non-bare repository, this is the branch that will be checked out. `--branch` can also take tags and detaches the HEAD at that commit in the resulting repository."
msgstr "不将新创建的 HEAD 指向克隆仓库的 HEAD 所指向的分支，而是指向 `<分支名>` 分支。在非裸仓库中，这是将被检出的分支。 `--branch` 也可以使用标签并在生成的仓库中的提交时分离 HEAD。"

#. type: Labeled list
#: en/git-clone.txt:218
#, no-wrap, priority:300
msgid "-u <upload-pack>"
msgstr "-u <上传包>"

#. type: Plain text
#: en/git-clone.txt:223
#, priority:300
msgid "When given, and the repository to clone from is accessed via ssh, this specifies a non-default path for the command run on the other end."
msgstr "如果指定了要克隆的仓库，且可以通过 ssh 访问该仓库，这将为另一端运行的命令指定非默认路径。"

#. type: Labeled list
#: en/git-clone.txt:224 en/git-init.txt:67 en/git-svn.txt:578
#, no-wrap, placeholders:'--template=', priority:300
msgid "--template=<template-directory>"
msgstr "--template=<模板目录>"

#. type: Plain text
#: en/git-clone.txt:227
#, placeholders:'linkgit:git-init[1]', priority:300
msgid "Specify the directory from which templates will be used; (See the \"TEMPLATE DIRECTORY\" section of linkgit:git-init[1].)"
msgstr "指定将使用模板的目录；（请参阅 linkgit:git-init[1] 的 “模板目录” 部分。）"

#. type: Labeled list
#: en/git-clone.txt:228
#, no-wrap, priority:300
msgid "-c <key>=<value>"
msgstr "-c <键>=<值>"

#. type: Labeled list
#: en/git-clone.txt:229
#, no-wrap, placeholders:'--config', priority:300
msgid "--config <key>=<value>"
msgstr "--config <键>=<值>"

#. type: Plain text
#: en/git-clone.txt:238
#, placeholders:'linkgit:git-config[1]':'core.eol', priority:300
msgid "Set a configuration variable in the newly-created repository; this takes effect immediately after the repository is initialized, but before the remote history is fetched or any files checked out. The key is in the same format as expected by linkgit:git-config[1] (e.g., `core.eol=true`). If multiple values are given for the same key, each value will be written to the config file. This makes it safe, for example, to add additional fetch refspecs to the origin remote."
msgstr "在新创建的仓库中设置配置变量；这将在初始化仓库之后、获取远程历史记录或签出任何文件之前立即生效。密钥的格式与 linkgit:git-config[1] 期望的格式相同（例如，`core.eol = true`）。如果为同一键指定了多个值，则每个值都将写入配置文件。例如，这可以安全地将其他抓取引用规则添加到源远程仓库。"

#. type: Plain text
#: en/git-clone.txt:244
#, placeholders:'`--mirror`':'`--no-tags`', priority:300
msgid "Due to limitations of the current implementation, some configuration variables do not take effect until after the initial fetch and checkout. Configuration variables known to not take effect are: `remote.<name>.mirror` and `remote.<name>.tagOpt`. Use the corresponding `--mirror` and `--no-tags` options instead."
msgstr "由于当前实现方式的限制，某些配置变量要等到初始获取和签出后才能生效。已知不会生效的配置变量有：`remote.<名称> .mirror` 和 `remote.<名称> .tagOpt`。如要修改，应改用相应的 `--mirror` 和 `--no-tags` 选项。"

#. type: Labeled list
#: en/git-clone.txt:245
#, no-wrap, placeholders:'--depth', priority:300
msgid "--depth <depth>"
msgstr "--depth <深度>"

#. type: Plain text
#: en/git-clone.txt:251
#, placeholders:'`--single-branch`':'`--no-single-branch`':'`--shallow-submodules`', priority:300
msgid "Create a 'shallow' clone with a history truncated to the specified number of commits. Implies `--single-branch` unless `--no-single-branch` is given to fetch the histories near the tips of all branches. If you want to clone submodules shallowly, also pass `--shallow-submodules`."
msgstr "创建一个历史记录被截断为指定提交次数的 ‘浅’ 克隆。暗含 `--single-branch` 选项，除非给出 `--no-single-branch` 来获取所有分支顶端附近的历史记录。如果要浅层克隆子模块，还可以使用 `--shallow-submodules` 选项。"

#. type: Plain text
#: en/git-clone.txt:254
#, priority:300
msgid "Create a shallow clone with a history after the specified time."
msgstr "创建浅克隆，只包含指定的时间之后的历史记录。"

#. type: Plain text
#: en/git-clone.txt:259
#, priority:300
msgid "Create a shallow clone with a history, excluding commits reachable from a specified remote branch or tag. This option can be specified multiple times."
msgstr "创建一个有历史的浅克隆，不包含可以被指定远程分支或标签访问的提交。本选项可以使用多次。"

#. type: Labeled list
#: en/git-clone.txt:260 en/git-submodule.txt:444
#, ignore-same, no-wrap, priority:300
msgid "--[no-]single-branch"
msgstr "--[no-]single-branch"

#. type: Plain text
#: en/git-clone.txt:269
#, placeholders:'`--branch`':'HEAD':'HEAD':'`--single-branch`', priority:300
msgid "Clone only the history leading to the tip of a single branch, either specified by the `--branch` option or the primary branch remote's `HEAD` points at. Further fetches into the resulting repository will only update the remote-tracking branch for the branch this option was used for the initial cloning. If the HEAD at the remote did not point at any branch when `--single-branch` clone was made, no remote-tracking branch is created."
msgstr "仅克隆直到单一分支末尾的历史，该分支被 `--branch` 选项或主分支远程 `HEAD` 指定。被创建仓库之后的抓取将只更新在克隆时被指定的远程跟踪分支。如果在 `--single-branch` 克隆时，远程 HEAD 未指向任何分支，则不会创建远程跟踪分支。"

#. type: Plain text
#: en/git-clone.txt:276
#, placeholders:'--no-tags`':'linkgit:git-fetch[1]', priority:300
msgid "Don't clone any tags, and set `remote.<remote>.tagOpt=--no-tags` in the config, ensuring that future `git pull` and `git fetch` operations won't follow any tags. Subsequent explicit tag fetches will still work, (see linkgit:git-fetch[1])."
msgstr "不克隆任何标签，并在配置中设置 `remote.<remote>.tagOpt=--no-tags` ，确保将来的 `git pull` 和 `git fetch` 操作不会跟随任何标签。随后的显式标签抓取仍将起作用（参阅 linkgit:git-fetch[1]）。"

#. type: Plain text
#: en/git-clone.txt:281
#, placeholders:'`--single-branch`', priority:300
msgid "Can be used in conjunction with `--single-branch` to clone and maintain a branch with no references other than a single cloned branch. This is useful e.g. to maintain minimal clones of the default branch of some repository for search indexing."
msgstr "可以与 `--single-branch` 结合使用，以克隆和维护除单个克隆分支外没有其他引用的分支。这在例如维护某些仓库的默认分支的最小克隆以进行搜索索引时有用。"

#. type: Labeled list
#: en/git-clone.txt:282
#, no-wrap, placeholders:'--recurse-submodules', priority:300
msgid "--recurse-submodules[=<pathspec>]"
msgstr "--recurse-submodules[=<路径规范>]"

#. type: Plain text
#: en/git-clone.txt:290
#, placeholders:'submodule.active', priority:300
msgid "After the clone is created, initialize and clone submodules within based on the provided pathspec. If no pathspec is provided, all submodules are initialized and cloned. This option can be given multiple times for pathspecs consisting of multiple entries. The resulting clone has `submodule.active` set to the provided pathspec, or \".\" (meaning all submodules) if no pathspec is provided."
msgstr "创建克隆后，根据提供的路径规范初始化并克隆其中的子模块。如果未提供路径规范，则将初始化并克隆所有子模块。对于由多个条目组成的路径规范，可以多次赋予此选项。生成的克隆将把 `submodule.active` 设为提供的路径规范。如果未提供路径规范，生成的克隆将把 `submodule.active` 设为 \".\" （表示所有子模块）。"

#. type: Plain text
#: en/git-clone.txt:297
#, placeholders:'--init':'--recursive':'`--no-checkout`':'`-n`':'`--bare`':'`--mirror`', priority:300
msgid "Submodules are initialized and cloned using their default settings. This is equivalent to running `git submodule update --init --recursive <pathspec>` immediately after the clone is finished. This option is ignored if the cloned repository does not have a worktree/checkout (i.e. if any of `--no-checkout`/`-n`, `--bare`, or `--mirror` is given)"
msgstr "子模块使用其默认设置进行初始化和克隆。这等效于克隆完成后立即运行 `git submodule update --init --recursive <路径规范>`。如果克隆的仓库没有工作区/检出（即给出了 `--no-checkout`/`-n`，`--bare` 或 `--mirror`中的任何一个选项），则忽略此选项"

#. type: Labeled list
#: en/git-clone.txt:298
#, ignore-same, no-wrap, priority:300
msgid "--[no-]shallow-submodules"
msgstr "--[no-]shallow-submodules"

#. type: Plain text
#: en/git-clone.txt:300
#, priority:300
msgid "All submodules which are cloned will be shallow with a depth of 1."
msgstr "所有克隆的子模块都将是浅克隆，深度为 1。"

#. type: Labeled list
#: en/git-clone.txt:301
#, ignore-same, no-wrap, priority:300
msgid "--[no-]remote-submodules"
msgstr "--[no-]remote-submodules"

#. type: Plain text
#: en/git-clone.txt:306
#, placeholders:'`--remote`', priority:300
msgid "All submodules which are cloned will use the status of the submodule's remote-tracking branch to update the submodule, rather than the superproject's recorded SHA-1. Equivalent to passing `--remote` to `git submodule update`."
msgstr "克隆的所有子模块将使用子模块的远程跟踪分支的状态来更新子模块，而不是超级项目的已记录 SHA-1。等同于将 `--remote` 传递给 `git submodule update`。"

#. type: Labeled list
#: en/git-clone.txt:307 en/git-init.txt:72
#, no-wrap, priority:300
msgid "--separate-git-dir=<git-dir>"
msgstr "--separate-git-dir=<Git 目录>"

#. type: Plain text
#: en/git-clone.txt:313
#, priority:300
msgid "Instead of placing the cloned repository where it is supposed to be, place the cloned repository at the specified directory, then make a filesystem-agnostic Git symbolic link to there. The result is Git repository can be separated from working tree."
msgstr "不将克隆的仓库放置在原处，而是将克隆的仓库放置在指定的目录中，然后在此处建立与文件系统无关的 Git 符号链接。这可以将 Git 仓库与工作区分离。"

#. type: Labeled list
#: en/git-clone.txt:314
#, no-wrap, placeholders:'--ref-format=', priority:300
msgid "--ref-format=<ref-format"
msgstr "--ref-format=<引用格式>"

#. type: Plain text
#: en/git-clone.txt:317 en/git-init.txt:64
#, priority:300
msgid "Specify the given ref storage format for the repository. The valid values are:"
msgstr "指定存储库的给定引用存储格式。有效值为："

#. type: Labeled list
#: en/git-clone.txt:320 en/git-submodule.txt:438
#, no-wrap, priority:300
msgid "-j <n>"
msgstr "-j <n>"

#. type: Labeled list
#: en/git-clone.txt:321 en/git-submodule.txt:439
#, no-wrap, placeholders:'--jobs', priority:300
msgid "--jobs <n>"
msgstr "--jobs <n>"

#. type: Plain text
#: en/git-clone.txt:324
#, placeholders:'submodule.fetchJobs', priority:300
msgid "The number of submodules fetched at the same time. Defaults to the `submodule.fetchJobs` option."
msgstr "同时抓取的子模块数。默认为 `submodule.fetchJobs` 选项。"

#. type: Labeled list
#: en/git-clone.txt:325 en/git-fetch-pack.txt:118 en/git-ls-remote.txt:83 en/git-push.txt:50 en/git-upload-archive.txt:57 en/pull-fetch-param.txt:1
#, no-wrap, priority:300
msgid "<repository>"
msgstr "<仓库>"

#. type: Plain text
#: en/git-clone.txt:329
#, placeholders:'<<URLS,', priority:300
msgid "The (possibly remote) repository to clone from. See the <<URLS,GIT URLS>> section below for more information on specifying repositories."
msgstr "要克隆的（可能是远程的）仓库。有关指定仓库的更多信息，参阅下面的 <<URLS,GIT 地址>> 部分。"

#. type: Labeled list
#: en/git-clone.txt:330 en/git-cvsserver.txt:65 en/git-daemon.txt:220 en/git-send-pack.txt:96 en/git-upload-pack.txt:47
#, no-wrap, priority:300
msgid "<directory>"
msgstr "<目录>"

#. type: Plain text
#: en/git-clone.txt:336
#, priority:300
msgid "The name of a new directory to clone into. The \"humanish\" part of the source repository is used if no directory is explicitly given (`repo` for `/path/to/repo.git` and `foo` for `host.xz:foo/.git`). Cloning into an existing directory is only allowed if the directory is empty."
msgstr "要克隆到的新目录的名称。如果未明确指定目录，则使用源仓库中的 “人性化” 部分（对于 `/path/to/repo.git` 而言，为 `repo`；对于 `host.xz:foo/.git` 而言，为 `foo` ）。仅当目录为空时才允许克隆到现有目录。"

#. type: Labeled list
#: en/git-clone.txt:337
#, no-wrap, placeholders:'--bundle-uri=', priority:300
msgid "--bundle-uri=<uri>"
msgstr "--bundle-uri=<uri>"

#. type: Plain text
#: en/git-clone.txt:343
#, placeholders:'`--depth`':'`--shallow-since`':'`--shallow-exclude`', priority:300
msgid "Before fetching from the remote, fetch a bundle from the given `<uri>` and unbundle the data into the local repository. The refs in the bundle will be stored under the hidden `refs/bundle/*` namespace. This option is incompatible with `--depth`, `--shallow-since`, and `--shallow-exclude`."
msgstr "在从远程获取之前，从给定的 `<uri>` 中获取一个捆绑包，并将数据解绑到本地仓库中。捆绑包中的引用将被存储在隐藏的 `refs/bundle/*` 命名空间下。该选项不与 `--depth`、`--shallow-since`、`--shallow-exclude` 兼容。"

#. type: Plain text
#: en/git-clone.txt:351
#, priority:300
msgid "Clone from upstream:"
msgstr "从上游仓库克隆："

#. type: delimited block -
#: en/git-clone.txt:356
#, ignore-ellipsis, no-wrap, placeholders:'git.kernel.org':'linux.git', priority:300
msgid ""
"$ git clone git://git.kernel.org/pub/scm/.../linux.git my-linux\n"
"$ cd my-linux\n"
"$ make\n"
msgstr ""
"$ git clone git://git.kernel.org/pub/scm/.../linux.git my-linux\n"
"$ cd my-linux\n"
"$ make\n"

#. type: Plain text
#: en/git-clone.txt:360
#, priority:300
msgid "Make a local clone that borrows from the current directory, without checking things out:"
msgstr "制作一个从当前目录借用的本地克隆，而无需进行检出："

#. type: delimited block -
#: en/git-clone.txt:365
#, no-wrap, placeholders:'git show-branch', priority:300
msgid ""
"$ git clone -l -s -n . ../copy\n"
"$ cd ../copy\n"
"$ git show-branch\n"
msgstr ""
"$ git clone -l -s -n . ../copy\n"
"$ cd ../copy\n"
"$ git show-branch\n"

#. type: Plain text
#: en/git-clone.txt:369
#, priority:300
msgid "Clone from upstream while borrowing from an existing local directory:"
msgstr "从上游仓库克隆时借用本地目录："

#. type: delimited block -
#: en/git-clone.txt:375
#, ignore-ellipsis, no-wrap, placeholders:'--reference':'linux.git':'git.kernel.org':'linux.git', priority:300
msgid ""
"$ git clone --reference /git/linux.git \\\n"
"\tgit://git.kernel.org/pub/scm/.../linux.git \\\n"
"\tmy-linux\n"
"$ cd my-linux\n"
msgstr ""
"$ git clone --reference /git/linux.git \\\n"
"\tgit://git.kernel.org/pub/scm/.../linux.git \\\n"
"\tmy-linux\n"
"$ cd my-linux\n"

#. type: Plain text
#: en/git-clone.txt:379
#, priority:300
msgid "Create a bare repository to publish your changes to the public:"
msgstr "创建一个裸仓库，以将您的更改发布给公众："

#. type: delimited block -
#: en/git-clone.txt:382
#, no-wrap, placeholders:'--bare':'proj.git', priority:300
msgid "$ git clone --bare -l /home/proj/.git /pub/scm/proj.git\n"
msgstr "$ git clone --bare -l /home/proj/.git /pub/scm/proj.git\n"

#. type: Title =
#: en/git-column.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-column(1)"
msgstr "git-column(1)"

#. type: Plain text
#: en/git-column.txt:7
#, placeholders:'git-column', priority:100
msgid "git-column - Display data in columns"
msgstr "git-column - 以列展示数据"

#. type: Plain text
#: en/git-column.txt:13
#, no-wrap, placeholders:'[--command=':'[--width=':'[--indent=':'[--nl=':'[--padding=', priority:100
msgid ""
"'git column' [--command=<name>] [--[raw-]mode=<mode>] [--width=<width>]\n"
"\t     [--indent=<string>] [--nl=<string>] [--padding=<n>]\n"
msgstr ""
"'git column' [--command=<名称>] [--[raw-]mode=<模式>] [--width=<宽度>]\n"
"\t     [--indent=<字符串>] [--nl=<字符串>] [--padding=<n>]\n"

#. type: Plain text
#: en/git-column.txt:20
#, priority:100
msgid "This command formats the lines of its standard input into a table with multiple columns. Each input line occupies one cell of the table. It is used internally by other git commands to format output into columns."
msgstr "该命令将其标准输入的行格式化为一个多列表格。每个输入行占据表格的一个单元。它被其他Git命令内部使用，以将输出信息格式化为列。"

#. type: Labeled list
#: en/git-column.txt:23
#, no-wrap, placeholders:'--command=', priority:100
msgid "--command=<name>"
msgstr "--command=<名称>"

#. type: Plain text
#: en/git-column.txt:26
#, placeholders:'column.ui', priority:100
msgid "Look up layout mode using configuration variable column.<name> and column.ui."
msgstr "使用配置变量column.<名称>和column.ui查询布局模式。"

#. type: Labeled list
#: en/git-column.txt:27
#, no-wrap, placeholders:'--mode=', priority:100
msgid "--mode=<mode>"
msgstr "--mode=<模式>"

#. type: Plain text
#: en/git-column.txt:30
#, placeholders:'column.ui':'linkgit:git-config[1]', priority:100
msgid "Specify layout mode. See configuration variable column.ui for option syntax in linkgit:git-config[1]."
msgstr "指定布局模式。选项的语法见 linkgit:git-config[1] 中column.ui变量的配置。"

#. type: Labeled list
#: en/git-column.txt:31
#, no-wrap, placeholders:'--raw-mode=', priority:100
msgid "--raw-mode=<n>"
msgstr "--raw-mode=<n>"

# ERROR: --mode not found in translation
#. type: Plain text
#: en/git-column.txt:34
#, placeholders:'--mode', priority:100
msgid "Same as --mode but take mode encoded as a number. This is mainly used by other commands that have already parsed layout mode."
msgstr "与 --mode 选项相同，但该选项将模式编码为一个数字。这主要是被其他已经解析了布局模式的命令使用。"

#. type: Labeled list
#: en/git-column.txt:35
#, no-wrap, placeholders:'--width=', priority:100
msgid "--width=<width>"
msgstr "--width=<宽度>"

#. type: Plain text
#: en/git-column.txt:38
#, priority:100
msgid "Specify the terminal width. By default 'git column' will detect the terminal width, or fall back to 80 if it is unable to do so."
msgstr "指定终端的宽度。默认情况下，'git column'会检测终端宽度，如果无法检测，则会将其宽度设置为80。"

#. type: Labeled list
#: en/git-column.txt:39
#, no-wrap, placeholders:'--indent=', priority:100
msgid "--indent=<string>"
msgstr "--indent=<字符串>"

#. type: Plain text
#: en/git-column.txt:41
#, priority:100
msgid "String to be printed at the beginning of each line."
msgstr "设置要在每一行的开头打印的字符串。"

#. type: Labeled list
#: en/git-column.txt:42
#, no-wrap, placeholders:'--nl=', priority:100
msgid "--nl=<string>"
msgstr "--nl=<字符串>"

#. type: Plain text
#: en/git-column.txt:45
#, priority:100
msgid "String to be printed at the end of each line, including newline character."
msgstr "在每一行的末尾要打印的字符串，包括换行符。"

#. type: Labeled list
#: en/git-column.txt:46
#, no-wrap, placeholders:'--padding=', priority:100
msgid "--padding=<N>"
msgstr "--padding=<N>"

#. type: Plain text
#: en/git-column.txt:48
#, priority:100
msgid "The number of spaces between columns. One space by default."
msgstr "列之间的空格数，默认为一个空格。"

#. type: Plain text
#: en/git-column.txt:53
#, priority:100
msgid "Format data by columns:"
msgstr "按列格式化数据："

#. type: delimited block -
#: en/git-column.txt:58
#, no-wrap, placeholders:'--mode=column':'--padding=5', priority:100
msgid ""
"$ seq 1 24 | git column --mode=column --padding=5\n"
"1      4      7      10     13     16     19     22\n"
"2      5      8      11     14     17     20     23\n"
"3      6      9      12     15     18     21     24\n"
msgstr ""
"$ seq 1 24 | git column --mode=column --padding=5\n"
"1      4      7      10     13     16     19     22\n"
"2      5      8      11     14     17     20     23\n"
"3      6      9      12     15     18     21     24\n"

#. type: Plain text
#: en/git-column.txt:61
#, priority:100
msgid "Format data by rows:"
msgstr "按行格式化数据："

#. type: delimited block -
#: en/git-column.txt:66
#, no-wrap, placeholders:'--mode=row':'--padding=5', priority:100
msgid ""
"$ seq 1 21 | git column --mode=row --padding=5\n"
"1      2      3      4      5      6      7\n"
"8      9      10     11     12     13     14\n"
"15     16     17     18     19     20     21\n"
msgstr ""
"$ seq 1 21 | git column --mode=row --padding=5\n"
"1      2      3      4      5      6      7\n"
"8      9      10     11     12     13     14\n"
"15     16     17     18     19     20     21\n"

#. type: Plain text
#: en/git-column.txt:69
#, priority:100
msgid "List some tags in a table with unequal column widths:"
msgstr "在一个列宽不等的表格中列出一些标签："

#. type: delimited block -
#: en/git-column.txt:75
#, no-wrap, placeholders:'--list':'--column=row', priority:100
msgid ""
"$ git tag --list 'v2.4.*' --column=row,dense\n"
"v2.4.0  v2.4.0-rc0  v2.4.0-rc1  v2.4.0-rc2  v2.4.0-rc3\n"
"v2.4.1  v2.4.10     v2.4.11     v2.4.12     v2.4.2\n"
"v2.4.3  v2.4.4      v2.4.5      v2.4.6      v2.4.7\n"
"v2.4.8  v2.4.9\n"
msgstr ""
"$ git tag --list 'v2.4.*' --column=row,dense\n"
"v2.4.0  v2.4.0-rc0  v2.4.0-rc1  v2.4.0-rc2  v2.4.0-rc3\n"
"v2.4.1  v2.4.10     v2.4.11     v2.4.12     v2.4.2\n"
"v2.4.3  v2.4.4      v2.4.5      v2.4.6      v2.4.7\n"
"v2.4.8  v2.4.9\n"

#. type: Title =
#: en/git-commit-tree.txt:2
#, ignore-same, no-wrap, priority:80
msgid "git-commit-tree(1)"
msgstr "git-commit-tree(1)"

#. type: Plain text
#: en/git-commit-tree.txt:7
#, placeholders:'git-commit-tree', priority:80
msgid "git-commit-tree - Create a new commit object"
msgstr "git-commit-tree -创建一个新的提交对象"

#. type: Plain text
#: en/git-commit-tree.txt:15
#, ignore-ellipsis, no-wrap, placeholders:'git commit-tree':'git commit-tree', priority:80
msgid ""
"'git commit-tree' <tree> [(-p <parent>)...]\n"
"'git commit-tree' [(-p <parent>)...] [-S[<keyid>]] [(-m <message>)...]\n"
"\t\t  [(-F <file>)...] <tree>\n"
msgstr ""
"'git commit-tree' <目录树> [(-p <父对象>)...]\n"
"'git commit-tree' [(-p <父对象>)...] [-S[<keyid>]] [(-m <消息>)...]\n"
"\t\t  [(-F <文件>)...] <目录树>\n"

#. type: Plain text
#: en/git-commit-tree.txt:21
#, placeholders:'linkgit:git-commit[1]', priority:80
msgid "This is usually not what an end user wants to run directly. See linkgit:git-commit[1] instead."
msgstr "这通常不是最终用户想要直接运行的。 请参见 linkgit:git-commit[1]。"

#. type: Plain text
#: en/git-commit-tree.txt:25
#, placeholders:'`-m`':'`-F`', priority:80
msgid "Creates a new commit object based on the provided tree object and emits the new commit object id on stdout. The log message is read from the standard input, unless `-m` or `-F` options are given."
msgstr "根据提供的树对象创建新的提交对象，并将新的提交对象 id 发送到 stdout。除非给出 `-m` 或 `-F`选项，否则日志信息将从标准输入读取。"

# ERROR: `-m` not found in translation
#. type: Plain text
#: en/git-commit-tree.txt:29
#, placeholders:'`-m`':'`-F`', priority:80
msgid "The `-m` and `-F` options can be given any number of times, in any order. The commit log message will be composed in the order in which the options are given."
msgstr "`-m` 和 `-F` 选项可以以任意顺序给出任意次数。提交日志信息将按照选项的顺序排列。"

#. type: Plain text
#: en/git-commit-tree.txt:34
#, priority:80
msgid "A commit object may have any number of parents. With exactly one parent, it is an ordinary commit. Having more than one parent makes the commit a merge between several lines of history. Initial (root) commits have no parents."
msgstr "一个提交对象可以有任意数量的父对象。如果只有一个父对象，它就是一个普通的提交。如果有一个以上的父提交对象，提交就会在多行历史记录之间进行合并。初始（根）提交没有父对象。"

#. type: Plain text
#: en/git-commit-tree.txt:38
#, priority:80
msgid "While a tree represents a particular directory state of a working directory, a commit represents that state in \"time\", and explains how to get there."
msgstr "树表示工作目录的特定目录状态，而提交则表示 “时间” 上的状态，并说明如何到达该状态。"

#. type: Plain text
#: en/git-commit-tree.txt:44
#, placeholders:'HEAD':'.git/HEAD', priority:80
msgid "Normally a commit would identify a new \"HEAD\" state, and while Git doesn't care where you save the note about that state, in practice we tend to just write the result to the file that is pointed at by `.git/HEAD`, so that we can always see what the last committed state was."
msgstr "通常情况下，一次提交会确定一个新的 \"HEAD\" 状态，虽然 Git 并不关心你把关于该状态的注释保存在哪里，但在实践中，我们倾向于把结果写入 `.git/HEAD` 指向的文件，这样我们就能随时看到上次提交的状态。"

#. type: Labeled list
#: en/git-commit-tree.txt:47 en/git.txt:396
#, no-wrap, priority:100
msgid "<tree>"
msgstr "<目录树>"

#. type: Plain text
#: en/git-commit-tree.txt:49
#, priority:80
msgid "An existing tree object."
msgstr "一个现有的目录树对象。"

#. type: Labeled list
#: en/git-commit-tree.txt:50
#, no-wrap, priority:80
msgid "-p <parent>"
msgstr "-p <父提交>"

#. type: Plain text
#: en/git-commit-tree.txt:52
#, placeholders:'`-p`', priority:80
msgid "Each `-p` indicates the id of a parent commit object."
msgstr "每个 `-p` 表示父提交对象的 id。"

#. type: Labeled list
#: en/git-commit-tree.txt:53 en/git-fmt-merge-msg.txt:42
#, no-wrap, priority:100
msgid "-m <message>"
msgstr "-m <信息>"

#. type: Plain text
#: en/git-commit-tree.txt:56
#, priority:80
msgid "A paragraph in the commit log message. This can be given more than once and each <message> becomes its own paragraph."
msgstr "提交日志信息中的一个段落。可以给出多个段落，每个 <信息> 都将成为自己的段落。"

#. type: Labeled list
#: en/git-commit-tree.txt:57 en/git-commit.txt:167 en/git-fmt-merge-msg.txt:51 en/git-merge.txt:86 en/git-notes.txt:147 en/git-tag.txt:174
#, no-wrap, priority:280
msgid "-F <file>"
msgstr "-F <文件>"

#. type: Plain text
#: en/git-commit-tree.txt:61
#, priority:80
msgid "Read the commit log message from the given file. Use `-` to read from the standard input. This can be given more than once and the content of each file becomes its own paragraph."
msgstr "从给定文件中读取提交日志信息。使用 `-` 从标准输入读取。可以多次给定该文件，每个文件的内容都会成为自己的段落。"

# ERROR: --no-gpg-sign not found in translation
# ERROR: --no-gpg-sign not found in translation
#. type: Plain text
#: en/git-commit-tree.txt:69
#, placeholders:'`--no-gpg-sign`':'`--gpg-sign`', priority:80
msgid "GPG-sign commits. The `keyid` argument is optional and defaults to the committer identity; if specified, it must be stuck to the option without a space. `--no-gpg-sign` is useful to countermand a `--gpg-sign` option given earlier on the command line."
msgstr "GPG 签名提交。`keyid` 参数是可选的，默认为提交者身份；如果指定，必须与选项粘连，不能有空格。`--no-gpg-sign` 用于抵消命令行中先前给出的 `--gpg-sign`选项。"

#. type: Title -
#: en/git-commit-tree.txt:71
#, no-wrap, priority:80
msgid "Commit Information"
msgstr "提交信息"

#. type: Plain text
#: en/git-commit-tree.txt:74
#, priority:80
msgid "A commit encapsulates:"
msgstr "一个提交封装了："

#. type: Plain text
#: en/git-commit-tree.txt:76
#, priority:80
msgid "all parent object ids"
msgstr "所有父对象 ID"

#. type: Plain text
#: en/git-commit-tree.txt:77
#, priority:80
msgid "author name, email and date"
msgstr "作者姓名、电子邮件和日期"

#. type: Plain text
#: en/git-commit-tree.txt:78
#, priority:80
msgid "committer name and email and the commit time."
msgstr "提交者姓名、电子邮件和提交时间。"

#. type: Plain text
#: en/git-commit-tree.txt:82
#, placeholders:'git commit-tree', priority:80
msgid "A commit comment is read from stdin. If a changelog entry is not provided via \"<\" redirection, 'git commit-tree' will just wait for one to be entered and terminated with ^D."
msgstr "提交注释从标准输入流读取。如果没有通过 \"<\" 重定向提供更新日志条目，'git commit-tree' 就会等待输入条目，并以 ^D 结束。"

#. type: Title -
#: en/git-commit-tree.txt:86
#, no-wrap, priority:80
msgid "Discussion"
msgstr "讨论"

#. type: Title -
#: en/git-commit-tree.txt:91 en/git-commit.txt:571 en/git-config.txt:298 en/git-credential-store.txt:45 en/git-show-ref.txt:200 en/git-submodule.txt:454 en/git-svn.txt:1137 en/git-tag.txt:385
#, no-wrap, priority:280
msgid "FILES"
msgstr "文件"

#. type: Plain text
#: en/git-commit-tree.txt:93
#, priority:80
msgid "/etc/mailname"
msgstr "/etc/mailname"

#. type: Plain text
#: en/git-commit-tree.txt:98
#, ignore-same, priority:80
msgid "linkgit:git-write-tree[1] linkgit:git-commit[1]"
msgstr "linkgit:git-write-tree[1] linkgit:git-commit[1]"

#. type: Title =
#: en/git-commit.txt:2
#, ignore-same, no-wrap, priority:280
msgid "git-commit(1)"
msgstr "git-commit(1)"

#. type: Plain text
#: en/git-commit.txt:7
#, placeholders:'git-commit', priority:280
msgid "git-commit - Record changes to the repository"
msgstr "git-commit - 记录仓库的修改"

#. type: Plain text
#: en/git-commit.txt:19
#, ignore-ellipsis, no-wrap, placeholders:'--interactive':'--patch]':'[--amend]':'[--dry-run]':'--squash':'--fixup':'[--reset-author]':'[--allow-empty]':'[--allow-empty-message]':'[--no-verify]':'[--author=':'[--date=':'[--cleanup=':'[--pathspec-from-file=':'[--pathspec-file-nul]':'--trailer', priority:280
msgid ""
"'git commit' [-a | --interactive | --patch] [-s] [-v] [-u<mode>] [--amend]\n"
"\t   [--dry-run] [(-c | -C | --squash) <commit> | --fixup [(amend|reword):]<commit>)]\n"
"\t   [-F <file> | -m <msg>] [--reset-author] [--allow-empty]\n"
"\t   [--allow-empty-message] [--no-verify] [-e] [--author=<author>]\n"
"\t   [--date=<date>] [--cleanup=<mode>] [--[no-]status]\n"
"\t   [-i | -o] [--pathspec-from-file=<file> [--pathspec-file-nul]]\n"
"\t   [(--trailer <token>[(=|:)<value>])...] [-S[<keyid>]]\n"
"\t   [--] [<pathspec>...]\n"
msgstr ""
"'git commit' [-a | --interactive | --patch] [-s] [-v] [-u<模式>] [--amend]\n"
"\t   [--dry-run] [(-c | -C | --squash) <提交> | --fixup [(amend|reword):]<提交>)]\n"
"\t   [-F <文件> | -m <消息>] [--reset-author] [--allow-empty]\n"
"\t   [--allow-empty-message] [--no-verify] [-e] [--author=<提交人>]\n"
"\t   [--date=<日期>] [--cleanup=<模式>] [--[no-]status]\n"
"\t   [-i | -o] [--pathspec-from-file=<文件> [--pathspec-file-nul]]\n"
"\t   [(--trailer <token>[(=|:)<value>])...] [-S[<keyid>]]\n"
"\t   [--] [<路径>...]\n"

#. type: Plain text
#: en/git-commit.txt:28
#, placeholders:'HEAD':'HEAD':'linkgit:git-checkout[1]', priority:280
msgid "Create a new commit containing the current contents of the index and the given log message describing the changes. The new commit is a direct child of HEAD, usually the tip of the current branch, and the branch is updated to point to it (unless no branch is associated with the working tree, in which case HEAD is \"detached\" as described in linkgit:git-checkout[1])."
msgstr "创建一个新的提交，包含索引的当前内容和描述变化的给定日志信息。新的提交是 HEAD 的直接子节点，通常是当前分支的顶端，分支会被更新以指向它（除非工作树上没有分支，在这种情况下 HEAD 会被 \"分离\"，如 linkgit:git-checkout[1] 所述）。"

#. type: Plain text
#: en/git-commit.txt:30
#, priority:280
msgid "The content to be committed can be specified in several ways:"
msgstr "可以用几种方式指定要提交的内容："

#. type: Plain text
#: en/git-commit.txt:34
#, placeholders:'linkgit:git-add[1]', priority:280
msgid "by using linkgit:git-add[1] to incrementally \"add\" changes to the index before using the 'commit' command (Note: even modified files must be \"added\");"
msgstr "通过使用linkgit:git-add[1]，在使用'commit'命令之前，逐步将修改内容 \"添加\"到索引中（注意:即使是修改过的文件也必须被 \"添加\" ）；"

#. type: Plain text
#: en/git-commit.txt:37
#, placeholders:'linkgit:git-rm[1]', priority:280
msgid "by using linkgit:git-rm[1] to remove files from the working tree and the index, again before using the 'commit' command;"
msgstr "通过使用 linkgit:git-rm[1] ，在再次使用“提交”命令之前从工作树和索引中删除文件；"

#. type: Plain text
#: en/git-commit.txt:43
#, placeholders:'--interactive':'--patch', priority:280
msgid "by listing files as arguments to the 'commit' command (without --interactive or --patch switch), in which case the commit will ignore changes staged in the index, and instead record the current content of the listed files (which must already be known to Git);"
msgstr "通过将文件列为“commit”命令的参数(不带--interactive或--patch switch)，在这种情况下，提交将忽略索引中的更改，而是记录所列文件的当前内容(Git必须已经知道);"

#. type: Plain text
#: en/git-commit.txt:49
#, priority:280
msgid "by using the -a switch with the 'commit' command to automatically \"add\" changes from all known files (i.e. all files that are already listed in the index) and to automatically \"rm\" files in the index that have been removed from the working tree, and then perform the actual commit;"
msgstr "通过在'commit'命令中使用-a开关，自动 \"添加 \"所有已知文件的修改（即所有已经列在索引中的文件），并自动 \"清除 \"索引中已经从工作树中删除的文件，然后执行实际的提交；"

#. type: Plain text
#: en/git-commit.txt:55
#, placeholders:'--interactive':'--patch':'linkgit:git-add[1]', priority:280
msgid "by using the --interactive or --patch switches with the 'commit' command to decide one by one which files or hunks should be part of the commit in addition to contents in the index, before finalizing the operation. See the ``Interactive Mode'' section of linkgit:git-add[1] to learn how to operate these modes."
msgstr "通过在'commit'命令中使用 --interactive 或 --patch 开关，在最终完成操作之前，逐一决定哪些文件或块应该成为提交的一部分，而不是索引中的内容。参见 linkgit:git-add[1] 的 ``交互式模式'一节，了解如何操作这些模式。"

#. type: Plain text
#: en/git-commit.txt:59
#, placeholders:'`--dry-run`', priority:280
msgid "The `--dry-run` option can be used to obtain a summary of what is included by any of the above for the next commit by giving the same set of parameters (options and paths)."
msgstr "`--dry-run`选项可以用来获得上述任何一个选项为下一次提交所包含的内容的摘要，只要给出相同的参数（选项和路径）即可。"

#. type: Plain text
#: en/git-commit.txt:62
#, priority:280
msgid "If you make a commit and then find a mistake immediately after that, you can recover from it with 'git reset'."
msgstr "如果你做了一个提交，然后紧接着发现了一个错误，你可以用'git reset'来恢复它。"

#. type: Plain text
#: en/git-commit.txt:72
#, priority:280
msgid "Tell the command to automatically stage files that have been modified and deleted, but new files you have not told Git about are not affected."
msgstr "告诉命令自动阶段化已经被修改和删除的文件，但你没有告诉 Git 的新文件不受影响。"

#. type: Plain text
#: en/git-commit.txt:78
#, placeholders:'linkgit:git-add[1]', priority:280
msgid "Use the interactive patch selection interface to choose which changes to commit. See linkgit:git-add[1] for details."
msgstr "使用交互式补丁选择界面来选择要提交的修改。详情见 linkgit:git-add[1]。"

#. type: Labeled list
#: en/git-commit.txt:79
#, no-wrap, priority:280
msgid "-C <commit>"
msgstr "-C <提交>"

#. type: Labeled list
#: en/git-commit.txt:80
#, no-wrap, placeholders:'--reuse-message=', priority:280
msgid "--reuse-message=<commit>"
msgstr "--reuse-message=<提交>"

#. type: Plain text
#: en/git-commit.txt:84
#, priority:280
msgid "Take an existing commit object, and reuse the log message and the authorship information (including the timestamp) when creating the commit."
msgstr "取一个现有的提交对象，并在创建提交时重新使用日志信息和作者信息（包括时间戳）。"

#. type: Labeled list
#: en/git-commit.txt:85
#, no-wrap, priority:280
msgid "-c <commit>"
msgstr "-c <commit>"

#. type: Labeled list
#: en/git-commit.txt:86
#, no-wrap, placeholders:'--reedit-message=', priority:280
msgid "--reedit-message=<commit>"
msgstr "--reedit-message=<提交>"

# ERROR: `-c` not found in translation
#. type: Plain text
#: en/git-commit.txt:89
#, placeholders:'`-c`', priority:280
msgid "Like '-C', but with `-c` the editor is invoked, so that the user can further edit the commit message."
msgstr "和'-C'一样，但用 `-c` 会调用编辑器，这样用户可以进一步编辑提交信息。"

#. type: Labeled list
#: en/git-commit.txt:90
#, no-wrap, placeholders:'--fixup=[(amend|reword)', priority:280
msgid "--fixup=[(amend|reword):]<commit>"
msgstr "--fixup=[(amend|reword):]<提交>"

#. type: Plain text
#: en/git-commit.txt:100
#, placeholders:'--autosquash`':'`--fixup=':'`--fixup=amend':'`--fixup=reword', priority:280
msgid "Create a new commit which \"fixes up\" `<commit>` when applied with `git rebase --autosquash`. Plain `--fixup=<commit>` creates a \"fixup!\" commit which changes the content of `<commit>` but leaves its log message untouched. `--fixup=amend:<commit>` is similar but creates an \"amend!\" commit which also replaces the log message of `<commit>` with the log message of the \"amend!\" commit. `--fixup=reword:<commit>` creates an \"amend!\" commit which replaces the log message of `<commit>` with its own log message but makes no changes to the content of `<commit>`."
msgstr "创建一个新的提交，在使用 `git rebase --autosquash` 时，\"修复\"`<commit>`。普通的`--fixup=<commit>`会创建一个 \"fixup!\"的提交，改变`<commit>`的内容，但不改变其日志信息。`--fixup=amend:<commit>`类似，但会创建一个 \"修正！\"的提交，同时用 \"修正！\"的提交的日志信息替换`<commit>`的日志信息。 `--fixup=reword:<commit>`创建一个 \"修正！\"提交，用自己的日志信息替换`<commit>`的日志信息，但不对`<commit>`的内容做任何修改。"

#. type: Plain text
#: en/git-commit.txt:108
#, placeholders:'`--fixup=':'--autosquash`':'`-m`':'--autosquash`', priority:280
msgid "The commit created by plain `--fixup=<commit>` has a subject composed of \"fixup!\" followed by the subject line from <commit>, and is recognized specially by `git rebase --autosquash`. The `-m` option may be used to supplement the log message of the created commit, but the additional commentary will be thrown away once the \"fixup!\" commit is squashed into `<commit>` by `git rebase --autosquash`."
msgstr "由普通的`--fixup=<commit>`创建的提交，其主题由 \"fixup!\"和<commit>的主题行组成，并被`git rebase --autosquash`特别识别。`-m`选项可以用来补充创建提交的日志信息，但一旦 \"fixup!\"提交被`git rebase --autosquash`压入`<commit>`，额外的注释就会被扔掉。"

#. type: Plain text
#: en/git-commit.txt:118
#, placeholders:'`--fixup=amend':'--autosquash`':'`--allow-empty-message`', priority:280
msgid "The commit created by `--fixup=amend:<commit>` is similar but its subject is instead prefixed with \"amend!\". The log message of <commit> is copied into the log message of the \"amend!\" commit and opened in an editor so it can be refined. When `git rebase --autosquash` squashes the \"amend!\" commit into `<commit>`, the log message of `<commit>` is replaced by the refined log message from the \"amend!\" commit. It is an error for the \"amend!\" commit's log message to be empty unless `--allow-empty-message` is specified."
msgstr "由`--fixup=amend:<commit>`创建的提交与此类似，但其主题前缀为 \"amend!\"。<commit>的日志信息会被复制到 \"amend!\"提交的日志信息中，并在编辑器中打开，以便对其进行修改。当`git rebase --autosquash`将 \"amend!\"提交压入`<commit>`时，`<commit>`的日志信息会被 \"amend!\"提交的精炼日志信息所取代。如果 \"修正！\"提交的日志信息为空，则是一个错误，除非指定`--allow-empty-message`。"

#. type: Plain text
#: en/git-commit.txt:124
#, placeholders:'`--fixup=reword':'`--fixup=amend':'--only`':'--autosquash`', priority:280
msgid "`--fixup=reword:<commit>` is shorthand for `--fixup=amend:<commit> --only`. It creates an \"amend!\" commit with only a log message (ignoring any changes staged in the index). When squashed by `git rebase --autosquash`, it replaces the log message of `<commit>` without making any other changes."
msgstr "`--fixup=reword:<commit>`是`--fixup=amend:<commit>--only`的简写。它创建一个只有日志信息的 \"修正！\"提交（忽略索引中的任何修改）。当被`git rebase --autosquash`压制时，它会替换`<commit>`的日志信息而不做任何其他改动。"

#. type: Plain text
#: en/git-commit.txt:128
#, placeholders:'--autosquash`':'linkgit:git-rebase[1]', priority:280
msgid "Neither \"fixup!\" nor \"amend!\" commits change authorship of `<commit>` when applied by `git rebase --autosquash`. See linkgit:git-rebase[1] for details."
msgstr "当被 `git rebase --autosquash` 应用时，\"fixup!\"和 \"amend!\"提交都不会改变 `<commit>` 的作者身份。 详情见 linkgit:git-rebase[1]。"

#. type: Labeled list
#: en/git-commit.txt:129
#, no-wrap, placeholders:'--squash=', priority:280
msgid "--squash=<commit>"
msgstr "--squash=<提交>"

#. type: Plain text
#: en/git-commit.txt:135
#, placeholders:'--autosquash`':'`-m`':'`-c`':'`-C`':'`-F`':'linkgit:git-rebase[1]', priority:280
msgid "Construct a commit message for use with `rebase --autosquash`. The commit message subject line is taken from the specified commit with a prefix of \"squash! \". Can be used with additional commit message options (`-m`/`-c`/`-C`/`-F`). See linkgit:git-rebase[1] for details."
msgstr "构建一条提交信息，供`rebase --autosquash`使用。 提交信息的主题行取自指定的提交，前缀为 \"squash!\". 可以和其他提交信息选项（`-m`/`-c`/`-C`/`-F`）一起使用。详情见 linkgit:git-rebase[1]。"

#. type: Labeled list
#: en/git-commit.txt:136
#, ignore-same, no-wrap, priority:280
msgid "--reset-author"
msgstr "--reset-author"

#. type: Plain text
#: en/git-commit.txt:141
#, placeholders:'--amend', priority:280
msgid "When used with -C/-c/--amend options, or when committing after a conflicting cherry-pick, declare that the authorship of the resulting commit now belongs to the committer. This also renews the author timestamp."
msgstr "当与-C/-c/--amend选项一起使用时，或者当在一个冲突的cherry-pick之后提交时，声明所产生的提交的作者身份现在属于提交者。这也是对作者时间戳的更新。"

#. type: Labeled list
#: en/git-commit.txt:142 en/git-status.txt:28 en/git-symbolic-ref.txt:45
#, ignore-same, no-wrap, priority:280
msgid "--short"
msgstr "--short"

#. type: Plain text
#: en/git-commit.txt:145
#, placeholders:'linkgit:git-status[1]':'`--dry-run`', priority:280
msgid "When doing a dry-run, give the output in the short-format. See linkgit:git-status[1] for details. Implies `--dry-run`."
msgstr "当做干运行的时候，以简短的形式给出输出。详见 linkgit:git-status[1]。意味着 `--dry-run`。"

#. type: Labeled list
#: en/git-commit.txt:146 en/git-status.txt:32
#, ignore-same, no-wrap, priority:280
msgid "--branch"
msgstr "--branch"

#. type: Plain text
#: en/git-commit.txt:148 en/git-status.txt:34
#, priority:280
msgid "Show the branch and tracking info even in short-format."
msgstr "即使在短文中也要显示分支和跟踪信息。"

#. type: Plain text
#: en/git-commit.txt:153
#, placeholders:'linkgit:git-status[1]':'`--dry-run`', priority:280
msgid "When doing a dry-run, give the output in a porcelain-ready format. See linkgit:git-status[1] for details. Implies `--dry-run`."
msgstr "在做干运行的时候，要把输出结果以可瓷器的格式给出。详见 linkgit:git-status[1]。意味着 `--dry-run`。"

#. type: Labeled list
#: en/git-commit.txt:154 en/git-describe.txt:88 en/git-ls-tree.txt:52 en/git-status.txt:47
#, ignore-same, no-wrap, priority:280
msgid "--long"
msgstr "--long"

# ERROR: `--dry-run` not found in translation
#. type: Plain text
#: en/git-commit.txt:157
#, placeholders:'`--dry-run`', priority:280
msgid "When doing a dry-run, give the output in the long-format. Implies `--dry-run`."
msgstr "当做干运行时，以长格式给出输出。 意味着 `--dry-run`。"

#. type: Labeled list
#: en/git-commit.txt:159 en/git-config.txt:230 en/git-grep.txt:177
#, ignore-same, no-wrap, priority:280
msgid "--null"
msgstr "--null"

#. type: Plain text
#: en/git-commit.txt:166
#, placeholders:'`--porcelain`':'`-z`':'core.quotePath':'linkgit:git-config[1]', priority:280
msgid "When showing `short` or `porcelain` status output, print the filename verbatim and terminate the entries with NUL, instead of LF. If no format is given, implies the `--porcelain` output format. Without the `-z` option, filenames with \"unusual\" characters are quoted as explained for the configuration variable `core.quotePath` (see linkgit:git-config[1])."
msgstr "当显示 \"short \"或 \"porcelain \"状态输出时，逐字打印文件名，用NUL而不是LF来结束条目。 如果没有给出格式，就意味着是`--porcelain`输出格式。 如果没有`-z`选项，带有 \"不寻常 \"字符的文件名将被引用，正如对配置变量`core.quotePath`的解释（见linkgit:git-config[1]）。"

#. type: Labeled list
#: en/git-commit.txt:168 en/git-merge.txt:87 en/git-notes.txt:148 en/git-tag.txt:175
#, no-wrap, placeholders:'--file=', priority:280
msgid "--file=<file>"
msgstr "--file=<文件>"

#. type: Plain text
#: en/git-commit.txt:171
#, priority:280
msgid "Take the commit message from the given file. Use '-' to read the message from the standard input."
msgstr "从给定文件中获取提交信息。 使用'-'可以从标准输入中读取信息。"

#. type: Labeled list
#: en/git-commit.txt:172
#, no-wrap, placeholders:'--author=', priority:280
msgid "--author=<author>"
msgstr "--author=<提交人>"

#. type: Plain text
#: en/git-commit.txt:178
#, placeholders:'--all':'--author=', priority:280
msgid "Override the commit author. Specify an explicit author using the standard `A U Thor <author@example.com>` format. Otherwise <author> is assumed to be a pattern and is used to search for an existing commit by that author (i.e. rev-list --all -i --author=<author>); the commit author is then copied from the first such commit found."
msgstr "覆盖提交者。使用标准的`A U Thor <author@example.com>`格式指定一个明确的作者。否则，<author>将被假定为一个模式，用于搜索该作者的现有提交（即 rev-list --all -i --author=<author>）；然后从找到的第一个此类提交中复制提交作者。"

#. type: Labeled list
#: en/git-commit.txt:179
#, no-wrap, placeholders:'--date=', priority:280
msgid "--date=<date>"
msgstr "--date=<日期>"

#. type: Plain text
#: en/git-commit.txt:181
#, priority:280
msgid "Override the author date used in the commit."
msgstr "覆盖提交中使用的作者日期。"

#. type: Labeled list
#: en/git-commit.txt:182 en/git-merge.txt:70 en/git-notes.txt:138 en/git-svn.txt:468 en/git-tag.txt:166
#, no-wrap, priority:280
msgid "-m <msg>"
msgstr "-m <消息>"

#. type: Labeled list
#: en/git-commit.txt:183 en/git-notes.txt:139 en/git-svn.txt:469 en/git-tag.txt:167
#, no-wrap, placeholders:'--message=', priority:280
msgid "--message=<msg>"
msgstr "--message=<msg>"

#. type: Plain text
#: en/git-commit.txt:187
#, placeholders:'`-m`', priority:280
msgid "Use the given <msg> as the commit message. If multiple `-m` options are given, their values are concatenated as separate paragraphs."
msgstr "使用给定的<msg>作为提交信息。 如果给定了多个`-m`选项，它们的值会作为单独的段落串联起来。"

# ERROR: `-m` not found in translation
# ERROR: `-c` not found in translation
# ERROR: `-C` not found in translation
# ERROR: `-F` not found in translation
#. type: Plain text
#: en/git-commit.txt:189
#, placeholders:'`-m`':'`-c`':'`-C`':'`-F`', priority:280
msgid "The `-m` option is mutually exclusive with `-c`, `-C`, and `-F`."
msgstr "`-m` 选项与 `-c`、`-C` 和 `-F` 相互排斥。"

#. type: Labeled list
#: en/git-commit.txt:190
#, no-wrap, priority:280
msgid "-t <file>"
msgstr "-t <文件>"

#. type: Labeled list
#: en/git-commit.txt:191
#, no-wrap, placeholders:'--template=', priority:280
msgid "--template=<file>"
msgstr "--template=<文件>"

#. type: Plain text
#: en/git-commit.txt:200
#, placeholders:'commit.template':'`-m`':'`-F`', priority:280
msgid "When editing the commit message, start the editor with the contents in the given file. The `commit.template` configuration variable is often used to give this option implicitly to the command. This mechanism can be used by projects that want to guide participants with some hints on what to write in the message in what order. If the user exits the editor without editing the message, the commit is aborted. This has no effect when a message is given by other means, e.g. with the `-m` or `-F` options."
msgstr "编辑提交信息时，以给定文件中的内容启动编辑器。 `commit.template`配置变量经常被用来给命令隐含这个选项。 这个机制可以被那些希望通过一些提示来指导参与者在消息中以何种顺序书写的项目所使用。 如果用户在没有编辑消息的情况下退出编辑器，提交将被中止。 当用其他方式给出消息时，例如用`-m`或`-F`选项时，这没有影响。"

#. type: Labeled list
#: en/git-commit.txt:203
#, no-wrap, placeholders:'--trailer', priority:280
msgid "--trailer <token>[(=|:)<value>]"
msgstr "--trailer <令牌>[(=|:)<值>]"

#. type: Plain text
#: en/git-commit.txt:213
#, placeholders:'--trailer':'--trailer':'linkgit:git-interpret-trailers[1]', priority:280
msgid "Specify a (<token>, <value>) pair that should be applied as a trailer. (e.g. `git commit --trailer \"Signed-off-by:C O Mitter \\ <committer@example.com>\" --trailer \"Helped-by:C O Mitter \\ <committer@example.com>\"` will add the \"Signed-off-by\" trailer and the \"Helped-by\" trailer to the commit message.) The `trailer.*` configuration variables (linkgit:git-interpret-trailers[1]) can be used to define if a duplicated trailer is omitted, where in the run of trailers each trailer would appear, and other details."
msgstr "指定一个（<token>, <value>）对，应该作为拖车应用。(例如，`git commit --trailer \"Signed-off-by:C O Mitter / <committer@example.com>\" --trailer \"Helped-by:C O Mitter / <committer@example.com>\"`将在提交信息中加入 \"Signed-off-by \"预告片和 \"Helped-by \"预告片。) `trailer.*`配置变量（linkgit:git-interpret-trailers[1]）可以用来定义是否省略重复的拖车，每个拖车会出现在拖车运行的哪个位置，以及其他细节。"

#. type: Labeled list
#: en/git-commit.txt:215 en/git-push.txt:422 en/merge-options.txt:135
#, ignore-same, no-wrap, priority:280
msgid "--[no-]verify"
msgstr "--[no-]verify"

#. type: Plain text
#: en/git-commit.txt:219
#, placeholders:'`--no-verify`':'`-n`':'linkgit:githooks[5]', priority:280
msgid "By default, the pre-commit and commit-msg hooks are run. When any of `--no-verify` or `-n` is given, these are bypassed. See also linkgit:githooks[5]."
msgstr "默认情况下，会运行 pre-commit 和 commit-msg 钩子。当给出任何 `--no-verify` 或 `-n` 时，这些都会被绕过。参见链接 linkgit:githooks[5]。"

#. type: Plain text
#: en/git-commit.txt:225
#, priority:280
msgid "Usually recording a commit that has the exact same tree as its sole parent commit is a mistake, and the command prevents you from making such a commit. This option bypasses the safety, and is primarily for use by foreign SCM interface scripts."
msgstr "通常情况下，记录一个与唯一的父级提交的树完全相同的提交是一个错误，该命令会阻止你做出这样的提交。 这个选项绕过了安全问题，主要供国外SCM接口脚本使用。"

#. type: Plain text
#: en/git-commit.txt:231
#, placeholders:'--allow-empty':'linkgit:git-commit-tree[1]', priority:280
msgid "Like --allow-empty this command is primarily for use by foreign SCM interface scripts. It allows you to create a commit with an empty commit message without using plumbing commands like linkgit:git-commit-tree[1]."
msgstr "和 --allow-empty 一样，这条命令主要是给国外的 SCM 接口脚本使用的。它允许你在不使用linkgit:git-commit-tree[1]等管道命令的情况下创建一个带有空提交信息的提交。"

#. type: Plain text
#: en/git-commit.txt:236
#, priority:280
msgid "This option determines how the supplied commit message should be cleaned up before committing. The '<mode>' can be `strip`, `whitespace`, `verbatim`, `scissors` or `default`."
msgstr "这个选项决定了在提交前如何清理所提供的提交信息。 <mode>可以是`strip`、`whitespace`、`verbatim`、`scissors`或`default`。"

#. type: Labeled list
#: en/git-commit.txt:238
#, no-wrap, priority:280
msgid "strip"
msgstr "剥离"

#. type: Plain text
#: en/git-commit.txt:241
#, priority:280
msgid "Strip leading and trailing empty lines, trailing whitespace, commentary and collapse consecutive empty lines."
msgstr "剥离前面和后面的空行、后面的空白、注释和折叠的连续空行。"

#. type: Labeled list
#: en/git-commit.txt:241
#, no-wrap, priority:280
msgid "whitespace"
msgstr "空白字符"

#. type: Plain text
#: en/git-commit.txt:243
#, priority:280
msgid "Same as `strip` except #commentary is not removed."
msgstr "与 \"strip \"相同，只是#commentary不被删除。"

#. type: Labeled list
#: en/git-commit.txt:243
#, no-wrap, priority:280
msgid "verbatim"
msgstr "逐字逐句"

#. type: Plain text
#: en/git-commit.txt:245
#, priority:280
msgid "Do not change the message at all."
msgstr "完全不要改变信息。"

#. type: Labeled list
#: en/git-commit.txt:245
#, no-wrap, priority:280
msgid "scissors"
msgstr "scissors"

#. type: Plain text
#: en/git-commit.txt:249
#, placeholders:'core.commentChar', priority:280
msgid "Same as `whitespace` except that everything from (and including) the line found below is truncated, if the message is to be edited. \"`#`\" can be customized with core.commentChar."
msgstr "与 \"whitespace \"相同，但如果要编辑信息，从下面一行开始（包括）的所有内容都被截断。 \"`#`\"可以用core.commentChar自定义。"

#. type: Plain text
#: en/git-commit.txt:251
#, no-wrap, placeholders:'------------------------':'------------------------', priority:280
msgid "# ------------------------ >8 ------------------------\n"
msgstr "# ------------------------ >8 ------------------------\n"

#. type: Plain text
#: en/git-commit.txt:255
#, priority:280
msgid "Same as `strip` if the message is to be edited. Otherwise `whitespace`."
msgstr "如果要编辑信息，与`strip`相同。 否则就是`whitespace'。"

#. type: Plain text
#: en/git-commit.txt:259
#, placeholders:'commit.cleanup':'linkgit:git-config[1]', priority:280
msgid "The default can be changed by the `commit.cleanup` configuration variable (see linkgit:git-config[1])."
msgstr "默认值可以通过 `commit.cleanup` 配置变量来改变（见linkgit:git-config[1]）。"

#. type: Plain text
#: en/git-commit.txt:266
#, placeholders:'`-F`':'`-m`':'`-C`', priority:280
msgid "The message taken from file with `-F`, command line with `-m`, and from commit object with `-C` are usually used as the commit log message unmodified. This option lets you further edit the message taken from these sources."
msgstr "用`-F`从文件中获取的信息，用`-m`从命令行中获取的信息，以及用`-C`从提交对象中获取的信息，通常都是未经修改的提交日志信息。这个选项可以让你进一步编辑从这些来源获取的信息。"

#. type: Labeled list
#: en/git-commit.txt:267 en/git-revert.txt:66 en/merge-options.txt:20
#, ignore-same, no-wrap, priority:280
msgid "--no-edit"
msgstr "--no-edit"

#. type: Plain text
#: en/git-commit.txt:271
#, placeholders:'--amend':'--no-edit`', priority:280
msgid "Use the selected commit message without launching an editor. For example, `git commit --amend --no-edit` amends a commit without changing its commit message."
msgstr "使用选定的提交信息而不启动编辑器。 例如，`git commit --amend --no-edit`修改一个提交，但不改变其提交信息。"

#. type: Labeled list
#: en/git-commit.txt:272
#, ignore-same, no-wrap, priority:280
msgid "--amend"
msgstr "--amend"

#. type: Plain text
#: en/git-commit.txt:282
#, placeholders:'`-i`':'`-o`':'`-m`':'`-F`':'`-c`':'`--reset-author`', priority:280
msgid "Replace the tip of the current branch by creating a new commit. The recorded tree is prepared as usual (including the effect of the `-i` and `-o` options and explicit pathspec), and the message from the original commit is used as the starting point, instead of an empty message, when no other message is specified from the command line via options such as `-m`, `-F`, `-c`, etc. The new commit has the same parents and author as the current one (the `--reset-author` option can countermand this)."
msgstr "通过创建一个新的提交来替换当前分支的顶端。记录的树像往常一样准备（包括`-i`和`-o`选项和显式pathspec的效果），当命令行没有通过`-m`、`-F`、`-c`等选项指定其他信息时，原始提交的信息会被用作起点，而不是空信息。 新的提交与当前的提交具有相同的父辈和作者（`--reset-author`选项可以反驳）。"

#. type: Plain text
#: en/git-commit.txt:285
#, priority:280
msgid "It is a rough equivalent for:"
msgstr "它大致相当于："

#. type: delimited block -
#: en/git-commit.txt:289
#, ignore-ellipsis, no-wrap, placeholders:'--soft':'HEAD':'ORIG_HEAD', priority:280
msgid ""
"\t$ git reset --soft HEAD^\n"
"\t$ ... do something else to come up with the right tree ...\n"
"\t$ git commit -c ORIG_HEAD\n"
msgstr ""
"\t$ git reset --soft HEAD^\n"
"\t$ ... 另辟蹊径，找到正确的目录树中 ...\n"
"\t$ git commit -c ORIG_HEAD\n"

#. type: Plain text
#: en/git-commit.txt:292
#, priority:280
msgid "but can be used to amend a merge commit."
msgstr "但可以用来修改合并提交。"

#. type: Plain text
#: en/git-commit.txt:297
#, placeholders:'linkgit:git-rebase[1]', priority:280
msgid "You should understand the implications of rewriting history if you amend a commit that has already been published. (See the \"RECOVERING FROM UPSTREAM REBASE\" section in linkgit:git-rebase[1].)"
msgstr "如果你修改了一个已经发布的提交，你应该明白重写历史的意义。 参见 linkgit:git-rebase[1]中的 “从上游仓库重建中恢复” 部分。）"

#. type: Labeled list
#: en/git-commit.txt:298
#, ignore-same, no-wrap, priority:280
msgid "--no-post-rewrite"
msgstr "--no-post-rewrite"

#. type: Plain text
#: en/git-commit.txt:300
#, priority:280
msgid "Bypass the post-rewrite hook."
msgstr "绕过post-rewrite钩子。"

#. type: Labeled list
#: en/git-commit.txt:302
#, ignore-same, no-wrap, priority:280
msgid "--include"
msgstr "--include"

#. type: Plain text
#: en/git-commit.txt:307
#, priority:280
msgid "Before making a commit out of staged contents so far, stage the contents of paths given on the command line as well. This is usually not what you want unless you are concluding a conflicted merge."
msgstr "在对迄今为止的暂存内容进行提交之前，对命令行上给出的路径内容也进行暂存。 这通常不是你想要的，除非你正在结束一个冲突的合并。"

#. type: Labeled list
#: en/git-commit.txt:309
#, ignore-same, no-wrap, priority:280
msgid "--only"
msgstr "--only"

#. type: Plain text
#: en/git-commit.txt:321
#, placeholders:'`--amend`':'`--allow-empty`', priority:280
msgid "Make a commit by taking the updated working tree contents of the paths specified on the command line, disregarding any contents that have been staged for other paths. This is the default mode of operation of 'git commit' if any paths are given on the command line, in which case this option can be omitted. If this option is specified together with `--amend`, then no paths need to be specified, which can be used to amend the last commit without committing changes that have already been staged. If used together with `--allow-empty` paths are also not required, and an empty commit will be created."
msgstr "在提交时，只取命令行上指定的工作树的最新内容，而不考虑其他路径上的缓存内容。这是'git commit'的默认操作模式，如果在命令行中给出了任何路径，在这种情况下可以省略该选项。 如果该选项与`--amend`一起指定，则不需要指定路径，可以用来修改最后的提交，而不提交已经被暂存的修改。如果和`--allow-empty`一起使用，也不需要指定路径，将创建一个空的提交。"

#. type: Labeled list
#: en/git-commit.txt:335 en/git-status.txt:58
#, no-wrap, priority:280
msgid "-u[<mode>]"
msgstr "-u[<模式>]"

#. type: Labeled list
#: en/git-commit.txt:336 en/git-status.txt:59
#, no-wrap, placeholders:'--untracked-files', priority:280
msgid "--untracked-files[=<mode>]"
msgstr "--untracked-files[=<模式>]"

#. type: Plain text
#: en/git-commit.txt:338 en/git-status.txt:61
#, priority:280
msgid "Show untracked files."
msgstr "显示未追踪文件。"

#. type: Plain text
#: en/git-commit.txt:343
#, priority:280
msgid "The mode parameter is optional (defaults to 'all'), and is used to specify the handling of untracked files; when -u is not used, the default is 'normal', i.e. show untracked files and directories."
msgstr "模式参数是可选的（默认为 \"所有\"），用于指定对未追踪文件的处理；当没有使用-u时，默认为 \"正常\"，即显示未追踪的文件和目录。"

#. type: Plain text
#: en/git-commit.txt:345 en/git-status.txt:68 en/git-status.txt:110
#, priority:280
msgid "The possible options are:"
msgstr "可选项："

#. type: Plain text
#: en/git-commit.txt:347
#, priority:280
msgid "'no' - Show no untracked files"
msgstr "'no' - 显示未被追踪的文件"

#. type: Plain text
#: en/git-commit.txt:348
#, priority:280
msgid "'normal' - Shows untracked files and directories"
msgstr "'normal' - 显示未被追踪的文件和目录"

#. type: Plain text
#: en/git-commit.txt:349 en/git-status.txt:72
#, priority:280
msgid "'all' - Also shows individual files in untracked directories."
msgstr "'all' - 也显示未被追踪的目录中的单个文件。"

#. type: Plain text
#: en/git-commit.txt:352 en/git-status.txt:85
#, placeholders:'status.showUntrackedFiles':'linkgit:git-config[1]', priority:280
msgid "The default can be changed using the status.showUntrackedFiles configuration variable documented in linkgit:git-config[1]."
msgstr "默认值可以用linkgit:git-config[1]中记载的 status.showUntrackedFiles 配置变量来改变。"

#. type: Plain text
#: en/git-commit.txt:364
#, placeholders:'HEAD':'commit.verbose':'linkgit:git-config[1]', priority:280
msgid "Show unified diff between the HEAD commit and what would be committed at the bottom of the commit message template to help the user describe the commit by reminding what changes the commit has. Note that this diff output doesn't have its lines prefixed with '#'. This diff will not be a part of the commit message. See the `commit.verbose` configuration variable in linkgit:git-config[1]."
msgstr "在提交信息模板的底部显示HEAD提交和将要提交的内容之间的统一差异，通过提醒提交有哪些变化来帮助用户描述提交。 请注意，这个差异输出的行数不会以'#'为前缀。这个差异不会成为提交信息的一部分。参见 linkgit:git-config[1] 中的 `commit.verbose` 配置变量。"

#. type: Plain text
#: en/git-commit.txt:368
#, priority:280
msgid "If specified twice, show in addition the unified diff between what would be committed and the worktree files, i.e. the unstaged changes to tracked files."
msgstr "如果指定了两次，则另外显示将被提交的文件和工作树文件之间的统一差异，即对已跟踪文件的非阶段性修改。"

#. type: Plain text
#: en/git-commit.txt:372
#, priority:280
msgid "Suppress commit summary message."
msgstr "抑制提交摘要信息。"

#. type: Plain text
#: en/git-commit.txt:377
#, priority:280
msgid "Do not create a commit, but show a list of paths that are to be committed, paths with local changes that will be left uncommitted and paths that are untracked."
msgstr "不创建提交，但显示要提交的路径列表，有局部改动的路径将不提交，以及未跟踪的路径。"

#. type: Labeled list
#: en/git-commit.txt:378
#, ignore-same, no-wrap, priority:280
msgid "--status"
msgstr "--status"

#. type: Plain text
#: en/git-commit.txt:383
#, placeholders:'linkgit:git-status[1]':'commit.status', priority:280
msgid "Include the output of linkgit:git-status[1] in the commit message template when using an editor to prepare the commit message. Defaults to on, but can be used to override configuration variable commit.status."
msgstr "在使用编辑器准备提交信息时，在提交信息模板中包含linkgit:git-status[1]的输出。 默认为开，但可以用来覆盖配置变量commit.status。"

#. type: Labeled list
#: en/git-commit.txt:384
#, ignore-same, no-wrap, priority:280
msgid "--no-status"
msgstr "--no-status"

#. type: Plain text
#: en/git-commit.txt:388
#, placeholders:'linkgit:git-status[1]', priority:280
msgid "Do not include the output of linkgit:git-status[1] in the commit message template when using an editor to prepare the default commit message."
msgstr "当使用编辑器准备默认的提交信息时，不要将 linkgit:git-status[1] 的输出包含在提交信息模板中。"

#. type: Plain text
#: en/git-commit.txt:406
#, priority:280
msgid "When pathspec is given on the command line, commit the contents of the files that match the pathspec without recording the changes already added to the index. The contents of these files are also staged for the next commit on top of what have been staged before."
msgstr "当命令行中给出pathspec时，提交符合pathspec的文件内容，而不记录已经添加到索引中的修改。这些文件的内容也会在下一次提交时在之前的文件基础上被暂存。"

#. type: Plain text
#: en/git-commit.txt:422
#, placeholders:'--staged', priority:280
msgid "When recording your own work, the contents of modified files in your working tree are temporarily stored to a staging area called the \"index\" with 'git add'. A file can be reverted back, only in the index but not in the working tree, to that of the last commit with `git restore --staged <file>`, which effectively reverts 'git add' and prevents the changes to this file from participating in the next commit. After building the state to be committed incrementally with these commands, `git commit` (without any pathname parameter) is used to record what has been staged so far. This is the most basic form of the command. An example:"
msgstr "在记录自己的工作时，工作树中修改过的文件的内容会通过 'git add' 暂时存储到一个叫做 \"index\" 的暂存区域。 一个文件可以用 `git restore --staged <问价>` 恢复到上次提交时的状态，只是在索引中，而不是在工作目录树中，这实际上是恢复了'git add'，并阻止这个文件的修改参与下一次提交。 在用这些命令建立了要增量提交的状态后，`git commit`（没有任何路径名参数）被用来记录到目前为止已经分阶段提交的内容。 这是该命令最基本的形式。例如："

#. type: delimited block -
#: en/git-commit.txt:428
#, no-wrap, priority:280
msgid ""
"$ edit hello.c\n"
"$ git rm goodbye.c\n"
"$ git add hello.c\n"
"$ git commit\n"
msgstr ""
"$ edit hello.c\n"
"$ git rm goodbye.c\n"
"$ git add hello.c\n"
"$ git commit\n"

#. type: Plain text
#: en/git-commit.txt:436
#, priority:280
msgid "Instead of staging files after each individual change, you can tell `git commit` to notice the changes to the files whose contents are tracked in your working tree and do corresponding `git add` and `git rm` for you. That is, this example does the same as the earlier example if there is no other change in your working tree:"
msgstr "你可以告诉`git commit`注意到工作树中内容被跟踪的文件的变化，并为你做相应的 `git add` 和 `git rm`，而不是在每个单独的变化后暂存文件。 也就是说，如果你的工作目录树中没有其他变化，这个例子的做法与前面的例子相同："

#. type: delimited block -
#: en/git-commit.txt:441
#, no-wrap, priority:280
msgid ""
"$ edit hello.c\n"
"$ rm goodbye.c\n"
"$ git commit -a\n"
msgstr ""
"$ edit hello.c\n"
"$ rm goodbye.c\n"
"$ git commit -a\n"

#. type: Plain text
#: en/git-commit.txt:446
#, priority:280
msgid "The command `git commit -a` first looks at your working tree, notices that you have modified hello.c and removed goodbye.c, and performs necessary `git add` and `git rm` for you."
msgstr "命令`git commit -a`首先查看你的工作树，注意到你修改了hello.c并删除了goodbye.c，并为你执行必要的`git add`和`git rm`。"

#. type: Plain text
#: en/git-commit.txt:451
#, priority:280
msgid "After staging changes to many files, you can alter the order the changes are recorded in, by giving pathnames to `git commit`. When pathnames are given, the command makes a commit that only records the changes made to the named paths:"
msgstr "在对许多文件进行分期修改后，你可以通过给 `git commit` 提供路径名来改变修改的顺序。 给出路径名后，该命令就会进行提交，只记录对指定路径的修改："

#. type: delimited block -
#: en/git-commit.txt:457
#, no-wrap, priority:280
msgid ""
"$ edit hello.c hello.h\n"
"$ git add hello.c hello.h\n"
"$ edit Makefile\n"
"$ git commit Makefile\n"
msgstr ""
"$ edit hello.c hello.h\n"
"$ git add hello.c hello.h\n"
"$ edit Makefile\n"
"$ git commit Makefile\n"

#. type: Plain text
#: en/git-commit.txt:464
#, priority:280
msgid "This makes a commit that records the modification to `Makefile`. The changes staged for `hello.c` and `hello.h` are not included in the resulting commit. However, their changes are not lost -- they are still staged and merely held back. After the above sequence, if you do:"
msgstr "这将产生一个提交，记录对 `Makefile` 的修改。 为 `hello.c` 和 `hello.h` 所做的修改不包括在这次提交中。 然而，它们的修改并没有丢失——它们仍然被暂存，只是被保留了下来。 在上述顺序之后，如果你："

#. type: delimited block -
#: en/git-commit.txt:467 en/git-commit.txt:493
#, no-wrap, priority:280
msgid "$ git commit\n"
msgstr "$ git commit\n"

#. type: Plain text
#: en/git-commit.txt:471
#, priority:280
msgid "this second commit would record the changes to `hello.c` and `hello.h` as expected."
msgstr "第二次提交会记录下对`hello.c`和`hello.h`的修改，正如预期的那样。"

#. type: Plain text
#: en/git-commit.txt:479
#, priority:280
msgid "After a merge (initiated by 'git merge' or 'git pull') stops because of conflicts, cleanly merged paths are already staged to be committed for you, and paths that conflicted are left in unmerged state. You would have to first check which paths are conflicting with 'git status' and after fixing them manually in your working tree, you would stage the result as usual with 'git add':"
msgstr "在一次合并（由 'git merge' 或 'git pull' 发起）因冲突而停止后，干净的合并路径已经被分阶段提交给你了，而发生冲突的路径则被留在未合并状态。 你必须先用 'git status' 检查哪些路径有冲突，然后在工作目录树上手动修复它们，再像往常一样用 'git add' 将结果分阶段："

#. type: delimited block -
#: en/git-commit.txt:485
#, no-wrap, priority:280
msgid ""
"$ git status | grep unmerged\n"
"unmerged: hello.c\n"
"$ edit hello.c\n"
"$ git add hello.c\n"
msgstr ""
"$ git status | grep unmerged\n"
"unmerged: hello.c\n"
"$ edit hello.c\n"
"$ git add hello.c\n"

#. type: Plain text
#: en/git-commit.txt:490
#, placeholders:'git ls-files', priority:280
msgid "After resolving conflicts and staging the result, `git ls-files -u` would stop mentioning the conflicted path. When you are done, run `git commit` to finally record the merge:"
msgstr "在解决冲突并将结果归档后，`git ls-files -u` 将不再提及冲突的路径。 完成后，运行 `git commit` 来最终记录合并的结果："

#. type: Plain text
#: en/git-commit.txt:501
#, placeholders:'`-a`':'`-i`', priority:280
msgid "As with the case to record your own changes, you can use `-a` option to save typing. One difference is that during a merge resolution, you cannot use `git commit` with pathnames to alter the order the changes are committed, because the merge should be recorded as a single commit. In fact, the command refuses to run when given pathnames (but see `-i` option)."
msgstr "和记录自己的修改的情况一样，你可以使用`-a`选项来节省打字。 有一点不同的是，在解决合并的过程中，你不能使用`git commit`和路径名来改变修改的提交顺序，因为合并应该被记录为一次提交。 事实上，该命令在给定路径名时拒绝运行（但见`-i`选项）。"

#. type: Title -
#: en/git-commit.txt:503
#, no-wrap, priority:280
msgid "COMMIT INFORMATION"
msgstr "承诺信息"

#. type: Plain text
#: en/git-commit.txt:507
#, priority:280
msgid "Author and committer information is taken from the following environment variables, if set:"
msgstr "作者和提交者的信息取自以下环境变量，如果设置了的话："

#. type: Plain text
#: en/git-commit.txt:514
#, no-wrap, placeholders:'GIT_AUTHOR_NAME':'GIT_AUTHOR_EMAIL':'GIT_AUTHOR_DATE':'GIT_COMMITTER_NAME':'GIT_COMMITTER_EMAIL':'GIT_COMMITTER_DATE', priority:280
msgid ""
"\tGIT_AUTHOR_NAME\n"
"\tGIT_AUTHOR_EMAIL\n"
"\tGIT_AUTHOR_DATE\n"
"\tGIT_COMMITTER_NAME\n"
"\tGIT_COMMITTER_EMAIL\n"
"\tGIT_COMMITTER_DATE\n"
msgstr ""
"\tGIT_AUTHOR_NAME\n"
"\tGIT_AUTHOR_EMAIL\n"
"\tGIT_AUTHOR_DATE\n"
"\tGIT_COMMITTER_NAME\n"
"\tGIT_COMMITTER_EMAIL\n"
"\tGIT_COMMITTER_DATE\n"

#. type: Plain text
#: en/git-commit.txt:516
#, priority:280
msgid "(nb \"<\", \">\" and \"\\n\"s are stripped)"
msgstr "（注意\"<\"、\">\" 和 \"\\n\" 被剥离）"

#. type: Plain text
#: en/git-commit.txt:522
#, placeholders:'credential.username':'linkgit:git-config[1]', priority:280
msgid "The author and committer names are by convention some form of a personal name (that is, the name by which other humans refer to you), although Git does not enforce or require any particular form. Arbitrary Unicode may be used, subject to the constraints listed above. This name has no effect on authentication; for that, see the `credential.username` variable in linkgit:git-config[1]."
msgstr "作者和提交者的名字按惯例是某种形式的人名（也就是其他人称呼你的名字），尽管Git并不强制或要求任何特定的形式。可以使用任意的Unicode，但要遵守上述的限制。这个名字对认证没有影响；关于这一点，请看linkgit:git-config[1]中的`credential.username`变量。"

#. type: Plain text
#: en/git-commit.txt:529
#, placeholders:'user.name':'user.email', priority:280
msgid "In case (some of) these environment variables are not set, the information is taken from the configuration items `user.name` and `user.email`, or, if not present, the environment variable EMAIL, or, if that is not set, system user name and the hostname used for outgoing mail (taken from `/etc/mailname` and falling back to the fully qualified hostname when that file does not exist)."
msgstr "如果这些环境变量（其中一些）没有设置，信息来自配置项`user.name`和`user.email`，或者，如果不存在，环境变量EMAIL，或者，如果没有设置，系统用户名和用于发送邮件的主机名（取自`/etc/mailname`，如果该文件不存在，则返回到完全合格的主机名）。"

#. type: Plain text
#: en/git-commit.txt:533
#, placeholders:'author.name':'committer.name':'user.name':'user.email', priority:280
msgid "The `author.name` and `committer.name` and their corresponding email options override `user.name` and `user.email` if set and are overridden themselves by the environment variables."
msgstr "如果设置了`author.name`和`committer.name`及其相应的email选项，将覆盖`user.name`和`user.email`，并由环境变量自行覆盖。"

#. type: Plain text
#: en/git-commit.txt:536
#, placeholders:'user.name':'user.email', priority:280
msgid "The typical usage is to set just the `user.name` and `user.email` variables; the other options are provided for more complex use cases."
msgstr "典型的用法是只设置 \"user.name \"和 \"user.email \"变量；其他选项是为更复杂的使用情况提供的。"

#. type: Plain text
#: en/git-commit.txt:550
#, placeholders:'linkgit:git-format-patch[1]', priority:280
msgid "Though not required, it's a good idea to begin the commit message with a single short (no more than 50 characters) line summarizing the change, followed by a blank line and then a more thorough description. The text up to the first blank line in a commit message is treated as the commit title, and that title is used throughout Git. For example, linkgit:git-format-patch[1] turns a commit into email, and it uses the title on the Subject line and the rest of the commit in the body."
msgstr "虽然不是必须的，但在提交信息的开头用一行简短（不多于 50 个字符）的文字来概括修改内容是个好主意，接下来是空白行，然后是更详尽的描述。 提交信息中第一个空行之前的文字被视为提交标题，并且该标题在整个 Git 中使用。 例如，linkgit:git-format-patch[1] 把提交变成了电子邮件，它在主题行使用标题，在正文中使用提交的其他内容。"

#. type: Title -
#: en/git-commit.txt:554
#, no-wrap, priority:280
msgid "ENVIRONMENT AND CONFIGURATION VARIABLES"
msgstr "环境和配置变量"

#. type: Plain text
#: en/git-commit.txt:559
#, placeholders:'GIT_EDITOR':'core.editor':'linkgit:git-var[1]', priority:280
msgid "The editor used to edit the commit log message will be chosen from the `GIT_EDITOR` environment variable, the core.editor configuration variable, the `VISUAL` environment variable, or the `EDITOR` environment variable (in that order). See linkgit:git-var[1] for details."
msgstr "用于编辑提交日志信息的编辑器将从`GIT_EDITOR`环境变量、core.editor配置变量、`VISUAL`环境变量或`EDITOR`环境变量中选择（按顺序）。 详情见linkgit:git-var[1]。"

#. type: Plain text
#: en/git-commit.txt:569
#, placeholders:'linkgit:githooks[5]', priority:280
msgid "This command can run `commit-msg`, `prepare-commit-msg`, `pre-commit`, `post-commit` and `post-rewrite` hooks. See linkgit:githooks[5] for more information."
msgstr "这个命令可以运行`commit-msg`、`prepare-commit-msg`、`pre-commit`、`post-commit`和`post-rewrite`钩子。 更多信息见linkgit:githooks[5]。"

#. type: Labeled list
#: en/git-commit.txt:573
#, no-wrap, placeholders:'$GIT_DIR':'COMMIT_EDITMSG', priority:280
msgid "`$GIT_DIR/COMMIT_EDITMSG`"
msgstr "`$GIT_DIR/COMMIT_EDITMSG`"

#. type: Plain text
#: en/git-commit.txt:579
#, priority:280
msgid "This file contains the commit message of a commit in progress. If `git commit` exits due to an error before creating a commit, any commit message that has been provided by the user (e.g., in an editor session) will be available in this file, but will be overwritten by the next invocation of `git commit`."
msgstr "该文件包含正在进行的提交的提交信息。 如果`git commit`在创建提交前因错误而退出，任何由用户提供的提交信息（例如在编辑器会话中）都会在此文件中出现，但会被下次调用`git commit`时覆盖。"

#. type: Plain text
#: en/git-commit.txt:587
#, ignore-same, priority:280
msgid "linkgit:git-add[1], linkgit:git-rm[1], linkgit:git-mv[1], linkgit:git-merge[1], linkgit:git-commit-tree[1]"
msgstr "linkgit:git-add[1], linkgit:git-rm[1], linkgit:git-mv[1], linkgit:git-merge[1], linkgit:git-commit-tree[1]"

#. type: Title =
#: en/git-config.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-config(1)"
msgstr "git-config(1)"

#. type: Plain text
#: en/git-config.txt:7
#, placeholders:'git-config', priority:100
msgid "git-config - Get and set repository or global options"
msgstr "git-config - 获取和设置仓库或全局选项"

#. type: Plain text
#: en/git-config.txt:27
#, no-wrap, placeholders:'[--type=':'[--fixed-value]':'[--show-origin]':'[--show-scope]':'--null]':'[--type=':'--add':'[--type=':'[--fixed-value]':'--replace-all':'[--type=':'[--show-origin]':'[--show-scope]':'--null]':'[--fixed-value]':'--get':'[--type=':'[--show-origin]':'[--show-scope]':'--null]':'[--fixed-value]':'--get-all':'[--type=':'[--show-origin]':'[--show-scope]':'--null]':'[--fixed-value]':'[--name-only]':'--get-regexp':'[--type=':'--null]':'--get-urlmatch':'[--fixed-value]':'--unset':'[--fixed-value]':'--unset-all':'--rename-section':'--remove-section':'[--show-origin]':'[--show-scope]':'--null]':'[--name-only]':'--list':'--get-color':'--get-colorbool':'--edit', priority:100
msgid ""
"'git config' [<file-option>] [--type=<type>] [--fixed-value] [--show-origin] [--show-scope] [-z|--null] <name> [<value> [<value-pattern>]]\n"
"'git config' [<file-option>] [--type=<type>] --add <name> <value>\n"
"'git config' [<file-option>] [--type=<type>] [--fixed-value] --replace-all <name> <value> [<value-pattern>]\n"
"'git config' [<file-option>] [--type=<type>] [--show-origin] [--show-scope] [-z|--null] [--fixed-value] --get <name> [<value-pattern>]\n"
"'git config' [<file-option>] [--type=<type>] [--show-origin] [--show-scope] [-z|--null] [--fixed-value] --get-all <name> [<value-pattern>]\n"
"'git config' [<file-option>] [--type=<type>] [--show-origin] [--show-scope] [-z|--null] [--fixed-value] [--name-only] --get-regexp <name-regex> [<value-pattern>]\n"
"'git config' [<file-option>] [--type=<type>] [-z|--null] --get-urlmatch <name> <URL>\n"
"'git config' [<file-option>] [--fixed-value] --unset <name> [<value-pattern>]\n"
"'git config' [<file-option>] [--fixed-value] --unset-all <name> [<value-pattern>]\n"
"'git config' [<file-option>] --rename-section <old-name> <new-name>\n"
"'git config' [<file-option>] --remove-section <name>\n"
"'git config' [<file-option>] [--show-origin] [--show-scope] [-z|--null] [--name-only] -l | --list\n"
"'git config' [<file-option>] --get-color <name> [<default>]\n"
"'git config' [<file-option>] --get-colorbool <name> [<stdout-is-tty>]\n"
"'git config' [<file-option>] -e | --edit\n"
msgstr ""
"'git config' [<文件选项>] [--type=<类型>] [--fixed-value] [--show-origin] [--show-scope] [-z|--null] <名称> [<值> [<值模式>]]\n"
"'git config' [<文件选项>] [--type=<类型>] --add <名称> <值>\n"
"'git config' [<文件选项>] [--type=<类型>] [--fixed-value] --replace-all <名称> <值> [<值模式>]\n"
"'git config' [<文件选项>] [--type=<类型>] [--show-origin] [--show-scope] [-z|--null] [--fixed-value] --get <名称> [<值模式>]\n"
"'git config' [<文件选项>] [--type=<类型>] [--show-origin] [--show-scope] [-z|--null] [--fixed-value] --get-all <名称> [<值模式>]\n"
"'git config' [<文件选项>] [--type=<类型>] [--show-origin] [--show-scope] [-z|--null] [--fixed-value] [--name-only] --get-regexp <名称正则表达式> [<值模式>]\n"
"'git config' [<文件选项>] [--type=<类型>] [-z|--null] --get-urlmatch <名称> <地址>\n"
"'git config' [<文件选项>] [--fixed-value] --unset <名称> [<值模式>]\n"
"'git config' [<文件选项>] [--fixed-value] --unset-all <名称> [<值模式>]\n"
"'git config' [<文件选项>] --rename-section <旧名称> <新名称>\n"
"'git config' [<文件选项>] --remove-section <名称>\n"
"'git config' [<文件选项>] [--show-origin] [--show-scope] [-z|--null] [--name-only] -l | --list\n"
"'git config' [<文件选项>] --get-color <名称> [<默认>]\n"
"'git config' [<文件选项>] --get-colorbool <名称> [<stdout-is-tty>]\n"
"'git config' [<文件选项>] -e | --edit\n"

#. type: Plain text
#: en/git-config.txt:33
#, priority:100
msgid "You can query/set/replace/unset options with this command. The name is actually the section and the key separated by a dot, and the value will be escaped."
msgstr "你可以用这个命令查询/设置/替换/取消选项。名称(name)实际上是用点隔开的节和键，值(value)会被转义。"

#. type: Plain text
#: en/git-config.txt:43
#, placeholders:'`--add`':'`--fixed-value`':'<<EXAMPLES>>':'`--fixed-value`', priority:100
msgid "Multiple lines can be added to an option by using the `--add` option. If you want to update or unset an option which can occur on multiple lines, a `value-pattern` (which is an extended regular expression, unless the `--fixed-value` option is given) needs to be given. Only the existing values that match the pattern are updated or unset. If you want to handle the lines that do *not* match the pattern, just prepend a single exclamation mark in front (see also <<EXAMPLES>>), but note that this only works when the `--fixed-value` option is not in use."
msgstr "通过使用 `--add` 选项，可以为一个选项添加多行。 如果你想更新或取消一个可以出现在多行的选项，需要给出一个 `value-pattern` （除非给出 `--fixed-value` 选项，否则这是一个扩展的正则表达式）。 只有符合该模式的现有值被更新或取消设置。 如果你想处理不符合模式的行，只需在前面加上一个感叹号（参见<<EXAMPLES>>），但注意这只在没有使用 `--fixed-value` 选项时有效。"

#. type: Plain text
#: en/git-config.txt:48
#, placeholders:'`--type=':'`--type=':'`--type`':'`--no-type`', priority:100
msgid "The `--type=<type>` option instructs 'git config' to ensure that incoming and outgoing values are canonicalize-able under the given <type>. If no `--type=<type>` is given, no canonicalization will be performed. Callers may unset an existing `--type` specifier with `--no-type`."
msgstr "`--type=<类型>` 选项指示 'git config' 确保传入和传出的值在给定的 <类型> 下是可以被规范化的。 如果没有给定 `--type=<类型>`，将不执行规范化。调用者可以用 `--no-type` 选项取消现有 `--type` 选项的指定。"

# ERROR: `--system` not found in translation
# ERROR: `--global` not found in translation
# ERROR: `--worktree` not found in translation
#. type: Plain text
#: en/git-config.txt:54
#, placeholders:'`--system`':'`--global`':'`--local`':'`--worktree`':'`--file':'<<FILES>>', priority:100
msgid "When reading, the values are read from the system, global and repository local configuration files by default, and options `--system`, `--global`, `--local`, `--worktree` and `--file <filename>` can be used to tell the command to read from only that location (see <<FILES>>)."
msgstr "读取配置时，默认从系统、全局和资源库的本地配置文件中读取数值，选项 `--system`、`--global`、`--local`、`--worktree` 和 `--file<文件名>` 可以用来告诉命令只从选定的位置读取（见<<FILES>>）。"

# ERROR: `--system` not found in translation
# ERROR: `--global` not found in translation
# ERROR: `--worktree` not found in translation
# ERROR: `--local` not found in translation
#. type: Plain text
#: en/git-config.txt:60
#, placeholders:'`--system`':'`--global`':'`--worktree`':'`--file':'`--local`', priority:100
msgid "When writing, the new value is written to the repository local configuration file by default, and options `--system`, `--global`, `--worktree`, `--file <filename>` can be used to tell the command to write to that location (you can say `--local` but that is the default)."
msgstr "写入时，新值默认写入仓库的本地配置文件，选项 `--system`、`--global`、`--worktree`、`--file <文件名>` 可以用来告诉命令写到那个位置（你可以给出 `--local` 选项，但是默认选项就是本地(local)）。"

#. type: Plain text
#: en/git-config.txt:63
#, priority:100
msgid "This command will fail with non-zero status upon error. Some exit codes are:"
msgstr "该命令出错时将以非零状态失败。 以下是一些退出代码："

#. type: Plain text
#: en/git-config.txt:65
#, priority:100
msgid "The section or key is invalid (ret=1),"
msgstr "该节或键无效（退出代码为1），"

#. type: Plain text
#: en/git-config.txt:66
#, priority:100
msgid "no section or name was provided (ret=2),"
msgstr "没有提供节或键（退出值为2），"

#. type: Plain text
#: en/git-config.txt:67
#, priority:100
msgid "the config file is invalid (ret=3),"
msgstr "配置文件无效（退出代码为3），"

#. type: Plain text
#: en/git-config.txt:68
#, priority:100
msgid "the config file cannot be written (ret=4),"
msgstr "配置文件无法写入（退出代码为4），"

#. type: Plain text
#: en/git-config.txt:69
#, priority:100
msgid "you try to unset an option which does not exist (ret=5),"
msgstr "你试图取消一个不存在的选项（退出代码为5），"

#. type: Plain text
#: en/git-config.txt:70
#, priority:100
msgid "you try to unset/set an option for which multiple lines match (ret=5), or"
msgstr "你试图取消/设置一个多行匹配的选项（退出代码为5），或"

#. type: Plain text
#: en/git-config.txt:71
#, priority:100
msgid "you try to use an invalid regexp (ret=6)."
msgstr "试图使用一个无效的正则表达式（退出代码为6）。"

#. type: Plain text
#: en/git-config.txt:73
#, priority:100
msgid "On success, the command returns the exit code 0."
msgstr "执行成功时，该命令返回退出代码0。"

#. type: Plain text
#: en/git-config.txt:76
#, placeholders:'--config`', priority:100
msgid "A list of all available configuration variables can be obtained using the `git help --config` command."
msgstr "所有可用配置变量的列表可以通过 `git help --config` 命令获取。"

#. type: Labeled list
#: en/git-config.txt:81
#, ignore-same, no-wrap, priority:100
msgid "--replace-all"
msgstr "--replace-all"

#. type: Plain text
#: en/git-config.txt:84
#, priority:100
msgid "Default behavior is to replace at most one line. This replaces all lines matching the key (and optionally the `value-pattern`)."
msgstr "默认行为是最多替换一行。这将会替换所有与键（以及可选的 `value-pattern` ）匹配的行。"

#. type: Labeled list
#: en/git-config.txt:85 en/git-update-index.txt:44
#, ignore-same, no-wrap, priority:100
msgid "--add"
msgstr "--add"

#. type: Plain text
#: en/git-config.txt:89
#, placeholders:'`--replace-all`', priority:100
msgid "Adds a new line to the option without altering any existing values. This is the same as providing '^$' as the `value-pattern` in `--replace-all`."
msgstr "不改变任何现有的值的情况下，在选项中增加一个新的行。 这与在 `--replace-all` 选项中提供 '^$' 作为 `value-pattern` 是一样的。"

#. type: Labeled list
#: en/git-config.txt:90
#, ignore-same, no-wrap, priority:100
msgid "--get"
msgstr "--get"

#. type: Plain text
#: en/git-config.txt:94
#, priority:100
msgid "Get the value for a given key (optionally filtered by a regex matching the value). Returns error code 1 if the key was not found and the last value if multiple key values were found."
msgstr "获取一个给定的键的值（可选择通过与该值相匹配的正则表达式进行过滤）。如果没有找到键值，返回错误代码1；如果找到多个键值，则返回最后一个值。"

#. type: Labeled list
#: en/git-config.txt:95
#, ignore-same, no-wrap, priority:100
msgid "--get-all"
msgstr "--get-all"

#. type: Plain text
#: en/git-config.txt:97
#, priority:100
msgid "Like get, but returns all values for a multi-valued key."
msgstr "和 --get 选项类似，但是该选项会返回一个多值键的所有值。"

#. type: Labeled list
#: en/git-config.txt:98
#, ignore-same, no-wrap, priority:100
msgid "--get-regexp"
msgstr "--get-regexp"

#. type: Plain text
#: en/git-config.txt:104
#, placeholders:'--get-all', priority:100
msgid "Like --get-all, but interprets the name as a regular expression and writes out the key names. Regular expression matching is currently case-sensitive and done against a canonicalized version of the key in which section and variable names are lowercased, but subsection names are not."
msgstr "像 --get-all 选项一样，但是用正则表达式作为名称，并写出键名。 正则表达式匹配目前是区分大小写的，并且是针对一个规范化的键的版本进行的，其中节 (section) 和变量名称是小写的，但子节名称不是小写的。"

#. type: Labeled list
#: en/git-config.txt:105
#, no-wrap, placeholders:'--get-urlmatch', priority:100
msgid "--get-urlmatch <name> <URL>"
msgstr "--get-urlmatch <名称> <URL>"

#. type: Plain text
#: en/git-config.txt:112
#, priority:100
msgid "When given a two-part <name> as <section>.<key>, the value for <section>.<URL>.<key> whose <URL> part matches the best to the given URL is returned (if no such key exists, the value for <section>.<key> is used as a fallback). When given just the <section> as name, do so for all the keys in the section and list them. Returns error code 1 if no value is found."
msgstr "当给定一个由两部分组成的名称 section.key 时，返回 section.<URL>.key 的值，其 <URL> 部分是给定的最相匹配的 URL（如果没有这样的键存在，section.key 的值将作为备用值）。 当只给出 section 的名称时，对 section 中的所有 key 进行处理，并将其列出。 如果没有找到值，返回错误代码 1（section: 节，key:键；在配置文件中是这样的 [section] key=value）。"

#. type: Labeled list
#: en/git-config.txt:113
#, ignore-same, no-wrap, priority:100
msgid "--global"
msgstr "--global"

#. type: Plain text
#: en/git-config.txt:118
#, placeholders:'$XDG_CONFIG_HOME', priority:100
msgid "For writing options: write to global `~/.gitconfig` file rather than the repository `.git/config`, write to `$XDG_CONFIG_HOME/git/config` file if this file exists and the `~/.gitconfig` file doesn't."
msgstr "对于写入选项：写入全局的 `~/.gitconfig` 文件而不是仓库的 `.git/config` 文件，如果该文件存在而 `~/.gitconfig` 文件不存在，则写入 `$XDG_CONFIG_HOME/git/config` 文件。"

#. type: Plain text
#: en/git-config.txt:121
#, placeholders:'$XDG_CONFIG_HOME', priority:100
msgid "For reading options: read only from global `~/.gitconfig` and from `$XDG_CONFIG_HOME/git/config` rather than from all available files."
msgstr "对于读取选项：只从全局的 `~/.gitconfig` 和 `$XDG_CONFIG_HOME/git/config` 中读取，而不是从所有可用文件中读取。"

#. type: Plain text
#: en/git-config.txt:123 en/git-config.txt:133 en/git-config.txt:142 en/git-config.txt:161 en/git-config.txt:409
#, placeholders:'<<FILES>>', priority:100
msgid "See also <<FILES>>."
msgstr "另请参见<<FILES>>。"

#. type: Labeled list
#: en/git-config.txt:124
#, ignore-same, no-wrap, priority:100
msgid "--system"
msgstr "--system"

#. type: Plain text
#: en/git-config.txt:128
#, placeholders:'$(prefix)', priority:100
msgid "For writing options: write to system-wide `$(prefix)/etc/gitconfig` rather than the repository `.git/config`."
msgstr "对于写选项：写到系统范围内的 `$(prefix)/etc/gitconfig` 文件中，而不是仓库中的 `.git/config` 文件。"

#. type: Plain text
#: en/git-config.txt:131
#, placeholders:'$(prefix)', priority:100
msgid "For reading options: read only from system-wide `$(prefix)/etc/gitconfig` rather than from all available files."
msgstr "对于读取选项：只从系统范围内的 `$(prefix)/etc/gitconfig` 读取，而不是从所有可用文件中读取。"

#. type: Plain text
#: en/git-config.txt:137
#, priority:100
msgid "For writing options: write to the repository `.git/config` file. This is the default behavior."
msgstr "对于写选项：写到仓库的 `.git/config` 文件中。 这是默认行为。"

#. type: Plain text
#: en/git-config.txt:140
#, priority:100
msgid "For reading options: read only from the repository `.git/config` rather than from all available files."
msgstr "对于读取选项：只从仓库 `.git/config` 文件中读取，而不是从所有可用文件中读取。"

#. type: Labeled list
#: en/git-config.txt:143 en/git-restore.txt:59
#, ignore-same, no-wrap, priority:280
msgid "--worktree"
msgstr "--worktree"

#. type: Plain text
#: en/git-config.txt:151
#, placeholders:'`--local`':'$GIT_DIR':'config.worktree':'extensions.worktreeConfig':'`--local`':'$GIT_DIR':'$GIT_COMMON_DIR':'$GIT_DIR':'linkgit:git-worktree[1]':'extensions.worktreeConfig', priority:100
msgid "Similar to `--local` except that `$GIT_DIR/config.worktree` is read from or written to if `extensions.worktreeConfig` is enabled. If not it's the same as `--local`. Note that `$GIT_DIR` is equal to `$GIT_COMMON_DIR` for the main working tree, but is of the form `$GIT_DIR/worktrees/<id>/` for other working trees. See linkgit:git-worktree[1] to learn how to enable `extensions.worktreeConfig`."
msgstr "与 `--local` 选项类似，只是如果启用了 `extensions.worktreeConfig` ，则从 `$GIT_DIR/config.worktree` 读取或写入。如果没有，则与 `--local` 选项行为相同。注意，对于主工作区， `$GIT_DIR` 等于 `$GIT_COMMON_DIR`，但对于其他工作区，它的形式是 `$GIT_DIR/worktrees/<id>/`。了解如何启用 `extensions.worktreeConfig`，参见 linkgit:git-worktree[1] 。"

#. type: Labeled list
#: en/git-config.txt:152
#, no-wrap, priority:100
msgid "-f <config-file>"
msgstr "-f <配置文件>"

#. type: Labeled list
#: en/git-config.txt:153
#, no-wrap, placeholders:'--file', priority:100
msgid "--file <config-file>"
msgstr "--file <配置文件>"

#. type: Plain text
#: en/git-config.txt:156
#, priority:100
msgid "For writing options: write to the specified file rather than the repository `.git/config`."
msgstr "对于写入选项：写到指定的文件，而不是仓库 `.git/config` 文件。"

#. type: Plain text
#: en/git-config.txt:159
#, priority:100
msgid "For reading options: read only from the specified file rather than from all available files."
msgstr "对于读取选项：只从指定的文件而不是从所有可用的文件中读取。"

#. type: Labeled list
#: en/git-config.txt:162
#, no-wrap, placeholders:'--blob', priority:100
msgid "--blob <blob>"
msgstr "--blob <blob>"

#. type: Plain text
#: en/git-config.txt:168
#, placeholders:'`--file`':'linkgit:gitrevisions[7]', priority:100
msgid "Similar to `--file` but use the given blob instead of a file. E.g. you can use 'master:.gitmodules' to read values from the file '.gitmodules' in the master branch. See \"SPECIFYING REVISIONS\" section in linkgit:gitrevisions[7] for a more complete list of ways to spell blob names."
msgstr "类似于 `--file` 选项，但使用指定的二进制对象而不是文件。例如，你可以使用 'master:.gitmodules' 来读取主分支中 '.gitmodules' 文件中的值。参见 linkgit:gitrevisions[7] 中的 “指定的修正” 部分，以获得更完整的二进制对象名称拼写方式。"

#. type: Labeled list
#: en/git-config.txt:169
#, ignore-same, no-wrap, priority:100
msgid "--remove-section"
msgstr "--remove-section"

#. type: Plain text
#: en/git-config.txt:171
#, priority:100
msgid "Remove the given section from the configuration file."
msgstr "从配置文件中删除了该节。"

#. type: Labeled list
#: en/git-config.txt:172
#, ignore-same, no-wrap, priority:100
msgid "--rename-section"
msgstr "--rename-section"

#. type: Plain text
#: en/git-config.txt:174
#, priority:100
msgid "Rename the given section to a new name."
msgstr "将给定的节重命名为一个新的名称。"

#. type: Labeled list
#: en/git-config.txt:175
#, ignore-same, no-wrap, priority:100
msgid "--unset"
msgstr "--unset"

#. type: Plain text
#: en/git-config.txt:177
#, priority:100
msgid "Remove the line matching the key from config file."
msgstr "从配置文件中删除与该键匹配的行。"

#. type: Labeled list
#: en/git-config.txt:178
#, ignore-same, no-wrap, priority:100
msgid "--unset-all"
msgstr "--unset-all"

#. type: Plain text
#: en/git-config.txt:180
#, priority:100
msgid "Remove all lines matching the key from config file."
msgstr "从配置文件中删除所有匹配该键的行。"

#. type: Plain text
#: en/git-config.txt:184
#, priority:100
msgid "List all variables set in config file, along with their values."
msgstr "列出配置文件中设置的所有变量，以及它们的值。"

#. type: Labeled list
#: en/git-config.txt:185
#, ignore-same, no-wrap, priority:100
msgid "--fixed-value"
msgstr "--fixed-value"

#. type: Plain text
#: en/git-config.txt:190
#, priority:100
msgid "When used with the `value-pattern` argument, treat `value-pattern` as an exact string instead of a regular expression. This will restrict the name/value pairs that are matched to only those where the value is exactly equal to the `value-pattern`."
msgstr "当与 `value-pattern` 参数一起使用时，将 `value-pattern` 视为精确的字符串，而不是正则表达式。这将使得被匹配的名称/值对只有那些值与 `value-pattern` 完全相等的名称/值对。"

#. type: Labeled list
#: en/git-config.txt:191
#, no-wrap, placeholders:'--type', priority:100
msgid "--type <type>"
msgstr "--type <类型>"

#. type: Plain text
#: en/git-config.txt:195
#, priority:100
msgid "'git config' will ensure that any input or output is valid under the given type constraint(s), and will canonicalize outgoing values in `<type>`'s canonical form."
msgstr "'git config' 将确保任何输入或输出在给定的类型约束下是有效的，并将以 `<类型>` 的规范形式将输出的值规范化。"

#. type: Plain text
#: en/git-config.txt:197
#, priority:100
msgid "Valid `<type>`'s include:"
msgstr "有效的 `<类型>` 包括："

#. type: Plain text
#: en/git-config.txt:199
#, priority:100
msgid "'bool': canonicalize values as either \"true\" or \"false\"."
msgstr "'bool'：将数值规范化为 \"true\" 或 \"false\"。"

#. type: Plain text
#: en/git-config.txt:202
#, priority:100
msgid "'int': canonicalize values as simple decimal numbers. An optional suffix of 'k', 'm', or 'g' will cause the value to be multiplied by 1024, 1048576, or 1073741824 upon input."
msgstr "'int'：将数值规范化为简单的十进制数字。可选的后缀 'k'、'm' 或 'g'将导致输入的值被乘以 1024、1048576 或 1073741824。"

#. type: Plain text
#: en/git-config.txt:204
#, priority:100
msgid "'bool-or-int': canonicalize according to either 'bool' or 'int', as described above."
msgstr "'bool-or-int'：如上所述，根据 'bool '或 'int' 进行规范化。"

#. type: Plain text
#: en/git-config.txt:208
#, placeholders:'$HOME':'section.variable', priority:100
msgid "'path': canonicalize by expanding a leading `~` to the value of `$HOME` and `~user` to the home directory for the specified user. This specifier has no effect when setting the value (but you can use `git config section.variable ~/` from the command line to let your shell do the expansion.)"
msgstr "'path'：通过在 `$HOME` 和 `~user` 的值中添加前导 `~` 来规范化指定用户的主目录。在设置值时，该说明符没有任何作用（但可以在命令行中使用 `git config section.variable ~/` 让 shell 进行扩展）。"

#. type: Plain text
#: en/git-config.txt:210
#, priority:100
msgid "'expiry-date': canonicalize by converting from a fixed or relative date-string to a timestamp. This specifier has no effect when setting the value."
msgstr "'expiry-date'：通过将固定或相对日期字符串转换为时间戳进行规范化。这个指定符在设置值时没有影响。"

#. type: Plain text
#: en/git-config.txt:214
#, priority:100
msgid "'color': When getting a value, canonicalize by converting to an ANSI color escape sequence. When setting a value, a sanity-check is performed to ensure that the given value is canonicalize-able as an ANSI color, but it is written as-is."
msgstr "'color'： 当获得一个值时，通过转换为 ANSI 颜色转义序列进行规范化。当设置一个值时，会进行理智检查，以确保给定的值可以被规范化为 ANSI 颜色，但它会按原样写入。"

#. type: Labeled list
#: en/git-config.txt:216
#, ignore-same, no-wrap, priority:100
msgid "--bool"
msgstr "--bool"

#. type: Labeled list
#: en/git-config.txt:217
#, ignore-same, no-wrap, priority:100
msgid "--int"
msgstr "--int"

#. type: Labeled list
#: en/git-config.txt:218
#, ignore-same, no-wrap, priority:100
msgid "--bool-or-int"
msgstr "--bool-or-int"

#. type: Labeled list
#: en/git-config.txt:219 en/git-hash-object.txt:41
#, ignore-same, no-wrap, priority:100
msgid "--path"
msgstr "--path"

#. type: Labeled list
#: en/git-config.txt:220
#, ignore-same, no-wrap, priority:100
msgid "--expiry-date"
msgstr "--expiry-date"

#. type: Plain text
#: en/git-config.txt:223
#, placeholders:'`--type`', priority:100
msgid "Historical options for selecting a type specifier. Prefer instead `--type` (see above)."
msgstr "选择类型指定器的历史选项。更倾向于选择 `--type`（见上文）。"

#. type: Labeled list
#: en/git-config.txt:224
#, ignore-same, no-wrap, priority:100
msgid "--no-type"
msgstr "--no-type"

#. type: Plain text
#: en/git-config.txt:228
#, placeholders:'`--no-type`':'`--type=', priority:100
msgid "Un-sets the previously set type specifier (if one was previously set). This option requests that 'git config' not canonicalize the retrieved variable. `--no-type` has no effect without `--type=<type>` or `--<type>`."
msgstr "取消先前设置的类型指定器（如果先前有的话）。这个选项要求 'git config' 不对检索的变量进行规范化处理。 `--no-type` 在没有 `--type=<类型>` 或 `--<类型>` 选项的情况下没有作用。"

#. type: Plain text
#: en/git-config.txt:237
#, priority:100
msgid "For all options that output values and/or keys, always end values with the null character (instead of a newline). Use newline instead as a delimiter between key and value. This allows for secure parsing of the output without getting confused e.g. by values that contain line breaks."
msgstr "对于所有输出值和/或键的选项，总是用空字符（而不是换行）结束值。使用换行符作为键和值之间的分隔符。这样可以安全地解析输出，而不会被包含换行的值所混淆。"

#. type: Plain text
#: en/git-config.txt:241
#, placeholders:'`--list`':'`--get-regexp`', priority:100
msgid "Output only the names of config variables for `--list` or `--get-regexp`."
msgstr "只输出 `--list` 或 `--get-regexp` 的配置变量的名称。"

#. type: Labeled list
#: en/git-config.txt:242
#, ignore-same, no-wrap, priority:100
msgid "--show-origin"
msgstr "--show-origin"

#. type: Plain text
#: en/git-config.txt:247
#, priority:100
msgid "Augment the output of all queried config options with the origin type (file, standard input, blob, command line) and the actual origin (config file path, ref, or blob id if applicable)."
msgstr "用来源类型（文件、标准输入、blob、命令行）和实际来源（配置文件路径、引用或 blob id（如适用））对所有查询到的配置选项的输出进行扩充。"

#. type: Labeled list
#: en/git-config.txt:248
#, ignore-same, no-wrap, priority:100
msgid "--show-scope"
msgstr "--show-scope"

#. type: Plain text
#: en/git-config.txt:252
#, placeholders:'`--show-origin`', priority:100
msgid "Similar to `--show-origin` in that it augments the output of all queried config options with the scope of that value (worktree, local, global, system, command)."
msgstr "类似于 `--show-origin` 选项，它用该值的范围（工作区、本地、全局、系统、命令）来增加所有查询的配置选项的输出。"

#. type: Labeled list
#: en/git-config.txt:253
#, no-wrap, placeholders:'--get-colorbool', priority:100
msgid "--get-colorbool <name> [<stdout-is-tty>]"
msgstr "--get-colorbool <名称> [<stdout-is-tty>]"

#. type: Plain text
#: en/git-config.txt:263
#, placeholders:'color.diff':'color.ui', priority:100
msgid "Find the color setting for `<name>` (e.g. `color.diff`) and output \"true\" or \"false\". `<stdout-is-tty>` should be either \"true\" or \"false\", and is taken into account when configuration says \"auto\". If `<stdout-is-tty>` is missing, then checks the standard output of the command itself, and exits with status 0 if color is to be used, or exits with status 1 otherwise. When the color setting for `name` is undefined, the command uses `color.ui` as fallback."
msgstr "找到 `<名称>` 的颜色设置（例如 `color.diff`），并输出 \"true\" 或 \"false\"。 `<stdout-is-tty>` 应该是 \"true\" 或 \"false\"，同样考虑配置为 \"auto\" 的情况。 如果 `<stdout-is-tty>` 缺失，则检查命令本身的标准输出，如果要使用颜色则以状态 0 退出，否则以状态 1 退出。 当 `名称` 的颜色设置未被定义时，该命令使用 `color.ui` 作为回退（stdout 是 \"standard output\" 的缩写，而 tty 是 \"teletypewriter\" 的缩写，通常指的是终端或控制台。）。"

#. type: Labeled list
#: en/git-config.txt:264
#, no-wrap, placeholders:'--get-color', priority:100
msgid "--get-color <name> [<default>]"
msgstr "--get-color <名称> [<默认值>]"

#. type: Plain text
#: en/git-config.txt:270
#, placeholders:'color.diff.new', priority:100
msgid "Find the color configured for `name` (e.g. `color.diff.new`) and output it as the ANSI color escape sequence to the standard output. The optional `default` parameter is used instead, if there is no color configured for `name`."
msgstr "找到为 `名称` 配置的颜色（例如：`color.diff.new`），并将其作为 ANSI 颜色转义序列输出到标准输出。 如果没有为 `名称` 配置的颜色，则使用可选的 `默认值` 参数来代替。"

#. type: Plain text
#: en/git-config.txt:274
#, placeholders:'`--type=color':'[--default=':'`--get-color`':'`--get-color`':'`--type=color`', priority:100
msgid "`--type=color [--default=<default>]` is preferred over `--get-color` (but note that `--get-color` will omit the trailing newline printed by `--type=color`)."
msgstr "`--type=color [--default=<默认>]` 比 `--get-color` 更受欢迎（但注意 `--get-color` 会省略 `--type=color` 打印的尾部换行）。"

#. type: Plain text
#: en/git-config.txt:279
#, placeholders:'`--system`':'`--global`', priority:100
msgid "Opens an editor to modify the specified config file; either `--system`, `--global`, or repository (default)."
msgstr "打开一个编辑器来修改指定的配置文件；可以是 `--system`，`--global`，也可以是仓库（默认）。"

#. type: Labeled list
#: en/git-config.txt:280
#, ignore-same, no-wrap, priority:100
msgid "--[no-]includes"
msgstr "--[no-]includes"

#. type: Plain text
#: en/git-config.txt:285
#, placeholders:'`--file`':'`--global`', priority:100
msgid "Respect `include.*` directives in config files when looking up values. Defaults to `off` when a specific file is given (e.g., using `--file`, `--global`, etc) and `on` when searching all config files."
msgstr "在查找数值时尊重配置文件中的 `include.*` 指令。当给出一个特定的文件时，默认为 `off`（例如，使用 `--file`、`--global` 等），当搜索所有配置文件时，默认为 `on`。"

#. type: Labeled list
#: en/git-config.txt:286
#, no-wrap, placeholders:'--default', priority:100
msgid "--default <value>"
msgstr "--default <值>"

#. type: Plain text
#: en/git-config.txt:289
#, placeholders:'`--get`', priority:100
msgid "When using `--get`, and the requested variable is not found, behave as if <value> were the value assigned to the that variable."
msgstr "当使用 `--get` 时，如果没有找到所要求的变量，那么表现得就像是该变量被赋予了 <值> 这个值。"

#. type: Plain text
#: en/git-config.txt:295
#, placeholders:'pager.config':'`--list`':'`--get-', priority:100
msgid "`pager.config` is only respected when listing configuration, i.e., when using `--list` or any of the `--get-*` which may return multiple results. The default is to use a pager."
msgstr "`pager.config` 只在列出配置时被尊重，即在使用 `--list` 或任何可能返回多个结果的 `--get-*` 时。 默认情况下是使用 pager。"

#. type: Plain text
#: en/git-config.txt:302
#, priority:100
msgid "By default, 'git config' will read configuration options from multiple files:"
msgstr "默认情况下，'git config' 会从多个文件中读取配置选项："

#. type: Plain text
#: en/git-config.txt:303 en/git-config.txt:353
#, no-wrap, placeholders:'$(prefix)', priority:100
msgid "$(prefix)/etc/gitconfig"
msgstr "$(prefix)/etc/gitconfig"

#. type: Plain text
#: en/git-config.txt:305
#, priority:100
msgid "System-wide configuration file."
msgstr "全系统的配置文件。"

#. type: Plain text
#: en/git-config.txt:306 en/git-config.txt:356
#, no-wrap, placeholders:'$XDG_CONFIG_HOME', priority:100
msgid "$XDG_CONFIG_HOME/git/config"
msgstr "$XDG_CONFIG_HOME/git/config"

#. type: Plain text
#: en/git-config.txt:307 en/git-config.txt:358
#, no-wrap, priority:100
msgid "~/.gitconfig"
msgstr "~/.gitconfig"

#. type: Plain text
#: en/git-config.txt:311
#, placeholders:'XDG_CONFIG_HOME':'$HOME':'$XDG_CONFIG_HOME', priority:100
msgid "User-specific configuration files. When the XDG_CONFIG_HOME environment variable is not set or empty, $HOME/.config/ is used as $XDG_CONFIG_HOME."
msgstr "用户特定的配置文件。当 XDG_CONFIG_HOME 环境变量没有设置或为空时，$HOME/.config/ 被用作 $XDG_CONFIG_HOME。"

#. type: Plain text
#: en/git-config.txt:314
#, priority:100
msgid "These are also called \"global\" configuration files. If both files exist, both files are read in the order given above."
msgstr "这些文件也被称为 “全局” 配置文件。如果这两个文件都存在，就按照上面的顺序读取这两个文件。"

#. type: Plain text
#: en/git-config.txt:315 en/git-config.txt:361
#, no-wrap, placeholders:'$GIT_DIR', priority:100
msgid "$GIT_DIR/config"
msgstr "$GIT_DIR/config"

#. type: Plain text
#: en/git-config.txt:317
#, priority:100
msgid "Repository specific configuration file."
msgstr "仓库特定的配置文件。"

#. type: Plain text
#: en/git-config.txt:318 en/git-config.txt:364
#, no-wrap, placeholders:'$GIT_DIR':'config.worktree', priority:100
msgid "$GIT_DIR/config.worktree"
msgstr "$GIT_DIR/config.worktree"

#. type: Plain text
#: en/git-config.txt:321
#, placeholders:'extensions.worktreeConfig':'$GIT_DIR', priority:100
msgid "This is optional and is only searched when `extensions.worktreeConfig` is present in $GIT_DIR/config."
msgstr "这是可选的，只有当 $GIT_DIR/config 中存在 `extensions.worktreeConfig` 时才会被搜索到。"

#. type: Plain text
#: en/git-config.txt:324
#, placeholders:'`-c`':'linkgit:git[1]', priority:100
msgid "You may also provide additional configuration parameters when running any git command by using the `-c` option. See linkgit:git[1] for details."
msgstr "你也可以在运行任何 git 命令时通过使用 `-c` 选项提供额外的配置参数。详情见 linkgit:git[1]。"

#. type: Plain text
#: en/git-config.txt:330
#, priority:100
msgid "Options will be read from all of these files that are available. If the global or the system-wide configuration files are missing or unreadable they will be ignored. If the repository configuration file is missing or unreadable, 'git config' will exit with a non-zero error code. An error message is produced if the file is unreadable, but not if it is missing."
msgstr "选项将从所有这些可用的文件中读取。如果全局或全系统的配置文件丢失或不可读，它们将被忽略。如果版本库的配置文件丢失或不可读，'git config' 将以非零的错误代码退出。如果文件不可读，会产生一个错误信息，但如果文件丢失，则不会产生错误信息。"

#. type: Plain text
#: en/git-config.txt:334
#, priority:100
msgid "The files are read in the order given above, with last value found taking precedence over values read earlier. When multiple values are taken then all values of a key from all files will be used."
msgstr "文件是按照上述顺序读取的，最后发现的值优先于之前读取的值。 当有多个值时，将使用所有文件中某个键的所有值。"

#. type: Plain text
#: en/git-config.txt:338
#, placeholders:'`--replace-all`':'`--unset`', priority:100
msgid "By default, options are only written to the repository specific configuration file. Note that this also affects options like `--replace-all` and `--unset`. *'git config' will only ever change one file at a time*."
msgstr "默认情况下，选项只被写入版本库特定的配置文件中。请注意，这也会影响到 `--replace-all` 和 `--unset` 等选项。*'git config' 一次只能改变一个文件*。"

#. type: Plain text
#: en/git-config.txt:343
#, placeholders:'`--file`':'`--system`':'`--global`':'`--local`':'`--worktree`':'<<OPTIONS>>', priority:100
msgid "You can limit which configuration sources are read from or written to by specifying the path of a file with the `--file` option, or by specifying a configuration scope with `--system`, `--global`, `--local`, or `--worktree`. For more, see <<OPTIONS>> above."
msgstr "你可以通过使用 `--file` 选项指定文件路径，或者使用 `--system`、`--global`、`--local` 或 `--worktree` 指定配置范围，来限制从哪些配置源读取或写入。 更多内容请参见上面的 <<OPTIONS>>。"

#. type: Title -
#: en/git-config.txt:346
#, no-wrap, priority:100
msgid "SCOPES"
msgstr "范围"

#. type: Plain text
#: en/git-config.txt:350
#, priority:100
msgid "Each configuration source falls within a configuration scope. The scopes are:"
msgstr "每个配置源都属于一个配置范围。这些范围包括："

#. type: Labeled list
#: en/git-config.txt:351
#, no-wrap, priority:100
msgid "system"
msgstr "system"

#. type: Labeled list
#: en/git-config.txt:354
#, no-wrap, priority:100
msgid "global"
msgstr "global"

#. type: Labeled list
#: en/git-config.txt:359
#, no-wrap, priority:100
msgid "local"
msgstr "local"

#. type: Labeled list
#: en/git-config.txt:362
#, no-wrap, priority:100
msgid "worktree"
msgstr "工作区"

#. type: Labeled list
#: en/git-config.txt:365
#, no-wrap, priority:100
msgid "command"
msgstr "命令"

#. type: Plain text
#: en/git-config.txt:368
#, placeholders:'<<ENVIRONMENT>>', priority:100
msgid "GIT_CONFIG_{COUNT,KEY,VALUE} environment variables (see <<ENVIRONMENT>> below)"
msgstr "GIT_CONFIG_{COUNT,KEY,VALUE} 环境变量（见下文 <<ENVIRONMENT>>）"

#. type: Plain text
#: en/git-config.txt:370
#, placeholders:'`-c`', priority:100
msgid "the `-c` option"
msgstr "`-c` 选项"

#. type: Plain text
#: en/git-config.txt:373
#, placeholders:'`--system`':'`--global`':'`--local`':'`--worktree`', priority:100
msgid "With the exception of 'command', each scope corresponds to a command line option: `--system`, `--global`, `--local`, `--worktree`."
msgstr "除了 'command' 之外，每个范围都对应于一个命令行选项：`--system`、`--global`、`--local`、`--worktree`。"

#. type: Plain text
#: en/git-config.txt:378
#, placeholders:'<<OPTIONS>>', priority:100
msgid "When reading options, specifying a scope will only read options from the files within that scope. When writing options, specifying a scope will write to the files within that scope (instead of the repository specific configuration file). See <<OPTIONS>> above for a complete description."
msgstr "当读取选项时，指定一个范围将只从该范围内的文件读取选项。当写选项时，指定一个范围将写到该范围内的文件（而不是仓库的特定配置文件）。参见上面的<<OPTIONS>>以获得完整的描述。"

#. type: Plain text
#: en/git-config.txt:382
#, priority:100
msgid "Most configuration options are respected regardless of the scope it is defined in, but some options are only respected in certain scopes. See the respective option's documentation for the full details."
msgstr "大多数配置选项无论在哪个作用域中定义都会被尊重，但有些选项只在某些作用域中被尊重。完整的细节请参见相应选项的文档。"

#. type: Title ~
#: en/git-config.txt:384
#, no-wrap, priority:100
msgid "Protected configuration"
msgstr "受保护的配置"

#. type: Plain text
#: en/git-config.txt:389
#, priority:100
msgid "Protected configuration refers to the 'system', 'global', and 'command' scopes. For security reasons, certain options are only respected when they are specified in protected configuration, and ignored otherwise."
msgstr "受保护的配置指的是 'system'、'global' 和 'command' 范围。 出于安全考虑，某些选项只有在受保护的配置中指定时才会被尊重，否则会被忽略。"

#. type: Plain text
#: en/git-config.txt:394
#, priority:100
msgid "Git treats these scopes as if they are controlled by the user or a trusted administrator. This is because an attacker who controls these scopes can do substantial harm without using Git, so it is assumed that the user's environment protects these scopes against attackers."
msgstr "Git 将这些作用域视为由用户或可信的管理员控制。这是因为控制这些作用域的攻击者可以在不使用 Git 的情况下造成实质性的伤害，所以假定用户的环境会保护这些作用域免受攻击。"

#. type: Title -
#: en/git-config.txt:397 en/git-cvsserver.txt:308 en/git-daemon.txt:333 en/git-http-backend.txt:257 en/git-notes.txt:350 en/git-upload-pack.txt:51
#, no-wrap, priority:280
msgid "ENVIRONMENT"
msgstr "环境变量"

#. type: Labeled list
#: en/git-config.txt:399 en/git-var.txt:86
#, ignore-same, no-wrap, priority:100
msgid "GIT_CONFIG_GLOBAL"
msgstr "GIT_CONFIG_GLOBAL"

#. type: Labeled list
#: en/git-config.txt:400 en/git-var.txt:83
#, ignore-same, no-wrap, priority:100
msgid "GIT_CONFIG_SYSTEM"
msgstr "GIT_CONFIG_SYSTEM"

#. type: Plain text
#: en/git-config.txt:403
#, placeholders:'linkgit:git[1]', priority:100
msgid "Take the configuration from the given files instead from global or system-level configuration. See linkgit:git[1] for details."
msgstr "从给定的文件中获取配置，而不是从全局或系统级配置中获取。详情见 linkgit:git[1]。"

#. type: Labeled list
#: en/git-config.txt:404
#, ignore-same, no-wrap, priority:100
msgid "GIT_CONFIG_NOSYSTEM"
msgstr "GIT_CONFIG_NOSYSTEM"

#. type: Plain text
#: en/git-config.txt:407
#, placeholders:'$(prefix)':'linkgit:git[1]', priority:100
msgid "Whether to skip reading settings from the system-wide $(prefix)/etc/gitconfig file. See linkgit:git[1] for details."
msgstr "是否跳过从全系统 $(prefix)/etc/gitconfig 文件中读取设置。详见 linkgit:git[1]。"

#. type: Labeled list
#: en/git-config.txt:410
#, ignore-same, no-wrap, priority:100
msgid "GIT_CONFIG_COUNT"
msgstr "GIT_CONFIG_COUNT"

#. type: Labeled list
#: en/git-config.txt:411
#, no-wrap, priority:100
msgid "GIT_CONFIG_KEY_<n>"
msgstr "GIT_CONFIG_KEY_<n>"

#. type: Labeled list
#: en/git-config.txt:412
#, no-wrap, priority:100
msgid "GIT_CONFIG_VALUE_<n>"
msgstr "GIT_CONFIG_VALUE_<n>"

#. type: Plain text
#: en/git-config.txt:421
#, placeholders:'GIT_CONFIG_COUNT':'GIT_CONFIG_COUNT':'GIT_CONFIG_COUNT', priority:100
msgid "If GIT_CONFIG_COUNT is set to a positive number, all environment pairs GIT_CONFIG_KEY_<n> and GIT_CONFIG_VALUE_<n> up to that number will be added to the process's runtime configuration. The config pairs are zero-indexed. Any missing key or value is treated as an error. An empty GIT_CONFIG_COUNT is treated the same as GIT_CONFIG_COUNT=0, namely no pairs are processed. These environment variables will override values in configuration files, but will be overridden by any explicit options passed via `git -c`."
msgstr "如果 GIT_CONFIG_COUNT 被设置为一个正数，所有环境对 GIT_CONFIG_KEY_<n> 和 GIT_CONFIG_VALUE_<n> 到这个数字都将被添加到进程的运行时配置中。配置对是零索引的。任何缺失的键或值都被视为一个错误。空的 GIT_CONFIG_COUNT 与 GIT_CONFIG_COUNT=0 的处理方式相同，即不处理配置对。这些环境变量将覆盖配置文件中的值，但会被通过 `git -c` 传递的任何明确选项所覆盖。"

#. type: Plain text
#: en/git-config.txt:425
#, priority:100
msgid "This is useful for cases where you want to spawn multiple git commands with a common configuration but cannot depend on a configuration file, for example when writing scripts."
msgstr "这在你想用一个共同的配置催生多个 git 命令，但又不能依赖一个配置文件的情况下很有用，例如在编写脚本时。"

#. type: Labeled list
#: en/git-config.txt:426
#, ignore-same, no-wrap, priority:100
msgid "GIT_CONFIG"
msgstr "GIT_CONFIG"

#. type: Plain text
#: en/git-config.txt:432
#, placeholders:'`--file`':'GIT_CONFIG':'`--file`':'`--file`', priority:100
msgid "If no `--file` option is provided to `git config`, use the file given by `GIT_CONFIG` as if it were provided via `--file`. This variable has no effect on other Git commands, and is mostly for historical compatibility; there is generally no reason to use it instead of the `--file` option."
msgstr "如果 `git config` 没有提供 `--file` 选项，则命令会使用 `GIT_CONFIG` 提供的文件，就像通过 `--file` 选项提供的一样。这个变量对其他 Git 命令没有影响，主要是为了兼容历史版本；通常不会用它来代替 `--file` 选项。"

#. type: Plain text
#: en/git-config.txt:438
#, priority:100
msgid "Given a .git/config like this:"
msgstr "给出一个这样的 .git/config："

#. type: delimited block -
#: en/git-config.txt:445
#, no-wrap, priority:100
msgid ""
"#\n"
"# This is the config file, and\n"
"# a '#' or ';' character indicates\n"
"# a comment\n"
"#\n"
msgstr ""
"#\n"
"# 这就是配置文件，并且\n"
"# 一个'#' 或 ';' 字符表示\n"
"# 一个注释\n"
"#\n"

#. type: delimited block -
#: en/git-config.txt:450 en/git.txt:375
#, no-wrap, priority:100
msgid ""
"; core variables\n"
"[core]\n"
"\t; Don't trust file modes\n"
"\tfilemode = false\n"
msgstr ""
"; 核心变量\n"
"[core]\n"
"\t; 不信任文件模式\n"
"\tfilemode = false\n"

#. type: delimited block -
#: en/git-config.txt:455
#, no-wrap, priority:100
msgid ""
"; Our diff algorithm\n"
"[diff]\n"
"\texternal = /usr/local/bin/diff-wrapper\n"
"\trenames = true\n"
msgstr ""
"; 我们的差异算法\n"
"[diff]\n"
"\texternal = /usr/local/bin/diff-wrapper\n"
"\trename = true\n"

#. type: delimited block -
#: en/git-config.txt:460
#, no-wrap, placeholders:'kernel.org', priority:100
msgid ""
"; Proxy settings\n"
"[core]\n"
"\tgitproxy=proxy-command for kernel.org\n"
"\tgitproxy=default-proxy ; for all the rest\n"
msgstr ""
"; 代理设置\n"
"[core]\n"
"\tgitproxy=proxy-command for kernel.org\n"
"\tgitproxy=default-proxy ; 适用于其他所有网站\n"

#. type: delimited block -
#: en/git-config.txt:467
#, no-wrap, placeholders:'cookie.txt', priority:100
msgid ""
"; HTTP\n"
"[http]\n"
"\tsslVerify\n"
"[http \"https://weak.example.com\"]\n"
"\tsslVerify = false\n"
"\tcookieFile = /tmp/cookie.txt\n"
msgstr ""
"; HTTP\n"
"[http]\n"
"\tsslVerify\n"
"[http \"https://weak.example.com\"]\n"
"\tsslVerify = false\n"
"\tcookiFile= /tmp/cookie.txt\n"

#. type: Plain text
#: en/git-config.txt:470
#, priority:100
msgid "you can set the filemode to true with"
msgstr "你可以用以下方法将文件模式设置为真"

#. type: delimited block -
#: en/git-config.txt:473
#, no-wrap, placeholders:'core.filemode', priority:100
msgid "% git config core.filemode true\n"
msgstr "% git config core.filemode true\n"

#. type: Plain text
#: en/git-config.txt:478
#, placeholders:'kernel.org', priority:100
msgid "The hypothetical proxy command entries actually have a postfix to discern what URL they apply to. Here is how to change the entry for kernel.org to \"ssh\"."
msgstr "假设的代理命令条目实际上有一个后缀来辨别它们适用于什么URL。下面是如何将 kernel.org 的条目改为 \"ssh\"。"

#. type: delimited block -
#: en/git-config.txt:481
#, no-wrap, placeholders:'core.gitproxy':'kernel.org':'kernel.org', priority:100
msgid "% git config core.gitproxy '\"ssh\" for kernel.org' 'for kernel.org$'\n"
msgstr "% git config core.gitproxy '\"ssh\" for kernel.org' 'for kernel.org$'\n"

#. type: Plain text
#: en/git-config.txt:484
#, placeholders:'kernel.org', priority:100
msgid "This makes sure that only the key/value pair for kernel.org is replaced."
msgstr "这确保了只有 kernel.org 的键/值对被替换。"

#. type: Plain text
#: en/git-config.txt:486
#, priority:100
msgid "To delete the entry for renames, do"
msgstr "要删除重名的条目，请执行"

#. type: delimited block -
#: en/git-config.txt:489
#, no-wrap, placeholders:'--unset':'diff.renames', priority:100
msgid "% git config --unset diff.renames\n"
msgstr "% git config --unset diff.renames\n"

#. type: Plain text
#: en/git-config.txt:493
#, placeholders:'core.gitproxy', priority:100
msgid "If you want to delete an entry for a multivar (like core.gitproxy above), you have to provide a regex matching the value of exactly one line."
msgstr "如果你想删除一个多变量的条目（如上面的 core.gitproxy），你必须提供一个与恰好一行的值相匹配的正则表达式。"

#. type: Plain text
#: en/git-config.txt:495
#, priority:100
msgid "To query the value for a given key, do"
msgstr "要查询一个给定键的值，可以这样做"

#. type: delimited block -
#: en/git-config.txt:498
#, no-wrap, placeholders:'--get':'core.filemode', priority:100
msgid "% git config --get core.filemode\n"
msgstr "% git config --get core.filemode\n"

#. type: Plain text
#: en/git-config.txt:501 en/git-merge-index.txt:66
#, priority:100
msgid "or"
msgstr "或"

#. type: delimited block -
#: en/git-config.txt:504
#, no-wrap, placeholders:'core.filemode', priority:100
msgid "% git config core.filemode\n"
msgstr "% git config core.filemode\n"

#. type: Plain text
#: en/git-config.txt:507
#, priority:100
msgid "or, to query a multivar:"
msgstr "或者，要查询一个多变量："

#. type: delimited block -
#: en/git-config.txt:510
#, no-wrap, placeholders:'--get':'core.gitproxy':'kernel.org', priority:100
msgid "% git config --get core.gitproxy \"for kernel.org$\"\n"
msgstr "% git config --get core.gitproxy \"for kernel.org$\"\n"

#. type: Plain text
#: en/git-config.txt:513
#, priority:100
msgid "If you want to know all the values for a multivar, do:"
msgstr "如果你想知道一个多变量的所有值，可以这么做："

#. type: delimited block -
#: en/git-config.txt:516
#, no-wrap, placeholders:'--get-all':'core.gitproxy', priority:100
msgid "% git config --get-all core.gitproxy\n"
msgstr "% git config --get-all core.gitproxy\n"

#. type: Plain text
#: en/git-config.txt:520
#, placeholders:'core.gitproxy', priority:100
msgid "If you like to live dangerously, you can replace *all* core.gitproxy by a new one with"
msgstr "如果你喜欢危险操作，你可以用一个新的 core.gitproxy 来取代 *所有* core.gitproxy"

#. type: delimited block -
#: en/git-config.txt:523
#, no-wrap, placeholders:'--replace-all':'core.gitproxy', priority:100
msgid "% git config --replace-all core.gitproxy ssh\n"
msgstr "% git config --replace-all core.gitproxy ssh\n"

#. type: Plain text
#: en/git-config.txt:527
#, ignore-ellipsis, priority:100
msgid "However, if you really only want to replace the line for the default proxy, i.e. the one without a \"for ...\" postfix, do something like this:"
msgstr "然而，如果你真的只想替换默认代理，即没有 \"for ...\" 后缀的那一行，可以这样做："

#. type: delimited block -
#: en/git-config.txt:530
#, no-wrap, placeholders:'core.gitproxy', priority:100
msgid "% git config core.gitproxy ssh '! for '\n"
msgstr "% git config core.gitproxy ssh '! for '\n"

#. type: Plain text
#: en/git-config.txt:533
#, priority:100
msgid "To actually match only values with an exclamation mark, you have to"
msgstr "为了真正地只匹配带有感叹号的值，你必须"

#. type: delimited block -
#: en/git-config.txt:536
#, no-wrap, priority:100
msgid "% git config section.key value '[!]'\n"
msgstr "% git config section.key value '[!]'\n"

#. type: Plain text
#: en/git-config.txt:539
#, priority:100
msgid "To add a new proxy, without altering any of the existing ones, use"
msgstr "要添加一个新的代理，而不改变任何现有的代理，使用"

#. type: delimited block -
#: en/git-config.txt:542
#, no-wrap, placeholders:'--add':'core.gitproxy', priority:100
msgid "% git config --add core.gitproxy '\"proxy-command\" for example.com'\n"
msgstr "% git config --add core.gitproxy '\"proxy-command\" for example.com'\n"

#. type: Plain text
#: en/git-config.txt:546
#, priority:100
msgid "An example to use customized color from the configuration in your script:"
msgstr "一个例子是在你的脚本中使用配置的自定义颜色："

#. type: delimited block -
#: en/git-config.txt:552
#, no-wrap, placeholders:'--get-color':'color.diff.whitespace':'--get-color':'${WS}':'${RESET}', priority:100
msgid ""
"#!/bin/sh\n"
"WS=$(git config --get-color color.diff.whitespace \"blue reverse\")\n"
"RESET=$(git config --get-color \"\" \"reset\")\n"
"echo \"${WS}your whitespace color or blue reverse${RESET}\"\n"
msgstr ""
"#!/bin/sh\n"
"WS=$(git config --get-color color.diff.whitespace \"blue reverse\")\n"
"RESET=$(git config --get-color \"\" \"reset\")\n"
"echo \"${WS}your whitespace color or blue reverse${RESET}\"\n"

#. type: Plain text
#: en/git-config.txt:556
#, placeholders:'http.sslVerify', priority:100
msgid "For URLs in `https://weak.example.com`, `http.sslVerify` is set to false, while it is set to `true` for all others:"
msgstr "对于 `https://weak.example.com` 中的 URL，`http.sslVerify` 被设置为 false，而对于所有其他的 URL，它被设置为 `true`："

#. type: delimited block -
#: en/git-config.txt:565
#, no-wrap, placeholders:'--type=bool':'--get-urlmatch':'http.sslverify':'--type=bool':'--get-urlmatch':'http.sslverify':'--get-urlmatch':'http.cookieFile':'cookie.txt':'http.sslverify', priority:100
msgid ""
"% git config --type=bool --get-urlmatch http.sslverify https://good.example.com\n"
"true\n"
"% git config --type=bool --get-urlmatch http.sslverify https://weak.example.com\n"
"false\n"
"% git config --get-urlmatch http https://weak.example.com\n"
"http.cookieFile /tmp/cookie.txt\n"
"http.sslverify false\n"
msgstr ""
"% git config --type=bool --get-urlmatch http.sslverify https://good.example.com\n"
"true\n"
"% git config --type=bool --get-urlmatch http.sslverify https://weak.example.com\n"
"false\n"
"% git config --get-urlmatch http https://weak.example.com\n"
"http.cookieFile /tmp/cookie.txt\n"
"http.sslverify false\n"

#. type: Title -
#: en/git-config.txt:570 en/git-describe.txt:202 en/git-fetch.txt:305 en/git-mv.txt:56 en/git-pack-refs.txt:87 en/git-pull.txt:240 en/git-replace.txt:139 en/git-rm.txt:190 en/git-svn.txt:1150 en/git-worktree.txt:514
#, no-wrap, priority:280
msgid "BUGS"
msgstr "漏洞"

#. type: Plain text
#: en/git-config.txt:575
#, priority:100
msgid "When using the deprecated `[section.subsection]` syntax, changing a value will result in adding a multi-line key instead of a change, if the subsection is given with at least one uppercase character. For example when the config looks like"
msgstr "当使用废弃的 `[section.subsection]` 语法时，如果 subsection 至少有一个大写字母，改变一个值将导致添加一个多行键而不是改变。例如，有以下配置"

#. type: delimited block -
#: en/git-config.txt:579
#, no-wrap, priority:100
msgid ""
"  [section.subsection]\n"
"    key = value1\n"
msgstr ""
"  [section.subsection]\n"
"    key = value1\n"

#. type: Plain text
#: en/git-config.txt:582
#, priority:100
msgid "and running `git config section.Subsection.key value2` will result in"
msgstr "并运行 `git config section.Subsection.key value2` 将导致如下的结果"

#. type: delimited block -
#: en/git-config.txt:587
#, no-wrap, priority:100
msgid ""
"  [section.subsection]\n"
"    key = value1\n"
"    key = value2\n"
msgstr ""
"  [section.subsection]\n"
"    key = value1\n"
"    key = value2\n"

#. type: Title =
#: en/git-count-objects.txt:2
#, ignore-same, no-wrap, priority:80
msgid "git-count-objects(1)"
msgstr "git-count-objects(1)"

#. type: Plain text
#: en/git-count-objects.txt:7
#, placeholders:'git-count-objects', priority:80
msgid "git-count-objects - Count unpacked number of objects and their disk consumption"
msgstr "git-count-objects - 统计未打包对象的数量及其磁盘消耗量"

#. type: Plain text
#: en/git-count-objects.txt:12
#, no-wrap, placeholders:'git count-objects':'--human-readable]', priority:80
msgid "'git count-objects' [-v] [-H | --human-readable]\n"
msgstr "'git count-objects' [-v] [-H | --human-readable]\n"

#. type: Plain text
#: en/git-count-objects.txt:17
#, priority:80
msgid "Counts the number of unpacked object files and disk space consumed by them, to help you decide when it is a good time to repack."
msgstr "计算已解压对象文件的数量及其占用的磁盘空间，帮助你决定何时是重新打包的好时机。"

#. type: Plain text
#: en/git-count-objects.txt:24
#, priority:80
msgid "Provide more detailed reports:"
msgstr "提供更详细的报告："

#. type: Plain text
#: en/git-count-objects.txt:26
#, priority:80
msgid "count: the number of loose objects"
msgstr "count：松散物体的数量"

#. type: Plain text
#: en/git-count-objects.txt:28
#, priority:80
msgid "size: disk space consumed by loose objects, in KiB (unless -H is specified)"
msgstr "size：松散对象占用的磁盘空间，单位为 KiB（除非指定 -H）"

#. type: Plain text
#: en/git-count-objects.txt:30
#, priority:80
msgid "in-pack: the number of in-pack objects"
msgstr "in-pack：包内对象的数量"

#. type: Plain text
#: en/git-count-objects.txt:32
#, priority:80
msgid "size-pack: disk space consumed by the packs, in KiB (unless -H is specified)"
msgstr "size-pack：数据包占用的磁盘空间，单位 KiB（除非指定 -H）"

#. type: Plain text
#: en/git-count-objects.txt:35
#, placeholders:'git prune-packed', priority:80
msgid "prune-packable: the number of loose objects that are also present in the packs. These objects could be pruned using `git prune-packed`."
msgstr "prune-packable：在数据包中也存在的松散对象的数量。可以使用 `git prune-packed`对这些对象进行剪枝。"

#. type: Plain text
#: en/git-count-objects.txt:38
#, priority:80
msgid "garbage: the number of files in the object database that are neither valid loose objects nor valid packs"
msgstr "garbage：对象数据库中既不是有效松散对象也不是有效包的文件数"

#. type: Plain text
#: en/git-count-objects.txt:41
#, priority:80
msgid "size-garbage: disk space consumed by garbage files, in KiB (unless -H is specified)"
msgstr "size-garbage：垃圾文件占用的磁盘空间，单位 KiB（除非指定 -H）"

#. type: Plain text
#: en/git-count-objects.txt:46
#, priority:80
msgid "alternate: absolute path of alternate object databases; may appear multiple times, one line per path. Note that if the path contains non-printable characters, it may be surrounded by double-quotes and contain C-style backslashed escape sequences."
msgstr "alternate：备用对象数据库的绝对路径；可多次出现，每个路径一行。请注意，如果路径包含不可打印字符，则可以用双引号包围，并包含 C 风格的反斜线转义序列。"

#. type: Labeled list
#: en/git-count-objects.txt:47 en/git-cvsserver.txt:61 en/git-grep.txt:115
#, ignore-same, no-wrap, priority:100
msgid "-H"
msgstr "-H"

#. type: Labeled list
#: en/git-count-objects.txt:48
#, ignore-same, no-wrap, priority:80
msgid "--human-readable"
msgstr "--human-readable"

#. type: Plain text
#: en/git-count-objects.txt:51
#, priority:80
msgid "Print sizes in human readable format"
msgstr "以人类可读的格式打印对象大小"

#. type: Title =
#: en/git-credential-cache--daemon.txt:2
#, no-wrap, placeholders:'git-credential-cache':'{litdd}', priority:90
msgid "git-credential-cache{litdd}daemon(1)"
msgstr "git-credential-cache{litdd}daemon(1)"

#. type: Plain text
#: en/git-credential-cache--daemon.txt:7
#, placeholders:'git-credential-cache--daemon', priority:90
msgid "git-credential-cache--daemon - Temporarily store user credentials in memory"
msgstr "git-credential-cache--daemon - 在内存中临时存储用户证书"

#. type: Plain text
#: en/git-credential-cache--daemon.txt:12
#, no-wrap, placeholders:'git credential-cache':'{litdd}':'[--debug]', priority:90
msgid "'git credential-cache{litdd}daemon' [--debug] <socket-path>\n"
msgstr "'git credential-cache{litdd}daemon' [--debug] <socket 路径>\n"

#. type: Plain text
#: en/git-credential-cache--daemon.txt:18
#, placeholders:'linkgit:git-credential-cache[1]', priority:90
msgid "You probably don't want to invoke this command yourself; it is started automatically when you use linkgit:git-credential-cache[1]."
msgstr "您可能不想自己调用这条命令；当您使用 linkgit:git-credential-cache[1] 时，它会自动启动。"

#. type: Plain text
#: en/git-credential-cache--daemon.txt:23
#, placeholders:'git-credential-cache', priority:90
msgid "This command listens on the Unix domain socket specified by `<socket-path>` for `git-credential-cache` clients. Clients may store and retrieve credentials. Each credential is held for a timeout specified by the client; once no credentials are held, the daemon exits."
msgstr "此命令通过 `<套接字路径>` 指定的 Unix 域套接字监听 `git-credential-cache` 客户端。客户端可以存储和检索证书。每个凭据的保留时间由客户端指定；一旦没有凭据保留，守护进程就会退出。"

#. type: Plain text
#: en/git-credential-cache--daemon.txt:27
#, placeholders:'`--debug`', priority:90
msgid "If the `--debug` option is specified, the daemon does not close its stderr stream, and may output extra diagnostics to it even after it has begun listening for clients."
msgstr "如果指定了 `--debug` 选项，守护进程不会关闭标准错误流，甚至在开始监听客户端后仍可能向其输出额外的诊断信息。"

#. type: Title =
#: en/git-credential-cache.txt:2
#, ignore-same, no-wrap, priority:90
msgid "git-credential-cache(1)"
msgstr "git-credential-cache(1)"

#. type: Plain text
#: en/git-credential-cache.txt:7
#, placeholders:'git-credential-cache', priority:90
msgid "git-credential-cache - Helper to temporarily store passwords in memory"
msgstr "git-credential-cache - 在内存中临时存储密码的助手"

#. type: delimited block -
#: en/git-credential-cache.txt:12
#, no-wrap, placeholders:'credential.helper', priority:90
msgid "git config credential.helper 'cache [<options>]'\n"
msgstr "git config credential.helper 'cache [<多个选项>]'\n"

#. type: Plain text
#: en/git-credential-cache.txt:24
#, priority:90
msgid "This command caches credentials for use by future Git programs. The stored credentials are kept in memory of the cache-daemon process (instead of being written to a file) and are forgotten after a configurable timeout. Credentials are forgotten sooner if the cache-daemon dies, for example if the system restarts. The cache is accessible over a Unix domain socket, restricted to the current user by filesystem permissions."
msgstr "该命令会缓存凭证，供未来的 Git 程序使用。 存储的凭据保存在 cache-daemon 进程的内存中（而不是写入文件），并在可配置的超时后被遗忘。如果 cache-daemon 死机，例如系统重启，证书会更快被遗忘。缓存可通过 Unix 域套接字访问，并通过文件系统权限限制为当前用户访问。"

#. type: Plain text
#: en/git-credential-cache.txt:28
#, placeholders:'linkgit:gitcredentials[7]', priority:90
msgid "You probably don't want to invoke this command directly; it is meant to be used as a credential helper by other parts of Git. See linkgit:gitcredentials[7] or `EXAMPLES` below."
msgstr "你可能不想直接调用这条命令；它的目的是作为 Git 其他部分的凭证助手。请参阅 linkgit:gitcredentials[7] 或下面的 `例子`。"

#. type: Labeled list
#: en/git-credential-cache.txt:32
#, no-wrap, placeholders:'--timeout', priority:90
msgid "--timeout <seconds>"
msgstr "--timeout <秒>"

#. type: Plain text
#: en/git-credential-cache.txt:35
#, priority:90
msgid "Number of seconds to cache credentials (default: 900)."
msgstr "缓存证书的秒数（默认值：900）。"

#. type: Labeled list
#: en/git-credential-cache.txt:36
#, no-wrap, placeholders:'--socket', priority:90
msgid "--socket <path>"
msgstr "--socket <路径>"

#. type: Plain text
#: en/git-credential-cache.txt:46
#, placeholders:'$XDG_CACHE_HOME':'git-credential-cache':'git-credential-cache', priority:90
msgid "Use `<path>` to contact a running cache daemon (or start a new cache daemon if one is not started). Defaults to `$XDG_CACHE_HOME/git/credential/socket` unless `~/.git-credential-cache/` exists in which case `~/.git-credential-cache/socket` is used instead. If your home directory is on a network-mounted filesystem, you may need to change this to a local filesystem. You must specify an absolute path."
msgstr "使用 `<路径>` 联系正在运行的缓存守护进程（或在未启动缓存守护进程的情况下启动新的缓存守护进程）。 默认路径是 `$XDG_CACHE_HOME/git/credential/socket`，除非存在 `~/.git-credential-cache/`，在这种情况下会使用 `~/.git-credential-cache/socket`。 如果您的主目录位于网络挂载的文件系统上，可能需要将其更改为本地文件系统。必须指定绝对路径。"

#. type: Title -
#: en/git-credential-cache.txt:48
#, no-wrap, priority:90
msgid "CONTROLLING THE DAEMON"
msgstr "控制守护进程"

#. type: Plain text
#: en/git-credential-cache.txt:52
#, priority:90
msgid "If you would like the daemon to exit early, forgetting all cached credentials before their timeout, you can issue an `exit` action:"
msgstr "如果希望守护进程提前退出，在超时前忘记所有缓存的凭据，可以发出 `exit`操作："

#. type: delimited block -
#: en/git-credential-cache.txt:55
#, no-wrap, placeholders:'git credential-cache', priority:90
msgid "git credential-cache exit\n"
msgstr "git credential-cache exit\n"

#. type: Plain text
#: en/git-credential-cache.txt:62 en/git-credential-store.txt:75
#, priority:100
msgid "The point of this helper is to reduce the number of times you must type your username or password. For example:"
msgstr "这个助手的意义在于减少你必须输入用户名或密码的次数。比如说："

#. type: delimited block -
#: en/git-credential-cache.txt:68
#, no-wrap, placeholders:'credential.helper', priority:90
msgid ""
"$ git config credential.helper cache\n"
"$ git push http://example.com/repo.git\n"
"Username: <type your username>\n"
"Password: <type your password>\n"
msgstr ""
"$ git config credential.helper cache\n"
"$ git push http://example.com/repo.git\n"
"Username: <输入你的用户名>\n"
"Password: <输入你的密码>\n"

#. type: delimited block -
#: en/git-credential-cache.txt:72
#, no-wrap, priority:90
msgid ""
"[work for 5 more minutes]\n"
"$ git push http://example.com/repo.git\n"
"[your credentials are used automatically]\n"
msgstr ""
"[再工作 5 分钟]\n"
"$ git push http://example.com/repo.git\n"
"[自动使用您的证书]\n"

#. type: Plain text
#: en/git-credential-cache.txt:76
#, placeholders:'credential.helper', priority:90
msgid "You can provide options via the credential.helper configuration variable (this example increases the cache time to 1 hour):"
msgstr "您可以通过 credential.helper 配置变量提供选项（本例将缓存时间增加到 1 小时）："

#. type: delimited block -
#: en/git-credential-cache.txt:79
#, no-wrap, placeholders:'credential.helper':'--timeout=3600', priority:90
msgid "$ git config credential.helper 'cache --timeout=3600'\n"
msgstr "$ git config credential.helper 'cache --timeout=3600'\n"

#. type: Title =
#: en/git-credential-store.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-credential-store(1)"
msgstr "git-credential-store(1)"

#. type: Plain text
#: en/git-credential-store.txt:7
#, placeholders:'git-credential-store', priority:100
msgid "git-credential-store - Helper to store credentials on disk"
msgstr "git-credential-store - 在磁盘上存储凭证的助手"

#. type: delimited block -
#: en/git-credential-store.txt:12
#, no-wrap, placeholders:'credential.helper', priority:100
msgid "git config credential.helper 'store [<options>]'\n"
msgstr "git config credential.helper 'store [<选项>]'\n"

#. type: Plain text
#: en/git-credential-store.txt:21
#, placeholders:'linkgit:git-credential-cache[1]', priority:100
msgid "Using this helper will store your passwords unencrypted on disk, protected only by filesystem permissions. If this is not an acceptable security tradeoff, try linkgit:git-credential-cache[1], or find a helper that integrates with secure storage provided by your operating system."
msgstr "使用这个助手会将你的密码未加密地存储在磁盘上，只受文件系统权限的保护。如果这不是一个可接受的安全权衡，请尝试 linkgit:git-credential-cache[1]，或者找一个能与你的操作系统提供的安全存储整合的助手。"

#. type: Plain text
#: en/git-credential-store.txt:24
#, priority:100
msgid "This command stores credentials indefinitely on disk for use by future Git programs."
msgstr "该命令在磁盘上无限期地存储凭证，供未来的 Git 程序使用。"

#. type: Plain text
#: en/git-credential-store.txt:28
#, placeholders:'linkgit:gitcredentials[7]', priority:100
msgid "You probably don't want to invoke this command directly; it is meant to be used as a credential helper by other parts of git. See linkgit:gitcredentials[7] or `EXAMPLES` below."
msgstr "你可能不想直接调用这个命令；它是作为 git 其他部分的凭证助手来使用的。参见 linkgit:gitcredentials[7] 或下面的 `EXAMPLES`。"

#. type: Labeled list
#: en/git-credential-store.txt:32
#, no-wrap, placeholders:'--file=', priority:100
msgid "--file=<path>"
msgstr "--file=<路径>"

#. type: Plain text
#: en/git-credential-store.txt:42
#, placeholders:'git-credentials':'$XDG_CONFIG_HOME':'git-credentials':'$XDG_CONFIG_HOME':'<<FILES>>', priority:100
msgid "Use `<path>` to lookup and store credentials. The file will have its filesystem permissions set to prevent other users on the system from reading it, but it will not be encrypted or otherwise protected. If not specified, credentials will be searched for from `~/.git-credentials` and `$XDG_CONFIG_HOME/git/credentials`, and credentials will be written to `~/.git-credentials` if it exists, or `$XDG_CONFIG_HOME/git/credentials` if it exists and the former does not. See also <<FILES>>."
msgstr "使用 `<路径>` 来查询和存储证书。该文件将设置其文件系统权限，以防止系统中的其他用户读取它，但不会被加密或其他保护。如果没有指定，将从 `~/.git-credentials` 和 `$XDG_CONFIG_HOME/git/credentials` 中搜索证书，如果证书存在，将被写入 `~/.git-credentials`，如果证书存在而前者不存在，则写入 `$XDG_CONFIG_HOME/git/credentials`。参见 <<FILES>>。"

#. type: Plain text
#: en/git-credential-store.txt:49
#, placeholders:'`--file`':'git-credential-store', priority:100
msgid "If not set explicitly with `--file`, there are two files where git-credential-store will search for credentials in order of precedence:"
msgstr "如果没有用 `--file` 明确设置，有两个文件，git-credential-store 将按照优先顺序搜索证书："

#. type: Labeled list
#: en/git-credential-store.txt:50
#, no-wrap, placeholders:'git-credentials', priority:100
msgid "~/.git-credentials"
msgstr "~/.git-credentials"

#. type: Plain text
#: en/git-credential-store.txt:52
#, priority:100
msgid "User-specific credentials file."
msgstr "用户特定的凭证文件。"

#. type: Labeled list
#: en/git-credential-store.txt:53
#, no-wrap, placeholders:'$XDG_CONFIG_HOME', priority:100
msgid "$XDG_CONFIG_HOME/git/credentials"
msgstr "$XDG_CONFIG_HOME/git/credentials"

#. type: Plain text
#: en/git-credential-store.txt:59
#, placeholders:'$XDG_CONFIG_HOME':'$HOME':'git-credentials', priority:100
msgid "Second user-specific credentials file. If '$XDG_CONFIG_HOME' is not set or empty, `$HOME/.config/git/credentials` will be used. Any credentials stored in this file will not be used if `~/.git-credentials` has a matching credential as well. It is a good idea not to create this file if you sometimes use older versions of Git that do not support it."
msgstr "第二个用户专用的证书文件。如果 '$XDG_CONFIG_HOME' 没有设置或为空，`$HOME/.config/git/credentials` 将被使用。如果 `~/.git-credentials` 也有匹配的凭证，那么存储在该文件中的任何凭证将不会被使用。如果你有时使用不支持该文件的旧版本的 Git，那么不创建该文件是个好主意。"

#. type: Plain text
#: en/git-credential-store.txt:63
#, priority:100
msgid "For credential lookups, the files are read in the order given above, with the first matching credential found taking precedence over credentials found in files further down the list."
msgstr "对于凭证查询，文件按上述顺序读取，发现的第一个匹配凭证优先于在列表后面的文件中发现的凭证。"

#. type: Plain text
#: en/git-credential-store.txt:67
#, placeholders:'git-credentials', priority:100
msgid "Credential storage will by default write to the first existing file in the list. If none of these files exist, `~/.git-credentials` will be created and written to."
msgstr "凭证存储将默认写到列表中的第一个现有文件。如果这些文件都不存在，`~/.git-credentials` 将被创建并写入。"

#. type: Plain text
#: en/git-credential-store.txt:69
#, priority:100
msgid "When erasing credentials, matching credentials will be erased from all files."
msgstr "擦除证书时，匹配的证书将从所有文件中擦除。"

#. type: delimited block -
#: en/git-credential-store.txt:81
#, no-wrap, placeholders:'credential.helper', priority:100
msgid ""
"$ git config credential.helper store\n"
"$ git push http://example.com/repo.git\n"
"Username: <type your username>\n"
"Password: <type your password>\n"
msgstr ""
"$ git config credential.helper store\n"
"$ git push http://example.com/repo.git\n"
"Username: <输入您的用户名>\n"
"Password: <输入密码>\n"

#. type: delimited block -
#: en/git-credential-store.txt:85
#, no-wrap, priority:100
msgid ""
"[several days later]\n"
"$ git push http://example.com/repo.git\n"
"[your credentials are used automatically]\n"
msgstr ""
"[几天后]\n"
"$ git push http://example.com/repo.git\n"
"[自动使用您的证书]\n"

#. type: Title -
#: en/git-credential-store.txt:88
#, no-wrap, priority:100
msgid "STORAGE FORMAT"
msgstr "存储格式"

#. type: Plain text
#: en/git-credential-store.txt:92
#, placeholders:'git-credentials', priority:100
msgid "The `.git-credentials` file is stored in plaintext. Each credential is stored on its own line as a URL like:"
msgstr "`.git-credentials` 文件是以明文存储的。每个凭证都以 URL 的形式存储在自己的一行中，比如："

#. type: delimited block -
#: en/git-credential-store.txt:95
#, no-wrap, priority:100
msgid "https://user:pass@example.com\n"
msgstr "https://user:pass@example.com\n"

#. type: Plain text
#: en/git-credential-store.txt:100
#, priority:100
msgid "No other kinds of lines (e.g. empty lines or comment lines) are allowed in the file, even though some may be silently ignored. Do not view or edit the file with editors."
msgstr "文件中不允许有其他类型的行（如空行或注释行），尽管有些行可能被默默地忽略了。不要用编辑器查看或编辑该文件。"

#. type: Plain text
#: en/git-credential-store.txt:107
#, placeholders:'linkgit:gitcredentials[7]', priority:100
msgid "When Git needs authentication for a particular URL context, credential-store will consider that context a pattern to match against each entry in the credentials file. If the protocol, hostname, and username (if we already have one) match, then the password is returned to Git. See the discussion of configuration in linkgit:gitcredentials[7] for more information."
msgstr "当 Git 需要对某个特定的 URL 上下文进行认证时，credential-store 会将该上下文视为一种模式，与凭证文件中的每个条目进行匹配。 如果协议、主机名和用户名（如果我们已经有了）相匹配，那么密码就会返回给 Git。更多信息见 linkgit:gitcredentials[7] 中关于配置的讨论。"

#. type: Title =
#: en/git-credential.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-credential(1)"
msgstr "git-credential(1)"

#. type: Plain text
#: en/git-credential.txt:7
#, placeholders:'git-credential', priority:100
msgid "git-credential - Retrieve and store user credentials"
msgstr "git-credential - 检索和存储用户证书"

#. type: delimited block -
#: en/git-credential.txt:12
#, no-wrap, priority:100
msgid "'git credential' (fill|approve|reject)\n"
msgstr "'git credential' (fill|approve|reject)\n"

#. type: Plain text
#: en/git-credential.txt:24
#, placeholders:'git-credential', priority:100
msgid "Git has an internal interface for storing and retrieving credentials from system-specific helpers, as well as prompting the user for usernames and passwords. The git-credential command exposes this interface to scripts which may want to retrieve, store, or prompt for credentials in the same manner as Git. The design of this scriptable interface models the internal C API; see credential.h for more background on the concepts."
msgstr "Git 有一个内部接口，用于存储和检索来自系统特定帮助器的凭证，以及提示用户输入用户名和密码。git-credential 命令将这个接口暴露给脚本，这些脚本可能希望以与 Git 相同的方式检索、存储或提示凭证。这个脚本接口的设计仿照了内部的 C 语言应用程序接口；更多概念的背景见 credential.h。"

#. type: Plain text
#: en/git-credential.txt:28
#, placeholders:'git-credential':'<<IOFMT,', priority:100
msgid "git-credential takes an \"action\" option on the command-line (one of `fill`, `approve`, or `reject`) and reads a credential description on stdin (see <<IOFMT,INPUT/OUTPUT FORMAT>>)."
msgstr "git-credential 使用命令行上的 \"action\" 选项（`fill` 、`approve` 或 `reject` 之一），并在标准输入流上读取证书描述（参见 <<IOFMT,输入/输出格式>>）。"

#. type: Plain text
#: en/git-credential.txt:35
#, placeholders:'git-credential', priority:100
msgid "If the action is `fill`, git-credential will attempt to add \"username\" and \"password\" attributes to the description by reading config files, by contacting any configured credential helpers, or by prompting the user. The username and password attributes of the credential description are then printed to stdout together with the attributes already provided."
msgstr "如果动作是 `fill`，git-credential 将尝试通过读取配置文件、联系任何已配置的凭证助手或提示用户来向描述中添加 “用户名” 和 “密码” 属性。然后，凭证描述中的用户名和密码属性会和已经提供的属性一起打印到标准输出流。"

#. type: Plain text
#: en/git-credential.txt:39
#, placeholders:'git-credential', priority:100
msgid "If the action is `approve`, git-credential will send the description to any configured credential helpers, which may store the credential for later use."
msgstr "如果动作是 `approve`，git-credential 将把描述发送给任何配置的凭证助手，它们可以存储凭证供以后使用。"

#. type: Plain text
#: en/git-credential.txt:43
#, placeholders:'git-credential', priority:100
msgid "If the action is `reject`, git-credential will send the description to any configured credential helpers, which may erase any stored credentials matching the description."
msgstr "如果动作是 `reject`，git-credential 将把描述发送到任何配置的凭证助手，这可能会删除任何与描述相匹配的存储凭证。"

#. type: Plain text
#: en/git-credential.txt:45
#, priority:100
msgid "If the action is `approve` or `reject`, no output should be emitted."
msgstr "如果动作是 `approve` 或 `reject`，就不应该有输出。"

#. type: Title -
#: en/git-credential.txt:47
#, no-wrap, priority:100
msgid "TYPICAL USE OF GIT CREDENTIAL"
msgstr "git 凭证的典型用途"

#. type: Plain text
#: en/git-credential.txt:51
#, placeholders:'git-credential', priority:100
msgid "An application using git-credential will typically use `git credential` following these steps:"
msgstr "使用 git-credential 的应用程序通常会按照以下步骤使用 `git credential`："

#. type: Plain text
#: en/git-credential.txt:53
#, priority:100
msgid "Generate a credential description based on the context."
msgstr "根据上下文生成一个凭证描述。"

#. type: Plain text
#: en/git-credential.txt:59
#, placeholders:'foo.git', priority:100
msgid "For example, if we want a password for `https://example.com/foo.git`, we might generate the following credential description (don't forget the blank line at the end; it tells `git credential` that the application finished feeding all the information it has):"
msgstr "例如，如果我们想要一个 `https://example.com/foo.git` 的密码，我们可能会生成下面的凭证描述（别忘了最后的空行；它告诉 `git credential`，应用程序已经完成了所有信息的输入）："

#. type: Plain text
#: en/git-credential.txt:63
#, no-wrap, placeholders:'foo.git', priority:100
msgid ""
"\t protocol=https\n"
"\t host=example.com\n"
"\t path=foo.git\n"
msgstr ""
"\t protocol=https\n"
"\t host=example.com\n"
"\t path=foo.git\n"

#. type: Plain text
#: en/git-credential.txt:69
#, placeholders:'git-credential', priority:100
msgid "Ask git-credential to give us a username and password for this description. This is done by running `git credential fill`, feeding the description from step (1) to its standard input. The complete credential description (including the credential per se, i.e. the login and password) will be produced on standard output, like:"
msgstr "要求 git-credential 为这个描述提供一个用户名和密码。这可以通过运行 `git credential fill` 来实现，将步骤（1）中的描述输入到其标准输入中。完整的凭证描述（包括凭证本身，即登录名和密码）将在标准输出中产生，比如："

#. type: Plain text
#: en/git-credential.txt:74
#, no-wrap, priority:100
msgid ""
"protocol=https\n"
"host=example.com\n"
"username=bob\n"
"password=secr3t\n"
msgstr ""
"protocol=https\n"
"host=example.com\n"
"username=bob\n"
"password=secr3t\n"

#. type: Plain text
#: en/git-credential.txt:79
#, placeholders:'credential.useHttpPath', priority:100
msgid "In most cases, this means the attributes given in the input will be repeated in the output, but Git may also modify the credential description, for example by removing the `path` attribute when the protocol is HTTP(s) and `credential.useHttpPath` is false."
msgstr "在大多数情况下，这意味着输入中给出的属性将在输出中重复出现，但Git也可以修改凭证描述，例如，当协议是HTTP(s)且 `credential.useHttpPath` 为假时，删除 `path` 属性。"

#. type: Plain text
#: en/git-credential.txt:85
#, priority:100
msgid "If the `git credential` knew about the password, this step may not have involved the user actually typing this password (the user may have typed a password to unlock the keychain instead, or no user interaction was done if the keychain was already unlocked) before it returned `password=secr3t`."
msgstr "如果`git credential` 知道密码，在返回 `password=secr3t` 之前，这一步可能不涉及用户实际输入这个密码（用户可能输入了一个密码来代替解锁钥匙串，或者如果钥匙串已经被解锁，则没有进行用户交互）。"

#. type: Plain text
#: en/git-credential.txt:88
#, priority:100
msgid "Use the credential (e.g., access the URL with the username and password from step (2)), and see if it's accepted."
msgstr "使用该证书（例如，用步骤（2）中的用户名和密码访问 URL），看看是否被接受。"

#. type: Plain text
#: en/git-credential.txt:98
#, priority:100
msgid "Report on the success or failure of the password. If the credential allowed the operation to complete successfully, then it can be marked with an \"approve\" action to tell `git credential` to reuse it in its next invocation. If the credential was rejected during the operation, use the \"reject\" action so that `git credential` will ask for a new password in its next invocation. In either case, `git credential` should be fed with the credential description obtained from step (2) (which also contains the fields provided in step (1))."
msgstr "报告密码的成功或失败。如果凭证允许操作成功完成，那么可以用 \"approve\" 动作标记，告诉 `git credential` 在下一次调用中重新使用它。如果操作过程中证书被拒绝，使用 \"reject\" 动作，这样 `git credential` 将在下一次调用中要求一个新的密码。在这两种情况下，`git credential` 应该被输入从步骤 (2) 中获得的凭证描述（其中也包含步骤(1)中提供的描述）。"

#. type: Title -
#: en/git-credential.txt:101
#, no-wrap, priority:100
msgid "INPUT/OUTPUT FORMAT"
msgstr "输入/输出格式"

#. type: Plain text
#: en/git-credential.txt:108
#, priority:100
msgid "`git credential` reads and/or writes (depending on the action used) credential information in its standard input/output. This information can correspond either to keys for which `git credential` will obtain the login information (e.g. host, protocol, path), or to the actual credential data to be obtained (username/password)."
msgstr "`git credential` 在其标准输入/输出中读取和/或写入（取决于使用的操作）凭证信息。这些信息可以对应于 `git credential` 将获得登录信息的键（如主机、协议、路径），或者对应于要获得的实际凭证数据（用户名/密码）。"

#. type: Plain text
#: en/git-credential.txt:112
#, priority:100
msgid "The credential is split into a set of named attributes, with one attribute per line. Each attribute is specified by a key-value pair, separated by an `=` (equals) sign, followed by a newline."
msgstr "凭证被分割成一组命名的属性，每行一个属性。每个属性由一个键值对指定，用一个 `=`（等号）分隔，后面是换行。"

#. type: Plain text
#: en/git-credential.txt:115
#, priority:100
msgid "The key may contain any bytes except `=`, newline, or NUL. The value may contain any bytes except newline or NUL."
msgstr "键可以包含任何字节，除了 `=`、换行或 NUL。值可以包含除换行或 NUL 之外的任何字节。"

#. type: Plain text
#: en/git-credential.txt:121
#, priority:100
msgid "Attributes with keys that end with C-style array brackets `[]` can have multiple values. Each instance of a multi-valued attribute forms an ordered list of values - the order of the repeated attributes defines the order of the values. An empty multi-valued attribute (`key[]=\\n`) acts to clear any previous entries and reset the list."
msgstr "键值以 C 型数组括号 `[]` 结尾的属性可以有多个值。一个多值属性的每个实例形成一个有序的值列表--重复属性的顺序决定了值的顺序。一个空的多值属性（`key[]=\\n`）的作用是清除之前的任何条目并重置列表。"

#. type: Plain text
#: en/git-credential.txt:125
#, priority:100
msgid "In all cases, all bytes are treated as-is (i.e., there is no quoting, and one cannot transmit a value with newline or NUL in it). The list of attributes is terminated by a blank line or end-of-file."
msgstr "在所有情况下，所有字节都按原样处理（即没有引号，也不能传输带有换行或NUL的值）。属性列表以空行或文件结束来结束。"

#. type: Plain text
#: en/git-credential.txt:127
#, priority:100
msgid "Git understands the following attributes:"
msgstr "Git 可理解以下属性："

#. type: Labeled list
#: en/git-credential.txt:128
#, ignore-same, no-wrap, priority:100
msgid "`protocol`"
msgstr "`protocol`"

#. type: Plain text
#: en/git-credential.txt:132
#, priority:100
msgid "The protocol over which the credential will be used (e.g., `https`)."
msgstr "将使用证书的协议（例如，`https`）。"

#. type: Labeled list
#: en/git-credential.txt:133
#, ignore-same, no-wrap, priority:100
msgid "`host`"
msgstr "`host`"

#. type: Plain text
#: en/git-credential.txt:137
#, priority:100
msgid "The remote hostname for a network credential. This includes the port number if one was specified (e.g., \"example.com:8088\")."
msgstr "网络凭证的远程主机名。 如果指定了端口号，这包括端口号（例如，\"example.com:8088\"）。"

#. type: Labeled list
#: en/git-credential.txt:138
#, ignore-same, no-wrap, priority:100
msgid "`path`"
msgstr "`path`"

#. type: Plain text
#: en/git-credential.txt:143
#, priority:100
msgid "The path with which the credential will be used. E.g., for accessing a remote https repository, this will be the repository's path on the server."
msgstr "证书将被使用的路径。例如，对于访问远程 https 版本库，这将是服务器上版本库的路径。"

#. type: Labeled list
#: en/git-credential.txt:144
#, ignore-same, no-wrap, priority:100
msgid "`username`"
msgstr "`username`"

#. type: Plain text
#: en/git-credential.txt:148
#, priority:100
msgid "The credential's username, if we already have one (e.g., from a URL, the configuration, the user, or from a previously run helper)."
msgstr "证书的用户名，如果我们已经有了一个（例如，从URL、配置、用户，或从先前运行的帮助器）。"

#. type: Labeled list
#: en/git-credential.txt:149
#, ignore-same, no-wrap, priority:100
msgid "`password`"
msgstr "`password`"

#. type: Plain text
#: en/git-credential.txt:152
#, priority:100
msgid "The credential's password, if we are asking it to be stored."
msgstr "凭证的密码，如果我们要求它被存储。"

#. type: Labeled list
#: en/git-credential.txt:153
#, ignore-same, no-wrap, priority:100
msgid "`password_expiry_utc`"
msgstr "`password_expiry_utc`"

#. type: Plain text
#: en/git-credential.txt:158
#, priority:100
msgid "Generated passwords such as an OAuth access token may have an expiry date. When reading credentials from helpers, `git credential fill` ignores expired passwords. Represented as Unix time UTC, seconds since 1970."
msgstr "生成的密码，如 OAuth 访问令牌，可能有一个过期日期。 当从助手那里读取凭证时，`git credential fill` 会忽略过期的密码。表示为 Unix 时间 UTC，自 1970 年以来的秒数。"

#. type: Labeled list
#: en/git-credential.txt:159
#, ignore-same, no-wrap, priority:100
msgid "`oauth_refresh_token`"
msgstr "`oauth_refresh_token`"

#. type: Plain text
#: en/git-credential.txt:164
#, priority:100
msgid "An OAuth refresh token may accompany a password that is an OAuth access token. Helpers must treat this attribute as confidential like the password attribute. Git itself has no special behaviour for this attribute."
msgstr "一个 OAuth 刷新令牌可以伴随着一个 OAuth 访问令牌的密码。帮助者必须像密码属性一样，将此属性视为机密。Git 本身对这个属性没有特殊行为。"

#. type: Labeled list
#: en/git-credential.txt:165
#, ignore-same, no-wrap, priority:100
msgid "`url`"
msgstr "`url`"

#. type: Plain text
#: en/git-credential.txt:172
#, priority:100
msgid "When this special attribute is read by `git credential`, the value is parsed as a URL and treated as if its constituent parts were read (e.g., `url=https://example.com` would behave as if `protocol=https` and `host=example.com` had been provided). This can help callers avoid parsing URLs themselves."
msgstr "当这个特殊属性被 `git credential` 读取时，该值被解析为一个 URL，并被当作其组成部分来处理（例如，`url=_00` 的行为就如同提供了 `protocol=https` 和 `host=example.com`）。这可以帮助调用者避免自己解析 URL。"

#. type: Plain text
#: en/git-credential.txt:177
#, priority:100
msgid "Note that specifying a protocol is mandatory and if the URL doesn't specify a hostname (e.g., \"cert:///path/to/file\") the credential will contain a hostname attribute whose value is an empty string."
msgstr "请注意，指定协议是强制性的，如果 URL 没有指定主机名（例如，\"cert:///path/to/file\"），证书将包含一个主机名属性，其值是一个空字符串。"

#. type: Plain text
#: en/git-credential.txt:180
#, priority:100
msgid "Components which are missing from the URL (e.g., there is no username in the example above) will be left unset."
msgstr "URL 中缺少的组件（例如，上面的例子中没有用户名）将不被设置。"

#. type: Labeled list
#: en/git-credential.txt:181
#, no-wrap, priority:100
msgid "`wwwauth[]`"
msgstr "`wwwauth[]`"

#. type: Plain text
#: en/git-credential.txt:186
#, priority:100
msgid "When an HTTP response is received by Git that includes one or more 'WWW-Authenticate' authentication headers, these will be passed by Git to credential helpers."
msgstr "当 Git 收到包含一个或多个 \"WWW-Authenticate\" 认证头的 HTTP 响应时，这些头将被 Git 传递给证书助手。"

#. type: Plain text
#: en/git-credential.txt:191
#, priority:100
msgid "Each 'WWW-Authenticate' header value is passed as a multi-valued attribute 'wwwauth[]', where the order of the attributes is the same as they appear in the HTTP response. This attribute is 'one-way' from Git to pass additional information to credential helpers."
msgstr "每个 'WWW-Authenticate' 头的值都以多值属性 'wwwauth[]' 的形式传递，其中属性的顺序与它们在 HTTP 响应中出现的一样。这个属性是 Git 的 'one-way' 属性，用于传递额外的信息给证书助手。"

#. type: Plain text
#: en/git-credential.txt:193
#, priority:100
msgid "Unrecognised attributes are silently discarded."
msgstr "未识别的属性会被默默地丢弃。"

#. type: Title =
#: en/git-cvsexportcommit.txt:2
#, ignore-same, no-wrap, priority:90
msgid "git-cvsexportcommit(1)"
msgstr "git-cvsexportcommit(1)"

#. type: Plain text
#: en/git-cvsexportcommit.txt:7
#, placeholders:'git-cvsexportcommit', priority:90
msgid "git-cvsexportcommit - Export a single commit to a CVS checkout"
msgstr "git-cvsexportcommit - 将单个提交导出为 CVS 检出"

#. type: Plain text
#: en/git-cvsexportcommit.txt:14
#, no-wrap, priority:90
msgid ""
"'git cvsexportcommit' [-h] [-u] [-v] [-c] [-P] [-p] [-a] [-d <cvsroot>]\n"
"\t[-w <cvs-workdir>] [-W] [-f] [-m <msgprefix>] [<parent-commit>] <commit-id>\n"
msgstr ""
"'git cvsexportcommit' [-h] [-u] [-v] [-c] [-P] [-p] [-a] [-d <CVS 根>]\n"
"\t[-w <CVS 工作目录>] [-W] [-f] [-m <消息前缀>] [<父提交>] <提交 ID>\n"

#. type: Plain text
#: en/git-cvsexportcommit.txt:20
#, priority:90
msgid "Exports a commit from Git to a CVS checkout, making it easier to merge patches from a Git repository into a CVS repository."
msgstr "将提交从 Git 导出到 CVS 检出，从而更轻松地将补丁从 Git 仓库合并到 CVS 仓库。"

#. type: Plain text
#: en/git-cvsexportcommit.txt:24
#, placeholders:'GIT_DIR', priority:90
msgid "Specify the name of a CVS checkout using the -w switch or execute it from the root of the CVS working copy. In the latter case GIT_DIR must be defined. See examples below."
msgstr "使用 -w 开关指定 CVS 检出的名称，或从 CVS 工作副本的根目录执行。在后一种情况下，必须定义 GIT_DIR。请参阅下面的示例。"

#. type: Plain text
#: en/git-cvsexportcommit.txt:28
#, priority:90
msgid "It does its best to do the safe thing, it will check that the files are unchanged and up to date in the CVS checkout, and it will not autocommit by default."
msgstr "它会尽最大努力做到安全，它会检查文件是否在 CVS 签出中保持不变且是最新的，而且默认情况下不会自动提交。"

#. type: Plain text
#: en/git-cvsexportcommit.txt:30
#, priority:90
msgid "Supports file additions, removals, and commits that affect binary files."
msgstr "支持影响二进制文件的文件添加、删除和提交。"

#. type: Plain text
#: en/git-cvsexportcommit.txt:33
#, priority:90
msgid "If the commit is a merge commit, you must tell 'git cvsexportcommit' what parent the changeset should be done against."
msgstr "如果该提交是合并提交，则必须告诉 'git cvsexportcommit' 该变更集应针对哪个父级提交。"

#. type: Plain text
#: en/git-cvsexportcommit.txt:40
#, priority:90
msgid "Commit automatically if the patch applied cleanly. It will not commit if any hunks fail to apply or there were other problems."
msgstr "如果补丁应用无误，则自动提交。如果有任何缺口未能应用或出现其他问题，则不会提交。"

#. type: Plain text
#: en/git-cvsexportcommit.txt:44
#, placeholders:'--fuzz=0', priority:90
msgid "Be pedantic (paranoid) when applying patches. Invokes patch with --fuzz=0"
msgstr "打补丁时要迂腐（偏执）。以 --fuzz=0 调用补丁"

#. type: Plain text
#: en/git-cvsexportcommit.txt:48
#, priority:90
msgid "Add authorship information. Adds Author line, and Committer (if different from Author) to the message."
msgstr "添加作者信息。在邮件中添加作者行和提交者（如果与作者不同）。"

#. type: Plain text
#: en/git-cvsexportcommit.txt:53
#, priority:90
msgid "Set an alternative CVSROOT to use. This corresponds to the CVS -d parameter. Usually users will not want to set this, except if using CVS in an asymmetric fashion."
msgstr "设置要使用的另一个 CVSROOT。 这相当于 CVS -d 参数。 通常情况下，除非以非对称方式使用 CVS，否则用户不会希望设置该参数。"

#. type: Plain text
#: en/git-cvsexportcommit.txt:56
#, priority:90
msgid "Force the merge even if the files are not up to date."
msgstr "即使文件不是最新的，也可强制合并。"

#. type: Plain text
#: en/git-cvsexportcommit.txt:59
#, priority:90
msgid "Force the parent commit, even if it is not a direct parent."
msgstr "强制父提交，即使它不是直接父代。"

#. type: Plain text
#: en/git-cvsexportcommit.txt:63
#, priority:90
msgid "Prepend the commit message with the provided prefix. Useful for patch series and the like."
msgstr "用提供的前缀作为提交信息的前缀。 适用于补丁系列等。"

#. type: Plain text
#: en/git-cvsexportcommit.txt:66
#, priority:90
msgid "Update affected files from CVS repository before attempting export."
msgstr "在尝试导出之前，更新 CVS 仓库中受影响的文件。"

#. type: Plain text
#: en/git-cvsexportcommit.txt:70
#, placeholders:'$Revision':'$Revision', priority:90
msgid "Reverse CVS keyword expansion (e.g. $Revision: 1.2.3.4$ becomes $Revision$) in working CVS checkout before applying patch."
msgstr "在应用补丁之前，在工作的 CVS 签出中反转 CVS 关键字扩展（例如，$Revision: 1.2.3.4$ 变为 $Revision$）。"

#. type: Plain text
#: en/git-cvsexportcommit.txt:76
#, placeholders:'GIT_DIR':'cvsexportcommit.cvsdir', priority:90
msgid "Specify the location of the CVS checkout to use for the export. This option does not require GIT_DIR to be set before execution if the current directory is within a Git repository. The default is the value of 'cvsexportcommit.cvsdir'."
msgstr "指定用于导出的 CVS 签出位置。如果当前目录位于 Git 仓库中，则执行前无需设置 GIT_DIR。 默认值为 'cvsexportcommit.cvsdir'。"

#. type: Plain text
#: en/git-cvsexportcommit.txt:81
#, priority:90
msgid "Tell cvsexportcommit that the current working directory is not only a Git checkout, but also the CVS checkout. Therefore, Git will reset the working directory to the parent commit before proceeding."
msgstr "告诉 cvsexportcommit 当前工作目录不仅是 Git 签出目录，也是 CVS 签出目录。 因此，Git 会在继续之前将工作目录重置为父提交。"

#. type: Plain text
#: en/git-cvsexportcommit.txt:84
#, priority:90
msgid "Verbose."
msgstr "详细模式。"

#. type: Labeled list
#: en/git-cvsexportcommit.txt:87
#, no-wrap, placeholders:'cvsexportcommit.cvsdir', priority:90
msgid "cvsexportcommit.cvsdir"
msgstr "cvsexportcommit.cvsdir"

#. type: Plain text
#: en/git-cvsexportcommit.txt:89
#, priority:90
msgid "The default location of the CVS checkout to use for the export."
msgstr "用于导出的 CVS 签出的默认位置。"

#. type: Labeled list
#: en/git-cvsexportcommit.txt:93
#, no-wrap, priority:90
msgid "Merge one patch into CVS"
msgstr "将一个修补程序合并到 CVS 中"

#. type: delimited block -
#: en/git-cvsexportcommit.txt:100
#, no-wrap, placeholders:'GIT_DIR', priority:90
msgid ""
"$ export GIT_DIR=~/project/.git\n"
"$ cd ~/project_cvs_checkout\n"
"$ git cvsexportcommit -v <commit-sha1>\n"
"$ cvs commit -F .msg <files>\n"
msgstr ""
"$ export GIT_DIR=~/project/.git\n"
"$ cd ~/project_cvs_checkout\n"
"$ git cvsexportcommit -v <提交 sha1>\n"
"$ cvs commit -F .msg <文件>\n"

#. type: Labeled list
#: en/git-cvsexportcommit.txt:102
#, no-wrap, priority:90
msgid "Merge one patch into CVS (-c and -w options). The working directory is within the Git Repo"
msgstr "将一个补丁合并到 CVS（-c 和 -w 选项）。工作目录在 Git 仓库中"

#. type: delimited block -
#: en/git-cvsexportcommit.txt:106
#, no-wrap, priority:90
msgid "\t$ git cvsexportcommit -v -c -w ~/project_cvs_checkout <commit-sha1>\n"
msgstr "\t$ git cvsexportcommit -v -c -w ~/project_cvs_checkout <提交 sha1>\n"

#. type: Labeled list
#: en/git-cvsexportcommit.txt:108
#, no-wrap, priority:90
msgid "Merge pending patches into CVS automatically -- only if you really know what you are doing"
msgstr "自动将待处理的补丁合并到 CVS ——只有当你真正了解自己在做什么时才会这样做"

#. type: delimited block -
#: en/git-cvsexportcommit.txt:114
#, no-wrap, placeholders:'GIT_DIR', priority:90
msgid ""
"$ export GIT_DIR=~/project/.git\n"
"$ cd ~/project_cvs_checkout\n"
"$ git cherry cvshead myhead | sed -n 's/^+ //p' | xargs -l1 git cvsexportcommit -c -p -v\n"
msgstr ""
"$ export GIT_DIR=~/project/.git\n"
"$ cd ~/project_cvs_checkout\n"
"$ git cherry cvshead myhead | sed -n 's/^+ //p' | xargs -l1 git cvsexportcommit -c -p -v\n"

#. type: Title =
#: en/git-cvsimport.txt:2
#, ignore-same, no-wrap, priority:90
msgid "git-cvsimport(1)"
msgstr "git-cvsimport(1)"

#. type: Plain text
#: en/git-cvsimport.txt:7
#, placeholders:'git-cvsimport', priority:90
msgid "git-cvsimport - Salvage your data out of another SCM people love to hate"
msgstr "git-cvsimport - 从另一个让人由爱生恨的 SCM 中获取数据"

#. type: Plain text
#: en/git-cvsimport.txt:17
#, no-wrap, placeholders:'HEAD', priority:90
msgid ""
"'git cvsimport' [-o <branch-for-HEAD>] [-h] [-v] [-d <CVSROOT>]\n"
"\t      [-A <author-conv-file>] [-p <options-for-cvsps>] [-P <file>]\n"
"\t      [-C <git-repository>] [-z <fuzz>] [-i] [-k] [-u] [-s <subst>]\n"
"\t      [-a] [-m] [-M <regex>] [-S <regex>] [-L <commit-limit>]\n"
"\t      [-r <remote>] [-R] [<CVS-module>]\n"
msgstr ""
"'git cvsimport' [-o <HEAD 分支>] [-h] [-v] [-d <CVSROOT>]\n"
"\t      [-A <author-conv-file>] [-p <options-for-cvsps>] [-P <文件>]\n"
"\t      [-C <Git 仓库>] [-z <fuzz>] [-i] [-k] [-u] [-s <subst>]\n"
"\t      [-a] [-m] [-M <正则表达式>] [-S <正则表达式>] [-L <提交范围>]\n"
"\t      [-r <远程仓库>] [-R] [<CVS 模块>]\n"

#. type: Plain text
#: en/git-cvsimport.txt:26
#, placeholders:'http://cvs2svn.tigris.org/cvs2git.html[':'https://gitlab.com/esr/cvs-fast-export[', priority:90
msgid "*WARNING:* `git cvsimport` uses cvsps version 2, which is considered deprecated; it does not work with cvsps version 3 and later. If you are performing a one-shot import of a CVS repository consider using http://cvs2svn.tigris.org/cvs2git.html[cvs2git] or https://gitlab.com/esr/cvs-fast-export[cvs-fast-export]."
msgstr "*警告：* `git cvsimport` 使用 cvsps 第 2 版，该版本已被视为弃用；它不能用于 cvsps 第 3 版及更高版本。 如果要一次性导入 CVS 仓库，请考虑使用 http://cvs2svn.tigris.org/cvs2git.html[cvs2git] 或 https://gitlab.com/esr/cvs-fast-export[cvs-fast-export]。"

#. type: Plain text
#: en/git-cvsimport.txt:29
#, priority:90
msgid "Imports a CVS repository into Git. It will either create a new repository, or incrementally import into an existing one."
msgstr "将 CVS 仓库导入 Git。它既可以创建一个新的仓库，也可以增量导入现有仓库。"

#. type: Plain text
#: en/git-cvsimport.txt:32
#, priority:90
msgid "Splitting the CVS log into patch sets is done by 'cvsps'. At least version 2.1 is required."
msgstr "将 CVS 日志分割成补丁集由 'cvsps' 完成。 至少需要 2.1 版本。"

#. type: Plain text
#: en/git-cvsimport.txt:35
#, placeholders:'<<issues,', priority:90
msgid "*WARNING:* for certain situations the import leads to incorrect results. Please see the section <<issues,ISSUES>> for further reference."
msgstr "*警告：* 在某些情况下，导入会导致不正确的结果。请参阅 <<issues,ISSUES>> 部分以获取更多参考。"

#. type: Plain text
#: en/git-cvsimport.txt:42
#, priority:90
msgid "You should *never* do any work of your own on the branches that are created by 'git cvsimport'. By default initial import will create and populate a \"master\" branch from the CVS repository's main branch which you're free to work with; after that, you need to 'git merge' incremental imports, or any CVS branches, yourself. It is advisable to specify a named remote via -r to separate and protect the incoming branches."
msgstr "您*绝对不*应该在 'git cvsimport' 创建的分支上做任何自己的工作。 默认情况下，初始导入会从 CVS 仓库的主分支创建并填充一个 \"master\" 分支，您可以自由使用该分支；之后，您需要自己 'git merge' 增量导入或任何 CVS 分支。 建议通过 -r 指定一个命名的远程分支，以分隔和保护导入的分支。"

#. type: Plain text
#: en/git-cvsimport.txt:48
#, placeholders:'linkgit:git-cvsserver[1]':'linkgit:gitcvs-migration[7]', priority:90
msgid "If you intend to set up a shared public repository that all developers can read/write, or if you want to use linkgit:git-cvsserver[1], then you probably want to make a bare clone of the imported repository, and use the clone as the shared repository. See linkgit:gitcvs-migration[7]."
msgstr "如果你打算建立一个所有开发者都能读写的共享公共仓库，或者如果你想使用 linkgit:git-cvsserver[1]，那么你可能想做一个导入仓库的裸克隆，并将该克隆作为共享仓库。 参见 linkgit:gitcvs-migration[7]。"

#. type: Plain text
#: en/git-cvsimport.txt:54
#, priority:90
msgid "Verbosity: let 'cvsimport' report what it is doing."
msgstr "Verbosity: 让 'cvsimport' 报告他正在做什么。"

#. type: Labeled list
#: en/git-cvsimport.txt:55
#, no-wrap, priority:90
msgid "-d <CVSROOT>"
msgstr "-d <CVSROOT>"

#. type: Plain text
#: en/git-cvsimport.txt:61
#, priority:90
msgid "The root of the CVS archive. May be local (a simple path) or remote; currently, only the :local:, :ext: and :pserver: access methods are supported. If not given, 'git cvsimport' will try to read it from `CVS/Root`. If no such file exists, it checks for the `CVSROOT` environment variable."
msgstr "CVS 存档的根目录。可以是本地（简单路径）或远程；目前只支持 :local:、:ext: 和 :pserver: 访问方法。如果没有给出，'git cvsimport' 将尝试从 'CVS/Root' 中读取。如果没有此类文件，则会检查 `CVSROOT` 环境变量。"

#. type: Labeled list
#: en/git-cvsimport.txt:62
#, no-wrap, priority:90
msgid "<CVS-module>"
msgstr "<CVS_module>"

#. type: Plain text
#: en/git-cvsimport.txt:66
#, priority:90
msgid "The CVS module you want to import. Relative to <CVSROOT>. If not given, 'git cvsimport' tries to read it from `CVS/Repository`."
msgstr "要导入的 CVS 模块。相对于 <CVSROOT>。 如果没有给出，/git cvsimport' 会尝试从 `CVS/Repository` 中读取。"

#. type: Labeled list
#: en/git-cvsimport.txt:67
#, no-wrap, priority:90
msgid "-C <target-dir>"
msgstr "-C <目标目录>"

#. type: Plain text
#: en/git-cvsimport.txt:70
#, priority:90
msgid "The Git repository to import to. If the directory doesn't exist, it will be created. Default is the current directory."
msgstr "要导入的 Git 仓库。 如果目录不存在，则会创建。 默认为当前目录。"

#. type: Labeled list
#: en/git-cvsimport.txt:71
#, no-wrap, priority:90
msgid "-r <remote>"
msgstr "-r <远程仓库>"

#. type: Plain text
#: en/git-cvsimport.txt:75
#, priority:90
msgid "The Git remote to import this CVS repository into. Moves all CVS branches into remotes/<remote>/<branch> akin to the way 'git clone' uses 'origin' by default."
msgstr "要导入此 CVS 仓库的 Git 远程仓库。 将所有 CVS 分支移至 remotes/<远程仓库>/<分支>，类似于 'git clone' 默认使用 'origin' 的方式。"

#. type: Labeled list
#: en/git-cvsimport.txt:76
#, no-wrap, placeholders:'HEAD', priority:90
msgid "-o <branch-for-HEAD>"
msgstr "-o <branch-for-HEAD>"

#. type: Plain text
#: en/git-cvsimport.txt:84
#, placeholders:'HEAD':'HEAD':'HEAD', priority:90
msgid "When no remote is specified (via -r) the `HEAD` branch from CVS is imported to the 'origin' branch within the Git repository, as `HEAD` already has a special meaning for Git. When a remote is specified the `HEAD` branch is named remotes/<remote>/master mirroring 'git clone' behaviour. Use this option if you want to import into a different branch."
msgstr "如果没有指定远程分支（通过 -r），CVS 中的 `HEAD` 分支会被导入 Git 仓库中的 'origin' 分支，因为 `HEAD` 对 Git 已经有了特殊含义。 如果指定了一个远程分支，`HEAD` 分支就会被命名为 remotes/<远程仓库>/master，以反映 'git clone' 行为。 如果要导入不同的分支，请使用此选项。"

#. type: Plain text
#: en/git-cvsimport.txt:87
#, priority:90
msgid "Use '-o master' for continuing an import that was initially done by the old cvs2git tool."
msgstr "使用 '-o master' 继续导入最初由旧版 cvs2git 工具完成的导入。"

#. type: Plain text
#: en/git-cvsimport.txt:92
#, priority:90
msgid "Import-only: don't perform a checkout after importing. This option ensures the working directory and index remain untouched and will not create them if they do not exist."
msgstr "仅导入：导入后不执行检出。 该选项可确保工作目录和索引保持不变，如果不存在也不会创建。"

#. type: Plain text
#: en/git-cvsimport.txt:97
#, priority:90
msgid "Kill keywords: will extract files with '-kk' from the CVS archive to avoid noisy changesets. Highly recommended, but off by default to preserve compatibility with early imported trees."
msgstr "杀死关键字：将从 CVS 存档中提取带有 '-kk' 的文件，以避免出现嘈杂的更改集。强烈建议使用，但默认为关闭，以保持与早期导入树的兼容性。"

#. type: Plain text
#: en/git-cvsimport.txt:100
#, priority:90
msgid "Convert underscores in tag and branch names to dots."
msgstr "将标记和分支名称中的下划线转换为点。"

#. type: Labeled list
#: en/git-cvsimport.txt:101
#, no-wrap, priority:90
msgid "-s <subst>"
msgstr "-s <subst>"

#. type: Plain text
#: en/git-cvsimport.txt:103
#, priority:90
msgid "Substitute the character \"/\" in branch names with <subst>"
msgstr "用 <subst> 代替分支名称中的字符\"/\""

#. type: Labeled list
#: en/git-cvsimport.txt:104
#, no-wrap, priority:90
msgid "-p <options-for-cvsps>"
msgstr "-p <options-for-cvsps>"

#. type: Plain text
#: en/git-cvsimport.txt:107
#, placeholders:'`-u`', priority:90
msgid "Additional options for cvsps. The options `-u` and '-A' are implicit and should not be used here."
msgstr "cvsps 的附加选项。 选项 `-u` 和 '-A' 是隐含的，不应在此使用。"

#. type: Plain text
#: en/git-cvsimport.txt:109
#, priority:90
msgid "If you need to pass multiple options, separate them with a comma."
msgstr "如果需要传递多个选项，请用逗号分隔。"

#. type: Labeled list
#: en/git-cvsimport.txt:110
#, no-wrap, priority:90
msgid "-z <fuzz>"
msgstr "-z <fuzz>"

#. type: Plain text
#: en/git-cvsimport.txt:113
#, priority:90
msgid "Pass the timestamp fuzz factor to cvsps, in seconds. If unset, cvsps defaults to 300s."
msgstr "向 cvsps 传递时间戳模糊因子，单位为秒。如果未设置，cvsps 默认为 300 秒。"

#. type: Labeled list
#: en/git-cvsimport.txt:114
#, no-wrap, priority:90
msgid "-P <cvsps-output-file>"
msgstr "-P <cvsps 输出文件>"

#. type: Plain text
#: en/git-cvsimport.txt:117
#, priority:90
msgid "Instead of calling cvsps, read the provided cvsps output file. Useful for debugging or when cvsps is being handled outside cvsimport."
msgstr "不调用 cvsps，而是读取提供的 cvsps 输出文件。在调试或在 cvsimport 之外处理 cvsps 时非常有用。"

#. type: Plain text
#: en/git-cvsimport.txt:122
#, priority:90
msgid "Attempt to detect merges based on the commit message. This option will enable default regexes that try to capture the source branch name from the commit message."
msgstr "尝试根据提交信息检测合并。该选项将启用默认的 regexes，尝试从提交信息中捕捉源分支名称。"

#. type: Labeled list
#: en/git-cvsimport.txt:123
#, no-wrap, priority:90
msgid "-M <regex>"
msgstr "-M <正则表达式>"

#. type: Plain text
#: en/git-cvsimport.txt:127
#, placeholders:'`-m`', priority:90
msgid "Attempt to detect merges based on the commit message with a custom regex. It can be used with `-m` to enable the default regexes as well. You must escape forward slashes."
msgstr "尝试使用自定义正则表达式根据提交信息检测合并。也可与 `-m` 搭配使用，启用默认的 regexes。必须转义为正斜杠。"

#. type: Plain text
#: en/git-cvsimport.txt:129
#, priority:90
msgid "The regex must capture the source branch name in $1."
msgstr "正则表达式必须在 $1 中捕获源分支名称。"

#. type: Plain text
#: en/git-cvsimport.txt:131
#, priority:90
msgid "This option can be used several times to provide several detection regexes."
msgstr "该选项可多次使用，以提供多个检测 regexes。"

#. type: Labeled list
#: en/git-cvsimport.txt:132
#, no-wrap, priority:90
msgid "-S <regex>"
msgstr "-S <正则表达式>"

#. type: Plain text
#: en/git-cvsimport.txt:134
#, priority:90
msgid "Skip paths matching the regex."
msgstr "跳过与正则表达式匹配的路径。"

#. type: Plain text
#: en/git-cvsimport.txt:138
#, priority:90
msgid "Import all commits, including recent ones. cvsimport by default skips commits that have a timestamp less than 10 minutes ago."
msgstr "cvsimport 默认跳过时间戳少于 10 分钟的提交。"

#. type: Labeled list
#: en/git-cvsimport.txt:139
#, no-wrap, priority:90
msgid "-L <limit>"
msgstr "-L <限制>"

#. type: Plain text
#: en/git-cvsimport.txt:142
#, priority:90
msgid "Limit the number of commits imported. Workaround for cases where cvsimport leaks memory."
msgstr "限制导入的提交次数。针对 cvsimport 泄露内存情况的解决方法。"

#. type: Labeled list
#: en/git-cvsimport.txt:143
#, no-wrap, priority:90
msgid "-A <author-conv-file>"
msgstr "-A <作者的 conv 文件>"

#. type: Plain text
#: en/git-cvsimport.txt:148
#, priority:90
msgid "CVS by default uses the Unix username when writing its commit logs. Using this option and an author-conv-file maps the name recorded in CVS to author name, e-mail and optional time zone:"
msgstr "CVS 在编写提交日志时默认使用 Unix 用户名。使用此选项和 author-conv 文件可将 CVS 中记录的姓名映射为作者姓名、电子邮件和可选的时区："

#. type: delimited block -
#: en/git-cvsimport.txt:152
#, no-wrap, priority:90
msgid ""
"\texon=Andreas Ericsson <ae@op5.se>\n"
"\tspawn=Simon Pawn <spawn@frog-pond.org> America/Chicago\n"
msgstr ""
"\texon=Andreas Ericsson <ae@op5.se>\n"
"\tspawn=Simon Pawn <spawn@frog-pond.org> America/Chicago\n"

#. type: Plain text
#: en/git-cvsimport.txt:159
#, placeholders:'GIT_AUTHOR_NAME':'GIT_AUTHOR_EMAIL':'GIT_AUTHOR_DATE', priority:90
msgid "'git cvsimport' will make it appear as those authors had their GIT_AUTHOR_NAME and GIT_AUTHOR_EMAIL set properly all along. If a time zone is specified, GIT_AUTHOR_DATE will have the corresponding offset applied."
msgstr "'git cvsimport' 将使这些作者的 GIT_AUTHOR_NAME 和 GIT_AUTHOR_EMAIL 一直设置正确。 如果指定了时区，GIT_AUTHOR_DATE 将应用相应的偏移量。"

#. type: Plain text
#: en/git-cvsimport.txt:163
#, placeholders:'$GIT_DIR', priority:90
msgid "For convenience, this data is saved to `$GIT_DIR/cvs-authors` each time the '-A' option is provided and read from that same file each time 'git cvsimport' is run."
msgstr "为方便起见，每次提供 '-A' 选项时，这些数据都会被保存到 `$GIT_DIR/cvs-authors` 中，每次运行 'git cvsimport' 时，都会从同一文件中读取这些数据。"

#. type: Plain text
#: en/git-cvsimport.txt:167
#, priority:90
msgid "It is not recommended to use this feature if you intend to export changes back to CVS again later with 'git cvsexportcommit'."
msgstr "如果您打算稍后再用 'git cvsexportcommit' 将更改导出回 CVS，则不建议使用此功能。"

#. type: Plain text
#: en/git-cvsimport.txt:173
#, placeholders:'$GIT_DIR', priority:90
msgid "Generate a `$GIT_DIR/cvs-revisions` file containing a mapping from CVS revision numbers to newly-created Git commit IDs. The generated file will contain one line for each (filename, revision) pair imported; each line will look like"
msgstr "生成一个 `$GIT_DIR/cvs-revisions` 文件，其中包含从 CVS 版本号到新创建的 Git 提交 ID 的映射。 生成的文件将为导入的每一对（文件名、修订版）包含一行；每行看起来像"

#. type: delimited block -
#: en/git-cvsimport.txt:176
#, no-wrap, priority:90
msgid "src/widget.c 1.1 1d862f173cdc7325b6fa6d2ae1cfd61fd1b512b7\n"
msgstr "src/widget.c 1.1 1d862f173cdc7325b6fa6d2ae1cfd61fd1b512b7\n"

#. type: Plain text
#: en/git-cvsimport.txt:180
#, priority:90
msgid "The revision data is appended to the file if it already exists, for use when doing incremental imports."
msgstr "如果已存在修订数据，则会将其附加到文件中，以便在进行增量导入时使用。"

#. type: Plain text
#: en/git-cvsimport.txt:183
#, priority:90
msgid "This option may be useful if you have CVS revision numbers stored in commit messages, bug-tracking systems, email archives, and the like."
msgstr "如果在提交信息、错误跟踪系统、电子邮件归档等中存储了 CVS 版本号，该选项可能会很有用。"

#. type: Plain text
#: en/git-cvsimport.txt:186
#, priority:90
msgid "Print a short usage message and exit."
msgstr "打印简短的使用信息并退出。"

#. type: Plain text
#: en/git-cvsimport.txt:190
#, placeholders:'`-v`', priority:90
msgid "If `-v` is specified, the script reports what it is doing."
msgstr "如果指定了 `-v`，脚本会报告它正在做什么。"

#. type: Plain text
#: en/git-cvsimport.txt:193
#, priority:90
msgid "Otherwise, success is indicated the Unix way, i.e. by simply exiting with a zero exit status."
msgstr "否则，将以 Unix 的方式表示成功，即直接以零退出状态退出。"

#. type: Title -
#: en/git-cvsimport.txt:196
#, no-wrap, priority:90
msgid "ISSUES"
msgstr "问题"

#. type: Plain text
#: en/git-cvsimport.txt:198
#, priority:90
msgid "Problems related to timestamps:"
msgstr "与时间戳有关的问题："

#. type: Plain text
#: en/git-cvsimport.txt:202
#, priority:90
msgid "If timestamps of commits in the CVS repository are not stable enough to be used for ordering commits changes may show up in the wrong order."
msgstr "如果 CVS 存储库中提交的时间戳不够稳定，无法用于对提交进行排序，则更改可能会以错误的顺序显示。"

#. type: Plain text
#: en/git-cvsimport.txt:204
#, placeholders:'HEAD', priority:90
msgid "If any files were ever \"cvs import\"ed more than once (e.g., import of more than one vendor release) the HEAD contains the wrong content."
msgstr "如果任何文件曾被多次 \"cvs import\"（如导入多个供应商发布的版本），则 HEAD 包含错误的内容。"

#. type: Plain text
#: en/git-cvsimport.txt:207
#, priority:90
msgid "If the timestamp order of different files cross the revision order within the commit matching time window the order of commits may be wrong."
msgstr "如果在提交匹配时间窗口内，不同文件的时间戳顺序与修订顺序不一致，提交顺序可能会出错。"

#. type: Plain text
#: en/git-cvsimport.txt:209
#, priority:90
msgid "Problems related to branches:"
msgstr "与分支机构有关的问题:"

#. type: Plain text
#: en/git-cvsimport.txt:211
#, priority:90
msgid "Branches on which no commits have been made are not imported."
msgstr "未提交的分支不会被导入。"

#. type: Plain text
#: en/git-cvsimport.txt:213
#, priority:90
msgid "All files from the branching point are added to a branch even if never added in CVS."
msgstr "分支点的所有文件都会添加到分支中，即使从未在 CVS 中添加过。"

#. type: Plain text
#: en/git-cvsimport.txt:216
#, priority:90
msgid "This applies to files added to the source branch *after* a daughter branch was created: if previously no commit was made on the daughter branch they will erroneously be added to the daughter branch in git."
msgstr "这适用于在创建子分支*之后*添加到源分支的文件：如果之前没有在子分支上提交，这些文件就会在 git 中被错误地添加到子分支上。"

#. type: Plain text
#: en/git-cvsimport.txt:218
#, priority:90
msgid "Problems related to tags:"
msgstr "与标签有关的问题："

#. type: Plain text
#: en/git-cvsimport.txt:220
#, priority:90
msgid "Multiple tags on the same revision are not imported."
msgstr "不会导入同一修订版上的多个标记。"

#. type: Plain text
#: en/git-cvsimport.txt:223
#, priority:90
msgid "If you suspect that any of these issues may apply to the repository you want to import, consider using cvs2git:"
msgstr "如果您怀疑要导入的仓库可能存在上述问题，请考虑使用 cvs2git："

#. type: Plain text
#: en/git-cvsimport.txt:225
#, placeholders:'subversion.apache.org', priority:90
msgid "cvs2git (part of cvs2svn), `https://subversion.apache.org/`"
msgstr "cvs2git（cvs2svn 的一部分），`http://subversion.apache.org/`"

#. type: Title =
#: en/git-cvsserver.txt:2
#, ignore-same, no-wrap, priority:90
msgid "git-cvsserver(1)"
msgstr "git-cvsserver(1)"

#. type: Plain text
#: en/git-cvsserver.txt:7
#, placeholders:'git-cvsserver', priority:90
msgid "git-cvsserver - A CVS server emulator for Git"
msgstr "git-cvsserver - Git 的 CVS 服务器模拟器"

#. type: Plain text
#: en/git-cvsserver.txt:12
#, priority:90
msgid "SSH:"
msgstr "SSH:"

#. type: Plain text
#: en/git-cvsserver.txt:16
#, no-wrap, placeholders:'CVS_SERVER', priority:90
msgid ""
"export CVS_SERVER=\"git cvsserver\"\n"
"'cvs' -d :ext:user@server/path/repo.git co <HEAD_name>\n"
msgstr ""
"export CVS_SERVER=\"git cvsserver\"\n"
"'cvs' -d :ext:user@server/path/repo.git co <HEAD 名称>\n"

#. type: Plain text
#: en/git-cvsserver.txt:18
#, placeholders:'inetd.conf', priority:90
msgid "pserver (/etc/inetd.conf):"
msgstr "pserver (/etc/inetd.conf):"

#. type: Plain text
#: en/git-cvsserver.txt:21
#, no-wrap, placeholders:'git-cvsserver':'git-cvsserver', priority:90
msgid "cvspserver stream tcp nowait nobody /usr/bin/git-cvsserver git-cvsserver pserver\n"
msgstr "无人值守的 cvspserver tcp 流服务器 /usr/bin/git-cvsserver git-cvsserver pserver\n"

#. type: Plain text
#: en/git-cvsserver.txt:23
#, priority:90
msgid "Usage:"
msgstr "用法："

#. type: Plain text
#: en/git-cvsserver.txt:26
#, ignore-ellipsis, no-wrap, placeholders:'git-cvsserver', priority:90
msgid "'git-cvsserver' [<options>] [pserver|server] [<directory> ...]\n"
msgstr "'git-cvsserver' [<多个选项>] [pserver|server] [<目录> ...]\n"

#. type: Plain text
#: en/git-cvsserver.txt:31
#, priority:90
msgid "This application is a CVS emulation layer for Git."
msgstr "该程序是 Git 的 CVS 仿真层。"

#. type: Plain text
#: en/git-cvsserver.txt:35
#, priority:90
msgid "It is highly functional. However, not all methods are implemented, and for those methods that are implemented, not all switches are implemented."
msgstr "它的功能性很强。然而，并非所有方法都能实现，而对于那些已实现的方法，并非所有开关都能实现。"

#. type: Plain text
#: en/git-cvsserver.txt:38
#, priority:90
msgid "Testing has been done using both the CLI CVS client, and the Eclipse CVS plugin. Most functionality works fine with both of these clients."
msgstr "测试使用 CLI CVS 客户端和 Eclipse CVS 插件进行。大多数功能在这两个客户端上都能正常运行。"

#. type: Plain text
#: en/git-cvsserver.txt:45
#, placeholders:'linkgit:git-daemon[1]', priority:90
msgid "All these options obviously only make sense if enforced by the server side. They have been implemented to resemble the linkgit:git-daemon[1] options as closely as possible."
msgstr "所有这些选项显然只有在服务器端执行时才有意义。 这些选项的实现尽可能与 linkgit:git-daemon[1] 选项相似。"

#. type: Labeled list
#: en/git-cvsserver.txt:46
#, no-wrap, placeholders:'--base-path', priority:90
msgid "--base-path <path>"
msgstr "--base-path <路径>"

#. type: Plain text
#: en/git-cvsserver.txt:48
#, priority:90
msgid "Prepend 'path' to requested CVSROOT"
msgstr "在请求的 CVSROOT 前加上 ‘路径’"

#. type: Labeled list
#: en/git-cvsserver.txt:49 en/git-daemon.txt:49
#, ignore-same, no-wrap, priority:100
msgid "--strict-paths"
msgstr "--strict-paths"

#. type: Plain text
#: en/git-cvsserver.txt:51
#, priority:90
msgid "Don't allow recursing into subdirectories"
msgstr "不允许递归到子目录中"

#. type: Labeled list
#: en/git-cvsserver.txt:52 en/git-daemon.txt:78
#, ignore-same, no-wrap, priority:100
msgid "--export-all"
msgstr "--export-all"

#. type: Plain text
#: en/git-cvsserver.txt:55
#, placeholders:'gitcvs.enabled', priority:90
msgid "Don't check for `gitcvs.enabled` in config. You also have to specify a list of allowed directories (see below) if you want to use this option."
msgstr "不要在配置中检查 `gitcvs.enabled`。如果要使用此选项，还必须指定允许使用的目录列表（见下文）。"

#. type: Labeled list
#: en/git-cvsserver.txt:56
#, ignore-same, no-wrap, priority:90
msgid "-V"
msgstr "-V"

#. type: Labeled list
#: en/git-cvsserver.txt:57 en/git.txt:42
#, ignore-same, no-wrap, priority:100
msgid "--version"
msgstr "--version"

#. type: Plain text
#: en/git-cvsserver.txt:59
#, priority:90
msgid "Print version information and exit"
msgstr "打印版本信息并退出"

#. type: Labeled list
#: en/git-cvsserver.txt:62 en/git.txt:50
#, ignore-same, no-wrap, priority:100
msgid "--help"
msgstr "--help"

#. type: Plain text
#: en/git-cvsserver.txt:64
#, priority:90
msgid "Print usage information and exit"
msgstr "打印使用信息并退出"

#. type: Plain text
#: en/git-cvsserver.txt:70
#, placeholders:'gitcvs.enabled':'`--export-all`', priority:90
msgid "The remaining arguments provide a list of directories. If no directories are given, then all are allowed. Repositories within these directories still require the `gitcvs.enabled` config option, unless `--export-all` is specified."
msgstr "其余参数提供了一个目录列表。如果没有给出目录，则允许所有目录。除非指定了 `--export-all`，否则这些目录中的仓库仍需要使用 `gitcvs.enabled` 配置选项。"

#. type: Title -
#: en/git-cvsserver.txt:72 en/git-fast-export.txt:272
#, no-wrap, priority:90
msgid "LIMITATIONS"
msgstr "局限"

#. type: Plain text
#: en/git-cvsserver.txt:75
#, priority:90
msgid "CVS clients cannot tag, branch or perform Git merges."
msgstr "CVS 客户端不能标记、分支或执行 Git 合并。"

#. type: Plain text
#: en/git-cvsserver.txt:79
#, placeholders:'git-cvsserver', priority:90
msgid "'git-cvsserver' maps Git branches to CVS modules. This is very different from what most CVS users would expect since in CVS modules usually represent one or more directories."
msgstr "'git-cvsserver' 将 Git 分支映射到 CVS 模块。这与大多数 CVS 用户的预期大相径庭，因为在 CVS 中，模块通常代表一个或多个目录。"

#. type: Title -
#: en/git-cvsserver.txt:81
#, no-wrap, priority:90
msgid "INSTALLATION"
msgstr "安装"

#. type: Plain text
#: en/git-cvsserver.txt:85
#, placeholders:'inetd.conf', priority:90
msgid "If you are going to offer CVS access via pserver, add a line in /etc/inetd.conf like"
msgstr "如果要通过 pserver 提供 CVS 访问，请在 /etc/inetd.conf 中添加一行，如"

#. type: delimited block -
#: en/git-cvsserver.txt:89
#, no-wrap, placeholders:'git-cvsserver', priority:90
msgid "   cvspserver stream tcp nowait nobody git-cvsserver pserver\n"
msgstr "   cvspserver stream tcp nowait nobody git-cvsserver pserver\n"

#. type: Plain text
#: en/git-cvsserver.txt:95
#, placeholders:'inetd.conf', priority:90
msgid "Note: Some inetd servers let you specify the name of the executable independently of the value of argv[0] (i.e. the name the program assumes it was executed with). In this case the correct line in /etc/inetd.conf looks like"
msgstr "注意：有些 inetd 服务器允许您独立于 argv[0] 的值（即程序假定执行的名称）指定可执行文件的名称。在这种情况下，/etc/inetd.conf 中的正确行应如下所示"

#. type: delimited block -
#: en/git-cvsserver.txt:98
#, no-wrap, placeholders:'git-cvsserver':'git-cvsserver', priority:90
msgid "   cvspserver stream tcp nowait nobody /usr/bin/git-cvsserver git-cvsserver pserver\n"
msgstr "   cvspserver stream tcp nowait nobody /usr/bin/git-cvsserver git-cvsserver pserver\n"

#. type: Plain text
#: en/git-cvsserver.txt:105
#, placeholders:'gitcvs.authdb', priority:90
msgid "Only anonymous access is provided by pserver by default. To commit you will have to create pserver accounts, simply add a gitcvs.authdb setting in the config file of the repositories you want the cvsserver to allow writes to, for example:"
msgstr "pserver 默认只提供匿名访问。要提交您必须创建的 pserver 账户，只需在您希望 cvsserver 允许写入的软件源的配置文件中添加 gitcvs.authdb 设置即可，例如:"

#. type: delimited block -
#: en/git-cvsserver.txt:110
#, no-wrap, priority:90
msgid ""
"   [gitcvs]\n"
"\tauthdb = /etc/cvsserver/passwd\n"
msgstr ""
"   [gitcvs]\n"
"\tauthdb = /etc/cvsserver/passwd\n"

#. type: Plain text
#: en/git-cvsserver.txt:114
#, priority:90
msgid "The format of these files is username followed by the encrypted password, for example:"
msgstr "例如，这些文件的格式是用户名，然后是加密密码:"

#. type: delimited block -
#: en/git-cvsserver.txt:119
#, no-wrap, placeholders:'$VfF6EoPYCJEYcVQwATgOP':'$znZIcumu1tNLATgV2l6e1', priority:90
msgid ""
"   myuser:sqkNi8zPf01HI\n"
"   myuser:$1$9K7FzU28$VfF6EoPYCJEYcVQwATgOP/\n"
"   myuser:$5$.NqmNH1vwfzGpV8B$znZIcumu1tNLATgV2l6e1/mY8RzhUDHMOaVOeL1cxV3\n"
msgstr ""
"   myuser:sqkNi8zPf01HI\n"
"   myuser:$1$9K7FzU28$VfF6EoPYCJEYcVQwATgOP/\n"
"   myuser:$5$.NqmNH1vwfzGpV8B$znZIcumu1tNLATgV2l6e1/mY8RzhUDHMOaVOeL1cxV3\n"

#. type: Plain text
#: en/git-cvsserver.txt:122
#, priority:90
msgid "You can use the 'htpasswd' facility that comes with Apache to make these files, but only with the -d option (or -B if your system supports it)."
msgstr "您可以使用 Apache 自带的 'htpasswd' 工具来创建这些文件，但只能使用 -d 选项（如果您的系统支持 -B）。"

#. type: Plain text
#: en/git-cvsserver.txt:126
#, priority:90
msgid "Preferably use the system specific utility that manages password hash creation in your platform (e.g. mkpasswd in Linux, encrypt in OpenBSD or pwhash in NetBSD) and paste it in the right location."
msgstr "最好使用在您的平台上管理密码哈希创建的特定系统实用程序（例如 Linux 中的 mkpasswd、OpenBSD 中的 encrypt 或 NetBSD 中的 pwhash），然后将其粘贴到正确的位置。"

#. type: Plain text
#: en/git-cvsserver.txt:128
#, priority:90
msgid "Then provide your password via the pserver method, for example:"
msgstr "然后通过 pserver 方法提供密码，例如:"

#. type: delimited block -
#: en/git-cvsserver.txt:130
#, no-wrap, priority:90
msgid "   cvs -d:pserver:someuser:somepassword@server:/path/repo.git co <HEAD_name>\n"
msgstr "   cvs -d:pserver:someuser:somepassword@server:/path/repo.git co <HEAD 名>\n"

#. type: Plain text
#: en/git-cvsserver.txt:134
#, placeholders:'CVS_SERVER':'git-cvsserver', priority:90
msgid "No special setup is needed for SSH access, other than having Git tools in the PATH. If you have clients that do not accept the CVS_SERVER environment variable, you can rename 'git-cvsserver' to `cvs`."
msgstr "SSH 访问无需特殊设置，只需在 PATH 中安装 Git 工具即可。如果客户端不接受 CVS_SERVER 环境变量，可以将 'git-cvsserver' 更名为 `cvs`。"

#. type: Plain text
#: en/git-cvsserver.txt:137
#, placeholders:'CVS_SERVER', priority:90
msgid "Note: Newer CVS versions (>= 1.12.11) also support specifying CVS_SERVER directly in CVSROOT like"
msgstr "注意：较新的 CVS 版本（>= 1.12.11）也支持直接在 CVSROOT 中指定 CVS_SERVER，如"

#. type: delimited block -
#: en/git-cvsserver.txt:140
#, no-wrap, placeholders:'CVS_SERVER', priority:90
msgid "   cvs -d \":ext;CVS_SERVER=git cvsserver:user@server/path/repo.git\" co <HEAD_name>\n"
msgstr "   cvs -d \":ext;CVS_SERVER=git cvsserver:user@server/path/repo.git\" co <HEAD 名称>\n"

#. type: Plain text
#: en/git-cvsserver.txt:146
#, placeholders:'git-shell':'CVS_SERVER':'git-shell':'git-cvsserver', priority:90
msgid "This has the advantage that it will be saved in your 'CVS/Root' files and you don't need to worry about always setting the correct environment variable. SSH users restricted to 'git-shell' don't need to override the default with CVS_SERVER (and shouldn't) as 'git-shell' understands `cvs` to mean 'git-cvsserver' and pretends that the other end runs the real 'cvs' better."
msgstr "这样做的好处是，它将保存在你的 'CVS/Root' 文件中，你不必担心总是设置正确的环境变量。 受限于 'git-shell' 的 SSH 用户不需要（也不应该）用 CVS_SERVER 覆盖默认值，因为 'git-shell' 会将 `cvs` 理解为 'git-cvsserver'，并假装另一端运行的是真正的 'cvs'。"

#. type: Plain text
#: en/git-cvsserver.txt:149
#, priority:90
msgid "For each repo that you want accessible from CVS you need to edit config in the repo and add the following section."
msgstr "对于希望从 CVS 访问的每个仓库，都需要在仓库中编辑配置并添加以下部分。"

#. type: delimited block -
#: en/git-cvsserver.txt:156
#, no-wrap, priority:90
msgid ""
"   [gitcvs]\n"
"        enabled=1\n"
"        # optional for debugging\n"
"\tlogFile=/path/to/logfile\n"
msgstr ""
"   [gitcvs]\n"
"        enabled=1\n"
"        # 可选项，用于调试\n"
"\tlogFile=/path/to/logfile\n"

#. type: Plain text
#: en/git-cvsserver.txt:162
#, placeholders:'git-cvsserver':'<<dbbackend,', priority:90
msgid "Note: you need to ensure each user that is going to invoke 'git-cvsserver' has write access to the log file and to the database (see <<dbbackend,Database Backend>>. If you want to offer write access over SSH, the users of course also need write access to the Git repository itself."
msgstr "注意：需要确保每个调用 'git-cvsserver' 的用户都有写入日志文件和数据库的权限（参见 <<dbbackend,数据库后台>>）。如果要通过 SSH 提供写访问权限，用户当然也需要有写访问 Git 仓库本身的权限。"

#. type: Plain text
#: en/git-cvsserver.txt:165
#, placeholders:'linkgit:gitcvs-migration[7]', priority:90
msgid "You also need to ensure that each repository is \"bare\" (without a Git index file) for `cvs commit` to work. See linkgit:gitcvs-migration[7]."
msgstr "你还需要确保每个仓库都是 \"裸仓库\"（没有 Git 索引文件），这样 `cvs commit` 才能工作。参见 linkgit:gitcvs-migration[7]。"

#. type: Plain text
#: en/git-cvsserver.txt:171
#, priority:90
msgid "All configuration variables can also be overridden for a specific method of access. Valid method names are \"ext\" (for SSH access) and \"pserver\". The following example configuration would disable pserver access while still allowing access over SSH."
msgstr "所有配置变量都可以针对特定的访问方法进行重载。有效的方法名称是 \"ext\"（用于 SSH 访问）和 \"pserver\"。下面的配置示例将禁止 pserver 访问，但仍允许通过 SSH 访问。"

#. type: delimited block -
#: en/git-cvsserver.txt:174
#, no-wrap, priority:90
msgid ""
"   [gitcvs]\n"
"        enabled=0\n"
msgstr ""
"   [gitcvs]\n"
"        enabled=0\n"

#. type: delimited block -
#: en/git-cvsserver.txt:177
#, no-wrap, priority:90
msgid ""
"   [gitcvs \"ext\"]\n"
"        enabled=1\n"
msgstr ""
"   [gitcvs \"ext\"]\n"
"        enabled=1\n"

#. type: Plain text
#: en/git-cvsserver.txt:184
#, placeholders:'CVS_SERVER':'git-shell':'CVS_SERVER':'git-cvsserver', priority:90
msgid "If you didn't specify the CVSROOT/CVS_SERVER directly in the checkout command, automatically saving it in your 'CVS/Root' files, then you need to set them explicitly in your environment. CVSROOT should be set as per normal, but the directory should point at the appropriate Git repo. As above, for SSH clients _not_ restricted to 'git-shell', CVS_SERVER should be set to 'git-cvsserver'."
msgstr "如果您没有在签出命令中直接指定 CVSROOT/CVS_SERVER，而是将其自动保存在 'CVS/Root' 文件中，那么您就需要在环境中明确设置它们。 CVSROOT 应按常规设置，但目录应指向相应的 Git 仓库。 如上所述，对于不受限于 'git-shell' 的 SSH 客户端，CVS_SERVER 应设置为 'git-cvsserver'。"

#. type: delimited block -
#: en/git-cvsserver.txt:189
#, no-wrap, placeholders:'CVS_SERVER', priority:90
msgid ""
"   export CVSROOT=:ext:user@server:/var/git/project.git\n"
"   export CVS_SERVER=\"git cvsserver\"\n"
msgstr ""
"   export CVSROOT=:ext:user@server:/var/git/project.git\n"
"   export CVS_SERVER=\"git cvsserver\"\n"

#. type: Plain text
#: en/git-cvsserver.txt:196
#, placeholders:'GIT_AUTHOR_NAME':'GIT_AUTHOR_EMAIL':'GIT_COMMITTER_NAME':'GIT_COMMITTER_EMAIL', priority:90
msgid "For SSH clients that will make commits, make sure their server-side .ssh/environment files (or .bashrc, etc., according to their specific shell) export appropriate values for GIT_AUTHOR_NAME, GIT_AUTHOR_EMAIL, GIT_COMMITTER_NAME, and GIT_COMMITTER_EMAIL. For SSH clients whose login shell is bash, .bashrc may be a reasonable alternative."
msgstr "对于会进行提交的 SSH 客户端，请确保其服务器端的 .ssh/environment 文件（或 .bashrc 等，根据其特定的 shell）导出了适当的 GIT_AUTHOR_NAME、GIT_AUTHOR_EMAIL、GIT_COMMITTER_NAME 和 GIT_COMMITTER_EMAIL 值。 对于登录 shell 为 bash 的 SSH 客户端，.bashrc 可能是一个合理的替代方案。"

#. type: Plain text
#: en/git-cvsserver.txt:202
#, priority:90
msgid "Clients should now be able to check out the project. Use the CVS 'module' name to indicate what Git 'head' you want to check out. This also sets the name of your newly checked-out directory, unless you tell it otherwise with `-d <dir-name>`. For example, this checks out 'master' branch to the `project-master` directory:"
msgstr "客户现在应该可以签出项目了。使用 CVS 'module'（模块）名称来指明你要签出的 Git 'head'（头）。 这也会设置新签出目录的名称，除非你用 `-d <目录名>` 另作说明。 例如，这将签出 'master' 分支到 `project-master` 目录："

#. type: delimited block -
#: en/git-cvsserver.txt:205
#, no-wrap, priority:90
msgid "   cvs co -d project-master master\n"
msgstr "   cvs co -d project-master master\n"

#. type: Title -
#: en/git-cvsserver.txt:209
#, no-wrap, priority:90
msgid "DATABASE BACKEND"
msgstr "数据库后台"

#. type: Plain text
#: en/git-cvsserver.txt:215
#, placeholders:'git-cvsserver', priority:90
msgid "'git-cvsserver' uses one database per Git head (i.e. CVS module) to store information about the repository to maintain consistent CVS revision numbers. The database needs to be updated (i.e. written to) after every commit."
msgstr "'git-cvsserver' 为每个 Git 头（即 CVS 模块）使用一个数据库来存储有关仓库的信息，以保持一致的 CVS 版本号。每次提交后都需要更新（即写入）数据库。"

#. type: Plain text
#: en/git-cvsserver.txt:220
#, placeholders:'git-cvsserver':'git-cvsserver', priority:90
msgid "If the commit is done directly by using `git` (as opposed to using 'git-cvsserver') the update will need to happen on the next repository access by 'git-cvsserver', independent of access method and requested operation."
msgstr "如果直接使用 `git`（而不是使用 'git-cvsserver'）提交，则更新需要在下一次使用 'git-cvsserver' 访问仓库时进行，与访问方式和请求的操作无关。"

#. type: Plain text
#: en/git-cvsserver.txt:225
#, placeholders:'git-cvsserver':'git-cvsserver', priority:90
msgid "That means that even if you offer only read access (e.g. by using the pserver method), 'git-cvsserver' should have write access to the database to work reliably (otherwise you need to make sure that the database is up to date any time 'git-cvsserver' is executed)."
msgstr "这就意味着，即使只提供读取访问权限（例如使用 pserver 方法），'git-cvsserver' 也必须拥有对数据库的写入访问权限，才能可靠地工作（否则就需要确保在执行 'git-cvsserver' 的任何时候数据库都是最新的）。"

#. type: Plain text
#: en/git-cvsserver.txt:232
#, placeholders:'git-cvsserver', priority:90
msgid "By default it uses SQLite databases in the Git directory, named `gitcvs.<module-name>.sqlite`. Note that the SQLite backend creates temporary files in the same directory as the database file on write so it might not be enough to grant the users using 'git-cvsserver' write access to the database file without granting them write access to the directory, too."
msgstr "默认情况下，它使用 Git 目录中的 SQLite 数据库，名为 `gitcvs.<模块名>.sqlite`。请注意，SQLite 后端在写入时会在与数据库文件相同的目录下创建临时文件，因此只授予使用 'git-cvsserver' 的用户对数据库文件的写入权限，而不授予他们对目录的写入权限可能是不够的。"

#. type: Plain text
#: en/git-cvsserver.txt:244
#, placeholders:'git-cvsserver':'git-cvsserver', priority:90
msgid "The database cannot be reliably regenerated in a consistent form after the branch it is tracking has changed. Example: For merged branches, 'git-cvsserver' only tracks one branch of development, and after a 'git merge' an incrementally updated database may track a different branch than a database regenerated from scratch, causing inconsistent CVS revision numbers. `git-cvsserver` has no way of knowing which branch it would have picked if it had been run incrementally pre-merge. So if you have to fully or partially (from old backup) regenerate the database, you should be suspicious of pre-existing CVS sandboxes."
msgstr "跟踪的分支发生变化后，数据库无法以一致的形式可靠地重新生成。 例如对于合并的分支，'git-cvsserver' 只能跟踪一个开发分支，而在 'git merge' 之后，增量更新的数据库可能会与从头开始生成的数据库跟踪不同的分支，从而导致 CVS 版本号不一致。如果在合并前增量运行，`git-cvsserver` 无法知道自己会选择哪个分支。因此，如果你必须全部或部分（从旧备份）重新生成数据库，你就应该对已经存在的 CVS 沙箱有所怀疑。"

#. type: Plain text
#: en/git-cvsserver.txt:247
#, priority:90
msgid "You can configure the database backend with the following configuration variables:"
msgstr "您可以使用以下配置变量配置数据库后台："

#. type: Title ~
#: en/git-cvsserver.txt:249
#, no-wrap, priority:90
msgid "Configuring database backend"
msgstr "配置数据库后台"

#. type: Plain text
#: en/git-cvsserver.txt:254
#, placeholders:'git-cvsserver', priority:90
msgid "'git-cvsserver' uses the Perl DBI module. Please also read its documentation if changing these variables, especially about `DBI->connect()`."
msgstr "'git-cvsserver' 使用 Perl DBI 模块。如果要更改这些变量，请阅读其文档，尤其是有关 `DBI->connect()` 的文档。"

#. type: Labeled list
#: en/git-cvsserver.txt:255
#, no-wrap, placeholders:'gitcvs.dbName', priority:90
msgid "gitcvs.dbName"
msgstr "gitcvs.dbName"

#. type: Plain text
#: en/git-cvsserver.txt:261
#, placeholders:'m.sqlite', priority:90
msgid "Database name. The exact meaning depends on the selected database driver, for SQLite this is a filename. Supports variable substitution (see below). May not contain semicolons (`;`). Default: '%Ggitcvs.%m.sqlite'"
msgstr "数据库名称。具体含义取决于所选的数据库驱动程序，对于 SQLite，这是一个文件名。 支持变量替换（见下文）。不得包含分号 (`;`)。 默认：'%Ggitcvs.%m.sqlite'"

#. type: Labeled list
#: en/git-cvsserver.txt:262
#, no-wrap, placeholders:'gitcvs.dbDriver', priority:90
msgid "gitcvs.dbDriver"
msgstr "gitcvs.dbDriver"

#. type: Plain text
#: en/git-cvsserver.txt:270
#, priority:90
msgid "Used DBI driver. You can specify any available driver for this here, but it might not work. cvsserver is tested with 'DBD::SQLite', reported to work with 'DBD::Pg', and reported *not* to work with 'DBD::mysql'. Please regard this as an experimental feature. May not contain colons (`:`). Default: 'SQLite'"
msgstr "使用的 DBI 驱动程序。cvsserver 已使用 'DBD::SQLite' 进行了测试，据报告可使用 'DBD::Pg'，但*不*能使用 'DBD::mysql'。 请将其视为试验性功能。不得包含冒号 (`:`)。 默认：'SQLite'"

#. type: Labeled list
#: en/git-cvsserver.txt:271
#, no-wrap, placeholders:'gitcvs.dbuser', priority:90
msgid "gitcvs.dbuser"
msgstr "gitcvs.dbuser"

#. type: Plain text
#: en/git-cvsserver.txt:275
#, priority:90
msgid "Database user. Only useful if setting `dbDriver`, since SQLite has no concept of database users. Supports variable substitution (see below)."
msgstr "数据库用户。只有在设置 `dbDriver` 时才有用，因为 SQLite 没有数据库用户的概念。支持变量替换（见下文）。"

#. type: Labeled list
#: en/git-cvsserver.txt:276
#, no-wrap, placeholders:'gitcvs.dbPass', priority:90
msgid "gitcvs.dbPass"
msgstr "gitcvs.dbPass"

#. type: Plain text
#: en/git-cvsserver.txt:279
#, priority:90
msgid "Database password. Only useful if setting `dbDriver`, since SQLite has no concept of database passwords."
msgstr "数据库密码。 只有在设置 `dbDriver` 时才有用，因为 SQLite 没有数据库密码的概念。"

#. type: Labeled list
#: en/git-cvsserver.txt:280
#, no-wrap, placeholders:'gitcvs.dbTableNamePrefix', priority:90
msgid "gitcvs.dbTableNamePrefix"
msgstr "gitcvs.dbTableNamePrefix"

#. type: Plain text
#: en/git-cvsserver.txt:284
#, priority:90
msgid "Database table name prefix. Supports variable substitution (see below). Any non-alphabetic characters will be replaced with underscores."
msgstr "数据库表名前缀。 支持变量替换（见下文）。 任何非字母字符都将用下划线代替。"

#. type: Plain text
#: en/git-cvsserver.txt:286
#, placeholders:'<<configaccessmethod,', priority:90
msgid "All variables can also be set per access method, see <<configaccessmethod,above>>."
msgstr "所有变量也可按访问方法设置，请参阅<<configaccessmethod,上文>>。"

#. type: Title ^
#: en/git-cvsserver.txt:288
#, no-wrap, priority:90
msgid "Variable substitution"
msgstr "变量替换"

#. type: Plain text
#: en/git-cvsserver.txt:290
#, priority:90
msgid "In `dbDriver` and `dbUser` you can use the following variables:"
msgstr "在 `dbDriver` 和 `dbUser` 中，可以使用以下变量："

#. type: Labeled list
#: en/git-cvsserver.txt:291
#, ignore-same, no-wrap, priority:90
msgid "%G"
msgstr "%G"

#. type: Plain text
#: en/git-cvsserver.txt:293
#, priority:90
msgid "Git directory name"
msgstr "Git 目录名称"

#. type: Labeled list
#: en/git-cvsserver.txt:293
#, ignore-same, no-wrap, priority:90
msgid "%g"
msgstr "%g"

#. type: Plain text
#: en/git-cvsserver.txt:298
#, priority:90
msgid "Git directory name, where all characters except for alphanumeric ones, `.`, and `-` are replaced with `_` (this should make it easier to use the directory name in a filename if wanted)"
msgstr "Git 目录名称，其中除字母数字、`.` 和 `-` 之外的所有字符均替换为 `_`（这样可以方便在文件名中使用该目录名称）"

#. type: Labeled list
#: en/git-cvsserver.txt:298
#, ignore-same, no-wrap, priority:90
msgid "%m"
msgstr "%m"

#. type: Plain text
#: en/git-cvsserver.txt:300
#, priority:90
msgid "CVS module/Git head name"
msgstr "CVS 模块/Git 头名称"

#. type: Labeled list
#: en/git-cvsserver.txt:300
#, ignore-same, no-wrap, priority:90
msgid "%a"
msgstr "%a"

#. type: Plain text
#: en/git-cvsserver.txt:302
#, priority:90
msgid "access method (one of \"ext\" or \"pserver\")"
msgstr "访问方法（\"ext\" 或 \"pserver\" 之一）"

#. type: Labeled list
#: en/git-cvsserver.txt:302
#, ignore-same, no-wrap, priority:90
msgid "%u"
msgstr "%u"

#. type: Plain text
#: en/git-cvsserver.txt:306
#, placeholders:'git-cvsserver', priority:90
msgid "Name of the user running 'git-cvsserver'. If no name can be determined, the numeric uid is used."
msgstr "运行 'git-cvsserver' 的用户名。 如果无法确定用户名，则使用数字 uid。"

#. type: Plain text
#: en/git-cvsserver.txt:312
#, placeholders:'git-shell', priority:90
msgid "These variables obviate the need for command-line options in some circumstances, allowing easier restricted usage through git-shell."
msgstr "在某些情况下，这些变量省去了命令行选项，从而可以通过 git-shell 更方便地限制使用。"

#. type: Labeled list
#: en/git-cvsserver.txt:313
#, ignore-same, no-wrap, priority:90
msgid "GIT_CVSSERVER_BASE_PATH"
msgstr "GIT_CVSSERVER_BASE_PATH"

#. type: Plain text
#: en/git-cvsserver.txt:315
#, placeholders:'--base-path', priority:90
msgid "This variable replaces the argument to --base-path."
msgstr "该变量取代 --base-path 的参数。"

#. type: Labeled list
#: en/git-cvsserver.txt:316
#, ignore-same, no-wrap, priority:90
msgid "GIT_CVSSERVER_ROOT"
msgstr "GIT_CVSSERVER_ROOT"

#. type: Plain text
#: en/git-cvsserver.txt:320
#, ignore-ellipsis, placeholders:'gitcvs.enabled':'`--export-all`', priority:90
msgid "This variable specifies a single directory, replacing the `<directory>...` argument list. The repository still requires the `gitcvs.enabled` config option, unless `--export-all` is specified."
msgstr "该变量指定了一个单一目录，取代了 `<目录>...` 参数列表。除非指定了 `--export-all`，否则仓库仍需要使用 `gitcvs.enabled` 配置选项。"

#. type: Plain text
#: en/git-cvsserver.txt:323
#, priority:90
msgid "When these environment variables are set, the corresponding command-line arguments may not be used."
msgstr "设置这些环境变量后，可能无法使用相应的命令行参数。"

#. type: Title -
#: en/git-cvsserver.txt:325
#, no-wrap, priority:90
msgid "ECLIPSE CVS CLIENT NOTES"
msgstr "ECLIPSE CVS 客户端说明"

#. type: Plain text
#: en/git-cvsserver.txt:328
#, priority:90
msgid "To get a checkout with the Eclipse CVS client:"
msgstr "使用 Eclipse CVS 客户端进行签出："

#. type: Plain text
#: en/git-cvsserver.txt:330
#, priority:90
msgid "Select \"Create a new project -> From CVS checkout\""
msgstr "选择 \"创建新项目 -> 从 CVS 签出\""

#. type: Plain text
#: en/git-cvsserver.txt:332
#, priority:90
msgid "Create a new location. See the notes below for details on how to choose the right protocol."
msgstr "创建新位置。有关如何选择正确协议的详细信息，请参阅下面的说明。"

#. type: Plain text
#: en/git-cvsserver.txt:335
#, priority:90
msgid "Browse the 'modules' available. It will give you a list of the heads in the repository. You will not be able to browse the tree from there. Only the heads."
msgstr "浏览可用的 \"模块\"。它将为你提供一份软件源中的模块头列表。在这里，你无法浏览模块树。只能浏览头部。"

#. type: Plain text
#: en/git-cvsserver.txt:337
#, placeholders:'HEAD', priority:90
msgid "Pick `HEAD` when it asks what branch/tag to check out. Untick the \"launch commit wizard\" to avoid committing the .project file."
msgstr "在询问要签出哪个分支/标记时，选择 `HEAD`。取消勾选 \"launch commit wizard\" （登录后提交）以避免提交 .project 文件。"

#. type: Plain text
#: en/git-cvsserver.txt:343
#, placeholders:'CVS_SERVER', priority:90
msgid "Protocol notes: If you are using anonymous access via pserver, just select that. Those using SSH access should choose the 'ext' protocol, and configure 'ext' access on the Preferences->Team->CVS->ExtConnection pane. Set CVS_SERVER to \"`git cvsserver`\". Note that password support is not good when using 'ext', you will definitely want to have SSH keys setup."
msgstr "协议说明：如果通过 pserver 使用匿名访问，只需选择该协议即可。 使用 SSH 访问的用户应选择 'ext' 协议，并在 偏好设置->团队->CVS->外部连接 窗格中配置 'ext' 访问。将 CVS_SERVER 设置为 \"`git cvsserver`\"。请注意，使用 'ext' 时不支持密码，因此一定要设置 SSH 密钥。"

#. type: Plain text
#: en/git-cvsserver.txt:348
#, placeholders:'CVS_SERVER':'git-cvsserver':'git-cvsserver', priority:90
msgid "Alternatively, you can just use the non-standard extssh protocol that Eclipse offer. In that case CVS_SERVER is ignored, and you will have to replace the cvs utility on the server with 'git-cvsserver' or manipulate your `.bashrc` so that calling 'cvs' effectively calls 'git-cvsserver'."
msgstr "或者，你也可以使用 Eclipse 提供的非标准 extssh 协议。在这种情况下，CVS_SERVER 会被忽略，你必须用 'git-cvsserver' 替换服务器上的 cvs 工具，或者修改你的 `.bashrc` 以便调用 'cvs' 时能有效地调用 'git-cvsserver'。"

#. type: Title -
#: en/git-cvsserver.txt:350
#, no-wrap, priority:90
msgid "CLIENTS KNOWN TO WORK"
msgstr "已知工作的客户"

#. type: Plain text
#: en/git-cvsserver.txt:353
#, priority:90
msgid "CVS 1.12.9 on Debian"
msgstr "在 Debian 上的 CVS 1.12.9"

#. type: Plain text
#: en/git-cvsserver.txt:354
#, priority:90
msgid "CVS 1.11.17 on MacOSX (from Fink package)"
msgstr "MacOSX 上的 CVS 1.11.17（来自 Fink 软件包）"

#. type: Plain text
#: en/git-cvsserver.txt:355
#, priority:90
msgid "Eclipse 3.0, 3.1.2 on MacOSX (see Eclipse CVS Client Notes)"
msgstr "MacOSX 上的 Eclipse 3.0、3.1.2（参见 Eclipse CVS 客户端说明）"

#. type: Plain text
#: en/git-cvsserver.txt:356
#, priority:90
msgid "TortoiseCVS"
msgstr "TortoiseCVS"

#. type: Title -
#: en/git-cvsserver.txt:358
#, no-wrap, priority:90
msgid "OPERATIONS SUPPORTED"
msgstr "支持的业务"

#. type: Plain text
#: en/git-cvsserver.txt:362
#, priority:90
msgid "All the operations required for normal use are supported, including checkout, diff, status, update, log, add, remove, commit."
msgstr "支持正常使用所需的所有操作，包括签出、差异、状态、更新、日志、添加、删除、提交。"

#. type: Plain text
#: en/git-cvsserver.txt:371
#, priority:90
msgid "Most CVS command arguments that read CVS tags or revision numbers (typically -r) work, and also support any git refspec (tag, branch, commit ID, etc). However, CVS revision numbers for non-default branches are not well emulated, and cvs log does not show tags or branches at all. (Non-main-branch CVS revision numbers superficially resemble CVS revision numbers, but they actually encode a git commit ID directly, rather than represent the number of revisions since the branch point.)"
msgstr "大多数 CVS 命令参数都能读取 CVS 标签或版本号（通常是 -r），而且还支持任何 git refspec（标签、分支、提交 ID 等）。 不过，非默认分支的 CVS 版本号并不能很好地模拟，而且 cvs log 根本不会显示标签或分支。 (非主分支的 CVS 版本号表面上与 CVS 版本号相似，但实际上它们直接编码了 git 的提交 ID，而不是代表自分支点以来的修订次数。）"

#. type: Plain text
#: en/git-cvsserver.txt:385
#, priority:90
msgid "Note that there are two ways to checkout a particular branch. As described elsewhere on this page, the \"module\" parameter of cvs checkout is interpreted as a branch name, and it becomes the main branch. It remains the main branch for a given sandbox even if you temporarily make another branch sticky with cvs update -r. Alternatively, the -r argument can indicate some other branch to actually checkout, even though the module is still the \"main\" branch. Tradeoffs (as currently implemented): Each new \"module\" creates a new database on disk with a history for the given module, and after the database is created, operations against that main branch are fast. Or alternatively, -r doesn't take any extra disk space, but may be significantly slower for many operations, like cvs update."
msgstr "请注意，有两种方法可以检出特定分支。 正如本页其他地方所述，cvs checkout 的 \"模型\" 参数会被解释为分支名称，并成为主分支。 即使使用 cvs update -r 将另一个分支暂时置为主干分支，它仍是指定沙盒的主干分支。 或者，-r 参数也可以指示实际签出的其他分支，即使模块仍是 \"主\" 分支。 权衡（目前的实现方式）：每个新的 \"模块\" 都会在磁盘上创建一个新的数据库，其中包含给定模块的历史记录。 或者，-r 不会占用任何额外的磁盘空间，但在许多操作（如 cvs 更新）上可能会明显慢一些。"

#. type: Plain text
#: en/git-cvsserver.txt:398
#, priority:90
msgid "If you want to refer to a git refspec that has characters that are not allowed by CVS, you have two options. First, it may just work to supply the git refspec directly to the appropriate CVS -r argument; some CVS clients don't seem to do much sanity checking of the argument. Second, if that fails, you can use a special character escape mechanism that only uses characters that are valid in CVS tags. A sequence of 4 or 5 characters of the form (underscore (`\"_\"`), dash (`\"-\"`), one or two characters, and dash (`\"-\"`)) can encode various characters based on the one or two letters: `\"s\"` for slash (`\"/\"`), `\"p\"` for period (`\".\"`), `\"u\"` for underscore (`\"_\"`), or two hexadecimal digits for any byte value at all (typically an ASCII number, or perhaps a part of a UTF-8 encoded character)."
msgstr "如果要引用的 git refspec 包含 CVS 不允许的字符，有两种选择。 首先，直接向相应的 CVS -r 参数提供 git refspec 可能行得通；有些 CVS 客户端似乎不会对参数进行太多的正确性检查。 其次，如果方法失败，可以使用一种特殊的字符转义机制，它只使用 CVS 标记中有效的字符。 由 4 或 5 个字符（下划线 (`\"_\"`) 、破折号 (`\"-\"`)、一个或两个字符和破折号 (`\"-\"`)）组成的序列可以根据一个或两个字母编码各种字符：`\"s\"`表示斜线 (`\"/\"`)，`\"p\"`表示句号 (`\".\"`)，`\"u\"` 表示下划线 (`\"_\"`)，或者两个十六进制数字表示任何字节值（通常是 ASCII 数字，也可能是 UTF-8 编码字符的一部分）。"

#. type: Plain text
#: en/git-cvsserver.txt:401
#, priority:90
msgid "Legacy monitoring operations are not supported (edit, watch and related). Exports and tagging (tags and branches) are not supported at this stage."
msgstr "不支持传统的监控操作（编辑、监视和相关）。 现阶段不支持导出和标记（标记和分支）。"

#. type: Title ~
#: en/git-cvsserver.txt:403
#, no-wrap, priority:90
msgid "CRLF Line Ending Conversions"
msgstr "CRLF 行尾转换"

#. type: Plain text
#: en/git-cvsserver.txt:408
#, placeholders:'`-k`', priority:90
msgid "By default the server leaves the `-k` mode blank for all files, which causes the CVS client to treat them as a text files, subject to end-of-line conversion on some platforms."
msgstr "默认情况下，服务器会将所有文件的 `-k` 模式留空，这将导致 CVS 客户端将这些文件视为文本文件，并在某些平台上进行行尾转换。"

#. type: Plain text
#: en/git-cvsserver.txt:413
#, placeholders:'`-k`':'gitcvs.usecrlfattr':'linkgit:gitattributes[5]', priority:90
msgid "You can make the server use the end-of-line conversion attributes to set the `-k` modes for files by setting the `gitcvs.usecrlfattr` config variable. See linkgit:gitattributes[5] for more information about end-of-line conversion."
msgstr "通过设置 `gitcvs.usecrlfattr` 配置变量，可以让服务器使用行尾转换属性来设置文件的 `-k` 模式。 有关行尾转换的更多信息，请参阅 linkgit:gitattributes[5]。"

#. type: Plain text
#: en/git-cvsserver.txt:422
#, placeholders:'gitcvs.usecrlfattr':'gitcvs.allBinary':'gitcvs.allBinary':'`-k`':'gitcvs.allBinary':'`-k`', priority:90
msgid "Alternatively, if `gitcvs.usecrlfattr` config is not enabled or the attributes do not allow automatic detection for a filename, then the server uses the `gitcvs.allBinary` config for the default setting. If `gitcvs.allBinary` is set, then file not otherwise specified will default to '-kb' mode. Otherwise the `-k` mode is left blank. But if `gitcvs.allBinary` is set to \"guess\", then the correct `-k` mode will be guessed based on the contents of the file."
msgstr "另外，如果未启用 `gitcvs.usecrlfattr` 配置或属性不允许自动检测文件名，则服务器将使用 `gitcvs.allBinary` 配置作为默认设置。 如果设置了 `gitcvs.allBinary`，则未指定的文件将默认为 '-kb' 模式。否则，`-k` 模式将留空。但如果将 `gitcvs.allBinary` 设置为 \"guess\"（猜测），则将根据文件内容猜测正确的 `k` 模式。"

#. type: Plain text
#: en/git-cvsserver.txt:426
#, placeholders:'gitcvs.usecrlfattr':'gitcvs.allBinary', priority:90
msgid "For best consistency with 'cvs', it is probably best to override the defaults by setting `gitcvs.usecrlfattr` to true, and `gitcvs.allBinary` to \"guess\"."
msgstr "为了与 'cvs' 保持一致，最好将 `gitcvs.usecrlfattr` 设为 true，将 `gitcvs.allBinary` 设为 \"guess\"，从而覆盖默认值。"

#. type: Title -
#: en/git-cvsserver.txt:428
#, no-wrap, priority:90
msgid "DEPENDENCIES"
msgstr "依赖"

#. type: Plain text
#: en/git-cvsserver.txt:430
#, placeholders:'git-cvsserver', priority:90
msgid "'git-cvsserver' depends on DBD::SQLite."
msgstr "'git-cvsserver' 取决于 DBD::SQLite。"

#. type: Title =
#: en/git-daemon.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-daemon(1)"
msgstr "git-daemon(1)"

#. type: Plain text
#: en/git-daemon.txt:7
#, placeholders:'git-daemon', priority:100
msgid "git-daemon - A really simple server for Git repositories"
msgstr "git-daemon - 一个非常简单的git存储库服务器"

#. type: Plain text
#: en/git-daemon.txt:25
#, ignore-ellipsis, no-wrap, placeholders:'[--verbose]':'[--syslog]':'[--export-all]':'[--timeout=':'[--init-timeout=':'[--max-connections=':'[--strict-paths]':'[--base-path=':'[--base-path-relaxed]':'[--user-path':'--user-path=':'[--interpolated-path=':'[--reuseaddr]':'[--detach]':'[--pid-file=':'[--enable=':'[--disable=':'[--allow-override=':'[--forbid-override=':'[--access-hook=':'[--inetd':'[--listen=':'[--port=':'[--user=':'[--group=':'[--log-destination=(stderr|syslog|none)]', priority:100
msgid ""
"'git daemon' [--verbose] [--syslog] [--export-all]\n"
"\t     [--timeout=<n>] [--init-timeout=<n>] [--max-connections=<n>]\n"
"\t     [--strict-paths] [--base-path=<path>] [--base-path-relaxed]\n"
"\t     [--user-path | --user-path=<path>]\n"
"\t     [--interpolated-path=<pathtemplate>]\n"
"\t     [--reuseaddr] [--detach] [--pid-file=<file>]\n"
"\t     [--enable=<service>] [--disable=<service>]\n"
"\t     [--allow-override=<service>] [--forbid-override=<service>]\n"
"\t     [--access-hook=<path>] [--[no-]informative-errors]\n"
"\t     [--inetd |\n"
"\t      [--listen=<host-or-ipaddr>] [--port=<n>]\n"
"\t      [--user=<user> [--group=<group>]]]\n"
"\t     [--log-destination=(stderr|syslog|none)]\n"
"\t     [<directory>...]\n"
msgstr ""
"'git daemon' [--verbose] [--syslog] [--export-all]\n"
"\t     [--timeout=<n>] [--init-timeout=<n>] [--max-connections=<n>]\n"
"\t     [--strict-paths] [--base-path=<路径>] [--base-path-relaxed]\n"
"\t     [--user-path | --user-path=<路径>]\n"
"\t     [--interpolated-path=<路径模板>]\n"
"\t     [--reuseaddr] [--detach] [--pid-file=<文件>]\n"
"\t     [--enable=<服务>] [--disable=<服务>]\n"
"\t     [--allow-override=<服务>] [--forbid-override=<服务>]\n"
"\t     [--access-hook=<路径>] [--[no-]informative-errors]\n"
"\t     [--inetd |\n"
"\t      [--listen=<主机或 ip 地址>] [--port=<n>]\n"
"\t      [--user=<用户> [--group=<组>]]]\n"
"\t     [--log-destination=(stderr|syslog|none)]\n"
"\t     [<目录>...]\n"

#. type: Plain text
#: en/git-daemon.txt:31
#, placeholders:'DEFAULT_GIT_PORT', priority:100
msgid "A really simple TCP Git daemon that normally listens on port \"DEFAULT_GIT_PORT\" aka 9418. It waits for a connection asking for a service, and will serve that service if it is enabled."
msgstr "一个非常简单的 TCP Git 守护进程，通常在端口 \"DEFAULT_GIT_PORT\"（即 9418）上进行监听。 它等待一个要求提供服务的连接，如果该服务被启用，它将提供服务。"

#. type: Plain text
#: en/git-daemon.txt:37
#, placeholders:'git-daemon-export-ok':'`--export-all`', priority:100
msgid "It verifies that the directory has the magic file \"git-daemon-export-ok\", and it will refuse to export any Git directory that hasn't explicitly been marked for export this way (unless the `--export-all` parameter is specified). If you pass some directory paths as 'git daemon' arguments, the offers are limited to repositories within those directories."
msgstr "它验证该目录是否有神奇的文件 \"git-daemon-export-ok\"，它将拒绝导出任何没有明确标记为这种方式导出的 Gi t目录（除非指定 `--export-all` 参数）。如果你把一些目录路径作为 \"git daemon\" 参数传递，那么提供的内容就会被限制在这些目录内的仓库。"

#. type: Plain text
#: en/git-daemon.txt:41
#, placeholders:'git fetch-pack':'git ls-remote', priority:100
msgid "By default, only `upload-pack` service is enabled, which serves 'git fetch-pack' and 'git ls-remote' clients, which are invoked from 'git fetch', 'git pull', and 'git clone'."
msgstr "默认情况下，只有 \"upload-pack \"服务被启用，它为 \"git fetch-pack\" 和 \"git ls-remote\" 客户端服务，这些客户端是由 \"git fetch\"、\"git pull\" 和 \"git clone \" 调用的。"

#. type: Plain text
#: en/git-daemon.txt:44
#, priority:100
msgid "This is ideally suited for read-only updates, i.e., pulling from Git repositories."
msgstr "这非常适合于只读更新，即从 Git 仓库拉取。"

#. type: Plain text
#: en/git-daemon.txt:46
#, priority:100
msgid "An `upload-archive` also exists to serve 'git archive'."
msgstr "还存在一个 `upload-archive`，为 'git archive' 服务。"

#. type: Plain text
#: en/git-daemon.txt:54
#, priority:100
msgid "Match paths exactly (i.e. don't allow \"/foo/repo\" when the real path is \"/foo/repo.git\" or \"/foo/repo/.git\") and don't do user-relative paths. 'git daemon' will refuse to start when this option is enabled and no directory arguments are provided."
msgstr "准确匹配路径（即不允许 \"/foo/repo\"，而真正的路径是 \"/foo/repo.git \" 或 \"/foo/repo/.git\"），不做与用户相关的路径。 当这个选项被启用并且没有提供目录参数时，\"git daemon\" 将拒绝启动。"

#. type: Labeled list
#: en/git-daemon.txt:55
#, no-wrap, placeholders:'--base-path=', priority:100
msgid "--base-path=<path>"
msgstr "--base-path=<路径>"

#. type: Plain text
#: en/git-daemon.txt:61
#, placeholders:'--base-path=':'hello.git':'hello.git', priority:100
msgid "Remap all the path requests as relative to the given path. This is sort of \"Git root\" - if you run 'git daemon' with '--base-path=/srv/git' on example.com, then if you later try to pull 'git://example.com/hello.git', 'git daemon' will interpret the path as `/srv/git/hello.git`."
msgstr "将所有的路径请求重新映射为相对于给定路径的请求。 这有点像 \"Git root\"--如果你在 example.com 上用 '--base-path=/srv/git' 运行 'git daemon'，那么如果你以后试图拉 'git://example.com/hello.git'，'git daemon' 将把路径解释为 `/srv/git/hello.git`。"

#. type: Labeled list
#: en/git-daemon.txt:62
#, ignore-same, no-wrap, priority:100
msgid "--base-path-relaxed"
msgstr "--base-path-relaxed"

#. type: Plain text
#: en/git-daemon.txt:67
#, placeholders:'--base-path':'--base-path', priority:100
msgid "If --base-path is enabled and repo lookup fails, with this option 'git daemon' will attempt to lookup without prefixing the base path. This is useful for switching to --base-path usage, while still allowing the old paths."
msgstr "如果启用了 --base-path，并且 repo 查找失败，使用这个选项，'git daemon' 将尝试在不加前缀的基础路径下进行查找。 这对于切换到 --base-path 的使用很有用，同时仍然允许使用旧的路径。"

#. type: Labeled list
#: en/git-daemon.txt:68
#, no-wrap, placeholders:'--interpolated-path=', priority:100
msgid "--interpolated-path=<pathtemplate>"
msgstr "--interpolated-path=<路径模板>"

#. type: Plain text
#: en/git-daemon.txt:77
#, priority:100
msgid "To support virtual hosting, an interpolated path template can be used to dynamically construct alternate paths. The template supports %H for the target hostname as supplied by the client but converted to all lowercase, %CH for the canonical hostname, %IP for the server's IP address, %P for the port number, and %D for the absolute path of the named repository. After interpolation, the path is validated against the directory list."
msgstr "为了支持虚拟主机，可以使用插值路径模板来动态地构建备用路径。 该模板支持由客户提供的目标主机名的 %H，但转换为小写字母；支持规范主机名的 %CH；支持服务器 IP 地址的 %IP；支持端口号的 %P；支持命名仓库的绝对路径的 %D。 在插值之后，该路径将根据目录列表进行验证。"

#. type: Plain text
#: en/git-daemon.txt:82
#, placeholders:'git-daemon-export-ok', priority:100
msgid "Allow pulling from all directories that look like Git repositories (have the 'objects' and 'refs' subdirectories), even if they do not have the 'git-daemon-export-ok' file."
msgstr "允许从所有看起来像 Git 仓库的目录（有 'objects' 和 'refs' 子目录）提取，即使它们没有 'git-daemon-export-ok' 文件。"

#. type: Labeled list
#: en/git-daemon.txt:83
#, ignore-same, no-wrap, priority:100
msgid "--inetd"
msgstr "--inetd"

#. type: Plain text
#: en/git-daemon.txt:88
#, placeholders:'--syslog':'`--log-destination=`':'--detach':'--port':'--listen':'--user':'--group', priority:100
msgid "Have the server run as an inetd service. Implies --syslog (may be overridden with `--log-destination=`). Incompatible with --detach, --port, --listen, --user and --group options."
msgstr "让服务器作为一个 inetd 服务运行。暗示 --syslog（可以用 `--log-destination=` 重写）。 与 --detach、--port、--listen、--user 和 --group 选项不兼容。"

#. type: Labeled list
#: en/git-daemon.txt:89
#, no-wrap, placeholders:'--listen=', priority:100
msgid "--listen=<host-or-ipaddr>"
msgstr "--listen=<主机或 IP 地址>"

#. type: Plain text
#: en/git-daemon.txt:96
#, placeholders:'--listen=':'--listen':'`--inetd`', priority:100
msgid "Listen on a specific IP address or hostname. IP addresses can be either an IPv4 address or an IPv6 address if supported. If IPv6 is not supported, then --listen=<hostname> is also not supported and --listen must be given an IPv4 address. Can be given more than once. Incompatible with `--inetd` option."
msgstr "在一个特定的 IP 地址或主机名上收听。 IP 地址可以是一个 IPv4 地址，也可以是一个 IPv6 地址（如果支持）。 如果不支持 IPv6，那么 --listen=hostname也不被支持，--listen 必须给出一个 IPv4 地址。 可以多次给出。 与 `--inetd` 选项不兼容。"

#. type: Labeled list
#: en/git-daemon.txt:97
#, no-wrap, placeholders:'--port=', priority:100
msgid "--port=<n>"
msgstr "--port=<n>"

#. type: Plain text
#: en/git-daemon.txt:99
#, placeholders:'`--inetd`', priority:100
msgid "Listen on an alternative port. Incompatible with `--inetd` option."
msgstr "在另一个端口上监听。 与 `--inetd` 选项不兼容。"

#. type: Labeled list
#: en/git-daemon.txt:100
#, no-wrap, placeholders:'--init-timeout=', priority:100
msgid "--init-timeout=<n>"
msgstr "--init-timeout=<n>"

#. type: Plain text
#: en/git-daemon.txt:104
#, priority:100
msgid "Timeout (in seconds) between the moment the connection is established and the client request is received (typically a rather low value, since that should be basically immediate)."
msgstr "从建立连接到收到客户端请求之间的超时（以秒为单位）（通常是一个相当低的值，因为这基本上应该是即时的）。"

#. type: Labeled list
#: en/git-daemon.txt:105 en/git-upload-pack.txt:31
#, no-wrap, placeholders:'--timeout=', priority:100
msgid "--timeout=<n>"
msgstr "--timeout=<n>"

#. type: Plain text
#: en/git-daemon.txt:109
#, priority:100
msgid "Timeout (in seconds) for specific client sub-requests. This includes the time it takes for the server to process the sub-request and the time spent waiting for the next client's request."
msgstr "特定客户端子请求的超时（单位：秒）。这包括服务器处理子请求的时间和等待下一个客户端请求的时间。"

#. type: Labeled list
#: en/git-daemon.txt:110
#, no-wrap, placeholders:'--max-connections=', priority:100
msgid "--max-connections=<n>"
msgstr "--max-connections=<n>"

#. type: Plain text
#: en/git-daemon.txt:113
#, priority:100
msgid "Maximum number of concurrent clients, defaults to 32. Set it to zero for no limit."
msgstr "最大并发客户数，默认为 32。 设置为零表示没有限制。"

#. type: Labeled list
#: en/git-daemon.txt:114
#, ignore-same, no-wrap, priority:100
msgid "--syslog"
msgstr "--syslog"

#. type: Plain text
#: en/git-daemon.txt:116
#, placeholders:'`--log-destination=syslog`', priority:100
msgid "Short for `--log-destination=syslog`."
msgstr "是 `--log-destination=syslog` 的简称。"

#. type: Labeled list
#: en/git-daemon.txt:117
#, no-wrap, placeholders:'--log-destination=', priority:100
msgid "--log-destination=<destination>"
msgstr "--log-destination=<目的>"

#. type: Plain text
#: en/git-daemon.txt:122
#, placeholders:'--verbose', priority:100
msgid "Send log messages to the specified destination. Note that this option does not imply --verbose, thus by default only error conditions will be logged. The <destination> must be one of:"
msgstr "发送日志信息到指定的目的地。 注意，这个选项并不意味着 --verbose，因此默认情况下只有错误情况会被记录下来。 <目的> 必须是以下之一："

#. type: Labeled list
#: en/git-daemon.txt:124
#, no-wrap, priority:100
msgid "stderr"
msgstr "标准错误"

#. type: Plain text
#: en/git-daemon.txt:129
#, placeholders:'`--detach`', priority:100
msgid "Write to standard error. Note that if `--detach` is specified, the process disconnects from the real standard error, making this destination effectively equivalent to `none`."
msgstr "写入标准错误。 注意，如果指定了 `--detach`，进程就会断开与真正的标准错误的连接，使得这个目的地实际上等同于 `none`。"

#. type: Labeled list
#: en/git-daemon.txt:129
#, no-wrap, priority:100
msgid "syslog"
msgstr "日志服务器"

#. type: Plain text
#: en/git-daemon.txt:131
#, placeholders:'git-daemon', priority:100
msgid "Write to syslog, using the `git-daemon` identifier."
msgstr "写入 syslog，使用 `git-daemon` 标识符。"

#. type: Plain text
#: en/git-daemon.txt:133
#, priority:100
msgid "Disable all logging."
msgstr "禁用所有日志记录。"

#. type: Plain text
#: en/git-daemon.txt:137
#, placeholders:'`--inetd`':'`--detach`', priority:100
msgid "The default destination is `syslog` if `--inetd` or `--detach` is specified, otherwise `stderr`."
msgstr "如果指定了 `--inetd` 或 `--detach`，默认的目标是 `syslog`，否则是 `stderr`。"

#. type: Labeled list
#: en/git-daemon.txt:138
#, ignore-same, no-wrap, priority:100
msgid "--user-path"
msgstr "--user-path"

#. type: Labeled list
#: en/git-daemon.txt:139
#, no-wrap, placeholders:'--user-path=', priority:100
msgid "--user-path=<path>"
msgstr "--user-path=<路径>"

#. type: Plain text
#: en/git-daemon.txt:147
#, placeholders:'{tilde}':'{tilde}':'`--user-path=', priority:100
msgid "Allow {tilde}user notation to be used in requests. When specified with no parameter, a request to git://host/{tilde}alice/foo is taken as a request to access 'foo' repository in the home directory of user `alice`. If `--user-path=<path>` is specified, the same request is taken as a request to access `<path>/foo` repository in the home directory of user `alice`."
msgstr "允许在请求中使用 {tilde} 用户符号。 当没有指定参数时，对 git://host/{tilde}alice/foo 的请求会被视为访问用户 `alice` 的主目录下的 'foo' 仓库的请求。 如果指定了 `--user-path=path`，同样的请求将被视为访问用户 `alice` 的主目录下的 `path/foo` 仓库。"

#. type: Plain text
#: en/git-daemon.txt:150
#, priority:100
msgid "Log details about the incoming connections and requested files."
msgstr "记录有关传入连接和请求文件的详细信息。"

#. type: Labeled list
#: en/git-daemon.txt:151
#, ignore-same, no-wrap, priority:100
msgid "--reuseaddr"
msgstr "--reuseaddr"

#. type: Plain text
#: en/git-daemon.txt:155
#, placeholders:'SO_REUSEADDR', priority:100
msgid "Use SO_REUSEADDR when binding the listening socket. This allows the server to restart without waiting for old connections to time out."
msgstr "在绑定监听套接字时使用 SO_REUSEADDR。 这允许服务器重新启动，而不必等待旧的连接超时。"

#. type: Plain text
#: en/git-daemon.txt:158
#, placeholders:'--syslog', priority:100
msgid "Detach from the shell. Implies --syslog."
msgstr "从 shell 中分离出来。这意味着 --syslog。"

#. type: Labeled list
#: en/git-daemon.txt:159
#, no-wrap, placeholders:'--pid-file=', priority:100
msgid "--pid-file=<file>"
msgstr "--pid-file=<文件>"

#. type: Plain text
#: en/git-daemon.txt:162
#, placeholders:'`--inetd`', priority:100
msgid "Save the process id in 'file'. Ignored when the daemon is run under `--inetd`."
msgstr "在 'file' 中保存进程 ID。 当守护进程在 `--inetd` 下运行时被忽略。"

#. type: Labeled list
#: en/git-daemon.txt:163
#, no-wrap, placeholders:'--user=', priority:100
msgid "--user=<user>"
msgstr "--user=<用户>"

#. type: Labeled list
#: en/git-daemon.txt:164
#, no-wrap, placeholders:'--group=', priority:100
msgid "--group=<group>"
msgstr "--group=<组>"

#. type: Plain text
#: en/git-daemon.txt:170
#, placeholders:'`--user`':'`--group`', priority:100
msgid "Change daemon's uid and gid before entering the service loop. When only `--user` is given without `--group`, the primary group ID for the user is used. The values of the option are given to `getpwnam(3)` and `getgrnam(3)` and numeric IDs are not supported."
msgstr "在进入服务循环之前，改变 daemon 的 uid 和 gid。 当只给出 `--user` 而没有 `--group` 时，将使用用户的主要组 ID。 该选项的值是给 `getpwnam(3)` 和 `getgrnam(3)` 的，不支持数字 ID。"

#. type: Plain text
#: en/git-daemon.txt:174
#, placeholders:'`--inetd`', priority:100
msgid "Giving these options is an error when used with `--inetd`; use the facility of inet daemon to achieve the same before spawning 'git daemon' if needed."
msgstr "当与 `--inetd` 一起使用时，给出这些选项是一个错误；如果需要，在催生 'git daemon' 之前，使用 inet daemon 的设施来实现同样的目的。"

#. type: Plain text
#: en/git-daemon.txt:181
#, placeholders:'$HOME', priority:100
msgid "Like many programs that switch user id, the daemon does not reset environment variables such as `$HOME` when it runs git programs, e.g. `upload-pack` and `receive-pack`. When using this option, you may also want to set and export `HOME` to point at the home directory of `<user>` before starting the daemon, and make sure any Git configuration files in that directory are readable by `<user>`."
msgstr "像许多切换用户 ID 的程序一样，守护进程在运行 git 程序（如 `upload-pack` 和 `receive-pack`）时，不会重置 `$HOME` 之类的环境变量。当使用这个选项时，你可能还想在启动守护进程之前设置并导出 `HOME` 指向 `<user>` 的主目录，并确保该目录下的任何 Git 配置文件是 `<user>` 可以读取的。"

#. type: Labeled list
#: en/git-daemon.txt:182
#, no-wrap, placeholders:'--enable=', priority:100
msgid "--enable=<service>"
msgstr "--enable=<服务>"

#. type: Labeled list
#: en/git-daemon.txt:183
#, no-wrap, placeholders:'--disable=', priority:100
msgid "--disable=<service>"
msgstr "--disable=<服务>"

#. type: Plain text
#: en/git-daemon.txt:189
#, priority:100
msgid "Enable/disable the service site-wide per default. Note that a service disabled site-wide can still be enabled per repository if it is marked overridable and the repository enables the service with a configuration item."
msgstr "在全站范围内默认启用/禁用该服务。 请注意，如果一个全站禁用的服务被标记为可重写，并且版本库用配置项启用了该服务，那么它仍然可以在每个版本库中启用。"

#. type: Labeled list
#: en/git-daemon.txt:190
#, no-wrap, placeholders:'--allow-override=', priority:100
msgid "--allow-override=<service>"
msgstr "--allow-override=<服务>"

#. type: Labeled list
#: en/git-daemon.txt:191
#, no-wrap, placeholders:'--forbid-override=', priority:100
msgid "--forbid-override=<service>"
msgstr "--forbid-override=<服务>"

#. type: Plain text
#: en/git-daemon.txt:195
#, priority:100
msgid "Allow/forbid overriding the site-wide default with per repository configuration. By default, all the services may be overridden."
msgstr "允许/禁止用每个版本库的配置来覆盖全站的默认值。 默认情况下，所有的服务都可以被覆盖。"

#. type: Labeled list
#: en/git-daemon.txt:196
#, ignore-same, no-wrap, priority:100
msgid "--[no-]informative-errors"
msgstr "--[no-]informative-errors"

#. type: Plain text
#: en/git-daemon.txt:204
#, placeholders:'git-daemon':'--no-informative-errors', priority:100
msgid "When informative errors are turned on, git-daemon will report more verbose errors to the client, differentiating conditions like \"no such repository\" from \"repository not exported\". This is more convenient for clients, but may leak information about the existence of unexported repositories. When informative errors are not enabled, all errors report \"access denied\" to the client. The default is --no-informative-errors."
msgstr "当信息性错误被打开时，git-daemon 会向客户端报告更多详细的错误，区分 \"没有这样的仓库\" 和 \"仓库没有被导出\" 这样的情况。这对客户端来说更方便，但可能会泄露未导出版本库的信息。 如果不启用信息性错误，所有错误都会向客户报告 \"拒绝访问\"。默认情况是 --no-informative-errors。"

#. type: Labeled list
#: en/git-daemon.txt:205
#, no-wrap, placeholders:'--access-hook=', priority:100
msgid "--access-hook=<path>"
msgstr "--access-hook=<路径>"

#. type: Plain text
#: en/git-daemon.txt:215
#, placeholders:'$REMOTE_ADDR':'$REMOTE_PORT', priority:100
msgid "Every time a client connects, first run an external command specified by the <path> with service name (e.g. \"upload-pack\"), path to the repository, hostname (%H), canonical hostname (%CH), IP address (%IP), and TCP port (%P) as its command-line arguments. The external command can decide to decline the service by exiting with a non-zero status (or to allow it by exiting with a zero status). It can also look at the $REMOTE_ADDR and `$REMOTE_PORT` environment variables to learn about the requestor when making this decision."
msgstr "每次客户端连接时，首先运行 <路径> 指定的外部命令，以服务名称（如 \"upload-pack\"）、仓库的路径、主机名（%H）、规范主机名（%CH）、IP 地址（%IP）和 TCP 端口（%P）作为其命令行参数。外部命令可以通过以非零状态退出来决定拒绝该服务（或通过以零状态退出来允许它）。 在做出这个决定时，它还可以查看 $REMOTE_ADDR 和 `$REMOTE_PORT` 环境变量来了解请求者的情况。"

#. type: Plain text
#: en/git-daemon.txt:219
#, priority:100
msgid "The external command can optionally write a single line to its standard output to be sent to the requestor as an error message when it declines the service."
msgstr "外部命令可以选择在其标准输出中写入一行，在拒绝服务时作为错误信息发送给请求者。"

#. type: Plain text
#: en/git-daemon.txt:226
#, placeholders:'git-daemon':'`--strict-paths`', priority:100
msgid "The remaining arguments provide a list of directories. If any directories are specified, then the `git-daemon` process will serve a requested directory only if it is contained in one of these directories. If `--strict-paths` is specified, then the requested directory must match one of these directories exactly."
msgstr "其余的参数提供了一个目录列表。如果指定了任何目录，那么 `git-daemon` 进程将只在所请求的目录包含在这些目录中时提供服务。如果指定了 `--strict-paths`，那么请求的目录必须与这些目录之一完全匹配。"

#. type: Title -
#: en/git-daemon.txt:228 en/git-http-backend.txt:35
#, no-wrap, priority:100
msgid "SERVICES"
msgstr "服务"

#. type: Plain text
#: en/git-daemon.txt:236
#, priority:100
msgid "These services can be globally enabled/disabled using the command-line options of this command. If finer-grained control is desired (e.g. to allow 'git archive' to be run against only in a few selected repositories the daemon serves), the per-repository configuration file can be used to enable or disable them."
msgstr "这些服务可以通过该命令的命令行选项全局启用/禁用。 如果需要更精细的控制（例如，允许 'git archive' 只在守护进程所服务的几个选定的仓库中运行），可以使用每个仓库的配置文件来启用或禁用它们。"

#. type: Labeled list
#: en/git-daemon.txt:237
#, no-wrap, priority:100
msgid "upload-pack"
msgstr "upload-pack"

#. type: Plain text
#: en/git-daemon.txt:242
#, placeholders:'git fetch-pack':'git ls-remote':'daemon.uploadpack', priority:100
msgid "This serves 'git fetch-pack' and 'git ls-remote' clients. It is enabled by default, but a repository can disable it by setting `daemon.uploadpack` configuration item to `false`."
msgstr "它为 'git fetch-pack' 和 'git ls-remote' 客户端服务。 它默认是启用的，但仓库可以通过设置 `daemon.uploadpack` 配置项为 `false` 来禁用它。"

#. type: Labeled list
#: en/git-daemon.txt:243
#, no-wrap, priority:100
msgid "upload-archive"
msgstr "upload-archive"

#. type: Plain text
#: en/git-daemon.txt:247
#, placeholders:'--remote':'daemon.uploadarch', priority:100
msgid "This serves 'git archive --remote'. It is disabled by default, but a repository can enable it by setting `daemon.uploadarch` configuration item to `true`."
msgstr "这为 'git archive --remote' 服务。 它默认是禁用的，但版本库可以通过设置 `daemon.uploadarch` 配置项为 `true` 来启用它。"

#. type: Labeled list
#: en/git-daemon.txt:248
#, no-wrap, priority:100
msgid "receive-pack"
msgstr "receive-pack"

#. type: Plain text
#: en/git-daemon.txt:257
#, placeholders:'git send-pack':'daemon.receivepack', priority:100
msgid "This serves 'git send-pack' clients, allowing anonymous push. It is disabled by default, as there is _no_ authentication in the protocol (in other words, anybody can push anything into the repository, including removal of refs). This is solely meant for a closed LAN setting where everybody is friendly. This service can be enabled by setting `daemon.receivepack` configuration item to `true`."
msgstr "它为 'git send-pack' 客户端服务，允许匿名推送。 它默认是禁用的，因为协议中没有认证（换句话说，任何人都可以推送任何东西到仓库，包括删除引用）。 这只适用于封闭的局域网环境，大家都很友好。 这个服务可以通过设置 `daemon.receivepack` 配置项为 `true` 来启用。"

#. type: Labeled list
#: en/git-daemon.txt:260
#, no-wrap, priority:100
msgid "We assume the following in /etc/services"
msgstr "我们在 /etc/services 中假设如下"

#. type: delimited block -
#: en/git-daemon.txt:265
#, no-wrap, priority:100
msgid ""
"$ grep 9418 /etc/services\n"
"git\t\t9418/tcp\t\t# Git Version Control System\n"
msgstr ""
"$ grep 9418 /etc/services\n"
"git\t\t9418/tcp\t\t# Git 版本控制系统\n"

#. type: Labeled list
#: en/git-daemon.txt:267
#, no-wrap, priority:100
msgid "'git daemon' as inetd server"
msgstr "'git daemon' 作为 inetd 服务器"

#. type: Plain text
#: en/git-daemon.txt:271
#, priority:100
msgid "To set up 'git daemon' as an inetd service that handles any repository within `/pub/foo` or `/pub/bar`, place an entry like the following into `/etc/inetd` all on one line:"
msgstr "要把 'git daemon' 设置为 inetd 服务，处理 `/pub/foo` 或 `/pub/bar` 内的任何仓库，在 `/etc/inetd` 中放入如下条目，全部放在一行："

#. type: delimited block -
#: en/git-daemon.txt:276
#, no-wrap, placeholders:'--inetd':'--verbose':'--export-all', priority:100
msgid ""
"\tgit stream tcp nowait nobody  /usr/bin/git\n"
"\t\tgit daemon --inetd --verbose --export-all\n"
"\t\t/pub/foo /pub/bar\n"
msgstr ""
"\tgit stream tcp nowait nobody  /usr/bin/git\n"
"\t\tgit daemon --inetd --verbose --export-all\n"
"\t\t/pub/foo /pub/bar\n"

#. type: Labeled list
#: en/git-daemon.txt:279
#, no-wrap, priority:100
msgid "'git daemon' as inetd server for virtual hosts"
msgstr "作为虚拟主机的 inetd 服务器的 'git daemon'"

#. type: Plain text
#: en/git-daemon.txt:284
#, priority:100
msgid "To set up 'git daemon' as an inetd service that handles repositories for different virtual hosts, `www.example.com` and `www.example.org`, place an entry like the following into `/etc/inetd` all on one line:"
msgstr "要将 'git daemon' 设置为 inetd 服务，处理不同的虚拟主机 `www.example.com` 和 `www.example.org` 的仓库，在 `/etc/inetd` 中放置如下条目，全部在一行："

#. type: delimited block -
#: en/git-daemon.txt:292
#, no-wrap, placeholders:'--inetd':'--verbose':'--export-all':'--interpolated-path=', priority:100
msgid ""
"\tgit stream tcp nowait nobody /usr/bin/git\n"
"\t\tgit daemon --inetd --verbose --export-all\n"
"\t\t--interpolated-path=/pub/%H%D\n"
"\t\t/pub/www.example.org/software\n"
"\t\t/pub/www.example.com/software\n"
"\t\t/software\n"
msgstr ""
"\tgit stream tcp nowait nobody /usr/bin/git\n"
"\t\tgit daemon --inetd --verbose --export-all\n"
"\t\t--interpolated-path=/pub/%H%D\n"
"\t\t/pub/www.example.org/software\n"
"\t\t/pub/www.example.com/software\n"
"\t\t/software\n"

#. type: Plain text
#: en/git-daemon.txt:300
#, priority:100
msgid "In this example, the root-level directory `/pub` will contain a subdirectory for each virtual host name supported. Further, both hosts advertise repositories simply as `git://www.example.com/software/repo.git`. For pre-1.4.0 clients, a symlink from `/software` into the appropriate default repository could be made as well."
msgstr "在这个例子中，根级目录 `/pub` 将包含一个子目录，用于支持每个虚拟主机名。 此外，两台主机都简单地以 `git://www.example.com/software/repo.git` 的方式宣传仓库。 对于 1.4.0 之前的客户端，也可以从 `/software` 建立一个符号链接到相应的默认仓库。"

#. type: Labeled list
#: en/git-daemon.txt:302
#, no-wrap, priority:100
msgid "'git daemon' as regular daemon for virtual hosts"
msgstr "'git daemon' 作为虚拟主机的常规守护程序"

#. type: Plain text
#: en/git-daemon.txt:306
#, priority:100
msgid "To set up 'git daemon' as a regular, non-inetd service that handles repositories for multiple virtual hosts based on their IP addresses, start the daemon like this:"
msgstr "要把 'git daemon' 设置成一个普通的、非 inetd 的服务，处理基于 IP 地址的多个虚拟主机的存储库，可以像这样启动 daemon："

#. type: delimited block -
#: en/git-daemon.txt:312
#, no-wrap, placeholders:'--verbose':'--export-all':'--interpolated-path=', priority:100
msgid ""
"\tgit daemon --verbose --export-all\n"
"\t\t--interpolated-path=/pub/%IP/%D\n"
"\t\t/pub/192.168.1.200/software\n"
"\t\t/pub/10.10.220.23/software\n"
msgstr ""
"\tgit daemon --verbose --export-all\n"
"\t\t--interpolated-path=/pub/%IP/%D\n"
"\t\t/pub/192.168.1.200/software\n"
"\t\t/pub/10.10.220.23/software\n"

#. type: Plain text
#: en/git-daemon.txt:318
#, priority:100
msgid "In this example, the root-level directory `/pub` will contain a subdirectory for each virtual host IP address supported. Repositories can still be accessed by hostname though, assuming they correspond to these IP addresses."
msgstr "在这个例子中，根级目录 `/pub` 将包含一个支持每个虚拟主机IP地址的子目录。 虽然仓库仍然可以通过主机名访问，但假设它们对应于这些 IP 地址。"

#. type: Labeled list
#: en/git-daemon.txt:319
#, no-wrap, priority:100
msgid "selectively enable/disable services per repository"
msgstr "选择性地启用/禁用每个仓库的服务"

#. type: Plain text
#: en/git-daemon.txt:324
#, placeholders:'--remote':'HEAD', priority:100
msgid "To enable 'git archive --remote' and disable 'git fetch' against a repository, have the following in the configuration file in the repository (that is the file 'config' next to `HEAD`, 'refs' and 'objects')."
msgstr "要启用 'git archive --remote' 并禁用 'git fetch'，在仓库的配置文件中要有以下内容（也就是在 `HEAD`、'refs' 和 'objects' 旁的 'config'文件）。"

#. type: delimited block -
#: en/git-daemon.txt:329
#, no-wrap, priority:100
msgid ""
"\t[daemon]\n"
"\t\tuploadpack = false\n"
"\t\tuploadarch = true\n"
msgstr ""
"\t[daemon]\n"
"\t\tuploadpack = false\n"
"\t\tuploadarch = true\n"

#. type: Plain text
#: en/git-daemon.txt:338
#, placeholders:'REMOTE_ADDR':'REMOTE_ADDR', priority:100
msgid "'git daemon' will set REMOTE_ADDR to the IP address of the client that connected to it, if the IP address is available. REMOTE_ADDR will be available in the environment of hooks called when services are performed."
msgstr "'git daemon' 将把 REMOTE_ADDR 设置为连接到它的客户端的 IP 地址，如果该 IP 地址是可用的。REMOTE_ADDR 将在执行服务时调用的钩子环境中可用。"

#. type: Title =
#: en/git-describe.txt:2
#, ignore-same, no-wrap, priority:260
msgid "git-describe(1)"
msgstr "git-describe(1)"

#. type: Plain text
#: en/git-describe.txt:7
#, placeholders:'git-describe', priority:260
msgid "git-describe - Give an object a human readable name based on an available ref"
msgstr "git-describe - 根据一个可用的引用，给一个对象起一个人类可读的名字"

#. type: Plain text
#: en/git-describe.txt:14
#, ignore-ellipsis, no-wrap, placeholders:'[--all]':'[--tags]':'[--contains]':'[--abbrev=':'[--all]':'[--tags]':'[--contains]':'[--abbrev=':'--dirty', priority:260
msgid ""
"'git describe' [--all] [--tags] [--contains] [--abbrev=<n>] [<commit-ish>...]\n"
"'git describe' [--all] [--tags] [--contains] [--abbrev=<n>] --dirty[=<mark>]\n"
"'git describe' <blob>\n"
msgstr ""
"'git describe' [--all] [--tags] [--contains] [--abbrev=<n>] [<commit-ish>...]\n"
"'git describe' [--all] [--tags] [--contains] [--abbrev=<n>] --dirty[=<mark>] 。\n"
"'git describe' <blob\n"

#. type: Plain text
#: en/git-describe.txt:24
#, priority:260
msgid "The command finds the most recent tag that is reachable from a commit. If the tag points to the commit, then only the tag is shown. Otherwise, it suffixes the tag name with the number of additional commits on top of the tagged object and the abbreviated object name of the most recent commit. The result is a \"human-readable\" object name which can also be used to identify the commit to other git commands."
msgstr "该命令找到可从提交中获取的最新标签。 如果标签指向该提交，则只显示该标签。 否则，它会在标签名后面加上附加提交的数量，以及最新提交的缩写对象名。其结果是一个 \"人类可读 \"的对象名称，也可用于识别其他git命令中的提交。"

#. type: Plain text
#: en/git-describe.txt:28
#, placeholders:'--all':'--tags':'linkgit:git-tag[1]', priority:260
msgid "By default (without --all or --tags) `git describe` only shows annotated tags. For more information about creating annotated tags see the -a and -s options to linkgit:git-tag[1]."
msgstr "默认情况下（没有 --all 或 --tags）`git describe`只显示有注释的标签。 关于创建注释标签的更多信息，请参见linkgit:git-tag[1]的-a和-s选项。"

#. type: Plain text
#: en/git-describe.txt:34
#, placeholders:'HEAD', priority:260
msgid "If the given object refers to a blob, it will be described as `<commit-ish>:<path>`, such that the blob can be found at `<path>` in the `<commit-ish>`, which itself describes the first commit in which this blob occurs in a reverse revision walk from HEAD."
msgstr "如果给定的对象指的是一个blob，它将被描述为`<commit-ish>:<path>`，这样就可以在`<commit-ish>`中的`<path>`找到这个blob，而这个blob本身就描述了从HEAD反向修订中出现的第一个提交。"

#. type: Labeled list
#: en/git-describe.txt:37
#, ignore-ellipsis, no-wrap, priority:260
msgid "<commit-ish>..."
msgstr "<提交号>..."

#. type: Plain text
#: en/git-describe.txt:39
#, placeholders:'HEAD', priority:260
msgid "Commit-ish object names to describe. Defaults to HEAD if omitted."
msgstr "要描述的类似于承诺的对象名称。 如果省略，则默认为HEAD。"

#. type: Labeled list
#: en/git-describe.txt:40
#, no-wrap, placeholders:'--dirty', priority:260
msgid "--dirty[=<mark>]"
msgstr "--dirty[=<标记>]"

#. type: Labeled list
#: en/git-describe.txt:41
#, no-wrap, placeholders:'--broken', priority:260
msgid "--broken[=<mark>]"
msgstr "--broken[=<标记>]"

#. type: Plain text
#: en/git-describe.txt:49
#, placeholders:'HEAD':'HEAD':'`--broken', priority:260
msgid "Describe the state of the working tree. When the working tree matches HEAD, the output is the same as \"git describe HEAD\". If the working tree has local modification \"-dirty\" is appended to it. If a repository is corrupt and Git cannot determine if there is local modification, Git will error out, unless `--broken' is given, which appends the suffix \"-broken\" instead."
msgstr "描述工作树的状态。 当工作树与HEAD匹配时，其输出与 \"git describe HEAD \"相同。 如果工作树有本地修改，\"-dirty \"会被附加到它上面。 如果一个仓库被破坏了，而Git不能确定是否有本地修改，Git会出错，除非给了`--broken'，它将附加后缀\"-broken\"。"

#. type: Plain text
#: en/git-describe.txt:54
#, priority:260
msgid "Instead of using only the annotated tags, use any ref found in `refs/` namespace. This option enables matching any known branch, remote-tracking branch, or lightweight tag."
msgstr "而不是只使用注释的标签，使用在`refs/`命名空间中发现的任何ref。 这个选项可以匹配任何已知的分支、远程跟踪分支或轻量级标签。"

#. type: Plain text
#: en/git-describe.txt:59
#, priority:260
msgid "Instead of using only the annotated tags, use any tag found in `refs/tags` namespace. This option enables matching a lightweight (non-annotated) tag."
msgstr "而不是只使用注释过的标签，使用在`refs/tags`命名空间中发现的任何标签。 这个选项可以匹配轻量级（非注释的）标签。"

#. type: Labeled list
#: en/git-describe.txt:60
#, ignore-same, no-wrap, priority:260
msgid "--contains"
msgstr "--contains"

# ERROR: --tags not found in translation
#. type: Plain text
#: en/git-describe.txt:64
#, placeholders:'--tags', priority:260
msgid "Instead of finding the tag that predates the commit, find the tag that comes after the commit, and thus contains it. Automatically implies --tags."
msgstr "与其寻找提交前的标签，不如寻找提交后的标签，从而包含该标签。 自动暗含 --tags。"

#. type: Plain text
#: en/git-describe.txt:71
#, priority:260
msgid "Instead of using the default number of hexadecimal digits (which will vary according to the number of objects in the repository with a default of 7) of the abbreviated object name, use <n> digits, or as many digits as needed to form a unique object name. An <n> of 0 will suppress long format, only showing the closest tag."
msgstr "不要使用缩写对象名称的默认十六进制数字（根据存储库中对象的数量而变化，默认为7），而是使用<n>数字，或根据需要使用任意多的数字来形成唯一的对象名称。<n>为0将抑制长格式，仅显示最近的标记。"

#. type: Labeled list
#: en/git-describe.txt:72
#, no-wrap, placeholders:'--candidates=', priority:260
msgid "--candidates=<n>"
msgstr "--candidates=<n>"

#. type: Plain text
#: en/git-describe.txt:78
#, priority:260
msgid "Instead of considering only the 10 most recent tags as candidates to describe the input commit-ish consider up to <n> candidates. Increasing <n> above 10 will take slightly longer but may produce a more accurate result. An <n> of 0 will cause only exact matches to be output."
msgstr "与其只考虑用最近的10个标签来描述输入的commit-ish，不如考虑最多<n>个候选人。 将<n>增加到10以上会花费更长的时间，但可能会产生一个更准确的结果。 <n>为0将导致只输出完全匹配的结果。"

#. type: Labeled list
#: en/git-describe.txt:79
#, ignore-same, no-wrap, priority:260
msgid "--exact-match"
msgstr "--exact-match"

#. type: Plain text
#: en/git-describe.txt:82
#, placeholders:'--candidates=0', priority:260
msgid "Only output exact matches (a tag directly references the supplied commit). This is a synonym for --candidates=0."
msgstr "只输出完全匹配的内容（一个标签直接引用所提供的提交）。 这是 --candidates=0 的同义词。"

#. type: Labeled list
#: en/git-describe.txt:83 en/git-ls-files.txt:192
#, ignore-same, no-wrap, priority:260
msgid "--debug"
msgstr "--debug"

#. type: Plain text
#: en/git-describe.txt:87
#, priority:260
msgid "Verbosely display information about the searching strategy being employed to standard error. The tag name will still be printed to standard out."
msgstr "以粗略的方式向标准错误显示正在使用的搜索策略的信息。 标签名称仍将被打印到标准输出。"

#. type: Plain text
#: en/git-describe.txt:96
#, ignore-ellipsis, priority:260
msgid "Always output the long format (the tag, the number of commits and the abbreviated commit name) even when it matches a tag. This is useful when you want to see parts of the commit object name in \"describe\" output, even when the commit in question happens to be a tagged version. Instead of just emitting the tag name, it will describe such a commit as v1.2-0-gdeadbee (0th commit since tag v1.2 that points at object deadbee....)."
msgstr "总是输出长格式（标签、提交数量和提交名称的缩写），即使它与一个标签相匹配。 当你想在 \"describe \"输出中看到提交对象的部分名称时，这很有用，即使相关的提交恰好是一个有标签的版本。 它不会只发出标签名称，而是将这样的提交描述为v1.2-0-gdeadbee（标签v1.2后的第0次提交，指向对象deadbee....）。"

#. type: Labeled list
#: en/git-describe.txt:97
#, no-wrap, placeholders:'--match', priority:260
msgid "--match <pattern>"
msgstr "--match <模式>"

#. type: Plain text
#: en/git-describe.txt:106
#, placeholders:'`--all`':'`--no-match`', priority:260
msgid "Only consider tags matching the given `glob(7)` pattern, excluding the \"refs/tags/\" prefix. If used with `--all`, it also considers local branches and remote-tracking references matching the pattern, excluding respectively \"refs/heads/\" and \"refs/remotes/\" prefix; references of other types are never considered. If given multiple times, a list of patterns will be accumulated, and tags matching any of the patterns will be considered. Use `--no-match` to clear and reset the list of patterns."
msgstr "只考虑与给定的 `glob(7)` 模式匹配的标签，不包括 \"refs/tags/\" 前缀。如果和`--all`一起使用，它也会考虑匹配该模式的本地分支和远程跟踪引用，分别排除 \"refs/heads/\"和 \"refs/remotes/\"前缀；其他类型的引用永远不会被考虑。如果给出多次，将积累一个模式列表，匹配任何模式的标签都会被考虑。 使用`--no-match`来清除和重置模式列表。"

#. type: Labeled list
#: en/git-describe.txt:107 en/git-pack-refs.txt:72
#, no-wrap, placeholders:'--exclude', priority:260
msgid "--exclude <pattern>"
msgstr "--exclude <模式>"

#. type: Plain text
#: en/git-describe.txt:118
#, placeholders:'`--all`':'--match':'--match':'--exclude':'`--no-exclude`', priority:260
msgid "Do not consider tags matching the given `glob(7)` pattern, excluding the \"refs/tags/\" prefix. If used with `--all`, it also does not consider local branches and remote-tracking references matching the pattern, excluding respectively \"refs/heads/\" and \"refs/remotes/\" prefix; references of other types are never considered. If given multiple times, a list of patterns will be accumulated and tags matching any of the patterns will be excluded. When combined with --match a tag will be considered when it matches at least one --match pattern and does not match any of the --exclude patterns. Use `--no-exclude` to clear and reset the list of patterns."
msgstr "不考虑与给定的 `glob(7)` 模式匹配的标签，排除 \"refs/tags/\"前缀。如果和`--all`一起使用，也不考虑匹配模式的本地分支和远程跟踪引用，分别排除 \"refs/heads/\"和 \"refs/remotes/\"前缀；其他类型的引用从不考虑。如果给定多次，将积累一个模式列表，匹配任何模式的标签将被排除。当与--match结合时，当一个标签至少匹配一个--match模式且不匹配任何--exclude模式时，将被考虑。使用`--no-exclude`来清除和重置模式列表。"

#. type: Labeled list
#: en/git-describe.txt:119 en/git-diff-tree.txt:120 en/git-format-patch.txt:194 en/git-name-rev.txt:84
#, ignore-same, no-wrap, priority:260
msgid "--always"
msgstr "--always"

#. type: Plain text
#: en/git-describe.txt:121 en/git-name-rev.txt:86
#, priority:260
msgid "Show uniquely abbreviated commit object as fallback."
msgstr "显示唯一缩写的提交对象作为后备。"

#. type: Plain text
#: en/git-describe.txt:126
#, priority:260
msgid "Follow only the first parent commit upon seeing a merge commit. This is useful when you wish to not match tags on branches merged in the history of the target commit."
msgstr "在看到合并提交时，只跟随第一个父提交。 当你希望不匹配目标提交历史中合并的分支上的标签时，这很有用。"

#. type: Plain text
#: en/git-describe.txt:131
#, placeholders:'git.git', priority:260
msgid "With something like git.git current tree, I get:"
msgstr "使用类似 git.git current tree 这样的工具，我得到的结果是："

#. type: Plain text
#: en/git-describe.txt:134
#, no-wrap, priority:260
msgid ""
"\t[torvalds@g5 git]$ git describe parent\n"
"\tv1.0.4-14-g2414721\n"
msgstr ""
"\t[torvalds@g5 git]$ git describe parent\n"
"\tv1.0.4-14-g2414721\n"

#. type: Plain text
#: en/git-describe.txt:140
#, priority:260
msgid "i.e. the current head of my \"parent\" branch is based on v1.0.4, but since it has a few commits on top of that, describe has added the number of additional commits (\"14\") and an abbreviated object name for the commit itself (\"2414721\") at the end."
msgstr "也就是说，我的 \"父 \"分支的当前头部是基于v1.0.4的，但由于它在此基础上有一些提交，所以describe在最后添加了额外的提交数量（\"14\"）和提交本身的缩写对象名称（\"2414721\"）。"

#. type: Plain text
#: en/git-describe.txt:151
#, priority:260
msgid "The number of additional commits is the number of commits which would be displayed by \"git log v1.0.4..parent\". The hash suffix is \"-g\" + an unambiguous abbreviation for the tip commit of parent (which was `2414721b194453f058079d897d13c4e377f92dc6`). The length of the abbreviation scales as the repository grows, using the approximate number of objects in the repository and a bit of math around the birthday paradox, and defaults to a minimum of 7. The \"g\" prefix stands for \"git\" and is used to allow describing the version of a software depending on the SCM the software is managed with. This is useful in an environment where people may use different SCMs."
msgstr "额外提交的次数是 \"git log v1.0.4.parent\" 显示的提交次数。 哈希后缀是\"-g\" + 父提交（即 `2414721b194453f058079d897d13c4e377f92dc6` ）顶端提交的明确缩写。缩写的长度会随着仓库的增长而缩减，使用的是仓库中对象的大致数量和生日悖论的数学计算方法，默认最小长度为 7。\"g\" 前缀代表 \"git\" ，用于根据管理软件的 SCM 来描述软件的版本。这在人们使用不同 SCM 的环境中非常有用。"

#. type: Plain text
#: en/git-describe.txt:153
#, priority:260
msgid "Doing a 'git describe' on a tag-name will just show the tag name:"
msgstr "对一个标签名做 'git describe'，只会显示标签名："

#. type: Plain text
#: en/git-describe.txt:156
#, no-wrap, priority:260
msgid ""
"\t[torvalds@g5 git]$ git describe v1.0.4\n"
"\tv1.0.4\n"
msgstr ""
"\t[torvalds@g5 git]$ git describe v1.0.4\n"
"\tv1.0.4\n"

#. type: Plain text
#: en/git-describe.txt:159
#, placeholders:'--all', priority:260
msgid "With --all, the command can use branch heads as references, so the output shows the reference path as well:"
msgstr "使用 --all 选项，命令可以使用分支头作为参考，所以输出也会显示引用路径："

#. type: Plain text
#: en/git-describe.txt:162
#, no-wrap, placeholders:'--all':'--abbrev=4', priority:260
msgid ""
"\t[torvalds@g5 git]$ git describe --all --abbrev=4 v1.0.5^2\n"
"\ttags/v1.0.0-21-g975b\n"
msgstr ""
"\t[torvalds@g5 git]$ git describe --all --abbrev=4 v1.0.5^2\n"
"\ttags/v1.0.0-21-g975b\n"

#. type: Plain text
#: en/git-describe.txt:165
#, no-wrap, placeholders:'--all':'--abbrev=4':'HEAD', priority:260
msgid ""
"\t[torvalds@g5 git]$ git describe --all --abbrev=4 HEAD^\n"
"\theads/lt/describe-7-g975b\n"
msgstr ""
"\t[torvalds@g5 git]$ git describe --all --abbrev=4 HEAD^\n"
"\theads/lt/describe-7-g975b\n"

#. type: Plain text
#: en/git-describe.txt:168
#, placeholders:'--abbrev', priority:260
msgid "With --abbrev set to 0, the command can be used to find the closest tagname without any suffix:"
msgstr "在 --abbrev 选项设置为0的情况下，该命令可以用来寻找最接近的没有任何后缀的标签名："

#. type: Plain text
#: en/git-describe.txt:171
#, no-wrap, placeholders:'--abbrev=0', priority:260
msgid ""
"\t[torvalds@g5 git]$ git describe --abbrev=0 v1.0.5^2\n"
"\ttags/v1.0.0\n"
msgstr ""
"\t[torvalds@g5 git]$ git describe --abbrev=0 v1.0.5^2\n"
"\ttags/v1.0.0\n"

#. type: Plain text
#: en/git-describe.txt:177
#, priority:260
msgid "Note that the suffix you get if you type these commands today may be longer than what Linus saw above when he ran these commands, as your Git repository may have new commits whose object names begin with 975b that did not exist back then, and \"-g975b\" suffix alone may not be sufficient to disambiguate these commits."
msgstr "请注意，如果你今天输入这些命令，得到的后缀可能比上面Linus运行这些命令时看到的要长，因为你的Git仓库可能有新的提交，其对象名称以975b开头，而这些提交在当时并不存在，仅靠\"-g975b \"后缀可能还不足以区分这些提交。"

#. type: Title -
#: en/git-describe.txt:180
#, no-wrap, priority:260
msgid "SEARCH STRATEGY"
msgstr "搜索策略"

#. type: Plain text
#: en/git-describe.txt:187
#, priority:260
msgid "For each commit-ish supplied, 'git describe' will first look for a tag which tags exactly that commit. Annotated tags will always be preferred over lightweight tags, and tags with newer dates will always be preferred over tags with older dates. If an exact match is found, its name will be output and searching will stop."
msgstr "对于提供的每个提交，'git describe'将首先寻找一个标签，该标签正是该提交的标签。 有注释的标签总是比轻量级的标签更受欢迎，日期较新的标签总是比日期较老的标签更受欢迎。 如果找到一个完全匹配的标签，它的名字就会被输出，搜索就会停止。"

#. type: Plain text
#: en/git-describe.txt:194
#, placeholders:'`--first-parent`', priority:260
msgid "If an exact match was not found, 'git describe' will walk back through the commit history to locate an ancestor commit which has been tagged. The ancestor's tag will be output along with an abbreviation of the input commit-ish's SHA-1. If `--first-parent` was specified then the walk will only consider the first parent of each commit."
msgstr "如果没有找到完全匹配的，'git describe'会回溯提交历史，找到一个已经被标记的祖先提交。 该祖先的标签将与输入的提交的SHA-1的缩写一起被输出。如果指定了 `--first-parent`，那么回溯将只考虑每个提交的第一个父级。"

#. type: Plain text
#: en/git-describe.txt:200
#, priority:260
msgid "If multiple tags were found during the walk then the tag which has the fewest commits different from the input commit-ish will be selected and output. Here fewest commits different is defined as the number of commits which would be shown by `git log tag..input` will be the smallest number of commits possible."
msgstr "如果在行走过程中发现了多个标签，那么将选择与输入的commit-ish相差最少的标签并输出。 这里，最小的提交差异被定义为 \"git log tag...input \"所显示的提交数量将是最小的提交数量。"

#. type: Plain text
#: en/git-describe.txt:208
#, priority:260
msgid "Tree objects as well as tag objects not pointing at commits, cannot be described. When describing blobs, the lightweight tags pointing at blobs are ignored, but the blob is still described as <commit-ish>:<path> despite the lightweight tag being favorable."
msgstr "树对象以及不指向提交的标签对象，不能被描述。 在描述 blob 时，指向 blob 的轻量级标签会被忽略，但尽管轻量级标签是有利的，blob 仍然被描述为 <提交号>:<路径>。"

#. type: Title =
#: en/git-diff-files.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-diff-files(1)"
msgstr "git-diff-files(1)"

#. type: Plain text
#: en/git-diff-files.txt:7
#, placeholders:'git-diff-files', priority:100
msgid "git-diff-files - Compares files in the working tree and the index"
msgstr "git-diff-files - 对比工作区和索引中的文件"

#. type: Plain text
#: en/git-diff-files.txt:13
#, ignore-ellipsis, no-wrap, placeholders:'git diff-files':'--cc]', priority:100
msgid "'git diff-files' [-q] [-0 | -1 | -2 | -3 | -c | --cc] [<common-diff-options>] [<path>...]\n"
msgstr "'git diff-files' [-q] [-0|-1|-2|-3|-c|--cc] [<普通差异选项>] [<路径>...]\n"

#. type: Plain text
#: en/git-diff-files.txt:20
#, placeholders:'git diff-index':'git diff-tree', priority:100
msgid "Compares the files in the working tree and the index. When paths are specified, compares only those named paths. Otherwise all entries in the index are compared. The output format is the same as for 'git diff-index' and 'git diff-tree'."
msgstr "比较工作区和索引中的文件。 当指定路径时，只比较那些命名的路径。 否则就比较索引中的所有条目。 输出格式与 'git diff-index' 和 'git diff-tree' 的相同。"

#. type: Labeled list
#: en/git-diff-files.txt:25 en/git-diff.txt:128
#, no-wrap, placeholders:'--base', priority:280
msgid "-1 --base"
msgstr "-1 --base"

#. type: Labeled list
#: en/git-diff-files.txt:26 en/git-diff.txt:129
#, no-wrap, placeholders:'--ours', priority:280
msgid "-2 --ours"
msgstr "-2 --ours"

#. type: Labeled list
#: en/git-diff-files.txt:27 en/git-diff.txt:130
#, no-wrap, placeholders:'--theirs', priority:280
msgid "-3 --theirs"
msgstr "-3 --theirs"

#. type: Labeled list
#: en/git-diff-files.txt:28 en/git-diff.txt:137
#, ignore-same, no-wrap, priority:280
msgid "-0"
msgstr "-0"

#. type: Plain text
#: en/git-diff-files.txt:32
#, priority:100
msgid "Diff against the \"base\" version, \"our branch\", or \"their branch\" respectively. With these options, diffs for merged entries are not shown."
msgstr "分别与 “基础” 版本、“我们的分支” 或 “他们的分支” 进行比较。 有了这些选项，合并后的条目的差异就不会显示。"

#. type: Plain text
#: en/git-diff-files.txt:36
#, priority:100
msgid "The default is to diff against our branch (-2) and the cleanly resolved paths. The option -0 can be given to omit diff output for unmerged entries and just show \"Unmerged\"."
msgstr "默认是针对我们的分支 (-2) 和干净的解决路径进行差异比对。 可以给出选项 -0 来省略未合并的条目的差异输出，只显示 \"Unmerged\"。"

#. type: Plain text
#: en/git-diff-files.txt:43
#, priority:100
msgid "This compares stage 2 (our branch), stage 3 (their branch), and the working tree file and outputs a combined diff, similar to the way 'diff-tree' shows a merge commit with these flags."
msgstr "这将比较第二阶段（我们的分支）、第三阶段（他们的分支）和工作区文件，并输出一个综合的差异，类似于 'diff-tree' 显示带有这些标志的合并提交。"

#. type: Plain text
#: en/git-diff-files.txt:46
#, priority:100
msgid "Remain silent even for nonexistent files"
msgstr "即使对不存在的文件也保持沉默"

#. type: Title =
#: en/git-diff-index.txt:2
#, ignore-same, no-wrap, priority:80
msgid "git-diff-index(1)"
msgstr "git-diff-index(1)"

#. type: Plain text
#: en/git-diff-index.txt:7
#, placeholders:'git-diff-index', priority:80
msgid "git-diff-index - Compare a tree to the working tree or index"
msgstr "git-diff-index - 比较树和工作树或索引"

#. type: Plain text
#: en/git-diff-index.txt:13
#, ignore-ellipsis, no-wrap, placeholders:'git diff-index':'[--cached]':'[--merge-base]', priority:80
msgid "'git diff-index' [-m] [--cached] [--merge-base] [<common-diff-options>] <tree-ish> [<path>...]\n"
msgstr "'git diff-index' [-m] [--cached] [--merge-base] [<提交差异选项>] <目录树对象> [<路径>...]\n"

#. type: Plain text
#: en/git-diff-index.txt:21
#, priority:80
msgid "Compare the content and mode of the blobs found in a tree object with the corresponding tracked files in the working tree, or with the corresponding paths in the index. When <path> arguments are present, compare only paths matching those patterns. Otherwise all tracked files are compared."
msgstr "将树对象中发现的 blob 的内容和模式与工作树中的相应跟踪文件或索引中的相应路径进行比较。 如果存在 <路径> 参数，则只比较与这些模式匹配的路径。 否则，将比较所有跟踪文件。"

#. type: Plain text
#: en/git-diff-index.txt:28
#, priority:80
msgid "The id of a tree object to diff against."
msgstr "树对象的 id。"

#. type: Plain text
#: en/git-diff-index.txt:31
#, priority:80
msgid "Do not consider the on-disk file at all."
msgstr "完全不考虑磁盘文件。"

#. type: Labeled list
#: en/git-diff-index.txt:32 en/git-diff-tree.txt:46 en/git-show-branch.txt:82
#, ignore-same, no-wrap, priority:100
msgid "--merge-base"
msgstr "--merge-base"

#. type: Plain text
#: en/git-diff-index.txt:36
#, placeholders:'HEAD', priority:80
msgid "Instead of comparing <tree-ish> directly, use the merge base between <tree-ish> and HEAD instead. <tree-ish> must be a commit."
msgstr "与其直接比较 <目录树对象>，不如使用 <目录树对象> 和 HEAD 之间的合并基数。 <目录树对象> 必须是一个提交。"

#. type: Plain text
#: en/git-diff-index.txt:42
#, placeholders:'git diff-index', priority:80
msgid "By default, files recorded in the index but not checked out are reported as deleted. This flag makes 'git diff-index' say that all non-checked-out files are up to date."
msgstr "默认情况下，索引中有记录但未签出的文件会被报告为已删除。 这个标记会让 'git diff-index' 认为所有未签出的文件都是最新的。"

#. type: Title -
#: en/git-diff-index.txt:46
#, no-wrap, priority:80
msgid "OPERATING MODES"
msgstr "运行模式"

#. type: Plain text
#: en/git-diff-index.txt:51
#, placeholders:'`--cached`', priority:80
msgid "You can choose whether you want to trust the index file entirely (using the `--cached` flag) or ask the diff logic to show any files that don't match the stat state as being \"tentatively changed\". Both of these operations are very useful indeed."
msgstr "你可以选择是完全信任索引文件（使用 `--cached` 标志），还是要求 diff 逻辑将任何与统计状态不匹配的文件显示为 \"暂定更改\"。 这两种操作都非常有用。"

#. type: Title -
#: en/git-diff-index.txt:53
#, no-wrap, priority:80
msgid "CACHED MODE"
msgstr "缓存模式"

#. type: Plain text
#: en/git-diff-index.txt:55
#, placeholders:'`--cached`', priority:80
msgid "If `--cached` is specified, it allows you to ask:"
msgstr "如果指定了 `--cached`，则可以询问："

#. type: Plain text
#: en/git-diff-index.txt:58
#, no-wrap, placeholders:'HEAD':'git write-tree', priority:80
msgid ""
"\tshow me the differences between HEAD and the current index\n"
"\tcontents (the ones I'd write using 'git write-tree')\n"
msgstr ""
"\t向我显示 HEAD 和当前索引\n"
"\t内容（即我使用 'git write-tree' 写入的内容）之间的差异\n"

#. type: Plain text
#: en/git-diff-index.txt:63
#, priority:80
msgid "For example, let's say that you have worked on your working directory, updated some files in the index and are ready to commit. You want to see exactly *what* you are going to commit, without having to write a new tree object and compare it that way, and to do that, you just do"
msgstr "举个例子，假设你在工作目录中工作，更新了索引中的一些文件，准备提交。你想知道你 *要* 提交的内容，而不需要写一个新的树对象并进行比较"

#. type: Plain text
#: en/git-diff-index.txt:65
#, no-wrap, placeholders:'git diff-index':'--cached':'HEAD', priority:80
msgid "\tgit diff-index --cached HEAD\n"
msgstr "\tgit diff-index --cached HEAD\n"

#. type: Plain text
#: en/git-diff-index.txt:70
#, placeholders:'git-commit':'git diff-files':'git diff-index', priority:80
msgid "Example: let's say I had renamed `commit.c` to `git-commit.c`, and I had done an `update-index` to make that effective in the index file. `git diff-files` wouldn't show anything at all, since the index file matches my working directory. But doing a 'git diff-index' does:"
msgstr "示例：假设我把 `commit.c` 重命名为 `git-commit.c`，并执行了 `update-index` 使其在索引文件中生效。 由于索引文件与我的工作目录一致，所以`git diff-files`根本不会显示任何内容。但使用 'git diff-index ' 就可以："

#. type: Plain text
#: en/git-diff-index.txt:74
#, no-wrap, placeholders:'git diff-index':'--cached':'HEAD':'git-commit', priority:80
msgid ""
"  torvalds@ppc970:~/git> git diff-index --cached HEAD\n"
"  :100644 000000 4161aecc6700a2eb579e842af0b7f22b98443f74 0000000000000000000000000000000000000000 D\tcommit.c\n"
"  :000000 100644 0000000000000000000000000000000000000000 4161aecc6700a2eb579e842af0b7f22b98443f74 A\tgit-commit.c\n"
msgstr ""
"  torvalds@ppc970:~/git> git diff-index --cached HEAD\n"
"  -100644 blob    4161aecc6700a2eb579e842af0b7f22b98443f74        commit.c\n"
"  +100644 blob    4161aecc6700a2eb579e842af0b7f22b98443f74        git-commit.c\n"

#. type: Plain text
#: en/git-diff-index.txt:76
#, priority:80
msgid "You can see easily that the above is a rename."
msgstr "不难看出，以上是重命名。"

#. type: Plain text
#: en/git-diff-index.txt:80
#, placeholders:'git diff-index':'--cached`':'git write-tree', priority:80
msgid "In fact, `git diff-index --cached` *should* always be entirely equivalent to actually doing a 'git write-tree' and comparing that. Except this one is much nicer for the case where you just want to check where you are."
msgstr "事实上，`git diff-index --cached` *应当* 总是完全等同于实际执行 'git write-tree' 并进行比较。只不过，这个方法更适合只想查看当前位置的情况。"

#. type: Plain text
#: en/git-diff-index.txt:84
#, placeholders:'git diff-index':'--cached`', priority:80
msgid "So doing a `git diff-index --cached` is basically very useful when you are asking yourself \"what have I already marked for being committed, and what's the difference to a previous tree\"."
msgstr "因此，当你问自己 “我已经标记了哪些内容要提交，与之前的树有什么不同” 时，使用 `git diff-index --cached` 基本上是非常有用的。"

#. type: Title -
#: en/git-diff-index.txt:86
#, no-wrap, priority:80
msgid "NON-CACHED MODE"
msgstr "非缓存模式"

#. type: Plain text
#: en/git-diff-index.txt:91
#, placeholders:'git write-tree':'git diff-tree', priority:80
msgid "The \"non-cached\" mode takes a different approach, and is potentially the more useful of the two in that what it does can't be emulated with a 'git write-tree' + 'git diff-tree'. Thus that's the default mode. The non-cached version asks the question:"
msgstr "“非缓存” 模式采用的是另一种方法，而且可能是两种模式中最有用的一种，因为它的功能无法用 'git write-tree' + 'git diff-tree' 来模拟。因此这是默认模式。 非缓存版本提出的问题是："

#. type: Plain text
#: en/git-diff-index.txt:94
#, no-wrap, placeholders:'HEAD', priority:80
msgid ""
"  show me the differences between HEAD and the currently checked out\n"
"  tree - index contents _and_ files that aren't up to date\n"
msgstr ""
"  向我显示 HEAD 与当前已签出树之间的差异 - \n"
"  索引内容 _ 和未更新的文件\n"

#. type: Plain text
#: en/git-diff-index.txt:98
#, placeholders:'git diff-tree', priority:80
msgid "which is obviously a very useful question too, since that tells you what you *could* commit. Again, the output matches the 'git diff-tree -r' output to a tee, but with a twist."
msgstr "这显然也是一个非常有用的问题，因为它会告诉你*可能*提交的内容。同样，输出结果与 'git diff-tree -r' 的输出结果完全吻合，但又有所变化。"

#. type: Plain text
#: en/git-diff-index.txt:104
#, placeholders:'git update-index', priority:80
msgid "The twist is that if some file doesn't match the index, we don't have a backing store thing for it, and we use the magic \"all-zero\" sha1 to show that. So let's say that you have edited `kernel/sched.c`, but have not actually done a 'git update-index' on it yet - there is no \"object\" associated with the new state, and you get:"
msgstr "问题在于，如果某个文件与索引不匹配，我们就不会为它建立备份存储，我们会使用 “全零” sha1 来显示这一点。比方说，你编辑了 `kernel/sched.c`，但实际上还没有执行 'git update-index' --没有与新状态相关联的 “对象”，你就会得到："

#. type: Plain text
#: en/git-diff-index.txt:107
#, no-wrap, placeholders:'git diff-index':'--abbrev':'HEAD', priority:80
msgid ""
"  torvalds@ppc970:~/v2.6/linux> git diff-index --abbrev HEAD\n"
"  :100644 100644 7476bb5ba 000000000 M\tkernel/sched.c\n"
msgstr ""
"  torvalds@ppc970:~/v2.6/linux> git diff-index --abbrev HEAD\n"
"  :100644 100644 7476bb5ba 000000000 M\tkernel/sched.c\n"

#. type: Plain text
#: en/git-diff-index.txt:112
#, priority:80
msgid "i.e., it shows that the tree has changed, and that `kernel/sched.c` is not up to date and may contain new stuff. The all-zero sha1 means that to get the real diff, you need to look at the object in the working directory directly rather than do an object-to-object diff."
msgstr "也就是说，它显示树已经改变，而且 `kernel/sched.c` 不是最新的，可能包含新的内容。全零的 sha1 意味着要获得真正的差异，需要直接查看工作目录中的对象，而不是进行对象间的差异。"

#. type: Plain text
#: en/git-diff-index.txt:118
#, placeholders:'git diff-index':'git update-index', priority:80
msgid "As with other commands of this type, 'git diff-index' does not actually look at the contents of the file at all. So maybe `kernel/sched.c` hasn't actually changed, and it's just that you touched it. In either case, it's a note that you need to 'git update-index' it to make the index be in sync."
msgstr "与其他同类命令一样，'git diff-index' 实际上并不查看文件内容。所以也许 `kernel/sched.c` 实际上并没有改变，只是你看了一下而已。无论哪种情况，都需要 'git update-index' 来使索引同步。"

#. type: Plain text
#: en/git-diff-index.txt:124
#, priority:80
msgid "You can have a mixture of files show up as \"has been updated\" and \"is still dirty in the working directory\" together. You can always tell which file is in which state, since the \"has been updated\" ones show a valid sha1, and the \"not in sync with the index\" ones will always have the special all-zero sha1."
msgstr "你可以让各种文件同时显示为 “已更新” 和 “仍在工作目录中”。由于 “已更新” 的文件会显示有效的 sha1，而 “未与索引同步” 的文件则会显示特殊的全零 sha1，因此你总能分辨出哪个文件处于哪种状态。"

#. type: Title =
#: en/git-difftool.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-difftool(1)"
msgstr "git-difftool(1)"

#. type: Plain text
#: en/git-difftool.txt:7
#, placeholders:'git-difftool', priority:100
msgid "git-difftool - Show changes using common diff tools"
msgstr "git-difftool - 使用常见的差异工具显示变化"

#. type: Plain text
#: en/git-difftool.txt:12
#, ignore-ellipsis, no-wrap, priority:100
msgid "'git difftool' [<options>] [<commit> [<commit>]] [--] [<path>...]\n"
msgstr "'git difftool' [<选项>] [<提交> [<提交>]] [--] [<路径>...]\n"

#. type: Plain text
#: en/git-difftool.txt:19
#, placeholders:'linkgit:git-diff[1]', priority:100
msgid "'git difftool' is a Git command that allows you to compare and edit files between revisions using common diff tools. 'git difftool' is a frontend to 'git diff' and accepts the same options and arguments. See linkgit:git-diff[1]."
msgstr "'git difftool' 是一条 Git 命令，它允许你使用常用的差异工具在不同版本之间比较和编辑文件。 'git difftool' 是 'git diff' 的前端，接受相同的选项和参数。参见 linkgit:git-diff[1]。"

#. type: Labeled list
#: en/git-difftool.txt:23
#, ignore-same, no-wrap, priority:100
msgid "--dir-diff"
msgstr "--dir-diff"

#. type: Plain text
#: en/git-difftool.txt:27
#, priority:100
msgid "Copy the modified files to a temporary location and perform a directory diff on them. This mode never prompts before launching the diff tool."
msgstr "把修改过的文件复制到一个临时位置，然后对它们进行目录比较。这种模式在启动差异工具之前从不提示。"

#. type: Labeled list
#: en/git-difftool.txt:28 en/git-mergetool.txt:70
#, ignore-same, no-wrap, priority:240
msgid "-y"
msgstr "-y"

#. type: Labeled list
#: en/git-difftool.txt:29 en/git-mergetool.txt:71
#, ignore-same, no-wrap, priority:240
msgid "--no-prompt"
msgstr "--no-prompt"

#. type: Plain text
#: en/git-difftool.txt:31
#, priority:100
msgid "Do not prompt before launching a diff tool."
msgstr "在启动差异工具之前不要提示。"

#. type: Labeled list
#: en/git-difftool.txt:32 en/git-mergetool.txt:78
#, ignore-same, no-wrap, priority:240
msgid "--prompt"
msgstr "--prompt"

#. type: Plain text
#: en/git-difftool.txt:36
#, priority:100
msgid "Prompt before each invocation of the diff tool. This is the default behaviour; the option is provided to override any configuration settings."
msgstr "在每次调用差异工具之前提示。 这是默认行为；提供该选项是为了覆盖任何配置设置。"

#. type: Plain text
#: en/git-difftool.txt:40
#, priority:100
msgid "Start showing the diff for the given path, the paths before it will move to the end and output."
msgstr "开始显示给定路径的差异，在它之前的路径将移动到终点并输出。"

#. type: Plain text
#: en/git-difftool.txt:44
#, priority:100
msgid "Start showing the diff for the given path, skipping all the paths before it."
msgstr "开始显示给定路径的差异，跳过前面所有的路径。"

#. type: Labeled list
#: en/git-difftool.txt:45 en/git-mergetool.txt:27
#, no-wrap, priority:240
msgid "-t <tool>"
msgstr "-t <工具>"

#. type: Labeled list
#: en/git-difftool.txt:46 en/git-mergetool.txt:28
#, no-wrap, placeholders:'--tool=', priority:240
msgid "--tool=<tool>"
msgstr "--tool=<工具>"

#. type: Plain text
#: en/git-difftool.txt:50
#, placeholders:'--tool-help`', priority:100
msgid "Use the diff tool specified by <tool>. Valid values include emerge, kompare, meld, and vimdiff. Run `git difftool --tool-help` for the list of valid <tool> settings."
msgstr "使用由 <工具> 指定的差异工具。 有效值包括 emerge, kompare, meld, 和 vimdiff。运行 `git difftool --tool-help` 以获得有效的 <工具> 设置列表。"

#. type: Plain text
#: en/git-difftool.txt:55
#, placeholders:'diff.tool':'diff.tool', priority:100
msgid "If a diff tool is not specified, 'git difftool' will use the configuration variable `diff.tool`. If the configuration variable `diff.tool` is not set, 'git difftool' will pick a suitable default."
msgstr "如果没有指定差异工具，'git difftool' 将使用配置变量 `diff.tool`。 如果配置变量 `diff.tool` 没有设置，'git difftool' 将选择一个合适的默认值。"

#. type: Plain text
#: en/git-difftool.txt:61
#, priority:100
msgid "You can explicitly provide a full path to the tool by setting the configuration variable `difftool.<tool>.path`. For example, you can configure the absolute path to kdiff3 by setting `difftool.kdiff3.path`. Otherwise, 'git difftool' assumes the tool is available in PATH."
msgstr "你可以通过设置配置变量 `difftool.<工具>.path` 来明确提供工具的完整路径。例如，你可以通过设置 `difftool.kdiff3.path` 来配置 kdiff3 的绝对路径。否则，'git difftool' 会假定该工具在 PATH 中可用。"

#. type: Plain text
#: en/git-difftool.txt:66
#, priority:100
msgid "Instead of running one of the known diff tools, 'git difftool' can be customized to run an alternative program by specifying the command line to invoke in a configuration variable `difftool.<tool>.cmd`."
msgstr "通过在配置变量 `difftool.<工具>.cmd` 中指定要调用的命令行，可以定制 'git difftool'，而不是运行一个已知的比较工具，以运行一个替代程序。"

#. type: Plain text
#: en/git-difftool.txt:76
#, placeholders:'`-t`':'`--tool`':'diff.tool':'$LOCAL':'$REMOTE':'$MERGED':'$BASE':'$MERGED', priority:100
msgid "When 'git difftool' is invoked with this tool (either through the `-t` or `--tool` option or the `diff.tool` configuration variable) the configured command line will be invoked with the following variables available: `$LOCAL` is set to the name of the temporary file containing the contents of the diff pre-image and `$REMOTE` is set to the name of the temporary file containing the contents of the diff post-image. `$MERGED` is the name of the file which is being compared. `$BASE` is provided for compatibility with custom merge tool commands and has the same value as `$MERGED`."
msgstr "当 'git difftool' 与此工具一起调用时（通过 `-t` 或 `--tool` 选项或 `diff.tool` 配置变量），配置的命令行将被调用，以下变量可用： `$LOCAL` 被设置为包含差异比对前图像内容的临时文件名，`$REMOTE` 被设置为包含差异比对后图像内容的临时文件名。 `$MERGED` 是被比较的文件的名称。`$BASE` 是为了与自定义合并工具命令兼容而提供的，其值与 `$MERGED` 相同。"

#. type: Labeled list
#: en/git-difftool.txt:77 en/git-mergetool.txt:67
#, ignore-same, no-wrap, priority:240
msgid "--tool-help"
msgstr "--tool-help"

# ERROR: `--tool` not found in translation
#. type: Plain text
#: en/git-difftool.txt:79
#, placeholders:'`--tool`', priority:100
msgid "Print a list of diff tools that may be used with `--tool`."
msgstr "列出可以和 `--tool` 命令一起使用的 diff 工具。"

#. type: Labeled list
#: en/git-difftool.txt:80
#, ignore-same, no-wrap, priority:100
msgid "--[no-]symlinks"
msgstr "--[no-]symlinks"

#. type: Plain text
#: en/git-difftool.txt:85
#, placeholders:'`--dir-diff`', priority:100
msgid "'git difftool''s default behavior is to create symlinks to the working tree when run in `--dir-diff` mode and the right-hand side of the comparison yields the same content as the file in the working tree."
msgstr "在 `--dir-diff` 模式下运行时，'git difftool' 的默认行为是创建指向工作目录树的符号链接，比较的右侧结果与工作目录树中的文件内容相同。"

#. type: Plain text
#: en/git-difftool.txt:88
#, placeholders:'`--no-symlinks`':'`--no-symlinks`', priority:100
msgid "Specifying `--no-symlinks` instructs 'git difftool' to create copies instead. `--no-symlinks` is the default on Windows."
msgstr "指定 `---no-symlinks` 会指示 'git difftool' 创建副本。 `--no-symlinks` 是 Windows 上的默认值。"

#. type: Labeled list
#: en/git-difftool.txt:89
#, no-wrap, priority:100
msgid "-x <command>"
msgstr "-x <命令>"

#. type: Labeled list
#: en/git-difftool.txt:90
#, no-wrap, placeholders:'--extcmd=', priority:100
msgid "--extcmd=<command>"
msgstr "--extcmd=<命令>"

#. type: Plain text
#: en/git-difftool.txt:95
#, placeholders:'git-difftool':'$LOCAL':'$REMOTE':'$BASE', priority:100
msgid "Specify a custom command for viewing diffs. 'git-difftool' ignores the configured defaults and runs `<command> $LOCAL $REMOTE` when this option is specified. Additionally, `$BASE` is set in the environment."
msgstr "指定一个用于查看差异的自定义命令。 'git-difftool' 忽略了配置的默认值，当这个选项被指定时，运行`$command $LOCAL $REMOTE`。 此外，`$BASE`在环境中被设置。"

#. type: Labeled list
#: en/git-difftool.txt:96 en/git-help.txt:70 en/git-mergetool.txt:82 en/git-show-branch.txt:110 en/git-update-index.txt:127 en/rev-list-options.txt:308
#, ignore-same, no-wrap, priority:260
msgid "-g"
msgstr "-g"

#. type: Labeled list
#: en/git-difftool.txt:97
#, ignore-same, no-wrap, priority:100
msgid "--[no-]gui"
msgstr "--[no-]gui"

# ERROR: --no-gui not found in translation
#. type: Plain text
#: en/git-difftool.txt:106
#, placeholders:'git-difftool':'`-g`':'`--gui`':'diff.guitool':'diff.tool':'difftool.guiDefault':'`--no-gui`':'diff.guitool':'merge.guitool':'diff.tool':'merge.tool', priority:100
msgid "When 'git-difftool' is invoked with the `-g` or `--gui` option the default diff tool will be read from the configured `diff.guitool` variable instead of `diff.tool`. This may be selected automatically using the configuration variable `difftool.guiDefault`. The `--no-gui` option can be used to override these settings. If `diff.guitool` is not set, we will fallback in the order of `merge.guitool`, `diff.tool`, `merge.tool` until a tool is found."
msgstr "当使用 `-g` 或 `--gui` 选项调用 'git-difftool' 时，默认的差异工具将从配置的 `diff.guitool` 变量中读取，而不是 `diff.tool`。这可以通过配置变量 `difftool.guiDefault` 自动选择。可以使用 `--no-gui` 选项来覆盖这些设置。如果未设置 `diff.guitool`，我们将按照 `merge.guitool`, `diff.tool`, `merge.tool` 的顺序进行回退，直到找到工具为止。"

#. type: Labeled list
#: en/git-difftool.txt:107
#, ignore-same, no-wrap, priority:100
msgid "--[no-]trust-exit-code"
msgstr "--[no-]trust-exit-code"

#. type: Plain text
#: en/git-difftool.txt:112
#, placeholders:'git-difftool':'`--trust-exit-code`':'git-difftool', priority:100
msgid "'git-difftool' invokes a diff tool individually on each file. Errors reported by the diff tool are ignored by default. Use `--trust-exit-code` to make 'git-difftool' exit when an invoked diff tool returns a non-zero exit code."
msgstr "'git-difftool' 在每个文件上单独调用一个差异工具。 默认情况下，差异工具报告的错误会被忽略。 使用 `--trust-exit-code` 使 'git-difftool' 在被调用的差异工具返回非零的退出代码时退出。"

#. type: Plain text
#: en/git-difftool.txt:115
#, placeholders:'git-difftool':'`--trust-exit-code`', priority:100
msgid "'git-difftool' will forward the exit code of the invoked tool when `--trust-exit-code` is used."
msgstr "'git-difftool' 在使用 `--trust-exit-code` 时将转发被调用工具的退出代码。"

#. type: Plain text
#: en/git-difftool.txt:117
#, placeholders:'linkgit:git-diff[1]', priority:100
msgid "See linkgit:git-diff[1] for the full list of supported options."
msgstr "关于支持的选项的完整列表，见 linkgit:git-diff[1]。"

#. type: Plain text
#: en/git-difftool.txt:122
#, priority:100
msgid "'git difftool' falls back to 'git mergetool' config variables when the difftool equivalents have not been defined."
msgstr "当差异工具等价物没有被定义时，'git difftool' 会返回到 'git mergetool' 配置变量。"

#. type: Plain text
#: en/git-difftool.txt:131
#, priority:100
msgid "Show changes between commits, commit and working tree, etc"
msgstr "显示提交之间的变化，提交和工作区，等等"

#. type: Plain text
#: en/git-difftool.txt:134
#, priority:100
msgid "Run merge conflict resolution tools to resolve merge conflicts"
msgstr "运行合并冲突解决工具来解决合并冲突"

#. type: Plain text
#: en/git-difftool.txt:137
#, priority:100
msgid "Get and set repository or global options"
msgstr "获取和设置仓库或全局选项"

#. type: Title =
#: en/git-diff-tree.txt:2
#, ignore-same, no-wrap, priority:80
msgid "git-diff-tree(1)"
msgstr "git-diff-tree(1)"

#. type: Plain text
#: en/git-diff-tree.txt:7
#, placeholders:'git-diff-tree', priority:80
msgid "git-diff-tree - Compares the content and mode of blobs found via two tree objects"
msgstr "git-diff-tree - 比较通过两个树对象找到的 Blob 的内容和模式"

#. type: Plain text
#: en/git-diff-tree.txt:15
#, ignore-ellipsis, no-wrap, placeholders:'git diff-tree':'[--stdin]':'[--no-commit-id]':'[--pretty]':'--cc]':'[--combined-all-paths]':'[--root]':'[--merge-base]', priority:80
msgid ""
"'git diff-tree' [--stdin] [-m] [-s] [-v] [--no-commit-id] [--pretty]\n"
"\t      [-t] [-r] [-c | --cc] [--combined-all-paths] [--root] [--merge-base]\n"
"\t      [<common-diff-options>] <tree-ish> [<tree-ish>] [<path>...]\n"
msgstr ""
"'git diff-tree' [--stdin] [-m] [-s] [-v] [--no-commit-id] [--pretty]\n"
"\t      [-t] [-r] [-c | --cc] [--combined-all-paths] [--root] [--merge-base]\n"
"\t      [<common-diff-options>] <目录树对象> [<目录树对象>] [<路径>...]\n"

#. type: Plain text
#: en/git-diff-tree.txt:19
#, priority:80
msgid "Compare the content and mode of blobs found via two tree objects."
msgstr "比较两个目录树对象中发现的 blob 的内容和模式。"

#. type: Plain text
#: en/git-diff-tree.txt:22
#, placeholders:'--stdin', priority:80
msgid "If there is only one <tree-ish> given, the commit is compared with its parents (see --stdin below)."
msgstr "如果只给出一个 <目录树对象>，则会将该提交与其父提交进行比较（见下文的 --stdin）。"

#. type: Plain text
#: en/git-diff-tree.txt:24
#, placeholders:'git diff-tree', priority:80
msgid "Note that 'git diff-tree' can use the tree encapsulated in a commit object."
msgstr "请注意，'git diff-tree' 可以使用封装在提交对象中的树。"

#. type: Plain text
#: en/git-diff-tree.txt:31
#, priority:80
msgid "The id of a tree object."
msgstr "树对象的 id。"

#. type: Labeled list
#: en/git-diff-tree.txt:32 en/git-diff.txt:142 en/git-submodule.txt:448
#, ignore-ellipsis, no-wrap, priority:280
msgid "<path>..."
msgstr "<路径>..."

#. type: Plain text
#: en/git-diff-tree.txt:35
#, priority:80
msgid "If provided, the results are limited to a subset of files matching one of the provided pathspecs."
msgstr "如果提供了该选项，则结果仅限于与所提供的路径规格之一相匹配的文件子集。"

#. type: Plain text
#: en/git-diff-tree.txt:38 en/git-ls-tree.txt:46
#, priority:80
msgid "Recurse into sub-trees."
msgstr "向子树递归。"

#. type: Plain text
#: en/git-diff-tree.txt:41
#, priority:80
msgid "Show tree entry itself as well as subtrees. Implies -r."
msgstr "展示目录树本身以及子树。 暗指 -r。"

#. type: Plain text
#: en/git-diff-tree.txt:45
#, placeholders:'`--root`', priority:80
msgid "When `--root` is specified the initial commit will be shown as a big creation event. This is equivalent to a diff against the NULL tree."
msgstr "当指定了 `--root` 时，初始提交将显示为一个大的创建事件。这相当于针对 NULL 树的差分。"

#. type: Plain text
#: en/git-diff-tree.txt:50
#, priority:80
msgid "Instead of comparing the <tree-ish>s directly, use the merge base between the two <tree-ish>s as the \"before\" side. There must be two <tree-ish>s given and they must both be commits."
msgstr "不要直接比较 <树对象>，而是使用两个 <树对象> 之间的合并基数作为 \"before\" 边。 必须有两个 <树对象>，而且必须都是提交。"

#. type: Plain text
#: en/git-diff-tree.txt:57
#, placeholders:'`--stdin`', priority:80
msgid "When `--stdin` is specified, the command does not take <tree-ish> arguments from the command line. Instead, it reads lines containing either two <tree>, one <commit>, or a list of <commit> from its standard input. (Use a single space as separator.)"
msgstr "如果指定了 `--stdin`，命令不会从命令行获取 <树对象> 参数。 相反，它会从标准输入中读取包含两个 <目录树>、一个 <提交> 或一个 <提交> 列表的行。 (使用单空格作为分隔符）"

#. type: Plain text
#: en/git-diff-tree.txt:62
#, priority:80
msgid "When two trees are given, it compares the first tree with the second. When a single commit is given, it compares the commit with its parents. The remaining commits, when given, are used as if they are parents of the first commit."
msgstr "当给出两个树时，它会比较第一个目录树和第二个目录树。 如果给出的是单个提交，则会将该提交与其父提交进行比较。 如果给出了其余的提交，则会把它们当作第一个提交的父提交来使用。"

#. type: Plain text
#: en/git-diff-tree.txt:67
#, priority:80
msgid "When comparing two trees, the ID of both trees (separated by a space and terminated by a newline) is printed before the difference. When comparing commits, the ID of the first (or only) commit, followed by a newline, is printed."
msgstr "比较两棵目录树时，会在差值前打印两棵目录树的 ID（用空格分隔并以换行结束）。 比较提交时，则会打印第一个（或唯一一个）提交的 ID，并以换行结束。"

#. type: Plain text
#: en/git-diff-tree.txt:70
#, priority:80
msgid "The following flags further affect the behavior when comparing commits (but not trees)."
msgstr "以下标记会进一步影响比较提交（而不是目录树树）时的行为。"

#. type: Plain text
#: en/git-diff-tree.txt:76
#, placeholders:'git diff-tree':'--stdin':'`-c`', priority:80
msgid "By default, 'git diff-tree --stdin' does not show differences for merge commits. With this flag, it shows differences to that commit from all of its parents. See also `-c`."
msgstr "默认情况下，'git diff-tree --stdin' 不会显示合并提交的差异。 有了这个标记，它就会显示该提交与其所有父提交的差异。另请参阅 `-c`。"

#. type: Plain text
#: en/git-diff-tree.txt:82
#, placeholders:'git diff-tree':'--stdin':'`-p`':'`-p`':'`-v`', priority:80
msgid "By default, 'git diff-tree --stdin' shows differences, either in machine-readable form (without `-p`) or in patch form (with `-p`). This output can be suppressed. It is only useful with the `-v` flag."
msgstr "默认情况下，'git diff-tree --stdin' 会以机器可读形式（不含 `-p`）或补丁形式（含 `-p`）显示差异。 该输出可以被抑制。 只有使用 `-v` 标志时才有用。"

#. type: Plain text
#: en/git-diff-tree.txt:86
#, placeholders:'git diff-tree':'--stdin', priority:80
msgid "This flag causes 'git diff-tree --stdin' to also show the commit message before the differences."
msgstr "该标记会使 'git diff-tree --stdin' 在差异之前显示提交信息。"

#. type: Labeled list
#: en/git-diff-tree.txt:89
#, ignore-same, no-wrap, priority:80
msgid "--no-commit-id"
msgstr "--no-commit-id"

#. type: Plain text
#: en/git-diff-tree.txt:92
#, placeholders:'git diff-tree', priority:80
msgid "'git diff-tree' outputs a line with the commit ID when applicable. This flag suppressed the commit ID output."
msgstr "'git diff-tree' 会在适当的时候输出一行提交 ID。 该标记会抑制提交 ID 的输出。"

#. type: Plain text
#: en/git-diff-tree.txt:102
#, placeholders:'`--stdin`':'`-m`', priority:80
msgid "This flag changes the way a merge commit is displayed (which means it is useful only when the command is given one <tree-ish>, or `--stdin`). It shows the differences from each of the parents to the merge result simultaneously instead of showing pairwise diff between a parent and the result one at a time (which is what the `-m` option does). Furthermore, it lists only files which were modified from all parents."
msgstr "这个标记改变了合并提交的显示方式（这意味着它只在命令为一个 <树对象> 或 `--stdin` 时有用）。 它会同时显示每个父文件与合并结果之间的差异，而不是一次一个地显示父文件与合并结果之间的成对差异（`-m` 选项就是这么做的）。 此外，它只列出从所有父文件修改过的文件。"

#. type: Plain text
#: en/git-diff-tree.txt:112
#, placeholders:'`-c`':'`-c`':'`-p`', priority:80
msgid "This flag changes the way a merge commit patch is displayed, in a similar way to the `-c` option. It implies the `-c` and `-p` options and further compresses the patch output by omitting uninteresting hunks whose contents in the parents have only two variants and the merge result picks one of them without modification. When all hunks are uninteresting, the commit itself and the commit log message are not shown, just like in any other \"empty diff\" case."
msgstr "这个标记改变了合并提交补丁的显示方式，与 `-c` 选项类似。它暗示了 `-c` 和 `-p` 选项，并通过省略不感兴趣的 hunk 来进一步压缩补丁输出，这些 hunk 的内容在父节点中只有两种变体，合并结果会选择其中之一而不做修改。 如果所有 hunk 都是无趣的，提交本身和提交日志信息都不会显示，就像其他 “空差异” 情况一样。"

#. type: Plain text
#: en/git-diff-tree.txt:119
#, placeholders:'--cc', priority:80
msgid "This flag causes combined diffs (used for merge commits) to list the name of the file from all parents. It thus only has effect when -c or --cc are specified, and is likely only useful if filename changes are detected (i.e. when either rename or copy detection have been requested)."
msgstr "该标记会导致合并差异（用于合并提交）列出所有父文件的文件名。 因此，它只有在指定 -c 或 --cc 时才有效，而且可能只有在检测到文件名更改时才有用（即请求重命名或复制检测时）。"

#. type: Plain text
#: en/git-diff-tree.txt:123
#, priority:80
msgid "Show the commit itself and the commit log message even if the diff itself is empty."
msgstr "即使差异本身为空，也会显示提交本身和提交日志信息。"

#. type: Title =
#: en/git-diff.txt:2
#, ignore-same, no-wrap, priority:280
msgid "git-diff(1)"
msgstr "git-diff(1)"

#. type: Plain text
#: en/git-diff.txt:7
#, placeholders:'git-diff', priority:280
msgid "git-diff - Show changes between commits, commit and working tree, etc"
msgstr "git-diff - 显示提交和工作区等变化"

#. type: Plain text
#: en/git-diff.txt:18
#, ignore-ellipsis, no-wrap, placeholders:'--cached':'[--merge-base]':'[--merge-base]':'--no-index', priority:280
msgid ""
"'git diff' [<options>] [<commit>] [--] [<path>...]\n"
"'git diff' [<options>] --cached [--merge-base] [<commit>] [--] [<path>...]\n"
"'git diff' [<options>] [--merge-base] <commit> [<commit>...] <commit> [--] [<path>...]\n"
"'git diff' [<options>] <commit>...<commit> [--] [<path>...]\n"
"'git diff' [<options>] <blob> <blob>\n"
"'git diff' [<options>] --no-index [--] <path> <path>\n"
msgstr ""
"'git diff' [<options>] [<commit>] [--] [<path>...]。\n"
"'git diff' [<options>] --cached [--merge-base] [<commit>] [--] [<path>...]。\n"
"'git diff' [<options>] [--merge-base] <commit> [<commit>...] <commit> [--] [<path>...]\n"
"'git diff' [<options>] <commit>...<commit> [--] [<path>...]。\n"
"'git diff' [<options>] <blob> <blob\n"
"'git diff' [<options>] --no-index [--] <path> <path>。\n"

#. type: Plain text
#: en/git-diff.txt:25
#, priority:280
msgid "Show changes between the working tree and the index or a tree, changes between the index and a tree, changes between two trees, changes resulting from a merge, changes between two blob objects, or changes between two files on disk."
msgstr "显示工作树和索引或树之间的变化，索引和树之间的变化，两个树之间的变化，合并产生的变化，两个blob对象之间的变化，或者磁盘上两个文件之间的变化。"

#. type: Labeled list
#: en/git-diff.txt:26
#, ignore-ellipsis, no-wrap, priority:280
msgid "'git diff' [<options>] [--] [<path>...]"
msgstr "'git diff' [<选项>] [--] [<路径>...]"

#. type: Plain text
#: en/git-diff.txt:33
#, placeholders:'linkgit:git-add[1]', priority:280
msgid "This form is to view the changes you made relative to the index (staging area for the next commit). In other words, the differences are what you _could_ tell Git to further add to the index but you still haven't. You can stage these changes by using linkgit:git-add[1]."
msgstr "这个表格是用来查看你相对于索引（下次提交的暂存区域）所做的修改。 换句话说，这些差异是你_可以告诉 Git 进一步添加到索引中，但你仍然没有。 你可以用linkgit:git-add[1]来对这些改动进行分期。"

#. type: Labeled list
#: en/git-diff.txt:34
#, no-wrap, placeholders:'--no-index', priority:280
msgid "'git diff' [<options>] --no-index [--] <path> <path>"
msgstr "'git diff' [<选项>] --no-index [--] <路径> <路径>"

#. type: Plain text
#: en/git-diff.txt:42
#, placeholders:'`--no-index`':'`--exit-code`', priority:280
msgid "This form is to compare the given two paths on the filesystem. You can omit the `--no-index` option when running the command in a working tree controlled by Git and at least one of the paths points outside the working tree, or when running the command outside a working tree controlled by Git. This form implies `--exit-code`."
msgstr "这种形式是为了比较文件系统上给定的两个路径。 当在一个由Git控制的工作树中运行该命令，并且至少有一个路径指向工作树之外，或者在一个由Git控制的工作树之外运行该命令时，你可以省略`--no-index`选项。这种形式意味着`--exit-code`。"

# ERROR: --merge-base not found in translation
#. type: Labeled list
#: en/git-diff.txt:43
#, ignore-ellipsis, no-wrap, placeholders:'--cached':'[--merge-base]', priority:280
msgid "'git diff' [<options>] --cached [--merge-base] [<commit>] [--] [<path>...]"
msgstr "'git diff' [<选项>] --cached [--merge-base] [<提交>] [--] [<路径>...]"

#. type: Plain text
#: en/git-diff.txt:52
#, placeholders:'HEAD':'HEAD':'--staged':'--cached', priority:280
msgid "This form is to view the changes you staged for the next commit relative to the named <commit>. Typically you would want comparison with the latest commit, so if you do not give <commit>, it defaults to HEAD. If HEAD does not exist (e.g. unborn branches) and <commit> is not given, it shows all staged changes. --staged is a synonym of --cached."
msgstr "这个表单是用来查看你为下一次提交所做的相对于<commit>的修改。 通常情况下，你希望与最新的提交进行比较，所以如果你没有给出 <commit>，它默认为 HEAD。 如果HEAD不存在（例如未出生的分支），并且没有给出<commit>，它将显示所有已缓存的修改。 --staged是--cached的同义词。"

#. type: Plain text
#: en/git-diff.txt:56
#, placeholders:'--merge-base':'HEAD':'--cached':'--merge-base':'--cached':'git merge-base':'HEAD', priority:280
msgid "If --merge-base is given, instead of using <commit>, use the merge base of <commit> and HEAD. `git diff --cached --merge-base A` is equivalent to `git diff --cached $(git merge-base A HEAD)`."
msgstr "如果给出 --merge-base，则不使用 <提交>，而使用 <提交> 和 HEAD 的合并基数。 `git diff --cached --merge-base A` 等同于 `git diff --cached $(git merge-base A HEAD)`。"

#. type: Labeled list
#: en/git-diff.txt:57
#, ignore-ellipsis, no-wrap, placeholders:'[--merge-base]', priority:280
msgid "'git diff' [<options>] [--merge-base] <commit> [--] [<path>...]"
msgstr "'git diff' [<选项>] [--merge-base] <提交> [--] [<路径>...]"

#. type: Plain text
#: en/git-diff.txt:64
#, placeholders:'HEAD', priority:280
msgid "This form is to view the changes you have in your working tree relative to the named <commit>. You can use HEAD to compare it with the latest commit, or a branch name to compare with the tip of a different branch."
msgstr "这个表格是用来查看你的工作树中相对于命名为<commit>的修改。 您可以使用 HEAD 来与最新的提交进行比较，或者使用分支名称来与不同分支的顶端进行比较。"

#. type: Plain text
#: en/git-diff.txt:68
#, placeholders:'--merge-base':'HEAD':'--merge-base':'git merge-base':'HEAD', priority:280
msgid "If --merge-base is given, instead of using <commit>, use the merge base of <commit> and HEAD. `git diff --merge-base A` is equivalent to `git diff $(git merge-base A HEAD)`."
msgstr "如果给出了 --merge-base，则不使用<commit>，而使用<commit>和HEAD的合并基数。 `git diff --merge-base A`等同于`git diff $(git merge-base A HEAD)`。"

# ERROR: --merge-base not found in translation
#. type: Labeled list
#: en/git-diff.txt:69
#, ignore-ellipsis, no-wrap, placeholders:'[--merge-base]', priority:280
msgid "'git diff' [<options>] [--merge-base] <commit> <commit> [--] [<path>...]"
msgstr "'git diff' [<多个选项>] [--merge-base] <提交> <提交> [--] [<路径>...]"

#. type: Plain text
#: en/git-diff.txt:73
#, priority:280
msgid "This is to view the changes between two arbitrary <commit>."
msgstr "这是为了查看两个任意<commit>之间的变化。"

#. type: Plain text
#: en/git-diff.txt:77
#, placeholders:'--merge-base':'--merge-base':'git merge-base', priority:280
msgid "If --merge-base is given, use the merge base of the two commits for the \"before\" side. `git diff --merge-base A B` is equivalent to `git diff $(git merge-base A B) B`."
msgstr "如果给出了 --merge-base，则使用两个提交的合并基础作为 \"之前 \"的一方。 `git diff --merge-base A B`等同于`git diff $(git merge-base A B) B`。"

#. type: Labeled list
#: en/git-diff.txt:78
#, ignore-ellipsis, no-wrap, priority:280
msgid "'git diff' [<options>] <commit> <commit>... <commit> [--] [<path>...]"
msgstr "'git diff' [<选项>] <提交> <提交>... <提交> [--] [<路径>...]"

#. type: Plain text
#: en/git-diff.txt:86
#, priority:280
msgid "This form is to view the results of a merge commit. The first listed <commit> must be the merge itself; the remaining two or more commits should be its parents. Convenient ways to produce the desired set of revisions are to use the suffixes `^@` and `^!`. If A is a merge commit, then `git diff A A^@`, `git diff A^!` and `git show A` all give the same combined diff."
msgstr "此表单用于查看合并提交的结果。 第一个列出的 <提交> 必须是合并本身；其余两个或更多的提交应该是它的父提交。 使用后缀 `^@` 和 `^!` 可以方便地生成所需的修订集。 如果 A 是合并提交，那么 `git diff A A^@` 、`git diff A^!` 和 `git show A` 都会得到相同的合并差异。"

#. type: Labeled list
#: en/git-diff.txt:87
#, ignore-ellipsis, no-wrap, priority:280
msgid "'git diff' [<options>] <commit>..<commit> [--] [<path>...]"
msgstr "'git diff' [<选项>] <提交>..<提交> [--] [<路径>...]"

#. type: Plain text
#: en/git-diff.txt:93
#, placeholders:'HEAD', priority:280
msgid "This is synonymous to the earlier form (without the `..`) for viewing the changes between two arbitrary <commit>. If <commit> on one side is omitted, it will have the same effect as using HEAD instead."
msgstr "这与早期的形式（没有`.`）是同义的，用于查看两个任意<commit>之间的变化。 如果省略了一侧的<commit>，将产生与使用HEAD相同的效果。"

#. type: Labeled list
#: en/git-diff.txt:94
#, ignore-ellipsis, no-wrap, priority:280
msgid "'git diff' [<options>] <commit>\\...<commit> [--] [<path>...]"
msgstr "'git diff' [<选项>] <提交>\\...<提交> [--] [<路径>...]"

#. type: Plain text
#: en/git-diff.txt:101
#, ignore-ellipsis, placeholders:'git merge-base':'HEAD', priority:280
msgid "This form is to view the changes on the branch containing and up to the second <commit>, starting at a common ancestor of both <commit>. `git diff A...B` is equivalent to `git diff $(git merge-base A B) B`. You can omit any one of <commit>, which has the same effect as using HEAD instead."
msgstr "这种形式是为了查看包含和直到第二个<commit>的分支上的变化，从两个<commit>的共同祖先开始。 `git diff A...B`等同于`git diff $(git merge-base A B) B`。 你可以省略<commit>中的任何一个，这与使用HEAD的效果相同。"

#. type: Plain text
#: en/git-diff.txt:110
#, placeholders:'`--merge-base`':'AUTO_MERGE':'linkgit:git-merge[1]':'AUTO_MERGE', priority:280
msgid "Just in case you are doing something exotic, it should be noted that all of the <commit> in the above description, except in the `--merge-base` case and in the last two forms that use `..` notations, can be any <tree>. A tree of interest is the one pointed to by the ref named `AUTO_MERGE`, which is written by the 'ort' merge strategy upon hitting merge conflicts (see linkgit:git-merge[1]). Comparing the working tree with `AUTO_MERGE` shows changes you've made so far to resolve textual conflicts (see the examples below)."
msgstr "为了以防万一，需要注意的是，上述描述中的所有 <commit> 都可以是任何 <tree>，除了 `--merge-base` 和最后两种使用 `...` 符号的形式。我们感兴趣的树是由名为 `AUTO_MERGE` 的引用指向的树，它是在遇到合并冲突时由 'ort' 合并策略写入的（参见 linkgit:git-merge[1]）。 将工作树与 `AUTO_MERGE` 进行比较，就能看到迄今为止为解决文本冲突所做的改动（参见下面的示例）。"

#. type: Plain text
#: en/git-diff.txt:117
#, ignore-ellipsis, placeholders:'linkgit:gitrevisions[7]':'linkgit:gitrevisions[7]', priority:280
msgid "For a more complete list of ways to spell <commit>, see \"SPECIFYING REVISIONS\" section in linkgit:gitrevisions[7]. However, \"diff\" is about comparing two _endpoints_, not ranges, and the range notations (`<commit>..<commit>` and `<commit>...<commit>`) do not mean a range as defined in the \"SPECIFYING RANGES\" section in linkgit:gitrevisions[7]."
msgstr "关于<commit>的更完整的拼写方式，见linkgit:gitrevisions[7]中的 \"SPECIFYING REVISIONS \"部分。 然而，\"diff \"是关于比较两个_端点，而不是范围，而且范围符号（`<commit>...<commit>`和`<commit>...<commit>`）并不意味着linkgit:gitrevisions[7]中 \"SPECIFYING RANGES \"部分所定义的范围。"

#. type: Labeled list
#: en/git-diff.txt:118
#, no-wrap, priority:280
msgid "'git diff' [<options>] <blob> <blob>"
msgstr "'git diff' [<选项>] <blob> <blob>"

#. type: Plain text
#: en/git-diff.txt:122
#, priority:280
msgid "This form is to view the differences between the raw contents of two blob objects."
msgstr "这种形式是为了查看两个blob对象的原始内容之间的差异。"

#. type: Plain text
#: en/git-diff.txt:136
#, placeholders:'linkgit:git-read-tree[1]', priority:280
msgid "Compare the working tree with the \"base\" version (stage #1), \"our branch\" (stage #2) or \"their branch\" (stage #3). The index contains these stages only for unmerged entries i.e. while resolving conflicts. See linkgit:git-read-tree[1] section \"3-Way Merge\" for detailed information."
msgstr "将工作树与 \"基础 \"版本（阶段#1）、\"我们的分支\"（阶段#2）或 \"他们的分支\"（阶段#3）进行比较。 索引只对未合并的条目包含这些阶段，即在解决冲突时。 详细情况见 linkgit:git-read-tree[1] \"3-Way Merge\" 部分。"

#. type: Plain text
#: en/git-diff.txt:141
#, priority:280
msgid "Omit diff output for unmerged entries and just show \"Unmerged\". Can be used only when comparing the working tree with the index."
msgstr "省略未合并的条目的差异输出，只显示 \"Unmerged\"。 只能在比较工作树和索引的时候使用。"

#. type: Plain text
#: en/git-diff.txt:146
#, priority:280
msgid "The <paths> parameters, when given, are used to limit the diff to the named paths (you can give directory names and get diff for all files under them)."
msgstr "<paths>参数，当给出时，用于将diff限制在指定的路径上（你可以给出目录名称，并获得其下所有文件的diff）。"

#. type: Labeled list
#: en/git-diff.txt:153
#, no-wrap, priority:280
msgid "Various ways to check your working tree"
msgstr "检查你的工作树的各种方法"

#. type: delimited block -
#: en/git-diff.txt:160
#, no-wrap, placeholders:'--cached':'HEAD':'AUTO_MERGE', priority:280
msgid ""
"$ git diff            <1>\n"
"$ git diff --cached   <2>\n"
"$ git diff HEAD       <3>\n"
"$ git diff AUTO_MERGE <4>\n"
msgstr ""
"$ git diff            <1>\n"
"$ git diff --cached   <2>\n"
"$ git diff HEAD       <3>\n"
"$ git diff AUTO_MERGE <4>\n"

#. type: Plain text
#: en/git-diff.txt:163
#, priority:280
msgid "Changes in the working tree not yet staged for the next commit."
msgstr "工作树上的修改还没有为下一次提交做铺垫。"

#. type: Plain text
#: en/git-diff.txt:165
#, placeholders:'`-a`', priority:280
msgid "Changes between the index and your last commit; what you would be committing if you run `git commit` without `-a` option."
msgstr "索引和你最后一次提交之间的变化；如果你运行`git commit`而不使用`-a`选项，你将会提交的内容。"

#. type: Plain text
#: en/git-diff.txt:167
#, priority:280
msgid "Changes in the working tree since your last commit; what you would be committing if you run `git commit -a`"
msgstr "自你上次提交后工作目录树上的变化；如果你运行 `git commit -a`，你将提交的内容"

#. type: Plain text
#: en/git-diff.txt:169
#, priority:280
msgid "Changes in the working tree you've made to resolve textual conflicts so far."
msgstr "您为解决文本冲突而对工作目录树所做的修改。"

#. type: Labeled list
#: en/git-diff.txt:170
#, no-wrap, priority:280
msgid "Comparing with arbitrary commits"
msgstr "与任意提交的比较"

#. type: delimited block -
#: en/git-diff.txt:176
#, no-wrap, placeholders:'HEAD':'HEAD':'HEAD', priority:280
msgid ""
"$ git diff test            <1>\n"
"$ git diff HEAD -- ./test  <2>\n"
"$ git diff HEAD^ HEAD      <3>\n"
msgstr ""
"$ git diff test <1>\n"
"$ git diff HEAD -- ./test <2>\n"
"$ git diff HEAD^ HEAD <3>\n"

#. type: Plain text
#: en/git-diff.txt:180
#, priority:280
msgid "Instead of using the tip of the current branch, compare with the tip of \"test\" branch."
msgstr "不使用当前分支的顶端，而是与 \"测试 \"分支的顶端比较。"

#. type: Plain text
#: en/git-diff.txt:183
#, priority:280
msgid "Instead of comparing with the tip of \"test\" branch, compare with the tip of the current branch, but limit the comparison to the file \"test\"."
msgstr "与其说是与 \"test \"分支的顶端比较，不如说是与当前分支的顶端比较，但只限于与 \"test \"文件比较。"

#. type: Plain text
#: en/git-diff.txt:184
#, priority:280
msgid "Compare the version before the last commit and the last commit."
msgstr "比较上次提交前的版本和上次提交的版本。"

#. type: Labeled list
#: en/git-diff.txt:185
#, no-wrap, priority:280
msgid "Comparing branches"
msgstr "比较分支机构"

#. type: delimited block -
#: en/git-diff.txt:191
#, ignore-ellipsis, no-wrap, priority:280
msgid ""
"$ git diff topic master    <1>\n"
"$ git diff topic..master   <2>\n"
"$ git diff topic...master  <3>\n"
msgstr ""
"$ git diff topic master    <1>\n"
"$ git diff topic..master   <2>\n"
"$ git diff topic...master  <3>\n"

#. type: Plain text
#: en/git-diff.txt:194
#, priority:280
msgid "Changes between the tips of the topic and the master branches."
msgstr "专题的提示和主分支之间的变化。"

#. type: Plain text
#: en/git-diff.txt:195 en/git-remote-fd.txt:44 en/git-remote-fd.txt:52 en/git-web--browse.txt:52
#, priority:280
msgid "Same as above."
msgstr "同上。"

#. type: Plain text
#: en/git-diff.txt:197
#, priority:280
msgid "Changes that occurred on the master branch since when the topic branch was started off it."
msgstr "自专题分支开始以来，在主分支上发生的变化。"

#. type: Labeled list
#: en/git-diff.txt:198
#, no-wrap, priority:280
msgid "Limiting the diff output"
msgstr "限制差分输出"

#. type: delimited block -
#: en/git-diff.txt:204
#, no-wrap, placeholders:'--diff-filter=MRC':'--name-status', priority:280
msgid ""
"$ git diff --diff-filter=MRC            <1>\n"
"$ git diff --name-status                <2>\n"
"$ git diff arch/i386 include/asm-i386   <3>\n"
msgstr ""
"$ git diff --diff-filter=MRC            <1>\n"
"$ git diff --name-status                <2>\n"
"$ git diff arch/i386 include/asm-i386   <3>\n"

#. type: Plain text
#: en/git-diff.txt:208
#, priority:280
msgid "Show only modification, rename, and copy, but not addition or deletion."
msgstr "只显示修改、重命名和复制，但不显示增加或删除。"

#. type: Plain text
#: en/git-diff.txt:210
#, priority:280
msgid "Show only names and the nature of change, but not actual diff output."
msgstr "只显示名称和变化的性质，但不显示实际的差异输出。"

#. type: Plain text
#: en/git-diff.txt:211
#, priority:280
msgid "Limit diff output to named subtrees."
msgstr "将diff输出限制在命名的子树上。"

#. type: Labeled list
#: en/git-diff.txt:212
#, no-wrap, priority:280
msgid "Munging the diff output"
msgstr "轧制差速器输出"

#. type: delimited block -
#: en/git-diff.txt:217
#, no-wrap, placeholders:'--find-copies-harder', priority:280
msgid ""
"$ git diff --find-copies-harder -B -C  <1>\n"
"$ git diff -R                          <2>\n"
msgstr ""
"$ git diff --find-copies-harder -B -C  <1>\n"
"$ git diff -R                          <2>\n"

#. type: Plain text
#: en/git-diff.txt:221
#, priority:280
msgid "Spend extra cycles to find renames, copies and complete rewrites (very expensive)."
msgstr "花费额外的周期来寻找重命名、复制和完全重写（非常昂贵）。"

#. type: Plain text
#: en/git-diff.txt:222
#, priority:280
msgid "Output diff in reverse."
msgstr "反向输出差值。"

#. type: Plain text
#: en/git-diff.txt:239
#, placeholders:'linkgit:git-difftool[1]':'linkgit:git-log[1]':'linkgit:gitdiffcore[7]':'linkgit:git-format-patch[1]':'linkgit:git-apply[1]':'linkgit:git-show[1]', priority:280
msgid "diff(1), linkgit:git-difftool[1], linkgit:git-log[1], linkgit:gitdiffcore[7], linkgit:git-format-patch[1], linkgit:git-apply[1], linkgit:git-show[1]"
msgstr "diff(1), linkgit:git-difftool[1], linkgit:git-log[1], linkgit:gitdiffcore[7], linkgit:git-format-patch[1], linkgit:git-apply[1], linkgit:git-show[1]"

#. type: Title =
#: en/git-fast-export.txt:2
#, ignore-same, no-wrap, priority:90
msgid "git-fast-export(1)"
msgstr "git-fast-export(1)"

#. type: Plain text
#: en/git-fast-export.txt:7
#, placeholders:'git-fast-export', priority:90
msgid "git-fast-export - Git data exporter"
msgstr "git-fast-export - Git 数据导出器"

#. type: Plain text
#: en/git-fast-export.txt:13
#, no-wrap, placeholders:'git fast-export':'git fast-import', priority:90
msgid "'git fast-export' [<options>] | 'git fast-import'\n"
msgstr "'git fast-export' [<选项>] | 'git fast-import'\n"

#. type: Plain text
#: en/git-fast-export.txt:18
#, placeholders:'git fast-import', priority:90
msgid "This program dumps the given revisions in a form suitable to be piped into 'git fast-import'."
msgstr "该程序会将给定的修订转储为适合导入 'git fast-import' 的形式。"

#. type: Plain text
#: en/git-fast-export.txt:23
#, placeholders:'linkgit:git-bundle[1]':'git fast-import':'git filter-repo', priority:90
msgid "You can use it as a human-readable bundle replacement (see linkgit:git-bundle[1]), or as a format that can be edited before being fed to 'git fast-import' in order to do history rewrites (an ability relied on by tools like 'git filter-repo')."
msgstr "你可以把它用作人类可读的 bundle 替换（参见 linkgit:git-bundle[1]），也可以把它用作一种格式，在输入到 'git fast-import' 之前进行编辑，以便进行历史重写（'git filter-repo' 等工具依赖这种能力）。"

#. type: Labeled list
#: en/git-fast-export.txt:26
#, no-wrap, placeholders:'--progress=', priority:90
msgid "--progress=<n>"
msgstr "--progress=<n>"

#. type: Plain text
#: en/git-fast-export.txt:29
#, placeholders:'git fast-import', priority:90
msgid "Insert 'progress' statements every <n> objects, to be shown by 'git fast-import' during import."
msgstr "每隔 <n> 个对象插入 'progress' （进度）语句，在导入时由 'git fast-import' 显示。"

#. type: Labeled list
#: en/git-fast-export.txt:30
#, ignore-same, no-wrap, priority:90
msgid "--signed-tags=(verbatim|warn|warn-strip|strip|abort)"
msgstr "--signed-tags=(verbatim|warn|warn-strip|strip|abort)"

#. type: Plain text
#: en/git-fast-export.txt:34
#, priority:90
msgid "Specify how to handle signed tags. Since any transformation after the export can change the tag names (which can also happen when excluding revisions) the signatures will not match."
msgstr "指定如何处理已签名的标记。 由于导出后的任何转换都可能更改标记名（排除修订时也可能发生这种情况），因此签名将不匹配。"

#. type: Plain text
#: en/git-fast-export.txt:41
#, priority:90
msgid "When asking to 'abort' (which is the default), this program will die when encountering a signed tag. With 'strip', the tags will silently be made unsigned, with 'warn-strip' they will be made unsigned but a warning will be displayed, with 'verbatim', they will be silently exported and with 'warn', they will be exported, but you will see a warning."
msgstr "当要求 'abort'（禁止，默认值）时，该程序将在遇到已签名标记时死亡。 如果使用 'strip'（剥夺），标签将被静默地取消签名；如果使用 'warn-strip'，标签将被取消签名，但会显示警告；如果使用 'verbatim'（逐字报告），标签将被静默地导出；如果使用 'warn'，标签将被导出，但会显示警告。"

#. type: Labeled list
#: en/git-fast-export.txt:42
#, ignore-same, no-wrap, priority:90
msgid "--tag-of-filtered-object=(abort|drop|rewrite)"
msgstr "--tag-of-filtered-object=(abort|drop|rewrite)"

#. type: Plain text
#: en/git-fast-export.txt:46
#, priority:90
msgid "Specify how to handle tags whose tagged object is filtered out. Since revisions and files to export can be limited by path, tagged objects may be filtered completely."
msgstr "指定如何处理已过滤掉标记对象的标记。 由于要导出的版本和文件可能受路径限制，标记对象可能会被完全过滤掉。"

#. type: Plain text
#: en/git-fast-export.txt:52
#, placeholders:'linkgit:git-rev-list[1]', priority:90
msgid "When asking to 'abort' (which is the default), this program will die when encountering such a tag. With 'drop' it will omit such tags from the output. With 'rewrite', if the tagged object is a commit, it will rewrite the tag to tag an ancestor commit (via parent rewriting; see linkgit:git-rev-list[1])"
msgstr "如果要求 'abort'（终止，默认值），程序将在遇到此类标记时死亡。 如果使用 'drop'（丢弃），则会从输出中省略此类标记。 如果使用 'rewrite'（重写），如果标记对象是一个提交，程序将重写该标记以标记一个祖先提交（通过父级重写；参见 linkgit:git-rev-list[1])"

#. type: Plain text
#: en/git-fast-export.txt:58
#, placeholders:'linkgit:git-diff[1]', priority:90
msgid "Perform move and/or copy detection, as described in the linkgit:git-diff[1] manual page, and use it to generate rename and copy commands in the output dump."
msgstr "如 linkgit:git-diff[1] 手册页所述，执行移动和/或复制检测，并在输出转储中生成重命名和复制命令。"

#. type: Plain text
#: en/git-fast-export.txt:61
#, priority:90
msgid "Note that earlier versions of this command did not complain and produced incorrect results if you gave these options."
msgstr "请注意，如果您提供了这些选项，该命令的早期版本不会发出错误提示，并会产生不正确的结果。"

#. type: Labeled list
#: en/git-fast-export.txt:62 en/git-fast-import.txt:93
#, no-wrap, placeholders:'--export-marks=', priority:90
msgid "--export-marks=<file>"
msgstr "--export-marks=<文件>"

#. type: Plain text
#: en/git-fast-export.txt:73
#, placeholders:'--import-marks', priority:90
msgid "Dumps the internal marks table to <file> when complete. Marks are written one per line as `:markid SHA-1`. Only marks for revisions are dumped; marks for blobs are ignored. Backends can use this file to validate imports after they have been completed, or to save the marks table across incremental runs. As <file> is only opened and truncated at completion, the same path can also be safely given to --import-marks. The file will not be written if no new object has been marked/exported."
msgstr "完成后将内部标记表转存到 <文件> 中。 标记以 `:markid SHA-1` 的形式每行写一个。只转储修订版的标记；忽略 blob 的标记。 后端可以在导入完成后使用此文件验证导入，或在增量运行时保存标记表。 由于 <文件> 仅在导入完成时打开并截断，因此也可以安全地为 --import-marks 提供相同的路径。 如果没有标记/导出新对象，文件将不会被写入。"

#. type: Labeled list
#: en/git-fast-export.txt:74 en/git-fast-import.txt:102
#, no-wrap, placeholders:'--import-marks=', priority:90
msgid "--import-marks=<file>"
msgstr "--import-marks=<文件>"

#. type: Plain text
#: en/git-fast-export.txt:78
#, placeholders:'--export-marks', priority:90
msgid "Before processing any input, load the marks specified in <file>. The input file must exist, must be readable, and must use the same format as produced by --export-marks."
msgstr "在处理任何输入之前，加载 <文件> 中指定的标记。 输入文件必须存在，必须可读，必须使用与 --export-marks 生成的相同格式。"

#. type: Labeled list
#: en/git-fast-export.txt:79
#, ignore-same, no-wrap, priority:90
msgid "--mark-tags"
msgstr "--mark-tags"

#. type: Plain text
#: en/git-fast-export.txt:87
#, placeholders:'`--export-marks`':'`--import-marks`', priority:90
msgid "In addition to labelling blobs and commits with mark ids, also label tags. This is useful in conjunction with `--export-marks` and `--import-marks`, and is also useful (and necessary) for exporting of nested tags. It does not hurt other cases and would be the default, but many fast-import frontends are not prepared to accept tags with mark identifiers."
msgstr "除了用标记 id 标记 blob 和提交，还可以标记标签。 这与 `--export-marks`（导出标记） 和 `--import-marks`（导入标记）`配合使用，对于导出嵌套标记也很有用（而且很必要）。 这对其他情况没有影响，也是默认做法，但许多快速导入前端并不准备接受带有标记标识符的标签。"

#. type: Plain text
#: en/git-fast-export.txt:92
#, placeholders:'--import-marks', priority:90
msgid "Any commits (or tags) that have already been marked will not be exported again. If the backend uses a similar --import-marks file, this allows for incremental bidirectional exporting of the repository by keeping the marks the same across runs."
msgstr "任何已标记的提交（或标记）都不会再次导出。 如果后端使用类似的 --import-marks 文件，则可以通过在不同运行中保持相同的标记来实现仓库的增量双向导出。"

#. type: Labeled list
#: en/git-fast-export.txt:93
#, ignore-same, no-wrap, priority:90
msgid "--fake-missing-tagger"
msgstr "--fake-missing-tagger"

#. type: Plain text
#: en/git-fast-export.txt:98
#, priority:90
msgid "Some old repositories have tags without a tagger. The fast-import protocol was pretty strict about that, and did not allow that. So fake a tagger to be able to fast-import the output."
msgstr "有些旧仓库有标签，但没有标记。 快速导入协议对此非常严格，不允许这样做。 所以要伪造一个标签，以便能够快速导入输出。"

#. type: Labeled list
#: en/git-fast-export.txt:99
#, ignore-same, no-wrap, priority:90
msgid "--use-done-feature"
msgstr "--use-done-feature"

#. type: Plain text
#: en/git-fast-export.txt:102
#, priority:90
msgid "Start the stream with a 'feature done' stanza, and terminate it with a 'done' command."
msgstr "用 'feature done' 字符串启动数据流，用 'done' 命令终止数据流。"

#. type: Labeled list
#: en/git-fast-export.txt:103
#, ignore-same, no-wrap, priority:90
msgid "--no-data"
msgstr "--no-data"

#. type: Plain text
#: en/git-fast-export.txt:110
#, priority:90
msgid "Skip output of blob objects and instead refer to blobs via their original SHA-1 hash. This is useful when rewriting the directory structure or history of a repository without touching the contents of individual files. Note that the resulting stream can only be used by a repository which already contains the necessary objects."
msgstr "跳过 blob 对象的输出，而是通过其原始 SHA-1 哈希值引用 blob。 这在重写仓库的目录结构或历史记录时非常有用，而且不会触及单个文件的内容。 请注意，生成的数据流只能由已包含必要对象的仓库使用。"

#. type: Labeled list
#: en/git-fast-export.txt:111 en/git-ls-tree.txt:82
#, ignore-same, no-wrap, priority:90
msgid "--full-tree"
msgstr "--full-tree"

#. type: Plain text
#: en/git-fast-export.txt:116
#, priority:90
msgid "This option will cause fast-export to issue a \"deleteall\" directive for each commit followed by a full list of all files in the commit (as opposed to just listing the files which are different from the commit's first parent)."
msgstr "该选项将导致 fast-export 为每个提交发出一个 \"deleteall\" 指令，然后列出提交中所有文件的完整列表（而不是只列出与提交的第一个父文件不同的文件）。"

#. type: Labeled list
#: en/git-fast-export.txt:117
#, ignore-same, no-wrap, priority:90
msgid "--anonymize"
msgstr "--anonymize"

#. type: Plain text
#: en/git-fast-export.txt:121
#, priority:90
msgid "Anonymize the contents of the repository while still retaining the shape of the history and stored tree. See the section on `ANONYMIZING` below."
msgstr "对资源库的内容进行匿名化处理，同时仍保留历史记录和存储树的形状。 请参阅下文 `匿名化` 部分。"

#. type: Labeled list
#: en/git-fast-export.txt:122
#, no-wrap, placeholders:'--anonymize-map=', priority:90
msgid "--anonymize-map=<from>[:<to>]"
msgstr "--anonymize-map=<开始>[:<结束>]"

#. type: Plain text
#: en/git-fast-export.txt:126
#, priority:90
msgid "Convert token `<from>` to `<to>` in the anonymized output. If `<to>` is omitted, map `<from>` to itself (i.e., do not anonymize it). See the section on `ANONYMIZING` below."
msgstr "将匿名化输出中的令牌 `<from>` 转换为 `<to>`。如果省略了 `<to>`，则将 `<from>` 映射到其本身（即不对其进行匿名化）。请参阅下面的 `匿名化` 部分。"

#. type: Labeled list
#: en/git-fast-export.txt:127
#, ignore-same, no-wrap, priority:90
msgid "--reference-excluded-parents"
msgstr "--reference-excluded-parents"

#. type: Plain text
#: en/git-fast-export.txt:138
#, placeholders:'git fast-export':'{tilde}':'{tilde}':'{tilde}':'{tilde}':'{tilde}':'--reference-excluded-parents', priority:90
msgid "By default, running a command such as `git fast-export master~5..master` will not include the commit master{tilde}5 and will make master{tilde}4 no longer have master{tilde}5 as a parent (though both the old master{tilde}4 and new master{tilde}4 will have all the same files). Use --reference-excluded-parents to instead have the stream refer to commits in the excluded range of history by their sha1sum. Note that the resulting stream can only be used by a repository which already contains the necessary parent commits."
msgstr "默认情况下，运行诸如 `git fast-export master~5..master` 这样的命令不会包含 master{tilde}5 提交，并会使 master{tilde}4 不再将 master{tilde}5 作为父提交（尽管旧的 master{tilde}4 和新的 master{tilde}4 拥有相同的文件）。 使用 --reference-excluded-parents 可以让数据流通过 sha1sum 来引用历史中排除范围内的提交。 需要注意的是，生成的数据流只能由已包含必要父提交的仓库使用。"

#. type: Labeled list
#: en/git-fast-export.txt:139
#, ignore-same, no-wrap, priority:90
msgid "--show-original-ids"
msgstr "--show-original-ids"

#. type: Plain text
#: en/git-fast-export.txt:145
#, placeholders:'git-fast-import', priority:90
msgid "Add an extra directive to the output for commits and blobs, `original-oid <SHA1SUM>`. While such directives will likely be ignored by importers such as git-fast-import, it may be useful for intermediary filters (e.g. for rewriting commit messages which refer to older commits, or for stripping blobs by id)."
msgstr "为提交和 blob 的输出添加一个额外的指令：`original-oid <SHA1SUM>`。 虽然这类指令可能会被 git-fast-import 等导入程序忽略，但对于中间过滤器（例如重写引用较早提交的提交信息，或按 id 剔除 blobs）来说可能很有用。"

#. type: Labeled list
#: en/git-fast-export.txt:146
#, ignore-same, no-wrap, priority:90
msgid "--reencode=(yes|no|abort)"
msgstr "--reencode=(yes|no|abort)"

#. type: Plain text
#: en/git-fast-export.txt:152
#, priority:90
msgid "Specify how to handle `encoding` header in commit objects. When asking to 'abort' (which is the default), this program will die when encountering such a commit object. With 'yes', the commit message will be re-encoded into UTF-8. With 'no', the original encoding will be preserved."
msgstr "指定如何处理提交对象中的 `encoding` （编码）头。 如果要求 'abort'（中止，默认值），程序将在遇到此类提交对象时结束。 如果使用 'yes'，提交信息将被重新编码为 UTF-8。 如果选择 'no'，则将保留原始编码。"

#. type: Labeled list
#: en/git-fast-export.txt:153
#, ignore-same, no-wrap, priority:90
msgid "--refspec"
msgstr "--refspec"

#. type: Plain text
#: en/git-fast-export.txt:156
#, priority:90
msgid "Apply the specified refspec to each ref exported. Multiple of them can be specified."
msgstr "对导出的每个引用应用指定的引用规范。可以指定多个。"

#. type: Labeled list
#: en/git-fast-export.txt:157
#, ignore-ellipsis, no-wrap, priority:90
msgid "[<git-rev-list-args>...]"
msgstr "[<git-rev-list-args>...]"

#. type: Plain text
#: en/git-fast-export.txt:165
#, placeholders:'git rev-parse':'git rev-list':'--reference-excluded-parents':'{tilde}':'{tilde}', priority:90
msgid "A list of arguments, acceptable to 'git rev-parse' and 'git rev-list', that specifies the specific objects and references to export. For example, `master~10..master` causes the current master reference to be exported along with all objects added since its 10th ancestor commit and (unless the --reference-excluded-parents option is specified) all files common to master{tilde}9 and master{tilde}10."
msgstr "'git rev-parse' 和 'git rev-list' 可接受的参数列表，用于指定要导出的特定对象和引用。 例如，`master~10..master` 会导出当前的主引用，以及其第 10 次祖先提交后添加的所有对象，以及（除非指定了 --reference-excluded-parents 选项）master{tilde}9 和 master{tilde}10 的所有公共文件。"

#. type: delimited block -
#: en/git-fast-export.txt:171
#, no-wrap, placeholders:'git fast-export':'--all':'git fast-import', priority:90
msgid "$ git fast-export --all | (cd /empty/repository && git fast-import)\n"
msgstr "$ git fast-export --all | (cd /empty/repository && git fast-import)\n"

#. type: Plain text
#: en/git-fast-export.txt:176
#, priority:90
msgid "This will export the whole repository and import it into the existing empty repository. Except for reencoding commits that are not in UTF-8, it would be a one-to-one mirror."
msgstr "这将导出整个仓库，并导入现有的空仓库。 除了对非 UTF-8 版本的提交进行重新编码外，这将是一个一对一的镜像。"

#. type: delimited block -
#: en/git-fast-export.txt:181
#, no-wrap, placeholders:'git fast-export':'git fast-import', priority:90
msgid ""
"$ git fast-export master~5..master |\n"
"\tsed \"s|refs/heads/master|refs/heads/other|\" |\n"
"\tgit fast-import\n"
msgstr ""
"$ git fast-export master~5..master |\n"
"\tsed \"s|refs/heads/master|refs/heads/other|\" |\n"
"\tgit fast-import\n"

#. type: Plain text
#: en/git-fast-export.txt:185
#, priority:90
msgid "This makes a new branch called 'other' from 'master~5..master' (i.e. if 'master' has linear history, it will take the last 5 commits)."
msgstr "这样就从 'master~5..master' 中创建了一个名为 'other' 的新分支（也就是说，如果 'master' 的历史是线性的，那么它将采用最近的 5 次提交）。"

#. type: Plain text
#: en/git-fast-export.txt:189
#, priority:90
msgid "Note that this assumes that none of the blobs and commit messages referenced by that revision range contains the string 'refs/heads/master'."
msgstr "请注意，这是在假设该修订范围引用的 blob 和提交信息中没有包含 'refs/heads/master' 字符串。"

#. type: Title -
#: en/git-fast-export.txt:192
#, no-wrap, priority:90
msgid "ANONYMIZING"
msgstr "匿名化"

#. type: Plain text
#: en/git-fast-export.txt:200
#, placeholders:'`--anonymize`', priority:90
msgid "If the `--anonymize` option is given, git will attempt to remove all identifying information from the repository while still retaining enough of the original tree and history patterns to reproduce some bugs. The goal is that a git bug which is found on a private repository will persist in the anonymized repository, and the latter can be shared with git developers to help solve the bug."
msgstr "如果给定了 `--anonymize` 选项，git 会尝试移除仓库中的所有身份信息，但仍会保留足够的原始树和历史模式来重现某些 bug。这样做的目的是，在私有仓库中发现的 git bug 会在匿名仓库中继续存在，而后者可以与 git 开发人员共享，以帮助解决 bug。"

#. type: Plain text
#: en/git-fast-export.txt:212
#, priority:90
msgid "With this option, git will replace all refnames, paths, blob contents, commit and tag messages, names, and email addresses in the output with anonymized data. Two instances of the same string will be replaced equivalently (e.g., two commits with the same author will have the same anonymized author in the output, but bear no resemblance to the original author string). The relationship between commits, branches, and tags is retained, as well as the commit timestamps (but the commit messages and refnames bear no resemblance to the originals). The relative makeup of the tree is retained (e.g., if you have a root tree with 10 files and 3 trees, so will the output), but their names and the contents of the files will be replaced."
msgstr "使用该选项后，git 会用匿名数据替换输出中的所有引用名、路径、blob 内容、提交和标记信息、姓名和电子邮件地址。 同一字符串的两个实例将被等效替换（例如，两个提交的作者相同，输出中的匿名作者也相同，但与原始作者字符串并无相似之处）。提交、分支和标签之间的关系以及提交时间戳都会保留（但提交信息和引用名与原始信息没有任何相似之处）。保留树的相对构成（例如，如果根树有 10 个文件和 3 个树，输出也会保留），但文件名和文件内容会被替换。"

#. type: Plain text
#: en/git-fast-export.txt:215
#, priority:90
msgid "If you think you have found a git bug, you can start by exporting an anonymized stream of the whole repository:"
msgstr "如果您认为自己发现了一个 git bug，可以从导出整个仓库的匿名流开始："

#. type: delimited block -
#: en/git-fast-export.txt:218
#, no-wrap, placeholders:'git fast-export':'--anonymize':'--all', priority:90
msgid "$ git fast-export --anonymize --all >anon-stream\n"
msgstr "$ git fast-export --anonymize --all >anon-stream\n"

#. type: Plain text
#: en/git-fast-export.txt:223
#, priority:90
msgid "Then confirm that the bug persists in a repository created from that stream (many bugs will not, as they really do depend on the exact repository contents):"
msgstr "然后确认错误是否持续存在于根据该数据流创建的仓库中（许多错误不会持续存在，因为它们确实取决于仓库的确切内容）："

#. type: delimited block -
#: en/git-fast-export.txt:229
#, ignore-ellipsis, no-wrap, placeholders:'git fast-import', priority:90
msgid ""
"$ git init anon-repo\n"
"$ cd anon-repo\n"
"$ git fast-import <../anon-stream\n"
"$ ... test your bug ...\n"
msgstr ""
"$ git init anon-repo\n"
"$ cd anon-repo\n"
"$ git fast-import <../anon-stream\n"
"$ ... test your bug ...\n"

#. type: Plain text
#: en/git-fast-export.txt:236
#, priority:90
msgid "If the anonymized repository shows the bug, it may be worth sharing `anon-stream` along with a regular bug report. Note that the anonymized stream compresses very well, so gzipping it is encouraged. If you want to examine the stream to see that it does not contain any private data, you can peruse it directly before sending. You may also want to try:"
msgstr "如果匿名仓库显示了错误，则值得在提交常规错误报告的同时分享 `anon-stream`（匿名流）。请注意，匿名流的压缩效果非常好，因此建议将其压缩为 gzip 格式。如果您想检查流是否包含任何私人数据，可以在发送前直接阅读。您还可以尝试："

#. type: delimited block -
#: en/git-fast-export.txt:239
#, no-wrap, priority:90
msgid "$ perl -pe 's/\\d+/X/g' <anon-stream | sort -u | less\n"
msgstr "$ perl -pe 's/\\d+/X/g' <anon-stream | sort -u | less\n"

#. type: Plain text
#: en/git-fast-export.txt:245
#, priority:90
msgid "which shows all of the unique lines (with numbers converted to \"X\", to collapse \"User 0\", \"User 1\", etc into \"User X\"). This produces a much smaller output, and it is usually easy to quickly confirm that there is no private data in the stream."
msgstr "显示所有的唯一行（数字转换为 \"X\"，将 \"用户 0\"、\"用户 1\" 等折叠为 \"用户 X\"）。这样产生的输出要小得多，而且通常很容易快速确认数据流中没有私人数据。"

#. type: Plain text
#: en/git-fast-export.txt:251
#, placeholders:'git rev-list', priority:90
msgid "Reproducing some bugs may require referencing particular commits or paths, which becomes challenging after refnames and paths have been anonymized. You can ask for a particular token to be left as-is or mapped to a new value. For example, if you have a bug which reproduces with `git rev-list sensitive -- secret.c`, you can run:"
msgstr "重现某些错误可能需要引用特定的提交或路径，这在引用名和路径被匿名化后变得很有难度。您可以要求将特定标记保持原样或映射到一个新值。例如，如果有一个 bug 可以用 `git rev-list sensitive -- secret.c` 来重现，可以运行："

#. type: delimited block -
#: en/git-fast-export.txt:257
#, no-wrap, placeholders:'git fast-export':'--anonymize':'--all':'--anonymize-map=sensitive':'--anonymize-map=secret', priority:90
msgid ""
"$ git fast-export --anonymize --all \\\n"
"      --anonymize-map=sensitive:foo \\\n"
"      --anonymize-map=secret.c:bar.c \\\n"
"      >stream\n"
msgstr ""
"$ git fast-export --anonymize --all \\\n"
"      --anonymize-map=sensitive:foo \\\n"
"      --anonymize-map=secret.c:bar.c \\\n"
"      >stream\n"

#. type: Plain text
#: en/git-fast-export.txt:261
#, placeholders:'git rev-list', priority:90
msgid "After importing the stream, you can then run `git rev-list foo -- bar.c` in the anonymized repository."
msgstr "导入流之后，就可以在匿名仓库中运行 `git rev-list foo -- bar.c`。"

#. type: Plain text
#: en/git-fast-export.txt:266
#, priority:90
msgid "Note that paths and refnames are split into tokens at slash boundaries. The command above would anonymize `subdir/secret.c` as something like `path123/bar.c`; you could then search for `bar.c` in the anonymized repository to determine the final pathname."
msgstr "请注意，路径和引用名会在斜线边界被分割成标记。 上面的命令会将 `subdir/secret.c` 匿名化为类似 `path123/bar.c` 的内容；然后你可以在匿名化的仓库中搜索 `bar.c` 以确定最终路径名。"

#. type: Plain text
#: en/git-fast-export.txt:270
#, priority:90
msgid "To make referencing the final pathname simpler, you can map each path component; so if you also anonymize `subdir` to `publicdir`, then the final pathname would be `publicdir/bar.c`."
msgstr "为了简化最终路径名的引用，可以对每个路径组件进行映射；因此，如果同时将 `subdir` 匿名化为 `publicdir`，那么最终路径名将是 `publicdir/bar.c`。"

#. type: Plain text
#: en/git-fast-export.txt:277
#, placeholders:'git fast-import':'linux.git', priority:90
msgid "Since 'git fast-import' cannot tag trees, you will not be able to export the linux.git repository completely, as it contains a tag referencing a tree instead of a commit."
msgstr "由于 'git fast-import' 无法对树进行标记，因此您将无法完全导出 linux.git 仓库，因为其中包含了一个引用树而非提交的标记。"

#. type: Title =
#: en/git-fast-import.txt:2
#, ignore-same, no-wrap, priority:90
msgid "git-fast-import(1)"
msgstr "git-fast-import(1)"

#. type: Plain text
#: en/git-fast-import.txt:7
#, placeholders:'git-fast-import', priority:90
msgid "git-fast-import - Backend for fast Git data importers"
msgstr "git-fast-import - 快速 Git 数据导入的后端"

#. type: Plain text
#: en/git-fast-import.txt:13
#, no-wrap, placeholders:'git fast-import', priority:90
msgid "frontend | 'git fast-import' [<options>]\n"
msgstr "frontend | 'git fast-import' [<多个选项>]\n"

#. type: Plain text
#: en/git-fast-import.txt:20
#, placeholders:'git fast-import', priority:90
msgid "This program is usually not what the end user wants to run directly. Most end users want to use one of the existing frontend programs, which parses a specific type of foreign source and feeds the contents stored there to 'git fast-import'."
msgstr "最终用户通常并不想直接运行这个程序。 大多数最终用户都希望使用现有的前端程序，这些程序会解析特定类型的外来源，并将其中存储的内容输入到 'git fast-import' 中。"

#. type: Plain text
#: en/git-fast-import.txt:26
#, priority:90
msgid "fast-import reads a mixed command/data stream from standard input and writes one or more packfiles directly into the current repository. When EOF is received on standard input, fast import writes out updated branch and tag refs, fully updating the current repository with the newly imported data."
msgstr "fast-import 从标准输入端读取混合命令/数据流，并将一个或多个文件包直接写入当前仓库。 当标准输入收到 EOF 时，fast import 会写出更新的分支和标记引用，用新导入的数据完全更新当前仓库。"

#. type: Plain text
#: en/git-fast-import.txt:32
#, priority:90
msgid "The fast-import backend itself can import into an empty repository (one that has already been initialized by 'git init') or incrementally update an existing populated repository. Whether or not incremental imports are supported from a particular foreign source depends on the frontend program in use."
msgstr "快速导入后端本身可以导入一个空仓本库（一个已被 'git init' 初始化的仓库），也可以增量更新一个已填充的仓库。 是否支持从特定外来源增量导入，取决于所使用的前端程序。"

#. type: Plain text
#: en/git-fast-import.txt:41
#, priority:90
msgid "Force updating modified existing branches, even if doing so would cause commits to be lost (as the new commit does not contain the old commit)."
msgstr "强制更新已修改的现有分支，即使这样做会导致提交丢失（因为新提交不包含旧提交）。"

#. type: Plain text
#: en/git-fast-import.txt:47
#, placeholders:'--stats', priority:90
msgid "Disable the output shown by --stats, making fast-import usually be silent when it is successful. However, if the import stream has directives intended to show user output (e.g. `progress` directives), the corresponding messages will still be shown."
msgstr "禁用 --stats 显示的输出，使 fast-import 在成功导入时通常保持沉默。 不过，如果导入流中有用于显示用户输出的指令（如 `progress` 指令），则仍会显示相应的信息。"

#. type: Labeled list
#: en/git-fast-import.txt:48
#, ignore-same, no-wrap, priority:90
msgid "--stats"
msgstr "--stats"

#. type: Plain text
#: en/git-fast-import.txt:53
#, placeholders:'--quiet', priority:90
msgid "Display some basic statistics about the objects fast-import has created, the packfiles they were stored into, and the memory used by fast-import during this run. Showing this output is currently the default, but can be disabled with --quiet."
msgstr "显示 fast-import 创建的对象、这些对象存储在哪些文件包中，以及 fast-import 在运行过程中使用的内存等基本统计数据。 默认情况下显示此输出，但可使用 --quiet 关闭此功能。"

#. type: Labeled list
#: en/git-fast-import.txt:54
#, ignore-same, no-wrap, priority:90
msgid "--allow-unsafe-features"
msgstr "--allow-unsafe-features"

#. type: Plain text
#: en/git-fast-import.txt:63
#, priority:90
msgid "Many command-line options can be provided as part of the fast-import stream itself by using the `feature` or `option` commands. However, some of these options are unsafe (e.g., allowing fast-import to access the filesystem outside of the repository). These options are disabled by default, but can be allowed by providing this option on the command line. This currently impacts only the `export-marks`, `import-marks`, and `import-marks-if-exists` feature commands."
msgstr "通过使用 `feature` 或 `option` 命令，许多命令行选项可以作为 fast-import 流本身的一部分提供。然而，其中一些选项是不安全的（例如，允许 fast-import 访问仓库之外的文件系统）。这些选项默认是禁用的，但可以通过在命令行中提供该选项来允许。 目前这只影响 `export-marks`、`import-marks` 和 `import-marks-if-exists`。"

#. type: Plain text
#: en/git-fast-import.txt:68
#, priority:90
msgid "Only enable this option if you trust the program generating the fast-import stream! This option is enabled automatically for remote-helpers that use the `import` capability, as they are already trusted to run their own code."
msgstr "只有在信任生成快速导入流的程序时，才能启用此选项！对于使用 `import` 功能的远程帮助程序，该选项会自动启用，因为它们已经被信任可以运行自己的代码。"

#. type: Title ~
#: en/git-fast-import.txt:70
#, no-wrap, priority:90
msgid "Options for Frontends"
msgstr "前端的选项"

#. type: Labeled list
#: en/git-fast-import.txt:72
#, no-wrap, placeholders:'--cat-blob-fd=', priority:90
msgid "--cat-blob-fd=<fd>"
msgstr "--cat-blob-fd=<fd>"

#. type: Plain text
#: en/git-fast-import.txt:77
#, priority:90
msgid "Write responses to `get-mark`, `cat-blob`, and `ls` queries to the file descriptor <fd> instead of `stdout`. Allows `progress` output intended for the end-user to be separated from other output."
msgstr "将对 `get-mark`、`cat-blob` 和 `ls` 查询的响应写入文件描述符 <fd> 而不是 `stdout`。 允许将面向最终用户的 `progress` 输出与其他输出分开。"

#. type: Labeled list
#: en/git-fast-import.txt:78
#, no-wrap, placeholders:'--date-format=', priority:90
msgid "--date-format=<fmt>"
msgstr "--date-format=<格式>"

#. type: Plain text
#: en/git-fast-import.txt:83
#, priority:90
msgid "Specify the type of dates the frontend will supply to fast-import within `author`, `committer` and `tagger` commands. See ``Date Formats'' below for details about which formats are supported, and their syntax."
msgstr "指定前台在 `author`, `committer` 和 `tagger` 命令中提供给快速导入的日期类型。 有关支持的格式及其语法的详细信息，请参阅下面的 \"日期格式\"。"

#. type: Labeled list
#: en/git-fast-import.txt:84
#, ignore-same, no-wrap, priority:90
msgid "--done"
msgstr "--done"

#. type: Plain text
#: en/git-fast-import.txt:89
#, priority:90
msgid "Terminate with error if there is no `done` command at the end of the stream. This option might be useful for detecting errors that cause the frontend to terminate before it has started to write a stream."
msgstr "如果数据流末尾没有 `done` 命令，则错误终止。 该选项可能有助于检测导致前端在开始写入数据流之前就终止的错误。"

#. type: Title ~
#: en/git-fast-import.txt:91
#, no-wrap, priority:90
msgid "Locations of Marks Files"
msgstr "标记文件的位置"

#. type: Plain text
#: en/git-fast-import.txt:101
#, placeholders:'--import-marks', priority:90
msgid "Dumps the internal marks table to <file> when complete. Marks are written one per line as `:markid SHA-1`. Frontends can use this file to validate imports after they have been completed, or to save the marks table across incremental runs. As <file> is only opened and truncated at checkpoint (or completion) the same path can also be safely given to --import-marks."
msgstr "完成后将内部标记表转存到 <文件> 中。 标记以 `:markid SHA-1` 的形式每行写一个。 前端可在导入完成后使用此文件验证导入，或在增量运行时保存标记表。 由于 <文件> 只在检查点（或完成时）打开和截断，因此同样的路径也可以安全地提供给 --import-marks 文件。"

#. type: Plain text
#: en/git-fast-import.txt:109
#, placeholders:'--export-marks', priority:90
msgid "Before processing any input, load the marks specified in <file>. The input file must exist, must be readable, and must use the same format as produced by --export-marks. Multiple options may be supplied to import more than one set of marks. If a mark is defined to different values, the last file wins."
msgstr "在处理任何输入之前，加载 <文件> 中指定的标记。 输入文件必须存在，必须可读，必须使用与 --export-marks 生成的相同格式。 可以提供多个选项来导入多组标记。 如果一个标记被定义为不同的值，则以最后一个文件为准。"

#. type: Labeled list
#: en/git-fast-import.txt:110
#, no-wrap, placeholders:'--import-marks-if-exists=', priority:90
msgid "--import-marks-if-exists=<file>"
msgstr "--import-marks-if-exists=<文件>"

#. type: Plain text
#: en/git-fast-import.txt:113
#, placeholders:'--import-marks', priority:90
msgid "Like --import-marks but instead of erroring out, silently skips the file if it does not exist."
msgstr "与 --import-marks 类似，但不会出错，而是在文件不存在时自动跳过。"

#. type: Labeled list
#: en/git-fast-import.txt:114
#, ignore-same, no-wrap, priority:90
msgid "--[no-]relative-marks"
msgstr "--[no-]relative-marks"

#. type: Plain text
#: en/git-fast-import.txt:121
#, placeholders:'--relative-marks':'--import-marks=':'--export-marks=':'git-fast-import', priority:90
msgid "After specifying --relative-marks the paths specified with --import-marks= and --export-marks= are relative to an internal directory in the current repository. In git-fast-import this means that the paths are relative to the .git/info/fast-import directory. However, other importers may use a different location."
msgstr "指定 --relative-marks（相对标记）后，用 --import-marks= 和 --export-marks= 指定的路径将相对于当前仓库的内部目录。 在 git-fast-import 中，这意味着路径是相对于 .git/info/fast-import 目录的。不过，其他导入程序可能会使用不同的位置。"

#. type: Plain text
#: en/git-fast-import.txt:124
#, priority:90
msgid "Relative and non-relative marks may be combined by interweaving --(no-)-relative-marks with the --(import|export)-marks= options."
msgstr "相对标记和非相对标记可以通过--(no-)-relative-marks 与--(import|export)-marks= 选项交织使用。"

#. type: Title ~
#: en/git-fast-import.txt:126
#, no-wrap, priority:90
msgid "Submodule Rewriting"
msgstr "重写子模块"

#. type: Labeled list
#: en/git-fast-import.txt:128
#, no-wrap, placeholders:'--rewrite-submodules-from=', priority:90
msgid "--rewrite-submodules-from=<name>:<file>"
msgstr "--rewrite-submodules-from=<名称>:<文件>"

#. type: Labeled list
#: en/git-fast-import.txt:129
#, no-wrap, placeholders:'--rewrite-submodules-to=', priority:90
msgid "--rewrite-submodules-to=<name>:<file>"
msgstr "--rewrite-submodules-to=<名称>:<文件>"

#. type: Plain text
#: en/git-fast-import.txt:134
#, placeholders:'git fast-export':'git fast-import', priority:90
msgid "Rewrite the object IDs for the submodule specified by <name> from the values used in the from <file> to those used in the to <file>. The from marks should have been created by `git fast-export`, and the to marks should have been created by `git fast-import` when importing that same submodule."
msgstr "将 <名称> 指定的子模块的对象 ID 从 from <文件> 中使用的值重写为 to <文件> 中使用的值。from 标记应由 `git fast-export` 创建，而 to 标记应在导入同一子模块时由 `git fast-import` 创建。"

#. type: Plain text
#: en/git-fast-import.txt:139
#, priority:90
msgid "<name> may be any arbitrary string not containing a colon character, but the same value must be used with both options when specifying corresponding marks. Multiple submodules may be specified with different values for <name>. It is an error not to use these options in corresponding pairs."
msgstr "<名称> 可以是不含冒号的任意字符串，但在指定相应标记时，两个选项必须使用相同的值。 可以使用不同的 <名称> 值指定多个子模块。不在相应的选项对中使用这些选项是错误的。"

#. type: Plain text
#: en/git-fast-import.txt:144
#, priority:90
msgid "These options are primarily useful when converting a repository from one hash algorithm to another; without them, fast-import will fail if it encounters a submodule because it has no way of writing the object ID into the new hash algorithm."
msgstr "这些选项主要用于将仓库从一种哈希算法转换为另一种哈希算法；如果没有这些选项，fast-import 在遇到子模块时就会失败，因为它无法将对象 ID 写入新的哈希算法。"

#. type: Title ~
#: en/git-fast-import.txt:146
#, no-wrap, priority:90
msgid "Performance and Compression Tuning"
msgstr "性能和压缩调整"

#. type: Labeled list
#: en/git-fast-import.txt:148
#, no-wrap, placeholders:'--active-branches=', priority:90
msgid "--active-branches=<n>"
msgstr "--active-branches=<n>"

#. type: Plain text
#: en/git-fast-import.txt:151
#, priority:90
msgid "Maximum number of branches to maintain active at once. See ``Memory Utilization'' below for details. Default is 5."
msgstr "同时激活的最大分支数。 详情请参阅下文的 \"内存利用率\"。 默认为 5。"

#. type: Labeled list
#: en/git-fast-import.txt:152
#, no-wrap, placeholders:'--big-file-threshold=', priority:90
msgid "--big-file-threshold=<n>"
msgstr "--big-file-threshold=<n>"

#. type: Plain text
#: en/git-fast-import.txt:157
#, priority:90
msgid "Maximum size of a blob that fast-import will attempt to create a delta for, expressed in bytes. The default is 512m (512 MiB). Some importers may wish to lower this on systems with constrained memory."
msgstr "fast-import 将尝试创建 delta 的 blob 的最大大小，以字节为单位。 默认值为 512m（512MB）。 有些导入者可能希望在内存有限的系统上降低该值。"

#. type: Labeled list
#: en/git-fast-import.txt:158 en/git-fetch-pack.txt:85 en/git-pack-objects.txt:127 en/git-repack.txt:119
#, no-wrap, placeholders:'--depth=', priority:100
msgid "--depth=<n>"
msgstr "--depth=<n>"

#. type: Plain text
#: en/git-fast-import.txt:161
#, priority:90
msgid "Maximum delta depth, for blob and tree deltification. Default is 50."
msgstr "用于 blob 和树形脱模的最大脱模深度。 默认值为 50。"

#. type: Labeled list
#: en/git-fast-import.txt:162
#, no-wrap, placeholders:'--export-pack-edges=', priority:90
msgid "--export-pack-edges=<file>"
msgstr "--export-pack-edges=<文件>"

#. type: Plain text
#: en/git-fast-import.txt:170
#, placeholders:'git pack-objects', priority:90
msgid "After creating a packfile, print a line of data to <file> listing the filename of the packfile and the last commit on each branch that was written to that packfile. This information may be useful after importing projects whose total object set exceeds the 4 GiB packfile limit, as these commits can be used as edge points during calls to 'git pack-objects'."
msgstr "创建 packfile 后，向 <文件> 打印一行数据，列出 packfile 的文件名和写入该 packfile 的每个分支的最后一次提交。 在导入总对象集超过 4 GiB packfile 限制的项目后，这些信息可能会很有用，因为在调用 'git pack-objects' 时，这些提交可以用作边缘点。"

#. type: Labeled list
#: en/git-fast-import.txt:171 en/git-pack-objects.txt:152 en/git-repack.txt:147
#, no-wrap, placeholders:'--max-pack-size=', priority:100
msgid "--max-pack-size=<n>"
msgstr "--max-pack-size=<n>"

#. type: Plain text
#: en/git-fast-import.txt:174
#, priority:90
msgid "Maximum size of each output packfile. The default is unlimited."
msgstr "每个输出包文件的最大大小。 默认为无限大。"

#. type: Labeled list
#: en/git-fast-import.txt:175
#, ignore-same, no-wrap, priority:90
msgid "fastimport.unpackLimit"
msgstr "fastimport.unpackLimit"

#. type: Plain text
#: en/git-fast-import.txt:177
#, placeholders:'linkgit:git-config[1]', priority:90
msgid "See linkgit:git-config[1]"
msgstr "参见 linkgit:git-config[1]"

#. type: Title -
#: en/git-fast-import.txt:179 en/git-filter-branch.txt:463 en/git-p4.txt:548
#, no-wrap, priority:90
msgid "PERFORMANCE"
msgstr "性能"

#. type: Plain text
#: en/git-fast-import.txt:186
#, priority:90
msgid "The design of fast-import allows it to import large projects in a minimum amount of memory usage and processing time. Assuming the frontend is able to keep up with fast-import and feed it a constant stream of data, import times for projects holding 10+ years of history and containing 100,000+ individual commits are generally completed in just 1-2 hours on quite modest (~$2,000 USD) hardware."
msgstr "fast-import 的设计使其能够以最少的内存占用和处理时间导入大型项目。 假设前端能够跟上 fast-import 的速度，并向其提供源源不断的数据流，那么对于拥有 10 年以上历史、包含 100,000 多次单独提交的项目，通常只需 1-2 个小时就能完成导入，而且硬件配置也不高（约 2,000 美元）。"

#. type: Plain text
#: en/git-fast-import.txt:192
#, priority:90
msgid "Most bottlenecks appear to be in foreign source data access (the source just cannot extract revisions fast enough) or disk IO (fast-import writes as fast as the disk will take the data). Imports will run faster if the source data is stored on a different drive than the destination Git repository (due to less IO contention)."
msgstr "大多数瓶颈似乎都出现在国外源数据访问（源无法以足够快的速度提取修订）或磁盘 IO（快速导入写入的速度与磁盘接受数据的速度一样快）上。 如果源数据存储在与目标 Git 仓库不同的驱动器上，导入速度会更快（因为 IO 竞争更少）。"

#. type: Title -
#: en/git-fast-import.txt:195
#, no-wrap, priority:90
msgid "DEVELOPMENT COST"
msgstr "开发成本"

#. type: Plain text
#: en/git-fast-import.txt:202
#, priority:90
msgid "A typical frontend for fast-import tends to weigh in at approximately 200 lines of Perl/Python/Ruby code. Most developers have been able to create working importers in just a couple of hours, even though it is their first exposure to fast-import, and sometimes even to Git. This is an ideal situation, given that most conversion tools are throw-away (use once, and never look back)."
msgstr "一个典型的快速导入前端往往需要大约 200 行 Perl/Python/Ruby 代码。 大多数开发人员都能在几个小时内创建出可用的导入程序，尽管这是他们第一次接触快速导入，有时甚至是第一次接触 Git。 鉴于大多数转换工具都是一次性工具（用过一次就不再回头），这种情况是最理想的。"

#. type: Title -
#: en/git-fast-import.txt:205
#, no-wrap, priority:90
msgid "PARALLEL OPERATION"
msgstr "并行操作"

#. type: Plain text
#: en/git-fast-import.txt:210
#, priority:90
msgid "Like 'git push' or 'git fetch', imports handled by fast-import are safe to run alongside parallel `git repack -a -d` or `git gc` invocations, or any other Git operation (including 'git prune', as loose objects are never used by fast-import)."
msgstr "与 'git push' 或 'git fetch' 一样，由 fast-import 处理的导入可以安全地与并行的 `git repack -a -d` 或 `git gc`调用，或任何其他 Git 操作（包括 'git prune'，因为 fast-import 从不使用松散对象）同时运行。"

#. type: Plain text
#: en/git-fast-import.txt:219
#, priority:90
msgid "fast-import does not lock the branch or tag refs it is actively importing. After the import, during its ref update phase, fast-import tests each existing branch ref to verify the update will be a fast-forward update (the commit stored in the ref is contained in the new history of the commit to be written). If the update is not a fast-forward update, fast-import will skip updating that ref and instead prints a warning message. fast-import will always attempt to update all branch refs, and does not stop on the first failure."
msgstr "fast-import 不会锁定正在导入的分支或标签引用。 导入后，在引用更新阶段，fast-import 会测试每个现有分支引用，以验证更新是否为快进更新（存储在引用中的提交包含在要写入的提交的新历史中）。 如果更新不是快进更新，fast-import 会跳过更新该引用，并打印警告信息。fast-import 会一直尝试更新所有分支引用，不会因为第一次失败而停止。"

#. type: Plain text
#: en/git-fast-import.txt:223
#, placeholders:'--force':'--force', priority:90
msgid "Branch updates can be forced with --force, but it's recommended that this only be used on an otherwise quiet repository. Using --force is not necessary for an initial import into an empty repository."
msgstr "分支更新可以使用 --force 强制进行，但建议只在没有更新的仓库中使用。 初次导入空仓库时，无需使用 --force。"

#. type: Title -
#: en/git-fast-import.txt:226
#, no-wrap, priority:90
msgid "TECHNICAL DISCUSSION"
msgstr "技术探讨"

#. type: Plain text
#: en/git-fast-import.txt:233
#, priority:90
msgid "fast-import tracks a set of branches in memory. Any branch can be created or modified at any point during the import process by sending a `commit` command on the input stream. This design allows a frontend program to process an unlimited number of branches simultaneously, generating commits in the order they are available from the source data. It also simplifies the frontend programs considerably."
msgstr "fast-import 会在内存中跟踪一组分支。 在导入过程中，任何分支都可以通过向输入流发送 `commit` 命令来创建或修改。 这种设计允许前端程序同时处理数量不限的分支，并按照源数据的顺序生成提交。 这也大大简化了前端程序。"

#. type: Plain text
#: en/git-fast-import.txt:242
#, placeholders:'GIT_DIR', priority:90
msgid "fast-import does not use or alter the current working directory, or any file within it. (It does however update the current Git repository, as referenced by `GIT_DIR`.) Therefore an import frontend may use the working directory for its own purposes, such as extracting file revisions from the foreign source. This ignorance of the working directory also allows fast-import to run very quickly, as it does not need to perform any costly file update operations when switching between branches."
msgstr "fast-import 不会使用或更改当前工作目录或其中的任何文件。 (但它会更新当前的 Git 仓库，正如 `GIT_DIR` 所引用的那样）。 因此，导入前端可能会出于自己的目的使用工作目录，比如从外来源中提取文件修订版。 这种对工作目录的无视也使得 fast-import 可以非常快速地运行，因为在分支间切换时，它不需要执行任何代价高昂的文件更新操作。"

#. type: Title -
#: en/git-fast-import.txt:244 en/git-merge-tree.txt:225
#, no-wrap, priority:100
msgid "INPUT FORMAT"
msgstr "输入格式"

#. type: Plain text
#: en/git-fast-import.txt:250
#, priority:90
msgid "With the exception of raw file data (which Git does not interpret) the fast-import input format is text (ASCII) based. This text based format simplifies development and debugging of frontend programs, especially when a higher level language such as Perl, Python or Ruby is being used."
msgstr "除了原始文件数据（Git 不会对其进行解释），快速导入输入格式都是基于文本（ASCII）的。 这种基于文本的格式简化了前端程序的开发和调试，尤其是在使用 Perl、Python 或 Ruby 等高级语言的情况下。"

#. type: Plain text
#: en/git-fast-import.txt:258
#, priority:90
msgid "fast-import is very strict about its input. Where we say SP below we mean *exactly* one space. Likewise LF means one (and only one) linefeed and HT one (and only one) horizontal tab. Supplying additional whitespace characters will cause unexpected results, such as branch names or file names with leading or trailing spaces in their name, or early termination of fast-import when it encounters unexpected input."
msgstr "fast-import 对输入的要求非常严格。 我们在下文中所说的 SP 是指一个空格。 同样，LF 表示一个（且只有一个）换行符，HT 表示一个（且只有一个）水平制表符。 提供额外的空格字符会导致意想不到的结果，如分支名称或文件名称中包含前导空格或尾部空格，或当 fast-import 遇到意外输入时提前终止。"

#. type: Title ~
#: en/git-fast-import.txt:260
#, no-wrap, priority:90
msgid "Stream Comments"
msgstr "流评论"

#. type: Plain text
#: en/git-fast-import.txt:267
#, priority:90
msgid "To aid in debugging frontends fast-import ignores any line that begins with `#` (ASCII pound/hash) up to and including the line ending `LF`. A comment line may contain any sequence of bytes that does not contain an LF and therefore may be used to include any detailed debugging information that might be specific to the frontend and useful when inspecting a fast-import data stream."
msgstr "为了帮助调试前端，fast-import 会忽略任何以 `#`（ASCII 磅/散列）开头的行，包括以 `LF` 结尾的行。 注释行可以包含任何不包含 LF 的字节序列，因此可以用来包含任何详细的调试信息，这些信息可能是前端特有的，在检查 fast-import 数据流时也很有用。"

#. type: Title ~
#: en/git-fast-import.txt:269
#, no-wrap, priority:90
msgid "Date Formats"
msgstr "日期格式"

#. type: Plain text
#: en/git-fast-import.txt:273
#, placeholders:'--date-format=', priority:90
msgid "The following date formats are supported. A frontend should select the format it will use for this import by passing the format name in the --date-format=<fmt> command-line option."
msgstr "支持以下日期格式。 前台应通过在 --date-format=<日期格式> 命令行选项中传递格式名称来选择导入时使用的格式。"

#. type: Labeled list
#: en/git-fast-import.txt:274
#, ignore-same, no-wrap, priority:90
msgid "`raw`"
msgstr "`raw`"

#. type: Plain text
#: en/git-fast-import.txt:278
#, placeholders:'--date-format', priority:90
msgid "This is the Git native format and is `<time> SP <offutc>`. It is also fast-import's default format, if --date-format was not specified."
msgstr "这是 Git 的本地格式，为 `<time> SP <offutc>`。 如果没有指定 --date-format 格式，它也是 fast-import 的默认格式。"

#. type: Plain text
#: en/git-fast-import.txt:282
#, priority:90
msgid "The time of the event is specified by `<time>` as the number of seconds since the UNIX epoch (midnight, Jan 1, 1970, UTC) and is written as an ASCII decimal integer."
msgstr "事件发生的时间由 `<时间>` 指定，是自 UNIX 纪元（世界协调时 1970 年 1 月 1 日午夜）以来的秒数，并写成 ASCII 十进制整数。"

#. type: Plain text
#: en/git-fast-import.txt:288
#, priority:90
msgid "The local offset is specified by `<offutc>` as a positive or negative offset from UTC. For example EST (which is 5 hours behind UTC) would be expressed in `<tz>` by ``-0500'' while UTC is ``+0000''. The local offset does not affect `<time>`; it is used only as an advisement to help formatting routines display the timestamp."
msgstr "本地偏移量由 `<offutc>` 指定，与 UTC 的偏移量为正或负。 例如，东部标准时间（比协调世界时晚 5 小时）在 `<tz>` 中表示为 ''0500''，而协调世界时为 ''+0000''。 本地偏移并不影响 `<time>`；它只是作为一种提示，帮助格式化例程显示时间戳。"

#. type: Plain text
#: en/git-fast-import.txt:294
#, priority:90
msgid "If the local offset is not available in the source material, use ``+0000'', or the most common local offset. For example many organizations have a CVS repository which has only ever been accessed by users who are located in the same location and time zone. In this case a reasonable offset from UTC could be assumed."
msgstr "如果源材料中没有本地偏移量，则使用 ''+0000'' 或最常用的本地偏移量。 例如，许多组织都有一个 CVS 仓库，只有位于同一地点和时区的用户才能访问该仓库。 在这种情况下，可以假定与 UTC 有合理的偏移。"

#. type: Plain text
#: en/git-fast-import.txt:298
#, priority:90
msgid "Unlike the `rfc2822` format, this format is very strict. Any variation in formatting will cause fast-import to reject the value, and some sanity checks on the numeric values may also be performed."
msgstr "与 `rfc2822` 格式不同，该格式非常严格。 格式上的任何变化都会导致 fast-import 拒绝该值，同时也会对数值进行一些正确性检查。"

#. type: Labeled list
#: en/git-fast-import.txt:299
#, ignore-same, no-wrap, priority:90
msgid "`raw-permissive`"
msgstr "`raw-permissive`"

#. type: Plain text
#: en/git-fast-import.txt:304
#, priority:90
msgid "This is the same as `raw` except that no sanity checks on the numeric epoch and local offset are performed. This can be useful when trying to filter or import an existing history with e.g. bogus timezone values."
msgstr "这与 `raw` 相同，只是不对数字纪元和本地偏移进行正确性检查。 这在过滤或导入包含错误时区值等内容的现有历史记录时非常有用。"

#. type: Labeled list
#: en/git-fast-import.txt:305
#, no-wrap, priority:90
msgid "`rfc2822`"
msgstr "`rfc2822`"

#. type: Plain text
#: en/git-fast-import.txt:307
#, priority:90
msgid "This is the standard email format as described by RFC 2822."
msgstr "这是 RFC 2822 所描述的标准电子邮件格式。"

#. type: Plain text
#: en/git-fast-import.txt:312
#, priority:90
msgid "An example value is ``Tue Feb 6 11:22:18 2007 -0500''. The Git parser is accurate, but a little on the lenient side. It is the same parser used by 'git am' when applying patches received from email."
msgstr "示例值为 ''Tue Feb 6 11:22:18 2007 -0500''。 Git 解析器很准确，但有点偏宽松。 它与 'git am' 在应用从电子邮件收到的补丁时使用的解析器相同。"

#. type: Plain text
#: en/git-fast-import.txt:318
#, priority:90
msgid "Some malformed strings may be accepted as valid dates. In some of these cases Git will still be able to obtain the correct date from the malformed string. There are also some types of malformed strings which Git will parse wrong, and yet consider valid. Seriously malformed strings will be rejected."
msgstr "有些畸形字符串可能会被当作有效日期。 在某些情况下，Git 仍能从畸形字符串中获取正确的日期。 还有一些类型的畸形字符串，Git 会将其解析为错误，但认为是有效的。 严重的畸形字符串将被拒绝。"

#. type: Plain text
#: en/git-fast-import.txt:323
#, priority:90
msgid "Unlike the `raw` format above, the time zone/UTC offset information contained in an RFC 2822 date string is used to adjust the date value to UTC prior to storage. Therefore it is important that this information be as accurate as possible."
msgstr "与上述 `raw` 格式不同，RFC 2822 日期字符串中包含的时区/UTC 偏移信息用于在存储前将日期值调整为 UTC。 因此，该信息必须尽可能准确。"

#. type: Plain text
#: en/git-fast-import.txt:328
#, priority:90
msgid "If the source material uses RFC 2822 style dates, the frontend should let fast-import handle the parsing and conversion (rather than attempting to do it itself) as the Git parser has been well tested in the wild."
msgstr "如果源材料使用 RFC 2822 样式的日期，前台应让 fast-import 处理解析和转换（而不是自己尝试），因为 Git 解析器已在野外进行了良好的测试。"

#. type: Plain text
#: en/git-fast-import.txt:333
#, priority:90
msgid "Frontends should prefer the `raw` format if the source material already uses UNIX-epoch format, can be coaxed to give dates in that format, or its format is easily convertible to it, as there is no ambiguity in parsing."
msgstr "如果源材料已经使用了 UNIX-epoch 格式，或者可以哄骗源材料以该格式提供日期，或者源材料的格式很容易转换成该格式（因为在解析时不会产生歧义），那么前端程序应优先使用 `raw` 格式。"

#. type: Labeled list
#: en/git-fast-import.txt:334
#, ignore-same, no-wrap, priority:90
msgid "`now`"
msgstr "`now`"

#. type: Plain text
#: en/git-fast-import.txt:337
#, priority:90
msgid "Always use the current time and time zone. The literal `now` must always be supplied for `<when>`."
msgstr "始终使用当前时间和时区。 必须始终为 `<when>` 提供字面意义上的 `now`。"

#. type: Plain text
#: en/git-fast-import.txt:342
#, priority:90
msgid "This is a toy format. The current time and time zone of this system is always copied into the identity string at the time it is being created by fast-import. There is no way to specify a different time or time zone."
msgstr "这是一种玩具格式。 在通过快速导入创建身份字符串时，系统的当前时间和时区总是被复制到身份字符串中。 无法指定不同的时间或时区。"

#. type: Plain text
#: en/git-fast-import.txt:347
#, placeholders:'git update-index', priority:90
msgid "This particular format is supplied as it's short to implement and may be useful to a process that wants to create a new commit right now, without needing to use a working directory or 'git update-index'."
msgstr "提供这种格式的原因是，它的实现时间很短，而且可能对想要立即创建新提交的进程很有用，而不需要使用工作目录或 'git update-index'。"

#. type: Plain text
#: en/git-fast-import.txt:354
#, priority:90
msgid "If separate `author` and `committer` commands are used in a `commit` the timestamps may not match, as the system clock will be polled twice (once for each command). The only way to ensure that both author and committer identity information has the same timestamp is to omit `author` (thus copying from `committer`) or to use a date format other than `now`."
msgstr "如果在 `commit` 中分别使用了 `authoe` 和 `committer` 命令，时间戳可能会不一致，因为系统时钟会轮询两次（每条命令一次）。 确保作者和提交者身份信息具有相同时间戳的唯一方法是省略 `author` 命令（因此从 `committer` 命令复制），或使用除 `now` 以外的其他日期格式。"

#. type: Title ~
#: en/git-fast-import.txt:356
#, no-wrap, priority:90
msgid "Commands"
msgstr "命令"

#. type: Plain text
#: en/git-fast-import.txt:360
#, priority:90
msgid "fast-import accepts several commands to update the current repository and control the current import process. More detailed discussion (with examples) of each command follows later."
msgstr "fast-import 接受多条命令来更新当前仓库和控制当前导入过程。 稍后将对每条命令进行更详细的讨论（附示例）。"

#. type: Title ~
#: en/git-fast-import.txt:361 en/git-fast-import.txt:430
#, ignore-same, no-wrap, priority:90
msgid "`commit`"
msgstr "`commit`"

#. type: Plain text
#: en/git-fast-import.txt:365
#, priority:90
msgid "Creates a new branch or updates an existing branch by creating a new commit and updating the branch to point at the newly created commit."
msgstr "通过创建新提交并更新分支以指向新创建的提交，创建新分支或更新现有分支。"

#. type: Title ~
#: en/git-fast-import.txt:366 en/git-fast-import.txt:820
#, ignore-same, no-wrap, priority:90
msgid "`tag`"
msgstr "`tag`"

#. type: Plain text
#: en/git-fast-import.txt:371
#, priority:90
msgid "Creates an annotated tag object from an existing commit or branch. Lightweight tags are not supported by this command, as they are not recommended for recording meaningful points in time."
msgstr "从现有提交或分支创建注释标签对象。 此命令不支持轻量级标记，因为不建议用它们来记录有意义的时间点。"

#. type: Title ~
#: en/git-fast-import.txt:372 en/git-fast-import.txt:865
#, ignore-same, no-wrap, priority:90
msgid "`reset`"
msgstr "`reset`"

#. type: Plain text
#: en/git-fast-import.txt:376
#, priority:90
msgid "Reset an existing branch (or a new branch) to a specific revision. This command must be used to change a branch to a specific revision without making a commit on it."
msgstr "将现有分支（或新分支）重置为特定版本。 必须使用这条命令，才能在不提交的情况下，将分支更改为特定版本。"

#. type: Title ~
#: en/git-fast-import.txt:377 en/git-fast-import.txt:894
#, ignore-same, no-wrap, priority:90
msgid "`blob`"
msgstr "`blob`"

#. type: Plain text
#: en/git-fast-import.txt:381
#, priority:90
msgid "Convert raw file data into a blob, for future use in a `commit` command. This command is optional and is not needed to perform an import."
msgstr "将原始文件数据转换为 blob，以便将来在 `commit` 命令中使用。 该命令是可选的，执行导入时不需要。"

#. type: Title ~
#: en/git-fast-import.txt:382 en/git-fast-import.txt:967
#, ignore-same, no-wrap, priority:90
msgid "`alias`"
msgstr "`alias`"

#. type: Plain text
#: en/git-fast-import.txt:388
#, placeholders:'--import-marks', priority:90
msgid "Record that a mark refers to a given object without first creating any new object. Using --import-marks and referring to missing marks will cause fast-import to fail, so aliases can provide a way to set otherwise pruned commits to a valid value (e.g. the nearest non-pruned ancestor)."
msgstr "在不创建任何新对象的情况下，记录一个标记指向一个给定对象。 使用 --import-marks 并引用缺失的标记会导致 fast-import 失败，因此别名可以提供一种方法，将原本已剪枝的提交设置为有效值（例如最近的未剪枝祖先）。"

#. type: Title ~
#: en/git-fast-import.txt:389 en/git-fast-import.txt:982
#, ignore-same, no-wrap, priority:90
msgid "`checkpoint`"
msgstr "`checkpoint`"

#. type: Plain text
#: en/git-fast-import.txt:394
#, priority:90
msgid "Forces fast-import to close the current packfile, generate its unique SHA-1 checksum and index, and start a new packfile. This command is optional and is not needed to perform an import."
msgstr "强制 fast-import 关闭当前包文件，生成其唯一的 SHA-1 校验和和索引，并启动一个新的包文件。 此命令为可选命令，执行导入时无需使用。"

#. type: Title ~
#: en/git-fast-import.txt:395 en/git-fast-import.txt:1010
#, ignore-same, no-wrap, priority:90
msgid "`progress`"
msgstr "`progress`"

#. type: Plain text
#: en/git-fast-import.txt:399
#, priority:90
msgid "Causes fast-import to echo the entire line to its own standard output. This command is optional and is not needed to perform an import."
msgstr "使 fast-import 将整行内容回传至自己的标准输出。 该命令是可选的，执行导入时不需要它。"

#. type: Title ~
#: en/git-fast-import.txt:400 en/git-fast-import.txt:1217
#, ignore-same, no-wrap, priority:90
msgid "`done`"
msgstr "`done`"

#. type: Plain text
#: en/git-fast-import.txt:404
#, placeholders:'`--done`', priority:90
msgid "Marks the end of the stream. This command is optional unless the `done` feature was requested using the `--done` command-line option or `feature done` command."
msgstr "标记数据流的结束。除非使用 `--done` 命令行选项或 `feature done` 命令要求使用 `done` 功能，否则该命令是可选的。"

#. type: Title ~
#: en/git-fast-import.txt:405 en/git-fast-import.txt:1035
#, ignore-same, no-wrap, priority:90
msgid "`get-mark`"
msgstr "`get-mark`"

#. type: Plain text
#: en/git-fast-import.txt:409
#, placeholders:'`--cat-blob-fd`', priority:90
msgid "Causes fast-import to print the SHA-1 corresponding to a mark to the file descriptor set with `--cat-blob-fd`, or `stdout` if unspecified."
msgstr "使 fast-import 向使用 `--cat-blob-fd` 设置的文件描述符打印标记对应的 SHA-1 值，如果未指定，则打印 `stdout`。"

#. type: Title ~
#: en/git-fast-import.txt:410 en/git-fast-import.txt:1050
#, ignore-same, no-wrap, priority:90
msgid "`cat-blob`"
msgstr "`cat-blob`"

#. type: Plain text
#: en/git-fast-import.txt:414
#, placeholders:'--batch':'`--cat-blob-fd`', priority:90
msgid "Causes fast-import to print a blob in 'cat-file --batch' format to the file descriptor set with `--cat-blob-fd` or `stdout` if unspecified."
msgstr "使 fast-import 以 'cat-file --batch' 格式向使用 `--cat-blob-fd` 或 `stdout` 设置的文件描述符打印 blob。"

#. type: Title ~
#: en/git-fast-import.txt:415 en/git-fast-import.txt:1081
#, ignore-same, no-wrap, priority:90
msgid "`ls`"
msgstr "`ls`"

#. type: Plain text
#: en/git-fast-import.txt:419
#, placeholders:'`--cat-blob-fd`', priority:90
msgid "Causes fast-import to print a line describing a directory entry in 'ls-tree' format to the file descriptor set with `--cat-blob-fd` or `stdout` if unspecified."
msgstr "使 fast-import 以 'ls-tree' 格式向使用 `--cat-blob-fd` 或 `stdout` 设置的文件描述符打印描述目录条目的行。"

#. type: Title ~
#: en/git-fast-import.txt:420 en/git-fast-import.txt:1134
#, ignore-same, no-wrap, priority:90
msgid "`feature`"
msgstr "`feature`"

#. type: Plain text
#: en/git-fast-import.txt:423
#, priority:90
msgid "Enable the specified feature. This requires that fast-import supports the specified feature, and aborts if it does not."
msgstr "启用指定功能。这要求 fast-import 支持指定的功能，如果不支持则会终止。"

#. type: Title ~
#: en/git-fast-import.txt:424 en/git-fast-import.txt:1189
#, ignore-same, no-wrap, priority:90
msgid "`option`"
msgstr "`option`"

#. type: Plain text
#: en/git-fast-import.txt:428
#, priority:90
msgid "Specify any of the options listed under OPTIONS that do not change stream semantic to suit the frontend's needs. This command is optional and is not needed to perform an import."
msgstr "指定 \"选项\"（OPTIONS）中列出的任何选项，这些选项不会改变流语义以适应前台的需要。此命令为可选项，执行导入时不需要。"

#. type: Plain text
#: en/git-fast-import.txt:433
#, priority:90
msgid "Create or update a branch with a new commit, recording one logical change to the project."
msgstr "用新的提交创建或更新分支，记录项目的逻辑变更。"

#. type: delimited block .
#: en/git-fast-import.txt:446
#, no-wrap, priority:90
msgid ""
"\t'commit' SP <ref> LF\n"
"\tmark?\n"
"\toriginal-oid?\n"
"\t('author' (SP <name>)? SP LT <email> GT SP <when> LF)?\n"
"\t'committer' (SP <name>)? SP LT <email> GT SP <when> LF\n"
"\t('encoding' SP <encoding>)?\n"
"\tdata\n"
"\t('from' SP <commit-ish> LF)?\n"
"\t('merge' SP <commit-ish> LF)*\n"
"\t(filemodify | filedelete | filecopy | filerename | filedeleteall | notemodify)*\n"
"\tLF?\n"
msgstr ""
"\t'commit' SP <引用> LF\n"
"\tmark?\n"
"\toriginal-oid?\n"
"\t('author' (SP <名称>)? SP LT <email> GT SP <when> LF)?\n"
"\t'committer' (SP <名称>)? SP LT <email> GT SP <when> LF\n"
"\t('encoding' SP <编码>)?\n"
"\tdata\n"
"\t('from' SP <提交号> LF)?\n"
"\t('merge' SP <提交号> LF)*\n"
"\t(filemodify | filedelete | filecopy | filerename | filedeleteall | notemodify)*\n"
"\tLF?\n"

#. type: Plain text
#: en/git-fast-import.txt:454
#, placeholders:'1_0':'1_0', priority:90
msgid "where `<ref>` is the name of the branch to make the commit on. Typically branch names are prefixed with `refs/heads/` in Git, so importing the CVS branch symbol `RELENG-1_0` would use `refs/heads/RELENG-1_0` for the value of `<ref>`. The value of `<ref>` must be a valid refname in Git. As `LF` is not valid in a Git refname, no quoting or escaping syntax is supported here."
msgstr "其中 `<引用>` 是要提交的分支名称。 在 Git 中，分支名称通常以 `refs/heads/` 为前缀，因此导入 CVS 分支符号 `RELENG-1_0` 时，`<引用>` 的值应为 `refs/heads/RELENG-1_0`。 在 Git 中，`<引用>` 的值必须是有效的引用名称。 由于 `LF` 在 Git 引用名称中无效，因此此处不支持引号或转义语法。"

#. type: Plain text
#: en/git-fast-import.txt:460
#, priority:90
msgid "A `mark` command may optionally appear, requesting fast-import to save a reference to the newly created commit for future use by the frontend (see below for format). It is very common for frontends to mark every commit they create, thereby allowing future branch creation from any imported commit."
msgstr "`mark`（标记）命令可能会出现，要求 fast-import 保存新创建提交的引用，供前端将来使用（格式见下文）。 前端通常会标记他们创建的每个提交，从而允许将来从任何导入的提交中创建分支。"

#. type: Plain text
#: en/git-fast-import.txt:466
#, priority:90
msgid "The `data` command following `committer` must supply the commit message (see below for `data` command syntax). To import an empty commit message use a 0 length data. Commit messages are free-form and are not interpreted by Git. Currently they must be encoded in UTF-8, as fast-import does not permit other encodings to be specified."
msgstr "在 `committer` 之后的 `data` 命令必须提供提交信息（请参阅下面的 `data` 命令语法）。 要导入空的提交信息，请使用长度为 0 的数据。 提交信息是自由格式的，Git 无法解释。 目前它们必须以 UTF-8 编码，因为 fast-import 不允许指定其他编码。"

#. type: Plain text
#: en/git-fast-import.txt:474
#, priority:90
msgid "Zero or more `filemodify`, `filedelete`, `filecopy`, `filerename`, `filedeleteall` and `notemodify` commands may be included to update the contents of the branch prior to creating the commit. These commands may be supplied in any order. However it is recommended that a `filedeleteall` command precede all `filemodify`, `filecopy`, `filerename` and `notemodify` commands in the same commit, as `filedeleteall` wipes the branch clean (see below)."
msgstr "在创建提交之前，可以包含零个或多个 `filemodify`, `filedelete`, `filecopy`, `filerename`, `filedeleteall` 和 `notemodify` 命令来更新分支的内容。 这些命令可以任意顺序提供。 不过，我们建议在同一提交中的所有 `filemodify`, `filecopy`, `filerename` 和 `notemodify` 命令之前都加上 `filedeleteall` 命令，因为 `filedeleteall` 会将分支清除干净（见下文）。"

#. type: Plain text
#: en/git-fast-import.txt:481
#, priority:90
msgid "The `LF` after the command is optional (it used to be required). Note that for reasons of backward compatibility, if the commit ends with a `data` command (i.e. it has no `from`, `merge`, `filemodify`, `filedelete`, `filecopy`, `filerename`, `filedeleteall` or `notemodify` commands) then two `LF` commands may appear at the end of the command instead of just one."
msgstr "命令后的 `LF` 是可选的（以前是必须的）。 请注意，出于向后兼容性的考虑，如果提交以一条 `data` 命令结束（即没有 `from`、`mmerge`、`filemodify`、`filedelete`、`filecopy`、`filerename`、`filedeleteall` 或 `notemodify` 命令），那么命令末尾可能会出现两条 `LF` 命令，而不是只有一条。"

#. type: Title ^
#: en/git-fast-import.txt:483
#, ignore-same, no-wrap, priority:90
msgid "`author`"
msgstr "`author`"

#. type: Plain text
#: en/git-fast-import.txt:489
#, priority:90
msgid "An `author` command may optionally appear, if the author information might differ from the committer information. If `author` is omitted then fast-import will automatically use the committer's information for the author portion of the commit. See below for a description of the fields in `author`, as they are identical to `committer`."
msgstr "如果作者信息可能与提交者信息不同，可选择使用 `author` 命令。 如果省略了 `author` 命令，那么 fast-import 将自动使用提交者的信息来处理提交的作者部分。 有关 `author` 字段的描述，请参阅下文，因为它们与 `committer` 相同。"

#. type: Title ^
#: en/git-fast-import.txt:491
#, ignore-same, no-wrap, priority:90
msgid "`committer`"
msgstr "`committer`"

#. type: Plain text
#: en/git-fast-import.txt:494
#, priority:90
msgid "The `committer` command indicates who made this commit, and when they made it."
msgstr "`committer` 命令会显示谁提交了该提交，以及提交的时间。"

#. type: Plain text
#: en/git-fast-import.txt:502
#, priority:90
msgid "Here `<name>` is the person's display name (for example ``Com M Itter'') and `<email>` is the person's email address (``\\cm@example.com''). `LT` and `GT` are the literal less-than (\\x3c) and greater-than (\\x3e) symbols. These are required to delimit the email address from the other fields in the line. Note that `<name>` and `<email>` are free-form and may contain any sequence of bytes, except `LT`, `GT` and `LF`. `<name>` is typically UTF-8 encoded."
msgstr "这里的`<名称>`是个人的显示名（例如 ''Com M Itter''），`<email>`是个人的电子邮件地址（''\\cm@example.com''）。 `LT` 和 `GT` 是字面上的小于（\\x3c）和大于（\\x3e）符号。 需要使用这些符号将电子邮件地址与行中的其他字段分隔开来。 请注意，`<名称>` 和 `<email>`是自由格式，可以包含任何字节序列，但 `LT`、`GT` 和`LF` 除外。 `<名称>` 通常采用 UTF-8 编码。"

#. type: Plain text
#: en/git-fast-import.txt:507
#, placeholders:'--date-format=', priority:90
msgid "The time of the change is specified by `<when>` using the date format that was selected by the --date-format=<fmt> command-line option. See ``Date Formats'' above for the set of supported formats, and their syntax."
msgstr "更改的时间由 `<when>`指定，并使用 --date-format=<日期格式> 命令行选项选择的日期格式。 有关支持的格式及其语法，请参阅上文的 ''日期格式''。"

#. type: Title ^
#: en/git-fast-import.txt:509
#, ignore-same, no-wrap, priority:90
msgid "`encoding`"
msgstr "`encoding`"

#. type: Plain text
#: en/git-fast-import.txt:513
#, priority:90
msgid "The optional `encoding` command indicates the encoding of the commit message. Most commits are UTF-8 and the encoding is omitted, but this allows importing commit messages into git without first reencoding them."
msgstr "可选的 `encoding` 命令表示提交信息的编码。 大多数提交信息都是 UTF-8 编码，编码可以省略，但这样就可以将提交信息导入 git 而无需先重新编码。"

#. type: Title ^
#: en/git-fast-import.txt:515
#, ignore-same, no-wrap, priority:90
msgid "`from`"
msgstr "`from`"

#. type: Plain text
#: en/git-fast-import.txt:521
#, priority:90
msgid "The `from` command is used to specify the commit to initialize this branch from. This revision will be the first ancestor of the new commit. The state of the tree built at this commit will begin with the state at the `from` commit, and be altered by the content modifications in this commit."
msgstr "`from` 命令用于指定从哪个提交开始初始化分支。 此修订将成为新提交的第一个祖先。 在此提交中构建的树的状态将从 `from` 提交中的状态开始，并由此提交中的内容修改所改变。"

#. type: Plain text
#: en/git-fast-import.txt:531
#, priority:90
msgid "Omitting the `from` command in the first commit of a new branch will cause fast-import to create that commit with no ancestor. This tends to be desired only for the initial commit of a project. If the frontend creates all files from scratch when making a new branch, a `merge` command may be used instead of `from` to start the commit with an empty tree. Omitting the `from` command on existing branches is usually desired, as the current commit on that branch is automatically assumed to be the first ancestor of the new commit."
msgstr "在新分支的第一次提交中省略 `from` 命令会导致 fast-import 创建的提交没有祖先。这往往只适用于项目的首次提交。 如果前端在创建新分支时从头开始创建所有文件，则可以使用 `merge` 命令代替 `from` 命令，以空树开始提交。 在现有分支上，通常希望省略 `from` 命令，因为该分支上的当前提交会被自动假定为新提交的第一个祖先。"

#. type: Plain text
#: en/git-fast-import.txt:534
#, priority:90
msgid "As `LF` is not valid in a Git refname or SHA-1 expression, no quoting or escaping syntax is supported within `<commit-ish>`."
msgstr "由于 `LF` 在 Git 引用名称或 SHA-1 表达式中无效，因此 `<提交号>` 中不支持引号或转义语法。"

#. type: Plain text
#: en/git-fast-import.txt:536
#, priority:90
msgid "Here `<commit-ish>` is any of the following:"
msgstr "这里的 `<提交号>` 是指以下任何一种："

#. type: Plain text
#: en/git-fast-import.txt:540
#, priority:90
msgid "The name of an existing branch already in fast-import's internal branch table. If fast-import doesn't know the name, it's treated as a SHA-1 expression."
msgstr "fast-import 内部分支表中现有分支的名称。 如果 fast-import 不知道该名称，则将其视为 SHA-1 表达式。"

#. type: Plain text
#: en/git-fast-import.txt:542
#, priority:90
msgid "A mark reference, `:<idnum>`, where `<idnum>` is the mark number."
msgstr "标记引用，`<idnum>`，其中 `<idnum>`是标记编号。"

#. type: Plain text
#: en/git-fast-import.txt:548
#, priority:90
msgid "The reason fast-import uses `:` to denote a mark reference is this character is not legal in a Git branch name. The leading `:` makes it easy to distinguish between the mark 42 (`:42`) and the branch 42 (`42` or `refs/heads/42`), or an abbreviated SHA-1 which happened to consist only of base-10 digits."
msgstr "fast-import 使用 `:` 表示标记引用的原因是，这个字符在 Git 分支名称中是不合法的。 前导的 `:` 便于区分标记 42 (`:42`)和分支 42 (`42` 或 `refs/heads/42`)，或缩写的 SHA-1，而后者恰好只由基数为 10 的数字组成。"

#. type: Plain text
#: en/git-fast-import.txt:550
#, priority:90
msgid "Marks must be declared (via `mark`) before they can be used."
msgstr "标记必须先声明（通过 `mark` ）才能使用。"

#. type: Plain text
#: en/git-fast-import.txt:552
#, priority:90
msgid "A complete 40 byte or abbreviated commit SHA-1 in hex."
msgstr "以十六进制表示的完整的 40 字节或缩写的 SHA-1 提交。"

#. type: Plain text
#: en/git-fast-import.txt:555
#, placeholders:'linkgit:gitrevisions[7]', priority:90
msgid "Any valid Git SHA-1 expression that resolves to a commit. See ``SPECIFYING REVISIONS'' in linkgit:gitrevisions[7] for details."
msgstr "任何解析为提交的有效 Git SHA-1 表达式。 详见 linkgit:gitrevisions[7] 中的 ''指定修订格式''。"

#. type: Plain text
#: en/git-fast-import.txt:558
#, priority:90
msgid "The special null SHA-1 (40 zeros) specifies that the branch is to be removed."
msgstr "特殊的空 SHA-1（40 个零）表示要删除分支。"

#. type: Plain text
#: en/git-fast-import.txt:561
#, priority:90
msgid "The special case of restarting an incremental import from the current branch value should be written as:"
msgstr "从当前分支值重新开始增量导入的特殊情况应写为："

#. type: delimited block -
#: en/git-fast-import.txt:563
#, no-wrap, priority:90
msgid "\tfrom refs/heads/branch^0\n"
msgstr "\tfrom refs/heads/branch^0\n"

#. type: Plain text
#: en/git-fast-import.txt:570
#, priority:90
msgid "The `^0` suffix is necessary as fast-import does not permit a branch to start from itself, and the branch is created in memory before the `from` command is even read from the input. Adding `^0` will force fast-import to resolve the commit through Git's revision parsing library, rather than its internal branch table, thereby loading in the existing value of the branch."
msgstr "后缀 `^0` 是必要的，因为 fast-import 不允许分支从自身开始，分支会在从输入的 `from` 命令读取之前在内存中创建。 添加 `^0` 会强制 fast-import 通过 Git 的修订解析库而非内部分支表来解析提交，从而加载分支的现有值。"

#. type: Title ^
#: en/git-fast-import.txt:572
#, ignore-same, no-wrap, priority:90
msgid "`merge`"
msgstr "`merge`"

#. type: Plain text
#: en/git-fast-import.txt:580
#, priority:90
msgid "Includes one additional ancestor commit. The additional ancestry link does not change the way the tree state is built at this commit. If the `from` command is omitted when creating a new branch, the first `merge` commit will be the first ancestor of the current commit, and the branch will start out with no files. An unlimited number of `merge` commands per commit are permitted by fast-import, thereby establishing an n-way merge."
msgstr "包括一个额外的祖先提交。 额外的祖先链接不会改变本次提交的树状态构建方式。 如果在创建新分支时省略了 `from` 命令，则第一个 `merge` 提交将是当前提交的第一个祖先，分支开始时将没有文件。 fast-import 允许在每次提交中使用不限次数的 `merge` 命令，从而建立 n 路合并。"

#. type: Plain text
#: en/git-fast-import.txt:583
#, priority:90
msgid "Here `<commit-ish>` is any of the commit specification expressions also accepted by `from` (see above)."
msgstr "这里的 `<提交号>` 是`from` 也接受的任何提交规范表达式（见上文）。"

#. type: Title ^
#: en/git-fast-import.txt:585
#, ignore-same, no-wrap, priority:90
msgid "`filemodify`"
msgstr "`filemodify`"

#. type: Plain text
#: en/git-fast-import.txt:589
#, priority:90
msgid "Included in a `commit` command to add a new file or change the content of an existing file. This command has two different means of specifying the content of the file."
msgstr "包含在 `commit` 命令中，用于添加新文件或更改现有文件的内容。 该命令有两种指定文件内容的不同方式。"

#. type: Labeled list
#: en/git-fast-import.txt:590 en/git-fast-import.txt:757
#, no-wrap, priority:90
msgid "External data format"
msgstr "外部数据格式"

#. type: Plain text
#: en/git-fast-import.txt:593
#, priority:90
msgid "The data content for the file was already supplied by a prior `blob` command. The frontend just needs to connect it."
msgstr "文件的数据内容已由之前的 `blob` 命令提供。 前台只需将其连接起来即可。"

#. type: delimited block .
#: en/git-fast-import.txt:596
#, no-wrap, priority:90
msgid "\t'M' SP <mode> SP <dataref> SP <path> LF\n"
msgstr "\t'M' SP <模式> SP <引用日期> SP <路径> LF\n"

#. type: Plain text
#: en/git-fast-import.txt:603
#, placeholders:'`--import-marks`', priority:90
msgid "Here usually `<dataref>` must be either a mark reference (`:<idnum>`) set by a prior `blob` command, or a full 40-byte SHA-1 of an existing Git blob object. If `<mode>` is `040000`` then `<dataref>` must be the full 40-byte SHA-1 of an existing Git tree object or a mark reference set with `--import-marks`."
msgstr "通常情况下，`<数据引用>` 必须是由之前的 `blob` 命令设置的标记引用 (`:<idnum>`)，或者是现有 Git blob 对象的完整 40 字节 SHA-1 值。 如果 `<模式>` 是 `040000``，则 `<数据引用>` 必须是现有 Git 树对象的完整 40 字节 SHA-1 或用 `--import-marks` 设置的标记引用。"

#. type: Labeled list
#: en/git-fast-import.txt:604 en/git-fast-import.txt:770
#, no-wrap, priority:90
msgid "Inline data format"
msgstr "内联数据格式"

#. type: Plain text
#: en/git-fast-import.txt:608
#, priority:90
msgid "The data content for the file has not been supplied yet. The frontend wants to supply it as part of this modify command."
msgstr "文件的数据内容尚未提供。 前台希望将其作为该修改命令的一部分提供。"

#. type: delimited block .
#: en/git-fast-import.txt:612
#, no-wrap, priority:90
msgid ""
"\t'M' SP <mode> SP 'inline' SP <path> LF\n"
"\tdata\n"
msgstr ""
"\t'M' SP <模式> SP 'inline' SP <路径> LF\n"
"\tdata\n"

#. type: Plain text
#: en/git-fast-import.txt:615 en/git-fast-import.txt:781
#, priority:90
msgid "See below for a detailed description of the `data` command."
msgstr "有关 `data` 命令的详细说明，请参阅下文。"

#. type: Plain text
#: en/git-fast-import.txt:618
#, priority:90
msgid "In both formats `<mode>` is the type of file entry, specified in octal. Git only supports the following modes:"
msgstr "在这两种格式中，`<模式>` 都是以八进制指定的文件类型。 Git 仅支持以下模式："

#. type: Plain text
#: en/git-fast-import.txt:622
#, priority:90
msgid "`100644` or `644`: A normal (not-executable) file. The majority of files in most projects use this mode. If in doubt, this is what you want."
msgstr "`100644` 或 `644`： 普通（不可执行）文件。 大多数项目中的大部分文件都使用这种模式。 如果不知道用什么格式，请使用这种模式。"

#. type: Plain text
#: en/git-fast-import.txt:623
#, priority:90
msgid "`100755` or `755`: A normal, but executable, file."
msgstr "`100755` 或 `755`： 一个普通但可执行的文件。"

#. type: Plain text
#: en/git-fast-import.txt:624
#, priority:90
msgid "`120000`: A symlink, the content of the file will be the link target."
msgstr "`120000` ：符号链接，文件内容将成为链接目标。"

#. type: Plain text
#: en/git-fast-import.txt:627
#, priority:90
msgid "`160000`: A gitlink, SHA-1 of the object refers to a commit in another repository. Git links can only be specified either by SHA or through a commit mark. They are used to implement submodules."
msgstr "`160000` ： 一个 Git 链接，对象的 SHA-1 指向另一个仓库中的提交。Git 链接只能通过 SHA 或提交标记指定。它们用于实现子模块。"

#. type: Plain text
#: en/git-fast-import.txt:629
#, placeholders:'`--import-marks`', priority:90
msgid "`040000`: A subdirectory. Subdirectories can only be specified by SHA or through a tree mark set with `--import-marks`."
msgstr "`040000` ：子目录。 子目录只能通过 SHA 或使用 `--import-marks` 设置的树形标记来指定。"

#. type: Plain text
#: en/git-fast-import.txt:632
#, priority:90
msgid "In both formats `<path>` is the complete path of the file to be added (if not already existing) or modified (if already existing)."
msgstr "在这两种格式中，`<路径>` 都是要添加（如果尚未存在）或修改（如果已经存在）的文件的完整路径。"

#. type: Plain text
#: en/git-fast-import.txt:636
#, priority:90
msgid "A `<path>` string must use UNIX-style directory separators (forward slash `/`), may contain any byte other than `LF`, and must not start with double quote (`\"`)."
msgstr "`<路径>` 字符串必须使用 UNIX 风格的目录分隔符（正斜杠 `/`），可以包含除 `LF` 以外的任何字节，且不得以双引号 (`\"`) 开头。"

#. type: Plain text
#: en/git-fast-import.txt:643
#, priority:90
msgid "A path can use C-style string quoting; this is accepted in all cases and mandatory if the filename starts with double quote or contains `LF`. In C-style quoting, the complete name should be surrounded with double quotes, and any `LF`, backslash, or double quote characters must be escaped by preceding them with a backslash (e.g., `\"path/with\\n, \\\\ and \\\" in it\"`)."
msgstr "路径可以使用 C 风格字符串引号；在任何情况下都可以使用，如果文件名以双引号开头或包含 `LF`，则必须使用。在 C 风格引号中，完整的名称应该用双引号括起来，任何 `LF`、反斜杠或双引号字符都必须用反斜杠括起来（例如，`\"path/with\\n, \\\\ and \\\" in it\"`）。"

#. type: Plain text
#: en/git-fast-import.txt:645
#, priority:90
msgid "The value of `<path>` must be in canonical form. That is it must not:"
msgstr "`<路径>` 的值必须是规范格式。也就是说，绝不能是："

#. type: Plain text
#: en/git-fast-import.txt:647
#, priority:90
msgid "contain an empty directory component (e.g. `foo//bar` is invalid),"
msgstr "包含一个空目录组件（如 `foo//bar` 就是无效的），"

#. type: Plain text
#: en/git-fast-import.txt:648
#, priority:90
msgid "end with a directory separator (e.g. `foo/` is invalid),"
msgstr "以目录分隔符结尾（如 `foo/` 是无效的），"

#. type: Plain text
#: en/git-fast-import.txt:649
#, priority:90
msgid "start with a directory separator (e.g. `/foo` is invalid),"
msgstr "以目录分隔符开头（如 `/foo` 是无效的），"

#. type: Plain text
#: en/git-fast-import.txt:651
#, priority:90
msgid "contain the special component `.` or `..` (e.g. `foo/./bar` and `foo/../bar` are invalid)."
msgstr "包含特殊成分 `.` 或 `..`（例如，`foo/./bar` 和 `foo/../bar` 是无效的）。"

#. type: Plain text
#: en/git-fast-import.txt:653
#, priority:90
msgid "The root of the tree can be represented by an empty string as `<path>`."
msgstr "树根可以用空字符 `<路径>` 表示。"

#. type: Plain text
#: en/git-fast-import.txt:655
#, priority:90
msgid "It is recommended that `<path>` always be encoded using UTF-8."
msgstr "建议始终使用 UTF-8 对 `<路径>` 进行编码。"

#. type: Title ^
#: en/git-fast-import.txt:657
#, ignore-same, no-wrap, priority:90
msgid "`filedelete`"
msgstr "`filedelete`"

#. type: Plain text
#: en/git-fast-import.txt:663
#, priority:90
msgid "Included in a `commit` command to remove a file or recursively delete an entire directory from the branch. If the file or directory removal makes its parent directory empty, the parent directory will be automatically removed too. This cascades up the tree until the first non-empty directory or the root is reached."
msgstr "包含在 `commit` 命令中，用于从分支中删除文件或递归删除整个目录。 如果文件或目录删除后其父级目录为空，父级目录也会自动删除。 这将沿着树向上逐级进行，直到到达第一个非空目录或根目录为止。"

#. type: delimited block .
#: en/git-fast-import.txt:666
#, no-wrap, priority:90
msgid "\t'D' SP <path> LF\n"
msgstr "\t'D' SP <路径> LF\n"

#. type: Plain text
#: en/git-fast-import.txt:671
#, priority:90
msgid "here `<path>` is the complete path of the file or subdirectory to be removed from the branch. See `filemodify` above for a detailed description of `<path>`."
msgstr "这里的 `<路劲>` 是要从分支中删除的文件或子目录的完整路径。 有关 `<路径>` 的详细说明，请参阅上文的 `filemodify` 。"

#. type: Title ^
#: en/git-fast-import.txt:673
#, ignore-same, no-wrap, priority:90
msgid "`filecopy`"
msgstr "`filecopy`"

#. type: Plain text
#: en/git-fast-import.txt:678
#, priority:90
msgid "Recursively copies an existing file or subdirectory to a different location within the branch. The existing file or directory must exist. If the destination exists it will be completely replaced by the content copied from the source."
msgstr "递归复制现有文件或子目录到分支内的不同位置。 现有文件或目录必须存在。 如果目标位置存在，它将被从源位置复制的内容完全取代。"

#. type: delimited block .
#: en/git-fast-import.txt:681
#, no-wrap, priority:90
msgid "\t'C' SP <path> SP <path> LF\n"
msgstr "\t'C' SP <路径> SP <路径> LF\n"

#. type: Plain text
#: en/git-fast-import.txt:687 en/git-fast-import.txt:707
#, priority:90
msgid "here the first `<path>` is the source location and the second `<path>` is the destination. See `filemodify` above for a detailed description of what `<path>` may look like. To use a source path that contains SP the path must be quoted."
msgstr "这里第一个 `<路径>` 是源位置，第二个 `<路径>` 是目标位置。 关于 `<路径>` 的详细说明，请参阅上文的 `filemodify` 。 要使用包含 SP 的源路径，路径必须加引号。"

#. type: Plain text
#: en/git-fast-import.txt:692
#, priority:90
msgid "A `filecopy` command takes effect immediately. Once the source location has been copied to the destination any future commands applied to the source location will not impact the destination of the copy."
msgstr "`filecopy`（文件复制）命令会立即生效。 一旦源位置被复制到目标位置，今后应用于源位置的任何命令都不会影响复制的目标位置。"

#. type: Title ^
#: en/git-fast-import.txt:694
#, ignore-same, no-wrap, priority:90
msgid "`filerename`"
msgstr "`filerename`"

#. type: Plain text
#: en/git-fast-import.txt:698
#, priority:90
msgid "Renames an existing file or subdirectory to a different location within the branch. The existing file or directory must exist. If the destination exists it will be replaced by the source directory."
msgstr "将现有文件或子目录重命名到分支内的不同位置。 现有文件或目录必须存在。如果目标目录存在，它将被源目录取代。"

#. type: delimited block .
#: en/git-fast-import.txt:701
#, no-wrap, priority:90
msgid "\t'R' SP <path> SP <path> LF\n"
msgstr "\t'R' SP <路径> SP <路径> LF\n"

#. type: Plain text
#: en/git-fast-import.txt:712
#, priority:90
msgid "A `filerename` command takes effect immediately. Once the source location has been renamed to the destination any future commands applied to the source location will create new files there and not impact the destination of the rename."
msgstr "`filename`（文件重命名）命令会立即生效。 一旦源位置被重命名为目标位置，今后应用于源位置的任何命令都将在该位置创建新文件，而不会影响重命名的目标位置。"

#. type: Plain text
#: en/git-fast-import.txt:721
#, priority:90
msgid "Note that a `filerename` is the same as a `filecopy` followed by a `filedelete` of the source location. There is a slight performance advantage to using `filerename`, but the advantage is so small that it is never worth trying to convert a delete/add pair in source material into a rename for fast-import. This `filerename` command is provided just to simplify frontends that already have rename information and don't want bother with decomposing it into a `filecopy` followed by a `filedelete`."
msgstr "请注意，`filerename` 等同于源位置的 `filecopy` 和 `filedelete`。 使用 `filerename` 在性能上略有优势，但优势非常小，不值得为了快速导入而尝试将源材料中的删除/添加对转换为重命名。 提供这个 `fileerename` 命令只是为了简化已经有重命名信息的前端程序，而不需要将其分解为 `filecopy` 和 `filedelete` 命令。"

#. type: Title ^
#: en/git-fast-import.txt:723
#, ignore-same, no-wrap, priority:90
msgid "`filedeleteall`"
msgstr "`filedeleteall`"

#. type: Plain text
#: en/git-fast-import.txt:728
#, priority:90
msgid "Included in a `commit` command to remove all files (and also all directories) from the branch. This command resets the internal branch structure to have no files in it, allowing the frontend to subsequently add all interesting files from scratch."
msgstr "包含在 `commit` 命令中，用于删除分支中的所有文件（以及所有目录）。 该命令会重置内部分支结构，使其不包含任何文件，从而允许前台随后从头开始添加所有感兴趣的文件。"

#. type: delimited block .
#: en/git-fast-import.txt:731
#, no-wrap, priority:90
msgid "\t'deleteall' LF\n"
msgstr "\t'deleteall' LF\n"

#. type: Plain text
#: en/git-fast-import.txt:737
#, priority:90
msgid "This command is extremely useful if the frontend does not know (or does not care to know) what files are currently on the branch, and therefore cannot generate the proper `filedelete` commands to update the content."
msgstr "如果前台不知道（或不关心知道）当前分支上有哪些文件，因而无法生成适当的 `filedelete` 命令来更新内容，那么这条命令就非常有用。"

#. type: Plain text
#: en/git-fast-import.txt:745
#, priority:90
msgid "Issuing a `filedeleteall` followed by the needed `filemodify` commands to set the correct content will produce the same results as sending only the needed `filemodify` and `filedelete` commands. The `filedeleteall` approach may however require fast-import to use slightly more memory per active branch (less than 1 MiB for even most large projects); so frontends that can easily obtain only the affected paths for a commit are encouraged to do so."
msgstr "在发出 `filedeleteall` 命令后，再发出所需的 `filemodify` 命令来设置正确的内容，与只发出所需的 `filemodify` 和 `filedelete` 命令产生的结果是一样的。 不过，`filedeleteall` 方法可能会要求 fast-import 在每个活动分支上使用稍多的内存（对于大多数大型项目而言，内存都小于 1MB）；因此，我们鼓励能够轻松获取提交中仅受影响路径的前端这样做。"

#. type: Title ^
#: en/git-fast-import.txt:747
#, ignore-same, no-wrap, priority:90
msgid "`notemodify`"
msgstr "`notemodify`"

#. type: Plain text
#: en/git-fast-import.txt:756
#, priority:90
msgid "Included in a `commit` `<notes-ref>` command to add a new note annotating a `<commit-ish>` or change this annotation contents. Internally it is similar to filemodify 100644 on `<commit-ish>` path (maybe split into subdirectories). It's not advised to use any other commands to write to the `<notes-ref>` tree except `filedeleteall` to delete all existing notes in this tree. This command has two different means of specifying the content of the note."
msgstr "包含在`commit` `<引用笔记>`命令中，用于为 `<提交号>` 添加新注释或更改注释内容。 在内部，它类似于在 `<提交号>` 路径（可能分成子目录）上的文件修改 100644。除了使用 `filedeleteall` 命令删除`<notes_ref>` 树中的所有现有注释外，不建议使用任何其他命令向 `<引用笔记>` 树中写入注释。 该命令有两种指定笔记内容的不同方法。"

#. type: Plain text
#: en/git-fast-import.txt:761
#, priority:90
msgid "The data content for the note was already supplied by a prior `blob` command. The frontend just needs to connect it to the commit that is to be annotated."
msgstr "注释的数据内容已由先前的 `blob` 命令提供。 前台只需将其连接到要注释的提交。"

#. type: delimited block .
#: en/git-fast-import.txt:764
#, no-wrap, priority:90
msgid "\t'N' SP <dataref> SP <commit-ish> LF\n"
msgstr "\t'N' SP <引用日期> SP <提交号> LF\n"

#. type: Plain text
#: en/git-fast-import.txt:769
#, priority:90
msgid "Here `<dataref>` can be either a mark reference (`:<idnum>`) set by a prior `blob` command, or a full 40-byte SHA-1 of an existing Git blob object."
msgstr "这里的 `<数据引用>` 既可以是之前的 `blob` 命令设置的标记引用（`:<idnum>`），也可以是现有 Git blob 对象的完整 40 字节 SHA-1 值。"

#. type: Plain text
#: en/git-fast-import.txt:774
#, priority:90
msgid "The data content for the note has not been supplied yet. The frontend wants to supply it as part of this modify command."
msgstr "备注的数据内容尚未提供。 前台希望将其作为该修改命令的一部分提供。"

#. type: delimited block .
#: en/git-fast-import.txt:778
#, no-wrap, priority:90
msgid ""
"\t'N' SP 'inline' SP <commit-ish> LF\n"
"\tdata\n"
msgstr ""
"\t'N' SP 'inline' SP <提交号> LF\n"
"\tdata\n"

#. type: Plain text
#: en/git-fast-import.txt:784
#, priority:90
msgid "In both formats `<commit-ish>` is any of the commit specification expressions also accepted by `from` (see above)."
msgstr "在这两种格式中，`<提交号>` 是 `from` 也接受的任何提交规范表达式（见上文）。"

#. type: Title ~
#: en/git-fast-import.txt:786
#, ignore-same, no-wrap, priority:90
msgid "`mark`"
msgstr "`mark`"

#. type: Plain text
#: en/git-fast-import.txt:792
#, priority:90
msgid "Arranges for fast-import to save a reference to the current object, allowing the frontend to recall this object at a future point in time, without knowing its SHA-1. Here the current object is the object creation command the `mark` command appears within. This can be `commit`, `tag`, and `blob`, but `commit` is the most common usage."
msgstr "安排快速导入保存当前对象的引用，以便前端在未来某个时间点调用该对象，而无需知道其 SHA-1。 在这里，当前对象指的是 `mark` 命令中出现的对象创建命令。 这可以是 `commit`、`tag` 和 `blob`，但 `commit` 是最常见的用法。"

#. type: delimited block .
#: en/git-fast-import.txt:795
#, no-wrap, priority:90
msgid "\t'mark' SP ':' <idnum> LF\n"
msgstr "\t'mark' SP ':' <idnum> LF\n"

#. type: Plain text
#: en/git-fast-import.txt:801
#, priority:90
msgid "where `<idnum>` is the number assigned by the frontend to this mark. The value of `<idnum>` is expressed as an ASCII decimal integer. The value 0 is reserved and cannot be used as a mark. Only values greater than or equal to 1 may be used as marks."
msgstr "其中，`<idnum>` 是前台分配给此标记的编号。 `<idnum>` 的值用 ASCII 十进制整数表示。 0 是保留值，不能用作标记。 只有大于或等于 1 的值才能用作标记。"

#. type: Plain text
#: en/git-fast-import.txt:805
#, priority:90
msgid "New marks are created automatically. Existing marks can be moved to another object simply by reusing the same `<idnum>` in another `mark` command."
msgstr "新标记会自动创建。 只需在另一个 `mark` 命令中重复使用相同的 `<idnum>`，即可将现有标记移动到另一个对象上。"

#. type: Title ~
#: en/git-fast-import.txt:807
#, ignore-same, no-wrap, priority:90
msgid "`original-oid`"
msgstr "`original-oid`"

#. type: Plain text
#: en/git-fast-import.txt:812
#, priority:90
msgid "Provides the name of the object in the original source control system. fast-import will simply ignore this directive, but filter processes which operate on and modify the stream before feeding to fast-import may have uses for this information"
msgstr "提供原始源码控制系统中对象的名称。fast-import 将直接忽略此指令，但在向 fast-import 输入数据流之前对其进行操作和修改的过滤进程可能会使用此信息"

#. type: delimited block .
#: en/git-fast-import.txt:815
#, no-wrap, priority:90
msgid "\t'original-oid' SP <object-identifier> LF\n"
msgstr "\t'original-oid' SP <对象标识符> LF\n"

#. type: Plain text
#: en/git-fast-import.txt:818
#, priority:90
msgid "where `<object-identifier>` is any string not containing LF."
msgstr "其中，`<对象标识符>` 是任何不包含 LF 的字符串。"

#. type: Plain text
#: en/git-fast-import.txt:823
#, priority:90
msgid "Creates an annotated tag referring to a specific commit. To create lightweight (non-annotated) tags see the `reset` command below."
msgstr "创建指向特定提交的注释标记。 要创建轻量级（无注释）标签，请参阅下面的 `reset` 命令。"

#. type: delimited block .
#: en/git-fast-import.txt:831
#, no-wrap, priority:90
msgid ""
"\t'tag' SP <name> LF\n"
"\tmark?\n"
"\t'from' SP <commit-ish> LF\n"
"\toriginal-oid?\n"
"\t'tagger' (SP <name>)? SP LT <email> GT SP <when> LF\n"
"\tdata\n"
msgstr ""
"\t'tag' SP <名称> LF\n"
"\tmark?\n"
"\t'from' SP <提交号> LF\n"
"\toriginal-oid?\n"
"\t'tagger' (SP <名称>)? SP LT <email> GT SP <when> LF\n"
"\tdata\n"

#. type: Plain text
#: en/git-fast-import.txt:834
#, priority:90
msgid "where `<name>` is the name of the tag to create."
msgstr "其中 `<名称>` 是要创建的标记的名称。"

#. type: Plain text
#: en/git-fast-import.txt:839
#, placeholders:'1_0':'1_0':'1_0', priority:90
msgid "Tag names are automatically prefixed with `refs/tags/` when stored in Git, so importing the CVS branch symbol `RELENG-1_0-FINAL` would use just `RELENG-1_0-FINAL` for `<name>`, and fast-import will write the corresponding ref as `refs/tags/RELENG-1_0-FINAL`."
msgstr "因此，导入 CVS 分支符号 `RELENG-1_0-FINAL` 时，只需在 `<名称>` 中使用 `RELENG-1_0-FINAL`，而 fast-import 会将相应的引用写成 `refs/tags/RELENG-1_0-FINAL`。"

#. type: Plain text
#: en/git-fast-import.txt:843
#, priority:90
msgid "The value of `<name>` must be a valid refname in Git and therefore may contain forward slashes. As `LF` is not valid in a Git refname, no quoting or escaping syntax is supported here."
msgstr "在 Git 中，`<名称>` 的值必须是有效的引用名称，因此可能包含正斜杠。 由于 `LF` 在 Git 引用名称中无效，因此此处不支持引号或转义语法。"

#. type: Plain text
#: en/git-fast-import.txt:846
#, priority:90
msgid "The `from` command is the same as in the `commit` command; see above for details."
msgstr "`from` 命令与 `commit` 命令相同，详见上文。"

#. type: Plain text
#: en/git-fast-import.txt:849
#, priority:90
msgid "The `tagger` command uses the same format as `committer` within `commit`; again see above for details."
msgstr "`tagger` 命令使用的格式与 `commit` 中的 `committer` 相同；详情参见上文。"

#. type: Plain text
#: en/git-fast-import.txt:855
#, priority:90
msgid "The `data` command following `tagger` must supply the annotated tag message (see below for `data` command syntax). To import an empty tag message use a 0 length data. Tag messages are free-form and are not interpreted by Git. Currently they must be encoded in UTF-8, as fast-import does not permit other encodings to be specified."
msgstr "在 `tagger` 之后的 `data` 命令必须提供已注释的标记信息（请参阅下面的 `data` 命令语法）。 要导入空标签信息，请使用长度为 0 的数据。 标签信息是自由格式的，不会被 Git 解释。 目前，它们必须以 UTF-8 编码，因为 fast-import 不允许指定其他编码。"

#. type: Plain text
#: en/git-fast-import.txt:863
#, priority:90
msgid "Signing annotated tags during import from within fast-import is not supported. Trying to include your own PGP/GPG signature is not recommended, as the frontend does not (easily) have access to the complete set of bytes which normally goes into such a signature. If signing is required, create lightweight tags from within fast-import with `reset`, then create the annotated versions of those tags offline with the standard 'git tag' process."
msgstr "不支持在 fast-import 中导入时对已注释的标记进行签名。 不建议尝试加入自己的 PGP/GPG 签名，因为前端无法（轻易）获取通常用于签名的完整字节集。 如果需要签名，请使用 `reset` 在 fast-import 中创建轻量级标签，然后使用标准的 'git tag' 流程离线创建这些标签的注释版本。"

#. type: Plain text
#: en/git-fast-import.txt:870
#, priority:90
msgid "Creates (or recreates) the named branch, optionally starting from a specific revision. The reset command allows a frontend to issue a new `from` command for an existing branch, or to create a new branch from an existing commit without creating a new commit."
msgstr "创建（或重新创建）指定的分支，可选择从特定版本开始。 重置命令允许前台为现有分支发布新的 `from` 命令，或从现有提交创建新分支，而无需创建新提交。"

#. type: delimited block .
#: en/git-fast-import.txt:875
#, no-wrap, priority:90
msgid ""
"\t'reset' SP <ref> LF\n"
"\t('from' SP <commit-ish> LF)?\n"
"\tLF?\n"
msgstr ""
"\t'reset' SP <引用> LF\n"
"\t('from' SP <提交号> LF)?\n"
"\tLF?\n"

#. type: Plain text
#: en/git-fast-import.txt:879
#, priority:90
msgid "For a detailed description of `<ref>` and `<commit-ish>` see above under `commit` and `from`."
msgstr "有关 `<引用>` 和 `<提交号>` 的详细说明，请参阅上文 `commit` 和 `from` 部分。"

#. type: Plain text
#: en/git-fast-import.txt:881 en/git-fast-import.txt:1008
#, priority:90
msgid "The `LF` after the command is optional (it used to be required)."
msgstr "命令后的 `LF` 是可选项（以前是必选项）。"

#. type: Plain text
#: en/git-fast-import.txt:884
#, priority:90
msgid "The `reset` command can also be used to create lightweight (non-annotated) tags. For example:"
msgstr "`reset` （重置）命令还可用于创建轻量级（无注释）标记。 例如："

#. type: delimited block =
#: en/git-fast-import.txt:888
#, no-wrap, priority:90
msgid ""
"\treset refs/tags/938\n"
"\tfrom :938\n"
msgstr ""
"\treset refs/tags/938\n"
"\tfrom :938\n"

#. type: Plain text
#: en/git-fast-import.txt:892
#, priority:90
msgid "would create the lightweight tag `refs/tags/938` referring to whatever commit mark `:938` references."
msgstr "将创建轻量级标记 `refs/tags/938`，并引用提交标记 `:938`。"

#. type: Plain text
#: en/git-fast-import.txt:899
#, priority:90
msgid "Requests writing one file revision to the packfile. The revision is not connected to any commit; this connection must be formed in a subsequent `commit` command by referencing the blob through an assigned mark."
msgstr "请求向包文件写入一个文件修订。 修订版与任何提交都没有关联；这种关联必须在随后的 `commit` 命令中通过指定标记引用 blob 来形成。"

#. type: delimited block .
#: en/git-fast-import.txt:905
#, no-wrap, priority:90
msgid ""
"\t'blob' LF\n"
"\tmark?\n"
"\toriginal-oid?\n"
"\tdata\n"
msgstr ""
"\t'blob' LF\n"
"\tmark?\n"
"\toriginal-oid?\n"
"\tdata\n"

#. type: Plain text
#: en/git-fast-import.txt:911
#, priority:90
msgid "The mark command is optional here as some frontends have chosen to generate the Git SHA-1 for the blob on their own, and feed that directly to `commit`. This is typically more work than it's worth however, as marks are inexpensive to store and easy to use."
msgstr "这里的标记命令是可选的，因为有些前端选择自己为 blob 生成 Git SHA-1，并直接将其输入到 `commit` 中。 这通常是得不偿失的，因为标记的存储成本很低，而且易于使用。"

#. type: Title ~
#: en/git-fast-import.txt:913
#, ignore-same, no-wrap, priority:90
msgid "`data`"
msgstr "`data`"

#. type: Plain text
#: en/git-fast-import.txt:920
#, priority:90
msgid "Supplies raw data (for use as blob/file content, commit messages, or annotated tag messages) to fast-import. Data can be supplied using an exact byte count or delimited with a terminating line. Real frontends intended for production-quality conversions should always use the exact byte count format, as it is more robust and performs better. The delimited format is intended primarily for testing fast-import."
msgstr "向 fast-import 提供原始数据（用作 blob/文件内容、提交信息或注释标签信息）。 提供的数据可以使用精确的字节数，也可以用终止行分隔。 用于生产质量转换的真正前端应始终使用精确字节数格式，因为这种格式更稳健、性能更好。 分隔格式主要用于测试快速导入。"

#. type: Plain text
#: en/git-fast-import.txt:925
#, priority:90
msgid "Comment lines appearing within the `<raw>` part of `data` commands are always taken to be part of the body of the data and are therefore never ignored by fast-import. This makes it safe to import any file/message content whose lines might start with `#`."
msgstr "在 `data` 命令的 `<raw>` 部分中出现的注释行总是被视为数据正文的一部分，因此 fast-import 不会忽略这些注释行。 这样就可以安全导入任何可能以 `#` 开头的文件/信息内容。"

#. type: Labeled list
#: en/git-fast-import.txt:926
#, no-wrap, priority:90
msgid "Exact byte count format"
msgstr "精确字节计数格式"

#. type: Plain text
#: en/git-fast-import.txt:928
#, priority:90
msgid "The frontend must specify the number of bytes of data."
msgstr "前台必须指定数据的字节数。"

#. type: delimited block .
#: en/git-fast-import.txt:932
#, no-wrap, priority:90
msgid ""
"\t'data' SP <count> LF\n"
"\t<raw> LF?\n"
msgstr ""
"\t'data' SP <count> LF\n"
"\t<raw> LF?\n"

#. type: Plain text
#: en/git-fast-import.txt:938
#, priority:90
msgid "where `<count>` is the exact number of bytes appearing within `<raw>`. The value of `<count>` is expressed as an ASCII decimal integer. The `LF` on either side of `<raw>` is not included in `<count>` and will not be included in the imported data."
msgstr "其中，`<count>` 是出现在 `<raw>` 中的确切字节数。 `<count>` 的值用 ASCII 十进制整数表示。 `<raw>` 两侧的 `LF` 不包含在 `<count>` 中，也不会包含在导入的数据中。"

#. type: Plain text
#: en/git-fast-import.txt:943
#, priority:90
msgid "The `LF` after `<raw>` is optional (it used to be required) but recommended. Always including it makes debugging a fast-import stream easier as the next command always starts in column 0 of the next line, even if `<raw>` did not end with an `LF`."
msgstr "在 `<raw>` 后面的 `LF` 是可选的（以前是必须的），但建议使用。 始终包含它可以使调试快速导入流变得更容易，因为下一条命令总是从下一行的第 0 列开始，即使 `<raw>` 没有以 `LF` 结束。"

#. type: Labeled list
#: en/git-fast-import.txt:944
#, no-wrap, priority:90
msgid "Delimited format"
msgstr "分隔格式"

#. type: Plain text
#: en/git-fast-import.txt:949
#, priority:90
msgid "A delimiter string is used to mark the end of the data. fast-import will compute the length by searching for the delimiter. This format is primarily useful for testing and is not recommended for real data."
msgstr "fast-import 将通过搜索分隔符来计算长度。 这种格式主要用于测试，不建议用于真实数据。"

#. type: delimited block .
#: en/git-fast-import.txt:955
#, no-wrap, priority:90
msgid ""
"\t'data' SP '<<' <delim> LF\n"
"\t<raw> LF\n"
"\t<delim> LF\n"
"\tLF?\n"
msgstr ""
"\t'data' SP '<<' <分隔符> LF\n"
"\t<原始格式> LF\n"
"\t<分隔符> LF\n"
"\tLF?\n"

#. type: Plain text
#: en/git-fast-import.txt:963
#, priority:90
msgid "where `<delim>` is the chosen delimiter string. The string `<delim>` must not appear on a line by itself within `<raw>`, as otherwise fast-import will think the data ends earlier than it really does. The `LF` immediately trailing `<raw>` is part of `<raw>`. This is one of the limitations of the delimited format, it is impossible to supply a data chunk which does not have an LF as its last byte."
msgstr "其中 `<delim>` 是选定的分隔符字符串。 字符串 `<delim>` 不能单独出现在 `<raw>` 中的一行，否则 fast-import 会认为数据结束的时间比实际时间早。 紧跟在 `<raw>` 后面的 `LF` 是 `<raw>` 的一部分。 这是分隔格式的限制之一，不可能提供最后一个字节没有 LF 的数据块。"

#. type: Plain text
#: en/git-fast-import.txt:965
#, priority:90
msgid "The `LF` after `<delim> LF` is optional (it used to be required)."
msgstr "在 `<delim> LF` 后面的 `LF` 是可选的（以前是必须的）。"

#. type: Plain text
#: en/git-fast-import.txt:970
#, priority:90
msgid "Record that a mark refers to a given object without first creating any new object."
msgstr "记录标记指向某个对象，而无需先创建任何新对象。"

#. type: delimited block .
#: en/git-fast-import.txt:976
#, no-wrap, priority:90
msgid ""
"\t'alias' LF\n"
"\tmark\n"
"\t'to' SP <commit-ish> LF\n"
"\tLF?\n"
msgstr ""
"\t'alias' LF\n"
"\tmark\n"
"\t'to' SP <提交号> LF\n"
"\tLF?\n"

#. type: Plain text
#: en/git-fast-import.txt:979
#, priority:90
msgid "For a detailed description of `<commit-ish>` see above under `from`."
msgstr "有关 `<提交号>` 的详细说明，请参阅上文 `from` 部分。"

#. type: Plain text
#: en/git-fast-import.txt:985
#, priority:90
msgid "Forces fast-import to close the current packfile, start a new one, and to save out all current branch refs, tags and marks."
msgstr "强制 fast-import 关闭当前的打包文件，启动一个新文件，并保存所有当前的分支参考、标记和标记。"

#. type: delimited block .
#: en/git-fast-import.txt:989
#, no-wrap, priority:90
msgid ""
"\t'checkpoint' LF\n"
"\tLF?\n"
msgstr ""
"\t'checkpoint' LF\n"
"\tLF?\n"

#. type: Plain text
#: en/git-fast-import.txt:995
#, placeholders:'--max-pack-size', priority:90
msgid "Note that fast-import automatically switches packfiles when the current packfile reaches --max-pack-size, or 4 GiB, whichever limit is smaller. During an automatic packfile switch fast-import does not update the branch refs, tags or marks."
msgstr "请注意，当当前包文件达到 --max-pack-size 或 4 GiB（以较小者为准）时，fast-import 会自动切换包文件。 在自动切换打包文件期间，fast-import 不会更新分支引用、标记或标记。"

#. type: Plain text
#: en/git-fast-import.txt:1000
#, priority:90
msgid "As a `checkpoint` can require a significant amount of CPU time and disk IO (to compute the overall pack SHA-1 checksum, generate the corresponding index file, and update the refs) it can easily take several minutes for a single `checkpoint` command to complete."
msgstr "由于一个 `checkpoint` （检查点）可能需要大量的 CPU 时间和磁盘 IO（计算整个包的 SHA-1 校验和、生成相应的索引文件并更新引用），因此一条 `checkpoint` 命令可能需要几分钟才能完成。"

#. type: Plain text
#: en/git-fast-import.txt:1006
#, priority:90
msgid "Frontends may choose to issue checkpoints during extremely large and long running imports, or when they need to allow another Git process access to a branch. However given that a 30 GiB Subversion repository can be loaded into Git through fast-import in about 3 hours, explicit checkpointing may not be necessary."
msgstr "前端可能会选择在超大、超长的导入过程中，或需要允许另一个 Git 进程访问某个分支时，发出检查点。 不过，通过 fast-import 将一个 30GB 的 Subversion 仓库加载到 Git 大约只需要 3 个小时，因此可能不需要明确的检查点。"

#. type: Plain text
#: en/git-fast-import.txt:1015
#, priority:90
msgid "Causes fast-import to print the entire `progress` line unmodified to its standard output channel (file descriptor 1) when the command is processed from the input stream. The command otherwise has no impact on the current import, or on any of fast-import's internal state."
msgstr "在处理输入流中的命令时，使 fast-import 将整个 `progress` 行未经修改地打印到标准输出通道（文件描述符 1）。 除此之外，该命令不会对当前导入或 fast-import 的任何内部状态产生影响。"

#. type: delimited block .
#: en/git-fast-import.txt:1019
#, no-wrap, priority:90
msgid ""
"\t'progress' SP <any> LF\n"
"\tLF?\n"
msgstr ""
"\t'progress' SP <任意> LF\n"
"\tLF?\n"

#. type: Plain text
#: en/git-fast-import.txt:1025
#, priority:90
msgid "The `<any>` part of the command may contain any sequence of bytes that does not contain `LF`. The `LF` after the command is optional. Callers may wish to process the output through a tool such as sed to remove the leading part of the line, for example:"
msgstr "命令的 `<任意>` 部分可包含不含 `LF` 的任何字节序列。 命令后的 `LF` 是可选的。 调用者可能希望通过 sed 等工具处理输出，例如删除行的前导部分："

#. type: delimited block =
#: en/git-fast-import.txt:1028
#, no-wrap, placeholders:'git fast-import', priority:90
msgid "\tfrontend | git fast-import | sed 's/^progress //'\n"
msgstr "\tfrontend | git fast-import | sed 's/^progress //'\n"

#. type: Plain text
#: en/git-fast-import.txt:1033
#, priority:90
msgid "Placing a `progress` command immediately after a `checkpoint` will inform the reader when the `checkpoint` has been completed and it can safely access the refs that fast-import updated."
msgstr "在 `checkpoint` 之后紧接一个 `progress` 命令，可以通知阅读器 `checkpoint` 何时完成，阅读器可以安全地访问快速导入更新的引用。"

#. type: Plain text
#: en/git-fast-import.txt:1041
#, placeholders:'`--cat-blob-fd`', priority:90
msgid "Causes fast-import to print the SHA-1 corresponding to a mark to stdout or to the file descriptor previously arranged with the `--cat-blob-fd` argument. The command otherwise has no impact on the current import; its purpose is to retrieve SHA-1s that later commits might want to refer to in their commit messages."
msgstr "命令 fast-import 将标记对应的 SHA-1 打印到标准输出流或之前用 `--cat-blob-fd` 参数安排的文件描述符。该命令不会对当前导入产生任何影响；其目的是检索 SHA-1，供以后的提交在提交信息中参考。"

#. type: delimited block .
#: en/git-fast-import.txt:1044
#, no-wrap, priority:90
msgid "\t'get-mark' SP ':' <idnum> LF\n"
msgstr "\t'get-mark' SP ':' <idnum> LF\n"

#. type: Plain text
#: en/git-fast-import.txt:1048 en/git-fast-import.txt:1079 en/git-fast-import.txt:1132
#, priority:90
msgid "See ``Responses To Commands'' below for details about how to read this output safely."
msgstr "有关如何安全读取输出结果的详细信息，请参阅下文 ''对命令的回复''。"

#. type: Plain text
#: en/git-fast-import.txt:1056
#, placeholders:'`--cat-blob-fd`', priority:90
msgid "Causes fast-import to print a blob to a file descriptor previously arranged with the `--cat-blob-fd` argument. The command otherwise has no impact on the current import; its main purpose is to retrieve blobs that may be in fast-import's memory but not accessible from the target repository."
msgstr "使 fast-import 将 blob 打印到先前用 `--cat-blob-fd` 参数安排的文件描述符。 该命令不会对当前导入产生任何影响；其主要目的是检索 fast-import 内存中的 blob，但目标存储库无法访问这些 blob。"

#. type: delimited block .
#: en/git-fast-import.txt:1059
#, no-wrap, priority:90
msgid "\t'cat-blob' SP <dataref> LF\n"
msgstr "\t'cat-blob' SP <引用日期> LF\n"

#. type: Plain text
#: en/git-fast-import.txt:1064
#, priority:90
msgid "The `<dataref>` can be either a mark reference (`:<idnum>`) set previously or a full 40-byte SHA-1 of a Git blob, preexisting or ready to be written."
msgstr "`<数据引用>` 可以是之前设置的标记引用 (`:<idnum>`)，也可以是 Git blob 的完整 40 字节 SHA-1，可以是预先存在的，也可以是准备写入的。"

#. type: Plain text
#: en/git-fast-import.txt:1066
#, placeholders:'git cat-file':'--batch`', priority:90
msgid "Output uses the same format as `git cat-file --batch`:"
msgstr "输出格式与 `git cat-file --batch` 相同："

#. type: delimited block =
#: en/git-fast-import.txt:1070
#, no-wrap, priority:90
msgid ""
"\t<sha1> SP 'blob' SP <size> LF\n"
"\t<contents> LF\n"
msgstr ""
"\t<sha1> SP 'blob' SP <尺寸> LF\n"
"\t<内容> LF\n"

#. type: Plain text
#: en/git-fast-import.txt:1076
#, priority:90
msgid "This command can be used where a `filemodify` directive can appear, allowing it to be used in the middle of a commit. For a `filemodify` using an inline directive, it can also appear right before the `data` directive."
msgstr "该命令可用于出现 `filemodify` 指令的地方，允许在提交中间使用。 对于使用内联指令的 `filemodify`，它也可以出现在 `data` 指令之前。"

#. type: Plain text
#: en/git-fast-import.txt:1087
#, placeholders:'`--cat-blob-fd`', priority:90
msgid "Prints information about the object at a path to a file descriptor previously arranged with the `--cat-blob-fd` argument. This allows printing a blob from the active commit (with `cat-blob`) or copying a blob or tree from a previous commit for use in the current one (with `filemodify`)."
msgstr "打印文件描述符路径上的对象信息，该文件描述符是之前用 `--cat-blob-fd` 参数安排的。 这样就可以打印当前提交中的 blob（使用 `cat-blob` 时），或复制先前提交中的 blob 或树以用于当前提交（使用 `filemodify` 时）。"

#. type: Plain text
#: en/git-fast-import.txt:1090
#, priority:90
msgid "The `ls` command can also be used where a `filemodify` directive can appear, allowing it to be used in the middle of a commit."
msgstr "`ls` 命令也可用于出现 `filemodify` 指令的地方，允许在提交过程中使用。"

#. type: Labeled list
#: en/git-fast-import.txt:1091
#, no-wrap, priority:90
msgid "Reading from the active commit"
msgstr "从活动提交中读取"

#. type: Plain text
#: en/git-fast-import.txt:1095
#, priority:90
msgid "This form can only be used in the middle of a `commit`. The path names a directory entry within fast-import's active commit. The path must be quoted in this case."
msgstr "这种形式只能在 `commit` 过程中使用。 路径命名 fast-import 活动提交中的目录条目。 在这种情况下，路径必须加引号。"

#. type: delimited block .
#: en/git-fast-import.txt:1098
#, no-wrap, priority:90
msgid "\t'ls' SP <path> LF\n"
msgstr "\t'ls' SP <路径> LF\n"

#. type: Labeled list
#: en/git-fast-import.txt:1100
#, no-wrap, priority:90
msgid "Reading from a named tree"
msgstr "从命名树读取数据"

#. type: Plain text
#: en/git-fast-import.txt:1106
#, priority:90
msgid "The `<dataref>` can be a mark reference (`:<idnum>`) or the full 40-byte SHA-1 of a Git tag, commit, or tree object, preexisting or waiting to be written. The path is relative to the top level of the tree named by `<dataref>`."
msgstr "`<数据引用>` 可以是一个标记引用 ( `:<idnum>` )，也可以是 Git 标签、提交或树对象的完整 40 字节 SHA-1，可以是已存在的，也可以是等待写入的。 路径是相对于由 `<数据引用>` 命名的树的顶层的。"

#. type: delimited block .
#: en/git-fast-import.txt:1109
#, no-wrap, priority:90
msgid "\t'ls' SP <dataref> SP <path> LF\n"
msgstr "\t'ls' SP <引用日期> SP <路径> LF\n"

#. type: Plain text
#: en/git-fast-import.txt:1112
#, priority:90
msgid "See `filemodify` above for a detailed description of `<path>`."
msgstr "有关 `<路径>` 的详细说明，请参阅上文的 `filemodify` 。"

#. type: Plain text
#: en/git-fast-import.txt:1114
#, placeholders:'git ls-tree', priority:90
msgid "Output uses the same format as `git ls-tree <tree> -- <path>`:"
msgstr "输出格式与 `git ls-tree <目录树> -- <路径>`相同："

#. type: delimited block =
#: en/git-fast-import.txt:1117
#, no-wrap, priority:90
msgid "\t<mode> SP ('blob' | 'tree' | 'commit') SP <dataref> HT <path> LF\n"
msgstr "\t<模式> SP ('blob' | 'tree' | 'commit') SP <引用日期> HT <路径> LF\n"

#. type: Plain text
#: en/git-fast-import.txt:1122
#, priority:90
msgid "The <dataref> represents the blob, tree, or commit object at <path> and can be used in later 'get-mark', 'cat-blob', 'filemodify', or 'ls' commands."
msgstr "<数据引用> 表示 <路劲> 中的 blob、树或提交对象，可用于后面的 'get-mark'、'cat-blob'、'filemodify' 或 'ls' 命令。"

#. type: Plain text
#: en/git-fast-import.txt:1125
#, placeholders:'git fast-import', priority:90
msgid "If there is no file or subtree at that path, 'git fast-import' will instead report"
msgstr "如果该路径下没有文件或子树，'git fast-import' 将报告"

#. type: delimited block =
#: en/git-fast-import.txt:1128
#, no-wrap, priority:90
msgid "\tmissing SP <path> LF\n"
msgstr "\tmissing SP <路径> LF\n"

#. type: Plain text
#: en/git-fast-import.txt:1137
#, priority:90
msgid "Require that fast-import supports the specified feature, or abort if it does not."
msgstr "要求 fast-import 支持指定的功能，如果不支持则终止。"

#. type: delimited block .
#: en/git-fast-import.txt:1140
#, no-wrap, priority:90
msgid "\t'feature' SP <feature> ('=' <argument>)? LF\n"
msgstr "\t'feature' SP <功能> ('=' <参数>)? LF\n"

#. type: Plain text
#: en/git-fast-import.txt:1143
#, priority:90
msgid "The <feature> part of the command may be any one of the following:"
msgstr "命令的 <功能> 部分可以是以下任何一种："

#. type: Plain text
#: en/git-fast-import.txt:1144 en/git-fast-import.txt:1211
#, no-wrap, priority:90
msgid "date-format"
msgstr "date-format（日期格式）"

#. type: Plain text
#: en/git-fast-import.txt:1145 en/git-fast-import.txt:1213
#, no-wrap, priority:90
msgid "export-marks"
msgstr "export-marks（出口标记）"

#. type: Labeled list
#: en/git-fast-import.txt:1146
#, no-wrap, priority:90
msgid "relative-marks"
msgstr "relative-marks"

#. type: Labeled list
#: en/git-fast-import.txt:1147
#, no-wrap, priority:90
msgid "no-relative-marks"
msgstr "no-relative-marks"

#. type: Plain text
#: en/git-fast-import.txt:1148 en/git-fast-import.txt:1215
#, no-wrap, priority:90
msgid "force"
msgstr "强制"

#. type: Plain text
#: en/git-fast-import.txt:1152
#, priority:90
msgid "Act as though the corresponding command-line option with a leading `--` was passed on the command line (see OPTIONS, above)."
msgstr "就像在命令行中传递了带前导 `--` 的相应命令行选项一样（见上文选项）。"

#. type: Plain text
#: en/git-fast-import.txt:1153 en/git-fast-import.txt:1212
#, no-wrap, priority:90
msgid "import-marks"
msgstr "import-marks（入口标记）"

#. type: Labeled list
#: en/git-fast-import.txt:1154
#, no-wrap, priority:90
msgid "import-marks-if-exists"
msgstr "import-marks-if-exists（导入标记是否存在）"

#. type: Plain text
#: en/git-fast-import.txt:1162
#, placeholders:'--import-marks':'--import-marks=':'--import-marks-if-exists', priority:90
msgid "Like --import-marks except in two respects: first, only one \"feature import-marks\" or \"feature import-marks-if-exists\" command is allowed per stream; second, an --import-marks= or --import-marks-if-exists command-line option overrides any of these \"feature\" commands in the stream; third, \"feature import-marks-if-exists\" like a corresponding command-line option silently skips a nonexistent file."
msgstr "与 --import-marks 类似，但有两点不同：第一，每个数据流只允许一条 \"feature import-marks\" 或 \"feature import-marks-if-exists\" 命令；第二，命令行选项 --import-marks= 或 --import-marks-if-exists 会覆盖数据流中的任何这些 \"feature\" 命令；第三，\"feature import-marks-if-exists\" 与相应的命令行选项一样，会静默地跳过一个不存在的文件。"

#. type: Labeled list
#: en/git-fast-import.txt:1163
#, no-wrap, priority:90
msgid "get-mark"
msgstr "get-mark"

#. type: Labeled list
#: en/git-fast-import.txt:1164
#, no-wrap, priority:90
msgid "cat-blob"
msgstr "cat-blob"

#. type: Labeled list
#: en/git-fast-import.txt:1165
#, no-wrap, priority:90
msgid "ls"
msgstr "ls"

#. type: Plain text
#: en/git-fast-import.txt:1173
#, priority:90
msgid "Require that the backend support the 'get-mark', 'cat-blob', or 'ls' command respectively. Versions of fast-import not supporting the specified command will exit with a message indicating so. This lets the import error out early with a clear message, rather than wasting time on the early part of an import before the unsupported command is detected."
msgstr "要求后端分别支持 'get-mark'、'cat-blob' 或 'ls' 命令。 不支持指定命令的 fast-import 版本在退出时会给出提示信息。 这样，导入过程中就不会在检测到不支持的命令之前浪费时间，而会在早期就出现明确的错误信息。"

#. type: Labeled list
#: en/git-fast-import.txt:1174
#, no-wrap, priority:90
msgid "notes"
msgstr "备注"

#. type: Plain text
#: en/git-fast-import.txt:1179
#, priority:90
msgid "Require that the backend support the 'notemodify' (N) subcommand to the 'commit' command. Versions of fast-import not supporting notes will exit with a message indicating so."
msgstr "要求后端支持 'commit' 命令的 'notemodify'（N）子命令。 不支持备注的 fast-import 版本在退出时会显示相关信息。"

#. type: Labeled list
#: en/git-fast-import.txt:1180
#, no-wrap, priority:90
msgid "done"
msgstr "完成"

#. type: Plain text
#: en/git-fast-import.txt:1187
#, placeholders:'git fast-import', priority:90
msgid "Error out if the stream ends without a 'done' command. Without this feature, errors causing the frontend to end abruptly at a convenient point in the stream can go undetected. This may occur, for example, if an import front end dies in mid-operation without emitting SIGTERM or SIGKILL at its subordinate git fast-import instance."
msgstr "如果数据流在没有 'done' （完成）命令的情况下结束，就会出错。 如果没有这项功能，导致前端在流中某个适当位置突然结束的错误就可能不会被发现。 例如，如果一个导入前端在操作中途死亡，而没有在其下属的 git fast-import 实例中发出 SIGTERM 或 SIGKILL，就可能发生这种情况。"

#. type: Plain text
#: en/git-fast-import.txt:1194
#, placeholders:'git fast-import':'git fast-import', priority:90
msgid "Processes the specified option so that git fast-import behaves in a way that suits the frontend's needs. Note that options specified by the frontend are overridden by any options the user may specify to git fast-import itself."
msgstr "处理指定的选项，使 git fast-import 的行为符合前端的需要。 注意，前端指定的选项会被用户为 git fast-import 本身指定的任何选项所覆盖。"

#. type: delimited block .
#: en/git-fast-import.txt:1197
#, no-wrap, priority:90
msgid "    'option' SP <option> LF\n"
msgstr "    'option' SP <选项> LF\n"

#. type: Plain text
#: en/git-fast-import.txt:1202
#, priority:90
msgid "The `<option>` part of the command may contain any of the options listed in the OPTIONS section that do not change import semantics, without the leading `--` and is treated in the same way."
msgstr "`<选项>` 命令的一部分可能包含选项部分中列出的不更改导入语义的任何选项，而不更改前导 `--`，并且处理方式相同。"

#. type: Plain text
#: en/git-fast-import.txt:1206
#, priority:90
msgid "Option commands must be the first commands on the input (not counting feature commands), to give an option command after any non-option command is an error."
msgstr "选项命令必须是输入的第一条命令（不包括功能命令），在任何非选项命令之后给出选项命令都是错误的。"

#. type: Plain text
#: en/git-fast-import.txt:1209
#, priority:90
msgid "The following command-line options change import semantics and may therefore not be passed as option:"
msgstr "以下命令行选项会改变导入语义，因此不能作为选项传递："

#. type: Plain text
#: en/git-fast-import.txt:1214
#, priority:90
msgid "cat-blob-fd"
msgstr "cat-blob-fd"

#. type: Plain text
#: en/git-fast-import.txt:1220
#, priority:90
msgid "If the `done` feature is not in use, treated as if EOF was read. This can be used to tell fast-import to finish early."
msgstr "如果未使用 `done` 功能，则视作已读取 EOF。 这可以用来告诉 fast-import 提前结束。"

#. type: Plain text
#: en/git-fast-import.txt:1224
#, placeholders:'`--done`', priority:90
msgid "If the `--done` command-line option or `feature done` command is in use, the `done` command is mandatory and marks the end of the stream."
msgstr "如果使用了 `--done` 命令行选项或 `feature done` 命令，则 `done` 命令是强制性的，标志着数据流的结束。"

#. type: Title -
#: en/git-fast-import.txt:1226
#, no-wrap, priority:90
msgid "RESPONSES TO COMMANDS"
msgstr "对命令的响应"

#. type: Plain text
#: en/git-fast-import.txt:1233
#, priority:90
msgid "New objects written by fast-import are not available immediately. Most fast-import commands have no visible effect until the next checkpoint (or completion). The frontend can send commands to fill fast-import's input pipe without worrying about how quickly they will take effect, which improves performance by simplifying scheduling."
msgstr "快速导入写入的新对象不能立即使用。 大多数 fast-import 命令在下一个检查点（或完成）之前都不会有明显的效果。 前端可以发送命令来填充 fast-import 的输入管道，而不必担心这些命令的生效速度，这样可以简化调度，从而提高性能。"

#. type: Plain text
#: en/git-fast-import.txt:1240
#, priority:90
msgid "For some frontends, though, it is useful to be able to read back data from the current repository as it is being updated (for example when the source material describes objects in terms of patches to be applied to previously imported objects). This can be accomplished by connecting the frontend and fast-import via bidirectional pipes:"
msgstr "不过，对于某些前端来说，在更新时从当前资源库读回数据是非常有用的（例如，当源材料以补丁的形式描述要应用到先前导入对象的对象时）。 这可以通过双向管道连接前端和快速导入来实现："

#. type: delimited block =
#: en/git-fast-import.txt:1245
#, no-wrap, placeholders:'git fast-import', priority:90
msgid ""
"\tmkfifo fast-import-output\n"
"\tfrontend <fast-import-output |\n"
"\tgit fast-import >fast-import-output\n"
msgstr ""
"\tmkfifo fast-import-output\n"
"\tfrontend <fast-import-output |\n"
"\tgit fast-import >fast-import-output\n"

#. type: Plain text
#: en/git-fast-import.txt:1249
#, priority:90
msgid "A frontend set up this way can use `progress`, `get-mark`, `ls`, and `cat-blob` commands to read information from the import in progress."
msgstr "以这种方式设置的前端可以使用 `progress`、`get-mark`、`ls` 和 `cat-blob` 命令从正在进行的导入中读取信息。"

#. type: Plain text
#: en/git-fast-import.txt:1253
#, priority:90
msgid "To avoid deadlock, such frontends must completely consume any pending output from `progress`, `ls`, `get-mark`, and `cat-blob` before performing writes to fast-import that might block."
msgstr "为避免死锁，此类前端在向 fast-import 写入可能阻塞的内容之前，必须完全耗尽来自 `progress`、`ls`、`get-mark` 和 `cat-blob` 的任何待处理输出。"

#. type: Title -
#: en/git-fast-import.txt:1255
#, no-wrap, priority:90
msgid "CRASH REPORTS"
msgstr "事故报告"

#. type: Plain text
#: en/git-fast-import.txt:1261
#, priority:90
msgid "If fast-import is supplied invalid input it will terminate with a non-zero exit status and create a crash report in the top level of the Git repository it was importing into. Crash reports contain a snapshot of the internal fast-import state as well as the most recent commands that lead up to the crash."
msgstr "如果 fast-import 收到无效输入，它将以非零的退出状态终止，并在导入的 Git 仓库顶层创建一份崩溃报告。 崩溃报告包含 fast-import 内部状态的快照，以及导致崩溃的最新命令。"

#. type: Plain text
#: en/git-fast-import.txt:1268
#, priority:90
msgid "All recent commands (including stream comments, file changes and progress commands) are shown in the command history within the crash report, but raw file data and commit messages are excluded from the crash report. This exclusion saves space within the report file and reduces the amount of buffering that fast-import must perform during execution."
msgstr "所有最近的命令（包括流注释、文件更改和进度命令）都会显示在崩溃报告中的命令历史记录中，但原始文件数据和提交信息不会显示在崩溃报告中。 这种排除可以节省报告文件的空间，并减少 fast-import 在执行过程中必须执行的缓冲量。"

#. type: Plain text
#: en/git-fast-import.txt:1276
#, priority:90
msgid "After writing a crash report fast-import will close the current packfile and export the marks table. This allows the frontend developer to inspect the repository state and resume the import from the point where it crashed. The modified branches and tags are not updated during a crash, as the import did not complete successfully. Branch and tag information can be found in the crash report and must be applied manually if the update is needed."
msgstr "写完崩溃报告后，fast-import 会关闭当前的包文件并导出标记表。 这样，前端开发人员就可以检查仓库状态，并从崩溃的位置继续导入。 由于导入未成功完成，因此崩溃期间不会更新已修改的分支和标记。 分支和标记信息可在崩溃报告中找到，如果需要更新，必须手动应用。"

#. type: Plain text
#: en/git-fast-import.txt:1278
#, priority:90
msgid "An example crash:"
msgstr "崩溃实例："

#. type: delimited block =
#: en/git-fast-import.txt:1294
#, no-wrap, placeholders:'END_OF_INPUT':'.gitignore':'.gitignore':'END_OF_INPUT', priority:90
msgid ""
"\t$ cat >in <<END_OF_INPUT\n"
"\t# my very first test commit\n"
"\tcommit refs/heads/master\n"
"\tcommitter Shawn O. Pearce <spearce> 19283 -0400\n"
"\t# who is that guy anyway?\n"
"\tdata <<EOF\n"
"\tthis is my commit\n"
"\tEOF\n"
"\tM 644 inline .gitignore\n"
"\tdata <<EOF\n"
"\t.gitignore\n"
"\tEOF\n"
"\tM 777 inline bob\n"
"\tEND_OF_INPUT\n"
msgstr ""
"\t$ cat >in <<END_OF_INPUT\n"
"\t# 我的第一次测试提交\n"
"\tcommit refs/heads/master\n"
"\tcommitter Shawn O. Pearce <spearce> 19283 -0400\n"
"\t# 那家伙到底是谁？\n"
"\tdata <<EOF\n"
"\t这是我的提交\n"
"\tEOF\n"
"\tM 644 inline .gitignore\n"
"\tdata <<EOF\n"
"\t.gitignore\n"
"\tEOF\n"
"\tM 777 inline bob\n"
"\tEND_OF_INPUT\n"

#. type: delimited block =
#: en/git-fast-import.txt:1298
#, no-wrap, placeholders:'git fast-import':'fast_import_crash_8434', priority:90
msgid ""
"\t$ git fast-import <in\n"
"\tfatal: Corrupt mode: M 777 inline bob\n"
"\tfast-import: dumping crash report to .git/fast_import_crash_8434\n"
msgstr ""
"\t$ git fast-import <in\n"
"\tfatal: Corrupt mode: M 777 inline bob\n"
"\tfast-import: dumping crash report to .git/fast_import_crash_8434\n"

#. type: delimited block =
#: en/git-fast-import.txt:1304
#, no-wrap, placeholders:'fast_import_crash_8434', priority:90
msgid ""
"\t$ cat .git/fast_import_crash_8434\n"
"\tfast-import crash report:\n"
"\t    fast-import process: 8434\n"
"\t    parent process     : 1391\n"
"\t    at Sat Sep 1 00:58:12 2007\n"
msgstr ""
"\t$ cat .git/fast_import_crash_8434\n"
"\tfast-import crash report:\n"
"\t    fast-import process: 8434\n"
"\t    parent process     : 1391\n"
"\t    at Sat Sep 1 00:58:12 2007\n"

#. type: delimited block =
#: en/git-fast-import.txt:1306
#, no-wrap, priority:90
msgid "\tfatal: Corrupt mode: M 777 inline bob\n"
msgstr "\tfatal: Corrupt mode: M 777 inline bob（失败：错误的模式：M 777 ）\n"

#. type: delimited block =
#: en/git-fast-import.txt:1316
#, no-wrap, placeholders:'---------------------------------':'.gitignore', priority:90
msgid ""
"\tMost Recent Commands Before Crash\n"
"\t---------------------------------\n"
"\t  # my very first test commit\n"
"\t  commit refs/heads/master\n"
"\t  committer Shawn O. Pearce <spearce> 19283 -0400\n"
"\t  # who is that guy anyway?\n"
"\t  data <<EOF\n"
"\t  M 644 inline .gitignore\n"
"\t  data <<EOF\n"
msgstr ""
"\tMost Recent Commands Before Crash\n"
"\t---------------------------------\n"
"\t  # my very first test commit（我最开始的测试提交）\n"
"\t  commit refs/heads/master\n"
"\t  committer Shawn O. Pearce <spearce> 19283 -0400\n"
"\t  # who is that guy anyway?（这是什么？）\n"
"\t  data <<EOF\n"
"\t  M 644 inline .gitignore\n"
"\t  data <<EOF\n"

#. type: delimited block =
#: en/git-fast-import.txt:1317
#, no-wrap, priority:90
msgid "M 777 inline bob\n"
msgstr "M 777 inline bob\n"

#. type: delimited block =
#: en/git-fast-import.txt:1321
#, no-wrap, placeholders:'-----------------':'active_branches', priority:90
msgid ""
"Active Branch LRU\n"
"-----------------\n"
"active_branches = 1 cur, 5 max\n"
msgstr ""
"Active Branch LRU\n"
"-----------------\n"
"active_branches = 1 cur, 5 max\n"

#. type: delimited block =
#: en/git-fast-import.txt:1324
#, priority:90
msgid "pos clock name ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
msgstr "pos clock name ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"

#. type: delimited block =
#: en/git-fast-import.txt:1325
#, priority:90
msgid "0 refs/heads/master"
msgstr "0 refs/heads/master"

#. type: delimited block =
#: en/git-fast-import.txt:1335
#, no-wrap, placeholders:'-----------------', priority:90
msgid ""
"Inactive Branches\n"
"-----------------\n"
"refs/heads/master:\n"
"status      : active loaded dirty\n"
"tip commit  : 0000000000000000000000000000000000000000\n"
"old tree    : 0000000000000000000000000000000000000000\n"
"cur tree    : 0000000000000000000000000000000000000000\n"
"commit clock: 0\n"
"last pack   :\n"
msgstr ""
"Inactive Branches\n"
"-----------------\n"
"refs/heads/master:\n"
"status      : active loaded dirty\n"
"tip commit  : 0000000000000000000000000000000000000000\n"
"old tree    : 0000000000000000000000000000000000000000\n"
"cur tree    : 0000000000000000000000000000000000000000\n"
"commit clock: 0\n"
"last pack   :\n"

#. type: delimited block =
#: en/git-fast-import.txt:1339
#, placeholders:'-------------------', priority:90
msgid "------------------- END OF CRASH REPORT"
msgstr "------------------- END OF CRASH REPORT"

#. type: Title -
#: en/git-fast-import.txt:1342
#, no-wrap, priority:90
msgid "TIPS AND TRICKS"
msgstr "提示和技巧"

#. type: Plain text
#: en/git-fast-import.txt:1345
#, priority:90
msgid "The following tips and tricks have been collected from various users of fast-import, and are offered here as suggestions."
msgstr "以下提示和技巧是从 fast-import 的不同用户那里收集的，在此作为建议提供。"

#. type: Title ~
#: en/git-fast-import.txt:1347
#, no-wrap, priority:90
msgid "Use One Mark Per Commit"
msgstr "每次承诺使用一个标记"

#. type: Plain text
#: en/git-fast-import.txt:1355
#, placeholders:'--export-marks', priority:90
msgid "When doing a repository conversion, use a unique mark per commit (`mark :<n>`) and supply the --export-marks option on the command line. fast-import will dump a file which lists every mark and the Git object SHA-1 that corresponds to it. If the frontend can tie the marks back to the source repository, it is easy to verify the accuracy and completeness of the import by comparing each Git commit to the corresponding source revision."
msgstr "在进行仓转换时，每个提交使用一个唯一的标记（`标记 :<n>`），并在命令行中提供 --export-marks 选项。 如果前端能将标记与源代码仓库绑定，就能通过比较每个 Git 提交和相应的源代码版本，轻松验证导入的准确性和完整性。"

#. type: Plain text
#: en/git-fast-import.txt:1359
#, priority:90
msgid "Coming from a system such as Perforce or Subversion, this should be quite simple, as the fast-import mark can also be the Perforce changeset number or the Subversion revision number."
msgstr "从 Perforce 或 Subversion 等系统导入时，这应该非常简单，因为快速导入标记也可以是 Perforce 更改集编号或 Subversion 修订编号。"

#. type: Title ~
#: en/git-fast-import.txt:1361
#, no-wrap, priority:90
msgid "Freely Skip Around Branches"
msgstr "自由跳转分支"

#. type: Plain text
#: en/git-fast-import.txt:1366
#, priority:90
msgid "Don't bother trying to optimize the frontend to stick to one branch at a time during an import. Although doing so might be slightly faster for fast-import, it tends to increase the complexity of the frontend code considerably."
msgstr "在导入过程中，不要费心去优化前端，使其一次只针对一个分支。 虽然这样做可能会稍微加快快速导入的速度，但往往会大大增加前端代码的复杂性。"

#. type: Plain text
#: en/git-fast-import.txt:1370
#, priority:90
msgid "The branch LRU builtin to fast-import tends to behave very well, and the cost of activating an inactive branch is so low that bouncing around between branches has virtually no impact on import performance."
msgstr "fast-import 内置的分支 LRU 通常表现非常出色，而且激活非活动分支的成本很低，在分支间跳来跳去对导入性能几乎没有影响。"

#. type: Title ~
#: en/git-fast-import.txt:1372
#, no-wrap, priority:90
msgid "Handling Renames"
msgstr "处理重命名"

#. type: Plain text
#: en/git-fast-import.txt:1377
#, priority:90
msgid "When importing a renamed file or directory, simply delete the old name(s) and modify the new name(s) during the corresponding commit. Git performs rename detection after-the-fact, rather than explicitly during a commit."
msgstr "在导入重命名的文件或目录时，只需在相应的提交过程中删除旧名称并修改新名称即可。 Git 会在事后执行重命名检测，而不是在提交时明确执行。"

#. type: Title ~
#: en/git-fast-import.txt:1379
#, no-wrap, priority:90
msgid "Use Tag Fixup Branches"
msgstr "使用标签修复分支"

#. type: Plain text
#: en/git-fast-import.txt:1383
#, priority:90
msgid "Some other SCM systems let the user create a tag from multiple files which are not from the same commit/changeset. Or to create tags which are a subset of the files available in the repository."
msgstr "其他一些 SCM 系统允许用户从多个文件创建标签，而这些文件并非来自同一提交/变更集。 或者创建的标签是仓库中可用文件的子集。"

#. type: Plain text
#: en/git-fast-import.txt:1390
#, priority:90
msgid "Importing these tags as-is in Git is impossible without making at least one commit which ``fixes up'' the files to match the content of the tag. Use fast-import's `reset` command to reset a dummy branch outside of your normal branch space to the base commit for the tag, then commit one or more file fixup commits, and finally tag the dummy branch."
msgstr "如果不至少提交一次 ''修'' 文件以匹配标签内容，就无法在 Git 中原样导入这些标签。 使用 fast-import 的 `reset` 命令，在正常分支空间外重置一个假分支，使其与标签的基本提交一致，然后提交一次或多次文件修复提交，最后给假分支打上标签。"

#. type: Plain text
#: en/git-fast-import.txt:1396
#, priority:90
msgid "For example since all normal branches are stored under `refs/heads/` name the tag fixup branch `TAG_FIXUP`. This way it is impossible for the fixup branch used by the importer to have namespace conflicts with real branches imported from the source (the name `TAG_FIXUP` is not `refs/heads/TAG_FIXUP`)."
msgstr "例如，由于所有正常分支都存储在 `refs/heads/` 下，因此将标记修复分支命名为 `TAG_FIXUP`。 这样，导入程序使用的修复分支就不可能与从源代码导入的真正分支发生命名空间冲突（名称 `TAG_FIXUP` 不是 `refs/heads/TAG_FIXUP`）。"

#. type: Plain text
#: en/git-fast-import.txt:1402
#, priority:90
msgid "When committing fixups, consider using `merge` to connect the commit(s) which are supplying file revisions to the fixup branch. Doing so will allow tools such as 'git blame' to track through the real commit history and properly annotate the source files."
msgstr "提交修复时，请考虑使用 `merge` 将提供文件修订的提交连接到修复分支。 这样做可以让 'git blame' 等工具追踪真实的提交历史，并正确地注释源文件。"

#. type: Plain text
#: en/git-fast-import.txt:1405
#, priority:90
msgid "After fast-import terminates the frontend will need to do `rm .git/TAG_FIXUP` to remove the dummy branch."
msgstr "快速导入结束后，前台需要执行 `rm .git/TAG_FIXUP` 来移除虚拟分支。"

#. type: Title ~
#: en/git-fast-import.txt:1407
#, no-wrap, priority:90
msgid "Import Now, Repack Later"
msgstr "立即导入，稍后重新打包"

#. type: Plain text
#: en/git-fast-import.txt:1411
#, priority:90
msgid "As soon as fast-import completes the Git repository is completely valid and ready for use. Typically this takes only a very short time, even for considerably large projects (100,000+ commits)."
msgstr "快速导入完成后，Git 仓库就完全有效，可以随时使用。 通常这只需要很短的时间，即使对于相当大的项目（100,000+ 次提交）也是如此。"

#. type: Plain text
#: en/git-fast-import.txt:1418
#, placeholders:'--window', priority:90
msgid "However repacking the repository is necessary to improve data locality and access performance. It can also take hours on extremely large projects (especially if -f and a large --window parameter is used). Since repacking is safe to run alongside readers and writers, run the repack in the background and let it finish when it finishes. There is no reason to wait to explore your new Git project!"
msgstr "不过，为了提高数据的位置性和访问性能，有必要重新打包仓库。 在超大型项目中，这也可能需要数小时（尤其是在使用 -f 和较大的 --window 参数时）。 由于重新打包可以安全地与读写器同时运行，因此请在后台运行重新打包，并让它在完成时完成。 没有理由等待探索新的 Git 项目！"

#. type: Plain text
#: en/git-fast-import.txt:1423
#, priority:90
msgid "If you choose to wait for the repack, don't try to run benchmarks or performance tests until repacking is completed. fast-import outputs suboptimal packfiles that are simply never seen in real use situations."
msgstr "如果您选择等待重新打包，在重新打包完成之前不要尝试运行基准或性能测试。"

#. type: Title ~
#: en/git-fast-import.txt:1425
#, no-wrap, priority:90
msgid "Repacking Historical Data"
msgstr "重新打包历史数据"

#. type: Plain text
#: en/git-fast-import.txt:1432
#, placeholders:'--window=50', priority:90
msgid "If you are repacking very old imported data (e.g. older than the last year), consider expending some extra CPU time and supplying --window=50 (or higher) when you run 'git repack'. This will take longer, but will also produce a smaller packfile. You only need to expend the effort once, and everyone using your project will benefit from the smaller repository."
msgstr "如果您要重新打包非常旧的导入数据（例如，比去年更旧的数据），可以考虑在运行 'git repack' 时花费一些额外的 CPU 时间并提供 --window=50（或更高）的参数。 这样会花费更多时间，但生成的打包文件也会更小。 您只需花费一次精力，而使用您项目的每个人都将受益于更小的仓库。"

#. type: Title ~
#: en/git-fast-import.txt:1434
#, no-wrap, priority:90
msgid "Include Some Progress Messages"
msgstr "包括一些进展信息"

#. type: Plain text
#: en/git-fast-import.txt:1441
#, priority:90
msgid "Every once in a while have your frontend emit a `progress` message to fast-import. The contents of the messages are entirely free-form, so one suggestion would be to output the current month and year each time the current commit date moves into the next month. Your users will feel better knowing how much of the data stream has been processed."
msgstr "每隔一段时间，让你的前端向快速导入发出一条 `progress`（进度）信息。 消息的内容可以完全自由发挥，因此建议在当前提交日期进入下一个月时，输出当前月份和年份。 这样，用户就能更好地了解数据流的处理情况。"

#. type: Title -
#: en/git-fast-import.txt:1444
#, no-wrap, priority:90
msgid "PACKFILE OPTIMIZATION"
msgstr "包文件优化"

#. type: Plain text
#: en/git-fast-import.txt:1450
#, priority:90
msgid "When packing a blob fast-import always attempts to deltify against the last blob written. Unless specifically arranged for by the frontend, this will probably not be a prior version of the same file, so the generated delta will not be the smallest possible. The resulting packfile will be compressed, but will not be optimal."
msgstr "在打包 blob 时，fast-import 总是尝试根据最后写入的 blob 进行 deltify。 除非前端特别安排，否则这很可能不是同一文件的先前版本，因此生成的 delta 不会是尽可能小的。 生成的打包文件将被压缩，但不会达到最佳效果。"

#. type: Plain text
#: en/git-fast-import.txt:1458
#, priority:90
msgid "Frontends which have efficient access to all revisions of a single file (for example reading an RCS/CVS ,v file) can choose to supply all revisions of that file as a sequence of consecutive `blob` commands. This allows fast-import to deltify the different file revisions against each other, saving space in the final packfile. Marks can be used to later identify individual file revisions during a sequence of `commit` commands."
msgstr "可以高效访问单个文件所有修订版本的前端（例如读取 RCS/CVS ,v 文件），可以选择以连续的 `blob` 命令序列提供该文件的所有修订版本。 这样，快速导入程序就能将不同的文件修订版本相互区分开来，从而节省最终打包文件的空间。 标记可用于以后在一连串 `commit` 命令中识别单个文件修订版。"

#. type: Plain text
#: en/git-fast-import.txt:1465
#, priority:90
msgid "The packfile(s) created by fast-import do not encourage good disk access patterns. This is caused by fast-import writing the data in the order it is received on standard input, while Git typically organizes data within packfiles to make the most recent (current tip) data appear before historical data. Git also clusters commits together, speeding up revision traversal through better cache locality."
msgstr "fast-import 创建的包文件不支持良好的磁盘访问模式。 这是因为 fast-import 是按照标准输入的顺序写入数据的，而 Git 通常会在包文件中组织数据，使最新的（当前提示）数据出现在历史数据之前。 Git 还会将提交聚类在一起，通过更好的缓存定位加快版本遍历速度。"

#. type: Plain text
#: en/git-fast-import.txt:1472
#, placeholders:'`-f`', priority:90
msgid "For this reason it is strongly recommended that users repack the repository with `git repack -a -d` after fast-import completes, allowing Git to reorganize the packfiles for faster data access. If blob deltas are suboptimal (see above) then also adding the `-f` option to force recomputation of all deltas can significantly reduce the final packfile size (30-50% smaller can be quite typical)."
msgstr "因此，强烈建议用户在 fast-import 完成后使用 `git repack -a -d` 重新打包仓库，让 Git 重新组织打包文件以加快数据访问速度。 如果 blob deltas 是次优的（见上文），那么添加 `-f` 选项来强制重新计算所有 deltas，也能显著减少最终打包文件的大小（通常能减少 30-50%）。"

#. type: Plain text
#: en/git-fast-import.txt:1480
#, placeholders:'--aggressive`':'linkgit:git-gc[1]':'`--aggressive`':'`-f`':'linkgit:git-repack[1]':'`--aggressive`', priority:90
msgid "Instead of running `git repack` you can also run `git gc --aggressive`, which will also optimize other things after an import (e.g. pack loose refs). As noted in the \"AGGRESSIVE\" section in linkgit:git-gc[1] the `--aggressive` option will find new deltas with the `-f` option to linkgit:git-repack[1]. For the reasons elaborated on above using `--aggressive` after a fast-import is one of the few cases where it's known to be worthwhile."
msgstr "你也可以不运行 `git repack` 而运行 `git gc--aggressive`，它也会在导入后优化其他事情（比如打包松散的引用）。正如 linkgit:git-gc[1] 中的 \"AGRESSIVE \"部分所述，`--aggressive` 选项会在 linkgit:git-repack[1] 中使用 `-f` 选项找到新的 deltas。由于上述原因，在快速导入后使用 `--aggressive` 是为数不多的值得这么做的情况。"

#. type: Title -
#: en/git-fast-import.txt:1482
#, no-wrap, priority:90
msgid "MEMORY UTILIZATION"
msgstr "内存利用率"

#. type: Plain text
#: en/git-fast-import.txt:1488
#, priority:90
msgid "There are a number of factors which affect how much memory fast-import requires to perform an import. Like critical sections of core Git, fast-import uses its own memory allocators to amortize any overheads associated with malloc. In practice fast-import tends to amortize any malloc overheads to 0, due to its use of large block allocations."
msgstr "影响 fast-import 导入所需内存的因素有很多。 与核心 Git 的关键部分一样，fast-import 使用自己的内存分配器来摊销与 malloc 相关的开销。 在实践中，由于 fast-import 使用了大量的块分配，它往往会将 malloc 的开销摊销为 0。"

#. type: Title ~
#: en/git-fast-import.txt:1490
#, no-wrap, priority:90
msgid "per object"
msgstr "每个对象"

#. type: Plain text
#: en/git-fast-import.txt:1497
#, priority:90
msgid "fast-import maintains an in-memory structure for every object written in this execution. On a 32 bit system the structure is 32 bytes, on a 64 bit system the structure is 40 bytes (due to the larger pointer sizes). Objects in the table are not deallocated until fast-import terminates. Importing 2 million objects on a 32 bit system will require approximately 64 MiB of memory."
msgstr "fast-import 会为本次执行中写入的每个对象维护一个内存结构。 在 32 位系统中，该结构为 32 字节，在 64 位系统中，该结构为 40 字节（由于指针尺寸较大）。 表中的对象在 fast-import 终止前不会被重新分配。 在 32 位系统上导入 200 万个对象大约需要 64 MiB 内存。"

#. type: Plain text
#: en/git-fast-import.txt:1503
#, priority:90
msgid "The object table is actually a hashtable keyed on the object name (the unique SHA-1). This storage configuration allows fast-import to reuse an existing or already written object and avoid writing duplicates to the output packfile. Duplicate blobs are surprisingly common in an import, typically due to branch merges in the source."
msgstr "对象表实际上是一个以对象名称（唯一的 SHA-1）为键的哈希表。 这种存储配置允许 fast-import 重用现有或已写入的对象，避免将重复的对象写入输出包文件。 在导入过程中，重复的 blob 会非常常见，这通常是由于源代码中的分支合并造成的。"

#. type: Title ~
#: en/git-fast-import.txt:1505
#, no-wrap, priority:90
msgid "per mark"
msgstr "每个标记"

#. type: Plain text
#: en/git-fast-import.txt:1511
#, priority:90
msgid "Marks are stored in a sparse array, using 1 pointer (4 bytes or 8 bytes, depending on pointer size) per mark. Although the array is sparse, frontends are still strongly encouraged to use marks between 1 and n, where n is the total number of marks required for this import."
msgstr "标记存储在一个稀疏数组中，每个标记使用 1 个指针（4 字节或 8 字节，取决于指针大小）。 虽然数组是稀疏的，但仍强烈建议前端使用 1 到 n 之间的标记，其中 n 是本次导入所需的标记总数。"

#. type: Title ~
#: en/git-fast-import.txt:1513
#, no-wrap, priority:90
msgid "per branch"
msgstr "每个分支"

#. type: Plain text
#: en/git-fast-import.txt:1516
#, priority:90
msgid "Branches are classified as active and inactive. The memory usage of the two classes is significantly different."
msgstr "分支分为活动分支和非活动分支。 这两类分支的内存使用量差别很大。"

#. type: Plain text
#: en/git-fast-import.txt:1522
#, priority:90
msgid "Inactive branches are stored in a structure which uses 96 or 120 bytes (32 bit or 64 bit systems, respectively), plus the length of the branch name (typically under 200 bytes), per branch. fast-import will easily handle as many as 10,000 inactive branches in under 2 MiB of memory."
msgstr "非活动分支存储在一个结构中，每个分支使用 96 或 120 字节（分别用于 32 位或 64 位系统），外加分支名称的长度（通常小于 200 字节）。"

#. type: Plain text
#: en/git-fast-import.txt:1529
#, priority:90
msgid "Active branches have the same overhead as inactive branches, but also contain copies of every tree that has been recently modified on that branch. If subtree `include` has not been modified since the branch became active, its contents will not be loaded into memory, but if subtree `src` has been modified by a commit since the branch became active, then its contents will be loaded in memory."
msgstr "活动分支的开销与非活动分支相同，但也包含该分支上最近修改过的每棵树的副本。 如果子树 `include` 在分支变为活动后没有被修改过，其内容就不会被加载到内存中，但如果子树 `src` 在分支变为活动后被提交修改过，其内容就会被加载到内存中。"

#. type: Plain text
#: en/git-fast-import.txt:1533
#, priority:90
msgid "As active branches store metadata about the files contained on that branch, their in-memory storage size can grow to a considerable size (see below)."
msgstr "由于活动分支存储的是该分支所含文件的元数据，因此其内存存储容量可能会相当大（见下文）。"

#. type: Plain text
#: en/git-fast-import.txt:1538
#, placeholders:'--active-branches=', priority:90
msgid "fast-import automatically moves active branches to inactive status based on a simple least-recently-used algorithm. The LRU chain is updated on each `commit` command. The maximum number of active branches can be increased or decreased on the command line with --active-branches=."
msgstr "fast-import 根据一种简单的最近最少使用算法，自动将活动分支移至非活动状态。 LRU 链会在每一条 `commit` 命令中更新。 可以在命令行中使用 --active-branches= 来增加或减少活动分支的最大数量。"

#. type: Title ~
#: en/git-fast-import.txt:1540
#, no-wrap, priority:90
msgid "per active tree"
msgstr "每个活动目录树"

#. type: Plain text
#: en/git-fast-import.txt:1545
#, priority:90
msgid "Trees (aka directories) use just 12 bytes of memory on top of the memory required for their entries (see ``per active file'' below). The cost of a tree is virtually 0, as its overhead amortizes out over the individual file entries."
msgstr "树（又称目录）在其条目（见下文 ''每个活动文件''）所需内存之外，仅占用 12 字节内存。 树的成本几乎为零，因为其开销会在单个文件条目中摊销。"

#. type: Title ~
#: en/git-fast-import.txt:1547
#, no-wrap, priority:90
msgid "per active file entry"
msgstr "每个活动文件条目"

#. type: Plain text
#: en/git-fast-import.txt:1553
#, priority:90
msgid "Files (and pointers to subtrees) within active trees require 52 or 64 bytes (32/64 bit platforms) per entry. To conserve space, file and tree names are pooled in a common string table, allowing the filename ``Makefile'' to use just 16 bytes (after including the string header overhead) no matter how many times it occurs within the project."
msgstr "活动目录树中的文件（和指向子目录树的指针）每个条目需要 52 或 64 字节（32/64 位平台）。 为了节省空间，文件名和目录树名被集中到一个通用的字符串表中，这样无论文件名 ''Makefile'' 在项目中出现多少次，都只需使用 16 个字节（包括字符串头开销）。"

#. type: Plain text
#: en/git-fast-import.txt:1558
#, priority:90
msgid "The active branch LRU, when coupled with the filename string pool and lazy loading of subtrees, allows fast-import to efficiently import projects with 2,000+ branches and 45,114+ files in a very limited memory footprint (less than 2.7 MiB per active branch)."
msgstr "活动分支 LRU 与文件名字符串池和子树的懒加载相结合，使 fast-import 能够在非常有限的内存空间内（每个活动分支小于 2.7 MiB）高效导入包含 2,000 多个分支和 45,114 多个文件的项目。"

#. type: Title -
#: en/git-fast-import.txt:1560
#, no-wrap, priority:90
msgid "SIGNALS"
msgstr "信号"

#. type: Plain text
#: en/git-fast-import.txt:1566
#, placeholders:'git fast-import', priority:90
msgid "Sending *SIGUSR1* to the 'git fast-import' process ends the current packfile early, simulating a `checkpoint` command. The impatient operator can use this facility to peek at the objects and refs from an import in progress, at the cost of some added running time and worse compression."
msgstr "向 'git fast-import' 进程发送 *SIGUSR1* 会提前结束当前的打包文件，模拟一个 `checkpoint` 命令。 没有耐心的操作员可以使用这一工具来偷看正在导入的对象和引用，但代价是增加运行时间和降低压缩率。"

#. type: Title =
#: en/git-fetch-pack.txt:2
#, ignore-same, no-wrap, priority:90
msgid "git-fetch-pack(1)"
msgstr "git-fetch-pack(1)"

#. type: Plain text
#: en/git-fetch-pack.txt:7
#, placeholders:'git-fetch-pack', priority:90
msgid "git-fetch-pack - Receive missing objects from another repository"
msgstr "git-fetch-pack - 从另一个仓库接收丢失的对象"

#. type: Plain text
#: en/git-fetch-pack.txt:16
#, ignore-ellipsis, no-wrap, placeholders:'git fetch-pack':'[--all]':'[--quiet':'[--keep':'[--thin]':'[--include-tag]':'[--upload-pack=':'git-upload-pack':'[--depth=':'[--no-progress]', priority:90
msgid ""
"'git fetch-pack' [--all] [--quiet|-q] [--keep|-k] [--thin] [--include-tag]\n"
"\t[--upload-pack=<git-upload-pack>]\n"
"\t[--depth=<n>] [--no-progress]\n"
"\t[-v] <repository> [<refs>...]\n"
msgstr ""
"'git fetch-pack' [--all] [--quiet|-q] [--keep|-k] [--thin] [--include-tag]\n"
"\t[--upload-pack=<git-upload-pack>]\n"
"\t[--depth=<n>] [--no-progress]\n"
"\t[-v] <仓库> [<多个引用>...]\n"

#. type: Plain text
#: en/git-fetch-pack.txt:21
#, priority:90
msgid "Usually you would want to use 'git fetch', which is a higher level wrapper of this command, instead."
msgstr "通常情况下，您需要使用 'git fetch'，它是该命令的更高级封装。"

#. type: Plain text
#: en/git-fetch-pack.txt:27
#, placeholders:'git-upload-pack':'git-upload-pack', priority:90
msgid "Invokes 'git-upload-pack' on a possibly remote repository and asks it to send objects missing from this repository, to update the named heads. The list of commits available locally is found out by scanning the local refs/ hierarchy and sent to 'git-upload-pack' running on the other end."
msgstr "在可能的远程仓库中调用 'git-upload-pack'，并要求它发送该仓库中缺失的对象，以更新指定的头。 通过扫描本地 refs/ 层次结构，找出本地可用的提交列表，然后发送给另一端运行的 'git-upload-pack'。"

#. type: Plain text
#: en/git-fetch-pack.txt:31
#, priority:90
msgid "This command degenerates to download everything to complete the asked refs from the remote side when the local side does not have a common ancestor commit."
msgstr "当本地端没有共同祖先提交时，该命令会退化为从远程端下载所有内容以完成所请求的引用。"

#. type: Plain text
#: en/git-fetch-pack.txt:37
#, priority:90
msgid "Fetch all remote refs."
msgstr "获取所有远程引用。"

#. type: Plain text
#: en/git-fetch-pack.txt:43 en/git-send-pack.txt:47
#, priority:90
msgid "Take the list of refs from stdin, one per line. If there are refs specified on the command line in addition to this option, then the refs from stdin are processed after those on the command line."
msgstr "从标准输入流获取各个引用列表，每行一个。如果命令行中除此选项外还指定了其他引用，则会在处理命令行中的引用后再处理来自标准输入流的多个引用。"

#. type: Plain text
#: en/git-fetch-pack.txt:47 en/git-send-pack.txt:51
#, placeholders:'`--stateless-rpc`', priority:90
msgid "If `--stateless-rpc` is specified together with this option then the list of refs must be in packet format (pkt-line). Each ref must be in a separate packet, and the list must end with a flush packet."
msgstr "如果与此选项一起指定了 `--stateless-rpc`，那么引用列表必须是数据包格式（pkt-line）。每个引用必须在一个单独的数据包中，并且列表必须以清除数据包结束。"

#. type: Plain text
#: en/git-fetch-pack.txt:52
#, placeholders:'`-q`':'git unpack-objects', priority:90
msgid "Pass `-q` flag to 'git unpack-objects'; this makes the cloning process less verbose."
msgstr "向 'git unpack-objects' 传递 `-q` 标志；这会使克隆过程不那么冗长。"

#. type: Plain text
#: en/git-fetch-pack.txt:59
#, placeholders:'git unpack-objects', priority:90
msgid "Do not invoke 'git unpack-objects' on received data, but create a single packfile out of it instead, and store it in the object database. If provided twice then the pack is locked against repacking."
msgstr "不要对接收到的数据调用 'git unpack-objects'，而是将其创建为一个单独的数据包文件，并将其存储在对象数据库中。如果提供两次，则会锁定数据包，防止重新打包。"

#. type: Labeled list
#: en/git-fetch-pack.txt:60 en/git-pack-objects.txt:248 en/git-send-pack.txt:65
#, ignore-same, no-wrap, priority:90
msgid "--thin"
msgstr "--thin"

#. type: Plain text
#: en/git-fetch-pack.txt:63
#, priority:90
msgid "Fetch a \"thin\" pack, which records objects in deltified form based on objects not included in the pack to reduce network traffic."
msgstr "获取 “精简” 数据包，根据未包含在数据包中的对象，以简化形式记录对象，以减少网络流量。"

#. type: Labeled list
#: en/git-fetch-pack.txt:64 en/git-pack-objects.txt:84
#, ignore-same, no-wrap, priority:90
msgid "--include-tag"
msgstr "--include-tag"

#. type: Plain text
#: en/git-fetch-pack.txt:69
#, priority:90
msgid "If the remote side supports it, annotated tags objects will be downloaded on the same connection as the other objects if the object the tag references is downloaded. The caller must otherwise determine the tags this option made available."
msgstr "如果远端支持该选项，则在下载标记引用的对象时，注释标记对象将与其他对象在同一连接上下载。 否则，调用者必须确定该选项提供的标记。"

# ERROR: git-upload-pack not found in translation
#. type: Labeled list
#: en/git-fetch-pack.txt:70
#, no-wrap, placeholders:'--upload-pack=':'git-upload-pack', priority:90
msgid "--upload-pack=<git-upload-pack>"
msgstr "--upload-pack=<git-upload-pack>"

#. type: Plain text
#: en/git-fetch-pack.txt:81
#, placeholders:'git-upload-pack':'$PATH':'bash_profile':'$PATH':'$PATH':'bash_profile', priority:90
msgid "Use this to specify the path to 'git-upload-pack' on the remote side, if it is not found on your $PATH. Installations of sshd ignores the user's environment setup scripts for login shells (e.g. .bash_profile) and your privately installed git may not be found on the system default $PATH. Another workaround suggested is to set up your $PATH in \".bashrc\", but this flag is for people who do not want to pay the overhead for non-interactive shells by having a lean .bashrc file (they set most of the things up in .bash_profile)."
msgstr "如果在您的 $PATH 中找不到 'git-upload-pack'，则用它来指定远端 'git-upload-pack' 的路径。 安装 sshd 时会忽略用户登录 shell 的环境设置脚本（例如 .bash_profile），因此系统默认的 $PATH 中可能找不到用户自行安装的 git。 另一种变通方法是在 \".bashrc\" 中设置 $PATH，但这种方法只适用于不想为非交互式 shell 支付额外费用的用户（他们会在 .bash_profile 中设置大部分内容）。"

# ERROR: git-upload-pack not found in translation
#. type: Labeled list
#: en/git-fetch-pack.txt:82
#, no-wrap, placeholders:'--exec=':'git-upload-pack', priority:90
msgid "--exec=<git-upload-pack>"
msgstr "--exec=<git-upload-pack>"

#. type: Plain text
#: en/git-fetch-pack.txt:84
#, placeholders:'--upload-pack=':'git-upload-pack', priority:90
msgid "Same as --upload-pack=<git-upload-pack>."
msgstr "与 --upload-pack=<git-upload-pack> 相同。"

#. type: Plain text
#: en/git-fetch-pack.txt:89
#, placeholders:'git-upload-pack', priority:90
msgid "Limit fetching to ancestor-chains not longer than n. 'git-upload-pack' treats the special depth 2147483647 as infinite even if there is an ancestor-chain that long."
msgstr "'git-upload-pack' 将特殊深度 2147483647 视为无穷大，即使存在这么长的祖先链。"

#. type: Labeled list
#: en/git-fetch-pack.txt:99
#, ignore-same, no-wrap, priority:90
msgid "--deepen-relative"
msgstr "--deepen-relative"

#. type: Plain text
#: en/git-fetch-pack.txt:103
#, placeholders:'--depth', priority:90
msgid "Argument --depth specifies the number of commits from the current shallow boundary instead of from the tip of each remote branch history."
msgstr "参数 --depth 指定从当前浅边界开始的提交次数，而不是从每个远程分支历史的顶端开始的提交次数。"

#. type: Plain text
#: en/git-fetch-pack.txt:107
#, priority:90
msgid "Skips negotiating commits with the server in order to fetch all matching objects. Use to reapply a new partial clone blob/tree filter."
msgstr "跳过与服务器的协商提交，以获取所有匹配对象。用于重新应用新的部分克隆 blob/tree 过滤器。"

#. type: Plain text
#: en/git-fetch-pack.txt:110
#, priority:90
msgid "Do not show the progress."
msgstr "不要显示进度。"

#. type: Labeled list
#: en/git-fetch-pack.txt:111 en/git-index-pack.txt:96
#, ignore-same, no-wrap, priority:100
msgid "--check-self-contained-and-connected"
msgstr "--check-self-contained-and-connected"

#. type: Plain text
#: en/git-fetch-pack.txt:114
#, priority:90
msgid "Output \"connectivity-ok\" if the received pack is self-contained and connected."
msgstr "如果接收到的数据包是独立的且已连接，则输出 \"connectivity-ok\"（连接正常）。"

#. type: Plain text
#: en/git-fetch-pack.txt:117 en/git-push.txt:395 en/git-send-pack.txt:64
#, priority:220
msgid "Run verbosely."
msgstr "详细运行。"

#. type: Plain text
#: en/git-fetch-pack.txt:120
#, priority:90
msgid "The URL to the remote repository."
msgstr "远程仓库的 URL。"

#. type: Labeled list
#: en/git-fetch-pack.txt:121
#, ignore-ellipsis, no-wrap, priority:90
msgid "<refs>..."
msgstr "<引用>..."

#. type: Plain text
#: en/git-fetch-pack.txt:125
#, placeholders:'$GIT_DIR':'HEAD', priority:90
msgid "The remote heads to update from. This is relative to $GIT_DIR (e.g. \"HEAD\", \"refs/heads/master\"). When unspecified, update from all heads the remote side has."
msgstr "要更新的远程头。这是相对于 $GIT_DIR（例如 \"HEAD\"、\"refs/heads/master\"）而言的。 如果未指定，则对远端所有头进行更新。"

#. type: Plain text
#: en/git-fetch-pack.txt:129
#, priority:90
msgid "If the remote has enabled the options `uploadpack.allowTipSHA1InWant`, `uploadpack.allowReachableSHA1InWant`, or `uploadpack.allowAnySHA1InWant`, they may alternatively be 40-hex sha1s present on the remote."
msgstr "如果远程已启用选项 `uploadpack.allowTipSHA1InWant`、`uploadpack.allowReachableSHA1InWant` 或 `uploadpack.allowAnySHA1InWant`，它们也可以是远程仓库上的 40-hex sha1。"

#. type: Title =
#: en/git-fetch.txt:2
#, ignore-same, no-wrap, priority:220
msgid "git-fetch(1)"
msgstr "git-fetch(1)"

#. type: Plain text
#: en/git-fetch.txt:7
#, placeholders:'git-fetch', priority:220
msgid "git-fetch - Download objects and refs from another repository"
msgstr "git-fetch - 从另一个仓库下载对象和引用"

#. type: Plain text
#: en/git-fetch.txt:16
#, ignore-ellipsis, no-wrap, placeholders:'--multiple':'--all', priority:220
msgid ""
"'git fetch' [<options>] [<repository> [<refspec>...]]\n"
"'git fetch' [<options>] <group>\n"
"'git fetch' --multiple [<options>] [(<repository> | <group>)...]\n"
"'git fetch' --all [<options>]\n"
msgstr ""
"'git fetch' [<选项>] [<仓库> [<引用规范>...]]\n"
"'git fetch' [<选项>] <组>\n"
"'git fetch' --multiple [<选项>] [(<仓库> | <组>)...]\n"
"'git fetch' --all [<选项>]\n"

#. type: Plain text
#: en/git-fetch.txt:24
#, priority:220
msgid "Fetch branches and/or tags (collectively, \"refs\") from one or more other repositories, along with the objects necessary to complete their histories. Remote-tracking branches are updated (see the description of <refspec> below for ways to control this behavior)."
msgstr "从一个或多个其它仓库获取分支和/或标记（统称为 \"refs\"），以及完成其历史所需的对象。 远程跟踪的分支会被更新（关于控制这种行为的方法，请参见下面 <引用规范> 的描述）。"

#. type: Plain text
#: en/git-fetch.txt:32
#, placeholders:'--tags':'--no-tags', priority:220
msgid "By default, any tag that points into the histories being fetched is also fetched; the effect is to fetch tags that point at branches that you are interested in. This default behavior can be changed by using the --tags or --no-tags options or by configuring remote.<name>.tagOpt. By using a refspec that fetches tags explicitly, you can fetch tags that do not point into branches you are interested in as well."
msgstr "默认情况下，任何指向被获取的历史的标签也会被获取；其效果是获取指向你感兴趣的分支的标签。 这个默认行为可以通过使用 --tags 或 --no-tags 选项或者配置 remote.<远程仓库名称>.tagOpt 来改变。 通过使用明确获取标签的引用规范，你也可以获取那些没有指向你感兴趣的分支的标签。"

#. type: Plain text
#: en/git-fetch.txt:37
#, placeholders:'linkgit:git-config[1]', priority:220
msgid "'git fetch' can fetch from either a single named repository or URL, or from several repositories at once if <group> is given and there is a remotes.<group> entry in the configuration file. (See linkgit:git-config[1])."
msgstr "'git fetch' 可以从一个命名的仓库或 URL 中获取，或者如果给定了 <组> 并且在配置文件中有 remotes.<组> 项，则可以同时从几个仓库获取。 (参见 linkgit:git-config[1]）。"

#. type: Plain text
#: en/git-fetch.txt:40
#, priority:220
msgid "When no remote is specified, by default the `origin` remote will be used, unless there's an upstream branch configured for the current branch."
msgstr "当没有指定远程仓库时，默认情况下将使用 `origin` 远程仓库，除非有一个上游分支配置在当前分支上。"

#. type: Plain text
#: en/git-fetch.txt:44
#, placeholders:'.git/FETCH_HEAD':'linkgit:git-pull[1]', priority:220
msgid "The names of refs that are fetched, together with the object names they point at, are written to `.git/FETCH_HEAD`. This information may be used by scripts or other git commands, such as linkgit:git-pull[1]."
msgstr "被获取的引用名称，以及它们所指向的对象名称，被写到 `.git/FETCH_HEAD`。 这些信息可以被脚本或其他 git 命令使用，比如linkgit:git-pull[1]。"

#. type: Plain text
#: en/git-fetch.txt:54
#, priority:220
msgid "Read refspecs, one per line, from stdin in addition to those provided as arguments. The \"tag <name>\" format is not supported."
msgstr "从stdin中读取引用规范，每行一个，除了作为参数提供的那些之外。不支持 \"标签 <名称>\" 格式。"

#. type: Title -
#: en/git-fetch.txt:59
#, no-wrap, placeholders:'[[CRTB]]', priority:220
msgid "CONFIGURED REMOTE-TRACKING BRANCHES[[CRTB]]"
msgstr "配置的远程跟踪分支 [[CRTB]]"

#. type: Plain text
#: en/git-fetch.txt:65
#, priority:220
msgid "You often interact with the same remote repository by regularly and repeatedly fetching from it. In order to keep track of the progress of such a remote repository, `git fetch` allows you to configure `remote.<repository>.fetch` configuration variables."
msgstr "你通过经常定期和重复地从同一个远程仓库取东西来与之互动。 为了跟踪这种远程仓库的进度，`git fetch` 允许你配置 `remote.<仓库>.fetch` 配置变量。"

#. type: Plain text
#: en/git-fetch.txt:67
#, priority:220
msgid "Typically such a variable may look like this:"
msgstr "一般来说，这种变量可能看起来像这样："

#. type: delimited block -
#: en/git-fetch.txt:71
#, no-wrap, priority:220
msgid ""
"[remote \"origin\"]\n"
"\tfetch = +refs/heads/*:refs/remotes/origin/*\n"
msgstr ""
"[remote \"origin\"]\n"
"\tfetch = +refs/heads/*:refs/remotes/origin/*\n"

#. type: Plain text
#: en/git-fetch.txt:74
#, priority:220
msgid "This configuration is used in two ways:"
msgstr "这种配置有两种使用方式："

#. type: Plain text
#: en/git-fetch.txt:84
#, priority:220
msgid "When `git fetch` is run without specifying what branches and/or tags to fetch on the command line, e.g. `git fetch origin` or `git fetch`, `remote.<repository>.fetch` values are used as the refspecs--they specify which refs to fetch and which local refs to update. The example above will fetch all branches that exist in the `origin` (i.e. any ref that matches the left-hand side of the value, `refs/heads/*`) and update the corresponding remote-tracking branches in the `refs/remotes/origin/*` hierarchy."
msgstr "当 `git fetch` 运行时，没有在命令行中指定要取哪些分支和/或标记，例如 `git fetch origin` 或 `git fetch`，`remote.<仓库>.fetch` 值被用作引用规范——它们指定要取哪些引用和要更新哪些本地引用。 上面的例子将获取所有存在于 `origin` 中的分支（即任何与数值左边的`refs/heads/*`相匹配的引用），并更新 `refs/remotes/origin/*` 层次结构中相应的远程跟踪的分支。"

#. type: Plain text
#: en/git-fetch.txt:101
#, priority:220
msgid "When `git fetch` is run with explicit branches and/or tags to fetch on the command line, e.g. `git fetch origin master`, the <refspec>s given on the command line determine what are to be fetched (e.g. `master` in the example, which is a short-hand for `master:`, which in turn means \"fetch the 'master' branch but I do not explicitly say what remote-tracking branch to update with it from the command line\"), and the example command will fetch _only_ the 'master' branch. The `remote.<repository>.fetch` values determine which remote-tracking branch, if any, is updated. When used in this way, the `remote.<repository>.fetch` values do not have any effect in deciding _what_ gets fetched (i.e. the values are not used as refspecs when the command-line lists refspecs); they are only used to decide _where_ the refs that are fetched are stored by acting as a mapping."
msgstr "当 `git fetch` 运行时，命令行上有明确的要取的分支和/或标记，例如 `git fetch origin master`，命令行上给出的所有 <引用规范> 决定了要取的是什么（例如例子中的 `master` 是 `master:` 的简称，意思是 \"获取 'master' 分支，但我没有明确说要在命令行中更新哪个远程跟踪分支\"），而这个例子的命令将「只」获取 'master' 分支。 `remote.<仓库>.fetch`值决定了哪个远程跟踪分支（如果有的话）被更新。 当以这种方式使用时，`remote.<仓库>.fetch` 值对决定获取什么没有任何影响（即当命令行列出引用规范时，这些值不会被用作引用规范）；它们只是通过作为一个映射来决定获取的引用被存储在哪里。"

#. type: Plain text
#: en/git-fetch.txt:105
#, placeholders:'`--refmap=', priority:220
msgid "The latter use of the `remote.<repository>.fetch` values can be overridden by giving the `--refmap=<refspec>` parameter(s) on the command line."
msgstr "后者对 `remote.<仓库>.fetch` 值的使用可以通过在命令行中给出 `--refmap=<引用规范>` 参数去覆盖。"

#. type: Title -
#: en/git-fetch.txt:107
#, no-wrap, priority:220
msgid "PRUNING"
msgstr "剪枝"

#. type: Plain text
#: en/git-fetch.txt:112
#, priority:220
msgid "Git has a default disposition of keeping data unless it's explicitly thrown away; this extends to holding onto local references to branches on remotes that have themselves deleted those branches."
msgstr "Git默认保留数据，除非它被明确地扔掉；这延伸到保留对远程分支的本地引用，而这些分支本身已经被删除。"

#. type: Plain text
#: en/git-fetch.txt:118
#, placeholders:'--contains', priority:220
msgid "If left to accumulate, these stale references might make performance worse on big and busy repos that have a lot of branch churn, and e.g. make the output of commands like `git branch -a --contains <commit>` needlessly verbose, as well as impacting anything else that'll work with the complete set of known references."
msgstr "如果任其积累，这些陈旧的引用可能会使大型繁忙仓库的性能变差，例如，使 `git branch -a --contains <提交>` 等命令的输出不必要地冗长，以及影响其他任何与完整的已知引用有关的工作。"

#. type: Plain text
#: en/git-fetch.txt:121
#, priority:220
msgid "These remote-tracking references can be deleted as a one-off with either of:"
msgstr "这些远程跟踪引用可以通过以下两种方式一次性删除："

#. type: delimited block -
#: en/git-fetch.txt:125
#, no-wrap, placeholders:'--prune', priority:220
msgid ""
"# While fetching\n"
"$ git fetch --prune <name>\n"
msgstr ""
"# 在获取的时候\n"
"$ git fetch --prune <名称>\n"

#. type: delimited block -
#: en/git-fetch.txt:128
#, no-wrap, priority:220
msgid ""
"# Only prune, don't fetch\n"
"$ git remote prune <name>\n"
msgstr ""
"# 只修剪，不获取\n"
"$ git remote prune <名称>\n"

#. type: Plain text
#: en/git-fetch.txt:134
#, placeholders:'fetch.prune':'linkgit:git-config[1]', priority:220
msgid "To prune references as part of your normal workflow without needing to remember to run that, set `fetch.prune` globally, or `remote.<name>.prune` per-remote in the config. See linkgit:git-config[1]."
msgstr "要把修剪引用作为正常工作流程的一部分，而不需要记住运行该程序，可以在全局设置 `fetch.prune`，或者在配置中设置 `remote.<名称>.prune`，为每个远程仓库进行设置。见linkgit:git-config[1]。"

#. type: Plain text
#: en/git-fetch.txt:139
#, placeholders:'<<CRTB,', priority:220
msgid "Here's where things get tricky and more specific. The pruning feature doesn't actually care about branches, instead it'll prune local <--> remote-references as a function of the refspec of the remote (see `<refspec>` and <<CRTB,CONFIGURED REMOTE-TRACKING BRANCHES>> above)."
msgstr "这里是事情变得棘手和更具体的地方。修剪功能实际上并不关心分支，相反，它将修剪本地<-->远程引用，作为远程的引用规范的函数（见上面的`<引用规范>`和上面的<<CRTB,配置远程跟踪分支>>）。"

#. type: Plain text
#: en/git-fetch.txt:145
#, placeholders:'--prune', priority:220
msgid "Therefore if the refspec for the remote includes e.g. `refs/tags/*:refs/tags/*`, or you manually run e.g. `git fetch --prune <name> \"refs/tags/*:refs/tags/*\"` it won't be stale remote tracking branches that are deleted, but any local tag that doesn't exist on the remote."
msgstr "因此，如果远程的引用规范包括例如 `refs/tags/*:refs/tags/*`这样的规范，或者你手动运行例如 `git fetch --prune <名称> \"refs/tags/*:refs/tags/*\"`，那么被删除的就不是过时的远程跟踪分支，而是远程上不存在的任何本地标签。"

#. type: Plain text
#: en/git-fetch.txt:150
#, priority:220
msgid "This might not be what you expect, i.e. you want to prune remote `<name>`, but also explicitly fetch tags from it, so when you fetch from it you delete all your local tags, most of which may not have come from the `<name>` remote in the first place."
msgstr "这可能不是你所期望的，即你想修剪远程的 `<名称>`，但也明确地从它那里获取标签，所以当你从它那里获取时，你会删除所有的本地标签，其中大部分可能首先不是来自远程的 `<名称>`。"

#. type: Plain text
#: en/git-fetch.txt:154
#, priority:220
msgid "So be careful when using this with a refspec like `refs/tags/*:refs/tags/*`, or any other refspec which might map references from multiple remotes to the same local namespace."
msgstr "因此，当与 `refs/tags/*:refs/tags/*` 这样的引用规范一起使用时要小心，或者任何其他可能将多个远程的引用映射到同一本地命名空间的引用规范。"

#. type: Plain text
#: en/git-fetch.txt:161
#, placeholders:'`--prune-tags`':'`--prune`':'fetch.pruneTags':'linkgit:git-config[1]', priority:220
msgid "Since keeping up-to-date with both branches and tags on the remote is a common use-case the `--prune-tags` option can be supplied along with `--prune` to prune local tags that don't exist on the remote, and force-update those tags that differ. Tag pruning can also be enabled with `fetch.pruneTags` or `remote.<name>.pruneTags` in the config. See linkgit:git-config[1]."
msgstr "由于在远程保持最新的分支和标签是一个常见的使用情况，`--prune-tags` 选项可以和 `--prune` 一起使用，以修剪在远程不存在的本地标签，并强制更新那些不同的标签。标签修剪也可以通过配置中的 `fetch.pruneTags` 或 `remote.<名称>.pruneTags` 启用。见linkgit:git-config[1]。"

#. type: Plain text
#: en/git-fetch.txt:165
#, placeholders:'`--prune-tags`', priority:220
msgid "The `--prune-tags` option is equivalent to having `refs/tags/*:refs/tags/*` declared in the refspecs of the remote. This can lead to some seemingly strange interactions:"
msgstr "`--prune-tags` 选项相当于在远程的引用规范中声明 `refs/tags/*:refs/tags/*` 。这可能会导致一些看起来很奇怪的结果："

#. type: delimited block -
#: en/git-fetch.txt:170
#, no-wrap, placeholders:'--no-tags':'--no-tags':'--prune-tags', priority:220
msgid ""
"# These both fetch tags\n"
"$ git fetch --no-tags origin 'refs/tags/*:refs/tags/*'\n"
"$ git fetch --no-tags --prune-tags origin\n"
msgstr ""
"# 这两个命令都可以用来获取标签\n"
"$ git fetch --no-tags origin 'refs/tags/*:refs/tags/*'\n"
"$ git fetch --no-tags --prune-tags origin\n"

#. type: Plain text
#: en/git-fetch.txt:176
#, placeholders:'`--prune`', priority:220
msgid "The reason it doesn't error out when provided without `--prune` or its config versions is for flexibility of the configured versions, and to maintain a 1=1 mapping between what the command line flags do, and what the configuration versions do."
msgstr "在没有 `--prune` 或其配置的情况下，它不会出错的原因是为了配置的灵活性，以及在命令行标志和配置之间保持 1=1 的映射。"

#. type: Plain text
#: en/git-fetch.txt:181
#, placeholders:'fetch.pruneTags':'--prune`':'`--prune`', priority:220
msgid "It's reasonable to e.g. configure `fetch.pruneTags=true` in `~/.gitconfig` to have tags pruned whenever `git fetch --prune` is run, without making every invocation of `git fetch` without `--prune` an error."
msgstr "例如，在 `~/.gitconfig` 中配置 `fetch.pruneTags=true`，以便在运行 `git fetch --prune` 时修剪标签，这是很合理的，不会使每次调用 `git fetch` 而没有 `--prune` 时都出现错误。"

#. type: Plain text
#: en/git-fetch.txt:185
#, placeholders:'`--prune-tags`', priority:220
msgid "Pruning tags with `--prune-tags` also works when fetching a URL instead of a named remote. These will all prune tags not found on origin:"
msgstr "使用 `--prune-tags` 修剪标签，在获取一个URL而不是一个命名的远程时也能发挥作用。这些都会修剪在原点没有发现的标签："

#. type: delimited block -
#: en/git-fetch.txt:191
#, no-wrap, placeholders:'--prune':'--prune-tags':'--prune':'--prune':'--prune-tags':'--prune', priority:220
msgid ""
"$ git fetch origin --prune --prune-tags\n"
"$ git fetch origin --prune 'refs/tags/*:refs/tags/*'\n"
"$ git fetch <url-of-origin> --prune --prune-tags\n"
"$ git fetch <url-of-origin> --prune 'refs/tags/*:refs/tags/*'\n"
msgstr ""
"$ git fetch origin --prune --prune-tags\n"
"$ git fetch origin --prune 'refs/tags/*:refs/tags/*'\n"
"$ git fetch <origin 的地址> --prune --prune-tags\n"
"$ git fetch <origin 的 地址> --prune 'refs/tags/*:refs/tags/*'\n"

#. type: Plain text
#: en/git-fetch.txt:199
#, priority:220
msgid "The output of \"git fetch\" depends on the transport method used; this section describes the output when fetching over the Git protocol (either locally or via ssh) and Smart HTTP protocol."
msgstr "\"git fetch\" 的输出取决于所使用的传输方式；本节描述了通过 Git 协议（本地或通过 ssh）和智能 HTTP 协议获取时的输出。"

#. type: Plain text
#: en/git-fetch.txt:202
#, priority:220
msgid "The status of the fetch is output in tabular form, with each line representing the status of a single ref. Each line is of the form:"
msgstr "获取的状态以表格的形式输出，每一行代表一个引用的状态。每一行的形式是："

#. type: delimited block -
#: en/git-fetch.txt:205
#, no-wrap, priority:220
msgid " <flag> <summary> <from> -> <to> [<reason>]\n"
msgstr " <标志> <概述> <起始> -> <结束> [<原因>]\n"

#. type: Plain text
#: en/git-fetch.txt:211
#, placeholders:'`--porcelain`', priority:220
msgid "When using `--porcelain`, the output format is intended to be machine-parseable. In contrast to the human-readable output formats it thus prints to standard output instead of standard error. Each line is of the form:"
msgstr "当使用 `--porcelain` 时，输出格式的目的是让机器可以解析。与人类可读的输出格式不同，它将打印到标准输出而不是标准错误。每一行都是这样的形式："

#. type: delimited block -
#: en/git-fetch.txt:214
#, no-wrap, priority:220
msgid "<flag> <old-object-id> <new-object-id> <local-reference>\n"
msgstr "<标志> <旧对象ID> <新对象ID> <本地引用>\n"

#. type: Plain text
#: en/git-fetch.txt:218
#, placeholders:'--verbose', priority:220
msgid "The status of up-to-date refs is shown only if the --verbose option is used."
msgstr "只有在使用 --verbose 选项时，才会显示最新的引用状态。"

#. type: Plain text
#: en/git-fetch.txt:223
#, placeholders:'fetch.output', priority:220
msgid "In compact output mode, specified with configuration variable fetch.output, if either entire `<from>` or `<to>` is found in the other string, it will be substituted with `*` in the other string. For example, `master -> origin/master` becomes `master -> origin/*`."
msgstr "在紧凑输出模式下，通过配置变量 fetch.output 指定，如果在另一个字符串中发现整个 `<起点>` 或 `<终点>`，它将被替换成另一个字符串中的 `*`。例如，`master -> origin/master` 变成 `master -> origin/*`。"

#. type: Labeled list
#: en/git-fetch.txt:224 en/git-push.txt:460
#, no-wrap, priority:220
msgid "flag"
msgstr "标志"

#. type: Plain text
#: en/git-fetch.txt:226 en/git-push.txt:462
#, priority:220
msgid "A single character indicating the status of the ref:"
msgstr "表示引用状态的单个字符："

#. type: Labeled list
#: en/git-fetch.txt:226 en/git-push.txt:462
#, no-wrap, priority:220
msgid "(space)"
msgstr "（空格）"

#. type: Plain text
#: en/git-fetch.txt:227
#, priority:220
msgid "for a successfully fetched fast-forward;"
msgstr "表示成功的快速合并；"

#. type: Labeled list
#: en/git-fetch.txt:227 en/git-push.txt:463
#, no-wrap, priority:220
msgid "`+`"
msgstr "`+`"

#. type: Plain text
#: en/git-fetch.txt:228 en/git-push.txt:464
#, priority:220
msgid "for a successful forced update;"
msgstr "表示一个成功的强制更新；"

#. type: Labeled list
#: en/git-fetch.txt:228 en/git-push.txt:464
#, ignore-same, no-wrap, priority:220
msgid "`-`"
msgstr "`-`"

#. type: Plain text
#: en/git-fetch.txt:229
#, priority:220
msgid "for a successfully pruned ref;"
msgstr "表示成功修剪引用；"

#. type: Labeled list
#: en/git-fetch.txt:229
#, ignore-same, no-wrap, priority:220
msgid "`t`"
msgstr "`t`"

#. type: Plain text
#: en/git-fetch.txt:230
#, priority:220
msgid "for a successful tag update;"
msgstr "表示成功更新标签；"

#. type: Labeled list
#: en/git-fetch.txt:230 en/git-push.txt:465
#, no-wrap, priority:220
msgid "`*`"
msgstr "`*`"

#. type: Plain text
#: en/git-fetch.txt:231
#, priority:220
msgid "for a successfully fetched new ref;"
msgstr "表示成功获取新引用；"

#. type: Labeled list
#: en/git-fetch.txt:231 en/git-push.txt:466
#, no-wrap, priority:220
msgid "`!`"
msgstr "`!`"

#. type: Plain text
#: en/git-fetch.txt:232
#, priority:220
msgid "for a ref that was rejected or failed to update; and"
msgstr "表示被拒绝或更新失败的引用；以及"

#. type: Labeled list
#: en/git-fetch.txt:232 en/git-push.txt:467
#, no-wrap, priority:220
msgid "`=`"
msgstr "`=`"

#. type: Plain text
#: en/git-fetch.txt:233
#, priority:220
msgid "for a ref that was up to date and did not need fetching."
msgstr "表示一个最新的、不需要获取的引用。"

#. type: Labeled list
#: en/git-fetch.txt:234 en/git-push.txt:469
#, no-wrap, priority:220
msgid "summary"
msgstr "概述"

#. type: Plain text
#: en/git-fetch.txt:239
#, ignore-ellipsis, priority:220
msgid "For a successfully fetched ref, the summary shows the old and new values of the ref in a form suitable for using as an argument to `git log` (this is `<old>..<new>` in most cases, and `<old>...<new>` for forced non-fast-forward updates)."
msgstr "对于一个成功获取的引用，摘要以适合作为 `git log` 参数的形式显示该引用的新旧值（在大多数情况下是 `<旧>..<新>`，对于强制非快速合并是 `<旧>...<新>`）。"

#. type: Labeled list
#: en/git-fetch.txt:240 en/git-push.txt:497
#, no-wrap, priority:220
msgid "from"
msgstr "起始"

#. type: Plain text
#: en/git-fetch.txt:244
#, priority:220
msgid "The name of the remote ref being fetched from, minus its `refs/<type>/` prefix. In the case of deletion, the name of the remote ref is \"(none)\"."
msgstr "被获取的远程引用的名称，减去其`refs/<类型>/`前缀。在删除的情况下，远程引用的名称是 \"(none)\"。"

#. type: Labeled list
#: en/git-fetch.txt:245 en/git-push.txt:502
#, no-wrap, priority:220
msgid "to"
msgstr "结束"

#. type: Plain text
#: en/git-fetch.txt:248
#, priority:220
msgid "The name of the local ref being updated, minus its `refs/<type>/` prefix."
msgstr "被更新的本地引用的名称，去掉其 `refs/<类型>/` 前缀。"

#. type: Labeled list
#: en/git-fetch.txt:249 en/git-push.txt:506
#, no-wrap, priority:220
msgid "reason"
msgstr "原因"

#. type: Plain text
#: en/git-fetch.txt:253
#, priority:220
msgid "A human-readable explanation. In the case of successfully fetched refs, no explanation is needed. For a failed ref, the reason for failure is described."
msgstr "一个人类可读的解释。如果是成功获取的引用，不需要解释。对于失败的引用，将描述失败的原因。"

#. type: Plain text
#: en/git-fetch.txt:258
#, priority:220
msgid "Update the remote-tracking branches:"
msgstr "更新远程追踪的分支："

#. type: delimited block -
#: en/git-fetch.txt:261
#, no-wrap, priority:220
msgid "$ git fetch origin\n"
msgstr "$ git fetch origin\n"

#. type: Plain text
#: en/git-fetch.txt:267
#, priority:220
msgid "The above command copies all branches from the remote `refs/heads/` namespace and stores them to the local `refs/remotes/origin/` namespace, unless the `remote.<repository>.fetch` option is used to specify a non-default refspec."
msgstr "上述命令从远程的 `refs/heads/` 命名空间复制所有分支，并存储到本地的 `refs/remotes/origin/` 命名空间，除非使用 `remote.<仓库>.fetch` 选项来指定一个非默认的引用规范。"

#. type: Plain text
#: en/git-fetch.txt:269
#, priority:220
msgid "Using refspecs explicitly:"
msgstr "明确使用引用规范："

#. type: delimited block -
#: en/git-fetch.txt:272
#, no-wrap, priority:220
msgid "$ git fetch origin +seen:seen maint:tmp\n"
msgstr "$ git fetch origin +seen:seen maint:tmp\n"

#. type: Plain text
#: en/git-fetch.txt:277
#, priority:220
msgid "This updates (or creates, as necessary) branches `seen` and `tmp` in the local repository by fetching from the branches (respectively) `seen` and `maint` from the remote repository."
msgstr "这通过从远程存储库的分支（分别）获取 `seen` 和 `maint` 来更新（或根据需要创建）本地存储库中的分支 `seen` 和 `tmp`。"

#. type: Plain text
#: en/git-fetch.txt:280
#, priority:220
msgid "The `seen` branch will be updated even if it does not fast-forward, because it is prefixed with a plus sign; `tmp` will not be."
msgstr "即使不快进，`seen` 分支也会被更新，因为它的前缀是加号；`tmp` 则不会。"

#. type: Plain text
#: en/git-fetch.txt:283
#, priority:220
msgid "Peek at a remote's branch, without configuring the remote in your local repository:"
msgstr "窥视一个远程的分支，而不需要在你的本地版本库中配置远程："

#. type: delimited block -
#: en/git-fetch.txt:287
#, no-wrap, placeholders:'git.kernel.org':'git.git':'FETCH_HEAD', priority:220
msgid ""
"$ git fetch git://git.kernel.org/pub/scm/git/git.git maint\n"
"$ git log FETCH_HEAD\n"
msgstr ""
"$ git fetch git://git.kernel.org/pub/scm/git/git.git maint\n"
"$ git log FETCH_HEAD\n"

#. type: Plain text
#: en/git-fetch.txt:294
#, placeholders:'git.kernel.org':'git.git':'FETCH_HEAD':'linkgit:git-log[1]':'linkgit:git-gc[1]', priority:220
msgid "The first command fetches the `maint` branch from the repository at `git://git.kernel.org/pub/scm/git/git.git` and the second command uses `FETCH_HEAD` to examine the branch with linkgit:git-log[1]. The fetched objects will eventually be removed by git's built-in housekeeping (see linkgit:git-gc[1])."
msgstr "第一条命令从 `git://git.kernel.org/pub/scm/git.git` 的存储库中获取 `maint` 分支，第二条命令使用 `FETCH_HEAD` 用 linkgit:git-log[1] 来检查该分支。 取出的对象最终会被 git 内置的内务管理删除（见 linkgit:git-gc[1]）。"

#. type: Plain text
#: en/git-fetch.txt:310
#, placeholders:'--recurse-submodules':'$GIT_DIR', priority:220
msgid "Using --recurse-submodules can only fetch new commits in submodules that are present locally e.g. in `$GIT_DIR/modules/`. If the upstream adds a new submodule, that submodule cannot be fetched until it is cloned e.g. by `git submodule update`. This is expected to be fixed in a future Git version."
msgstr "使用 --recurse-submodules 只能获取本地存在的子模块中的新提交，例如在 `$GIT_DIR/modules/`。如果上游添加了一个新的子模块，该子模块不能被获取，直到它被克隆，例如，通过`git submodule update`。这个问题有望在未来的 Git 版本中被修复。"

#. type: Title =
#: en/git-filter-branch.txt:2
#, ignore-same, no-wrap, priority:90
msgid "git-filter-branch(1)"
msgstr "git-filter-branch(1)"

#. type: Plain text
#: en/git-filter-branch.txt:7
#, placeholders:'git-filter-branch', priority:90
msgid "git-filter-branch - Rewrite branches"
msgstr "git-filter-branch - 重写分支"

#. type: Plain text
#: en/git-filter-branch.txt:18
#, ignore-ellipsis, no-wrap, placeholders:'git filter-branch':'[--setup':'[--subdirectory-filter':'[--env-filter':'[--tree-filter':'[--index-filter':'[--parent-filter':'[--msg-filter':'[--commit-filter':'[--tag-name-filter':'[--prune-empty]':'[--original':'--force]':'[--state-branch', priority:90
msgid ""
"'git filter-branch' [--setup <command>] [--subdirectory-filter <directory>]\n"
"\t[--env-filter <command>] [--tree-filter <command>]\n"
"\t[--index-filter <command>] [--parent-filter <command>]\n"
"\t[--msg-filter <command>] [--commit-filter <command>]\n"
"\t[--tag-name-filter <command>] [--prune-empty]\n"
"\t[--original <namespace>] [-d <directory>] [-f | --force]\n"
"\t[--state-branch <branch>] [--] [<rev-list-options>...]\n"
msgstr ""
"'git filter-branch' [--setup <命令>] [--subdirectory-filter <目录>]\n"
"\t[--env-filter <命令>] [--tree-filter <命令>]\n"
"\t[--index-filter <命令>] [--parent-filter <命令>]\n"
"\t[--msg-filter <命令>] [--commit-filter <命令>]\n"
"\t[--tag-name-filter <命令>] [--prune-empty]\n"
"\t[--original <命名空间>] [-d <目录>] [-f | --force]\n"
"\t[--state-branch <分支>] [--] [<rev-list-options>...]\n"

#. type: Title -
#: en/git-filter-branch.txt:20 en/git-pack-redundant.txt:15
#, no-wrap, priority:90
msgid "WARNING"
msgstr "警告"

#. type: Plain text
#: en/git-filter-branch.txt:31
#, placeholders:'git filter-branch':'https://github.com/newren/git-filter-repo/[':'git filter-repo':'git filter-branch':'<<SAFETY>>':'<<PERFORMANCE>>', priority:90
msgid "'git filter-branch' has a plethora of pitfalls that can produce non-obvious manglings of the intended history rewrite (and can leave you with little time to investigate such problems since it has such abysmal performance). These safety and performance issues cannot be backward compatibly fixed and as such, its use is not recommended. Please use an alternative history filtering tool such as https://github.com/newren/git-filter-repo/[git filter-repo]. If you still need to use 'git filter-branch', please carefully read <<SAFETY>> (and <<PERFORMANCE>>) to learn about the land mines of filter-branch, and then vigilantly avoid as many of the hazards listed there as reasonably possible."
msgstr "'git filter-branch' 存在大量隐患，可能会对预期的历史重写产生不明显的误差（而且由于其性能糟糕，你几乎没有时间去研究这些问题）。 这些安全和性能问题无法向后兼容修复，因此不建议使用。 请使用其他历史过滤工具，如 https://github.com/newren/git-filter-repo/[git filter-repo]。 如果您仍然需要使用 'git filter-branch'，请仔细阅读 <<SAFETY>>（和 <<PERFORMANCE>>）以了解 filter-branch 的隐患，然后尽可能合理地避免其中列出的危险。"

#. type: Plain text
#: en/git-filter-branch.txt:40
#, priority:90
msgid "Lets you rewrite Git revision history by rewriting the branches mentioned in the <rev-list-options>, applying custom filters on each revision. Those filters can modify each tree (e.g. removing a file or running a perl rewrite on all files) or information about each commit. Otherwise, all information (including original commit times or merge information) will be preserved."
msgstr "让你可以通过重写 <rev-list 选项> 中提到的分支来重写 Git 修订历史，并对每个修订应用自定义过滤器。 这些过滤器可以修改每棵树（例如删除文件或在所有文件上运行 perl 重写）或每个提交的信息。 否则，所有信息（包括原始提交时间或合并信息）都将被保留。"

#. type: Plain text
#: en/git-filter-branch.txt:47
#, priority:90
msgid "The command will only rewrite the _positive_ refs mentioned in the command line (e.g. if you pass 'a..b', only 'b' will be rewritten). If you specify no filters, the commits will be recommitted without any changes, which would normally have no effect. Nevertheless, this may be useful in the future for compensating for some Git bugs or such, therefore such a usage is permitted."
msgstr "该命令只会重写命令行中提到的 _positive_ refs（例如，如果您传递 'a..b'，则只会重写 'b'）。 如果不指定过滤器，提交将在不做任何改动的情况下重新提交，这通常不会产生任何影响。 不过，这在将来补偿某些 Git bug 或类似问题时可能会有用，因此允许使用这种方法。"

#. type: Plain text
#: en/git-filter-branch.txt:52
#, priority:90
msgid "*NOTE*: This command honors `.git/info/grafts` file and refs in the `refs/replace/` namespace. If you have any grafts or replacement refs defined, running this command will make them permanent."
msgstr "*注意*： 此命令尊重 `.git/info/grafts` 文件和 `refs/replace/` 命名空间中的引用。如果您定义了任何移植物或替换引用，运行此命令将使其永久生效。"

#. type: Plain text
#: en/git-filter-branch.txt:61
#, placeholders:'linkgit:git-rebase[1]', priority:90
msgid "*WARNING*! The rewritten history will have different object names for all the objects and will not converge with the original branch. You will not be able to easily push and distribute the rewritten branch on top of the original branch. Please do not use this command if you do not know the full implications, and avoid using it anyway, if a simple single commit would suffice to fix your problem. (See the \"RECOVERING FROM UPSTREAM REBASE\" section in linkgit:git-rebase[1] for further information about rewriting published history.)"
msgstr "*警告*！重写后的历史记录中，所有对象的名称都会不同，并且不会与原始分支趋同。对象的名称也会不同，并且不会与原始分支一致。 您将无法在原始分支的基础上推送和分发重写分支。原始分支。 如果不了解该命令的全部影响，请不要使用它。如果简单的单次提交就能解决您的问题，请尽量避免使用该命令。就能解决问题的话，请避免使用该命令。 (请参阅 linkgit:git-rebase[1] 中的 \"RECOVERING FROM UPSTREAM\" 重写已发布历史。）"

#. type: Plain text
#: en/git-filter-branch.txt:65
#, priority:90
msgid "Always verify that the rewritten version is correct: The original refs, if different from the rewritten ones, will be stored in the namespace 'refs/original/'."
msgstr "请务必验证重写版本是否正确：原始参考文件（如果与重写版本不同）将存储在命名空间 'refs/original/' 中。"

#. type: Plain text
#: en/git-filter-branch.txt:69
#, placeholders:'`-d`', priority:90
msgid "Note that since this operation is very I/O expensive, it might be a good idea to redirect the temporary directory off-disk with the `-d` option, e.g. on tmpfs. Reportedly the speedup is very noticeable."
msgstr "需要注意的是，由于该操作的 I/O 成本很高，因此最好使用 `-d` 选项将临时目录重定向到磁盘外，例如在 tmpfs 上。 据报道，速度提升非常明显。"

#. type: Title ~
#: en/git-filter-branch.txt:72
#, no-wrap, priority:90
msgid "Filters"
msgstr "筛选"

#. type: Plain text
#: en/git-filter-branch.txt:84
#, placeholders:'$GIT_COMMIT':'GIT_AUTHOR_NAME':'GIT_AUTHOR_EMAIL':'GIT_AUTHOR_DATE':'GIT_COMMITTER_NAME':'GIT_COMMITTER_EMAIL':'GIT_COMMITTER_DATE':'linkgit:git-commit-tree[1]', priority:90
msgid "The filters are applied in the order as listed below. The <command> argument is always evaluated in the shell context using the 'eval' command (with the notable exception of the commit filter, for technical reasons). Prior to that, the `$GIT_COMMIT` environment variable will be set to contain the id of the commit being rewritten. Also, GIT_AUTHOR_NAME, GIT_AUTHOR_EMAIL, GIT_AUTHOR_DATE, GIT_COMMITTER_NAME, GIT_COMMITTER_EMAIL, and GIT_COMMITTER_DATE are taken from the current commit and exported to the environment, in order to affect the author and committer identities of the replacement commit created by linkgit:git-commit-tree[1] after the filters have run."
msgstr "过滤器的应用顺序如下。 <命令> 参数总是在 shell 上下文中使用 'eval' 命令进行评估（由于技术原因，提交过滤器是个明显的例外）。 在此之前，`$GIT_COMMIT` 环境变量将被设置为包含被改写提交的 id。 此外，GIT_AUTHOR_NAME、GIT_AUTHOR_EMAIL、GIT_AUTHOR_DATE、GIT_COMMITTER_NAME、GIT_COMMITTER_EMAIL 和 GIT_COMMITTER_DATE 会从当前提交中提取并导出到环境中，以便在过滤器运行后影响 linkgit:git-commit-tree[1] 创建的替换提交的作者和提交者身份。"

#. type: Plain text
#: en/git-filter-branch.txt:87
#, priority:90
msgid "If any evaluation of <command> returns a non-zero exit status, the whole operation will be aborted."
msgstr "如果对 <命令> 的任何评估返回非零的退出状态，则整个操作将被终止。"

#. type: Plain text
#: en/git-filter-branch.txt:93
#, priority:90
msgid "A 'map' function is available that takes an \"original sha1 id\" argument and outputs a \"rewritten sha1 id\" if the commit has been already rewritten, and \"original sha1 id\" otherwise; the 'map' function can return several ids on separate lines if your commit filter emitted multiple commits."
msgstr "我们提供了一个 'map' 函数，它接收 '原始 sha1 id' 参数，如果提交已被改写，则输出 '改写后的 sha1 id'，否则输出 '原始 sha1 id'。"

#. type: Labeled list
#: en/git-filter-branch.txt:98
#, no-wrap, placeholders:'--setup', priority:90
msgid "--setup <command>"
msgstr "--setup <命令>"

#. type: Plain text
#: en/git-filter-branch.txt:104
#, priority:90
msgid "This is not a real filter executed for each commit but a one time setup just before the loop. Therefore no commit-specific variables are defined yet. Functions or variables defined here can be used or modified in the following filter steps except the commit filter, for technical reasons."
msgstr "这不是为每次提交执行的真正过滤器，而是在循环之前的一次性设置。因此还没有定义特定于提交的变量。 由于技术原因，此处定义的函数或变量可以在除提交过滤器之外的后续过滤器步骤中使用或修改。"

#. type: Labeled list
#: en/git-filter-branch.txt:105
#, no-wrap, placeholders:'--subdirectory-filter', priority:90
msgid "--subdirectory-filter <directory>"
msgstr "--subdirectory-filter <目录>"

#. type: Plain text
#: en/git-filter-branch.txt:109
#, placeholders:'<<Remap_to_ancestor>>', priority:90
msgid "Only look at the history which touches the given subdirectory. The result will contain that directory (and only that) as its project root. Implies <<Remap_to_ancestor>>."
msgstr "只查看涉及给定子目录的历史记录。 结果将包含作为项目根目录的该目录（且仅包含该目录）。隐含 <<Remap_to_ancestor>>。"

#. type: Labeled list
#: en/git-filter-branch.txt:110
#, no-wrap, placeholders:'--env-filter', priority:90
msgid "--env-filter <command>"
msgstr "--env-filter <命令>"

#. type: Plain text
#: en/git-filter-branch.txt:115
#, placeholders:'linkgit:git-commit-tree[1]', priority:90
msgid "This filter may be used if you only need to modify the environment in which the commit will be performed. Specifically, you might want to rewrite the author/committer name/email/time environment variables (see linkgit:git-commit-tree[1] for details)."
msgstr "如果只需要修改提交的环境，可以使用这个过滤器。 具体来说，你可能想重写作者/提交者姓名/电子邮件/时间等环境变量（详见 linkgit:git-commit-tree[1]）。"

#. type: Labeled list
#: en/git-filter-branch.txt:116
#, no-wrap, placeholders:'--tree-filter', priority:90
msgid "--tree-filter <command>"
msgstr "--tree-filter <命令>"

#. type: Plain text
#: en/git-filter-branch.txt:123
#, placeholders:'.gitignore', priority:90
msgid "This is the filter for rewriting the tree and its contents. The argument is evaluated in shell with the working directory set to the root of the checked out tree. The new tree is then used as-is (new files are auto-added, disappeared files are auto-removed - neither .gitignore files nor any other ignore rules *HAVE ANY EFFECT*!)."
msgstr "这是重写树及其内容的过滤器。 参数在 shell 中评估，工作目录设置为签出树的根目录。 新的签出树将按原样使用（自动添加新文件，自动删除已消失的文件--无论是 .gitignore 文件还是任何其他忽略规则都不会 *产生任何影响*！）。"

#. type: Labeled list
#: en/git-filter-branch.txt:124
#, no-wrap, placeholders:'--index-filter', priority:90
msgid "--index-filter <command>"
msgstr "--index-filter <命令>"

#. type: Plain text
#: en/git-filter-branch.txt:130
#, ignore-ellipsis, placeholders:'--cached':'--ignore-unmatch':'linkgit:git-update-index[1]', priority:90
msgid "This is the filter for rewriting the index. It is similar to the tree filter but does not check out the tree, which makes it much faster. Frequently used with `git rm --cached --ignore-unmatch ...`, see EXAMPLES below. For hairy cases, see linkgit:git-update-index[1]."
msgstr "这是用于重写索引的过滤器。 它与树过滤器类似，但不检查树，因此速度更快。 经常与 `git rm --cached --ignore-unmatch ... ` 一起使用，参见下面的示例。 如需了解更多信息，请参阅 linkgit:git-update-index[1]。"

#. type: Labeled list
#: en/git-filter-branch.txt:131
#, no-wrap, placeholders:'--parent-filter', priority:90
msgid "--parent-filter <command>"
msgstr "--parent-filter <命令>"

#. type: Plain text
#: en/git-filter-branch.txt:138
#, ignore-ellipsis, placeholders:'linkgit:git-commit-tree[1]', priority:90
msgid "This is the filter for rewriting the commit's parent list. It will receive the parent string on stdin and shall output the new parent string on stdout. The parent string is in the format described in linkgit:git-commit-tree[1]: empty for the initial commit, \"-p parent\" for a normal commit and \"-p parent1 -p parent2 -p parent3 ...\" for a merge commit."
msgstr "这是重写提交父级列表的过滤器。 它通过 stdin 接收父级字符串，并在标准输出流输出新的父级字符串。 父级字符串的格式如 linkgit:git-commit-tree[1] 所述：空表示初始提交，\"-p parent\" 表示正常提交，\"-p parent1 -p parent2 -p parent3 ...\" 表示合并提交。"

#. type: Labeled list
#: en/git-filter-branch.txt:139
#, no-wrap, placeholders:'--msg-filter', priority:90
msgid "--msg-filter <command>"
msgstr "--msg-filter <命令>"

#. type: Plain text
#: en/git-filter-branch.txt:144
#, priority:90
msgid "This is the filter for rewriting the commit messages. The argument is evaluated in the shell with the original commit message on standard input; its standard output is used as the new commit message."
msgstr "这是重写提交信息的过滤器。 该参数在 shell 中与标准输入的原始提交信息一起进行评估；其标准输出将用作新的提交信息。"

#. type: Labeled list
#: en/git-filter-branch.txt:145
#, no-wrap, placeholders:'--commit-filter', priority:90
msgid "--commit-filter <command>"
msgstr "--commit-filter <命令>"

#. type: Plain text
#: en/git-filter-branch.txt:151
#, ignore-ellipsis, placeholders:'git commit-tree':'TREE_ID':'PARENT_COMMIT_ID', priority:90
msgid "This is the filter for performing the commit. If this filter is specified, it will be called instead of the 'git commit-tree' command, with arguments of the form \"<TREE_ID> [(-p <PARENT_COMMIT_ID>)...]\" and the log message on stdin. The commit id is expected on stdout."
msgstr "这是执行提交的过滤器。 如果指定了该过滤器，它将代替 'git commit-tree' 命令被调用，参数形式为 \"<TREE_ID> [(-p <PARENT_COMMIT_ID>)...]\" 并在标准输入流上显示日志信息。 提交 ID 将显示在标准输出流上。"

#. type: Plain text
#: en/git-filter-branch.txt:155
#, priority:90
msgid "As a special extension, the commit filter may emit multiple commit ids; in that case, the rewritten children of the original commit will have all of them as parents."
msgstr "作为一种特殊扩展，提交过滤器可能会发出多个提交 ID；在这种情况下，原始提交的重写子代将以所有这些提交为父代。"

#. type: Plain text
#: en/git-filter-branch.txt:160
#, placeholders:'skip_commit', priority:90
msgid "You can use the 'map' convenience function in this filter, and other convenience functions, too. For example, calling 'skip_commit \"$@\"' will leave out the current commit (but not its changes! If you want that, use 'git rebase' instead)."
msgstr "您可以在此过滤器中使用 'map' 便利函数，也可以使用其他便利函数。 例如，调用 'skip_commit \"$@\"' 会忽略当前提交（但不会忽略其更改！如果想这样做，请使用 'git rebase'）。"

#. type: Plain text
#: en/git-filter-branch.txt:164
#, placeholders:'git_commit_non_empty_tree':'git commit-tree', priority:90
msgid "You can also use the `git_commit_non_empty_tree \"$@\"` instead of `git commit-tree \"$@\"` if you don't wish to keep commits with a single parent and that makes no change to the tree."
msgstr "如果不希望保留单父提交，也可以使用 `git_commit_non_empty_tree \"$@\"` 代替 `git commit-tree \"$@\"`，这样不会对提交树造成任何改变。"

#. type: Labeled list
#: en/git-filter-branch.txt:165
#, no-wrap, placeholders:'--tag-name-filter', priority:90
msgid "--tag-name-filter <command>"
msgstr "--tag-name-filter <命令>"

#. type: Plain text
#: en/git-filter-branch.txt:171
#, priority:90
msgid "This is the filter for rewriting tag names. When passed, it will be called for every tag ref that points to a rewritten object (or to a tag object which points to a rewritten object). The original tag name is passed via standard input, and the new tag name is expected on standard output."
msgstr "这是重写标记名的过滤器。当传递时，它将对指向重写对象的每个标签引用（或指向重写对象的标签对象）进行调用。 原始标签名通过标准输入传递，新标签名则通过标准输出传递。"

#. type: Plain text
#: en/git-filter-branch.txt:176
#, placeholders:'--tag-name-filter', priority:90
msgid "The original tags are not deleted, but can be overwritten; use \"--tag-name-filter cat\" to simply update the tags. In this case, be very careful and make sure you have the old tags backed up in case the conversion has run afoul."
msgstr "原始标签不会被删除，但可以被覆盖；使用 \"--tag-name-filter cat \" 可以简单地更新标签。 在这种情况下，要非常小心，确保备份了旧标签，以防转换出现问题。"

#. type: Plain text
#: en/git-filter-branch.txt:187
#, priority:90
msgid "Nearly proper rewriting of tag objects is supported. If the tag has a message attached, a new tag object will be created with the same message, author, and timestamp. If the tag has a signature attached, the signature will be stripped. It is by definition impossible to preserve signatures. The reason this is \"nearly\" proper, is because ideally if the tag did not change (points to the same object, has the same name, etc.) it should retain any signature. That is not the case, signatures will always be removed, buyer beware. There is also no support for changing the author or timestamp (or the tag message for that matter). Tags which point to other tags will be rewritten to point to the underlying commit."
msgstr "几乎支持标签对象的正确重写。如果标签附有信息，则将创建一个具有相同信息、作者和时间戳的新标签对象。如果标签附有签名，签名将被删除。根据定义，不可能保留签名。之所以说这 “几乎” 是正确的，是因为在理想情况下，如果标签没有改变（指向相同的对象、具有相同的名称等），就应该保留任何签名。但实际情况并非如此，签名总是会被移除，买家要小心。此外，也不支持更改作者或时间戳（或标签信息）。指向其他标记的标记将被重写为指向底层提交。"

#. type: Labeled list
#: en/git-filter-branch.txt:188
#, ignore-same, no-wrap, priority:90
msgid "--prune-empty"
msgstr "--prune-empty"

#. type: Plain text
#: en/git-filter-branch.txt:195
#, placeholders:'git-filter-branch':'`--commit-filter`':'git_commit_non_empty_tree', priority:90
msgid "Some filters will generate empty commits that leave the tree untouched. This option instructs git-filter-branch to remove such commits if they have exactly one or zero non-pruned parents; merge commits will therefore remain intact. This option cannot be used together with `--commit-filter`, though the same effect can be achieved by using the provided `git_commit_non_empty_tree` function in a commit filter."
msgstr "某些过滤器会产生空提交，从而使树保持原样。 此选项指示 git-filter-branch，如果这些提交的父提交中正好有一个或零个未剪枝，则删除这些提交；因此，合并提交将保持不变。 此选项不能与 `--commit-filter` 一起使用，不过在提交过滤器中使用所提供的 `git_commit_non_empty_tree` 函数可以达到同样的效果。"

#. type: Labeled list
#: en/git-filter-branch.txt:196
#, no-wrap, placeholders:'--original', priority:90
msgid "--original <namespace>"
msgstr "--original <命名空间>"

#. type: Plain text
#: en/git-filter-branch.txt:199
#, priority:90
msgid "Use this option to set the namespace where the original commits will be stored. The default value is 'refs/original'."
msgstr "使用此选项可设置存储原始提交的命名空间。默认值为 'refs/original'。"

#. type: Labeled list
#: en/git-filter-branch.txt:200
#, no-wrap, priority:90
msgid "-d <directory>"
msgstr "-d <目录>"

#. type: Plain text
#: en/git-filter-branch.txt:207
#, placeholders:'git-rewrite', priority:90
msgid "Use this option to set the path to the temporary directory used for rewriting. When applying a tree filter, the command needs to temporarily check out the tree to some directory, which may consume considerable space in case of large projects. By default it does this in the `.git-rewrite/` directory but you can override that choice by this parameter."
msgstr "使用该选项可设置用于重写的临时目录路径。 在应用树过滤器时，命令需要将树临时签出到某个目录，这可能会占用大型项目的大量空间。 默认情况下，它会在 `.git-rewrite/`目录下进行，但你可以用这个参数来覆盖这个选择。"

#. type: Plain text
#: en/git-filter-branch.txt:213
#, placeholders:'git filter-branch', priority:90
msgid "'git filter-branch' refuses to start with an existing temporary directory or when there are already refs starting with 'refs/original/', unless forced."
msgstr "除非强制要求，否则 'git filter-branch' 不会从已有的临时目录开始，也不会从已有的以 'refs/original/' 开头的引用开始。"

#. type: Labeled list
#: en/git-filter-branch.txt:214
#, no-wrap, placeholders:'--state-branch', priority:90
msgid "--state-branch <branch>"
msgstr "--state-branch <分支>"

#. type: Plain text
#: en/git-filter-branch.txt:219
#, priority:90
msgid "This option will cause the mapping from old to new objects to be loaded from named branch upon startup and saved as a new commit to that branch upon exit, enabling incremental of large trees. If '<branch>' does not exist it will be created."
msgstr "该选项将导致在启动时从指定分支加载新旧对象的映射，并在退出时作为新提交保存到该分支，从而实现大树的增量。如果 '<分支>' 不存在，它将被创建。"

#. type: Labeled list
#: en/git-filter-branch.txt:220
#, ignore-ellipsis, no-wrap, priority:90
msgid "<rev-list options>..."
msgstr "<版本列表选项>..."

#. type: Plain text
#: en/git-filter-branch.txt:225
#, placeholders:'git rev-list':'`--all`':'git filter-branch':'<<Remap_to_ancestor>>', priority:90
msgid "Arguments for 'git rev-list'. All positive refs included by these options are rewritten. You may also specify options such as `--all`, but you must use `--` to separate them from the 'git filter-branch' options. Implies <<Remap_to_ancestor>>."
msgstr "'git rev-list' 的参数。 这些选项包含的所有正引用都会被重写。 您也可以指定诸如 `--all` 之类的选项，但必须使用 `--` 将它们与 'git filter-branch' 选项分开。隐含 <<Remap_to_ancestor>>。"

#. type: Title ~
#: en/git-filter-branch.txt:229
#, no-wrap, priority:90
msgid "Remap to ancestor"
msgstr "重映射到祖先"

#. type: Plain text
#: en/git-filter-branch.txt:236
#, placeholders:'linkgit:git-rev-list[1]', priority:90
msgid "By using linkgit:git-rev-list[1] arguments, e.g., path limiters, you can limit the set of revisions which get rewritten. However, positive refs on the command line are distinguished: we don't let them be excluded by such limiters. For this purpose, they are instead rewritten to point at the nearest ancestor that was not excluded."
msgstr "通过使用 linkgit:git-rev-list[1] 参数，例如路径限制器，可以限制被改写的版本集。不过，命令行上的正向引用是有区别的：我们不会让它们被此类限制器排除在外。为此，它们会被改写为指向未被排除的最近的祖先。"

#. type: Plain text
#: en/git-filter-branch.txt:244
#, priority:90
msgid "On success, the exit status is `0`. If the filter can't find any commits to rewrite, the exit status is `2`. On any other error, the exit status may be any other non-zero value."
msgstr "成功时，退出状态为 `0`。 如果过滤器找不到要重写的提交，则退出状态为 `2`。 如果出现其他错误，退出状态可能是任何其他非零值。"

#. type: Plain text
#: en/git-filter-branch.txt:251
#, priority:90
msgid "Suppose you want to remove a file (containing confidential information or copyright violation) from all commits:"
msgstr "假设您想从所有提交中删除一个文件（包含机密信息或侵犯版权）："

#. type: delimited block -
#: en/git-filter-branch.txt:254
#, no-wrap, placeholders:'git filter-branch':'--tree-filter':'HEAD', priority:90
msgid "git filter-branch --tree-filter 'rm filename' HEAD\n"
msgstr "git filter-branch --tree-filter 'rm filename' HEAD\n"

#. type: Plain text
#: en/git-filter-branch.txt:259
#, priority:90
msgid "However, if the file is absent from the tree of some commit, a simple `rm filename` will fail for that tree and commit. Thus you may instead want to use `rm -f filename` as the script."
msgstr "但是，如果某个提交的树中没有该文件，那么简单的 `rm filename` 就会在该树和提交中失败。 因此，你可能需要使用 `rm -f filename` 作为脚本。"

#. type: Plain text
#: en/git-filter-branch.txt:265
#, placeholders:'`--index-filter`':'--cached':'`--ignore-unmatch`', priority:90
msgid "Using `--index-filter` with 'git rm' yields a significantly faster version. Like with using `rm filename`, `git rm --cached filename` will fail if the file is absent from the tree of a commit. If you want to \"completely forget\" a file, it does not matter when it entered history, so we also add `--ignore-unmatch`:"
msgstr "将 `--index-filter` 与 'git rm' 一起使用，速度会快很多。 和使用 `rm filename` 一样，如果文件不在提交树中，`git rm --cached filename` 也会失败。 如果你想 “完全遗忘 ” 一个文件，它何时进入历史并不重要，所以我们还添加了 `--ignore-unmatch`："

#. type: delimited block -
#: en/git-filter-branch.txt:268
#, no-wrap, placeholders:'git filter-branch':'--index-filter':'--cached':'--ignore-unmatch':'HEAD', priority:90
msgid "git filter-branch --index-filter 'git rm --cached --ignore-unmatch filename' HEAD\n"
msgstr "git filter-branch --index-filter 'git rm --cached --ignore-unmatch filename' HEAD\n"

#. type: Plain text
#: en/git-filter-branch.txt:271
#, placeholders:'HEAD', priority:90
msgid "Now, you will get the rewritten history saved in HEAD."
msgstr "现在，您将获得保存在 HEAD 中的改写历史记录。"

#. type: Plain text
#: en/git-filter-branch.txt:274
#, priority:90
msgid "To rewrite the repository to look as if `foodir/` had been its project root, and discard all other history:"
msgstr "重写仓库，使其看起来就像 `foodir/` 是其项目根目录，并丢弃所有其他历史记录："

#. type: delimited block -
#: en/git-filter-branch.txt:277
#, no-wrap, placeholders:'git filter-branch':'--subdirectory-filter':'--all', priority:90
msgid "git filter-branch --subdirectory-filter foodir -- --all\n"
msgstr "git filter-branch --subdirectory-filter foodir -- --all\n"

#. type: Plain text
#: en/git-filter-branch.txt:282
#, placeholders:'`--all`', priority:90
msgid "Thus you can, e.g., turn a library subdirectory into a repository of its own. Note the `--` that separates 'filter-branch' options from revision options, and the `--all` to rewrite all branches and tags."
msgstr "这样，你就可以把一个库子目录变成自己的仓库。 请注意 `--` 将 'filter-branch' 选项与修订选项分开，而 `--all` 则用于重写所有分支和标记。"

#. type: Plain text
#: en/git-filter-branch.txt:286
#, priority:90
msgid "To set a commit (which typically is at the tip of another history) to be the parent of the current initial commit, in order to paste the other history behind the current history:"
msgstr "将一个提交（通常位于另一个历史记录的顶端）设置为当前初始提交的父提交，以便将另一个历史记录粘贴到当前历史记录的后面："

#. type: delimited block -
#: en/git-filter-branch.txt:289
#, no-wrap, placeholders:'git filter-branch':'--parent-filter':'HEAD', priority:90
msgid "git filter-branch --parent-filter 'sed \"s/^\\$/-p <graft-id>/\"' HEAD\n"
msgstr "git filter-branch --parent-filter 'sed \"s/^\\$/-p <graft-id>/\"' HEAD\n"

#. type: Plain text
#: en/git-filter-branch.txt:295
#, priority:90
msgid "(if the parent string is empty - which happens when we are dealing with the initial commit - add graftcommit as a parent). Note that this assumes history with a single root (that is, no merge without common ancestors happened). If this is not the case, use:"
msgstr "(如果父级字符串为空（在处理初始提交时会出现这种情况），则添加 graftcommit 为父级）。 请注意，这假定历史只有一个根（即没有发生没有共同祖先的合并）。 如果不是这种情况，请使用："

#. type: delimited block -
#: en/git-filter-branch.txt:299
#, no-wrap, placeholders:'git filter-branch':'--parent-filter':'$GIT_COMMIT':'HEAD', priority:90
msgid ""
"git filter-branch --parent-filter \\\n"
"\t'test $GIT_COMMIT = <commit-id> && echo \"-p <graft-id>\" || cat' HEAD\n"
msgstr ""
"git filter-branch --parent-filter \\\n"
"\t'test $GIT_COMMIT = <提交id> && echo \"-p <graft-id>\" || cat' HEAD\n"

#. type: Plain text
#: en/git-filter-branch.txt:302
#, priority:90
msgid "or even simpler:"
msgstr "或者更简单："

#. type: delimited block -
#: en/git-filter-branch.txt:306
#, no-wrap, placeholders:'--graft':'$commit':'$graft':'git filter-branch':'$graft':'HEAD', priority:90
msgid ""
"git replace --graft $commit-id $graft-id\n"
"git filter-branch $graft-id..HEAD\n"
msgstr ""
"git replace --graft $commit-id $graft-id\n"
"git filter-branch $graft-id..HEAD\n"

#. type: Plain text
#: en/git-filter-branch.txt:309
#, priority:90
msgid "To remove commits authored by \"Darl McBribe\" from the history:"
msgstr "从历史中删除 \"Darl McBribe\" 编写的提交："

#. type: delimited block -
#: en/git-filter-branch.txt:318
#, no-wrap, placeholders:'git filter-branch':'--commit-filter':'$GIT_AUTHOR_NAME':'skip_commit':'git commit-tree':'HEAD', priority:90
msgid ""
"git filter-branch --commit-filter '\n"
"\tif [ \"$GIT_AUTHOR_NAME\" = \"Darl McBribe\" ];\n"
"\tthen\n"
"\t\tskip_commit \"$@\";\n"
"\telse\n"
"\t\tgit commit-tree \"$@\";\n"
"\tfi' HEAD\n"
msgstr ""
"git filter-branch --commit-filter '\n"
"\tif [ \"$GIT_AUTHOR_NAME\" = \"Darl McBribe\" ];\n"
"\tthen\n"
"\t\tskip_commit \"$@\";\n"
"\telse\n"
"\t\tgit commit-tree \"$@\";\n"
"\tfi' HEAD\n"

#. type: Plain text
#: en/git-filter-branch.txt:321
#, placeholders:'skip_commit', priority:90
msgid "The function 'skip_commit' is defined as follows:"
msgstr "函数 'skip_commit' 的定义如下："

#. type: delimited block -
#: en/git-filter-branch.txt:333
#, no-wrap, placeholders:'skip_commit', priority:90
msgid ""
"skip_commit()\n"
"{\n"
"\tshift;\n"
"\twhile [ -n \"$1\" ];\n"
"\tdo\n"
"\t\tshift;\n"
"\t\tmap \"$1\";\n"
"\t\tshift;\n"
"\tdone;\n"
"}\n"
msgstr ""
"skip_commit()\n"
"{\n"
"\tshift;\n"
"\twhile [ -n \"$1\" ];\n"
"\tdo\n"
"\t\tshift;\n"
"\t\tmap \"$1\";\n"
"\t\tshift;\n"
"\tdone;\n"
"}\n"

#. type: Plain text
#: en/git-filter-branch.txt:340
#, priority:90
msgid "The shift magic first throws away the tree id and then the -p parameters. Note that this handles merges properly! In case Darl committed a merge between P1 and P2, it will be propagated properly and all children of the merge will become merge commits with P1,P2 as their parents instead of the merge commit."
msgstr "移位魔法会首先删除树 id，然后删除 -p 参数。 请注意，这样可以正确处理合并！如果 Darl （达尔）提交了 P1 和 P2 之间的合并，它将被正确传播，合并的所有子提交都将成为以 P1,P2 为父提交的合并提交，而不是合并提交。"

#. type: Plain text
#: en/git-filter-branch.txt:345
#, priority:90
msgid "*NOTE* the changes introduced by the commits, and which are not reverted by subsequent commits, will still be in the rewritten branch. If you want to throw out _changes_ together with the commits, you should use the interactive mode of 'git rebase'."
msgstr "*注意* 这些提交所引入的变更，如果没有被后续提交所还原的改动仍将保留在重写分支中。如果你想要把_改动_连同提交一起扔掉，应该使用交互式的 'git rebase'。"

#. type: Plain text
#: en/git-filter-branch.txt:349
#, placeholders:'`--msg-filter`':'git svn-id', priority:90
msgid "You can rewrite the commit log messages using `--msg-filter`. For example, 'git svn-id' strings in a repository created by 'git svn' can be removed this way:"
msgstr "你可以使用 `--msg-filter` 重写提交日志信息。 例如，'git svn' 创建的仓库中的 'git svn-id' 字符串就可以用这种方法删除："

#. type: delimited block -
#: en/git-filter-branch.txt:354
#, no-wrap, placeholders:'git filter-branch':'--msg-filter':'git-svn-id', priority:90
msgid ""
"git filter-branch --msg-filter '\n"
"\tsed -e \"/^git-svn-id:/d\"\n"
"'\n"
msgstr ""
"git filter-branch --msg-filter '\n"
"\tsed -e \"/^git-svn-id:/d\"\n"
"'\n"

#. type: Plain text
#: en/git-filter-branch.txt:358
#, priority:90
msgid "If you need to add 'Acked-by' lines to, say, the last 10 commits (none of which is a merge), use this command:"
msgstr "如果需要在最近 10 次提交（其中没有一次是合并）中添加 'Acked-by' 行，请使用此命令："

#. type: delimited block -
#: en/git-filter-branch.txt:364
#, no-wrap, placeholders:'git filter-branch':'--msg-filter':'bugzilla.org':'HEAD':'HEAD', priority:90
msgid ""
"git filter-branch --msg-filter '\n"
"\tcat &&\n"
"\techo \"Acked-by: Bugs Bunny <bunny@bugzilla.org>\"\n"
"' HEAD~10..HEAD\n"
msgstr ""
"git filter-branch --msg-filter '\n"
"\tcat &&\n"
"\techo \"Acked-by: Bugs Bunny <bunny@bugzilla.org>\"\n"
"' HEAD~10..HEAD\n"

#. type: Plain text
#: en/git-filter-branch.txt:370
#, placeholders:'`--env-filter`':'user.email', priority:90
msgid "The `--env-filter` option can be used to modify committer and/or author identity. For example, if you found out that your commits have the wrong identity due to a misconfigured user.email, you can make a correction, before publishing the project, like this:"
msgstr "`--env-filter` 选项可用于修改提交者和/或作者身份。 例如，如果你发现由于 user.email 配置错误而导致提交者身份错误，你可以在发布项目之前像这样进行更正："

#. type: delimited block -
#: en/git-filter-branch.txt:382
#, no-wrap, placeholders:'git filter-branch':'--env-filter':'$GIT_AUTHOR_EMAIL':'GIT_AUTHOR_EMAIL':'$GIT_COMMITTER_EMAIL':'GIT_COMMITTER_EMAIL':'--all', priority:90
msgid ""
"git filter-branch --env-filter '\n"
"\tif test \"$GIT_AUTHOR_EMAIL\" = \"root@localhost\"\n"
"\tthen\n"
"\t\tGIT_AUTHOR_EMAIL=john@example.com\n"
"\tfi\n"
"\tif test \"$GIT_COMMITTER_EMAIL\" = \"root@localhost\"\n"
"\tthen\n"
"\t\tGIT_COMMITTER_EMAIL=john@example.com\n"
"\tfi\n"
"' -- --all\n"
msgstr ""
"git filter-branch --env-filter '\n"
"\tif test \"$GIT_AUTHOR_EMAIL\" = \"root@localhost\"\n"
"\tthen\n"
"\t\tGIT_AUTHOR_EMAIL=john@example.com\n"
"\tfi\n"
"\tif test \"$GIT_COMMITTER_EMAIL\" = \"root@localhost\"\n"
"\tthen\n"
"\t\tGIT_COMMITTER_EMAIL=john@example.com\n"
"\tfi\n"
"' -- --all\n"

#. type: Plain text
#: en/git-filter-branch.txt:388
#, placeholders:'git rev-list', priority:90
msgid "To restrict rewriting to only part of the history, specify a revision range in addition to the new branch name. The new branch name will point to the top-most revision that a 'git rev-list' of this range will print."
msgstr "要限制只重写历史的一部分，除了新分支名称外，还需指定一个版本范围。 新的分支名称将指向该范围内的 'git rev-list' 所能打印的最高修订版本。"

#. type: Plain text
#: en/git-filter-branch.txt:390
#, priority:90
msgid "Consider this history:"
msgstr "请看这段提交历史："

#. type: delimited block -
#: en/git-filter-branch.txt:395
#, no-wrap, placeholders:'--E--F--G--H':'--B-----C', priority:90
msgid ""
"     D--E--F--G--H\n"
"    /     /\n"
"A--B-----C\n"
msgstr ""
"     D--E--F--G--H\n"
"    /     /\n"
"A--B-----C\n"

#. type: Plain text
#: en/git-filter-branch.txt:398
#, priority:90
msgid "To rewrite only commits D,E,F,G,H, but leave A, B and C alone, use:"
msgstr "要只重写 D、E、F、G、H 提交，而不重写 A、B 和 C，请使用："

#. type: delimited block -
#: en/git-filter-branch.txt:401
#, ignore-ellipsis, no-wrap, placeholders:'git filter-branch', priority:90
msgid "git filter-branch ... C..H\n"
msgstr "git filter-branch ... C..H\n"

#. type: Plain text
#: en/git-filter-branch.txt:404
#, priority:90
msgid "To rewrite commits E,F,G,H, use one of these:"
msgstr "要重写 E、F、G、H 提交，请使用其中一种方法："

#. type: delimited block -
#: en/git-filter-branch.txt:408
#, ignore-ellipsis, no-wrap, placeholders:'git filter-branch':'--not':'git filter-branch':'--not', priority:90
msgid ""
"git filter-branch ... C..H --not D\n"
"git filter-branch ... D..H --not C\n"
msgstr ""
"git filter-branch ... C..H --not D\n"
"git filter-branch ... D..H --not C\n"

#. type: Plain text
#: en/git-filter-branch.txt:411
#, priority:90
msgid "To move the whole tree into a subdirectory, or remove it from there:"
msgstr "将整棵树移至子目录，或从子目录中删除："

#. type: delimited block -
#: en/git-filter-branch.txt:418
#, no-wrap, placeholders:'git filter-branch':'--index-filter':'git ls-files':'GIT_INDEX_FILE':'$GIT_INDEX_FILE':'git update-index':'--index-info':'$GIT_INDEX_FILE':'$GIT_INDEX_FILE':'HEAD', priority:90
msgid ""
"git filter-branch --index-filter \\\n"
"\t'git ls-files -s | sed \"s-\\t\\\"*-&newsubdir/-\" |\n"
"\t\tGIT_INDEX_FILE=$GIT_INDEX_FILE.new \\\n"
"\t\t\tgit update-index --index-info &&\n"
"\t mv \"$GIT_INDEX_FILE.new\" \"$GIT_INDEX_FILE\"' HEAD\n"
msgstr ""
"git filter-branch --index-filter \\\n"
"\t'git ls-files -s | sed \"s-\\t\\\"*-&newsubdir/-\" |\n"
"\t\tGIT_INDEX_FILE=$GIT_INDEX_FILE.new \\\n"
"\t\t\tgit update-index --index-info &&\n"
"\t mv \"$GIT_INDEX_FILE.new\" \"$GIT_INDEX_FILE\"' HEAD\n"

#. type: Title -
#: en/git-filter-branch.txt:423
#, no-wrap, priority:90
msgid "CHECKLIST FOR SHRINKING A REPOSITORY"
msgstr "缩减仓库的清单"

#. type: Plain text
#: en/git-filter-branch.txt:431
#, placeholders:'git-filter-branch':'`--index-filter`':'`--subdirectory-filter`', priority:90
msgid "git-filter-branch can be used to get rid of a subset of files, usually with some combination of `--index-filter` and `--subdirectory-filter`. People expect the resulting repository to be smaller than the original, but you need a few more steps to actually make it smaller, because Git tries hard not to lose your objects until you tell it to. First make sure that:"
msgstr "git-filter-branch 可以用来去掉一部分文件，通常与 `--index-filter` 和 `--subdirectory-filter` 结合使用。 人们希望生成的仓库比原始仓库更小，但实际上还需要一些步骤才能使仓库更小，因为 Git 会尽量避免丢失对象，直到你让它这么做为止。 首先确保："

#. type: Plain text
#: en/git-filter-branch.txt:435
#, placeholders:'--name-only':'--follow':'--all', priority:90
msgid "You really removed all variants of a filename, if a blob was moved over its lifetime. `git log --name-only --follow --all -- filename` can help you find renames."
msgstr "如果一个 blob 在其生命周期内被移动过，你就真的删除了文件名的所有变体。 `git log --name-only --follow --all -- filename` 可以帮你找到重命名。"

#. type: Plain text
#: en/git-filter-branch.txt:438
#, placeholders:'`--tag-name-filter':'--all`':'git-filter-branch', priority:90
msgid "You really filtered all refs: use `--tag-name-filter cat -- --all` when calling git-filter-branch."
msgstr "你真的过滤了所有引用：在调用 git-filter-branch 时使用 `--tag-name-filter cat ----all` 。"

#. type: Plain text
#: en/git-filter-branch.txt:441
#, priority:90
msgid "Then there are two ways to get a smaller repository. A safer way is to clone, that keeps your original intact."
msgstr "那么有两种方法可以获得更小的仓库。 比较安全的方法是克隆，这样可以保持你的原始版本不变。"

#. type: Plain text
#: en/git-filter-branch.txt:445
#, placeholders:'linkgit:git-clone[1]', priority:90
msgid "Clone it with `git clone file:///path/to/repo`. The clone will not have the removed objects. See linkgit:git-clone[1]. (Note that cloning with a plain path just hardlinks everything!)"
msgstr "使用 `git clone file:///path/to/repo` 克隆它。 克隆后将不会有被删除的对象。 参见 linkgit:git-clone[1]。 (注意，用纯路径克隆只会硬链接一切！）"

#. type: Plain text
#: en/git-filter-branch.txt:450
#, priority:90
msgid "If you really don't want to clone it, for whatever reasons, check the following points instead (in this order). This is a very destructive approach, so *make a backup* or go back to cloning it. You have been warned."
msgstr "如果你真的不想克隆它，不管出于什么原因，请检查以下几点（按此顺序）。 这是一种破坏性很强的方法，所以 *做好备份*，或者重新克隆。 我已经警告过你了。"

#. type: Plain text
#: en/git-filter-branch.txt:454
#, placeholders:'git-filter-branch':'git for-each-ref':'--format=':'git update-ref', priority:90
msgid "Remove the original refs backed up by git-filter-branch: say `git for-each-ref --format=\"%(refname)\" refs/original/ | xargs -n 1 git update-ref -d`."
msgstr "删除由 git-filter-branch 支持的原始参考文件：说 `git for-each-ref --format=\"%(引用名称)\" refs/original/ | xargs -n 1 git update-ref -d`."

#. type: Plain text
#: en/git-filter-branch.txt:456
#, placeholders:'--expire=now':'--all`', priority:90
msgid "Expire all reflogs with `git reflog expire --expire=now --all`."
msgstr "使用 `git reflog expire --expire=now --all` 过期所有引用日志。"

#. type: Plain text
#: en/git-filter-branch.txt:460
#, placeholders:'--prune=now`':'git-gc':'`--prune`', priority:90
msgid "Garbage collect all unreferenced objects with `git gc --prune=now` (or if your git-gc is not new enough to support arguments to `--prune`, use `git repack -ad; git prune` instead)."
msgstr "使用 `git gc --prune=now` 清理所有未引用的对象（如果你的 git-gc 还不够新，不支持 `--prune` 的参数，则使用 `git repack -ad; git prune` 代替）。"

#. type: Plain text
#: en/git-filter-branch.txt:467
#, placeholders:'git-filter-branch', priority:90
msgid "The performance of git-filter-branch is glacially slow; its design makes it impossible for a backward-compatible implementation to ever be fast:"
msgstr "git-filter-branch 的运行速度慢得像冰川；它的设计使得向后兼容的实现不可能很快："

#. type: Plain text
#: en/git-filter-branch.txt:473
#, placeholders:'git-filter-branch':'git-filter-branch', priority:90
msgid "In editing files, git-filter-branch by design checks out each and every commit as it existed in the original repo. If your repo has `10^5` files and `10^5` commits, but each commit only modifies five files, then git-filter-branch will make you do `10^10` modifications, despite only having (at most) `5*10^5` unique blobs."
msgstr "在编辑文件时，git-filter-branch 会检查原始仓库中的每个提交。 如果你的仓库有 `10^5` 个文件和 `10^5` 次提交，但每次提交只修改了五个文件，那么 git-filter-branch 会让你做 `10^10` 次修改，尽管（最多）只有 `5*10^5` 个唯一的 blob。"

#. type: Plain text
#: en/git-filter-branch.txt:476
#, placeholders:'git-filter-branch', priority:90
msgid "If you try and cheat and try to make git-filter-branch only work on files modified in a commit, then two things happen"
msgstr "如果你试图作弊，让 git-filter-branch 只对提交中修改过的文件起作用，那么会发生两种情况"

#. type: Plain text
#: en/git-filter-branch.txt:482
#, priority:90
msgid "you run into problems with deletions whenever the user is simply trying to rename files (because attempting to delete files that don't exist looks like a no-op; it takes some chicanery to remap deletes across file renames when the renames happen via arbitrary user-provided shell)"
msgstr "当用户只是试图重命名文件时，就会遇到删除问题（因为试图删除不存在的文件看起来是不可能的；当重命名通过任意用户提供的 shell 进行时，需要一些技巧来重新映射文件重命名时的删除）"

#. type: Plain text
#: en/git-filter-branch.txt:488
#, priority:90
msgid "even if you succeed at the map-deletes-for-renames chicanery, you still technically violate backward compatibility because users are allowed to filter files in ways that depend upon topology of commits instead of filtering solely based on file contents or names (though this has not been observed in the wild)."
msgstr "即使你成功地使用了 map-deletes-for-renames 的诡计，从技术上讲，你仍然违反了向后兼容性，因为用户可以根据提交的拓扑结构来过滤文件，而不是仅仅根据文件内容或名称来过滤（尽管在实际中还没有观察到这种情况）。"

#. type: Plain text
#: en/git-filter-branch.txt:495
#, placeholders:'--index-filter', priority:90
msgid "Even if you don't need to edit files but only want to e.g. rename or remove some and thus can avoid checking out each file (i.e. you can use --index-filter), you still are passing shell snippets for your filters. This means that for every commit, you have to have a prepared git repo where those filters can be run. That's a significant setup."
msgstr "即使您不需要编辑文件，而只想重命名或删除某些文件，从而可以避免检查每个文件（即您可以使用 --index-filter ），您仍然要为过滤器传递 shell 片段。 这意味着每次提交时，您都必须准备一个可以运行这些过滤器的 git repo。 这可是个大工程。"

#. type: Plain text
#: en/git-filter-branch.txt:507
#, placeholders:'git-filter-branch':'git-filter-branch':'git-filter-branch':'git-filter-branch', priority:90
msgid "Further, several additional files are created or updated per commit by git-filter-branch. Some of these are for supporting the convenience functions provided by git-filter-branch (such as map()), while others are for keeping track of internal state (but could have also been accessed by user filters; one of git-filter-branch's regression tests does so). This essentially amounts to using the filesystem as an IPC mechanism between git-filter-branch and the user-provided filters. Disks tend to be a slow IPC mechanism, and writing these files also effectively represents a forced synchronization point between separate processes that we hit with every commit."
msgstr "此外，git-filter-branch 还会在每次提交时创建或更新几个额外的文件。 其中一些用于支持 git-filter-branch 提供的便利函数（如 map()），另一些则用于跟踪内部状态（但也可能被用户过滤器访问；git-filter-branch 的一个回归测试就是这么做的）。 这基本上相当于把文件系统用作 git-filter-branch 和用户提供的过滤器之间的 IPC 机制。 磁盘往往是一种缓慢的 IPC 机制，而写入这些文件实际上也代表了我们在每次提交时都要在不同进程间强制同步的点。"

#. type: Plain text
#: en/git-filter-branch.txt:513
#, priority:90
msgid "The user-provided shell commands will likely involve a pipeline of commands, resulting in the creation of many processes per commit. Creating and running another process takes a widely varying amount of time between operating systems, but on any platform it is very slow relative to invoking a function."
msgstr "用户提供的 shell 命令很可能涉及命令流水线，导致每次提交都要创建许多进程。 在不同的操作系统上，创建和运行另一个进程所需的时间差别很大，但在任何平台上，相对于调用一个函数而言，创建和运行另一个进程都是非常缓慢的。"

#. type: Plain text
#: en/git-filter-branch.txt:519
#, placeholders:'git-filter-branch':'git-filter-branch', priority:90
msgid "git-filter-branch itself is written in shell, which is kind of slow. This is the one performance issue that could be backward-compatibly fixed, but compared to the above problems that are intrinsic to the design of git-filter-branch, the language of the tool itself is a relatively minor issue."
msgstr "git-filter-branch 本身是用 shell 编写的，速度有点慢。 这是一个可以向后兼容修复的性能问题，但与上述属于 git-filter-branch 设计本身的问题相比，工具本身的语言只是一个相对次要的问题。"

#. type: Plain text
#: en/git-filter-branch.txt:530
#, placeholders:'git-filter-branch':'git-filter-branch':'skip_commit':'`--setup`', priority:90
msgid "Side note: Unfortunately, people tend to fixate on the written-in-shell aspect and periodically ask if git-filter-branch could be rewritten in another language to fix the performance issues. Not only does that ignore the bigger intrinsic problems with the design, it'd help less than you'd expect: if git-filter-branch itself were not shell, then the convenience functions (map(), skip_commit(), etc) and the `--setup` argument could no longer be executed once at the beginning of the program but would instead need to be prepended to every user filter (and thus re-executed with every commit)."
msgstr "题外话：不幸的是，人们往往会把注意力集中在用 shell 编写的问题上，并定期询问是否可以用其他语言重写 git-filter-branch，以解决性能问题。 如果 git-filter-branch 本身不是 shell，那么方便函数（map()、skip_commit() 等）和 `--setup`参数就不能再在程序开始时执行一次，而是需要在每个用户过滤器中预置（因此每次提交都要重新执行）。"

#. type: Plain text
#: en/git-filter-branch.txt:541
#, placeholders:'https://github.com/newren/git-filter-repo/[':'git filter-repo':'git-filter-branch':'git-filter-branch':'git filter-repo':'https://github.com/newren/git-filter-repo/blob/master/contrib/filter-repo-demos/filter-lamely[':'git-filter-branch':'git-filter-branch', priority:90
msgid "The https://github.com/newren/git-filter-repo/[git filter-repo] tool is an alternative to git-filter-branch which does not suffer from these performance problems or the safety problems (mentioned below). For those with existing tooling which relies upon git-filter-branch, 'git filter-repo' also provides https://github.com/newren/git-filter-repo/blob/master/contrib/filter-repo-demos/filter-lamely[filter-lamely], a drop-in git-filter-branch replacement (with a few caveats). While filter-lamely suffers from all the same safety issues as git-filter-branch, it at least ameliorates the performance issues a little."
msgstr "https://github.com/newren/git-filter-repo/[git filter-repo] 工具是 git-filter-branch 的替代工具，它不存在这些性能问题或安全问题（如下所述）。对于那些现有工具依赖于 git-filter-branch 的用户，'git filter-repo' 还提供了 https://github.com/newren/git-filter-repo/blob/master/contrib/filter-repo-demos/filter-lamely[filter-lamely]，这是一个可直接替代 git-filter-branch 的工具（有一些注意事项）。 虽然 filter-lamely 与 git-filter-branch 存在同样的安全问题，但它至少在性能上稍有改善。"

#. type: Title -
#: en/git-filter-branch.txt:544
#, no-wrap, priority:90
msgid "SAFETY"
msgstr "安全性"

#. type: Plain text
#: en/git-filter-branch.txt:549
#, placeholders:'git-filter-branch', priority:90
msgid "git-filter-branch is riddled with gotchas resulting in various ways to easily corrupt repos or end up with a mess worse than what you started with:"
msgstr "git-filter-branch 漏洞百出，有各种方法可以轻易破坏仓库，或者最后弄得一团糟，比一开始更糟："

#. type: Plain text
#: en/git-filter-branch.txt:563
#, placeholders:'git-filter-branch', priority:90
msgid "Someone can have a set of \"working and tested filters\" which they document or provide to a coworker, who then runs them on a different OS where the same commands are not working/tested (some examples in the git-filter-branch manpage are also affected by this). BSD vs. GNU userland differences can really bite. If lucky, error messages are spewed. But just as likely, the commands either don't do the filtering requested, or silently corrupt by making some unwanted change. The unwanted change may only affect a few commits, so it's not necessarily obvious either. (The fact that problems won't necessarily be obvious means they are likely to go unnoticed until the rewritten history is in use for quite a while, at which point it's really hard to justify another flag-day for another rewrite.)"
msgstr "有些人可能有一套 “经过测试的有效过滤器”，他们将其记录下来或提供给同事，但同事在不同的操作系统上运行这些过滤器时，相同的命令却无法正常工作或经过测试（git-filter-branch manpage 中的一些示例也受此影响）。 BSD 与 GNU 的用户态差异确实会让人头疼。 如果幸运的话，会出现错误信息。 但同样有可能的是，这些命令要么没有完成所要求的过滤，要么因为做了一些不必要的改动而无声无息地损坏了程序。 这些不必要的改动可能只影响到几个提交，所以也不一定很明显。 (问题不一定很明显这一事实意味着，在重写的历史被使用一段时间后，这些问题才有可能被发现。）"

#. type: Plain text
#: en/git-filter-branch.txt:573
#, placeholders:'git-ls-files', priority:90
msgid "Filenames with spaces are often mishandled by shell snippets since they cause problems for shell pipelines. Not everyone is familiar with find -print0, xargs -0, git-ls-files -z, etc. Even people who are familiar with these may assume such flags are not relevant because someone else renamed any such files in their repo back before the person doing the filtering joined the project. And often, even those familiar with handling arguments with spaces may not do so just because they aren't in the mindset of thinking about everything that could possibly go wrong."
msgstr "带有空格的文件名通常会被 shell 片段错误处理，因为它们会给 shell 管道带来问题。 并非每个人都熟悉 find -print0、xargs -0、git-ls-files -z 等。 即使是熟悉这些的人，也可能会认为这些标记无关紧要，因为早在进行过滤的人加入项目之前，就有人重命名了他们的 repo 中的任何此类文件。 即使是熟悉处理带空格参数的人，也可能不会这么做，因为他们没有考虑到所有可能出错的地方。"

# ERROR: git ls-files not found in translation
# ERROR: WANTED_DIR not found in translation
# ERROR: git ls-files not found in translation
# ERROR: WANTED_DIR not found in translation
#. type: Plain text
#: en/git-filter-branch.txt:584
#, placeholders:'git ls-files':'WANTED_DIR':'core.quotePath', priority:90
msgid "Non-ascii filenames can be silently removed despite being in a desired directory. Keeping only wanted paths is often done using pipelines like `git ls-files | grep -v ^WANTED_DIR/ | xargs git rm`. ls-files will only quote filenames if needed, so folks may not notice that one of the files didn't match the regex (at least not until it's much too late). Yes, someone who knows about core.quotePath can avoid this (unless they have other special characters like \\t, \\n, or \"), and people who use ls-files -z with something other than grep can avoid this, but that doesn't mean they will."
msgstr "非英文字符串的文件名即使在想要的目录中，也会被悄悄移除。 只保留想要的路径通常是使用底层命令来完成的，如 `git ls-files | grep -v ^WANTED_DIR/ | xargs git rm`。 ls-files 只在需要时才会引用文件名，因此人们可能不会注意到其中一个文件与通配符不匹配（至少在为时已晚之前不会注意到）。 是的，知道 core.quotePath 的人可以避免这种情况（除非他们有其他特殊字符，如 \\t、\\n 或 \" ），使用 ls-files -z 而不是 grep 的人也可以避免这种情况，但这并不意味着他们会这样做。"

#. type: Plain text
#: en/git-filter-branch.txt:591
#, priority:90
msgid "Similarly, when moving files around, one can find that filenames with non-ascii or special characters end up in a different directory, one that includes a double quote character. (This is technically the same issue as above with quoting, but perhaps an interesting different way that it can and has manifested as a problem.)"
msgstr "同样，在移动文件时，我们会发现带有非字符串或特殊字符的文件名最终会出现在不同的目录中，其中包括一个双引号字符。 (从技术上讲，这与上面的引号问题是一样的，但也许是一个有趣的不同方式，它可以并已经表现为一个问题）"

#. type: Plain text
#: en/git-filter-branch.txt:600
#, placeholders:'git-filter-branch', priority:90
msgid "It's far too easy to accidentally mix up old and new history. It's still possible with any tool, but git-filter-branch almost invites it. If lucky, the only downside is users getting frustrated that they don't know how to shrink their repo and remove the old stuff. If unlucky, they merge old and new history and end up with multiple \"copies\" of each commit, some of which have unwanted or sensitive files and others which don't. This comes about in multiple different ways:"
msgstr "不小心混淆新旧历史太容易了。 任何工具都有可能发生这种情况，但 git-filter-branch 几乎是在自找麻烦。 如果幸运的话，唯一的坏处就是用户会因为不知道如何缩小他们的仓库并移除旧的东西而感到沮丧。 如果运气不好，他们就会合并新旧历史，最终每个提交都会有多个 “副本”，其中一些有不需要的文件或敏感文件，另一些则没有。 这种情况有多种不同的方式："

#. type: Plain text
#: en/git-filter-branch.txt:603
#, placeholders:'--all', priority:90
msgid "the default to only doing a partial history rewrite ('--all' is not the default and few examples show it)"
msgstr "默认情况下只进行部分历史重写（'--all' 不是默认值，而且很少有例子显示它）"

#. type: Plain text
#: en/git-filter-branch.txt:605
#, priority:90
msgid "the fact that there's no automatic post-run cleanup"
msgstr "没有运行后的自动清理功能"

# ERROR: --tag-name-filter not found in translation
# ERROR: --tag-name-filter not found in translation
#. type: Plain text
#: en/git-filter-branch.txt:608
#, placeholders:'--tag-name-filter', priority:90
msgid "the fact that --tag-name-filter (when used to rename tags) doesn't remove the old tags but just adds new ones with the new name"
msgstr "事实上 --tag-name-filter 选项（用于重命名标签时）不会删除旧标签，而只是用新名称添加新标签"

#. type: Plain text
#: en/git-filter-branch.txt:617
#, placeholders:'git filter-repo', priority:90
msgid "the fact that little educational information is provided to inform users of the ramifications of a rewrite and how to avoid mixing old and new history. For example, this man page discusses how users need to understand that they need to rebase their changes for all their branches on top of new history (or delete and reclone), but that's only one of multiple concerns to consider. See the \"DISCUSSION\" section of the git filter-repo manual page for more details."
msgstr "事实上，几乎没有提供任何教育信息，让用户了解重写的后果，以及如何避免新旧历史混合。 例如，该手册页面讨论了用户需要了解如何将所有分支的改动重置到新历史之上（或删除并重新克隆），但这只是需要考虑的多个问题之一。 更多详情，请参阅 git filter-repo 手册页面的 “讨论” 部分。"

#. type: Plain text
#: en/git-filter-branch.txt:620
#, priority:90
msgid "Annotated tags can be accidentally converted to lightweight tags, due to either of two issues:"
msgstr "注释标签可能会意外转换为轻量级标签，原因有两个："

#. type: Plain text
#: en/git-filter-branch.txt:625
#, placeholders:'git-filter-branch', priority:90
msgid "Someone can do a history rewrite, realize they messed up, restore from the backups in refs/original/, and then redo their git-filter-branch command. (The backup in refs/original/ is not a real backup; it dereferences tags first.)"
msgstr "有人可能会重写历史，意识到自己搞砸了，从 refs/original/ 中的备份恢复，然后重做 git-filter-branch 命令。 (refs/original/ 中的备份并不是真正的备份；它首先会取消引用标签）"

#. type: Plain text
#: en/git-filter-branch.txt:630
#, placeholders:'git-filter-branch':'--tags':'--all':'--tag-name-filter', priority:90
msgid "Running git-filter-branch with either --tags or --all in your <rev-list-options>. In order to retain annotated tags as annotated, you must use --tag-name-filter (and must not have restored from refs/original/ in a previously botched rewrite)."
msgstr "在运行 git-filter-branch 时，在 <rev-list 选项> 中使用 --tags 或 --all 选项。 为了将注释标签保留为注释标签，必须使用 --tag-name-filter（而且必须不是在之前失败的重写中从 refs/original/ 恢复的）。"

#. type: Plain text
#: en/git-filter-branch.txt:636
#, placeholders:'git-filter-branch':'--msg-filter', priority:90
msgid "Any commit messages that specify an encoding will become corrupted by the rewrite; git-filter-branch ignores the encoding, takes the original bytes, and feeds it to commit-tree without telling it the proper encoding. (This happens whether or not --msg-filter is used.)"
msgstr "任何指定编码的提交信息都会因为重写而损坏；git-filter-branch 会忽略编码，获取原始字节，并将其输入 commit-tree，而不会告诉它正确的编码。 (无论是否使用了 --msg-filter，都会发生这种情况）"

#. type: Plain text
#: en/git-filter-branch.txt:641
#, priority:90
msgid "Commit messages (even if they are all UTF-8) by default become corrupted due to not being updated -- any references to other commit hashes in commit messages will now refer to no-longer-extant commits."
msgstr "默认情况下，提交信息（即使它们都是 UTF-8）会因未更新而损坏 --any 提交信息中对其他提交哈希值的引用现在会指向不再存在的提交。"

#. type: Plain text
#: en/git-filter-branch.txt:652
#, placeholders:'node_modules', priority:90
msgid "There are no facilities for helping users find what unwanted crud they should delete, which means they are much more likely to have incomplete or partial cleanups that sometimes result in confusion and people wasting time trying to understand. (For example, folks tend to just look for big files to delete instead of big directories or extensions, and once they do so, then sometime later folks using the new repository who are going through history will notice a build artifact directory that has some files but not others, or a cache of dependencies (node_modules or similar) which couldn't have ever been functional since it's missing some files.)"
msgstr "没有任何工具可以帮助用户找到他们应该删除的不需要的垃圾，这意味着他们更有可能进行不完整或部分的清理，有时会造成混乱，让人浪费时间去理解。 (例如，人们倾向于只寻找要删除的大文件，而不是大目录或扩展名，一旦他们这样做了，那么使用新仓库的人在查看历史记录时就会发现构建工件目录中有一些文件但没有其他文件，或者依赖关系缓存（node_modules 或类似缓存）因为缺少了一些文件而无法正常运行）"

#. type: Plain text
#: en/git-filter-branch.txt:655
#, placeholders:'--prune-empty', priority:90
msgid "If --prune-empty isn't specified, then the filtering process can create hoards of confusing empty commits"
msgstr "如果不指定--prune-empty，过滤过程就会产生大量混乱的空提交"

#. type: Plain text
#: en/git-filter-branch.txt:659
#, placeholders:'--prune-empty', priority:90
msgid "If --prune-empty is specified, then intentionally placed empty commits from before the filtering operation are also pruned instead of just pruning commits that became empty due to filtering rules."
msgstr "如果指定了--prune-empty，那么过滤操作前有意放置的空提交也会被剪枝，而不只是剪枝因过滤规则而变为空的提交。"

#. type: Plain text
#: en/git-filter-branch.txt:662
#, ignore-ellipsis, placeholders:'--prune-empty', priority:90
msgid "If --prune-empty is specified, sometimes empty commits are missed and left around anyway (a somewhat rare bug, but it happens...)"
msgstr "如果指定--prune-empty，有时会漏掉一些空提交，但还是会保留下来（这是一个有点罕见的错误，但还是会发生......）"

#. type: Plain text
#: en/git-filter-branch.txt:666
#, placeholders:'--env-filter', priority:90
msgid "A minor issue, but users who have a goal to update all names and emails in a repository may be led to --env-filter which will only update authors and committers, missing taggers."
msgstr "这只是个小问题，但如果用户的目标是更新版本库中的所有姓名和电子邮件，则可能会使用 --env-filter，它只会更新作者和提交者，而不会更新标记者。"

#. type: Plain text
#: en/git-filter-branch.txt:672
#, placeholders:'--tag-name-filter':'git-filter-branch':'git-filter-branch', priority:90
msgid "If the user provides a --tag-name-filter that maps multiple tags to the same name, no warning or error is provided; git-filter-branch simply overwrites each tag in some undocumented pre-defined order resulting in only one tag at the end. (A git-filter-branch regression test requires this surprising behavior.)"
msgstr "如果用户提供了一个 --tag-name-filter 过滤器，将多个标签映射到同一个名字上，git-filter-branch 不会给出任何警告或错误信息，而只会按照某种未被记录的预定义顺序覆盖每个标签，导致最后只有一个标签。 (git-filter-branch 的回归测试需要这种令人惊讶的行为）"

#. type: Plain text
#: en/git-filter-branch.txt:675
#, placeholders:'git-filter-branch', priority:90
msgid "Also, the poor performance of git-filter-branch often leads to safety issues:"
msgstr "此外，git-filter-branch 的性能不佳往往会导致安全问题："

#. type: Plain text
#: en/git-filter-branch.txt:692
#, placeholders:'git-filter-branch', priority:90
msgid "Coming up with the correct shell snippet to do the filtering you want is sometimes difficult unless you're just doing a trivial modification such as deleting a couple files. Unfortunately, people often learn if the snippet is right or wrong by trying it out, but the rightness or wrongness can vary depending on special circumstances (spaces in filenames, non-ascii filenames, funny author names or emails, invalid timezones, presence of grafts or replace objects, etc.), meaning they may have to wait a long time, hit an error, then restart. The performance of git-filter-branch is so bad that this cycle is painful, reducing the time available to carefully re-check (to say nothing about what it does to the patience of the person doing the rewrite even if they do technically have more time available). This problem is extra compounded because errors from broken filters may not be shown for a long time and/or get lost in a sea of output. Even worse, broken filters often just result in silent incorrect rewrites."
msgstr "除非你只是做一些微不足道的修改，比如删除几个文件，否则有时很难找到正确的 shell 代码段来完成你想要的过滤。 不幸的是，人们往往通过尝试来判断代码段的正确与否，但正确与否会因特殊情况（文件名中的空格、非字符串文件名、有趣的作者姓名或电子邮件、无效的时区、存在嫁接或替换对象等）而有所不同，这意味着他们可能需要等待很长时间，遇到错误，然后重新启动。 git-filter-branch 的性能如此糟糕，以至于这种循环非常痛苦，减少了仔细重新检查的时间（更不用说对改写者耐心的影响了，即使他们在技术上有更多的时间）。 由于过滤器损坏导致的错误可能在很长时间内都不会显示出来，并且/或者在大量输出中丢失，因此这个问题变得更加复杂。 更糟糕的是，破损的过滤器往往只会导致无声的错误重写。"

#. type: Plain text
#: en/git-filter-branch.txt:700
#, priority:90
msgid "To top it all off, even when users finally find working commands, they naturally want to share them. But they may be unaware that their repo didn't have some special cases that someone else's does. So, when someone else with a different repository runs the same commands, they get hit by the problems above. Or, the user just runs commands that really were vetted for special cases, but they run it on a different OS where it doesn't work, as noted above."
msgstr "更糟糕的是，即使用户最终找到了可用的命令，他们自然也想分享这些命令。 但他们可能没有意识到，自己的软件源并不具备某些特殊情况，而别人的软件源却具备。 因此，当其他人使用不同的版本库运行相同的命令时，他们就会遇到上述问题。 或者，用户运行的命令确实经过了特殊情况审核，但他们在不同的操作系统上运行时却无法正常工作，如上所述。"

#. type: Title =
#: en/git-fmt-merge-msg.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-fmt-merge-msg(1)"
msgstr "git-fmt-merge-msg(1)"

#. type: Plain text
#: en/git-fmt-merge-msg.txt:7
#, placeholders:'git-fmt-merge-msg', priority:100
msgid "git-fmt-merge-msg - Produce a merge commit message"
msgstr "git-fmt-merge-msg - 生成合并提交信息"

# ERROR: --into-name not found in translation
#. type: Plain text
#: en/git-fmt-merge-msg.txt:14
#, no-wrap, placeholders:'git fmt-merge-msg':'[--into-name':'[--log':'--no-log]':'git fmt-merge-msg':'[--log':'--no-log]', priority:100
msgid ""
"'git fmt-merge-msg' [-m <message>] [--into-name <branch>] [--log[=<n>] | --no-log]\n"
"'git fmt-merge-msg' [-m <message>] [--log[=<n>] | --no-log] -F <file>\n"
msgstr ""
"'git fmt-merge-msg' [-m <消息>] [--into-name <分支>] [--log[=<n>] | --no-log]\n"
"'git fmt-merge-msg' [-m <消息>] [--log[=<n>] | --no-log] -F <文件>\n"

#. type: Plain text
#: en/git-fmt-merge-msg.txt:20
#, priority:100
msgid "Takes the list of merged objects on stdin and produces a suitable commit message to be used for the merge commit, usually to be passed as the '<merge-message>' argument of 'git merge'."
msgstr "接收标准输入流中的合并对象列表，并产生一个合适的提交信息，用于合并提交，通常作为 'git merge' 的 '<merge-message>' 参数传递。"

#. type: Plain text
#: en/git-fmt-merge-msg.txt:23
#, priority:100
msgid "This command is intended mostly for internal use by scripts automatically invoking 'git merge'."
msgstr "这条命令主要是供自动调用 'git merge' 的脚本内部使用。"

#. type: Labeled list
#: en/git-fmt-merge-msg.txt:27 en/merge-options.txt:93
#, no-wrap, placeholders:'--log', priority:240
msgid "--log[=<n>]"
msgstr "--log[=<n>]"

#. type: Plain text
#: en/git-fmt-merge-msg.txt:33
#, placeholders:'merge.log', priority:100
msgid "In addition to branch names, populate the log message with one-line descriptions from the actual commits that are being merged. At most <n> commits from each merge parent will be used (20 if <n> is omitted). This overrides the `merge.log` configuration variable."
msgstr "除了分支名称外，在日志信息中加入被合并的实际提交内容的单行描述。 最多使用每个合并父分支的 <n> 个提交（如果 <n> 被省略，则为 20 个）。 这覆盖了 `merge.log` 配置变量。"

#. type: Labeled list
#: en/git-fmt-merge-msg.txt:34 en/merge-options.txt:94
#, ignore-same, no-wrap, priority:240
msgid "--no-log"
msgstr "--no-log"

#. type: Plain text
#: en/git-fmt-merge-msg.txt:37
#, priority:100
msgid "Do not list one-line descriptions from the actual commits being merged."
msgstr "不要列出被合并的实际提交中的单行描述。"

#. type: Labeled list
#: en/git-fmt-merge-msg.txt:38
#, ignore-same, no-wrap, priority:100
msgid "--[no-]summary"
msgstr "--[no-]summary"

#. type: Plain text
#: en/git-fmt-merge-msg.txt:41
#, placeholders:'--log':'--no-log', priority:100
msgid "Synonyms to --log and --no-log; these are deprecated and will be removed in the future."
msgstr "与 --log 和 --no-log 的同义词；这些都是废弃的，将来会被删除。"

#. type: Labeled list
#: en/git-fmt-merge-msg.txt:43
#, no-wrap, placeholders:'--message', priority:100
msgid "--message <message>"
msgstr "--message <信息>"

#. type: Plain text
#: en/git-fmt-merge-msg.txt:46
#, placeholders:'`--log`', priority:100
msgid "Use <message> instead of the branch names for the first line of the log message. For use with `--log`."
msgstr "在日志信息的第一行使用 <message> 而不是分支名称。 与 `--log` 一起使用。"

# ERROR: --into-name not found in translation
#. type: Labeled list
#: en/git-fmt-merge-msg.txt:47 en/git-merge.txt:81
#, no-wrap, placeholders:'--into-name', priority:240
msgid "--into-name <branch>"
msgstr "--into-name <分支>"

#. type: Plain text
#: en/git-fmt-merge-msg.txt:50
#, priority:100
msgid "Prepare the merge message as if merging to the branch `<branch>`, instead of the name of the real branch to which the merge is made."
msgstr "准备合并信息，就像合并到分支 `<branch>` 一样，而不是合并到真正的分支名称。"

#. type: Labeled list
#: en/git-fmt-merge-msg.txt:52
#, no-wrap, placeholders:'--file', priority:100
msgid "--file <file>"
msgstr "--file <文件>"

#. type: Plain text
#: en/git-fmt-merge-msg.txt:55
#, priority:100
msgid "Take the list of merged objects from <file> instead of stdin."
msgstr "从 <文件> 而不是标准输入流获取合并后的对象列表。"

#. type: Labeled list
#: en/git-fmt-merge-msg.txt:60
#, ignore-same, no-wrap, priority:100
msgid "merge.summary"
msgstr "merge.summary"

#. type: Plain text
#: en/git-fmt-merge-msg.txt:63
#, placeholders:'merge.log', priority:100
msgid "Synonym to `merge.log`; this is deprecated and will be removed in the future."
msgstr "`merge.log` 的同义词；这已被废弃，将来会被删除。"

#. type: delimited block -
#: en/git-fmt-merge-msg.txt:70
#, no-wrap, placeholders:'git fmt-merge-msg':'--log':'$GIT_DIR':'FETCH_HEAD', priority:100
msgid ""
"$ git fetch origin master\n"
"$ git fmt-merge-msg --log <$GIT_DIR/FETCH_HEAD\n"
msgstr ""
"$ git fetch origin master\n"
"$ git fmt-merge-msg --log <$GIT_DIR/FETCH_HEAD\n"

#. type: Plain text
#: en/git-fmt-merge-msg.txt:74
#, priority:100
msgid "Print a log message describing a merge of the \"master\" branch from the \"origin\" remote."
msgstr "打印一条日志信息，描述从 \"origin\" 远程分支合并到 \"master\" 分支的情况。"

#. type: Title =
#: en/git-for-each-ref.txt:2
#, ignore-same, no-wrap, priority:80
msgid "git-for-each-ref(1)"
msgstr "git-for-each-ref(1)"

#. type: Plain text
#: en/git-for-each-ref.txt:7
#, placeholders:'git-for-each-ref', priority:80
msgid "git-for-each-ref - Output information on each ref"
msgstr "git-for-each-ref - 输出每个引用的信息"

#. type: Plain text
#: en/git-for-each-ref.txt:18
#, ignore-ellipsis, no-wrap, placeholders:'git for-each-ref':'[--count=':'[--shell':'--perl':'--python':'--tcl]':'--sort=':'[--format=':'--stdin':'[--points-at=':'[--merged':'[--no-merged':'[--contains':'[--no-contains':'[--exclude=', priority:80
msgid ""
"'git for-each-ref' [--count=<count>] [--shell|--perl|--python|--tcl]\n"
"\t\t   [(--sort=<key>)...] [--format=<format>]\n"
"\t\t   [ --stdin | <pattern>... ]\n"
"\t\t   [--points-at=<object>]\n"
"\t\t   [--merged[=<object>]] [--no-merged[=<object>]]\n"
"\t\t   [--contains[=<object>]] [--no-contains[=<object>]]\n"
"\t\t   [--exclude=<pattern> ...]\n"
msgstr ""
"'git for-each-ref' [--count=<数量>] [--shell|--perl|--python|--tcl]\n"
"\t\t   [(--sort=<键>)...] [--format=<格式>]\n"
"\t\t   [ --stdin | <模式>... ]\n"
"\t\t   [--points-at=<对象>]\n"
"\t\t   [--merged[=<对象>]] [--no-merged[=<对象>]]\n"
"\t\t   [--contains[=<对象>]] [--no-contains[=<对象>]]\n"
"\t\t   [--exclude=<模式> ...]\n"

#. type: Plain text
#: en/git-for-each-ref.txt:28
#, priority:80
msgid "Iterate over all refs that match `<pattern>` and show them according to the given `<format>`, after sorting them according to the given set of `<key>`. If `<count>` is given, stop after showing that many refs. The interpolated values in `<format>` can optionally be quoted as string literals in the specified host language allowing their direct evaluation in that language."
msgstr "遍历所有与 `<模式>` 匹配的引用，并根据给定的 `<格式>` 显示它们，然后根据给定的 `<键>` 对它们进行排序。 如果给定了 `<数量>`，则在显示这么多记录后停止。 在指定的宿主语言中，`<格式>` 中的内插值可选择引用为字符串字面量，以便在该语言中直接求值。"

#. type: Labeled list
#: en/git-for-each-ref.txt:31 en/git-show-ref.txt:102
#, ignore-ellipsis, no-wrap, priority:80
msgid "<pattern>..."
msgstr "<模式>..."

#. type: Plain text
#: en/git-for-each-ref.txt:36
#, priority:80
msgid "If one or more patterns are given, only refs are shown that match against at least one pattern, either using fnmatch(3) or literally, in the latter case matching completely or from the beginning up to a slash."
msgstr "如果给出一个或多个模式，则只显示至少与一个模式匹配的 refs，匹配方式可以是使用 fnmatch(3) 或字面匹配，在后一种情况下，完全匹配或从头匹配到斜线。"

#. type: Plain text
#: en/git-for-each-ref.txt:40
#, placeholders:'`--stdin`', priority:80
msgid "If `--stdin` is supplied, then the list of patterns is read from standard input instead of from the argument list."
msgstr "如果提供了 `--stdin`，则会从标准输入而不是参数列表中读取模式列表。"

#. type: Labeled list
#: en/git-for-each-ref.txt:41
#, no-wrap, placeholders:'--count=', priority:80
msgid "--count=<count>"
msgstr "--count=<数量>"

#. type: Plain text
#: en/git-for-each-ref.txt:45
#, priority:80
msgid "By default the command shows all refs that match `<pattern>`. This option makes it stop after showing that many refs."
msgstr "默认情况下，该命令会显示与 `<模式>` 匹配的所有记录。 该选项可使其在显示了这么多索引后停止。"

#. type: Plain text
#: en/git-for-each-ref.txt:52
#, placeholders:'--sort=', priority:80
msgid "A field name to sort on. Prefix `-` to sort in descending order of the value. When unspecified, `refname` is used. You may use the --sort=<key> option multiple times, in which case the last key becomes the primary key."
msgstr "要排序的字段名。 前缀 `-` 表示按值的降序排序。 如果未指定，则使用 `引用名` 。 可以多次使用 --sort=<键> 选项，在这种情况下，最后一个键将成为主键。"

#. type: Labeled list
#: en/git-for-each-ref.txt:53 en/git-ls-files.txt:220 en/git-ls-tree.txt:86 en/git-replace.txt:106 en/git-tag.txt:201 en/pretty-options.txt:2
#, no-wrap, placeholders:'--format=', priority:260
msgid "--format=<format>"
msgstr "--format=<格式>"

# ERROR: --resolve-undo not found in translation
# ERROR: --eol not found in translation
# ERROR: --resolve-undo not found in translation
# ERROR: --eol not found in translation
#. type: Plain text
#: en/git-for-each-ref.txt:59
#, priority:80
msgid "A string that interpolates `%(fieldname)` from a ref being shown and the object it points at. In addition, the string literal `%%` renders as `%` and `%xx` - where `xx` are hex digits - renders as the character with hex code `xx`. For example, `%00` interpolates to `\\0` (NUL), `%09` to `\\t` (TAB), and `%0a` to `\\n` (LF)."
msgstr "一个字符串，从显示的 ref 和它指向的对象之间插入 `%(字段名)`。此外，字符串字面 `%%` 会显示为 `%`，而 `%xx` - 其中 `xx` 是十六进制数字 - 会显示为十六进制代码 `xx` 的字符。例如，`%00`插值为 `\\0` (NUL)，`%09`插值为 `\\t` (TAB)，`%0a`插值为 `\\n` (LF)。"

#. type: Plain text
#: en/git-for-each-ref.txt:62
#, priority:80
msgid "When unspecified, `<format>` defaults to `%(objectname) SPC %(objecttype) TAB %(refname)`."
msgstr "未指定时，`<格式>` 默认为 `%(对象名) SPC %(对象类型) TAB %(引用名)`。"

#. type: Plain text
#: en/git-for-each-ref.txt:67 en/git-tag.txt:129
#, placeholders:'`--format`', priority:240
msgid "Respect any colors specified in the `--format` option. The `<when>` field must be one of `always`, `never`, or `auto` (if `<when>` is absent, behave as if `always` was given)."
msgstr "尊重`--format`选项中指定的任何颜色。`<什么时候>`字段必须是`always`、`never`或`auto`之一（如果没有`<什么时候>`，则表现为`always`）。"

#. type: Labeled list
#: en/git-for-each-ref.txt:68
#, ignore-same, no-wrap, priority:80
msgid "--shell"
msgstr "--shell"

#. type: Labeled list
#: en/git-for-each-ref.txt:69
#, ignore-same, no-wrap, priority:80
msgid "--perl"
msgstr "--perl"

#. type: Labeled list
#: en/git-for-each-ref.txt:70
#, ignore-same, no-wrap, priority:80
msgid "--python"
msgstr "--python"

#. type: Labeled list
#: en/git-for-each-ref.txt:71
#, ignore-same, no-wrap, priority:80
msgid "--tcl"
msgstr "--tcl"

#. type: Plain text
#: en/git-for-each-ref.txt:76
#, priority:80
msgid "If given, strings that substitute `%(fieldname)` placeholders are quoted as string literals suitable for the specified host language. This is meant to produce a scriptlet that can directly be `eval`ed."
msgstr "如果给定，替代 `%(字段名)` 占位符的字符串将被引述为适合指定主机语言的字符串字面量。 这样做的目的是生成可直接 `eval` 的脚本。"

#. type: Labeled list
#: en/git-for-each-ref.txt:77
#, no-wrap, placeholders:'--points-at=', priority:80
msgid "--points-at=<object>"
msgstr "--points-at=<对象>"

#. type: Plain text
#: en/git-for-each-ref.txt:79
#, priority:80
msgid "Only list refs which points at the given object."
msgstr "只列出指向给定对象的引用。"

#. type: Labeled list
#: en/git-for-each-ref.txt:80
#, no-wrap, placeholders:'--merged', priority:80
msgid "--merged[=<object>]"
msgstr "--merged[=<对象>]"

#. type: Plain text
#: en/git-for-each-ref.txt:83
#, placeholders:'HEAD', priority:80
msgid "Only list refs whose tips are reachable from the specified commit (HEAD if not specified)."
msgstr "仅列出提示可从指定提交（如未指定，则为 HEAD）到达的引用。"

#. type: Labeled list
#: en/git-for-each-ref.txt:84
#, no-wrap, placeholders:'--no-merged', priority:80
msgid "--no-merged[=<object>]"
msgstr "--no-merged[=<对象>]"

#. type: Plain text
#: en/git-for-each-ref.txt:87
#, placeholders:'HEAD', priority:80
msgid "Only list refs whose tips are not reachable from the specified commit (HEAD if not specified)."
msgstr "仅列出提示无法从指定提交（如未指定，则为 HEAD）到达的引用。"

#. type: Labeled list
#: en/git-for-each-ref.txt:88
#, no-wrap, placeholders:'--contains', priority:80
msgid "--contains[=<object>]"
msgstr "--contains[=<对象>]"

#. type: Plain text
#: en/git-for-each-ref.txt:91
#, placeholders:'HEAD', priority:80
msgid "Only list refs which contain the specified commit (HEAD if not specified)."
msgstr "仅列出包含指定提交（如未指定，则为 HEAD）的引用。"

#. type: Labeled list
#: en/git-for-each-ref.txt:92
#, no-wrap, placeholders:'--no-contains', priority:80
msgid "--no-contains[=<object>]"
msgstr "--no-contains[=<对象>]"

#. type: Plain text
#: en/git-for-each-ref.txt:95
#, placeholders:'HEAD', priority:80
msgid "Only list refs which don't contain the specified commit (HEAD if not specified)."
msgstr "仅列出不包含指定提交的引用（如未指定，则为 HEAD）。"

#. type: Plain text
#: en/git-for-each-ref.txt:98
#, priority:80
msgid "Sorting and filtering refs are case insensitive."
msgstr "排序和筛选引用不区分大小写。"

#. type: Plain text
#: en/git-for-each-ref.txt:107
#, priority:80
msgid "If one or more patterns are given, only refs which do not match any excluded pattern(s) are shown. Matching is done using the same rules as `<pattern>` above."
msgstr "如果给出一个或多个模式，则只显示不匹配任何排除模式的参考文件。匹配规则与上文的 `<模式>` 相同。"

#. type: Title -
#: en/git-for-each-ref.txt:109 en/git-ls-files.txt:267 en/git-ls-tree.txt:145
#, no-wrap, priority:80
msgid "FIELD NAMES"
msgstr "字段名"

#. type: Plain text
#: en/git-for-each-ref.txt:114
#, priority:80
msgid "Various values from structured fields in referenced objects can be used to interpolate into the resulting output, or as sort keys."
msgstr "引用对象中结构化字段的各种值可用于插值到输出结果中，或用作排序键。"

#. type: Plain text
#: en/git-for-each-ref.txt:116
#, priority:80
msgid "For all objects, the following names can be used:"
msgstr "所有对象都可以使用以下名称："

#. type: Labeled list
#: en/git-for-each-ref.txt:117
#, no-wrap, priority:80
msgid "refname"
msgstr "引用名"

#. type: Plain text
#: en/git-for-each-ref.txt:133
#, placeholders:'$GIT_DIR':'core.warnAmbiguousRefs', priority:80
msgid "The name of the ref (the part after $GIT_DIR/). For a non-ambiguous short name of the ref append `:short`. The option core.warnAmbiguousRefs is used to select the strict abbreviation mode. If `lstrip=<N>` (`rstrip=<N>`) is appended, strips `<N>` slash-separated path components from the front (back) of the refname (e.g. `%(refname:lstrip=2)` turns `refs/tags/foo` into `foo` and `%(refname:rstrip=2)` turns `refs/tags/foo` into `refs`). If `<N>` is a negative number, strip as many path components as necessary from the specified end to leave `-<N>` path components (e.g. `%(refname:lstrip=-2)` turns `refs/tags/foo` into `tags/foo` and `%(refname:rstrip=-1)` turns `refs/tags/foo` into `refs`). When the ref does not have enough components, the result becomes an empty string if stripping with positive <N>, or it becomes the full refname if stripping with negative <N>. Neither is an error."
msgstr "引用的名称（$GIT_DIR/ 后面的部分）。 对于非含混的引用短名，可添加 `:short`。 选项 core.warnAmbiguousRefs 用于选择严格缩写模式。如果添加了 `lstrip=<N>` (`rstrip=<N>`)，则会从引用名的前面（后面）删除 `<N>` 斜线分隔的路径组件（例如，`%(refname:lstrip=2)` 会将 `refs/tags/foo` 变成 `foo`，`%(refname:rstrip=2)` 会将 `refs/tags/foo` 变成 `refs`）。 如果 `<N>` 是负数，则从指定的末端剥离尽可能多的路径组件，以留下 `-<N>` 路径组件（例如，`%(refname:lstrip=-2)` 将 `refs/tags/foo` 转换为 `tags/foo` 和 `%(refname:rstrip=-1)` 将 `refs/tags/foo` 转换为 `refs`）。当引用没有足够的组件时，如果使用正 <N> 进行剥离，结果将变为空字符串；如果使用负 <N> 进行剥离，结果将变为完整的引用名称。 这两种情况都不是错误。"

#. type: Plain text
#: en/git-for-each-ref.txt:135
#, priority:80
msgid "`strip` can be used as a synonym to `lstrip`."
msgstr "`strip` 可作为 `lstrip` 的同义词使用。"

#. type: Labeled list
#: en/git-for-each-ref.txt:136 en/git-ls-files.txt:275 en/git-ls-tree.txt:153
#, no-wrap, priority:80
msgid "objecttype"
msgstr "objecttype"

#. type: Plain text
#: en/git-for-each-ref.txt:138
#, priority:80
msgid "The type of the object (`blob`, `tree`, `commit`, `tag`)."
msgstr "对象的类型（ `blob` ， `tree` ， `commit` ， `tag` ）。"

#. type: Labeled list
#: en/git-for-each-ref.txt:139
#, no-wrap, priority:80
msgid "objectsize"
msgstr "objectsize"

#. type: Plain text
#: en/git-for-each-ref.txt:143
#, placeholders:'git cat-file', priority:80
msgid "The size of the object (the same as 'git cat-file -s' reports). Append `:disk` to get the size, in bytes, that the object takes up on disk. See the note about on-disk sizes in the `CAVEATS` section below."
msgstr "对象的大小（与 'git cat-file -s' 报告相同）。 添加 `:disk` 可获得对象在磁盘上所占的大小（以字节为单位）。请参阅下文 `注意事项` 部分关于磁盘大小的说明。"

#. type: Labeled list
#: en/git-for-each-ref.txt:143 en/git-ls-files.txt:277 en/git-ls-tree.txt:155
#, no-wrap, priority:80
msgid "objectname"
msgstr "objectname"

#. type: Plain text
#: en/git-for-each-ref.txt:149
#, placeholders:'MINIMUM_ABBREV', priority:80
msgid "The object name (aka SHA-1). For a non-ambiguous abbreviation of the object name append `:short`. For an abbreviation of the object name with desired length append `:short=<length>`, where the minimum length is MINIMUM_ABBREV. The length may be exceeded to ensure unique object names."
msgstr "对象名称（又称 SHA-1）。 如果是对象名称的非明确缩写，请添加 `:short`。 若要使用具有所需长度的对象名称缩写，请添加 `:short=<长度>`，其中最小长度为 MINIMUM_ABBREV。为确保对象名称的唯一性，长度可以超出设定值。"

#. type: Labeled list
#: en/git-for-each-ref.txt:149
#, no-wrap, priority:80
msgid "deltabase"
msgstr "deltabase"

#. type: Plain text
#: en/git-for-each-ref.txt:153
#, priority:80
msgid "This expands to the object name of the delta base for the given object, if it is stored as a delta. Otherwise it expands to the null object name (all zeroes)."
msgstr "如果给定对象存储为 delta，则扩展为 delta 基的对象名称。 否则，它会扩展为空对象名称（全部为零）。"

#. type: Labeled list
#: en/git-for-each-ref.txt:154
#, no-wrap, priority:80
msgid "upstream"
msgstr "上有仓库"

#. type: Plain text
#: en/git-for-each-ref.txt:164
#, priority:80
msgid "The name of a local ref which can be considered ``upstream'' from the displayed ref. Respects `:short`, `:lstrip` and `:rstrip` in the same way as `refname` above. Additionally respects `:track` to show \"[ahead N, behind M]\" and `:trackshort` to show the terse version: \">\" (ahead), \"<\" (behind), \"<>\" (ahead and behind), or \"=\" (in sync). `:track` also prints \"[gone]\" whenever unknown upstream ref is encountered. Append `:track,nobracket` to show tracking information without brackets (i.e \"ahead N, behind M\")."
msgstr "可视为显示引用的 ''上游'' 的本地引用的名称。与上面的 `引用名` 相同，尊重 `:short`、`:lstrip` 和 `:rstrip`。 此外，还尊重 `:track`，以显示 \"[前方 N，后方 M]\" 和 `:trackshort`，以显示简短版本：\">\"（在前）、\"<\"（在后）、\"<>\"（在前和在后）或 \"=\"（同步）。每当遇到未知的上游引用时，`:track` 也会打印 \"[gone]\"。添加 `:track,nobracket`，可显示不带括号的跟踪信息（即 \"前方 N，后方 M\"）。"

#. type: Plain text
#: en/git-for-each-ref.txt:171
#, priority:80
msgid "For any remote-tracking branch `%(upstream)`, `%(upstream:remotename)` and `%(upstream:remoteref)` refer to the name of the remote and the name of the tracked remote ref, respectively. In other words, the remote-tracking branch can be updated explicitly and individually by using the refspec `%(upstream:remoteref):%(upstream)` to fetch from `%(upstream:remotename)`."
msgstr "对于任何远程跟踪分支 `%(upstream)`，`%(upstream:remotename)` 和 `%(upstream:remoteref)`分别指远程的名称和被跟踪的远程引用名称。换句话说，远程跟踪分支可以通过使用引用规范 `%(upstream:remoteref):%(upstream)` 从 `%(upstream:remotename)` 抓取来明确地单独更新。"

#. type: Plain text
#: en/git-for-each-ref.txt:175
#, priority:80
msgid "Has no effect if the ref does not have tracking information associated with it. All the options apart from `nobracket` are mutually exclusive, but if used together the last option is selected."
msgstr "如果引用没有关联跟踪信息，则该选项无效。 除 `nobracket` 以外的所有选项都是互斥的，但如果同时使用，则选择最后一个选项。"

#. type: Labeled list
#: en/git-for-each-ref.txt:176
#, no-wrap, priority:80
msgid "push"
msgstr "push"

#. type: Plain text
#: en/git-for-each-ref.txt:182
#, placeholders:'{push}':'{push}', priority:80
msgid "The name of a local ref which represents the `@{push}` location for the displayed ref. Respects `:short`, `:lstrip`, `:rstrip`, `:track`, `:trackshort`, `:remotename`, and `:remoteref` options as `upstream` does. Produces an empty string if no `@{push}` ref is configured."
msgstr "本地引用的名称，代表显示引用的 `@{push}`位置。与 `upstream` 相同，尊重 `:short`、`:lstrip`、`:rstrip`、`:track`、`:trackshort`、`:remotename` 和 `:remoteref`选项。如果没有配置 `@{push}` ref，则产生空字符串。"

#. type: Labeled list
#: en/git-for-each-ref.txt:183 en/git.txt:427
#, no-wrap, placeholders:'HEAD', priority:100
msgid "HEAD"
msgstr "HEAD"

#. type: Plain text
#: en/git-for-each-ref.txt:186
#, placeholders:'HEAD', priority:80
msgid "'*' if HEAD matches current ref (the checked out branch), ' ' otherwise."
msgstr "如果 HEAD 与当前引用（已签出分支）匹配，则为 '*'，否则为 ''。"

#. type: Plain text
#: en/git-for-each-ref.txt:192
#, placeholders:'linkgit:git-config[1]', priority:80
msgid "Change output color. Followed by `:<colorname>`, where color names are described under Values in the \"CONFIGURATION FILE\" section of linkgit:git-config[1]. For example, `%(color:bold red)`."
msgstr "更改输出颜色。后跟 `:<颜色名称>`，其中颜色名称在 linkgit:git-config[1] 的 “配置文件” 部分的 “值” 中有描述。 例如，`%(color:bold red)`。"

#. type: Labeled list
#: en/git-for-each-ref.txt:193
#, no-wrap, priority:80
msgid "align"
msgstr "对齐"

#. type: Plain text
#: en/git-for-each-ref.txt:207
#, ignore-ellipsis, placeholders:'`--quote`', priority:80
msgid "Left-, middle-, or right-align the content between %(align:...) and %(end). The \"align:\" is followed by `width=<width>` and `position=<position>` in any order separated by a comma, where the `<position>` is either left, right or middle, default being left and `<width>` is the total length of the content with alignment. For brevity, the \"width=\" and/or \"position=\" prefixes may be omitted, and bare <width> and <position> used instead. For instance, `%(align:<width>,<position>)`. If the contents length is more than the width then no alignment is performed. If used with `--quote` everything in between %(align:...) and %(end) is quoted, but if nested then only the topmost level performs quoting."
msgstr "将 %(align:...) 和 %(end) 之间的内容左对齐、中间对齐或右对齐。align: \"之后是 `width=<宽度>` 和 `position=<位置>`，顺序不限，中间用逗号隔开，其中 `<位置>` 可以是左对齐、右对齐或中间对齐，默认为左对齐 `<宽度>` 是对齐后内容的总长度。为简洁起见，可以省略前缀 \"width=\" 和/或 \"position=\"，而使用裸露的 <宽度> 和 <位置>。 例如，`%(align:<宽度>,<位置>)`。如果内容长度大于宽度，则不执行对齐。如果与 `--quote` 一起使用，%(align:...) 和 %(end) 之间的所有内容都会被加引号，但如果是嵌套内容，则只有最上层的内容会被加引号。"

#. type: Labeled list
#: en/git-for-each-ref.txt:208
#, no-wrap, priority:80
msgid "if"
msgstr "如果"

#. type: Plain text
#: en/git-for-each-ref.txt:220
#, ignore-ellipsis, placeholders:'HEAD':'HEAD', priority:80
msgid "Used as %(if)...%(then)...%(end) or %(if)...%(then)...%(else)...%(end). If there is an atom with value or string literal after the %(if) then everything after the %(then) is printed, else if the %(else) atom is used, then everything after %(else) is printed. We ignore space when evaluating the string before %(then), this is useful when we use the %(HEAD) atom which prints either \"*\" or \" \" and we want to apply the 'if' condition only on the 'HEAD' ref. Append \":equals=<string>\" or \":notequals=<string>\" to compare the value between the %(if:...) and %(then) atoms with the given string."
msgstr "作为 %(if)...%(then)...%(end) 或 %(if)...%(then)...%(else)...%(end) 使用。 如果在 %(if)之后有一个带值或字符串字面意义的原子，则打印 %(then) 之后的所有内容；如果使用了 %(else) 原子，则打印 %(else) 之后的所有内容。当我们使用 %(HEAD) 原子打印 \"*\" 或 \"\"，并希望仅在 'HEAD' 引用上应用 'if' 条件时，这将非常有用。 添加 \":equals=<字符串>\" 或 \":notequals=<字符串>\" 可将 %(if:...) 原子和 %(then) 原子之间的值与给定字符串进行比较。"

#. type: Labeled list
#: en/git-for-each-ref.txt:221
#, no-wrap, priority:80
msgid "symref"
msgstr "symref"

#. type: Plain text
#: en/git-for-each-ref.txt:226
#, priority:80
msgid "The ref which the given symbolic ref refers to. If not a symbolic ref, nothing is printed. Respects the `:short`, `:lstrip` and `:rstrip` options in the same way as `refname` above."
msgstr "所给符号引用指向的引用。如果不是符号引用，则不会打印任何内容。与上文的 `引用名` 相同，遵从 `:short`、`:lstrip` 和 `:rstrip` 选项。"

#. type: Labeled list
#: en/git-for-each-ref.txt:227
#, no-wrap, priority:80
msgid "signature"
msgstr "signature"

#. type: Plain text
#: en/git-for-each-ref.txt:229
#, priority:80
msgid "The GPG signature of a commit."
msgstr "检查提交的 GPG 签名。"

#. type: Labeled list
#: en/git-for-each-ref.txt:230
#, no-wrap, priority:80
msgid "signature:grade"
msgstr "signature:grade"

#. type: Plain text
#: en/git-for-each-ref.txt:237
#, priority:80
msgid "Show \"G\" for a good (valid) signature, \"B\" for a bad signature, \"U\" for a good signature with unknown validity, \"X\" for a good signature that has expired, \"Y\" for a good signature made by an expired key, \"R\" for a good signature made by a revoked key, \"E\" if the signature cannot be checked (e.g. missing key) and \"N\" for no signature."
msgstr "显示 \"G\" 代表一个好的（有效的）签名，\"B\" 代表一个坏的签名，\"U\" 代表一个有效性未知的好的签名，\"X\" 代表一个已经过期的好的签名，\"Y\" 代表一个由过期的钥匙制作的好的签名，\"R\" 代表一个由撤销的密钥制作的好的签名，\"E\" 如果不能检查签名（如缺少密钥），\"N\" 代表没有签名。"

#. type: Labeled list
#: en/git-for-each-ref.txt:238
#, no-wrap, priority:80
msgid "signature:signer"
msgstr "signature:signer"

#. type: Plain text
#: en/git-for-each-ref.txt:240
#, priority:80
msgid "The signer of the GPG signature of a commit."
msgstr "提交的 GPG 签名的签名者。"

#. type: Labeled list
#: en/git-for-each-ref.txt:241
#, no-wrap, priority:80
msgid "signature:key"
msgstr "signature:key"

#. type: Plain text
#: en/git-for-each-ref.txt:243
#, priority:80
msgid "The key of the GPG signature of a commit."
msgstr "提交的 GPG 签名密钥。"

#. type: Labeled list
#: en/git-for-each-ref.txt:244
#, no-wrap, priority:80
msgid "signature:fingerprint"
msgstr "signature:fingerprint"

#. type: Plain text
#: en/git-for-each-ref.txt:246
#, priority:80
msgid "The fingerprint of the GPG signature of a commit."
msgstr "提交的 GPG 签名指纹。"

#. type: Labeled list
#: en/git-for-each-ref.txt:247
#, no-wrap, priority:80
msgid "signature:primarykeyfingerprint"
msgstr "signature:primarykeyfingerprint"

#. type: Plain text
#: en/git-for-each-ref.txt:249
#, priority:80
msgid "The primary key fingerprint of the GPG signature of a commit."
msgstr "提交的 GPG 签名的主键指纹。"

#. type: Labeled list
#: en/git-for-each-ref.txt:250
#, no-wrap, priority:80
msgid "signature:trustlevel"
msgstr "signature:trustlevel"

#. type: Plain text
#: en/git-for-each-ref.txt:253
#, priority:80
msgid "The trust level of the GPG signature of a commit. Possible outputs are `ultimate`, `fully`, `marginal`, `never` and `undefined`."
msgstr "提交的 GPG 签名的信任级别。可能的输出包括 `ultimate` ， `fully` ， `marginal` ， `never` 和 `undifined`。"

#. type: Labeled list
#: en/git-for-each-ref.txt:254
#, no-wrap, priority:80
msgid "worktreepath"
msgstr "工作目录树路径"

#. type: Plain text
#: en/git-for-each-ref.txt:258
#, priority:80
msgid "The absolute path to the worktree in which the ref is checked out, if it is checked out in any linked worktree. Empty string otherwise."
msgstr "如果引用在任何链接的工作树中签出，则该引用签出所在工作目录的绝对路径。否则为空字符串。"

#. type: Labeled list
#: en/git-for-each-ref.txt:259
#, no-wrap, priority:80
msgid "ahead-behind:<committish>"
msgstr "ahead-behind:<提交对象>"

#. type: Plain text
#: en/git-for-each-ref.txt:263
#, priority:80
msgid "Two integers, separated by a space, demonstrating the number of commits ahead and behind, respectively, when comparing the output ref to the `<committish>` specified in the format."
msgstr "用空格分隔的两个整数，分别表示将输出引用与格式中指定的 `<提交对象>` 进行比较时，超前和滞后提交的次数。"

#. type: Labeled list
#: en/git-for-each-ref.txt:264
#, no-wrap, priority:80
msgid "describe[:options]"
msgstr "describe[:options]"

#. type: Plain text
#: en/git-for-each-ref.txt:268
#, placeholders:'linkgit:git-describe[1]', priority:80
msgid "A human-readable name, like linkgit:git-describe[1]; empty string for undescribable commits. The `describe` string may be followed by a colon and one or more comma-separated options."
msgstr "人类可读的名字，像 linkgit:git-describe[1]；空字符串表示不可描述的提交。 `describe` 字符串后面可以有冒号和零个或多个逗号分隔的选项。 当标签同时被添加或删除时，描述可能不一致。"

#. type: Labeled list
#: en/git-for-each-ref.txt:270
#, no-wrap, priority:80
msgid "tags=<bool-value>"
msgstr "tags=<布尔值>"

#. type: Plain text
#: en/git-for-each-ref.txt:274
#, placeholders:'linkgit:git-describe[1]', priority:80
msgid "Instead of only considering annotated tags, consider lightweight tags as well; see the corresponding option in linkgit:git-describe[1] for details."
msgstr "详细内容请参见 linkgit:git-describe[1] 中的相应选项。"

#. type: Labeled list
#: en/git-for-each-ref.txt:274
#, no-wrap, priority:80
msgid "abbrev=<number>"
msgstr "abbrev=<数字>"

#. type: Plain text
#: en/git-for-each-ref.txt:277
#, placeholders:'linkgit:git-describe[1]', priority:80
msgid "Use at least <number> hexadecimal digits; see the corresponding option in linkgit:git-describe[1] for details."
msgstr "至少使用 <数字> 十六进制数字；详见 linkgit:git-describe[1] 中的相应选项。"

#. type: Labeled list
#: en/git-for-each-ref.txt:277
#, no-wrap, priority:80
msgid "match=<pattern>"
msgstr "match=<模式>"

#. type: Plain text
#: en/git-for-each-ref.txt:281
#, placeholders:'linkgit:git-describe[1]', priority:80
msgid "Only consider tags matching the given `glob(7)` pattern, excluding the \"refs/tags/\" prefix; see the corresponding option in linkgit:git-describe[1] for details."
msgstr "只考虑与给定的 `glob(7)` 模式匹配的标签，不包括 \"refs/tags/\" 前缀；详见 linkgit:git-describe[1] 中的相应选项。"

#. type: Labeled list
#: en/git-for-each-ref.txt:281
#, no-wrap, priority:80
msgid "exclude=<pattern>"
msgstr "exclude=<模式>"

#. type: Plain text
#: en/git-for-each-ref.txt:285
#, placeholders:'linkgit:git-describe[1]', priority:80
msgid "Do not consider tags matching the given `glob(7)` pattern, excluding the \"refs/tags/\" prefix; see the corresponding option in linkgit:git-describe[1] for details."
msgstr "不考虑与给定的 `glob(7)` 模式（不包括 \"refs/tags/\" 前缀）匹配的标签；详情参见 linkgit:git-describe[1] 中的相应选项。"

#. type: Plain text
#: en/git-for-each-ref.txt:292
#, priority:80
msgid "In addition to the above, for commit and tag objects, the header field names (`tree`, `parent`, `object`, `type`, and `tag`) can be used to specify the value in the header field. Fields `tree` and `parent` can also be used with modifier `:short` and `:short=<length>` just like `objectname`."
msgstr "除上述内容外，对于提交和标记对象，头字段名称（ `tree` ， `parent` ， `object` ， `type` 和 `tag` ）可用于指定头字段名称中的值。 字段 `tree` 和 `parent` 也可以与修饰符 `:short` 和 `:short=<长度>` 一起使用，就像 `对象名` 一样。"

#. type: Plain text
#: en/git-for-each-ref.txt:297
#, priority:80
msgid "For commit and tag objects, the special `creatordate` and `creator` fields will correspond to the appropriate date or name-email-date tuple from the `committer` or `tagger` fields depending on the object type. These are intended for working on a mix of annotated and lightweight tags."
msgstr "对于提交和标记对象，特殊的 `creatordate` 和 `creator` 字段将与 `committer` 或 `tagger` 字段中的相应日期或姓名-电子邮件-日期元组相对应，具体取决于对象类型。 这些都是为混合使用注释标记和轻量级标记而设计的。"

#. type: Plain text
#: en/git-for-each-ref.txt:301
#, priority:80
msgid "For tag objects, a `fieldname` prefixed with an asterisk (`*`) expands to the `fieldname` value of the peeled object, rather than that of the tag object itself."
msgstr "对于标签对象，前缀为星号 (`*`) 的 `fieldname` 会扩展为剥离对象的 `fieldname` 值，而不是标签对象本身的值。"

#. type: Plain text
#: en/git-for-each-ref.txt:312
#, placeholders:'mailmap.file':'mailmap.blob':'linkgit:gitmailmap[5]', priority:80
msgid "Fields that have name-email-date tuple as its value (`author`, `committer`, and `tagger`) can be suffixed with `name`, `email`, and `date` to extract the named component. For email fields (`authoremail`, `committeremail` and `taggeremail`), `:trim` can be appended to get the email without angle brackets, and `:localpart` to get the part before the `@` symbol out of the trimmed email. In addition to these, the `:mailmap` option and the corresponding `:mailmap,trim` and `:mailmap,localpart` can be used (order does not matter) to get values of the name and email according to the .mailmap file or according to the file set in the mailmap.file or mailmap.blob configuration variable (see linkgit:gitmailmap[5])."
msgstr "以姓名-电子邮件-日期元组为值的字段（ `author` ， `committer` 和 `tagger`）可以后缀 `name` ， `email` 和 `date`，以提取命名组件。 对于电子邮件字段（ `authoremail` ， `committeremail` 和 `taggeremail` ），可添加 `:trim` 以获取不带角括号的电子邮件，并添加 `:localpart` 以从修剪后的电子邮件中获取 `@` 符号之前的部分。除此之外，还可以使用 `:mailmap` 选项和相应的 `:mailmap,trim` 和 `:mailmap,localpart`（顺序并不重要），根据 .mailmap 文件或 mailmap.file 或 mailmap.blob 配置变量（参见 linkgit:gitmailmap[5]）中设置的文件，获取姓名和电子邮件的值。"

#. type: Plain text
#: en/git-for-each-ref.txt:314
#, priority:80
msgid "The raw data in an object is `raw`."
msgstr "对象中的原始数据是 `raw`。"

#. type: Labeled list
#: en/git-for-each-ref.txt:315
#, no-wrap, priority:80
msgid "raw:size"
msgstr "raw:size"

#. type: Plain text
#: en/git-for-each-ref.txt:317
#, priority:80
msgid "The raw data size of the object."
msgstr "对象的原始数据大小。"

#. type: Plain text
#: en/git-for-each-ref.txt:321
#, placeholders:'`--format=':'`--python`':'`--shell`':'`--tcl`', priority:80
msgid "Note that `--format=%(raw)` can not be used with `--python`, `--shell`, `--tcl`, because such language may not support arbitrary binary data in their string variable type."
msgstr "请注意，`--format=%(raw)` 不能与 `--python` ， `--shell` 和 `--tcl` 一起使用，因为这些语言的字符串变量类型可能不支持任意二进制数据。"

#. type: Plain text
#: en/git-for-each-ref.txt:324
#, priority:80
msgid "The message in a commit or a tag object is `contents`, from which `contents:<part>` can be used to extract various parts out of:"
msgstr "提交或标记对象中的信息是 `contents`，从中可使用 `contents:<部分>` 提取不同部分："

#. type: Labeled list
#: en/git-for-each-ref.txt:325
#, no-wrap, priority:80
msgid "contents:size"
msgstr "contents:size"

#. type: Plain text
#: en/git-for-each-ref.txt:327
#, priority:80
msgid "The size in bytes of the commit or tag message."
msgstr "提交或标记信息的大小（字节）。"

#. type: Labeled list
#: en/git-for-each-ref.txt:328
#, no-wrap, priority:80
msgid "contents:subject"
msgstr "contents:subject"

#. type: Plain text
#: en/git-for-each-ref.txt:335
#, priority:80
msgid "The first paragraph of the message, which typically is a single line, is taken as the \"subject\" of the commit or the tag message. Instead of `contents:subject`, field `subject` can also be used to obtain same results. `:sanitize` can be appended to `subject` for subject line suitable for filename."
msgstr "信息的第一段（通常为单行）将作为提交或标记信息的 \"主题\"。 也可以使用字段 `subject` 代替 `contents:subject` ，以获得相同的结果。对于适合文件名的主题行，可在 `subject` 中添加 `:sanitize`。"

#. type: Labeled list
#: en/git-for-each-ref.txt:336
#, no-wrap, priority:80
msgid "contents:body"
msgstr "contents:body"

#. type: Plain text
#: en/git-for-each-ref.txt:339
#, priority:80
msgid "The remainder of the commit or the tag message that follows the \"subject\"."
msgstr "\"subject\" 后的其余提交内容或标记信息。"

#. type: Labeled list
#: en/git-for-each-ref.txt:340
#, no-wrap, priority:80
msgid "contents:signature"
msgstr "contents:signature"

#. type: Plain text
#: en/git-for-each-ref.txt:342
#, priority:80
msgid "The optional GPG signature of the tag."
msgstr "tag的可选GPG签名。"

#. type: Labeled list
#: en/git-for-each-ref.txt:343
#, no-wrap, priority:80
msgid "contents:lines=N"
msgstr "contents:lines=N"

#. type: Plain text
#: en/git-for-each-ref.txt:345
#, priority:80
msgid "The first `N` lines of the message."
msgstr "信息的前 `N` 行。"

#. type: Plain text
#: en/git-for-each-ref.txt:350
#, placeholders:'linkgit:git-interpret-trailers[1]':'linkgit:git-log[1]', priority:80
msgid "Additionally, the trailers as interpreted by linkgit:git-interpret-trailers[1] are obtained as `trailers[:options]` (or by using the historical alias `contents:trailers[:options]`). For valid [:option] values see `trailers` section of linkgit:git-log[1]."
msgstr "此外，linkgit:git-interpret-trailers[1] 中提到的的尾注可作为 `trailers[:options]` 获取（或使用历史别名 `contents:trailers[:options]`）。有关有效的 [:option] 值，请参阅 linkgit:git-log[1] 的 `trailers` 部分。"

#. type: Plain text
#: en/git-for-each-ref.txt:354
#, priority:80
msgid "For sorting purposes, fields with numeric values sort in numeric order (`objectsize`, `authordate`, `committerdate`, `creatordate`, `taggerdate`). All other fields are used to sort in their byte-value order."
msgstr "为便于排序，具有数值的字段按数值顺序排序（ `objectsize` , `authordate` , `committerdate` , `creatordate` , `taggerdate` ）。 所有其他字段都按字节值顺序排序。"

#. type: Plain text
#: en/git-for-each-ref.txt:357
#, priority:80
msgid "There is also an option to sort by versions, this can be done by using the fieldname `version:refname` or its alias `v:refname`."
msgstr "还有一个按版本排序的选项，可以通过使用字段名 `version:refname` 或其别名 `v:refname` 来实现。"

#. type: Plain text
#: en/git-for-each-ref.txt:361
#, priority:80
msgid "In any case, a field name that refers to a field inapplicable to the object referred by the ref does not cause an error. It returns an empty string instead."
msgstr "在任何情况下，如果字段名指向的字段不适用于引用所引用的对象，都不会导致错误。 它会返回一个空字符串替代输出。"

#. type: Plain text
#: en/git-for-each-ref.txt:365
#, placeholders:'`--date`':'linkgit:git-rev-list[1]', priority:80
msgid "As a special case for the date-type fields, you may specify a format for the date by adding `:` followed by date format name (see the values the `--date` option to linkgit:git-rev-list[1] takes)."
msgstr "作为日期类型字段的一种特殊情况，您可以在日期格式名称后添加 `:` 来指定日期的格式（参见 linkgit:git-rev-list[1] 的 `--date` 选项的取值）。"

#. type: Plain text
#: en/git-for-each-ref.txt:368
#, placeholders:'$open', priority:80
msgid "Some atoms like %(align) and %(if) always require a matching %(end). We call them \"opening atoms\" and sometimes denote them as %($open)."
msgstr "有些原子，如 %(align) 和 %(if) 总是需要一个匹配的 %(end)。 我们称它们为 “起始原子”，有时用 %($open) 表示。"

#. type: Plain text
#: en/git-for-each-ref.txt:373
#, priority:80
msgid "When a scripting language specific quoting is in effect, everything between a top-level opening atom and its matching %(end) is evaluated according to the semantics of the opening atom and only its result from the top-level is quoted."
msgstr "当脚本语言的特定引用生效时，顶层起始原子和与其匹配的 %(end) 之间的所有内容都会根据起始原子的语义进行评估，只有其从顶层得到的结果才会被引用。"

#. type: Plain text
#: en/git-for-each-ref.txt:380
#, priority:80
msgid "An example directly producing formatted text. Show the most recent 3 tagged commits:"
msgstr "直接生成格式化文本的示例。 显示最近 3 次标记的提交："

#. type: delimited block -
#: en/git-for-each-ref.txt:383 en/git-for-each-ref.txt:399 en/git-for-each-ref.txt:413 en/git-bisect-lk2009.txt:933
#, no-wrap, priority:100
msgid "#!/bin/sh\n"
msgstr "#!/bin/sh\n"

#. type: delimited block -
#: en/git-for-each-ref.txt:389
#, no-wrap, placeholders:'git for-each-ref':'--count=3':'--sort=':'--format=', priority:80
msgid ""
"git for-each-ref --count=3 --sort='-*authordate' \\\n"
"--format='From: %(*authorname) %(*authoremail)\n"
"Subject: %(*subject)\n"
"Date: %(*authordate)\n"
"Ref: %(*refname)\n"
msgstr ""
"git for-each-ref --count=3 --sort='-*authordate' \\\n"
"--format='From: %(*作者名) %(*作者邮箱)\n"
"Subject: %(*主题)\n"
"Date: %(*authordate)\n"
"Ref: %(*引用名)\n"

#. type: delimited block -
#: en/git-for-each-ref.txt:392
#, no-wrap, priority:80
msgid ""
"%(*body)\n"
"' 'refs/tags'\n"
msgstr ""
"%(*body)\n"
"' 'refs/tags'\n"

#. type: Plain text
#: en/git-for-each-ref.txt:397
#, placeholders:'--shell', priority:80
msgid "A simple example showing the use of shell eval on the output, demonstrating the use of --shell. List the prefixes of all heads:"
msgstr "一个简单的示例，说明如何在输出中使用 shell eval，并演示如何使用 --shell。 列出所有文件头的前缀："

#. type: delimited block -
#: en/git-for-each-ref.txt:406
#, no-wrap, placeholders:'git for-each-ref':'--shell':'--format=':'$entry':'$ref', priority:80
msgid ""
"git for-each-ref --shell --format=\"ref=%(refname)\" refs/heads | \\\n"
"while read entry\n"
"do\n"
"\teval \"$entry\"\n"
"\techo `dirname $ref`\n"
"done\n"
msgstr ""
"git for-each-ref --shell --format=\"ref=%(refname)\" refs/heads | \\\n"
"while read entry\n"
"do\n"
"\teval \"$entry\"\n"
"\techo `dirname $ref`\n"
"done\n"

#. type: Plain text
#: en/git-for-each-ref.txt:411
#, priority:80
msgid "A bit more elaborate report on tags, demonstrating that the format may be an entire script:"
msgstr "关于标签的报告更详细一些，表明格式可能是整个脚本："

#. type: delimited block -
#: en/git-for-each-ref.txt:418
#, no-wrap, priority:80
msgid ""
"fmt='\n"
"\tr=%(refname)\n"
"\tt=%(*objecttype)\n"
"\tT=${r#refs/tags/}\n"
msgstr ""
"fmt='\n"
"\tr=%(引用名)\n"
"\tt=%(*对象类型)\n"
"\tT=${r#refs/tags/}\n"

#. type: delimited block -
#: en/git-for-each-ref.txt:425
#, no-wrap, priority:80
msgid ""
"\to=%(*objectname)\n"
"\tn=%(*authorname)\n"
"\te=%(*authoremail)\n"
"\ts=%(*subject)\n"
"\td=%(*authordate)\n"
"\tb=%(*body)\n"
msgstr ""
"\to=%(*objectname)\n"
"\tn=%(*authorname)\n"
"\te=%(*authoremail)\n"
"\ts=%(*subject)\n"
"\td=%(*authordate)\n"
"\tb=%(*body)\n"

#. type: delimited block -
#: en/git-for-each-ref.txt:444
#, no-wrap, placeholders:'$kind', priority:80
msgid ""
"\tkind=Tag\n"
"\tif test \"z$t\" = z\n"
"\tthen\n"
"\t\t# could be a lightweight tag\n"
"\t\tt=%(objecttype)\n"
"\t\tkind=\"Lightweight tag\"\n"
"\t\to=%(objectname)\n"
"\t\tn=%(authorname)\n"
"\t\te=%(authoremail)\n"
"\t\ts=%(subject)\n"
"\t\td=%(authordate)\n"
"\t\tb=%(body)\n"
"\tfi\n"
"\techo \"$kind $T points at a $t object $o\"\n"
"\tif test \"z$t\" = zcommit\n"
"\tthen\n"
"\t\techo \"The commit was authored by $n $e\n"
"at $d, and titled\n"
msgstr ""
"\tkind=Tag\n"
"\tif test \"z$t\" = z\n"
"\tthen\n"
"\t\t# could be a lightweight tag\n"
"\t\tt=%(对象类型)\n"
"\t\tkind=\"Lightweight tag\"\n"
"\t\to=%(对象名)\n"
"\t\tn=%(作者名)\n"
"\t\te=%(作者邮箱)\n"
"\t\ts=%(主题)\n"
"\t\td=%(authordate)\n"
"\t\tb=%(主体)\n"
"\tfi\n"
"\techo \"$kind $T points at a $t object $o\"\n"
"\tif test \"z$t\" = zcommit\n"
"\tthen\n"
"\t\techo \"The commit was authored by $n $e\n"
"at $d, and titled\n"

#. type: delimited block -
#: en/git-for-each-ref.txt:446
#, no-wrap, priority:80
msgid "    $s\n"
msgstr "    $s\n"

#. type: delimited block -
#: en/git-for-each-ref.txt:453
#, no-wrap, priority:80
msgid ""
"Its message reads as:\n"
"\"\n"
"\t\techo \"$b\" | sed -e \"s/^/    /\"\n"
"\t\techo\n"
"\tfi\n"
"'\n"
msgstr ""
"其信息如下：\n"
"\"\n"
"\t\techo \"$b\" | sed -e \"s/^/    /\"\n"
"\t\techo\n"
"\tfi\n"
"'\n"

#. type: delimited block -
#: en/git-for-each-ref.txt:459
#, no-wrap, placeholders:'git for-each-ref':'--shell':'--format=':'$fmt':'--sort=':'--sort=-taggerdate':'$eval', priority:80
msgid ""
"eval=`git for-each-ref --shell --format=\"$fmt\" \\\n"
"\t--sort='*objecttype' \\\n"
"\t--sort=-taggerdate \\\n"
"\trefs/tags`\n"
"eval \"$eval\"\n"
msgstr ""
"eval=`git for-each-ref --shell --format=\"$fmt\" \\\n"
"\t--sort='*对象类型' \\\n"
"\t--sort=-taggerdate \\\n"
"\trefs/tags`\n"
"eval \"$eval\"\n"

#. type: Plain text
#: en/git-for-each-ref.txt:464
#, ignore-ellipsis, priority:80
msgid "An example to show the usage of %(if)...%(then)...%(else)...%(end). This prefixes the current branch with a star."
msgstr "举例说明 %(if)...%(then)...%(else)...%(end) 的用法。 这会给当前分支加上星号前缀。"

#. type: delimited block -
#: en/git-for-each-ref.txt:467
#, no-wrap, placeholders:'git for-each-ref':'--format=':'HEAD', priority:80
msgid "git for-each-ref --format=\"%(if)%(HEAD)%(then)* %(else)  %(end)%(refname:short)\" refs/heads/\n"
msgstr "git for-each-ref --format=\"%(if)%(HEAD)%(then)* %(else)  %(end)%(refname:short)\" refs/heads/\n"

#. type: Plain text
#: en/git-for-each-ref.txt:472
#, ignore-ellipsis, priority:80
msgid "An example to show the usage of %(if)...%(then)...%(end). This prints the authorname, if present."
msgstr "举例说明 %(if)...%(then)...%(end)的用法。 如果存在授权名称，则打印该名称。"

#. type: delimited block -
#: en/git-for-each-ref.txt:475
#, no-wrap, placeholders:'git for-each-ref':'--format=', priority:80
msgid "git for-each-ref --format=\"%(refname)%(if)%(authorname)%(then) Authored by: %(authorname)%(end)\"\n"
msgstr "git for-each-ref --format=\"%(refname)%(if)%(authorname)%(then) Authored by: %(authorname)%(end)\"\n"

#. type: Title =
#: en/git-format-patch.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-format-patch(1)"
msgstr "git-format-patch(1)"

#. type: Plain text
#: en/git-format-patch.txt:7
#, placeholders:'git-format-patch', priority:100
msgid "git-format-patch - Prepare patches for e-mail submission"
msgstr "git-format-patch - 为提交电子邮件准备补丁"

#. type: Plain text
#: en/git-format-patch.txt:35
#, no-wrap, placeholders:'git format-patch':'--output-directory':'--stdout]':'[--no-thread':'--thread':'--attach':'--inline':'--no-attach]':'--signoff]':'[--signature=':'--no-signature]':'[--signature-file=':'--numbered':'--no-numbered]':'[--start-number':'[--numbered-files]':'[--in-reply-to=':'[--suffix=':'[--ignore-if-in-upstream]':'[--always]':'[--cover-from-description=':'[--rfc]':'[--subject-prefix=':'--reroll-count':'[--to=':'[--cc=':'[--quiet]':'[--no-notes':'--notes':'[--interdiff=':'[--range-diff=':'[--creation-factor=':'[--filename-max-length=':'[--progress]', priority:100
msgid ""
"'git format-patch' [-k] [(-o|--output-directory) <dir> | --stdout]\n"
"\t\t   [--no-thread | --thread[=<style>]]\n"
"\t\t   [(--attach|--inline)[=<boundary>] | --no-attach]\n"
"\t\t   [-s | --signoff]\n"
"\t\t   [--signature=<signature> | --no-signature]\n"
"\t\t   [--signature-file=<file>]\n"
"\t\t   [-n | --numbered | -N | --no-numbered]\n"
"\t\t   [--start-number <n>] [--numbered-files]\n"
"\t\t   [--in-reply-to=<message-id>] [--suffix=.<sfx>]\n"
"\t\t   [--ignore-if-in-upstream] [--always]\n"
"\t\t   [--cover-from-description=<mode>]\n"
"\t\t   [--rfc] [--subject-prefix=<subject-prefix>]\n"
"\t\t   [(--reroll-count|-v) <n>]\n"
"\t\t   [--to=<email>] [--cc=<email>]\n"
"\t\t   [--[no-]cover-letter] [--quiet]\n"
"\t\t   [--[no-]encode-email-headers]\n"
"\t\t   [--no-notes | --notes[=<ref>]]\n"
"\t\t   [--interdiff=<previous>]\n"
"\t\t   [--range-diff=<previous> [--creation-factor=<percent>]]\n"
"\t\t   [--filename-max-length=<n>]\n"
"\t\t   [--progress]\n"
"\t\t   [<common-diff-options>]\n"
"\t\t   [ <since> | <revision-range> ]\n"
msgstr ""
"'git format-patch' [-k] [(-o|--output-directory) <dir> | --stdout]\n"
"\t\t   [--no-thread | --thread[=<风格>]]\n"
"\t\t   [(--attach|--inline)[=<boundary>] | --no-attach]\n"
"\t\t   [-s | --signoff]\n"
"\t\t   [--signature=<signature> | --no-signature]\n"
"\t\t   [--signature-file=<文件>]\n"
"\t\t   [-n | --numbered | -N | --no-numbered]\n"
"\t\t   [--start-number <n>] [--numbered-files]\n"
"\t\t   [--in-reply-to=<message id>] [--suffix=.<sfx>]\n"
"\t\t   [--ignore-if-in-upstream] [--always]\n"
"\t\t   [--cover-from-description=<模式>]\n"
"\t\t   [--rfc] [--subject-prefix=<主题前缀>]\n"
"\t\t   [(--reroll-count|-v) <n>]\n"
"\t\t   [--to=<e-mail>] [--cc=<e-mail>]\n"
"\t\t   [--[no-]cover-letter] [--quiet]\n"
"\t\t   [--[no-]encode-email-headers]\n"
"\t\t   [--no-notes | --notes[=<引用>]]\n"
"\t\t   [--interdiff=<以前的>]\n"
"\t\t   [--range-diff=<以前的> [--creation-factor=<百分比>]]\n"
"\t\t   [--filename-max-length=<n>]\n"
"\t\t   [--progress]\n"
"\t\t   [<普通差异选项>]\n"
"\t\t   [ <从> | <修订范围> ]\n"

#. type: Plain text
#: en/git-format-patch.txt:43
#, priority:100
msgid "Prepare each non-merge commit with its \"patch\" in one \"message\" per commit, formatted to resemble a UNIX mailbox. The output of this command is convenient for e-mail submission or for use with 'git am'."
msgstr "将每个非合并提交及其 “补丁” 准备在每个提交的一个 “消息” 中，格式类似于 UNIX 邮箱。 这条命令的输出便于提交电子邮件或与 \"git am\" 一起使用。"

#. type: Plain text
#: en/git-format-patch.txt:45
#, priority:100
msgid "A \"message\" generated by the command consists of three parts:"
msgstr "命令产生的 \"信息\" 由三部分组成："

#. type: Plain text
#: en/git-format-patch.txt:52
#, priority:100
msgid "A brief metadata header that begins with `From <commit>` with a fixed `Mon Sep 17 00:00:00 2001` datestamp to help programs like \"file(1)\" to recognize that the file is an output from this command, fields that record the author identity, the author date, and the title of the change (taken from the first paragraph of the commit log message)."
msgstr "一个简短的元数据头，以 \"From <提交>\" 开始，带有固定的 \"Mon Sep 17 00:00:00 2001\" 的日期，以帮助 \"file(1)\" 等程序识别该文件是该命令的输出，记录作者身份、作者日期和修改标题的字段（取自提交日志信息的第一段）。"

#. type: Plain text
#: en/git-format-patch.txt:54
#, priority:100
msgid "The second and subsequent paragraphs of the commit log message."
msgstr "提交日志信息的第二段和后续段落。"

#. type: Plain text
#: en/git-format-patch.txt:57
#, placeholders:'--stat':'linkgit:git-diff[1]', priority:100
msgid "The \"patch\", which is the \"diff -p --stat\" output (see linkgit:git-diff[1]) between the commit and its parent."
msgstr "“补丁”，也就是该提交和其父辈之间的 \"diff -p --stat\" 输出（见 linkgit:git-diff[1]）。"

#. type: Plain text
#: en/git-format-patch.txt:60
#, priority:100
msgid "The log message and the patch are separated by a line with a three-dash line."
msgstr "日志信息和补丁之间用三条虚线隔开。"

#. type: Plain text
#: en/git-format-patch.txt:62
#, priority:100
msgid "There are two ways to specify which commits to operate on."
msgstr "有两种方法可以指定要对哪些提交进行操作。"

#. type: Plain text
#: en/git-format-patch.txt:66
#, priority:100
msgid "A single commit, <since>, specifies that the commits leading to the tip of the current branch that are not in the history that leads to the <since> to be output."
msgstr "单一的提交，<从>，指定导致当前分支顶端的提交不在导致 <从> 的历史中，要被输出。"

#. type: Plain text
#: en/git-format-patch.txt:70
#, placeholders:'linkgit:gitrevisions[7]', priority:100
msgid "Generic <revision-range> expression (see \"SPECIFYING REVISIONS\" section in linkgit:gitrevisions[7]) means the commits in the specified range."
msgstr "通用的 <修订范围> 表达式（见 linkgit:gitrevisions[7]中的 \"指定修订\" 一节）表示指定范围内的提交。"

#. type: Plain text
#: en/git-format-patch.txt:76
#, placeholders:'`--root`':'git format-patch':'--root':'git format-patch', priority:100
msgid "The first rule takes precedence in the case of a single <commit>. To apply the second rule, i.e., format everything since the beginning of history up until <commit>, use the `--root` option: `git format-patch --root <commit>`. If you want to format only <commit> itself, you can do this with `git format-patch -1 <commit>`."
msgstr "在只有一个 <提交> 的情况下，第一条规则具有优先权。 要应用第二条规则，即格式化从历史开始到 <提交> 为止的所有内容，使用 `--root` 选项：`git format-patch --root <提交>`。 如果你只想格式化 <提交> 本身，你可以用`git format-patch -1 <提交>`来做。"

#. type: Plain text
#: en/git-format-patch.txt:83
#, placeholders:'`--numbered-files`':'`--stdout`', priority:100
msgid "By default, each output file is numbered sequentially from 1, and uses the first line of the commit message (massaged for pathname safety) as the filename. With the `--numbered-files` option, the output file names will only be numbers, without the first line of the commit appended. The names of the output files are printed to standard output, unless the `--stdout` option is specified."
msgstr "默认情况下，每个输出文件从 1 开始依次编号，并使用提交信息的第一行（为保证路径名的安全而进行了调整）作为文件名。使用 `--numbered-files` 选项，输出文件名将只有数字，而没有附加提交信息的第一行。 除非指定 `--stdout` 选项，否则输出文件的名称将被打印到标准输出。"

#. type: Plain text
#: en/git-format-patch.txt:91
#, placeholders:'`-o`':'format.outputDirectory':'`-o`':'format.outputDirectory':'format.outputDirectory', priority:100
msgid "If `-o` is specified, output files are created in <dir>. Otherwise they are created in the current working directory. The default path can be set with the `format.outputDirectory` configuration option. The `-o` option takes precedence over `format.outputDirectory`. To store patches in the current working directory even when `format.outputDirectory` points elsewhere, use `-o .`. All directory components will be created."
msgstr "如果指定了 `-o`，输出文件将在<目录>创建。 否则，它们将在当前工作目录下创建。默认路径可以通过 `format.outputDirectory` 配置选项来设置。 `-o` 选项优先于 `format.outputDirectory`。 要在当前工作目录下存储补丁，即使 `format.outputDirectory` 指向其他地方，使用 `-o .`。所有的目录组件都将被创建。"

#. type: Plain text
#: en/git-format-patch.txt:95
#, placeholders:'linkgit:git-commit[1]', priority:100
msgid "By default, the subject of a single patch is \"[PATCH] \" followed by the concatenation of lines from the commit message up to the first blank line (see the DISCUSSION section of linkgit:git-commit[1])."
msgstr "默认情况下，单个补丁的主题是 \"[PATCH]\"，后面是提交信息到第一个空行的串联（见 linkgit:git-commit[1] 的讨论部分）。"

#. type: Plain text
#: en/git-format-patch.txt:99
#, placeholders:'`-n`':'`-N`', priority:100
msgid "When multiple patches are output, the subject prefix will instead be \"[PATCH n/m] \". To force 1/1 to be added for a single patch, use `-n`. To omit patch numbers from the subject, use `-N`."
msgstr "当输出多个补丁时，主题前缀将改为 \"[PATCH n/m] \"。 要强制为单个补丁添加 1/1，使用 `-n`。 要从主题中省略补丁编号，使用 `-N`。"

#. type: Plain text
#: en/git-format-patch.txt:104
#, placeholders:'`--thread`':'git-format-patch', priority:100
msgid "If given `--thread`, `git-format-patch` will generate `In-Reply-To` and `References` headers to make the second and subsequent patch mails appear as replies to the first mail; this also generates a `Message-ID` header to reference."
msgstr "如果给出 `--thread`，`git-format-patch` 将生成 `In-Reply-To` 和 `References` 头，使第二封和随后的补丁邮件显示为对第一封邮件的回复；这也会生成一个 `Message-ID` 头供参考。"

#. type: Labeled list
#: en/git-format-patch.txt:110
#, no-wrap, priority:100
msgid "-<n>"
msgstr "-<n>"

#. type: Plain text
#: en/git-format-patch.txt:112
#, priority:100
msgid "Prepare patches from the topmost <n> commits."
msgstr "从最上面的 <n> 个提交中准备补丁。"

#. type: Labeled list
#: en/git-format-patch.txt:113
#, no-wrap, priority:100
msgid "-o <dir>"
msgstr "-o <目录>"

#. type: Labeled list
#: en/git-format-patch.txt:114
#, no-wrap, placeholders:'--output-directory', priority:100
msgid "--output-directory <dir>"
msgstr "--output-directory <目录>"

#. type: Plain text
#: en/git-format-patch.txt:117
#, priority:100
msgid "Use <dir> to store the resulting files, instead of the current working directory."
msgstr "使用 <目录> 来存储结果文件，而不是当前工作目录。"

#. type: Labeled list
#: en/git-format-patch.txt:119 en/git-shortlog.txt:30
#, ignore-same, no-wrap, priority:260
msgid "--numbered"
msgstr "--numbered"

#. type: Plain text
#: en/git-format-patch.txt:121
#, priority:100
msgid "Name output in '[PATCH n/m]' format, even with a single patch."
msgstr "以 '[PATCH n/m]' 的格式输出名称，即使只有一个补丁。"

#. type: Labeled list
#: en/git-format-patch.txt:123
#, ignore-same, no-wrap, priority:100
msgid "--no-numbered"
msgstr "--no-numbered"

#. type: Plain text
#: en/git-format-patch.txt:125
#, priority:100
msgid "Name output in '[PATCH]' format."
msgstr "以 '[PATCH]' 格式输出名称。"

#. type: Labeled list
#: en/git-format-patch.txt:126
#, no-wrap, placeholders:'--start-number', priority:100
msgid "--start-number <n>"
msgstr "--start-number <n>"

#. type: Plain text
#: en/git-format-patch.txt:128
#, priority:100
msgid "Start numbering the patches at <n> instead of 1."
msgstr "从<n>开始个给补丁编号，替代默认从1开始。"

#. type: Labeled list
#: en/git-format-patch.txt:129
#, ignore-same, no-wrap, priority:100
msgid "--numbered-files"
msgstr "--numbered-files"

#. type: Plain text
#: en/git-format-patch.txt:132
#, priority:100
msgid "Output file names will be a simple number sequence without the default first line of the commit appended."
msgstr "输出文件名将是一个简单的数字序列，没有附加默认的第一行提交。"

#. type: Labeled list
#: en/git-format-patch.txt:134
#, ignore-same, no-wrap, priority:100
msgid "--keep-subject"
msgstr "--keep-subject"

#. type: Plain text
#: en/git-format-patch.txt:137
#, priority:100
msgid "Do not strip/add '[PATCH]' from the first line of the commit log message."
msgstr "不要从提交日志信息的第一行剥离/添加 '[PATCH]'。"

#. type: Labeled list
#: en/git-format-patch.txt:144 en/git-pack-objects.txt:60
#, ignore-same, no-wrap, priority:100
msgid "--stdout"
msgstr "--stdout"

#. type: Plain text
#: en/git-format-patch.txt:147
#, priority:100
msgid "Print all commits to the standard output in mbox format, instead of creating a file for each one."
msgstr "以 mbox 格式将所有的提交打印到标准输出，而不是为每个提交创建一个文件。"

#. type: Labeled list
#: en/git-format-patch.txt:148
#, no-wrap, placeholders:'--attach', priority:100
msgid "--attach[=<boundary>]"
msgstr "--attach[=<边界>]"

#. type: Plain text
#: en/git-format-patch.txt:152
#, priority:100
msgid "Create multipart/mixed attachment, the first part of which is the commit message and the patch itself in the second part, with `Content-Disposition: attachment`."
msgstr "创建多部分/混合附件，第一部分是提交信息，第二部分是补丁本身，`Content-Disposition: attachment`。"

#. type: Labeled list
#: en/git-format-patch.txt:153
#, ignore-same, no-wrap, priority:100
msgid "--no-attach"
msgstr "--no-attach"

#. type: Plain text
#: en/git-format-patch.txt:156
#, priority:100
msgid "Disable the creation of an attachment, overriding the configuration setting."
msgstr "禁用附件的创建，覆盖配置设置。"

#. type: Labeled list
#: en/git-format-patch.txt:157
#, no-wrap, placeholders:'--inline', priority:100
msgid "--inline[=<boundary>]"
msgstr "--inline[=<边界>]"

#. type: Plain text
#: en/git-format-patch.txt:161
#, priority:100
msgid "Create multipart/mixed attachment, the first part of which is the commit message and the patch itself in the second part, with `Content-Disposition: inline`."
msgstr "创建 multipart/mixed 附件，第一部分是提交信息，第二部分是补丁本身，使用 `Content-Disposition: inline`。"

#. type: Labeled list
#: en/git-format-patch.txt:162
#, no-wrap, placeholders:'--thread', priority:100
msgid "--thread[=<style>]"
msgstr "--thread[=<样式>]"

#. type: Labeled list
#: en/git-format-patch.txt:163
#, ignore-same, no-wrap, priority:100
msgid "--no-thread"
msgstr "--no-thread"

#. type: Plain text
#: en/git-format-patch.txt:168
#, priority:100
msgid "Controls addition of `In-Reply-To` and `References` headers to make the second and subsequent mails appear as replies to the first. Also controls generation of the `Message-ID` header to reference."
msgstr "控制添加 `In-Reply-To` 和 `References` 标头，使第二封及以后的邮件显示为对第一封邮件的回复。 还控制生成 `Message-ID` 头，以便参考。"

#. type: Plain text
#: en/git-format-patch.txt:174
#, placeholders:'`--in-reply-to`', priority:100
msgid "The optional <style> argument can be either `shallow` or `deep`. 'shallow' threading makes every mail a reply to the head of the series, where the head is chosen from the cover letter, the `--in-reply-to`, and the first patch mail, in this order. 'deep' threading makes every mail a reply to the previous one."
msgstr "可选的 <风格> 参数可以是 `shallow` 或 `deep`。 ‘浅’ 线程使每封邮件都是对该系列的头的回复，其中头是从封面信、`--in-reply-to` 和第一个补丁邮件中选择的，按这个顺序。 ‘深’ 线程使每封邮件都是对前一封的回复。"

#. type: Plain text
#: en/git-format-patch.txt:177
#, placeholders:'`--no-thread`':'format.thread':'`--thread`':'`--thread=shallow`', priority:100
msgid "The default is `--no-thread`, unless the `format.thread` configuration is set. `--thread` without an argument is equivalent to `--thread=shallow`."
msgstr "默认是 `--no-thread`，除非设置了 `format.thread` 配置。 没有参数的 `--thread` 等同于 `--thread=shallow`。"

#. type: Plain text
#: en/git-format-patch.txt:181
#, placeholders:'git send-email':'git format-patch':'git send-email', priority:100
msgid "Beware that the default for 'git send-email' is to thread emails itself. If you want `git format-patch` to take care of threading, you will want to ensure that threading is disabled for `git send-email`."
msgstr "请注意，'git send-email' 的默认设置是对邮件本身进行线程处理。 如果你想让 `git format-patch` 负责线程，你要确保 `git send-email` 的线程被禁用。"

#. type: Labeled list
#: en/git-format-patch.txt:182
#, no-wrap, placeholders:'--in-reply-to=', priority:100
msgid "--in-reply-to=<message-id>"
msgstr "--in-reply-to=<消息 ID>"

#. type: Plain text
#: en/git-format-patch.txt:186
#, placeholders:'`--no-thread`', priority:100
msgid "Make the first mail (or all the mails with `--no-thread`) appear as a reply to the given <message-id>, which avoids breaking threads to provide a new patch series."
msgstr "使第一封邮件（或所有带有 `--no-thread` 的邮件）作为给定的 <消息 id> 的回复出现，这可以避免破坏线程以提供一个新的补丁系列。"

#. type: Labeled list
#: en/git-format-patch.txt:187
#, ignore-same, no-wrap, priority:100
msgid "--ignore-if-in-upstream"
msgstr "--ignore-if-in-upstream"

#. type: Plain text
#: en/git-format-patch.txt:193
#, priority:100
msgid "Do not include a patch that matches a commit in <until>..<since>. This will examine all patches reachable from <since> but not from <until> and compare them with the patches being generated, and any patch that matches is ignored."
msgstr "不包括与 <until>...<since> 中的提交相匹配的补丁。 这将检查所有可从 <since> 到达但不在 <until> 的补丁，并将它们与正在生成的补丁进行比较，任何匹配的补丁都将被忽略。"

#. type: Plain text
#: en/git-format-patch.txt:197
#, priority:100
msgid "Include patches for commits that do not introduce any change, which are omitted by default."
msgstr "包括那些没有引入任何变化的提交的补丁，这些补丁默认是省略的。"

#. type: Labeled list
#: en/git-format-patch.txt:198
#, no-wrap, placeholders:'--cover-from-description=', priority:100
msgid "--cover-from-description=<mode>"
msgstr "--cover-from-description=<模式>"

#. type: Plain text
#: en/git-format-patch.txt:201
#, priority:100
msgid "Controls which parts of the cover letter will be automatically populated using the branch's description."
msgstr "控制求职信的哪些部分将使用分支机构的描述自动填充。"

#. type: Plain text
#: en/git-format-patch.txt:206
#, priority:100
msgid "If `<mode>` is `message` or `default`, the cover letter subject will be populated with placeholder text. The body of the cover letter will be populated with the branch's description. This is the default mode when no configuration nor command line option is specified."
msgstr "如果 `<模式>` 是 `message` 或 `default`，求职信的主题将被填充为占位符文本。信函的正文将被填入分支的描述。这是没有指定配置或命令行选项时的默认模式。"

#. type: Plain text
#: en/git-format-patch.txt:210
#, priority:100
msgid "If `<mode>` is `subject`, the first paragraph of the branch description will populate the cover letter subject. The remainder of the description will populate the body of the cover letter."
msgstr "如果 `<模式>` 是 `subject`，分支描述的第一段将填入求职信的主题。描述的其余部分将填充到求职信的正文中。"

#. type: Plain text
#: en/git-format-patch.txt:214
#, priority:100
msgid "If `<mode>` is `auto`, if the first paragraph of the branch description is greater than 100 bytes, then the mode will be `message`, otherwise `subject` will be used."
msgstr "如果 `<模式>` 是 `auto`，如果分支描述的第一段大于100字节，那么模式将是 `message`，否则将使用 `subject`。"

#. type: Plain text
#: en/git-format-patch.txt:217
#, priority:100
msgid "If `<mode>` is `none`, both the cover letter subject and body will be populated with placeholder text."
msgstr "如果 `<模式>` 为 `none`，求职信的主题和正文都将被填充为占位符文本。"

#. type: Labeled list
#: en/git-format-patch.txt:218
#, no-wrap, placeholders:'--description-file=', priority:100
msgid "--description-file=<file>"
msgstr "--description-file=<文件>"

#. type: Plain text
#: en/git-format-patch.txt:221
#, priority:100
msgid "Use the contents of <file> instead of the branch's description for generating the cover letter."
msgstr "使用 <文件> 的内容而不是分支说明来生成求职信。"

#. type: Labeled list
#: en/git-format-patch.txt:222
#, no-wrap, placeholders:'--subject-prefix=', priority:100
msgid "--subject-prefix=<subject-prefix>"
msgstr "--subject-prefix=<主题前缀>"

#. type: Plain text
#: en/git-format-patch.txt:227
#, placeholders:'`--numbered`', priority:100
msgid "Instead of the standard '[PATCH]' prefix in the subject line, instead use '[<subject-prefix>]'. This can be used to name a patch series, and can be combined with the `--numbered` option."
msgstr "在主题行中不要使用标准的 '[PATCH]' 前缀，而应使用 '[<主题前缀>]'。这可用于命名补丁系列，并可与 `--numbered` 选项结合使用。"

#. type: Plain text
#: en/git-format-patch.txt:233
#, placeholders:'format.subjectPrefix', priority:100
msgid "The configuration variable `format.subjectPrefix` may also be used to configure a subject prefix to apply to a given repository for all patches. This is often useful on mailing lists which receive patches for several repositories and can be used to disambiguate the patches (with a value of e.g. \"PATCH my-project\")."
msgstr "配置变量 `format.subjectPrefix` 也可用于配置主题前缀，以适用于指定仓库的所有补丁。这在接收多个仓库补丁的邮件列表中通常很有用，可用于消除补丁的歧义（例如值为 \"PATCH my-project\"）。"

#. type: Labeled list
#: en/git-format-patch.txt:234
#, no-wrap, placeholders:'--filename-max-length=', priority:100
msgid "--filename-max-length=<n>"
msgstr "--filename-max-length=<n>"

#. type: Plain text
#: en/git-format-patch.txt:240
#, placeholders:'format.filenameMaxLength', priority:100
msgid "Instead of the standard 64 bytes, chomp the generated output filenames at around '<n>' bytes (too short a value will be silently raised to a reasonable length). Defaults to the value of the `format.filenameMaxLength` configuration variable, or 64 if unconfigured."
msgstr "代替标准的 64 字节，将生成的输出文件名压缩到 '<n>' 字节左右（太短的值会被默默提升到合理的长度）。 默认为 `format.filenameMaxLength` 配置变量的值，如果没有配置，则为 64。"

#. type: Labeled list
#: en/git-format-patch.txt:241
#, ignore-same, no-wrap, priority:100
msgid "--rfc"
msgstr "--rfc"

#. type: Plain text
#: en/git-format-patch.txt:245
#, priority:100
msgid "Prepends \"RFC\" to the subject prefix (producing \"RFC PATCH\" by default). RFC means \"Request For Comments\"; use this when sending an experimental patch for discussion rather than application."
msgstr "在主题前缀前加上 \"RFC\"（默认为 \"RFC PATCH\"）。RFC 的意思是 “征求意见”；在发送实验性补丁供讨论而非应用时使用。"

#. type: Labeled list
#: en/git-format-patch.txt:246
#, no-wrap, priority:100
msgid "-v <n>"
msgstr "-v <n>"

#. type: Labeled list
#: en/git-format-patch.txt:247
#, no-wrap, placeholders:'--reroll-count=', priority:100
msgid "--reroll-count=<n>"
msgstr "--reroll-count=<n>"

#. type: Plain text
#: en/git-format-patch.txt:259
#, placeholders:'`--subject-prefix`':'`--reroll-count=4`':'makefile.patch':'--reroll-count=4':'--reroll-count=4rev2', priority:100
msgid "Mark the series as the <n>-th iteration of the topic. The output filenames have `v<n>` prepended to them, and the subject prefix (\"PATCH\" by default, but configurable via the `--subject-prefix` option) has ` v<n>` appended to it. E.g. `--reroll-count=4` may produce `v4-0001-add-makefile.patch` file that has \"Subject: [PATCH v4 1/20] Add makefile\" in it. `<n>` does not have to be an integer (e.g. \"--reroll-count=4.4\", or \"--reroll-count=4rev2\" are allowed), but the downside of using such a reroll-count is that the range-diff/interdiff with the previous version does not state exactly which version the new iteration is compared against."
msgstr "将该系列标记为该主题的第 <n> 次迭代。输出的文件名有 `v<n>`，主题前缀（默认为 \"PATCH\"，但可通过 `--subject-prefix` 选项配置）有 `v<n>` 附加在上面。 例如，`--reroll-count=4` 可能产生 `v4-0001-add-makefile.patch` 文件，其中有 \"Subject： [PATCH v4 1/20] Add makefile\"。 `<n>` 不一定是整数（例如，\"--reroll-count=4.4\"，或 \"--reroll-count=4rev2 \"都可以），但使用这种 reroll-count 的缺点是，与前一版本的 range-diff/interdiff 并没有准确说明新的 interation 是与哪个版本比较。"

#. type: Labeled list
#: en/git-format-patch.txt:260
#, no-wrap, placeholders:'--to=', priority:100
msgid "--to=<email>"
msgstr "--to=<e-mail>"

#. type: Plain text
#: en/git-format-patch.txt:265
#, placeholders:'`--no-to`', priority:100
msgid "Add a `To:` header to the email headers. This is in addition to any configured headers, and may be used multiple times. The negated form `--no-to` discards all `To:` headers added so far (from config or command line)."
msgstr "在邮件标题中增加一个 `To: ` 头。这是在任何配置的头信息之外的，可以多次使用。 否定的形式 `--no-to` 会丢弃到目前为止添加的所有 `To:` 头信息（来自配置或命令行）。"

#. type: Labeled list
#: en/git-format-patch.txt:266
#, no-wrap, placeholders:'--cc=', priority:100
msgid "--cc=<email>"
msgstr "--cc=<email>"

#. type: Plain text
#: en/git-format-patch.txt:271
#, placeholders:'`--no-cc`', priority:100
msgid "Add a `Cc:` header to the email headers. This is in addition to any configured headers, and may be used multiple times. The negated form `--no-cc` discards all `Cc:` headers added so far (from config or command line)."
msgstr "在邮件标题中添加 `Cc: ` 标头。这是在任何配置的头信息之外的，可以多次使用。 否定的形式 `--no-cc` 会丢弃到目前为止添加的所有 `Cc:` 头信息（来自配置或命令行）。"

#. type: Labeled list
#: en/git-format-patch.txt:272
#, ignore-same, no-wrap, priority:100
msgid "--from"
msgstr "--from"

#. type: Labeled list
#: en/git-format-patch.txt:273
#, no-wrap, placeholders:'--from=', priority:100
msgid "--from=<ident>"
msgstr "--from=<身份>"

#. type: Plain text
#: en/git-format-patch.txt:279
#, priority:100
msgid "Use `ident` in the `From:` header of each commit email. If the author ident of the commit is not textually identical to the provided `ident`, place a `From:` header in the body of the message with the original author. If no `ident` is given, use the committer ident."
msgstr "在每封提交邮件的`From:` 标头中使用 `ident`。如果提交的作者身份与所提供的 `ident` 在文字上不一致，则在邮件正文中放置一个 `From: ` 头，注明原作者。如果没有给出 `ident`，则使用提交者的身份。"

#. type: Plain text
#: en/git-format-patch.txt:286
#, placeholders:'git send-email':'git send-email', priority:100
msgid "Note that this option is only useful if you are actually sending the emails and want to identify yourself as the sender, but retain the original author (and `git am` will correctly pick up the in-body header). Note also that `git send-email` already handles this transformation for you, and this option should not be used if you are feeding the result to `git send-email`."
msgstr "注意，这个选项只有在你实际发送邮件时才有用，并且想把你自己确定为发件人，但保留原作者（`git am` 会正确接收正文头）。还要注意的是，`git send-email` 已经为你处理了这种转换，如果你将结果反馈给 `git send-email`，就不应该使用这个选项。"

#. type: Labeled list
#: en/git-format-patch.txt:287
#, ignore-same, no-wrap, priority:100
msgid "--[no-]force-in-body-from"
msgstr "--[no-]force-in-body-from"

#. type: Plain text
#: en/git-format-patch.txt:297
#, placeholders:'`--from`':'format.forceInBodyFrom', priority:100
msgid "With the e-mail sender specified via the `--from` option, by default, an in-body \"From:\" to identify the real author of the commit is added at the top of the commit log message if the sender is different from the author. With this option, the in-body \"From:\" is added even when the sender and the author have the same name and address, which may help if the mailing list software mangles the sender's identity. Defaults to the value of the `format.forceInBodyFrom` configuration variable."
msgstr "对于通过 `--from` 选项指定的电子邮件发件人，默认情况下，如果发件人与作者不同，会在提交日志信息的顶部添加一个内文 \"From:\"，以确定提交的真正作者。 有了这个选项，即使发件人和作者的名字和地址相同，也会在正文中加入 \"From：\"，这在邮件列表软件混淆发件人身份时可能会有帮助。 默认为 `format.forceInBodyFrom` 配置变量的值。"

#. type: Labeled list
#: en/git-format-patch.txt:298
#, no-wrap, placeholders:'--add-header=', priority:100
msgid "--add-header=<header>"
msgstr "--add-header=<头部>"

#. type: Plain text
#: en/git-format-patch.txt:305
#, placeholders:'`--add-header=':'`--no-add-header`', priority:100
msgid "Add an arbitrary header to the email headers. This is in addition to any configured headers, and may be used multiple times. For example, `--add-header=\"Organization: git-foo\"`. The negated form `--no-add-header` discards *all* (`To:`, `Cc:`, and custom) headers added so far from config or command line."
msgstr "在邮件头中添加一个任意的头。 这是在任何配置的头文件之外的，并且可以多次使用。 例如，`--add-header=\"Organization: git-foo\"`。 否定的形式 `--no-add-header` 会丢弃 *所有*（`To:`, `Cc:`, 和自定义）从配置或命令行添加的头信息。"

#. type: Labeled list
#: en/git-format-patch.txt:306
#, ignore-same, no-wrap, priority:100
msgid "--[no-]cover-letter"
msgstr "--[no-]cover-letter"

#. type: Plain text
#: en/git-format-patch.txt:310
#, priority:100
msgid "In addition to the patches, generate a cover letter file containing the branch description, shortlog and the overall diffstat. You can fill in a description in the file before sending it out."
msgstr "除了补丁之外，还要生成一个包含分支描述、短日志和整体差异状态的封面文件。 你可以在发送之前在文件中填写描述。"

#. type: Labeled list
#: en/git-format-patch.txt:311
#, ignore-same, no-wrap, priority:100
msgid "--encode-email-headers"
msgstr "--encode-email-headers"

#. type: Labeled list
#: en/git-format-patch.txt:312
#, ignore-same, no-wrap, priority:100
msgid "--no-encode-email-headers"
msgstr "--no-encode-email-headers"

#. type: Plain text
#: en/git-format-patch.txt:317
#, placeholders:'format.encodeEmailHeaders', priority:100
msgid "Encode email headers that have non-ASCII characters with \"Q-encoding\" (described in RFC 2047), instead of outputting the headers verbatim. Defaults to the value of the `format.encodeEmailHeaders` configuration variable."
msgstr "用 \"Q-encoding\"（在RFC 2047中描述）对有非 ASCII 字符的邮件头进行编码，而不是逐字输出邮件头。默认为 `format.encodeEmailHeaders` 配置变量的值。"

#. type: Labeled list
#: en/git-format-patch.txt:318
#, no-wrap, placeholders:'--interdiff=', priority:100
msgid "--interdiff=<previous>"
msgstr "--interdiff=<以前>"

#. type: Plain text
#: en/git-format-patch.txt:326
#, placeholders:'git format-patch':'--cover-letter':'--interdiff=feature', priority:100
msgid "As a reviewer aid, insert an interdiff into the cover letter, or as commentary of the lone patch of a 1-patch series, showing the differences between the previous version of the patch series and the series currently being formatted. `previous` is a single revision naming the tip of the previous series which shares a common base with the series being formatted (for example `git format-patch --cover-letter --interdiff=feature/v1 -3 feature/v2`)."
msgstr "作为审查员的帮助，在封面信中插入一个 interdiff，或者作为1个补丁系列中唯一一个补丁的注释，显示补丁系列的前一个版本与当前被格式化的系列之间的差异。`previous` 是一个单一的修订，命名了与被格式化的系列有共同基础的前一个系列的提示（例如 `git format-patch --cover-letter --interdiff=feature/v1 -3 feature/v2`）。"

#. type: Labeled list
#: en/git-format-patch.txt:327
#, no-wrap, placeholders:'--range-diff=', priority:100
msgid "--range-diff=<previous>"
msgstr "--range-diff=<以前>"

#. type: Plain text
#: en/git-format-patch.txt:338
#, placeholders:'linkgit:git-range-diff[1]':'git format-patch':'--cover-letter':'--range-diff=feature':'git format-patch':'--cover-letter':'--range-diff=feature', priority:100
msgid "As a reviewer aid, insert a range-diff (see linkgit:git-range-diff[1]) into the cover letter, or as commentary of the lone patch of a 1-patch series, showing the differences between the previous version of the patch series and the series currently being formatted. `previous` can be a single revision naming the tip of the previous series if it shares a common base with the series being formatted (for example `git format-patch --cover-letter --range-diff=feature/v1 -3 feature/v2`), or a revision range if the two versions of the series are disjoint (for example `git format-patch --cover-letter --range-diff=feature/v1~3..feature/v1 -3 feature/v2`)."
msgstr "作为审查员的辅助工具，在封面信中插入一个 range-diff（见 linkgit:git-range-diff[1]），或者作为1个补丁系列中唯一一个补丁的注释，显示该补丁系列的前一个版本与当前被格式化的系列之间的差异。 `previous` 可以是一个单一的修订版，如果它与被格式化的系列有共同的基础，则命名为前一个系列的提示（例如 `git format-patch --cover-letter --range-diff=feature/v1 -3 feature/v2`），如果两个系列的版本不相干，则是一个修订范围（例如 `git format-patch --cover-letter --range-diff=feature/v1~3.feature/v1 -3 feature/v2`）。"

#. type: Plain text
#: en/git-format-patch.txt:343
#, priority:100
msgid "Note that diff options passed to the command affect how the primary product of `format-patch` is generated, and they are not passed to the underlying `range-diff` machinery used to generate the cover-letter material (this may change in the future)."
msgstr "请注意，传递给命令的差异选项会影响 `format-patch` 的主要产品如何生成，它们不会传递给用于生成封面材料的基础 `range-diff ` 机器（这在将来可能会改变）。"

#. type: Labeled list
#: en/git-format-patch.txt:344 en/git-range-diff.txt:68
#, no-wrap, placeholders:'--creation-factor=', priority:100
msgid "--creation-factor=<percent>"
msgstr "--creation-factor=<百分比>"

#. type: Plain text
#: en/git-format-patch.txt:349
#, placeholders:'`--range-diff`':'linkgit:git-range-diff[1]', priority:100
msgid "Used with `--range-diff`, tweak the heuristic which matches up commits between the previous and current series of patches by adjusting the creation/deletion cost fudge factor. See linkgit:git-range-diff[1]) for details."
msgstr "与 `--range-diff` 一起使用，通过调整创建/删除成本的模糊系数，来调整匹配上一个和当前系列补丁之间提交的启发式方法。详情见 linkgit:git-range-diff[1]）。"

#. type: Labeled list
#: en/git-format-patch.txt:350 en/pretty-options.txt:62
#, no-wrap, placeholders:'--notes', priority:260
msgid "--notes[=<ref>]"
msgstr "--notes[=<引用>]"

#. type: Labeled list
#: en/git-format-patch.txt:351 en/pretty-options.txt:83
#, ignore-same, no-wrap, priority:260
msgid "--no-notes"
msgstr "--no-notes"

#. type: Plain text
#: en/git-format-patch.txt:354
#, placeholders:'linkgit:git-notes[1]', priority:100
msgid "Append the notes (see linkgit:git-notes[1]) for the commit after the three-dash line."
msgstr "在三折线之后添加该提交的注释（见 linkgit:git-notes[1]）。"

#. type: Plain text
#: en/git-format-patch.txt:362
#, placeholders:'notes.rewrite':'linkgit:git-notes[1]', priority:100
msgid "The expected use case of this is to write supporting explanation for the commit that does not belong to the commit log message proper, and include it with the patch submission. While one can simply write these explanations after `format-patch` has run but before sending, keeping them as Git notes allows them to be maintained between versions of the patch series (but see the discussion of the `notes.rewrite` configuration options in linkgit:git-notes[1] to use this workflow)."
msgstr "预期的用例是为提交编写不属于提交日志信息本身的支持性解释，并将其包含在补丁提交中。虽然我们可以在 `format-patch` 运行后但在发送前简单地写下这些解释，但将其保留为 Git 笔记，可以在补丁系列的不同版本之间进行维护（但要使用这种工作流程，请参考 linkgit:git-notes[1] 中关于`notes.rewrite` 配置选项的讨论）。"

#. type: Plain text
#: en/git-format-patch.txt:365
#, placeholders:'`--no-notes`':'format.notes', priority:100
msgid "The default is `--no-notes`, unless the `format.notes` configuration is set."
msgstr "默认为`--no-notes`，除非设置了 `format.notes` 配置。"

#. type: Labeled list
#: en/git-format-patch.txt:366
#, no-wrap, priority:100
msgid "--[no-]signature=<signature>"
msgstr "--[no-]signature=<签名>"

#. type: Plain text
#: en/git-format-patch.txt:371
#, priority:100
msgid "Add a signature to each message produced. Per RFC 3676 the signature is separated from the body by a line with '-- ' on it. If the signature option is omitted the signature defaults to the Git version number."
msgstr "给每个产生的信息添加一个签名。根据 RFC 3676，签名与正文之间用一行 '--' 分隔。如果签名选项被省略，则签名默认为 Git 版本号。"

#. type: Labeled list
#: en/git-format-patch.txt:372
#, no-wrap, placeholders:'--signature-file=', priority:100
msgid "--signature-file=<file>"
msgstr "--signature-file=<文件>"

# ERROR: --signature not found in translation
#. type: Plain text
#: en/git-format-patch.txt:374
#, placeholders:'--signature', priority:100
msgid "Works just like --signature except the signature is read from a file."
msgstr "工作原理与 --signature 相同，只是签名是从文件中读取的。"

#. type: Labeled list
#: en/git-format-patch.txt:375
#, no-wrap, placeholders:'--suffix=', priority:100
msgid "--suffix=.<sfx>"
msgstr "--suffix=.<后缀>"

#. type: Plain text
#: en/git-format-patch.txt:380
#, placeholders:'`--suffix=', priority:100
msgid "Instead of using `.patch` as the suffix for generated filenames, use specified suffix. A common alternative is `--suffix=.txt`. Leaving this empty will remove the `.patch` suffix."
msgstr "不使用 `.patch` 作为生成文件名的后缀，而使用指定的后缀。 一个常见的选择是 `--suffix=.txt`。 将此留空将删除 `.patch` 后缀。"

#. type: Plain text
#: en/git-format-patch.txt:383
#, placeholders:'`--suffix=-patch`', priority:100
msgid "Note that the leading character does not have to be a dot; for example, you can use `--suffix=-patch` to get `0001-description-of-my-change-patch`."
msgstr "请注意，前导字符不一定是点；例如，你可以使用 `--suffix=-patch` 来获得 `0001-description-of-my-change-patch`。"

#. type: Plain text
#: en/git-format-patch.txt:387
#, priority:100
msgid "Do not print the names of the generated files to standard output."
msgstr "不要将生成的文件名打印到标准输出。"

#. type: Labeled list
#: en/git-format-patch.txt:388
#, ignore-same, no-wrap, priority:100
msgid "--no-binary"
msgstr "--no-binary"

#. type: Plain text
#: en/git-format-patch.txt:393
#, priority:100
msgid "Do not output contents of changes in binary files, instead display a notice that those files changed. Patches generated using this option cannot be applied properly, but they are still useful for code review."
msgstr "不输出二进制文件中的变化内容，而是显示这些文件变化的通知。 使用该选项生成的补丁不能被正确应用，但它们对代码审查仍然有用。"

#. type: Labeled list
#: en/git-format-patch.txt:394
#, ignore-same, no-wrap, priority:100
msgid "--zero-commit"
msgstr "--zero-commit"

#. type: Plain text
#: en/git-format-patch.txt:397
#, priority:100
msgid "Output an all-zero hash in each patch's From header instead of the hash of the commit."
msgstr "在每个补丁的 From 头中输出一个全零的哈希值，而不是提交的哈希值。"

#. type: Labeled list
#: en/git-format-patch.txt:398
#, no-wrap, priority:100
msgid "--[no-]base[=<commit>]"
msgstr "--[no-]base[=<提交>]"

#. type: Plain text
#: en/git-format-patch.txt:404
#, placeholders:'`--no-base`':'format.useAutoBase', priority:100
msgid "Record the base tree information to identify the state the patch series applies to. See the BASE TREE INFORMATION section below for details. If <commit> is \"auto\", a base commit is automatically chosen. The `--no-base` option overrides a `format.useAutoBase` configuration."
msgstr "记录基树信息，以确定该补丁系列所适用的状态。 详见下面的基树信息部分。如果 <提交> 是 \"auto\"，就会自动选择一个基数提交。`--no-base` 选项会覆盖 `format.useAutoBase` 配置。"

#. type: Plain text
#: en/git-format-patch.txt:411
#, priority:100
msgid "Treat the revision argument as a <revision-range>, even if it is just a single commit (that would normally be treated as a <since>). Note that root commits included in the specified range are always formatted as creation patches, independently of this flag."
msgstr "将修订版参数视为 <revision range>，即使它只是一个单一的提交（通常会被视为 <since>）。 注意，包含在指定范围内的根提交总是被格式化为创建补丁，与此标志无关。"

#. type: Plain text
#: en/git-format-patch.txt:414
#, priority:100
msgid "Show progress reports on stderr as patches are generated."
msgstr "在生成补丁时在标准错误流上显示进度报告。"

#. type: Plain text
#: en/git-format-patch.txt:422
#, priority:100
msgid "You can specify extra mail header lines to be added to each message, defaults for the subject prefix and file suffix, number patches when outputting more than one patch, add \"To:\" or \"Cc:\" headers, configure attachments, change the patch output directory, and sign off patches with configuration variables."
msgstr "你可以指定额外的邮件标题行添加到每封邮件中，主题前缀和文件后缀的默认值，在输出多个补丁时对补丁进行编号，添加 \"To: \" 或 \"Cc: \" 标题，配置附件，更改补丁输出目录，以及用配置变量签署补丁。"

#. type: delimited block -
#: en/git-format-patch.txt:436
#, no-wrap, priority:100
msgid ""
"[format]\n"
"\theaders = \"Organization: git-foo\\n\"\n"
"\tsubjectPrefix = CHANGE\n"
"\tsuffix = .txt\n"
"\tnumbered = auto\n"
"\tto = <email>\n"
"\tcc = <email>\n"
"\tattach [ = mime-boundary-string ]\n"
"\tsignOff = true\n"
"\toutputDirectory = <directory>\n"
"\tcoverLetter = auto\n"
"\tcoverFromDescription = auto\n"
msgstr ""
"[format]\n"
"\theaders = \"Organization: git-foo\\n\"\n"
"\tsubjectPrefix = CHANGE\n"
"\tsuffix = .txt\n"
"\tnumbered = auto\n"
"\tto = <电子邮箱地址>\n"
"\tcc = <电子邮箱地址>\n"
"\tattach [ = mime-boundary-string ]\n"
"\tsignOff = true\n"
"\toutputDirectory = <目录>\n"
"\tcoverLetter = auto\n"
"\tcoverFromDescription = auto\n"

#. type: Plain text
#: en/git-format-patch.txt:445
#, placeholders:'git format-patch', priority:100
msgid "The patch produced by 'git format-patch' is in UNIX mailbox format, with a fixed \"magic\" time stamp to indicate that the file is output from format-patch rather than a real mailbox, like so:"
msgstr "由 'git format-patch' 产生的补丁是 UNIX 邮箱格式，有一个固定的 \"magic\" 时间戳，以表明该文件是由 format-patch 输出的，而不是一个真正的邮箱，像这样："

#. type: delimited block -
#: en/git-format-patch.txt:455
#, no-wrap, placeholders:'tony.luck':'intel.com', priority:100
msgid ""
"From 8f72bad1baf19a53459661343e21d6491c3908d3 Mon Sep 17 00:00:00 2001\n"
"From: Tony Luck <tony.luck@intel.com>\n"
"Date: Tue, 13 Jul 2010 11:42:54 -0700\n"
"Subject: [PATCH] =?UTF-8?q?[IA64]=20Put=20ia64=20config=20files=20on=20the=20?=\n"
" =?UTF-8?q?Uwe=20Kleine-K=C3=B6nig=20diet?=\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
msgstr ""
"From 8f72bad1baf19a53459661343e21d6491c3908d3 Mon Sep 17 00:00:00 2001\n"
"From: Tony Luck <tony.luck@intel.com>\n"
"Date: Tue, 13 Jul 2010 11:42:54 -0700\n"
"Subject: [PATCH] =?UTF-8?q?[IA64]=20Put=20ia64=20config=20files=20on=20the=20?=\n"
" =?UTF-8?q?Uwe=20Kleine-K=C3=B6nig=20diet?=\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: delimited block -
#: en/git-format-patch.txt:458
#, no-wrap, priority:100
msgid ""
"arch/arm config files were slimmed down using a python script\n"
"(See commit c2330e286f68f1c408b4aa6515ba49d57f05beae comment)\n"
msgstr ""
"arch/arm config files were slimmed down using a python script\n"
"(见提交 c2330e286f68f1c408b4aa6515ba49d57f05beae 评论)\n"

#. type: delimited block -
#: en/git-format-patch.txt:461
#, ignore-ellipsis, no-wrap, priority:100
msgid ""
"Do the same for ia64 so we can have sleek & trim looking\n"
"...\n"
msgstr ""
"为 ia64 做同样的事情，这样我们就可以有光滑和修长的外观了。\n"
"...\n"

#. type: Plain text
#: en/git-format-patch.txt:469
#, ignore-ellipsis, placeholders:'linkgit:git-am[1]', priority:100
msgid "Typically it will be placed in a MUA's drafts folder, edited to add timely commentary that should not go in the changelog after the three dashes, and then sent as a message whose body, in our example, starts with \"arch/arm config files were...\". On the receiving end, readers can save interesting patches in a UNIX mailbox and apply them with linkgit:git-am[1]."
msgstr "通常情况下，它会被放在 MUA 的 drafts 文件夹中，被编辑以添加及时的评论，这些评论不应该被放在 changelog 中的三个破折号之后，然后以消息的形式发送，在我们的例子中，其正文以 \"arch/arm config files were...\" 开始。 在接收端，读者可以将有趣的补丁保存在 UNIX 邮箱中，并通过 linkgit:git-am[1] 应用它们。"

#. type: Plain text
#: en/git-format-patch.txt:475
#, placeholders:'git format-patch':'--scissors', priority:100
msgid "When a patch is part of an ongoing discussion, the patch generated by 'git format-patch' can be tweaked to take advantage of the 'git am --scissors' feature. After your response to the discussion comes a line that consists solely of \"`-- >8 --`\" (scissors and perforation), followed by the patch with unnecessary header fields removed:"
msgstr "当一个补丁是正在进行的讨论的一部分时，由 'git format-patch' 生成的补丁可以进行调整，以利用 'git am --scissors' 功能。 在你对讨论的回应之后，有一行只由 \"`-- >8 --`\"（剪刀和打孔）组成，后面是去除不必要的头域的补丁："

#. type: delimited block -
#: en/git-format-patch.txt:479
#, ignore-ellipsis, no-wrap, priority:100
msgid ""
"...\n"
"> So we should do such-and-such.\n"
msgstr ""
"...\n"
"> 所以，我们应该做这样那样的事情。\n"

#. type: delimited block -
#: en/git-format-patch.txt:481
#, no-wrap, priority:100
msgid "Makes sense to me.  How about this patch?\n"
msgstr "对我来说是有意义的。 这个补丁怎么样？\n"

#. type: delimited block -
#: en/git-format-patch.txt:484
#, no-wrap, priority:100
msgid ""
"-- >8 --\n"
"Subject: [IA64] Put ia64 config files on the Uwe Kleine-König diet\n"
msgstr ""
"-- >8 --\n"
"Subject: [IA64] 将 ia64 配置文件放在 Uwe Kleine-König diet 上\n"

#. type: delimited block -
#: en/git-format-patch.txt:487
#, ignore-ellipsis, no-wrap, priority:100
msgid ""
"arch/arm config files were slimmed down using a python script\n"
"...\n"
msgstr ""
"使用 python 脚本对 arch/arm 配置文件进行了精简\n"
"...\n"

#. type: Plain text
#: en/git-format-patch.txt:495
#, placeholders:'$SHA1':'$magic_timestamp', priority:100
msgid "When sending a patch this way, most often you are sending your own patch, so in addition to the \"`From $SHA1 $magic_timestamp`\" marker you should omit `From:` and `Date:` lines from the patch file. The patch title is likely to be different from the subject of the discussion the patch is in response to, so it is likely that you would want to keep the Subject: line, like the example above."
msgstr "当用这种方式发送补丁时，大多数情况下是发送你自己的补丁，所以除了 \"`From $SHA1 $magic_timestamp`\" 标记外，你应该从补丁文件中省略 `From: ` 和 `Date: ` 行。 补丁的标题很可能与补丁所回应的讨论主题不同，所以很可能要保留 Subject: 这一行，就像上面的例子一样。"

#. type: Title ~
#: en/git-format-patch.txt:497
#, no-wrap, priority:100
msgid "Checking for patch corruption"
msgstr "检查补丁是否损坏"

#. type: Plain text
#: en/git-format-patch.txt:500
#, priority:100
msgid "Many mailers if not set up properly will corrupt whitespace. Here are two common types of corruption:"
msgstr "许多邮件如果设置不当就会破坏空白。 以下是两种常见的损坏类型："

#. type: Plain text
#: en/git-format-patch.txt:502
#, priority:100
msgid "Empty context lines that do not have _any_ whitespace."
msgstr "没有「任何」空格的空的上下文行。"

#. type: Plain text
#: en/git-format-patch.txt:505
#, priority:100
msgid "Non-empty context lines that have one extra whitespace at the beginning."
msgstr "非空的上下文行，在开头有一个额外的空白。"

#. type: Plain text
#: en/git-format-patch.txt:507
#, priority:100
msgid "One way to test if your MUA is set up correctly is:"
msgstr "测试你的 MUA 是否设置正确的一个方法是："

#. type: Plain text
#: en/git-format-patch.txt:511
#, priority:100
msgid "Send the patch to yourself, exactly the way you would, except with To: and Cc: lines that do not contain the list and maintainer address."
msgstr "将补丁发送给自己，完全按照你的方式，只是在 To: 和 Cc: 行中不包含列表和维护者地址。"

#. type: Plain text
#: en/git-format-patch.txt:514
#, placeholders:'a.patch', priority:100
msgid "Save that patch to a file in UNIX mailbox format. Call it a.patch, say."
msgstr "将该补丁保存为 UNIX 邮箱格式的文件。 称之为 a.patch，例如。"

#. type: Plain text
#: en/git-format-patch.txt:516
#, priority:100
msgid "Apply it:"
msgstr "应用它："

#. type: Plain text
#: en/git-format-patch.txt:521
#, no-wrap, placeholders:'--source=HEAD':'--staged':'--worktree':'a.patch', priority:100
msgid ""
"$ git fetch <project> master:test-apply\n"
"$ git switch test-apply\n"
"$ git restore --source=HEAD --staged --worktree :/\n"
"$ git am a.patch\n"
msgstr ""
"$ git fetch <project> master:test-apply\n"
"$ git switch test-apply\n"
"$ git restore --source=HEAD --staged --worktree :/\n"
"$ git am a.patch\n"

#. type: Plain text
#: en/git-format-patch.txt:523
#, priority:100
msgid "If it does not apply correctly, there can be various reasons."
msgstr "如果它不能正确应用，可能有各种原因。"

#. type: Plain text
#: en/git-format-patch.txt:528
#, placeholders:'linkgit:git-rebase[1]', priority:100
msgid "The patch itself does not apply cleanly. That is _bad_ but does not have much to do with your MUA. You might want to rebase the patch with linkgit:git-rebase[1] before regenerating it in this case."
msgstr "补丁本身不能干净地应用。 这很糟糕，但与你的 MUA 没有多大关系。 在这种情况下，你可能要先用 linkgit:git-rebase[1] 把补丁重新归位，再重新生成。"

#. type: Plain text
#: en/git-format-patch.txt:533
#, priority:100
msgid "The MUA corrupted your patch; \"am\" would complain that the patch does not apply. Look in the .git/rebase-apply/ subdirectory and see what 'patch' file contains and check for the common corruption patterns mentioned above."
msgstr "MUA 损坏了你的补丁；\"am\" 会抱怨补丁不适用。 查看 .git/rebase-apply/ 子目录，看看 \"补丁\" 文件包含哪些内容，并检查上面提到的常见损坏模式。"

#. type: Plain text
#: en/git-format-patch.txt:541
#, priority:100
msgid "While at it, check the 'info' and 'final-commit' files as well. If what is in 'final-commit' is not exactly what you would want to see in the commit log message, it is very likely that the receiver would end up hand editing the log message when applying your patch. Things like \"Hi, this is my first patch.\\n\" in the patch e-mail should come after the three-dash line that signals the end of the commit message."
msgstr "同时，还要检查 'info' 和 'final-commit' 文件。 如果 'final-commit' 中的内容与你希望在提交日志信息中看到的不完全一样，那么很可能接收者在应用你的补丁时最终会手工编辑日志信息。 补丁邮件中的 \"Hi, this is my first patch.\\n\" 等内容应该出现在提交信息末尾的三折线之后。"

#. type: Title -
#: en/git-format-patch.txt:543
#, no-wrap, priority:100
msgid "MUA-SPECIFIC HINTS"
msgstr "针对 Mua 的提示"

#. type: Plain text
#: en/git-format-patch.txt:546
#, priority:100
msgid "Here are some hints on how to successfully submit patches inline using various mailers."
msgstr "这里有一些关于如何使用各种邮件工具成功地在线提交补丁的提示。"

#. type: Title ~
#: en/git-format-patch.txt:548
#, no-wrap, priority:100
msgid "GMail"
msgstr "GMail"

#. type: Plain text
#: en/git-format-patch.txt:554
#, placeholders:'git send-email', priority:100
msgid "GMail does not have any way to turn off line wrapping in the web interface, so it will mangle any emails that you send. You can however use \"git send-email\" and send your patches through the GMail SMTP server, or use any IMAP email client to connect to the google IMAP server and forward the emails through that."
msgstr "GMail 没有办法在网页界面上关闭换行，所以它会把你发送的任何邮件弄得一团糟。 然而，你可以使用 \"git send-email\"，通过 GMail 的 SMTP 服务器发送你的补丁，或者使用任何 IMAP 电子邮件客户端连接到谷歌的 IMAP 服务器，并通过它转发电子邮件。"

#. type: Plain text
#: en/git-format-patch.txt:557
#, placeholders:'git send-email':'linkgit:git-send-email[1]', priority:100
msgid "For hints on using 'git send-email' to send your patches through the GMail SMTP server, see the EXAMPLE section of linkgit:git-send-email[1]."
msgstr "关于使用 'git send-email' 通过 GMail SMTP 服务器发送补丁的提示，请参见 linkgit:git-send-email[1] 的案例部分。"

#. type: Plain text
#: en/git-format-patch.txt:560
#, placeholders:'linkgit:git-imap-send[1]', priority:100
msgid "For hints on submission using the IMAP interface, see the EXAMPLE section of linkgit:git-imap-send[1]."
msgstr "关于使用 IMAP 接口提交的提示，请参见 linkgit:git-imap-send[1] 的案例部分。"

#. type: Title ~
#: en/git-format-patch.txt:562
#, no-wrap, priority:100
msgid "Thunderbird"
msgstr "Thunderbird"

#. type: Plain text
#: en/git-format-patch.txt:566
#, priority:100
msgid "By default, Thunderbird will both wrap emails as well as flag them as being 'format=flowed', both of which will make the resulting email unusable by Git."
msgstr "默认情况下，Thunderbird 会将邮件包裹起来，并将其标记为 'format=flowed'，这两种情况都会使 Git 无法使用这些邮件。"

#. type: Plain text
#: en/git-format-patch.txt:570
#, priority:100
msgid "There are three different approaches: use an add-on to turn off line wraps, configure Thunderbird to not mangle patches, or use an external editor to keep Thunderbird from mangling the patches."
msgstr "有三种不同的方法：使用插件来关闭换行，配置 Thunderbird 使其不纠缠补丁，或者使用外部编辑器来防止 Thunderbird 纠缠补丁。"

#. type: Title ^
#: en/git-format-patch.txt:572
#, no-wrap, priority:100
msgid "Approach #1 (add-on)"
msgstr "办法1（附加的）"

#. type: Plain text
#: en/git-format-patch.txt:580
#, placeholders:'addons.mozilla.org':'git format-patch':'git imap-send', priority:100
msgid "Install the Toggle Word Wrap add-on that is available from https://addons.mozilla.org/thunderbird/addon/toggle-word-wrap/ It adds a menu entry \"Enable Word Wrap\" in the composer's \"Options\" menu that you can tick off. Now you can compose the message as you otherwise do (cut + paste, 'git format-patch' | 'git imap-send', etc), but you have to insert line breaks manually in any text that you type."
msgstr "安装 Toggle Word Wrap 插件，该插件可从 https://addons.mozilla.org/thunderbird/addon/toggle-word-wrap/。它在作曲家的 \"选项\" 菜单中增加了一个 \"启用换行符\" 的菜单项，你可以将其勾掉。现在你可以像其他方式一样编写信息（剪切+粘贴，'git format-patch'|'git imap-send'，等等），但你必须在你输入的任何文本中手动插入换行符。"

#. type: Title ^
#: en/git-format-patch.txt:582
#, no-wrap, priority:100
msgid "Approach #2 (configuration)"
msgstr "方法#2（配置）"

#. type: Plain text
#: en/git-format-patch.txt:584
#, priority:100
msgid "Three steps:"
msgstr "三个步骤："

#. type: Plain text
#: en/git-format-patch.txt:588
#, ignore-ellipsis, priority:100
msgid "Configure your mail server composition as plain text: Edit...Account Settings...Composition & Addressing, uncheck \"Compose Messages in HTML\"."
msgstr "将你的邮件服务器组成配置为纯文本： 编辑......账户设置......组成和地址，取消勾选 \"以HTML编写邮件\"。"

#. type: Plain text
#: en/git-format-patch.txt:590
#, priority:100
msgid "Configure your general composition window to not wrap."
msgstr "配置你的一般组成窗口，使其不被包裹。"

#. type: Plain text
#: en/git-format-patch.txt:593
#, priority:100
msgid "In Thunderbird 2: Edit..Preferences..Composition, wrap plain text messages at 0"
msgstr "在 Thunderbird 2 中：编辑...偏好...组成，将纯文本信息包在 0 处"

#. type: Plain text
#: en/git-format-patch.txt:599
#, placeholders:'wrap_long_lines':'mailnews.wraplength', priority:100
msgid "In Thunderbird 3: Edit..Preferences..Advanced..Config Editor. Search for \"mail.wrap_long_lines\". Toggle it to make sure it is set to `false`. Also, search for \"mailnews.wraplength\" and set the value to 0."
msgstr "在 Thunderbird 3 中：编辑...偏好...高级...配置编辑器。 搜索 \"mail.wrap_long_lines\"。 切换它，确保它被设置为 \"false\"。另外，搜索 \"mailnews.wraplength\" 并将其设置为 0。"

#. type: Plain text
#: en/git-format-patch.txt:604
#, placeholders:'send_plaintext_flowed', priority:100
msgid "Disable the use of format=flowed: Edit..Preferences..Advanced..Config Editor. Search for \"mailnews.send_plaintext_flowed\". Toggle it to make sure it is set to `false`."
msgstr "禁止使用 format=flowed： 编辑...偏好...高级...配置编辑器。 搜索 \"mailnews.send_plaintext_flowed\"。 拨动它，确保它被设置为 `false`。"

#. type: Plain text
#: en/git-format-patch.txt:608
#, placeholders:'git format-patch':'git imap-send', priority:100
msgid "After that is done, you should be able to compose email as you otherwise would (cut + paste, 'git format-patch' | 'git imap-send', etc), and the patches will not be mangled."
msgstr "完成后，你应该能够像其他方式一样编写电子邮件（剪切+粘贴，'git format-patch' | 'git imap-send'，等等），而且补丁不会被弄乱。"

#. type: Title ^
#: en/git-format-patch.txt:610
#, no-wrap, priority:100
msgid "Approach #3 (external editor)"
msgstr "方法三（外部编辑）"

#. type: Plain text
#: en/git-format-patch.txt:615
#, placeholders:'mjg.github.io':'globs.org':'articles.php', priority:100
msgid "The following Thunderbird extensions are needed: AboutConfig from https://mjg.github.io/AboutConfig/ and External Editor from https://globs.org/articles.php?lng=en&pg=8"
msgstr "需要以下 Thunderbird 扩展： https://mjg.github.io/AboutConfig/ 中的 AboutConfig 和 https://globs.org/articles.php?lng=en&pg=8 中的 External Editor"

#. type: Plain text
#: en/git-format-patch.txt:617
#, priority:100
msgid "Prepare the patch as a text file using your method of choice."
msgstr "用你选择的方法把补丁准备成一个文本文件。"

#. type: Plain text
#: en/git-format-patch.txt:622
#, priority:100
msgid "Before opening a compose window, use Edit->Account Settings to uncheck the \"Compose messages in HTML format\" setting in the \"Composition & Addressing\" panel of the account to be used to send the patch."
msgstr "在打开撰写窗口之前，使用 Edit->Account Settingd 取消勾选要用来发送补丁的账户的 \"Composition & Addressing\" 面板中的 \"Compose messages in HTML format\" 设置。"

#. type: Plain text
#: en/git-format-patch.txt:626
#, priority:100
msgid "In the main Thunderbird window, 'before' you open the compose window for the patch, use Tools->about:config to set the following to the indicated values:"
msgstr "在 Thunderbird 主窗口中，在你打开补丁的撰写窗口之前，使用 Tools->about:config 将以下内容设置为指定值："

#. type: delimited block -
#: en/git-format-patch.txt:630
#, no-wrap, placeholders:'send_plaintext_flowed':'mailnews.wraplength', priority:100
msgid ""
"\tmailnews.send_plaintext_flowed  => false\n"
"\tmailnews.wraplength             => 0\n"
msgstr ""
"\tmailnews.send_plaintext_flowed  => false\n"
"\tmailnews.wraplength             => 0\n"

#. type: Plain text
#: en/git-format-patch.txt:633
#, priority:100
msgid "Open a compose window and click the external editor icon."
msgstr "打开一个作曲窗口，点击外部编辑器图标。"

#. type: Plain text
#: en/git-format-patch.txt:636
#, priority:100
msgid "In the external editor window, read in the patch file and exit the editor normally."
msgstr "在外部编辑器窗口，读入补丁文件并正常退出编辑器。"

#. type: Plain text
#: en/git-format-patch.txt:639
#, priority:100
msgid "Side note: it may be possible to do step 2 with about:config and the following settings but no one's tried yet."
msgstr "题外话：也许可以用 about:config 和以下设置来完成第二步，但还没有人试过。"

#. type: delimited block -
#: en/git-format-patch.txt:644
#, no-wrap, placeholders:'html_compose':'mail.identity.default':'compose_html':'mail.identity.id':'compose_html', priority:100
msgid ""
"\tmail.html_compose                       => false\n"
"\tmail.identity.default.compose_html      => false\n"
"\tmail.identity.id?.compose_html          => false\n"
msgstr ""
"\tmail.html_compose                       => false\n"
"\tmail.identity.default.compose_html      => false\n"
"\tmail.identity.id?.compose_html          => false\n"

#. type: Plain text
#: en/git-format-patch.txt:649
#, priority:100
msgid "There is a script in contrib/thunderbird-patch-inline which can help you include patches with Thunderbird in an easy way. To use it, do the steps above and then use the script as the external editor."
msgstr "contrib/thunderbird-patch-inline 中有一个脚本，可以帮助你以一种简单的方式将补丁加入 Thunderbird。要使用它，请执行上面的步骤，然后使用该脚本作为外部编辑器。"

#. type: Title ~
#: en/git-format-patch.txt:651
#, no-wrap, priority:100
msgid "KMail"
msgstr "KMail"

#. type: Plain text
#: en/git-format-patch.txt:653
#, priority:100
msgid "This should help you to submit patches inline using KMail."
msgstr "这应该有助于你使用 KMail 在线提交补丁。"

#. type: Plain text
#: en/git-format-patch.txt:655
#, priority:100
msgid "Prepare the patch as a text file."
msgstr "把补丁准备成一个文本文件。"

#. type: Plain text
#: en/git-format-patch.txt:657
#, priority:100
msgid "Click on New Mail."
msgstr "点击 \"New Mail\"。"

#. type: Plain text
#: en/git-format-patch.txt:660
#, priority:100
msgid "Go under \"Options\" in the Composer window and be sure that \"Word wrap\" is not set."
msgstr "在合成器窗口的 \"Otions\" 下，确保没有设置 \"Word warp\"。"

#. type: Plain text
#: en/git-format-patch.txt:662
#, ignore-ellipsis, priority:100
msgid "Use Message -> Insert file... and insert the patch."
msgstr "Use Message -> Insert file... 并插入补丁。"

#. type: Plain text
#: en/git-format-patch.txt:665
#, priority:100
msgid "Back in the compose window: add whatever other text you wish to the message, complete the addressing and subject fields, and press send."
msgstr "回到撰写窗口：在信息中添加你想要的任何其他文本，完成地址和主题字段，然后按发送。"

#. type: Title -
#: en/git-format-patch.txt:667
#, no-wrap, priority:100
msgid "BASE TREE INFORMATION"
msgstr "基准树信息"

#. type: Plain text
#: en/git-format-patch.txt:676
#, priority:100
msgid "The base tree information block is used for maintainers or third party testers to know the exact state the patch series applies to. It consists of the 'base commit', which is a well-known commit that is part of the stable part of the project history everybody else works off of, and zero or more 'prerequisite patches', which are well-known patches in flight that is not yet part of the 'base commit' that need to be applied on top of 'base commit' in topological order before the patches can be applied."
msgstr "基准树信息块用于维护者或第三方测试人员了解补丁系列所适用的确切状态。它由 ‘基本提交’ 和零个或多个 ‘前提补丁’ 组成，前者是众所周知的提交，是项目历史中稳定部分的一部分，而后者是正在运行的知名补丁，还不是 ‘基本提交’ 的一部分，在应用这些补丁之前需要在 ‘基本提交’ 之上按拓扑顺序应用。"

#. type: Plain text
#: en/git-format-patch.txt:682
#, placeholders:'git patch-id':'--stable`', priority:100
msgid "The 'base commit' is shown as \"base-commit: \" followed by the 40-hex of the commit object name. A 'prerequisite patch' is shown as \"prerequisite-patch-id: \" followed by the 40-hex 'patch id', which can be obtained by passing the patch through the `git patch-id --stable` command."
msgstr "‘基本提交’ 显示为 \"base-commit: \"，后面是提交对象名称的 40-hex。 ‘先决补丁’ 显示为 \"prerequisite-patch-id: \"，后面是 40-hex 的 “补丁ID”，这个 ID 可以通过 `git patch-id --stable` 命令来获得。"

#. type: Plain text
#: en/git-format-patch.txt:686
#, priority:100
msgid "Imagine that on top of the public commit P, you applied well-known patches X, Y and Z from somebody else, and then built your three-patch series A, B, C, the history would be like:"
msgstr "想象一下，在公开提交的 P 之上，你应用了别人的知名补丁 X、Y 和 Z，然后建立了你的三套补丁系列 A、B、C，历史会是这样："

#. type: delimited block .
#: en/git-format-patch.txt:689
#, no-wrap, placeholders:'---P---X---Y---Z---A---B---C', priority:100
msgid "---P---X---Y---Z---A---B---C\n"
msgstr "---P---X---Y---Z---A---B---C\n"

#. type: Plain text
#: en/git-format-patch.txt:696
#, placeholders:'git format-patch':'--base=P':'`--cover-letter`', priority:100
msgid "With `git format-patch --base=P -3 C` (or variants thereof, e.g. with `--cover-letter` or using `Z..C` instead of `-3 C` to specify the range), the base tree information block is shown at the end of the first message the command outputs (either the first patch, or the cover letter), like this:"
msgstr "使用 `git format-patch --base=P -3 C`（或其变体，例如使用 `--cover-letter` 或使用 `Z...C` 代替 `-3 C` 来指定范围），基础树信息块会显示在命令输出的第一个信息（第一个补丁，或封面信）的末尾，像这样："

#. type: delimited block -
#: en/git-format-patch.txt:702
#, no-wrap, priority:100
msgid ""
"base-commit: P\n"
"prerequisite-patch-id: X\n"
"prerequisite-patch-id: Y\n"
"prerequisite-patch-id: Z\n"
msgstr ""
"base-commit: P\n"
"prerequisite-patch-id: X\n"
"prerequisite-patch-id: Y\n"
"prerequisite-patch-id: Z\n"

#. type: Plain text
#: en/git-format-patch.txt:705
#, priority:100
msgid "For non-linear topology, such as"
msgstr "对于非线性拓扑结构，如"

#. type: delimited block .
#: en/git-format-patch.txt:710
#, no-wrap, placeholders:'---P---X---A---M---C':'---Z---B', priority:100
msgid ""
"---P---X---A---M---C\n"
"    \\         /\n"
"     Y---Z---B\n"
msgstr ""
"---P---X---A---M---C\n"
"    \\         /\n"
"     Y---Z---B\n"

#. type: Plain text
#: en/git-format-patch.txt:715
#, placeholders:'git format-patch':'--base=P', priority:100
msgid "You can also use `git format-patch --base=P -3 C` to generate patches for A, B and C, and the identifiers for P, X, Y, Z are appended at the end of the first message."
msgstr "你也可以使用 `git format-patch --base=P -3 C` 来生成 A、B 和 C 的补丁，P、X、Y、Z 的标识符被附加在第一条信息的末尾。"

#. type: Plain text
#: en/git-format-patch.txt:721
#, placeholders:'`--base=auto`':'--set-upstream-to`', priority:100
msgid "If set `--base=auto` in cmdline, it will automatically compute the base commit as the merge base of tip commit of the remote-tracking branch and revision-range specified in cmdline. For a local branch, you need to make it to track a remote branch by `git branch --set-upstream-to` before using this option."
msgstr "如果在 cmdline 中设置 `--base=auto`，它将自动计算基础提交，作为远程跟踪分支和 cmdline 中指定的修订范围的提示提交的合并基础。 对于本地分支，在使用此选项之前，需要通过 `git branch --set-upstream-to` 使其跟踪远程分支。"

#. type: Plain text
#: en/git-format-patch.txt:727
#, priority:100
msgid "Extract commits between revisions R1 and R2, and apply them on top of the current branch using 'git am' to cherry-pick them:"
msgstr "提取 R1 和 R2 修订版之间的提交，并用 \"git am\" 将其应用于当前分支之上，以拣选它们："

#. type: delimited block -
#: en/git-format-patch.txt:730
#, no-wrap, placeholders:'git format-patch':'--stdout', priority:100
msgid "$ git format-patch -k --stdout R1..R2 | git am -3 -k\n"
msgstr "$ git format-patch -k --stdout R1..R2 | git am -3 -k\n"

#. type: Plain text
#: en/git-format-patch.txt:734
#, priority:100
msgid "Extract all commits which are in the current branch but not in the origin branch:"
msgstr "提取所有在当前分支但不在原生分支中的提交："

#. type: delimited block -
#: en/git-format-patch.txt:737
#, no-wrap, placeholders:'git format-patch', priority:100
msgid "$ git format-patch origin\n"
msgstr "$ git format-patch origin\n"

#. type: Plain text
#: en/git-format-patch.txt:740
#, priority:100
msgid "For each commit a separate file is created in the current directory."
msgstr "每次提交都会在当前目录下创建一个单独的文件。"

#. type: Plain text
#: en/git-format-patch.txt:743
#, priority:100
msgid "Extract all commits that lead to 'origin' since the inception of the project:"
msgstr "提取自项目开始以来所有导致 'origin' 的提交："

#. type: delimited block -
#: en/git-format-patch.txt:746
#, no-wrap, placeholders:'git format-patch':'--root', priority:100
msgid "$ git format-patch --root origin\n"
msgstr "$ git format-patch --root origin\n"

#. type: Plain text
#: en/git-format-patch.txt:749
#, priority:100
msgid "The same as the previous one:"
msgstr "与前者相同："

#. type: delimited block -
#: en/git-format-patch.txt:752
#, no-wrap, placeholders:'git format-patch', priority:100
msgid "$ git format-patch -M -B origin\n"
msgstr "$ git format-patch -M -B origin\n"

#. type: Plain text
#: en/git-format-patch.txt:759
#, priority:100
msgid "Additionally, it detects and handles renames and complete rewrites intelligently to produce a renaming patch. A renaming patch reduces the amount of text output, and generally makes it easier to review. Note that non-Git \"patch\" programs won't understand renaming patches, so use it only when you know the recipient uses Git to apply your patch."
msgstr "此外，它还能智能地检测和处理重命名和完全重写，以产生重命名补丁。 重命名补丁减少了文本输出的数量，一般来说，它更容易审查。 注意，非 Git 的 “补丁” 程序不会理解重命名补丁，所以只有当你知道收件人使用 Git 来应用你的补丁时才会使用它。"

#. type: Plain text
#: en/git-format-patch.txt:762
#, priority:100
msgid "Extract three topmost commits from the current branch and format them as e-mailable patches:"
msgstr "从当前分支中提取三个最重要的提交，并将其格式化为可发送电子邮件的补丁："

#. type: delimited block -
#: en/git-format-patch.txt:765
#, no-wrap, placeholders:'git format-patch', priority:100
msgid "$ git format-patch -3\n"
msgstr "$ git format-patch -3\n"

#. type: Plain text
#: en/git-format-patch.txt:774
#, priority:100
msgid "Note that `format-patch` will omit merge commits from the output, even if they are part of the requested range. A simple \"patch\" does not include enough information for the receiving end to reproduce the same merge commit."
msgstr "请注意，`format-patch` 将从输出中省略合并提交，即使它们是请求范围的一部分。一个简单的 “补丁” 并不包括足够的信息让接收端重现同一个合并提交。"

#. type: Plain text
#: en/git-format-patch.txt:778
#, ignore-same, priority:100
msgid "linkgit:git-am[1], linkgit:git-send-email[1]"
msgstr "linkgit:git-am[1], linkgit:git-send-email[1]"

#. type: Title =
#: en/git-fsck-objects.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-fsck-objects(1)"
msgstr "git-fsck-objects(1)"

#. type: Plain text
#: en/git-fsck-objects.txt:7
#, placeholders:'git-fsck-objects', priority:100
msgid "git-fsck-objects - Verifies the connectivity and validity of the objects in the database"
msgstr "git-fsck-objects - 验证数据库中对象的连接性和有效性"

#. type: Plain text
#: en/git-fsck-objects.txt:13
#, ignore-ellipsis, no-wrap, placeholders:'git fsck-objects', priority:100
msgid "'git fsck-objects' ...\n"
msgstr "'git fsck-objects' ...\n"

#. type: Plain text
#: en/git-fsck-objects.txt:19
#, placeholders:'linkgit:git-fsck[1]', priority:100
msgid "This is a synonym for linkgit:git-fsck[1]. Please refer to the documentation of that command."
msgstr "这是 linkgit:git-fsck[1] 的同义词。 请参考该命令的文档。"

#. type: Title =
#: en/git-fsck.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-fsck(1)"
msgstr "git-fsck(1)"

#. type: Plain text
#: en/git-fsck.txt:7
#, placeholders:'git-fsck', priority:100
msgid "git-fsck - Verifies the connectivity and validity of the objects in the database"
msgstr "git-fsck - 验证数据库中对象的连接性和有效性"

#. type: Plain text
#: en/git-fsck.txt:16
#, ignore-ellipsis, no-wrap, placeholders:'[--tags]':'[--root]':'[--unreachable]':'[--cache]':'[--no-reflogs]':'[--strict]':'[--verbose]':'[--lost-found]':'[--connectivity-only]', priority:100
msgid ""
"'git fsck' [--tags] [--root] [--unreachable] [--cache] [--no-reflogs]\n"
"\t [--[no-]full] [--strict] [--verbose] [--lost-found]\n"
"\t [--[no-]dangling] [--[no-]progress] [--connectivity-only]\n"
"\t [--[no-]name-objects] [<object>...]\n"
msgstr ""
"'git fsck' [--tags] [--root] [--unreachable] [--cache] [--no-reflogs]\n"
"\t [--[no-]full] [--strict] [--verbose] [--lost-found]\n"
"\t [--[no-]dangling] [--[no-]progress] [--connectivity-only]\n"
"\t [--[no-]name-objects] [<对象>*]\n"

#. type: Plain text
#: en/git-fsck.txt:25
#, priority:100
msgid "An object to treat as the head of an unreachability trace."
msgstr "一个要作为不可及性追踪的头的对象。"

#. type: Plain text
#: en/git-fsck.txt:29
#, placeholders:'--no-reflogs', priority:100
msgid "If no objects are given, 'git fsck' defaults to using the index file, all SHA-1 references in the `refs` namespace, and all reflogs (unless --no-reflogs is given) as heads."
msgstr "如果没有给出对象，'git fsck' 默认使用索引文件、`refs` 命名空间中的所有 SHA-1 引用，以及所有引用日志（除非 --no-reflogs 选项被给出）作为头。"

#. type: Labeled list
#: en/git-fsck.txt:30
#, ignore-same, no-wrap, priority:100
msgid "--unreachable"
msgstr "--unreachable"

#. type: Plain text
#: en/git-fsck.txt:33
#, priority:100
msgid "Print out objects that exist but that aren't reachable from any of the reference nodes."
msgstr "打印出存在但不能从任何参考节点到达的对象。"

#. type: Labeled list
#: en/git-fsck.txt:34
#, ignore-same, no-wrap, priority:100
msgid "--[no-]dangling"
msgstr "--[no-]dangling"

#. type: Plain text
#: en/git-fsck.txt:37
#, placeholders:'`--no-dangling`', priority:100
msgid "Print objects that exist but that are never 'directly' used (default). `--no-dangling` can be used to omit this information from the output."
msgstr "打印存在但从未 'directly ' 使用的对象（默认）。 `--no-dangling` 可以用来从输出中省略这一信息。"

#. type: Plain text
#: en/git-fsck.txt:40
#, priority:100
msgid "Report root nodes."
msgstr "报告根节点。"

#. type: Plain text
#: en/git-fsck.txt:43
#, priority:100
msgid "Report tags."
msgstr "报告标签。"

#. type: Labeled list
#: en/git-fsck.txt:44
#, ignore-same, no-wrap, priority:100
msgid "--cache"
msgstr "--cache"

#. type: Plain text
#: en/git-fsck.txt:47
#, priority:100
msgid "Consider any object recorded in the index also as a head node for an unreachability trace."
msgstr "考虑将索引中记录的任何对象也作为不可达性追踪的头节点。"

#. type: Labeled list
#: en/git-fsck.txt:48
#, ignore-same, no-wrap, priority:100
msgid "--no-reflogs"
msgstr "--no-reflogs"

#. type: Plain text
#: en/git-fsck.txt:53
#, priority:100
msgid "Do not consider commits that are referenced only by an entry in a reflog to be reachable. This option is meant only to search for commits that used to be in a ref, but now aren't, but are still in that corresponding reflog."
msgstr "不认为那些只被引用日志中的条目引用的提交是可以达到的。 这个选项只是为了搜索那些曾经在引用中，但现在不在了，但仍在那个相应引用日志中的提交。"

#. type: Labeled list
#: en/git-fsck.txt:54
#, ignore-same, no-wrap, priority:100
msgid "--full"
msgstr "--full"

#. type: Plain text
#: en/git-fsck.txt:63
#, placeholders:'GIT_OBJECT_DIRECTORY':'$GIT_DIR':'GIT_ALTERNATE_OBJECT_DIRECTORIES':'$GIT_DIR':'$GIT_DIR':'--no-full', priority:100
msgid "Check not just objects in GIT_OBJECT_DIRECTORY ($GIT_DIR/objects), but also the ones found in alternate object pools listed in GIT_ALTERNATE_OBJECT_DIRECTORIES or $GIT_DIR/objects/info/alternates, and in packed Git archives found in $GIT_DIR/objects/pack and corresponding pack subdirectories in alternate object pools. This is now default; you can turn it off with --no-full."
msgstr "不仅检查 GIT_OBJECT_DIRECTORY ($GIT_DIR/objects) 中的对象，还检查 GIT_ALTERNATE_OBJECT_DIRECTORIES 或 $GIT_DIR/objects/info/alternates 中列出的备用对象库中的对象，以及 $GIT_DIR/objects/pack 和备用对象库中相应 pack 子目录中的打包 Git 档案。 这现在是默认的；你可以用 --no-full 关闭它。"

#. type: Labeled list
#: en/git-fsck.txt:64
#, ignore-same, no-wrap, priority:100
msgid "--connectivity-only"
msgstr "--connectivity-only"

#. type: Plain text
#: en/git-fsck.txt:72
#, priority:100
msgid "Check only the connectivity of reachable objects, making sure that any objects referenced by a reachable tag, commit, or tree are present. This speeds up the operation by avoiding reading blobs entirely (though it does still check that referenced blobs exist). This will detect corruption in commits and trees, but not do any semantic checks (e.g., for format errors). Corruption in blob objects will not be detected at all."
msgstr "只检查可达对象的连接性，确保可达标签、提交或目录树所引用的任何对象都存在。这样可以完全避免读取 blobs，从而加快操作速度（尽管它仍然会检查被引用的 blobs 是否存在）。这将检测提交和树的损坏，但不做任何语义检查（例如，格式错误）。blob 对象中的损坏将完全不会被检测到。"

#. type: Plain text
#: en/git-fsck.txt:76
#, placeholders:'`--no-dangling`', priority:100
msgid "Unreachable tags, commits, and trees will also be accessed to find the tips of dangling segments of history. Use `--no-dangling` if you don't care about this output and want to speed it up further."
msgstr "无法到达的标签、提交和树也会被访问，以找到历史的悬空部分的提示。如果你不关心这个输出并想进一步加快它的速度，请使用 `--no-dangling`。"

#. type: Labeled list
#: en/git-fsck.txt:77 en/git-mktag.txt:43 en/git-unpack-objects.txt:44
#, ignore-same, no-wrap, priority:100
msgid "--strict"
msgstr "--strict"

#. type: Plain text
#: en/git-fsck.txt:84
#, priority:100
msgid "Enable more strict checking, namely to catch a file mode recorded with g+w bit set, which was created by older versions of Git. Existing repositories, including the Linux kernel, Git itself, and sparse repository have old objects that trigger this check, but it is recommended to check new projects with this flag."
msgstr "启用更严格的检查，即抓取记录有 g+w 位的文件模式，这是由旧版本的 Git 创建的。 现有的仓库，包括 Linux 内核、Git 本身和稀疏仓库都有旧的对象，会触发这个检查，但建议用这个标志检查新项目。"

#. type: Plain text
#: en/git-fsck.txt:87
#, priority:100
msgid "Be chatty."
msgstr "要健谈。"

#. type: Labeled list
#: en/git-fsck.txt:88
#, ignore-same, no-wrap, priority:100
msgid "--lost-found"
msgstr "--lost-found"

#. type: Plain text
#: en/git-fsck.txt:93
#, priority:100
msgid "Write dangling objects into .git/lost-found/commit/ or .git/lost-found/other/, depending on type. If the object is a blob, the contents are written into the file, rather than its object name."
msgstr "将悬空的对象写入 .git/lost-found/commit/ 或 .git/lost-found/other/，具体取决于类型。 如果对象是一个 blob，其内容将被写入文件，而不是其对象名称。"

#. type: Labeled list
#: en/git-fsck.txt:94
#, ignore-same, no-wrap, priority:100
msgid "--name-objects"
msgstr "--name-objects"

#. type: Plain text
#: en/git-fsck.txt:99
#, placeholders:'linkgit:git-rev-parse[1]':'HEAD':'{1234567890}', priority:100
msgid "When displaying names of reachable objects, in addition to the SHA-1 also display a name that describes *how* they are reachable, compatible with linkgit:git-rev-parse[1], e.g. `HEAD@{1234567890}~25^2:src/`."
msgstr "当显示可达对象的名称时，除了 SHA-1外，还显示描述 *如何* 可达的名称，与 linkgit:git-rev-parse[1] 兼容，例如，`HEAD@{1234567890}~25^2:src/`。"

#. type: Plain text
#: en/git-fsck.txt:106
#, placeholders:'--no-progress':'--verbose':'--progress', priority:100
msgid "Progress status is reported on the standard error stream by default when it is attached to a terminal, unless --no-progress or --verbose is specified. --progress forces progress status even if the standard error stream is not directed to a terminal."
msgstr "除非指定 --no-progress 或 --verbose，否则当标准错误流连接到终端时，默认情况下会报告进度状态。--progress 即使标准错误流没有指向终端，也会强制显示进度状态。"

#. type: Plain text
#: en/git-fsck.txt:123
#, placeholders:'git-fsck':'`--unreachable`', priority:100
msgid "git-fsck tests SHA-1 and general object sanity, and it does full tracking of the resulting reachability and everything else. It prints out any corruption it finds (missing or bad objects), and if you use the `--unreachable` flag it will also print out objects that exist but that aren't reachable from any of the specified head nodes (or the default set, as mentioned above)."
msgstr "git-fsck 测试 SHA-1和一般对象的正确性，并对结果的可及性和其他一切进行全面跟踪。它打印出它发现的任何损坏（缺失或坏的对象），如果你使用 `--unreachable` 标志，它也会打印出存在但从任何指定的头部节点（或默认集，如上所述）无法到达的对象。"

#. type: Plain text
#: en/git-fsck.txt:127
#, priority:100
msgid "Any corrupt objects you will have to find in backups or other archives (i.e., you can just remove them and do an 'rsync' with some other site in the hopes that somebody else has the object you have corrupted)."
msgstr "任何损坏的对象，你将不得不在备份或其他档案中找到（也就是说，你可以直接删除它们，并与其他网站做一个 'rsync'，希望别人拥有你损坏的对象）。"

#. type: Plain text
#: en/git-fsck.txt:130
#, placeholders:'core.commitGraph':'git commit-graph':'linkgit:git-commit-graph[1]', priority:100
msgid "If core.commitGraph is true, the commit-graph file will also be inspected using 'git commit-graph verify'. See linkgit:git-commit-graph[1]."
msgstr "如果 core.commitGraph 为真，提交的图形文件也将用 'git commit-graph verify' 来检查。见 linkgit:git-commit-graph[1]。"

#. type: Title -
#: en/git-fsck.txt:132
#, no-wrap, priority:100
msgid "Extracted Diagnostics"
msgstr "提取的诊断方法"

#. type: Labeled list
#: en/git-fsck.txt:134
#, no-wrap, priority:100
msgid "unreachable <type> <object>"
msgstr "无法到达 <类型> <对象> 的问题"

#. type: Plain text
#: en/git-fsck.txt:141
#, priority:100
msgid "The <type> object <object>, isn't actually referred to directly or indirectly in any of the trees or commits seen. This can mean that there's another root node that you're not specifying or that the tree is corrupt. If you haven't missed a root node then you might as well delete unreachable nodes since they can't be used."
msgstr "<类型> 对象 <对象>，实际上在看到的任何树或提交中都没有直接或间接地提到过。这可能意味着还有一个根节点没有被你指定，或者目录树被破坏了。如果你没有漏掉一个根节点，那么你不妨删除不可达的节点，因为它们不能被使用。"

#. type: Labeled list
#: en/git-fsck.txt:142
#, no-wrap, priority:100
msgid "missing <type> <object>"
msgstr "缺少 <类型> <对象>"

#. type: Plain text
#: en/git-fsck.txt:145
#, priority:100
msgid "The <type> object <object>, is referred to but isn't present in the database."
msgstr "<类型> 对象 <object>，被提及但不存在于数据库中。"

#. type: Labeled list
#: en/git-fsck.txt:146
#, no-wrap, priority:100
msgid "dangling <type> <object>"
msgstr "悬空的 <类型> <对象>"

#. type: Plain text
#: en/git-fsck.txt:149
#, priority:100
msgid "The <type> object <object>, is present in the database but never 'directly' used. A dangling commit could be a root node."
msgstr "<类型> 对象 <object>，存在于数据库中，但从未 'directly' 使用。一个悬空的提交可能是一个根节点。"

#. type: Labeled list
#: en/git-fsck.txt:150
#, no-wrap, priority:100
msgid "hash mismatch <object>"
msgstr "哈希值不匹配 <对象>"

#. type: Plain text
#: en/git-fsck.txt:154
#, priority:100
msgid "The database has an object whose hash doesn't match the object database value. This indicates a serious data integrity problem."
msgstr "数据库中有一个对象的哈希值与对象数据库的值不一致。 这表明一个严重的数据完整性问题。"

#. type: Title -
#: en/git-fsck.txt:157
#, no-wrap, priority:100
msgid "FSCK MESSAGES"
msgstr "FSCK 信息"

#. type: Plain text
#: en/git-fsck.txt:163
#, priority:100
msgid "The following lists the types of errors `git fsck` detects and what each error means, with their default severity. The severity of the error, other than those that are marked as \"(FATAL)\", can be tweaked by setting the corresponding `fsck.<msg-id>` configuration variable."
msgstr "下面列出了 `git fsck` 检测的错误类型和每个错误的含义，以及它们的默认严重程度。 除了那些被标记为 \"(FATAL)\" 的错误，其他错误的严重程度可以通过设置相应的 `fsck.<msg-id>` 配置变量来调整。"

#. type: Title -
#: en/git-fsck.txt:168 en/git.txt:459
#, no-wrap, priority:100
msgid "Environment Variables"
msgstr "环境变量"

#. type: Labeled list
#: en/git-fsck.txt:170
#, ignore-same, no-wrap, priority:100
msgid "GIT_OBJECT_DIRECTORY"
msgstr "GIT_OBJECT_DIRECTORY"

#. type: Plain text
#: en/git-fsck.txt:172
#, placeholders:'$GIT_DIR', priority:100
msgid "used to specify the object database root (usually $GIT_DIR/objects)"
msgstr "用来指定对象数据库的根（通常是 $GIT_DIR/objects）"

#. type: Labeled list
#: en/git-fsck.txt:173
#, ignore-same, no-wrap, priority:100
msgid "GIT_INDEX_FILE"
msgstr "GIT_INDEX_FILE"

#. type: Plain text
#: en/git-fsck.txt:175
#, priority:100
msgid "used to specify the index file of the index"
msgstr "用来指定索引的索引文件"

#. type: Labeled list
#: en/git-fsck.txt:176
#, ignore-same, no-wrap, priority:100
msgid "GIT_ALTERNATE_OBJECT_DIRECTORIES"
msgstr "GIT_ALTERNATE_OBJECT_DIRECTORIES"

#. type: Plain text
#: en/git-fsck.txt:178
#, priority:100
msgid "used to specify additional object database roots (usually unset)"
msgstr "用来指定额外的对象数据库根（通常不设置）"

#. type: Title =
#: en/git-gc.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-gc(1)"
msgstr "git-gc(1)"

#. type: Plain text
#: en/git-gc.txt:7
#, placeholders:'git-gc', priority:100
msgid "git-gc - Cleanup unnecessary files and optimize the local repository"
msgstr "git-gc - 清理不必要的文件并优化本地仓库"

#. type: Plain text
#: en/git-gc.txt:13
#, no-wrap, placeholders:'[--aggressive]':'[--auto]':'[--quiet]':'[--prune=':'--no-prune]':'[--force]':'[--keep-largest-pack]', priority:100
msgid "'git gc' [--aggressive] [--auto] [--quiet] [--prune=<date> | --no-prune] [--force] [--keep-largest-pack]\n"
msgstr "'git gc' [--aggressive] [--auto] [--quiet] [--prune=<日期> | --no-prune] [--force] [--keep-largest-pack]\n"

#. type: Plain text
#: en/git-gc.txt:22
#, priority:100
msgid "Runs a number of housekeeping tasks within the current repository, such as compressing file revisions (to reduce disk space and increase performance), removing unreachable objects which may have been created from prior invocations of 'git add', packing refs, pruning reflog, rerere metadata or stale working trees. May also update ancillary indexes such as the commit-graph."
msgstr "在当前版本库中执行一些内务管理任务，比如压缩文件修订（以减少磁盘空间并提高性能），移除之前调用 'git add' 所创建的不可达对象，打包引用，修剪引用日志、rerere metadata 或过时的工作区。也可以更新辅助索引，如提交图。"

#. type: Plain text
#: en/git-gc.txt:27
#, placeholders:'gc.auto', priority:100
msgid "When common porcelain operations that create objects are run, they will check whether the repository has grown substantially since the last maintenance, and if so run `git gc` automatically. See `gc.auto` below for how to disable this behavior."
msgstr "当运行创建对象的普通上层命令操作时，它们会检查仓库在上次维护后是否有大幅增长，如果有，就自动运行 `git gc`。参见下面的 `gc.auto` 以了解如何禁用这一行为。"

#. type: Plain text
#: en/git-gc.txt:33
#, placeholders:'linkgit:git-fast-import[1]', priority:100
msgid "Running `git gc` manually should only be needed when adding objects to a repository without regularly running such porcelain commands, to do a one-off repository optimization, or e.g. to clean up a suboptimal mass-import. See the \"PACKFILE OPTIMIZATION\" section in linkgit:git-fast-import[1] for more details on the import case."
msgstr "手动运行 `git gc` 应该只在向仓库添加对象而不定期运行这种上层命令时才需要，以进行一次性的仓库优化，或者例如清理次优的大规模导入。关于导入情况的更多细节，请参见 linkgit:git-fast-import[1] 中的 “包装文件优化” 部分。"

#. type: Labeled list
#: en/git-gc.txt:37 en/git-read-tree.txt:72
#, ignore-same, no-wrap, priority:100
msgid "--aggressive"
msgstr "--aggressive"

#. type: Plain text
#: en/git-gc.txt:43
#, priority:100
msgid "Usually 'git gc' runs very quickly while providing good disk space utilization and performance. This option will cause 'git gc' to more aggressively optimize the repository at the expense of taking much more time. The effects of this optimization are mostly persistent. See the \"AGGRESSIVE\" section below for details."
msgstr "通常，'git gc' 运行得非常快，同时提供良好的磁盘空间利用率和性能。 这个选项会使 'git gc' 更积极地优化仓库，代价是花费更多的时间。 这种优化的效果大多是持续性的。详情见下面的 \"AGGRESSIVE\" 部分。"

#. type: Labeled list
#: en/git-gc.txt:44
#, ignore-same, no-wrap, priority:100
msgid "--auto"
msgstr "--auto"

#. type: Plain text
#: en/git-gc.txt:47
#, priority:100
msgid "With this option, 'git gc' checks whether any housekeeping is required; if not, it exits without performing any work."
msgstr "有了这个选项，'git gc' 就会检查是否需要任何内务处理；如果不需要，它就会退出，不执行任何工作。"

#. type: Plain text
#: en/git-gc.txt:50
#, placeholders:'gc.auto', priority:100
msgid "See the `gc.auto` option in the \"CONFIGURATION\" section below for how this heuristic works."
msgstr "关于这个启发式的工作原理，请看下面 “配置” 部分的 `gc.auto` 选项。"

#. type: Plain text
#: en/git-gc.txt:55
#, ignore-ellipsis, placeholders:'gc.auto':'gc.autoPackLimit', priority:100
msgid "Once housekeeping is triggered by exceeding the limits of configuration options such as `gc.auto` and `gc.autoPackLimit`, all other housekeeping tasks (e.g. rerere, working trees, reflog...) will be performed as well."
msgstr "一旦超过配置选项如 `gc.auto` 和 `gc.autoPackLimit` 的限制而触发内务管理，所有其他内务管理任务（如 reere、working trees、reflog...）也将被执行。"

#. type: Labeled list
#: en/git-gc.txt:57
#, ignore-same, no-wrap, priority:100
msgid "--[no-]cruft"
msgstr "--[no-]cruft"

#. type: Plain text
#: en/git-gc.txt:61
#, placeholders:'`--cruft`', priority:100
msgid "When expiring unreachable objects, pack them separately into a cruft pack instead of storing them as loose objects. `--cruft` is on by default."
msgstr "当无法到达的对象过期时，将它们单独打包到一个 cruft 包中，而不是将它们作为散装对象存储。`--cruft` 是默认开启的。"

#. type: Labeled list
#: en/git-gc.txt:62 en/git-repack.txt:77
#, no-wrap, placeholders:'--max-cruft-size=', priority:100
msgid "--max-cruft-size=<n>"
msgstr "--max-cruft-size=<n>"

#. type: Plain text
#: en/git-gc.txt:68
#, placeholders:'gc.maxCruftSize':'`--max-cruft-size`':'linkgit:git-repack[1]', priority:100
msgid "When packing unreachable objects into a cruft pack, limit the size of new cruft packs to be at most `<n>` bytes. Overrides any value specified via the `gc.maxCruftSize` configuration. See the `--max-cruft-size` option of linkgit:git-repack[1] for more."
msgstr "在将无法访问的对象打包到 Cruft 包时，限制新 Cruft 包的大小最多为 `<n>` 字节。覆盖通过 `gc.maxCruftSize` 配置指定的任何值。参见 linkgit:git-repack[1] 的 `--max-cruft-size`选项了解更多。"

#. type: Labeled list
#: en/git-gc.txt:69
#, no-wrap, placeholders:'--prune=', priority:100
msgid "--prune=<date>"
msgstr "--prune=<日期>"

#. type: Plain text
#: en/git-gc.txt:76
#, placeholders:'gc.pruneExpire':'--prune=now':'--prune', priority:100
msgid "Prune loose objects older than date (default is 2 weeks ago, overridable by the config variable `gc.pruneExpire`). --prune=now prunes loose objects regardless of their age and increases the risk of corruption if another process is writing to the repository concurrently; see \"NOTES\" below. --prune is on by default."
msgstr "修剪超过日期的松散对象（默认是 2 周前，可由配置变量 `gc.pruneExpire` 覆盖）。 --prune=now 删减松散对象，无论其年龄大小，如果有其他进程同时向仓库写入，则会增加损坏的风险；见下面的 “注意事项”。--prune 默认是打开的。"

#. type: Labeled list
#: en/git-gc.txt:77 en/git-pack-refs.txt:58
#, ignore-same, no-wrap, priority:100
msgid "--no-prune"
msgstr "--no-prune"

#. type: Plain text
#: en/git-gc.txt:79
#, priority:100
msgid "Do not prune any loose objects."
msgstr "不要修剪任何松散的对象。"

#. type: Plain text
#: en/git-gc.txt:82
#, priority:100
msgid "Suppress all progress reports."
msgstr "抑制所有进度报告。"

#. type: Plain text
#: en/git-gc.txt:86
#, priority:100
msgid "Force `git gc` to run even if there may be another `git gc` instance running on this repository."
msgstr "强制 `git gc` 运行，即使这个仓库可能有另一个 `git gc` 实例在运行。"

#. type: Labeled list
#: en/git-gc.txt:87
#, ignore-same, no-wrap, priority:100
msgid "--keep-largest-pack"
msgstr "--keep-largest-pack"

#. type: Plain text
#: en/git-gc.txt:92
#, placeholders:'gc.bigPackThreshold', priority:100
msgid "All packs except the largest non-cruft pack, any packs marked with a `.keep` file, and any cruft pack(s) are consolidated into a single pack. When this option is used, `gc.bigPackThreshold` is ignored."
msgstr "除了最大的非破坏性包，任何标有 `.keep` 文件的包，以及任何破坏性的包，都会被合并为一个包。当使用这个选项时，`gc.bigPackThreshold` 被忽略。"

#. type: Title -
#: en/git-gc.txt:94
#, no-wrap, priority:100
msgid "AGGRESSIVE"
msgstr "侵略的"

#. type: Plain text
#: en/git-gc.txt:101
#, placeholders:'`--aggressive`':'linkgit:git-repack[1]':'`-f`':'`--no-reuse-delta`':'linkgit:git-pack-objects[1]', priority:100
msgid "When the `--aggressive` option is supplied, linkgit:git-repack[1] will be invoked with the `-f` flag, which in turn will pass `--no-reuse-delta` to linkgit:git-pack-objects[1]. This will throw away any existing deltas and re-compute them, at the expense of spending much more time on the repacking."
msgstr "当提供 `--aggressive` 选项时，linkgit:git-repack[1] 将被调用，并带有 `-f` 标志，这又将把 `--no-reuse-delta` 传递给 linkgit:git-pack-objects[1]。这将丢弃任何现有的 delta 并重新计算，代价是在重新打包上花费更多的时间。"

#. type: Plain text
#: en/git-gc.txt:106
#, priority:100
msgid "The effects of this are mostly persistent, e.g. when packs and loose objects are coalesced into one another pack the existing deltas in that pack might get re-used, but there are also various cases where we might pick a sub-optimal delta from a newer pack instead."
msgstr "这方面的影响主要是持久性的，例如，当包和松散对象被凝聚成另一个包时，该包中现有的 delta 可能会被重新使用，但也有各种情况，我们可能会从一个较新的包中挑选一个次优 delta。"

#. type: Plain text
#: en/git-gc.txt:112
#, placeholders:'`--aggressive`':'`--depth`':'`--window`':'linkgit:git-repack[1]':'gc.aggressiveDepth':'gc.aggressiveWindow', priority:100
msgid "Furthermore, supplying `--aggressive` will tweak the `--depth` and `--window` options passed to linkgit:git-repack[1]. See the `gc.aggressiveDepth` and `gc.aggressiveWindow` settings below. By using a larger window size we're more likely to find more optimal deltas."
msgstr "此外，提供 `--aggressive` 将调整传递给 linkgit:git-repack[1] 的 `--depth` 和 `--window` 选项。见下面的 `gc.aggressiveDepth` 和 `gc.aggressiveWindow` 设置。通过使用较大的窗口尺寸，我们更有可能找到更多的最佳 deltas。"

#. type: Plain text
#: en/git-gc.txt:118
#, priority:100
msgid "It's probably not worth it to use this option on a given repository without running tailored performance benchmarks on it. It takes a lot more time, and the resulting space/delta optimization may or may not be worth it. Not using this at all is the right trade-off for most users and their repositories."
msgstr "在没有运行定制的性能基准的情况下，在一个给定的仓库上使用这个选项可能是不值得的。它需要更多的时间，而由此产生的空间/延迟优化可能值得也可能不值得。对于大多数用户和他们的仓库来说，完全不使用这个选项是正确的权衡。"

#. type: Plain text
#: en/git-gc.txt:140
#, priority:100
msgid "'git gc' tries very hard not to delete objects that are referenced anywhere in your repository. In particular, it will keep not only objects referenced by your current set of branches and tags, but also objects referenced by the index, remote-tracking branches, reflogs (which may reference commits in branches that were later amended or rewound), and anything else in the refs/* namespace. Note that a note (of the kind created by 'git notes') attached to an object does not contribute in keeping the object alive. If you are expecting some objects to be deleted and they aren't, check all of those locations and decide whether it makes sense in your case to remove those references."
msgstr "'git gc' 非常努力地不删除在你的仓库中任何地方被引用的对象。特别是，它不仅会保留当前分支和标记集所引用的对象，还会保留索引、远程跟踪分支、 引用日志（可能引用了后来被修改或回绕的分支中的提交）以及 refs/* 名称空间中的任何其他对象。请注意，附在一个对象上的注释（由 'git notes' 创建的那种）并不有助于保持该对象的活力。如果你期待一些对象被删除，而它们没有被删除，请检查所有这些位置，并决定在你的情况下，删除这些引用是否有意义。"

#. type: Plain text
#: en/git-gc.txt:147
#, priority:100
msgid "On the other hand, when 'git gc' runs concurrently with another process, there is a risk of it deleting an object that the other process is using but hasn't created a reference to. This may just cause the other process to fail or may corrupt the repository if the other process later adds a reference to the deleted object. Git has two features that significantly mitigate this problem:"
msgstr "另一方面，当 'git gc' 与另一个进程同时运行时，它有可能删除另一个进程正在使用但还没有创建引用的对象。这可能会导致其他进程失败，或者如果其他进程后来添加了对被删除对象的引用，则可能会破坏仓库。Git 有两个功能可以大大缓解这个问题："

#. type: Plain text
#: en/git-gc.txt:150
#, placeholders:'`--prune`', priority:100
msgid "Any object with modification time newer than the `--prune` date is kept, along with everything reachable from it."
msgstr "任何修改时间早于 `--prune` 日期的对象都会被保留，同时也会保留所有可以到达的对象。"

#. type: Plain text
#: en/git-gc.txt:154
#, priority:100
msgid "Most operations that add an object to the database update the modification time of the object if it is already present so that #1 applies."
msgstr "大多数向数据库添加对象的操作都会更新对象的修改时间，如果它已经存在，那么 #1 就适用。"

#. type: Plain text
#: en/git-gc.txt:158
#, priority:100
msgid "However, these features fall short of a complete solution, so users who run commands concurrently have to live with some risk of corruption (which seems to be low in practice)."
msgstr "然而，这些功能并不是一个完整的解决方案，所以同时运行命令的用户不得不忍受一些损坏的风险（在实践中似乎很低）。"

#. type: Plain text
#: en/git-gc.txt:164
#, placeholders:'--auto':'linkgit:githooks[5]', priority:100
msgid "The 'git gc --auto' command will run the 'pre-auto-gc' hook. See linkgit:githooks[5] for more information."
msgstr "'git gc --auto' 命令将运行 'pre-auto-gc' 钩子。 更多信息请参见 linkgit:githooks[5]。"

#. type: Plain text
#: en/git-gc.txt:172
#, ignore-same, priority:100
msgid "linkgit:git-prune[1] linkgit:git-reflog[1] linkgit:git-repack[1] linkgit:git-rerere[1]"
msgstr "linkgit:git-prune[1] linkgit:git-reflog[1] linkgit:git-repack[1] linkgit:git-rerere[1]"

#. type: Title =
#: en/git-get-tar-commit-id.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-get-tar-commit-id(1)"
msgstr "git-get-tar-commit-id(1)"

#. type: Plain text
#: en/git-get-tar-commit-id.txt:7
#, placeholders:'git-get-tar-commit-id':'git-archive', priority:100
msgid "git-get-tar-commit-id - Extract commit ID from an archive created using git-archive"
msgstr "git-get-tar-commit-id - 从使用 git-archive 创建的归档中提取提交 ID"

#. type: Plain text
#: en/git-get-tar-commit-id.txt:13
#, no-wrap, placeholders:'git get-tar-commit-id', priority:100
msgid "'git get-tar-commit-id'\n"
msgstr "'git get-tar-commit-id'\n"

#. type: Plain text
#: en/git-get-tar-commit-id.txt:22
#, priority:100
msgid "Read a tar archive created by 'git archive' from the standard input and extract the commit ID stored in it. It reads only the first 1024 bytes of input, thus its runtime is not influenced by the size of the tar archive very much."
msgstr "从标准输入中读取 'git archive' 创建的 tar 档案，并提取其中的提交 ID。 它只读取输入的前 1024 字节，因此它的运行时间不会受到 tar 压缩包大小的影响。"

#. type: Plain text
#: en/git-get-tar-commit-id.txt:27
#, placeholders:'git get-tar-commit-id', priority:100
msgid "If no commit ID is found, 'git get-tar-commit-id' quietly exits with a return code of 1. This can happen if the archive had not been created using 'git archive' or if the first parameter of 'git archive' had been a tree ID instead of a commit ID or tag."
msgstr "如果没有找到提交 ID，'git get-tar-commit-id' 就会悄悄存在，返回代码为 1。如果档案没有用 'git archive' 创建，或者 'git archive' 的第一个参数是树的 ID 而不是提交 ID 或标签，就会发生这种情况。"

#. type: Title =
#: en/git-grep.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-grep(1)"
msgstr "git-grep(1)"

#. type: Plain text
#: en/git-grep.txt:7
#, placeholders:'git-grep', priority:100
msgid "git-grep - Print lines matching a pattern"
msgstr "git-grep - 打印与模式匹配的行"

#. type: Plain text
#: en/git-grep.txt:33
#, ignore-ellipsis, no-wrap, placeholders:'--text]':'[--textconv]':'--ignore-case]':'--word-regexp]':'--invert-match]':'[--full-name]':'--extended-regexp]':'--basic-regexp]':'--perl-regexp]':'--fixed-strings]':'--line-number]':'[--column]':'--files-with-matches]':'--files-without-match]':'--open-files-in-pager':'--null]':'--only-matching':'--count]':'[--all-match]':'--quiet]':'[--max-depth':'[--color':'--no-color]':'[--break]':'[--heading]':'--show-function]':'--function-context]':'--max-count':'[--threads':'[--and':'--or':'--not':'[--recurse-submodules]':'[--parent-basename':'[--cached':'--no-index':'--untracked]', priority:100
msgid ""
"'git grep' [-a | --text] [-I] [--textconv] [-i | --ignore-case] [-w | --word-regexp]\n"
"\t   [-v | --invert-match] [-h|-H] [--full-name]\n"
"\t   [-E | --extended-regexp] [-G | --basic-regexp]\n"
"\t   [-P | --perl-regexp]\n"
"\t   [-F | --fixed-strings] [-n | --line-number] [--column]\n"
"\t   [-l | --files-with-matches] [-L | --files-without-match]\n"
"\t   [(-O | --open-files-in-pager) [<pager>]]\n"
"\t   [-z | --null]\n"
"\t   [ -o | --only-matching ] [-c | --count] [--all-match] [-q | --quiet]\n"
"\t   [--max-depth <depth>] [--[no-]recursive]\n"
"\t   [--color[=<when>] | --no-color]\n"
"\t   [--break] [--heading] [-p | --show-function]\n"
"\t   [-A <post-context>] [-B <pre-context>] [-C <context>]\n"
"\t   [-W | --function-context]\n"
"\t   [(-m | --max-count) <num>]\n"
"\t   [--threads <num>]\n"
"\t   [-f <file>] [-e] <pattern>\n"
"\t   [--and|--or|--not|(|)|-e <pattern>...]\n"
"\t   [--recurse-submodules] [--parent-basename <basename>]\n"
"\t   [ [--[no-]exclude-standard] [--cached | --no-index | --untracked] | <tree>...]\n"
"\t   [--] [<pathspec>...]\n"
msgstr ""
"'git grep' [-a | --text] [-I] [--textconv] [-i | --ignore-case] [-w | --word-regexp]\n"
"\t   [-v | --invert-match] [-h|-H] [--full-name]\n"
"\t   [-E | --extended-regexp] [-G | --basic-regexp]\n"
"\t   [-P | --perl-regexp]\n"
"\t   [-F | --fixed-strings] [-n | --line-number] [--column]\n"
"\t   [-l | --files-with-matches] [-L | --files-without-match]\n"
"\t   [(-O | --open-files-in-pager) [<分页器>]]\n"
"\t   [-z | --null]\n"
"\t   [ -o | --only-matching ] [-c | --count] [--all-match] [-q | --quiet]\n"
"\t   [--max-depth <depth>] [--[no-]recursive]\n"
"\t   [--color[=<when>] | --no-color]\n"
"\t   [--break] [--heading] [-p | --show-function]\n"
"\t   [-A <后上下文>] [-B <前上下文>] [-C <上下文>]\n"
"\t   [-W | --function-context]\n"
"\t   [(-m | --max-count) <数量>]\n"
"\t   [--threads <数量>]\n"
"\t   [-f <file>] [-e] <模式>\n"
"\t   [--and|--or|--not|(|)|-e <模式>...]\n"
"\t   [--recurse-submodules] [--parent-basename <basename>]\n"
"\t   [ [--[no-]exclude-standard] [--cached | --no-index | --untracked] | <目录树>...]\n"
"\t   [--] [<路径规范>...]\n"

#. type: Plain text
#: en/git-grep.txt:40
#, priority:100
msgid "Look for specified patterns in the tracked files in the work tree, blobs registered in the index file, or blobs in given tree objects. Patterns are lists of one or more search expressions separated by newline characters. An empty string as search expression matches all lines."
msgstr "在工作区中的跟踪文件、在索引文件中注册的 blobs 或给定树对象中的 blobs 中寻找指定的模式。 模式是由一个或多个搜索表达式组成的列表，用换行符分隔。 一个空的字符串作为搜索表达式可以匹配所有的行。"

#. type: Plain text
#: en/git-grep.txt:47
#, priority:100
msgid "Instead of searching tracked files in the working tree, search blobs registered in the index file."
msgstr "与其搜索工作区中的跟踪文件，不如搜索索引文件中注册的 blobs。"

#. type: Plain text
#: en/git-grep.txt:50
#, priority:100
msgid "Search files in the current directory that is not managed by Git."
msgstr "搜索当前目录中不被 Git 管理的文件。"

#. type: Labeled list
#: en/git-grep.txt:51
#, ignore-same, no-wrap, priority:100
msgid "--untracked"
msgstr "--untracked"

#. type: Plain text
#: en/git-grep.txt:54
#, priority:100
msgid "In addition to searching in the tracked files in the working tree, search also in untracked files."
msgstr "除了在工作区中的跟踪文件中搜索外，还可以在未跟踪的文件中搜索。"

#. type: Labeled list
#: en/git-grep.txt:55
#, ignore-same, no-wrap, priority:100
msgid "--no-exclude-standard"
msgstr "--no-exclude-standard"

#. type: Plain text
#: en/git-grep.txt:58
#, placeholders:'.gitignore':'`--untracked`', priority:100
msgid "Also search in ignored files by not honoring the `.gitignore` mechanism. Only useful with `--untracked`."
msgstr "也可以通过不遵守 `.gitignore` 机制在被忽略的文件中搜索。只对 `--untracked` 有用。"

#. type: Labeled list
#: en/git-grep.txt:59 en/git-ls-files.txt:127
#, ignore-same, no-wrap, priority:100
msgid "--exclude-standard"
msgstr "--exclude-standard"

#. type: Plain text
#: en/git-grep.txt:63
#, placeholders:'.gitignore':'`--no-index`', priority:100
msgid "Do not pay attention to ignored files specified via the `.gitignore` mechanism. Only useful when searching files in the current directory with `--no-index`."
msgstr "不注意通过 `.gitignore` 机制指定的被忽略的文件。 只有在用 `--no-index` 搜索当前目录下的文件时才有用。"

#. type: Plain text
#: en/git-grep.txt:70
#, placeholders:'`--no-index`', priority:100
msgid "Recursively search in each submodule that is active and checked out in the repository. When used in combination with the <tree> option the prefix of all submodule output will be the name of the parent project's <tree> object. This option has no effect if `--no-index` is given."
msgstr "递归搜索在仓库中激活和检出的每个子模块。 当与 <tree> 选项结合使用时，所有子模块输出的前缀将是父项目的 <tree> 对象的名称。如果给了 `--no-index`，这个选项就没有效果。"

#. type: Plain text
#: en/git-grep.txt:74
#, priority:100
msgid "Process binary files as if they were text."
msgstr "像处理文本一样处理二进制文件。"

#. type: Plain text
#: en/git-grep.txt:77
#, priority:100
msgid "Honor textconv filter settings."
msgstr "认可 textconv 过滤器设置。"

#. type: Plain text
#: en/git-grep.txt:81
#, priority:100
msgid "Do not honor textconv filter settings. This is the default."
msgstr "不用认可 textconv 过滤器的设置。 这是默认的。"

#. type: Plain text
#: en/git-grep.txt:86
#, priority:100
msgid "Ignore case differences between the patterns and the files."
msgstr "忽略图案和文件之间的大小写差异。"

#. type: Labeled list
#: en/git-grep.txt:87
#, ignore-same, no-wrap, priority:100
msgid "-I"
msgstr "-I"

#. type: Plain text
#: en/git-grep.txt:89
#, priority:100
msgid "Don't match the pattern in binary files."
msgstr "不匹配二进制文件中的模式。"

#. type: Labeled list
#: en/git-grep.txt:90
#, no-wrap, placeholders:'--max-depth', priority:100
msgid "--max-depth <depth>"
msgstr "--max-depth <深度>"

#. type: Plain text
#: en/git-grep.txt:96
#, placeholders:'--max-depth', priority:100
msgid "For each <pathspec> given on command line, descend at most <depth> levels of directories. A value of -1 means no limit. This option is ignored if <pathspec> contains active wildcards. In other words if \"a*\" matches a directory named \"a*\", \"*\" is matched literally so --max-depth is still effective."
msgstr "对于命令行上给出的每个 <路径规范>，最多下降 <深度> 级目录。值为-1意味着没有限制。 如果 <路径规范> 包含有效的通配符，这个选项会被忽略。 换句话说，如果 \"a*\" 匹配名为 \"a* \"的目录，\"*\" 就会被匹配，所以 --max-depth 仍然有效。"

#. type: Labeled list
#: en/git-grep.txt:98 en/git-submodule.txt:421
#, ignore-same, no-wrap, priority:220
msgid "--recursive"
msgstr "--recursive"

#. type: Plain text
#: en/git-grep.txt:100
#, placeholders:'`--max-depth=-1`', priority:100
msgid "Same as `--max-depth=-1`; this is the default."
msgstr "与 `--max-depth=-1` 相同；这是默认值。"

#. type: Labeled list
#: en/git-grep.txt:101
#, ignore-same, no-wrap, priority:100
msgid "--no-recursive"
msgstr "--no-recursive"

#. type: Plain text
#: en/git-grep.txt:103
#, placeholders:'`--max-depth=0`', priority:100
msgid "Same as `--max-depth=0`."
msgstr "与 `--max-depth=0` 相同。"

#. type: Labeled list
#: en/git-grep.txt:105
#, ignore-same, no-wrap, priority:100
msgid "--word-regexp"
msgstr "--word-regexp"

#. type: Plain text
#: en/git-grep.txt:109
#, priority:100
msgid "Match the pattern only at word boundary (either begin at the beginning of a line, or preceded by a non-word character; end at the end of a line or followed by a non-word character)."
msgstr "只在词的边界处匹配模式（要么从一行的开头开始，要么前面是一个非词的字符；要么在一行的结尾结束，要么后面是一个非词的字符）。"

#. type: Labeled list
#: en/git-grep.txt:111
#, ignore-same, no-wrap, priority:100
msgid "--invert-match"
msgstr "--invert-match"

#. type: Plain text
#: en/git-grep.txt:113
#, priority:100
msgid "Select non-matching lines."
msgstr "选择非匹配的行。"

#. type: Plain text
#: en/git-grep.txt:121
#, placeholders:'`-h`':'`-H`':'`-h`', priority:100
msgid "By default, the command shows the filename for each match. `-h` option is used to suppress this output. `-H` is there for completeness and does not do anything except it overrides `-h` given earlier on the command line."
msgstr "默认情况下，该命令显示每个匹配的文件名。 `-h` 选项用于抑制这种输出。 `-H` 是为了完整性而存在的，除了覆盖先前在命令行中给出的 `-h` 外，它不做任何事情。"

#. type: Labeled list
#: en/git-grep.txt:122 en/git-ls-files.txt:176 en/git-ls-tree.txt:78
#, ignore-same, no-wrap, priority:100
msgid "--full-name"
msgstr "--full-name"

#. type: Plain text
#: en/git-grep.txt:127 en/git-ls-files.txt:181
#, priority:100
msgid "When run from a subdirectory, the command usually outputs paths relative to the current directory. This option forces paths to be output relative to the project top directory."
msgstr "当从一个子目录运行时，该命令通常会输出相对于当前目录的路径。 这个选项强制输出相对于项目顶层目录的路径。"

#. type: Labeled list
#: en/git-grep.txt:128 en/rev-list-options.txt:87
#, ignore-same, no-wrap, priority:260
msgid "-E"
msgstr "-E"

#. type: Labeled list
#: en/git-grep.txt:129 en/rev-list-options.txt:88
#, ignore-same, no-wrap, priority:260
msgid "--extended-regexp"
msgstr "--extended-regexp"

#. type: Labeled list
#: en/git-grep.txt:130
#, ignore-same, no-wrap, priority:100
msgid "-G"
msgstr "-G"

#. type: Labeled list
#: en/git-grep.txt:131 en/rev-list-options.txt:83
#, ignore-same, no-wrap, priority:260
msgid "--basic-regexp"
msgstr "--basic-regexp"

#. type: Plain text
#: en/git-grep.txt:134
#, priority:100
msgid "Use POSIX extended/basic regexp for patterns. Default is to use basic regexp."
msgstr "对模式使用 POSIX 扩展/基本的正则表达式。 默认是使用基本的正则表达式。"

#. type: Labeled list
#: en/git-grep.txt:136 en/rev-list-options.txt:98
#, ignore-same, no-wrap, priority:260
msgid "--perl-regexp"
msgstr "--perl-regexp"

#. type: Plain text
#: en/git-grep.txt:138
#, priority:100
msgid "Use Perl-compatible regular expressions for patterns."
msgstr "使用与 Perl 兼容的正则表达式的模式。"

#. type: Plain text
#: en/git-grep.txt:142 en/rev-list-options.txt:105
#, priority:260
msgid "Support for these types of regular expressions is an optional compile-time dependency. If Git wasn't compiled with support for them providing this option will cause it to die."
msgstr "对这些类型的正则表达式的支持是一个可选的编译时依赖。如果Git在编译时没有对它们的支持，提供这个选项将导致它死亡。"

#. type: Labeled list
#: en/git-grep.txt:143 en/git-repack.txt:102 en/rev-list-options.txt:92
#, ignore-same, no-wrap, priority:260
msgid "-F"
msgstr "-F"

#. type: Labeled list
#: en/git-grep.txt:144 en/rev-list-options.txt:93
#, ignore-same, no-wrap, priority:260
msgid "--fixed-strings"
msgstr "--fixed-strings"

#. type: Plain text
#: en/git-grep.txt:147
#, priority:100
msgid "Use fixed strings for patterns (don't interpret pattern as a regex)."
msgstr "使用固定的字符串来表示模式（不要把模式解释为一个重合词）。"

#. type: Labeled list
#: en/git-grep.txt:149
#, ignore-same, no-wrap, priority:100
msgid "--line-number"
msgstr "--line-number"

#. type: Plain text
#: en/git-grep.txt:151
#, priority:100
msgid "Prefix the line number to matching lines."
msgstr "在匹配的行前加上行号。"

#. type: Labeled list
#: en/git-grep.txt:152
#, ignore-same, no-wrap, priority:100
msgid "--column"
msgstr "--column"

#. type: Plain text
#: en/git-grep.txt:155
#, priority:100
msgid "Prefix the 1-indexed byte-offset of the first match from the start of the matching line."
msgstr "前缀为从匹配行开始的第一个匹配的索引的字节偏移量。"

#. type: Labeled list
#: en/git-grep.txt:157
#, ignore-same, no-wrap, priority:100
msgid "--files-with-matches"
msgstr "--files-with-matches"

#. type: Labeled list
#: en/git-grep.txt:159
#, ignore-same, no-wrap, priority:100
msgid "-L"
msgstr "-L"

#. type: Labeled list
#: en/git-grep.txt:160
#, ignore-same, no-wrap, priority:100
msgid "--files-without-match"
msgstr "--files-without-match"

#. type: Plain text
#: en/git-grep.txt:165
#, placeholders:'`--name-only`':'`--files-with-matches`', priority:100
msgid "Instead of showing every matched line, show only the names of files that contain (or do not contain) matches. For better compatibility with 'git diff', `--name-only` is a synonym for `--files-with-matches`."
msgstr "不显示每个匹配行，只显示包含（或不包含）匹配的文件名。 为了与 'git diff' 更好地兼容，`--name-only` 是 `--files-with-matches` 的同义词。"

#. type: Labeled list
#: en/git-grep.txt:166
#, no-wrap, priority:100
msgid "-O[<pager>]"
msgstr "-O[<分页器>]"

#. type: Labeled list
#: en/git-grep.txt:167
#, no-wrap, placeholders:'--open-files-in-pager', priority:100
msgid "--open-files-in-pager[=<pager>]"
msgstr "--open-files-in-pager[=<分页器>]"

#. type: Plain text
#: en/git-grep.txt:175
#, placeholders:'core.pager':'linkgit:git-config[1]', priority:100
msgid "Open the matching files in the pager (not the output of 'grep'). If the pager happens to be \"less\" or \"vi\", and the user specified only one pattern, the first file is positioned at the first match automatically. The `pager` argument is optional; if specified, it must be stuck to the option without a space. If `pager` is unspecified, the default pager will be used (see `core.pager` in linkgit:git-config[1])."
msgstr "在分页器中打开匹配的文件（不是 'grep' 的输出）。 如果分页器恰好是 \"less\" 或 \"vi\"，而用户只指定了一个模式，那么第一个文件就会自动定位在第一个匹配处。`pager` 参数是可选的；如果指定，它必须与选项卡在一起，没有空格。如果没有指定 `pager`，将使用默认的分页器（见 linkgit:git-config[1] 中的 `core.pager`）。"

#. type: Plain text
#: en/git-grep.txt:182
#, placeholders:'core.quotePath':'linkgit:git-config[1]', priority:100
msgid "Use \\0 as the delimiter for pathnames in the output, and print them verbatim. Without this option, pathnames with \"unusual\" characters are quoted as explained for the configuration variable core.quotePath (see linkgit:git-config[1])."
msgstr "使用\\0作为输出中路径名的分隔符，并逐字打印它们。按照配置变量core.quotePath的说明，引用带有“ unusual”字符的路径名 (查阅linkgit:git-config[1])。"

#. type: Labeled list
#: en/git-grep.txt:184
#, ignore-same, no-wrap, priority:100
msgid "--only-matching"
msgstr "--only-matching"

#. type: Plain text
#: en/git-grep.txt:187
#, priority:100
msgid "Print only the matched (non-empty) parts of a matching line, with each such part on a separate output line."
msgstr "只打印匹配行中的匹配（非空）部分，每一个这样的部分都在单独的输出行中。"

#. type: Labeled list
#: en/git-grep.txt:189 en/rev-list-options.txt:1199
#, ignore-same, no-wrap, priority:260
msgid "--count"
msgstr "--count"

#. type: Plain text
#: en/git-grep.txt:192
#, priority:100
msgid "Instead of showing every matched line, show the number of lines that match."
msgstr "与其显示每一个匹配的行，不如显示匹配的行数。"

#. type: Plain text
#: en/git-grep.txt:196
#, priority:100
msgid "Show colored matches. The value must be always (the default), never, or auto."
msgstr "显示有颜色的匹配。 该值必须是总是（默认值）、从不、或自动。"

#. type: Plain text
#: en/git-grep.txt:201
#, placeholders:'`--color=never`', priority:100
msgid "Turn off match highlighting, even when the configuration file gives the default to color output. Same as `--color=never`."
msgstr "关闭匹配高亮，即使在配置文件中默认为彩色输出。 与 `--color=never` 相同。"

#. type: Labeled list
#: en/git-grep.txt:202
#, ignore-same, no-wrap, priority:100
msgid "--break"
msgstr "--break"

#. type: Plain text
#: en/git-grep.txt:204
#, priority:100
msgid "Print an empty line between matches from different files."
msgstr "在不同文件的匹配之间打印一个空行。"

#. type: Labeled list
#: en/git-grep.txt:205
#, ignore-same, no-wrap, priority:100
msgid "--heading"
msgstr "--heading"

#. type: Plain text
#: en/git-grep.txt:208
#, priority:100
msgid "Show the filename above the matches in that file instead of at the start of each shown line."
msgstr "在该文件中的匹配项上方显示文件名，而不是在每个显示行的开头。"

#. type: Labeled list
#: en/git-grep.txt:210
#, ignore-same, no-wrap, priority:100
msgid "--show-function"
msgstr "--show-function"

#. type: Plain text
#: en/git-grep.txt:216
#, placeholders:'linkgit:gitattributes[5]', priority:100
msgid "Show the preceding line that contains the function name of the match, unless the matching line is a function name itself. The name is determined in the same way as `git diff` works out patch hunk headers (see 'Defining a custom hunk-header' in linkgit:gitattributes[5])."
msgstr "显示包含匹配的函数名的前一行，除非匹配的一行本身就是一个函数名。 该名称的确定方式与 `git diff` 编制补丁组头的方式相同（见 linkgit:gitattributes[5] 中的 ‘定义自定义组头’）。"

#. type: Labeled list
#: en/git-grep.txt:217
#, no-wrap, priority:100
msgid "-<num>"
msgstr "-<num>"

#. type: Labeled list
#: en/git-grep.txt:218
#, no-wrap, priority:100
msgid "-C <num>"
msgstr "-C <数量>"

#. type: Labeled list
#: en/git-grep.txt:219
#, no-wrap, placeholders:'--context', priority:100
msgid "--context <num>"
msgstr "--context <数量>"

#. type: Plain text
#: en/git-grep.txt:222
#, priority:100
msgid "Show <num> leading and trailing lines, and place a line containing `--` between contiguous groups of matches."
msgstr "显示 <num> 前导行和后导行，并在连续的匹配组之间放置一个包含`--`的行。"

#. type: Labeled list
#: en/git-grep.txt:223
#, no-wrap, priority:100
msgid "-A <num>"
msgstr "-A <num>"

#. type: Labeled list
#: en/git-grep.txt:224
#, no-wrap, placeholders:'--after-context', priority:100
msgid "--after-context <num>"
msgstr "--after-context <数量>"

#. type: Plain text
#: en/git-grep.txt:227
#, priority:100
msgid "Show <num> trailing lines, and place a line containing `--` between contiguous groups of matches."
msgstr "显示 <num> 尾行，并在连续的匹配组之间放置一个包含 `--` 的行。"

#. type: Labeled list
#: en/git-grep.txt:228
#, no-wrap, priority:100
msgid "-B <num>"
msgstr "-B <num>"

#. type: Labeled list
#: en/git-grep.txt:229
#, no-wrap, placeholders:'--before-context', priority:100
msgid "--before-context <num>"
msgstr "--before-context <数量>"

#. type: Plain text
#: en/git-grep.txt:232
#, priority:100
msgid "Show <num> leading lines, and place a line containing `--` between contiguous groups of matches."
msgstr "显示 <num> 引导行，并在连续的匹配组之间放置一个包含 `--` 的行。"

#. type: Plain text
#: en/git-grep.txt:241
#, placeholders:'linkgit:gitattributes[5]', priority:100
msgid "Show the surrounding text from the previous line containing a function name up to the one before the next function name, effectively showing the whole function in which the match was found. The function names are determined in the same way as `git diff` works out patch hunk headers (see 'Defining a custom hunk-header' in linkgit:gitattributes[5])."
msgstr "显示从包含函数名的前一行到下一个函数名之前的周围文本，有效地显示找到匹配的整个函数。函数名的确定方式与 `git diff` 确定补丁组头的方式相同（见 linkgit:gitattributes[5] 中的 ‘定义自定义组头’）。"

#. type: Labeled list
#: en/git-grep.txt:242
#, no-wrap, priority:100
msgid "-m <num>"
msgstr "-C <数量>"

#. type: Labeled list
#: en/git-grep.txt:243
#, no-wrap, placeholders:'--max-count', priority:100
msgid "--max-count <num>"
msgstr "--max-count <数量>"

#. type: Plain text
#: en/git-grep.txt:249
#, placeholders:'`-v`':'`--invert-match`', priority:100
msgid "Limit the amount of matches per file. When using the `-v` or `--invert-match` option, the search stops after the specified number of non-matches. A value of -1 will return unlimited results (the default). A value of 0 will exit immediately with a non-zero status."
msgstr "限制每个文件的匹配数量。当使用 `-v` 或 `--invert-match` 选项时，搜索会在指定的非匹配数量后停止。值为 -1 将返回无限的结果（默认）。值为 0 将立即退出，状态为非零。"

#. type: Labeled list
#: en/git-grep.txt:250
#, no-wrap, placeholders:'--threads', priority:100
msgid "--threads <num>"
msgstr "--threads <数量>"

#. type: Plain text
#: en/git-grep.txt:253
#, placeholders:'grep.threads', priority:100
msgid "Number of grep worker threads to use. See `grep.threads` in 'CONFIGURATION' for more information."
msgstr "要使用的 grep 工作线程的数量。 更多信息见 “配置” 中的 `grep.threads`。"

#. type: Labeled list
#: en/git-grep.txt:254
#, no-wrap, priority:100
msgid "-f <file>"
msgstr "-f <文件>"

#. type: Plain text
#: en/git-grep.txt:256
#, priority:100
msgid "Read patterns from <file>, one per line."
msgstr "从 <文件> 中读取模式，每行一个。"

#. type: Plain text
#: en/git-grep.txt:259
#, priority:100
msgid "Passing the pattern via <file> allows for providing a search pattern containing a \\0."
msgstr "通过<文件> 传递模式，可以提供一个包含一个 \\0 的搜索模式。"

#. type: Plain text
#: en/git-grep.txt:264
#, placeholders:'`--perl-regexp`', priority:100
msgid "Not all pattern types support patterns containing \\0. Git will error out if a given pattern type can't support such a pattern. The `--perl-regexp` pattern type when compiled against the PCRE v2 backend has the widest support for these types of patterns."
msgstr "不是所有的模式类型都支持包含 \\0 的模式。如果一个给定的模式类型不支持这样的模式，Git 会出错。`--perl-regexp` 模式类型在针对 PCRE v2 后端进行编译时，对这些类型的模式有最广泛的支持。"

#. type: Plain text
#: en/git-grep.txt:269
#, placeholders:'`--ignore-case`', priority:100
msgid "In versions of Git before 2.23.0 patterns containing \\0 would be silently considered fixed. This was never documented, there were also odd and undocumented interactions between e.g. non-ASCII patterns containing \\0 and `--ignore-case`."
msgstr "在 2.23.0 之前的 Git 版本中，含有 \\0 的模式会被默默地认为是固定的。这一点从未被记录下来，还有一些奇怪的、未被记录的互动，例如包含 \\0 的非 ASCII 模式和 `--ignore-case` 之间。"

#. type: Plain text
#: en/git-grep.txt:273
#, priority:100
msgid "In future versions we may learn to support patterns containing \\0 for more search backends, until then we'll die when the pattern type in question doesn't support them."
msgstr "在未来的版本中，我们可能会学会为更多的搜索后端支持含有 \\0 的模式，在此之前，当有关的模式类型不支持它们时，我们就会死心。"

#. type: Plain text
#: en/git-grep.txt:279
#, priority:100
msgid "The next parameter is the pattern. This option has to be used for patterns starting with `-` and should be used in scripts passing user input to grep. Multiple patterns are combined by 'or'."
msgstr "下一个参数是模式。这个选项必须用于以 `-` 开头的模式，并应在将用户输入传递给 grep 的脚本中使用。 多个模式用 'or' 组合。"

#. type: Labeled list
#: en/git-grep.txt:280
#, ignore-same, no-wrap, priority:100
msgid "--and"
msgstr "--and"

#. type: Labeled list
#: en/git-grep.txt:281
#, ignore-same, no-wrap, priority:100
msgid "--or"
msgstr "--or"

#. type: Labeled list
#: en/git-grep.txt:282 en/git-rev-parse.txt:139 en/rev-list-options.txt:151
#, ignore-same, no-wrap, priority:260
msgid "--not"
msgstr "--not"

#. type: Labeled list
#: en/git-grep.txt:283
#, ignore-ellipsis, no-wrap, priority:100
msgid "( ... )"
msgstr "( ... )"

#. type: Plain text
#: en/git-grep.txt:288
#, placeholders:'`--or`':'`--and`':'`--or`':'`-e`', priority:100
msgid "Specify how multiple patterns are combined using Boolean expressions. `--or` is the default operator. `--and` has higher precedence than `--or`. `-e` has to be used for all patterns."
msgstr "使用布尔表达式指定多个模式的组合方式。 `--or` 是默认的运算符。 `--and` 比 `--or` 有更高的优先权。 `-e` 必须用于所有模式。"

#. type: Labeled list
#: en/git-grep.txt:289 en/rev-list-options.txt:70
#, ignore-same, no-wrap, priority:260
msgid "--all-match"
msgstr "--all-match"

#. type: Plain text
#: en/git-grep.txt:293
#, placeholders:'`--or`', priority:100
msgid "When giving multiple pattern expressions combined with `--or`, this flag is specified to limit the match to files that have lines to match all of them."
msgstr "当给出多个模式表达式与 `--or` 组合时，指定这个标志是为了将匹配限制在有行的文件中，以匹配所有的文件。"

#. type: Plain text
#: en/git-grep.txt:298
#, priority:100
msgid "Do not output matched lines; instead, exit with status 0 when there is a match and with non-zero status when there isn't."
msgstr "不输出匹配的行；相反，当有匹配时以状态 0 退出，没有匹配时以非零状态退出。"

#. type: Labeled list
#: en/git-grep.txt:299
#, ignore-ellipsis, no-wrap, priority:100
msgid "<tree>..."
msgstr "<目录树>..."

#. type: Plain text
#: en/git-grep.txt:302
#, priority:100
msgid "Instead of searching tracked files in the working tree, search blobs in the given trees."
msgstr "与其在工作区中搜索被追踪的文件，不如在给定的目录树中搜索 blobs。"

#. type: Plain text
#: en/git-grep.txt:306
#, priority:100
msgid "Signals the end of options; the rest of the parameters are <pathspec> limiters."
msgstr "标志着选项的结束；其余的参数是 <路径规范> 限制器。"

#. type: Plain text
#: en/git-grep.txt:310
#, priority:100
msgid "If given, limit the search to paths matching at least one pattern. Both leading paths match and glob(7) patterns are supported."
msgstr "如果给定，将搜索限制在与至少一个模式匹配的路径上。 前导路径匹配和 glob(7) 模式都被支持。"

#. type: Labeled list
#: en/git-grep.txt:317
#, no-wrap, placeholders:'time_t', priority:100
msgid "`git grep 'time_t' -- '*.[ch]'`"
msgstr "`git grep 'time_t' -- '*.[ch]'`"

#. type: Plain text
#: en/git-grep.txt:320
#, placeholders:'time_t', priority:100
msgid "Looks for `time_t` in all tracked .c and .h files in the working directory and its subdirectories."
msgstr "在工作目录及其子目录中所有跟踪的 .c 和 .h 文件中寻找 `time_t`。"

#. type: Labeled list
#: en/git-grep.txt:321
#, no-wrap, placeholders:'--and':'MAX_PATH':'PATH_MAX', priority:100
msgid "`git grep -e '#define' --and \\( -e MAX_PATH -e PATH_MAX \\)`"
msgstr "`git grep -e '#define' --and \\( -e MAX_PATH -e PATH_MAX \\)`"

#. type: Plain text
#: en/git-grep.txt:324
#, placeholders:'MAX_PATH':'PATH_MAX', priority:100
msgid "Looks for a line that has `#define` and either `MAX_PATH` or `PATH_MAX`."
msgstr "寻找有 `#define` 和 `MAX_PATH` 或 `PATH_MAX` 的行。"

#. type: Labeled list
#: en/git-grep.txt:325
#, no-wrap, placeholders:'--all-match', priority:100
msgid "`git grep --all-match -e NODE -e Unexpected`"
msgstr "`git grep --all-match -e NODE -e Unexpected`"

#. type: Plain text
#: en/git-grep.txt:328
#, priority:100
msgid "Looks for a line that has `NODE` or `Unexpected` in files that have lines that match both."
msgstr "在文件中寻找有 `NODE` 或 `Unexpected` 字样的行，这些行与这两个字相匹配。"

#. type: Labeled list
#: en/git-grep.txt:329
#, no-wrap, priority:100
msgid "`git grep solution -- :^Documentation`"
msgstr "`git grep solution -- :^Documentation`"

#. type: Plain text
#: en/git-grep.txt:331
#, priority:100
msgid "Looks for `solution`, excluding files in `Documentation`."
msgstr "寻找 `solution`，排除 `Documentation`中的文件。"

#. type: Title -
#: en/git-grep.txt:333
#, no-wrap, priority:100
msgid "NOTES ON THREADS"
msgstr "线条的注释"

#. type: Plain text
#: en/git-grep.txt:337
#, placeholders:'`--threads`':'grep.threads':'`--open-files-in-pager`', priority:100
msgid "The `--threads` option (and the grep.threads configuration) will be ignored when `--open-files-in-pager` is used, forcing a single-threaded execution."
msgstr "当使用 `--open-files-in-pager` 时，`--threads` 选项（和 grep.threads 配置）将被忽略，强制单线程执行。"

#. type: Plain text
#: en/git-grep.txt:342
#, placeholders:'`--cached`':'`--textconv`':'`--threads=1`', priority:100
msgid "When grepping the object store (with `--cached` or giving tree objects), running with multiple threads might perform slower than single threaded if `--textconv` is given and there are too many text conversions. So if you experience low performance in this case, it might be desirable to use `--threads=1`."
msgstr "当检索对象存储时（使用 `--cached` 或给出树状对象），如果给出 `--textconv` 并且有太多的文本转换，多线程运行可能比单线程运行要慢。因此，如果你在这种情况下遇到低性能，使用 `--threads=1` 可能是可取的。"

#. type: Title =
#: en/git-gui.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-gui(1)"
msgstr "git-gui(1)"

#. type: Plain text
#: en/git-gui.txt:7
#, placeholders:'git-gui', priority:100
msgid "git-gui - A portable graphical interface to Git"
msgstr "git-gui - 一个可移植的git图形界面"

#. type: Plain text
#: en/git-gui.txt:12
#, no-wrap, priority:100
msgid "'git gui' [<command>] [<arguments>]\n"
msgstr "'git gui' [<命令>] [参数]\n"

#. type: Plain text
#: en/git-gui.txt:19
#, priority:100
msgid "A Tcl/Tk based graphical user interface to Git. 'git gui' focuses on allowing users to make changes to their repository by making new commits, amending existing ones, creating branches, performing local merges, and fetching/pushing to remote repositories."
msgstr "一个基于 Tcl/Tk 的 Git 图形化用户界面。 'git gui' 的重点是允许用户对他们的仓库进行修改，包括做出新的提交，修改现有的提交，创建分支，执行本地合并，以及获取/推送到远程仓库。"

#. type: Plain text
#: en/git-gui.txt:24
#, priority:100
msgid "Unlike 'gitk', 'git gui' focuses on commit generation and single file annotation and does not show project history. It does however supply menu actions to start a 'gitk' session from within 'git gui'."
msgstr "与 'gitk' 不同，'git gui' 专注于提交生成和单一文件注释，不显示项目历史。 不过它提供了菜单操作，可以从 'git gui' 中启动 'gitk' 会话。"

#. type: Plain text
#: en/git-gui.txt:29
#, priority:100
msgid "'git gui' is known to work on all popular UNIX systems, Mac OS X, and Windows (under both Cygwin and MSYS). To the extent possible OS specific user interface guidelines are followed, making 'git gui' a fairly native interface for users."
msgstr "众所周知，'git gui' 可以在所有流行的UNIX系统、Mac OS X 和 Windows（在 Cygwin 和 MSYS 下）运行。 在可能的范围内，遵循操作系统特定的用户界面准则，使 'git gui' 成为用户的一个相当原始的界面。"

#. type: Title -
#: en/git-gui.txt:31 en/git-p4.txt:63 en/git-remote.txt:44 en/git-rerere.txt:32 en/git-shell.txt:25 en/git-stash.txt:51 en/git-submodule.txt:33 en/git-svn.txt:29 en/git-worktree.txt:65
#, no-wrap, priority:240
msgid "COMMANDS"
msgstr "命令"

#. type: Labeled list
#: en/git-gui.txt:32
#, no-wrap, priority:100
msgid "blame"
msgstr "历史追溯"

#. type: Plain text
#: en/git-gui.txt:35
#, priority:100
msgid "Start a blame viewer on the specified file on the given version (or working directory if not specified)."
msgstr "在指定的版本（如果没有指定，则为工作目录）上对指定的文件启动一个历史追溯查看器。"

#. type: Labeled list
#: en/git-gui.txt:36
#, no-wrap, priority:100
msgid "browser"
msgstr "浏览器"

#. type: Plain text
#: en/git-gui.txt:40
#, priority:100
msgid "Start a tree browser showing all files in the specified commit. Files selected through the browser are opened in the blame viewer."
msgstr "启动一个树状浏览器，显示指定提交中的所有文件。 通过浏览器选择的文件会在历史追溯查看器中打开。"

#. type: Labeled list
#: en/git-gui.txt:41
#, no-wrap, priority:100
msgid "citool"
msgstr "citool"

#. type: Plain text
#: en/git-gui.txt:46
#, priority:100
msgid "Start 'git gui' and arrange to make exactly one commit before exiting and returning to the shell. The interface is limited to only commit actions, slightly reducing the application's startup time and simplifying the menubar."
msgstr "启动 'git gui' 并安排在退出并返回 shell 之前正好做一次提交。 该界面只限于提交操作，稍微减少了应用程序的启动时间，并简化了菜单栏。"

#. type: Labeled list
#: en/git-gui.txt:47
#, no-wrap, priority:100
msgid "version"
msgstr "版本"

#. type: Plain text
#: en/git-gui.txt:49
#, priority:100
msgid "Display the currently running version of 'git gui'."
msgstr "显示当前运行的 'git gui' 的版本。"

#. type: Title -
#: en/git-gui.txt:52 en/git-whatchanged.txt:29
#, no-wrap, priority:100
msgid "Examples"
msgstr "例如"

#. type: Labeled list
#: en/git-gui.txt:53
#, no-wrap, priority:100
msgid "`git gui blame Makefile`"
msgstr "`git gui blame Makefile`"

#. type: Plain text
#: en/git-gui.txt:61
#, priority:100
msgid "Show the contents of the file 'Makefile' in the current working directory, and provide annotations for both the original author of each line, and who moved the line to its current location. The uncommitted file is annotated, and uncommitted changes (if any) are explicitly attributed to 'Not Yet Committed'."
msgstr "显示当前工作目录中 'Makefile' 文件的内容，并为每一行的原作者和谁把这一行移到当前位置提供注释。 未提交的文件有注释，未提交的修改（如果有的话）被明确地归结为 ‘尚未提交’。"

#. type: Labeled list
#: en/git-gui.txt:62
#, no-wrap, priority:100
msgid "`git gui blame v0.99.8 Makefile`"
msgstr "`git gui blame v0.99.8 Makefile`"

#. type: Plain text
#: en/git-gui.txt:68
#, priority:100
msgid "Show the contents of 'Makefile' in revision 'v0.99.8' and provide annotations for each line. Unlike the above example the file is read from the object database and not the working directory."
msgstr "显示修订版 'v0.99.8' 中 'Makefile' 的内容，并为每一行提供注释。 与上面的例子不同，该文件是从对象数据库而不是工作目录中读取的。"

#. type: Labeled list
#: en/git-gui.txt:69
#, no-wrap, placeholders:'--line=100', priority:100
msgid "`git gui blame --line=100 Makefile`"
msgstr "`git gui blame --line=100 Makefile`"

#. type: Plain text
#: en/git-gui.txt:73
#, priority:100
msgid "Loads annotations as described above and automatically scrolls the view to center on line '100'."
msgstr "如上所述加载注释，并自动滚动视图至第 '100' 行中心。"

#. type: Labeled list
#: en/git-gui.txt:74
#, no-wrap, priority:100
msgid "`git gui citool`"
msgstr "`git gui citool`"

#. type: Plain text
#: en/git-gui.txt:79
#, priority:100
msgid "Make one commit and return to the shell when it is complete. This command returns a non-zero exit code if the window was closed in any way other than by making a commit."
msgstr "进行一次提交，完成后返回到 shell。 如果窗口被关闭，而不是通过提交的方式，该命令会返回一个非零的退出代码。"

#. type: Labeled list
#: en/git-gui.txt:80
#, no-wrap, placeholders:'--amend`', priority:100
msgid "`git gui citool --amend`"
msgstr "`git gui citool --amend`"

#. type: Plain text
#: en/git-gui.txt:84
#, priority:100
msgid "Automatically enter the 'Amend Last Commit' mode of the interface."
msgstr "自动进入界面的 ‘修正最后提交’ 模式。"

#. type: Labeled list
#: en/git-gui.txt:85
#, no-wrap, placeholders:'--nocommit`', priority:100
msgid "`git gui citool --nocommit`"
msgstr "`git gui citool --nocommit`"

#. type: Plain text
#: en/git-gui.txt:91
#, placeholders:'linkgit:git-mergetool[1]', priority:100
msgid "Behave as normal citool, but instead of making a commit simply terminate with a zero exit code. It still checks that the index does not contain any unmerged entries, so you can use it as a GUI version of linkgit:git-mergetool[1]"
msgstr "和普通的 citool 一样，但不做提交，而是以零退出代码结束。它仍然会检查索引是否包含任何未合并的条目，所以你可以把它当作 linkgit:git-mergetool[1] 的 GUI 版本"

#. type: Labeled list
#: en/git-gui.txt:92
#, no-wrap, priority:100
msgid "`git citool`"
msgstr "`git citool`"

#. type: Plain text
#: en/git-gui.txt:95
#, priority:100
msgid "Same as `git gui citool` (above)."
msgstr "与 `git gui citool`（上文）相同。"

#. type: Labeled list
#: en/git-gui.txt:96
#, no-wrap, priority:100
msgid "`git gui browser maint`"
msgstr "`git gui browser maint`"

#. type: Plain text
#: en/git-gui.txt:101
#, priority:100
msgid "Show a browser for the tree of the 'maint' branch. Files selected in the browser can be viewed with the internal blame viewer."
msgstr "显示 'maint' 分支的树的浏览器。 在浏览器中选择的文件可以用内部责备查看器查看。"

#. type: Plain text
#: en/git-gui.txt:108
#, priority:100
msgid "The Git repository browser. Shows branches, commit history and file differences. gitk is the utility started by 'git gui''s Repository Visualize actions."
msgstr "Git 仓库浏览器。 gitk 是由 'git gui' 的 Repository Visualize 操作启动的实用程序，显示分支、提交历史和文件差异。"

#. type: Title -
#: en/git-gui.txt:110
#, no-wrap, priority:100
msgid "Other"
msgstr "其它"

#. type: Plain text
#: en/git-gui.txt:114
#, priority:100
msgid "'git gui' is actually maintained as an independent project, but stable versions are distributed as part of the Git suite for the convenience of end users."
msgstr "'git gui' 实际上是作为一个独立项目进行维护的，但为了方便最终用户，其稳定版本作为 Git 套件的一部分发布。"

#. type: Plain text
#: en/git-gui.txt:116
#, priority:100
msgid "The official repository of the 'git gui' project can be found at:"
msgstr "'git gui' 项目的官方仓库可以在以下网址找到："

#. type: Plain text
#: en/git-gui.txt:118
#, no-wrap, placeholders:'github.com':'git-gui', priority:100
msgid "  https://github.com/prati0100/git-gui.git/\n"
msgstr "  https://github.com/prati0100/git-gui.git/\n"

#. type: Title =
#: en/git-hash-object.txt:2
#, ignore-same, no-wrap, priority:80
msgid "git-hash-object(1)"
msgstr "git-hash-object(1)"

#. type: Plain text
#: en/git-hash-object.txt:7
#, placeholders:'git-hash-object', priority:80
msgid "git-hash-object - Compute object ID and optionally create an object from a file"
msgstr "git-hash-object - 计算对象 ID 并选择性地从文件创建对象"

#. type: Plain text
#: en/git-hash-object.txt:15
#, ignore-ellipsis, no-wrap, placeholders:'git hash-object':'[--path=':'--no-filters]':'[--stdin':'[--literally]':'git hash-object':'--stdin-paths':'[--no-filters]', priority:80
msgid ""
"'git hash-object' [-t <type>] [-w] [--path=<file> | --no-filters]\n"
"\t\t[--stdin [--literally]] [--] <file>...\n"
"'git hash-object' [-t <type>] [-w] --stdin-paths [--no-filters]\n"
msgstr ""
"'git hash-object' [-t <类型>] [-w] [--path=<文件> | --no-filters]\n"
"\t\t[--stdin [--literally]] [--] <文件>...\n"
"'git hash-object' [-t <类型>] [-w] --stdin-paths [--no-filters]\n"

#. type: Plain text
#: en/git-hash-object.txt:23
#, priority:80
msgid "Computes the object ID value for an object with specified type with the contents of the named file (which can be outside of the work tree), and optionally writes the resulting object into the object database. Reports its object ID to its standard output. When <type> is not specified, it defaults to \"blob\"."
msgstr "使用指定文件（可以在工作区之外）的内容计算指定类型对象的对象 ID 值，并将计算结果写入对象数据库。 向标准输出报告对象 ID。 如果未指定 <类型>，则默认为 \"blob\"。"

#. type: Labeled list
#: en/git-hash-object.txt:27
#, no-wrap, priority:80
msgid "-t <type>"
msgstr "-t <类型>"

#. type: Plain text
#: en/git-hash-object.txt:30
#, priority:80
msgid "Specify the type of object to be created (default: \"blob\"). Possible values are `commit`, `tree`, `blob`, and `tag`."
msgstr "指定要创建的对象类型（默认：\"blob\"）。可能的值有：`commit` 、 `tree` 、 `blob` 和 `tag`。"

#. type: Plain text
#: en/git-hash-object.txt:33
#, priority:80
msgid "Actually write the object into the object database."
msgstr "将对象实际写入对象数据库。"

#. type: Plain text
#: en/git-hash-object.txt:36
#, priority:80
msgid "Read the object from standard input instead of from a file."
msgstr "从标准输入而不是文件中读取对象。"

#. type: Labeled list
#: en/git-hash-object.txt:37
#, ignore-same, no-wrap, priority:80
msgid "--stdin-paths"
msgstr "--stdin-paths"

#. type: Plain text
#: en/git-hash-object.txt:40
#, priority:80
msgid "Read file names from the standard input, one per line, instead of from the command-line."
msgstr "从标准输入端读取文件名，每行一个，而不是从命令行读取。"

#. type: Plain text
#: en/git-hash-object.txt:50
#, priority:80
msgid "Hash object as if it were located at the given path. The location of the file does not directly influence the hash value, but the path is used to determine which Git filters should be applied to the object before it can be placed in the object database. As a result of applying filters, the actual blob put into the object database may differ from the given file. This option is mainly useful for hashing temporary files located outside of the working directory or files read from stdin."
msgstr "散列对象，就像它位于给定的路径上一样。文件的位置并不直接影响哈希值，但路径用于确定在将对象放入对象数据库之前，应该对其应用哪些 Git 过滤器。 由于应用了过滤器，实际放入对象数据库的 blob 可能与给定文件不同。该选项主要用于对位于工作目录之外的临时文件或从标准输入流读取的文件进行散列。"

#. type: Labeled list
#: en/git-hash-object.txt:51
#, ignore-same, no-wrap, priority:80
msgid "--no-filters"
msgstr "--no-filters"

#. type: Plain text
#: en/git-hash-object.txt:56
#, placeholders:'`--path`', priority:80
msgid "Hash the contents as is, ignoring any input filter that would have been chosen by the attributes mechanism, including the end-of-line conversion. If the file is read from standard input then this is always implied, unless the `--path` option is given."
msgstr "按原样散列文件内容，忽略属性机制选择的任何输入过滤器，包括行尾转换。如果文件是从标准输入读取的，那么除非给出了 `--path` 选项，否则这总是隐含的。"

#. type: Labeled list
#: en/git-hash-object.txt:57
#, ignore-same, no-wrap, priority:80
msgid "--literally"
msgstr "--literally"

#. type: Plain text
#: en/git-hash-object.txt:62
#, placeholders:'`--stdin`':'git-fsck', priority:80
msgid "Allow `--stdin` to hash any garbage into a loose object which might not otherwise pass standard object parsing or git-fsck checks. Useful for stress-testing Git itself or reproducing characteristics of corrupt or bogus objects encountered in the wild."
msgstr "允许 `--stdin` 将任何垃圾散列到一个松散的对象中，否则该对象可能无法通过标准对象解析或 git-fsck 检查。这对于 Git 本身的压力测试或重现野外遇到的损坏或假对象的特征非常有用。"

#. type: Title =
#: en/git-help.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-help(1)"
msgstr "git-help(1)"

#. type: Plain text
#: en/git-help.txt:7
#, placeholders:'git-help', priority:100
msgid "git-help - Display help information about Git"
msgstr "git-help - 显示有关 Git 的帮助信息"

#. type: Plain text
#: en/git-help.txt:17
#, no-wrap, placeholders:'--all]':'[[-i|--info] [-m|--man] [-w|--web]]':'--guides]':'--config]':'[--user-interfaces]':'[--developer-interfaces]', priority:100
msgid ""
"'git help' [-a|--all] [--[no-]verbose] [--[no-]external-commands] [--[no-]aliases]\n"
"'git help' [[-i|--info] [-m|--man] [-w|--web]] [<command>|<doc>]\n"
"'git help' [-g|--guides]\n"
"'git help' [-c|--config]\n"
"'git help' [--user-interfaces]\n"
"'git help' [--developer-interfaces]\n"
msgstr ""
"'git help' [-a|--all] [--[no-]verbose] [--[no-]external-commands] [--[no-]aliases]\n"
"'git help' [[-i|--info] [-m|--man] [-w|--web]] [<命令>|<文档>]\n"
"'git help' [-g|--guides]\n"
"'git help' [-c|--config]\n"
"'git help' [--user-interfaces]\n"
"'git help' [--developer-interfaces]\n"

#. type: Plain text
#: en/git-help.txt:24
#, priority:100
msgid "With no options and no '<command>' or '<doc>' given, the synopsis of the 'git' command and a list of the most commonly used Git commands are printed on the standard output."
msgstr "如果没有选项，也没有给出 '<命令>' 或 '<文档>'，'git' 命令的概要和最常用的 Git 命令的列表会被打印在标准输出上。"

# ERROR: `-a` not found in translation
#. type: Plain text
#: en/git-help.txt:27
#, placeholders:'`--all`':'`-a`', priority:100
msgid "If the option `--all` or `-a` is given, all available commands are printed on the standard output."
msgstr "如果给出选项 `--all` 或 `-a`，所有可用的命令都会打印在标准输出上。"

# ERROR: `-g` not found in translation
#. type: Plain text
#: en/git-help.txt:30
#, placeholders:'`--guides`':'`-g`', priority:100
msgid "If the option `--guides` or `-g` is given, a list of the Git concept guides is also printed on the standard output."
msgstr "如果给了 `--guides` 或 `-g` 选项，Git 概念指南的列表也会打印在标准输出上。"

#. type: Plain text
#: en/git-help.txt:35
#, priority:100
msgid "If a command or other documentation is given, the relevant manual page will be brought up. The 'man' program is used by default for this purpose, but this can be overridden by other options or configuration variables."
msgstr "如果给出了一个命令或其他文件，相关的手册页就会被调出来。默认情况下使用 'man' 程序来实现这一目的，但这可以被其他选项或配置变量所覆盖。"

#. type: Plain text
#: en/git-help.txt:39
#, placeholders:'--help`', priority:100
msgid "If an alias is given, git shows the definition of the alias on standard output. To get the manual page for the aliased command, use `git <command> --help`."
msgstr "如果给了一个别名，git 会在标准输出上显示该别名的定义。要获得别名命令的手册页，请使用 `git <command> --help`。"

#. type: Plain text
#: en/git-help.txt:42
#, ignore-ellipsis, placeholders:'--help', priority:100
msgid "Note that `git --help ...` is identical to `git help ...` because the former is internally converted into the latter."
msgstr "请注意，`git --help ...` 与 `git help ...` 相同，因为前者在内部被转换为后者。"

#. type: Plain text
#: en/git-help.txt:44
#, placeholders:'linkgit:git[1]', priority:100
msgid "To display the linkgit:git[1] man page, use `git help git`."
msgstr "要显示 linkgit:git[1] 的帮助页，请使用 `git help git`。"

#. type: Plain text
#: en/git-help.txt:46
#, placeholders:'--help`', priority:100
msgid "This page can be displayed with 'git help help' or `git help --help`."
msgstr "这个页面可以用 'git help help' 或 `git help --help` 显示。"

#. type: Plain text
#: en/git-help.txt:52
#, priority:100
msgid "Print all the available commands on the standard output."
msgstr "在标准输出上打印所有可用的命令。"

#. type: Labeled list
#: en/git-help.txt:53
#, ignore-same, no-wrap, priority:100
msgid "--no-external-commands"
msgstr "--no-external-commands"

#. type: Plain text
#: en/git-help.txt:56
#, placeholders:'`--all`':'$PATH', priority:100
msgid "When used with `--all`, exclude the listing of external \"git-*\" commands found in the `$PATH`."
msgstr "当与 `--all` 一起使用时，排除在 `$PATH` 中发现的外部 \"git-*\" 命令的列表。"

#. type: Labeled list
#: en/git-help.txt:57
#, ignore-same, no-wrap, priority:100
msgid "--no-aliases"
msgstr "--no-aliases"

#. type: Plain text
#: en/git-help.txt:60
#, placeholders:'`--all`', priority:100
msgid "When used with `--all`, exclude the listing of configured aliases."
msgstr "当与 `--all` 一起使用时，不包括配置的别名列表。"

#. type: Plain text
#: en/git-help.txt:64
#, placeholders:'`--all`', priority:100
msgid "When used with `--all`, print description for all recognized commands. This is the default."
msgstr "当与 `--all` 一起使用时，打印所有识别的命令的描述。这是默认的。"

#. type: Labeled list
#: en/git-help.txt:66
#, ignore-same, no-wrap, priority:100
msgid "--config"
msgstr "--config"

#. type: Plain text
#: en/git-help.txt:69
#, placeholders:'linkgit:git-config[1]', priority:100
msgid "List all available configuration variables. This is a short summary of the list in linkgit:git-config[1]."
msgstr "列出所有可用的配置变量。这是对 linkgit:git-config[1] 中的列表的简短总结。"

#. type: Labeled list
#: en/git-help.txt:71
#, ignore-same, no-wrap, priority:100
msgid "--guides"
msgstr "--guides"

#. type: Plain text
#: en/git-help.txt:73
#, priority:100
msgid "Print a list of the Git concept guides on the standard output."
msgstr "在标准输出上打印 Git 概念指南的列表。"

#. type: Labeled list
#: en/git-help.txt:74
#, ignore-same, no-wrap, priority:100
msgid "--user-interfaces"
msgstr "--user-interfaces"

#. type: Plain text
#: en/git-help.txt:77
#, priority:100
msgid "Print a list of the repository, command and file interfaces documentation on the standard output."
msgstr "在标准输出上打印一个仓库、命令和文件接口文档的列表。"

#. type: Plain text
#: en/git-help.txt:81
#, placeholders:'.git/info/exclude':'linkgit:gitrepository-layout[5]':'linkgit:gitmailmap[5]', priority:100
msgid "In-repository file interfaces such as `.git/info/exclude` are documented here (see linkgit:gitrepository-layout[5]), as well as in-tree configuration such as `.mailmap` (see linkgit:gitmailmap[5])."
msgstr "仓库内的文件接口，如 `.git/info/exclude`，在这里有记录（见 linkgit:gitrepository-layout[5]），以及树内配置，如 `.mailmap`（见linkgit:gitmailmap[5]）。"

#. type: Plain text
#: en/git-help.txt:86
#, placeholders:'linkgit:gitcli[7]':'linkgit:githooks[5]', priority:100
msgid "This section of the documentation also covers general or widespread user-interface conventions (e.g. linkgit:gitcli[7]), and pseudo-configuration such as the file-based `.git/hooks/*` interface described in linkgit:githooks[5]."
msgstr "这一部分的文档还包括一般的或普遍的用户界面惯例（例如 linkgit:gitcli[7]），以及伪配置，例如 linkgit:githooks[5] 中描述的基于文件的 `.git/hooks/*` 界面。"

#. type: Labeled list
#: en/git-help.txt:87
#, ignore-same, no-wrap, priority:100
msgid "--developer-interfaces"
msgstr "--developer-interfaces"

#. type: Plain text
#: en/git-help.txt:90
#, priority:100
msgid "Print a list of file formats, protocols and other developer interfaces documentation on the standard output."
msgstr "在标准输出上打印文件格式、协议和其他开发者接口文件的清单。"

#. type: Labeled list
#: en/git-help.txt:92
#, ignore-same, no-wrap, priority:100
msgid "--info"
msgstr "--info"

#. type: Plain text
#: en/git-help.txt:95
#, priority:100
msgid "Display manual page for the command in the 'info' format. The 'info' program will be used for that purpose."
msgstr "以 'info' 格式显示该命令的手册页。'info' 程序将被用于该目的。"

#. type: Labeled list
#: en/git-help.txt:97
#, ignore-same, no-wrap, priority:100
msgid "--man"
msgstr "--man"

#. type: Plain text
#: en/git-help.txt:101
#, placeholders:'help.format', priority:100
msgid "Display manual page for the command in the 'man' format. This option may be used to override a value set in the `help.format` configuration variable."
msgstr "以 'man' 格式显示该命令的手册页。这个选项可以用来覆盖 `help.format` 配置变量中设置的值。"

#. type: Plain text
#: en/git-help.txt:105
#, placeholders:'man.viewer', priority:100
msgid "By default the 'man' program will be used to display the manual page, but the `man.viewer` configuration variable may be used to choose other display programs (see below)."
msgstr "默认情况下，将使用 'man' 程序来显示手册页面，但 `man.viewer` 配置变量可以用来选择其他显示程序（见下文）。"

#. type: Labeled list
#: en/git-help.txt:107
#, ignore-same, no-wrap, priority:100
msgid "--web"
msgstr "--web"

#. type: Plain text
#: en/git-help.txt:110
#, priority:100
msgid "Display manual page for the command in the 'web' (HTML) format. A web browser will be used for that purpose."
msgstr "以 ‘网页’（HTML）格式显示该命令的手册页面。为此将使用一个网络浏览器。"

#. type: Plain text
#: en/git-help.txt:116
#, placeholders:'help.browser':'web.browser':'{litdd}':'linkgit:git-web{litdd}browse[1]', priority:100
msgid "The web browser can be specified using the configuration variable `help.browser`, or `web.browser` if the former is not set. If neither of these config variables is set, the 'git web{litdd}browse' helper script (called by 'git help') will pick a suitable default. See linkgit:git-web{litdd}browse[1] for more information about this."
msgstr "网络浏览器可以用配置变量 `help.browser` 来指定，如果前者没有设置，则用 `web.browser`。如果这些配置变量都没有设置，'git web{litdd}browse' 辅助脚本（由 \"git help \"调用）会选择一个合适的默认值。参见 linkgit:git-web{litdd}browse[1] 获取更多相关信息。"

#. type: Title -
#: en/git-help.txt:118 en/git-interpret-trailers.txt:187 en/git-p4.txt:556 en/git-web--browse.txt:59
#, no-wrap, priority:100
msgid "CONFIGURATION VARIABLES"
msgstr "配置变量"

#. type: Title ~
#: en/git-help.txt:121
#, ignore-same, no-wrap, priority:100
msgid "help.format"
msgstr "help.format"

#. type: Plain text
#: en/git-help.txt:127
#, placeholders:'help.format', priority:100
msgid "If no command-line option is passed, the `help.format` configuration variable will be checked. The following values are supported for this variable; they make 'git help' behave as their corresponding command- line option:"
msgstr "如果没有传递命令行选项，将检查 `help.format` 配置变量。该变量支持以下值；它们使 'git help' 的行为与它们相应的命令行选项相同："

#. type: Plain text
#: en/git-help.txt:129
#, placeholders:'--man', priority:100
msgid "\"man\" corresponds to '-m|--man',"
msgstr "\"man\" 对应的是 '-m|--man'，"

#. type: Plain text
#: en/git-help.txt:130
#, placeholders:'--info', priority:100
msgid "\"info\" corresponds to '-i|--info',"
msgstr "\"info\" 对应的是 '-i|--info'，"

#. type: Plain text
#: en/git-help.txt:131
#, placeholders:'--web', priority:100
msgid "\"web\" or \"html\" correspond to '-w|--web'."
msgstr "\"web\" 或 \"html\" 对应于 '-w|--web'。"

#. type: Title ~
#: en/git-help.txt:133
#, no-wrap, placeholders:'help.browser':'web.browser', priority:100
msgid "help.browser, web.browser, and browser.<tool>.path"
msgstr "help.browser, web.browser 和 browser.<工具>.path"

#. type: Plain text
#: en/git-help.txt:139
#, placeholders:'help.browser':'web.browser':'--web':'linkgit:git-web{litdd}browse[1]', priority:100
msgid "The `help.browser`, `web.browser` and `browser.<tool>.path` will also be checked if the 'web' format is chosen (either by command-line option or configuration variable). See '-w|--web' in the OPTIONS section above and linkgit:git-web{litdd}browse[1]."
msgstr "如果选择了 'web' 格式（通过命令行选项或配置变量），`help.browser`、`web.browser` 和 `browser.<工具>.path` 也将被检查。见上面选项部分的 '-w|--web' 和 linkgit:git-web{litdd}browse[1]。"

#. type: Title ~
#: en/git-help.txt:141
#, no-wrap, placeholders:'man.viewer', priority:100
msgid "man.viewer"
msgstr "man.viewer"

#. type: Plain text
#: en/git-help.txt:145
#, placeholders:'man.viewer', priority:100
msgid "The `man.viewer` configuration variable will be checked if the 'man' format is chosen. The following values are currently supported:"
msgstr "如果选择 'man' 格式，`man.viewer` 配置变量将被检查。目前支持以下数值："

#. type: Plain text
#: en/git-help.txt:147
#, priority:100
msgid "\"man\": use the 'man' program as usual,"
msgstr "\"man\" : 像往常一样使用 'man' 程序、"

#. type: Plain text
#: en/git-help.txt:149
#, priority:100
msgid "\"woman\": use 'emacsclient' to launch the \"woman\" mode in emacs (this only works starting with emacsclient versions 22),"
msgstr "\"woman\": 使用 'emacsclient' 在 emacs 中启动 \"woman\" 模式（这只在 emacsclient 第 22 版开始工作），"

#. type: Plain text
#: en/git-help.txt:151
#, priority:100
msgid "\"konqueror\": use 'kfmclient' to open the man page in a new konqueror tab (see 'Note about konqueror' below)."
msgstr "\"konqueror\": 使用 'kfmclient' 在一个新的 konqueror 标签中打开手册页（见下文 ‘关于 konqueror 的说明’）。"

#. type: Plain text
#: en/git-help.txt:154
#, priority:100
msgid "Values for other tools can be used if there is a corresponding `man.<tool>.cmd` configuration entry (see below)."
msgstr "如果有相应的 `man.<工具>.cmd` 配置项，可以使用其他工具的值（见下文）。"

#. type: Plain text
#: en/git-help.txt:158
#, placeholders:'man.viewer', priority:100
msgid "Multiple values may be given to the `man.viewer` configuration variable. Their corresponding programs will be tried in the order listed in the configuration file."
msgstr "可以给 `man.viewer` 配置变量设置多个值。他们相应的程序将按照配置文件中列出的顺序进行尝试。"

#. type: Plain text
#: en/git-help.txt:160
#, priority:100
msgid "For example, this configuration:"
msgstr "例如，这种配置："

#. type: delimited block -
#: en/git-help.txt:165
#, no-wrap, priority:100
msgid ""
"\t[man]\n"
"\t\tviewer = konqueror\n"
"\t\tviewer = woman\n"
msgstr ""
"\t[man]\n"
"\t\tviewer = konqueror\n"
"\t\tviewer = woman\n"

#. type: Plain text
#: en/git-help.txt:169
#, priority:100
msgid "will try to use konqueror first. But this may fail (for example, if DISPLAY is not set) and in that case emacs' woman mode will be tried."
msgstr "将首先尝试使用 konqueror。但这可能会失败（例如，如果没有设置DISPLAY），在这种情况下，将尝试 Emacs 的 woman 模式。"

#. type: Plain text
#: en/git-help.txt:173
#, placeholders:'GIT_MAN_VIEWER', priority:100
msgid "If everything fails, or if no viewer is configured, the viewer specified in the `GIT_MAN_VIEWER` environment variable will be tried. If that fails too, the 'man' program will be tried anyway."
msgstr "如果一切都失败了，或者没有配置查看器，将尝试 `GIT_MAN_VIEWER` 环境变量中指定的查看器。 如果这也失败了，将尝试使用 'man' 程序。"

#. type: Title ~
#: en/git-help.txt:175
#, no-wrap, priority:100
msgid "man.<tool>.path"
msgstr "man.<工具>.path"

#. type: Plain text
#: en/git-help.txt:182
#, placeholders:'man.konqueror.path', priority:100
msgid "You can explicitly provide a full path to your preferred man viewer by setting the configuration variable `man.<tool>.path`. For example, you can configure the absolute path to konqueror by setting 'man.konqueror.path'. Otherwise, 'git help' assumes the tool is available in PATH."
msgstr "你可以通过设置配置变量 `man.<工具>.path` 来明确提供你喜欢的 man viewer 的完整路径。例如，你可以通过设置 'man.konqueror.path' 来配置 konqueror 的绝对路径。否则，'git help' 会假定该工具在 PATH中 是可用的。"

#. type: Title ~
#: en/git-help.txt:184
#, no-wrap, priority:100
msgid "man.<tool>.cmd"
msgstr "man.<工具>.cmd"

#. type: Plain text
#: en/git-help.txt:192
#, placeholders:'man.viewer', priority:100
msgid "When the man viewer, specified by the `man.viewer` configuration variables, is not among the supported ones, then the corresponding `man.<tool>.cmd` configuration variable will be looked up. If this variable exists then the specified tool will be treated as a custom command and a shell eval will be used to run the command with the man page passed as arguments."
msgstr "当由 `man.viewer` 配置变量指定的 man viewer 不在支持的范围内时，将查找相应的 `man.<工具>.cmd` 配置变量。如果这个变量存在，那么指定的工具将被视为一个自定义的命令，shell eval 将被用来运行命令，并将 man page 作为参数传递。"

#. type: Title ~
#: en/git-help.txt:194
#, no-wrap, priority:100
msgid "Note about konqueror"
msgstr "关于 konqueror 的说明"

#. type: Plain text
#: en/git-help.txt:199
#, placeholders:'man.viewer', priority:100
msgid "When 'konqueror' is specified in the `man.viewer` configuration variable, we launch 'kfmclient' to try to open the man page on an already opened konqueror in a new tab if possible."
msgstr "当 `man.viewer` 配置变量中指定为 'konqueror' 时，我们启动 'kfmclient'，以尝试在新标签页中打开已经打开的 konqueror 的 man 页面。"

#. type: Plain text
#: en/git-help.txt:203
#, placeholders:'man.konqueror.path', priority:100
msgid "For consistency, we also try such a trick if 'man.konqueror.path' is set to something like `A_PATH_TO/konqueror`. That means we will try to launch `A_PATH_TO/kfmclient` instead."
msgstr "为了保持一致性，如果 'man.konqueror.path' 被设置为 `A_PATH_TO/konqueror`，这意味着我们将尝试启动 `A_PATH_TO/kfmclient`，而不是尝试这样的技巧。"

#. type: Plain text
#: en/git-help.txt:206 en/git-web--browse.txt:100
#, priority:100
msgid "If you really want to use 'konqueror', then you can use something like the following:"
msgstr "如果你真的想使用 'konqueror'，那么你可以使用类似以下的东西："

#. type: delimited block -
#: en/git-help.txt:210
#, no-wrap, priority:100
msgid ""
"\t[man]\n"
"\t\tviewer = konq\n"
msgstr ""
"\t[man]\n"
"\t\tviewer = konq\n"

#. type: delimited block -
#: en/git-help.txt:213
#, no-wrap, priority:100
msgid ""
"\t[man \"konq\"]\n"
"\t\tcmd = A_PATH_TO/konqueror\n"
msgstr ""
"\t[man \"konq\"]\n"
"\t\tcmd = A_PATH_TO/konqueror\n"

#. type: Title ~
#: en/git-help.txt:216
#, no-wrap, placeholders:'--global', priority:100
msgid "Note about git config --global"
msgstr "关于 git config --global 的说明"

#. type: Plain text
#: en/git-help.txt:220
#, placeholders:'`--global`', priority:100
msgid "Note that all these configuration variables should probably be set using the `--global` flag, for example like this:"
msgstr "请注意，所有这些配置变量可能都应该使用 `--global` 标志来设置，比如说像这样："

#. type: delimited block -
#: en/git-help.txt:224
#, no-wrap, placeholders:'--global':'help.format':'--global':'web.browser', priority:100
msgid ""
"$ git config --global help.format web\n"
"$ git config --global web.browser firefox\n"
msgstr ""
"$ git config --global help.format web\n"
"$ git config --global web.browser firefox\n"

#. type: Plain text
#: en/git-help.txt:228 en/git-web--browse.txt:121
#, placeholders:'linkgit:git-config[1]', priority:100
msgid "as they are probably more user specific than repository specific. See linkgit:git-config[1] for more information about this."
msgstr "因为它们可能更多是针对用户而不是针对仓库。 更多相关信息见 linkgit:git-config[1]。"

#. type: Title =
#: en/git-http-backend.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-http-backend(1)"
msgstr "git-http-backend(1)"

#. type: Plain text
#: en/git-http-backend.txt:7
#, placeholders:'git-http-backend', priority:100
msgid "git-http-backend - Server side implementation of Git over HTTP"
msgstr "git-http-backend - Git 在 HTTP 上的服务器端实现"

#. type: Plain text
#: en/git-http-backend.txt:12
#, no-wrap, placeholders:'git http-backend', priority:100
msgid "'git http-backend'\n"
msgstr "'git http-backend'\n"

#. type: Plain text
#: en/git-http-backend.txt:22
#, placeholders:'GIT_PROTOCOL', priority:100
msgid "A simple CGI program to serve the contents of a Git repository to Git clients accessing the repository over http:// and https:// protocols. The program supports clients fetching using both the smart HTTP protocol and the backwards-compatible dumb HTTP protocol, as well as clients pushing using the smart HTTP protocol. It also supports Git's more-efficient \"v2\" protocol if properly configured; see the discussion of `GIT_PROTOCOL` in the ENVIRONMENT section below."
msgstr "一个简单的 CGI 程序，为通过 http:// 和 https:// 协议访问仓库的 Git 客户提供内容。 该程序支持客户端使用智能 HTTP 协议和向后兼容的哑 HTTP 协议获取内容，以及客户端使用智能 HTTP 协议推送内容。如果配置得当，它还支持 Git 更高效的 \"v2\" 协议；见下文环境部分关于`GIT_PROTOCOL` 的讨论。"

#. type: Plain text
#: en/git-http-backend.txt:27
#, placeholders:'git-daemon-export-ok':'GIT_HTTP_EXPORT_ALL', priority:100
msgid "It verifies that the directory has the magic file \"git-daemon-export-ok\", and it will refuse to export any Git directory that hasn't explicitly been marked for export this way (unless the `GIT_HTTP_EXPORT_ALL` environment variable is set)."
msgstr "它验证该目录是否有魔术文件 \"git-daemon-export-ok\"，它将拒绝导出任何没有明确标记为这种方式导出的 Git 目录（除非设置了 `GIT_HTTP_EXPORT_ALL` 环境变量）。"

#. type: Plain text
#: en/git-http-backend.txt:33
#, placeholders:'git fetch-pack':'git ls-remote':'git send-pack', priority:100
msgid "By default, only the `upload-pack` service is enabled, which serves 'git fetch-pack' and 'git ls-remote' clients, which are invoked from 'git fetch', 'git pull', and 'git clone'. If the client is authenticated, the `receive-pack` service is enabled, which serves 'git send-pack' clients, which is invoked from 'git push'."
msgstr "默认情况下，只有 `upload-pack` 服务被启用，它为 'git fetch-pack' 和 'git ls-remote' 客户端服务，这些客户端被 'git fetch'、'git pull' 和 'git clone' 调用。 如果客户端经过认证，`receive-pack` 服务将被启用，它为 'git send-pack' 客户端服务，该服务由 'git push' 调用。"

#. type: Plain text
#: en/git-http-backend.txt:38
#, priority:100
msgid "These services can be enabled/disabled using the per-repository configuration file:"
msgstr "这些服务可以使用每个库的配置文件来启用/禁用："

#. type: Labeled list
#: en/git-http-backend.txt:39
#, no-wrap, placeholders:'http.getanyfile', priority:100
msgid "http.getanyfile"
msgstr "http.getanyfile"

#. type: Plain text
#: en/git-http-backend.txt:46
#, priority:100
msgid "This serves Git clients older than version 1.6.6 that are unable to use the upload pack service. When enabled, clients are able to read any file within the repository, including objects that are no longer reachable from a branch but are still present. It is enabled by default, but a repository can disable it by setting this configuration value to `false`."
msgstr "这是为 1.6.6 版本以上的 Git 客户端提供服务，它们无法使用上传包服务。 启用后，客户端能够读取仓库内的任何文件，包括不再能从分支到达但仍然存在的对象。 默认情况下是启用的，但仓库可以通过将此配置项设置为 `false` 来禁用它。"

#. type: Labeled list
#: en/git-http-backend.txt:47
#, no-wrap, placeholders:'http.uploadpack', priority:100
msgid "http.uploadpack"
msgstr "http.uploadpack"

#. type: Plain text
#: en/git-http-backend.txt:51
#, placeholders:'git fetch-pack':'git ls-remote', priority:100
msgid "This serves 'git fetch-pack' and 'git ls-remote' clients. It is enabled by default, but a repository can disable it by setting this configuration value to `false`."
msgstr "这为 'git fetch-pack' 和 'git ls-remote' 客户端服务。 它在默认情况下是启用的，但仓库可以通过将此配置项设置为`false`来禁用它。"

#. type: Labeled list
#: en/git-http-backend.txt:52
#, no-wrap, placeholders:'http.receivepack', priority:100
msgid "http.receivepack"
msgstr "http.receivepack"

#. type: Plain text
#: en/git-http-backend.txt:58
#, placeholders:'git send-pack', priority:100
msgid "This serves 'git send-pack' clients, allowing push. It is disabled by default for anonymous users, and enabled by default for users authenticated by the web server. It can be disabled by setting this item to `false`, or enabled for all users, including anonymous users, by setting it to `true`."
msgstr "这为 'git send-pack' 客户提供服务，允许推送。 默认情况下，它对匿名用户是禁用的，而对通过网络服务器认证的用户是启用的。 可以通过设置该项为 `false` 来禁用它，或者通过设置为 `true` 来为所有用户（包括匿名用户）启用。"

#. type: Title -
#: en/git-http-backend.txt:60
#, no-wrap, priority:100
msgid "URL TRANSLATION"
msgstr "地址翻译"

#. type: Plain text
#: en/git-http-backend.txt:67
#, placeholders:'git http-backend':'PATH_INFO':'GIT_PROJECT_ROOT':'GIT_PROJECT_ROOT':'git http-backend':'PATH_TRANSLATED', priority:100
msgid "To determine the location of the repository on disk, 'git http-backend' concatenates the environment variables PATH_INFO, which is set automatically by the web server, and GIT_PROJECT_ROOT, which must be set manually in the web server configuration. If GIT_PROJECT_ROOT is not set, 'git http-backend' reads PATH_TRANSLATED, which is also set automatically by the web server."
msgstr "为了确定磁盘上仓库的位置，'git http-backend' 将环境变量 PATH_INFO 和 GIT_PROJECT_ROOT 连接起来，前者由 Web 服务器自动设置，后者则必须在 Web 服务器配置中手动设置。 如果 GIT_PROJECT_ROOT 没有设置，'git http-backend '会读取 PATH_TRANSLATED，这也是由网络服务器自动设置的。"

#. type: Plain text
#: en/git-http-backend.txt:72
#, placeholders:'$hostname':'bar.git':'bar.git', priority:100
msgid "All of the following examples map `http://$hostname/git/foo/bar.git` to `/var/www/git/foo/bar.git`."
msgstr "下面所有的例子都把 `http://$hostname/git/foo/bar.git` 映射到 `/var/www/git/foo/bar.git`。"

#. type: Labeled list
#: en/git-http-backend.txt:73
#, no-wrap, priority:100
msgid "Apache 2.x"
msgstr "Apache 2.x"

#. type: Plain text
#: en/git-http-backend.txt:77
#, placeholders:'mod_cgi':'mod_alias':'mod_env':'GIT_PROJECT_ROOT', priority:100
msgid "Ensure mod_cgi, mod_alias, and mod_env are enabled, set GIT_PROJECT_ROOT (or DocumentRoot) appropriately, and create a ScriptAlias to the CGI:"
msgstr "确保 mod_cgi、mod_alias 和 mod_env被 启用，适当地设置 GIT_PROJECT_ROOT（或 DocumentRoot），并为 CGI 创建一个 ScriptAlias："

#. type: delimited block -
#: en/git-http-backend.txt:82
#, no-wrap, placeholders:'GIT_PROJECT_ROOT':'GIT_HTTP_EXPORT_ALL':'git-core':'git-http-backend', priority:100
msgid ""
"SetEnv GIT_PROJECT_ROOT /var/www/git\n"
"SetEnv GIT_HTTP_EXPORT_ALL\n"
"ScriptAlias /git/ /usr/libexec/git-core/git-http-backend/\n"
msgstr ""
"SetEnv GIT_PROJECT_ROOT /var/www/git\n"
"SetEnv GIT_HTTP_EXPORT_ALL\n"
"ScriptAlias /git/ /usr/libexec/git-core/git-http-backend/\n"

#. type: delimited block -
#: en/git-http-backend.txt:94
#, no-wrap, placeholders:'git-http-backend':'HTTP_GIT_PROTOCOL':'GIT_PROTOCOL':'GIT_PROTOCOL':'HTTP_GIT_PROTOCOL':'GIT_PROTOCOL', priority:100
msgid ""
"# This is not strictly necessary using Apache and a modern version of\n"
"# git-http-backend, as the webserver will pass along the header in the\n"
"# environment as HTTP_GIT_PROTOCOL, and http-backend will copy that into\n"
"# GIT_PROTOCOL. But you may need this line (or something similar if you\n"
"# are using a different webserver), or if you want to support older Git\n"
"# versions that did not do that copying.\n"
"#\n"
"# Having the webserver set up GIT_PROTOCOL is perfectly fine even with\n"
"# modern versions (and will take precedence over HTTP_GIT_PROTOCOL,\n"
"# which means it can be used to override the client's request).\n"
"SetEnvIf Git-Protocol \".*\" GIT_PROTOCOL=$0\n"
msgstr ""
"# 这在使用 Apache 和现代版本的\n"
"# git-http-backend，因为网络服务器会把头信息在\n"
"# 环境中作为 HTTP_GIT_PROTOCOL 传递，而 http-backend 会将其复制到\n"
"# git_protocol。但你可能需要这一行（或类似的东西，如果你\n"
"# 使用不同的 webserver），或者如果你想支持旧的 Git\n"
"# 版本没有做这样的复制。\n"
"#\n"
"# 让 webserver 设置 GIT_PROTOCOL 是完全可以的，即使在\n"
"# 现代版本也是如此（并且优先于 HTTP_GIT_PROTOCOL，\n"
"# 这意味着它可以被用来覆盖客户端的请求）。\n"
"SetEnvIf Git-Protocol \".*\"GIT_PROTOCOL=$0\n"

#. type: Plain text
#: en/git-http-backend.txt:100
#, priority:100
msgid "To enable anonymous read access but authenticated write access, require authorization for both the initial ref advertisement (which we detect as a push via the service parameter in the query string), and the receive-pack invocation itself:"
msgstr "为了实现匿名的读取访问，但要有认证的写入访问，需要对最初的引用广播（我们通过查询字符串中的服务参数检测为推送）和接收包调用本身进行授权："

#. type: delimited block -
#: en/git-http-backend.txt:105
#, no-wrap, placeholders:'{QUERY_STRING}':'git-receive-pack':'{REQUEST_URI}':'git-receive-pack', priority:100
msgid ""
"RewriteCond %{QUERY_STRING} service=git-receive-pack [OR]\n"
"RewriteCond %{REQUEST_URI} /git-receive-pack$\n"
"RewriteRule ^/git/ - [E=AUTHREQUIRED:yes]\n"
msgstr ""
"RewriteCond %{QUERY_STRING} service=git-receive-pack [OR]\n"
"RewriteCond %{REQUEST_URI} /git-receive-pack$\n"
"RewriteRule ^/git/ - [E=AUTHREQUIRED:yes]\n"

#. type: delimited block -
#: en/git-http-backend.txt:109
#, no-wrap, priority:100
msgid ""
"<LocationMatch \"^/git/\">\n"
"\tOrder Deny,Allow\n"
"\tDeny from env=AUTHREQUIRED\n"
msgstr ""
"<LocationMatch \"^/git/\">\n"
"\tOrder Deny,Allow\n"
"\tDeny from env=AUTHREQUIRED\n"

#. type: delimited block -
#: en/git-http-backend.txt:116
#, ignore-ellipsis, no-wrap, priority:100
msgid ""
"\tAuthType Basic\n"
"\tAuthName \"Git Access\"\n"
"\tRequire group committers\n"
"\tSatisfy Any\n"
"\t...\n"
"</LocationMatch>\n"
msgstr ""
"\tAuthType Basic\n"
"\tAuthName \"Git Access\"\n"
"\tRequire group committers\n"
"\tSatisfy Any\n"
"\t...\n"
"</LocationMatch>\n"

#. type: Plain text
#: en/git-http-backend.txt:121
#, placeholders:'mod_rewrite':'git-receive-pack', priority:100
msgid "If you do not have `mod_rewrite` available to match against the query string, it is sufficient to just protect `git-receive-pack` itself, like:"
msgstr "如果你没有 `mod_rewrite` 可用来匹配查询字符串，只需保护 `git-receive-pack` 本身即可，比如："

#. type: delimited block -
#: en/git-http-backend.txt:129
#, ignore-ellipsis, no-wrap, placeholders:'git-receive-pack', priority:100
msgid ""
"<LocationMatch \"^/git/.*/git-receive-pack$\">\n"
"\tAuthType Basic\n"
"\tAuthName \"Git Access\"\n"
"\tRequire group committers\n"
"\t...\n"
"</LocationMatch>\n"
msgstr ""
"<LocationMatch \"^/git/.*/git-receive-pack$\">\n"
"\tAuthType Basic\n"
"\tAuthName \"Git Access\"\n"
"\tRequire group committers\n"
"\t...\n"
"</LocationMatch>\n"

#. type: Plain text
#: en/git-http-backend.txt:139
#, placeholders:'http.receivepack':'http.receivepack', priority:100
msgid "In this mode, the server will not request authentication until the client actually starts the object negotiation phase of the push, rather than during the initial contact. For this reason, you must also enable the `http.receivepack` config option in any repositories that should accept a push. The default behavior, if `http.receivepack` is not set, is to reject any pushes by unauthenticated users; the initial request will therefore report `403 Forbidden` to the client, without even giving an opportunity for authentication."
msgstr "在这种模式下，服务器将不会请求认证，直到客户端实际开始推送的对象协商阶段，而不是在最初的接触中。 由于这个原因，你必须在任何应该接受推送的存储库中启用 `http.receivepack` 配置选项。如果没有设置 `http.receivepack`，默认行为是拒绝任何未经认证的用户的推送；因此初始请求将向客户端报告 `403 Forbidden`，甚至不给认证机会。"

#. type: Plain text
#: en/git-http-backend.txt:142
#, priority:100
msgid "To require authentication for both reads and writes, use a Location directive around the repository, or one of its parent directories:"
msgstr "要对读和写都要求认证，可以在仓库或它的一个父目录周围使用 Location 指令："

#. type: delimited block -
#: en/git-http-backend.txt:150
#, ignore-ellipsis, no-wrap, priority:100
msgid ""
"<Location /git/private>\n"
"\tAuthType Basic\n"
"\tAuthName \"Private Git Access\"\n"
"\tRequire group committers\n"
"\t...\n"
"</Location>\n"
msgstr ""
"<Location /git/private>\n"
"\tAuthType Basic\n"
"\tAuthName \"Private Git Access\"\n"
"\tRequire group committers\n"
"\t...\n"
"</Location>\n"

#. type: Plain text
#: en/git-http-backend.txt:155
#, placeholders:'git http-backend', priority:100
msgid "To serve gitweb at the same url, use a ScriptAliasMatch to only those URLs that 'git http-backend' can handle, and forward the rest to gitweb:"
msgstr "要在同一个网址上为 gitweb 提供服务，使用 ScriptAliasMatch，只对那些 'git http-backend' 可以处理的网址进行匹配，其余的转发给 gitweb："

#. type: delimited block -
#: en/git-http-backend.txt:165
#, no-wrap, placeholders:'HEAD':'{2}':'{38}':'{40}':'git-core':'git-http-backend', priority:100
msgid ""
"ScriptAliasMatch \\\n"
"\t\"(?x)^/git/(.*/(HEAD | \\\n"
"\t\t\tinfo/refs | \\\n"
"\t\t\tobjects/(info/[^/]+ | \\\n"
"\t\t\t\t [0-9a-f]{2}/[0-9a-f]{38} | \\\n"
"\t\t\t\t pack/pack-[0-9a-f]{40}\\.(pack|idx)) | \\\n"
"\t\t\tgit-(upload|receive)-pack))$\" \\\n"
"\t/usr/libexec/git-core/git-http-backend/$1\n"
msgstr ""
"ScriptAliasMatch \\\n"
"\t\"(?x)^/git/(.*/(HEAD | \\\n"
"\t\t\tinfo/refs | \\\n"
"\t\t\tobjects/(info/[^/]+ | \\\n"
"\t\t\t\t [0-9a-f]{2}/[0-9a-f]{38} | \\\n"
"\t\t\t\t pack/pack-[0-9a-f]{40}\\.(pack|idx)) | \\\n"
"\t\t\tgit-(upload|receive)-pack))$\" \\\n"
"\t/usr/libexec/git-core/git-http-backend/$1\n"

#. type: delimited block -
#: en/git-http-backend.txt:167
#, no-wrap, placeholders:'gitweb.cgi', priority:100
msgid "ScriptAlias /git/ /var/www/cgi-bin/gitweb.cgi/\n"
msgstr "ScriptAlias /git/ /var/www/cgi-bin/gitweb.cgi/\n"

#. type: Plain text
#: en/git-http-backend.txt:171
#, placeholders:'linkgit:gitnamespaces[7]', priority:100
msgid "To serve multiple repositories from different linkgit:gitnamespaces[7] in a single repository:"
msgstr "在一个仓库中为来自不同 linkgit:gitnamespaces[7] 的多个仓库提供服务："

#. type: delimited block -
#: en/git-http-backend.txt:175
#, no-wrap, placeholders:'Request_URI':'GIT_NAMESPACE':'git-core':'git-http-backend':'storage.git', priority:100
msgid ""
"SetEnvIf Request_URI \"^/git/([^/]*)\" GIT_NAMESPACE=$1\n"
"ScriptAliasMatch ^/git/[^/]*(.*) /usr/libexec/git-core/git-http-backend/storage.git$1\n"
msgstr ""
"SetEnvIf Request_URI \"^/git/([^/]*)\" GIT_NAMESPACE=$1\n"
"ScriptAliasMatch ^/git/[^/]*(.*) /usr/libexec/git-core/git-http-backend/storage.git$1\n"

#. type: Labeled list
#: en/git-http-backend.txt:177
#, no-wrap, priority:100
msgid "Accelerated static Apache 2.x"
msgstr "加速静态 Apache 2.x"

#. type: Plain text
#: en/git-http-backend.txt:182
#, priority:100
msgid "Similar to the above, but Apache can be used to return static files that are stored on disk. On many systems this may be more efficient as Apache can ask the kernel to copy the file contents from the file system directly to the network:"
msgstr "与上述情况类似，但 Apache 可以用来返回存储在磁盘上的静态文件。 在许多系统上，这可能更有效率，因为 Apache 可以要求内核将文件内容从文件系统直接复制到网络上："

#. type: delimited block -
#: en/git-http-backend.txt:185 en/git-http-backend.txt:195
#, no-wrap, placeholders:'GIT_PROJECT_ROOT', priority:100
msgid "SetEnv GIT_PROJECT_ROOT /var/www/git\n"
msgstr "SetEnv GIT_PROJECT_ROOT /var/www/git\n"

#. type: delimited block -
#: en/git-http-backend.txt:189
#, no-wrap, placeholders:'{2}':'{38}':'{40}':'git-core':'git-http-backend', priority:100
msgid ""
"AliasMatch ^/git/(.*/objects/[0-9a-f]{2}/[0-9a-f]{38})$          /var/www/git/$1\n"
"AliasMatch ^/git/(.*/objects/pack/pack-[0-9a-f]{40}.(pack|idx))$ /var/www/git/$1\n"
"ScriptAlias /git/ /usr/libexec/git-core/git-http-backend/\n"
msgstr ""
"AliasMatch ^/git/(.*/objects/[0-9a-f]{2}/[0-9a-f]{38})$          /var/www/git/$1\n"
"AliasMatch ^/git/(.*/objects/pack/pack-[0-9a-f]{40}.(pack|idx))$ /var/www/git/$1\n"
"ScriptAlias /git/ /usr/libexec/git-core/git-http-backend/\n"

#. type: Plain text
#: en/git-http-backend.txt:192
#, priority:100
msgid "This can be combined with the gitweb configuration:"
msgstr "这可以与 gitweb 的配置相结合："

#. type: delimited block -
#: en/git-http-backend.txt:205
#, no-wrap, placeholders:'{2}':'{38}':'{40}':'HEAD':'git-core':'git-http-backend':'gitweb.cgi', priority:100
msgid ""
"AliasMatch ^/git/(.*/objects/[0-9a-f]{2}/[0-9a-f]{38})$          /var/www/git/$1\n"
"AliasMatch ^/git/(.*/objects/pack/pack-[0-9a-f]{40}.(pack|idx))$ /var/www/git/$1\n"
"ScriptAliasMatch \\\n"
"\t\"(?x)^/git/(.*/(HEAD | \\\n"
"\t\t\tinfo/refs | \\\n"
"\t\t\tobjects/info/[^/]+ | \\\n"
"\t\t\tgit-(upload|receive)-pack))$\" \\\n"
"\t/usr/libexec/git-core/git-http-backend/$1\n"
"ScriptAlias /git/ /var/www/cgi-bin/gitweb.cgi/\n"
msgstr ""
"AliasMatch ^/git/(.*/objects/[0-9a-f]{2}/[0-9a-f]{38})$          /var/www/git/$1\n"
"AliasMatch ^/git/(.*/objects/pack/pack-[0-9a-f]{40}.(pack|idx))$ /var/www/git/$1\n"
"ScriptAliasMatch \\\n"
"\t\"(?x)^/git/(.*/(HEAD | \\\n"
"\t\t\tinfo/refs | \\\n"
"\t\t\tobjects/info/[^/]+ | \\\n"
"\t\t\tgit-(upload|receive)-pack))$\" \\\n"
"\t/usr/libexec/git-core/git-http-backend/$1\n"
"ScriptAlias /git/ /var/www/cgi-bin/gitweb.cgi/\n"

#. type: Labeled list
#: en/git-http-backend.txt:207
#, no-wrap, priority:100
msgid "Lighttpd"
msgstr "Lighttpd"

#. type: Plain text
#: en/git-http-backend.txt:211
#, placeholders:'mod_cgi':'mod_alias':'mod_auth':'mod_setenv':'GIT_PROJECT_ROOT', priority:100
msgid "Ensure that `mod_cgi`, `mod_alias`, `mod_auth`, `mod_setenv` are loaded, then set `GIT_PROJECT_ROOT` appropriately and redirect all requests to the CGI:"
msgstr "确保 `mod_cgi`、`mod_alias`、`mod_auth`、`mod_setenv` 已经加载，然后适当设置 `GIT_PROJECT_ROOT`，并将所有请求重定向到 CGI："

#. type: delimited block -
#: en/git-http-backend.txt:221
#, no-wrap, placeholders:'alias.url':'git-core':'git-http-backend':'$HTTP':'cgi.assign':'setenv.add':'GIT_PROJECT_ROOT':'GIT_HTTP_EXPORT_ALL', priority:100
msgid ""
"alias.url += ( \"/git\" => \"/usr/lib/git-core/git-http-backend\" )\n"
"$HTTP[\"url\"] =~ \"^/git\" {\n"
"\tcgi.assign = (\"\" => \"\")\n"
"\tsetenv.add-environment = (\n"
"\t\t\"GIT_PROJECT_ROOT\" => \"/var/www/git\",\n"
"\t\t\"GIT_HTTP_EXPORT_ALL\" => \"\"\n"
"\t)\n"
"}\n"
msgstr ""
"alias.url += ( \"/git\" => \"/usr/lib/git-core/git-http-backend\" )\n"
"$HTTP[\"url\"] =~ \"^/git\" {\n"
"\tcgi.assign = (\"\" => \"\")\n"
"\tsetenv.add-environment = (\n"
"\t\t\"GIT_PROJECT_ROOT\" => \"/var/www/git\",\n"
"\t\t\"GIT_HTTP_EXPORT_ALL\" => \"\"\n"
"\t)\n"
"}\n"

#. type: Plain text
#: en/git-http-backend.txt:224
#, priority:100
msgid "To enable anonymous read access but authenticated write access:"
msgstr "要启用匿名的读取访问，但要有认证的写入访问："

#. type: delimited block -
#: en/git-http-backend.txt:232
#, no-wrap, placeholders:'$HTTP':'git-receive-pack':'git-auth':'$HTTP':'git-receive-pack':'git-auth', priority:100
msgid ""
"$HTTP[\"querystring\"] =~ \"service=git-receive-pack\" {\n"
"\tinclude \"git-auth.conf\"\n"
"}\n"
"$HTTP[\"url\"] =~ \"^/git/.*/git-receive-pack$\" {\n"
"\tinclude \"git-auth.conf\"\n"
"}\n"
msgstr ""
"$HTTP[\"querystring\"] =~ \"service=git-receive-pack\" {\n"
"\tinclude \"git-auth.conf\"\n"
"}\n"
"$HTTP[\"url\"] =~ \"^/git/.*/git-receive-pack$\" {\n"
"\tinclude \"git-auth.conf\"\n"
"}\n"

#. type: Plain text
#: en/git-http-backend.txt:235
#, placeholders:'git-auth', priority:100
msgid "where `git-auth.conf` looks something like:"
msgstr "其中 `git-auth.conf` 看起来像："

#. type: delimited block -
#: en/git-http-backend.txt:245
#, ignore-ellipsis, no-wrap, placeholders:'auth.require':'auth.backend', priority:100
msgid ""
"auth.require = (\n"
"\t\"/\" => (\n"
"\t\t\"method\" => \"basic\",\n"
"\t\t\"realm\" => \"Git Access\",\n"
"\t\t\"require\" => \"valid-user\"\n"
"\t       )\n"
")\n"
"# ...and set up auth.backend here\n"
msgstr ""
"auth.require = (\n"
"\t\"/\" => (\n"
"\t\t\"method\" => \"basic\",\n"
"\t\t\"realm\" => \"Git Access\",\n"
"\t\t\"require\" => \"valid-user\"\n"
"\t       )\n"
")\n"
"# ...并在此设置auth.backend\n"

#. type: Plain text
#: en/git-http-backend.txt:248
#, priority:100
msgid "To require authentication for both reads and writes:"
msgstr "要求对读和写都进行认证："

#. type: delimited block -
#: en/git-http-backend.txt:253
#, no-wrap, placeholders:'$HTTP':'git-auth', priority:100
msgid ""
"$HTTP[\"url\"] =~ \"^/git/private\" {\n"
"\tinclude \"git-auth.conf\"\n"
"}\n"
msgstr ""
"$HTTP[\"url\"] =~ \"^/git/private\" {\n"
"\tinclude \"git-auth.conf\"\n"
"}\n"

#. type: Plain text
#: en/git-http-backend.txt:260
#, placeholders:'git http-backend', priority:100
msgid "'git http-backend' relies upon the `CGI` environment variables set by the invoking web server, including:"
msgstr "'git http-backend' 依赖于调用网络服务器设置的 `CGI` 环境变量，包括："

#. type: Plain text
#: en/git-http-backend.txt:262
#, placeholders:'PATH_INFO':'GIT_PROJECT_ROOT':'PATH_TRANSLATED', priority:100
msgid "PATH_INFO (if GIT_PROJECT_ROOT is set, otherwise PATH_TRANSLATED)"
msgstr "PATH_INFO（如果设置了 GIT_PROJECT_ROOT，否则为 PATH_TRANSLATED）"

#. type: Plain text
#: en/git-http-backend.txt:263
#, placeholders:'REMOTE_USER', priority:100
msgid "REMOTE_USER"
msgstr "REMOTE_USER"

#. type: Plain text
#: en/git-http-backend.txt:264
#, placeholders:'REMOTE_ADDR', priority:100
msgid "REMOTE_ADDR"
msgstr "REMOTE_ADDR"

# ERROR: CONTENT_TYPE not found in translation
#. type: Plain text
#: en/git-http-backend.txt:265
#, placeholders:'CONTENT_TYPE', priority:100
msgid "CONTENT_TYPE"
msgstr "CONTENT_TYPE"

#. type: Plain text
#: en/git-http-backend.txt:266
#, placeholders:'QUERY_STRING', priority:100
msgid "QUERY_STRING"
msgstr "QUERY_STRING"

#. type: Plain text
#: en/git-http-backend.txt:267
#, placeholders:'REQUEST_METHOD', priority:100
msgid "REQUEST_METHOD"
msgstr "REQUEST_METHOD"

#. type: Plain text
#: en/git-http-backend.txt:271
#, placeholders:'GIT_HTTP_EXPORT_ALL':'git-http-backend':'git-daemon-export-ok', priority:100
msgid "The `GIT_HTTP_EXPORT_ALL` environment variable may be passed to 'git-http-backend' to bypass the check for the \"git-daemon-export-ok\" file in each repository before allowing export of that repository."
msgstr "`GIT_HTTP_EXPORT_ALL` 环境变量可以传递给 'git-http-backend'，以绕过在允许导出每个仓库前对 \"git-daemon-export-ok\" 文件的检查。"

#. type: Plain text
#: en/git-http-backend.txt:280
#, placeholders:'GIT_HTTP_MAX_REQUEST_BUFFER':'http.maxRequestBuffer', priority:100
msgid "The `GIT_HTTP_MAX_REQUEST_BUFFER` environment variable (or the `http.maxRequestBuffer` config option) may be set to change the largest ref negotiation request that git will handle during a fetch; any fetch requiring a larger buffer will not succeed. This value should not normally need to be changed, but may be helpful if you are fetching from a repository with an extremely large number of refs. The value can be specified with a unit (e.g., `100M` for 100 megabytes). The default is 10 megabytes."
msgstr "`GIT_HTTP_MAX_REQUEST_BUFFER` 环境变量（或 `http.maxRequestBuffer` 配置变量）可以被设置为改变 git 在获取过程中所处理的最大引用协商请求；任何需要更大缓冲区的获取将不会成功。 这个值通常不需要改变，但如果你从一个有大量引用的仓库中获取，可能会有帮助。 这个值可以指定一个单位（例如，`100M` 表示 100 兆字节）。默认是 10 兆字节。"

#. type: Plain text
#: en/git-http-backend.txt:290
#, placeholders:'GIT_PROTOCOL':'HTTP_GIT_PROTOCOL':'git-http-backend':'GIT_PROTOCOL', priority:100
msgid "Clients may probe for optional protocol capabilities (like the v2 protocol) using the `Git-Protocol` HTTP header. In order to support these, the contents of that header must appear in the `GIT_PROTOCOL` environment variable. Most webservers will pass this header to the CGI via the `HTTP_GIT_PROTOCOL` variable, and `git-http-backend` will automatically copy that to `GIT_PROTOCOL`. However, some webservers may be more selective about which headers they'll pass, in which case they need to be configured explicitly (see the mention of `Git-Protocol` in the Apache config from the earlier EXAMPLES section)."
msgstr "客户端可以使用 `Git-Protocol` HTTP 头来探测可选的协议能力（如 v2 协议）。为了支持这些，该标头的内容必须出现在 `GIT_PROTOCOL` 环境变量中。大多数网络服务器将通过 `HTTP_GIT_PROTOCOL` 变量把这个头传递给 CGI，`git-http-backend` 将自动把它复制到 `GIT_PROTOCOL`。然而，一些网络服务器可能对他们要传递的头信息更有选择性，在这种情况下，他们需要明确配置（见前面例子部分的 Apache 配置中对 `Git-Protocol` 的提及）。"

#. type: Plain text
#: en/git-http-backend.txt:295
#, placeholders:'GIT_COMMITTER_NAME':'$REMOTE_USER':'GIT_COMMITTER_EMAIL':'{REMOTE_USER}':'REMOTE_ADDR':'git-receive-pack', priority:100
msgid "The backend process sets GIT_COMMITTER_NAME to '$REMOTE_USER' and GIT_COMMITTER_EMAIL to '$\\{REMOTE_USER}@http.$\\{REMOTE_ADDR\\}', ensuring that any reflogs created by 'git-receive-pack' contain some identifying information of the remote user who performed the push."
msgstr "后台进程将 GIT_COMMITTER_NAME 设置为 '$REMOTE_USER'，将 GIT_COMMITTER_EMAIL 设置为 '$\\{REMOTE_USER}\\@http.${REMOTE_ADDR\\}'，确保任何由 'git-receive-pack' 创建的引用日志包含执行推送的远程用户的一些识别信息。"

#. type: Plain text
#: en/git-http-backend.txt:298
#, placeholders:'git-receive-pack', priority:100
msgid "All `CGI` environment variables are available to each of the hooks invoked by the 'git-receive-pack'."
msgstr "所有 `CGI` 环境变量对 'git-receive-pack' 调用的每个钩子都是可用的。"

#. type: Title =
#: en/git-http-fetch.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-http-fetch(1)"
msgstr "git-http-fetch(1)"

#. type: Plain text
#: en/git-http-fetch.txt:7
#, placeholders:'git-http-fetch', priority:100
msgid "git-http-fetch - Download from a remote Git repository via HTTP"
msgstr "git-http-fetch - 通过 HTTP 从远程 Git 仓库下载"

#. type: Plain text
#: en/git-http-fetch.txt:13
#, no-wrap, placeholders:'git http-fetch':'[--recover]':'[--stdin':'--packfile=', priority:100
msgid "'git http-fetch' [-c] [-t] [-a] [-d] [-v] [-w <filename>] [--recover] [--stdin | --packfile=<hash> | <commit>] <URL>\n"
msgstr "'git http-fetch' [-c] [-t] [-a] [-d] [-v] [-w filename] [--recover] [--stdin | --packfile=<哈希值> | <提交>] <网址>\n"

#. type: Plain text
#: en/git-http-fetch.txt:17
#, priority:100
msgid "Downloads a remote Git repository via HTTP."
msgstr "通过HTTP下载远程Git存储库。"

#. type: Plain text
#: en/git-http-fetch.txt:21
#, placeholders:'`-a`':'`-c`':'`-t`', priority:100
msgid "This command always gets all objects. Historically, there were three options `-a`, `-c` and `-t` for choosing which objects to download. They are now silently ignored."
msgstr "这个命令总是获取所有的对象。在过去，有三个选项 `-a`、`-c` 和 `-t`用于选择下载哪些对象。现在它们被默默地忽略了。"

#. type: Labeled list
#: en/git-http-fetch.txt:24
#, no-wrap, priority:100
msgid "commit-id"
msgstr "commit-id"

#. type: Plain text
#: en/git-http-fetch.txt:27
#, priority:100
msgid "Either the hash or the filename under [URL]/refs/ to pull."
msgstr "在 [URL]/refs/ 下的哈希值或文件名来拉取。"

#. type: Labeled list
#: en/git-http-fetch.txt:28
#, no-wrap, priority:100
msgid "-a, -c, -t"
msgstr "-a, -c, -t"

#. type: Plain text
#: en/git-http-fetch.txt:30
#, priority:100
msgid "These options are ignored for historical reasons."
msgstr "由于历史原因，这些选项被忽略了。"

#. type: Plain text
#: en/git-http-fetch.txt:32
#, priority:100
msgid "Report what is downloaded."
msgstr "报告所下载的内容。"

#. type: Labeled list
#: en/git-http-fetch.txt:33
#, no-wrap, priority:100
msgid "-w <filename>"
msgstr "-w <文件名>"

#. type: Plain text
#: en/git-http-fetch.txt:36
#, placeholders:'$GIT_DIR', priority:100
msgid "Writes the commit-id into the specified filename under $GIT_DIR/refs/<filename> on the local end after the transfer is complete."
msgstr "转移完成后，在本地端将提交 ID 写入 $GIT_DIR/refs/<文件名>下的文件名。"

#. type: Plain text
#: en/git-http-fetch.txt:40
#, placeholders:'git http-fetch', priority:100
msgid "Instead of a commit id on the command line (which is not expected in this case), 'git http-fetch' expects lines on stdin in the format"
msgstr "'git http-fetch' 希望在标准输入流上看到格式为以下的行，而不是命令行上的提交 ID（在这种情况下不需要提交 ID）"

#. type: Plain text
#: en/git-http-fetch.txt:42
#, no-wrap, priority:100
msgid "<commit-id>['\\t'<filename-as-in--w>]\n"
msgstr "<commit-id>['\\t'<filename-as-in--w>]\n"

#. type: Labeled list
#: en/git-http-fetch.txt:43
#, no-wrap, placeholders:'--packfile=', priority:100
msgid "--packfile=<hash>"
msgstr "--packfile=<哈希值>"

# ERROR: --index-pack-args not found in translation
#. type: Plain text
#: en/git-http-fetch.txt:51
#, placeholders:'git http-fetch':'--index-pack-args', priority:100
msgid "For internal use only. Instead of a commit id on the command line (which is not expected in this case), 'git http-fetch' fetches the packfile directly at the given URL and uses index-pack to generate corresponding .idx and .keep files. The hash is used to determine the name of the temporary file and is arbitrary. The output of index-pack is printed to stdout. Requires --index-pack-args."
msgstr "仅供内部使用。'git http-fetch' 不会在命令行上显示提交 ID（在这种情况下不需要），而是直接从给定的 URL 获取包文件，并使用 index-pack 生成相应的 .idx 和 .keep 文件。 哈希值用于确定临时文件的名称，是任意的。index-pack 的输出会打印到标准输出。需要 --index-pack-args 选项。"

#. type: Labeled list
#: en/git-http-fetch.txt:52
#, no-wrap, placeholders:'--index-pack-args=', priority:100
msgid "--index-pack-args=<args>"
msgstr "--index-pack-args=<参数>"

#. type: Plain text
#: en/git-http-fetch.txt:55
#, priority:100
msgid "For internal use only. The command to run on the contents of the downloaded pack. Arguments are URL-encoded separated by spaces."
msgstr "仅供内部使用。对下载的包的内容运行的命令。参数为 URL 编码，以空格分隔。"

#. type: Labeled list
#: en/git-http-fetch.txt:56
#, ignore-same, no-wrap, priority:100
msgid "--recover"
msgstr "--recover"

#. type: Plain text
#: en/git-http-fetch.txt:59
#, priority:100
msgid "Verify that everything reachable from target is fetched. Used after an earlier fetch is interrupted."
msgstr "验证所有可以从目标地可达的东西都被取走了。 在一个较早的获取被中断后使用。"

#. type: Title =
#: en/git-http-push.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-http-push(1)"
msgstr "git-http-push(1)"

#. type: Plain text
#: en/git-http-push.txt:7
#, placeholders:'git-http-push', priority:100
msgid "git-http-push - Push objects over HTTP/DAV to another repository"
msgstr "git-http-push - 通过http/DAV将对象推送到另一个存储库"

#. type: Plain text
#: en/git-http-push.txt:13
#, ignore-ellipsis, no-wrap, placeholders:'git http-push':'[--all]':'[--dry-run]':'[--force]':'[--verbose]', priority:100
msgid "'git http-push' [--all] [--dry-run] [--force] [--verbose] <URL> <ref> [<ref>...]\n"
msgstr "'git http-push' [--all] [--dry-run] [--force] [--verbose] <网址> <引用> [<引用>...]\n"

#. type: Plain text
#: en/git-http-push.txt:18
#, priority:100
msgid "Sends missing objects to the remote repository, and updates the remote branch."
msgstr "向远程仓库发送缺失对象，并更新远程分支。"

#. type: Plain text
#: en/git-http-push.txt:22
#, priority:100
msgid "*NOTE*: This command is temporarily disabled if your libcurl is older than 7.16, as the combination has been reported not to work and sometimes corrupts the repository."
msgstr "*注意*： 如果你的 libcurl 的版本超过 7.16，这个命令会暂时失效。早于 7.16，这个命令会被暂时禁用，因为有报告说这个组合不起作用，并且有时会破坏仓库。"

#. type: Plain text
#: en/git-http-push.txt:29
#, priority:100
msgid "Do not assume that the remote repository is complete in its current state, and verify all objects in the entire local ref's history exist in the remote repository."
msgstr "不要假设远程仓库的当前状态是完整的，要验证整个本地引用的历史中的所有对象是否存在于远程仓库。"

#. type: Plain text
#: en/git-http-push.txt:36
#, priority:100
msgid "Usually, the command refuses to update a remote ref that is not an ancestor of the local ref used to overwrite it. This flag disables the check. What this means is that the remote repository can lose commits; use it with care."
msgstr "通常情况下，命令拒绝更新一个不是用来覆盖它的本地引用的祖先远程引用。 这个标志可以禁止这种检查。 这意味着远程仓库可能会丢失提交，使用时要小心。"

#. type: Plain text
#: en/git-http-push.txt:39 en/git-push.txt:176 en/git-send-pack.txt:54
#, priority:220
msgid "Do everything except actually send the updates."
msgstr "做除了实际发送更新外的所有事。"

#. type: Plain text
#: en/git-http-push.txt:43
#, priority:100
msgid "Report the list of objects being walked locally and the list of objects successfully sent to the remote repository."
msgstr "报告正在本地行走的对象的列表和成功发送到远程仓库的对象的列表。"

#. type: Plain text
#: en/git-http-push.txt:49
#, placeholders:'HEAD', priority:100
msgid "Remove <ref> from remote repository. The specified branch cannot be the remote HEAD. If -d is specified, the following other conditions must also be met:"
msgstr "从远程仓库中删除 <引用>。 指定的分支不能是远程的 HEAD。 如果指定了 -d，还必须满足以下其他条件："

#. type: Plain text
#: en/git-http-push.txt:51
#, placeholders:'HEAD', priority:100
msgid "Remote HEAD must resolve to an object that exists locally"
msgstr "远程 HEAD 必须解析到一个本地存在的对象"

#. type: Plain text
#: en/git-http-push.txt:52
#, priority:100
msgid "Specified branch resolves to an object that exists locally"
msgstr "指定的分支解析到一个本地存在的对象"

#. type: Plain text
#: en/git-http-push.txt:53
#, placeholders:'HEAD', priority:100
msgid "Specified branch is an ancestor of the remote HEAD"
msgstr "指定的分支是远程 HEAD 的一个祖先"

#. type: Labeled list
#: en/git-http-push.txt:54 en/git-send-pack.txt:99
#, ignore-ellipsis, no-wrap, priority:100
msgid "<ref>..."
msgstr "<引用>..."

#. type: Plain text
#: en/git-http-push.txt:56 en/git-send-pack.txt:101
#, priority:100
msgid "The remote refs to update."
msgstr "要更新的远程引用。"

#. type: Title -
#: en/git-http-push.txt:59 en/git-send-pack.txt:104
#, no-wrap, priority:100
msgid "SPECIFYING THE REFS"
msgstr "指定引用"

#. type: Plain text
#: en/git-http-push.txt:65
#, priority:100
msgid "A '<ref>' specification can be either a single pattern, or a pair of such patterns separated by a colon \":\" (this means that a ref name cannot have a colon in it). A single pattern '<name>' is just a shorthand for '<name>:<name>'."
msgstr "一个 '<引用>' 规范既可以是一个单一的模式，也可以是一对由冒号 \":\" 隔开的模式（这意味着一个引用名称中不能有冒号）。 一个单一的模式 '<名称>' 只是 '<名称>:<名称>' 的一个缩写。"

#. type: Plain text
#: en/git-http-push.txt:70
#, priority:100
msgid "Each pattern pair '<src>:<dst>' consists of the source side (before the colon) and the destination side (after the colon). The ref to be pushed is determined by finding a match that matches the source side, and where it is pushed is determined by using the destination side."
msgstr "每个模式对 '<src>:<dst>' 由源端（冒号之前）和目标端（冒号之后）组成。 要推送的引用是通过找到与源端相匹配的匹配物来确定的，而推送的位置是通过目的地端来确定的。"

#. type: Plain text
#: en/git-http-push.txt:73
#, priority:100
msgid "It is an error if '<src>' does not match exactly one of the local refs."
msgstr "如果 '<src>' 与本地引用中的一个不完全匹配，则是一个错误。"

#. type: Plain text
#: en/git-http-push.txt:75
#, priority:100
msgid "If '<dst>' does not match any remote ref, either"
msgstr "如果 '<dst>' 不匹配任何远程引用，或者"

#. type: Plain text
#: en/git-http-push.txt:78 en/git-send-pack.txt:139
#, priority:100
msgid "it has to start with \"refs/\"; <dst> is used as the destination literally in this case."
msgstr "它必须以 \"refs/\" 开头；在这种情况下，<dst> 被用作目标字面。"

#. type: Plain text
#: en/git-http-push.txt:82 en/git-send-pack.txt:143
#, priority:100
msgid "<src> == <dst> and the ref that matched the <src> must not exist in the set of remote refs; the ref matched <src> locally is used as the name of the destination."
msgstr "<src> == <dst>，并且与 <src> 相匹配的引用必须不存在于远程引用集合中；本地匹配的 <src>引用被用作目的地的名称。"

#. type: Plain text
#: en/git-http-push.txt:88
#, placeholders:'`--force`', priority:100
msgid "Without `--force`, the <src> ref is stored at the remote only if <dst> does not exist, or <dst> is a proper subset (i.e. an ancestor) of <src>. This check, known as \"fast-forward check\", is performed to avoid accidentally overwriting the remote ref and losing other peoples' commits from there."
msgstr "如果不使用 `--force` 选项，只有当 <目标i> 不存在，或者 <目标> 是 <源> 的适当子集（即祖先）时，<源> 引用才会被存储到远程引用中。 这种检查被称为 “快进检查”（fast-forward check），执行这种检查是为了避免意外覆盖远程引用并丢失其他人从那里提交的内容。"

#. type: Plain text
#: en/git-http-push.txt:90 en/git-send-pack.txt:151
#, placeholders:'`--force`', priority:100
msgid "With `--force`, the fast-forward check is disabled for all refs."
msgstr "使用 `--force`，所有裁判的快进检查都被禁用。"

#. type: Plain text
#: en/git-http-push.txt:93 en/git-send-pack.txt:154
#, priority:100
msgid "Optionally, a <ref> parameter can be prefixed with a plus '+' sign to disable the fast-forward check only on that ref."
msgstr "可以选择在 <ref> 参数前加上一个加号 '+' 号，以便仅在该引用上禁用快进检查。"

#. type: Title =
#: en/git-imap-send.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-imap-send(1)"
msgstr "git-imap-send(1)"

#. type: Plain text
#: en/git-imap-send.txt:7
#, placeholders:'git-imap-send', priority:100
msgid "git-imap-send - Send a collection of patches from stdin to an IMAP folder"
msgstr "git-imap-send - 从标准输入流中向 IMAP 文件夹发送补丁集"

#. type: Plain text
#: en/git-imap-send.txt:13
#, no-wrap, placeholders:'git imap-send', priority:100
msgid "'git imap-send' [-v] [-q] [--[no-]curl]\n"
msgstr "'git imap-send' [-v] [-q] [--[no-]curl]\n"

#. type: Plain text
#: en/git-imap-send.txt:23
#, placeholders:'git format-patch', priority:100
msgid "This command uploads a mailbox generated with 'git format-patch' into an IMAP drafts folder. This allows patches to be sent as other email is when using mail clients that cannot read mailbox files directly. The command also works with any general mailbox in which emails have the fields \"From\", \"Date\", and \"Subject\" in that order."
msgstr "这条命令将用 'git format-patch' 生成的邮箱上传到 IMAP 的 drafts 文件夹。 这允许在使用不能直接读取邮箱文件的邮件客户端时，将补丁作为其他邮件发送。该命令也适用于任何一般的邮箱，其中的邮件按顺序有 \"Form\"、\"Date\" 和 \"Subject\" 字段。"

#. type: Plain text
#: en/git-imap-send.txt:25
#, priority:100
msgid "Typical usage is something like:"
msgstr "典型的用法是这样的："

#. type: Plain text
#: en/git-imap-send.txt:27
#, placeholders:'git format-patch':'--signoff':'--stdout':'--attach':'git imap-send', priority:100
msgid "git format-patch --signoff --stdout --attach origin | git imap-send"
msgstr "git format-patch --signoff --stdout --attach origin | git imap-send"

#. type: Plain text
#: en/git-imap-send.txt:39
#, priority:100
msgid "Be quiet."
msgstr "静默运行。"

#. type: Labeled list
#: en/git-imap-send.txt:40
#, ignore-same, no-wrap, priority:100
msgid "--curl"
msgstr "--curl"

#. type: Plain text
#: en/git-imap-send.txt:44
#, placeholders:'USE_CURL_FOR_IMAP_SEND', priority:100
msgid "Use libcurl to communicate with the IMAP server, unless tunneling into it. Ignored if Git was built without the USE_CURL_FOR_IMAP_SEND option set."
msgstr "使用 libcurl 与 IMAP 服务器通信，除非通过隧道进入。 如果 Git 在构建时没有设置 USE_CURL_FOR_IMAP_SEND 选项，则会被忽略。"

#. type: Labeled list
#: en/git-imap-send.txt:45
#, ignore-same, no-wrap, priority:100
msgid "--no-curl"
msgstr "--no-curl"

#. type: Plain text
#: en/git-imap-send.txt:49
#, placeholders:'NO_OPENSSL', priority:100
msgid "Talk to the IMAP server using git's own IMAP routines instead of using libcurl. Ignored if Git was built with the NO_OPENSSL option set."
msgstr "使用 git 自己的 IMAP 例程与 IMAP 服务器对话，而不是使用 libcurl。 如果 Git 在构建时设置了 NO_OPENSSL 选项，则忽略。"

#. type: Plain text
#: en/git-imap-send.txt:56
#, placeholders:'imap.folder':'imap.tunnel':'imap.host', priority:100
msgid "To use the tool, `imap.folder` and either `imap.tunnel` or `imap.host` must be set to appropriate values."
msgstr "要使用该工具，`imap.folder` 和 `imap.tunnel` 或 `imap.host` 必须被设置为适当的值。"

#. type: Plain text
#: en/git-imap-send.txt:64
#, priority:100
msgid "Using tunnel mode:"
msgstr "使用隧道模式："

#. type: delimited block .
#: en/git-imap-send.txt:69
#, no-wrap, priority:100
msgid ""
"[imap]\n"
"    folder = \"INBOX.Drafts\"\n"
"    tunnel = \"ssh -q -C user@example.com /usr/bin/imapd ./Maildir 2> /dev/null\"\n"
msgstr ""
"[imap]\n"
"    folder = \"INBOX.Drafts\"\n"
"    tunnel = \"ssh -q -C user@example.com /usr/bin/imapd ./Maildir 2> /dev/null\"\n"

#. type: Plain text
#: en/git-imap-send.txt:72
#, priority:100
msgid "Using direct mode:"
msgstr "使用直接模式："

#. type: delimited block .
#: en/git-imap-send.txt:79
#, no-wrap, priority:100
msgid ""
"[imap]\n"
"    folder = \"INBOX.Drafts\"\n"
"    host = imap://imap.example.com\n"
"    user = bob\n"
"    pass = p4ssw0rd\n"
msgstr ""
"[imap]\n"
"    folder = \"INBOX.Drafts\"\n"
"    host = imap://imap.example.com\n"
"    user = bob\n"
"    pass = p4ssw0rd\n"

#. type: Plain text
#: en/git-imap-send.txt:82
#, priority:100
msgid "Using direct mode with SSL:"
msgstr "使用 SSL 的直接模式："

#. type: delimited block .
#: en/git-imap-send.txt:91
#, no-wrap, priority:100
msgid ""
"[imap]\n"
"    folder = \"INBOX.Drafts\"\n"
"    host = imaps://imap.example.com\n"
"    user = bob\n"
"    pass = p4ssw0rd\n"
"    port = 123\n"
"    ; sslVerify = false\n"
msgstr ""
"[imap]\n"
"    folder = \"INBOX.Drafts\"\n"
"    host = imaps://imap.example.com\n"
"    user = bob\n"
"    pass = p4ssw0rd\n"
"    port = 123\n"
"    ; sslVerify = false\n"

#. type: Plain text
#: en/git-imap-send.txt:100
#, priority:100
msgid "You may want to use `sslVerify=false` while troubleshooting, if you suspect that the reason you are having trouble connecting is because the certificate you use at the private server `example.com` you are trying to set up (or have set up) may not be verified correctly."
msgstr "在排除故障时，如果你怀疑连接有问题的原因是你在试图建立（或已经建立）的私人服务器 `example.com`上使用的证书可能没有被正确验证，你可能想使用 `sslVerify=false`。"

#. type: Plain text
#: en/git-imap-send.txt:102
#, priority:100
msgid "Using Gmail's IMAP interface:"
msgstr "使用 Gmail 的 IMAP 界面："

#. type: delimited block -
#: en/git-imap-send.txt:109
#, no-wrap, placeholders:'imap.gmail.com':'gmail.com', priority:100
msgid ""
"[imap]\n"
"\tfolder = \"[Gmail]/Drafts\"\n"
"\thost = imaps://imap.gmail.com\n"
"\tuser = user@gmail.com\n"
"\tport = 993\n"
msgstr ""
"[imap]\n"
"\tfolder = \"[Gmail]/Drafts\"\n"
"\thost = imaps://imap.gmail.com\n"
"\tuser = user@gmail.com\n"
"\tport = 993\n"

#. type: Plain text
#: en/git-imap-send.txt:114
#, priority:100
msgid "You might need to instead use: `folder = \"[Google Mail]/Drafts\"` if you get an error that the \"Folder doesn't exist\"."
msgstr "如果你得到一个错误，即 “文件夹不存在”，你可能需要改用： `folder = \"[Google Mail]/Drafts\"` 。"

#. type: Plain text
#: en/git-imap-send.txt:118
#, priority:100
msgid "If your Gmail account is set to another language than English, the name of the \"Drafts\" folder will be localized."
msgstr "如果你的 Gmail 账户被设置为英语以外的其他语言，\"Drafts\" 文件夹的名称将被本地化。"

#. type: Plain text
#: en/git-imap-send.txt:120
#, priority:100
msgid "Once the commits are ready to be sent, run the following command:"
msgstr "一旦准备好发送提交，请运行以下命令："

#. type: Plain text
#: en/git-imap-send.txt:122
#, no-wrap, placeholders:'git format-patch':'--cover-letter':'--stdout':'git imap-send', priority:100
msgid "  $ git format-patch --cover-letter -M --stdout origin/master | git imap-send\n"
msgstr "  $ git format-patch --cover-letter -M --stdout origin/master | git imap-send\n"

#. type: Plain text
#: en/git-imap-send.txt:126
#, priority:100
msgid "Just make sure to disable line wrapping in the email client (Gmail's web interface will wrap lines no matter what, so you need to use a real IMAP client)."
msgstr "只要确保禁用电子邮件客户端的换行功能（Gmail 的网络界面无论如何都会换行，所以你需要使用真正的 IMAP 客户端）。"

#. type: Title -
#: en/git-imap-send.txt:128
#, no-wrap, priority:100
msgid "CAUTION"
msgstr "小心"

#. type: Plain text
#: en/git-imap-send.txt:135
#, priority:100
msgid "It is still your responsibility to make sure that the email message sent by your email program meets the standards of your project. Many projects do not like patches to be attached. Some mail agents will transform patches (e.g. wrap lines, send them as format=flowed) in ways that make them fail. You will get angry flames ridiculing you if you don't check this."
msgstr "你仍然有责任确保你的电子邮件程序所发送的电子邮件符合你的项目的标准。 许多项目不喜欢附加补丁。 一些邮件代理会对补丁进行转换（例如，包行，以 format=flowed 的方式发送），使其失败。 如果你不检查这个，你会得到愤怒的火苗。"

#. type: Plain text
#: en/git-imap-send.txt:139
#, no-wrap, placeholders:'kb.mozillazine.org':'Plain_text_e':'Completely_plain_email', priority:100
msgid ""
"Thunderbird in particular is known to be problematic.  Thunderbird\n"
"users may wish to visit this web page for more information:\n"
"  https://kb.mozillazine.org/Plain_text_e-mail_-_Thunderbird#Completely_plain_email\n"
msgstr ""
"尤其是Thunderbird，众所周知，它存在问题。 Thunderbird\n"
"用户可能希望访问这个网页以了解更多信息：\n"
"  https://kb.mozillazine.org/Plain_text_e-mail_-_Thunderbird#Completely_plain_email\n"

#. type: Plain text
#: en/git-imap-send.txt:143
#, placeholders:'linkgit:git-format-patch[1]':'linkgit:git-send-email[1]', priority:100
msgid "linkgit:git-format-patch[1], linkgit:git-send-email[1], mbox(5)"
msgstr "linkgit:git-format-patch[1], linkgit:git-send-email[1], mbox(5)"

#. type: Title =
#: en/git-index-pack.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-index-pack(1)"
msgstr "git-index-pack(1)"

#. type: Plain text
#: en/git-index-pack.txt:7
#, placeholders:'git-index-pack', priority:100
msgid "git-index-pack - Build pack index file for an existing packed archive"
msgstr "git-index-pack - 为现有打包存档建立打包索引文件"

#. type: Plain text
#: en/git-index-pack.txt:15
#, no-wrap, placeholders:'git index-pack':'git index-pack':'--stdin':'[--fix-thin]':'[--keep]', priority:100
msgid ""
"'git index-pack' [-v] [-o <index-file>] [--[no-]rev-index] <pack-file>\n"
"'git index-pack' --stdin [--fix-thin] [--keep] [-v] [-o <index-file>]\n"
"\t\t  [--[no-]rev-index] [<pack-file>]\n"
msgstr ""
"'git index-pack' [-v] [-o <索引文件>] [--[no-]rev-index] <包文件>\n"
"'git index-pack' --stdin [--fix-thin] [--keep] [-v] [-o <索引文件>]\n"
"\t\t  [--[no-]rev-index] [<包文件>]\n"

#. type: Plain text
#: en/git-index-pack.txt:24
#, priority:100
msgid "Reads a packed archive (.pack) from the specified file, builds a pack index file (.idx) for it, and optionally writes a reverse-index (.rev) for the specified pack. The packed archive, together with the pack index, can then be placed in the objects/pack/ directory of a Git repository."
msgstr "从指定文件读取打包归档文件（.pack），为其建立打包索引文件（.idx），并为指定打包文件写入反向索引（.rev）。打包后的归档文件连同打包索引可以放在 Git 仓库的 objects/pack/ 目录中。"

#. type: Plain text
#: en/git-index-pack.txt:30
#, priority:100
msgid "Be verbose about what is going on, including progress status."
msgstr "对正在发生的事情要言之有物，包括进度状态。"

#. type: Labeled list
#: en/git-index-pack.txt:31
#, no-wrap, priority:100
msgid "-o <index-file>"
msgstr "-o <index-file>"

#. type: Plain text
#: en/git-index-pack.txt:38
#, priority:100
msgid "Write the generated pack index into the specified file. Without this option the name of pack index file is constructed from the name of packed archive file by replacing .pack with .idx (and the program fails if the name of packed archive does not end with .pack)."
msgstr "将生成的数据包索引写入指定的文件中。 如果没有这个选项，打包索引文件的名称是根据打包档案文件的名称构建的，将 .pack 替换为 .idx（如果打包档案的名称不是以 .pack 结尾，程序将失败）。"

#. type: Labeled list
#: en/git-index-pack.txt:39
#, ignore-same, no-wrap, priority:100
msgid "--[no-]rev-index"
msgstr "--[no-]rev-index"

#. type: Plain text
#: en/git-index-pack.txt:45
#, placeholders:'`--verify`':'pack.writeReverseIndex', priority:100
msgid "When this flag is provided, generate a reverse index (a `.rev` file) corresponding to the given pack. If `--verify` is given, ensure that the existing reverse index is correct. Takes precedence over `pack.writeReverseIndex`."
msgstr "当提供这个标志时，生成一个与给定包对应的反向索引（一个 `.rev` 文件）。如果给了 `--verify`，确保现有的反向索引是正确的。优先于 `pack.writeReverseIndex`。"

#. type: Plain text
#: en/git-index-pack.txt:55
#, placeholders:'--keep', priority:100
msgid "When this flag is provided, the pack is read from stdin instead and a copy is then written to <pack-file>. If <pack-file> is not specified, the pack is written to objects/pack/ directory of the current Git repository with a default name determined from the pack content. If <pack-file> is not specified consider using --keep to prevent a race condition between this process and 'git repack'."
msgstr "当提供这个标志时，数据包将从标注输入流读取，然后将副本写入 <pack-file>。如果没有指定 <pack-file>，数据包会被写入当前 Git 仓库的 objects/pack/ 目录中，其默认名称由数据包内容决定。 如果没有指定 <pack-file>，可以考虑使用 --keep 来防止这个过程和 'git repack' 之间出现竞争状态。"

#. type: Labeled list
#: en/git-index-pack.txt:56
#, ignore-same, no-wrap, priority:100
msgid "--fix-thin"
msgstr "--fix-thin"

#. type: Plain text
#: en/git-index-pack.txt:61
#, placeholders:'git pack-objects':'--thin`':'linkgit:git-pack-objects[1]':'--stdin', priority:100
msgid "Fix a \"thin\" pack produced by `git pack-objects --thin` (see linkgit:git-pack-objects[1] for details) by adding the excluded objects the deltified objects are based on to the pack. This option only makes sense in conjunction with --stdin."
msgstr "修正由 `git pack-objects --thin` 产生的 “轻量” 包（详见 linkgit:git-pack-objects[1]），将被删除的对象所基于的排除对象加入包中。这个选项只有在与 --stdin 结合时才有意义。"

#. type: Plain text
#: en/git-index-pack.txt:69
#, placeholders:'--stdin', priority:100
msgid "Before moving the index into its final destination create an empty .keep file for the associated pack file. This option is usually necessary with --stdin to prevent a simultaneous 'git repack' process from deleting the newly constructed pack and index before refs can be updated to use objects contained in the pack."
msgstr "在将索引移到其最终目的地之前，为相关的包文件创建一个空的 .keep 文件。 这个选项通常需要和 --stdin一起使用，以防止同时进行的 \"git repack\" 进程在更新引用以使用 pack 中包含的对象之前删除新建的 pack 和 index。"

#. type: Labeled list
#: en/git-index-pack.txt:70
#, no-wrap, placeholders:'--keep=', priority:100
msgid "--keep=<msg>"
msgstr "--keep=<消息>"

#. type: Plain text
#: en/git-index-pack.txt:76
#, placeholders:'--keep', priority:100
msgid "Like --keep, create a .keep file before moving the index into its final destination. However, instead of creating an empty file place '<msg>' followed by an LF into the .keep file. The '<msg>' message can later be searched for within all .keep files to locate any which have outlived their usefulness."
msgstr "像 --keep 一样，在将索引移到最终目的地之前创建一个 .keep 文件，但不是创建一个空文件，而是在 .keep 文件中放入 '<消息>' 和一个 LF。 以后可以在所有的 .keep 文件中搜索 '<消息>' 信息，以找到任何已经失去作用的文件。"

#. type: Labeled list
#: en/git-index-pack.txt:77 en/git-pack-objects.txt:289
#, no-wrap, placeholders:'--index-version=', priority:100
msgid "--index-version=<version>[,<offset>]"
msgstr "--index-version=<版本>[,<偏移>]"

#. type: Plain text
#: en/git-index-pack.txt:81 en/git-pack-objects.txt:293
#, priority:100
msgid "This is intended to be used by the test suite only. It allows to force the version for the generated pack index, and to force 64-bit index entries on objects located above the given offset."
msgstr "这是为测试套件准备的。它允许为生成的数据包索引强制选择版本，并对位于给定偏移量以上的对象强制选择 64 位索引条目。"

#. type: Labeled list
#: en/git-index-pack.txt:82
#, ignore-ellipsis, no-wrap, placeholders:'--strict', priority:100
msgid "--strict[=<msg-id>=<severity>...]"
msgstr "--strict[=<msg-id>=<severity>...]"

#. type: Plain text
#: en/git-index-pack.txt:89
#, placeholders:'`--strict=':'linkgit:git-fsck[1]', priority:100
msgid "Die, if the pack contains broken objects or links. An optional comma-separated list of `<msg-id>=<severity>` can be passed to change the severity of some possible issues, e.g., `--strict=\"missingEmail=ignore,badTagName=error\"`. See the entry for the `fsck.<msg-id>` configuration options in linkgit:git-fsck[1] for more information on the possible values of `<msg-id>` and `<severity>`."
msgstr "如果数据包包含损坏的对象或链接，则 \"死\"。可选的逗号分隔列表 `<msg-id>=<severity>` 可用于改变某些可能问题的严重程度，例如 `--strict=\"missingEmail=ignore,badTagName=error\"`。关于 `<msg-id>` 和 `<severity>` 的可能值，请参阅 linkgit:git-fsck[1] 中的 `fsck.<msg-id>` 配置选项。"

#. type: Labeled list
#: en/git-index-pack.txt:90
#, ignore-same, no-wrap, priority:100
msgid "--progress-title"
msgstr "--progress-title"

#. type: Plain text
#: en/git-index-pack.txt:92
#, priority:100
msgid "For internal use only."
msgstr "仅供内部使用。"

#. type: Plain text
#: en/git-index-pack.txt:95
#, placeholders:'`--stdin`', priority:100
msgid "Set the title of the progress bar. The title is \"Receiving objects\" by default and \"Indexing objects\" when `--stdin` is specified."
msgstr "设置进度条的标题。标题默认为 \"Receiving objects\"，当指定 `--stdin` 时为 \"Indexing objects\"。"

#. type: Plain text
#: en/git-index-pack.txt:98
#, priority:100
msgid "Die if the pack contains broken links. For internal use only."
msgstr "如果数据包中包含无法链接的链接则死亡。仅供内部使用。"

#. type: Labeled list
#: en/git-index-pack.txt:99
#, ignore-ellipsis, no-wrap, placeholders:'--fsck-objects', priority:100
msgid "--fsck-objects[=<msg-id>=<severity>...]"
msgstr "--fsck-objects[=<msg-id>=<severity>...]"

#. type: Plain text
#: en/git-index-pack.txt:105
#, placeholders:'`--strict`', priority:100
msgid "Die if the pack contains broken objects, but unlike `--strict`, don't choke on broken links. If the pack contains a tree pointing to a .gitmodules blob that does not exist, prints the hash of that blob (for the caller to check) after the hash that goes into the name of the pack/idx file (see \"Notes\")."
msgstr "如果数据包中包含破损的对象进程会死亡，与 `--strict` 选项不同的是，不会因为断掉的链接而阻塞。如果数据包包含一个指向不存在的 .gitmodules blob 的树，则在进入数据包 /idx 文件名的哈希值之后打印该 blob 的哈希值（供调用者检查）（见 “注意事项”）。"

#. type: Plain text
#: en/git-index-pack.txt:111
#, placeholders:'`--fsck-objects=':'linkgit:git-fsck[1]', priority:100
msgid "An optional comma-separated list of `<msg-id>=<severity>` can be passed to change the severity of some possible issues, e.g., `--fsck-objects=\"missingEmail=ignore,badTagName=ignore\"`. See the entry for the `fsck.<msg-id>` configuration options in linkgit:git-fsck[1] for more information on the possible values of `<msg-id>` and `<severity>`."
msgstr "可选的逗号分隔列表\"<msg-id>=<severity>\"可用于改变某些可能问题的严重程度，例如 `--fsck-objects=\"missingEmail=ignore,badTagName=ignore\"`。关于 `<msg-id>` 和 `<severity>` 的可能值，请参阅 linkgit:git-fsck[1] 中的 `fsck.<msg-id>` 配置选项。"

#. type: Labeled list
#: en/git-index-pack.txt:112 en/git-pack-objects.txt:279 en/git-repack.txt:131
#, no-wrap, placeholders:'--threads=', priority:100
msgid "--threads=<n>"
msgstr "--threads=<n>"

#. type: Plain text
#: en/git-index-pack.txt:121
#, priority:100
msgid "Specifies the number of threads to spawn when resolving deltas. This requires that index-pack be compiled with pthreads otherwise this option is ignored with a warning. This is meant to reduce packing time on multiprocessor machines. The required amount of memory for the delta search window is however multiplied by the number of threads. Specifying 0 will cause Git to auto-detect the number of CPU's and use maximum 3 threads."
msgstr "指定解析 deltas 时产生的线程数量。这要求 index-pack 在编译时使用 pthreads，否则这个选项会被忽略并发出警告。 这是为了减少多处理器机器上的打包时间。然而，delta 搜索窗口所需的内存量要乘以线程的数量。 指定为 0 将导致 Git 自动检测 CPU 的数量并使用最多 3 个线程。"

#. type: Labeled list
#: en/git-index-pack.txt:122 en/git-unpack-objects.txt:47
#, no-wrap, placeholders:'--max-input-size=', priority:100
msgid "--max-input-size=<size>"
msgstr "--max-input-size=<尺寸>"

#. type: Plain text
#: en/git-index-pack.txt:124 en/git-unpack-objects.txt:49
#, priority:100
msgid "Die, if the pack is larger than <size>."
msgstr "如果数据包大于 <size>，则死亡。"

#. type: Labeled list
#: en/git-index-pack.txt:125 en/git-show-index.txt:42
#, no-wrap, placeholders:'--object-format=', priority:100
msgid "--object-format=<hash-algorithm>"
msgstr "--object-format=<哈希算法>"

# ERROR: extensions.objectFormat not found in translation
#. type: Plain text
#: en/git-index-pack.txt:130
#, placeholders:'extensions.objectFormat', priority:100
msgid "Specify the given object format (hash algorithm) for the pack. The valid values are 'sha1' and (if enabled) 'sha256'. The default is the algorithm for the current repository (set by `extensions.objectFormat`), or 'sha1' if no value is set or outside a repository."
msgstr "为数据包指定给定的对象格式（哈希算法）。 有效值为 'sha1' 和（如果启用）'sha256'。 默认值是当前仓库的算法（由 `extensions.objectFormat` 设置），如果没有设置值或在仓库之外，则为 'sha1'。"

#. type: Plain text
#: en/git-index-pack.txt:132
#, placeholders:'--stdin', priority:100
msgid "This option cannot be used with --stdin."
msgstr "该选项不能与 --stdin 选项一起使用。"

#. type: Labeled list
#: en/git-index-pack.txt:135
#, no-wrap, placeholders:'--promisor', priority:100
msgid "--promisor[=<message>]"
msgstr "--promisor[=<信息>]"

#. type: Plain text
#: en/git-index-pack.txt:142
#, placeholders:'--fix-thin':'link:technical/partial-clone.html[', priority:100
msgid "Before committing the pack-index, create a .promisor file for this pack. Particularly helpful when writing a promisor pack with --fix-thin since the name of the pack is not final until the pack has been fully written. If a `<message>` is provided, then that content will be written to the .promisor file for future reference. See link:technical/partial-clone.html[partial clone] for more information."
msgstr "在提交 pack-index 之前，为这个 pack 创建一个 .promosor 文件。在用 --fix-thin 编写 pack 时特别有帮助，因为在完全编写完 pack 之前，pack 的名字还不是最终的。如果提供了 `<message>`，那么该内容将被写入 .promosor 文件，供将来参考。参见 link:technical/partial-clone.html[partial clone] 以了解更多信息。"

#. type: Plain text
#: en/git-index-pack.txt:152
#, placeholders:'--stdin', priority:100
msgid "Once the index has been created, the hash that goes into the name of the pack/idx file is printed to stdout. If --stdin was also used then this is prefixed by either \"pack\\t\", or \"keep\\t\" if a new .keep file was successfully created. This is useful to remove a .keep file used as a lock to prevent the race with 'git repack' mentioned above."
msgstr "索引创建完成后，pack/idx 文件名的哈希值会被打印到标准输出流。如果还使用了 --stdin 选项 ，则会以 \"pack/t\" 或 \"keep/t\" 作为前缀（如果成功创建了新的 .keep 文件）。这对移除用作锁的 .keep 文件很有用，可以防止上面提到的与 'git repack' 的竞争。"

#. type: Title =
#: en/git-init-db.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-init-db(1)"
msgstr "git-init-db(1)"

#. type: Plain text
#: en/git-init-db.txt:7
#, placeholders:'git-init-db', priority:100
msgid "git-init-db - Creates an empty Git repository"
msgstr "git-init-db - 创建一个空的 Git 仓库"

#. type: Plain text
#: en/git-init-db.txt:13
#, no-wrap, placeholders:'git init-db':'--quiet]':'[--bare]':'[--template=':'[--shared', priority:100
msgid "'git init-db' [-q | --quiet] [--bare] [--template=<template-directory>] [--separate-git-dir <git-dir>] [--shared[=<permissions>]]\n"
msgstr "'git init-db' [-q | --quiet] [--bare] [--template=<模板目录>] [--separate-git-dir <Git 目录>] [--shared[=<许可>]]\n"

#. type: Plain text
#: en/git-init-db.txt:20
#, placeholders:'linkgit:git-init[1]', priority:100
msgid "This is a synonym for linkgit:git-init[1]. Please refer to the documentation of that command."
msgstr "这是 linkgit:git-init[1] 的一个同义词。 请参考该命令的文档。"

#. type: Title =
#: en/git-init.txt:2
#, ignore-same, no-wrap, priority:300
msgid "git-init(1)"
msgstr "git-init(1)"

#. type: Plain text
#: en/git-init.txt:7
#, placeholders:'git-init', priority:300
msgid "git-init - Create an empty Git repository or reinitialize an existing one"
msgstr "git-init - 创建一个空的 Git 仓库或是重新初始化一个已经存在的仓库"

#. type: Plain text
#: en/git-init.txt:17
#, no-wrap, placeholders:'--quiet]':'[--bare]':'[--template=':'[--object-format=':'[--ref-format=':'--initial-branch=':'[--shared', priority:300
msgid ""
"'git init' [-q | --quiet] [--bare] [--template=<template-directory>]\n"
"\t  [--separate-git-dir <git-dir>] [--object-format=<format>]\n"
"\t  [--ref-format=<format>]\n"
"\t  [-b <branch-name> | --initial-branch=<branch-name>]\n"
"\t  [--shared[=<permissions>]] [<directory>]\n"
msgstr ""
"'git init' [-q | --quiet] [--bare] [--template=<模板目录>]\n"
"\t  [--separate-git-dir <Git 目录>] [--object-format=<格式>]\n"
"\t  [--ref-format=<引用格式>]\n"
"\t  [-b <分支名> | --initial-branch=<分支名>]\n"
"\t  [--shared[=<许可>]] [<目录>]\n"

# ERROR: --initial-branch not found in translation
#. type: Plain text
#: en/git-init.txt:27
#, placeholders:'`--initial-branch`', priority:300
msgid "This command creates an empty Git repository - basically a `.git` directory with subdirectories for `objects`, `refs/heads`, `refs/tags`, and template files. An initial branch without any commits will be created (see the `--initial-branch` option below for its name)."
msgstr "该命令创建一个空的 Git 仓库 - 本质上是一个 `.git` 目录，其中包含 `objects` 、`refs/heads` 、`refs/tags` 和模板文件的子目录。 同时将创建一个没有任何提交的初始分支（其名称参见下面的 `--initial-branch` 选项）。"

#. type: Plain text
#: en/git-init.txt:30
#, placeholders:'$GIT_DIR', priority:300
msgid "If the `$GIT_DIR` environment variable is set then it specifies a path to use instead of `./.git` for the base of the repository."
msgstr "如果设置了 `$GIT_DIR` 环境变量，那么它将指定用于仓库基础的路径，而不是 `./.git` ."

#. type: Plain text
#: en/git-init.txt:35
#, placeholders:'$GIT_OBJECT_DIRECTORY':'$GIT_DIR', priority:300
msgid "If the object storage directory is specified via the `$GIT_OBJECT_DIRECTORY` environment variable then the sha1 directories are created underneath; otherwise, the default `$GIT_DIR/objects` directory is used."
msgstr "如果通过 `$GIT_OBJECT_DIRECTORY` 环境变量指定了对象存储目录，那么将在该目录下创建 sha1 目录，否则将使用默认的 `$GIT_DIR/objects` 目录。"

#. type: Plain text
#: en/git-init.txt:40
#, priority:300
msgid "Running 'git init' in an existing repository is safe. It will not overwrite things that are already there. The primary reason for rerunning 'git init' is to pick up newly added templates (or to move the repository to another place if --separate-git-dir is given)."
msgstr "在现有仓库中运行 'git init' 是安全的。它不会覆盖已经存在的内容。重新运行 'git init' 的主要原因是选择新添加的模板（如果给定了 --separate-git-dir 参数，则将仓库移至另一个位置）。"

#. type: Plain text
#: en/git-init.txt:48
#, priority:300
msgid "Only print error and warning messages; all other output will be suppressed."
msgstr "仅打印错误和警告消息；所有其他输出将不会显示。"

#. type: Plain text
#: en/git-init.txt:53
#, placeholders:'GIT_DIR', priority:300
msgid "Create a bare repository. If `GIT_DIR` environment is not set, it is set to the current working directory."
msgstr "创建一个裸仓库。如果未设置 `GIT_DIR` 环境变量，则将其设置为当前工作目录。"

#. type: Labeled list
#: en/git-init.txt:54
#, no-wrap, placeholders:'--object-format=', priority:300
msgid "--object-format=<format>"
msgstr "--object-format=<格式>"

#. type: Plain text
#: en/git-init.txt:58
#, priority:300
msgid "Specify the given object format (hash algorithm) for the repository. The valid values are 'sha1' and (if enabled) 'sha256'. 'sha1' is the default."
msgstr "指定仓库的对象格式（哈希算法）。有效值为 'sha1' 和（如果启用）'sha256'。'sha1' 是默认值。"

#. type: Labeled list
#: en/git-init.txt:61
#, no-wrap, placeholders:'--ref-format=', priority:300
msgid "--ref-format=<format>"
msgstr "--ref-format=<格式>"

#. type: Plain text
#: en/git-init.txt:71
#, priority:300
msgid "Specify the directory from which templates will be used. (See the \"TEMPLATE DIRECTORY\" section below.)"
msgstr "指定要使用模板的目录。（请参见下面的 “模板目录” 部分。）"

#. type: Plain text
#: en/git-init.txt:78
#, placeholders:'$GIT_DIR', priority:300
msgid "Instead of initializing the repository as a directory to either `$GIT_DIR` or `./.git/`, create a text file there containing the path to the actual repository. This file acts as a filesystem-agnostic Git symbolic link to the repository."
msgstr "并不将存储库初始化至 `$GIT_DIR` 或 `./.git/` 目录，而是在其中创建一个包含实际仓库路径的文本文件。此文件作为连接到仓库的 Git 符号链接，其与文件系统无关。"

#. type: Plain text
#: en/git-init.txt:80
#, priority:300
msgid "If this is a reinitialization, the repository will be moved to the specified path."
msgstr "如果为重新初始化操作，则将仓库移动到指定的路径。"

#. type: Labeled list
#: en/git-init.txt:81
#, no-wrap, priority:300
msgid "-b <branch-name>"
msgstr "-b <分支名>"

#. type: Labeled list
#: en/git-init.txt:82
#, no-wrap, placeholders:'--initial-branch=', priority:300
msgid "--initial-branch=<branch-name>"
msgstr "--initial-branch=<分支名>"

# ERROR: init.defaultBranch not found in translation
#. type: Plain text
#: en/git-init.txt:88
#, placeholders:'init.defaultBranch', priority:300
msgid "Use the specified name for the initial branch in the newly created repository. If not specified, fall back to the default name (currently `master`, but this is subject to change in the future; the name can be customized via the `init.defaultBranch` configuration variable)."
msgstr "在新创建的仓库中使用指定的名称作为初始分支。 如果未指定，则返回默认名称（目前为 `master`，但将来可能会更改；可通过 `init.defaultBranch` 配置变量自定义名称）。"

#. type: Labeled list
#: en/git-init.txt:89
#, no-wrap, placeholders:'--shared', priority:300
msgid "--shared[=(false|true|umask|group|all|world|everybody|<perm>)]"
msgstr "--shared[=(false|true|umask|group|all|world|everybody|<许可>)]"

#. type: Plain text
#: en/git-init.txt:97
#, placeholders:'core.sharedRepository':'$GIT_DIR', priority:300
msgid "Specify that the Git repository is to be shared amongst several users. This allows users belonging to the same group to push into that repository. When specified, the config variable \"core.sharedRepository\" is set so that files and directories under `$GIT_DIR` are created with the requested permissions. When not specified, Git will use permissions reported by umask(2)."
msgstr "指定 Git 仓库在多个用户之间共享。这允许属于同一组的用户推送到该仓库。指定时，将设置配置变量 \"core.sharedRepository\"，以便使用请求的权限创建 `$GIT_DIR` 下的文件和目录。未指定时，Git 将使用 umask(2) 返回的权限。"

#. type: Plain text
#: en/git-init.txt:100
#, priority:300
msgid "The option can have the following values, defaulting to 'group' if no value is given:"
msgstr "此选项可以有以下值，如果未给定值，则默认为 'group'："

#. type: Labeled list
#: en/git-init.txt:102
#, no-wrap, priority:300
msgid "'umask' (or 'false')"
msgstr "'umask'（或 'false'）"

#. type: Plain text
#: en/git-init.txt:106
#, placeholders:'`--shared`', priority:300
msgid "Use permissions reported by umask(2). The default, when `--shared` is not specified."
msgstr "使用 umask(2) 返回的权限。未指定 `--shared` 时，此为默认值。"

#. type: Labeled list
#: en/git-init.txt:107
#, no-wrap, priority:300
msgid "'group' (or 'true')"
msgstr "'group' (或是 'true')"

#. type: Plain text
#: en/git-init.txt:115
#, priority:300
msgid "Make the repository group-writable, (and g+sx, since the git group may not be the primary group of all users). This is used to loosen the permissions of an otherwise safe umask(2) value. Note that the umask still applies to the other permission bits (e.g. if umask is '0022', using 'group' will not remove read privileges from other (non-group) users). See '0xxx' for how to exactly specify the repository permissions."
msgstr "使仓库组可写（并且 g+sx，因为 git 组可能不是所有用户的主要组）。这用于放宽原本安全的 umask(2) 值的权限。请注意，umask 仍然适用于其他权限位（例如，如果 umask 为 '0022'，则使用 'group' 不会删除其他（非组）用户的读取特权）。有关如何精确指定仓库权限的信息，请参见 '0xxx'。"

#. type: Labeled list
#: en/git-init.txt:116
#, no-wrap, priority:300
msgid "'all' (or 'world' or 'everybody')"
msgstr "'all' （或 'world' 或 'everybody'）"

#. type: Plain text
#: en/git-init.txt:119
#, priority:300
msgid "Same as 'group', but make the repository readable by all users."
msgstr "与使用 'group' 选项相同，但使仓库对所有用户可读。"

#. type: Labeled list
#: en/git-init.txt:120
#, no-wrap, priority:300
msgid "'<perm>'"
msgstr "'<perm>'"

#. type: Plain text
#: en/git-init.txt:130
#, priority:300
msgid "'<perm>' is a 3-digit octal number prefixed with `0` and each file will have mode '<perm>'. '<perm>' will override users' umask(2) value (and not only loosen permissions as 'group' and 'all' do). '0640' will create a repository which is group-readable, but not group-writable or accessible to others. '0660' will create a repo that is readable and writable to the current user and group, but inaccessible to others (directories and executable files get their `x` bit from the `r` bit for corresponding classes of users)."
msgstr "'<许可>' 是一个以 `0` 为前缀的三位八进制数，每个文件都有 '<许可>' 模式。'<许可>' 将覆盖用户的 umask(2) 值（而不只是像 'group' 和 'all' 那样放宽权限）。'0640' 将创建一个群组可读、但群组不可写或他人不可访问的仓库。'0660' 将创建一个当前用户和组可读可写，但其他用户不可访问的仓库（目录和可执行文件的 `x` 位来自相应用户类别的 `r` 位）。"

#. type: Plain text
#: en/git-init.txt:135
#, placeholders:'receive.denyNonFastForwards', priority:300
msgid "By default, the configuration flag `receive.denyNonFastForwards` is enabled in shared repositories, so that you cannot force a non fast-forwarding push into it."
msgstr "默认情况下，共享仓库中启用了配置标志 `receive.denyNonFastForwards`，因此您不能强制将非快速转发提交推送到该仓库中。"

#. type: Plain text
#: en/git-init.txt:138
#, priority:300
msgid "If you provide a 'directory', the command is run inside it. If this directory does not exist, it will be created."
msgstr "如果提供 'dicrectory'，则命令在其中运行。如果此目录不存在，则创建它。"

#. type: Title -
#: en/git-init.txt:140
#, no-wrap, priority:300
msgid "TEMPLATE DIRECTORY"
msgstr "模板目录"

#. type: Plain text
#: en/git-init.txt:144
#, placeholders:'$GIT_DIR', priority:300
msgid "Files and directories in the template directory whose name do not start with a dot will be copied to the `$GIT_DIR` after it is created."
msgstr "模板目录中名称不以点开头的文件和目录将在创建后复制到 `$GIT_DIR` 中。"

#. type: Plain text
#: en/git-init.txt:146
#, priority:300
msgid "The template directory will be one of the following (in order):"
msgstr "模板目录将是以下之一（按顺序）："

#. type: Plain text
#: en/git-init.txt:148
#, placeholders:'`--template`', priority:300
msgid "the argument given with the `--template` option;"
msgstr "用 `--template` 选项给出的参数；"

#. type: Plain text
#: en/git-init.txt:150
#, placeholders:'$GIT_TEMPLATE_DIR', priority:300
msgid "the contents of the `$GIT_TEMPLATE_DIR` environment variable;"
msgstr "`$GIT_TEMPLATE_DIR` 环境变量的内容；"

#. type: Plain text
#: en/git-init.txt:152
#, placeholders:'init.templateDir', priority:300
msgid "the `init.templateDir` configuration variable; or"
msgstr "`init.templateDir` 配置变量；或者"

#. type: Plain text
#: en/git-init.txt:154
#, placeholders:'git-core', priority:300
msgid "the default template directory: `/usr/share/git-core/templates`."
msgstr "默认模板目录：`/usr/share/git-core/templates`。"

#. type: Plain text
#: en/git-init.txt:157
#, placeholders:'linkgit:gitignore[5]', priority:300
msgid "The default template directory includes some directory structure, suggested \"exclude patterns\" (see linkgit:gitignore[5]), and sample hook files."
msgstr "默认的模板目录包括一些目录结构，建议的 “排除模式”（请参阅 linkgit:gitignore[5]）和示例钩子文件。"

#. type: Plain text
#: en/git-init.txt:160
#, priority:300
msgid "The sample hooks are all disabled by default. To enable one of the sample hooks rename it by removing its `.sample` suffix."
msgstr "默认情况下，样例钩子都被禁用。要启用一个示例挂钩，请通过删除其后缀 `.sample` 对其重命名。"

#. type: Plain text
#: en/git-init.txt:162
#, placeholders:'linkgit:githooks[5]', priority:300
msgid "See linkgit:githooks[5] for more general info on hook execution."
msgstr "有关钩子执行的更多信息，请参见 linkgit:githooks[5]。"

#. type: Labeled list
#: en/git-init.txt:166
#, no-wrap, priority:300
msgid "Start a new Git repository for an existing code base"
msgstr "为现有仓库开启新的 Git 仓库"

#. type: delimited block -
#: en/git-init.txt:173
#, no-wrap, priority:300
msgid ""
"$ cd /path/to/my/codebase\n"
"$ git init      <1>\n"
"$ git add .     <2>\n"
"$ git commit    <3>\n"
msgstr ""
"$ cd /path/to/my/codebase\n"
"$ git init      <1>\n"
"$ git add .     <2>\n"
"$ git commit    <3>\n"

#. type: Plain text
#: en/git-init.txt:176
#, priority:300
msgid "Create a /path/to/my/codebase/.git directory."
msgstr "创建 /path/to/my/codebase/.git 目录。"

#. type: Plain text
#: en/git-init.txt:177
#, priority:300
msgid "Add all existing files to the index."
msgstr "将所有现有文件添加到索引。"

#. type: Plain text
#: en/git-init.txt:178
#, priority:300
msgid "Record the pristine state as the first commit in the history."
msgstr "将原始状态记录为历史记录中的第一次提交。"

#. type: Title =
#: en/git-instaweb.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-instaweb(1)"
msgstr "git-instaweb(1)"

#. type: Plain text
#: en/git-instaweb.txt:7
#, placeholders:'git-instaweb', priority:100
msgid "git-instaweb - Instantly browse your working repository in gitweb"
msgstr "git-instaweb - 立即在 gitweb 中浏览您的工作仓库"

#. type: Plain text
#: en/git-instaweb.txt:14
#, no-wrap, placeholders:'[--local]':'[--httpd=':'[--port=':'[--browser=':'[--start]':'[--stop]':'[--restart]', priority:100
msgid ""
"'git instaweb' [--local] [--httpd=<httpd>] [--port=<port>]\n"
"               [--browser=<browser>]\n"
"'git instaweb' [--start] [--stop] [--restart]\n"
msgstr ""
"'git instaweb' [--local] [--httpd=<httpd>] [--port=<端口>]\n"
"               [--browser=<浏览器>]\n"
"'git instaweb' [--start] [--stop] [--restart]\n"

#. type: Plain text
#: en/git-instaweb.txt:19
#, priority:100
msgid "A simple script to set up `gitweb` and a web server for browsing the local repository."
msgstr "一个简单的脚本，用来设置 `gitweb` 和浏览本地仓库的网络服务器。"

#. type: Plain text
#: en/git-instaweb.txt:26
#, priority:100
msgid "Only bind the web server to the local IP (127.0.0.1)."
msgstr "只将 Web 服务器绑定到本地 IP（127.0.0.1）。"

#. type: Labeled list
#: en/git-instaweb.txt:28
#, ignore-same, no-wrap, priority:100
msgid "--httpd"
msgstr "--httpd"

#. type: Plain text
#: en/git-instaweb.txt:35
#, priority:100
msgid "The HTTP daemon command-line that will be executed. Command-line options may be specified here, and the configuration file will be added at the end of the command-line. Currently apache2, lighttpd, mongoose, plackup, python and webrick are supported. (Default: lighttpd)"
msgstr "将被执行的 HTTP 守护程序的命令行。 命令行选项可以在这里指定，配置文件将被添加到命令行的最后。 目前支持 apache2、lighttpd、mongoose、plackup、python 和 webrick。 (默认：lighttpd)"

#. type: Labeled list
#: en/git-instaweb.txt:37
#, ignore-same, no-wrap, priority:100
msgid "--module-path"
msgstr "--module-path"

#. type: Plain text
#: en/git-instaweb.txt:40
#, priority:100
msgid "The module path (only needed if httpd is Apache). (Default: /usr/lib/apache2/modules)"
msgstr "模块路径（只有当 httpd 是 Apache 时才需要）。 (默认：/usr/lib/apache2/modules)"

#. type: Labeled list
#: en/git-instaweb.txt:42
#, ignore-same, no-wrap, priority:100
msgid "--port"
msgstr "--port"

#. type: Plain text
#: en/git-instaweb.txt:44
#, priority:100
msgid "The port number to bind the httpd to. (Default: 1234)"
msgstr "绑定 httpd 的端口号。 (默认：1234)"

#. type: Labeled list
#: en/git-instaweb.txt:46
#, ignore-same, no-wrap, priority:100
msgid "--browser"
msgstr "--browser"

#. type: Plain text
#: en/git-instaweb.txt:52
#, placeholders:'{litdd}':'linkgit:git-web{litdd}browse[1]', priority:100
msgid "The web browser that should be used to view the gitweb page. This will be passed to the 'git web{litdd}browse' helper script along with the URL of the gitweb instance. See linkgit:git-web{litdd}browse[1] for more information about this. If the script fails, the URL will be printed to stdout."
msgstr "查看 gitweb 页面时应使用的网络浏览器。这将与 gitweb 实例的 URL 一起传递给 'git web{litdd}browse' 辅助脚本。参见 linkgit:git-web{litdd}browse[1] 获取更多相关信息。如果脚本失败，URL 会被打印到标准输出流。"

#. type: Labeled list
#: en/git-instaweb.txt:53 en/git-update-ref.txt:125
#, no-wrap, priority:100
msgid "start"
msgstr "起点"

#. type: Labeled list
#: en/git-instaweb.txt:54
#, ignore-same, no-wrap, priority:100
msgid "--start"
msgstr "--start"

#. type: Plain text
#: en/git-instaweb.txt:57
#, priority:100
msgid "Start the httpd instance and exit. Regenerate configuration files as necessary for spawning a new instance."
msgstr "启动 httpd 实例并退出。 根据需要重新生成配置文件以生成新的实例。"

#. type: Labeled list
#: en/git-instaweb.txt:58
#, no-wrap, priority:100
msgid "stop"
msgstr "停止"

#. type: Labeled list
#: en/git-instaweb.txt:59
#, ignore-same, no-wrap, priority:100
msgid "--stop"
msgstr "--stop"

#. type: Plain text
#: en/git-instaweb.txt:63
#, priority:100
msgid "Stop the httpd instance and exit. This does not generate any of the configuration files for spawning a new instance, nor does it close the browser."
msgstr "停止 httpd 实例并退出。 这不会生成任何用于生成新实例的配置文件，也不会关闭浏览器。"

#. type: Labeled list
#: en/git-instaweb.txt:64
#, no-wrap, priority:100
msgid "restart"
msgstr "重新启动"

#. type: Labeled list
#: en/git-instaweb.txt:65
#, ignore-same, no-wrap, priority:100
msgid "--restart"
msgstr "--restart"

#. type: Plain text
#: en/git-instaweb.txt:68
#, priority:100
msgid "Restart the httpd instance and exit. Regenerate configuration files as necessary for spawning a new instance."
msgstr "重新启动 httpd 实例并退出。 根据需要重新生成配置文件以生成新的实例。"

#. type: Plain text
#: en/git-instaweb.txt:73
#, priority:100
msgid "You may specify configuration in your .git/config"
msgstr "你可以在你的 .git/config 中指定配置"

#. type: delimited block -
#: en/git-instaweb.txt:81
#, no-wrap, priority:100
msgid ""
"[instaweb]\n"
"\tlocal = true\n"
"\thttpd = apache2 -f\n"
"\tport = 4321\n"
"\tbrowser = konqueror\n"
"\tmodulePath = /usr/lib/apache2/modules\n"
msgstr ""
"[instaweb]\n"
"\tlocal = true\n"
"\thttpd = apache2 -f\n"
"\tport = 4321\n"
"\tbrowser = konqueror\n"
"\tmodulePath = /usr/lib/apache2/modules\n"

#. type: Plain text
#: en/git-instaweb.txt:87
#, placeholders:'instaweb.browser':'web.browser':'linkgit:git-web{litdd}browse[1]', priority:100
msgid "If the configuration variable `instaweb.browser` is not set, `web.browser` will be used instead if it is defined. See linkgit:git-web{litdd}browse[1] for more information about this."
msgstr "如果配置变量 `instaweb.browser` 没有设置，如果定义了 `web.browser`，将使用它来代替。参见 linkgit:git-web{litdd}browse[1] 以了解更多相关信息。"

#. type: Title =
#: en/git-interpret-trailers.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-interpret-trailers(1)"
msgstr "git-interpret-trailers(1)"

#. type: Plain text
#: en/git-interpret-trailers.txt:7
#, placeholders:'git-interpret-trailers', priority:100
msgid "git-interpret-trailers - Add or parse structured information in commit messages"
msgstr "git-interpret-trailers - 添加或解析提交消息中的结构化信息"

#. type: Plain text
#: en/git-interpret-trailers.txt:14
#, ignore-ellipsis, no-wrap, placeholders:'git interpret-trailers':'[--in-place]':'[--trim-empty]':'--trailer':'[--parse]', priority:100
msgid ""
"'git interpret-trailers' [--in-place] [--trim-empty]\n"
"\t\t\t[(--trailer (<key>|<keyAlias>)[(=|:)<value>])...]\n"
"\t\t\t[--parse] [<file>...]\n"
msgstr ""
"'git interpret-trailers' [--in-place] [--trim-empty]\n"
"\t\t\t[(--trailer (<键>|<键别名>)[(=|:)<值>])...]\n"
"\t\t\t[--parse] [<文件>...]\n"

#. type: Plain text
#: en/git-interpret-trailers.txt:20
#, priority:100
msgid "Add or parse 'trailer' lines that look similar to RFC 822 e-mail headers, at the end of the otherwise free-form part of a commit message. For example, in the following commit message"
msgstr "在提交信息中原本自由格式部分的末尾添加或解析与 RFC 822 电子邮件标题相似的 ‘尾注’ 行。例如，在以下提交信息中"

#. type: delimited block -
#: en/git-interpret-trailers.txt:23
#, no-wrap, priority:100
msgid "subject\n"
msgstr "主题\n"

#. type: delimited block -
#: en/git-interpret-trailers.txt:25
#, no-wrap, priority:100
msgid "Lorem ipsum dolor sit amet, consectetur adipiscing elit.\n"
msgstr "Lorem ipsum dolor sit amet, consectetur adipiscing elit. 乱序拉丁文，作为占位符使用，无任何意义\n"

#. type: delimited block -
#: en/git-interpret-trailers.txt:28 en/git-interpret-trailers.txt:345
#, no-wrap, priority:100
msgid ""
"Signed-off-by: Alice <alice@example.com>\n"
"Signed-off-by: Bob <bob@example.com>\n"
msgstr ""
"Signed-off-by: Alice <alice@example.com>\n"
"Signed-off-by: Bob <bob@example.com>\n"

#. type: Plain text
#: en/git-interpret-trailers.txt:31
#, priority:100
msgid "the last two lines starting with \"Signed-off-by\" are trailers."
msgstr "以 \"Signed-off-by\" 开头的最后两行是尾注。"

#. type: Plain text
#: en/git-interpret-trailers.txt:37
#, placeholders:'`--parse`', priority:100
msgid "This command reads commit messages from either the <file> arguments or the standard input if no <file> is specified. If `--parse` is specified, the output consists of the parsed trailers coming from the input, without influencing them with any command line options or configuration variables."
msgstr "这条命令从 <文件> 参数或标准输入（如果没有指定 <文件> 参数）读取提交信息。 如果指定了 `--parse`，输出将由来自输入的经过解析尾注组成，不会受到任何命令行选项或配置变量的影响。"

#. type: Plain text
#: en/git-interpret-trailers.txt:43
#, ignore-ellipsis, placeholders:'`--trailer=', priority:100
msgid "Otherwise, this command applies `trailer.*` configuration variables (which could potentially add new trailers, as well as reposition them), as well as any command line arguments that can override configuration variables (such as `--trailer=...` which could also add new trailers), to each input file. The result is emitted on the standard output."
msgstr "否则，该命令会在每个输入文件中应用 `trailer.*` 配置变量（可能会添加新的拖车，也可能会调整拖车的位置），以及任何可以覆盖配置变量的命令行参数（例如 `--trailer=...`，也可能会添加新的拖车）。结果将输出到标准输出中。"

#. type: Plain text
#: en/git-interpret-trailers.txt:50
#, placeholders:'linkgit:git-format-patch[1]':'---':'`--no-divider`', priority:100
msgid "This command can also operate on the output of linkgit:git-format-patch[1], which is more elaborate than a plain commit message. Namely, such output includes a commit message (as above), a \"---\" divider line, and a patch part. For these inputs, the divider and patch parts are not modified by this command and are emitted as is on the output, unless `--no-divider` is specified."
msgstr "这条命令也可以处理 linkgit:git-format-patch[1] 的输出，它比普通的提交信息更复杂。也就是说，这种输出包括提交信息（如上所述）、\"---\" 分隔线和补丁部分。 对于这些输入，除非指定了 `--no-divider`，否则分隔线和补丁部分不会被此命令修改，而是原样输出。"

#. type: Plain text
#: en/git-interpret-trailers.txt:55
#, placeholders:'`--trailer`', priority:100
msgid "Some configuration variables control the way the `--trailer` arguments are applied to each input and the way any existing trailer in the input is changed. They also make it possible to automatically add some trailers."
msgstr "一些配置变量可以控制 `--trailer` 参数应用于每条提交信息的方式，以及修改提交信息中任何现有尾注的方式。它们还可以自动添加一些尾注。"

#. type: Plain text
#: en/git-interpret-trailers.txt:62
#, placeholders:'`--trailer`', priority:100
msgid "By default, a '<key>=<value>' or '<key>:<value>' argument given using `--trailer` will be appended after the existing trailers only if the last trailer has a different (<key>, <value>) pair (or if there is no existing trailer). The <key> and <value> parts will be trimmed to remove starting and trailing whitespace, and the resulting trimmed <key> and <value> will appear in the output like this:"
msgstr "默认情况下，使用 `--trailer` 给出的 '<键>=<值>' 或 '<键>:<值>' 参数，只有在最后一个尾注具有不同的（<键>, <值>）对（或没有现有尾注）时，才会追加到现有尾注之后。<键> 和 <值> 部分将被修剪以去除起始和尾部的空白，修剪后的 <键> 和 <值> 将像这样出现在输出中："

#. type: delimited block -
#: en/git-interpret-trailers.txt:65
#, no-wrap, priority:100
msgid "key: value\n"
msgstr "键: 值\n"

#. type: Plain text
#: en/git-interpret-trailers.txt:69
#, priority:100
msgid "This means that the trimmed <key> and <value> will be separated by `': '` (one colon followed by one space)."
msgstr "这意味着修剪后的 <键> 和 <值> 将用 `':'`（一个冒号后加一个空格）分隔。"

#. type: Plain text
#: en/git-interpret-trailers.txt:75
#, placeholders:'`--trailer`', priority:100
msgid "For convenience, a <keyAlias> can be configured to make using `--trailer` shorter to type on the command line. This can be configured using the 'trailer.<keyAlias>.key' configuration variable. The <keyAlias> must be a prefix of the full <key> string, although case sensitivity does not matter. For example, if you have"
msgstr "为方便起见，可以配置 <keyAlias> 以缩短使用 `--trailer` 命令行的键入时间。可以使用 'trailer.<keyAlias>.key' 配置变量进行配置。<keyAlias> 必须是完整 <key> 字符串的前缀，但大小写敏感性并不重要。例如"

#. type: delimited block -
#: en/git-interpret-trailers.txt:78
#, no-wrap, placeholders:'trailer.sign.key', priority:100
msgid "trailer.sign.key \"Signed-off-by: \"\n"
msgstr "trailer.sign.key \"Signed-off-by: \"\n"

#. type: Plain text
#: en/git-interpret-trailers.txt:82
#, placeholders:'`--trailer=':'`--trailer=', priority:100
msgid "in your configuration, you only need to specify `--trailer=\"sign: foo\"` on the command line instead of `--trailer=\"Signed-off-by: foo\"`."
msgstr "时，只需在命令行中指定 `--trailer=\"sign: foo\"`，而不是 `-trailer=\"Signed-off-by:foo\"`。"

#. type: Plain text
#: en/git-interpret-trailers.txt:87
#, priority:100
msgid "By default the new trailer will appear at the end of all the existing trailers. If there is no existing trailer, the new trailer will appear at the end of the input. A blank line will be added before the new trailer if there isn't one already."
msgstr "默认情况下，新预告片将出现在所有现有尾注的末尾。如果没有现有尾注，新尾注将出现在输入内容的末尾。如果没有新尾注，则会在新尾注前添加一行空行。"

#. type: Plain text
#: en/git-interpret-trailers.txt:96
#, placeholders:'---', priority:100
msgid "Existing trailers are extracted from the input by looking for a group of one or more lines that (i) is all trailers, or (ii) contains at least one Git-generated or user-configured trailer and consists of at least 25% trailers. The group must be preceded by one or more empty (or whitespace-only) lines. The group must either be at the end of the input or be the last non-whitespace lines before a line that starts with '---' (followed by a space or the end of the line)."
msgstr "从输入内容中提取现有尾注的方法是，在一行或多行中寻找一个组，该组(i) 全部是尾注，或 (ii) 包含至少一个 Git 生成或用户配置的尾注，且至少有 25% 的尾注。 该组行前必须有一个或多个空行（或仅空白行）。 该组必须位于输入内容的末尾，或者是以 '---' 开头（后跟空格或行尾）的行之前的最后一行非空格行。"

#. type: Plain text
#: en/git-interpret-trailers.txt:103
#, priority:100
msgid "When reading trailers, there can be no whitespace before or inside the <key>, but any number of regular space and tab characters are allowed between the <key> and the separator. There can be whitespaces before, inside or after the <value>. The <value> may be split over multiple lines with each subsequent line starting with at least one whitespace, like the \"folding\" in RFC 822. Example:"
msgstr "读取尾注时，<键> 前或 <键> 内不能有空白，但 <键> 和分隔符之间允许有任意数量的常规空格和制表符。<值> 之前、内部或之后都可以有空白。<值> 可以分成多行，每行至少以一个空格开始，就像 RFC 822 中的 “折叠” 一样。示例："

#. type: delimited block -
#: en/git-interpret-trailers.txt:107
#, no-wrap, priority:100
msgid ""
"key: This is a very long value, with spaces and\n"
"  newlines in it.\n"
msgstr ""
"键: 这是个非常长的值，有空格和\n"
"  新行。\n"

#. type: Plain text
#: en/git-interpret-trailers.txt:111
#, priority:100
msgid "Note that trailers do not follow (nor are they intended to follow) many of the rules for RFC 822 headers. For example they do not follow the encoding rule."
msgstr "请注意，尾注并不遵循（也无意遵循）RFC 822 标头的许多规则。例如，它们不遵循编码规则。"

#. type: Labeled list
#: en/git-interpret-trailers.txt:114
#, ignore-same, no-wrap, priority:100
msgid "--in-place"
msgstr "--in-place"

#. type: Plain text
#: en/git-interpret-trailers.txt:116
#, priority:100
msgid "Edit the files in place."
msgstr "在原地编辑文件。"

#. type: Labeled list
#: en/git-interpret-trailers.txt:117
#, ignore-same, no-wrap, priority:100
msgid "--trim-empty"
msgstr "--trim-empty"

#. type: Plain text
#: en/git-interpret-trailers.txt:121
#, priority:100
msgid "If the <value> part of any trailer contains only whitespace, the whole trailer will be removed from the output. This applies to existing trailers as well as new trailers."
msgstr "如果任何尾注的 <值> 部分只包含空格，整个尾注将从产生的消息中被删除。 这适用于现有的尾注和新的尾注。"

#. type: Labeled list
#: en/git-interpret-trailers.txt:122
#, no-wrap, placeholders:'--trailer', priority:100
msgid "--trailer <key>[(=|:)<value>]"
msgstr "--trailer <键>[(=|:)<值>]"

#. type: Plain text
#: en/git-interpret-trailers.txt:126
#, priority:100
msgid "Specify a (<key>, <value>) pair that should be applied as a trailer to the inputs. See the description of this command."
msgstr "指定一个（<键>, <值>）对，应该作为尾注应用到输入信息中。参见此命令的描述。"

#. type: Labeled list
#: en/git-interpret-trailers.txt:127
#, no-wrap, placeholders:'--where', priority:100
msgid "--where <placement>"
msgstr "--where <位置>"

#. type: Labeled list
#: en/git-interpret-trailers.txt:128
#, ignore-same, no-wrap, priority:100
msgid "--no-where"
msgstr "--no-where"

#. type: Plain text
#: en/git-interpret-trailers.txt:137
#, placeholders:'--where':'trailer.where':'--trailer':'--where':'--no-where':'--no-where':'--where', priority:100
msgid "Specify where all new trailers will be added. A setting provided with '--where' overrides the `trailer.where` and any applicable `trailer.<keyAlias>.where` configuration variables and applies to all '--trailer' options until the next occurrence of '--where' or '--no-where'. Upon encountering '--no-where', clear the effect of any previous use of '--where', such that the relevant configuration variables are no longer overridden. Possible placements are `after`, `before`, `end` or `start`."
msgstr "指定所有新预告片的添加位置。 带有 '--where' 的设置会覆盖 `trailer.where` 和任何适用的 `trailer.<键别名>.where` 配置变量，并适用于所有 `--trailer ` 选项，直到下一次出现 `--where` 或 `--no-where` 。遇到 `--no-where` 选项时，会清除之前使用 `--where` 选项的效果，使相关配置变量不再被覆盖。可能的位置有 `after` 、`before` 、`end` 或 `start`。"

#. type: Labeled list
#: en/git-interpret-trailers.txt:138
#, no-wrap, placeholders:'--if-exists', priority:100
msgid "--if-exists <action>"
msgstr "--if-exists <行为>"

#. type: Labeled list
#: en/git-interpret-trailers.txt:139
#, ignore-same, no-wrap, priority:100
msgid "--no-if-exists"
msgstr "--no-if-exists"

#. type: Plain text
#: en/git-interpret-trailers.txt:149
#, placeholders:'--if-exists':'trailer.ifExists':'--trailer':'--if-exists':'--no-if-exists':'--no-if-exists':'--if-exists', priority:100
msgid "Specify what action will be performed when there is already at least one trailer with the same <key> in the input. A setting provided with '--if-exists' overrides the `trailer.ifExists` and any applicable `trailer.<keyAlias>.ifExists` configuration variables and applies to all '--trailer' options until the next occurrence of '--if-exists' or '--no-if-exists'. Upon encountering '--no-if-exists, clear the effect of any previous use of '--if-exists, such that the relevant configuration variables are no longer overridden. Possible actions are `addIfDifferent`, `addIfDifferentNeighbor`, `add`, `replace` and `doNothing`."
msgstr "指定当输入中已经存在至少一个具有相同 <键> 的尾注时将执行的操作。 使用 '--if-exists' 提供的设置会覆盖 `trailer.ifExists` 和任何适用的 `trailer.<键别名>.ifExists` 配置变量，并适用于所有 '--trailer' 选项，直到下一次出现 '--if-exists' 或 '--no-if-exists'。遇到 '--no-if-exists' 时，清除之前使用 '--if-exists' 的效果，使相关配置变量不再被覆盖。可能的操作包括 `addIfDifferent` 、`addIfDifferentNeighbor` 、`add` 、`replace` 和 `doNothing`。"

#. type: Labeled list
#: en/git-interpret-trailers.txt:150
#, no-wrap, placeholders:'--if-missing', priority:100
msgid "--if-missing <action>"
msgstr "--if-missing <行为>"

#. type: Labeled list
#: en/git-interpret-trailers.txt:151
#, ignore-same, no-wrap, priority:100
msgid "--no-if-missing"
msgstr "--no-if-missing"

#. type: Plain text
#: en/git-interpret-trailers.txt:161
#, placeholders:'--if-missing':'trailer.ifMissing':'--trailer':'--if-missing':'--no-if-missing':'--no-if-missing':'--if-missing', priority:100
msgid "Specify what action will be performed when there is no other trailer with the same <key> in the input. A setting provided with '--if-missing' overrides the `trailer.ifMissing` and any applicable `trailer.<keyAlias>.ifMissing` configuration variables and applies to all '--trailer' options until the next occurrence of '--if-missing' or '--no-if-missing'. Upon encountering '--no-if-missing, clear the effect of any previous use of '--if-missing, such that the relevant configuration variables are no longer overridden. Possible actions are `doNothing` or `add`."
msgstr "指定当输入中没有与 <键> 相同的其他拖车时将执行的操作。 使用 '--if-missing' 提供的设置会覆盖 'trailer.ifMissing' 和任何适用的 'trailer.<键别名>.ifMissing' 配置变量，并适用于所有 '--trailer' 选项，直到下一次出现 '--if-missing' 或 '--no-if-missing'。遇到 '--no-if-missing' 时，会清除之前使用 '--if-missing' 的效果，使相关配置变量不再被覆盖。可能的操作是 `doNothing` 或 `add`。"

#. type: Labeled list
#: en/git-interpret-trailers.txt:162
#, ignore-same, no-wrap, priority:100
msgid "--only-trailers"
msgstr "--only-trailers"

#. type: Plain text
#: en/git-interpret-trailers.txt:164
#, priority:100
msgid "Output only the trailers, not any other parts of the input."
msgstr "只输出尾注，不输出输入的任何其他部分。"

#. type: Labeled list
#: en/git-interpret-trailers.txt:165
#, ignore-same, no-wrap, priority:100
msgid "--only-input"
msgstr "--only-input"

#. type: Plain text
#: en/git-interpret-trailers.txt:169
#, priority:100
msgid "Output only trailers that exist in the input; do not add any from the command-line or by applying `trailer.*` configuration variables."
msgstr "只输出输入中存在的尾注；不从命令行或通过应用 `trailer.*` 配置变量添加任何尾注。"

#. type: Labeled list
#: en/git-interpret-trailers.txt:170
#, ignore-same, no-wrap, priority:100
msgid "--unfold"
msgstr "--unfold"

#. type: Plain text
#: en/git-interpret-trailers.txt:173
#, priority:100
msgid "If a trailer has a value that runs over multiple lines (aka \"folded\"), reformat the value into a single line."
msgstr "如果尾注中的某个值跨越多行（又称 “折叠”），则应将该值重新格式化为单行。"

#. type: Labeled list
#: en/git-interpret-trailers.txt:174
#, ignore-same, no-wrap, priority:100
msgid "--parse"
msgstr "--parse"

#. type: Plain text
#: en/git-interpret-trailers.txt:180
#, placeholders:'`--only-trailers':'--only-input':'--unfold`':'--unfold', priority:100
msgid "A convenience alias for `--only-trailers --only-input --unfold`. This makes it easier to only see the trailers coming from the input without influencing them with any command line options or configuration variables, while also making the output machine-friendly with --unfold."
msgstr "`--only-trailers--only-input--unfold` 的便利别名。这样就可以更方便地只查看来自输入的预告片，而不会受到任何命令行选项或配置变量的影响，同时还可以通过 --unfold 使输出对机器友好。"

#. type: Labeled list
#: en/git-interpret-trailers.txt:181
#, ignore-same, no-wrap, priority:100
msgid "--no-divider"
msgstr "--no-divider"

#. type: Plain text
#: en/git-interpret-trailers.txt:185
#, placeholders:'`---`':'git format-patch', priority:100
msgid "Do not treat `---` as the end of the commit message. Use this when you know your input contains just the commit message itself (and not an email or the output of `git format-patch`)."
msgstr "不要把 `---` 当作提交信息的结尾。当你知道你的输入只包含提交信息本身（而不是电子邮件或 `git format-patch` 的输出）时，请使用这个方法。"

#. type: Labeled list
#: en/git-interpret-trailers.txt:189
#, no-wrap, placeholders:'trailer.separators', priority:100
msgid "trailer.separators"
msgstr "trailer.separators"

#. type: Plain text
#: en/git-interpret-trailers.txt:194
#, priority:100
msgid "This option tells which characters are recognized as trailer separators. By default only ':' is recognized as a trailer separator, except that '=' is always accepted on the command line for compatibility with other git commands."
msgstr "这个选项告诉我们哪些字符可以被识别为尾注分隔符。默认情况下，只有 ':' 被识别为尾注分隔符，但为了与其他 git 命令兼容，命令行上总是接受 '='。"

#. type: Plain text
#: en/git-interpret-trailers.txt:198
#, priority:100
msgid "The first character given by this option will be the default character used when another separator is not specified in the config for this trailer."
msgstr "当这个尾注的配置中没有指定其他分隔符时，这个选项给出的第一个字符将是默认使用的字符。"

#. type: Plain text
#: en/git-interpret-trailers.txt:205
#, priority:100
msgid "For example, if the value for this option is \"%=$\", then only lines using the format '<key><sep><value>' with <sep> containing '%', '=' or '$' and then spaces will be considered trailers. And '%' will be the default separator used, so by default trailers will appear like: '<key>% <value>' (one percent sign and one space will appear between the key and the value)."
msgstr "例如，如果该选项的值为 \"%=$\"，那么只有使用 \"<键><分隔符><值>\" 格式（<分隔符> 包含 '%'、'=' 或 '$'，然后是空格）的行才会被视为尾注。而 '%' 将是默认使用的分隔符，因此默认情况下，预告片将显示如下：<键>% <值>'（在键和值之间会出现一个百分号和一个空格）。"

#. type: Labeled list
#: en/git-interpret-trailers.txt:206
#, no-wrap, placeholders:'trailer.where', priority:100
msgid "trailer.where"
msgstr "trailer.where"

#. type: Plain text
#: en/git-interpret-trailers.txt:208
#, priority:100
msgid "This option tells where a new trailer will be added."
msgstr "这个选项告诉人们新的尾注将被添加到哪里。"

#. type: Plain text
#: en/git-interpret-trailers.txt:210
#, priority:100
msgid "This can be `end`, which is the default, `start`, `after` or `before`."
msgstr "默认是 `end`，也可以是 `start`，`after` 或 `before`。"

#. type: Plain text
#: en/git-interpret-trailers.txt:213
#, priority:100
msgid "If it is `end`, then each new trailer will appear at the end of the existing trailers."
msgstr "如果它是 `end`，那么每个新的拖车将出现在现有拖车的末尾。"

#. type: Plain text
#: en/git-interpret-trailers.txt:216
#, priority:100
msgid "If it is `start`, then each new trailer will appear at the start, instead of the end, of the existing trailers."
msgstr "如果是 `start`，那么每个新尾注将出现在现有尾注的开端，而不是结尾。"

#. type: Plain text
#: en/git-interpret-trailers.txt:219
#, priority:100
msgid "If it is `after`, then each new trailer will appear just after the last trailer with the same <key>."
msgstr "如果是 `after`，那么每个新的尾注将出现在具有相同 <键> 的最后一个尾注之后。"

#. type: Plain text
#: en/git-interpret-trailers.txt:222
#, priority:100
msgid "If it is `before`, then each new trailer will appear just before the first trailer with the same <key>."
msgstr "如果是 `before`，那么每个新的尾注将出现在具有相同 <键> 的第一个尾注之前。"

#. type: Labeled list
#: en/git-interpret-trailers.txt:223
#, no-wrap, placeholders:'trailer.ifexists', priority:100
msgid "trailer.ifexists"
msgstr "trailer.ifexists"

#. type: Plain text
#: en/git-interpret-trailers.txt:227
#, priority:100
msgid "This option makes it possible to choose what action will be performed when there is already at least one trailer with the same <key> in the input."
msgstr "通过该选项，可以选择在输入中至少有一个相同 <键> 的尾注时将执行的操作。"

#. type: Plain text
#: en/git-interpret-trailers.txt:230
#, priority:100
msgid "The valid values for this option are: `addIfDifferentNeighbor` (this is the default), `addIfDifferent`, `add`, `replace` or `doNothing`."
msgstr "这个选项的有效值是： `addIfDifferentNeighbor`（这是默认值），`addIfDifferent`，`add`，`replace` 或 `doNothing`。"

#. type: Plain text
#: en/git-interpret-trailers.txt:234
#, priority:100
msgid "With `addIfDifferentNeighbor`, a new trailer will be added only if no trailer with the same (<key>, <value>) pair is above or below the line where the new trailer will be added."
msgstr "使用 `addIfDifferentNeighbor`，只有在没有相同（<键>, <值>）的尾注对在新尾注的上方或下方，才会添加新的尾注。"

#. type: Plain text
#: en/git-interpret-trailers.txt:237
#, priority:100
msgid "With `addIfDifferent`, a new trailer will be added only if no trailer with the same (<key>, <value>) pair is already in the input."
msgstr "使用 `addIfDifferent`，只有当信息中没有相同的（<键>, <值>）尾注时，才会添加新的尾注。"

#. type: Plain text
#: en/git-interpret-trailers.txt:240
#, priority:100
msgid "With `add`, a new trailer will be added, even if some trailers with the same (<key>, <value>) pair are already in the input."
msgstr "使用 `add`，一个新的尾注将被添加，即使一些具有相同（<键>, <值>）对的尾注已经在信息中。"

#. type: Plain text
#: en/git-interpret-trailers.txt:245
#, priority:100
msgid "With `replace`, an existing trailer with the same <key> will be deleted and the new trailer will be added. The deleted trailer will be the closest one (with the same <key>) to the place where the new one will be added."
msgstr "使用 `replace`，一个具有相同 <键> 的现有尾注将被删除，新的尾注将被添加。被删除的尾注将是离新尾注位置最近的一个（具有相同的<键>）。"

#. type: Plain text
#: en/git-interpret-trailers.txt:248
#, priority:100
msgid "With `doNothing`, nothing will be done; that is no new trailer will be added if there is already one with the same <key> in the input."
msgstr "使用 `doNothing`，将不做任何事情；也就是说，如果消息中已经有一个相同的 <键>，将不会再添加新的尾注。"

#. type: Labeled list
#: en/git-interpret-trailers.txt:249
#, no-wrap, placeholders:'trailer.ifmissing', priority:100
msgid "trailer.ifmissing"
msgstr "trailer.ifmissing"

#. type: Plain text
#: en/git-interpret-trailers.txt:253
#, priority:100
msgid "This option makes it possible to choose what action will be performed when there is not yet any trailer with the same <key> in the input."
msgstr "这个选项使我们有可能选择当信息中还没有任何具有相同 <键> 的尾注时，将执行什么行为。"

#. type: Plain text
#: en/git-interpret-trailers.txt:256
#, priority:100
msgid "The valid values for this option are: `add` (this is the default) and `doNothing`."
msgstr "这个选项的有效值是： `add`（这是默认值）和 `doNothing`。"

#. type: Plain text
#: en/git-interpret-trailers.txt:258
#, priority:100
msgid "With `add`, a new trailer will be added."
msgstr "使用 `add`，一个新的尾注将被添加。"

#. type: Plain text
#: en/git-interpret-trailers.txt:260
#, priority:100
msgid "With `doNothing`, nothing will be done."
msgstr "有了 `doNothing`，就不会有任何事情发生。"

#. type: Labeled list
#: en/git-interpret-trailers.txt:261
#, no-wrap, priority:100
msgid "trailer.<keyAlias>.key"
msgstr "trailer.<键别名>.key"

#. type: Plain text
#: en/git-interpret-trailers.txt:268
#, ignore-ellipsis, placeholders:'trailer.ack.key':'`--trailer':'`--trailer', priority:100
msgid "Defines a <keyAlias> for the <key>. The <keyAlias> must be a prefix (case does not matter) of the <key>. For example, in `git config trailer.ack.key \"Acked-by\"` the \"Acked-by\" is the <key> and the \"ack\" is the <keyAlias>. This configuration allows the shorter `--trailer \"ack:...\"` invocation on the command line using the \"ack\" <keyAlias> instead of the longer `--trailer \"Acked-by:...\"`."
msgstr "为 <键> 定义 <键别名> 。<键别名> 必须是 <键> 的前缀（大小写并不重要）。例如，在 `git config trailer.ack.key \"Acked-by\"` 中，\"Acked-by\" 是 <键>，\"ack\" 是 <键别名>。这种配置允许在命令行上使用 \"ack\" <键别名> 调用较短的 `--trailer \"ack:...\"`，而不是较长的 `--trailer \"Acked-by:...\"`。"

#. type: Plain text
#: en/git-interpret-trailers.txt:273
#, placeholders:'trailer.separators', priority:100
msgid "At the end of the <key>, a separator can appear and then some space characters. By default the only valid separator is ':', but this can be changed using the `trailer.separators` config variable."
msgstr "这个 `key` 将被用来代替尾注中的 <键>。在这个键的末端，可以出现一个分隔符，然后是一些空格字符。默认情况下，唯一有效的分隔符是 ':'，但这可以通过 `trailer.separators` 配置变量来改变。"

#. type: Plain text
#: en/git-interpret-trailers.txt:276
#, priority:100
msgid "If there is a separator in the key, then it overrides the default separator when adding the trailer."
msgstr "如果密钥中有分隔符，则在添加尾注时会覆盖默认分隔符。"

#. type: Labeled list
#: en/git-interpret-trailers.txt:277
#, no-wrap, priority:100
msgid "trailer.<keyAlias>.where"
msgstr "trailer.<键别名>.where"

#. type: Plain text
#: en/git-interpret-trailers.txt:281
#, placeholders:'trailer.where', priority:100
msgid "This option takes the same values as the 'trailer.where' configuration variable and it overrides what is specified by that option for trailers with the specified <keyAlias>."
msgstr "这个选项与 'trailer.where' 配置变量的取值相同，对于指定 <键别名> 的尾注，它覆盖了该选项所指定的内容。"

#. type: Labeled list
#: en/git-interpret-trailers.txt:282
#, no-wrap, priority:100
msgid "trailer.<keyAlias>.ifexists"
msgstr "trailer.<键别名>.ifexists"

#. type: Plain text
#: en/git-interpret-trailers.txt:286
#, placeholders:'trailer.ifexists', priority:100
msgid "This option takes the same values as the 'trailer.ifexists' configuration variable and it overrides what is specified by that option for trailers with the specified <keyAlias>."
msgstr "这个选项与 'trailer.ifexists' 配置变量的取值相同，对于具有指定 <键别名> 的尾注，它覆盖了该选项所指定的内容。"

#. type: Labeled list
#: en/git-interpret-trailers.txt:287
#, no-wrap, priority:100
msgid "trailer.<keyAlias>.ifmissing"
msgstr "trailer.<键别名>.ifmissing"

#. type: Plain text
#: en/git-interpret-trailers.txt:291
#, placeholders:'trailer.ifmissing', priority:100
msgid "This option takes the same values as the 'trailer.ifmissing' configuration variable and it overrides what is specified by that option for trailers with the specified <keyAlias>."
msgstr "这个选项与 'trailer.ifmissing' 配置变量的取值相同，对于指定 <键别名> 的尾注，它覆盖该选项所指定的内容。"

#. type: Labeled list
#: en/git-interpret-trailers.txt:292
#, no-wrap, priority:100
msgid "trailer.<keyAlias>.command"
msgstr "trailer.<键别名>.command"

#. type: Plain text
#: en/git-interpret-trailers.txt:298
#, placeholders:'$ARG', priority:100
msgid "Deprecated in favor of 'trailer.<keyAlias>.cmd'. This option behaves in the same way as 'trailer.<keyAlias>.cmd', except that it doesn't pass anything as argument to the specified command. Instead the first occurrence of substring $ARG is replaced by the <value> that would be passed as argument."
msgstr "已弃用，改用 'trailer.<键别名>.cmd'。 该选项的作用与 'trailer.<键别名>.cmd' 相同，但它不会将任何内容作为参数传递给指定的命令。 相反，子串 $ARG 的第一次出现会被作为参数传递的 <值> 所替代。"

#. type: Plain text
#: en/git-interpret-trailers.txt:301
#, placeholders:'$ARG':'$ARG', priority:100
msgid "Note that $ARG in the user's command is only replaced once and that the original way of replacing $ARG is not safe."
msgstr "请注意，用户命令中的 $ARG 只被替换一次，而原来替换 $ARG 的方法并不安全。"

#. type: Plain text
#: en/git-interpret-trailers.txt:305
#, priority:100
msgid "When both 'trailer.<keyAlias>.cmd' and 'trailer.<keyAlias>.command' are given for the same <keyAlias>, 'trailer.<keyAlias>.cmd' is used and 'trailer.<keyAlias>.command' is ignored."
msgstr "当 'trailer.<键别名>.cmd' 和 'trailer.<键别名>.command' 都是针对同一个 <键别名> 给出的时候，使用 'trailer.<键别名>.cmd'，'trailer.<键别名>.command' 被忽略。"

#. type: Labeled list
#: en/git-interpret-trailers.txt:306
#, no-wrap, priority:100
msgid "trailer.<keyAlias>.cmd"
msgstr "trailer.<键别名>.cmd"

#. type: Plain text
#: en/git-interpret-trailers.txt:311
#, placeholders:'--trailer', priority:100
msgid "This option can be used to specify a shell command that will be called once to automatically add a trailer with the specified <keyAlias>, and then called each time a '--trailer <keyAlias>=<value>' argument is specified to modify the <value> of the trailer that this option would produce."
msgstr "这个选项可以用来指定一个将被调用的shell 命令：一次自动添加一个指定的 <键别名> 的尾注，然后每次用 '--trailer <键别名>=<值>' 参数来修改这个选项将产生的尾注的 <值>。"

# ERROR: --trailer not found in translation
#. type: Plain text
#: en/git-interpret-trailers.txt:318
#, placeholders:'--trailer':'git interpret-trailers', priority:100
msgid "When the specified command is first called to add a trailer with the specified <keyAlias>, the behavior is as if a special '--trailer <keyAlias>=<value>' argument was added at the beginning of the \"git interpret-trailers\" command, where <value> is taken to be the standard output of the command with any leading and trailing whitespace trimmed off."
msgstr "当第一次调用指定的命令来添加带有指定 <token> 的尾注时，其行为就像在 \"git interpret-trailers\" 命令的开头添加了一个特殊的 '--trailer <键别名>=<值>' 参数，其中 <值> 被认为是该命令的标准输出，其前面和后面的空白被修剪掉。"

#. type: Plain text
#: en/git-interpret-trailers.txt:325
#, placeholders:'--trailer':'--trailer', priority:100
msgid "If some '--trailer <keyAlias>=<value>' arguments are also passed on the command line, the command is called again once for each of these arguments with the same <keyAlias>. And the <value> part of these arguments, if any, will be passed to the command as its first argument. This way the command can produce a <value> computed from the <value> passed in the '--trailer <keyAlias>=<value>' argument."
msgstr "如果在命令行中还传递了一些 '--trailer <键别名>=<值>' 参数，那么对于这些参数中的每一个，都会以相同的 <键别名> 再次调用该命令。而这些参数的 <值> 部分，如果有的话，将作为第一个参数传递给命令。这样，命令可以产生一个从 '--trailer <键别名>=<值>' 参数中传递的 <值> 计算出来的 <值>。"

#. type: Plain text
#: en/git-interpret-trailers.txt:331
#, priority:100
msgid "Configure a 'sign' trailer with a 'Signed-off-by' key, and then add two of these trailers to a commit message file:"
msgstr "配置带有 'Signed-off-by' 密钥的 'sign' 尾注，然后在提交信息文件中添加两个这样的尾注："

#. type: delimited block -
#: en/git-interpret-trailers.txt:336
#, no-wrap, placeholders:'trailer.sign.key':'msg.txt', priority:100
msgid ""
"$ git config trailer.sign.key \"Signed-off-by\"\n"
"$ cat msg.txt\n"
"subject\n"
msgstr ""
"$ git config trailer.sign.key \"Signed-off-by\"\n"
"$ cat msg.txt\n"
"subject\n"

#. type: delimited block -
#: en/git-interpret-trailers.txt:340
#, no-wrap, placeholders:'git interpret-trailers':'--trailer':'--trailer':'msg.txt', priority:100
msgid ""
"body text\n"
"$ git interpret-trailers --trailer 'sign: Alice <alice@example.com>' --trailer 'sign: Bob <bob@example.com>' <msg.txt\n"
"subject\n"
msgstr ""
"body text\n"
"$ git interpret-trailers --trailer 'sign: Alice <alice@example.com>' --trailer 'sign: Bob <bob@example.com>' <msg.txt\n"
"subject\n"

#. type: delimited block -
#: en/git-interpret-trailers.txt:342 en/git-interpret-trailers.txt:354 en/git-interpret-trailers.txt:361 en/git-interpret-trailers.txt:392 en/git-interpret-trailers.txt:398 en/git-interpret-trailers.txt:404 en/git-interpret-trailers.txt:439 en/git-interpret-trailers.txt:463 en/git-interpret-trailers.txt:475 en/git-interpret-trailers.txt:488
#, no-wrap, priority:100
msgid "body text\n"
msgstr "正文\n"

#. type: Plain text
#: en/git-interpret-trailers.txt:348
#, placeholders:'`--in-place`', priority:100
msgid "Use the `--in-place` option to edit a commit message file in place:"
msgstr "使用 `--in-place` 选项就地编辑提交信息文件："

#. type: delimited block -
#: en/git-interpret-trailers.txt:352 en/git-interpret-trailers.txt:473
#, no-wrap, placeholders:'msg.txt', priority:100
msgid ""
"$ cat msg.txt\n"
"subject\n"
msgstr ""
"$ cat msg.txt\n"
"subject\n"

#. type: delimited block -
#: en/git-interpret-trailers.txt:359
#, no-wrap, placeholders:'git interpret-trailers':'--trailer':'--in-place':'msg.txt':'msg.txt', priority:100
msgid ""
"Signed-off-by: Bob <bob@example.com>\n"
"$ git interpret-trailers --trailer 'Acked-by: Alice <alice@example.com>' --in-place msg.txt\n"
"$ cat msg.txt\n"
"subject\n"
msgstr ""
"Signed-off-by: Bob <bob@example.com>\n"
"$ git interpret-trailers --trailer 'Acked-by: Alice <alice@example.com>' --in-place msg.txt\n"
"$ cat msg.txt\n"
"subject\n"

#. type: delimited block -
#: en/git-interpret-trailers.txt:364
#, no-wrap, priority:100
msgid ""
"Signed-off-by: Bob <bob@example.com>\n"
"Acked-by: Alice <alice@example.com>\n"
msgstr ""
"Signed-off-by: Bob <bob@example.com>\n"
"Acked-by: Alice <alice@example.com>\n"

#. type: Plain text
#: en/git-interpret-trailers.txt:368
#, priority:100
msgid "Extract the last commit as a patch, and add a 'Cc' and a 'Reviewed-by' trailer to it:"
msgstr "将最后一次提交的内容提取为补丁，并在其中加入 'Cc' 和 'Reviewed-by' 尾注："

#. type: delimited block -
#: en/git-interpret-trailers.txt:373
#, no-wrap, placeholders:'git format-patch':'foo.patch':'git interpret-trailers':'--trailer':'--trailer':'foo.patch':'bar.patch', priority:100
msgid ""
"$ git format-patch -1\n"
"0001-foo.patch\n"
"$ git interpret-trailers --trailer 'Cc: Alice <alice@example.com>' --trailer 'Reviewed-by: Bob <bob@example.com>' 0001-foo.patch >0001-bar.patch\n"
msgstr ""
"$ git format-patch -1\n"
"0001-foo.patch\n"
"$ git interpret-trailers --trailer 'Cc: Alice <alice@example.com>' --trailer 'Reviewed-by: Bob <bob@example.com>' 0001-foo.patch >0001-bar.patch\n"

#. type: Plain text
#: en/git-interpret-trailers.txt:378
#, priority:100
msgid "Configure a 'sign' trailer with a command to automatically add a 'Signed-off-by: ' with the author information only if there is no 'Signed-off-by: ' already, and show how it works:"
msgstr "配置一个带有命令的 'sign' 拖车，只有在没有 'Signed-off-by: ' 的情况下，才会自动添加带有作者信息的 'Signed-off-by: ' ，以下展示它是如何工作的："

#. type: delimited block -
#: en/git-interpret-trailers.txt:382
#, no-wrap, priority:100
msgid ""
"$ cat msg1.txt\n"
"subject\n"
msgstr ""
"$ cat msg1.txt\n"
"subject\n"

#. type: delimited block -
#: en/git-interpret-trailers.txt:390
#, no-wrap, placeholders:'trailer.sign.key':'trailer.sign.ifmissing':'trailer.sign.ifexists':'trailer.sign.cmd':'user.name':'user.email':'git interpret-trailers':'--trailer', priority:100
msgid ""
"body text\n"
"$ git config trailer.sign.key \"Signed-off-by: \"\n"
"$ git config trailer.sign.ifmissing add\n"
"$ git config trailer.sign.ifexists doNothing\n"
"$ git config trailer.sign.cmd 'echo \"$(git config user.name) <$(git config user.email)>\"'\n"
"$ git interpret-trailers --trailer sign <msg1.txt\n"
"subject\n"
msgstr ""
"body text\n"
"$ git config trailer.sign.key \"Signed-off-by: \"\n"
"$ git config trailer.sign.ifmissing add\n"
"$ git config trailer.sign.ifexists doNothing\n"
"$ git config trailer.sign.cmd 'echo \"$(git config user.name) <$(git config user.email)>\"'\n"
"$ git interpret-trailers --trailer sign <msg1.txt\n"
"主题\n"

#. type: delimited block -
#: en/git-interpret-trailers.txt:396
#, no-wrap, priority:100
msgid ""
"Signed-off-by: Bob <bob@example.com>\n"
"$ cat msg2.txt\n"
"subject\n"
msgstr ""
"Signed-off-by: Bob <bob@example.com>\n"
"$ cat msg2.txt\n"
"subject\n"

#. type: delimited block -
#: en/git-interpret-trailers.txt:402
#, no-wrap, placeholders:'git interpret-trailers':'--trailer', priority:100
msgid ""
"Signed-off-by: Alice <alice@example.com>\n"
"$ git interpret-trailers --trailer sign <msg2.txt\n"
"subject\n"
msgstr ""
"Signed-off-by: Alice <alice@example.com>\n"
"$ git interpret-trailers --trailer sign <msg2.txt\n"
"subject\n"

#. type: delimited block -
#: en/git-interpret-trailers.txt:406
#, no-wrap, priority:100
msgid "Signed-off-by: Alice <alice@example.com>\n"
msgstr "Signed-off-by: Alice <alice@example.com>\n"

#. type: Plain text
#: en/git-interpret-trailers.txt:410
#, priority:100
msgid "Configure a 'fix' trailer with a key that contains a '#' and no space after this character, and show how it works:"
msgstr "配置一个 'fix' 尾注，其关键是包含一个 '#'，并且这个字符后面没有空格，以下展示它是如何工作的："

#. type: delimited block -
#: en/git-interpret-trailers.txt:416
#, no-wrap, placeholders:'trailer.separators':'trailer.fix.key':'git interpret-trailers':'--trailer', priority:100
msgid ""
"$ git config trailer.separators \":#\"\n"
"$ git config trailer.fix.key \"Fix #\"\n"
"$ echo \"subject\" | git interpret-trailers --trailer fix=42\n"
"subject\n"
msgstr ""
"$ git config trailer.separators \":#\"\n"
"$ git config trailer.fix.key \"Fix #\"\n"
"$ echo \"subject\" | git interpret-trailers --trailer fix=42\n"
"subject\n"

#. type: delimited block -
#: en/git-interpret-trailers.txt:418
#, no-wrap, priority:100
msgid "Fix #42\n"
msgstr "Fix #42\n"

#. type: Plain text
#: en/git-interpret-trailers.txt:423
#, priority:100
msgid "Configure a 'help' trailer with a cmd use a script `glog-find-author` which search specified author identity from git log in git repository and show how it works:"
msgstr "在 cmd 中使用脚本 `glog-find-author` 配置一个 'help' 尾注，从 git 仓库的 git日志中搜索指定的作者身份，以下展示它是如何工作的："

#. type: delimited block -
#: en/git-interpret-trailers.txt:430
#, no-wrap, placeholders:'--author=':'--pretty=':'msg.txt', priority:100
msgid ""
"$ cat ~/bin/glog-find-author\n"
"#!/bin/sh\n"
"test -n \"$1\" && git log --author=\"$1\" --pretty=\"%an <%ae>\" -1 || true\n"
"$ cat msg.txt\n"
"subject\n"
msgstr ""
"$ cat ~/bin/glog-find-author\n"
"#!/bin/sh\n"
"test -n \"$1\" && git log --author=\"$1\" --pretty=\"%an <%ae>\" -1 || true\n"
"$ cat msg.txt\n"
"subject\n"

#. type: delimited block -
#: en/git-interpret-trailers.txt:437
#, no-wrap, placeholders:'trailer.help.key':'trailer.help.ifExists':'trailer.help.cmd':'git interpret-trailers':'--trailer=':'--trailer=':'msg.txt', priority:100
msgid ""
"body text\n"
"$ git config trailer.help.key \"Helped-by: \"\n"
"$ git config trailer.help.ifExists \"addIfDifferentNeighbor\"\n"
"$ git config trailer.help.cmd \"~/bin/glog-find-author\"\n"
"$ git interpret-trailers --trailer=\"help:Junio\" --trailer=\"help:Couder\" <msg.txt\n"
"subject\n"
msgstr ""
"body text\n"
"$ git config trailer.help.key \"Helped-by: \"\n"
"$ git config trailer.help.ifExists \"addIfDifferentNeighbor\"\n"
"$ git config trailer.help.cmd \"~/bin/glog-find-author\"\n"
"$ git interpret-trailers --trailer=\"help:Junio\" --trailer=\"help:Couder\" <msg.txt\n"
"subject\n"

#. type: delimited block -
#: en/git-interpret-trailers.txt:442
#, no-wrap, placeholders:'pobox.com':'christian.couder':'gmail.com', priority:100
msgid ""
"Helped-by: Junio C Hamano <gitster@pobox.com>\n"
"Helped-by: Christian Couder <christian.couder@gmail.com>\n"
msgstr ""
"Helped-by: Junio C Hamano <gitster@pobox.com>\n"
"Helped-by: Christian Couder <christian.couder@gmail.com>\n"

#. type: Plain text
#: en/git-interpret-trailers.txt:447
#, priority:100
msgid "Configure a 'ref' trailer with a cmd use a script `glog-grep` to grep last relevant commit from git log in the git repository and show how it works:"
msgstr "在 cmd 中用脚本 `glog-grep` 从git仓库的git日志中搜索最后一次相关的提交并配置一个 'ref' 尾注，以下展示它是如何工作的："

#. type: delimited block -
#: en/git-interpret-trailers.txt:454
#, no-wrap, placeholders:'--grep':'--pretty=reference':'msg.txt', priority:100
msgid ""
"$ cat ~/bin/glog-grep\n"
"#!/bin/sh\n"
"test -n \"$1\" && git log --grep \"$1\" --pretty=reference -1 || true\n"
"$ cat msg.txt\n"
"subject\n"
msgstr ""
"$ cat ~/bin/glog-grep\n"
"#!/bin/sh\n"
"test -n \"$1\" && git log --grep \"$1\" --pretty=reference -1 || true\n"
"$ cat msg.txt\n"
"subject\n"

#. type: delimited block -
#: en/git-interpret-trailers.txt:461
#, no-wrap, placeholders:'trailer.ref.key':'trailer.ref.ifExists':'trailer.ref.cmd':'git interpret-trailers':'--trailer=':'msg.txt', priority:100
msgid ""
"body text\n"
"$ git config trailer.ref.key \"Reference-to: \"\n"
"$ git config trailer.ref.ifExists \"replace\"\n"
"$ git config trailer.ref.cmd \"~/bin/glog-grep\"\n"
"$ git interpret-trailers --trailer=\"ref:Add copyright notices.\" <msg.txt\n"
"subject\n"
msgstr ""
"body text\n"
"$ git config trailer.ref.key \"Reference-to: \"\n"
"$ git config trailer.ref.ifExists \"replace\"\n"
"$ git config trailer.ref.cmd \"~/bin/glog-grep\"\n"
"$ git interpret-trailers --trailer=\"ref:Add copyright notices.\" <msg.txt\n"
"subject\n"

#. type: delimited block -
#: en/git-interpret-trailers.txt:465
#, no-wrap, priority:100
msgid "Reference-to: 8bc9a0c769 (Add copyright notices., 2005-04-07)\n"
msgstr "Reference-to: 8bc9a0c769 (Add copyright notices., 2005-04-07)\n"

#. type: Plain text
#: en/git-interpret-trailers.txt:469
#, priority:100
msgid "Configure a 'see' trailer with a command to show the subject of a commit that is related, and show how it works:"
msgstr "配置一个带有命令的 'see' 尾注，以显示相关提交的主题，以下展示它是如何工作的："

#. type: delimited block -
#: en/git-interpret-trailers.txt:486
#, no-wrap, placeholders:'HEAD':'--oneline':'--format=':'--abbrev-commit':'--abbrev=14':'trailer.see.key':'trailer.see.ifExists':'trailer.see.ifMissing':'trailer.see.cmd':'git interpret-trailers':'--trailer=see':'msg.txt', priority:100
msgid ""
"see: HEAD~2\n"
"$ cat ~/bin/glog-ref\n"
"#!/bin/sh\n"
"git log -1 --oneline --format=\"%h (%s)\" --abbrev-commit --abbrev=14\n"
"$ git config trailer.see.key \"See-also: \"\n"
"$ git config trailer.see.ifExists \"replace\"\n"
"$ git config trailer.see.ifMissing \"doNothing\"\n"
"$ git config trailer.see.cmd \"glog-ref\"\n"
"$ git interpret-trailers --trailer=see <msg.txt\n"
"subject\n"
msgstr ""
"see: HEAD~2\n"
"$ cat ~/bin/glog-ref\n"
"#!/bin/sh\n"
"git log -1 --oneline --format=\"%h (%s)\" --abbrev-commit --abbrev=14\n"
"$ git config trailer.see.key \"See-also: \"\n"
"$ git config trailer.see.ifExists \"replace\"\n"
"$ git config trailer.see.ifMissing \"doNothing\"\n"
"$ git config trailer.see.cmd \"glog-ref\"\n"
"$ git interpret-trailers --trailer=see <msg.txt\n"
"subject\n"

#. type: delimited block -
#: en/git-interpret-trailers.txt:490
#, no-wrap, priority:100
msgid "See-also: fe3187489d69c4 (subject of related commit)\n"
msgstr "See-also: fe3187489d69c4 (subject of related commit)\n"

#. type: Plain text
#: en/git-interpret-trailers.txt:497
#, placeholders:'git interpret-trailers':'git-version', priority:100
msgid "Configure a commit template with some trailers with empty values (using sed to show and keep the trailing spaces at the end of the trailers), then configure a commit-msg hook that uses 'git interpret-trailers' to remove trailers with empty values and to add a 'git-version' trailer:"
msgstr "配置一个带有一些空尾注的提交模板（使用 sed 来显示并保留尾注末尾的空格），然后配置一个 commit-msg 钩子，使用 'git interpret-trailers' 来移除空值尾注，并添加一个 'git-version' 尾注："

#. type: delimited block -
#: en/git-interpret-trailers.txt:501
#, no-wrap, placeholders:'temp.txt', priority:100
msgid ""
"$ cat temp.txt\n"
"***subject***\n"
msgstr ""
"$ cat temp.txt\n"
"***subject***\n"

#. type: delimited block -
#: en/git-interpret-trailers.txt:503
#, no-wrap, priority:100
msgid "***message***\n"
msgstr "***消息***\n"

#. type: delimited block -
#: en/git-interpret-trailers.txt:515
#, no-wrap, placeholders:'temp.txt':'commit_template':'commit.template':'commit_template':'git interpret-trailers':'--trim-empty':'--trailer':'git-version', priority:100
msgid ""
"Fixes: Z\n"
"Cc: Z\n"
"Reviewed-by: Z\n"
"Signed-off-by: Z\n"
"$ sed -e 's/ Z$/ /' temp.txt > commit_template.txt\n"
"$ git config commit.template commit_template.txt\n"
"$ cat .git/hooks/commit-msg\n"
"#!/bin/sh\n"
"git interpret-trailers --trim-empty --trailer \"git-version: \\$(git describe)\" \"\\$1\" > \"\\$1.new\"\n"
"mv \"\\$1.new\" \"\\$1\"\n"
"$ chmod +x .git/hooks/commit-msg\n"
msgstr ""
"Fixes: Z\n"
"Cc: Z\n"
"Reviewed-by: Z\n"
"Signed-off-by: Z\n"
"$ sed -e 's/ Z$/ /' temp.txt > commit_template.txt\n"
"$ git config commit.template commit_template.txt\n"
"$ cat .git/hooks/commit-msg\n"
"#!/bin/sh\n"
"git interpret-trailers --trim-empty --trailer \"git-version: \\$(git describe)\" \"\\$1\" > \"\\$1.new\"\n"
"mv \"\\$1.new\" \"\\$1\"\n"
"$ chmod +x .git/hooks/commit-msg\n"

#. type: Plain text
#: en/git-interpret-trailers.txt:520
#, ignore-same, priority:100
msgid "linkgit:git-commit[1], linkgit:git-format-patch[1], linkgit:git-config[1]"
msgstr "linkgit:git-commit[1], linkgit:git-format-patch[1], linkgit:git-config[1]"

#. type: Title =
#: en/git-log.txt:2
#, ignore-same, no-wrap, priority:260
msgid "git-log(1)"
msgstr "git-log(1)"

#. type: Plain text
#: en/git-log.txt:7
#, placeholders:'git-log', priority:260
msgid "git-log - Show commit logs"
msgstr "git-log - 显示提交日志"

#. type: Plain text
#: en/git-log.txt:13
#, ignore-ellipsis, no-wrap, priority:260
msgid "'git log' [<options>] [<revision-range>] [[--] <path>...]\n"
msgstr "'git log' [<options>] [<revision-range>] [[--] <path>...]\n"

#. type: Plain text
#: en/git-log.txt:17
#, priority:260
msgid "Shows the commit logs."
msgstr "显示提交日志。"

#. type: Plain text
#: en/git-log.txt:25
#, placeholders:'linkgit:git-rev-list[1]':'linkgit:git-diff[1]', priority:260
msgid "The command takes options applicable to the linkgit:git-rev-list[1] command to control what is shown and how, and options applicable to the linkgit:git-diff[1] command to control how the changes each commit introduces are shown."
msgstr "该命令采用适用于 linkgit:git-rev-list[1] 命令的选项来控制显示的内容和方式，以及适用于 linkgit:git-diff[1] 命令的选项来控制每次提交引入的更改的显示方式。"

#. type: Labeled list
#: en/git-log.txt:30
#, ignore-same, no-wrap, priority:260
msgid "--follow"
msgstr "--follow"

#. type: Plain text
#: en/git-log.txt:33
#, priority:260
msgid "Continue listing the history of a file beyond renames (works only for a single file)."
msgstr "继续列出文件的历史记录，包括重命名之后的情况（仅适用于单个文件）。"

#. type: Labeled list
#: en/git-log.txt:34
#, ignore-same, no-wrap, priority:260
msgid "--no-decorate"
msgstr "--no-decorate"

#. type: Labeled list
#: en/git-log.txt:35
#, ignore-same, no-wrap, priority:260
msgid "--decorate[=short|full|auto|no]"
msgstr "--decorate[=short|full|auto|no]"

#. type: Plain text
#: en/git-log.txt:45
#, placeholders:'`--decorate`':'`--decorate=short`':'log.decorate', priority:260
msgid "Print out the ref names of any commits that are shown. If 'short' is specified, the ref name prefixes 'refs/heads/', 'refs/tags/' and 'refs/remotes/' will not be printed. If 'full' is specified, the full ref name (including prefix) will be printed. If 'auto' is specified, then if the output is going to a terminal, the ref names are shown as if 'short' were given, otherwise no ref names are shown. The option `--decorate` is short-hand for `--decorate=short`. Default to configuration value of `log.decorate` if configured, otherwise, `auto`."
msgstr "打印显示的任何提交的引用名称。如果指定了 \"short\"，则不会打印引用名称的前缀 \"refs/heads/\"、\"refs/tags/\" 和 \"refs/remotes/\"。如果指定了 \"full\"，将打印完整的引用名称（包括前缀）。如果指定了 \"auto\"，则如果输出是发送到终端，则显示引用名称，就如同指定了\"short\"一样，否则不显示引用名称。选项 `--decorate` 是 `--decorate=short` 的简写。如果配置了 `log.decorate` 的配置值，默认为配置值，否则为 \"auto\"。"

#. type: Labeled list
#: en/git-log.txt:46
#, no-wrap, placeholders:'--decorate-refs=', priority:260
msgid "--decorate-refs=<pattern>"
msgstr "--decorate-refs=<pattern>"

#. type: Labeled list
#: en/git-log.txt:47
#, no-wrap, placeholders:'--decorate-refs-exclude=', priority:260
msgid "--decorate-refs-exclude=<pattern>"
msgstr "--decorate-refs-exclude=<pattern>"

#. type: Plain text
#: en/git-log.txt:54
#, placeholders:'`--decorate-refs-exclude`':'`--decorate-refs`':'log.excludeDecoration':'`--decorate-refs`':'log.excludeDecoration', priority:260
msgid "For each candidate reference, do not use it for decoration if it matches any patterns given to `--decorate-refs-exclude` or if it doesn't match any of the patterns given to `--decorate-refs`. The `log.excludeDecoration` config option allows excluding refs from the decorations, but an explicit `--decorate-refs` pattern will override a match in `log.excludeDecoration`."
msgstr "对于每个候选引用，在以下情况下不要将其用于装饰（decorate）：若它与`--decorate-refs-exclude`指定的任何模式匹配，或者若它不与`--decorate-refs`指定的任何模式匹配。配置选项`log.excludeDecoration`允许从装饰中排除引用，但是在`log.excludeDecoration`中的匹配项将被`--decorate-refs`模式中的显式指定所覆盖。"

#. type: Plain text
#: en/git-log.txt:58
#, placeholders:'HEAD', priority:260
msgid "If none of these options or config settings are given, then references are used as decoration if they match `HEAD`, `refs/heads/`, `refs/remotes/`, `refs/stash/`, or `refs/tags/`."
msgstr "如果没有给出这些选项或配置设置中的任何一个，那么如果引用与 `HEAD` 、`refs/heads/`、`refs/remotes/` 、`refs/stash/` 或 `refs/tags/` 匹配，则使用引用作为装饰。"

#. type: Labeled list
#: en/git-log.txt:59
#, ignore-same, no-wrap, priority:260
msgid "--clear-decorations"
msgstr "--clear-decorations"

#. type: Plain text
#: en/git-log.txt:65
#, placeholders:'`--decorate-refs`':'`--decorate-refs-exclude`':'log.initialDecorationSet', priority:260
msgid "When specified, this option clears all previous `--decorate-refs` or `--decorate-refs-exclude` options and relaxes the default decoration filter to include all references. This option is assumed if the config value `log.initialDecorationSet` is set to `all`."
msgstr "当指定了该选项时，它会清除所有先前的 `--decorate-refs` 或 `--decorate-refs-exclude` 选项，并放宽默认的装饰过滤器以包括所有引用。如果配置值 `log.initialDecorationSet` 设置为 `all`，则假定使用此选项。"

#. type: Labeled list
#: en/git-log.txt:66
#, ignore-same, no-wrap, priority:260
msgid "--source"
msgstr "--source"

#. type: Plain text
#: en/git-log.txt:69
#, priority:260
msgid "Print out the ref name given on the command line by which each commit was reached."
msgstr "打印出通过命令行给定的引用名称，以便触及每个提交。"

#. type: Plain text
#: en/git-log.txt:75
#, placeholders:'linkgit:git-shortlog[1]', priority:260
msgid "Use mailmap file to map author and committer names and email addresses to canonical real names and email addresses. See linkgit:git-shortlog[1]."
msgstr "使用 mailmap 文件将作者和提交者的名称和电子邮件地址映射到规范的真实名称和电子邮件地址。请参阅 linkgit:git-shortlog[1]。"

#. type: Labeled list
#: en/git-log.txt:76
#, ignore-same, no-wrap, priority:260
msgid "--full-diff"
msgstr "--full-diff"

#. type: Plain text
#: en/git-log.txt:82
#, ignore-ellipsis, priority:260
msgid "Without this flag, `git log -p <path>...` shows commits that touch the specified paths, and diffs about the same specified paths. With this, the full diff is shown for commits that touch the specified paths; this means that \"<path>...\" limits only commits, and doesn't limit diff for those commits."
msgstr "如果不使用此标志， `git log -p <path>...` 将显示与指定路径相关的提交，并显示关于相同指定路径的差异。使用此标志，将显示与指定路径相关的提交的完整差异；这意味着 \"<path>...\" 将仅限定提交，并不限定这些提交的差异。"

#. type: Plain text
#: en/git-log.txt:85
#, placeholders:'`--stat`', priority:260
msgid "Note that this affects all diff-based output types, e.g. those produced by `--stat`, etc."
msgstr "请注意，这会影响所有基于差异的输出类型。例如：由 `--stat` 等产生的输出。"

#. type: Labeled list
#: en/git-log.txt:86
#, ignore-same, no-wrap, priority:260
msgid "--log-size"
msgstr "--log-size"

#. type: Plain text
#: en/git-log.txt:91
#, priority:260
msgid "Include a line ``log size <number>'' in the output for each commit, where <number> is the length of that commit's message in bytes. Intended to speed up tools that read log messages from `git log` output by allowing them to allocate space in advance."
msgstr "在每个提交的输出中包含一行 ``log size <number>\"\" ，其中 <number> 是该提交消息的字节长度。旨在通过允许工具预先分配空间，加快从 `git log` 输出中读取日志消息的工具的速度。"

#. type: Labeled list
#: en/git-log.txt:94 en/git-shortlog.txt:100
#, no-wrap, priority:260
msgid "<revision-range>"
msgstr "<revision-range>"

#. type: Plain text
#: en/git-log.txt:102
#, placeholders:'HEAD':'HEAD':'HEAD':'linkgit:gitrevisions[7]', priority:260
msgid "Show only commits in the specified revision range. When no <revision-range> is specified, it defaults to `HEAD` (i.e. the whole history leading to the current commit). `origin..HEAD` specifies all the commits reachable from the current commit (i.e. `HEAD`), but not from `origin`. For a complete list of ways to spell <revision-range>, see the 'Specifying Ranges' section of linkgit:gitrevisions[7]."
msgstr "仅显示指定修订范围内的提交。当没有指定 <revision-range> 时，默认为 `HEAD`（即导致当前提交的整个历史记录）。`origin..HEAD` 指定从当前提交（即 `HEAD` ）可达的所有提交，但不包括从 `origin` 可达的提交。有关拼写 <revision-range> 的完整列表，请参阅 linkgit:gitrevisions[7] 的 \"Specifying Ranges\" 部分。"

#. type: Labeled list
#: en/git-log.txt:103 en/git-shortlog.txt:109
#, ignore-ellipsis, no-wrap, priority:260
msgid "[--] <path>..."
msgstr "[--] <path>..."

#. type: Plain text
#: en/git-log.txt:108
#, priority:260
msgid "Show only commits that are enough to explain how the files that match the specified paths came to be. See 'History Simplification' below for details and other simplification modes."
msgstr "只显示那些足以解释符合指定路径的文件是如何形成的提交。 有关细节和其他简化模式，请参见下面的'历史简化'。"

#. type: Plain text
#: en/git-log.txt:111 en/git-shortlog.txt:115
#, priority:260
msgid "Paths may need to be prefixed with `--` to separate them from options or the revision range, when confusion arises."
msgstr "当出现混淆时，路径可能需要以`--`为前缀，以便将其与选项或修订范围分开。"

#. type: Title -
#: en/git-log.txt:117 en/git-show.txt:49
#, no-wrap, priority:260
msgid "DIFF FORMATTING"
msgstr "差异格式化"

#. type: Plain text
#: en/git-log.txt:121
#, priority:260
msgid "By default, `git log` does not generate any diff output. The options below can be used to show the changes made by each commit."
msgstr "默认情况下，`git log`不会产生任何差异输出。下面的选项可以用来显示每次提交所做的修改。"

# ERROR: --cc not found in translation
# ERROR: --first-parent not found in translation
#. type: Plain text
#: en/git-log.txt:128
#, placeholders:'`--diff-merges`':'`-m`':'`-c`':'`--cc`':'`--dd`':'`--patch`':'`-S`':'`--first-parent`', priority:260
msgid "Note that unless one of `--diff-merges` variants (including short `-m`, `-c`, `--cc`, and `--dd` options) is explicitly given, merge commits will not show a diff, even if a diff format like `--patch` is selected, nor will they match search options like `-S`. The exception is when `--first-parent` is in use, in which case `first-parent` is the default format for merge commits."
msgstr "请注意，除非明确给出了 `--diff-merges` 变体（包括短 `-m`、`-c`、`--cc` 和 `--dd` 选项），否则合并提交不会显示差异，即使选择了 `--patch` 等差异格式，也不会匹配 `-S` 等搜索选项。使用 `--first-parent` 时例外，在这种情况下，`--first-parent` 是合并提交的默认格式。"

#. type: Labeled list
#: en/git-log.txt:137
#, no-wrap, placeholders:'--no-merges`', priority:260
msgid "`git log --no-merges`"
msgstr "`git log --no-merges`"

#. type: Plain text
#: en/git-log.txt:140
#, priority:260
msgid "Show the whole commit history, but skip any merges"
msgstr "显示整个提交历史，但跳过任何合并内容"

#. type: Labeled list
#: en/git-log.txt:141
#, no-wrap, priority:260
msgid "`git log v2.6.12.. include/scsi drivers/scsi`"
msgstr "`git log v2.6.12.. include/scsi drivers/scsi`"

#. type: Plain text
#: en/git-log.txt:145
#, priority:260
msgid "Show all commits since version 'v2.6.12' that changed any file in the `include/scsi` or `drivers/scsi` subdirectories"
msgstr "显示自版本 'v2.6.12' 以来改变 `include/scsi` 或 `drivers/scsi` 子目录中任何文件的所有提交"

#. type: Labeled list
#: en/git-log.txt:146
#, no-wrap, placeholders:'--since=', priority:260
msgid "`git log --since=\"2 weeks ago\" -- gitk`"
msgstr "`git log --since=\"2 weeks ago\" -- gitk`"

#. type: Plain text
#: en/git-log.txt:151
#, priority:260
msgid "Show the changes during the last two weeks to the file 'gitk'. The `--` is necessary to avoid confusion with the *branch* named 'gitk'"
msgstr "显示过去两周内对文件 'gitk' 的修改。 `--` 是必要的，以避免与名为 'gitk' 的 *分支* 相混淆"

#. type: Labeled list
#: en/git-log.txt:152
#, no-wrap, placeholders:'--name-status', priority:260
msgid "`git log --name-status release..test`"
msgstr "`git log --name-status release..test`"

#. type: Plain text
#: en/git-log.txt:157
#, priority:260
msgid "Show the commits that are in the \"test\" branch but not yet in the \"release\" branch, along with the list of paths each commit modifies."
msgstr "显示在 \"test \"分支中但尚未在 \"release \"分支中的提交，以及每个提交修改的路径列表。"

#. type: Labeled list
#: en/git-log.txt:158
#, no-wrap, placeholders:'--follow', priority:260
msgid "`git log --follow builtin/rev-list.c`"
msgstr "`git log --follow builtin/rev-list.c`"

#. type: Plain text
#: en/git-log.txt:163
#, priority:260
msgid "Shows the commits that changed `builtin/rev-list.c`, including those commits that occurred before the file was given its present name."
msgstr "显示改变`builtin/rev-list.c`的提交，包括那些在文件被赋予现在名字之前发生的提交。"

#. type: Labeled list
#: en/git-log.txt:164
#, no-wrap, placeholders:'--branches':'--not':'--remotes=origin`', priority:260
msgid "`git log --branches --not --remotes=origin`"
msgstr "`git log --branches --not --remotes=origin`"

#. type: Plain text
#: en/git-log.txt:169
#, priority:260
msgid "Shows all commits that are in any of local branches but not in any of remote-tracking branches for 'origin' (what you have that origin doesn't)."
msgstr "显示所有在本地分支中但不在 \"origin \"的远程跟踪分支中的提交（你有而origin没有的东西）。"

#. type: Labeled list
#: en/git-log.txt:170
#, no-wrap, placeholders:'--not':'--remotes=', priority:260
msgid "`git log master --not --remotes=*/master`"
msgstr "`git log master --not --remotes=*/master`"

#. type: Plain text
#: en/git-log.txt:174
#, priority:260
msgid "Shows all commits that are in local master but not in any remote repository master branches."
msgstr "显示所有在本地主库但不在任何远程仓库主库分支中的提交。"

#. type: Labeled list
#: en/git-log.txt:175
#, no-wrap, placeholders:'--first-parent`', priority:260
msgid "`git log -p -m --first-parent`"
msgstr "`git log -p -m --first-parent`"

#. type: Plain text
#: en/git-log.txt:182
#, priority:260
msgid "Shows the history including change diffs, but only from the ``main branch'' perspective, skipping commits that come from merged branches, and showing full diffs of changes introduced by the merges. This makes sense only when following a strict policy of merging all topic branches when staying on a single integration branch."
msgstr "显示包括变化差异的历史，但只从 \"主分支 \"的角度，跳过来自合并分支的提交，并显示合并带来的全部变化差异。 这只有在遵循严格的政策，在停留在一个集成分支时合并所有主题分支时才有意义。"

#. type: Labeled list
#: en/git-log.txt:183
#, no-wrap, priority:260
msgid "`git log -L '/int main/',/^}/:main.c`"
msgstr "`git log -L '/int main/',/^}/:main.c`"

#. type: Plain text
#: en/git-log.txt:187
#, priority:260
msgid "Shows how the function `main()` in the file `main.c` evolved over time."
msgstr "显示了文件`main.c`中的函数`main()`是如何随时间演变的。"

#. type: Labeled list
#: en/git-log.txt:188
#, no-wrap, priority:260
msgid "`git log -3`"
msgstr "`git log -3`"

#. type: Plain text
#: en/git-log.txt:191
#, priority:260
msgid "Limits the number of commits to show to 3."
msgstr "将显示的提交数量限制在3个。"

#. type: Plain text
#: en/git-log.txt:202
#, placeholders:'linkgit:git-config[1]':'linkgit:git-diff[1]', priority:260
msgid "See linkgit:git-config[1] for core variables and linkgit:git-diff[1] for settings related to diff generation."
msgstr "核心变量见 linkgit:git-config[1] ，与 diff 生成相关的设置见 linkgit:git-diff[1] 。"

#. type: Labeled list
#: en/git-log.txt:203
#, ignore-same, no-wrap, priority:260
msgid "format.pretty"
msgstr "format.pretty"

#. type: Plain text
#: en/git-log.txt:206
#, placeholders:'`--format`', priority:260
msgid "Default for the `--format` option. (See 'Pretty Formats' above.) Defaults to `medium`."
msgstr "`--format`选项的默认值。 (见上面的 \"漂亮的格式\"。)默认为 \"中等\"。"

#. type: Labeled list
#: en/git-log.txt:207
#, ignore-same, no-wrap, priority:260
msgid "i18n.logOutputEncoding"
msgstr "i18n.logOutputEncoding"

#. type: Plain text
#: en/git-log.txt:211
#, priority:260
msgid "Encoding to use when displaying logs. (See 'Discussion' above.) Defaults to the value of `i18n.commitEncoding` if set, and UTF-8 otherwise."
msgstr "显示日志时要使用的编码。 (见上面的 \"讨论\"。)如果设置了，默认为`i18n.commitEncoding`的值，否则为UTF-8。"

#. type: Title =
#: en/git-ls-files.txt:2
#, ignore-same, no-wrap, priority:80
msgid "git-ls-files(1)"
msgstr "git-ls-files(1)"

#. type: Plain text
#: en/git-ls-files.txt:7
#, placeholders:'git-ls-files', priority:80
msgid "git-ls-files - Show information about files in the index and the working tree"
msgstr "git-ls-files - 显示索引和工作目录树中的文件信息"

#. type: Plain text
#: en/git-ls-files.txt:25
#, ignore-ellipsis, no-wrap, placeholders:'git ls-files':'--cached]':'--deleted]':'--others]':'--ignored]':'--stage]':'--unmerged]':'--killed]':'--modified]':'[--resolve-undo]':'[--directory':'[--no-empty-directory]':'[--eol]':'[--deduplicate]':'--exclude=':'--exclude-from=':'[--exclude-per-directory=':'[--exclude-standard]':'[--error-unmatch]':'[--with-tree=':'[--full-name]':'[--recurse-submodules]':'[--abbrev':'[--format=', priority:80
msgid ""
"'git ls-files' [-z] [-t] [-v] [-f]\n"
"\t\t[-c|--cached] [-d|--deleted] [-o|--others] [-i|--ignored]\n"
"\t\t[-s|--stage] [-u|--unmerged] [-k|--killed] [-m|--modified]\n"
"\t\t[--resolve-undo]\n"
"\t\t[--directory [--no-empty-directory]] [--eol]\n"
"\t\t[--deduplicate]\n"
"\t\t[-x <pattern>|--exclude=<pattern>]\n"
"\t\t[-X <file>|--exclude-from=<file>]\n"
"\t\t[--exclude-per-directory=<file>]\n"
"\t\t[--exclude-standard]\n"
"\t\t[--error-unmatch] [--with-tree=<tree-ish>]\n"
"\t\t[--full-name] [--recurse-submodules]\n"
"\t\t[--abbrev[=<n>]] [--format=<format>] [--] [<file>...]\n"
msgstr ""
"'git ls-files' [-z] [-t] [-v] [-f]\n"
"\t\t[-c|--cached] [-d|--deleted] [-o|--others] [-i|--ignored]\n"
"\t\t[-s|--stage] [-u|--unmerged] [-k|--killed] [-m|--modified]\n"
"\t\t[--resolve-undo]\n"
"\t\t[--directory [--no-empty-directory]] [--eol]\n"
"\t\t[--deduplicate]\n"
"\t\t[-x <模式>|--exclude=<模式>]\n"
"\t\t[-X <文件>|--exclude-from=<文件>]\n"
"\t\t[--exclude-per-directory=<文件>]\n"
"\t\t[--exclude-standard]\n"
"\t\t[--error-unmatch] [--with-tree=<树状对象>]\n"
"\t\t[--full-name] [--recurse-submodules]\n"
"\t\t[--abbrev[=<n>]] [--format=<格式>] [--] [<文件>...]\n"

#. type: Plain text
#: en/git-ls-files.txt:30
#, priority:80
msgid "This command merges the file listing in the index with the actual working directory list, and shows different combinations of the two."
msgstr "该命令将索引中的文件列表与实际工作目录列表合并，并显示两者的不同组合。"

#. type: Plain text
#: en/git-ls-files.txt:35
#, priority:80
msgid "Several flags can be used to determine which files are shown, and each file may be printed multiple times if there are multiple entries in the index or if multiple statuses are applicable for the relevant file selection options."
msgstr "如果索引中有多个条目，或者相关文件选择选项有多个状态，则每个文件可以打印多次。"

#. type: Plain text
#: en/git-ls-files.txt:43
#, placeholders:'--resolve-undo', priority:80
msgid "Show all files cached in Git's index, i.e. all tracked files. (This is the default if no -c/-s/-d/-o/-u/-k/-m/--resolve-undo options are specified.)"
msgstr "显示 Git 索引中缓存的所有文件，即所有被跟踪的文件。 (如果没有指定 -c/-s/-d/-o/-u/-k/-m/--resolve-undo 选项，默认情况下是这样。）"

#. type: Labeled list
#: en/git-ls-files.txt:45
#, ignore-same, no-wrap, priority:80
msgid "--deleted"
msgstr "--deleted"

#. type: Plain text
#: en/git-ls-files.txt:47
#, priority:80
msgid "Show files with an unstaged deletion"
msgstr "显示未分阶段删除的文件"

#. type: Labeled list
#: en/git-ls-files.txt:49
#, ignore-same, no-wrap, priority:80
msgid "--modified"
msgstr "--modified"

#. type: Plain text
#: en/git-ls-files.txt:52
#, priority:80
msgid "Show files with an unstaged modification (note that an unstaged deletion also counts as an unstaged modification)"
msgstr "显示未暂存修改的文件（注意，未暂存删除也算作未暂存修改）"

#. type: Labeled list
#: en/git-ls-files.txt:54
#, ignore-same, no-wrap, priority:80
msgid "--others"
msgstr "--others"

#. type: Plain text
#: en/git-ls-files.txt:56
#, priority:80
msgid "Show other (i.e. untracked) files in the output"
msgstr "在输出中显示其他（即未跟踪）文件"

#. type: Labeled list
#: en/git-ls-files.txt:58
#, ignore-same, no-wrap, priority:80
msgid "--ignored"
msgstr "--ignored"

#. type: Plain text
#: en/git-ls-files.txt:67
#, placeholders:'`--exclude', priority:80
msgid "Show only ignored files in the output. Must be used with either an explicit '-c' or '-o'. When showing files in the index (i.e. when used with '-c'), print only those files matching an exclude pattern. When showing \"other\" files (i.e. when used with '-o'), show only those matched by an exclude pattern. Standard ignore rules are not automatically activated; therefore, at least one of the `--exclude*` options is required."
msgstr "在输出中只显示忽略的文件。 必须与明确的 '-c' 或 '-o' 一起使用。 显示索引中的文件时（即与 '-c' 一起使用时），只打印与排除模式匹配的文件。 显示 “其他” 文件时（即与 '-o' 一起使用时），只显示与排除模式匹配的文件。 标准忽略规则不会自动激活，因此至少需要一个 `--exclude*` 选项。"

#. type: Labeled list
#: en/git-ls-files.txt:69
#, ignore-same, no-wrap, priority:80
msgid "--stage"
msgstr "--stage"

#. type: Plain text
#: en/git-ls-files.txt:71
#, priority:80
msgid "Show staged contents' mode bits, object name and stage number in the output."
msgstr "在输出中显示暂存内容的模式位、对象名称和阶段编号。"

#. type: Labeled list
#: en/git-ls-files.txt:72
#, ignore-same, no-wrap, priority:80
msgid "--directory"
msgstr "--directory"

#. type: Plain text
#: en/git-ls-files.txt:76
#, placeholders:'--others', priority:80
msgid "If a whole directory is classified as \"other\", show just its name (with a trailing slash) and not its whole contents. Has no effect without -o/--others."
msgstr "如果整个目录被归类为 “其他”，则只显示其名称（带尾部斜线），而不显示其全部内容。 不使用 -o/--others 时无效。"

#. type: Labeled list
#: en/git-ls-files.txt:77
#, ignore-same, no-wrap, priority:80
msgid "--no-empty-directory"
msgstr "--no-empty-directory"

#. type: Plain text
#: en/git-ls-files.txt:79
#, placeholders:'--directory', priority:80
msgid "Do not list empty directories. Has no effect without --directory."
msgstr "不列出空目录。不使用 --directory 时无效。"

#. type: Labeled list
#: en/git-ls-files.txt:81 en/git-update-index.txt:67
#, ignore-same, no-wrap, priority:80
msgid "--unmerged"
msgstr "--unmerged"

# ERROR: --cached) not found in translation
#. type: Plain text
#: en/git-ls-files.txt:85
#, placeholders:'--stage':'--cached', priority:80
msgid "Show information about unmerged files in the output, but do not show any other tracked files (forces --stage, overrides --cached)."
msgstr "在输出中显示未合并文件的信息，但不显示任何其他跟踪文件（强制执行 --stage 命令，覆盖 --cached 命令）。"

#. type: Labeled list
#: en/git-ls-files.txt:87
#, ignore-same, no-wrap, priority:80
msgid "--killed"
msgstr "--killed"

#. type: Plain text
#: en/git-ls-files.txt:91
#, priority:80
msgid "Show untracked files on the filesystem that need to be removed due to file/directory conflicts for tracked files to be able to be written to the filesystem."
msgstr "显示文件系统中由于文件/目录冲突而需要删除的未跟踪文件，以便跟踪文件能够写入文件系统。"

#. type: Labeled list
#: en/git-ls-files.txt:92
#, ignore-same, no-wrap, priority:80
msgid "--resolve-undo"
msgstr "--resolve-undo"

#. type: Plain text
#: en/git-ls-files.txt:98
#, placeholders:'$PATH', priority:80
msgid "Show files having resolve-undo information in the index together with their resolve-undo information. (resolve-undo information is what is used to implement \"git checkout -m $PATH\", i.e. to recreate merge conflicts that were accidentally resolved)"
msgstr "在索引中显示有解决 --undo 信息的文件及其解决 --undo 信息。 (解决 --undo 信息用于执行 \"git checkout -m $PATH\"，即重新创建意外解决的合并冲突）"

#. type: Plain text
#: en/git-ls-files.txt:102
#, priority:80
msgid "\\0 line termination on output and do not quote filenames. See OUTPUT below for more information."
msgstr "输出时以 \\0 行结束，文件名不加引号。 更多信息，请参阅下面的输出一节。"

#. type: Labeled list
#: en/git-ls-files.txt:103
#, ignore-same, no-wrap, priority:80
msgid "--deduplicate"
msgstr "--deduplicate"

# ERROR: --modified not found in translation
# ERROR: --unmerged not found in translation
# ERROR: --stage not found in translation
#. type: Plain text
#: en/git-ls-files.txt:109
#, placeholders:'`--deleted`':'`--modified`':'`-t`':'`--unmerged`':'`--stage`', priority:80
msgid "When only filenames are shown, suppress duplicates that may come from having multiple stages during a merge, or giving `--deleted` and `--modified` option at the same time. When any of the `-t`, `--unmerged`, or `--stage` option is in use, this option has no effect."
msgstr "当只显示文件名时，抑制在合并过程中出现多个阶段，或同时给出 `--deleted` 和 `--modified` 选项时可能出现的重复。 当使用 `-t` ， `--unmerged` 或 `--stage` 选项时，此选项不起作用。"

#. type: Labeled list
#: en/git-ls-files.txt:110
#, no-wrap, priority:80
msgid "-x <pattern>"
msgstr "-x <模式>"

#. type: Plain text
#: en/git-ls-files.txt:115
#, priority:80
msgid "Skip untracked files matching pattern. Note that pattern is a shell wildcard pattern. See EXCLUDE PATTERNS below for more information."
msgstr "跳过与模式匹配的未跟踪文件。 请注意，pattern 是 shell 通配符模式。更多信息，请参阅下面的 EXCLUDE PATTERNS。"

#. type: Labeled list
#: en/git-ls-files.txt:116
#, no-wrap, priority:80
msgid "-X <file>"
msgstr "-X <文件>"

#. type: Labeled list
#: en/git-ls-files.txt:117
#, no-wrap, placeholders:'--exclude-from=', priority:80
msgid "--exclude-from=<file>"
msgstr "--exclude-from=<文件>"

#. type: Plain text
#: en/git-ls-files.txt:119
#, priority:80
msgid "Read exclude patterns from <file>; 1 per line."
msgstr "从 <文件> 中读取排除模式；每行 1 个。"

#. type: Labeled list
#: en/git-ls-files.txt:120
#, no-wrap, placeholders:'--exclude-per-directory=', priority:80
msgid "--exclude-per-directory=<file>"
msgstr "--exclude-per-directory=<文件>"

#. type: Plain text
#: en/git-ls-files.txt:126
#, placeholders:'`--exclude-standard`', priority:80
msgid "Read additional exclude patterns that apply only to the directory and its subdirectories in <file>. If you are trying to emulate the way Porcelain commands work, using the `--exclude-standard` option instead is easier and more thorough."
msgstr "读取仅适用于 <文件> 中目录及其子目录的附加排除模式。如果你想模仿 Porcelain 命令的工作方式，使用 `--exclude-standard` 选项会更简单、更彻底。"

#. type: Plain text
#: en/git-ls-files.txt:130
#, placeholders:'.git/info/exclude':'.gitignore', priority:80
msgid "Add the standard Git exclusions: .git/info/exclude, .gitignore in each directory, and the user's global exclusion file."
msgstr "添加标准的 Git 排除文件：.git/info/exclude、每个目录中的 .gitignore，以及用户的全局排除文件。"

#. type: Labeled list
#: en/git-ls-files.txt:131
#, ignore-same, no-wrap, priority:80
msgid "--error-unmatch"
msgstr "--error-unmatch"

#. type: Plain text
#: en/git-ls-files.txt:134
#, priority:80
msgid "If any <file> does not appear in the index, treat this as an error (return 1)."
msgstr "如果索引中没有出现任何 <文件> 文件，则将其视为错误（返回 1）。"

#. type: Labeled list
#: en/git-ls-files.txt:135
#, no-wrap, placeholders:'--with-tree=', priority:80
msgid "--with-tree=<tree-ish>"
msgstr "--with-tree=<树状对象>"

#. type: Plain text
#: en/git-ls-files.txt:141
#, placeholders:'--error-unmatch':'`-s`':'`-u`', priority:80
msgid "When using --error-unmatch to expand the user supplied <file> (i.e. path pattern) arguments to paths, pretend that paths which were removed in the index since the named <tree-ish> are still present. Using this option with `-s` or `-u` options does not make any sense."
msgstr "当使用 --error-unmatch 将用户提供的 <文件> （即路径模式）参数扩展为路径时，假定自命名为 <树状对象> 后在索引中删除的路径仍然存在。 将此选项与 `-s` 或 `-u` 选项一起使用没有任何意义。"

#. type: Plain text
#: en/git-ls-files.txt:149
#, placeholders:'linkgit:git-status[1]':'`--porcelain`':'linkgit:git-diff-files[1]':'`--name-status`':'linkgit:git-status[1]':'`--short`':'linkgit:git-diff[1]':'`--name-status`', priority:80
msgid "Show status tags together with filenames. Note that for scripting purposes, linkgit:git-status[1] `--porcelain` and linkgit:git-diff-files[1] `--name-status` are almost always superior alternatives; users should look at linkgit:git-status[1] `--short` or linkgit:git-diff[1] `--name-status` for more user-friendly alternatives."
msgstr "与文件名一起显示状态标签。 请注意，就脚本而言，linkgit:git-status[1] `--porcelain` 和 linkgit:git-diff-files[1] `--name-status` 几乎总是更好的选择；用户应该查看 linkgit:git-status[1] `--short` 或 linkgit:git-diff[1] `--name-status`，以获得更友好的选择。"

#. type: Plain text
#: en/git-ls-files.txt:154
#, priority:80
msgid "This option provides a reason for showing each filename, in the form of a status tag (which is followed by a space and then the filename). The status tags are all single characters from the following list:"
msgstr "该选项以状态标记（后跟空格，然后是文件名）的形式提供了显示每个文件名的理由。 状态标记均为以下列表中的单字符："

#. type: Labeled list
#: en/git-ls-files.txt:155
#, no-wrap, priority:80
msgid "H"
msgstr "H"

#. type: Plain text
#: en/git-ls-files.txt:156
#, priority:80
msgid "tracked file that is not either unmerged or skip-worktree"
msgstr "未合并或未跳过工作区的跟踪文件"

#. type: Labeled list
#: en/git-ls-files.txt:156
#, no-wrap, priority:80
msgid "S"
msgstr "S"

#. type: Plain text
#: en/git-ls-files.txt:157
#, priority:80
msgid "tracked file that is skip-worktree"
msgstr "跳过工作区的跟踪文件"

#. type: Labeled list
#: en/git-ls-files.txt:157
#, no-wrap, priority:80
msgid "M"
msgstr "M"

#. type: Plain text
#: en/git-ls-files.txt:158
#, priority:80
msgid "tracked file that is unmerged"
msgstr "未合并的跟踪文件"

#. type: Labeled list
#: en/git-ls-files.txt:158
#, no-wrap, priority:80
msgid "R"
msgstr "R"

#. type: Plain text
#: en/git-ls-files.txt:159
#, priority:80
msgid "tracked file with unstaged removal/deletion"
msgstr "未分阶段移除/删除的跟踪文件"

#. type: Labeled list
#: en/git-ls-files.txt:159
#, no-wrap, priority:80
msgid "C"
msgstr "C"

#. type: Plain text
#: en/git-ls-files.txt:160
#, priority:80
msgid "tracked file with unstaged modification/change"
msgstr "跟踪的文件有未暂存的修改/更改"

#. type: Labeled list
#: en/git-ls-files.txt:160
#, no-wrap, priority:80
msgid "K"
msgstr "K"

#. type: Plain text
#: en/git-ls-files.txt:162
#, priority:80
msgid "untracked paths which are part of file/directory conflicts which prevent checking out tracked files"
msgstr "未跟踪路径，这些路径是文件/目录冲突的一部分，妨碍了跟踪文件的检出"

#. type: Labeled list
#: en/git-ls-files.txt:162
#, no-wrap, priority:80
msgid "?"
msgstr "?"

#. type: Plain text
#: en/git-ls-files.txt:163
#, priority:80
msgid "untracked file"
msgstr "显示未追踪文件"

#. type: Labeled list
#: en/git-ls-files.txt:163
#, no-wrap, priority:80
msgid "U"
msgstr "U"

#. type: Plain text
#: en/git-ls-files.txt:164
#, priority:80
msgid "file with resolve-undo information"
msgstr "文件中的 resolve-undo 信息"

#. type: Plain text
#: en/git-ls-files.txt:170
#, placeholders:'`-t`':'linkgit:git-update-index[1]', priority:80
msgid "Similar to `-t`, but use lowercase letters for files that are marked as 'assume unchanged' (see linkgit:git-update-index[1])."
msgstr "与 `-t` 选项类似，但标记为 'assume unchanged' 的文件使用小写字母（参见 linkgit:git-update-index[1]）。"

#. type: Plain text
#: en/git-ls-files.txt:175
#, placeholders:'`-t`':'linkgit:git-update-index[1]', priority:80
msgid "Similar to `-t`, but use lowercase letters for files that are marked as 'fsmonitor valid' (see linkgit:git-update-index[1])."
msgstr "与 `-t` 类似，但标记为 'fsmonitor' 有效的文件使用小写字母（参见 linkgit:git-update-index[1]）。"

#. type: Plain text
#: en/git-ls-files.txt:185
#, placeholders:'--cached':'--stage', priority:80
msgid "Recursively calls ls-files on each active submodule in the repository. Currently there is only support for the --cached and --stage modes."
msgstr "在仓库中的每个活动子模块上递归调用 ls-files。 目前只支持 --cached 和 --stage 模式。"

#. type: Plain text
#: en/git-ls-files.txt:191 en/git-ls-tree.txt:77
#, placeholders:'--abbrev=', priority:80
msgid "Instead of showing the full 40-byte hexadecimal object lines, show the shortest prefix that is at least '<n>' hexdigits long that uniquely refers the object. Non default number of digits can be specified with --abbrev=<n>."
msgstr "不显示完整的 40 字节十六进制对象行，而是显示至少 '<n>' 个十六进制数字长度的最短前缀，该前缀唯一指向对象。 可以使用 --abbrev=<n> 指定非默认位数。"

#. type: Plain text
#: en/git-ls-files.txt:197
#, priority:80
msgid "After each line that describes a file, add more data about its cache entry. This is intended to show as much information as possible for manual inspection; the exact format may change at any time."
msgstr "在描述文件的每一行后，添加有关其缓存项的更多数据。 这样做的目的是显示尽可能多的信息，以方便人工检查；具体格式可能随时更改。"

#. type: Labeled list
#: en/git-ls-files.txt:198
#, ignore-same, no-wrap, priority:80
msgid "--eol"
msgstr "--eol"

#. type: Plain text
#: en/git-ls-files.txt:203
#, placeholders:'core.autocrlf', priority:80
msgid "Show <eolinfo> and <eolattr> of files. <eolinfo> is the file content identification used by Git when the \"text\" attribute is \"auto\" (or not set and core.autocrlf is not false). <eolinfo> is either \"-text\", \"none\", \"lf\", \"crlf\", \"mixed\" or \"\"."
msgstr "显示文件的 <eolinfo> 和 <eolattr>。 <eolinfo> 是 Git 在 \"text\" 属性为 \"auto\"（或未设置且 core.autocrlf 不为 false）时使用的文件内容标识。 <eolinfo> 可以是 \"-text\"、\"none\"、\"lf\"、\"crlf\"、\"mixed\" 或 \"\"。"

#. type: Plain text
#: en/git-ls-files.txt:206
#, priority:80
msgid "\"\" means the file is not a regular file, it is not in the index or not accessible in the working tree."
msgstr "\"\" 表示该文件不是普通文件，不在索引中或在工作区中无法访问。"

#. type: Plain text
#: en/git-ls-files.txt:210
#, priority:80
msgid "<eolattr> is the attribute that is used when checking out or committing, it is either \"\", \"-text\", \"text\", \"text=auto\", \"text eol=lf\", \"text eol=crlf\". Since Git 2.10 \"text=auto eol=lf\" and \"text=auto eol=crlf\" are supported."
msgstr "<eolattr> 是签出或提交时使用的属性，可以是 \"\"、\"-text\"、\"text\"、\"text=auto\"、\"text eol=lf\"、\"text eol=crlf\"。 Git 2.10 支持 \"text=auto eol=lf\" 和 \"text=auto eol=crlf\"。"

#. type: Plain text
#: en/git-ls-files.txt:214
#, priority:80
msgid "Both the <eolinfo> in the index (\"i/<eolinfo>\") and in the working tree (\"w/<eolinfo>\") are shown for regular files, followed by the (\"attr/<eolattr>\")."
msgstr "对于常规文件，索引（\"i/<eolinfo>\"）中的 <eolinfo> 和工作树（ \"w/<eolinfo>\" ）中的 <eolinfo> 都会显示，其后是（ \"attr/<eolattr>\" ）。"

#. type: Plain text
#: en/git-ls-files.txt:219
#, priority:80
msgid "If the index is sparse, show the sparse directories without expanding to the contained files. Sparse directories will be shown with a trailing slash, such as \"x/\" for a sparse directory \"x\"."
msgstr "如果索引是稀疏的，则显示稀疏目录，而不扩展到包含的文件。稀疏目录将以斜线显示，如 \"x/\" 表示稀疏目录 \"x\"。"

# ERROR: --resolve-undo not found in translation
# ERROR: --eol not found in translation
# ERROR: --resolve-undo not found in translation
# ERROR: --eol not found in translation
#. type: Plain text
#: en/git-ls-files.txt:227
#, placeholders:'--format':'`-s`':'`-o`':'`-k`':'`-t`':'`--resolve-undo`':'`--eol`', priority:80
msgid "A string that interpolates `%(fieldname)` from the result being shown. It also interpolates `%%` to `%`, and `%xx` where `xx` are hex digits interpolates to character with hex code `xx`; for example `%00` interpolates to `\\0` (NUL), `%09` to `\\t` (TAB) and %0a to `\\n` (LF). --format cannot be combined with `-s`, `-o`, `-k`, `-t`, `--resolve-undo` and `--eol`."
msgstr "一个字符串，从显示的结果中插值出 `%(字段名)`。 它还将 `%%` 内插到 `%`，将 `%xx` 内插到十六进制代码为 `xx` 的字符；例如，将 `%00` 内插到 `\\0` (NUL)，将 `%09` 内插到 `\\t` (TAB)，将 %0a 内插到 `\\n` (LF)。 --format 选项不能与`-s`、`-o`、`-k`、`-t`、`--resolve-undo` 和 `--eol` 选项结合使用。"

#. type: Labeled list
#: en/git-ls-files.txt:230 en/git.txt:418 en/git-update-index.txt:235
#, no-wrap, priority:100
msgid "<file>"
msgstr "<文件>"

#. type: Plain text
#: en/git-ls-files.txt:233
#, priority:80
msgid "Files to show. If no files are given all files which match the other specified criteria are shown."
msgstr "要显示的文件。如果没有给出文件，则会显示符合其他指定条件的所有文件。"

#. type: Plain text
#: en/git-ls-files.txt:238
#, placeholders:'git ls-files':'`--stage`', priority:80
msgid "'git ls-files' just outputs the filenames unless `--stage` is specified in which case it outputs:"
msgstr "'git ls-files' 只输出文件名，除非指定了 `--stage` 选项，在这种情况下才输出："

#. type: Plain text
#: en/git-ls-files.txt:240
#, no-wrap, priority:80
msgid "        [<tag> ]<mode> <object> <stage> <file>\n"
msgstr "        [<标签> ]<模式> <对象> <暂存> <文件>\n"

#. type: Plain text
#: en/git-ls-files.txt:243
#, no-wrap, placeholders:'git ls-files':'--eol', priority:80
msgid ""
"'git ls-files --eol' will show\n"
"\ti/<eolinfo><SPACES>w/<eolinfo><SPACES>attr/<eolattr><SPACE*><TAB><file>\n"
msgstr ""
"'git ls-files --eol' will show\n"
"\ti/<eolinfo><SPACES>w/<eolinfo><SPACES>attr/<eolattr><SPACE*><TAB><文件>\n"

#. type: Plain text
#: en/git-ls-files.txt:246
#, placeholders:'git ls-files':'--unmerged':'git ls-files':'--stage', priority:80
msgid "'git ls-files --unmerged' and 'git ls-files --stage' can be used to examine detailed information on unmerged paths."
msgstr "'git ls-files --unmerged' 和 'git ls-files --stage' 可以用来检查未合并路径的详细信息。"

#. type: Plain text
#: en/git-ls-files.txt:252
#, placeholders:'linkgit:git-read-tree[1]', priority:80
msgid "For an unmerged path, instead of recording a single mode/SHA-1 pair, the index records up to three such pairs; one from tree O in stage 1, A in stage 2, and B in stage 3. This information can be used by the user (or the porcelain) to see what should eventually be recorded at the path. (see linkgit:git-read-tree[1] for more information on state)"
msgstr "对于未合并的路径，索引不会记录单个模式/SHA-1 对，而是最多记录三个此类对；一个来自第一阶段的目录树 O，一个来自第二阶段的目录树 A，一个来自第三阶段的目录树 B。 用户（或上层命令）可以利用这些信息来查看路径上最终应该记录的内容。(有关状态的更多信息，请参阅 linkgit:git-read-tree[1])"

# ERROR: `--format` not found in translation
#. type: Plain text
#: en/git-ls-files.txt:263 en/git-ls-tree.txt:141
#, placeholders:'`--format`':'--format', priority:80
msgid "It is possible to print in a custom format by using the `--format` option, which is able to interpolate different fields using a `%(fieldname)` notation. For example, if you only care about the \"objectname\" and \"path\" fields, you can execute with a specific \"--format\" like"
msgstr "使用 `--format` 选项可以自定义打印格式，该选项可以使用 `%(fieldname)` 符号对不同字段进行插值。例如，如果只关心 “对象名” 和 “路径” 字段，可以使用特定的 \"--format\" 执行，如"

#. type: Plain text
#: en/git-ls-files.txt:265
#, no-wrap, placeholders:'git ls-files':'--format=', priority:80
msgid "\tgit ls-files --format='%(objectname) %(path)'\n"
msgstr "\tgit ls-files --format='%(对象名) %(路径)'\n"

#. type: Plain text
#: en/git-ls-files.txt:272
#, placeholders:'`--format=', priority:80
msgid "The way each path is shown can be customized by using the `--format=<format>` option, where the %(fieldname) in the <format> string for various aspects of the index entry are interpolated. The following \"fieldname\" are understood:"
msgstr "每个路径的显示方式可以通过使用 `--format=<格式>`选项进行自定义，在该选项中，<格式> 字符串中用于索引条目的不同方面的 %(字段名) 将被插值。 可以理解以下 “字段名”："

#. type: Labeled list
#: en/git-ls-files.txt:273 en/git-ls-tree.txt:151
#, no-wrap, priority:80
msgid "objectmode"
msgstr "objectmode"

#. type: Plain text
#: en/git-ls-files.txt:275
#, priority:80
msgid "The mode of the file which is recorded in the index."
msgstr "索引中记录的文件模式。"

#. type: Plain text
#: en/git-ls-files.txt:277
#, priority:80
msgid "The object type of the file which is recorded in the index."
msgstr "索引中记录的文件对象类型。"

#. type: Plain text
#: en/git-ls-files.txt:279
#, priority:80
msgid "The name of the file which is recorded in the index."
msgstr "索引中记录的文件名。"

#. type: Labeled list
#: en/git-ls-files.txt:279 en/git-ls-tree.txt:157
#, no-wrap, priority:80
msgid "objectsize[:padded]"
msgstr "objectsize[:padded]"

#. type: Plain text
#: en/git-ls-files.txt:283
#, priority:80
msgid "The object size of the file which is recorded in the index (\"-\" if the object is a `commit` or `tree`). It also supports a padded format of size with \"%(objectsize:padded)\"."
msgstr "索引中记录的文件对象大小（如果对象是 `commit` 或 `tree`，则为 \"-\"）。 它还支持 \"%(objectize:padded)\" 的填充大小格式。"

#. type: Labeled list
#: en/git-ls-files.txt:283
#, no-wrap, priority:80
msgid "stage"
msgstr "stage"

#. type: Plain text
#: en/git-ls-files.txt:285
#, priority:80
msgid "The stage of the file which is recorded in the index."
msgstr "索引中记录的文件阶段。"

#. type: Labeled list
#: en/git-ls-files.txt:285
#, no-wrap, priority:80
msgid "eolinfo:index"
msgstr "eolinfo:index"

#. type: Labeled list
#: en/git-ls-files.txt:286
#, no-wrap, priority:80
msgid "eolinfo:worktree"
msgstr "eolinfo:worktree"

#. type: Plain text
#: en/git-ls-files.txt:289
#, placeholders:'`--eol`', priority:80
msgid "The <eolinfo> (see the description of the `--eol` option) of the contents in the index or in the worktree for the path."
msgstr "路径的索引或工作树中内容的 <eolinfo>（参见 `--eol` 选项的说明）。"

#. type: Labeled list
#: en/git-ls-files.txt:289
#, no-wrap, priority:80
msgid "eolattr"
msgstr "eolattr"

#. type: Plain text
#: en/git-ls-files.txt:292
#, placeholders:'`--eol`', priority:80
msgid "The <eolattr> (see the description of the `--eol` option) that applies to the path."
msgstr "适用于路径的 <eolattr>（参见 `--eol` 选项的说明）。"

#. type: Labeled list
#: en/git-ls-files.txt:292 en/git-ls-tree.txt:160
#, no-wrap, priority:80
msgid "path"
msgstr "path"

#. type: Plain text
#: en/git-ls-files.txt:294
#, priority:80
msgid "The pathname of the file which is recorded in the index."
msgstr "索引中记录的文件路径名。"

#. type: Title -
#: en/git-ls-files.txt:296
#, no-wrap, priority:80
msgid "EXCLUDE PATTERNS"
msgstr "排除模式"

#. type: Plain text
#: en/git-ls-files.txt:302
#, placeholders:'git ls-files':'--others':'--ignored':'linkgit:gitignore[5]', priority:80
msgid "'git ls-files' can use a list of \"exclude patterns\" when traversing the directory tree and finding files to show when the flags --others or --ignored are specified. linkgit:gitignore[5] specifies the format of exclude patterns."
msgstr "'git ls-files' 在遍历目录树时可以使用 “排除模式” 列表，并在指定--others 或--ignored 标志时查找要显示的文件。 linkgit:gitignore[5] 指定了排除模式的格式。"

#. type: Plain text
#: en/git-ls-files.txt:305
#, priority:80
msgid "These exclude patterns can be specified from the following places, in order:"
msgstr "这些排除模式可依次在以下位置指定："

#. type: Plain text
#: en/git-ls-files.txt:309
#, placeholders:'--exclude=', priority:80
msgid "The command-line flag --exclude=<pattern> specifies a single pattern. Patterns are ordered in the same order they appear in the command line."
msgstr "命令行标志 --exclude=<模式> 可指定单一模式。 模式的排列顺序与命令行中出现的顺序相同。"

#. type: Plain text
#: en/git-ls-files.txt:313
#, placeholders:'--exclude-from=', priority:80
msgid "The command-line flag --exclude-from=<file> specifies a file containing a list of patterns. Patterns are ordered in the same order they appear in the file."
msgstr "命令行标志 --exclude-from=<文件> 可指定一个包含模式列表的文件。 模式的排列顺序与它们在文件中出现的顺序相同。"

#. type: Plain text
#: en/git-ls-files.txt:319
#, placeholders:'--exclude-per-directory=':'git ls-files':'.gitignore', priority:80
msgid "The command-line flag --exclude-per-directory=<name> specifies a name of the file in each directory 'git ls-files' examines, normally `.gitignore`. Files in deeper directories take precedence. Patterns are ordered in the same order they appear in the files."
msgstr "命令行标志 --exclude-per-directory=<名称> 指定了 'git ls-files' 检查的每个目录中的文件名，通常是 `.gitignore`。 深目录中的文件优先。 模式的排列顺序与文件中出现的顺序相同。"

#. type: Plain text
#: en/git-ls-files.txt:325
#, placeholders:'--exclude':'--exclude-from':'--exclude-per-directory', priority:80
msgid "A pattern specified on the command line with --exclude or read from the file specified with --exclude-from is relative to the top of the directory tree. A pattern read from a file specified by --exclude-per-directory is relative to the directory that the pattern file appears in."
msgstr "在命令行中用 --exclude 指定的模式或从用 --exclude-from 指定的文件中读取的模式是相对于目录树顶层的。 通过 --exclude-per-directory 指定的文件读取的模式是相对于模式文件所在目录的。"

#. type: Plain text
#: en/git-ls-files.txt:330
#, placeholders:'`--exclude-standard`':'`--exclude-standard`':'`--exclude-per-directory=':'.gitignore', priority:80
msgid "Generally, you should be able to use `--exclude-standard` when you want the exclude rules applied the same way as what Porcelain commands do. To emulate what `--exclude-standard` specifies, you can give `--exclude-per-directory=.gitignore`, and then specify:"
msgstr "一般来说，当你希望排除规则的应用方式与 Porcelain 命令相同时，可以使用 `--exclude-standard`。要模仿 `--exclude-standard`指定的方式，可以给出 `--exclude-per-directory=.gitignore`，然后指定："

#. type: Plain text
#: en/git-ls-files.txt:333
#, placeholders:'core.excludesfile':'$XDG_CONFIG_HOME', priority:80
msgid "The file specified by the `core.excludesfile` configuration variable, if exists, or the `$XDG_CONFIG_HOME/git/ignore` file."
msgstr "配置变量 `core.excludesfile` 指定的文件（如果存在），或 `$XDG_CONFIG_HOME/git/ignore` 文件。"

#. type: Plain text
#: en/git-ls-files.txt:335
#, placeholders:'$GIT_DIR', priority:80
msgid "The `$GIT_DIR/info/exclude` file."
msgstr "`$GIT_DIR/info/exclude` 文件。"

#. type: Plain text
#: en/git-ls-files.txt:337
#, placeholders:'`--exclude-from=`', priority:80
msgid "via the `--exclude-from=` option."
msgstr "通过 `--exclude-from=` 选项。"

#. type: Plain text
#: en/git-ls-files.txt:341
#, ignore-same, priority:80
msgid "linkgit:git-read-tree[1], linkgit:gitignore[5]"
msgstr "linkgit:git-read-tree[1], linkgit:gitignore[5]"

#. type: Title =
#: en/git-ls-remote.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-ls-remote(1)"
msgstr "git-ls-remote(1)"

#. type: Plain text
#: en/git-ls-remote.txt:7
#, placeholders:'git-ls-remote', priority:100
msgid "git-ls-remote - List references in a remote repository"
msgstr "git-ls-remote - 列出远程仓库中的引用"

#. type: Plain text
#: en/git-ls-remote.txt:15
#, ignore-ellipsis, no-wrap, placeholders:'git ls-remote':'[--heads]':'[--tags]':'[--refs]':'[--upload-pack=':'--quiet]':'[--exit-code]':'[--get-url]':'[--sort=':'[--symref]', priority:100
msgid ""
"'git ls-remote' [--heads] [--tags] [--refs] [--upload-pack=<exec>]\n"
"\t      [-q | --quiet] [--exit-code] [--get-url] [--sort=<key>]\n"
"\t      [--symref] [<repository> [<patterns>...]]\n"
msgstr ""
"'git ls-remote' [--heads] [--tags] [--refs] [--upload-pack=<exec>]\n"
"\t      [-q | --quiet] [--exit-code] [--get-url] [--sort=<键>]\n"
"\t      [--symref] [<仓库> [<模式>...]]\n"

#. type: Plain text
#: en/git-ls-remote.txt:20
#, priority:100
msgid "Displays references available in a remote repository along with the associated commit IDs."
msgstr "显示远程版本库中可用的引用以及相关的提交 ID。"

#. type: Labeled list
#: en/git-ls-remote.txt:25 en/git-show-ref.txt:48
#, ignore-same, no-wrap, priority:100
msgid "--heads"
msgstr "--heads"

#. type: Plain text
#: en/git-ls-remote.txt:34
#, placeholders:'git ls-remote', priority:100
msgid "Limit to only refs/heads and refs/tags, respectively. These options are _not_ mutually exclusive; when given both, references stored in refs/heads and refs/tags are displayed. Note that `git ls-remote -h` used without anything else on the command line gives help, consistent with other git subcommands."
msgstr "分别限制在 refs/heads 和 refs/tags。 这些选项不是相互排斥的；当两个选项都给出时，存储在 refs/heads 和 refs/tags 中的引用会被显示。 注意，`git ls-remote -h` 在命令行中不使用任何其他东西，就会提供帮助，与其他 git 子命令一致。"

#. type: Labeled list
#: en/git-ls-remote.txt:35
#, ignore-same, no-wrap, priority:100
msgid "--refs"
msgstr "--refs"

#. type: Plain text
#: en/git-ls-remote.txt:37
#, placeholders:'HEAD', priority:100
msgid "Do not show peeled tags or pseudorefs like `HEAD` in the output."
msgstr "在输出中不显示剥离的标签或像 `HEAD` 这样的伪引用。"

#. type: Plain text
#: en/git-ls-remote.txt:41
#, priority:100
msgid "Do not print remote URL to stderr."
msgstr "不将远程 URL 打印到标准错误流。"

#. type: Labeled list
#: en/git-ls-remote.txt:42
#, no-wrap, placeholders:'--upload-pack=', priority:100
msgid "--upload-pack=<exec>"
msgstr "--upload-pack=<exec>"

#. type: Plain text
#: en/git-ls-remote.txt:47
#, placeholders:'git-upload-pack', priority:100
msgid "Specify the full path of 'git-upload-pack' on the remote host. This allows listing references from repositories accessed via SSH and where the SSH daemon does not use the PATH configured by the user."
msgstr "指定远程主机上 'git-upload-pack' 的完整路径。这允许列出通过 SSH 访问的存储库的引用，而且 SSH 守护程序不使用用户配置的 PATH。"

#. type: Plain text
#: en/git-ls-remote.txt:53
#, priority:100
msgid "Exit with status \"2\" when no matching refs are found in the remote repository. Usually the command exits with status \"0\" to indicate it successfully talked with the remote repository, whether it found any matching refs."
msgstr "当在远程版本库中没有找到匹配的引用时，以状态 \"2\" 退出。通常该命令以状态 \"0\" 退出，表示它成功地与远程版本库进行了对话，无论是否找到了匹配的引用。"

#. type: Labeled list
#: en/git-ls-remote.txt:54
#, ignore-same, no-wrap, priority:100
msgid "--get-url"
msgstr "--get-url"

#. type: Plain text
#: en/git-ls-remote.txt:58
#, placeholders:'linkgit:git-config[1]', priority:100
msgid "Expand the URL of the given remote repository taking into account any \"url.<base>.insteadOf\" config setting (See linkgit:git-config[1]) and exit without talking to the remote."
msgstr "考虑任何 \"url.<base>.insteadOf\" 的配置设置（见linkgit:git-config[1]），展开给定的远程仓库的URL，然后退出，不与远程对话。"

#. type: Labeled list
#: en/git-ls-remote.txt:59
#, ignore-same, no-wrap, priority:100
msgid "--symref"
msgstr "--symref"

#. type: Plain text
#: en/git-ls-remote.txt:64
#, placeholders:'HEAD', priority:100
msgid "In addition to the object pointed by it, show the underlying ref pointed by it when showing a symbolic ref. Currently, upload-pack only shows the symref HEAD, so it will be the only one shown by ls-remote."
msgstr "除了它所指向的对象之外，在显示一个符号引用时，还要显示它所指向的底层引用。 目前，upload-pack 只显示符号引用HEAD，所以它将是 ls-remote 显示的唯一对象。"

#. type: Plain text
#: en/git-ls-remote.txt:74
#, placeholders:'versionsort.suffix':'linkgit:git-for-each-ref[1]', priority:100
msgid "Sort based on the key given. Prefix `-` to sort in descending order of the value. Supports \"version:refname\" or \"v:refname\" (tag names are treated as versions). The \"version:refname\" sort order can also be affected by the \"versionsort.suffix\" configuration variable. See linkgit:git-for-each-ref[1] for more sort options, but be aware keys like `committerdate` that require access to the objects themselves will not work for refs whose objects have not yet been fetched from the remote, and will give a `missing object` error."
msgstr "根据给定的键进行排序。前缀 `-` 以数值的降序来排序。支持 \"version:refname\" 或 \"v:refname\"（标签名被视为版本）。\"version:refname\" 的排序顺序也可以由 \"versionsort.suffix\" 配置的变量影响。 见 linkgit:git-for-each-ref[1] 以获得更多的排序选项，但要注意像 `committerdate` 这样需要访问对象本身的键，对对象尚未从远程获取的引用不起作用，并会出现 `missing object` 的错误。"

#. type: Plain text
#: en/git-ls-remote.txt:82
#, placeholders:'`--server-option=', priority:100
msgid "Transmit the given string to the server when communicating using protocol version 2. The given string must not contain a NUL or LF character. When multiple `--server-option=<option>` are given, they are all sent to the other side in the order listed on the command line."
msgstr "当使用协议版本2进行通信时，将给定的字符串传输给服务器。 给定的字符串不能包含 NUL 或 LF 字符。 当给出多个 `--server-option=<option>` 时，它们将按照命令行中列出的顺序全部发送给对方。"

#. type: Plain text
#: en/git-ls-remote.txt:87
#, placeholders:'linkgit:git-fetch[1]', priority:100
msgid "The \"remote\" repository to query. This parameter can be either a URL or the name of a remote (see the GIT URLS and REMOTES sections of linkgit:git-fetch[1])."
msgstr "要查询的 \"远程\" 版本库。 这个参数可以是一个 URL，也可以是一个远程的名称（见 linkgit:git-fetch[1] 的 GIT URLS 和远端部分）。"

#. type: Labeled list
#: en/git-ls-remote.txt:88
#, ignore-ellipsis, no-wrap, priority:100
msgid "<patterns>..."
msgstr "<模式>..."

#. type: Plain text
#: en/git-ls-remote.txt:98
#, ignore-ellipsis, placeholders:'--heads':'--tags':'linkgit:gitglossary[7]', priority:100
msgid "When unspecified, all references, after filtering done with --heads and --tags, are shown. When <patterns>... are specified, only references matching one or more of the given patterns are displayed. Each pattern is interpreted as a glob (see `glob` in linkgit:gitglossary[7]) which is matched against the \"tail\" of a ref, starting either from the start of the ref (so a full name like `refs/heads/foo` matches) or from a slash separator (so `bar` matches `refs/heads/bar` but not `refs/heads/foobar`)."
msgstr "当未指定时，在用 --heads 和 --tags 过滤后，所有引用都会被显示。 当 <patterns>... 被指定时，只显示匹配一个或多个给定模式的引用。每个模式都被解释为一个 glob（见 linkgit:gitglossary[7] 中的 `glob`），它与引用的 \"尾巴\" 相匹配，从引用的开头开始（所以像 `refs/heads/foo` 这样的全名匹配）或者从斜线分隔符开始（所以 `bar` 匹配 `refs/heads/bar`，而不是 `refs/heads/foobar`）。"

#. type: Plain text
#: en/git-ls-remote.txt:103 en/git-show-ref.txt:114
#, priority:100
msgid "The output is in the format:"
msgstr "输出格式为："

#. type: delimited block -
#: en/git-ls-remote.txt:106
#, no-wrap, priority:100
msgid "<oid> TAB <ref> LF\n"
msgstr "<oid> TAB <ref> LF\n"

#. type: Plain text
#: en/git-ls-remote.txt:112
#, placeholders:'`--refs`', priority:100
msgid "When showing an annotated tag, unless `--refs` is given, two such lines are shown: one with the refname for the tag itself as `<ref>`, and another with `<ref>` followed by `^{}`. The `<oid>` on the latter line shows the name of the object the tag points at."
msgstr "在显示注释标记时，除非给出 `--refs`，否则会显示两行：一行是标记本身的参考名 `<ref>`，另一行是 `<ref>` 后跟 `^{}`。后一行的 `<oid>` 显示的是标签指向的对象名称。"

#. type: Plain text
#: en/git-ls-remote.txt:118
#, priority:100
msgid "List all references (including symbolics and pseudorefs), peeling tags:"
msgstr "列出所有引用（包括符号和伪引用），剥离标签："

#. type: delimited block -
#: en/git-ls-remote.txt:126
#, no-wrap, placeholders:'git ls-remote':'HEAD', priority:100
msgid ""
"$ git ls-remote\n"
"27d43aaaf50ef0ae014b88bba294f93658016a2e\tHEAD\n"
"950264636c68591989456e3ba0a5442f93152c1a\trefs/heads/main\n"
"d9ab777d41f92a8c1684c91cfb02053d7dd1046b\trefs/heads/next\n"
"d4ca2e3147b409459955613c152220f4db848ee1\trefs/tags/v2.40.0\n"
"73876f4861cd3d187a4682290ab75c9dccadbc56\trefs/tags/v2.40.0^{}\n"
msgstr ""
"$ git ls-remote\n"
"27d43aaaf50ef0ae014b88bba294f93658016a2e\tHEAD\n"
"950264636c68591989456e3ba0a5442f93152c1a\trefs/heads/main\n"
"d9ab777d41f92a8c1684c91cfb02053d7dd1046b\trefs/heads/next\n"
"d4ca2e3147b409459955613c152220f4db848ee1\trefs/tags/v2.40.0\n"
"73876f4861cd3d187a4682290ab75c9dccadbc56\trefs/tags/v2.40.0^{}\n"

#. type: Plain text
#: en/git-ls-remote.txt:129
#, priority:100
msgid "List all references matching given patterns:"
msgstr "列出与给定模式匹配的所有引用："

#. type: delimited block -
#: en/git-ls-remote.txt:134
#, no-wrap, placeholders:'git ls-remote':'www.kernel.org':'git.git', priority:100
msgid ""
"$ git ls-remote http://www.kernel.org/pub/scm/git/git.git master seen rc\n"
"5fe978a5381f1fbad26a80e682ddd2a401966740\trefs/heads/master\n"
"c781a84b5204fb294c9ccc79f8b3baceeb32c061\trefs/heads/seen\n"
msgstr ""
"$ git ls-remote http://www.kernel.org/pub/scm/git/git.git master seen rc\n"
"5fe978a5381f1fbad26a80e682ddd2a401966740\trefs/heads/master\n"
"c781a84b5204fb294c9ccc79f8b3baceeb32c061\trefs/heads/seen\n"

#. type: Plain text
#: en/git-ls-remote.txt:137
#, priority:100
msgid "List only tags matching a given wildcard pattern:"
msgstr "仅列出与给定通配符模式匹配的标记："

#. type: delimited block -
#: en/git-ls-remote.txt:144
#, no-wrap, placeholders:'git ls-remote':'--tags':'www.kernel.org':'git.git', priority:100
msgid ""
"$ git ls-remote --tags http://www.kernel.org/pub/scm/git/git.git v\\*\n"
"485a869c64a68cc5795dd99689797c5900f4716d\trefs/tags/v2.39.2\n"
"cbf04937d5b9fcf0a76c28f69e6294e9e3ecd7e6\trefs/tags/v2.39.2^{}\n"
"d4ca2e3147b409459955613c152220f4db848ee1\trefs/tags/v2.40.0\n"
"73876f4861cd3d187a4682290ab75c9dccadbc56\trefs/tags/v2.40.0^{}\n"
msgstr ""
"$ git ls-remote --tags http://www.kernel.org/pub/scm/git/git.git v\\*\n"
"485a869c64a68cc5795dd99689797c5900f4716d\trefs/tags/v2.39.2\n"
"cbf04937d5b9fcf0a76c28f69e6294e9e3ecd7e6\trefs/tags/v2.39.2^{}\n"
"d4ca2e3147b409459955613c152220f4db848ee1\trefs/tags/v2.40.0\n"
"73876f4861cd3d187a4682290ab75c9dccadbc56\trefs/tags/v2.40.0^{}\n"

#. type: Plain text
#: en/git-ls-remote.txt:149
#, ignore-same, priority:100
msgid "linkgit:git-check-ref-format[1]."
msgstr "linkgit:git-check-ref-format[1]."

#. type: Title =
#: en/git-ls-tree.txt:2
#, ignore-same, no-wrap, priority:80
msgid "git-ls-tree(1)"
msgstr "git-ls-tree(1)"

#. type: Plain text
#: en/git-ls-tree.txt:7
#, placeholders:'git-ls-tree', priority:80
msgid "git-ls-tree - List the contents of a tree object"
msgstr "git-ls-tree - 列出树对象的内容"

#. type: Plain text
#: en/git-ls-tree.txt:15
#, ignore-ellipsis, no-wrap, placeholders:'git ls-tree':'[--name-only]':'[--name-status]':'[--object-only]':'[--full-name]':'[--full-tree]':'[--abbrev':'[--format=', priority:80
msgid ""
"'git ls-tree' [-d] [-r] [-t] [-l] [-z]\n"
"\t    [--name-only] [--name-status] [--object-only] [--full-name] [--full-tree] [--abbrev[=<n>]] [--format=<format>]\n"
"\t    <tree-ish> [<path>...]\n"
msgstr ""
"'git ls-tree' [-d] [-r] [-t] [-l] [-z]\n"
"\t    [--name-only] [--name-status] [--object-only] [--full-name] [--full-tree] [--abbrev[=<n>]] [--format=<格式>]\n"
"\t    <目录树对象> [<路径>...]\n"

#. type: Plain text
#: en/git-ls-tree.txt:20
#, priority:80
msgid "Lists the contents of a given tree object, like what \"/bin/ls -a\" does in the current working directory. Note that:"
msgstr "列出给定树对象的内容，类似于当前工作目录中的 \"/bin/ls -a\"。 请注意："

#. type: Plain text
#: en/git-ls-tree.txt:25
#, placeholders:'`-r`', priority:80
msgid "the behaviour is slightly different from that of \"/bin/ls\" in that the '<path>' denotes just a list of patterns to match, e.g. so specifying directory name (without `-r`) will behave differently, and order of the arguments does not matter."
msgstr "行为与 \"/bin/ls\" 略有不同，'<路径>' 表示的只是要匹配的模式列表，例如，指定目录名（不含 `-r`）的行为会有所不同，参数的顺序并不重要。"

#. type: Plain text
#: en/git-ls-tree.txt:35
#, placeholders:'git ls-tree':'HEAD':'HEAD':'git ls-tree':'HEAD':'HEAD':'--full-tree', priority:80
msgid "the behaviour is similar to that of \"/bin/ls\" in that the '<path>' is taken as relative to the current working directory. E.g. when you are in a directory 'sub' that has a directory 'dir', you can run 'git ls-tree -r HEAD dir' to list the contents of the tree (that is `sub/dir` in `HEAD`). You don't want to give a tree that is not at the root level (e.g. `git ls-tree -r HEAD:sub dir`) in this case, as that would result in asking for `sub/sub/dir` in the `HEAD` commit. However, the current working directory can be ignored by passing --full-tree option."
msgstr "的行为类似于 \"/bin/ls\"，因为 '<路径>' 是相对于当前工作目录而言的。 例如，当你在一个有目录 'dir' 的目录 'sub' 中时，你可以运行 'git ls-tree -r HEAD dir' 来列出目录树（即 `HEAD` 中的 `sub/dir` ）的内容。 在这种情况下，你不会想给出一个不在根目录下的树（例如 `git ls-tree -r HEAD:sub dir`），因为这会导致在 `HEAD` 提交中询问 `sub/sub/dir`。 不过，可以通过 --full-tree 选项忽略当前工作目录。"

#. type: Plain text
#: en/git-ls-tree.txt:40
#, priority:80
msgid "Id of a tree-ish."
msgstr "树状对象 ID。"

#. type: Plain text
#: en/git-ls-tree.txt:43
#, priority:80
msgid "Show only the named tree entry itself, not its children."
msgstr "只显示已命名的目录条目本身，不显示其子条目。"

#. type: Plain text
#: en/git-ls-tree.txt:50
#, placeholders:'`-r`':'`-d`':'`-t`', priority:80
msgid "Show tree entries even when going to recurse them. Has no effect if `-r` was not passed. `-d` implies `-t`."
msgstr "即使在递归时也显示树条目。如果未传递 `-r`，则无影响。`-d` 意味着 `-t`。"

#. type: Plain text
#: en/git-ls-tree.txt:54
#, priority:80
msgid "Show object size of blob (file) entries."
msgstr "显示 blob（文件）条目的对象大小。"

#. type: Plain text
#: en/git-ls-tree.txt:58
#, priority:80
msgid "\\0 line termination on output and do not quote filenames. See OUTPUT FORMAT below for more information."
msgstr "输出以 \\0 行结束，文件名不加引号。 更多信息，请参阅下面的输出格式。"

#. type: Plain text
#: en/git-ls-tree.txt:63
#, placeholders:'`--object-only`', priority:80
msgid "List only filenames (instead of the \"long\" output), one per line. Cannot be combined with `--object-only`."
msgstr "只列出文件名（而不是 “长” 输出），每行一个。 不能与 `--object-only` 结合使用。"

#. type: Labeled list
#: en/git-ls-tree.txt:64
#, ignore-same, no-wrap, priority:80
msgid "--object-only"
msgstr "--object-only"

#. type: Plain text
#: en/git-ls-tree.txt:71
#, placeholders:'`--name-only`':'`--name-status`':'`--format=', priority:80
msgid "List only names of the objects, one per line. Cannot be combined with `--name-only` or `--name-status`. This is equivalent to specifying `--format='%(objectname)'`, but for both this option and that exact format the command takes a hand-optimized codepath instead of going through the generic formatting mechanism."
msgstr "仅列出对象名称，每行一个。不能与 `--name-only` 或 `--name-status` 结合使用。 这等同于指定 `--format='%(对象名)'` ，但对于该选项和精确格式，命令都采用手工优化的代码路径，而不是通过通用格式化机制。"

#. type: Plain text
#: en/git-ls-tree.txt:81
#, priority:80
msgid "Instead of showing the path names relative to the current working directory, show the full path names."
msgstr "不显示相对于当前工作目录的路径名，而是显示完整的路径名。"

#. type: Plain text
#: en/git-ls-tree.txt:85
#, placeholders:'--full-name', priority:80
msgid "Do not limit the listing to the current working directory. Implies --full-name."
msgstr "不将列表限制在当前工作目录。 暗含 --full-name."

#. type: Plain text
#: en/git-ls-tree.txt:95
#, placeholders:'`--format`':'`--long`':'`--name-only`':'`--object-only`', priority:80
msgid "A string that interpolates `%(fieldname)` from the result being shown. It also interpolates `%%` to `%`, and `%xNN` where `NN` are hex digits interpolates to character with hex code `NN`; for example `%x00` interpolates to `\\0` (NUL), `%x09` to `\\t` (TAB) and `%x0a` to `\\n` (LF). When specified, `--format` cannot be combined with other format-altering options, including `--long`, `--name-only` and `--object-only`."
msgstr "一个字符串，从显示的结果中插值出 `%(字段名)`。它还将 `%%` 插值为 `%`，将 `%xNN` 插值为十六进制代码为 `NN` 的字符；例如，将 `%x00` 插值为 `\\0` (NUL)，将 `%x09` 插值为 `\\t` (TAB)，将 `%x0a` 插值为 `\\n` (LF)。 当指定时，`--format` 不能与其他改变格式的选项结合使用，包括 `--long`、`--name-only` 和 `--object-only` 。"

#. type: Labeled list
#: en/git-ls-tree.txt:96
#, ignore-ellipsis, no-wrap, priority:80
msgid "[<path>...]"
msgstr "[<路径>...]"

#. type: Plain text
#: en/git-ls-tree.txt:100
#, priority:80
msgid "When paths are given, show them (note that this isn't really raw pathnames, but rather a list of patterns to match). Otherwise implicitly uses the root level of the tree as the sole path argument."
msgstr "如果给出路径，则显示路径（注意这并不是真正的原始路径名，而是要匹配的模式列表）。 否则会隐式地将树的根层作为唯一的路径参数。"

#. type: Title -
#: en/git-ls-tree.txt:103
#, no-wrap, priority:80
msgid "Output Format"
msgstr "输出格式"

#. type: Plain text
#: en/git-ls-tree.txt:108
#, placeholders:'`--format`':'`--name-only`':'`--format`', priority:80
msgid "The output format of `ls-tree` is determined by either the `--format` option, or other format-altering options such as `--name-only` etc. (see `--format` above)."
msgstr "`ls-tree` 的输出格式由 `--format` 选项或其他改变格式的选项（如 `--name-only` 等）决定（参见上文的 `--format` ）。"

#. type: Plain text
#: en/git-ls-tree.txt:112
#, placeholders:'`--format`', priority:80
msgid "The use of certain `--format` directives is equivalent to using those options, but invoking the full formatting machinery can be slower than using an appropriate formatting option."
msgstr "使用某些 `--format` 指令等同于使用这些选项，但调用完整的格式化机制可能比使用适当的格式化选项要慢。"

#. type: Plain text
#: en/git-ls-tree.txt:116
#, placeholders:'`--format`', priority:80
msgid "In cases where the `--format` would exactly map to an existing option `ls-tree` will use the appropriate faster path. Thus the default format is equivalent to:"
msgstr "在 `--format` 与现有选项完全对应的情况下，`ls-tree` 将使用适当的更快路径。因此，默认格式相当于："

#. type: Plain text
#: en/git-ls-tree.txt:118
#, no-wrap, priority:80
msgid "\t%(objectmode) %(objecttype) %(objectname)%x09%(path)\n"
msgstr "\t%(对象模式) %(对象类型) %(对象名)%x09%(路径)\n"

#. type: Plain text
#: en/git-ls-tree.txt:121
#, placeholders:'`--index-info':'--stdin`':'git update-index', priority:80
msgid "This output format is compatible with what `--index-info --stdin` of 'git update-index' expects."
msgstr "该输出格式与 'git update-index' 的 `--index-info--stdin` 所期望的格式兼容。"

#. type: Plain text
#: en/git-ls-tree.txt:123
#, placeholders:'`-l`', priority:80
msgid "When the `-l` option is used, format changes to"
msgstr "当使用 `-l` 选项时，格式变为"

#. type: Plain text
#: en/git-ls-tree.txt:125
#, no-wrap, priority:80
msgid "\t%(objectmode) %(objecttype) %(objectname) %(objectsize:padded)%x09%(path)\n"
msgstr "\t%(对象模式) %(对象类型) %(对象名) %(对象大小:padded)%x09%(路径)\n"

#. type: Plain text
#: en/git-ls-tree.txt:129
#, priority:80
msgid "Object size identified by <objectname> is given in bytes, and right-justified with minimum width of 7 characters. Object size is given only for blobs (file) entries; for other entries `-` character is used in place of size."
msgstr "<对象名> 标识的对象大小以字节为单位，右对齐，最小宽度为 7 个字符。 对象大小仅用于 blobs（文件）条目；对于其他条目，使用 `-` 字符代替大小。"

#. type: Plain text
#: en/git-ls-tree.txt:136
#, priority:80
msgid "Customized format:"
msgstr "定制格式："

#. type: Plain text
#: en/git-ls-tree.txt:143
#, no-wrap, placeholders:'git ls-tree':'--format=', priority:80
msgid "\tgit ls-tree --format='%(objectname) %(path)' <tree-ish>\n"
msgstr "\tgit ls-tree --format='%(对象名) %(路径)' <树状对象>\n"

#. type: Plain text
#: en/git-ls-tree.txt:150
#, priority:80
msgid "Various values from structured fields can be used to interpolate into the resulting output. For each outputting line, the following names can be used:"
msgstr "结构化字段中的各种值可用于插值到输出结果中。每个输出行可以使用以下名称："

#. type: Plain text
#: en/git-ls-tree.txt:153
#, priority:80
msgid "The mode of the object."
msgstr "对象的模式。"

#. type: Plain text
#: en/git-ls-tree.txt:155
#, priority:80
msgid "The type of the object (`commit`, `blob` or `tree`)."
msgstr "对象的类型（`commit`、`blob` 或 `tree`）。"

#. type: Plain text
#: en/git-ls-tree.txt:157
#, priority:80
msgid "The name of the object."
msgstr "对象的名称。"

#. type: Plain text
#: en/git-ls-tree.txt:160
#, priority:80
msgid "The size of a `blob` object (\"-\" if it's a `commit` or `tree`). It also supports a padded format of size with \"%(objectsize:padded)\"."
msgstr "`blob` 对象的大小（如果是 `commit` 或 `tree` ，则为 \"-\" ）。 它还支持 \"%(对象大小:padded)\" 的填充大小格式。"

#. type: Plain text
#: en/git-ls-tree.txt:162
#, priority:80
msgid "The pathname of the object."
msgstr "对象的路径名。"

#. type: Title =
#: en/git-mailinfo.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-mailinfo(1)"
msgstr "git-mailinfo(1)"

#. type: Plain text
#: en/git-mailinfo.txt:7
#, placeholders:'git-mailinfo', priority:100
msgid "git-mailinfo - Extracts patch and authorship from a single e-mail message"
msgstr "git-mailinfo - 从单个电子邮件信息中提取补丁和作者"

#. type: Plain text
#: en/git-mailinfo.txt:15
#, no-wrap, placeholders:'--encoding=':'[--quoted-cr=', priority:100
msgid ""
"'git mailinfo' [-k|-b] [-u | --encoding=<encoding> | -n]\n"
"\t       [--[no-]scissors] [--quoted-cr=<action>]\n"
"\t       <msg> <patch>\n"
msgstr ""
"'git mailinfo' [-k|-b] [-u | --encoding=<编码> | -n]\n"
"\t       [--[no-]scissors] [--quoted-cr=<行为>]\n"
"\t       <消息> <补丁>\n"

#. type: Plain text
#: en/git-mailinfo.txt:25
#, placeholders:'linkgit:git-am[1]', priority:100
msgid "Reads a single e-mail message from the standard input, and writes the commit log message in <msg> file, and the patches in <patch> file. The author name, e-mail and e-mail subject are written out to the standard output to be used by 'git am' to create a commit. It is usually not necessary to use this command directly. See linkgit:git-am[1] instead."
msgstr "从标准输入中读取一条电子邮件，并将提交日志信息写入<msg> 文件，将补丁写入<patch>文件。 作者姓名、电子邮件和电子邮件主题会被写到标准输出，以便被 'git am' 用来创建一个提交。 通常没有必要直接使用这个命令。 请参见 linkgit:git-am[1]。"

#. type: Plain text
#: en/git-mailinfo.txt:34
#, placeholders:'git format-patch', priority:100
msgid "Usually the program removes email cruft from the Subject: header line to extract the title line for the commit log message. This option prevents this munging, and is most useful when used to read back 'git format-patch -k' output."
msgstr "通常情况下，程序会从Subject: header 行中删除电子邮件的残余部分，以提取提交日志信息的标题行。 这个选项可以防止这种删除，在用于回读 'git format-patch -k' 输出时最有用。"

#. type: Plain text
#: en/git-mailinfo.txt:36
#, priority:100
msgid "Specifically, the following are removed until none of them remain:"
msgstr "具体来说，以下内容会被删除，直到一个都不剩："

#. type: Plain text
#: en/git-mailinfo.txt:39
#, priority:100
msgid "Leading and trailing whitespace."
msgstr "前导和尾部的多余空白字符。"

#. type: Plain text
#: en/git-mailinfo.txt:41
#, priority:100
msgid "Leading `Re:`, `re:`, and `:`."
msgstr "前导的的 `Re:`，`re:`，和 `:`。"

#. type: Plain text
#: en/git-mailinfo.txt:43
#, priority:100
msgid "Leading bracketed strings (between `[` and `]`, usually"
msgstr "前导括号内的字符串（在 `[` 和 `]` 之间，通常是"

#. type: Plain text
#: en/git-mailinfo.txt:44
#, priority:100
msgid "`[PATCH]`)."
msgstr "`[PATCH]`）。"

#. type: Plain text
#: en/git-mailinfo.txt:48
#, priority:100
msgid "Finally, runs of whitespace are normalized to a single ASCII space character."
msgstr "最后，空格被规范化为一个ASCII空格字符。"

#. type: Plain text
#: en/git-mailinfo.txt:53
#, priority:100
msgid "When -k is not in effect, all leading strings bracketed with '[' and ']' pairs are stripped. This option limits the stripping to only the pairs whose bracketed string contains the word \"PATCH\"."
msgstr "当-k 不生效时，所有用 '[' 和 ']' 对括起来的前导字符串都被剥离。 这个选项限制了剥离的范围，只限于括号内的字符串包含 \"PATCH \" 一词的对括号。"

#. type: Plain text
#: en/git-mailinfo.txt:60
#, priority:100
msgid "The commit log message, author name and author email are taken from the e-mail, and after minimally decoding MIME transfer encoding, re-coded in the charset specified by `i18n.commitEncoding` (defaulting to UTF-8) by transliterating them. This used to be optional but now it is the default."
msgstr "提交日志信息、作者姓名和作者的电子邮件来自电子邮件，在对 MIME 传输编码进行最小化解码后，通过音译将其重新编码为 `i18n.commitEncoding` 指定的字符集（默认为 UTF-8）。 这曾经是可选的，但现在是默认的。"

#. type: Plain text
#: en/git-mailinfo.txt:63
#, priority:100
msgid "Note that the patch is always used as-is without charset conversion, even with this flag."
msgstr "注意，即使有这个标志，补丁也总是按原样使用，不进行字符集转换。"

#. type: Plain text
#: en/git-mailinfo.txt:67
#, priority:100
msgid "Similar to -u. But when re-coding, the charset specified here is used instead of the one specified by `i18n.commitEncoding` or UTF-8."
msgstr "与 -u 类似。 但在重新编码时，使用这里指定的字符集，而不是 `i18n.commitEncoding` 或 UTF-8 所指定的。"

#. type: Plain text
#: en/git-mailinfo.txt:70
#, priority:100
msgid "Disable all charset re-coding of the metadata."
msgstr "禁用元数据的所有字符集重新编码。"

#. type: Plain text
#: en/git-mailinfo.txt:75
#, priority:100
msgid "Copy the Message-ID header at the end of the commit message. This is useful in order to associate commits with mailing list discussions."
msgstr "复制提交信息末尾的 Message-ID 头。 这对于将提交与邮件列表讨论联系起来是很有用的。"

#. type: Plain text
#: en/git-mailinfo.txt:83
#, priority:100
msgid "Remove everything in body before a scissors line (e.g. \"-- >8 --\"). The line represents scissors and perforation marks, and is used to request the reader to cut the message at that line. If that line appears in the body of the message before the patch, everything before it (including the scissors line itself) is ignored when this option is used."
msgstr "删除正文中剪刀线之前的所有内容（如\"-->8--\"）。 这条线代表剪刀和打孔的标记，用来要求读者在该线处剪切信息。 如果该行出现在邮件正文中的补丁之前，当使用该选项时，它之前的所有内容（包括剪刀线本身）都会被忽略。"

#. type: Plain text
#: en/git-mailinfo.txt:88
#, priority:100
msgid "This is useful if you want to begin your message in a discussion thread with comments and suggestions on the message you are responding to, and to conclude it with a patch submission, separating the discussion and the beginning of the proposed commit log message with a scissors line."
msgstr "如果你想在讨论线中开始你的信息，对你所回应的信息提出评论和建议，并以提交补丁作为结束，用剪刀线把讨论和建议的提交日志信息的开头分开，这很有用。"

#. type: Plain text
#: en/git-mailinfo.txt:90
#, placeholders:'mailinfo.scissors', priority:100
msgid "This can be enabled by default with the configuration option mailinfo.scissors."
msgstr "这可以通过配置选项 mailinfo.scissors 来默认启用。"

#. type: Plain text
#: en/git-mailinfo.txt:93
#, placeholders:'mailinfo.scissors', priority:100
msgid "Ignore scissors lines. Useful for overriding mailinfo.scissors settings."
msgstr "忽略剪切线。对于覆盖 mailinfo.scissors 设置很有用。"

#. type: Plain text
#: en/git-mailinfo.txt:98
#, priority:100
msgid "Action when processes email messages sent with base64 or quoted-printable encoding, and the decoded lines end with a CRLF instead of a simple LF."
msgstr "当处理以 base64 或 quoted-printable 编码发送的电子邮件，并且解码后的行以 CRLF 而不是简单的 LF 结尾时，就会启用。"

#. type: Plain text
#: en/git-mailinfo.txt:100
#, priority:100
msgid "The valid actions are:"
msgstr "有效的行为是："

#. type: Plain text
#: en/git-mailinfo.txt:103
#, priority:100
msgid "`nowarn`: Git will do nothing when such a CRLF is found."
msgstr "`nowarn`： 当发现这样的 CRLF 时，Git将不做任何事情。"

#. type: Plain text
#: en/git-mailinfo.txt:104
#, priority:100
msgid "`warn`: Git will issue a warning for each message if such a CRLF is"
msgstr "`warn`： 如果有这样的 CRLF，Git 会对每条信息发出警告"

#. type: Plain text
#: en/git-mailinfo.txt:105
#, priority:100
msgid "found."
msgstr "找到了。"

#. type: Plain text
#: en/git-mailinfo.txt:106
#, priority:100
msgid "`strip`: Git will convert those CRLF to LF."
msgstr "`strip`： Git 将把这些 CRLF 转换为 LF。"

#. type: Plain text
#: en/git-mailinfo.txt:110
#, placeholders:'mailinfo.quotedCR', priority:100
msgid "The default action could be set by configuration option `mailinfo.quotedCR`. If no such configuration option has been set, `warn` will be used."
msgstr "默认动作可以通过配置选项 `mailinfo.quotedCR` 设置。 如果没有设置这样的配置选项，将使用 `warn`。"

#. type: Labeled list
#: en/git-mailinfo.txt:111
#, no-wrap, priority:100
msgid "<msg>"
msgstr "<消息>"

#. type: Plain text
#: en/git-mailinfo.txt:114
#, priority:100
msgid "The commit log message extracted from e-mail, usually except the title line which comes from e-mail Subject."
msgstr "从电子邮件中提取的提交日志信息，通常除了来自电子邮件主题的标题行。"

#. type: Labeled list
#: en/git-mailinfo.txt:115
#, no-wrap, priority:100
msgid "<patch>"
msgstr "<补丁>"

#. type: Plain text
#: en/git-mailinfo.txt:117
#, priority:100
msgid "The patch extracted from e-mail."
msgstr "从电子邮件中提取的补丁。"

#. type: Title =
#: en/git-mailsplit.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-mailsplit(1)"
msgstr "git-mailsplit(1)"

#. type: Plain text
#: en/git-mailsplit.txt:7
#, placeholders:'git-mailsplit', priority:100
msgid "git-mailsplit - Simple UNIX mbox splitter program"
msgstr "git-mailsplit - 简单的UNIX mbox分割程序"

#. type: Plain text
#: en/git-mailsplit.txt:13
#, ignore-ellipsis, no-wrap, placeholders:'[--keep-cr]':'[--mboxrd]', priority:100
msgid ""
"'git mailsplit' [-b] [-f<nn>] [-d<prec>] [--keep-cr] [--mboxrd]\n"
"\t\t-o<directory> [--] [(<mbox>|<Maildir>)...]\n"
msgstr ""
"'git mailsplit' [-b] [-f<nn>] [-d<prec>] [--keep-cr] [--mboxrd]\n"
"\t\t-o<目录> [--] [(<mbox>|<Maildir>)...]\n"

#. type: Plain text
#: en/git-mailsplit.txt:18
#, priority:100
msgid "Splits a mbox file or a Maildir into a list of files: \"0001\" \"0002\" .. in the specified directory so you can process them further from there."
msgstr "将一个 mbox 文件或一个 Maildir 分割成一个文件列表： \"0001\" \"0002\"...... 存放在指定的目录中，这样你就可以从那里进一步处理它们。"

#. type: Plain text
#: en/git-mailsplit.txt:21
#, priority:100
msgid "Maildir splitting relies upon filenames being sorted to output patches in the correct order."
msgstr "Maildir 分割依赖于文件名的排序，以便按照正确的顺序输出补丁。"

#. type: Labeled list
#: en/git-mailsplit.txt:24
#, no-wrap, priority:100
msgid "<mbox>"
msgstr "<mbox>"

#. type: Plain text
#: en/git-mailsplit.txt:27
#, priority:100
msgid "Mbox file to split. If not given, the mbox is read from the standard input."
msgstr "要分割的 Mbox 文件。 如果没有给出，则从标准输入中读取 Mbox。"

#. type: Labeled list
#: en/git-mailsplit.txt:28
#, no-wrap, priority:100
msgid "<Maildir>"
msgstr "<Maildir>"

#. type: Plain text
#: en/git-mailsplit.txt:31
#, priority:100
msgid "Root of the Maildir to split. This directory should contain the cur, tmp and new subdirectories."
msgstr "要分割的 Maildir 的根目录。这个目录应该包含 cur、tmp 和新的子目录。"

#. type: Labeled list
#: en/git-mailsplit.txt:32
#, no-wrap, priority:100
msgid "-o<directory>"
msgstr "-o<目录>"

#. type: Plain text
#: en/git-mailsplit.txt:34
#, priority:100
msgid "Directory in which to place the individual messages."
msgstr "放置各个信息的目录。"

#. type: Plain text
#: en/git-mailsplit.txt:38
#, priority:100
msgid "If any file doesn't begin with a From line, assume it is a single mail message instead of signaling an error."
msgstr "如果任何文件不以发件人行开头，则假定它是单封邮件，而不是发出错误信号。"

#. type: Labeled list
#: en/git-mailsplit.txt:39
#, no-wrap, priority:100
msgid "-d<prec>"
msgstr "-d<prec>"

#. type: Plain text
#: en/git-mailsplit.txt:43
#, priority:100
msgid "Instead of the default 4 digits with leading zeros, different precision can be specified for the generated filenames."
msgstr "可以为生成的文件名指定不同的精度，而不是默认的带前导零的4位数。"

#. type: Labeled list
#: en/git-mailsplit.txt:44
#, no-wrap, priority:100
msgid "-f<nn>"
msgstr "-f<nn>"

#. type: Plain text
#: en/git-mailsplit.txt:47
#, priority:100
msgid "Skip the first <nn> numbers, for example if -f3 is specified, start the numbering with 0004."
msgstr "跳过第一个 <nn>数字，例如如果指定了-f3，就从 0004 开始编号。"

#. type: Labeled list
#: en/git-mailsplit.txt:48
#, ignore-same, no-wrap, priority:100
msgid "--keep-cr"
msgstr "--keep-cr"

#. type: Plain text
#: en/git-mailsplit.txt:50
#, priority:100
msgid "Do not remove `\\r` from lines ending with `\\r\\n`."
msgstr "不要从以 `\\r\\n` 结尾的行中删除`\\r`。"

#. type: Labeled list
#: en/git-mailsplit.txt:51
#, ignore-same, no-wrap, priority:100
msgid "--mboxrd"
msgstr "--mboxrd"

#. type: Plain text
#: en/git-mailsplit.txt:54
#, priority:100
msgid "Input is of the \"mboxrd\" format and \"^>+From \" line escaping is reversed."
msgstr "输入是 \"mboxrd\" 格式，\"^>+From\" 行转义被颠倒。"

#. type: Title =
#: en/git-merge-base.txt:2
#, ignore-same, no-wrap, priority:80
msgid "git-merge-base(1)"
msgstr "git-merge-base(1)"

#. type: Plain text
#: en/git-merge-base.txt:7
#, placeholders:'git-merge-base', priority:80
msgid "git-merge-base - Find as good common ancestors as possible for a merge"
msgstr "git-merge-base - 为合并找到尽可能好的共同祖先"

#. type: Plain text
#: en/git-merge-base.txt:17
#, ignore-ellipsis, no-wrap, placeholders:'git merge-base':'--all]':'git merge-base':'--all]':'--octopus':'git merge-base':'--is-ancestor':'git merge-base':'--independent':'git merge-base':'--fork-point', priority:80
msgid ""
"'git merge-base' [-a | --all] <commit> <commit>...\n"
"'git merge-base' [-a | --all] --octopus <commit>...\n"
"'git merge-base' --is-ancestor <commit> <commit>\n"
"'git merge-base' --independent <commit>...\n"
"'git merge-base' --fork-point <ref> [<commit>]\n"
msgstr ""
"'git merge-base' [-a | --all] <提交> <提交>...\n"
"'git merge-base' [-a | --all] --octopus <提交>...\n"
"'git merge-base' --is-ancestor <提交> <提交>\n"
"'git merge-base' --independent <提交>...\n"
"'git merge-base' --fork-point <引用> [<提交>]\n"

#. type: Plain text
#: en/git-merge-base.txt:27
#, placeholders:'git merge-base', priority:80
msgid "'git merge-base' finds the best common ancestor(s) between two commits to use in a three-way merge. One common ancestor is 'better' than another common ancestor if the latter is an ancestor of the former. A common ancestor that does not have any better common ancestor is a 'best common ancestor', i.e. a 'merge base'. Note that there can be more than one merge base for a pair of commits."
msgstr "'git merge-base' 会找出两个提交之间的最佳共同祖先，用于三方合并。 如果一个公共祖先是另一个公共祖先的祖先，那么后者就比前者 “更好”。 没有更好的共同祖先的共同祖先就是 “最佳共同祖先”，即 “合并基础”。 请注意，一对提交可以有多个合并基础。"

#. type: Title -
#: en/git-merge-base.txt:29
#, no-wrap, priority:80
msgid "OPERATION MODES"
msgstr "运行模式"

#. type: Plain text
#: en/git-merge-base.txt:33
#, priority:80
msgid "In the most common special case, specifying only two commits on the command line means computing the merge base between the given two commits."
msgstr "在最常见的特殊情况下，在命令行中只指定两个提交，意味着要计算给定的两个提交之间的合并基数。"

#. type: Plain text
#: en/git-merge-base.txt:38
#, priority:80
msgid "More generally, among the two commits to compute the merge base from, one is specified by the first commit argument on the command line; the other commit is a (possibly hypothetical) commit that is a merge across all the remaining commits on the command line."
msgstr "一般来说，在计算合并基础的两个提交中，一个由命令行上的第一个提交参数指定；另一个提交是一个（可能是假设的）提交，是命令行上所有剩余提交的合并。"

#. type: Plain text
#: en/git-merge-base.txt:42
#, placeholders:'linkgit:git-show-branch[1]':'`--merge-base`', priority:80
msgid "As a consequence, the 'merge base' is not necessarily contained in each of the commit arguments if more than two commits are specified. This is different from linkgit:git-show-branch[1] when used with the `--merge-base` option."
msgstr "因此，如果指定了两个以上的提交，‘合并基础’ 并不一定包含在每个提交参数中。当使用 `--merge-base` 选项的时候，这不同于 linkgit:git-show-branch[1]。"

#. type: Labeled list
#: en/git-merge-base.txt:43
#, ignore-same, no-wrap, priority:80
msgid "--octopus"
msgstr "--octopus"

#. type: Plain text
#: en/git-merge-base.txt:47
#, placeholders:'git show-branch':'--merge-base', priority:80
msgid "Compute the best common ancestors of all supplied commits, in preparation for an n-way merge. This mimics the behavior of 'git show-branch --merge-base'."
msgstr "计算所有提交的最佳公共祖先，为 n 次合并做准备。 这模仿了 'git show-branch --merge-base' 的行为。"

#. type: Labeled list
#: en/git-merge-base.txt:48 en/git-show-branch.txt:89
#, ignore-same, no-wrap, priority:100
msgid "--independent"
msgstr "--independent"

#. type: Plain text
#: en/git-merge-base.txt:54
#, placeholders:'git show-branch':'--independent', priority:80
msgid "Instead of printing merge bases, print a minimal subset of the supplied commits with the same ancestors. In other words, among the commits given, list those which cannot be reached from any other. This mimics the behavior of 'git show-branch --independent'."
msgstr "与其打印合并库，不如打印所提供的具有相同祖先的提交的最小子集。 换句话说，在给出的提交中，列出那些无法从其他提交到达的提交。 这模仿了 'git show-branch--independent' 的行为。"

#. type: Labeled list
#: en/git-merge-base.txt:55
#, ignore-same, no-wrap, priority:80
msgid "--is-ancestor"
msgstr "--is-ancestor"

#. type: Plain text
#: en/git-merge-base.txt:59
#, priority:80
msgid "Check if the first <commit> is an ancestor of the second <commit>, and exit with status 0 if true, or with status 1 if not. Errors are signaled by a non-zero status that is not 1."
msgstr "检查第一个 <提交> 是否是第二个 <提交> 的祖先，如果是，则以状态 0 退出；如果不是，则以状态 1 退出。 如果状态不是 0，则表示出错。"

#. type: Labeled list
#: en/git-merge-base.txt:60 en/git-rebase.txt:451
#, ignore-same, no-wrap, priority:100
msgid "--fork-point"
msgstr "--fork-point"

#. type: Plain text
#: en/git-merge-base.txt:68
#, priority:80
msgid "Find the point at which a branch (or any history that leads to <commit>) forked from another branch (or any reference) <ref>. This does not just look for the common ancestor of the two commits, but also takes into account the reflog of <ref> to see if the history leading to <commit> forked from an earlier incarnation of the branch <ref> (see discussion of this mode below)."
msgstr "查找一个分支（或导致 <提交> 的任何历史）从另一个分支（或任何引用）<引用> 分支出去的时间点。这不仅仅是查找两个提交的共同祖先，而且还要考虑 <引用> 的引用日志，以查看导致 <提交> 的历史是否从分支 <引用> 的早期化身分叉而来（请参阅下文对该模式的讨论）。"

#. type: Plain text
#: en/git-merge-base.txt:74
#, priority:80
msgid "Output all merge bases for the commits, instead of just one."
msgstr "输出提交的所有合并基础，而不是只有一个。"

#. type: Plain text
#: en/git-merge-base.txt:80
#, placeholders:'git merge-base', priority:80
msgid "Given two commits 'A' and 'B', `git merge-base A B` will output a commit which is reachable from both 'A' and 'B' through the parent relationship."
msgstr "给定两个提交 'A' 和 'B'，`git merge-base A B` 会输出一个通过父级关系从 'A' 和 'B' 都能到达的提交。"

#. type: Plain text
#: en/git-merge-base.txt:82
#, priority:80
msgid "For example, with this topology:"
msgstr "例如，采用这种拓扑结构："

#. type: delimited block .
#: en/git-merge-base.txt:87
#, no-wrap, placeholders:'o---o---o---':'---o---1---o---o---o---A', priority:80
msgid ""
"\t o---o---o---B\n"
"\t/\n"
"---o---1---o---o---o---A\n"
msgstr ""
"\t o---o---o---B\n"
"\t/\n"
"---o---1---o---o---o---A\n"

#. type: Plain text
#: en/git-merge-base.txt:90
#, priority:80
msgid "the merge base between 'A' and 'B' is '1'."
msgstr "'A' 和 'B' 之间的合并基数为 '1'。"

#. type: Plain text
#: en/git-merge-base.txt:94
#, placeholders:'git merge-base', priority:80
msgid "Given three commits 'A', 'B', and 'C', `git merge-base A B C` will compute the merge base between 'A' and a hypothetical commit 'M', which is a merge between 'B' and 'C'. For example, with this topology:"
msgstr "给定三个提交 'A' 、'B' 和 'C'， `git merge-base A B C` 会计算 'A' 和假设提交 'M' 之间的合并基础，'M' 是 'B' 和 'C' 之间的合并。 例如这个拓扑："

#. type: delimited block .
#: en/git-merge-base.txt:101
#, no-wrap, placeholders:'o---o---o---o---':'o---o---o---':'---2---1---o---o---o---A', priority:80
msgid ""
"       o---o---o---o---C\n"
"      /\n"
"     /   o---o---o---B\n"
"    /   /\n"
"---2---1---o---o---o---A\n"
msgstr ""
"       o---o---o---o---C\n"
"      /\n"
"     /   o---o---o---B\n"
"    /   /\n"
"---2---1---o---o---o---A\n"

#. type: Plain text
#: en/git-merge-base.txt:105
#, placeholders:'git merge-base', priority:80
msgid "the result of `git merge-base A B C` is '1'. This is because the equivalent topology with a merge commit 'M' between 'B' and 'C' is:"
msgstr "`git merge-base A B C` 的结果是 '1'。 这是因为 'B' 和 'C' 之间有一个合并提交 'M' 的等效拓扑结构是："

#. type: delimited block .
#: en/git-merge-base.txt:113
#, no-wrap, placeholders:'o---o---o---o---o':'o---o---o---o---':'---2---1---o---o---o---A', priority:80
msgid ""
"       o---o---o---o---o\n"
"      /                 \\\n"
"     /   o---o---o---o---M\n"
"    /   /\n"
"---2---1---o---o---o---A\n"
msgstr ""
"       o---o---o---o---o\n"
"      /                 \\\n"
"     /   o---o---o---o---M\n"
"    /   /\n"
"---2---1---o---o---o---A\n"

#. type: Plain text
#: en/git-merge-base.txt:118
#, placeholders:'git merge-base', priority:80
msgid "and the result of `git merge-base A M` is '1'. Commit '2' is also a common ancestor between 'A' and 'M', but '1' is a better common ancestor, because '2' is an ancestor of '1'. Hence, '2' is not a merge base."
msgstr "和 `git merge-base A M` 的结果是 '1' 。 提交 '2' 也是 'A' 和 'M' 的共同祖先，但 '1' 是更好的共同祖先，因为 '2' 是 '1' 的祖先。 因此，'2' 不是合并基础。"

#. type: Plain text
#: en/git-merge-base.txt:121
#, placeholders:'git merge-base':'--octopus', priority:80
msgid "The result of `git merge-base --octopus A B C` is '2', because '2' is the best common ancestor of all commits."
msgstr "`git merge-base --octopus A B C` 的结果是 '2' ，因为 '2' 是所有提交的最佳共同祖先。"

#. type: Plain text
#: en/git-merge-base.txt:124
#, priority:80
msgid "When the history involves criss-cross merges, there can be more than one 'best' common ancestor for two commits. For example, with this topology:"
msgstr "当历史涉及交叉合并时，两个提交的 ‘最佳’ 共同祖先可能不止一个。 例如这个拓扑："

#. type: delimited block .
#: en/git-merge-base.txt:131
#, no-wrap, placeholders:'---1---o---A':'---2---o---o---B', priority:80
msgid ""
"---1---o---A\n"
"    \\ /\n"
"     X\n"
"    / \\\n"
"---2---o---o---B\n"
msgstr ""
"---1---o---A\n"
"    \\ /\n"
"     X\n"
"    / \\\n"
"---2---o---o---B\n"

#. type: Plain text
#: en/git-merge-base.txt:136
#, placeholders:'`--all`', priority:80
msgid "both '1' and '2' are merge bases of A and B. Neither one is better than the other (both are 'best' merge bases). When the `--all` option is not given, it is unspecified which best one is output."
msgstr "'1' 和 '2' 都是 A 和 B 的合并基础。 如果没有给出 `--all` 选项，则不会指定输出哪个是最好的。"

#. type: Plain text
#: en/git-merge-base.txt:141
#, priority:80
msgid "A common idiom to check \"fast-forward-ness\" between two commits A and B is (or at least used to be) to compute the merge base between A and B, and check if it is the same as A, in which case, A is an ancestor of B. You will see this idiom used often in older scripts."
msgstr "检查两个提交 A 和 B 之间的 “快进性” 的一个常见习语是（或至少曾经是）计算 A 和 B 之间的合并基数，并检查它是否与 A 相同，在这种情况下，A 就是 B 的祖先。"

#. type: delimited block .
#: en/git-merge-base.txt:148
#, ignore-ellipsis, no-wrap, placeholders:'git rev-parse':'--verify':'git merge-base', priority:80
msgid ""
"A=$(git rev-parse --verify A)\n"
"if test \"$A\" = \"$(git merge-base A B)\"\n"
"then\n"
"\t... A is an ancestor of B ...\n"
"fi\n"
msgstr ""
"A=$(git rev-parse --verify A)\n"
"if test \"$A\" = \"$(git merge-base A B)\"\n"
"then\n"
"\t... A 是 B 的一个祖先 ...\n"
"fi\n"

#. type: Plain text
#: en/git-merge-base.txt:151
#, priority:80
msgid "In modern git, you can say this in a more direct way:"
msgstr "在现代 Git 中，可以用更直接的方式来表达："

#. type: delimited block .
#: en/git-merge-base.txt:157
#, ignore-ellipsis, no-wrap, placeholders:'git merge-base':'--is-ancestor', priority:80
msgid ""
"if git merge-base --is-ancestor A B\n"
"then\n"
"\t... A is an ancestor of B ...\n"
"fi\n"
msgstr ""
"if git merge-base --is-ancestor A B\n"
"then\n"
"\t... A 是 B 的一个祖先 ...\n"
"fi\n"

#. type: Plain text
#: en/git-merge-base.txt:160
#, priority:80
msgid "instead."
msgstr "代替。"

#. type: Title -
#: en/git-merge-base.txt:162
#, no-wrap, priority:80
msgid "Discussion on fork-point mode"
msgstr "关于叉点模式的讨论"

#. type: Plain text
#: en/git-merge-base.txt:168
#, priority:80
msgid "After working on the `topic` branch created with `git switch -c topic origin/master`, the history of remote-tracking branch `origin/master` may have been rewound and rebuilt, leading to a history of this shape:"
msgstr "在使用 `git switch -c topic origin/master` 创建的 `topic` 分支上工作后，远程跟踪分支 `origin/master` 的历史可能会被倒带和重建，从而导致出现这种形状的历史："

#. type: delimited block .
#: en/git-merge-base.txt:177
#, no-wrap, placeholders:'o---':'---o---o---B1--o---o---o---B':'---D1---D', priority:80
msgid ""
"\t\t o---B2\n"
"\t\t/\n"
"---o---o---B1--o---o---o---B (origin/master)\n"
"\t\\\n"
"\t B0\n"
"\t  \\\n"
"\t   D0---D1---D (topic)\n"
msgstr ""
"\t\t o---B2\n"
"\t\t/\n"
"---o---o---B1--o---o---o---B (origin/master)\n"
"\t\\\n"
"\t B0\n"
"\t  \\\n"
"\t   D0---D1---D (topic)\n"

#. type: Plain text
#: en/git-merge-base.txt:184
#, priority:80
msgid "where `origin/master` used to point at commits B0, B1, B2 and now it points at B, and your `topic` branch was started on top of it back when `origin/master` was at B0, and you built three commits, D0, D1, and D, on top of it. Imagine that you now want to rebase the work you did on the topic on top of the updated origin/master."
msgstr "其中，`origin/master` 曾指向 B0、B1 和 B2 提交，现在则指向 B，而您的 `topic` 分支是在 `origin/master` 指向 B0 时在其上创建的，您在其上创建了 D0、D1 和 D 三个提交。 想象一下，你现在想在更新后的 origin/master 分支上重建你在主题上所做的工作。"

#. type: Plain text
#: en/git-merge-base.txt:190
#, placeholders:'git merge-base', priority:80
msgid "In such a case, `git merge-base origin/master topic` would return the parent of B0 in the above picture, but B0^..D is *not* the range of commits you would want to replay on top of B (it includes B0, which is not what you wrote; it is a commit the other side discarded when it moved its tip from B0 to B1)."
msgstr "在这种情况下，`git merge-base origin/master topic` 会返回上图中 B0 的父提交，但 B0^..D 并 *不是* 你想在 B 上重放的提交范围（它包括 B0，而 B0 并不是你写的内容；它是另一个提交从 B0 移到 B1 时丢弃的提交）。"

#. type: Plain text
#: en/git-merge-base.txt:198
#, placeholders:'git merge-base':'--fork-point', priority:80
msgid "`git merge-base --fork-point origin/master topic` is designed to help in such a case. It takes not only B but also B0, B1, and B2 (i.e. old tips of the remote-tracking branches your repository's reflog knows about) into account to see on which commit your topic branch was built and finds B0, allowing you to replay only the commits on your topic, excluding the commits the other side later discarded."
msgstr "`git merge-base --fork-point origin/master topic` 就是为这种情况而设计的。 它不仅会考虑 B，还会考虑 B0、B1 和 B2（即仓库的引用日志所知道的远程跟踪分支的旧提示），以查看你的特性分支是在哪个提交上建立的，并找到 B0，从而只重放你的特性上的提交，而不包括对方后来丢弃的提交。"

#. type: Plain text
#: en/git-merge-base.txt:200
#, priority:80
msgid "Hence"
msgstr "因此"

#. type: Plain text
#: en/git-merge-base.txt:202
#, no-wrap, placeholders:'fork_point':'git merge-base':'--fork-point', priority:80
msgid "    $ fork_point=$(git merge-base --fork-point origin/master topic)\n"
msgstr "    $ fork_point=$(git merge-base --fork-point origin/master topic)\n"

#. type: Plain text
#: en/git-merge-base.txt:204
#, priority:80
msgid "will find B0, and"
msgstr "会发现 B0，而"

#. type: Plain text
#: en/git-merge-base.txt:206
#, no-wrap, placeholders:'--onto':'$fork_point', priority:80
msgid "    $ git rebase --onto origin/master $fork_point topic\n"
msgstr "    $ git rebase --onto origin/master $fork_point topic\n"

#. type: Plain text
#: en/git-merge-base.txt:209
#, priority:80
msgid "will replay D0, D1, and D on top of B to create a new history of this shape:"
msgstr "将在 B 的基础上重放 D0、D1 和 D，以创建该形状的新历史："

#. type: delimited block .
#: en/git-merge-base.txt:218
#, no-wrap, placeholders:'o---':'---o---o---B1--o---o---o---B':'--D1':'--D':'---D1---D', priority:80
msgid ""
"\t\t o---B2\n"
"\t\t/\n"
"---o---o---B1--o---o---o---B (origin/master)\n"
"\t\\                   \\\n"
"\t B0                  D0'--D1'--D' (topic - updated)\n"
"\t  \\\n"
"\t   D0---D1---D (topic - old)\n"
msgstr ""
"\t\t o---B2\n"
"\t\t/\n"
"---o---o---B1--o---o---o---B (origin/master)\n"
"\t\\                   \\\n"
"\t B0                  D0'--D1'--D' (topic - updated)\n"
"\t  \\\n"
"\t   D0---D1---D (topic - old)\n"

# ERROR: --fork-point not found in translation
# ERROR: --fork-point not found in translation
#. type: Plain text
#: en/git-merge-base.txt:226
#, placeholders:'`--fork-point`':'`--fork-point`', priority:80
msgid "A caveat is that older reflog entries in your repository may be expired by `git gc`. If B0 no longer appears in the reflog of the remote-tracking branch `origin/master`, the `--fork-point` mode obviously cannot find it and fails, avoiding to give a random and useless result (such as the parent of B0, like the same command without the `--fork-point` option gives)."
msgstr "需要注意的是，仓库中较早的引用日志条目可能会被 `git gc` 过期。 如果 B0 不再出现在远程跟踪分支 `origin/master` 的引用日志中，`--fork-point` 模式显然就找不到它，并会失败，从而避免给出一个随机而无用的结果（例如 B0 的父分支，就像不使用 `--fork-point` 选项的同一命令给出的结果一样）。"

# ERROR: --fork-point not found in translation
# ERROR: --fork-point not found in translation
#. type: Plain text
#: en/git-merge-base.txt:237
#, placeholders:'`--fork-point`':'git merge-base':'`--fork-point`', priority:80
msgid "Also, the remote-tracking branch you use the `--fork-point` mode with must be the one your topic forked from its tip. If you forked from an older commit than the tip, this mode would not find the fork point (imagine in the above sample history B0 did not exist, origin/master started at B1, moved to B2 and then B, and you forked your topic at origin/master^ when origin/master was B1; the shape of the history would be the same as above, without B0, and the parent of B1 is what `git merge-base origin/master topic` correctly finds, but the `--fork-point` mode will not, because it is not one of the commits that used to be at the tip of origin/master)."
msgstr "另外，使用 `--fork-point`（分叉点）\"模式的远程跟踪分支必须是你的主题从其顶点分叉出来的分支。 如果你从比顶端更早的提交中分叉，该模式将无法找到分叉点（想象一下，在上面的示例历史中，B0 并不存在，origin/master 从 B1 开始，移动到 B2，然后是 B，而你在 origin/master^ 分叉你的主题时，origin/master 是 B1；B1 的父提交会被 `git merge-base origin/master topic` 正确找到，但在 `-fork-point`模式下不会，因为它不是 origin/master 最前沿的提交之一）。"

#. type: Title -
#: en/git-merge-base.txt:240
#, no-wrap, priority:80
msgid "See also"
msgstr "另见"

#. type: Plain text
#: en/git-merge-base.txt:244
#, ignore-same, priority:80
msgid "linkgit:git-rev-list[1], linkgit:git-show-branch[1], linkgit:git-merge[1]"
msgstr "linkgit:git-rev-list[1], linkgit:git-show-branch[1], linkgit:git-merge[1]"

#. type: Title =
#: en/git-merge-file.txt:2
#, ignore-same, no-wrap, priority:90
msgid "git-merge-file(1)"
msgstr "git-merge-file(1)"

#. type: Plain text
#: en/git-merge-file.txt:7
#, placeholders:'git-merge-file', priority:90
msgid "git-merge-file - Run a three-way file merge"
msgstr "git-merge-file - 运行三方文件合并"

#. type: Plain text
#: en/git-merge-file.txt:15
#, no-wrap, placeholders:'git merge-file':'[--ours':'--theirs':'--union]':'--stdout]':'--quiet]':'[--marker-size=':'[--object-id]', priority:90
msgid ""
"'git merge-file' [-L <current-name> [-L <base-name> [-L <other-name>]]]\n"
"\t[--ours|--theirs|--union] [-p|--stdout] [-q|--quiet] [--marker-size=<n>]\n"
"\t[--[no-]diff3] [--object-id] <current> <base> <other>\n"
msgstr ""
"'git merge-file' [-L <当前名称> [-L <基本名称> [-L <另一个名称>]]]\n"
"\t[--ours|--theirs|--union] [-p|--stdout] [-q|--quiet] [--marker-size=<n>]\n"
"\t[--[no-]diff3] [--object-id] <当前文件> <基础文件> <另一个文件>\n"

#. type: Plain text
#: en/git-merge-file.txt:26
#, placeholders:'git merge-file':'git merge-file':'git merge-file', priority:90
msgid "Given three files `<current>`, `<base>` and `<other>`, 'git merge-file' incorporates all changes that lead from `<base>` to `<other>` into `<current>`. The result ordinarily goes into `<current>`. 'git merge-file' is useful for combining separate changes to an original. Suppose `<base>` is the original, and both `<current>` and `<other>` are modifications of `<base>`, then 'git merge-file' combines both changes."
msgstr "给定 <当前文件>、<基础文件> 和 <其他文件> 这三个文件，'git merge-file' 会将从 `<基础文件>` 到 `<另一个文件>` 的所有改动合并到 `<当前文件>` 中。合并后的结果通常会放入 `<当前文件>`。'git merge-file' 可用于合并对原文件的不同改动。假设 `<基础文件>`是原文件，而 `<当前文件>` 和 `<另一个文件>` 都是对 `<基础文件>` 的修改，那么 'git merge-file' 会合并这两处修改。"

#. type: Plain text
#: en/git-merge-file.txt:31
#, placeholders:'git merge-file', priority:90
msgid "A conflict occurs if both `<current>` and `<other>` have changes in a common segment of lines. If a conflict is found, 'git merge-file' normally outputs a warning and brackets the conflict with lines containing <<<<<<< and >>>>>>> markers. A typical conflict will look like this:"
msgstr "如果 `<当前文件>` 和 `<另一个文件>` 在共同的行段中都有改动，就会发生冲突。如果发现冲突，\"git merge-file\" 通常会输出警告，并用包含 <<<<<<< 和 >>>>>>> 标记的行括弧括住冲突。典型的冲突如下："

#. type: Plain text
#: en/git-merge-file.txt:37
#, no-wrap, priority:90
msgid ""
"\t<<<<<<< A\n"
"\tlines in file A\n"
"\t=======\n"
"\tlines in file B\n"
"\t>>>>>>> B\n"
msgstr ""
"\t<<<<<<< A\n"
"\t文件 A 中的某几行\n"
"\t=======\n"
"\t文件 B 中的某几行\n"
"\t>>>>>>> B\n"

#. type: Plain text
#: en/git-merge-file.txt:43
#, placeholders:'`--ours`':'`--theirs`':'`--union`':'`--marker-size`', priority:90
msgid "If there are conflicts, the user should edit the result and delete one of the alternatives. When `--ours`, `--theirs`, or `--union` option is in effect, however, these conflicts are resolved favouring lines from `<current>`, lines from `<other>`, or lines from both respectively. The length of the conflict markers can be given with the `--marker-size` option."
msgstr "如果存在冲突，用户应编辑结果并删除其中一个备选行。 但是，如果使用了 `--ours`、`--theirs` 或 `--union`选项，这些冲突就会分别以 `<当前文件>`、`<其他文件>` 或两者的行为优先。 冲突标记的长度可以用 `--marker-size` 选项给出。"

#. type: Plain text
#: en/git-merge-file.txt:47
#, placeholders:'`--object-id`', priority:90
msgid "If `--object-id` is specified, exactly the same behavior occurs, except that instead of specifying what to merge as files, it is specified as a list of object IDs referring to blobs."
msgstr "如果指定了 `--object-id`，则会发生完全相同的行为，只不过不是指定要合并为文件的内容，而是指定为指向 blob 的对象 ID 列表。"

#. type: Plain text
#: en/git-merge-file.txt:51
#, priority:90
msgid "The exit value of this program is negative on error, and the number of conflicts otherwise (truncated to 127 if there are more than that many conflicts). If the merge was clean, the exit value is 0."
msgstr "如果程序出错，则退出值为负数，否则退出值为冲突数（如果冲突数超过 127，则截断为 127）。如果合并无误，则退出值为 0。"

#. type: Plain text
#: en/git-merge-file.txt:55
#, placeholders:'git merge-file':'linkgit:git[1]', priority:90
msgid "'git merge-file' is designed to be a minimal clone of RCS 'merge'; that is, it implements all of RCS 'merge''s functionality which is needed by linkgit:git[1]."
msgstr "'git merge-file' 被设计为 RCS 'merge' 的最小克隆；也就是说，它实现了 RCS 'merge' 的所有功能，而这正是 linkgit:git[1] 所需要的。"

#. type: Labeled list
#: en/git-merge-file.txt:60
#, ignore-same, no-wrap, priority:90
msgid "--object-id"
msgstr "--object-id"

#. type: Plain text
#: en/git-merge-file.txt:63
#, priority:90
msgid "Specify the contents to merge as blobs in the current repository instead of files. In this case, the operation must take place within a valid repository."
msgstr "指定要合并的内容为当前仓库中的 blob，而不是文件。在这种情况下，操作必须在有效的仓库中进行。"

#. type: Plain text
#: en/git-merge-file.txt:67
#, placeholders:'`-p`', priority:90
msgid "If the `-p` option is specified, the merged file (including conflicts, if any) goes to standard output as normal; otherwise, the merged file is written to the object store and the object ID of its blob is written to standard output."
msgstr "如果指定了 `-p` 选项，合并后的文件（包括冲突（如果有的话））会像往常一样写入标准输出；否则，合并后的文件会写入对象存储空间，其 blob 的对象 ID 会写入标准输出。"

#. type: Labeled list
#: en/git-merge-file.txt:68
#, no-wrap, priority:90
msgid "-L <label>"
msgstr "-L <标签>"

#. type: Plain text
#: en/git-merge-file.txt:75
#, placeholders:'git merge-file', priority:90
msgid "This option may be given up to three times, and specifies labels to be used in place of the corresponding file names in conflict reports. That is, `git merge-file -L x -L y -L z a b c` generates output that looks like it came from files x, y and z instead of from files a, b and c."
msgstr "这个选项最多可以给出三次，它指定了在冲突报告中用来代替相应文件名的标签。也就是说，`git merge-file -L x -L y -L z a b c` 产生的输出看起来像是来自文件 x、y 和 z，而不是文件 a、b 和 c。"

#. type: Plain text
#: en/git-merge-file.txt:79
#, priority:90
msgid "Send results to standard output instead of overwriting `<current>`."
msgstr "将结果发送到标准输出，而不是覆盖 `<当前文件>`。"

#. type: Plain text
#: en/git-merge-file.txt:82
#, priority:90
msgid "Quiet; do not warn about conflicts."
msgstr "安静；不警告冲突。"

#. type: Labeled list
#: en/git-merge-file.txt:83
#, ignore-same, no-wrap, priority:90
msgid "--diff3"
msgstr "--diff3"

#. type: Plain text
#: en/git-merge-file.txt:85
#, priority:90
msgid "Show conflicts in \"diff3\" style."
msgstr "以 \"diff3\" 样式显示冲突。"

#. type: Labeled list
#: en/git-merge-file.txt:86
#, ignore-same, no-wrap, priority:90
msgid "--zdiff3"
msgstr "--zdiff3"

#. type: Plain text
#: en/git-merge-file.txt:88
#, priority:90
msgid "Show conflicts in \"zdiff3\" style."
msgstr "以 \"zdiff3\" 样式显示冲突。"

#. type: Labeled list
#: en/git-merge-file.txt:91
#, ignore-same, no-wrap, priority:90
msgid "--union"
msgstr "--union"

#. type: Plain text
#: en/git-merge-file.txt:94
#, priority:90
msgid "Instead of leaving conflicts in the file, resolve conflicts favouring our (or their or both) side of the lines."
msgstr "与其在文件中留下冲突，不如解决冲突，使冲突有利于我们（或他们或双方）。"

#. type: Plain text
#: en/git-merge-file.txt:101
#, placeholders:'linkgit:git-diff[1]':'`--diff-algorithm`', priority:90
msgid "Use a different diff algorithm while merging. The current default is \"myers\", but selecting more recent algorithm such as \"histogram\" can help avoid mismerges that occur due to unimportant matching lines (such as braces from distinct functions). See also linkgit:git-diff[1] `--diff-algorithm`."
msgstr "合并时使用不同的差异算法。目前的默认值是 \"myers\"，但选择更新颖的算法（如 \"histogram\"）有助于避免因不重要的匹配行（如不同函数的大括号）而导致的错误合并。另请参阅 linkgit:git-diff[1] `--diff-algorithm`。"

#. type: Labeled list
#: en/git-merge-file.txt:105
#, no-wrap, placeholders:'git merge-file':'README.my':'README.upstream', priority:90
msgid "`git merge-file README.my README README.upstream`"
msgstr "`git merge-file README.my README README.upstream`"

#. type: Plain text
#: en/git-merge-file.txt:109
#, placeholders:'README.my':'README.upstream':'README.my', priority:90
msgid "combines the changes of README.my and README.upstream since README, tries to merge them and writes the result into README.my."
msgstr "合并 README.my 和 README.upstream 自 README 以来的改动，尝试合并它们，并将结果写入 README.my。"

#. type: Labeled list
#: en/git-merge-file.txt:110
#, no-wrap, placeholders:'git merge-file', priority:90
msgid "`git merge-file -L a -L b -L c tmp/a123 tmp/b234 tmp/c345`"
msgstr "`git merge-file -L a -L b -L c tmp/a123 tmp/b234 tmp/c345`"

#. type: Plain text
#: en/git-merge-file.txt:114
#, priority:90
msgid "merges tmp/a123 and tmp/c345 with the base tmp/b234, but uses labels `a` and `c` instead of `tmp/a123` and `tmp/c345`."
msgstr "将 tmp/a123 和 tmp/c345 与基础 tmp/b234 合并，但使用标签 `a` 和 `c` 代替 `tmp/a123` 和 `tmp/c345`。"

#. type: Labeled list
#: en/git-merge-file.txt:115
#, no-wrap, placeholders:'git merge-file':'--object-id', priority:90
msgid "`git merge-file -p --object-id abc1234 def567 890abcd`"
msgstr "`git merge-file -p --object-id abc1234 def567 890abcd`"

#. type: Plain text
#: en/git-merge-file.txt:119
#, priority:90
msgid "combines the changes of the blob abc1234 and 890abcd since def567, tries to merge them and writes the result to standard output"
msgstr "合并自 def567 以来 blob abc1234 和 890abcd 的变化，尝试合并它们，并将结果写入标准输出"

#. type: Title =
#: en/git-merge-index.txt:2
#, ignore-same, no-wrap, priority:90
msgid "git-merge-index(1)"
msgstr "git-merge-index(1)"

#. type: Plain text
#: en/git-merge-index.txt:7
#, placeholders:'git-merge-index', priority:90
msgid "git-merge-index - Run a merge for files needing merging"
msgstr "git-merge-index - 对需要合并的文件进行合并"

#. type: Plain text
#: en/git-merge-index.txt:13
#, ignore-ellipsis, no-wrap, placeholders:'git merge-index', priority:90
msgid "'git merge-index' [-o] [-q] <merge-program> (-a | ( [--] <file>...) )\n"
msgstr "'git merge-index' [-o] [-q] <合并程序> (-a | ( [--] <文件>...) )\n"

#. type: Plain text
#: en/git-merge-index.txt:20
#, priority:90
msgid "This looks up the <file>(s) in the index and, if there are any merge entries, passes the SHA-1 hash for those files as arguments 1, 2, 3 (empty argument if no file), and <file> as argument 4. File modes for the three files are passed as arguments 5, 6 and 7."
msgstr "它会查找索引中的 <文件> 文件，如果有合并条目，则将这些文件的 SHA-1 哈希值作为参数 1、2、3（如果没有文件则为空参数）和 <文件> 作为参数 4 传递。 三个文件的文件模式作为参数 5、6 和 7 传递。"

#. type: Plain text
#: en/git-merge-index.txt:28
#, priority:90
msgid "Run merge against all files in the index that need merging."
msgstr "针对索引中需要合并的所有文件运行合并。"

#. type: Plain text
#: en/git-merge-index.txt:34
#, priority:90
msgid "Instead of stopping at the first failed merge, do all of them in one shot - continue with merging even when previous merges returned errors, and only return the error code after all the merges."
msgstr "不要在第一次合并失败时就停止，而是一次性完成所有合并--即使之前的合并返回错误，也要继续合并，并且只在所有合并后返回错误代码。"

#. type: Plain text
#: en/git-merge-index.txt:39
#, priority:90
msgid "Do not complain about a failed merge program (a merge program failure usually indicates conflicts during the merge). This is for porcelains which might want to emit custom messages."
msgstr "不要抱怨合并程序失败（合并程序失败通常表示合并过程中发生冲突）。这适用于可能希望发出自定义信息的上层命令。"

#. type: Plain text
#: en/git-merge-index.txt:43
#, placeholders:'git merge-index', priority:90
msgid "If 'git merge-index' is called with multiple <file>s (or -a) then it processes them in turn only stopping if merge returns a non-zero exit code."
msgstr "如果调用 'git merge-index' 时有多个 <文件>s （或 -a），那么只有在 merge 返回非零退出代码时，才会依次处理它们。"

#. type: Plain text
#: en/git-merge-index.txt:46
#, priority:90
msgid "Typically this is run with a script calling Git's imitation of the 'merge' command from the RCS package."
msgstr "通常情况下，运行脚本时会调用 RCS 软件包中 Git 的 'merge' 命令。"

#. type: Plain text
#: en/git-merge-index.txt:49
#, placeholders:'git merge-one-file', priority:90
msgid "A sample script called 'git merge-one-file' is included in the distribution."
msgstr "发行版中包含一个名为 'git merge-one-file' 的示例脚本。"

#. type: Plain text
#: en/git-merge-index.txt:54
#, priority:90
msgid "ALERT ALERT ALERT! The Git \"merge object order\" is different from the RCS 'merge' program merge object order. In the above ordering, the original is first. But the argument order to the 3-way merge program 'merge' is to have the original in the middle. Don't ask me why."
msgstr "警报 警报Git 的 “合并对象顺序” 与 RCS 的 'merge' 程序合并对象顺序不同。在上述顺序中，原始文件在前。但三方合并程序 'merge' 的参数顺序是把原始文件放在中间。别问我为什么。"

#. type: Plain text
#: en/git-merge-index.txt:56 en/git-svn.txt:171
#, priority:100
msgid "Examples:"
msgstr "实例："

#. type: delimited block -
#: en/git-merge-index.txt:63
#, no-wrap, placeholders:'git merge-index', priority:90
msgid ""
"torvalds@ppc970:~/merge-test> git merge-index cat MM\n"
"This is MM from the original tree.\t\t# original\n"
"This is modified MM in the branch A.\t\t# merge1\n"
"This is modified MM in the branch B.\t\t# merge2\n"
"This is modified MM in the branch B.\t\t# current contents\n"
msgstr ""
"torvalds@ppc970:~/merge-test> git merge-index cat MM\n"
"This is MM from the original tree.\t\t# 初分支\n"
"This is modified MM in the branch A.\t\t# 合并1\n"
"This is modified MM in the branch B.\t\t# 合并2\n"
"This is modified MM in the branch B.\t\t# 现在的内容\n"

#. type: delimited block -
#: en/git-merge-index.txt:74
#, no-wrap, placeholders:'git merge-index', priority:90
msgid ""
"torvalds@ppc970:~/merge-test> git merge-index cat AA MM\n"
"cat: : No such file or directory\n"
"This is added AA in the branch A.\n"
"This is added AA in the branch B.\n"
"This is added AA in the branch B.\n"
"fatal: merge program failed\n"
msgstr ""
"torvalds@ppc970:~/merge-test> git merge-index cat AA MM\n"
"cat: : No such file or directory\n"
"This is added AA in the branch A.\n"
"This is added AA in the branch B.\n"
"This is added AA in the branch B.\n"
"fatal: merge program failed\n"

#. type: Plain text
#: en/git-merge-index.txt:80
#, placeholders:'git merge-index':'git merge-index', priority:90
msgid "where the latter example shows how 'git merge-index' will stop trying to merge once anything has returned an error (i.e., `cat` returned an error for the AA file, because it didn't exist in the original, and thus 'git merge-index' didn't even try to merge the MM thing)."
msgstr "后一个例子说明了 'git merge-index' 如何在出现错误时停止合并（即 `cat` 对 AA 文件返回错误，因为它在原始文件中并不存在，因此 'git merge-index' 甚至没有尝试合并 MM 文件）。"

#. type: Title =
#: en/git-merge-one-file.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-merge-one-file(1)"
msgstr "git-merge-one-file(1)"

#. type: Plain text
#: en/git-merge-one-file.txt:7
#, placeholders:'git-merge-one-file':'git-merge-index', priority:100
msgid "git-merge-one-file - The standard helper program to use with git-merge-index"
msgstr "git-merge-one-file - 与 git-merge-index 一起使用的标准辅助程序"

#. type: Plain text
#: en/git-merge-one-file.txt:13
#, no-wrap, placeholders:'git merge-one-file', priority:100
msgid "'git merge-one-file'\n"
msgstr "'git merge-one-file'\n"

#. type: Plain text
#: en/git-merge-one-file.txt:18
#, placeholders:'git merge-index':'git read-tree', priority:100
msgid "This is the standard helper program to use with 'git merge-index' to resolve a merge after the trivial merge done with 'git read-tree -m'."
msgstr "这是标准的辅助程序，与 'git merge-index' 一起使用，以解决用 'git read-tree -m' 进行的琐碎合并后的合并问题。"

#. type: Title =
#: en/git-mergetool--lib.txt:2
#, no-wrap, placeholders:'git-mergetool':'{litdd}', priority:100
msgid "git-mergetool{litdd}lib(1)"
msgstr "git-mergetool{litdd}lib(1)"

#. type: Plain text
#: en/git-mergetool--lib.txt:7
#, placeholders:'git-mergetool--lib', priority:100
msgid "git-mergetool--lib - Common Git merge tool shell scriptlets"
msgstr "git-mergetool--lib - 常见的 Git 合并工具壳 shell 脚本程序"

#. type: Plain text
#: en/git-mergetool--lib.txt:12
#, no-wrap, placeholders:'TOOL_MODE':'--exec-path':'git-mergetool':'{litdd}', priority:100
msgid "'TOOL_MODE=(diff|merge) . \"$(git --exec-path)/git-mergetool{litdd}lib\"'\n"
msgstr "'TOOL_MODE=(diff|merge) . \"$(git --exec-path)/git-mergetool{litdd}lib\"'\n"

#. type: Plain text
#: en/git-mergetool--lib.txt:19 en/git-sh-i18n.txt:19 en/git-sh-setup.txt:19
#, priority:100
msgid "This is not a command the end user would want to run. Ever. This documentation is meant for people who are studying the Porcelain-ish scripts and/or are writing new ones."
msgstr "这不是一个终端用户想要运行的命令。 永远不会。 这个文档是为研究 Porcelain-ish 脚本和/或正在编写新脚本的人准备的。"

#. type: Plain text
#: en/git-mergetool--lib.txt:23
#, placeholders:'git-mergetool':'{litdd}', priority:100
msgid "The 'git-mergetool{litdd}lib' scriptlet is designed to be sourced (using `.`) by other shell scripts to set up functions for working with Git merge tools."
msgstr "'git-mergetool{litdd}lib' 脚本被设计成可以被其他 shell 脚本引用（使用 `.`），以设置与 Git 合并工具一起工作的功能。"

#. type: Plain text
#: en/git-mergetool--lib.txt:27
#, placeholders:'git-mergetool':'{litdd}':'TOOL_MODE', priority:100
msgid "Before sourcing 'git-mergetool{litdd}lib', your script must set `TOOL_MODE` to define the operation mode for the functions listed below. 'diff' and 'merge' are valid values."
msgstr "在链接到 'git-mergetool{litdd}lib' 之前，你的脚本必须设置 `TOOL_MODE` 来定义下列函数的操作模式。 'diff' 和 'merge'是有效值。"

#. type: Title -
#: en/git-mergetool--lib.txt:29 en/git-sh-i18n.txt:28 en/git-sh-setup.txt:34
#, no-wrap, priority:100
msgid "FUNCTIONS"
msgstr "功能"

#. type: Labeled list
#: en/git-mergetool--lib.txt:30
#, no-wrap, placeholders:'get_merge_tool', priority:100
msgid "get_merge_tool"
msgstr "get_merge_tool"

#. type: Plain text
#: en/git-mergetool--lib.txt:34
#, placeholders:'$GIT_MERGETOOL_GUI', priority:100
msgid "Returns a merge tool. The return code is 1 if we returned a guessed merge tool, else 0. '$GIT_MERGETOOL_GUI' may be set to 'true' to search for the appropriate guitool."
msgstr "返回一个合并工具。如果我们返回一个被猜中的合并工具，返回代码为 1，否则为0。'$GIT_MERGETOOL_GUI' 可以被设置为 'true' 以搜索合适的 guitool。"

#. type: Labeled list
#: en/git-mergetool--lib.txt:35
#, no-wrap, placeholders:'get_merge_tool_cmd', priority:100
msgid "get_merge_tool_cmd"
msgstr "get_merge_tool_cmd"

#. type: Plain text
#: en/git-mergetool--lib.txt:37
#, priority:100
msgid "Returns the custom command for a merge tool."
msgstr "返回一个合并工具的自定义命令。"

#. type: Labeled list
#: en/git-mergetool--lib.txt:38
#, no-wrap, placeholders:'get_merge_tool_path', priority:100
msgid "get_merge_tool_path"
msgstr "get_merge_tool_path"

#. type: Plain text
#: en/git-mergetool--lib.txt:40
#, priority:100
msgid "Returns the custom path for a merge tool."
msgstr "返回一个合并工具的自定义路径。"

#. type: Labeled list
#: en/git-mergetool--lib.txt:41
#, no-wrap, placeholders:'initialize_merge_tool', priority:100
msgid "initialize_merge_tool"
msgstr "initialize_merge_tool"

#. type: Plain text
#: en/git-mergetool--lib.txt:44
#, priority:100
msgid "Brings merge tool specific functions into scope so they can be used or overridden."
msgstr "将特定于合并工具的函数纳入作用域，以便使用或覆盖这些函数。"

#. type: Labeled list
#: en/git-mergetool--lib.txt:45
#, no-wrap, placeholders:'run_merge_tool', priority:100
msgid "run_merge_tool"
msgstr "run_merge_tool"

#. type: Plain text
#: en/git-mergetool--lib.txt:50
#, placeholders:'$MERGED':'$LOCAL':'$REMOTE':'$BASE', priority:100
msgid "Launches a merge tool given the tool name and a true/false flag to indicate whether a merge base is present. '$MERGED', '$LOCAL', '$REMOTE', and '$BASE' must be defined for use by the merge tool."
msgstr "根据工具名称和表示是否存在合并基础的真/假标志，启动合并工具。 合并工具必须定义 '$MERGED' 、'$LOCAL' 、'$REMOTE' 和 '$BASE'。"

#. type: Title =
#: en/git-mergetool.txt:2
#, ignore-same, no-wrap, priority:240
msgid "git-mergetool(1)"
msgstr "git-mergetool(1)"

#. type: Plain text
#: en/git-mergetool.txt:7
#, placeholders:'git-mergetool', priority:240
msgid "git-mergetool - Run merge conflict resolution tools to resolve merge conflicts"
msgstr "git-mergetool - 运行合并冲突解决工具以解决合并冲突"

# ERROR: --[no-]prompt] not found in translation
#. type: Plain text
#: en/git-mergetool.txt:12
#, ignore-ellipsis, no-wrap, placeholders:'[--tool=', priority:240
msgid "'git mergetool' [--tool=<tool>] [-y | --[no-]prompt] [<file>...]\n"
msgstr "'git mergetool' [--tool=<工具>] [-y |--[no-]prompt] [<文件>...] 。\n"

#. type: Plain text
#: en/git-mergetool.txt:18
#, priority:240
msgid "Use `git mergetool` to run one of several merge utilities to resolve merge conflicts. It is typically run after 'git merge'."
msgstr "使用 `git mergetool` 来运行几个合并工具中的一个来解决合并冲突。 它通常在 'git merge' 之后运行。"

#. type: Plain text
#: en/git-mergetool.txt:24
#, priority:240
msgid "If one or more <file> parameters are given, the merge tool program will be run to resolve differences in each file (skipping those without conflicts). Specifying a directory will include all unresolved files in that path. If no <file> names are specified, 'git mergetool' will run the merge tool program on every file with merge conflicts."
msgstr "如果给出一个或多个 <文件> 参数，合并工具程序会运行以解决每个文件的差异（跳过那些没有冲突的文件）。 指定一个目录将包括该路径中所有未解决的文件。 如果没有指定 <文件> 名称，'git mergetool' 将对每个有合并冲突的文件运行合并工具程序。"

#. type: Plain text
#: en/git-mergetool.txt:33
#, placeholders:'--tool-help`', priority:240
msgid "Use the merge resolution program specified by <tool>. Valid values include emerge, gvimdiff, kdiff3, meld, vimdiff, and tortoisemerge. Run `git mergetool --tool-help` for the list of valid <tool> settings."
msgstr "使用由<工具>指定的合并解决程序。 有效值包括 emerge、gvimdiff、kdiff3、meld、vimdiff 和 tortoisemerge。运行`git mergetool --tool-help`以获得有效的<工具>设置列表。"

#. type: Plain text
#: en/git-mergetool.txt:38
#, placeholders:'merge.tool':'merge.tool', priority:240
msgid "If a merge resolution program is not specified, 'git mergetool' will use the configuration variable `merge.tool`. If the configuration variable `merge.tool` is not set, 'git mergetool' will pick a suitable default."
msgstr "如果没有指定合并解决程序，'git mergetool' 将使用配置变量 `merge.tool`。 如果配置变量 `merge.tool` 没有设置，'git mergetool' 将自行挑选一个合适的程序。"

#. type: Plain text
#: en/git-mergetool.txt:44
#, priority:240
msgid "You can explicitly provide a full path to the tool by setting the configuration variable `mergetool.<tool>.path`. For example, you can configure the absolute path to kdiff3 by setting `mergetool.kdiff3.path`. Otherwise, 'git mergetool' assumes the tool is available in PATH."
msgstr "你可以通过设置配置变量`mergetool.<工具>.path`来明确提供工具的完整路径。例如，你可以通过设置`mergetool.kdiff3.path`来配置kdiff3的绝对路径。否则，\"git mergetool\"会假定该工具在PATH中配置过。"

#. type: Plain text
#: en/git-mergetool.txt:49
#, priority:240
msgid "Instead of running one of the known merge tool programs, 'git mergetool' can be customized to run an alternative program by specifying the command line to invoke in a configuration variable `mergetool.<tool>.cmd`."
msgstr "通过在配置变量`mergetool.<工具>.cmd`中指定调用的命令行，'git mergetool'可以代替运行一个已知的合并工具程序，从而指定运行另一个程序。"

#. type: Plain text
#: en/git-mergetool.txt:60
#, placeholders:'`-t`':'`--tool`':'merge.tool':'$BASE':'$LOCAL':'$REMOTE':'$MERGED', priority:240
msgid "When 'git mergetool' is invoked with this tool (either through the `-t` or `--tool` option or the `merge.tool` configuration variable), the configured command line will be invoked with `$BASE` set to the name of a temporary file containing the common base for the merge, if available; `$LOCAL` set to the name of a temporary file containing the contents of the file on the current branch; `$REMOTE` set to the name of a temporary file containing the contents of the file to be merged, and `$MERGED` set to the name of the file to which the merge tool should write the result of the merge resolution."
msgstr "当 'git mergetool' 与该工具一起被调用时（通过 `-t` 或 `--tool` 选项或 `merge.tool` 配置变量），配置的命令行将被调用， `$BASE` 被设置为临时文件的名称，包含合并的共同基础（如果有的话）； `$LOCAL` 被设置为包含当前分支上的文件内容的临时文件名称；`$REMOTE` 被设置为包含要合并文件内容的临时文件名称，以及合并工具应该将合并的结果写入 `$MERGED` 设置的文件中。"

#. type: Plain text
#: en/git-mergetool.txt:66
#, priority:240
msgid "If the custom merge tool correctly indicates the success of a merge resolution with its exit code, then the configuration variable `mergetool.<tool>.trustExitCode` can be set to `true`. Otherwise, 'git mergetool' will prompt the user to indicate the success of the resolution after the custom tool has exited."
msgstr "如果自定义合并工具能够正确地用其退出代码指示合并成功，那么配置变量 `mergetool.<工具>.trustExitCode` 可以被设置为 `true`。 否则，'git mergetool' 将在用户在自定义工具退出后表明解决成功。"

# ERROR: `--tool` not found in translation
#. type: Plain text
#: en/git-mergetool.txt:69
#, placeholders:'`--tool`', priority:240
msgid "Print a list of merge tools that may be used with `--tool`."
msgstr "打印出可以和 `--tool` 命令一起使用的merge工具列表。"

#. type: Plain text
#: en/git-mergetool.txt:77
#, placeholders:'`--tool`':'merge.tool', priority:240
msgid "Don't prompt before each invocation of the merge resolution program. This is the default if the merge resolution program is explicitly specified with the `--tool` option or with the `merge.tool` configuration variable."
msgstr "在每次调用合并解决程序之前不会提示。 如果用 `--tool` 选项或 `merge.tool` 配置变量明确指定了合并解决程序，默认就是这种做法。"

#. type: Plain text
#: en/git-mergetool.txt:81
#, priority:240
msgid "Prompt before each invocation of the merge resolution program to give the user a chance to skip the path."
msgstr "在每次调用合并解决程序前提示，让用户有机会跳过该路径。"

#. type: Labeled list
#: en/git-mergetool.txt:83
#, ignore-same, no-wrap, priority:240
msgid "--gui"
msgstr "--gui"

#. type: Plain text
#: en/git-mergetool.txt:90
#, placeholders:'git-mergetool':'`-g`':'`--gui`':'merge.guitool':'merge.tool':'merge.guitool':'merge.tool':'mergetool.guiDefault', priority:240
msgid "When 'git-mergetool' is invoked with the `-g` or `--gui` option, the default merge tool will be read from the configured `merge.guitool` variable instead of `merge.tool`. If `merge.guitool` is not set, we will fallback to the tool configured under `merge.tool`. This may be autoselected using the configuration variable `mergetool.guiDefault`."
msgstr "当使用 `-g` 或 `--gui` 选项调用 'git-mergetool' 时，默认的合并工具将从配置的 `merge.guitool` 变量中读取，而不是 `merge.tool` 变量。如果未设置 `merge.guitool` 变量，我们将退回到在 `merge.tool` 下配置的工具。这可以通过配置变量 `mergetool.guiDefault` 自动选择。"

#. type: Labeled list
#: en/git-mergetool.txt:91
#, ignore-same, no-wrap, priority:240
msgid "--no-gui"
msgstr "--no-gui"

# ERROR: mergetool.guiDefault not found in translation
#. type: Plain text
#: en/git-mergetool.txt:95
#, placeholders:'`-g`':'`--gui`':'mergetool.guiDefault':'merge.tool', priority:240
msgid "This overrides a previous `-g` or `--gui` setting or `mergetool.guiDefault` configuration and reads the default merge tool from the configured `merge.tool` variable."
msgstr "这将覆盖之前的 `-g` 或 `--gui` 设置或 `mergetool.guiDefault` 配置，并从配置的 `merge.tool` 变量读取默认的合并工具。"

#. type: Plain text
#: en/git-mergetool.txt:102
#, placeholders:'diff.orderFile':'linkgit:git-config[1]':'diff.orderFile', priority:240
msgid "Process files in the order specified in the <orderfile>, which has one shell glob pattern per line. This overrides the `diff.orderFile` configuration variable (see linkgit:git-config[1]). To cancel `diff.orderFile`, use `-O/dev/null`."
msgstr "按照 <顺序文件> 中指定的顺序处理文件，每行有一个 shell匹配模式。 这会覆盖 `diff.orderFile` 配置的变量（见 linkgit:git-config[1]）。 可以使用使用 `-O/dev/null`取消 `diff.orderFile`。"

#. type: Title -
#: en/git-mergetool.txt:112
#, no-wrap, priority:240
msgid "TEMPORARY FILES"
msgstr "临时文件"

#. type: Plain text
#: en/git-mergetool.txt:116
#, priority:240
msgid "`git mergetool` creates `*.orig` backup files while resolving merges. These are safe to remove once a file has been merged and its `git mergetool` session has completed."
msgstr "`git mergetool`在解决合并问题时创建`*.orig`备份文件。 一旦文件被合并，并且其`git mergetool`会话完成，这些文件就可以安全地删除。"

#. type: Plain text
#: en/git-mergetool.txt:120
#, placeholders:'mergetool.keepBackup', priority:240
msgid "Setting the `mergetool.keepBackup` configuration variable to `false` causes `git mergetool` to automatically remove the backup files as files are successfully merged."
msgstr "将 `mergetool.keepBackup` 配置变量设置为 `false` 会使 `git mergetool` 在文件成功合并后自动删除备份。"

#. type: Title -
#: en/git-mergetool.txt:122
#, no-wrap, priority:240
msgid "BACKEND SPECIFIC HINTS"
msgstr "后端特定提示"

#. type: Title ~
#: en/git-mergetool.txt:125
#, ignore-same, no-wrap, priority:240
msgid "vimdiff"
msgstr "vimdiff"

#. type: Title =
#: en/git-merge-tree.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-merge-tree(1)"
msgstr "git-merge-tree(1)"

#. type: Plain text
#: en/git-merge-tree.txt:7
#, placeholders:'git-merge-tree', priority:100
msgid "git-merge-tree - Perform merge without touching index or working tree"
msgstr "git-merge-tree - 显示三向合并，不触及索引"

#. type: Plain text
#: en/git-merge-tree.txt:14
#, no-wrap, placeholders:'git merge-tree':'[--write-tree]':'git merge-tree':'[--trivial-merge]', priority:100
msgid ""
"'git merge-tree' [--write-tree] [<options>] <branch1> <branch2>\n"
"'git merge-tree' [--trivial-merge] <base-tree> <branch1> <branch2> (deprecated)\n"
msgstr ""
"'git merge-tree' [--write-tree] [<选项>] <分支 1> <分支 2>\n"
"'git merge-tree' [--trivial-merge] <基础目录树> <分支 1> <分支 2> (deprecated)\n"

#. type: Plain text
#: en/git-merge-tree.txt:23
#, placeholders:'`--write-tree`':'`--trivial-merge`':'<<DEPMERGE,':'`--write-tree`', priority:100
msgid "This command has a modern `--write-tree` mode and a deprecated `--trivial-merge` mode. With the exception of the <<DEPMERGE,DEPRECATED DESCRIPTION>> section at the end, the rest of this documentation describes the modern `--write-tree` mode."
msgstr "该命令有现代的 `--wirte-tree` 模式和过时的 `--trivial-merge` 模式。 除了最后的 <<DEPMERGE,弃用说明>> 部分，本文档的其余部分描述的是现代的 `--write-tree` 模式。"

#. type: Plain text
#: en/git-merge-tree.txt:26
#, priority:100
msgid "Performs a merge, but does not make any new commits and does not read from or write to either the working tree or index."
msgstr "执行合并，但不做任何新的提交，也不从工作区或索引中读取或写入。"

#. type: Plain text
#: en/git-merge-tree.txt:29
#, placeholders:'linkgit:git-merge[1]', priority:100
msgid "The performed merge will use the same features as the \"real\" linkgit:git-merge[1], including:"
msgstr "执行的合并将使用与 “真正的” linkgit:git-merge[1]相同的功能，包括："

#. type: Plain text
#: en/git-merge-tree.txt:31
#, priority:100
msgid "three way content merges of individual files"
msgstr "单个文件的多路合并"

#. type: Plain text
#: en/git-merge-tree.txt:32
#, priority:100
msgid "rename detection"
msgstr "rename detection"

#. type: Plain text
#: en/git-merge-tree.txt:33
#, priority:100
msgid "proper directory/file conflict handling"
msgstr "正确处理目录/文件冲突"

#. type: Plain text
#: en/git-merge-tree.txt:35
#, priority:100
msgid "recursive ancestor consolidation (i.e. when there is more than one merge base, creating a virtual merge base by merging the merge bases)"
msgstr "递归祖先合并（即当有一个以上的合并基数时，通过合并基础创建一个虚拟合并基础）"

#. type: Plain text
#: en/git-merge-tree.txt:36
#, priority:100
msgid "etc."
msgstr "等等。"

#. type: Plain text
#: en/git-merge-tree.txt:39
#, priority:100
msgid "After the merge completes, a new toplevel tree object is created. See `OUTPUT` below for details."
msgstr "合并完成后，会创建一个新的顶层树对象。 详见下面的 “输出”。"

#. type: Plain text
#: en/git-merge-tree.txt:48
#, placeholders:'<<OUTPUT>>', priority:100
msgid "Do not quote filenames in the <Conflicted file info> section, and end each filename with a NUL character rather than newline. Also begin the messages section with a NUL character instead of a newline. See <<OUTPUT>> below for more information."
msgstr "在 <冲突文件信息> 部分不要引用文件名，每个文件名用 NUL 字符而不是换行来结束。 在信息部分也要用 NUL 字符而不是换行来开始。 更多信息见下面的 <<OUTPUT>>。"

#. type: Plain text
#: en/git-merge-tree.txt:55
#, priority:100
msgid "In the Conflicted file info section, instead of writing a list of (mode, oid, stage, path) tuples to output for conflicted files, just provide a list of filenames with conflicts (and do not list filenames multiple times if they have multiple conflicting stages)."
msgstr "在冲突的文件信息部分，不要为冲突的文件写一个（mode, oid, stage, path）图元列表来输出，只需提供一个有冲突的文件名列表（如果文件有多个冲突的阶段，不多次列出文件名）。"

#. type: Labeled list
#: en/git-merge-tree.txt:56
#, ignore-same, no-wrap, priority:100
msgid "--[no-]messages"
msgstr "--[no-]messages"

#. type: Plain text
#: en/git-merge-tree.txt:61
#, priority:100
msgid "Write any informational messages such as \"Auto-merging <path>\" or CONFLICT notices to the end of stdout. If unspecified, the default is to include these messages if there are merge conflicts, and to omit them otherwise."
msgstr "将任何信息性的消息，如\"Auto-merging <path>\" 或冲突通知写到标准输出流的末尾。 如果没有指定，默认情况下，如果有合并冲突，就包括这些信息，否则就省略它们。"

#. type: Labeled list
#: en/git-merge-tree.txt:62 en/merge-options.txt:200
#, ignore-same, no-wrap, priority:240
msgid "--allow-unrelated-histories"
msgstr "--allow-unrelated-histories"

#. type: Plain text
#: en/git-merge-tree.txt:66
#, priority:100
msgid "merge-tree will by default error out if the two branches specified share no common history. This flag can be given to override that check and make the merge proceed anyway."
msgstr "如果指定的两个分支没有共同的历史，merge-tree 默认会出错。 这个标志可以用来覆盖这个检查，并使合并继续进行。"

#. type: Labeled list
#: en/git-merge-tree.txt:67
#, no-wrap, placeholders:'--merge-base=', priority:100
msgid "--merge-base=<commit>"
msgstr "--merge-base=<提交>"

#. type: Plain text
#: en/git-merge-tree.txt:71
#, placeholders:'`--stdin`', priority:100
msgid "Instead of finding the merge-bases for <branch1> and <branch2>, specify a merge-base for the merge, and specifying multiple bases is currently not supported. This option is incompatible with `--stdin`."
msgstr "不需要为 <branch1> 和 <branch2> 寻找合并基础，而是为合并指定一个合并基础，目前不支持指定多个合并基础。该选项与 `--stdin` 不兼容。"

#. type: Plain text
#: en/git-merge-tree.txt:78
#, placeholders:'git-merge-tree', priority:100
msgid "For a successful merge, the output from git-merge-tree is simply one line:"
msgstr "对于一个成功的合并，git-merge-tree 的输出仅仅是一行："

#. type: Plain text
#: en/git-merge-tree.txt:80
#, no-wrap, priority:100
msgid "\t<OID of toplevel tree>\n"
msgstr "\t<OID of toplevel tree>\n"

#. type: Plain text
#: en/git-merge-tree.txt:82
#, priority:100
msgid "Whereas for a conflicted merge, the output is by default of the form:"
msgstr "而对于有冲突的合并，默认的输出形式是："

#. type: Plain text
#: en/git-merge-tree.txt:86
#, no-wrap, priority:100
msgid ""
"\t<OID of toplevel tree>\n"
"\t<Conflicted file info>\n"
"\t<Informational messages>\n"
msgstr ""
"\t<OID of toplevel tree>\n"
"\t<Conflicted file info>\n"
"\t<Informational messages>\n"

#. type: Plain text
#: en/git-merge-tree.txt:88
#, priority:100
msgid "These are discussed individually below."
msgstr "下面将分别讨论这些问题。"

#. type: Plain text
#: en/git-merge-tree.txt:93
#, placeholders:'`--stdin`', priority:100
msgid "However, there is an exception. If `--stdin` is passed, then there is an extra section at the beginning, a NUL character at the end, and then all the sections repeat for each line of input. Thus, if the first merge is conflicted and the second is clean, the output would be of the form:"
msgstr "然而，有一个例外。 如果通过了 `--stdin`，那么在开头有一个额外的部分，在结尾有一个 NUL 字符，然后所有的部分在每行输入中都会重复。 因此，如果第一次合并是冲突的，而第二次是干净的，输出将是这样的形式："

#. type: Plain text
#: en/git-merge-tree.txt:102
#, no-wrap, priority:100
msgid ""
"\t<Merge status>\n"
"\t<OID of toplevel tree>\n"
"\t<Conflicted file info>\n"
"\t<Informational messages>\n"
"\tNUL\n"
"\t<Merge status>\n"
"\t<OID of toplevel tree>\n"
"\tNUL\n"
msgstr ""
"\t<Merge status>\n"
"\t<OID of toplevel tree>\n"
"\t<Conflicted file info>\n"
"\t<Informational messages>\n"
"\tNUL\n"
"\t<Merge status>\n"
"\t<OID of toplevel tree>\n"
"\tNUL\n"

#. type: Title ~
#: en/git-merge-tree.txt:105
#, no-wrap, priority:100
msgid "Merge status"
msgstr "Merge status"

#. type: Plain text
#: en/git-merge-tree.txt:108
#, priority:100
msgid "This is an integer status followed by a NUL character. The integer status is:"
msgstr "这是一个整数状态，后面有一个 NUL 字符。 整数状态是："

#. type: Plain text
#: en/git-merge-tree.txt:113
#, no-wrap, priority:100
msgid ""
"     0: merge had conflicts\n"
"     1: merge was clean\n"
"     <0: something prevented the merge from running (e.g. access to repository\n"
"\t objects denied by filesystem)\n"
msgstr ""
"     0：合并后有冲突\n"
"     1： 合并是干净的\n"
"     <0：有什么东西阻止了合并的运行（例如，文件系统拒绝对仓库对象的访问\n"
"\t 对象的访问被文件系统拒绝)\n"

#. type: Title ~
#: en/git-merge-tree.txt:116
#, no-wrap, priority:100
msgid "OID of toplevel tree"
msgstr "顶层目录树的 OID"

#. type: Plain text
#: en/git-merge-tree.txt:122
#, placeholders:'`-z`', priority:100
msgid "This is a tree object that represents what would be checked out in the working tree at the end of `git merge`. If there were conflicts, then files within this tree may have embedded conflict markers. This section is always followed by a newline (or NUL if `-z` is passed)."
msgstr "这是一个树状对象，代表在`git merge` 结束时工作区上检查出来的东西。 如果有冲突，那么这个目录树中的文件可能会有嵌入式冲突标记。 这一部分的后面总是有一个换行符（如果传递了 `-z` 则为 NUL）。"

#. type: Title ~
#: en/git-merge-tree.txt:125
#, no-wrap, priority:100
msgid "Conflicted file info"
msgstr "冲突的文件信息"

#. type: Plain text
#: en/git-merge-tree.txt:128
#, priority:100
msgid "This is a sequence of lines with the format"
msgstr "这是一连串的行，格式为"

#. type: Plain text
#: en/git-merge-tree.txt:130
#, no-wrap, priority:100
msgid "\t<mode> <object> <stage> <filename>\n"
msgstr "\t<mode> <object> <stage> <filename>\n"

# ERROR: --name-only not found in translation
#. type: Plain text
#: en/git-merge-tree.txt:136
#, placeholders:'core.quotePath':'linkgit:git-config[1]':'`--name-only`':'`-z`', priority:100
msgid "The filename will be quoted as explained for the configuration variable `core.quotePath` (see linkgit:git-config[1]). However, if the `--name-only` option is passed, the mode, object, and stage will be omitted. If `-z` is passed, the \"lines\" are terminated by a NUL character instead of a newline character."
msgstr "文件名将按照配置变量 `core.quotePath` 的说明加引号（参见 linkgit:git-config[1]）。 不过，如果通过了 `--name-only`选项，则会省略模式、对象和阶段。 如果传递了 `-z` 选项，“行” 将以 NUL 字符而不是换行符结束。"

#. type: Title ~
#: en/git-merge-tree.txt:139
#, no-wrap, priority:100
msgid "Informational messages"
msgstr "信息"

#. type: Plain text
#: en/git-merge-tree.txt:144
#, placeholders:'`-z`', priority:100
msgid "This section provides informational messages, typically about conflicts. The format of the section varies significantly depending on whether `-z` is passed."
msgstr "这一部分提供信息，通常是关于冲突的信息。 该部分的格式因是否传递了 `-z` 而有很大不同。"

#. type: Plain text
#: en/git-merge-tree.txt:146
#, placeholders:'`-z`', priority:100
msgid "If `-z` is passed:"
msgstr "如果 `-z`被传递："

#. type: Plain text
#: en/git-merge-tree.txt:149
#, priority:100
msgid "The output format is zero or more conflict informational records, each of the form:"
msgstr "输出格式是零条或更多的冲突信息记录，每条记录的形式都是："

#. type: Plain text
#: en/git-merge-tree.txt:151
#, no-wrap, priority:100
msgid "\t<list-of-paths><conflict-type>NUL<conflict-message>NUL\n"
msgstr "\t<list-of-paths><conflict-type>NUL<conflict-message>NUL\n"

#. type: Plain text
#: en/git-merge-tree.txt:153
#, priority:100
msgid "where <list-of-paths> is of the form"
msgstr "其中 <list-of-paths> 的形式为"

#. type: Plain text
#: en/git-merge-tree.txt:155
#, ignore-ellipsis, no-wrap, priority:100
msgid "\t<number-of-paths>NUL<path1>NUL<path2>NUL...<pathN>NUL\n"
msgstr "\t<number-of-paths>NUL<path1>NUL<path2>NUL...<pathN>NUL\n"

#. type: Plain text
#: en/git-merge-tree.txt:159
#, priority:100
msgid "and includes paths (or branch names) affected by the conflict or informational message in <conflict-message>. Also, <conflict-type> is a stable string explaining the type of conflict, such as"
msgstr "并包括受冲突影响的路径（或分支名称）或 <conflict-message> 中的信息消息。 另外，<conflict-type> 是一个稳定的字符串，解释了冲突的类型，比如说"

#. type: Plain text
#: en/git-merge-tree.txt:161
#, priority:100
msgid "\"Auto-merging\""
msgstr "\"Auto-merging\""

#. type: Plain text
#: en/git-merge-tree.txt:162
#, priority:100
msgid "\"CONFLICT (rename/delete)\""
msgstr "\"CONFLICT (重命名/删除)\""

#. type: Plain text
#: en/git-merge-tree.txt:163
#, priority:100
msgid "\"CONFLICT (submodule lacks merge base)\""
msgstr "\"CONFLICT (子模块缺乏合并基础)\""

#. type: Plain text
#: en/git-merge-tree.txt:164
#, priority:100
msgid "\"CONFLICT (binary)\""
msgstr "\"CONFLICT (二进制)\""

#. type: Plain text
#: en/git-merge-tree.txt:168
#, priority:100
msgid "and <conflict-message> is a more detailed message about the conflict which often (but not always) embeds the <stable-short-type-description> within it. These strings may change in future Git versions. Some examples:"
msgstr "和 <conflict-message> 是关于冲突的更详细的信息，通常（但不一定）会嵌入 <stable-short-type-description> 中。 这些字符串在未来的Git版本中可能会改变。 一些例子："

#. type: Plain text
#: en/git-merge-tree.txt:170
#, priority:100
msgid "\"Auto-merging <file>\""
msgstr "\"Auto-merging <文件>\""

#. type: Plain text
#: en/git-merge-tree.txt:171
#, ignore-ellipsis, priority:100
msgid "\"CONFLICT (rename/delete): <oldfile> renamed...but deleted in...\""
msgstr "\"CONFLICT (rename/delete): <oldfile> 被重命名... 但在... 被删除。\""

#. type: Plain text
#: en/git-merge-tree.txt:172
#, priority:100
msgid "\"Failed to merge submodule <submodule> (no merge base)\""
msgstr "“合并子模块 <submodule> 失败（没有合并基础）”"

#. type: Plain text
#: en/git-merge-tree.txt:173
#, priority:100
msgid "\"Warning: cannot merge binary files: <filename>\""
msgstr "“警告：不能合并二进制文件： <filename>”"

#. type: Plain text
#: en/git-merge-tree.txt:175
#, placeholders:'`-z`', priority:100
msgid "If `-z` is NOT passed:"
msgstr "如果没有传递 `-z`："

#. type: Plain text
#: en/git-merge-tree.txt:185
#, priority:100
msgid "This section starts with a blank line to separate it from the previous sections, and then only contains the <conflict-message> information from the previous section (separated by newlines). These are non-stable strings that should not be parsed by scripts, and are just meant for human consumption. Also, note that while <conflict-message> strings usually do not contain embedded newlines, they sometimes do. (However, the free-form messages will never have an embedded NUL character). So, the entire block of information is meant for human readers as an agglomeration of all conflict messages."
msgstr "这一节以空行开始，与前几节分开，然后只包含前一节的 <conflict-message> 信息（用换行符分开）。 这些是不稳定的字符串，不应该被脚本解析，只是为了供人使用。 另外，请注意，虽然 <conflict-message> 字符串通常不包含嵌入式换行符，但有时也会包含。 (然而，自由格式的信息永远不会有一个嵌入的 NUL 字符）。 所以，整个信息块是作为所有冲突信息的集合体提供给人类阅读的。"

#. type: Plain text
#: en/git-merge-tree.txt:196
#, placeholders:'--stdin', priority:100
msgid "For a successful, non-conflicted merge, the exit status is 0. When the merge has conflicts, the exit status is 1. If the merge is not able to complete (or start) due to some kind of error, the exit status is something other than 0 or 1 (and the output is unspecified). When --stdin is passed, the return status is 0 for both successful and conflicted merges, and something other than 0 or 1 if it cannot complete all the requested merges."
msgstr "如果合并成功，没有冲突，退出状态为 0；如果合并有冲突，退出状态为 1；如果合并由于某种错误而无法完成（或开始），退出状态为 0 或 1 以外的内容（而且输出结果未指明）。 当传递 --stdin 时，对于成功的合并和有冲突的合并，返回状态都是 0，如果不能完成所有要求的合并，则返回 0 或 1 以外的其他状态。"

#. type: Title -
#: en/git-merge-tree.txt:198
#, no-wrap, priority:100
msgid "USAGE NOTES"
msgstr "使用说明"

#. type: Plain text
#: en/git-merge-tree.txt:205
#, placeholders:'linkgit:git-hash-object[1]':'linkgit:git-mktree[1]':'linkgit:git-commit-tree[1]':'linkgit:git-write-tree[1]':'linkgit:git-update-ref[1]':'linkgit:git-mktag[1]', priority:100
msgid "This command is intended as low-level plumbing, similar to linkgit:git-hash-object[1], linkgit:git-mktree[1], linkgit:git-commit-tree[1], linkgit:git-write-tree[1], linkgit:git-update-ref[1], and linkgit:git-mktag[1]. Thus, it can be used as a part of a series of steps such as:"
msgstr "这个命令旨在作为低级的底层命令，类似于 linkgit:git-hash-object[1]，linkgit:git-mktree[1]， linkgit:git-commit-tree[1]， linkgit:git-write-tree[1]，linkgit:git-update-ref[1] 和 linkgit:git-mktag[1]。 因此，它可以作为一系列步骤的一部分来使用，比如："

#. type: Plain text
#: en/git-merge-tree.txt:210
#, ignore-ellipsis, no-wrap, placeholders:'git merge-tree':'--write-tree':'$BRANCH1':'$BRANCH2':'git commit-tree':'$NEWTREE':'$BRANCH1':'$BRANCH2':'git update-ref':'$BRANCH1':'$NEWCOMMIT', priority:100
msgid ""
"       NEWTREE=$(git merge-tree --write-tree $BRANCH1 $BRANCH2)\n"
"       test $? -eq 0 || die \"There were conflicts...\"\n"
"       NEWCOMMIT=$(git commit-tree $NEWTREE -p $BRANCH1 -p $BRANCH2)\n"
"       git update-ref $BRANCH1 $NEWCOMMIT\n"
msgstr ""
"       NEWTREE=$(git merge-tree --write-tree $BRANCH1 $BRANCH2)\n"
"       test $? -eq 0 || die \"There were conflicts...\"\n"
"       NEWCOMMIT=$(git commit-tree $NEWTREE -p $BRANCH1 -p $BRANCH2)\n"
"       git update-ref $BRANCH1 $NEWCOMMIT\n"

#. type: Plain text
#: en/git-merge-tree.txt:213
#, priority:100
msgid "Note that when the exit status is non-zero, `NEWTREE` in this sequence will contain a lot more output than just a tree."
msgstr "注意，当退出状态为非零时，这个序列中的 `NEWTREE` 将包含很多输出，而不仅仅是一棵目录树。"

#. type: Plain text
#: en/git-merge-tree.txt:216
#, placeholders:'linkgit:git-merge[1]', priority:100
msgid "For conflicts, the output includes the same information that you'd get with linkgit:git-merge[1]:"
msgstr "对于冲突，输出包括你用 linkgit:git-merge[1] 得到的相同信息："

#. type: Plain text
#: en/git-merge-tree.txt:219
#, placeholders:'<<OIDTLT,', priority:100
msgid "what would be written to the working tree (the <<OIDTLT,OID of toplevel tree>>)"
msgstr "什么会被写入工作区（<<OIDTLT,顶层目录树树的 OID>>）"

#. type: Plain text
#: en/git-merge-tree.txt:221
#, placeholders:'<<CFI,', priority:100
msgid "the higher order stages that would be written to the index (the <<CFI,Conflicted file info>>)"
msgstr "将被写入索引的高阶阶段（<<CFI,冲突的文件信息>>）"

#. type: Plain text
#: en/git-merge-tree.txt:223
#, placeholders:'<<IM,', priority:100
msgid "any messages that would have been printed to stdout (the <<IM,Informational messages>>)"
msgstr "任何会被打印到标准输出流的信息（<<IM,信息性信息>>）"

#. type: Plain text
#: en/git-merge-tree.txt:228
#, placeholders:'git merge-tree':'--stdin', priority:100
msgid "'git merge-tree --stdin' input format is fully text based. Each line has this format:"
msgstr "'git merge-tree --stdin' 的输入格式是完全基于文本的。每一行都有这样的格式："

#. type: Plain text
#: en/git-merge-tree.txt:230
#, no-wrap, priority:100
msgid "\t[<base-commit> -- ]<branch1> <branch2>\n"
msgstr "\t[<基础提交> -- ]<分支1> <分支2>\n"

#. type: Plain text
#: en/git-merge-tree.txt:234
#, priority:100
msgid "If one line is separated by `--`, the string before the separator is used for specifying a merge-base for the merge and the string after the separator describes the branches to be merged."
msgstr "如果一行被 `--` 分隔，分隔符前的字符串用于指定合并的基础，分隔符后的字符串描述要合并的分支。"

#. type: Title -
#: en/git-merge-tree.txt:236
#, no-wrap, priority:100
msgid "MISTAKES TO AVOID"
msgstr "应避免的错误"

#. type: Plain text
#: en/git-merge-tree.txt:245
#, placeholders:'<<CFI,', priority:100
msgid "Do NOT look through the resulting toplevel tree to try to find which files conflict; parse the <<CFI,Conflicted file info>> section instead. Not only would parsing an entire tree be horrendously slow in large repositories, there are numerous types of conflicts not representable by conflict markers (modify/delete, mode conflict, binary file changed on both sides, file/directory conflicts, various rename conflict permutations, etc.)"
msgstr "不要在产生的顶层目录树中寻找哪些文件有冲突，而要解析 <<CFI,冲突文件信息>> 部分。 在大型存储库中，不仅解析整个目录树会慢得吓人，而且有许多冲突类型无法用冲突标记来表示（修改/删除，模式冲突，二进制文件在两边都有改变，文件/目录冲突，各种重命名冲突的变种，等等。）"

#. type: Plain text
#: en/git-merge-tree.txt:251
#, placeholders:'<<CFI,', priority:100
msgid "Do NOT interpret an empty <<CFI,Conflicted file info>> list as a clean merge; check the exit status. A merge can have conflicts without having individual files conflict (there are a few types of directory rename conflicts that fall into this category, and others might also be added in the future)."
msgstr "不要把一个空的 <<CFI,冲突文件信息>> 列表理解为一个干净的合并；检查退出状态。 一个合并可以有冲突而没有单个文件的冲突（有几种类型的目录重命名冲突属于这个类别，其他的也可能在将来被添加）。"

#. type: Plain text
#: en/git-merge-tree.txt:265
#, placeholders:'<<CFI,':'<<IM,':'merge.directoryRenames':'<<IM,', priority:100
msgid "Do NOT attempt to guess or make the user guess the conflict types from the <<CFI,Conflicted file info>> list. The information there is insufficient to do so. For example: Rename/rename(1to2) conflicts (both sides renamed the same file differently) will result in three different files having higher order stages (but each only has one higher order stage), with no way (short of the <<IM,Informational messages>> section) to determine which three files are related. File/directory conflicts also result in a file with exactly one higher order stage. Possibly-involved-in-directory-rename conflicts (when \"merge.directoryRenames\" is unset or set to \"conflicts\") also result in a file with exactly one higher order stage. In all cases, the <<IM,Informational messages>> section has the necessary info, though it is not designed to be machine parseable."
msgstr "不要试图猜测或让用户猜测 <<CFI,冲突文件信息>> 列表中的冲突类型。 那里的信息不足以做到这一点。 比如说： Rname/rename（ 1 对 2 ）冲突（双方以不同方式重命名同一文件）将导致三个不同的文件具有高阶阶段(但每个文件只有一个高阶阶段），没有办法（除了 <<IM,信息消息>> 部分）确定哪三个文件是相关的。 文件/目录冲突也会导致一个文件正好有一个高阶阶段。 可能涉及目录重命名的冲突（当 \"merge.directoryRenames\" 未设置或设置为 \"conflict\" 时）也会导致一个文件正好有一个高阶阶段。 在所有情况下，<<IM,消息性信息>> 部分都有必要的信息，尽管它不是被设计为可被机器解析的。"

#. type: Plain text
#: en/git-merge-tree.txt:272
#, placeholders:'<<CFI,':'<<IM,', priority:100
msgid "Do NOT assume that each path from <<CFI,Conflicted file info>>, and the logical conflicts in the <<IM,Informational messages>> have a one-to-one mapping, nor that there is a one-to-many mapping, nor a many-to-one mapping. Many-to-many mappings exist, meaning that each path can have many logical conflict types in a single merge, and each logical conflict type can affect many paths."
msgstr "不要假设 <<CFI,冲突文件信息>> 中的每个路径和 <<IM,信息消息>> 中的逻辑冲突有一对一的映射，也不要假设存在一对多的映射，更不要假设存在多对一的映射。 存在多对多的映射，意味着每个路径在一次合并中可以有许多逻辑冲突类型，每个逻辑冲突类型可以影响许多路径。"

#. type: Plain text
#: en/git-merge-tree.txt:276
#, placeholders:'<<IM,', priority:100
msgid "Do NOT assume all filenames listed in the <<IM,Informational messages>> section had conflicts. Messages can be included for files that have no conflicts, such as \"Auto-merging <file>\"."
msgstr "不要认为 <<IM,信息消息>> 部分列出的所有文件名都有冲突。 对于没有冲突的文件，可以包括信息，如 \"Auto-merging <文件>\"。"

#. type: Plain text
#: en/git-merge-tree.txt:287
#, placeholders:'<<CFI,':'<<OIDTLT,':'<<CFI,', priority:100
msgid "AVOID taking the OIDS from the <<CFI,Conflicted file info>> and re-merging them to present the conflicts to the user. This will lose information. Instead, look up the version of the file found within the <<OIDTLT,OID of toplevel tree>> and show that instead. In particular, the latter will have conflict markers annotated with the original branch/commit being merged and, if renames were involved, the original filename. While you could include the original branch/commit in the conflict marker annotations when re-merging, the original filename is not available from the <<CFI,Conflicted file info>> and thus you would be losing information that might help the user resolve the conflict."
msgstr "避免从 <<CFI,冲突文件信息>> 中提取 OIDS，并将它们重新合并以向用户展示冲突。 这将丢失信息。 相反，在 <<OIDTLT,顶层目录树的OID>> 中查找文件的版本，并显示它。 特别是，后者将有冲突标记，并标明被合并的原始分支/提交，如果涉及重名，则标明原始文件名。 虽然你可以在重新合并时将原始分支/提交包括在冲突标记的注释中，但原始文件名不能从 <<CFI,冲突文件信息>> 中获得，因此你会失去可能帮助用户解决冲突的信息。"

#. type: Title -
#: en/git-merge-tree.txt:290
#, no-wrap, priority:100
msgid "DEPRECATED DESCRIPTION"
msgstr "弃用说明"

#. type: Plain text
#: en/git-merge-tree.txt:295
#, placeholders:'<<NEWMERGE,':'`--trivial-merge`', priority:100
msgid "Per the <<NEWMERGE,DESCRIPTION>> and unlike the rest of this documentation, this section describes the deprecated `--trivial-merge` mode."
msgstr "根据 <<NEWMERGE,DESCRIPTION>>，与本文档的其他部分不同，本节描述了被废弃的 `--trivial-merge` 模式。"

#. type: Plain text
#: en/git-merge-tree.txt:298
#, placeholders:'`--trivial-merge`', priority:100
msgid "Other than the optional `--trivial-merge`, this mode accepts no options."
msgstr "除了可选的 `--trivial-merge` 外，该模式不接受任何选项。"

#. type: Plain text
#: en/git-merge-tree.txt:306
#, placeholders:'git read-tree', priority:100
msgid "This mode reads three tree-ish, and outputs trivial merge results and conflicting stages to the standard output in a semi-diff format. Since this was designed for higher level scripts to consume and merge the results back into the index, it omits entries that match <branch1>. The result of this second form is similar to what three-way 'git read-tree -m' does, but instead of storing the results in the index, the command outputs the entries to the standard output."
msgstr "这种模式读取三个树状的，并将琐碎的合并结果和冲突的阶段以 semi-diff 格式输出到标准输出。 由于这是为更高级别的脚本设计的，以消耗并将结果合并回索引中，所以它省略了与 <branch1> 相匹配的条目。 第二种形式的结果类似于三方 \"git read-tree -m\" 的做法，但该命令不是将结果存储在索引中，而是将条目输出到标准输出。"

#. type: Plain text
#: en/git-merge-tree.txt:313
#, priority:100
msgid "This form not only has limited applicability (a trivial merge cannot handle content merges of individual files, rename detection, proper directory/file conflict handling, etc.), the output format is also difficult to work with, and it will generally be less performant than the first form even on successful merges (especially if working in large repositories)."
msgstr "这种形式不仅适用性有限（一个琐碎的合并不能处理单个文件的内容合并、重命名检测、适当的目录/文件冲突处理等），输出格式也很难处理，而且即使在成功的合并中，它的性能一般也不如第一种形式（特别是在大型仓库中工作）。"

#. type: Title =
#: en/git-merge.txt:2
#, ignore-same, no-wrap, priority:240
msgid "git-merge(1)"
msgstr "git-merge(1)"

#. type: Plain text
#: en/git-merge.txt:7
#, placeholders:'git-merge', priority:240
msgid "git-merge - Join two or more development histories together"
msgstr "git-merge - 将两个或多个开发历史合并在一起"

# ERROR: --stat not found in translation
# ERROR: --abort not found in translation
# ERROR: --quit not found in translation
# ERROR: --stat] not found in translation
# ERROR: --[no-]rerere-autoupdate] not found in translation
#. type: Plain text
#: en/git-merge.txt:18
#, ignore-ellipsis, no-wrap, placeholders:'[--stat]':'[--no-commit]':'[--squash]':'[--no-verify]':'[--into-name':'--continue':'--abort':'--quit', priority:240
msgid ""
"'git merge' [-n] [--stat] [--no-commit] [--squash] [--[no-]edit]\n"
"\t[--no-verify] [-s <strategy>] [-X <strategy-option>] [-S[<keyid>]]\n"
"\t[--[no-]allow-unrelated-histories]\n"
"\t[--[no-]rerere-autoupdate] [-m <msg>] [-F <file>]\n"
"\t[--into-name <branch>] [<commit>...]\n"
"'git merge' (--continue | --abort | --quit)\n"
msgstr ""
"'git merge' [-n] [--stat] [--no-commit] [--squash] [--[no-]edit]\n"
"\t[--no-verify] [-s <策略>] [-X <策略选项>] [-S[<键 ID>]]\n"
"\t[--[no-]allow-unrelated-histories]\n"
"\t[--[no-]rerere-autoupdate] [-m <信息>] [-F <文件>]\n"
"\t[--into-name <分支>] [<提交>...］\n"
"'git merge' (--continue |--abort |--quit)\n"

#. type: Plain text
#: en/git-merge.txt:26
#, priority:240
msgid "Incorporates changes from the named commits (since the time their histories diverged from the current branch) into the current branch. This command is used by `git pull` to incorporate changes from another repository and can be used by hand to merge changes from one branch into another."
msgstr "将指定的提交内容（从它们的历史与当前分支相分离时起）并入当前分支。 这条命令被 \"git pull \"用来合并另一个仓库的改动，也可以用手将一个分支的改动合并到另一个分支。"

#. type: Plain text
#: en/git-merge.txt:29
#, priority:240
msgid "Assume the following history exists and the current branch is `master`:"
msgstr "假设存在以下历史，且当前分支为 `master`："

#. type: delimited block -
#: en/git-merge.txt:34
#, no-wrap, placeholders:'---B---C':'---E---F---G', priority:240
msgid ""
"\t  A---B---C topic\n"
"\t /\n"
"    D---E---F---G master\n"
msgstr ""
"\t  A---B---C topic\n"
"\t /\n"
"    D---E---F---G master\n"

#. type: Plain text
#: en/git-merge.txt:42
#, placeholders:'ORIG_HEAD', priority:240
msgid "Then `git merge topic` will replay the changes made on the `topic` branch since it diverged from `master` (i.e., `E`) until its current commit (`C`) on top of `master`, and record the result in a new commit along with the names of the two parent commits and a log message from the user describing the changes. Before the operation, `ORIG_HEAD` is set to the tip of the current branch (`C`)."
msgstr "然后 `git merge topic` 将重现 `topic` 分支从 `master`（即 `E`）分流到 `master` 之上的当前提交（ `C` ）所做的修改，并将结果与两个父提交的名称和用户描述修改的日志信息一起记录在一个新提交中。在操作之前，`ORIG_HEAD`被设置为当前分支（`C`）的顶端。"

#. type: delimited block -
#: en/git-merge.txt:47
#, no-wrap, placeholders:'---B---C':'---E---F---G---H', priority:240
msgid ""
"\t  A---B---C topic\n"
"\t /         \\\n"
"    D---E---F---G---H master\n"
msgstr ""
"\t  A---B---C topic\n"
"\t /         \\\n"
"    D---E---F---G---H master\n"

#. type: Plain text
#: en/git-merge.txt:53
#, placeholders:'`--no-commit`':'--abort`':'--continue`', priority:240
msgid "A merge stops if there's a conflict that cannot be resolved automatically or if `--no-commit` was provided when initiating the merge. At that point you can run `git merge --abort` or `git merge --continue`."
msgstr "如果出现无法自动解决的冲突，或者在启动合并时提供了 `--no-commit` 选项，合并就会停止。这时可以运行 `git merge --abort` 或 `git merge --continue` 。"

#. type: Plain text
#: en/git-merge.txt:59
#, placeholders:'--abort`':'--abort`', priority:240
msgid "`git merge --abort` will abort the merge process and try to reconstruct the pre-merge state. However, if there were uncommitted changes when the merge started (and especially if those changes were further modified after the merge was started), `git merge --abort` will in some cases be unable to reconstruct the original (pre-merge) changes. Therefore:"
msgstr "`git merge --abort` 会中止合并过程，并尝试重建合并前的状态。然而，如果合并开始时有未提交的修改（尤其是合并开始后这些修改被进一步修改），`git merge --abort` 在某些情况下将无法重建原始的（合并前的）修改。因此："

#. type: Plain text
#: en/git-merge.txt:63
#, priority:240
msgid "*Warning*: Running `git merge` with non-trivial uncommitted changes is discouraged: while possible, it may leave you in a state that is hard to back out of in the case of a conflict."
msgstr "*警告*：在非重要的未提交的修改中运行 `git merge`是不可取的。不鼓励这样做：虽然有可能，但它可能会让你处于一个很难在冲突中恢复的状态。并且如果发生冲突的话会处于一个很难退出的状态。"

#. type: Plain text
#: en/git-merge.txt:73
#, priority:240
msgid "Set the commit message to be used for the merge commit (in case one is created)."
msgstr "设置用于合并提交的提交信息（如果创建了一个的话）。"

#. type: Plain text
#: en/git-merge.txt:76 en/git-merge.txt:93
#, placeholders:'`--log`', priority:240
msgid "If `--log` is specified, a shortlog of the commits being merged will be appended to the specified message."
msgstr "如果指定了`--log`，正在合并的提交的简短日志将被附加到指定的消息中。"

#. type: Plain text
#: en/git-merge.txt:80
#, placeholders:'git fmt-merge-msg', priority:240
msgid "The `git fmt-merge-msg` command can be used to give a good default for automated `git merge` invocations. The automated message can include the branch description."
msgstr "`git fmt-merge-msg` 命令可以为自动 `git merge` 调用提供一个良好的默认值。自动信息可以包括分支描述。"

#. type: Plain text
#: en/git-merge.txt:85
#, priority:240
msgid "Prepare the default merge message as if merging to the branch `<branch>`, instead of the name of the real branch to which the merge is made."
msgstr "准备默认的合并信息，就像合并到分支`<分支>`一样，而不是真正要合并的分支名称。"

#. type: Plain text
#: en/git-merge.txt:90
#, priority:240
msgid "Read the commit message to be used for the merge commit (in case one is created)."
msgstr "读取用于合并提交的提交信息（如果创建了）。"

#. type: Plain text
#: en/git-merge.txt:100
#, placeholders:'`--no-overwrite-ignore`', priority:240
msgid "Silently overwrite ignored files from the merge result. This is the default behavior. Use `--no-overwrite-ignore` to abort."
msgstr "默认会静默地覆盖合并结果中被忽略的文件。使用`--no-overwrite-ignore`来终止。"

#. type: Plain text
#: en/git-merge.txt:105
#, priority:240
msgid "Abort the current conflict resolution process, and try to reconstruct the pre-merge state. If an autostash entry is present, apply it to the worktree."
msgstr "中止当前的冲突解决过程，并尝试重建合并前的状态。工作区会自动应用自动存储条目。"

#. type: Plain text
#: en/git-merge.txt:110
#, placeholders:'--abort`', priority:240
msgid "If there were uncommitted worktree changes present when the merge started, `git merge --abort` will in some cases be unable to reconstruct these changes. It is therefore recommended to always commit or stash your changes before running `git merge`."
msgstr "如果合并开始时有未提交的工作区变化，`git merge --abort` 在某些情况下将无法重现这些变化。因此，建议在运行 `git merge` 之前，一定要提交或储存你的修改。"

# ERROR: --abort` not found in translation
# ERROR: --merge` not found in translation
# ERROR: --abort` not found in translation
# ERROR: --merge` not found in translation
#. type: Plain text
#: en/git-merge.txt:116
#, placeholders:'--abort`':'--merge`':'MERGE_HEAD':'MERGE_AUTOSTASH':'--abort`':'--merge`', priority:240
msgid "`git merge --abort` is equivalent to `git reset --merge` when `MERGE_HEAD` is present unless `MERGE_AUTOSTASH` is also present in which case `git merge --abort` applies the stash entry to the worktree whereas `git reset --merge` will save the stashed changes in the stash list."
msgstr "当 `MERGE_HEAD` 存在时，`git merge --abort` 等同于 `git reset --merge` ，除非 `MERGE_AUTOSTASH`也存在，在这种情况下 `git merge --abort` 会将暂存项应用到工作区重，而 `git reset --merge` 则会将暂存的改动保存在暂存列表中。"

#. type: Plain text
#: en/git-merge.txt:121
#, placeholders:'MERGE_AUTOSTASH', priority:240
msgid "Forget about the current merge in progress. Leave the index and the working tree as-is. If `MERGE_AUTOSTASH` is present, the stash entry will be saved to the stash list."
msgstr "忘记当前正在进行的合并。让索引和工作区保持原样。如果`MERGE_AUTOSTASH`存在，储藏库条目将被保存到储藏库列表。"

#. type: Plain text
#: en/git-merge.txt:126
#, placeholders:'--continue`', priority:240
msgid "After a `git merge` stops due to conflicts you can conclude the merge by running `git merge --continue` (see \"HOW TO RESOLVE CONFLICTS\" section below)."
msgstr "在 `git merge` 因冲突而停止后，你可以通过运行 `git merge --continue` 来结束当前合并（见下文“如何解决冲突”部分）。"

#. type: Plain text
#: en/git-merge.txt:131
#, priority:240
msgid "Commits, usually other branch heads, to merge into our branch. Specifying more than one commit will create a merge with more than two parents (affectionately called an Octopus merge)."
msgstr "提交，通常是其他分支负责人，合并到我们的分支中。 指定多个提交将创建具有两个以上父项的合并（亲切地称为八爪/多路合并）。"

#. type: Plain text
#: en/git-merge.txt:135
#, priority:240
msgid "If no commit is given from the command line, merge the remote-tracking branches that the current branch is configured to use as its upstream. See also the configuration section of this manual page."
msgstr "如果命令行没有给出提交，则合并当前分支被配置为上游的远程跟踪分支。 参见本手册页的配置部分。"

#. type: Plain text
#: en/git-merge.txt:139
#, placeholders:'FETCH_HEAD':'.git/FETCH_HEAD', priority:240
msgid "When `FETCH_HEAD` (and no other commit) is specified, the branches recorded in the `.git/FETCH_HEAD` file by the previous invocation of `git fetch` for merging are merged to the current branch."
msgstr "当指定`FETCH_HEAD`（没有其他提交）时，之前调用 `git fetch`进行合并时记录在`.git/FETCH_HEAD`文件中的分支会被合并到当前分支。"

#. type: Title -
#: en/git-merge.txt:142
#, no-wrap, priority:240
msgid "PRE-MERGE CHECKS"
msgstr "合并前检查"

#. type: Plain text
#: en/git-merge.txt:150
#, placeholders:'linkgit:git-stash[1]', priority:240
msgid "Before applying outside changes, you should get your own work in good shape and committed locally, so it will not be clobbered if there are conflicts. See also linkgit:git-stash[1]. `git pull` and `git merge` will stop without doing anything when local uncommitted changes overlap with files that `git pull`/`git merge` may need to update."
msgstr "在应用外部的修改之前，你应该把自己的工作做好，并在本地提交，这样在有冲突的时候就不会被打乱了。 参见 linkgit:git-stash[1]。 `git pul` 和 `git merge` 会在本地未提交的修改与 `git pull`/`git merge` 可能需要更新的文件重叠时会不做任何操作，立即停止。"

#. type: Plain text
#: en/git-merge.txt:156
#, placeholders:'HEAD':'HEAD', priority:240
msgid "To avoid recording unrelated changes in the merge commit, `git pull` and `git merge` will also abort if there are any changes registered in the index relative to the `HEAD` commit. (Special narrow exceptions to this rule may exist depending on which merge strategy is in use, but generally, the index must match HEAD.)"
msgstr "为了避免在合并提交中记录不相关的变化，`git pull` 和 `git merge` 也会在相对于`HEAD`提交的索引中存在任何变化时中止。 (根据使用的合并策略，这一规则可能存在特殊的狭义例外，但一般来说，索引必须与HEAD相匹配。)"

#. type: Plain text
#: en/git-merge.txt:159
#, placeholders:'HEAD', priority:240
msgid "If all named commits are already ancestors of `HEAD`, `git merge` will exit early with the message \"Already up to date.\""
msgstr "如果所有命名的提交都已经是`HEAD`的祖先，`git merge` 将提前退出，提示 \"已经是最新的。\""

#. type: Title -
#: en/git-merge.txt:161
#, no-wrap, priority:240
msgid "FAST-FORWARD MERGE"
msgstr "快进式合并"

#. type: Plain text
#: en/git-merge.txt:171
#, placeholders:'HEAD', priority:240
msgid "Often the current branch head is an ancestor of the named commit. This is the most common case especially when invoked from `git pull`: you are tracking an upstream repository, you have committed no local changes, and now you want to update to a newer upstream revision. In this case, a new commit is not needed to store the combined history; instead, the `HEAD` (along with the index) is updated to point at the named commit, without creating an extra merge commit."
msgstr "通常情况下，当前的分支头是指定提交的祖先。 这是最常见的情况，特别是当从'git pull'调用时：你正在跟踪一个上游仓库，你没有提交本地的修改，现在你想更新到一个更新的上游版本。 在这种情况下，不需要新的提交来存储合并历史；相反，`HEAD`（连同索引）被更新为指向指定的提交，而不需要创建额外的合并提交。"

#. type: Plain text
#: en/git-merge.txt:173
#, placeholders:'`--no-ff`', priority:240
msgid "This behavior can be suppressed with the `--no-ff` option."
msgstr "这种行为可以通过`--no-ff`选项来抑制。"

#. type: Title -
#: en/git-merge.txt:175
#, no-wrap, priority:240
msgid "TRUE MERGE"
msgstr "正确的合并"

#. type: Plain text
#: en/git-merge.txt:180
#, priority:240
msgid "Except in a fast-forward merge (see above), the branches to be merged must be tied together by a merge commit that has both of them as its parents."
msgstr "除了快进合并（见上文），被合并的分支必须由一个以它们两个为父分支的合并提交捆绑在一起。"

#. type: Plain text
#: en/git-merge.txt:185
#, placeholders:'HEAD', priority:240
msgid "A merged version reconciling the changes from all branches to be merged is committed, and your `HEAD`, index, and working tree are updated to it. It is possible to have modifications in the working tree as long as they do not overlap; the update will preserve them."
msgstr "一个调和了所有要合并的分支的修改的合并版本被提交，你的`HEAD`、索引和工作区将更新到这个版本。 在工作区中可以有一些修改，只要它们不重叠；更新将保留这些修改。"

#. type: Plain text
#: en/git-merge.txt:188
#, priority:240
msgid "When it is not obvious how to reconcile the changes, the following happens:"
msgstr "当不清楚如何调和这些变化时，就会发生以下情况："

#. type: Plain text
#: en/git-merge.txt:190
#, placeholders:'HEAD', priority:240
msgid "The `HEAD` pointer stays the same."
msgstr "`HEAD`的指针保持不变。"

#. type: Plain text
#: en/git-merge.txt:191
#, placeholders:'MERGE_HEAD', priority:240
msgid "The `MERGE_HEAD` ref is set to point to the other branch head."
msgstr "`MERGE_HEAD`参数被设置为指向另一个分支头部。"

#. type: Plain text
#: en/git-merge.txt:193
#, priority:240
msgid "Paths that merged cleanly are updated both in the index file and in your working tree."
msgstr "合并干净的路径在索引文件和你的工作区中都更新了。"

#. type: Plain text
#: en/git-merge.txt:199
#, placeholders:'HEAD':'MERGE_HEAD':'git ls-files', priority:240
msgid "For conflicting paths, the index file records up to three versions: stage 1 stores the version from the common ancestor, stage 2 from `HEAD`, and stage 3 from `MERGE_HEAD` (you can inspect the stages with `git ls-files -u`). The working tree files contain the result of the merge operation; i.e. 3-way merge results with familiar conflict markers `<<<` `===` `>>>`."
msgstr "对于冲突的路径，索引文件最多记录三个版本：第1阶段存储来自共同祖先的版本，第2阶段来自 `HEAD` ，第3阶段来自 `MERGE_HEAD` （你可以用`git ls-files -u` 检查这些阶段）。 工作目录树文件包含了 “合并” 程序的结果；即带有熟悉的冲突标记 `<<<` `===` `>>>` 的三方合并结果。"

#. type: Plain text
#: en/git-merge.txt:203
#, placeholders:'AUTO_MERGE', priority:240
msgid "A ref named `AUTO_MERGE` is written, pointing to a tree corresponding to the current content of the working tree (including conflict markers for textual conflicts). Note that this ref is only written when the 'ort' merge strategy is used (the default)."
msgstr "会写入一个引用名为 `AUTO_MERGE` 的引用，指向一个与当前工作区内容（包括文本冲突的冲突标记）相对应的目录树。 请注意，只有在使用 'ort' 合并策略（默认）时，才会写入这个引用。"

#. type: Plain text
#: en/git-merge.txt:207
#, placeholders:'HEAD', priority:240
msgid "No other changes are made. In particular, the local modifications you had before you started merge will stay the same and the index entries for them stay as they were, i.e. matching `HEAD`."
msgstr "没有其他变化。 特别是，你在开始合并之前的本地修改将保持不变，它们的索引条目保持原样，即匹配`HEAD`。"

#. type: Plain text
#: en/git-merge.txt:210
#, placeholders:'--abort`', priority:240
msgid "If you tried a merge which resulted in complex conflicts and want to start over, you can recover with `git merge --abort`."
msgstr "如果你尝试的合并导致了复杂的冲突，并想重新开始，你可以用`git merge --abort`恢复。"

#. type: Title -
#: en/git-merge.txt:212
#, no-wrap, priority:240
msgid "MERGING TAG"
msgstr "合并标签"

#. type: Plain text
#: en/git-merge.txt:219
#, placeholders:'linkgit:git-tag[1]', priority:240
msgid "When merging an annotated (and possibly signed) tag, Git always creates a merge commit even if a fast-forward merge is possible, and the commit message template is prepared with the tag message. Additionally, if the tag is signed, the signature check is reported as a comment in the message template. See also linkgit:git-tag[1]."
msgstr "当合并一个有注释的（可能是有签名的）标签时，即使可以进行快速合并，Git也会创建一个合并提交，并且会一起准备提交消息模板和标签消息。 此外，如果标签有签名，签名检查会在消息模板中作为注释报告。参见 linkgit:git-tag[1]。"

#. type: Plain text
#: en/git-merge.txt:223
#, priority:240
msgid "When you want to just integrate with the work leading to the commit that happens to be tagged, e.g. synchronizing with an upstream release point, you may not want to make an unnecessary merge commit."
msgstr "当你只想与恰好被标记的提交的工作整合时，比如说与上游发布点同步，你可能不想做一个不必要的合并提交。"

#. type: Plain text
#: en/git-merge.txt:227
#, placeholders:'`--ff-only`', priority:240
msgid "In such a case, you can \"unwrap\" the tag yourself before feeding it to `git merge`, or pass `--ff-only` when you do not have any work on your own. e.g."
msgstr "在这种情况下，你可以在把标签送入`git merge`之前自己 \"解包\"，或者在自己没有任何工作的时候设置`--ff-only`，如下例。"

#. type: delimited block -
#: en/git-merge.txt:232
#, no-wrap, placeholders:'--ff-only', priority:240
msgid ""
"git fetch origin\n"
"git merge v1.2.3^0\n"
"git merge --ff-only v1.2.3\n"
msgstr ""
"git fetch origin\n"
"git merge v1.2.3^0\n"
"git merge --ff-only v1.2.3\n"

#. type: Title -
#: en/git-merge.txt:236
#, no-wrap, priority:240
msgid "HOW CONFLICTS ARE PRESENTED"
msgstr "冲突如何呈现"

#. type: Plain text
#: en/git-merge.txt:245
#, priority:240
msgid "During a merge, the working tree files are updated to reflect the result of the merge. Among the changes made to the common ancestor's version, non-overlapping ones (that is, you changed an area of the file while the other side left that area intact, or vice versa) are incorporated in the final result verbatim. When both sides made changes to the same area, however, Git cannot randomly pick one side over the other, and asks you to resolve it by leaving what both sides did to that area."
msgstr "在合并过程中，工作区文件被更新以反映合并的结果。 在对共同祖先的版本所做的修改中，非重叠的修改（即你改变了文件的某个区域，而另一方则保留了该区域，反之亦然）会被逐字纳入最终结果中。 然而，当双方都对同一区域进行了修改时，Git不能随机地选择一方而不是另一方，而是要求你通过保留双方对该区域的修改来解决这个问题。"

#. type: Plain text
#: en/git-merge.txt:248
#, priority:240
msgid "By default, Git uses the same style as the one used by the \"merge\" program from the RCS suite to present such a conflicted hunk, like this:"
msgstr "默认情况下，Git使用与RCS套件中的 \"merge\"程序相同的样式来呈现这样一个有冲突的大块，像这样："

#. type: delimited block -
#: en/git-merge.txt:260
#, no-wrap, priority:240
msgid ""
"Here are lines that are either unchanged from the common\n"
"ancestor, or cleanly resolved because only one side changed,\n"
"or cleanly resolved because both sides changed the same way.\n"
"<<<<<<< yours:sample.txt\n"
"Conflict resolution is hard;\n"
"let's go shopping.\n"
"=======\n"
"Git makes conflict resolution easy.\n"
">>>>>>> theirs:sample.txt\n"
"And here is another line that is cleanly resolved or unmodified.\n"
msgstr ""
"这里是与共同的祖先相比没有变化的行。\n"
"祖先没有变化，或者因为只有一方发生了变化而得到干净的解决、\n"
"或者因为两边都有相同的变化而被干净地解决了。\n"
"<<<<<<< yours:sample.txt\n"
"冲突的解决是困难的；\n"
"让我们去购物吧。\n"
"=======\n"
"Git让冲突解决变得简单。\n"
">>>>>>> theirs:sample.txt\n"
"而这里是另一行干净利落的解决或未修改的内容。\n"

#. type: Plain text
#: en/git-merge.txt:265
#, priority:240
msgid "The area where a pair of conflicting changes happened is marked with markers `<<<<<<<`, `=======`, and `>>>>>>>`. The part before the `=======` is typically your side, and the part afterwards is typically their side."
msgstr "发生一对冲突变化的区域被标记为`<<<<<<<`、`=======`和`>>>>>>>`。 `=======`之前的部分通常是你做的修改，而之后的部分通常是别人的修改。"

#. type: Plain text
#: en/git-merge.txt:271
#, priority:240
msgid "The default format does not show what the original said in the conflicting area. You cannot tell how many lines are deleted and replaced with Barbie's remark on your side. The only thing you can tell is that your side wants to say it is hard and you'd prefer to go shopping, while the other side wants to claim it is easy."
msgstr "默认的格式并不显示原文在冲突区说了什么。 你无法知道有多少行被删除，并被替换成你方的芭比娃娃的言论。 你唯一能知道的是，你方想说这很难，你更愿意去购物，而另一方则想说这很容易。"

#. type: Plain text
#: en/git-merge.txt:275
#, placeholders:'merge.conflictStyle', priority:240
msgid "An alternative style can be used by setting the `merge.conflictStyle` configuration variable to either \"diff3\" or \"zdiff3\". In \"diff3\" style, the above conflict may look like this:"
msgstr "通过将 \"merge.conflictStyle \"配置变量设置为 \"diff3 \"或 \"zdiff3\"，可以使用另一种风格。 在 \"diff3 \"风格中，上述冲突可能看起来像这样："

#. type: delimited block -
#: en/git-merge.txt:291
#, no-wrap, priority:240
msgid ""
"Here are lines that are either unchanged from the common\n"
"ancestor, or cleanly resolved because only one side changed,\n"
"<<<<<<< yours:sample.txt\n"
"or cleanly resolved because both sides changed the same way.\n"
"Conflict resolution is hard;\n"
"let's go shopping.\n"
"||||||| base:sample.txt\n"
"or cleanly resolved because both sides changed identically.\n"
"Conflict resolution is hard.\n"
"=======\n"
"or cleanly resolved because both sides changed the same way.\n"
"Git makes conflict resolution easy.\n"
">>>>>>> theirs:sample.txt\n"
"And here is another line that is cleanly resolved or unmodified.\n"
msgstr ""
"这里是与共同的祖先相比没有变化的行。\n"
"祖先没有变化，或者因为只有一方发生了变化而得到了干净的解决、\n"
"<<<<<<< yours:sample.txt\n"
"或干净地解决了，因为双方都以同样的方式改变了。\n"
"冲突的解决是很难的；\n"
"让我们去购物吧。\n"
"||||||| base:sample.txt\n"
"或干净利落地解决了，因为双方的变化都一样。\n"
"冲突的解决是很难的。\n"
"=======\n"
"或干净利落地解决了，因为双方都有相同的变化。\n"
"Git使冲突解决变得容易。\n"
">>>>>>> theirs:sample.txt\n"
"而这里是另一行被干净地解决或未修改的。\n"

#. type: Plain text
#: en/git-merge.txt:294
#, priority:240
msgid "while in \"zdiff3\" style, it may look like this:"
msgstr "而在 \"zdiff3\" 样式中，它可能看起来像这样："

#. type: delimited block -
#: en/git-merge.txt:309
#, no-wrap, priority:240
msgid ""
"Here are lines that are either unchanged from the common\n"
"ancestor, or cleanly resolved because only one side changed,\n"
"or cleanly resolved because both sides changed the same way.\n"
"<<<<<<< yours:sample.txt\n"
"Conflict resolution is hard;\n"
"let's go shopping.\n"
"||||||| base:sample.txt\n"
"or cleanly resolved because both sides changed identically.\n"
"Conflict resolution is hard.\n"
"=======\n"
"Git makes conflict resolution easy.\n"
">>>>>>> theirs:sample.txt\n"
"And here is another line that is cleanly resolved or unmodified.\n"
msgstr ""
"这里是与共同的祖先相比没有变化的行。\n"
"祖先没有变化，或者因为只有一方发生了变化而得到干净的解决、\n"
"或者因为两边都有相同的变化而被干净地解决了。\n"
"<<<<<<< yours:sample.txt\n"
"冲突的解决是困难的；\n"
"让我们去购物吧。\n"
"||||||| base:sample.txt\n"
"或干净利落地解决，因为双方的变化都一样。\n"
"冲突的解决是很难的。\n"
"=======\n"
"Git 让冲突解决变得简单。\n"
">>>>>>> theirs:sample.txt\n"
"而这里是另一行被干净地解决或未修改的内容。\n"

#. type: Plain text
#: en/git-merge.txt:317
#, priority:240
msgid "In addition to the `<<<<<<<`, `=======`, and `>>>>>>>` markers, it uses another `|||||||` marker that is followed by the original text. You can tell that the original just stated a fact, and your side simply gave in to that statement and gave up, while the other side tried to have a more positive attitude. You can sometimes come up with a better resolution by viewing the original."
msgstr "除了`<<<<<<<`、`=======`和`>>>>>>>`标记外，它还使用了另一个`|||||||`标记，后面是原文。 你可以看出，原文只是陈述了一个事实，而你的一方只是屈服于这个陈述而放弃了，而另一方则试图有一个更积极的态度。 你有时可以通过查看原文得出一个更好的解决方案。"

#. type: Title -
#: en/git-merge.txt:320
#, no-wrap, priority:240
msgid "HOW TO RESOLVE CONFLICTS"
msgstr "如何解决冲突"

#. type: Plain text
#: en/git-merge.txt:323
#, priority:240
msgid "After seeing a conflict, you can do two things:"
msgstr "看到冲突后，你可以做两件事："

#. type: Plain text
#: en/git-merge.txt:328
#, placeholders:'HEAD':'--abort`', priority:240
msgid "Decide not to merge. The only clean-ups you need are to reset the index file to the `HEAD` commit to reverse 2. and to clean up working tree changes made by 2. and 3.; `git merge --abort` can be used for this."
msgstr "决定不进行合并。 唯一需要清理的是将索引文件重置为`HEAD`提交，以逆转2.，并清理2.和3.对工作树的修改；可以用`git merge --abort`来做这份工作。"

#. type: Plain text
#: en/git-merge.txt:335
#, placeholders:'--continue`', priority:240
msgid "Resolve the conflicts. Git will mark the conflicts in the working tree. Edit the files into shape and `git add` them to the index. Use `git commit` or `git merge --continue` to seal the deal. The latter command checks whether there is a (interrupted) merge in progress before calling `git commit`."
msgstr "解决冲突。 Git会在工作树上标记冲突。 将文件编辑成形，然后 `git add` 它们到索引中。 使用 `git commit` 或 `git merge --continue` 解决。后一个命令在调用 `git commit` 之前会检查是否有一个（中断的）合并正在进行。"

#. type: Plain text
#: en/git-merge.txt:337
#, priority:240
msgid "You can work through the conflict with a number of tools:"
msgstr "你可以用一些工具来解决冲突："

#. type: Plain text
#: en/git-merge.txt:340
#, priority:240
msgid "Use a mergetool. `git mergetool` to launch a graphical mergetool which will work through the merge with you."
msgstr "使用一个合并工具。 `git mergetool` 启动一个图形化的合并工具，它将帮助你完成合并工作。"

# ERROR: AUTO_MERGE not found in translation
#. type: Plain text
#: en/git-merge.txt:345
#, placeholders:'HEAD':'MERGE_HEAD':'AUTO_MERGE', priority:240
msgid "Look at the diffs. `git diff` will show a three-way diff, highlighting changes from both the `HEAD` and `MERGE_HEAD` versions. `git diff AUTO_MERGE` will show what changes you've made so far to resolve textual conflicts."
msgstr "查看差异。 `git diff` 会显示三向差异，突出显示来自 `HEAD` 和 `MERGE_HEAD` 两个版本的改动。`git diff AUTO_MERGE` 会显示您为解决文本冲突所做的改动。"

#. type: Plain text
#: en/git-merge.txt:349
#, placeholders:'--merge':'HEAD':'MERGE_HEAD', priority:240
msgid "Look at the diffs from each branch. `git log --merge -p <path>` will show diffs first for the `HEAD` version and then the `MERGE_HEAD` version."
msgstr "看看每个分支的差异。`git log --merge -p <路径>`将首先显示`HEAD`版本的差异，然后是`MERGE_HEAD`版本。"

#. type: Plain text
#: en/git-merge.txt:354
#, placeholders:'HEAD':'MERGE_HEAD', priority:240
msgid "Look at the originals. `git show :1:filename` shows the common ancestor, `git show :2:filename` shows the `HEAD` version, and `git show :3:filename` shows the `MERGE_HEAD` version."
msgstr "看一下原件。 `git show :1:filename`显示共同的祖先，`git show :2:filename`显示`HEAD`版本，`git show :3:filename`显示`MERGE_HEAD`版本。"

#. type: Plain text
#: en/git-merge.txt:361
#, priority:240
msgid "Merge branches `fixes` and `enhancements` on top of the current branch, making an octopus merge:"
msgstr "合并分支 `fixes` 和 `enhancements` 到当前分支之上，进行多路合并："

#. type: delimited block -
#: en/git-merge.txt:364
#, no-wrap, priority:240
msgid "$ git merge fixes enhancements\n"
msgstr "$ git merge 修复增强功能\n"

#. type: Plain text
#: en/git-merge.txt:368
#, priority:240
msgid "Merge branch `obsolete` into the current branch, using `ours` merge strategy:"
msgstr "将分支`obsolete`合并到当前分支，使用`ours`的合并策略："

#. type: delimited block -
#: en/git-merge.txt:371
#, no-wrap, priority:240
msgid "$ git merge -s ours obsolete\n"
msgstr "$ git merge -s ours obsolete\n"

#. type: Plain text
#: en/git-merge.txt:375
#, priority:240
msgid "Merge branch `maint` into the current branch, but do not make a new commit automatically:"
msgstr "合并分支`maint`到当前分支，但是我们不做自动创建新提交:"

#. type: delimited block -
#: en/git-merge.txt:378
#, no-wrap, placeholders:'--no-commit', priority:240
msgid "$ git merge --no-commit maint\n"
msgstr "$ git merge --no-commit maint\n"

#. type: Plain text
#: en/git-merge.txt:382
#, priority:240
msgid "This can be used when you want to include further changes to the merge, or want to write your own merge commit message."
msgstr "当您想在合并中加入进一步的更改，或者您想手动编写合并提交信息时，就可以使用此功能。"

#. type: Plain text
#: en/git-merge.txt:386
#, priority:240
msgid "You should refrain from abusing this option to sneak substantial changes into a merge commit. Small fixups like bumping release/version name would be acceptable."
msgstr "你应该避免滥用这个选项，它可以在合并提交中偷偷地进行版本库中实质性的修改。 小的修正，例如修改发布日志内容/版本名称，是推荐的。"

#. type: Labeled list
#: en/git-merge.txt:393
#, no-wrap, priority:240
msgid "branch.<name>.mergeOptions"
msgstr "分支 .<名字>.合并操作选项"

#. type: Plain text
#: en/git-merge.txt:397
#, priority:240
msgid "Sets default options for merging into branch <name>. The syntax and supported options are the same as those of `git merge`, but option values containing whitespace characters are currently not supported."
msgstr "设置合并到分支 <分支名> 的默认选项。语法和支持的选项与 `git merge` 相同，不过目前不支持包含空格的选项值。"

#. type: Plain text
#: en/git-merge.txt:410
#, ignore-same, priority:240
msgid "linkgit:git-fmt-merge-msg[1], linkgit:git-pull[1], linkgit:gitattributes[5], linkgit:git-reset[1], linkgit:git-diff[1], linkgit:git-ls-files[1], linkgit:git-add[1], linkgit:git-rm[1], linkgit:git-mergetool[1]"
msgstr "linkgit:git-fmt-merge-msg[1], linkgit:git-pull[1], linkgit:gitattributes[5], linkgit:git-reset[1], linkgit:git-diff[1], linkgit:git-ls-files[1], linkgit:git-add[1], linkgit:git-rm[1], linkgit:git-mergetool[1]"

#. type: Title =
#: en/git-mktag.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-mktag(1)"
msgstr "git-mktag(1)"

#. type: Plain text
#: en/git-mktag.txt:7
#, placeholders:'git-mktag', priority:100
msgid "git-mktag - Creates a tag object with extra validation"
msgstr "git-mktag - 创建带有额外验证的标记对象"

#. type: Plain text
#: en/git-mktag.txt:13
#, no-wrap, priority:100
msgid "'git mktag'\n"
msgstr "'git mktag'\n"

#. type: Plain text
#: en/git-mktag.txt:19
#, priority:100
msgid "Reads a tag's contents on standard input and creates a tag object. The output is the new tag's <object> identifier."
msgstr "读取标准输入中的标签内容并创建一个标签对象。输出是新标签的 <对象> 标识符。"

#. type: Plain text
#: en/git-mktag.txt:23
#, placeholders:'linkgit:git-hash-object[1]':'--stdin`', priority:100
msgid "This command is mostly equivalent to linkgit:git-hash-object[1] invoked with `-t tag -w --stdin`. I.e. both of these will create and write a tag found in `my-tag`:"
msgstr "这个命令主要等同于 linkgit:git-hash-object[1] 与 `-t tag -w --stdin` 一起调用。也就是说，这两个命令都会创建并写入一个在 `my-tag` 中找到的标签："

#. type: Plain text
#: en/git-mktag.txt:26
#, no-wrap, placeholders:'git hash-object':'--stdin', priority:100
msgid ""
"    git mktag <my-tag\n"
"    git hash-object -t tag -w --stdin <my-tag\n"
msgstr ""
"    git mktag <my-tag\n"
"    git hash-object -t tag -w --stdin <my-tag\n"

#. type: Plain text
#: en/git-mktag.txt:29
#, placeholders:'linkgit:git-fsck[1]', priority:100
msgid "The difference is that mktag will die before writing the tag if the tag doesn't pass a linkgit:git-fsck[1] check."
msgstr "不同的是，如果标签没有通过 linkgit:git-fsck[1] 的检查，mktag 进程会在写入标签前结束。"

#. type: Plain text
#: en/git-mktag.txt:33
#, placeholders:'linkgit:git-fsck[1]', priority:100
msgid "The \"fsck\" check done by mktag is stricter than what linkgit:git-fsck[1] would run by default in that all `fsck.<msg-id>` messages are promoted from warnings to errors (so e.g. a missing \"tagger\" line is an error)."
msgstr "mktag 的 \"fsck\" 检查比 linkgit:git-fsck[1] 默认运行的更严格，因为所有的 `fsck.<消息 ID>` 信息都从警告提升为错误（所以例如，缺少 \"tagger\" 行就是一个错误）。"

#. type: Plain text
#: en/git-mktag.txt:37
#, placeholders:'linkgit:git-fsck[1]', priority:100
msgid "Extra headers in the object are also an error under mktag, but ignored by linkgit:git-fsck[1]. This extra check can be turned off by setting the appropriate `fsck.<msg-id>` variable:"
msgstr "对象中的额外头文件在 mktag 下也是一个错误，但被 linkgit:git-fsck[1] 忽略。这个额外的检查可以通过设置适当的 `fsck.<消息 ID>` 变量来关闭："

#. type: Plain text
#: en/git-mktag.txt:39
#, no-wrap, placeholders:'fsck.extraHeaderEntry', priority:100
msgid "    git -c fsck.extraHeaderEntry=ignore mktag <my-tag-with-headers\n"
msgstr "    git -c fsck.extraHeaderEntry=ignore mktag <my-tag-with-headers\n"

#. type: Plain text
#: en/git-mktag.txt:47
#, placeholders:'linkgit:git-fsck[1]':'`--strict`':'`--no-strict`', priority:100
msgid "By default mktag turns on the equivalent of linkgit:git-fsck[1] `--strict` mode. Use `--no-strict` to disable it."
msgstr "默认情况下，mktag 打开了相当于 linkgit:git-fsck[1] 的 `--strict` 模式。使用 `--no-strict` 来禁用它。"

#. type: Title -
#: en/git-mktag.txt:49
#, no-wrap, priority:100
msgid "Tag Format"
msgstr "标签格式"

#. type: Plain text
#: en/git-mktag.txt:52
#, priority:100
msgid "A tag signature file, to be fed to this command's standard input, has a very simple fixed format: four lines of"
msgstr "将被送入该命令的标准输入的标签签名文件有一个非常简单的固定格式：四行的"

#. type: Plain text
#: en/git-mktag.txt:57
#, no-wrap, priority:100
msgid ""
"  object <hash>\n"
"  type <typename>\n"
"  tag <tagname>\n"
"  tagger <tagger>\n"
msgstr ""
"  object <哈希值>\n"
"  type <类型名>\n"
"  tag <标签名>\n"
"  tagger <标记>\n"

#. type: Plain text
#: en/git-mktag.txt:63
#, priority:100
msgid "followed by some 'optional' free-form message (some tags created by older Git may not have a `tagger` line). The message, when it exists, is separated by a blank line from the header. The message part may contain a signature that Git itself doesn't care about, but that can be verified with gpg."
msgstr "后面是一些 ‘可选的’ 自由形式的信息（一些由旧版 Git 创建的标签可能没有 `tagger` 行）。 当信息存在时，会用一行空行与标头分开。 消息部分可能包含一个 Git 自己并不关心的签名，但可以用 gpg 验证。"

#. type: Title =
#: en/git-mktree.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-mktree(1)"
msgstr "git-mktree(1)"

#. type: Plain text
#: en/git-mktree.txt:7
#, placeholders:'git-mktree', priority:100
msgid "git-mktree - Build a tree-object from ls-tree formatted text"
msgstr "git-mktree - 从 ls-tree 格式化文本构建树对象"

#. type: Plain text
#: en/git-mktree.txt:13
#, no-wrap, placeholders:'[--missing]':'[--batch]', priority:100
msgid "'git mktree' [-z] [--missing] [--batch]\n"
msgstr "'git mktree' [-z] [--missing] [--batch]\n"

#. type: Plain text
#: en/git-mktree.txt:20
#, priority:100
msgid "Reads standard input in non-recursive `ls-tree` output format, and creates a tree object. The order of the tree entries is normalized by mktree so pre-sorting the input is not required. The object name of the tree object built is written to the standard output."
msgstr "以非递归的 `ls-tree` 输出格式读取标准输入，并创建一个树形对象。 树条目的顺序由 mktree 规范化，所以不需要对输入进行预先排序。 建立的树形对象的对象名称被写入标准输出。"

#. type: Plain text
#: en/git-mktree.txt:25
#, priority:100
msgid "Read the NUL-terminated `ls-tree -z` output instead."
msgstr "读取以 NUL 结尾的 `ls-tree -z` 输出。"

#. type: Labeled list
#: en/git-mktree.txt:26
#, ignore-same, no-wrap, priority:100
msgid "--missing"
msgstr "--missing"

#. type: Plain text
#: en/git-mktree.txt:31
#, priority:100
msgid "Allow missing objects. The default behaviour (without this option) is to verify that each tree entry's hash identifies an existing object. This option has no effect on the treatment of gitlink entries (aka \"submodules\") which are always allowed to be missing."
msgstr "允许缺失的对象。 默认行为（没有这个选项）是验证每个树条目的 sha1 标识了一个现有对象。 这个选项对处理 gitlink 条目（又称 “子模块”）没有影响，它总是被允许缺失。"

#. type: Plain text
#: en/git-mktree.txt:37
#, placeholders:'`-z`', priority:100
msgid "Allow building of more than one tree object before exiting. Each tree is separated by a single blank line. The final newline is optional. Note - if the `-z` option is used, lines are terminated with NUL."
msgstr "允许在退出前建立一个以上的目录树对象。 每棵树之间都有一个空行。最后的换行是可选的。 注意 - 如果使用 `-z` 选项，则以 NUL 结束行。"

#. type: Title =
#: en/git-mv.txt:2
#, ignore-same, no-wrap, priority:280
msgid "git-mv(1)"
msgstr "git-mv(1)"

#. type: Plain text
#: en/git-mv.txt:7
#, placeholders:'git-mv', priority:280
msgid "git-mv - Move or rename a file, a directory, or a symlink"
msgstr "git-mv - 移动或重命名一个文件、一个目录或一个符号链接"

#. type: Plain text
#: en/git-mv.txt:13
#, ignore-ellipsis, no-wrap, priority:280
msgid "'git mv' [<options>] <source>... <destination>\n"
msgstr "'git mv' [<options>] <source>... <destination>\n"

#. type: Plain text
#: en/git-mv.txt:17
#, priority:280
msgid "Move or rename a file, directory, or symlink."
msgstr "移动或重命名一个文件、目录或符号链接。"

#. type: Plain text
#: en/git-mv.txt:20
#, ignore-ellipsis, no-wrap, priority:280
msgid ""
" git mv [-v] [-f] [-n] [-k] <source> <destination>\n"
" git mv [-v] [-f] [-n] [-k] <source> ... <destination-directory>\n"
msgstr ""
" git mv [-v] [-f] [-n] [-k] <源文件> <目标文件>\n"
" git mv [-v] [-f] [-n] [-k] <源文件> ...<目标目录>\n"

#. type: Plain text
#: en/git-mv.txt:25
#, priority:280
msgid "In the first form, it renames <source>, which must exist and be either a file, symlink or directory, to <destination>. In the second form, the last argument has to be an existing directory; the given sources will be moved into this directory."
msgstr "在第一种形式中，它将 <源文件>（必须存在且可以是文件、符号链接或目录）重命名为 <目标文件>。在第二种形式中，最后一个参数必须是一个已存在的目录；给定的源文件将被移动到该目录中。"

#. type: Plain text
#: en/git-mv.txt:28
#, priority:280
msgid "The index is updated after successful completion, but the change must still be committed."
msgstr "在移动成功完成后，索引就会被更新，但更改仍需要进行提交才能生效。"

#. type: Plain text
#: en/git-mv.txt:34
#, priority:280
msgid "Force renaming or moving of a file even if the <destination> exists."
msgstr "即使 <目标文件> 存在，也强制重命名或移动文件。"

# ERROR: `-f` not found in translation
#. type: Plain text
#: en/git-mv.txt:39
#, placeholders:'`-f`', priority:280
msgid "Skip move or rename actions which would lead to an error condition. An error happens when a source is neither existing nor controlled by Git, or when it would overwrite an existing file unless `-f` is given."
msgstr "跳过可能导致错误条件的移动或重命名操作。当源文件既不存在也不受Git控制，或者在没有提供 `-f` 选项的情况下覆盖现有文件时，该指令就会就会发生错误。"

#. type: Plain text
#: en/git-mv.txt:42
#, priority:280
msgid "Do nothing; only show what would happen"
msgstr "什么都不做，仅显示将会发生的操作"

#. type: Plain text
#: en/git-mv.txt:46
#, priority:280
msgid "Report the names of files as they are moved."
msgstr "报告文件在移动时的名称的变化。"

#. type: Plain text
#: en/git-mv.txt:54
#, placeholders:'core.worktree':'linkgit:gitmodules[5]', priority:280
msgid "Moving a submodule using a gitfile (which means they were cloned with a Git version 1.7.8 or newer) will update the gitfile and core.worktree setting to make the submodule work in the new location. It also will attempt to update the submodule.<name>.path setting in the linkgit:gitmodules[5] file and stage that file (unless -n is used)."
msgstr "使用 gitfile（意味着它们是使用 Git 1.7.8 或更新版本进行克隆的）来移动子模块将更新 gitfile 和 core.worktree 设置，以使子模块在新位置正常工作。它还将尝试更新 linkgit:gitmodules[5] 文件中的 submodule.<name>.path 设置，并将该文件暂存（除非使用了 -n 选项）。"

#. type: Plain text
#: en/git-mv.txt:66
#, priority:280
msgid "Each time a superproject update moves a populated submodule (e.g. when switching between commits before and after the move) a stale submodule checkout will remain in the old location and an empty directory will appear in the new location. To populate the submodule again in the new location the user will have to run \"git submodule update\" afterwards. Removing the old directory is only safe when it uses a gitfile, as otherwise the history of the submodule will be deleted too. Both steps will be obsolete when recursive submodule update has been implemented."
msgstr "每当父工程更新导致子模块移动时（例如，在移动之前和之后的提交之间切换时），旧位置将保留一个陈旧的子模块检出，并在新位置出现一个空目录。要在新位置重新填充子模块，用户必须运行 \"git submodule update\"。只有在旧目录使用 gitfile 时，删除旧目录才是安全的，否则子模块的历史记录也将被删除。当实现递归子模块更新时，这两个步骤将变得不再需要。"

#. type: Title =
#: en/git-name-rev.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-name-rev(1)"
msgstr "git-name-rev(1)"

#. type: Plain text
#: en/git-name-rev.txt:7
#, placeholders:'git-name-rev', priority:100
msgid "git-name-rev - Find symbolic names for given revs"
msgstr "git-name-rev - 为给定的 rev 查找符号名称"

#. type: Plain text
#: en/git-name-rev.txt:14
#, ignore-ellipsis, no-wrap, placeholders:'git name-rev':'[--tags]':'[--refs=':'--all':'--annotate-stdin', priority:100
msgid ""
"'git name-rev' [--tags] [--refs=<pattern>]\n"
"\t       ( --all | --annotate-stdin | <commit-ish>... )\n"
msgstr ""
"'git name-rev' [--tags] [--refs=<模式>]\n"
"\t       ( --all | --annotate-stdin | <提交号>... )\n"

#. type: Plain text
#: en/git-name-rev.txt:19
#, placeholders:'git rev-parse', priority:100
msgid "Finds symbolic names suitable for human digestion for revisions given in any format parsable by 'git rev-parse'."
msgstr "查找适合人类理解的符号名称，这些名称是以 'git rev-parse' 可解析的任何格式给出的修订。"

#. type: Plain text
#: en/git-name-rev.txt:26
#, priority:100
msgid "Do not use branch names, but only tags to name the commits"
msgstr "不要使用分支名称，只用标签来命名提交内容"

#. type: Labeled list
#: en/git-name-rev.txt:27
#, no-wrap, placeholders:'--refs=', priority:100
msgid "--refs=<pattern>"
msgstr "--refs=<模式>"

#. type: Plain text
#: en/git-name-rev.txt:32
#, placeholders:'`--no-refs`', priority:100
msgid "Only use refs whose names match a given shell pattern. The pattern can be a branch name, a tag name, or a fully qualified ref name. If given multiple times, use refs whose names match any of the given shell patterns. Use `--no-refs` to clear any previous ref patterns given."
msgstr "只使用名称符合给定 shell 模式的引用。 该模式可以是分支名称、标记名称或完全限定的引用名称。如果多次给定，则使用名称符合任何给定 shell 模式的引用。使用 `--no-refs` 可清除之前给出的任何引用模式。"

#. type: Plain text
#: en/git-name-rev.txt:41
#, placeholders:'--refs':'--refs':'--exclude':'`--no-exclude`', priority:100
msgid "Do not use any ref whose name matches a given shell pattern. The pattern can be one of branch name, tag name or fully qualified ref name. If given multiple times, a ref will be excluded when it matches any of the given patterns. When used together with --refs, a ref will be used as a match only when it matches at least one --refs pattern and does not match any --exclude patterns. Use `--no-exclude` to clear the list of exclude patterns."
msgstr "不要使用其名称与给定的壳模式相匹配的任何引用。该模式可以是分支名称、标签名称或完全合格的引用名称之一。如果多次给定，当一个引用与任何给定的模式匹配时，它将被排除。当与 --refs 一起使用时，只有当一个引用至少与一个 --refs 模式相匹配，并且不与任何 --exclude 模式相匹配时，才会被用作匹配。使用 `--no-exclude` 来清除排除模式的列表。"

#. type: Plain text
#: en/git-name-rev.txt:44
#, priority:100
msgid "List all commits reachable from all refs"
msgstr "列出所有引用所可达的所有提交"

#. type: Labeled list
#: en/git-name-rev.txt:45
#, ignore-same, no-wrap, priority:100
msgid "--annotate-stdin"
msgstr "--annotate-stdin"

#. type: Plain text
#: en/git-name-rev.txt:51
#, placeholders:'$hex':'$hex':'--name-only':'$hex':'`--stdin`', priority:100
msgid "Transform stdin by substituting all the 40-character SHA-1 hexes (say $hex) with \"$hex ($rev_name)\". When used with --name-only, substitute with \"$rev_name\", omitting $hex altogether. This option was called `--stdin` in older versions of Git."
msgstr "通过用 \"$hex ($rev_name)\" 替换所有 40 个字符的 SHA-1 六位数（比如 $hex）来转换标准输入。 当与 --name-only 一起使用时，用 \"$rev_name\" 替代，完全省略 $hex。这个选项在旧版本的 Git 中被称为 `--stdin`。"

#. type: delimited block -
#: en/git-name-rev.txt:56
#, no-wrap, priority:100
msgid "$ cat sample.txt\n"
msgstr "$ cat sample.txt\n"

#. type: delimited block -
#: en/git-name-rev.txt:60
#, no-wrap, priority:100
msgid ""
"An abbreviated revision 2ae0a9cb82 will not be substituted.\n"
"The full name after substitution is 2ae0a9cb8298185a94e5998086f380a355dd8907,\n"
"while its tree object is 70d105cc79e63b81cfdcb08a15297c23e60b07ad\n"
msgstr ""
"缩写版本 2ae0a9cb82 不会被替换。 \n"
"替换后的全名是 2ae0a9cb8298185a94e5998086f380a355dd8907，\n"
"而其目录树对象是 70d105cc79e63b81cfdcb08a15297c23e60b07ad\n"

#. type: delimited block -
#: en/git-name-rev.txt:62
#, no-wrap, placeholders:'git name-rev':'--annotate-stdin', priority:100
msgid "$ git name-rev --annotate-stdin <sample.txt\n"
msgstr "$ git name-rev --annotate-stdin <sample.txt\n"

#. type: delimited block -
#: en/git-name-rev.txt:66
#, no-wrap, priority:100
msgid ""
"An abbreviated revision 2ae0a9cb82 will not be substituted.\n"
"The full name after substitution is 2ae0a9cb8298185a94e5998086f380a355dd8907 (master),\n"
"while its tree object is 70d105cc79e63b81cfdcb08a15297c23e60b07ad\n"
msgstr ""
"缩写版本 2ae0a9cb82 不会被替换。 \n"
"替换后的全名是 2ae0a9cb8298185a94e5998086f380a355dd8907（master），\n"
"而其目录树对象是 70d105cc79e63b81cfdcb08a15297c23e60b07ad\n"

#. type: delimited block -
#: en/git-name-rev.txt:68
#, no-wrap, placeholders:'git name-rev':'--name-only':'--annotate-stdin', priority:100
msgid "$ git name-rev --name-only --annotate-stdin <sample.txt\n"
msgstr "$ git name-rev --name-only --annotate-stdin <sample.txt\n"

#. type: delimited block -
#: en/git-name-rev.txt:72
#, no-wrap, priority:100
msgid ""
"An abbreviated revision 2ae0a9cb82 will not be substituted.\n"
"The full name after substitution is master,\n"
"while its tree object is 70d105cc79e63b81cfdcb08a15297c23e60b07ad\n"
msgstr ""
"缩写版本 2ae0a9cb82 不会被替换。 \n"
"替换后的全名是 master，\n"
"而其目录树对象是 70d105cc79e63b81cfdcb08a15297c23e60b07ad\n"

# ERROR: --tags not found in translation
# ERROR: --tags not found in translation
#. type: Plain text
#: en/git-name-rev.txt:79
#, placeholders:'--tags':'git-describe', priority:100
msgid "Instead of printing both the SHA-1 and the name, print only the name. If given with --tags the usual tag prefix of \"tags/\" is also omitted from the name, matching the output of `git-describe` more closely."
msgstr "不要同时打印 SHA-1 和名字，而只打印名字。 如果给与 --tags 选项，通常的标签前缀 \"tags/\" 也会从名称中省略，与 `git-describe` 的输出更接近。"

#. type: Labeled list
#: en/git-name-rev.txt:80
#, ignore-same, no-wrap, priority:100
msgid "--no-undefined"
msgstr "--no-undefined"

#. type: Plain text
#: en/git-name-rev.txt:83
#, priority:100
msgid "Die with error code != 0 when a reference is undefined, instead of printing `undefined`."
msgstr "当一个引用未被定义时，以错误代码不为 0 的方式退出，而不是打印 `undefined`。"

#. type: Plain text
#: en/git-name-rev.txt:94
#, priority:100
msgid "Given a commit, find out where it is relative to the local refs. Say somebody wrote you about that fantastic commit 33db5f4d9027a10e477ccf054b2c1ab94f74c85a. Of course, you look into the commit, but that only tells you what happened, but not the context."
msgstr "给出一个提交，找出它在本地引用中的相对位置。假设有人给你写了关于 33db5f4d9027a10e477ccf054b2c1ab94f74c85a 的精彩提交。 当然，你会去查这个提交，但这只能告诉你发生了什么，但不能告诉你背景。"

#. type: Plain text
#: en/git-name-rev.txt:96
#, placeholders:'git name-rev', priority:100
msgid "Enter 'git name-rev':"
msgstr "输入 'git name-rev'："

#. type: delimited block -
#: en/git-name-rev.txt:100
#, no-wrap, placeholders:'git name-rev', priority:100
msgid ""
"% git name-rev 33db5f4d9027a10e477ccf054b2c1ab94f74c85a\n"
"33db5f4d9027a10e477ccf054b2c1ab94f74c85a tags/v0.99~940\n"
msgstr ""
"% git name-rev 33db5f4d9027a10e477ccf054b2c1ab94f74c85a\n"
"33db5f4d9027a10e477ccf054b2c1ab94f74c85a tags/v0.99~940\n"

#. type: Plain text
#: en/git-name-rev.txt:103
#, priority:100
msgid "Now you are wiser, because you know that it happened 940 revisions before v0.99."
msgstr "现在你更聪明了，因为你知道它发生在 v0.99 之前的 940 次修订。"

#. type: Plain text
#: en/git-name-rev.txt:105
#, priority:100
msgid "Another nice thing you can do is:"
msgstr "你可以做的另一件好事是："

#. type: delimited block -
#: en/git-name-rev.txt:108
#, no-wrap, placeholders:'git name-rev':'--annotate-stdin', priority:100
msgid "% git log | git name-rev --annotate-stdin\n"
msgstr "% git log | git name-rev --annotate-stdin\n"

#. type: Title =
#: en/git-notes.txt:2
#, ignore-same, no-wrap, priority:280
msgid "git-notes(1)"
msgstr "git-notes(1)"

#. type: Plain text
#: en/git-notes.txt:7
#, placeholders:'git-notes', priority:280
msgid "git-notes - Add or inspect object notes"
msgstr "git-notes - 添加或查看对象注释"

#. type: Plain text
#: en/git-notes.txt:23
#, ignore-ellipsis, no-wrap, placeholders:'[--allow-empty]':'--separator=':'--stdin':'[--allow-empty]':'--separator=':'[--allow-empty]':'--commit':'--abort':'[--ignore-missing]':'[--stdin]', priority:280
msgid ""
"'git notes' [list [<object>]]\n"
"'git notes' add [-f] [--allow-empty] [--[no-]separator | --separator=<paragraph-break>] [--[no-]stripspace] [-F <file> | -m <msg> | (-c | -C) <object>] [<object>]\n"
"'git notes' copy [-f] ( --stdin | <from-object> [<to-object>] )\n"
"'git notes' append [--allow-empty] [--[no-]separator | --separator=<paragraph-break>] [--[no-]stripspace] [-F <file> | -m <msg> | (-c | -C) <object>] [<object>]\n"
"'git notes' edit [--allow-empty] [<object>] [--[no-]stripspace]\n"
"'git notes' show [<object>]\n"
"'git notes' merge [-v | -q] [-s <strategy> ] <notes-ref>\n"
"'git notes' merge --commit [-v | -q]\n"
"'git notes' merge --abort [-v | -q]\n"
"'git notes' remove [--ignore-missing] [--stdin] [<object>...]\n"
"'git notes' prune [-n] [-v]\n"
"'git notes' get-ref\n"
msgstr ""
"'git notes' [list [<object>]]\n"
"'git notes' add [-f] [--allow-empty] [--[no-]separator | --separator=<paragraph-break>] [--[no-]stripspace] [-F <file> | -m <msg> | (-c | -C) <object>] [<object>]\n"
"'git notes' copy [-f] ( --stdin | <from-object> [<to-object>] )\n"
"'git notes' append [--allow-empty] [--[no-]separator | --separator=<paragraph-break>] [--[no-]stripspace] [-F <file> | -m <msg> | (-c | -C) <object>] [<object>]\n"
"'git notes' edit [--allow-empty] [<object>] [--[no-]stripspace]\n"
"'git notes' show [<object>]\n"
"'git notes' merge [-v | -q] [-s <strategy> ] <notes-ref>\n"
"'git notes' merge --commit [-v | -q]\n"
"'git notes' merge --abort [-v | -q]\n"
"'git notes' remove [--ignore-missing] [--stdin] [<object>...]\n"
"'git notes' prune [-n] [-v]\n"
"'git notes' get-ref\n"

#. type: Plain text
#: en/git-notes.txt:29
#, priority:280
msgid "Adds, removes, or reads notes attached to objects, without touching the objects themselves."
msgstr "添加、移除或读取附加在对象上的注释，而不影响对象本身。"

#. type: Plain text
#: en/git-notes.txt:34
#, priority:280
msgid "By default, notes are saved to and read from `refs/notes/commits`, but this default can be overridden. See the OPTIONS, CONFIGURATION, and ENVIRONMENT sections below. If this ref does not exist, it will be quietly created when it is first needed to store a note."
msgstr "默认情况下，注释被保存在 `refs/notes/commits` 中，并且可以覆盖此默认设置。请参阅下面的 OPTIONS、CONFIGURATION 和 ENVIRONMENT 部分。如果该引用不存在，当首次需要存储注释时，它将被静默地创建。"

#. type: Plain text
#: en/git-notes.txt:41
#, priority:280
msgid "A typical use of notes is to supplement a commit message without changing the commit itself. Notes can be shown by 'git log' along with the original commit message. To distinguish these notes from the message stored in the commit object, the notes are indented like the message, after an unindented line saying \"Notes (<refname>):\" (or \"Notes:\" for `refs/notes/commits`)."
msgstr "注释的一个典型用途是在不改变提交本身的情况下补充提交信息。注释可以通过 \"git log \"与原始提交信息一起显示。为了将这些注释与保存在提交对象中的消息区分开来，注释会像消息一样缩进，在未缩进的一行后面写上 \"注释（<参考名称>）：\"（或 \"注释：\"用于`参考/注释/提交`）。"

#. type: Plain text
#: en/git-notes.txt:45
#, placeholders:'git format-patch':'`--notes`', priority:280
msgid "Notes can also be added to patches prepared with `git format-patch` by using the `--notes` option. Such notes are added as a patch commentary after a three dash separator line."
msgstr "注释也可以通过使用`git format-patch`选项添加到补丁中，`--notes`。这样的注释会作为补丁注释添加在三个破折号的分隔线之后。"

# ERROR: <<CONFIGURATION>> not found in translation
#. type: Plain text
#: en/git-notes.txt:48
#, placeholders:'notes.displayRef':'<<CONFIGURATION>>', priority:280
msgid "To change which notes are shown by 'git log', see the \"notes.displayRef\" discussion in <<CONFIGURATION>>."
msgstr "要更改 'git log' 显示的注释，请参阅 <<CONFIGURATION>> 中的 \"notes.displayRef\" 讨论。"

#. type: Plain text
#: en/git-notes.txt:51
#, placeholders:'notes.rewrite', priority:280
msgid "See the \"notes.rewrite.<command>\" configuration for a way to carry notes across commands that rewrite commits."
msgstr "参见 \"notes.rewrite.<command>\"配置，以了解在重写提交的命令中携带笔记的方法。"

#. type: Title -
#: en/git-notes.txt:54
#, no-wrap, priority:280
msgid "SUBCOMMANDS"
msgstr "次级单位"

#. type: Labeled list
#: en/git-notes.txt:56 en/git-worktree.txt:109
#, ignore-same, no-wrap, priority:280
msgid "list"
msgstr "list"

#. type: Plain text
#: en/git-notes.txt:61
#, priority:280
msgid "List the notes object for a given object. If no object is given, show a list of all note objects and the objects they annotate (in the format \"<note-object> <annotated-object>\"). This is the default subcommand if no subcommand is given."
msgstr "列出给定对象的注释对象。如果没有给定对象，则显示所有注解对象及其注解的对象的列表（格式为\"<注解对象><注解对象>\"）。 如果没有给出子命令，这是默认的子命令。"

#. type: Labeled list
#: en/git-notes.txt:62
#, ignore-same, no-wrap, priority:280
msgid "add"
msgstr "add"

#. type: Plain text
#: en/git-notes.txt:71
#, placeholders:'HEAD':'`-f`':'`-m`':'`-F`':'`--separator`', priority:280
msgid "Add notes for a given object (defaults to HEAD). Abort if the object already has notes (use `-f` to overwrite existing notes). However, if you're using `add` interactively (using an editor to supply the notes contents), then - instead of aborting - the existing notes will be opened in the editor (like the `edit` subcommand). If you specify multiple `-m` and `-F`, a blank line will be inserted between the messages. Use the `--separator` option to insert other delimiters."
msgstr "为给定对象添加注释（默认为 HEAD）。如果对象已有注释，则终止添加（使用 `-f` 覆盖现有注释）。 但是，如果使用 `add` 交互式命令（使用编辑器提供注释内容），那么现有注释将在编辑器中打开（类似于 `edit` 子命令），而不是终止。如果指定多个 `-m` 和 `-F`，将在信息之间插入空行。使用 `--separator` 选项可以插入其他分隔符。"

#. type: Labeled list
#: en/git-notes.txt:72
#, ignore-same, no-wrap, priority:280
msgid "copy"
msgstr "copy"

#. type: Plain text
#: en/git-notes.txt:78
#, placeholders:'HEAD', priority:280
msgid "Copy the notes for the first object onto the second object (defaults to HEAD). Abort if the second object already has notes, or if the first object has none (use -f to overwrite existing notes to the second object). This subcommand is equivalent to: `git notes add [-f] -C $(git notes list <from-object>) <to-object>`"
msgstr "将第一个对象的注释复制到第二个对象上（默认为HEAD）。如果第二个对象已经有注解，或者第一个对象没有注解，则放弃（使用 -f 将现有注解覆盖到第二个对象）。这个子命令等同于。`git notes add [-f] -C $(git notes list <from-object>) <to-object>`"

#. type: Plain text
#: en/git-notes.txt:80
#, placeholders:'`--stdin`', priority:280
msgid "In `--stdin` mode, take lines in the format"
msgstr "在`--stdin`模式下，采取格式为"

#. type: delimited block -
#: en/git-notes.txt:83
#, no-wrap, priority:280
msgid "<from-object> SP <to-object> [ SP <rest> ] LF\n"
msgstr "<从对象> SP <到对象 [ SP <停止> ] LF\n"

#. type: Plain text
#: en/git-notes.txt:88
#, priority:280
msgid "on standard input, and copy the notes from each <from-object> to its corresponding <to-object>. (The optional `<rest>` is ignored so that the command can read the input given to the `post-rewrite` hook.)"
msgstr "在标准输入中，将每个 <from-object> 中的注释复制到相应的 <to-object> 中。（可选的 `<rest>` 被忽略，以便命令可以读取给 `post-rewrite` 钩的输入）"

#. type: Labeled list
#: en/git-notes.txt:89
#, ignore-same, no-wrap, priority:280
msgid "append"
msgstr "append"

#. type: Plain text
#: en/git-notes.txt:96
#, placeholders:'`-m`':'`-F`':'HEAD':'`--separator`', priority:280
msgid "Append new message(s) given by `-m` or `-F` options to an existing note, or add them as a new note if one does not exist, for the object (defaults to HEAD). When appending to an existing note, a blank line is added before each new message as an inter-paragraph separator. The separator can be customized with the `--separator` option."
msgstr "将 `-m` 或 `-F` 选项指定的新信息附加到现有注释中，或将不存在的信息作为新注释添加到对象中（默认为 HEAD）。 当添加到现有注释时，每条新信息前都会添加一个空行作为段间分隔符。 分隔符可使用 `--separator` 选项自定义。"

#. type: Labeled list
#: en/git-notes.txt:97
#, ignore-same, no-wrap, priority:280
msgid "edit"
msgstr "edit"

#. type: Plain text
#: en/git-notes.txt:99
#, placeholders:'HEAD', priority:280
msgid "Edit the notes for a given object (defaults to HEAD)."
msgstr "编辑一个给定对象的注释（默认为HEAD）。"

#. type: Labeled list
#: en/git-notes.txt:100
#, ignore-same, no-wrap, priority:280
msgid "show"
msgstr "show"

#. type: Plain text
#: en/git-notes.txt:102
#, placeholders:'HEAD', priority:280
msgid "Show the notes for a given object (defaults to HEAD)."
msgstr "显示一个给定对象的注释（默认为HEAD）。"

#. type: Labeled list
#: en/git-notes.txt:103 en/git-submodule.txt:165
#, ignore-same, no-wrap, priority:280
msgid "merge"
msgstr "merge"

#. type: Plain text
#: en/git-notes.txt:108
#, priority:280
msgid "Merge the given notes ref into the current notes ref. This will try to merge the changes made by the given notes ref (called \"remote\") since the merge-base (if any) into the current notes ref (called \"local\")."
msgstr "将给定的注释参考文献合并到当前的注释参考文献中。 这将尝试把给定的注释（称为 \"远程\"）自合并基础（如果有的话）以来所做的修改合并到当前的注释（称为 \"本地\"）。"

#. type: Plain text
#: en/git-notes.txt:117
#, placeholders:'.git/NOTES_MERGE_WORKTREE':'--commit':'--abort', priority:280
msgid "If conflicts arise and a strategy for automatically resolving conflicting notes (see the \"NOTES MERGE STRATEGIES\" section) is not given, the \"manual\" resolver is used. This resolver checks out the conflicting notes in a special worktree (`.git/NOTES_MERGE_WORKTREE`), and instructs the user to manually resolve the conflicts there. When done, the user can either finalize the merge with 'git notes merge --commit', or abort the merge with 'git notes merge --abort'."
msgstr "如果出现冲突，并且没有给出自动解决冲突笔记的策略（见 \"NOTES MERGE STRATEGIES \"一节），就会使用 \"手动 \"解决器。这个解决方法在一个特殊的工作树（`.git/NOTES_MERGE_WORKTREE`）中检查出冲突的笔记，并指示用户手动解决那里的冲突。 完成后，用户可以用 \"git notes merge --commit \"最终完成合并，或者用 \"git notes merge --abort \"中止合并。"

#. type: Labeled list
#: en/git-notes.txt:118 en/git-worktree.txt:136
#, ignore-same, no-wrap, priority:280
msgid "remove"
msgstr "remove"

#. type: Plain text
#: en/git-notes.txt:123
#, placeholders:'HEAD', priority:280
msgid "Remove the notes for given objects (defaults to HEAD). When giving zero or one object from the command line, this is equivalent to specifying an empty note message to the `edit` subcommand."
msgstr "删除给定对象的注释（默认为HEAD）。当从命令行给出零或一个对象时，这相当于给`edit`子命令指定一个空的注释信息。"

#. type: Labeled list
#: en/git-notes.txt:124 en/git-worktree.txt:132
#, ignore-same, no-wrap, priority:280
msgid "prune"
msgstr "prune"

#. type: Plain text
#: en/git-notes.txt:126
#, priority:280
msgid "Remove all notes for non-existing/unreachable objects."
msgstr "删除所有不存在/无法到达的对象的注释。"

#. type: Labeled list
#: en/git-notes.txt:127
#, ignore-same, no-wrap, priority:280
msgid "get-ref"
msgstr "get-ref"

#. type: Plain text
#: en/git-notes.txt:130
#, priority:280
msgid "Print the current notes ref. This provides an easy way to retrieve the current notes ref (e.g. from scripts)."
msgstr "打印当前的注释参考。这提供了一个简单的方法来检索当前的笔记参考文献（例如从脚本中）。"

#. type: Plain text
#: en/git-notes.txt:137
#, priority:280
msgid "When adding notes to an object that already has notes, overwrite the existing notes (instead of aborting)."
msgstr "当向一个已经有注释的对象添加注释时，覆盖现有的注释（而不是中止）。"

#. type: Plain text
#: en/git-notes.txt:146
#, placeholders:'`-m`':'`--no-stripspace`', priority:280
msgid "Use the given note message (instead of prompting). If multiple `-m` options are given, their values are concatenated as separate paragraphs. Lines starting with `#` and empty lines other than a single line between paragraphs will be stripped out. If you wish to keep them verbatim, use `--no-stripspace`."
msgstr "使用给定的注释信息（而不是提示）。 如果给定了多个`-m`选项，它们的值将作为单独的段落串联起来。 以`#`开头的行和段落之间的单行以外的空行将被剥离出来。 如果希望逐字保留，请使用 `--no-stripspace` 选项。"

#. type: Plain text
#: en/git-notes.txt:154
#, placeholders:'`--no-stripspace`', priority:280
msgid "Take the note message from the given file. Use '-' to read the note message from the standard input. Lines starting with `#` and empty lines other than a single line between paragraphs will be stripped out. If you wish to keep them verbatim, use `--no-stripspace`."
msgstr "从给定的文件中获取注释信息。 使用 '-' 可以从标准输入中读取注释信息。 以 `#` 开头的行和段落之间的单行以外的空行将被剥离出来。如果希望逐字保留，请使用 `--no-stripspace` 选项。"

#. type: Labeled list
#: en/git-notes.txt:155
#, no-wrap, priority:280
msgid "-C <object>"
msgstr "-C <对象>"

#. type: Labeled list
#: en/git-notes.txt:156
#, no-wrap, placeholders:'--reuse-message=', priority:280
msgid "--reuse-message=<object>"
msgstr "--reuse-message=<对象>"

#. type: Plain text
#: en/git-notes.txt:163
#, placeholders:'`--stripspace`', priority:280
msgid "Take the given blob object (for example, another note) as the note message. (Use `git notes copy <object>` instead to copy notes between objects.). By default, message will be copied verbatim, but if you wish to strip out the lines starting with `#` and empty lines other than a single line between paragraphs, use with`--stripspace` option."
msgstr "将给定的 blob 对象（例如另一个笔记）作为笔记信息。(使用 `git notes copy <对象>` 可以在对象之间复制注释）。 默认情况下，信息将被逐字复制，但如果希望删除以 `#` 开头的行和段落之间单行以外的空行，请使用 `--stripspace` 选项。"

#. type: Labeled list
#: en/git-notes.txt:164
#, no-wrap, priority:280
msgid "-c <object>"
msgstr "-c <对象>"

#. type: Labeled list
#: en/git-notes.txt:165
#, no-wrap, placeholders:'--reedit-message=', priority:280
msgid "--reedit-message=<object>"
msgstr "--reedit-message=<对象>"

# ERROR: `-c` not found in translation
#. type: Plain text
#: en/git-notes.txt:168
#, placeholders:'`-c`', priority:280
msgid "Like '-C', but with `-c` the editor is invoked, so that the user can further edit the note message."
msgstr "像 '-C' 一样，但有了 `-c` 就会调用编辑器，这样用户就可以进一步编辑注释信息。"

#. type: Plain text
#: en/git-notes.txt:172
#, priority:280
msgid "Allow an empty note object to be stored. The default behavior is to automatically remove empty notes."
msgstr "允许存储一个空的笔记对象。默认行为是自动删除空笔记。"

#. type: Labeled list
#: en/git-notes.txt:173
#, no-wrap, placeholders:'--separator=', priority:280
msgid "--[no-]separator, --separator=<paragraph-break>"
msgstr "--[no-]separator, --separator=<段落分隔符>"

#. type: Plain text
#: en/git-notes.txt:178
#, placeholders:'`--no-separator`', priority:280
msgid "Specify a string used as a custom inter-paragraph separator (a newline is added at the end as needed). If `--no-separator`, no separators will be added between paragraphs. Defaults to a blank line."
msgstr "指定用于自定义段落间分隔符的字符串（根据需要在末尾添加换行符）。如果使用 `--no-separator`，则段落之间不添加分隔符。 默认为空行。"

#. type: Labeled list
#: en/git-notes.txt:179
#, ignore-same, no-wrap, priority:280
msgid "--[no-]stripspace"
msgstr "--[no-]stripspace"

#. type: Plain text
#: en/git-notes.txt:185
#, placeholders:'`-m`':'`-F`':'`-C`':'`-c`', priority:280
msgid "Strip leading and trailing whitespace from the note message. Also strip out empty lines other than a single line between paragraphs. Lines starting with `#` will be stripped out in non-editor cases like `-m`, `-F` and `-C`, but not in editor case like `git notes edit`, `-c`, etc."
msgstr "从备注信息中删除前导和尾部空白。 还会删除段落之间单行以外的空行。以 `#` 开头的行在非编辑器情况下（如 `-m` 、`-F` 和 `-C`）会被删除，但在编辑器情况下（如 `git notes edit`、`-c` 等）不会。"

#. type: Labeled list
#: en/git-notes.txt:186
#, no-wrap, placeholders:'--ref', priority:280
msgid "--ref <ref>"
msgstr "--ref <引用>"

#. type: Plain text
#: en/git-notes.txt:192
#, placeholders:'GIT_NOTES_REF':'core.notesRef', priority:280
msgid "Manipulate the notes tree in <ref>. This overrides `GIT_NOTES_REF` and the \"core.notesRef\" configuration. The ref specifies the full refname when it begins with `refs/notes/`; when it begins with `notes/`, `refs/` and otherwise `refs/notes/` is prefixed to form a full name of the ref."
msgstr "操纵<ref>中的笔记树。 这覆盖了`GIT_NOTES_REF`和 \"core.notesRef \"配置。 当Ref以`refs/notes/`开始时，指定完整的Ref名称；当它以`notes/`开始时，`refs/`，否则`refs/notes/`前缀，形成Ref的全名。"

#. type: Plain text
#: en/git-notes.txt:196
#, priority:280
msgid "Do not consider it an error to request removing notes from an object that does not have notes attached to it."
msgstr "不要认为请求从一个没有附加注释的对象上删除注释是一个错误。"

#. type: Plain text
#: en/git-notes.txt:201
#, priority:280
msgid "Also read the object names to remove notes from the standard input (there is no reason you cannot combine this with object names from the command line)."
msgstr "还可以从标准输入中读取对象名称来删除注释（你没有理由不把它与命令行的对象名称结合起来）。"

#. type: Plain text
#: en/git-notes.txt:206
#, priority:280
msgid "Do not remove anything; just report the object names whose notes would be removed."
msgstr "不要删除任何东西；只是报告其注释将被删除的对象名称。"

#. type: Labeled list
#: en/git-notes.txt:207 en/git-rebase.txt:375 en/merge-options.txt:143
#, no-wrap, priority:280
msgid "-s <strategy>"
msgstr "-s <策略>"

#. type: Plain text
#: en/git-notes.txt:215
#, placeholders:'cat_sort_uniq':'notes.mergeStrategy', priority:280
msgid "When merging notes, resolve notes conflicts using the given strategy. The following strategies are recognized: \"manual\" (default), \"ours\", \"theirs\", \"union\" and \"cat_sort_uniq\". This option overrides the \"notes.mergeStrategy\" configuration setting. See the \"NOTES MERGE STRATEGIES\" section below for more information on each notes merge strategy."
msgstr "合并笔记时，使用给定的策略解决笔记冲突。以下策略是被认可的。\"手动\"（默认）、\"我们的\"、\"他们的\"、\"联合 \"和 \"cat_sort_uniq\"。 这个选项覆盖了 \"notes.mergeStrategy \"的配置设置。 关于每种笔记合并策略的更多信息，请看下面的 \"笔记合并策略 \"部分。"

#. type: Labeled list
#: en/git-notes.txt:216 en/merge-options.txt:1
#, ignore-same, no-wrap, priority:280
msgid "--commit"
msgstr "--commit"

#. type: Plain text
#: en/git-notes.txt:224
#, placeholders:'.git/NOTES_MERGE_WORKTREE':'.git/NOTES_MERGE_PARTIAL':'.git/NOTES_MERGE_WORKTREE':'.git/NOTES_MERGE_REF', priority:280
msgid "Finalize an in-progress 'git notes merge'. Use this option when you have resolved the conflicts that 'git notes merge' stored in .git/NOTES_MERGE_WORKTREE. This amends the partial merge commit created by 'git notes merge' (stored in .git/NOTES_MERGE_PARTIAL) by adding the notes in .git/NOTES_MERGE_WORKTREE. The notes ref stored in the .git/NOTES_MERGE_REF symref is updated to the resulting commit."
msgstr "最终确定一个正在进行的'git notes merge'。当您解决了'git notes merge'存储在.git/NOTES_MERGE_WORKTREE中的冲突后，使用此选项。这将修正由'git notes merge'创建的部分合并提交（存储在.git/NOTES_MERGE_PARTIAL中），加入.git/NOTES_MERGE_WORKTREE中的注释。存储在 .git/NOTES_MERGE_REF 符号参考中的注释会被更新到结果提交中。"

#. type: Plain text
#: en/git-notes.txt:229
#, priority:280
msgid "Abort/reset an in-progress 'git notes merge', i.e. a notes merge with conflicts. This simply removes all files related to the notes merge."
msgstr "中止/重置正在进行的 \"git笔记合并\"，即有冲突的笔记合并。这只是删除了所有与笔记合并有关的文件。"

#. type: Plain text
#: en/git-notes.txt:233
#, priority:280
msgid "When merging notes, operate quietly."
msgstr "合并笔记时，要安静地操作。"

#. type: Plain text
#: en/git-notes.txt:239
#, priority:280
msgid "When merging notes, be more verbose. When pruning notes, report all object names whose notes are removed."
msgstr "当合并笔记时，要更加详细。 当修剪注释时，报告所有被删除注释的对象名称。"

#. type: Plain text
#: en/git-notes.txt:253
#, ignore-ellipsis, priority:280
msgid "Commit notes are blobs containing extra information about an object (usually information to supplement a commit's message). These blobs are taken from notes refs. A notes ref is usually a branch which contains \"files\" whose paths are the object names for the objects they describe, with some directory separators included for performance reasons footnote:[Permitted pathnames have the form 'bf'`/`'fe'`/`'30'`/`'...'`/`'680d5a...': a sequence of directory names of two hexadecimal digits each followed by a filename with the rest of the object ID.]."
msgstr "提交注释是包含关于一个对象的额外信息（通常是补充提交信息的信息）的 blobs。 这些 blobs 取自注释参考。 一个注释参考通常是一个包含 “文件” 的分支，这些文件的路径是它们所描述的对象的名称，出于性能的考虑，还包括一些目录分隔符 footnote:[允许的路径名有 'bf'`/`'fe'`/`'30'`/`'...`/`'680d5a...' 的形式：一串由两个十六进制数字组成的目录名，后面是一个带有其余对象ID的文件名。]。"

#. type: Plain text
#: en/git-notes.txt:260
#, placeholders:'linkgit:git-commit[1]', priority:280
msgid "Every notes change creates a new commit at the specified notes ref. You can therefore inspect the history of the notes by invoking, e.g., `git log -p notes/commits`. Currently the commit message only records which operation triggered the update, and the commit authorship is determined according to the usual rules (see linkgit:git-commit[1]). These details may change in the future."
msgstr "每一个笔记的变化都会在指定的笔记参考号上创建一个新的提交。 因此，你可以通过调用，例如，`git log -p notes/commits`，来检查笔记的历史。 目前，提交信息只记录了哪个操作触发了更新，而提交者的身份则根据通常的规则确定（见 linkgit:git-commit[1]）。 这些细节在未来可能会发生变化。"

#. type: Plain text
#: en/git-notes.txt:264
#, priority:280
msgid "It is also permitted for a notes ref to point directly to a tree object, in which case the history of the notes can be read with `git log -p -g <refname>`."
msgstr "也允许注释直接指向树状对象，在这种情况下，可以用`git log -p -g <refname>`读取注释的历史。"

#. type: Title -
#: en/git-notes.txt:267
#, no-wrap, priority:280
msgid "NOTES MERGE STRATEGIES"
msgstr "注释 合并策略"

#. type: Plain text
#: en/git-notes.txt:276
#, placeholders:'.git/NOTES_MERGE_WORKTREE':'--commit':'--abort', priority:280
msgid "The default notes merge strategy is \"manual\", which checks out conflicting notes in a special work tree for resolving notes conflicts (`.git/NOTES_MERGE_WORKTREE`), and instructs the user to resolve the conflicts in that work tree. When done, the user can either finalize the merge with 'git notes merge --commit', or abort the merge with 'git notes merge --abort'."
msgstr "默认的笔记合并策略是 \"手动\"，它在一个用于解决笔记冲突的特殊工作树（`.git/NOTES_MERGE_WORKTREE`）中检查出冲突的笔记，并指示用户在该工作树中解决冲突。 完成后，用户可以用 \"git notes merge --commit \"最终完成合并，或者用 \"git notes merge --abort \"中止合并。"

#. type: Plain text
#: en/git-notes.txt:279
#, placeholders:'--strategy':'notes.mergeStrategy', priority:280
msgid "Users may select an automated merge strategy from among the following using either -s/--strategy option or configuring notes.mergeStrategy accordingly:"
msgstr "用户可以使用 -s/--strategy 选项或相应地配置 notes.mergeStrategy，从以下内容中选择一个自动合并策略："

#. type: Plain text
#: en/git-notes.txt:282
#, priority:280
msgid "\"ours\" automatically resolves conflicting notes in favor of the local version (i.e. the current notes ref)."
msgstr "\"我们的 \"自动解决冲突的注释，支持本地版本（即当前的注释参考）。"

#. type: Plain text
#: en/git-notes.txt:286
#, priority:280
msgid "\"theirs\" automatically resolves notes conflicts in favor of the remote version (i.e. the given notes ref being merged into the current notes ref)."
msgstr "\"他们的 \"自动解决笔记冲突，有利于远程版本（即给定的笔记参考文献被合并到当前的笔记参考文献中）。"

#. type: Plain text
#: en/git-notes.txt:289
#, priority:280
msgid "\"union\" automatically resolves notes conflicts by concatenating the local and remote versions."
msgstr "\"union \"通过串联本地和远程版本自动解决注释冲突。"

#. type: Plain text
#: en/git-notes.txt:299
#, placeholders:'cat_sort_uniq', priority:280
msgid "\"cat_sort_uniq\" is similar to \"union\", but in addition to concatenating the local and remote versions, this strategy also sorts the resulting lines, and removes duplicate lines from the result. This is equivalent to applying the \"cat | sort | uniq\" shell pipeline to the local and remote versions. This strategy is useful if the notes follow a line-based format where one wants to avoid duplicated lines in the merge result. Note that if either the local or remote version contain duplicate lines prior to the merge, these will also be removed by this notes merge strategy."
msgstr "\"cat_sort_uniq \"与 \"union \"类似，但除了连接本地和远程版本之外，这个策略还对结果行进行排序，并从结果中删除重复的行。这相当于对本地和远程版本应用 \"cat | sort | uniq \"shell流水线。如果笔记是基于行的格式，希望在合并结果中避免重复的行，那么这个策略就很有用。 请注意，如果本地或远程版本在合并前包含重复的行，这些行也会被这个笔记合并策略所删除。"

#. type: Plain text
#: en/git-notes.txt:306
#, priority:280
msgid "You can use notes to add annotations with information that was not available at the time a commit was written."
msgstr "你可以使用注释来添加提交时无法获得的信息的注释。"

#. type: delimited block -
#: en/git-notes.txt:312
#, ignore-ellipsis, no-wrap, placeholders:'kdbg.org':'pobox.com', priority:280
msgid ""
"$ git notes add -m 'Tested-by: Johannes Sixt <j6t@kdbg.org>' 72a144e2\n"
"$ git show -s 72a144e\n"
"[...]\n"
"    Signed-off-by: Junio C Hamano <gitster@pobox.com>\n"
msgstr ""
"$ git notes add -m 'Tested-by: Johannes Sixt <j6t@kdbg.org>' 72a144e2\n"
"$ git show -s 72a144e\n"
"[...]\n"
"    Signed-off-by: Junio C Hamano <gitster@pobox.com>\n"

#. type: delimited block -
#: en/git-notes.txt:315
#, no-wrap, placeholders:'kdbg.org', priority:280
msgid ""
"Notes:\n"
"    Tested-by: Johannes Sixt <j6t@kdbg.org>\n"
msgstr ""
"注意事项。\n"
"    测试者： Johannes Sixt <j6t@kdbg.org>\n"

#. type: Plain text
#: en/git-notes.txt:320
#, placeholders:'git hash-object', priority:280
msgid "In principle, a note is a regular Git blob, and any kind of (non-)format is accepted. You can binary-safely create notes from arbitrary files using 'git hash-object':"
msgstr "原则上，笔记是一个普通的 Git blob，任何种类的（非）格式都可以接受。 你可以使用 'git hash-object' 从任意文件中二进制安全地创建注释："

#. type: delimited block -
#: en/git-notes.txt:325
#, no-wrap, placeholders:'git hash-object':'a.out':'--ref=built':'--allow-empty':'$blob':'HEAD', priority:280
msgid ""
"$ cc *.c\n"
"$ blob=$(git hash-object -w a.out)\n"
"$ git notes --ref=built add --allow-empty -C \"$blob\" HEAD\n"
msgstr ""
"$ cc *.c\n"
"$ blob=$(git hash-object -w a.out)\n"
"$ git notes --ref=built add --allow-empty -C \"$blob\" HEAD\n"

#. type: Plain text
#: en/git-notes.txt:332
#, placeholders:'--ref=built':'a.out':'HEAD', priority:280
msgid "(You cannot simply use `git notes --ref=built add -F a.out HEAD` because that is not binary-safe.) Of course, it doesn't make much sense to display non-text-format notes with 'git log', so if you use such notes, you'll probably need to write some special-purpose tools to do something useful with them."
msgstr "(你不能简单地使用`git notes --ref=built add -F a.out HEAD`，因为这不是二进制安全的。) 当然，用'git log'来显示非文本格式的笔记没有什么意义，所以如果你使用这样的笔记，你可能需要写一些特殊用途的工具来对它们做一些有用的事情。"

#. type: Labeled list
#: en/git-notes.txt:338
#, ignore-same, no-wrap, priority:280
msgid "core.notesRef"
msgstr "core.notesRef"

#. type: Plain text
#: en/git-notes.txt:343
#, priority:280
msgid "Notes ref to read and manipulate instead of `refs/notes/commits`. Must be an unabbreviated ref name. This setting can be overridden through the environment and command line."
msgstr "读取和操作的注释，而不是`refs/notes/commits`。 必须是一个不简略的参考文献名称。 这个设置可以通过环境和命令行来覆盖。"

#. type: Labeled list
#: en/git-notes.txt:352
#, ignore-same, no-wrap, priority:280
msgid "`GIT_NOTES_REF`"
msgstr "`GIT_NOTES_REF`"

#. type: Plain text
#: en/git-notes.txt:355
#, placeholders:'core.notesRef', priority:280
msgid "Which ref to manipulate notes from, instead of `refs/notes/commits`. This overrides the `core.notesRef` setting."
msgstr "从哪个参考文献来操作笔记，而不是`refs/notes/commits`。 这覆盖了`core.notesRef'的设置。"

#. type: Labeled list
#: en/git-notes.txt:356
#, ignore-same, no-wrap, priority:280
msgid "`GIT_NOTES_DISPLAY_REF`"
msgstr "`GIT_NOTES_DISPLAY_REF`"

#. type: Plain text
#: en/git-notes.txt:362
#, placeholders:'core.notesRef':'GIT_NOTES_REF':'notes.displayRef', priority:280
msgid "Colon-delimited list of refs or globs indicating which refs, in addition to the default from `core.notesRef` or `GIT_NOTES_REF`, to read notes from when showing commit messages. This overrides the `notes.displayRef` setting."
msgstr "以冒号为界的参考文献或globs列表，表示除了默认的`core.notesRef`或`GIT_NOTES_REF`之外，在显示提交信息时要从哪些参考文献读取。 这取代了`notes.displayRef`的设置。"

#. type: Plain text
#: en/git-notes.txt:365
#, priority:280
msgid "A warning will be issued for refs that do not exist, but a glob that does not match any refs is silently ignored."
msgstr "对于不存在的 refs 将会发出警告，但是不匹配任何 refs 的 glob 会被默默地忽略。"

#. type: Labeled list
#: en/git-notes.txt:366
#, ignore-same, no-wrap, priority:280
msgid "`GIT_NOTES_REWRITE_MODE`"
msgstr "`GIT_NOTES_REWRITE_MODE`"

#. type: Plain text
#: en/git-notes.txt:371
#, placeholders:'cat_sort_uniq':'core.rewriteMode', priority:280
msgid "When copying notes during a rewrite, what to do if the target commit already has a note. Must be one of `overwrite`, `concatenate`, `cat_sort_uniq`, or `ignore`. This overrides the `core.rewriteMode` setting."
msgstr "在重写过程中复制注释时，如果目标提交已经有一个注释，该如何处理。 必须是`overwrite`, `concatenate`, `cat_sort_uniq`, 或 `ignore`之一。 这覆盖了`core.rewriteMode`的设置。"

#. type: Labeled list
#: en/git-notes.txt:372
#, ignore-same, no-wrap, priority:280
msgid "`GIT_NOTES_REWRITE_REF`"
msgstr "`GIT_NOTES_REWRITE_REF`"

#. type: Plain text
#: en/git-notes.txt:376
#, priority:280
msgid "When rewriting commits, which notes to copy from the original to the rewritten commit. Must be a colon-delimited list of refs or globs."
msgstr "当重写提交时，要从原始提交中复制哪些注释到重写的提交中。 必须是一个以冒号分隔的 refs 或 globs 列表。"

#. type: Plain text
#: en/git-notes.txt:379
#, placeholders:'notes.rewrite':'notes.rewriteRef', priority:280
msgid "If not set in the environment, the list of notes to copy depends on the `notes.rewrite.<command>` and `notes.rewriteRef` settings."
msgstr "如果环境中没有设置，要复制的笔记列表取决于`notes.rewrite.<command>`和`notes.rewriteRef`设置。"

#. type: Title =
#: en/git-p4.txt:2
#, ignore-same, no-wrap, priority:90
msgid "git-p4(1)"
msgstr "git-p4(1)"

#. type: Plain text
#: en/git-p4.txt:7
#, placeholders:'git-p', priority:90
msgid "git-p4 - Import from and submit to Perforce repositories"
msgstr "git-p4 - 从 Perforce 仓库导入和提交"

#. type: Plain text
#: en/git-p4.txt:16
#, ignore-ellipsis, no-wrap, priority:90
msgid ""
"'git p4 clone' [<sync-options>] [<clone-options>] <p4-depot-path>...\n"
"'git p4 sync' [<sync-options>] [<p4-depot-path>...]\n"
"'git p4 rebase'\n"
"'git p4 submit' [<submit-options>] [<master-branch-name>]\n"
msgstr ""
"'git p4 clone' [<同步选项>] [<克隆选项>] <p4 depot path>...\n"
"'git p4 sync' [<同步选项>] [<p4 depot path>...]\n"
"'git p4 rebase'\n"
"'git p4 submit' [<提交选项>] [<主分支名>]\n"

#. type: Plain text
#: en/git-p4.txt:22
#, priority:90
msgid "This command provides a way to interact with p4 repositories using Git."
msgstr "该命令提供了一种使用 Git 与 p4 仓库交互的方法。"

#. type: Plain text
#: en/git-p4.txt:30
#, priority:90
msgid "Create a new Git repository from an existing p4 repository using 'git p4 clone', giving it one or more p4 depot paths. Incorporate new commits from p4 changes with 'git p4 sync'. The 'sync' command is also used to include new branches from other p4 depot paths. Submit Git changes back to p4 using 'git p4 submit'. The command 'git p4 rebase' does a sync plus rebases the current branch onto the updated p4 remote branch."
msgstr "使用 'git p4 clone' 从现有的 p4 仓库创建一个新的 Git 仓库，并赋予它一个或多个 p4 仓库路径。 使用 'git p4 sync' 从 p4 变更中纳入新提交。 'sync' 命令也可用于纳入来自其他 p4 仓库路径的新分支。 使用 'git p4 submit' 将 Git 变动提交回 p4。 'git p4 rebase' 命令在同步的基础上，将当前分支重定向到更新后的 p4 远程分支上。"

#. type: Plain text
#: en/git-p4.txt:35
#, priority:90
msgid "Clone a repository:"
msgstr "克隆仓库："

#. type: delimited block -
#: en/git-p4.txt:38 en/git-p4.txt:71
#, no-wrap, priority:90
msgid "$ git p4 clone //depot/path/project\n"
msgstr "$ git p4 clone //depot/path/project\n"

#. type: Plain text
#: en/git-p4.txt:41
#, priority:90
msgid "Do some work in the newly created Git repository:"
msgstr "在新创建的 Git 仓库中做一些工作："

#. type: delimited block -
#: en/git-p4.txt:46
#, no-wrap, priority:90
msgid ""
"$ cd project\n"
"$ vi foo.h\n"
"$ git commit -a -m \"edited foo.h\"\n"
msgstr ""
"$ cd project\n"
"$ vi foo.h\n"
"$ git commit -a -m \"edited foo.h\"\n"

#. type: Plain text
#: en/git-p4.txt:50
#, priority:90
msgid "Update the Git repository with recent changes from p4, rebasing your work on top:"
msgstr "用 p4 的最新改动更新 Git 仓库，并将你的工作重新加载到上面："

#. type: delimited block -
#: en/git-p4.txt:53 en/git-p4.txt:130
#, no-wrap, priority:90
msgid "$ git p4 rebase\n"
msgstr "$ git p4 rebase\n"

#. type: Plain text
#: en/git-p4.txt:56
#, priority:90
msgid "Submit your commits back to p4:"
msgstr "将您的提交提交回 p4："

#. type: delimited block -
#: en/git-p4.txt:59 en/git-p4.txt:145
#, no-wrap, priority:90
msgid "$ git p4 submit\n"
msgstr "$ git p4 submit\n"

#. type: Title ~
#: en/git-p4.txt:66
#, no-wrap, priority:90
msgid "Clone"
msgstr "克隆"

#. type: Plain text
#: en/git-p4.txt:69
#, priority:90
msgid "Generally, 'git p4 clone' is used to create a new Git directory from an existing p4 repository:"
msgstr "一般来说，'git p4 clone' 用于从现有的 p4 仓库创建一个新的 Git 目录："

#. type: Plain text
#: en/git-p4.txt:73
#, priority:90
msgid "This:"
msgstr "就像这样："

#. type: Plain text
#: en/git-p4.txt:75
#, priority:90
msgid "Creates an empty Git repository in a subdirectory called 'project'."
msgstr "在名为 'project' 的子目录下创建一个空的 Git 仓库。"

#. type: Plain text
#: en/git-p4.txt:78
#, priority:90
msgid "Imports the full contents of the head revision from the given p4 depot path into a single commit in the Git branch 'refs/remotes/p4/master'."
msgstr "从给定的 p4 仓库路径导入头修订版的全部内容到 Git 分支 'refs/remotes/p4/master' 中的一次提交。"

#. type: Plain text
#: en/git-p4.txt:80
#, priority:90
msgid "Creates a local branch, 'master' from this remote and checks it out."
msgstr "从远程分支创建本地分支 'master'，并对其进行检查。"

#. type: Plain text
#: en/git-p4.txt:83
#, priority:90
msgid "To reproduce the entire p4 history in Git, use the '@all' modifier on the depot path:"
msgstr "要在 Git 中重现整个 p4 历史，请在仓库路径上使用 '@all' 修饰符："

#. type: delimited block -
#: en/git-p4.txt:85
#, no-wrap, priority:90
msgid "$ git p4 clone //depot/path/project@all\n"
msgstr "$ git p4 clone //depot/path/project@all\n"

#. type: Title ~
#: en/git-p4.txt:89
#, no-wrap, priority:90
msgid "Sync"
msgstr "同步"

#. type: Plain text
#: en/git-p4.txt:92
#, priority:90
msgid "As development continues in the p4 repository, those changes can be included in the Git repository using:"
msgstr "随着 p4 仓库开发的继续，这些变更也会被纳入 Git 仓库："

#. type: delimited block -
#: en/git-p4.txt:94
#, no-wrap, priority:90
msgid "$ git p4 sync\n"
msgstr "$ git p4 sync\n"

#. type: Plain text
#: en/git-p4.txt:96
#, priority:90
msgid "This command finds new changes in p4 and imports them as Git commits."
msgstr "该命令在 p4 中查找新的改动，并将其导入 Git 提交。"

#. type: Plain text
#: en/git-p4.txt:99
#, priority:90
msgid "P4 repositories can be added to an existing Git repository using 'git p4 sync' too:"
msgstr "也可以使用 'git p4 sync' 将 P4 仓库添加到现有的 Git 仓库中："

#. type: delimited block -
#: en/git-p4.txt:104
#, no-wrap, priority:90
msgid ""
"$ mkdir repo-git\n"
"$ cd repo-git\n"
"$ git init\n"
"$ git p4 sync //path/in/your/perforce/depot\n"
msgstr ""
"$ mkdir repo-git\n"
"$ cd repo-git\n"
"$ git init\n"
"$ git p4 sync //path/in/your/perforce/depot\n"

#. type: Plain text
#: en/git-p4.txt:109
#, placeholders:'`--branch`', priority:90
msgid "This imports the specified depot into 'refs/remotes/p4/master' in an existing Git repository. The `--branch` option can be used to specify a different branch to be used for the p4 content."
msgstr "将指定的仓库导入现有 Git 仓库中的 'refs/remotes/p4/master'。 可以使用 `--branch` 选项为 p4 内容指定不同的分支。"

#. type: Plain text
#: en/git-p4.txt:114
#, priority:90
msgid "If a Git repository includes branches 'refs/remotes/origin/p4', these will be fetched and consulted first during a 'git p4 sync'. Since importing directly from p4 is considerably slower than pulling changes from a Git remote, this can be useful in a multi-developer environment."
msgstr "如果 Git 仓库包含分支 'refs/remotes/origin/p4'，那么在 'git p4 sync' 过程中，这些分支将首先被获取和查阅。 由于直接从 p4 导入要比从 Git 远端拉取更改慢得多，这在多开发人员环境中非常有用。"

#. type: Plain text
#: en/git-p4.txt:119
#, placeholders:'`--branch`', priority:90
msgid "If there are multiple branches, doing 'git p4 sync' will automatically use the \"BRANCH DETECTION\" algorithm to try to partition new changes into the right branch. This can be overridden with the `--branch` option to specify just a single branch to update."
msgstr "如果有多个分支，'git p4 sync' 会自动使用 “分支检测” 算法将新的改动分到正确的分支。 可以用 `--branch` 选项覆盖该算法，只指定更新一个分支。"

#. type: Title ~
#: en/git-p4.txt:122
#, no-wrap, priority:90
msgid "Rebase"
msgstr "变基"

#. type: Plain text
#: en/git-p4.txt:128
#, priority:90
msgid "A common working pattern is to fetch the latest changes from the p4 depot and merge them with local uncommitted changes. Often, the p4 repository is the ultimate location for all code, thus a rebase workflow makes sense. This command does 'git p4 sync' followed by 'git rebase' to move local commits on top of updated p4 changes."
msgstr "常见的工作模式是从 p4 仓库获取最新的修改，然后与本地未提交的修改合并。 通常情况下，p4 仓库是所有代码的最终位置，因此使用 rebase 工作流程是合理的。 该命令先执行 'git p4 sync'，然后再执行 'git rebase'，将本地提交移至 p4 更新的改动之上。"

#. type: Title ~
#: en/git-p4.txt:134
#, no-wrap, priority:90
msgid "Submit"
msgstr "提交"

#. type: Plain text
#: en/git-p4.txt:140
#, placeholders:'git-p', priority:90
msgid "Submitting changes from a Git repository back to the p4 repository requires a separate p4 client workspace. This should be specified using the `P4CLIENT` environment variable or the Git configuration variable 'git-p4.client'. The p4 client must exist, but the client root will be created and populated if it does not already exist."
msgstr "将 Git 仓库中的更改提交回 p4 仓库需要一个单独的 p4 客户端工作区。 这需要使用 `P4CLIENT` 环境变量或 Git 配置变量 'git-p4.client' 来指定。 p4 客户端必须存在，但如果客户端根目录不存在，则会创建并填充客户端根目录。"

#. type: Plain text
#: en/git-p4.txt:143
#, priority:90
msgid "To submit all changes that are in the current Git branch but not in the 'p4/master' branch, use:"
msgstr "要提交当前 Git 分支中但不在 'p4/master' 分支中的所有更改，请使用："

#. type: Plain text
#: en/git-p4.txt:148
#, priority:90
msgid "To specify a branch other than the current one, use:"
msgstr "要指定当前分支以外的分支，请使用："

#. type: delimited block -
#: en/git-p4.txt:150
#, no-wrap, priority:90
msgid "$ git p4 submit topicbranch\n"
msgstr "$ git p4 submit topicbranch\n"

#. type: Plain text
#: en/git-p4.txt:153
#, priority:90
msgid "To specify a single commit or a range of commits, use:"
msgstr "要指定一次提交或一系列提交，请使用："

#. type: delimited block -
#: en/git-p4.txt:156
#, no-wrap, placeholders:'--commit':'--commit', priority:90
msgid ""
"$ git p4 submit --commit <sha1>\n"
"$ git p4 submit --commit <sha1..sha1>\n"
msgstr ""
"$ git p4 submit --commit <sha1>\n"
"$ git p4 submit --commit <sha1..sha1>\n"

#. type: Plain text
#: en/git-p4.txt:160
#, placeholders:'`--origin=`', priority:90
msgid "The upstream reference is generally 'refs/remotes/p4/master', but can be overridden using the `--origin=` command-line option."
msgstr "上游引用通常是 'refs/remotes/p4/master'，但可以使用 `--origin=` 命令行选项来覆盖。"

#. type: Plain text
#: en/git-p4.txt:165
#, placeholders:'`--preserve-user`', priority:90
msgid "The p4 changes will be created as the user invoking 'git p4 submit'. The `--preserve-user` option will cause ownership to be modified according to the author of the Git commit. This option requires admin privileges in p4, which can be granted using 'p4 protect'."
msgstr "p4 变更将以调用 'git p4 submit' 的用户身份创建。`--preserve-user` 选项会根据 Git 提交的作者修改所有权。 该选项需要 p4 的管理员权限，可以使用 'p4 protect' 授予。"

#. type: Plain text
#: en/git-p4.txt:167
#, placeholders:'`--shelve`':'`--update-shelve`', priority:90
msgid "To shelve changes instead of submitting, use `--shelve` and `--update-shelve`:"
msgstr "要搁置更改而不是提交，请使用 `--shelve` 和 `--update-shelve`："

#. type: delimited block -
#: en/git-p4.txt:171
#, no-wrap, placeholders:'--shelve':'--update-shelve':'--update-shelve', priority:90
msgid ""
"$ git p4 submit --shelve\n"
"$ git p4 submit --update-shelve 1234 --update-shelve 2345\n"
msgstr ""
"$ git p4 submit --shelve\n"
"$ git p4 submit --update-shelve 1234 --update-shelve 2345\n"

#. type: Title ~
#: en/git-p4.txt:175
#, no-wrap, priority:90
msgid "Unshelve"
msgstr "恢复更改"

#. type: Plain text
#: en/git-p4.txt:178
#, priority:90
msgid "Unshelving will take a shelved P4 changelist, and produce the equivalent git commit in the branch refs/remotes/p4-unshelved/<changelist>."
msgstr "取消上架会获取已上架的 P4 更新列表，并在 refs/remotes/p4-unshelved/<变更列表> 分支中产生等价的 git 提交。"

#. type: Plain text
#: en/git-p4.txt:182
#, placeholders:'HEAD', priority:90
msgid "The git commit is created relative to the current origin revision (HEAD by default). A parent commit is created based on the origin, and then the unshelve commit is created based on that."
msgstr "git 提交是相对于当前的源版本（默认为 HEAD）创建的。 根据起源创建父提交，然后根据父提交创建解保存提交。"

#. type: Plain text
#: en/git-p4.txt:184
#, placeholders:'--origin', priority:90
msgid "The origin revision can be changed with the \"--origin\" option."
msgstr "可以使用 \"--origin\" 选项更改原点版本。"

#. type: Plain text
#: en/git-p4.txt:187
#, priority:90
msgid "If the target branch in refs/remotes/p4-unshelved already exists, the old one will be renamed."
msgstr "如果 refs/remotes/p4-unshelved 中的目标分支已经存在，旧分支将被重命名。"

#. type: delimited block -
#: en/git-p4.txt:195
#, no-wrap, priority:90
msgid ""
"$ git p4 sync\n"
"$ git p4 unshelve 12345\n"
"$ git show p4-unshelved/12345\n"
"<submit more changes via p4 to the same files>\n"
"$ git p4 unshelve 12345\n"
"<refuses to unshelve until git is in sync with p4 again>\n"
msgstr ""
"$ git p4 sync\n"
"$ git p4 unshelve 12345\n"
"$ git show p4-unshelved/12345\n"
"<通过 p4 对同一文件提交更多修改>\n"
"$ git p4 unshelve 12345\n"
"<在 git 与 p4 重新同步之前，拒绝解锁>\n"

#. type: Title ~
#: en/git-p4.txt:202
#, no-wrap, priority:90
msgid "General options"
msgstr "常规选项"

#. type: Plain text
#: en/git-p4.txt:204
#, priority:90
msgid "All commands except clone accept these options."
msgstr "除克隆外，所有命令都接受这些选项。"

#. type: Labeled list
#: en/git-p4.txt:205
#, no-wrap, priority:90
msgid "--git-dir <dir>"
msgstr "--git-dir <目录>"

#. type: Plain text
#: en/git-p4.txt:207
#, placeholders:'GIT_DIR':'linkgit:git[1]', priority:90
msgid "Set the `GIT_DIR` environment variable. See linkgit:git[1]."
msgstr "设置 `GIT_DIR` 环境变量。 参见 linkgit:git[1]。"

#. type: Plain text
#: en/git-p4.txt:211
#, priority:90
msgid "Provide more progress information."
msgstr "提供更多进度信息。"

#. type: Title ~
#: en/git-p4.txt:213
#, no-wrap, priority:90
msgid "Sync options"
msgstr "同步选项"

#. type: Plain text
#: en/git-p4.txt:216
#, priority:90
msgid "These options can be used in the initial 'clone' as well as in subsequent 'sync' operations."
msgstr "这些选项可用于初始 'clone' 和后续 'sync' 操作。"

#. type: Labeled list
#: en/git-p4.txt:217
#, no-wrap, placeholders:'--branch', priority:90
msgid "--branch <ref>"
msgstr "--branch <引用>"

#. type: Plain text
#: en/git-p4.txt:221
#, priority:90
msgid "Import changes into <ref> instead of refs/remotes/p4/master. If <ref> starts with refs/, it is used as is. Otherwise, if it does not start with p4/, that prefix is added."
msgstr "将更改导入 <引入> 而不是 refs/remotes/p4/master。 如果 <引用> 以 refs/ 开头，则按原样使用。 否则，如果不是以 p4/ 开头，则会添加该前缀。"

#. type: Plain text
#: en/git-p4.txt:225
#, placeholders:'--import-local', priority:90
msgid "By default a <ref> not starting with refs/ is treated as the name of a remote-tracking branch (under refs/remotes/). This behavior can be modified using the --import-local option."
msgstr "默认情况下，不以 refs/ 开头的 <引用> 会被视为远程跟踪分支的名称（位于 refs/remotes/ 下）。 可以使用 --import-local 选项修改这一行为。"

#. type: Plain text
#: en/git-p4.txt:227
#, priority:90
msgid "The default <ref> is \"master\"."
msgstr "默认 <引用> 为 \"master\"。"

#. type: Plain text
#: en/git-p4.txt:230
#, priority:90
msgid "This example imports a new remote \"p4/proj2\" into an existing Git repository:"
msgstr "本示例将一个新的远程 \"p4/proj2\" 导入现有的 Git 仓库："

#. type: delimited block -
#: en/git-p4.txt:234
#, no-wrap, placeholders:'--branch=refs', priority:90
msgid ""
"    $ git init\n"
"    $ git p4 sync --branch=refs/remotes/p4/proj2 //depot/proj2\n"
msgstr ""
"    $ git init\n"
"    $ git p4 sync --branch=refs/remotes/p4/proj2 //depot/proj2\n"

#. type: Labeled list
#: en/git-p4.txt:236
#, ignore-same, no-wrap, priority:90
msgid "--detect-branches"
msgstr "--detect-branches"

#. type: Plain text
#: en/git-p4.txt:239
#, priority:90
msgid "Use the branch detection algorithm to find new paths in p4. It is documented below in \"BRANCH DETECTION\"."
msgstr "使用分支检测算法在 p4 中查找新路径。 下面的 “分支检测” 将介绍这种算法。"

#. type: Labeled list
#: en/git-p4.txt:240
#, no-wrap, placeholders:'--changesfile', priority:90
msgid "--changesfile <file>"
msgstr "--changesfile <文件>"

#. type: Plain text
#: en/git-p4.txt:244
#, priority:90
msgid "Import exactly the p4 change numbers listed in 'file', one per line. Normally, 'git p4' inspects the current p4 repository state and detects the changes it should import."
msgstr "精确导入 'file' 中列出的 p4 变更编号，每行一个。 通常，’git p4‘ 会检查当前的 p4 仓库状态，并检测出它应该导入的变更。"

#. type: Labeled list
#: en/git-p4.txt:245
#, ignore-same, no-wrap, priority:90
msgid "--silent"
msgstr "--silent"

#. type: Plain text
#: en/git-p4.txt:247
#, priority:90
msgid "Do not print any progress information."
msgstr "不要打印任何进度信息。"

#. type: Labeled list
#: en/git-p4.txt:248
#, ignore-same, no-wrap, priority:90
msgid "--detect-labels"
msgstr "--detect-labels"

#. type: Plain text
#: en/git-p4.txt:252
#, priority:90
msgid "Query p4 for labels associated with the depot paths, and add them as tags in Git. Limited usefulness as only imports labels associated with new changelists. Deprecated."
msgstr "查询 p4 中与仓库路径相关的标签，并在 Git 中将其添加为标签。作用有限，因为只能导入与新变更列表相关的标签所以弃用。"

#. type: Labeled list
#: en/git-p4.txt:253 en/git-p4.txt:430
#, ignore-same, no-wrap, priority:90
msgid "--import-labels"
msgstr "--import-labels"

#. type: Plain text
#: en/git-p4.txt:255
#, priority:90
msgid "Import labels from p4 into Git."
msgstr "将标签从 p4 导入 Git。"

#. type: Labeled list
#: en/git-p4.txt:256
#, ignore-same, no-wrap, priority:90
msgid "--import-local"
msgstr "--import-local"

#. type: Plain text
#: en/git-p4.txt:263
#, placeholders:'`--import-local`', priority:90
msgid "By default, p4 branches are stored in 'refs/remotes/p4/', where they will be treated as remote-tracking branches by linkgit:git-branch[1] and other commands. This option instead puts p4 branches in 'refs/heads/p4/'. Note that future sync operations must specify `--import-local` as well so that they can find the p4 branches in refs/heads."
msgstr "默认情况下，p4 分支存储在 'refs/remotes/p4/' 中，linkgit:git-branch[1] 和其他命令会将其视为远程跟踪分支。 该选项会把 p4 分支放到 'refs/heads/p4/' 中。 需要注意的是，今后的同步操作也必须指定 `--import-local`，这样才能在 refs/heads 中找到 p4 分支。"

#. type: Labeled list
#: en/git-p4.txt:264
#, no-wrap, placeholders:'--max-changes', priority:90
msgid "--max-changes <n>"
msgstr "--max-changes <n>"

#. type: Plain text
#: en/git-p4.txt:270
#, placeholders:'--max-changes', priority:90
msgid "Import at most 'n' changes, rather than the entire range of changes included in the given revision specifier. A typical usage would be use '@all' as the revision specifier, but then to use '--max-changes 1000' to import only the last 1000 revisions rather than the entire revision history."
msgstr "最多导入'n' 次修改，而不是导入给定版本说明符中包含的全部修改。一个典型的用法是使用 '@all' 作为版本说明符，然后使用 '--max-changes 1000' 只导入最后 1000 个版本，而不是整个修订历史。"

#. type: Labeled list
#: en/git-p4.txt:271
#, no-wrap, placeholders:'--changes-block-size', priority:90
msgid "--changes-block-size <n>"
msgstr "--changes-block-size <n>"

#. type: Plain text
#: en/git-p4.txt:279
#, priority:90
msgid "The internal block size to use when converting a revision specifier such as '@all' into a list of specific change numbers. Instead of using a single call to 'p4 changes' to find the full list of changes for the conversion, there are a sequence of calls to 'p4 changes -m', each of which requests one block of changes of the given size. The default block size is 500, which should usually be suitable."
msgstr "在将版本说明符（如 '@all'）转换为具体的变更编号列表时使用的内部块大小。在转换过程中，不需要调用一次 'p4 changes' 就能找到完整的修改列表，而是需要调用一系列 'p4 changes -m'，每次调用都会请求一个给定大小的修改块。默认的块大小是 500，这通常是合适的。"

#. type: Labeled list
#: en/git-p4.txt:280
#, ignore-same, no-wrap, priority:90
msgid "--keep-path"
msgstr "--keep-path"

#. type: Plain text
#: en/git-p4.txt:287
#, placeholders:'`--keep-path`', priority:90
msgid "The mapping of file names from the p4 depot path to Git, by default, involves removing the entire depot path. With this option, the full p4 depot path is retained in Git. For example, path '//depot/main/foo/bar.c', when imported from '//depot/main/', becomes 'foo/bar.c'. With `--keep-path`, the Git path is instead 'depot/main/foo/bar.c'."
msgstr "默认情况下，从 p4 仓库路径到 Git 的文件名映射涉及删除整个仓库路径。 有了这个选项，Git 会保留完整的 p4 仓库路径。 例如，路径 '//depot/main/foo/bar.c ' 从 '//depot/main/' 导入时，会变成 'foo/bar.c'。 如果使用 `--keep-path`，Git 路径就会变成 'depot/main/foo/bar.c'。"

#. type: Labeled list
#: en/git-p4.txt:288
#, ignore-same, no-wrap, priority:90
msgid "--use-client-spec"
msgstr "--use-client-spec"

#. type: Plain text
#: en/git-p4.txt:291
#, priority:90
msgid "Use a client spec to find the list of interesting files in p4. See the \"CLIENT SPEC\" section below."
msgstr "使用客户端规范在 p4 中查找感兴趣的文件列表。 请参阅下面的 “客户端规范” 部分。"

#. type: Labeled list
#: en/git-p4.txt:292
#, no-wrap, priority:90
msgid "-/ <path>"
msgstr "-/ <路径>"

#. type: Plain text
#: en/git-p4.txt:294
#, priority:90
msgid "Exclude selected depot paths when cloning or syncing."
msgstr "克隆或同步时排除选定的仓库路径。"

#. type: Title ~
#: en/git-p4.txt:296
#, no-wrap, priority:90
msgid "Clone options"
msgstr "克隆选项"

#. type: Plain text
#: en/git-p4.txt:299
#, priority:90
msgid "These options can be used in an initial 'clone', along with the 'sync' options described above."
msgstr "这些选项可与上述 'sync' 选项一起用于初始 'clone'。"

#. type: Labeled list
#: en/git-p4.txt:300
#, no-wrap, placeholders:'--destination', priority:90
msgid "--destination <directory>"
msgstr "--destination <目录>"

#. type: Plain text
#: en/git-p4.txt:304
#, priority:90
msgid "Where to create the Git repository. If not provided, the last component in the p4 depot path is used to create a new directory."
msgstr "创建 Git 仓库的位置。 如果未提供，则使用 p4 仓库路径中的最后一个组件来创建新目录。"

#. type: Plain text
#: en/git-p4.txt:307
#, placeholders:'linkgit:git-clone[1]', priority:90
msgid "Perform a bare clone. See linkgit:git-clone[1]."
msgstr "执行裸克隆。 参见 linkgit:git-clone[1]。"

#. type: Title ~
#: en/git-p4.txt:309
#, no-wrap, priority:90
msgid "Submit options"
msgstr "提交选项"

#. type: Plain text
#: en/git-p4.txt:311
#, priority:90
msgid "These options can be used to modify 'git p4 submit' behavior."
msgstr "这些选项可用于修改 'git p4 sumit' 行为。"

#. type: Labeled list
#: en/git-p4.txt:312
#, no-wrap, placeholders:'--origin', priority:90
msgid "--origin <commit>"
msgstr "--origin <提交>"

#. type: Plain text
#: en/git-p4.txt:316
#, placeholders:'HEAD', priority:90
msgid "Upstream location from which commits are identified to submit to p4. By default, this is the most recent p4 commit reachable from `HEAD`."
msgstr "提交到 p4 的上游位置。 默认情况下，这是可以从 `HEAD` 到达的最新 p4 提交。"

#. type: Plain text
#: en/git-p4.txt:322
#, placeholders:'linkgit:git-diff[1]', priority:90
msgid "Detect renames. See linkgit:git-diff[1]. Renames will be represented in p4 using explicit 'move' operations. There is no corresponding option to detect copies, but there are variables for both moves and copies."
msgstr "检测重命名。 参见 linkgit:git-diff[1]。 重命名将在 p4 中使用明确的 'move' 操作来表示。 没有相应的选项来检测副本，但移动和副本都有变量。"

#. type: Labeled list
#: en/git-p4.txt:323
#, ignore-same, no-wrap, priority:90
msgid "--preserve-user"
msgstr "--preserve-user"

#. type: Plain text
#: en/git-p4.txt:326
#, priority:90
msgid "Re-author p4 changes before submitting to p4. This option requires p4 admin privileges."
msgstr "在提交到 p4 之前重新授权 p4 更改。 此选项需要 p4 管理员权限。"

#. type: Labeled list
#: en/git-p4.txt:327
#, ignore-same, no-wrap, priority:90
msgid "--export-labels"
msgstr "--export-labels"

#. type: Plain text
#: en/git-p4.txt:330
#, priority:90
msgid "Export tags from Git as p4 labels. Tags found in Git are applied to the perforce working directory."
msgstr "将 Git 中的标签导出为 p4 标签。在 Git 中找到的标签会应用到 perforce 工作目录。"

#. type: Plain text
#: en/git-p4.txt:335
#, priority:90
msgid "Show just what commits would be submitted to p4; do not change state in Git or p4."
msgstr "只显示将提交到 p4 的提交内容；不改变 Git 或 p4 的状态。"

#. type: Labeled list
#: en/git-p4.txt:336
#, ignore-same, no-wrap, priority:90
msgid "--prepare-p4-only"
msgstr "--prepare-p4-only"

#. type: Plain text
#: en/git-p4.txt:342
#, priority:90
msgid "Apply a commit to the p4 workspace, opening, adding and deleting files in p4 as for a normal submit operation. Do not issue the final \"p4 submit\", but instead print a message about how to submit manually or revert. This option always stops after the first (oldest) commit. Git tags are not exported to p4."
msgstr "将提交应用到 p4 工作区，像正常提交操作一样在 p4 中打开、添加和删除文件。 不发出最终的 \"p4 submit\"，而是打印一条关于如何手动提交或还原的信息。 该选项总是在第一次（最旧的）提交后停止。 Git 标签不会导出到 p4。"

#. type: Labeled list
#: en/git-p4.txt:343
#, ignore-same, no-wrap, priority:90
msgid "--shelve"
msgstr "--shelve"

#. type: Plain text
#: en/git-p4.txt:347
#, priority:90
msgid "Instead of submitting create a series of shelved changelists. After creating each shelve, the relevant files are reverted/deleted. If you have multiple commits pending multiple shelves will be created."
msgstr "不提交，而是创建一系列搁置的变更列表。 创建每个书架后，相关文件将被还原/删除。 如果有多个提交待处理，则会创建多个书架。"

#. type: Labeled list
#: en/git-p4.txt:348
#, no-wrap, placeholders:'--update-shelve', priority:90
msgid "--update-shelve CHANGELIST"
msgstr "--update-shelve CHANGELIST（变更列表）"

#. type: Plain text
#: en/git-p4.txt:351
#, placeholders:'--shelve', priority:90
msgid "Update an existing shelved changelist with this commit. Implies --shelve. Repeat for multiple shelved changelists."
msgstr "使用此提交更新现有的已上架更新列表。意味着 --shelve。对多个已上架更新列表重复此操作。"

#. type: Labeled list
#: en/git-p4.txt:352
#, ignore-same, no-wrap, priority:90
msgid "--conflict=(ask|skip|quit)"
msgstr "--conflict=(ask|skip|quit)"

#. type: Plain text
#: en/git-p4.txt:358
#, priority:90
msgid "Conflicts can occur when applying a commit to p4. When this happens, the default behavior (\"ask\") is to prompt whether to skip this commit and continue, or quit. This option can be used to bypass the prompt, causing conflicting commits to be automatically skipped, or to quit trying to apply commits, without prompting."
msgstr "将提交应用到 p4 时可能会发生冲突。 当发生这种情况时，默认行为（\"ask\"）是提示是否跳过该提交并继续，或者退出。 该选项可用于绕过提示，自动跳过冲突提交，或在不提示的情况下放弃尝试应用提交。"

#. type: Labeled list
#: en/git-p4.txt:359 en/git-submodule.txt:292
#, no-wrap, placeholders:'--branch', priority:220
msgid "--branch <branch>"
msgstr "--branch <分支>"

#. type: Plain text
#: en/git-p4.txt:363
#, priority:90
msgid "After submitting, sync this named branch instead of the default p4/master. See the \"Sync options\" section above for more information."
msgstr "提交后，同步这个已命名的分支，而不是默认的 p4/master。 更多信息，请参阅上文 “同步选项” 部分。"

#. type: Labeled list
#: en/git-p4.txt:364
#, no-wrap, placeholders:'--commit', priority:90
msgid "--commit (<sha1>|<sha1>..<sha1>)"
msgstr "--commit <sha1>|<sha1..sha1>"

#. type: Plain text
#: en/git-p4.txt:367
#, priority:90
msgid "Submit only the specified commit or range of commits, instead of the full list of changes that are in the current Git branch."
msgstr "只提交指定的提交或提交范围，而不是当前 Git 分支中的全部变更列表。"

#. type: Labeled list
#: en/git-p4.txt:368
#, ignore-same, no-wrap, priority:90
msgid "--disable-rebase"
msgstr "--disable-rebase"

#. type: Plain text
#: en/git-p4.txt:371
#, placeholders:'git-p', priority:90
msgid "Disable the automatic rebase after all commits have been successfully submitted. Can also be set with git-p4.disableRebase."
msgstr "在成功提交所有提交后禁用自动回溯。也可以用 git-p4.disableRebase 设置。"

#. type: Labeled list
#: en/git-p4.txt:372
#, ignore-same, no-wrap, priority:90
msgid "--disable-p4sync"
msgstr "--disable-p4sync"

#. type: Plain text
#: en/git-p4.txt:376
#, placeholders:'--disable-rebase':'git-p', priority:90
msgid "Disable the automatic sync of p4/master from Perforce after commits have been submitted. Implies --disable-rebase. Can also be set with git-p4.disableP4Sync. Sync with origin/master still goes ahead if possible."
msgstr "提交后，禁用从 Perforce 自动同步 p4/master 的功能。意味着 --disable-rebase。也可通过 git-p4.disableP4Sync 设置。如果可能的话，与 origin/master 的同步仍会继续。"

#. type: Title -
#: en/git-p4.txt:378
#, no-wrap, priority:90
msgid "Hooks for submit"
msgstr "提交钩子"

#. type: Title ~
#: en/git-p4.txt:381
#, no-wrap, priority:90
msgid "p4-pre-submit"
msgstr "p4-pre-submit"

#. type: Plain text
#: en/git-p4.txt:387
#, placeholders:'git-p':'`--no-verify`', priority:90
msgid "The `p4-pre-submit` hook is executed if it exists and is executable. The hook takes no parameters and nothing from standard input. Exiting with non-zero status from this script prevents `git-p4 submit` from launching. It can be bypassed with the `--no-verify` command line option."
msgstr "如果存在 `p4-pre-submit` 钩子且可执行，则执行该钩子。 钩子不需要参数，也不需要标准输入。以非零状态退出该脚本会阻止 `git-p4 submit` 启动。 可以使用 `--no-verify`命令行选项绕过它。"

#. type: Plain text
#: en/git-p4.txt:389
#, priority:90
msgid "One usage scenario is to run unit tests in the hook."
msgstr "一种使用场景是在钩子中运行单元测试。"

#. type: Title ~
#: en/git-p4.txt:391
#, no-wrap, priority:90
msgid "p4-prepare-changelist"
msgstr "p4-prepare-changelist"

#. type: Plain text
#: en/git-p4.txt:398
#, priority:90
msgid "The `p4-prepare-changelist` hook is executed right after preparing the default changelist message and before the editor is started. It takes one parameter, the name of the file that contains the changelist text. Exiting with a non-zero status from the script will abort the process."
msgstr "`p4-prepare-changelist` 钩子会在准备好默认更改列表信息后，编辑器启动前立即执行。 它需要一个参数，即包含更新列表文本的文件名。以非零状态退出脚本将中止进程。"

#. type: Plain text
#: en/git-p4.txt:402
#, placeholders:'`--no-verify`':'`--prepare-p4-only`', priority:90
msgid "The purpose of the hook is to edit the message file in place, and it is not suppressed by the `--no-verify` option. This hook is called even if `--prepare-p4-only` is set."
msgstr "该钩子的目的是就地编辑消息文件，它不会被 `--no-verify`（不验证）选项抑制。即使设置了 `--prepare-p4-only`，也会调用该钩子。"

#. type: Title ~
#: en/git-p4.txt:404
#, no-wrap, priority:90
msgid "p4-changelist"
msgstr "p4-changelist"

#. type: Plain text
#: en/git-p4.txt:411
#, placeholders:'`--no-verify`', priority:90
msgid "The `p4-changelist` hook is executed after the changelist message has been edited by the user. It can be bypassed with the `--no-verify` option. It takes a single parameter, the name of the file that holds the proposed changelist text. Exiting with a non-zero status causes the command to abort."
msgstr "`p4-changelist` 钩子会在用户编辑更新列表信息后执行。可以使用 `--no-verify` 选项绕过该钩子。该钩子只接受一个参数，即保存更改列表文本的文件名。以非零状态退出会导致命令中止。"

#. type: Plain text
#: en/git-p4.txt:415
#, priority:90
msgid "The hook is allowed to edit the changelist file and can be used to normalize the text into some project standard format. It can also be used to refuse the Submit after inspect the message file."
msgstr "该钩子允许编辑更改列表文件，并可用于将文本规范化为某种项目标准格式。还可以在检查信息文件后拒绝提交。"

#. type: Title ~
#: en/git-p4.txt:417
#, no-wrap, priority:90
msgid "p4-post-changelist"
msgstr "p4-post-changelist"

#. type: Plain text
#: en/git-p4.txt:423
#, priority:90
msgid "The `p4-post-changelist` hook is invoked after the submit has successfully occurred in P4. It takes no parameters and is meant primarily for notification and cannot affect the outcome of the git p4 submit action."
msgstr "`p4-post-changelist` 钩子会在 P4 提交成功后被调用。它不需要参数，主要用于通知，不会影响 git p4 提交操作的结果。"

#. type: Title ~
#: en/git-p4.txt:427
#, no-wrap, priority:90
msgid "Rebase options"
msgstr "重置选项"

#. type: Plain text
#: en/git-p4.txt:429
#, priority:90
msgid "These options can be used to modify 'git p4 rebase' behavior."
msgstr "这些选项可用于修改 'git p4 rebase' 行为。"

#. type: Plain text
#: en/git-p4.txt:432
#, priority:90
msgid "Import p4 labels."
msgstr "导入 p4 标签。"

#. type: Title ~
#: en/git-p4.txt:434
#, no-wrap, priority:90
msgid "Unshelve options"
msgstr "卸载选项"

#. type: Labeled list
#: en/git-p4.txt:436
#, ignore-same, no-wrap, priority:90
msgid "--origin"
msgstr "--origin"

#. type: Plain text
#: en/git-p4.txt:439
#, priority:90
msgid "Sets the git refspec against which the shelved P4 changelist is compared. Defaults to p4/master."
msgstr "设置用于比较 P4 更新列表的 git refspec。 默认为 p4/master。"

#. type: Title -
#: en/git-p4.txt:441
#, no-wrap, priority:90
msgid "DEPOT PATH SYNTAX"
msgstr "仓库路径语法"

#. type: Plain text
#: en/git-p4.txt:445
#, priority:90
msgid "The p4 depot path argument to 'git p4 sync' and 'git p4 clone' can be one or more space-separated p4 depot paths, with an optional p4 revision specifier on the end:"
msgstr "'git p4 sync' 和 'git p4 clone' 的 p4 仓库路径参数可以是一个或多个空格分隔的 p4 仓库路径，末尾还可以加上一个可选的 p4 版本说明符："

#. type: Labeled list
#: en/git-p4.txt:446
#, no-wrap, priority:90
msgid "\"//depot/my/project\""
msgstr "\"//depot/my/project\""

#. type: Plain text
#: en/git-p4.txt:448
#, priority:90
msgid "Import one commit with all files in the '#head' change under that tree."
msgstr "导入一次提交，并在该树下导入 '#head' 变更中的所有文件。"

#. type: Labeled list
#: en/git-p4.txt:449
#, no-wrap, priority:90
msgid "\"//depot/my/project@all\""
msgstr "\"//depot/my/project@all\""

#. type: Plain text
#: en/git-p4.txt:451
#, priority:90
msgid "Import one commit for each change in the history of that depot path."
msgstr "为该仓库路径历史上的每次更改导入一个提交。"

#. type: Labeled list
#: en/git-p4.txt:452
#, no-wrap, priority:90
msgid "\"//depot/my/project@1,6\""
msgstr "\"//depot/my/project@1,6\""

#. type: Plain text
#: en/git-p4.txt:454
#, priority:90
msgid "Import only changes 1 through 6."
msgstr "只导入更改 1 至 6。"

#. type: Labeled list
#: en/git-p4.txt:455
#, no-wrap, priority:90
msgid "\"//depot/proj1@all //depot/proj2@all\""
msgstr "\"//depot/proj1@all //depot/proj2@all\""

#. type: Plain text
#: en/git-p4.txt:464
#, placeholders:'`--destination`', priority:90
msgid "Import all changes from both named depot paths into a single repository. Only files below these directories are included. There is not a subdirectory in Git for each \"proj1\" and \"proj2\". You must use the `--destination` option when specifying more than one depot path. The revision specifier must be specified identically on each depot path. If there are files in the depot paths with the same name, the path with the most recently updated version of the file is the one that appears in Git."
msgstr "将两个已命名仓库路径中的所有更改导入一个版本库。 只包含这些目录下的文件。 在 Git 中，每个 \"proj1\" 和 \"proj2\" 都没有子目录。 指定多个仓库路径时，必须使用 `--destination` 选项。 每个仓库路径上的修订说明必须完全相同。 如果仓库路径中存在同名文件，则 Git 会显示该文件最新更新版本的路径。"

#. type: Plain text
#: en/git-p4.txt:466
#, priority:90
msgid "See 'p4 help revisions' for the full syntax of p4 revision specifiers."
msgstr "有关 p4 修订说明符的完整语法，请参阅 \"p4 帮助修订\"。"

#. type: Title -
#: en/git-p4.txt:469
#, no-wrap, priority:90
msgid "CLIENT SPEC"
msgstr "CLIENT SPEC"

#. type: Plain text
#: en/git-p4.txt:479
#, placeholders:'`--use-client-spec`', priority:90
msgid "The p4 client specification is maintained with the 'p4 client' command and contains among other fields, a View that specifies how the depot is mapped into the client repository. The 'clone' and 'sync' commands can consult the client spec when given the `--use-client-spec` option or when the useClientSpec variable is true. After 'git p4 clone', the useClientSpec variable is automatically set in the repository configuration file. This allows future 'git p4 submit' commands to work properly; the submit command looks only at the variable and does not have a command-line option."
msgstr "p4 客户端规范由 'p4 client' 命令维护，除其他字段外，它还包含一个 View，用于指定如何将仓库映射到客户端仓库。 如果给定 `--use-client-spec` 选项，或者 useClientSpec 变量为 true，'clone' 和 'sync' 命令就能查阅客户端规范。 'git p4 clone' 后，useClientSpec 变量会自动在版本库配置文件中设置。 这样，以后的 'git p4 submit' 命令就能正常工作了；提交命令只查看变量，而没有命令行选项。"

#. type: Plain text
#: en/git-p4.txt:486
#, ignore-ellipsis, priority:90
msgid "The full syntax for a p4 view is documented in 'p4 help views'. 'git p4' knows only a subset of the view syntax. It understands multi-line mappings, overlays with '+', exclusions with '-' and double-quotes around whitespace. Of the possible wildcards, 'git p4' only handles '...', and only when it is at the end of the path. 'git p4' will complain if it encounters an unhandled wildcard."
msgstr "p4 视图的完整语法记录在 'p4 help views' 中。 'git p4' 只知道视图语法的一部分。 它能理解多行映射、用 '+' 覆盖、用 '-' 排除，以及在空白处加双引号。 在可能的通配符中，'git p4' 只处理 '...'，而且只在路径末尾才处理。 如果遇到未处理的通配符，'git p4' 会抱怨。"

#. type: Plain text
#: en/git-p4.txt:491
#, priority:90
msgid "Bugs in the implementation of overlap mappings exist. If multiple depot paths map through overlays to the same location in the repository, 'git p4' can choose the wrong one. This is hard to solve without dedicating a client spec just for 'git p4'."
msgstr "重叠映射的实现存在错误。 如果多个仓库路径通过重叠映射到仓库中的同一位置，'git p4' 可能会选择错误的路径。 如果不专门为 'git p4' 制定客户端规范，这个问题很难解决。"

#. type: Plain text
#: en/git-p4.txt:496
#, placeholders:'git-p', priority:90
msgid "The name of the client can be given to 'git p4' in multiple ways. The variable 'git-p4.client' takes precedence if it exists. Otherwise, normal p4 mechanisms of determining the client are used: environment variable `P4CLIENT`, a file referenced by `P4CONFIG`, or the local host name."
msgstr "'git p4' 可以通过多种方式指定客户端名称。 如果存在变量 'git-p4.client'，则优先使用。 否则，将使用正常的 p4 机制来确定客户端：环境变量 `P4CLIENT`、`P4CONFIG` 引用的文件或本地主机名。"

#. type: Title -
#: en/git-p4.txt:499
#, no-wrap, priority:90
msgid "BRANCH DETECTION"
msgstr "分支检测"

#. type: Plain text
#: en/git-p4.txt:506
#, priority:90
msgid "P4 does not have the same concept of a branch as Git. Instead, p4 organizes its content as a directory tree, where by convention different logical branches are in different locations in the tree. The 'p4 branch' command is used to maintain mappings between different areas in the tree, and indicate related content. 'git p4' can use these mappings to determine branch relationships."
msgstr "P4 并不像 Git 那样有分支的概念。 相反，P4 以目录树的形式组织内容，按照惯例，不同的逻辑分支位于目录树的不同位置。 'p4 branch' 命令用于维护目录树中不同区域之间的映射关系，并指示相关内容。 'git p4' 可以使用这些映射来确定分支关系。"

#. type: Plain text
#: en/git-p4.txt:511
#, placeholders:'`--detect-branches`', priority:90
msgid "If you have a repository where all the branches of interest exist as subdirectories of a single depot path, you can use `--detect-branches` when cloning or syncing to have 'git p4' automatically find subdirectories in p4, and to generate these as branches in Git."
msgstr "如果你有一个仓库，其中所有感兴趣的分支都作为单个仓库路径的子目录存在，你可以在克隆或同步时使用 `--detect-branches`，让 'git p4' 在 p4 中自动查找子目录，并在 Git 中生成这些分支。"

#. type: Plain text
#: en/git-p4.txt:513
#, priority:90
msgid "For example, if the P4 repository structure is:"
msgstr "例如，如果 P4 仓库结构为："

#. type: delimited block -
#: en/git-p4.txt:516
#, ignore-ellipsis, no-wrap, priority:90
msgid ""
"//depot/main/...\n"
"//depot/branch1/...\n"
msgstr ""
"//depot/main/...\n"
"//depot/branch1/...\n"

#. type: Plain text
#: en/git-p4.txt:519
#, priority:90
msgid "And \"p4 branch -o branch1\" shows a View line that looks like:"
msgstr "而 \"p4 branch -o branch1\" 显示的 View 行看起来就像这样："

#. type: delimited block -
#: en/git-p4.txt:521
#, ignore-ellipsis, no-wrap, priority:90
msgid "//depot/main/... //depot/branch1/...\n"
msgstr "//depot/main/... //depot/branch1/...\n"

#. type: Plain text
#: en/git-p4.txt:524
#, priority:90
msgid "Then this 'git p4 clone' command:"
msgstr "然后执行 'git p4 clone' 命令："

#. type: delimited block -
#: en/git-p4.txt:526
#, no-wrap, placeholders:'--detect-branches', priority:90
msgid "git p4 clone --detect-branches //depot@all\n"
msgstr "git p4 clone --detect-branches //depot@all\n"

#. type: Plain text
#: en/git-p4.txt:529
#, priority:90
msgid "produces a separate branch in 'refs/remotes/p4/' for //depot/main, called 'master', and one for //depot/branch1 called 'depot/branch1'."
msgstr "在 'refs/remotes/p4/' 中为 //depot/main 生成一个单独的分支，称为 'master'，为 //depot/branch1 生成一个分支，称为 'depot/branch1'。"

#. type: Plain text
#: en/git-p4.txt:539
#, placeholders:'git-p', priority:90
msgid "However, it is not necessary to create branches in p4 to be able to use them like branches. Because it is difficult to infer branch relationships automatically, a Git configuration setting 'git-p4.branchList' can be used to explicitly identify branch relationships. It is a list of \"source:destination\" pairs, like a simple p4 branch specification, where the \"source\" and \"destination\" are the path elements in the p4 repository. The example above relied on the presence of the p4 branch. Without p4 branches, the same result will occur with:"
msgstr "不过，要像使用分支那样使用分支，并不需要在 p4 中创建分支。 因为很难自动推断分支关系，所以可以使用 Git 配置设置 'git-p4.branchList' 来明确标识分支关系。 这是一个 'source:destination' （源：目的）对列表，就像一个简单的 p4 分支规范，其中 “源” 和 “目的” 是 p4 仓库中的路径元素。 上面的例子依赖于 p4 分支的存在。 如果没有 p4 分支，也会出现同样的结果："

#. type: delimited block -
#: en/git-p4.txt:544
#, no-wrap, placeholders:'git-p':'--detect-branches', priority:90
msgid ""
"git init depot\n"
"cd depot\n"
"git config git-p4.branchList main:branch1\n"
"git p4 clone --detect-branches //depot@all .\n"
msgstr ""
"git init depot\n"
"cd depot\n"
"git config git-p4.branchList main:branch1\n"
"git p4 clone --detect-branches //depot@all .\n"

#. type: Plain text
#: en/git-p4.txt:553
#, placeholders:'linkgit:git-gc[1]', priority:90
msgid "The fast-import mechanism used by 'git p4' creates one pack file for each invocation of 'git p4 sync'. Normally, Git garbage compression (linkgit:git-gc[1]) automatically compresses these to fewer pack files, but explicit invocation of 'git repack -adf' may improve performance."
msgstr "'git p4' 使用的快速导入机制会为每次调用 'git p4 sync' 创建一个包文件。 通常情况下，Git 垃圾压缩（linkgit:git-gc[1]）会自动将其压缩为更少的打包文件，但明确调用 'git repack -adf' 可能会提高性能。"

#. type: Plain text
#: en/git-p4.txt:559
#, placeholders:'git-p', priority:90
msgid "The following config settings can be used to modify 'git p4' behavior. They all are in the 'git-p4' section."
msgstr "以下配置设置可用于修改 'git p4' 行为。 它们都在 'git-p4' 部分。"

#. type: Title ~
#: en/git-p4.txt:561
#, no-wrap, priority:90
msgid "General variables"
msgstr "常规变量"

#. type: Labeled list
#: en/git-p4.txt:562
#, ignore-same, no-wrap, priority:90
msgid "git-p4.user"
msgstr "git-p4.user"

#. type: Plain text
#: en/git-p4.txt:565
#, priority:90
msgid "User specified as an option to all p4 commands, with '-u <user>'. The environment variable `P4USER` can be used instead."
msgstr "作为所有 p4 命令的一个选项，用 '-u <用户>' 指定用户。 可以使用环境变量 `P4USER` 代替。"

#. type: Labeled list
#: en/git-p4.txt:566
#, ignore-same, no-wrap, priority:90
msgid "git-p4.password"
msgstr "git-p4.password"

#. type: Plain text
#: en/git-p4.txt:570
#, priority:90
msgid "Password specified as an option to all p4 commands, with '-P <password>'. The environment variable `P4PASS` can be used instead."
msgstr "作为所有 p4 命令的选项，用 '-P <密码>' 指定密码。 可以使用环境变量 `P4PASS` 代替。"

#. type: Labeled list
#: en/git-p4.txt:571
#, ignore-same, no-wrap, priority:90
msgid "git-p4.port"
msgstr "git-p4.port"

#. type: Plain text
#: en/git-p4.txt:575
#, priority:90
msgid "Port specified as an option to all p4 commands, with '-p <port>'. The environment variable `P4PORT` can be used instead."
msgstr "作为所有 p4 命令的选项，用 '-p <端口>' 指定端口。 可以使用环境变量 `P4PORT` 代替。"

#. type: Labeled list
#: en/git-p4.txt:576
#, ignore-same, no-wrap, priority:90
msgid "git-p4.host"
msgstr "git-p4.host"

#. type: Plain text
#: en/git-p4.txt:580
#, priority:90
msgid "Host specified as an option to all p4 commands, with '-h <host>'. The environment variable `P4HOST` can be used instead."
msgstr "主机作为所有 p4 命令的选项，用 '-h <主机>' 指定。 可以使用环境变量 `P4HOST` 代替。"

#. type: Labeled list
#: en/git-p4.txt:581
#, ignore-same, no-wrap, priority:90
msgid "git-p4.client"
msgstr "git-p4.client"

#. type: Plain text
#: en/git-p4.txt:584
#, priority:90
msgid "Client specified as an option to all p4 commands, with '-c <client>', including the client spec."
msgstr "作为所有 p4 命令的选项，用 '-c <客户端>' 指定客户端，包括客户端规范。"

#. type: Labeled list
#: en/git-p4.txt:585
#, ignore-same, no-wrap, priority:90
msgid "git-p4.retries"
msgstr "git-p4.retries"

#. type: Plain text
#: en/git-p4.txt:590
#, priority:90
msgid "Specifies the number of times to retry a p4 command (notably, 'p4 sync') if the network times out. The default value is 3. Set the value to 0 to disable retries or if your p4 version does not support retries (pre 2012.2)."
msgstr "指定网络超时时重试 p4 命令（特别是 'p4 sync' ）的次数，默认值为 3。默认值为 3，如果 p4 版本不支持重试（2012.2 之前），则将该值设为 0 以禁用重试。"

#. type: Title ~
#: en/git-p4.txt:592
#, no-wrap, priority:90
msgid "Clone and sync variables"
msgstr "克隆和同步变量"

#. type: Labeled list
#: en/git-p4.txt:593
#, ignore-same, no-wrap, priority:90
msgid "git-p4.syncFromOrigin"
msgstr "git-p4.syncFromOrigin"

#. type: Plain text
#: en/git-p4.txt:599
#, priority:90
msgid "Because importing commits from other Git repositories is much faster than importing them from p4, a mechanism exists to find p4 changes first in Git remotes. If branches exist under 'refs/remote/origin/p4', those will be fetched and used when syncing from p4. This variable can be set to 'false' to disable this behavior."
msgstr "由于从其他 Git 仓库导入提交比从 p4 导入要快得多，因此有一种机制可以在 Git 远端中首先找到 p4 的变更。 如果在 'refs/remote/origin/p4' 下存在分支，从 p4 同步时就会使用这些分支。 可以将此变量设为 'false' 以禁用此行为。"

#. type: Labeled list
#: en/git-p4.txt:600
#, ignore-same, no-wrap, priority:90
msgid "git-p4.branchUser"
msgstr "git-p4.branchUser"

#. type: Plain text
#: en/git-p4.txt:605
#, priority:90
msgid "One phase in branch detection involves looking at p4 branches to find new ones to import. By default, all branches are inspected. This option limits the search to just those owned by the single user named in the variable."
msgstr "分支检测的一个阶段是查看 p4 分支，以找到要导入的新分支。 默认情况下，会检查所有分支。 该选项将搜索范围限制为变量中指定的单个用户所拥有的分支。"

#. type: Labeled list
#: en/git-p4.txt:606
#, ignore-same, no-wrap, priority:90
msgid "git-p4.branchList"
msgstr "git-p4.branchList"

#. type: Plain text
#: en/git-p4.txt:611
#, priority:90
msgid "List of branches to be imported when branch detection is enabled. Each entry should be a pair of branch names separated by a colon (:). This example declares that both branchA and branchB were created from main:"
msgstr "启用分支检测时要导入的分支列表。 每个条目都是一对分支名称，中间用冒号（:）隔开。 本示例声明 branchA 和 branchB 都是从 main 创建的："

#. type: delimited block -
#: en/git-p4.txt:615
#, no-wrap, placeholders:'git-p':'--add':'git-p', priority:90
msgid ""
"git config       git-p4.branchList main:branchA\n"
"git config --add git-p4.branchList main:branchB\n"
msgstr ""
"git config       git-p4.branchList main:branchA\n"
"git config --add git-p4.branchList main:branchB\n"

#. type: Labeled list
#: en/git-p4.txt:617
#, no-wrap, placeholders:'git-p', priority:90
msgid "git-p4.ignoredP4Labels"
msgstr "git-p4.ignoredP4Labels"

#. type: Plain text
#: en/git-p4.txt:620
#, priority:90
msgid "List of p4 labels to ignore. This is built automatically as unimportable labels are discovered."
msgstr "要忽略的 p4 标签列表。当发现不可导入的标签时，该列表会自动生成。"

#. type: Labeled list
#: en/git-p4.txt:621
#, ignore-same, no-wrap, priority:90
msgid "git-p4.importLabels"
msgstr "git-p4.importLabels"

#. type: Plain text
#: en/git-p4.txt:623
#, placeholders:'--import-labels', priority:90
msgid "Import p4 labels into git, as per --import-labels."
msgstr "根据 --import-labels 将 p4 标签导入 git。"

#. type: Labeled list
#: en/git-p4.txt:624
#, ignore-same, no-wrap, priority:90
msgid "git-p4.labelImportRegexp"
msgstr "git-p4.labelImportRegexp"

#. type: Plain text
#: en/git-p4.txt:627
#, priority:90
msgid "Only p4 labels matching this regular expression will be imported. The default value is '[a-zA-Z0-9_\\-.]+$'."
msgstr "只有匹配此正则表达式的 p4 标签才会被导入。默认值为 '[a-zA-Z0-9_\\-.]+$'。"

#. type: Labeled list
#: en/git-p4.txt:628
#, ignore-same, no-wrap, priority:90
msgid "git-p4.useClientSpec"
msgstr "git-p4.useClientSpec"

#. type: Plain text
#: en/git-p4.txt:633
#, placeholders:'`--use-client-spec`', priority:90
msgid "Specify that the p4 client spec should be used to identify p4 depot paths of interest. This is equivalent to specifying the option `--use-client-spec`. See the \"CLIENT SPEC\" section above. This variable is a boolean, not the name of a p4 client."
msgstr "指定使用 p4 客户端规范来识别感兴趣的 p4 仓库路径。 这等同于指定选项 `--use-client-spec`。 参见上文的 \"CLIENT SPEC\"（指定客户端） 章节。 此变量是一个布尔值，而不是 p4 客户端的名称。"

#. type: Labeled list
#: en/git-p4.txt:634
#, ignore-same, no-wrap, priority:90
msgid "git-p4.pathEncoding"
msgstr "git-p4.pathEncoding"

#. type: Plain text
#: en/git-p4.txt:642
#, placeholders:'git-p', priority:90
msgid "Perforce keeps the encoding of a path as given by the originating OS. Git expects paths encoded as UTF-8. Use this config to tell git-p4 what encoding Perforce had used for the paths. This encoding is used to transcode the paths to UTF-8. As an example, Perforce on Windows often uses \"cp1252\" to encode path names. If this option is passed into a p4 clone request, it is persisted in the resulting new git repo."
msgstr "Perforce 会保留原始操作系统提供的路径编码。 Git 希望路径编码为 UTF-8。使用此配置，可以告诉 git-p4 Perforce 对路径使用的编码。该编码会被用于将路径转码为 UTF-8。例如，Windows 上的 Perforce 通常使用 \"cp1252 \"来编码路径名。如果在 p4 clone 请求中传递了这个选项，它就会在生成的新 Git 仓库中持续存在。"

#. type: Labeled list
#: en/git-p4.txt:643
#, ignore-same, no-wrap, priority:90
msgid "git-p4.metadataDecodingStrategy"
msgstr "git-p4.metadataDecodingStrategy"

#. type: Plain text
#: en/git-p4.txt:667
#, placeholders:'git-p', priority:90
msgid "Perforce keeps the encoding of a changelist descriptions and user full names as stored by the client on a given OS. The p4v client uses the OS-local encoding, and so different users can end up storing different changelist descriptions or user full names in different encodings, in the same depot. Git tolerates inconsistent/incorrect encodings in commit messages and author names, but expects them to be specified in utf-8. git-p4 can use three different decoding strategies in handling the encoding uncertainty in Perforce: 'passthrough' simply passes the original bytes through from Perforce to git, creating usable but incorrectly-encoded data when the Perforce data is encoded as anything other than utf-8. 'strict' expects the Perforce data to be encoded as utf-8, and fails to import when this is not true. 'fallback' attempts to interpret the data as utf-8, and otherwise falls back to using a secondary encoding - by default the common windows encoding 'cp-1252' - with upper-range bytes escaped if decoding with the fallback encoding also fails. Under python2 the default strategy is 'passthrough' for historical reasons, and under python3 the default is 'fallback'. When 'strict' is selected and decoding fails, the error message will propose changing this config parameter as a workaround. If this option is passed into a p4 clone request, it is persisted into the resulting new git repo."
msgstr "Perforce 会保留特定操作系统上客户端存储的更新列表描述和用户全名的编码。而 p4v 客户端使用的是操作系统本地编码，因此不同用户可能会在同一个仓库中以不同编码存储不同的更新列表描述或用户全名。 git-p4 可以使用三种不同的解码策略来处理 Perforce 编码的不确定性：'passthrough'（直通）只是将原始字节从 Perforce 传到 git，当 Perforce 数据的编码不是 utf-8 时，就会产生可用但编码不正确的数据。'strict' （严格）要求 Perforce 数据以 utf-8 编码，否则导入失败。 'fallback' （回退）会尝试将数据解释为 utf-8，否则会退回到使用二级编码（默认情况下是常用的 windows 编码 'cp-1252'），如果使用回退编码解码也失败，则会转义上层字节。 在 python2 下，由于历史原因，默认策略是 'passthrough'，而在 python3 下，默认策略是 'fallback'。 如果选择了 'strict'，但解码失败，则错误信息会建议更改此配置参数作为解决方法。如果在 p4 克隆请求中传递此选项，则会将其持久化到生成的新 Git 仓库中。"

#. type: Labeled list
#: en/git-p4.txt:668
#, ignore-same, no-wrap, priority:90
msgid "git-p4.metadataFallbackEncoding"
msgstr "git-p4.metadataFallbackEncoding"

#. type: Plain text
#: en/git-p4.txt:675
#, placeholders:'git-p', priority:90
msgid "Specify the fallback encoding to use when decoding Perforce author names and changelists descriptions using the 'fallback' strategy (see git-p4.metadataDecodingStrategy). The fallback encoding will only be used when decoding as utf-8 fails. This option defaults to cp1252, a common windows encoding. If this option is passed into a p4 clone request, it is persisted into the resulting new git repo."
msgstr "使用 'fallback' 策略（参见 git-p4.metadataDecodingStrategy）解码 Perforce 作者姓名和 changelists 描述时，指定要使用的后备编码。只有在解码为 utf-8 失败时，才会使用后备编码。该选项默认为 cp1252，这是一种常用的 windows 编码。如果在 p4 克隆请求中传递了该选项，则会将其持久化到生成的新 git 仓库中。"

#. type: Labeled list
#: en/git-p4.txt:676
#, ignore-same, no-wrap, priority:90
msgid "git-p4.largeFileSystem"
msgstr "git-p4.largeFileSystem"

#. type: Plain text
#: en/git-p4.txt:682
#, placeholders:'git-lfs':'github.com', priority:90
msgid "Specify the system that is used for large (binary) files. Please note that large file systems do not support the 'git p4 submit' command. Only Git LFS is implemented right now (see https://git-lfs.github.com/ for more information). Download and install the Git LFS command line extension to use this option and configure it like this:"
msgstr "指定大型（二进制）文件使用的系统。请注意，大文件系统不支持 'git p4 submit' 命令。 目前只支持 Git LFS（详情请见 https://git-lfs.github.com/）。下载并安装 Git LFS 命令行扩展来使用该选项，并像这样配置："

#. type: delimited block -
#: en/git-p4.txt:685
#, no-wrap, placeholders:'git-p', priority:90
msgid "git config       git-p4.largeFileSystem GitLFS\n"
msgstr "git config       git-p4.largeFileSystem GitLFS\n"

#. type: Labeled list
#: en/git-p4.txt:687
#, ignore-same, no-wrap, priority:90
msgid "git-p4.largeFileExtensions"
msgstr "git-p4.largeFileExtensions"

#. type: Plain text
#: en/git-p4.txt:690
#, priority:90
msgid "All files matching a file extension in the list will be processed by the large file system. Do not prefix the extensions with '.'."
msgstr "大文件系统将处理列表中与文件扩展名匹配的所有文件。扩展名前不要加 '.'。"

#. type: Labeled list
#: en/git-p4.txt:691
#, ignore-same, no-wrap, priority:90
msgid "git-p4.largeFileThreshold"
msgstr "git-p4.largeFileThreshold"

#. type: Plain text
#: en/git-p4.txt:695
#, priority:90
msgid "All files with an uncompressed size exceeding the threshold will be processed by the large file system. By default the threshold is defined in bytes. Add the suffix k, m, or g to change the unit."
msgstr "所有未压缩大小超过阈值的文件都将由大文件系统处理。默认情况下，阈值以字节为单位。添加后缀 k、m 或 g 可更改单位。"

#. type: Labeled list
#: en/git-p4.txt:696
#, ignore-same, no-wrap, priority:90
msgid "git-p4.largeFileCompressedThreshold"
msgstr "git-p4.largeFileCompressedThreshold"

#. type: Plain text
#: en/git-p4.txt:701
#, priority:90
msgid "All files with a compressed size exceeding the threshold will be processed by the large file system. This option might slow down your clone/sync process. By default the threshold is defined in bytes. Add the suffix k, m, or g to change the unit."
msgstr "所有压缩大小超过阈值的文件都将由大文件系统处理。该选项可能会减慢克隆/同步进程。默认情况下，阈值以字节为单位。添加后缀 k、m 或 g 可更改单位。"

#. type: Labeled list
#: en/git-p4.txt:702
#, ignore-same, no-wrap, priority:90
msgid "git-p4.largeFilePush"
msgstr "git-p4.largeFilePush"

#. type: Plain text
#: en/git-p4.txt:705
#, priority:90
msgid "Boolean variable which defines if large files are automatically pushed to a server."
msgstr "布尔变量，用于定义是否将大文件自动推送到服务器。布尔变量，用于定义是否将大文件自动推送到服务器。"

#. type: Labeled list
#: en/git-p4.txt:706
#, ignore-same, no-wrap, priority:90
msgid "git-p4.keepEmptyCommits"
msgstr "git-p4.keepEmptyCommits"

#. type: Plain text
#: en/git-p4.txt:709
#, priority:90
msgid "A changelist that contains only excluded files will be imported as an empty commit if this boolean option is set to true."
msgstr "如果该布尔选项设置为 'true'，则仅包含排除文件的更新列表将作为空提交导入。"

#. type: Labeled list
#: en/git-p4.txt:710
#, ignore-same, no-wrap, priority:90
msgid "git-p4.mapUser"
msgstr "git-p4.mapUser"

#. type: Plain text
#: en/git-p4.txt:713
#, priority:90
msgid "Map a P4 user to a name and email address in Git. Use a string with the following format to create a mapping:"
msgstr "将 P4 用户映射到 Git 中的名称和电子邮件地址。使用格式如下的字符串创建映射："

#. type: delimited block -
#: en/git-p4.txt:716
#, no-wrap, placeholders:'--add':'git-p':'address.com', priority:90
msgid "git config --add git-p4.mapUser \"p4user = First Last <mail@address.com>\"\n"
msgstr "git config --add git-p4.mapUser \"p4user = First Last <mail@address.com>\"\n"

#. type: Plain text
#: en/git-p4.txt:720
#, priority:90
msgid "A mapping will override any user information from P4. Mappings for multiple P4 user can be defined."
msgstr "映射将覆盖 P4 中的任何用户信息。可以为多个 P4 用户定义映射。"

#. type: Title ~
#: en/git-p4.txt:722
#, no-wrap, priority:90
msgid "Submit variables"
msgstr "提交变量"

#. type: Labeled list
#: en/git-p4.txt:723
#, ignore-same, no-wrap, priority:90
msgid "git-p4.detectRenames"
msgstr "git-p4.detectRenames"

#. type: Plain text
#: en/git-p4.txt:726
#, placeholders:'linkgit:git-diff[1]', priority:90
msgid "Detect renames. See linkgit:git-diff[1]. This can be true, false, or a score as expected by 'git diff -M'."
msgstr "检测重命名。 参见 linkgit:git-diff[1]。 可以是 true、false，也可以是 'git diff -M' 所期望的分数。"

#. type: Labeled list
#: en/git-p4.txt:727
#, ignore-same, no-wrap, priority:90
msgid "git-p4.detectCopies"
msgstr "git-p4.detectCopies"

#. type: Plain text
#: en/git-p4.txt:730
#, placeholders:'linkgit:git-diff[1]', priority:90
msgid "Detect copies. See linkgit:git-diff[1]. This can be true, false, or a score as expected by 'git diff -C'."
msgstr "检测副本。 参见 linkgit:git-diff[1]。 可以是 true、false，也可以是 'git diff -C' 所期望的分数。"

#. type: Labeled list
#: en/git-p4.txt:731
#, ignore-same, no-wrap, priority:90
msgid "git-p4.detectCopiesHarder"
msgstr "git-p4.detectCopiesHarder"

#. type: Plain text
#: en/git-p4.txt:733
#, placeholders:'linkgit:git-diff[1]', priority:90
msgid "Detect copies harder. See linkgit:git-diff[1]. A boolean."
msgstr "更难检测副本。 参见 linkgit:git-diff[1]。 布尔值。"

#. type: Labeled list
#: en/git-p4.txt:734
#, ignore-same, no-wrap, priority:90
msgid "git-p4.preserveUser"
msgstr "git-p4.preserveUser"

#. type: Plain text
#: en/git-p4.txt:737
#, priority:90
msgid "On submit, re-author changes to reflect the Git author, regardless of who invokes 'git p4 submit'."
msgstr "提交时，无论谁调用了 'git p4 submit'，都会重新授权以反映 Git 作者。"

#. type: Labeled list
#: en/git-p4.txt:738
#, no-wrap, placeholders:'git-p', priority:90
msgid "git-p4.allowMissingP4Users"
msgstr "git-p4.allowMissingP4Users"

#. type: Plain text
#: en/git-p4.txt:742
#, priority:90
msgid "When 'preserveUser' is true, 'git p4' normally dies if it cannot find an author in the p4 user map. This setting submits the change regardless."
msgstr "当 'preserveUser' 为真时，'git p4' 如果在 p4 用户映射中找不到作者，通常就会挂掉。 无论如何，该设置都会提交修改。"

#. type: Labeled list
#: en/git-p4.txt:743
#, ignore-same, no-wrap, priority:90
msgid "git-p4.skipSubmitEdit"
msgstr "git-p4.skipSubmitEdit"

#. type: Plain text
#: en/git-p4.txt:747
#, priority:90
msgid "The submit process invokes the editor before each p4 change is submitted. If this setting is true, though, the editing step is skipped."
msgstr "在每次提交 p4 更改之前，提交流程都会调用编辑器。 如果该设置为 true，编辑步骤将被跳过。"

#. type: Labeled list
#: en/git-p4.txt:748
#, ignore-same, no-wrap, priority:90
msgid "git-p4.skipSubmitEditCheck"
msgstr "git-p4.skipSubmitEditCheck"

#. type: Plain text
#: en/git-p4.txt:752
#, priority:90
msgid "After editing the p4 change message, 'git p4' makes sure that the description really was changed by looking at the file modification time. This option disables that test."
msgstr "在编辑 p4 的改动信息之后，'git p4' 通过审查文件修改时间确保真正改变描述。 这一选项禁用了上述的测试。"

#. type: Labeled list
#: en/git-p4.txt:753
#, ignore-same, no-wrap, priority:90
msgid "git-p4.allowSubmit"
msgstr "git-p4.allowSubmit"

#. type: Plain text
#: en/git-p4.txt:759
#, priority:90
msgid "By default, any branch can be used as the source for a 'git p4 submit' operation. This configuration variable, if set, permits only the named branches to be used as submit sources. Branch names must be the short names (no \"refs/heads/\"), and should be separated by commas (\",\"), with no spaces."
msgstr "默认情况下，任何分支都可以作为 'git p4 submit' 操作的来源。如果设置了这个配置变量，仅允许特定名称的分支作为提交的来源。该分支名必须是短名称（没有 \"refs/heads/\"），并且应当用没有空白的逗号（\",\"）分割。"

#. type: Labeled list
#: en/git-p4.txt:760
#, ignore-same, no-wrap, priority:90
msgid "git-p4.skipUserNameCheck"
msgstr "git-p4.skipUserNameCheck"

#. type: Plain text
#: en/git-p4.txt:764
#, priority:90
msgid "If the user running 'git p4 submit' does not exist in the p4 user map, 'git p4' exits. This option can be used to force submission regardless."
msgstr "如果运行 'git p4 submit' 的用户并不存在 p4 的用户图中，但存在 'git p4' 的用户图中。这个选项用来强制提交。"

#. type: Labeled list
#: en/git-p4.txt:765
#, ignore-same, no-wrap, priority:90
msgid "git-p4.attemptRCSCleanup"
msgstr "git-p4.attemptRCSCleanup"

#. type: Plain text
#: en/git-p4.txt:770
#, placeholders:'$Header', priority:90
msgid "If enabled, 'git p4 submit' will attempt to cleanup RCS keywords ($Header$, etc). These would otherwise cause merge conflicts and prevent the submit going ahead. This option should be considered experimental at present."
msgstr "如果启用这个选项，'git p4 submit' 将试图清理 RCS 关键字（例如 $Header$）。否则会导致合并冲突并防止提交。这个选项是当前的实验功能。"

#. type: Labeled list
#: en/git-p4.txt:771
#, ignore-same, no-wrap, priority:90
msgid "git-p4.exportLabels"
msgstr "git-p4.exportLabels"

#. type: Plain text
#: en/git-p4.txt:773
#, placeholders:'--export-labels', priority:90
msgid "Export Git tags to p4 labels, as per --export-labels."
msgstr "根据每个 --export-labels 将 Git tags 导出到 p4 标签。"

#. type: Labeled list
#: en/git-p4.txt:774
#, ignore-same, no-wrap, priority:90
msgid "git-p4.labelExportRegexp"
msgstr "git-p4.labelExportRegexp"

#. type: Plain text
#: en/git-p4.txt:777
#, priority:90
msgid "Only p4 labels matching this regular expression will be exported. The default value is '[a-zA-Z0-9_\\-.]+$'."
msgstr "只有匹配这个正则表达式的 p4 标签才会被导出。默认值是 '[a-zA-Z0-9_\\-.]+$'。"

#. type: Labeled list
#: en/git-p4.txt:778
#, ignore-same, no-wrap, priority:90
msgid "git-p4.conflict"
msgstr "git-p4.conflict"

#. type: Plain text
#: en/git-p4.txt:781
#, placeholders:'--conflict', priority:90
msgid "Specify submit behavior when a conflict with p4 is found, as per --conflict. The default behavior is 'ask'."
msgstr "根据每个 --conflict，当有 p4 冲突出现的时候，指定提交行为。默认行为是 'ask'。"

#. type: Labeled list
#: en/git-p4.txt:782
#, ignore-same, no-wrap, priority:90
msgid "git-p4.disableRebase"
msgstr "git-p4.disableRebase"

#. type: Plain text
#: en/git-p4.txt:784
#, priority:90
msgid "Do not rebase the tree against p4/master following a submit."
msgstr "在一个提交之后不将目录树变基到 p4/master。"

#. type: Labeled list
#: en/git-p4.txt:785
#, no-wrap, placeholders:'git-p', priority:90
msgid "git-p4.disableP4Sync"
msgstr "git-p4.disableP4Sync"

#. type: Plain text
#: en/git-p4.txt:787
#, placeholders:'git-p', priority:90
msgid "Do not sync p4/master with Perforce following a submit. Implies git-p4.disableRebase."
msgstr "提交后不与 Perforce 同步 p4/master。隐含 git-p4.disableRebase。"

#. type: Title -
#: en/git-p4.txt:789
#, no-wrap, priority:90
msgid "IMPLEMENTATION DETAILS"
msgstr "执行细节"

#. type: Plain text
#: en/git-p4.txt:791
#, priority:90
msgid "Changesets from p4 are imported using Git fast-import."
msgstr "使用 Git fast-import 导入 p4 中的更改集。"

#. type: Plain text
#: en/git-p4.txt:793
#, priority:90
msgid "Cloning or syncing does not require a p4 client; file contents are collected using 'p4 print'."
msgstr "克隆或同步不需要 p4 客户端；使用 'p4 print' 即可收集文件内容。"

#. type: Plain text
#: en/git-p4.txt:796
#, priority:90
msgid "Submitting requires a p4 client, which is not in the same location as the Git repository. Patches are applied, one at a time, to this p4 client and submitted from there."
msgstr "提交补丁需要一个 p4 客户端，该客户端与 Git 仓库不在同一位置。 补丁一次一个地应用到 p4 客户端，然后从那里提交。"

#. type: Plain text
#: en/git-p4.txt:800
#, priority:90
msgid "Each commit imported by 'git p4' has a line at the end of the log message indicating the p4 depot location and change number. This line is used by later 'git p4 sync' operations to know which p4 changes are new."
msgstr "'git p4' 导入的每个提交的日志信息末尾都有一行，标明 p4 仓库位置和变更编号。 后面的 'git p4 sync' 操作会使用这一行来了解哪些 p4 变动是新的。"

#. type: Title =
#: en/git-pack-objects.txt:2
#, ignore-same, no-wrap, priority:80
msgid "git-pack-objects(1)"
msgstr "git-pack-objects(1)"

#. type: Plain text
#: en/git-pack-objects.txt:7
#, placeholders:'git-pack-objects', priority:80
msgid "git-pack-objects - Create a packed archive of objects"
msgstr "git-pack-objects - 创建打包的对象档案"

#. type: Plain text
#: en/git-pack-objects.txt:19
#, no-wrap, placeholders:'git pack-objects':'--progress':'--all-progress]':'[--all-progress-implied]':'[--no-reuse-delta]':'[--delta-base-offset]':'[--non-empty]':'[--local]':'[--incremental]':'[--window=':'[--depth=':'[--revs':'[--unpacked':'--all]':'[--keep-pack=':'[--cruft]':'[--cruft-expiration=':'[--stdout':'[--filter=':'[--shallow]':'[--keep-true-parents]', priority:80
msgid ""
"'git pack-objects' [-q | --progress | --all-progress] [--all-progress-implied]\n"
"\t[--no-reuse-delta] [--delta-base-offset] [--non-empty]\n"
"\t[--local] [--incremental] [--window=<n>] [--depth=<n>]\n"
"\t[--revs [--unpacked | --all]] [--keep-pack=<pack-name>]\n"
"\t[--cruft] [--cruft-expiration=<time>]\n"
"\t[--stdout [--filter=<filter-spec>] | <base-name>]\n"
"\t[--shallow] [--keep-true-parents] [--[no-]sparse] < <object-list>\n"
msgstr ""
"'git pack-objects' [-q | --progress | --all-progress] [--all-progress-implied]\n"
"\t[--no-reuse-delta] [--delta-base-offset] [--non-empty]\n"
"\t[--local] [--incremental] [--window=<n>] [--depth=<n>]\n"
"\t[--revs [--unpacked | --all]] [--keep-pack=<包名>]\n"
"\t[--cruft] [--cruft-expiration=<时间>]\n"
"\t[--stdout [--filter=<过滤选项>] | <基础名>]\n"
"\t[--shallow] [--keep-true-parents] [--[no-]sparse] < <对象列表>\n"

#. type: Plain text
#: en/git-pack-objects.txt:26
#, priority:80
msgid "Reads list of objects from the standard input, and writes either one or more packed archives with the specified base-name to disk, or a packed archive to the standard output."
msgstr "从标准输入读取对象列表，并将一个或多个指定基数名称的打包档案写入磁盘，或将一个打包档案写入标准输出。"

#. type: Plain text
#: en/git-pack-objects.txt:32
#, priority:80
msgid "A packed archive is an efficient way to transfer a set of objects between two repositories as well as an access efficient archival format. In a packed archive, an object is either stored as a compressed whole or as a difference from some other object. The latter is often called a delta."
msgstr "打包档案是在两个储存库之间转移一组对象的有效方法，也是一种有效的存取档案格式。 在打包的档案中，一个对象要么是作为一个压缩的整体来存储，要么是作为与其他对象的区别来存储。 后者通常被称为 delta。"

#. type: Plain text
#: en/git-pack-objects.txt:36
#, priority:80
msgid "The packed archive format (.pack) is designed to be self-contained so that it can be unpacked without any further information. Therefore, each object that a delta depends upon must be present within the pack."
msgstr "打包的档案格式（.pack）被设计为自成一体，这样它就可以在没有任何进一步信息的情况下被解包。因此，delta 所依赖的每个对象都必须存在于pack 中。"

#. type: Plain text
#: en/git-pack-objects.txt:42
#, placeholders:'$GIT_OBJECT_DIRECTORY':'$GIT_ALTERNATE_OBJECT_DIRECTORIES', priority:80
msgid "A pack index file (.idx) is generated for fast, random access to the objects in the pack. Placing both the index file (.idx) and the packed archive (.pack) in the pack/ subdirectory of $GIT_OBJECT_DIRECTORY (or any of the directories on $GIT_ALTERNATE_OBJECT_DIRECTORIES) enables Git to read from the pack archive."
msgstr "一个打包的索引文件（.idx）被生成，以便快速、随机地访问打包中的对象。将索引文件（.idx）和打包的归档文件（.pack）放在$GIT_OBJECT_DIRECTORY（或 $GIT_ALTERNATE_OBJECT_DIRECTORIES 上的任何一个目录）的 pack/ 子目录下，可以使 Git 从打包的归档文件中读取。"

#. type: Plain text
#: en/git-pack-objects.txt:48
#, placeholders:'git unpack-objects', priority:80
msgid "The 'git unpack-objects' command can read the packed archive and expand the objects contained in the pack into \"one-file one-object\" format; this is typically done by the smart-pull commands when a pack is created on-the-fly for efficient network transport by their peers."
msgstr "'git unpack-objects' 命令可以读取打包后的档案，并将打包后的对象扩展为 “一对一的文件 - 对象” 的格式；这通常是由 smart-pull 命令在即时创建打包时完成的，以便由它们的同行进行有效的网络传输。"

#. type: Labeled list
#: en/git-pack-objects.txt:52
#, no-wrap, priority:80
msgid "base-name"
msgstr "基础名"

#. type: Plain text
#: en/git-pack-objects.txt:59
#, priority:80
msgid "Write into pairs of files (.pack and .idx), using <base-name> to determine the name of the created file. When this option is used, the two files in a pair are written in <base-name>-<SHA-1>.{pack,idx} files. <SHA-1> is a hash based on the pack content and is written to the standard output of the command."
msgstr "写入成对的文件（.pack 和 .idx），使用 <base-name> 来确定创建的文件名。 当使用该选项时，一对中的两个文件被写入 <base-name>-<SHA-1>.{pack,idx} 文件。 <SHA-1> 是一个基于 pack 内容的哈希值，会写入命令的标准输出中。"

#. type: Plain text
#: en/git-pack-objects.txt:63
#, priority:80
msgid "Write the pack contents (what would have been written to .pack file) out to the standard output."
msgstr "将包的内容（本来要写到 .pack 文件中的内容）写到标准输出中。"

#. type: Labeled list
#: en/git-pack-objects.txt:64
#, ignore-same, no-wrap, priority:80
msgid "--revs"
msgstr "--revs"

#. type: Plain text
#: en/git-pack-objects.txt:72
#, placeholders:'git rev-list':'`--objects`':'`--not`':'`--shallow', priority:80
msgid "Read the revision arguments from the standard input, instead of individual object names. The revision arguments are processed the same way as 'git rev-list' with the `--objects` flag uses its `commit` arguments to build the list of objects it outputs. The objects on the resulting list are packed. Besides revisions, `--not` or `--shallow <SHA-1>` lines are also accepted."
msgstr "从标准输入读取修订参数，而不是单个对象名称。 修订版参数的处理方式与带有 `--objects` 标志的 'git rev-list' 使用其 `commit` 参数来建立其输出的对象列表相同。 结果列表上的对象被打包。 除了修订，还接受 `--not` 或 `--shallow <SHA-1>` 行。"

#. type: Labeled list
#: en/git-pack-objects.txt:73 en/rev-list-options.txt:924
#, ignore-same, no-wrap, priority:260
msgid "--unpacked"
msgstr "--unpacked"

#. type: Plain text
#: en/git-pack-objects.txt:77
#, placeholders:'`--revs`', priority:80
msgid "This implies `--revs`. When processing the list of revision arguments read from the standard input, limit the objects packed to those that are not already packed."
msgstr "这暗指 `--revs`。 当处理从标准输入读取的修订参数列表时，将打包的对象限制在那些尚未打包的对象。"

#. type: Plain text
#: en/git-pack-objects.txt:83
#, placeholders:'`--revs`', priority:80
msgid "This implies `--revs`. In addition to the list of revision arguments read from the standard input, pretend as if all refs under `refs/` are specified to be included."
msgstr "这暗指 `--revs`。 除了从标准输入中读取的修订参数列表外，还假设指定要包括 `refs/`下的所有引用。"

#. type: Plain text
#: en/git-pack-objects.txt:88
#, priority:80
msgid "Include unasked-for annotated tags if the object they reference was included in the resulting packfile. This can be useful to send new tags to native Git clients."
msgstr "包括未被要求的注释标签，如果它们引用的对象被包含在结果的打包文件中。 这对于向本地 Git 客户端发送新的标签很有用。"

#. type: Labeled list
#: en/git-pack-objects.txt:89
#, ignore-same, no-wrap, priority:80
msgid "--stdin-packs"
msgstr "--stdin-packs"

#. type: Plain text
#: en/git-pack-objects.txt:95
#, priority:80
msgid "Read the basenames of packfiles (e.g., `pack-1234abcd.pack`) from the standard input, instead of object names or revision arguments. The resulting pack contains all objects listed in the included packs (those not beginning with `^`), excluding any objects listed in the excluded packs (beginning with `^`)."
msgstr "从标准输入中读取 packfiles（例如：`pack-1234abcd.pack`）的基本名称，而不是对象名称或修订参数。产生的数据包包含所有在包含的数据包中列出的对象（那些不是以 `^` 开头的），排除在排除的数据包中列出的任何对象（以 `^` 开头）。"

#. type: Plain text
#: en/git-pack-objects.txt:98
#, placeholders:'`--revs`':'`--revs`':'`--all`':'`--unpacked`', priority:80
msgid "Incompatible with `--revs`, or options that imply `--revs` (such as `--all`), with the exception of `--unpacked`, which is compatible."
msgstr "与 `--revs` 或暗指 `--revs` 的选项（如 `--all`）不兼容，但 `--unpacked` 除外，它是兼容的。"

#. type: Labeled list
#: en/git-pack-objects.txt:99 en/git-repack.txt:66
#, ignore-same, no-wrap, priority:100
msgid "--cruft"
msgstr "--cruft"

#. type: Plain text
#: en/git-pack-objects.txt:109
#, placeholders:'--cruft`':'`--cruft-expiration`', priority:80
msgid "Packs unreachable objects into a separate \"cruft\" pack, denoted by the existence of a `.mtimes` file. Typically used by `git repack --cruft`. Callers provide a list of pack names and indicate which packs will remain in the repository, along with which packs will be deleted (indicated by the `-` prefix). The contents of the cruft pack are all objects not contained in the surviving packs which have not exceeded the grace period (see `--cruft-expiration` below), or which have exceeded the grace period, but are reachable from an other object which hasn't."
msgstr "将无法到达的对象打包到一个单独的 \"cruft\" 包中，以 `.mtimes` 文件的存在为标志。通常由`git repack --cruft`使用。调用者提供一个包的名称列表，并指出哪些包将保留在版本库中，以及哪些包将被删除（用 `-` 前缀表示）。cruft 包的内容是所有不包含在幸存的包中的对象，它们没有超过宽限期（见下面的 `--cruft-expiration`），或者它们已经超过了宽限期，但可以从其他没有超过宽限期的对象中到达。"

#. type: Plain text
#: en/git-pack-objects.txt:116
#, placeholders:'`--cruft-expiration`':'`--cruft-expiration`':'`--cruft-expiration`', priority:80
msgid "When the input lists a pack containing all reachable objects (and lists all other packs as pending deletion), the corresponding cruft pack will contain all unreachable objects (with mtime newer than the `--cruft-expiration`) along with any unreachable objects whose mtime is older than the `--cruft-expiration`, but are reachable from an unreachable object whose mtime is newer than the `--cruft-expiration`)."
msgstr "当输入列出一个包含所有可达对象的包（并将所有其他包列为待删除），相应的 cruft 包将包含所有不可达对象（其 mtime 比 `--cruft-expiration` 新），以及任何 mtime 比 `--cruft-expiration` 早，但可从 mtime 比 `--cruft-expiration` 新的不可达对象到达的不可达对象）。"

#. type: Plain text
#: en/git-pack-objects.txt:120
#, placeholders:'`--unpack-unreachable`':'`--keep-unreachable`':'`--pack-loose-unreachable`':'`--stdin-packs`':'`--revs`', priority:80
msgid "Incompatible with `--unpack-unreachable`, `--keep-unreachable`, `--pack-loose-unreachable`, `--stdin-packs`, as well as any other options which imply `--revs`."
msgstr "与 `--unpack-unreachable`、 `--keep-unreachable`、 `--pack-loose-unreachable`、 `--stdin-packs`，以及其他暗示 `--revs` 的选项不兼容。"

#. type: Labeled list
#: en/git-pack-objects.txt:121 en/git-repack.txt:72
#, no-wrap, placeholders:'--cruft-expiration=', priority:100
msgid "--cruft-expiration=<approxidate>"
msgstr "--cruft-expiration=<近似值>"

# ERROR: `--cruft` not found in translation
#. type: Plain text
#: en/git-pack-objects.txt:125
#, placeholders:'`--cruft`', priority:80
msgid "If specified, objects are eliminated from the cruft pack if they have an mtime older than `<approxidate>`. If unspecified (and given `--cruft`), then no objects are eliminated."
msgstr "如果指定了，且对象的 mtime 超过 `<approxidate>`，就会从 cruft 包中剔除。如果没有指定（并给出 `--cruft`），那么没有对象被淘汰。"

#. type: Labeled list
#: en/git-pack-objects.txt:126 en/git-repack.txt:118
#, no-wrap, placeholders:'--window=', priority:100
msgid "--window=<n>"
msgstr "--window=<n>"

#. type: Plain text
#: en/git-pack-objects.txt:137
#, placeholders:'--window':'--depth', priority:80
msgid "These two options affect how the objects contained in the pack are stored using delta compression. The objects are first internally sorted by type, size and optionally names and compared against the other objects within --window to see if using delta compression saves space. --depth limits the maximum delta depth; making it too deep affects the performance on the unpacker side, because delta data needs to be applied that many times to get to the necessary object."
msgstr "这两个选项影响了使用 delta 压缩法存储数据包中的对象的方式。 这些对象首先按照类型、大小和可选的名称进行内部排序，并与 --window 内的其他对象进行比较，看使用 delta 压缩是否节省了空间。 --depth 限制了最大的 delta 深度；使其过深会影响到解包方的性能，因为 delta 数据需要应用那么多次才能到达必要的对象。"

#. type: Plain text
#: en/git-pack-objects.txt:140 en/git-repack.txt:130
#, placeholders:'--window':'--depth', priority:100
msgid "The default value for --window is 10 and --depth is 50. The maximum depth is 4095."
msgstr "--window 的默认值为 10，--depth 的默认值为 50。最大深度为 4095。"

#. type: Labeled list
#: en/git-pack-objects.txt:141 en/git-repack.txt:134
#, no-wrap, placeholders:'--window-memory=', priority:100
msgid "--window-memory=<n>"
msgstr "--window-memory=<n>"

#. type: Plain text
#: en/git-pack-objects.txt:151
#, placeholders:'`--window`':'`--window-memory=0`':'pack.windowMemory', priority:80
msgid "This option provides an additional limit on top of `--window`; the window size will dynamically scale down so as to not take up more than '<n>' bytes in memory. This is useful in repositories with a mix of large and small objects to not run out of memory with a large window, but still be able to take advantage of the large window for the smaller objects. The size can be suffixed with \"k\", \"m\", or \"g\". `--window-memory=0` makes memory usage unlimited. The default is taken from the `pack.windowMemory` configuration variable."
msgstr "这个选项在 `--window` 的基础上提供了一个额外的限制；窗口的大小将动态地缩小，以便不占用超过 '<n>' 字节的内存。 这对有大有小的对象的存储库很有用，它不会因为大窗口而耗尽内存，但仍然能够利用大窗口来处理小对象。 大小可以以 \"k\"、\"m \"或 \"g \"为后缀。 `--window-memory=0` 使内存使用不受限制。 默认值取自`pack.windowMemory` 配置变量。"

#. type: Plain text
#: en/git-pack-objects.txt:163
#, placeholders:'pack.packSizeLimit':'pack.packSizeLimit', priority:80
msgid "In unusual scenarios, you may not be able to create files larger than a certain size on your filesystem, and this option can be used to tell the command to split the output packfile into multiple independent packfiles, each not larger than the given size. The size can be suffixed with \"k\", \"m\", or \"g\". The minimum size allowed is limited to 1 MiB. The default is unlimited, unless the config variable `pack.packSizeLimit` is set. Note that this option may result in a larger and slower repository; see the discussion in `pack.packSizeLimit`."
msgstr "在不寻常的情况下，你可能无法在你的文件系统上创建大于一定大小的文件，这个选项可以用来告诉命令将输出的 packfile 分割成多个独立的 packfile，每个 packfile 都不大于给定的大小。大小可以以 \"k\"、\"m \"或 \"g \"为后缀。允许的最小尺寸被限制为1 MiB。 默认是无限制的，除非配置变量`pack.packSizeLimit` 被设置。注意，这个选项可能会导致仓库变大变慢；参见 `pack.packSizeLimit`中的讨论。"

#. type: Labeled list
#: en/git-pack-objects.txt:164
#, ignore-same, no-wrap, priority:80
msgid "--honor-pack-keep"
msgstr "--honor-pack-keep"

#. type: Plain text
#: en/git-pack-objects.txt:168
#, priority:80
msgid "This flag causes an object already in a local pack that has a .keep file to be ignored, even if it would have otherwise been packed."
msgstr "这个标志会使一个已经在本地打包的对象被忽略，即使它本来会被打包。"

#. type: Labeled list
#: en/git-pack-objects.txt:169 en/git-repack.txt:198
#, no-wrap, placeholders:'--keep-pack=', priority:100
msgid "--keep-pack=<pack-name>"
msgstr "--keep-pack=<包名>"

#. type: Plain text
#: en/git-pack-objects.txt:175
#, priority:80
msgid "This flag causes an object already in the given pack to be ignored, even if it would have otherwise been packed. `<pack-name>` is the pack file name without leading directory (e.g. `pack-123.pack`). The option could be specified multiple times to keep multiple packs."
msgstr "这个标志使已经在给定包中的对象被忽略，即使它本来已经被打包。`<pack-name>` 是不带前导目录的包文件名（例如：`pack-123.pack`）。该选项可以被多次指定以保留多个包。"

#. type: Plain text
#: en/git-pack-objects.txt:179
#, priority:80
msgid "This flag causes an object already in a pack to be ignored even if it would have otherwise been packed."
msgstr "这个标志使已经在包装中的对象被忽略，即使它本来会被包装。"

#. type: Plain text
#: en/git-pack-objects.txt:184
#, priority:80
msgid "This flag causes an object that is borrowed from an alternate object store to be ignored even if it would have otherwise been packed."
msgstr "这个标志导致从另一个对象存储空间借来的对象被忽略，即使它本来会被打包。"

#. type: Labeled list
#: en/git-pack-objects.txt:185
#, ignore-same, no-wrap, priority:80
msgid "--non-empty"
msgstr "--non-empty"

#. type: Plain text
#: en/git-pack-objects.txt:188
#, priority:80
msgid "Only create a packed archive if it would contain at least one object."
msgstr "只有在至少包含一个对象的情况下才会创建一个打包的档案。"

#. type: Labeled list
#: en/git-pack-objects.txt:195
#, ignore-same, no-wrap, priority:80
msgid "--all-progress"
msgstr "--all-progress"

#. type: Plain text
#: en/git-pack-objects.txt:205
#, placeholders:'--stdout':'--progress':'--stdout', priority:80
msgid "When --stdout is specified then progress report is displayed during the object count and compression phases but inhibited during the write-out phase. The reason is that in some cases the output stream is directly linked to another command which may wish to display progress status of its own as it processes incoming pack data. This flag is like --progress except that it forces progress report for the write-out phase as well even if --stdout is used."
msgstr "当指定 --stdout 时，在对象计数和压缩阶段会显示进度报告，但在写出阶段会被抑制。原因是在某些情况下，输出流直接与另一个命令相连，而后者在处理输入的数据时可能希望显示自己的进度状态。 这个标志和 --progress 一样，只是它在写出阶段也强制显示进度报告，即使使用了 --stdout。"

#. type: Labeled list
#: en/git-pack-objects.txt:206
#, ignore-same, no-wrap, priority:80
msgid "--all-progress-implied"
msgstr "--all-progress-implied"

#. type: Plain text
#: en/git-pack-objects.txt:210
#, placeholders:'--all-progress':'--all-progress', priority:80
msgid "This is used to imply --all-progress whenever progress display is activated. Unlike --all-progress this flag doesn't actually force any progress display by itself."
msgstr "当进度显示被激活时，它被用来暗指 --all-progress。 与 --all-progress 不同的是，这个标志本身实际上并不强制显示任何进度。"

#. type: Labeled list
#: en/git-pack-objects.txt:215
#, ignore-same, no-wrap, priority:80
msgid "--no-reuse-delta"
msgstr "--no-reuse-delta"

#. type: Plain text
#: en/git-pack-objects.txt:221
#, priority:80
msgid "When creating a packed archive in a repository that has existing packs, the command reuses existing deltas. This sometimes results in a slightly suboptimal pack. This flag tells the command not to reuse existing deltas but compute them from scratch."
msgstr "当在已有打包的版本库中创建一个打包的归档文件时，该命令会重用现有的三角洲。 这有时会导致一个稍微次优的打包。 这个标志告诉命令不要重用现有的 deltas，而是从头开始计算。"

#. type: Labeled list
#: en/git-pack-objects.txt:222
#, ignore-same, no-wrap, priority:80
msgid "--no-reuse-object"
msgstr "--no-reuse-object"

#. type: Plain text
#: en/git-pack-objects.txt:228
#, placeholders:'--no-reuse-delta', priority:80
msgid "This flag tells the command not to reuse existing object data at all, including non deltified object, forcing recompression of everything. This implies --no-reuse-delta. Useful only in the obscure case where wholesale enforcement of a different compression level on the packed data is desired."
msgstr "这个标志告诉命令不要重复使用现有的对象数据，包括非延迟对象，强迫重新压缩所有东西。 这意味着 --no-reuse-delta。只有在需要对打包的数据全盘执行不同的压缩级别的隐蔽情况下才有用。"

#. type: Labeled list
#: en/git-pack-objects.txt:229
#, no-wrap, placeholders:'--compression=', priority:80
msgid "--compression=<n>"
msgstr "--compression=<n>"

#. type: Plain text
#: en/git-pack-objects.txt:236
#, placeholders:'pack.compression':'core.compression':'--no-reuse-object', priority:80
msgid "Specifies compression level for newly-compressed data in the generated pack. If not specified, pack compression level is determined first by pack.compression, then by core.compression, and defaults to -1, the zlib default, if neither is set. Add --no-reuse-object if you want to force a uniform compression level on all data no matter the source."
msgstr "为生成的数据包中新压缩的数据指定压缩级别。 如果没有指定，数据包的压缩级别首先由 pack.compression 决定，然后由 core.compression 决定，如果两者都没有设置，则默认为 -1，即 zlib 默认值。 如果你想在所有的数据上强制使用统一的压缩级别，无论其来源如何，请添加 --no-reuse-object。"

#. type: Labeled list
#: en/git-pack-objects.txt:237
#, ignore-same, no-wrap, priority:80
msgid "--[no-]sparse"
msgstr "--[no-]sparse"

#. type: Plain text
#: en/git-pack-objects.txt:247
#, placeholders:'--revs':'pack.useSparse', priority:80
msgid "Toggle the \"sparse\" algorithm to determine which objects to include in the pack, when combined with the \"--revs\" option. This algorithm only walks trees that appear in paths that introduce new objects. This can have significant performance benefits when computing a pack to send a small change. However, it is possible that extra objects are added to the pack-file if the included commits contain certain types of direct renames. If this option is not included, it defaults to the value of `pack.useSparse`, which is true unless otherwise specified."
msgstr "与 \"--revs\" 选项结合使用时，切换 \"稀疏\" 算法，以确定哪些对象应包含在数据包中。这种算法只行走那些出现在引入新对象的路径中的树。 当计算一个包来发送一个小的变化时，这可能有显著的性能优势。然而，如果所包含的提交包含某些类型的直接重命名，则可能会有额外的对象被添加到包文件中。如果不包括这个选项，它默认为 `pack.useSparse` 的值，除非另有规定，否则为真。"

#. type: Plain text
#: en/git-pack-objects.txt:252
#, placeholders:'--stdout', priority:80
msgid "Create a \"thin\" pack by omitting the common objects between a sender and a receiver in order to reduce network transfer. This option only makes sense in conjunction with --stdout."
msgstr "通过省略发送方和接收方之间的共同对象来创建一个 \"轻量\" 包，以减少网络传输。这个选项只有在与 --stdout 一起使用时才有意义。"

#. type: Plain text
#: en/git-pack-objects.txt:257
#, placeholders:'git index-pack':'--fix-thin`':'linkgit:git-index-pack[1]', priority:80
msgid "Note: A thin pack violates the packed archive format by omitting required objects and is thus unusable by Git without making it self-contained. Use `git index-pack --fix-thin` (see linkgit:git-index-pack[1]) to restore the self-contained property."
msgstr "注意：轻量包由于省略了所需的对象而违反了打包的存档格式，因此如果不使其自成一体，Git 就无法使用。使用 `git index-pack --fix-thin` （ linkgit:git-index-pack[1]）来恢复自包含的属性。"

#. type: Labeled list
#: en/git-pack-objects.txt:258
#, ignore-same, no-wrap, priority:80
msgid "--shallow"
msgstr "--shallow"

#. type: Plain text
#: en/git-pack-objects.txt:262
#, placeholders:'--thin', priority:80
msgid "Optimize a pack that will be provided to a client with a shallow repository. This option, combined with --thin, can result in a smaller pack at the cost of speed."
msgstr "优化将被提供给客户的浅克隆仓库的数据包。 这个选项和 --thin 结合起来，可以以速度为代价，产生一个更小的包。"

#. type: Labeled list
#: en/git-pack-objects.txt:263
#, ignore-same, no-wrap, priority:80
msgid "--delta-base-offset"
msgstr "--delta-base-offset"

#. type: Plain text
#: en/git-pack-objects.txt:273
#, placeholders:'git pack-objects', priority:80
msgid "A packed archive can express the base object of a delta as either a 20-byte object name or as an offset in the stream, but ancient versions of Git don't understand the latter. By default, 'git pack-objects' only uses the former format for better compatibility. This option allows the command to use the latter format for compactness. Depending on the average delta chain length, this option typically shrinks the resulting packfile by 3-5 per-cent."
msgstr "打包后的归档文件可以用 20 字节的对象名称或流中的偏移量来表达 delta 的基础对象，但早期版本的 Git 不理解后者。 默认情况下，'git pack-objects' 只使用前一种格式，以提高兼容性。 这个选项允许该命令使用后者的格式以达到紧凑的目的。 根据 delta 链的平均长度，这个选项通常会将生成的 packfile 缩小 3-5%。"

#. type: Plain text
#: en/git-pack-objects.txt:278
#, placeholders:'linkgit:git-gc[1]':'linkgit:git-repack[1]':'linkgit:git-bundle[1]', priority:80
msgid "Note: Porcelain commands such as `git gc` (see linkgit:git-gc[1]), `git repack` (see linkgit:git-repack[1]) pass this option by default in modern Git when they put objects in your repository into pack files. So does `git bundle` (see linkgit:git-bundle[1]) when it creates a bundle."
msgstr "注意: 在现版本 Git 中，诸如 `git gc` (参见 linkgit:git-gc[1])、`git repack` (参见 linkgit:git-repack[1])之类的上层命令在将仓库中的对象放入打包文件时，默认会传递这个选项。 当 `git bundle` (参见 linkgit:git-bundle[1])创建一个捆绑包时也会这样做。"

#. type: Plain text
#: en/git-pack-objects.txt:288
#, priority:80
msgid "Specifies the number of threads to spawn when searching for best delta matches. This requires that pack-objects be compiled with pthreads otherwise this option is ignored with a warning. This is meant to reduce packing time on multiprocessor machines. The required amount of memory for the delta search window is however multiplied by the number of threads. Specifying 0 will cause Git to auto-detect the number of CPU's and set the number of threads accordingly."
msgstr "指定搜索最佳 delta 匹配时产生的线程数。 这要求 pack-objects 使用 pthreads 编译，否则该选项将被忽略并发出警告。 这样做的目的是在多处理器机器上减少打包时间。 然而，delta 搜索窗口所需的内存会乘以线程数。 指定 0 将导致 Git 自动检测 CPU 数量并相应设置线程数量。"

#. type: Labeled list
#: en/git-pack-objects.txt:294
#, ignore-same, no-wrap, priority:80
msgid "--keep-true-parents"
msgstr "--keep-true-parents"

#. type: Plain text
#: en/git-pack-objects.txt:297
#, priority:80
msgid "With this option, parents that are hidden by grafts are packed nevertheless."
msgstr "通过这种方法，被移植物覆盖的父母还是会被打包。"

#. type: Plain text
#: en/git-pack-objects.txt:302
#, placeholders:'linkgit:git-rev-list[1]', priority:80
msgid "Omits certain objects (usually blobs) from the resulting packfile. See linkgit:git-rev-list[1] for valid `<filter-spec>` forms."
msgstr "从生成的包文件中省略某些对象（通常是 blob）。 有关有效的 `<过滤规则>` 形式，请参见 linkgit:git-rev-list[1]。"

#. type: Labeled list
#: en/git-pack-objects.txt:303 en/rev-list-options.txt:993
#, ignore-same, no-wrap, priority:260
msgid "--no-filter"
msgstr "--no-filter"

#. type: Plain text
#: en/git-pack-objects.txt:305
#, placeholders:'`--filter=`', priority:80
msgid "Turns off any previous `--filter=` argument."
msgstr "关闭之前的 `--filter=` 参数。"

#. type: Labeled list
#: en/git-pack-objects.txt:306 en/rev-list-options.txt:1005
#, no-wrap, placeholders:'--missing=', priority:260
msgid "--missing=<missing-action>"
msgstr "--missing=<缺失行为>"

#. type: Plain text
#: en/git-pack-objects.txt:309 en/rev-list-options.txt:1008
#, priority:260
msgid "A debug option to help with future \"partial clone\" development. This option specifies how missing objects are handled."
msgstr "一个调试选项，帮助未来的 \"部分克隆 \"开发。 这个选项指定了如何处理丢失的对象。"

#. type: Plain text
#: en/git-pack-objects.txt:314
#, placeholders:'--missing=error', priority:80
msgid "The form '--missing=error' requests that pack-objects stop with an error if a missing object is encountered. If the repository is a partial clone, an attempt to fetch missing objects will be made before declaring them missing. This is the default action."
msgstr "表格 '--missing=error' 请求在遇到丢失对象时以错误停止 pack-objects。 如果仓库是部分克隆，在宣布丢失之前会尝试获取丢失的对象。 这是默认行为。"

#. type: Plain text
#: en/git-pack-objects.txt:318
#, placeholders:'--missing=allow-any', priority:80
msgid "The form '--missing=allow-any' will allow object traversal to continue if a missing object is encountered. No fetch of a missing object will occur. Missing objects will silently be omitted from the results."
msgstr "形式 '--missing=allow-any' 将允许在遇到丢失对象时继续遍历对象。 不会获取丢失的对象。 缺少的对象将从结果中被静默省略。"

#. type: Plain text
#: en/git-pack-objects.txt:323
#, placeholders:'--missing=allow-promisor', priority:80
msgid "The form '--missing=allow-promisor' is like 'allow-any', but will only allow object traversal to continue for EXPECTED promisor missing objects. No fetch of a missing object will occur. An unexpected missing object will raise an error."
msgstr "形式 '--missing=allow-promisor' 类似于 'allow-any'，但只允许继续遍历预期 promisor 丢失的对象。 不会获取丢失的对象。 意外丢失的对象将引发错误。"

#. type: Labeled list
#: en/git-pack-objects.txt:324 en/rev-list-options.txt:1023
#, ignore-same, no-wrap, priority:260
msgid "--exclude-promisor-objects"
msgstr "--exclude-promisor-objects"

#. type: Plain text
#: en/git-pack-objects.txt:330
#, priority:80
msgid "Omit objects that are known to be in the promisor remote. (This option has the purpose of operating only on locally created objects, so that when we repack, we still maintain a distinction between locally created objects [without .promisor] and objects from the promisor remote [with .promisor].) This is used with partial clone."
msgstr "省略已知在远程 promisor 中的对象。 （该选项的目的是只对本地创建的对象执行操作，这样当我们重新打包时，仍然可以区分本地创建的对象 [不含 .promisor] 和来自远程 promisor [含 .promisor] 的对象)。 该选项与部分克隆一起使用。"

#. type: Labeled list
#: en/git-pack-objects.txt:331 en/git-repack.txt:212
#, ignore-same, no-wrap, priority:100
msgid "--keep-unreachable"
msgstr "--keep-unreachable"

#. type: Plain text
#: en/git-pack-objects.txt:336
#, placeholders:'--unpacked=':'`--revs`', priority:80
msgid "Objects unreachable from the refs in packs named with --unpacked= option are added to the resulting pack, in addition to the reachable objects that are not in packs marked with *.keep files. This implies `--revs`."
msgstr "除了标有 *.keep 文件的包中没有的可到达对象之外，用 --unpacked= 选项命名的包中的引用无法到达的对象也会被添加到生成的包中。这意味着`--revs`。"

#. type: Labeled list
#: en/git-pack-objects.txt:337
#, ignore-same, no-wrap, priority:80
msgid "--pack-loose-unreachable"
msgstr "--pack-loose-unreachable"

#. type: Plain text
#: en/git-pack-objects.txt:340
#, placeholders:'`--revs`', priority:80
msgid "Pack unreachable loose objects (and their loose counterparts removed). This implies `--revs`."
msgstr "打包不可达的松散对象（并移除它们的松散对应对象）。这意味着`--revs`."

#. type: Labeled list
#: en/git-pack-objects.txt:341
#, ignore-same, no-wrap, priority:80
msgid "--unpack-unreachable"
msgstr "--unpack-unreachable"

#. type: Plain text
#: en/git-pack-objects.txt:343
#, placeholders:'`--revs`', priority:80
msgid "Keep unreachable objects in loose form. This implies `--revs`."
msgstr "以松散的形式保存无法访问的对象。这意味着 `--revs`。"

#. type: Labeled list
#: en/git-pack-objects.txt:344 en/git-repack.txt:219
#, ignore-same, no-wrap, priority:100
msgid "--delta-islands"
msgstr "--delta-islands"

#. type: Plain text
#: en/git-pack-objects.txt:347
#, priority:80
msgid "Restrict delta matches based on \"islands\". See DELTA ISLANDS below."
msgstr "根据 “岛屿” 限制增量匹配。请参阅下文的增量匹配。"

#. type: Title -
#: en/git-pack-objects.txt:350
#, no-wrap, priority:80
msgid "DELTA ISLANDS"
msgstr "DELTA ISLANDS"

#. type: Plain text
#: en/git-pack-objects.txt:362
#, priority:80
msgid "When possible, `pack-objects` tries to reuse existing on-disk deltas to avoid having to search for new ones on the fly. This is an important optimization for serving fetches, because it means the server can avoid inflating most objects at all and just send the bytes directly from disk. This optimization can't work when an object is stored as a delta against a base which the receiver does not have (and which we are not already sending). In that case the server \"breaks\" the delta and has to find a new one, which has a high CPU cost. Therefore it's important for performance that the set of objects in on-disk delta relationships match what a client would fetch."
msgstr "在可能的情况下， `pack-objects` 尝试重用现有的磁盘上的 deltas，以避免临时搜索新的 deltas。这对于服务获取来说是一个重要的优化，因为它意味着服务器可以完全避免膨胀大多数对象，而只是直接从磁盘发送字节。当一个对象以 delta 的形式存储，而接收者并不拥有（而且我们也没有发送）这个基数时，这种优化就不起作用了。在这种情况下，服务器将 “中断” delta，并必须找到一个新的delta，这将产生很高的 CPU 成本。因此，磁盘上 delta 关系中的对象集必须与客户端获取的对象相匹配，这对性能非常重要。"

#. type: Plain text
#: en/git-pack-objects.txt:367
#, priority:80
msgid "In a normal repository, this tends to work automatically. The objects are mostly reachable from the branches and tags, and that's what clients fetch. Any deltas we find on the server are likely to be between objects the client has or will have."
msgstr "在正常的仓库中，这往往是自动进行的。对象大多可以从分支和标签中获取，这也是客户端获取的内容。我们在服务器上发现的任何脱节都可能是客户端已经拥有或将要拥有的对象之间的脱节。"

#. type: Plain text
#: en/git-pack-objects.txt:377
#, placeholders:'GIT_NAMESPACE', priority:80
msgid "But in some repository setups, you may have several related but separate groups of ref tips, with clients tending to fetch those groups independently. For example, imagine that you are hosting several \"forks\" of a repository in a single shared object store, and letting clients view them as separate repositories through `GIT_NAMESPACE` or separate repos using the alternates mechanism. A naive repack may find that the optimal delta for an object is against a base that is only found in another fork. But when a client fetches, they will not have the base object, and we'll have to find a new delta on the fly."
msgstr "但在某些仓库设置中，您可能有几个相关但独立的引用提示组，客户端倾向于独立获取这些组。例如，假设你在一个共享对象存储空间中托管了多个版本库的 \"fork\"，并通过`GIT_NAMESPACE`或使用替代机制的独立仓库让客户端将它们视为独立的仓库。天真的 repack 可能会发现，一个对象的最佳 delta 是针对只有在另一个 fork 中才能找到的基数。但是，当客户端获取时，他们将没有基础对象，我们将不得不临时找到一个新的 delta。"

#. type: Plain text
#: en/git-pack-objects.txt:383
#, priority:80
msgid "A similar situation may exist if you have many refs outside of `refs/heads/` and `refs/tags/` that point to related objects (e.g., `refs/pull` or `refs/changes` used by some hosting providers). By default, clients fetch only heads and tags, and deltas against objects found only in those other groups cannot be sent as-is."
msgstr "如果在 `refs/heads/` 和 `refs/tags/` 之外有许多指向相关对象的引用（例如，某些托管提供商使用的 `refs/pull` 或 `refs/changes`），也可能存在类似的情况。默认情况下，客户端只获取 heads 和 tags，因此不能发送只在这些组中找到的对象的 deltas。"

#. type: Plain text
#: en/git-pack-objects.txt:391
#, priority:80
msgid "Delta islands solve this problem by allowing you to group your refs into distinct \"islands\". Pack-objects computes which objects are reachable from which islands, and refuses to make a delta from an object `A` against a base which is not present in all of `A`'s islands. This results in slightly larger packs (because we miss some delta opportunities), but guarantees that a fetch of one island will not have to recompute deltas on the fly due to crossing island boundaries."
msgstr "Delta 岛解决了这个问题，它允许您将您的引用分组为不同的 “岛”。Pack-objects 会计算哪些对象可以从哪些岛屿到达，并拒绝从对象 `A` 针对不存在于所有 `A` 岛屿中的基准进行 delta。这会导致数据包略微变大(因为我们错过了一些 delta 机会)，但保证了对一个岛的取值不会因为跨越岛的边界而不得不重新计算 delta。"

#. type: Plain text
#: en/git-pack-objects.txt:397
#, placeholders:'--window', priority:80
msgid "When repacking with delta islands the delta window tends to get clogged with candidates that are forbidden by the config. Repacking with a big --window helps (and doesn't take as long as it otherwise might because we can reject some object pairs based on islands before doing any computation on the content)."
msgstr "当使用 delta 岛重新打包时，delta 窗口往往会被配置禁止的候选对象堵塞。使用大的 --window 进行重新打包会有所帮助（而且不会像其他情况下花费那么长的时间，因为在对内容进行任何计算之前，我们可以根据岛拒绝一些对象对）。"

#. type: Plain text
#: en/git-pack-objects.txt:401
#, placeholders:'pack.island', priority:80
msgid "Islands are configured via the `pack.island` option, which can be specified multiple times. Each value is a left-anchored regular expressions matching refnames. For example:"
msgstr "岛是通过 `pack.island` 选项配置的，可以多次指定。每个值都是匹配 refnames 的左锚正则表达式。例如 :"

#. type: delimited block -
#: en/git-pack-objects.txt:406
#, no-wrap, priority:80
msgid ""
"[pack]\n"
"island = refs/heads/\n"
"island = refs/tags/\n"
msgstr ""
"[pack]\n"
"island = refs/heads/\n"
"island = refs/tags/\n"

#. type: Plain text
#: en/git-pack-objects.txt:413
#, priority:80
msgid "puts heads and tags into an island (whose name is the empty string; see below for more on naming). Any refs which do not match those regular expressions (e.g., `refs/pull/123`) is not in any island. Any object which is reachable only from `refs/pull/` (but not heads or tags) is therefore not a candidate to be used as a base for `refs/heads/`."
msgstr "将 heads 和 tags 放入一个 “岛” 中（其名称为空字符串；有关命名的更多信息，请参阅下文）。任何不匹配这些正则表达式的引用（例如 `refs/pull/123`）都不在任何岛中。因此，任何只能从 `refs/pull/` (而不能从 heads 或 tags) 访问的对象都不能作为 `refs/heads/` 的基础。"

#. type: Plain text
#: en/git-pack-objects.txt:421
#, priority:80
msgid "Refs are grouped into islands based on their \"names\", and two regexes that produce the same name are considered to be in the same island. The names are computed from the regexes by concatenating any capture groups from the regex, with a '-' dash in between. (And if there are no capture groups, then the name is the empty string, as in the above example.) This allows you to create arbitrary numbers of islands. Only up to 14 such capture groups are supported though."
msgstr "参考文件根据其 “名称” 分组，产生相同名称的两个 regex 被视为在同一个岛中。名称是通过连接 regex 中的任何捕获组和中间的 '-' 破折号来计算的。(如果没有捕获组，则名称为空字符串，如上例）。这允许您创建任意数量的岛屿。但最多只支持 14 个这样的捕获组。"

#. type: Plain text
#: en/git-pack-objects.txt:425
#, priority:80
msgid "For example, imagine you store the refs for each fork in `refs/virtual/ID`, where `ID` is a numeric identifier. You might then configure:"
msgstr "例如，假设你在 `refs/virtual/ID` 中存储了每个 fork 的引用，其中 `ID` 是一个数字标识符。然后您可以配置 :"

#. type: delimited block -
#: en/git-pack-objects.txt:431
#, no-wrap, priority:80
msgid ""
"[pack]\n"
"island = refs/virtual/([0-9]+)/heads/\n"
"island = refs/virtual/([0-9]+)/tags/\n"
"island = refs/virtual/([0-9]+)/(pull)/\n"
msgstr ""
"[pack]\n"
"island = refs/virtual/([0-9]+)/heads/\n"
"island = refs/virtual/([0-9]+)/tags/\n"
"island = refs/virtual/([0-9]+)/(pull)/\n"

#. type: Plain text
#: en/git-pack-objects.txt:436
#, priority:80
msgid "That puts the heads and tags for each fork in their own island (named \"1234\" or similar), and the pull refs for each go into their own \"1234-pull\"."
msgstr "这就将每个分叉的头和标签放在自己的岛（命名为 \"1234\" 或类似的名字）中，而每个分叉的拉动参考则放在自己的 \"1234-pull \"中。"

#. type: Plain text
#: en/git-pack-objects.txt:440
#, priority:80
msgid "Note that we pick a single island for each regex to go into, using \"last one wins\" ordering (which allows repo-specific config to take precedence over user-wide config, and so forth)."
msgstr "请注意，我们为每个 regex 选择一个单独的岛，使用 \"最后一个获胜\" 的排序（这允许特定于仓库的配置优先于用户范围内的配置，等等）。"

#. type: Plain text
#: en/git-pack-objects.txt:447 en/git-repack.txt:257
#, placeholders:'linkgit:git-config[1]', priority:100
msgid "Various configuration variables affect packing, see linkgit:git-config[1] (search for \"pack\" and \"delta\")."
msgstr "各种配置变量会影响打包，参见 linkgit:git-config[1] (搜索 \"pack\" 和 \"delta\")。"

#. type: Plain text
#: en/git-pack-objects.txt:451
#, placeholders:'core.bigFileThreshold', priority:80
msgid "Notably, delta compression is not used on objects larger than the `core.bigFileThreshold` configuration variable and on files with the attribute `delta` set to false."
msgstr "值得注意的是，delta 压缩不用于大于 `core.bigFileThreshold` 配置变量的对象和属性 `delta` 设置为 false 的文件。"

#. type: Plain text
#: en/git-pack-objects.txt:457
#, ignore-same, priority:80
msgid "linkgit:git-rev-list[1] linkgit:git-repack[1] linkgit:git-prune-packed[1]"
msgstr "linkgit:git-rev-list[1] linkgit:git-repack[1] linkgit:git-prune-packed[1]"

#. type: Title =
#: en/git-pack-redundant.txt:2
#, ignore-same, no-wrap, priority:80
msgid "git-pack-redundant(1)"
msgstr "git-pack-redundant(1)"

#. type: Plain text
#: en/git-pack-redundant.txt:7
#, placeholders:'git-pack-redundant', priority:80
msgid "git-pack-redundant - Find redundant pack files"
msgstr "git-pack-redundant - 查找多余的软件包文件"

#. type: Plain text
#: en/git-pack-redundant.txt:13
#, ignore-ellipsis, no-wrap, placeholders:'git pack-redundant':'[--verbose]':'[--alt-odb]':'--all', priority:80
msgid "'git pack-redundant' [--verbose] [--alt-odb] (--all | <pack-filename>...)\n"
msgstr "'git pack-redundant' [--verbose] [--alt-odb] (--all | <包文件名>...)\n"

#. type: Plain text
#: en/git-pack-redundant.txt:21
#, placeholders:'git pack-redundant', priority:80
msgid "`git pack-redundant` has been deprecated and is scheduled for removal in a future version of Git. Because it can only remove entire duplicate packs and not individual duplicate objects, it is generally not a useful tool for reducing repository size. You are better off using `git gc` to do so, which will put objects into a new pack, removing duplicates."
msgstr "`git pack-redundant` 已被弃用，并计划在未来的 Git 版本中移除。因为它只能移除整个重复的包，而不能移除单个重复的对象，所以它通常不是减少版本库大小的有用工具。最好使用 `git gc`，它会将对象放入一个新的包，删除重复的对象。"

#. type: Plain text
#: en/git-pack-redundant.txt:27
#, placeholders:'`--i-still-use-this`':'vger.kernel.org':'git-scm', priority:80
msgid "Running `pack-redundant` without the `--i-still-use-this` flag will fail in this release. If you believe you have a use case for which `pack-redundant` is better suited and oppose this removal, please contact the Git mailing list at git@vger.kernel.org. More information about the list is available at https://git-scm.com/community."
msgstr "在此版本中，运行不带 `--i-still-use-this` 标志的`pack-redundant` 将失败。如果您认为 `pack-redundant` 更适合您的用例，并反对删除该标志，请联系 Git 邮件列表 git@vger.kernel.org。有关该列表的更多信息，请访问 https://git-scm.com/community。"

#. type: Plain text
#: en/git-pack-redundant.txt:33
#, priority:80
msgid "This program computes which packs in your repository are redundant. The output is suitable for piping to `xargs rm` if you are in the root of the repository."
msgstr "该程序计算仓库中哪些包是多余的。如果你在仓库的根目录下，输出结果可以通过管道连接到 `xargs rm`。"

#. type: Plain text
#: en/git-pack-redundant.txt:38
#, placeholders:'git pack-redundant', priority:80
msgid "'git pack-redundant' accepts a list of objects on standard input. Any objects given will be ignored when checking which packs are required. This makes the following command useful when wanting to remove packs which contain unreachable objects."
msgstr "'git pack-redundant' 接受标准输入的对象列表。在检查需要哪些包时，给定的对象将被忽略。这使得下面的命令在移除包含不可达对象的包时非常有用。"

#. type: Plain text
#: en/git-pack-redundant.txt:41
#, placeholders:'--full':'--unreachable':'git pack-redundant':'--all', priority:80
msgid "git fsck --full --unreachable | cut -d ' ' -f3 | \\ git pack-redundant --all | xargs rm"
msgstr "git fsck --full --unreachable | cut -d ' ' -f3 | \\ git pack-redundant --all | xargs rm"

#. type: Plain text
#: en/git-pack-redundant.txt:48
#, priority:80
msgid "Processes all packs. Any filenames on the command line are ignored."
msgstr "处理所有数据包。忽略命令行中的任何文件名。"

#. type: Labeled list
#: en/git-pack-redundant.txt:49
#, ignore-same, no-wrap, priority:80
msgid "--alt-odb"
msgstr "--alt-odb"

#. type: Plain text
#: en/git-pack-redundant.txt:52
#, priority:80
msgid "Don't require objects present in packs from alternate object database (odb) directories to be present in local packs."
msgstr "不要求来自备用对象数据库（odb）目录的数据包中的对象也出现在本地数据包中。"

#. type: Plain text
#: en/git-pack-redundant.txt:55
#, priority:80
msgid "Outputs some statistics to stderr. Has a small performance penalty."
msgstr "向标注错误流输出一些统计数据。对性能有一点影响。"

#. type: Plain text
#: en/git-pack-redundant.txt:61
#, ignore-same, priority:80
msgid "linkgit:git-pack-objects[1] linkgit:git-repack[1] linkgit:git-prune-packed[1]"
msgstr "linkgit:git-pack-objects[1] linkgit:git-repack[1] linkgit:git-prune-packed[1]"

#. type: Title =
#: en/git-pack-refs.txt:2
#, ignore-same, no-wrap, priority:80
msgid "git-pack-refs(1)"
msgstr "git-pack-refs(1)"

#. type: Plain text
#: en/git-pack-refs.txt:7
#, placeholders:'git-pack-refs', priority:80
msgid "git-pack-refs - Pack heads and tags for efficient repository access"
msgstr "git-pack-refs - 打包头和标签，以便有效地访问仓库"

#. type: Plain text
#: en/git-pack-refs.txt:12
#, no-wrap, placeholders:'git pack-refs':'[--all]':'[--no-prune]':'[--include':'[--exclude', priority:80
msgid "'git pack-refs' [--all] [--no-prune] [--include <pattern>] [--exclude <pattern>]\n"
msgstr "'git pack-refs' [--all] [--no-prune] [--include <模式>] [--exclude <模式>]\n"

#. type: Plain text
#: en/git-pack-refs.txt:24
#, placeholders:'$GIT_DIR', priority:80
msgid "Traditionally, tips of branches and tags (collectively known as 'refs') were stored one file per ref in a (sub)directory under `$GIT_DIR/refs` directory. While many branch tips tend to be updated often, most tags and some branch tips are never updated. When a repository has hundreds or thousands of tags, this one-file-per-ref format both wastes storage and hurts performance."
msgstr "传统上，分支和标签的提示（统称为 'refs'）是在 `$GIT_DIR/refs` 目录下的一个（子）目录中，为每个引用储存一个文件。 虽然许多分支的提示经常被更新，但大多数标签和一些分支的提示从未被更新。 当一个仓库库有成百上千的标签时，这种每个引用一个文件的格式既浪费了存储空间，又损害了性能。"

#. type: Plain text
#: en/git-pack-refs.txt:31
#, placeholders:'$GIT_DIR':'$GIT_DIR', priority:80
msgid "This command is used to solve the storage and performance problem by storing the refs in a single file, `$GIT_DIR/packed-refs`. When a ref is missing from the traditional `$GIT_DIR/refs` directory hierarchy, it is looked up in this file and used if found."
msgstr "这个命令是用来解决存储和性能问题的，将引用存储在一个文件中，`$GIT_DIR/packed-refs`。 当传统的 `$GIT_DIR/refs`目录层次中缺少一个引用时，就在这个文件中查找，如果找到就使用。"

#. type: Plain text
#: en/git-pack-refs.txt:34
#, placeholders:'$GIT_DIR', priority:80
msgid "Subsequent updates to branches always create new files under `$GIT_DIR/refs` directory hierarchy."
msgstr "分支的后续更新总是在 `$GIT_DIR/refs` 目录层次下创建新文件。"

#. type: Plain text
#: en/git-pack-refs.txt:43
#, placeholders:'`--all`':'git pack-refs':'--all`':'`--all`', priority:80
msgid "A recommended practice to deal with a repository with too many refs is to pack its refs with `--all` once, and occasionally run `git pack-refs`. Tags are by definition stationary and are not expected to change. Branch heads will be packed with the initial `pack-refs --all`, but only the currently active branch heads will become unpacked, and the next `pack-refs` (without `--all`) will leave them unpacked."
msgstr "处理一个有太多引用的仓库的推荐做法是，用 `--all` 来打包它的引用一次，然后偶尔运行 `git pack-refs` 。 根据定义，标签是固定的，不应该改变。 分支头会被初始的 `pack-refs --all` 打包，但只有当前活动的分支头会被解压，下一次 `pack-refs`（没有 `--all`）会让它们被解压。"

#. type: Plain text
#: en/git-pack-refs.txt:57
#, priority:80
msgid "The command by default packs all tags and refs that are already packed, and leaves other refs alone. This is because branches are expected to be actively developed and packing their tips does not help performance. This option causes all refs to be packed as well, with the exception of hidden refs, broken refs, and symbolic refs. Useful for a repository with many branches of historical interests."
msgstr "该命令默认打包所有已打包的标签和引用，而不打包其他引用。 这是因为分支会被积极开发，打包它们的提示无助于提高性能。 该选项会导致所有 引用也被打包，但隐藏引用、破损引用和符号引用除外。对于有许多具有历史意义的分支的仓库来说非常有用。"

#. type: Plain text
#: en/git-pack-refs.txt:62
#, placeholders:'$GIT_DIR', priority:80
msgid "The command usually removes loose refs under `$GIT_DIR/refs` hierarchy after packing them. This option tells it not to."
msgstr "该命令通常在打包后删除 `$GIT_DIR/refs` 层次下的松散引用。 这个选项告诉它不要这样做。"

#. type: Labeled list
#: en/git-pack-refs.txt:63
#, no-wrap, placeholders:'--include', priority:80
msgid "--include <pattern>"
msgstr "--include <模式>"

#. type: Plain text
#: en/git-pack-refs.txt:71
#, placeholders:'`--include`':'`--exclude`':'`--exclude`':'`--include`':'`--all`':'`--no-include`', priority:80
msgid "Pack refs based on a `glob(7)` pattern. Repetitions of this option accumulate inclusion patterns. If a ref is both included in `--include` and `--exclude`, `--exclude` takes precedence. Using `--include` will preclude all tags from being included by default. Symbolic refs and broken refs will never be packed. When used with `--all`, it will be a noop. Use `--no-include` to clear and reset the list of patterns."
msgstr "根据 `glob(7)` 模式打包引用。重复使用该选项会累积包含模式。如果一个引用同时包含在 `--include` 和 `--exclude` 中，则 `--exclude` 优先。使用 `--include` 会默认排除所有标记。符号引用和断开的引用将永远不会被打包。与 `--all` 一起使用时，它将是一个 空操作。使用 `--no-include` 清除并重置模式列表。"

#. type: Plain text
#: en/git-pack-refs.txt:78
#, placeholders:'`--no-exclude`':'`--exclude`', priority:80
msgid "Do not pack refs matching the given `glob(7)` pattern. Repetitions of this option accumulate exclusion patterns. Use `--no-exclude` to clear and reset the list of patterns. If a ref is already packed, including it with `--exclude` will not unpack it."
msgstr "不打包与给定的 `glob(7)` 模式匹配的引用。重复使用此选项会累积排除模式。使用 `--no-exclude` 可以清除并重置模式列表。如果一个引用已经打包，使用 `--exclude`不会将其解包。"

#. type: Plain text
#: en/git-pack-refs.txt:81
#, placeholders:'`--all`':'`--exclude`', priority:80
msgid "When used with `--all`, pack only loose refs which do not match any of the provided `--exclude` patterns."
msgstr "与 `--all` 一起使用时，只打包与所提供的 `--exclude` 模式不匹配的松散引用。"

#. type: Plain text
#: en/git-pack-refs.txt:84
#, placeholders:'`--include`':'`--include`':'`--exclude`', priority:80
msgid "When used with `--include`, refs provided to `--include`, minus refs that are provided to `--exclude` will be packed."
msgstr "当与 `--include` 一起使用时，提供给 `--include` 的引用减去提供给 `--exclude` 的引用将被打包。"

#. type: Plain text
#: en/git-pack-refs.txt:92
#, priority:80
msgid "Older documentation written before the packed-refs mechanism was introduced may still say things like \".git/refs/heads/<branch> file exists\" when it means \"branch <branch> exists\"."
msgstr "在引入 packed-refs 机制之前编写的旧文档可能仍然会说 \".git/refs/heads/<branch>文件存在\" 这样的话，而它的意思是 \"<branch> 分支存在\"。"

#. type: Title =
#: en/git-patch-id.txt:2
#, ignore-same, no-wrap, priority:80
msgid "git-patch-id(1)"
msgstr "git-patch-id(1)"

#. type: Plain text
#: en/git-patch-id.txt:7
#, placeholders:'git-patch-id', priority:80
msgid "git-patch-id - Compute unique ID for a patch"
msgstr "git-patch-id - 计算补丁的唯一 ID"

#. type: Plain text
#: en/git-patch-id.txt:12
#, no-wrap, placeholders:'git patch-id':'[--stable':'--unstable':'--verbatim]', priority:80
msgid "'git patch-id' [--stable | --unstable | --verbatim]\n"
msgstr "'git patch-id' [--stable | --unstable | --verbatim]\n"

#. type: Plain text
#: en/git-patch-id.txt:16
#, priority:80
msgid "Read a patch from the standard input and compute the patch ID for it."
msgstr "从标准输入读取一个补丁，并计算出它的补丁 ID。"

#. type: Plain text
#: en/git-patch-id.txt:21
#, priority:80
msgid "A \"patch ID\" is nothing but a sum of SHA-1 of the file diffs associated with a patch, with line numbers ignored. As such, it's \"reasonably stable\", but at the same time also reasonably unique, i.e., two patches that have the same \"patch ID\" are almost guaranteed to be the same thing."
msgstr "\"补丁ID\" 只不过是一个与补丁相关的文件差异的 SHA-1 之和，行号被忽略。 因此，它是 \"相当稳定的\"，但同时也是相当独特的，也就是说，两个具有相同 \"补丁ID\" 的补丁几乎可以保证是同一个东西。"

#. type: Plain text
#: en/git-patch-id.txt:23
#, priority:80
msgid "The main usecase for this command is to look for likely duplicate commits."
msgstr "这个命令的主要用途是寻找可能的重复提交。"

#. type: Plain text
#: en/git-patch-id.txt:29
#, placeholders:'git diff-tree', priority:80
msgid "When dealing with 'git diff-tree' output, it takes advantage of the fact that the patch is prefixed with the object name of the commit, and outputs two 40-byte hexadecimal strings. The first string is the patch ID, and the second string is the commit ID. This can be used to make a mapping from patch ID to commit ID."
msgstr "在处理 'git diff-tree' 输出时，它利用了补丁的前缀是提交的对象名称这一事实，并输出两个 40 字节的十六进制字符串。 第一个字符串是补丁的 ID，第二个字符串是提交的 ID。 这可以用来做一个从补丁ID 到提交 ID 的映射。"

#. type: Labeled list
#: en/git-patch-id.txt:33
#, ignore-same, no-wrap, priority:80
msgid "--verbatim"
msgstr "--verbatim"

#. type: Plain text
#: en/git-patch-id.txt:36
#, priority:80
msgid "Calculate the patch-id of the input as it is given, do not strip any whitespace."
msgstr "计算输入的补丁 ID，因为它是给定的，不要剥离任何空白字符。"

#. type: Plain text
#: en/git-patch-id.txt:38
#, placeholders:'patchid.verbatim', priority:80
msgid "This is the default if patchid.verbatim is true."
msgstr "如果 patchid.verbatim 为真，这是默认的。"

#. type: Labeled list
#: en/git-patch-id.txt:39
#, ignore-same, no-wrap, priority:80
msgid "--stable"
msgstr "--stable"

#. type: Plain text
#: en/git-patch-id.txt:41
#, priority:80
msgid "Use a \"stable\" sum of hashes as the patch ID. With this option:"
msgstr "使用一个 \"稳定的\" 哈希值之和作为补丁 ID。有了这个选项："

#. type: Plain text
#: en/git-patch-id.txt:47
#, priority:80
msgid "Reordering file diffs that make up a patch does not affect the ID. In particular, two patches produced by comparing the same two trees with two different settings for \"-O<orderfile>\" result in the same patch ID signature, thereby allowing the computed result to be used as a key to index some meta-information about the change between the two trees;"
msgstr "对组成补丁的文件差异进行重新排序并不影响 ID。 特别是，用两个不同的 \"-O<顺序文件>\" 设置比较相同的两棵目录树所产生的两个补丁，会产生相同的补丁 ID 签名，从而允许计算结果被用作索引两个树之间变化的一些元信息的关键；"

#. type: Plain text
#: en/git-patch-id.txt:53
#, placeholders:'--unstable', priority:80
msgid "Result is different from the value produced by git 1.9 and older or produced when an \"unstable\" hash (see --unstable below) is configured - even when used on a diff output taken without any use of \"-O<orderfile>\", thereby making existing databases storing such \"unstable\" or historical patch-ids unusable."
msgstr "结果与 git 1.9 及更早版本产生的值不同，或者在配置了 \"不稳定\" 哈希值（见下文 --unstable）时产生的值不同——即使在没有使用 \"-O<orderfile>\" 的情况下用于 diff 输出，从而使存储这种 \"不稳定“或历史补丁标识的现有数据库无法使用。"

#. type: Plain text
#: en/git-patch-id.txt:55
#, priority:80
msgid "All whitespace within the patch is ignored and does not affect the id."
msgstr "补丁中的所有空白都将被忽略，并且不影响 id。"

#. type: Plain text
#: en/git-patch-id.txt:57
#, no-wrap, placeholders:'patchid.stable', priority:80
msgid "This is the default if patchid.stable is set to true.\n"
msgstr "如果 patchid.stable 设置为 true，则默认使用此值。\n"

#. type: Labeled list
#: en/git-patch-id.txt:58
#, ignore-same, no-wrap, priority:80
msgid "--unstable"
msgstr "--unstable"

#. type: Plain text
#: en/git-patch-id.txt:64
#, priority:80
msgid "Use an \"unstable\" hash as the patch ID. With this option, the result produced is compatible with the patch-id value produced by git 1.9 and older and whitespace is ignored. Users with pre-existing databases storing patch-ids produced by git 1.9 and older (who do not deal with reordered patches) may want to use this option."
msgstr "使用 “不稳定” 哈希值作为补丁 ID。有了这个选项，产生的结果与 git 1.9 及更早版本产生的补丁 ID 值兼容，空白被忽略。 如果您的数据库中已有 git 1.9 及更早版本产生的补丁标识（不处理重新排序的补丁），可能需要使用此选项。"

#. type: Plain text
#: en/git-patch-id.txt:66
#, priority:80
msgid "This is the default."
msgstr "这是默认设置。"

#. type: Title =
#: en/git-prune-packed.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-prune-packed(1)"
msgstr "git-prune-packed(1)"

#. type: Plain text
#: en/git-prune-packed.txt:7
#, placeholders:'git-prune-packed', priority:100
msgid "git-prune-packed - Remove extra objects that are already in pack files"
msgstr "git-prune-packed - 删除软件包文件中已有的额外对象"

#. type: Plain text
#: en/git-prune-packed.txt:13
#, no-wrap, placeholders:'git prune-packed':'--dry-run]':'--quiet]', priority:100
msgid "'git prune-packed' [-n | --dry-run] [-q | --quiet]\n"
msgstr "'git prune-packed' [-n|--dry-run] [-q|--quiet]\n"

#. type: Plain text
#: en/git-prune-packed.txt:19
#, placeholders:'$GIT_OBJECT_DIRECTORY', priority:100
msgid "This program searches the `$GIT_OBJECT_DIRECTORY` for all objects that currently exist in a pack file as well as in the independent object directories."
msgstr "这个程序会搜索 `$GIT_OBJECT_DIRECTORY` 所有当前存在于包文件中的对象以及独立的对象目录。"

#. type: Plain text
#: en/git-prune-packed.txt:21
#, priority:100
msgid "All such extra objects are removed."
msgstr "所有这些额外的对象都会被删除。"

#. type: Plain text
#: en/git-prune-packed.txt:24 en/git-repack.txt:24
#, priority:100
msgid "A pack is a collection of objects, individually compressed, with delta compression applied, stored in a single file, with an associated index file."
msgstr "压缩包是对象的集合，单独压缩，应用 delta 压缩，存储在单个文件中，并带有相关索引文件。"

#. type: Plain text
#: en/git-prune-packed.txt:27 en/git-repack.txt:27
#, priority:100
msgid "Packs are used to reduce the load on mirror systems, backup engines, disk storage, etc."
msgstr "软件包用于减少镜像系统、备份引擎、磁盘存储等的负载。"

#. type: Plain text
#: en/git-prune-packed.txt:35
#, priority:100
msgid "Don't actually remove any objects, only show those that would have been removed."
msgstr "实际不删除任何对象，只显示本应删除的对象。"

#. type: Plain text
#: en/git-prune-packed.txt:39
#, priority:100
msgid "Squelch the progress indicator."
msgstr "关闭进度指示器。"

#. type: Plain text
#: en/git-prune-packed.txt:44
#, ignore-same, priority:100
msgid "linkgit:git-pack-objects[1] linkgit:git-repack[1]"
msgstr "linkgit:git-pack-objects[1] linkgit:git-repack[1]"

#. type: Title =
#: en/git-prune.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-prune(1)"
msgstr "git-prune(1)"

#. type: Plain text
#: en/git-prune.txt:7
#, placeholders:'git-prune', priority:100
msgid "git-prune - Prune all unreachable objects from the object database"
msgstr "git-prune - 从对象数据库中删除所有无法访问的对象"

#. type: Plain text
#: en/git-prune.txt:13
#, ignore-ellipsis, no-wrap, placeholders:'[--progress]':'[--expire', priority:100
msgid "'git prune' [-n] [-v] [--progress] [--expire <time>] [--] [<head>...]\n"
msgstr "'git prune' [-n] [-v] [--progress] [--expire <时间>] [--] [<头>...]\n"

#. type: Plain text
#: en/git-prune.txt:19
#, priority:100
msgid "In most cases, users should run 'git gc', which calls 'git prune'. See the section \"NOTES\", below."
msgstr "在大多数情况下，用户应该运行 'git gc'，它调用 'git prune'。参见下文 “注意” 一节。"

#. type: Plain text
#: en/git-prune.txt:29
#, placeholders:'--unreachable':'git prune-packed', priority:100
msgid "This runs 'git fsck --unreachable' using all the refs available in `refs/`, optionally with an additional set of objects specified on the command line, and prunes all unpacked objects unreachable from any of these head objects from the object database. In addition, it prunes the unpacked objects that are also found in packs by running 'git prune-packed'. It also removes entries from .git/shallow that are not reachable by any ref."
msgstr "运行 'git fsck --unreachable'，使用 `refs/` 中可用的所有引用，可选地使用命令行中指定的附加对象集，并从对象数据库中删除所有从这些头对象中无法访问的未打包对象。 此外，它还会删除通过运行 'git prune-packed' 在包中找到的未打包对象。 它还会删除 .git/shallow 中任何引用都无法访问的条目。"

#. type: Plain text
#: en/git-prune.txt:32
#, placeholders:'linkgit:git-repack[1]', priority:100
msgid "Note that unreachable, packed objects will remain. If this is not desired, see linkgit:git-repack[1]."
msgstr "需要注意的是，无法到达的打包对象将被保留。 如果不希望这样，请参见 linkgit:git-repack[1]。"

#. type: Plain text
#: en/git-prune.txt:40
#, priority:100
msgid "Do not remove anything; just report what it would remove."
msgstr "不删除任何内容；只需报告将删除的内容。"

#. type: Plain text
#: en/git-prune.txt:44
#, priority:100
msgid "Report all removed objects."
msgstr "报告所有移除的对象。"

#. type: Plain text
#: en/git-prune.txt:47
#, priority:100
msgid "Show progress."
msgstr "显示进度。"

#. type: Labeled list
#: en/git-prune.txt:48 en/git-worktree.txt:261
#, no-wrap, placeholders:'--expire', priority:240
msgid "--expire <time>"
msgstr "--expire <时间>"

#. type: Plain text
#: en/git-prune.txt:50
#, priority:100
msgid "Only expire loose objects older than <time>."
msgstr "仅过期超过 <时间> 的松散对象。"

#. type: Labeled list
#: en/git-prune.txt:54
#, ignore-ellipsis, no-wrap, priority:100
msgid "<head>..."
msgstr "<head>..."

#. type: Plain text
#: en/git-prune.txt:58
#, priority:100
msgid "In addition to objects reachable from any of our references, keep objects reachable from listed <head>s."
msgstr "除了可从我们的任何引用到达的对象外，还保留可从列出的 <head> 到达的对象。"

#. type: Plain text
#: en/git-prune.txt:65
#, priority:100
msgid "To prune objects not used by your repository or another that borrows from your repository via its `.git/objects/info/alternates`:"
msgstr "剪切您的仓库或其他通过 `.git/objects/info/alternates` 借用您仓库的仓库不使用的对象："

#. type: delimited block -
#: en/git-prune.txt:68
#, no-wrap, placeholders:'git rev-parse':'--all', priority:100
msgid "$ git prune $(cd ../another && git rev-parse --all)\n"
msgstr "$ git prune $(cd ../another && git rev-parse --all)\n"

#. type: Plain text
#: en/git-prune.txt:76
#, priority:100
msgid "In most cases, users will not need to call 'git prune' directly, but should instead call 'git gc', which handles pruning along with many other housekeeping tasks."
msgstr "在大多数情况下，用户不需要直接调用 'git prune'，而应该调用 'git gc'，它可以处理剪枝和许多其他内务工作。"

#. type: Plain text
#: en/git-prune.txt:79
#, placeholders:'--unreachable', priority:100
msgid "For a description of which objects are considered for pruning, see 'git fsck''s --unreachable option."
msgstr "关于哪些对象会被考虑剪枝，请参见 'git fsck' 的 --unreachable 选项。"

#. type: Plain text
#: en/git-prune.txt:86
#, ignore-same, priority:100
msgid "linkgit:git-fsck[1], linkgit:git-gc[1], linkgit:git-reflog[1]"
msgstr "linkgit:git-fsck[1], linkgit:git-gc[1], linkgit:git-reflog[1]"

#. type: Title =
#: en/git-pull.txt:2
#, ignore-same, no-wrap, priority:220
msgid "git-pull(1)"
msgstr "git-pull(1)"

#. type: Plain text
#: en/git-pull.txt:7
#, placeholders:'git-pull', priority:220
msgid "git-pull - Fetch from and integrate with another repository or a local branch"
msgstr "git-pull - 从另一个仓库或本地分支撷取并与之集成"

#. type: Plain text
#: en/git-pull.txt:13
#, ignore-ellipsis, no-wrap, priority:220
msgid "'git pull' [<options>] [<repository> [<refspec>...]]\n"
msgstr "'git pull' [<选项>] [<仓库> [<引用规范>...]]\n"

#. type: Plain text
#: en/git-pull.txt:24
#, placeholders:'`--rebase`':'`--no-rebase`':'pull.rebase', priority:220
msgid "Incorporates changes from a remote repository into the current branch. If the current branch is behind the remote, then by default it will fast-forward the current branch to match the remote. If the current branch and the remote have diverged, the user needs to specify how to reconcile the divergent branches with `--rebase` or `--no-rebase` (or the corresponding configuration option in `pull.rebase`)."
msgstr "将远程版本库的修改并入当前分支。 如果当前分支落后于远程分支，那么默认情况下，它将快速合并当前分支以匹配远程分支。 如果当前分支和远程分支有分歧，用户需要用 `--rebase` 或 `--no-rebase`（或 `pull.rebase` 中的相应配置选项）来指定如何调和分歧的分支。"

#. type: Plain text
#: en/git-pull.txt:29
#, priority:220
msgid "More precisely, `git pull` runs `git fetch` with the given parameters and then depending on configuration options or command line flags, will call either `git rebase` or `git merge` to reconcile diverging branches."
msgstr "更确切地说，`git pull` 运行 `git fetch` 并给出参数，然后根据配置选项或命令行标志，调用 `git rebase` 或 `git merge` 来协调不同的分支。"

#. type: Plain text
#: en/git-pull.txt:36
#, placeholders:'linkgit:git-fetch[1]':'{asterisk}':'{asterisk}', priority:220
msgid "<repository> should be the name of a remote repository as passed to linkgit:git-fetch[1]. <refspec> can name an arbitrary remote ref (for example, the name of a tag) or even a collection of refs with corresponding remote-tracking branches (e.g., refs/heads/{asterisk}:refs/remotes/origin/{asterisk}), but usually it is the name of a branch in the remote repository."
msgstr "<仓库> 应该是传递给 linkgit:git-fetch[1] 的远程仓库的名称。 < 用引规范 > 可以命名一个任意的远程引用（例如，一个标签的名称），甚至是一个有相应远程跟踪分支的引用集合（例如，refs/heads/{asterisk}:refs/remotes/origin/{asterisk}），但通常它是远程仓库的一个分支名称。"

#. type: Plain text
#: en/git-pull.txt:40
#, placeholders:'`--track`', priority:220
msgid "Default values for <repository> and <branch> are read from the \"remote\" and \"merge\" configuration for the current branch as set by linkgit:git-branch[1] `--track`."
msgstr "<仓库> 和 < 分支 > 的默认值是从 linkgit:git-branch[1] `--track` 设置的当前分支的 \"远程\" 和 \"合并\" 配置中读取。"

#. type: Plain text
#: en/git-pull.txt:43
#, priority:220
msgid "Assume the following history exists and the current branch is \"`master`\":"
msgstr "假设存在以下历史，且当前分支为\"`master`\"："

#. type: delimited block -
#: en/git-pull.txt:50
#, no-wrap, placeholders:'---B---C':'---E---F---G', priority:220
msgid ""
"\t  A---B---C master on origin\n"
"\t /\n"
"    D---E---F---G master\n"
"\t^\n"
"\torigin/master in your repository\n"
msgstr ""
"\t  A---B---C master on origin\n"
"\t /\n"
"    D---E---F---G master\n"
"\t^\n"
"\t你仓库中的 origin/master\n"

#. type: Plain text
#: en/git-pull.txt:57
#, priority:220
msgid "Then \"`git pull`\" will fetch and replay the changes from the remote `master` branch since it diverged from the local `master` (i.e., `E`) until its current commit (`C`) on top of `master` and record the result in a new commit along with the names of the two parent commits and a log message from the user describing the changes."
msgstr "然后，\"`git pull`\" 将从远程的 `master` 分支获取并重放自它与本地 `master`（即 `E`）分歧以来的变化，直到它在 `master` 之上的当前提交（`C`），并将结果与两个父提交的名称和用户描述变化的日志信息一起记录在一个新提交中。"

#. type: delimited block -
#: en/git-pull.txt:62
#, no-wrap, placeholders:'---B---C':'---E---F---G---H', priority:220
msgid ""
"\t  A---B---C origin/master\n"
"\t /         \\\n"
"    D---E---F---G---H master\n"
msgstr ""
"\t  A---B---C origin/master\n"
"\t /         \\\n"
"    D---E---F---G---H master\n"

#. type: Plain text
#: en/git-pull.txt:66
#, placeholders:'linkgit:git-merge[1]', priority:220
msgid "See linkgit:git-merge[1] for details, including how conflicts are presented and handled."
msgstr "详情见 linkgit:git-merge[1]，包括如何呈现和处理冲突。"

#. type: Plain text
#: en/git-pull.txt:71
#, placeholders:'--merge`', priority:220
msgid "In Git 1.7.0 or later, to cancel a conflicting merge, use `git reset --merge`. *Warning*: In older versions of Git, running 'git pull' with uncommitted changes is discouraged: while possible, it leaves you in a state that may be hard to back out of in the case of a conflict."
msgstr "在 Git 1.7.0 或更高版本中，要取消一个冲突的合并，请使用 `git reset --merge`。 * 警告 *：在旧版本的 Git 中，不鼓励在未提交的情况下运行 \"git pull\"：虽然有可能，但在发生冲突的情况下，会让你处于一个难以恢复的状态。"

#. type: Plain text
#: en/git-pull.txt:76
#, placeholders:'linkgit:git-stash[1]', priority:220
msgid "If any of the remote changes overlap with local uncommitted changes, the merge will be automatically canceled and the work tree untouched. It is generally best to get any local changes in working order before pulling or stash them away with linkgit:git-stash[1]."
msgstr "如果任何远程修改与本地未提交的修改重叠，合并将被自动取消，工作目录树不会被改动。 一般来说，最好是在拉取之前把任何本地的修改弄到工作状态，或者用 linkgit:git-stash[1] 把它们贮藏起来。"

#. type: Plain text
#: en/git-pull.txt:85
#, placeholders:'git-fetch':'git-merge', priority:220
msgid "This is passed to both underlying git-fetch to squelch reporting of during transfer, and underlying git-merge to squelch output during merging."
msgstr "这将被传递给底层的 git-fetch，以便在传输过程中抑制报告，以及底层的 git-merge，以便在合并过程中抑制输出。"

#. type: Plain text
#: en/git-pull.txt:89
#, placeholders:'--verbose':'git-fetch':'git-merge', priority:220
msgid "Pass --verbose to git-fetch and git-merge."
msgstr "将 --verbose 传给 git-fetch 和 git-merge。"

#. type: Labeled list
#: en/git-pull.txt:90
#, ignore-same, no-wrap, priority:220
msgid "--[no-]recurse-submodules[=yes|on-demand|no]"
msgstr "--[no-]recurse-submodules[=yes|on-demand|no]"

#. type: Plain text
#: en/git-pull.txt:95
#, placeholders:'linkgit:git-fetch[1]':'linkgit:git-config[1]':'linkgit:gitmodules[5]', priority:220
msgid "This option controls if new commits of populated submodules should be fetched, and if the working trees of active submodules should be updated, too (see linkgit:git-fetch[1], linkgit:git-config[1] and linkgit:gitmodules[5])."
msgstr "这个选项控制是否应该获取已填充子模块的新提交，以及是否应该更新活动子模块的工作树（见linkgit:git-fetch[1], linkgit:git-config[1] 和 linkgit:gitmodules[5]）。"

#. type: Plain text
#: en/git-pull.txt:97
#, priority:220
msgid "If the checkout is done via rebase, local submodule commits are rebased as well."
msgstr "如果签出是通过变基完成的，那么本地子模块的提交也会被变基。"

#. type: Plain text
#: en/git-pull.txt:99
#, priority:220
msgid "If the update is done via merge, the submodule conflicts are resolved and checked out."
msgstr "如果更新是通过合并完成的，子模块的冲突就会被解决并被检查出来。"

#. type: Title ~
#: en/git-pull.txt:101
#, no-wrap, priority:220
msgid "Options related to merging"
msgstr "与合并有关的选项"

#. type: Labeled list
#: en/git-pull.txt:108
#, ignore-same, no-wrap, priority:220
msgid "--rebase[=false|true|merges|interactive]"
msgstr "--rebase[=false|true|merges|interactive]"

#. type: Plain text
#: en/git-pull.txt:114
#, priority:220
msgid "When true, rebase the current branch on top of the upstream branch after fetching. If there is a remote-tracking branch corresponding to the upstream branch and the upstream branch was rebased since last fetched, the rebase uses that information to avoid rebasing non-local changes."
msgstr "为真时，在获取后将当前分支变基到上游分支之上。如果有一个远程跟踪的分支与上游分支相对应，并且上游分支在上次获取后被重新建立了基础，那么变基就会使用该信息以避免重新建立非本地的变化。"

#. type: Plain text
#: en/git-pull.txt:118
#, placeholders:'--rebase-merges`':'linkgit:git-rebase[1]', priority:220
msgid "When set to `merges`, rebase using `git rebase --rebase-merges` so that the local merge commits are included in the rebase (see linkgit:git-rebase[1] for details)."
msgstr "当设置为 `merges` 时，使用 `git rebase --rebase-merges` 进行重建，这样本地的合并提交就会包含在重建中（详见 linkgit:git-rebase[1]）。"

#. type: Plain text
#: en/git-pull.txt:120
#, priority:220
msgid "When false, merge the upstream branch into the current branch."
msgstr "如果为false，则将上游分支合并到当前分支中。"

#. type: Plain text
#: en/git-pull.txt:122
#, priority:220
msgid "When `interactive`, enable the interactive mode of rebase."
msgstr "当设置为 `interactive` 时，启用变基的交互模式。"

#. type: Plain text
#: en/git-pull.txt:126
#, placeholders:'pull.rebase':'branch.autoSetupRebase':'linkgit:git-config[1]':'`--rebase`', priority:220
msgid "See `pull.rebase`, `branch.<name>.rebase` and `branch.autoSetupRebase` in linkgit:git-config[1] if you want to make `git pull` always use `--rebase` instead of merging."
msgstr "如果你想让 `git pull` 总是使用 `--rebase` 而不是合并，请参见 linkgit:git-config[1] 中的 `pull.rebase`, `branch.< 分支名 >.rebase` 和 `branch.autoSetupRebase`。"

#. type: Plain text
#: en/git-pull.txt:132
#, placeholders:'linkgit:git-rebase[1]', priority:220
msgid "This is a potentially _dangerous_ mode of operation. It rewrites history, which does not bode well when you published that history already. Do *not* use this option unless you have read linkgit:git-rebase[1] carefully."
msgstr "这是一种潜在的「危险的」操作模式。 它重写了历史，当你已经发布了这些历史时，这并不是一个好兆头。 除非你仔细阅读了linkgit:git-rebase[1]，否则请「不要」使用这个选项。"

#. type: Labeled list
#: en/git-pull.txt:133 en/git-svn.txt:261
#, ignore-same, no-wrap, priority:220
msgid "--no-rebase"
msgstr "--no-rebase"

#. type: Plain text
#: en/git-pull.txt:135
#, placeholders:'--rebase=false', priority:220
msgid "This is shorthand for --rebase=false."
msgstr "这是对 --rebase=false 的简写。"

#. type: Title ~
#: en/git-pull.txt:137
#, no-wrap, priority:220
msgid "Options related to fetching"
msgstr "与获取有关的选项"

#. type: Title -
#: en/git-pull.txt:148
#, no-wrap, priority:220
msgid "DEFAULT BEHAVIOUR"
msgstr "默认行为"

#. type: Plain text
#: en/git-pull.txt:155
#, priority:220
msgid "Often people use `git pull` without giving any parameter. Traditionally, this has been equivalent to saying `git pull origin`. However, when configuration `branch.<name>.remote` is present while on branch `<name>`, that value is used instead of `origin`."
msgstr "人们经常使用 `git pull` 而不给任何参数。 传统上，这等同于说 `git pull origin`。 然而，当配置 `branch.<分支名>.remote` 在分支 `< 分支名 >` 上出现时，该值会被用来代替 `origin`。"

#. type: Plain text
#: en/git-pull.txt:160
#, placeholders:'$GIT_DIR', priority:220
msgid "In order to determine what URL to use to fetch from, the value of the configuration `remote.<origin>.url` is consulted and if there is not any such variable, the value on the `URL:` line in `$GIT_DIR/remotes/<origin>` is used."
msgstr "为了确定使用什么 URL 来获取，将查询配置 `remote.<远程名>.url` 的值，如果没有这样的变量，将使用 `$GIT_DIR/remotes/< 远程名 >` 中 `URL:` 一行的值。"

#. type: Plain text
#: en/git-pull.txt:169
#, placeholders:'$GIT_DIR', priority:220
msgid "In order to determine what remote branches to fetch (and optionally store in the remote-tracking branches) when the command is run without any refspec parameters on the command line, values of the configuration variable `remote.<origin>.fetch` are consulted, and if there aren't any, `$GIT_DIR/remotes/<origin>` is consulted and its `Pull:` lines are used. In addition to the refspec formats described in the OPTIONS section, you can have a globbing refspec that looks like this:"
msgstr "当命令行上没有任何引用规范参数时，为了确定要获取哪些远程分支（并可选择存储在远程跟踪分支中），会查询配置变量 `remote.<远程名>.fetch` 的值，如果没有，会查询 `$GIT_DIR/remotes/< 远程名 >` 并使用其 `Pull:` 行。 除了在『选项』部分描述的引用规范格式之外，你还可以有一个看起来像这样的引用规范通配符："

#. type: delimited block -
#: en/git-pull.txt:172
#, no-wrap, priority:220
msgid "refs/heads/*:refs/remotes/origin/*\n"
msgstr "refs/heads/*:refs/remotes/origin/*\n"

#. type: Plain text
#: en/git-pull.txt:179
#, priority:220
msgid "A globbing refspec must have a non-empty RHS (i.e. must store what were fetched in remote-tracking branches), and its LHS and RHS must end with `/*`. The above specifies that all remote branches are tracked using remote-tracking branches in `refs/remotes/origin/` hierarchy under the same name."
msgstr "一个引用规范通配符必须有一个非空的 RHS（即必须存储在远程跟踪分支中获取的内容），其 LHS 和 RHS 必须以 `/*` 结尾。 以上规定了所有远程分支都使用同名的 `refs/remotes/origin/` 层次结构中的远程跟踪分支进行跟踪。"

#. type: Plain text
#: en/git-pull.txt:183
#, priority:220
msgid "The rule to determine which remote branch to merge after fetching is a bit involved, in order not to break backward compatibility."
msgstr "为了不破坏后向兼容性，确定在获取后合并哪个远程分支的规则有点复杂。"

#. type: Plain text
#: en/git-pull.txt:186
#, priority:220
msgid "If explicit refspecs were given on the command line of `git pull`, they are all merged."
msgstr "如果在 `git pull` 的命令行中给出了明确的引用规范，它们都会被合并。"

#. type: Plain text
#: en/git-pull.txt:191
#, placeholders:'$GIT_DIR', priority:220
msgid "When no refspec was given on the command line, then `git pull` uses the refspec from the configuration or `$GIT_DIR/remotes/<origin>`. In such cases, the following rules apply:"
msgstr "当命令行没有给出引用规范时，那么 `git pull` 使用配置或 `$GIT_DIR/remotes/<远程名>` 中的引用规范。 在这种情况下，以下规则适用："

#. type: Plain text
#: en/git-pull.txt:195
#, priority:220
msgid "If `branch.<name>.merge` configuration for the current branch `<name>` exists, that is the name of the branch at the remote site that is merged."
msgstr "如果当前分支 `<分支名>` 的 `branch.< 分支名 >.merge` 配置存在，这就是被合并的远程站点的分支名称。"

#. type: Plain text
#: en/git-pull.txt:197
#, priority:220
msgid "If the refspec is a globbing one, nothing is merged."
msgstr "如果引用规范是全局的， 则不合并任何信息。"

#. type: Plain text
#: en/git-pull.txt:199
#, priority:220
msgid "Otherwise the remote branch of the first refspec is merged."
msgstr "否则将合并第一个引用规范的远程分支。"

#. type: Plain text
#: en/git-pull.txt:207
#, priority:220
msgid "Update the remote-tracking branches for the repository you cloned from, then merge one of them into your current branch:"
msgstr "更新你所克隆的仓库的远程跟踪分支，然后将其中一个分支合并到你当前的分支："

#. type: delimited block -
#: en/git-pull.txt:211
#, no-wrap, priority:220
msgid ""
"$ git pull\n"
"$ git pull origin\n"
msgstr ""
"$ git pull\n"
"$ git pull origin\n"

#. type: Plain text
#: en/git-pull.txt:216
#, placeholders:'HEAD':'linkgit:git-config[1]', priority:220
msgid "Normally the branch merged in is the HEAD of the remote repository, but the choice is determined by the branch.<name>.remote and branch.<name>.merge options; see linkgit:git-config[1] for details."
msgstr "通常情况下，合并进来的分支是远程仓库的 HEAD，但选择由 branch.<分支名>.remote 和 branch.< 分支名 >.merge 选项决定；详见 linkgit:git-config[1] 。"

#. type: Plain text
#: en/git-pull.txt:218
#, priority:220
msgid "Merge into the current branch the remote branch `next`:"
msgstr "将远程分支 `next` 合并到当前分支："

#. type: delimited block -
#: en/git-pull.txt:221
#, no-wrap, priority:220
msgid "$ git pull origin next\n"
msgstr "$ git pull origin next\n"

#. type: Plain text
#: en/git-pull.txt:226
#, placeholders:'FETCH_HEAD', priority:220
msgid "This leaves a copy of `next` temporarily in FETCH_HEAD, and updates the remote-tracking branch `origin/next`. The same can be done by invoking fetch and merge:"
msgstr "这将在 FETCH_HEAD 中暂时留下 `next` 的副本，并更新远程跟踪分支 `origin/next`。 同样可以通过调用 fetch 和 merge 来完成："

#. type: delimited block -
#: en/git-pull.txt:230
#, no-wrap, priority:220
msgid ""
"$ git fetch origin\n"
"$ git merge origin/next\n"
msgstr ""
"$ git fetch origin\n"
"$ git merge origin/next\n"

#. type: Plain text
#: en/git-pull.txt:235
#, priority:220
msgid "If you tried a pull which resulted in complex conflicts and would want to start over, you can recover with 'git reset'."
msgstr "如果你尝试了一次拉取，导致了复杂的冲突，想重新开始，你可以用 'git reset' 来恢复。"

#. type: Plain text
#: en/git-pull.txt:247
#, placeholders:'--recurse-submodules', priority:220
msgid "Using --recurse-submodules can only fetch new commits in already checked out submodules right now. When e.g. upstream added a new submodule in the just fetched commits of the superproject the submodule itself cannot be fetched, making it impossible to check out that submodule later without having to do a fetch again. This is expected to be fixed in a future Git version."
msgstr "使用 --recurse-submodules 现在只能获取已经签出的子模块的新提交。例如，当上游在刚刚获取的超级项目的提交中添加了一个新的子模块时，子模块本身不能被获取，这使得以后不需要再次获取就能签出该子模块。这个问题有望在未来的 Git 版本中被修复。"

#. type: Plain text
#: en/git-pull.txt:251
#, ignore-same, priority:220
msgid "linkgit:git-fetch[1], linkgit:git-merge[1], linkgit:git-config[1]"
msgstr "linkgit:git-fetch[1], linkgit:git-merge[1], linkgit:git-config[1]"

#. type: Title =
#: en/git-push.txt:2
#, ignore-same, no-wrap, priority:220
msgid "git-push(1)"
msgstr "git-push(1)"

#. type: Plain text
#: en/git-push.txt:7
#, placeholders:'git-push', priority:220
msgid "git-push - Update remote refs along with associated objects"
msgstr "git-push - 与相关对象一起更新远程分支引用"

#. type: Plain text
#: en/git-push.txt:18
#, ignore-ellipsis, no-wrap, placeholders:'[--all':'--branches':'--mirror':'--tags]':'[--follow-tags]':'[--atomic]':'--dry-run]':'[--receive-pack=':'git-receive-pack':'[--repo=':'--force]':'--delete]':'[--prune]':'--quiet]':'--verbose]':'--set-upstream]':'--push-option=':'--signed=(true|false|if-asked)]':'[--force-with-lease':'[--force-if-includes]':'[--no-verify]', priority:220
msgid ""
"'git push' [--all | --branches | --mirror | --tags] [--follow-tags] [--atomic] [-n | --dry-run] [--receive-pack=<git-receive-pack>]\n"
"\t   [--repo=<repository>] [-f | --force] [-d | --delete] [--prune] [-q | --quiet] [-v | --verbose]\n"
"\t   [-u | --set-upstream] [-o <string> | --push-option=<string>]\n"
"\t   [--[no-]signed|--signed=(true|false|if-asked)]\n"
"\t   [--force-with-lease[=<refname>[:<expect>]] [--force-if-includes]]\n"
"\t   [--no-verify] [<repository> [<refspec>...]]\n"
msgstr ""
"'git push' [--all | --branches | --mirror | --tags] [--follow-tags] [--atomic] [-n | --dry-run] [--receive-pack=<git-receive-pack>]\n"
"\t   [--repo=<仓库>] [-f | --force] [-d | --delete] [--prune] [-q | --quiet] [-v | --verbose]\n"
"\t   [-u | --set-upstream] [-o <字符串> | --push-option=<字符串>]\n"
"\t   [--[no-]signed|--signed=(true|false|if-asked)]\n"
"\t   [--force-with-lease[=<引用名>[:<expect>]] [--force-if-includes]]\n"
"\t   [--no-verify] [<仓库> [<引用规范>...]]\n"

#. type: Plain text
#: en/git-push.txt:24
#, priority:220
msgid "Updates remote refs using local refs, while sending objects necessary to complete the given refs."
msgstr "使用本地引用更新远程仓库引用，同时发送完成给定引用的必要对象。"

#. type: Plain text
#: en/git-push.txt:28
#, placeholders:'linkgit:git-receive-pack[1]', priority:220
msgid "You can make interesting things happen to a repository every time you push into it, by setting up 'hooks' there. See documentation for linkgit:git-receive-pack[1]."
msgstr "通过设置 “钩子”，你可以在每次推送到一个仓库时，让它发生有趣的事情。 见 linkgit:git-receive-pack[1] 的文档。"

#. type: Plain text
#: en/git-push.txt:33
#, priority:220
msgid "When the command line does not specify where to push with the `<repository>` argument, `branch.*.remote` configuration for the current branch is consulted to determine where to push. If the configuration is missing, it defaults to 'origin'."
msgstr "当命令行没有用 `<仓库>` 参数指定推送位置时，会参考当前分支的 `branch.*.remote` 配置来决定推送位置。 如果配置丢失，则默认为 \"origin\"。"

#. type: Plain text
#: en/git-push.txt:39
#, ignore-ellipsis, placeholders:'`--all`':'`--mirror`':'`--tags`':'push.default':'linkgit:git-config[1]':'push.default', priority:220
msgid "When the command line does not specify what to push with `<refspec>...` arguments or `--all`, `--mirror`, `--tags` options, the command finds the default `<refspec>` by consulting `remote.*.push` configuration, and if it is not found, honors `push.default` configuration to decide what to push (See linkgit:git-config[1] for the meaning of `push.default`)."
msgstr "当命令行没有用 `<引用规范>...` 参数或 `--all`、`--mirror`、`--tags` 选项指定推送内容时，命令通过查阅 `remote.*.push` 配置找到默认的 `< 引用规范 >`，如果没有找到，则以 `push.default` 配置决定推送内容（关于 `push.default` 的含义，见 linkgit:git-config[1] ）。"

#. type: Plain text
#: en/git-push.txt:46
#, placeholders:'push.default', priority:220
msgid "When neither the command-line nor the configuration specifies what to push, the default behavior is used, which corresponds to the `simple` value for `push.default`: the current branch is pushed to the corresponding upstream branch, but as a safety measure, the push is aborted if the upstream branch does not have the same name as the local one."
msgstr "当命令行和配置都没有指定推送的内容时，将使用默认行为，这与 `push.default` 的 `simple` 值相对应：当前分支被推送到相应的上游分支，但作为一项安全措施，如果上游分支的名称与本地分支不一致，推送将被中止。"

#. type: Title -
#: en/git-push.txt:49
#, no-wrap, placeholders:'[[OPTIONS]]', priority:220
msgid "OPTIONS[[OPTIONS]]"
msgstr "选项[[OPTIONS]]"

#. type: Plain text
#: en/git-push.txt:55
#, placeholders:'<<URLS,':'<<REMOTES,', priority:220
msgid "The \"remote\" repository that is the destination of a push operation. This parameter can be either a URL (see the section <<URLS,GIT URLS>> below) or the name of a remote (see the section <<REMOTES,REMOTES>> below)."
msgstr "作为推送操作的目的地的 “远程” 仓库。 这个参数可以是一个网址（见下面 <<URLS,GIT 地址>> 一节），也可以是一个远程库的名称（见下面 <<REMOTES,远程仓库>> 一节）。"

#. type: Labeled list
#: en/git-push.txt:56
#, ignore-ellipsis, no-wrap, priority:220
msgid "<refspec>..."
msgstr "<引用规范>..."

#. type: Plain text
#: en/git-push.txt:61
#, priority:220
msgid "Specify what destination ref to update with what source object. The format of a <refspec> parameter is an optional plus `+`, followed by the source object <src>, followed by a colon `:`, followed by the destination ref <dst>."
msgstr "指定用什么源对象来更新哪个目标参考文献。 <引用规范> 参数的格式是一个可选的加号 `+`，后面是源对象 <src>，后面是冒号 `:`，后面是目标引用 <dst>。"

#. type: Plain text
#: en/git-push.txt:65
#, placeholders:'HEAD':'linkgit:gitrevisions[7]', priority:220
msgid "The <src> is often the name of the branch you would want to push, but it can be any arbitrary \"SHA-1 expression\", such as `master~4` or `HEAD` (see linkgit:gitrevisions[7])."
msgstr "<src> 通常是你想推送的分支的名字，但它可以是任何任意的“SHA-1 表达式”，比如 `master~4` 或 `HEAD`（见 linkgit:gitrevisions[7]）。"

#. type: Plain text
#: en/git-push.txt:75
#, priority:220
msgid "The <dst> tells which ref on the remote side is updated with this push. Arbitrary expressions cannot be used here, an actual ref must be named. If `git push [<repository>]` without any `<refspec>` argument is set to update some ref at the destination with `<src>` with `remote.<repository>.push` configuration variable, `:<dst>` part can be omitted--such a push will update a ref that `<src>` normally updates without any `<refspec>` on the command line. Otherwise, missing `:<dst>` means to update the same ref as the `<src>`."
msgstr "<dst> 远程仓库的哪个引用被这个推送更新。这里不能使用任意的表达式，必须命名一个实际的引用。 如果 `git push [< 仓库 >]` 没有任何 `< 引用规范 >` 参数被设置用 `remote.< 仓库 >.push` 配置变量更新目的地 `<src>` 的某个引用，则`:<dst>` 部分可以省略 —— 这样的推送将更新 `<src>` 通常更新的引用，命令行上没有任何 `< 引用规范 >`。 否则，缺少 `:<dst>` 意味着更新与 `<src>` 相同的引用。"

#. type: Plain text
#: en/git-push.txt:80
#, priority:220
msgid "If <dst> doesn't start with `refs/` (e.g. `refs/heads/master`) we will try to infer where in `refs/*` on the destination <repository> it belongs based on the type of <src> being pushed and whether <dst> is ambiguous."
msgstr "如果 <dst> 不是以 `refs/` 开头（例如 `refs/heads/master`），我们将根据被推送的 <src> 的类型和 <dst> 是否含糊不清，尝试推断它在目的地 < 仓库 > 的 `refs/*` 中的位置。"

#. type: Plain text
#: en/git-push.txt:84
#, priority:220
msgid "If <dst> unambiguously refers to a ref on the <repository> remote, then push to that ref."
msgstr "如果 <dst> 明确地指向 < 仓库 > 远程的一个引用，那么就推送到该引用。"

#. type: Plain text
#: en/git-push.txt:87
#, priority:220
msgid "If <src> resolves to a ref starting with refs/heads/ or refs/tags/, then prepend that to <dst>."
msgstr "如果 <src> 解析为以 refs/heads/ 或 refs/tags/ 开头的引用，则将其前置到 <dst>。"

#. type: Plain text
#: en/git-push.txt:93
#, placeholders:'advice.pushUnqualifiedRefname':'linkgit:git-config[1]', priority:220
msgid "Other ambiguity resolutions might be added in the future, but for now any other cases will error out with an error indicating what we tried, and depending on the `advice.pushUnqualifiedRefname` configuration (see linkgit:git-config[1]) suggest what refs/ namespace you may have wanted to push to."
msgstr "其他含糊的解决方案可能会在未来加入，但现在我们所尝试的任何其他情况都会出错，并根据`advice.pushUnqualifiedRefname`配置（见linkgit:git-config[1]）建议你可能想推送到哪个类型的引用中。"

#. type: Plain text
#: en/git-push.txt:101
#, priority:220
msgid "The object referenced by <src> is used to update the <dst> reference on the remote side. Whether this is allowed depends on where in `refs/*` the <dst> reference lives as described in detail below, in those sections \"update\" means any modifications except deletes, which as noted after the next few sections are treated differently."
msgstr "由 <src> 引用的对象被用来更新远程端的 <dst> 引用。这是否被允许取决于 <dst> 引用在`refs/*`中的位置，下面将详细描述，在这些章节中，“更新”意味着除了删除之外的任何修改，正如在接下来的几节中所指出的，这将被不同地对待。"

#. type: Plain text
#: en/git-push.txt:104
#, priority:220
msgid "The `refs/heads/*` namespace will only accept commit objects, and updates only if they can be fast-forwarded."
msgstr "`refs/heads/*` 命名空间只接受提交对象，只有在可以快进的情况下才接受更新。"

#. type: Plain text
#: en/git-push.txt:108
#, priority:220
msgid "The `refs/tags/*` namespace will accept any kind of object (as commits, trees and blobs can be tagged), and any updates to them will be rejected."
msgstr "`refs/tags/*` 命名空间将接受任何种类的对象（因为提交、树和二进制对象都可以被标记），对它们的任何更新都将被拒绝。"

#. type: Plain text
#: en/git-push.txt:113
#, priority:220
msgid "It's possible to push any type of object to any namespace outside of `refs/{tags,heads}/*`. In the case of tags and commits, these will be treated as if they were the commits inside `refs/heads/*` for the purposes of whether the update is allowed."
msgstr "可以将任何类型的对象推送到 `refs/{tags,heads}/*` 之外的任何命名空间。在标签和提交的情况下，这些将被视为 `refs/heads/*` 内的提交，以决定是否允许更新。"

#. type: Plain text
#: en/git-push.txt:122
#, priority:220
msgid "I.e. a fast-forward of commits and tags outside `refs/{tags,heads}/*` is allowed, even in cases where what's being fast-forwarded is not a commit, but a tag object which happens to point to a new commit which is a fast-forward of the commit the last tag (or commit) it's replacing. Replacing a tag with an entirely different tag is also allowed, if it points to the same commit, as well as pushing a peeled tag, i.e. pushing the commit that existing tag object points to, or a new tag object which an existing commit points to."
msgstr "也就是说，允许在 `refs/{tags,heads}/*` 之外进行快进提交和标签，即使被快进的不是一个提交，而是一个标签对象，它恰好指向一个新的提交，而这个提交是它所替代的最后一个标签（或提交）的快进。用一个完全不同的标签替换一个标签也是允许的，如果它指向同一个提交，以及推送一个剥离的标签，即推送现有标签对象所指向的提交，或现有提交所指向的新标签对象。"

#. type: Plain text
#: en/git-push.txt:126
#, priority:220
msgid "Tree and blob objects outside of `refs/{tags,heads}/*` will be treated the same way as if they were inside `refs/tags/*`, any update of them will be rejected."
msgstr "在 `refs/{tags,heads}/*` 之外的树和二进制对象的处理方式与在 `refs/tags/*` 之内的相同，它们的任何更新都会被拒绝。"

#. type: Plain text
#: en/git-push.txt:135
#, placeholders:'`--force`':'receive.denyNonFastForwards':'linkgit:git-config[1]':'linkgit:githooks[5]', priority:220
msgid "All of the rules described above about what's not allowed as an update can be overridden by adding an the optional leading `+` to a refspec (or using `--force` command line option). The only exception to this is that no amount of forcing will make the `refs/heads/*` namespace accept a non-commit object. Hooks and configuration can also override or amend these rules, see e.g. `receive.denyNonFastForwards` in linkgit:git-config[1] and `pre-receive` and `update` in linkgit:githooks[5]."
msgstr "上面描述的所有关于不允许更新的规则都可以通过在引用规范前面添加一个可选 `+` 来覆盖（或者使用 `--force` 命令行选项）。唯一的例外是，无论如何强制都不会使 `refs/heads/*` 命名空间接受一个非提交对象。钩子和配置也可以覆盖或修改这些规则，例如见 linkgit:git-config[1] 中的 `receive.denyNonFastForwards` 和 linkgit:githooks[5] 中的 `pre-receive` 和 `update`。"

#. type: Plain text
#: en/git-push.txt:141
#, placeholders:'`--force`':'receive.denyDeletes':'linkgit:git-config[1]':'linkgit:githooks[5]', priority:220
msgid "Pushing an empty <src> allows you to delete the <dst> ref from the remote repository. Deletions are always accepted without a leading `+` in the refspec (or `--force`), except when forbidden by configuration or hooks. See `receive.denyDeletes` in linkgit:git-config[1] and `pre-receive` and `update` in linkgit:githooks[5]."
msgstr "推送一个空的 <src> 允许你从远程版本库中删除 <dst> 的引用。除非配置或钩子禁止，否则在引用规范中没有前面的 `+` (或 `--force`) ，删除总是被接受的。参见 linkgit:git-config[1] 中的 `receive.denyDeletes` 以及 linkgit:githooks[5] 中的 `pre-receive` 和 `update`。"

#. type: Plain text
#: en/git-push.txt:146
#, priority:220
msgid "The special refspec `:` (or `+:` to allow non-fast-forward updates) directs Git to push \"matching\" branches: for every branch that exists on the local side, the remote side is updated if a branch of the same name already exists on the remote side."
msgstr "特殊的引用规范 `:`（或`+:`以允许非快进式更新）指示 Git 推送“匹配”的分支：对于每一个存在于本地的分支，如果远程仓库已经有一个同名的分支存在，则远程仓库会被更新。"

#. type: Plain text
#: en/git-push.txt:148
#, priority:220
msgid "`tag <tag>` means the same as `refs/tags/<tag>:refs/tags/<tag>`."
msgstr "`tag <tag>` 与 `refs/tags/<tag>:refs/tags/<tag>` 意思相同。"

#. type: Labeled list
#: en/git-push.txt:150
#, ignore-same, no-wrap, priority:220
msgid "--branches"
msgstr "--branches"

#. type: Plain text
#: en/git-push.txt:153
#, priority:220
msgid "Push all branches (i.e. refs under `refs/heads/`); cannot be used with other <refspec>."
msgstr "推送所有分支（即`refs/heads/`下的引用）；不能与其他 < 引用规范 > 一起使用。"

#. type: Plain text
#: en/git-push.txt:161
#, placeholders:'--prune', priority:220
msgid "Remove remote branches that don't have a local counterpart. For example a remote branch `tmp` will be removed if a local branch with the same name doesn't exist any more. This also respects refspecs, e.g. `git push --prune remote refs/heads/*:refs/tmp/*` would make sure that remote `refs/tmp/foo` will be removed if `refs/heads/foo` doesn't exist."
msgstr "删除没有本地对应分支的远程分支。例如，如果本地的同名分支不存在了，那么远程分支 `tmp` 将被删除。这也是对引用规范的尊重，例如，`git push --prune remote refs/heads/*:refs/tmp/*` 将确保如果 `refs/heads/foo` 不存在，那么远程的 `refs/tmp/foo` 将被删除。"

#. type: Plain text
#: en/git-push.txt:172
#, priority:220
msgid "Instead of naming each ref to push, specifies that all refs under `refs/` (which includes but is not limited to `refs/heads/`, `refs/remotes/`, and `refs/tags/`) be mirrored to the remote repository. Newly created local refs will be pushed to the remote end, locally updated refs will be force updated on the remote end, and deleted refs will be removed from the remote end. This is the default if the configuration option `remote.<remote>.mirror` is set."
msgstr "而不是命名每一个要推送的引用，指定`refs/`（包括但不限于`refs/heads/`、`refs/remotes/`和`refs/tags/`）下的所有引用都被镜像到远程仓库。 新创建的本地引用将被推送到远程端，本地更新的引用将被强制更新到远程端，而删除的引用将从远程仓库删除。 如果配置选项 `remote.<remote>.mirror`被设置，这就是默认的。"

#. type: Plain text
#: en/git-push.txt:181
#, priority:220
msgid "Produce machine-readable output. The output status line for each ref will be tab-separated and sent to stdout instead of stderr. The full symbolic names of the refs will be given."
msgstr "生成机器可读的输出。 每个引用的输出状态行将以制表符分隔，并发送至标准输出而不是标准报错。 将给出引用的完整符号名称。"

#. type: Plain text
#: en/git-push.txt:186
#, priority:220
msgid "All listed refs are deleted from the remote repository. This is the same as prefixing all refs with a colon."
msgstr "所有列出的引用都从远程仓库中删除。这与在所有引用前加冒号的做法相同。"

#. type: Plain text
#: en/git-push.txt:191
#, priority:220
msgid "All refs under `refs/tags` are pushed, in addition to refspecs explicitly listed on the command line."
msgstr "除了命令行上明确列出的引用规范之外，`refs/tags` 下的所有引用都被推送。"

#. type: Labeled list
#: en/git-push.txt:192
#, ignore-same, no-wrap, priority:220
msgid "--follow-tags"
msgstr "--follow-tags"

#. type: Plain text
#: en/git-push.txt:199
#, placeholders:'push.followTags':'push.followTags':'linkgit:git-config[1]', priority:220
msgid "Push all the refs that would be pushed without this option, and also push annotated tags in `refs/tags` that are missing from the remote but are pointing at commit-ish that are reachable from the refs being pushed. This can also be specified with configuration variable `push.followTags`. For more information, see `push.followTags` in linkgit:git-config[1]."
msgstr "推送所有在没有这个选项的情况下会被推送的引用，同时也推送 `refs/tags` 中的注释标签，这些标签在远程中缺失，但却指向被推送的引用中可以到达的提交号。 这也可以用配置变量 `push.followTags` 来指定。 更多信息，见 linkgit:git-config[1] 中的 `push.followTags`。"

#. type: Labeled list
#: en/git-push.txt:200 en/git-send-pack.txt:74
#, ignore-same, no-wrap, priority:220
msgid "--[no-]signed"
msgstr "--[no-]signed"

#. type: Labeled list
#: en/git-push.txt:201 en/git-send-pack.txt:75
#, ignore-same, no-wrap, priority:220
msgid "--signed=(true|false|if-asked)"
msgstr "--signed=(true|false|if-asked)"

#. type: Plain text
#: en/git-push.txt:210 en/git-send-pack.txt:84
#, placeholders:'`--no-signed`':'`--signed`':'--sign`':'linkgit:git-receive-pack[1]', priority:220
msgid "GPG-sign the push request to update refs on the receiving side, to allow it to be checked by the hooks and/or be logged. If `false` or `--no-signed`, no signing will be attempted. If `true` or `--signed`, the push will fail if the server does not support signed pushes. If set to `if-asked`, sign if and only if the server supports signed pushes. The push will also fail if the actual call to `gpg --sign` fails. See linkgit:git-receive-pack[1] for the details on the receiving end."
msgstr "对推送请求进行 GPG 签名，以更新接收方的引用，使其能够被钩子检查和/或被记录下来。 如果指定 `false` 或 `--no-signed`，将不尝试签名。 如果指定 `true` 或 `--signed`，且服务器不支持签名推送，推送将失败。 如果设置为 `if-asked`，仅当服务器支持签名推送时才签名。 如果实际调用 `gpg --sign` 失败，推送也将失败。 关于接收端的细节，见 linkgit:git-receive-pack[1]。"

#. type: Labeled list
#: en/git-push.txt:211
#, ignore-same, no-wrap, priority:220
msgid "--[no-]atomic"
msgstr "--[no-]atomic"

#. type: Plain text
#: en/git-push.txt:215
#, priority:220
msgid "Use an atomic transaction on the remote side if available. Either all refs are updated, or on error, no refs are updated. If the server does not support atomic pushes the push will fail."
msgstr "如果有的话，在远程仓库使用一个原子事务。 要么所有的引用都被更新，要么出错时，没有引用被更新。 如果服务器不支持原子推送，推送将会失败。"

#. type: Labeled list
#: en/git-push.txt:217
#, no-wrap, placeholders:'--push-option=', priority:220
msgid "--push-option=<option>"
msgstr "--push-option=<选项>"

#. type: Plain text
#: en/git-push.txt:227
#, placeholders:'`--push-option=':'`--push-option=':'push.pushOption', priority:220
msgid "Transmit the given string to the server, which passes them to the pre-receive as well as the post-receive hook. The given string must not contain a NUL or LF character. When multiple `--push-option=<option>` are given, they are all sent to the other side in the order listed on the command line. When no `--push-option=<option>` is given from the command line, the values of configuration variable `push.pushOption` are used instead."
msgstr "将给定的字符串传输给服务器，服务器将它们传递给 pre-receive 以及 post-receive 钩子。给定的字符串不能包含 NUL 或 LF 字符。 当给出多个 `--push-option=< 选项 >` 时，它们将按照命令行中列出的顺序全部发送给对方。 当命令行中没有给出 `--push-option=< 选项 >` 时，将使用配置变量`push.pushOption` 的值来代替。"

# ERROR: git-receive-pack not found in translation
#. type: Labeled list
#: en/git-push.txt:228 en/git-send-pack.txt:29
#, no-wrap, placeholders:'--receive-pack=':'git-receive-pack', priority:220
msgid "--receive-pack=<git-receive-pack>"
msgstr "--receive-pack=<git-receive-pack>"

# ERROR: git-receive-pack not found in translation
#. type: Labeled list
#: en/git-push.txt:229 en/git-send-pack.txt:35
#, no-wrap, placeholders:'--exec=':'git-receive-pack', priority:220
msgid "--exec=<git-receive-pack>"
msgstr "--exec=<git-receive-pack>"

#. type: Plain text
#: en/git-push.txt:234 en/git-send-pack.txt:34
#, placeholders:'git-receive-pack':'$PATH', priority:220
msgid "Path to the 'git-receive-pack' program on the remote end. Sometimes useful when pushing to a remote repository over ssh, and you do not have the program in a directory on the default $PATH."
msgstr "到远端的 'git-receive-pack' 程序的路径。 当通过 ssh 推送到远程版本库，而你没有在默认的 $PATH 目录下的程序时，有时会很有用。"

#. type: Labeled list
#: en/git-push.txt:235
#, ignore-same, no-wrap, priority:220
msgid "--[no-]force-with-lease"
msgstr "--[no-]force-with-lease"

#. type: Labeled list
#: en/git-push.txt:236
#, no-wrap, placeholders:'--force-with-lease=', priority:220
msgid "--force-with-lease=<refname>"
msgstr "--force-with-lease=<引用名>"

#. type: Labeled list
#: en/git-push.txt:237
#, no-wrap, placeholders:'--force-with-lease=', priority:220
msgid "--force-with-lease=<refname>:<expect>"
msgstr "--force-with-lease=< 引用名 >:< 期望>"

#. type: Plain text
#: en/git-push.txt:240
#, priority:220
msgid "Usually, \"git push\" refuses to update a remote ref that is not an ancestor of the local ref used to overwrite it."
msgstr "通常，\"git push\" 会拒绝更新一个不是用来覆盖它的本地引用的远程父引用。"

#. type: Plain text
#: en/git-push.txt:243
#, priority:220
msgid "This option overrides this restriction if the current value of the remote ref is the expected value. \"git push\" fails otherwise."
msgstr "如果远程引用的当前值是预期值，该选项会覆盖这一限制。否则，\"git push\" 会失败。"

#. type: Plain text
#: en/git-push.txt:250
#, placeholders:'`--force`', priority:220
msgid "Imagine that you have to rebase what you have already published. You will have to bypass the \"must fast-forward\" rule in order to replace the history you originally published with the rebased history. If somebody else built on top of your original history while you are rebasing, the tip of the branch at the remote may advance with their commit, and blindly pushing with `--force` will lose their work."
msgstr "想象一下，你必须对你已经发表的内容进行重新定位。 你必须绕过“必须快速合并”的规则，以便用重写的历史替换你最初发布的历史。 如果在你重新发布的时候，有其他人在你原来的历史之上构建，那么远程分支的顶端可能会随着他们的提交而前进，而盲目地用 `--force` 推送会丢失他们的改动。"

#. type: Plain text
#: en/git-push.txt:257
#, priority:220
msgid "This option allows you to say that you expect the history you are updating is what you rebased and want to replace. If the remote ref still points at the commit you specified, you can be sure that no other people did anything to the ref. It is like taking a \"lease\" on the ref without explicitly locking it, and the remote ref is updated only if the \"lease\" is still valid."
msgstr "这个选项允许你说，你希望你更新的历史是你重新建立的，并希望取代它。如果远程引用仍然指向你指定的提交，你就可以确定没有其他人对该引用做了什么。这就像在没有明确锁定的情况下对引用进行“租赁”，只有在 “租赁”仍然有效的情况下才会更新远程引用。"

#. type: Plain text
#: en/git-push.txt:262
#, placeholders:'`--force-with-lease`', priority:220
msgid "`--force-with-lease` alone, without specifying the details, will protect all remote refs that are going to be updated by requiring their current value to be the same as the remote-tracking branch we have for them."
msgstr "`--force-with-lease`，不指定细节，将保护所有将被更新的远程引用，要求它们的当前值与我们为它们准备的远程跟踪分支相同。"

#. type: Plain text
#: en/git-push.txt:267
#, placeholders:'`--force-with-lease=', priority:220
msgid "`--force-with-lease=<refname>`, without specifying the expected value, will protect the named ref (alone), if it is going to be updated, by requiring its current value to be the same as the remote-tracking branch we have for it."
msgstr "`--force-with-lease=< 引用名 >`，没有指定预期值，将保护命名的引用（单独），如果它要被更新，要求其当前值与我们对它的远程跟踪分支相同。"

#. type: Plain text
#: en/git-push.txt:275
#, placeholders:'`--force-with-lease=', priority:220
msgid "`--force-with-lease=<refname>:<expect>` will protect the named ref (alone), if it is going to be updated, by requiring its current value to be the same as the specified value `<expect>` (which is allowed to be different from the remote-tracking branch we have for the refname, or we do not even have to have such a remote-tracking branch when this form is used). If `<expect>` is the empty string, then the named ref must not already exist."
msgstr "`--force-with-lease=< 引用名 >:< 期望 >`将保护指定的引用（单独），如果它要被更新，要求它的当前值与指定的值`< 期望 >`相同（允许与我们对引用名的远程跟踪分支不同，或者在使用这种形式时，我们甚至不需要有这样一个远程跟踪分支）。 如果`< 期望 >`是空字符串，那么命名的引用必须不存在。"

#. type: Plain text
#: en/git-push.txt:280
#, placeholders:'`--force-with-lease=', priority:220
msgid "Note that all forms other than `--force-with-lease=<refname>:<expect>` that specifies the expected current value of the ref explicitly are still experimental and their semantics may change as we gain experience with this feature."
msgstr "请注意，除了`--force-with-lease=< 引用名 >:< 期望 >`以外的所有形式都是明确指定引用的预期当前值，这些形式仍然是试验性的，它们的语义可能会随着我们对这个功能的经验积累而改变。"

#. type: Plain text
#: en/git-push.txt:283
#, placeholders:'--no-force-with-lease':'--force-with-lease', priority:220
msgid "\"--no-force-with-lease\" will cancel all the previous --force-with-lease on the command line."
msgstr "\"--no-force-with-lease \" 将取消之前在命令行上所有的 --force-with-lease。"

#. type: Plain text
#: en/git-push.txt:289
#, placeholders:'`--force-with-lease`':'`--force-with-lease=', priority:220
msgid "A general note on safety: supplying this option without an expected value, i.e. as `--force-with-lease` or `--force-with-lease=<refname>` interacts very badly with anything that implicitly runs `git fetch` on the remote to be pushed to in the background, e.g. `git fetch origin` on your repository in a cronjob."
msgstr "关于安全性的一般说明：在没有预期值的情况下提供这个选项，即 `--force-with-lease` 或`--force-with-lease=< 引用名 >`，会与任何在后台隐式运行 `git fetch` 的远端推送的进程产生非常不好的互动，例如仓库中 cronjob 的 `git fetch origin`。"

#. type: Plain text
#: en/git-push.txt:296
#, placeholders:'`--force`', priority:220
msgid "The protection it offers over `--force` is ensuring that subsequent changes your work wasn't based on aren't clobbered, but this is trivially defeated if some background process is updating refs in the background. We don't have anything except the remote tracking info to go by as a heuristic for refs you're expected to have seen & are willing to clobber."
msgstr "与 `--force` 相比，它提供的保护是确保你的工作不基于后续的变化，但如果有后台进程在后台更新引用，这一点就很容易被破坏。除了远程跟踪信息外，我们没有任何你期望看到并愿意去破解可以作为启发式引用的东西。"

#. type: Plain text
#: en/git-push.txt:300
#, priority:220
msgid "If your editor or some other system is running `git fetch` in the background for you a way to mitigate this is to simply set up another remote:"
msgstr "如果你的编辑器或其他系统在后台为你运行`git fetch`，减轻这种情况的方法是简单地设置另一个远程："

#. type: Plain text
#: en/git-push.txt:303
#, no-wrap, placeholders:'remote.origin.url', priority:220
msgid ""
"\tgit remote add origin-push $(git config remote.origin.url)\n"
"\tgit fetch origin-push\n"
msgstr ""
"\tgit remote add origin-push $(git config remote.origin.url)\n"
"\tgit fetch origin-push\n"

#. type: Plain text
#: en/git-push.txt:306
#, priority:220
msgid "Now when the background process runs `git fetch origin` the references on `origin-push` won't be updated, and thus commands like:"
msgstr "现在，当后台进程运行 `git fetch origin` 时，`origin-push`上的引用将不会被更新，因此，像这样的命令："

#. type: Plain text
#: en/git-push.txt:308
#, no-wrap, placeholders:'--force-with-lease', priority:220
msgid "\tgit push --force-with-lease origin-push\n"
msgstr "\tgit push --force-with-lease origin-push\n"

#. type: Plain text
#: en/git-push.txt:313
#, placeholders:'--all`', priority:220
msgid "Will fail unless you manually run `git fetch origin-push`. This method is of course entirely defeated by something that runs `git fetch --all`, in that case you'd need to either disable it or do something more tedious like:"
msgstr "除非你手动运行 `git fetch origin-push`，否则会失败。当然，这种方法完全可以被运行 `git fetch --all` 的东西打败，在这种情况下，你需要禁用它或者做一些更繁琐的事情，比如："

#. type: Plain text
#: en/git-push.txt:318
#, no-wrap, placeholders:'--force-with-lease=master', priority:220
msgid ""
"\tgit fetch              # update 'master' from remote\n"
"\tgit tag base master    # mark our base point\n"
"\tgit rebase -i master   # rewrite some commits\n"
"\tgit push --force-with-lease=master:base master:master\n"
msgstr ""
"\tgit fetch              # 从远程仓库更新 'master' 分支\n"
"\tgit tag base master    # 标记基点\n"
"\tgit rebase -i master   # 重写某些提交\n"
"\tgit push --force-with-lease=master:base master:master\n"

#. type: Plain text
#: en/git-push.txt:324
#, priority:220
msgid "I.e. create a `base` tag for versions of the upstream code that you've seen and are willing to overwrite, then rewrite history, and finally force push changes to `master` if the remote version is still at `base`, regardless of what your local `remotes/origin/master` has been updated to in the background."
msgstr "也就是说，为你已经看到并愿意覆盖的上游仓库创建一个`base` 标签，然后重写历史，最后如果远程版本仍然在 `base`，则强制推送修改到`master`，不管你本地的 `remotes/origin/master` 在后台更新了什么。"

#. type: Plain text
#: en/git-push.txt:332
#, placeholders:'`--force-if-includes`':'`--force-with-lease', priority:220
msgid "Alternatively, specifying `--force-if-includes` as an ancillary option along with `--force-with-lease[=<refname>]` (i.e., without saying what exact commit the ref on the remote side must be pointing at, or which refs on the remote side are being protected) at the time of \"push\" will verify if updates from the remote-tracking refs that may have been implicitly updated in the background are integrated locally before allowing a forced update."
msgstr "另外，在“推送”时将 `--force-if-includes` 作为辅助选项与 `--force-with-lease[=< 引用名 >]` 一起指定（即不说远程的引用必须指向什么确切的提交，或远程的哪些引用被保护），将验证远程跟踪引用的更新是否在允许强制更新之前被整合在本地。"

#. type: Plain text
#: en/git-push.txt:340
#, placeholders:'`--force-with-lease`', priority:220
msgid "Usually, the command refuses to update a remote ref that is not an ancestor of the local ref used to overwrite it. Also, when `--force-with-lease` option is used, the command refuses to update a remote ref whose current value does not match what is expected."
msgstr "通常情况下，命令会拒绝更新一个不属于用来覆盖它的本地引用祖先的远程引用。 另外，当使用 `--force-with-lease` 选项时，命令会拒绝更新一个当前值与预期不符的远程引用。"

#. type: Plain text
#: en/git-push.txt:343
#, priority:220
msgid "This flag disables these checks, and can cause the remote repository to lose commits; use it with care."
msgstr "这个标志禁用了这些检查，并可能导致远程版本库丢失提交，使用时要小心。"

#. type: Plain text
#: en/git-push.txt:352
#, ignore-ellipsis, placeholders:'`--force`':'push.default', priority:220
msgid "Note that `--force` applies to all the refs that are pushed, hence using it with `push.default` set to `matching` or with multiple push destinations configured with `remote.*.push` may overwrite refs other than the current branch (including local refs that are strictly behind their remote counterpart). To force a push to only one branch, use a `+` in front of the refspec to push (e.g `git push origin +master` to force a push to the `master` branch). See the `<refspec>...` section above for details."
msgstr "注意，`--force` 适用于所有被推送的引用，因此在 `push.default` 设置为 `matching` 的情况下使用它，或者在 `remote.*.push` 配置了多个推送目的地的情况下，可能会覆盖当前分支以外的引用（包括严格落后于其远程对应的本地引用）。 要强制推送到一个分支，请在推送的引用规范前面使用 `+`（例如 `git push origin +master`，强制推送到 `master` 分支）。详情见上面的 `< 引用规范 >...` 部分。"

#. type: Labeled list
#: en/git-push.txt:353
#, ignore-same, no-wrap, priority:220
msgid "--[no-]force-if-includes"
msgstr "--[no-]force-if-includes"

#. type: Plain text
#: en/git-push.txt:356
#, priority:220
msgid "Force an update only if the tip of the remote-tracking ref has been integrated locally."
msgstr "只有远程跟踪的引用顶端被整合到本地才强制更新。"

#. type: Plain text
#: en/git-push.txt:362
#, priority:220
msgid "This option enables a check that verifies if the tip of the remote-tracking ref is reachable from one of the \"reflog\" entries of the local branch based in it for a rewrite. The check ensures that any updates from the remote have been incorporated locally by rejecting the forced update if that is not the case."
msgstr "这个选项启用了一个检查，以验证远程跟踪引用的顶端是否可以从本地分支的“引用日志”条目中到达，以便进行重写。该检查确保来自远程的任何更新都已纳入本地，如果不是这样，则拒绝强制更新。"

#. type: Plain text
#: en/git-push.txt:366
#, placeholders:'`--force-with-lease`':'`--force-with-lease=', priority:220
msgid "If the option is passed without specifying `--force-with-lease`, or specified along with `--force-with-lease=<refname>:<expect>`, it is a \"no-op\"."
msgstr "如果该选项没有指定 `--force-with-lease`，或者与 `--force-with-lease=< 引用名 >:< 期望 >`一起指定，则是“无选项”的。"

# ERROR: `--no-force-if-includes` not found in translation
#. type: Plain text
#: en/git-push.txt:368
#, placeholders:'`--no-force-if-includes`', priority:220
msgid "Specifying `--no-force-if-includes` disables this behavior."
msgstr "指定 `--no-force-if-includes` 就可以禁止这种行为。"

#. type: Labeled list
#: en/git-push.txt:369
#, no-wrap, placeholders:'--repo=', priority:220
msgid "--repo=<repository>"
msgstr "--repo=<仓库>"

#. type: Plain text
#: en/git-push.txt:372
#, priority:220
msgid "This option is equivalent to the <repository> argument. If both are specified, the command-line argument takes precedence."
msgstr "这个选项等同于 < 仓库 > 参数。如果两者都被指定，则以命令行参数为优先。"

#. type: Plain text
#: en/git-push.txt:379
#, placeholders:'linkgit:git-pull[1]':'linkgit:git-config[1]', priority:220
msgid "For every branch that is up to date or successfully pushed, add upstream (tracking) reference, used by argument-less linkgit:git-pull[1] and other commands. For more information, see `branch.<name>.merge` in linkgit:git-config[1]."
msgstr "对于每一个已经更新或成功推送的分支，添加上游（跟踪）引用，由无参数的 linkgit:git-pull[1] 和其他命令使用。更多信息，见 linkgit:git-config[1] 中的 `branch.< 分支名 >.merge`。"

#. type: Labeled list
#: en/git-push.txt:380
#, ignore-same, no-wrap, priority:220
msgid "--[no-]thin"
msgstr "--[no-]thin"

#. type: Plain text
#: en/git-push.txt:385
#, placeholders:'linkgit:git-send-pack[1]':'`--thin`', priority:220
msgid "These options are passed to linkgit:git-send-pack[1]. A thin transfer significantly reduces the amount of sent data when the sender and receiver share many of the same objects in common. The default is `--thin`."
msgstr "这些选项被传递给 linkgit:git-send-pack[1]。当发送方和接收方有许多共同的对象时，稀松传输会大大减少发送的数据量。默认是 `--thin`。"

#. type: Plain text
#: en/git-push.txt:391
#, priority:220
msgid "Suppress all output, including the listing of updated refs, unless an error occurs. Progress is not reported to the standard error stream."
msgstr "抑制所有的输出，包括更新的引用的列表，除非发生错误。进度不会报告给标准错误流。"

#. type: Labeled list
#: en/git-push.txt:403
#, ignore-same, no-wrap, priority:220
msgid "--recurse-submodules=check|on-demand|only|no"
msgstr "--recurse-submodules=check|on-demand|only|no"

#. type: Plain text
#: en/git-push.txt:417
#, placeholders:'`--no-recurse-submodules`':'push.recurseSubmodules', priority:220
msgid "May be used to make sure all submodule commits used by the revisions to be pushed are available on a remote-tracking branch. If 'check' is used Git will verify that all submodule commits that changed in the revisions to be pushed are available on at least one remote of the submodule. If any commits are missing the push will be aborted and exit with non-zero status. If 'on-demand' is used all submodules that changed in the revisions to be pushed will be pushed. If on-demand was not able to push all necessary revisions it will also be aborted and exit with non-zero status. If 'only' is used all submodules will be pushed while the superproject is left unpushed. A value of 'no' or using `--no-recurse-submodules` can be used to override the push.recurseSubmodules configuration variable when no submodule recursion is required."
msgstr "可以用来确保要推送的修订版所使用的所有子模块提交都在远程跟踪分支上可用。 如果使用 'check'，Git 将验证所有在要推送的修订版中发生变化的子模块提交是否在该子模块的至少一个远程上可用。如果缺少任何提交，推送将被中止并以非零状态退出。如果使用 'on-demand'，所有在要推送的修订版中发生变化的子模块都会被推送。如果 on-demand 不能推送所有必要的修订版，它也将被中止并以非零状态退出。如果使用 'only'，所有的子模块将被推送，父级项目则不被推送。当不需要子模块递归时，一个 \"no\" 的值或使用 `--no-recurse-submodules` 可以用来覆盖 push.recurseSubmodules 配置变量。"

#. type: Plain text
#: en/git-push.txt:421
#, placeholders:'push.recurseSubmodules':'submodule.recurse', priority:220
msgid "When using 'on-demand' or 'only', if a submodule has a \"push.recurseSubmodules={on-demand,only}\" or \"submodule.recurse\" configuration, further recursion will occur. In this case, \"only\" is treated as \"on-demand\"."
msgstr "当使用 \"on-demand\" 或 \"only\" 时，如果一个子模块有 \"push.recurseSubmodules={on-demand,only}\" 或 \"submodule.recurse\"配置，将发生进一步递归。在这种情况下，\"only\" 被视为 \"on-demand\"。"

#. type: Plain text
#: en/git-push.txt:426
#, placeholders:'linkgit:githooks[5]':'--verify':'--no-verify', priority:220
msgid "Toggle the pre-push hook (see linkgit:githooks[5]). The default is --verify, giving the hook a chance to prevent the push. With --no-verify, the hook is bypassed completely."
msgstr "切换 pre-push 钩子（见 linkgit:githooks[5]）。 默认是 --verify，给钩子一个机会来阻止推送。 如果使用 --no-verify，钩子会被完全绕过。"

#. type: Plain text
#: en/git-push.txt:443
#, priority:220
msgid "The output of \"git push\" depends on the transport method used; this section describes the output when pushing over the Git protocol (either locally or via ssh)."
msgstr "\"git push\" 的输出取决于所使用的传输方式；本节将介绍通过 Git 协议（本地或通过 ssh）推送时的输出。"

#. type: Plain text
#: en/git-push.txt:446
#, priority:220
msgid "The status of the push is output in tabular form, with each line representing the status of a single ref. Each line is of the form:"
msgstr "推送的状态以表格的形式输出，每一行代表一个引用的状态。每一行的形式是："

#. type: delimited block -
#: en/git-push.txt:449
#, no-wrap, priority:220
msgid " <flag> <summary> <from> -> <to> (<reason>)\n"
msgstr " <标志> <概述> <起始> -> <结束> (<原因>)\n"

#. type: Plain text
#: en/git-push.txt:452
#, placeholders:'--porcelain', priority:220
msgid "If --porcelain is used, then each line of the output is of the form:"
msgstr "如果使用了 --porcelain ，那么输出的每一行都是这样的："

#. type: delimited block -
#: en/git-push.txt:455
#, no-wrap, priority:220
msgid " <flag> \\t <from>:<to> \\t <summary> (<reason>)\n"
msgstr " <标志> \\t <起始>:<结束> \\t <概述> (<原因>)\n"

#. type: Plain text
#: en/git-push.txt:459
#, placeholders:'--porcelain':'--verbose', priority:220
msgid "The status of up-to-date refs is shown only if --porcelain or --verbose option is used."
msgstr "只有在使用 --porcelain 或 --verbose 选项时，才会显示最新引用的状态。"

#. type: Plain text
#: en/git-push.txt:463
#, priority:220
msgid "for a successfully pushed fast-forward;"
msgstr "表示推送成功的快速合并；"

#. type: Plain text
#: en/git-push.txt:465
#, priority:220
msgid "for a successfully deleted ref;"
msgstr "表示一个成功删除的引用；"

#. type: Plain text
#: en/git-push.txt:466
#, priority:220
msgid "for a successfully pushed new ref;"
msgstr "表示成功推送的引用；"

#. type: Plain text
#: en/git-push.txt:467
#, priority:220
msgid "for a ref that was rejected or failed to push; and"
msgstr "表示一个被拒绝或推送失败的引用；并且"

#. type: Plain text
#: en/git-push.txt:468
#, priority:220
msgid "for a ref that was up to date and did not need pushing."
msgstr "表示一个最新的、不需要推送的引用。"

#. type: Plain text
#: en/git-push.txt:474
#, ignore-ellipsis, priority:220
msgid "For a successfully pushed ref, the summary shows the old and new values of the ref in a form suitable for using as an argument to `git log` (this is `<old>..<new>` in most cases, and `<old>...<new>` for forced non-fast-forward updates)."
msgstr "对于一个成功获取的引用，摘要以适合作为 `git log` 参数的形式显示该引用的新旧值（在大多数情况下是 `<旧>..<新>`，对于强制非快速合并是 `<旧>...<新>`）。"

#. type: Plain text
#: en/git-push.txt:476
#, priority:220
msgid "For a failed update, more details are given:"
msgstr "对于失败的更新，会给出更多的细节："

#. type: Labeled list
#: en/git-push.txt:478
#, no-wrap, priority:220
msgid "rejected"
msgstr "已拒绝"

#. type: Plain text
#: en/git-push.txt:481
#, priority:220
msgid "Git did not try to send the ref at all, typically because it is not a fast-forward and you did not force the update."
msgstr "Git 根本没有尝试发送引用，典型的原因是它不是快速合并并且你没有强制更新。"

#. type: Labeled list
#: en/git-push.txt:482
#, no-wrap, priority:220
msgid "remote rejected"
msgstr "远程拒绝"

#. type: Plain text
#: en/git-push.txt:490
#, placeholders:'receive.denyCurrentBranch':'receive.denyNonFastForwards':'receive.denyDeletes':'receive.denyDeleteCurrent':'linkgit:git-config[1]', priority:220
msgid "The remote end refused the update. Usually caused by a hook on the remote side, or because the remote repository has one of the following safety options in effect: `receive.denyCurrentBranch` (for pushes to the checked out branch), `receive.denyNonFastForwards` (for forced non-fast-forward updates), `receive.denyDeletes` or `receive.denyDeleteCurrent`. See linkgit:git-config[1]."
msgstr "远程仓库拒绝更新。 通常是由远程仓库的钩子引起的，或者是因为远程仓库有以下安全选项：`receive.denyCurrentBranch`（用于推送到已检出的分支），`receive.denyNonFastForwards`（用于强制非快进更新），`receive.denyDeletes` 或者 `receive.denyDeleteCurrent`。 见 linkgit:git-config[1]。"

#. type: Labeled list
#: en/git-push.txt:491
#, no-wrap, priority:220
msgid "remote failure"
msgstr "远程故障"

#. type: Plain text
#: en/git-push.txt:495
#, priority:220
msgid "The remote end did not report the successful update of the ref, perhaps because of a temporary error on the remote side, a break in the network connection, or other transient error."
msgstr "远程端没有报告引用的成功更新，可能是因为远程端的临时错误，网络连接中断，或其他瞬时错误。"

#. type: Plain text
#: en/git-push.txt:501
#, priority:220
msgid "The name of the local ref being pushed, minus its `refs/<type>/` prefix. In the case of deletion, the name of the local ref is omitted."
msgstr "被推送的本地引用的名称，减去其 `refs/< 类型 >/` 前缀。在删除的情况下，本地引用的名称被省略。"

#. type: Plain text
#: en/git-push.txt:505
#, priority:220
msgid "The name of the remote ref being updated, minus its `refs/<type>/` prefix."
msgstr "被更新的本地引用的名称，去掉其 `refs/< 类型 >/` 前缀。"

#. type: Plain text
#: en/git-push.txt:510
#, priority:220
msgid "A human-readable explanation. In the case of successfully pushed refs, no explanation is needed. For a failed ref, the reason for failure is described."
msgstr "一个人类可读的解释。在成功推送引用的情况下，不需要解释。对于操作失败的引用，要描述失败的原因。"

#. type: Title -
#: en/git-push.txt:512
#, no-wrap, priority:220
msgid "NOTE ABOUT FAST-FORWARDS"
msgstr "关于快速合并的说明"

#. type: Plain text
#: en/git-push.txt:517
#, priority:220
msgid "When an update changes a branch (or more in general, a ref) that used to point at commit A to point at another commit B, it is called a fast-forward update if and only if B is a descendant of A."
msgstr "当一个更新将原来指向提交 A 的分支（或更普遍的，一个引用）改为指向另一个提交 B 时，当且仅当 B 是 A 的后代时，它被称为快速合并。"

#. type: Plain text
#: en/git-push.txt:521
#, priority:220
msgid "In a fast-forward update from A to B, the set of commits that the original commit A built on top of is a subset of the commits the new commit B builds on top of. Hence, it does not lose any history."
msgstr "在从 A 到 B 的快速合并中，原始提交 A 所建立的提交集是新提交 B 所建立的提交集的一个子集。 因此，它不会丢失任何历史。"

#. type: Plain text
#: en/git-push.txt:526
#, priority:220
msgid "In contrast, a non-fast-forward update will lose history. For example, suppose you and somebody else started at the same commit X, and you built a history leading to commit B while the other person built a history leading to commit A. The history looks like this:"
msgstr "相反，非快速合并更新会丢失历史。 例如，假设你和别人从同一个提交 X 开始，你建立了一个通往提交 B 的历史，而另一个人建立了一个通往提交 A 的历史。 这段历史看起来像这样："

#. type: delimited block -
#: en/git-push.txt:532
#, no-wrap, placeholders:'---X---A', priority:220
msgid ""
"      B\n"
"     /\n"
" ---X---A\n"
msgstr ""
"      B\n"
"     /\n"
" ---X---A\n"

#. type: Plain text
#: en/git-push.txt:538
#, priority:220
msgid "Further suppose that the other person already pushed changes leading to A back to the original repository from which you two obtained the original commit X."
msgstr "进一步假设对方已经将 A 导致的修改推送回原仓库，你们俩从原仓库中获得原始提交 X。"

#. type: Plain text
#: en/git-push.txt:541
#, priority:220
msgid "The push done by the other person updated the branch that used to point at commit X to point at commit A. It is a fast-forward."
msgstr "另一个人所做的推送，将原来指向提交 X 的分支更新为指向提交 A 的分支。"

#. type: Plain text
#: en/git-push.txt:546
#, priority:220
msgid "But if you try to push, you will attempt to update the branch (that now points at A) with commit B. This does _not_ fast-forward. If you did so, the changes introduced by commit A will be lost, because everybody will now start building on top of B."
msgstr "但如果你试图推送，你会试图用提交 B 来更新分支（现在指向 A）。这不是快速合并。 如果你这样做了，提交 A 引入的修改就会丢失，因为大家现在都会在 B 的基础上开始构建。"

#. type: Plain text
#: en/git-push.txt:549
#, priority:220
msgid "The command by default does not allow an update that is not a fast-forward to prevent such loss of history."
msgstr "该命令默认不允许非快速合并的更新，以防止这种历史的损失。"

#. type: Plain text
#: en/git-push.txt:554
#, priority:220
msgid "If you do not want to lose your work (history from X to B) or the work by the other person (history from X to A), you would need to first fetch the history from the repository, create a history that contains changes done by both parties, and push the result back."
msgstr "如果你不想丢失你的工作（从 X 到 B 的历史）或对方的工作（从 X 到 A 的历史），你需要先从仓库中获取历史，创建一个包含双方修改的历史，并将结果推送回去。"

#. type: Plain text
#: en/git-push.txt:558
#, priority:220
msgid "You can perform \"git pull\", resolve potential conflicts, and \"git push\" the result. A \"git pull\" will create a merge commit C between commits A and B."
msgstr "您可以执行 \"git pull\"，解决潜在的冲突，然后将结果 \"git push\"。 一个 \"git pull \"会在提交 A 和 B 之间创建一个合并提交 C。"

#. type: delimited block -
#: en/git-push.txt:564
#, no-wrap, placeholders:'---C':'---X---A', priority:220
msgid ""
"      B---C\n"
"     /   /\n"
" ---X---A\n"
msgstr ""
"      B---C\n"
"     /   /\n"
" ---X---A\n"

#. type: Plain text
#: en/git-push.txt:569
#, priority:220
msgid "Updating A with the resulting merge commit will fast-forward and your push will be accepted."
msgstr "用所产生的合并提交更新 A，将快速合并，你的推送将被接受。"

#. type: Plain text
#: en/git-push.txt:574
#, placeholders:'--rebase', priority:220
msgid "Alternatively, you can rebase your change between X and B on top of A, with \"git pull --rebase\", and push the result back. The rebase will create a new commit D that builds the change between X and B on top of A."
msgstr "另外，你也可以用 \"git pull --rebase\" 将 X 和 B 之间的改动重新归档到 A 之上，然后将结果推送回来。 重置将创建一个新的提交 D，将 X 和 B 之间的修改建立在 A 的基础上。"

#. type: delimited block -
#: en/git-push.txt:580
#, no-wrap, placeholders:'---X---A', priority:220
msgid ""
"      B   D\n"
"     /   /\n"
" ---X---A\n"
msgstr ""
"      B   D\n"
"     /   /\n"
" ---X---A\n"

#. type: Plain text
#: en/git-push.txt:585
#, priority:220
msgid "Again, updating A with this commit will fast-forward and your push will be accepted."
msgstr "同样的，用这个提交更新 A 会快速合并，你的推送会被接受。"

#. type: Plain text
#: en/git-push.txt:596
#, placeholders:'--amend':'--force':'--force', priority:220
msgid "There is another common situation where you may encounter non-fast-forward rejection when you try to push, and it is possible even when you are pushing into a repository nobody else pushes into. After you push commit A yourself (in the first picture in this section), replace it with \"git commit --amend\" to produce commit B, and you try to push it out, because forgot that you have pushed A out already. In such a case, and only if you are certain that nobody in the meantime fetched your earlier commit A (and started building on top of it), you can run \"git push --force\" to overwrite it. In other words, \"git push --force\" is a method reserved for a case where you do mean to lose history."
msgstr "还有一种常见的情况是，当你试图推送时，可能会遇到非快速合并拒绝，即使你推送到一个没有人推送的版本库中也有可能。在你自己推送了提交 A（在本节的第一幅图中），用 \"git commit --amend\" 替换后产生了提交 B，你试图推送它，因为忘记了你已经推送了 A。在这种情况下，只有当您确定在此期间没有人取走您先前的提交 A（并在其基础上开始构建），您才能运行 \"git push --force\" 来覆盖它。换句话说，\"git push --force\" 是一种保留给你确实想失去历史的情况的方法。"

#. type: Labeled list
#: en/git-push.txt:601
#, no-wrap, priority:220
msgid "`git push`"
msgstr "`git push`"

#. type: Plain text
#: en/git-push.txt:605
#, priority:220
msgid "Works like `git push <remote>`, where <remote> is the current branch's remote (or `origin`, if no remote is configured for the current branch)."
msgstr "像`git push < 远端 >`那样工作，其中 < 远端 > 是当前分支的远程仓库（或者`origin`，如果没有为当前分支配置远程仓库）。"

#. type: Labeled list
#: en/git-push.txt:606
#, no-wrap, priority:220
msgid "`git push origin`"
msgstr "`git push origin`"

#. type: Plain text
#: en/git-push.txt:611
#, priority:220
msgid "Without additional configuration, pushes the current branch to the configured upstream (`branch.<name>.merge` configuration variable) if it has the same name as the current branch, and errors out without pushing otherwise."
msgstr "不需要额外配置，如果它与当前分支同名，并且错误输出而不推送其他分支，则将其推送到配置过的上游仓库（`branch.<分支名>.merge` 配置变量）。"

#. type: Plain text
#: en/git-push.txt:615
#, placeholders:'push.default', priority:220
msgid "The default behavior of this command when no <refspec> is given can be configured by setting the `push` option of the remote, or the `push.default` configuration variable."
msgstr "当没有给出< 引用规范 >时，该命令的默认行为可以通过设置远程仓库的 `push` 选项或 `push.default`配置变量来配置。"

#. type: Plain text
#: en/git-push.txt:620
#, placeholders:'remote.origin.push':'HEAD', priority:220
msgid "For example, to default to pushing only the current branch to `origin` use `git config remote.origin.push HEAD`. Any valid <refspec> (like the ones in the examples below) can be configured as the default for `git push origin`."
msgstr "例如，要默认只将当前分支推送到 `origin`，使用 `git config remote.origin.push HEAD`。 任何有效的< 引用规范 >（比如下面例子中的那些）都可以被配置为 `git push origin` 的默认值。"

#. type: Labeled list
#: en/git-push.txt:621
#, no-wrap, priority:220
msgid "`git push origin :`"
msgstr "`git push origin :`"

#. type: Plain text
#: en/git-push.txt:625
#, placeholders:'<<OPTIONS,', priority:220
msgid "Push \"matching\" branches to `origin`. See <refspec> in the <<OPTIONS,OPTIONS>> section above for a description of \"matching\" branches."
msgstr "将 “匹配” 的分支推送到 `origin`。关于 “匹配” 分支的描述，请参见上面 <<OPTIONS,选项>> 部分的 <<引用规范>>。"

#. type: Labeled list
#: en/git-push.txt:626
#, no-wrap, priority:220
msgid "`git push origin master`"
msgstr "`git push origin master`"

#. type: Plain text
#: en/git-push.txt:632
#, priority:220
msgid "Find a ref that matches `master` in the source repository (most likely, it would find `refs/heads/master`), and update the same ref (e.g. `refs/heads/master`) in `origin` repository with it. If `master` did not exist remotely, it would be created."
msgstr "在源仓库中找到一个与 `master` 相匹配的引用（最可能的是找到 `refs/heads/master`），并在 `origin` 仓库中用它更新相同的引用（例如`refs/heads/master`）。 如果 `master` 不存在，它将被创建。"

#. type: Labeled list
#: en/git-push.txt:633
#, no-wrap, placeholders:'HEAD', priority:220
msgid "`git push origin HEAD`"
msgstr "`git push origin HEAD`"

#. type: Plain text
#: en/git-push.txt:636
#, priority:220
msgid "A handy way to push the current branch to the same name on the remote."
msgstr "一个方便的方法是将当前分支推送到远程的相同名称。"

#. type: Labeled list
#: en/git-push.txt:637
#, no-wrap, priority:220
msgid "`git push mothership master:satellite/master dev:satellite/dev`"
msgstr "`git push mothership master:satellite/master dev:satellite/dev`"

#. type: Plain text
#: en/git-push.txt:642
#, priority:220
msgid "Use the source ref that matches `master` (e.g. `refs/heads/master`) to update the ref that matches `satellite/master` (most probably `refs/remotes/satellite/master`) in the `mothership` repository; do the same for `dev` and `satellite/dev`."
msgstr "使用与 \"master\" 相匹配的源引用（例如，`refs/heads/master`）来更新 `mothership` 仓库中与 `satellite/master` 相匹配的引用（很可能是 `refs/remotes/satellite/master`）；对 `dev` 和 `satellite/dev`做同样的操作。"

#. type: Plain text
#: en/git-push.txt:645
#, ignore-ellipsis, priority:220
msgid "See the section describing `<refspec>...` above for a discussion of the matching semantics."
msgstr "关于匹配语义的讨论，请参见上面描述 `<引用规范>...` 的部分。"

#. type: Plain text
#: en/git-push.txt:652
#, priority:220
msgid "This is to emulate `git fetch` run on the `mothership` using `git push` that is run in the opposite direction in order to integrate the work done on `satellite`, and is often necessary when you can only make connection in one way (i.e. satellite can ssh into mothership but mothership cannot initiate connection to satellite because the latter is behind a firewall or does not run sshd)."
msgstr "这是为了模拟在`母舰` 上运行的 `git fetch` ，使用 `git push` 以相反的方向运行，以便整合 `卫星` 上完成的工作，当你只能以一种方式进行连接时（即卫星可以ssh到母舰，但母舰不能启动与卫星的连接，因为后者在防火墙后面或不运行 sshd），这往往是必要的。"

#. type: Plain text
#: en/git-push.txt:657
#, priority:220
msgid "After running this `git push` on the `satellite` machine, you would ssh into the `mothership` and run `git merge` there to complete the emulation of `git pull` that were run on `mothership` to pull changes made on `satellite`."
msgstr "在 `卫星` 机器上运行这个 `git push` 后，你将 ssh 进入 `母舰` 并在那里运行 `git merge` ，以完成对 `母舰` 上运行的 `git pull` 的模拟，以拉取 `卫星` 上的修改。"

#. type: Labeled list
#: en/git-push.txt:658
#, no-wrap, placeholders:'HEAD', priority:220
msgid "`git push origin HEAD:master`"
msgstr "`git push origin HEAD:master`"

#. type: Plain text
#: en/git-push.txt:662
#, priority:220
msgid "Push the current branch to the remote ref matching `master` in the `origin` repository. This form is convenient to push the current branch without thinking about its local name."
msgstr "推送当前分支到远程引用匹配 `master` 的 `origin` 仓库中。这种形式可以方便地推送当前分支，而不必考虑其本地名称。"

#. type: Labeled list
#: en/git-push.txt:663
#, no-wrap, priority:220
msgid "`git push origin master:refs/heads/experimental`"
msgstr "`git push origin master:refs/heads/experimental`"

#. type: Plain text
#: en/git-push.txt:669
#, priority:220
msgid "Create the branch `experimental` in the `origin` repository by copying the current `master` branch. This form is only needed to create a new branch or tag in the remote repository when the local name and the remote name are different; otherwise, the ref name on its own will work."
msgstr "通过复制当前的 `master` 分支，在 `origin` 仓库创建 `experimental` 分支。 只有在本地名称和远程名称不同的情况下，在远程仓库中创建新的分支或标签时才需要这个表单；否则，参考名称本身就可以了。"

#. type: Labeled list
#: en/git-push.txt:670
#, no-wrap, priority:220
msgid "`git push origin :experimental`"
msgstr "`git push origin :experimental`"

#. type: Plain text
#: en/git-push.txt:673
#, priority:220
msgid "Find a ref that matches `experimental` in the `origin` repository (e.g. `refs/heads/experimental`), and delete it."
msgstr "在 `origin` 仓库（例如`refs/heads/experimental`）中找到一个与 `experimental` 相匹配的引用，并将其删除。"

#. type: Labeled list
#: en/git-push.txt:674
#, no-wrap, priority:220
msgid "`git push origin +dev:master`"
msgstr "`git push origin +dev:master`"

#. type: Plain text
#: en/git-push.txt:679
#, priority:220
msgid "Update the origin repository's master branch with the dev branch, allowing non-fast-forward updates. *This can leave unreferenced commits dangling in the origin repository.* Consider the following situation, where a fast-forward is not possible:"
msgstr "用开发分支更新仓库的主分支，允许非快速合并更新。 *这可能会使未引用的提交在源码库中悬空。*考虑以下情况，即不可能进行快速合并："

#. type: delimited block -
#: en/git-push.txt:684
#, no-wrap, placeholders:'o---o---o---':'---B':'---Y---Z', priority:220
msgid ""
"\t    o---o---o---A---B  origin/master\n"
"\t\t     \\\n"
"\t\t      X---Y---Z  dev\n"
msgstr ""
"\t    o---o---o---A---B  origin/master\n"
"\t\t     \\\n"
"\t\t      X---Y---Z  dev\n"

#. type: Plain text
#: en/git-push.txt:687
#, priority:220
msgid "The above command would change the origin repository to"
msgstr "上面的命令将 origin 仓库更改为"

#. type: delimited block -
#: en/git-push.txt:692
#, no-wrap, placeholders:'---B':'o---o---o---':'---Y---Z', priority:220
msgid ""
"\t\t      A---B  (unnamed branch)\n"
"\t\t     /\n"
"\t    o---o---o---X---Y---Z  master\n"
msgstr ""
"\t\t      A---B  (unnamed branch)\n"
"\t\t     /\n"
"\t    o---o---o---X---Y---Z  master\n"

#. type: Plain text
#: en/git-push.txt:697
#, priority:220
msgid "Commits A and B would no longer belong to a branch with a symbolic name, and so would be unreachable. As such, these commits would be removed by a `git gc` command on the origin repository."
msgstr "提交 A 和 B 将不再属于具有符号名称的分支，因此将不可访问。因此，这些提交将被原始存储库上的“ gitgc”命令删除。"

#. type: Title =
#: en/git-quiltimport.txt:2
#, ignore-same, no-wrap, priority:90
msgid "git-quiltimport(1)"
msgstr "git-quiltimport(1)"

#. type: Plain text
#: en/git-quiltimport.txt:7
#, placeholders:'git-quiltimport', priority:90
msgid "git-quiltimport - Applies a quilt patchset onto the current branch"
msgstr "git-quiltimport - 在当前分支上应用被子补丁集"

#. type: Plain text
#: en/git-quiltimport.txt:14
#, no-wrap, placeholders:'[--dry-run':'[--author':'[--patches':'[--series':'[--keep-non-patch]', priority:90
msgid ""
"'git quiltimport' [--dry-run | -n] [--author <author>] [--patches <dir>]\n"
"\t\t[--series <file>] [--keep-non-patch]\n"
msgstr ""
"'git quiltimport' [--dry-run | -n] [--author <作者>] [--patches <目录>]\n"
"\t\t[--series <文件>] [--keep-non-patch]\n"

#. type: Plain text
#: en/git-quiltimport.txt:21
#, priority:90
msgid "Applies a quilt patchset onto the current Git branch, preserving the patch boundaries, patch order, and patch descriptions present in the quilt patchset."
msgstr "在当前 Git 分支上应用拼接补丁集，保留拼接补丁集中的补丁边界、补丁顺序和补丁描述。"

#. type: Plain text
#: en/git-quiltimport.txt:27
#, placeholders:'--author':'--author', priority:90
msgid "For each patch the code attempts to extract the author from the patch description. If that fails it falls back to the author specified with --author. If the --author flag was not given the patch description is displayed and the user is asked to interactively enter the author of the patch."
msgstr "对于每个补丁，代码会尝试从补丁描述中提取作者。 如果失败，则返回到用 --author 指定的作者。 如果没有给定 --author 标志，则显示补丁描述，并要求用户交互式输入补丁的作者。"

#. type: Plain text
#: en/git-quiltimport.txt:30
#, priority:90
msgid "If a subject is not found in the patch description the patch name is preserved as the 1 line subject in the Git description."
msgstr "如果在补丁描述中找不到主题，补丁名称将保留为 Git 描述中的一行主题。"

#. type: Plain text
#: en/git-quiltimport.txt:40
#, priority:90
msgid "Walk through the patches in the series and warn if we cannot find all of the necessary information to commit a patch. At the time of this writing only missing author information is warned about."
msgstr "浏览系列补丁，并在无法找到提交补丁所需的全部信息时发出警告。 在写这篇文章的时候，只有缺少作者信息的补丁才会被警告。"

#. type: Labeled list
#: en/git-quiltimport.txt:41
#, no-wrap, placeholders:'--author', priority:90
msgid "--author 'Author Name <Author Email>'"
msgstr "--author 'Author Name <作者邮箱>'"

#. type: Plain text
#: en/git-quiltimport.txt:44
#, priority:90
msgid "The author name and email address to use when no author information can be found in the patch description."
msgstr "在补丁说明中找不到作者信息时使用的作者姓名和电子邮件地址。"

#. type: Labeled list
#: en/git-quiltimport.txt:45
#, no-wrap, placeholders:'--patches', priority:90
msgid "--patches <dir>"
msgstr "--patches <目录>"

#. type: Plain text
#: en/git-quiltimport.txt:47
#, priority:90
msgid "The directory to find the quilt patches."
msgstr "查找被子补丁的目录。"

#. type: Plain text
#: en/git-quiltimport.txt:51
#, placeholders:'$QUILT_PATCHES', priority:90
msgid "The default for the patch directory is 'patches' or the value of the `$QUILT_PATCHES` environment variable."
msgstr "补丁目录默认为 'patches' 或环境变量 `$QUILT_PATCHES` 的值。"

#. type: Labeled list
#: en/git-quiltimport.txt:52
#, no-wrap, placeholders:'--series', priority:90
msgid "--series <file>"
msgstr "--series <文件>"

#. type: Plain text
#: en/git-quiltimport.txt:54
#, priority:90
msgid "The quilt series file."
msgstr "被子系列文件。"

#. type: Plain text
#: en/git-quiltimport.txt:58
#, placeholders:'$QUILT_SERIES', priority:90
msgid "The default for the series file is <patches>/series or the value of the `$QUILT_SERIES` environment variable."
msgstr "系列文件的默认值是 <patches>/series 或 `$QUILT_SERIES` 环境变量的值。"

#. type: Title =
#: en/git-range-diff.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-range-diff(1)"
msgstr "git-range-diff(1)"

#. type: Plain text
#: en/git-range-diff.txt:7
#, placeholders:'git-range-diff', priority:100
msgid "git-range-diff - Compare two commit ranges (e.g. two versions of a branch)"
msgstr "git-range-diff - 比较两个提交范围（例如一个分支的两个版本）"

#. type: Plain text
#: en/git-range-diff.txt:16
#, ignore-ellipsis, no-wrap, placeholders:'git range-diff':'[--color=[':'[--no-color]':'[--no-dual-color]':'[--creation-factor=':'[--left-only':'--right-only]', priority:100
msgid ""
"'git range-diff' [--color=[<when>]] [--no-color] [<diff-options>]\n"
"\t[--no-dual-color] [--creation-factor=<factor>]\n"
"\t[--left-only | --right-only]\n"
"\t( <range1> <range2> | <rev1>...<rev2> | <base> <rev1> <rev2> )\n"
"\t[[--] <path>...]\n"
msgstr ""
"'git range-diff' [--color=[<何时>]] [--no-color] [<差异选项>]\n"
"\t[--no-dual-color] [--creation-factor=<系数>]\n"
"\t[--left-only | --right-only]\n"
"\t( <范围 1> <范围 2> | <修订 1>...<修订 2> | <基础> <修订 1> <修订 2> )\n"
"\t[[--] <path>...]\n"

#. type: Plain text
#: en/git-range-diff.txt:22
#, priority:100
msgid "This command shows the differences between two versions of a patch series, or more generally, two commit ranges (ignoring merge commits)."
msgstr "该命令显示补丁系列的两个版本之间的差异，或者更笼统地说，两个提交范围之间的差异（忽略合并提交）。"

#. type: Plain text
#: en/git-range-diff.txt:25
#, priority:100
msgid "In the presence of `<path>` arguments, these commit ranges are limited accordingly."
msgstr "如果存在 `<path>` 参数，这些提交范围将受到相应的限制。"

#. type: Plain text
#: en/git-range-diff.txt:31
#, priority:100
msgid "To that end, it first finds pairs of commits from both commit ranges that correspond with each other. Two commits are said to correspond when the diff between their patches (i.e. the author information, the commit message and the commit diff) is reasonably small compared to the patches' size. See ``Algorithm`` below for details."
msgstr "为此，它首先从两个提交范围中找到相互对应的提交对。当两个补丁之间的差值（即作者信息、提交信息和提交差值）相对于补丁的大小相当小时，这两个提交就被认为是对应的。详见下面的 ``算法``。"

#. type: Plain text
#: en/git-range-diff.txt:35
#, priority:100
msgid "Finally, the list of matching commits is shown in the order of the second commit range, with unmatched commits being inserted just after all of their ancestors have been shown."
msgstr "最后，匹配的提交列表会按照第二个提交范围的顺序显示，未匹配的提交会在其所有祖先提交显示之后插入。"

#. type: Plain text
#: en/git-range-diff.txt:37
#, priority:100
msgid "There are three ways to specify the commit ranges:"
msgstr "指定提交范围有三种方法 :"

#. type: Plain text
#: en/git-range-diff.txt:41
#, placeholders:'linkgit:gitrevisions[7]', priority:100
msgid "`<range1> <range2>`: Either commit range can be of the form `<base>..<rev>`, `<rev>^!` or `<rev>^-<n>`. See `SPECIFYING RANGES` in linkgit:gitrevisions[7] for more details."
msgstr "`<range1> <range2>`： 提交范围可以是 `<base>...<rev>`、`<rev>^!` 或 `<rev>^-<n>`。详见 linkgit:gitrevisions[7] 中的 `指定范围`。"

#. type: Plain text
#: en/git-range-diff.txt:44
#, ignore-ellipsis, priority:100
msgid "`<rev1>...<rev2>`. This is equivalent to `<rev2>..<rev1> <rev1>..<rev2>`."
msgstr "`<rev1>...<rev2>`。这等同于 `<rev2>...<rev1> <rev1>...<rev2>`."

#. type: Plain text
#: en/git-range-diff.txt:47
#, priority:100
msgid "`<base> <rev1> <rev2>`: This is equivalent to `<base>..<rev1> <base>..<rev2>`."
msgstr "`<base> <rev1> <rev2>`： 等同于 `<base>..<rev1> <base>..<rev2>`."

#. type: Labeled list
#: en/git-range-diff.txt:50
#, ignore-same, no-wrap, priority:100
msgid "--no-dual-color"
msgstr "--no-dual-color"

#. type: Plain text
#: en/git-range-diff.txt:55
#, placeholders:'git range-diff', priority:100
msgid "When the commit diffs differ, `git range-diff` recreates the original diffs' coloring, and adds outer -/+ diff markers with the *background* being red/green to make it easier to see e.g. when there was a change in what exact lines were added."
msgstr "当提交的差异不同时，`git range-diff`会重现原始差异的颜色，并添加外层的 -/+ 差异标记，*背景* 为红/绿色，以便于查看，例如，当具体添加了哪些行时。"

#. type: Plain text
#: en/git-range-diff.txt:63
#, placeholders:'color.diff':'color.diff', priority:100
msgid "Additionally, the commit diff lines that are only present in the first commit range are shown \"dimmed\" (this can be overridden using the `color.diff.<slot>` config setting where `<slot>` is one of `contextDimmed`, `oldDimmed` and `newDimmed`), and the commit diff lines that are only present in the second commit range are shown in bold (which can be overridden using the config settings `color.diff.<slot>` with `<slot>` being one of `contextBold`, `oldBold` or `newBold`)."
msgstr "此外，只出现在第一个提交范围内的提交差异行会显示为 \"dimmed\"（这可以使用 `color.diff. <slot>` 配置设置，其中 `<slot>` 是`contextDimmed`、`oldDimmed` 和 `newDimmed` 中的一个），而仅出现在第二个提交范围内的提交差异行以粗体显示（这可以通过配置设置 `color.diff.<slot>` 来覆盖，其中 `<slot>` 是 `contextBold`、`oldBold` 和 `newBold` 中的一个）。"

#. type: Plain text
#: en/git-range-diff.txt:67
#, placeholders:'`--no-dual-color`', priority:100
msgid "This is known to `range-diff` as \"dual coloring\". Use `--no-dual-color` to revert to color all lines according to the outer diff markers (and completely ignore the inner diff when it comes to color)."
msgstr "这在 `range-diff` 中被称为 \"双重着色\"。使用 `--no-dual-color` 可以还原为根据外部差异标记对所有线条着色（在着色时完全忽略内部差异）。"

#. type: Plain text
#: en/git-range-diff.txt:75
#, placeholders:'git range-diff', priority:100
msgid "Set the creation/deletion cost fudge factor to `<percent>`. Defaults to 60. Try a larger value if `git range-diff` erroneously considers a large change a total rewrite (deletion of one commit and addition of another), and a smaller one in the reverse case. See the ``Algorithm`` section below for an explanation of why this is needed."
msgstr "将创建/删除成本误差因子设置为 `<百分比>`。 默认为 60。如果 `git range-diff` 错误地认为一个大的改动是完全重写 (删除一个提交，增加另一个提交)，可以使用较大的值，反之则使用较小的值。 请参阅下面的 ``算法`` 部分以了解为什么需要这个值。"

#. type: Labeled list
#: en/git-range-diff.txt:76 en/rev-list-options.txt:289
#, ignore-same, no-wrap, priority:260
msgid "--left-only"
msgstr "--left-only"

#. type: Plain text
#: en/git-range-diff.txt:79
#, ignore-ellipsis, priority:100
msgid "Suppress commits that are missing from the first specified range (or the \"left range\" when using the `<rev1>...<rev2>` format)."
msgstr "忽略第一个指定范围（或使用 `<rev1>...<rev2>` 格式时的 \"左侧范围\"）中丢失的提交。"

#. type: Labeled list
#: en/git-range-diff.txt:80 en/rev-list-options.txt:290
#, ignore-same, no-wrap, priority:260
msgid "--right-only"
msgstr "--right-only"

#. type: Plain text
#: en/git-range-diff.txt:83
#, ignore-ellipsis, priority:100
msgid "Suppress commits that are missing from the second specified range (or the \"right range\" when using the `<rev1>...<rev2>` format)."
msgstr "忽略第二个指定范围（或使用 `<rev1>...<rev2>` 格式时的 \"右侧范围\"）中丢失的提交。"

#. type: Labeled list
#: en/git-range-diff.txt:84
#, no-wrap, priority:100
msgid "--[no-]notes[=<ref>]"
msgstr "--[no-]notes[=<引用>]"

#. type: Plain text
#: en/git-range-diff.txt:87
#, placeholders:'linkgit:git-log[1]', priority:100
msgid "This flag is passed to the `git log` program (see linkgit:git-log[1]) that generates the patches."
msgstr "这个标志将传递给生成补丁的 `git log` 程序（参见 linkgit:git-log[1]）。"

#. type: Labeled list
#: en/git-range-diff.txt:88
#, no-wrap, priority:100
msgid "<range1> <range2>"
msgstr "<范围1> <范围2>"

#. type: Plain text
#: en/git-range-diff.txt:91
#, priority:100
msgid "Compare the commits specified by the two ranges, where `<range1>` is considered an older version of `<range2>`."
msgstr "比较两个范围指定的提交，其中 `<range1>` 被认为是 `<range2>` 的旧版本。"

#. type: Labeled list
#: en/git-range-diff.txt:92
#, ignore-ellipsis, no-wrap, priority:100
msgid "<rev1>...<rev2>"
msgstr "'<修订 1>..<修订 2>'"

#. type: Plain text
#: en/git-range-diff.txt:94
#, priority:100
msgid "Equivalent to passing `<rev2>..<rev1>` and `<rev1>..<rev2>`."
msgstr "相当于传递 `<rev2>...<rev1>` 和 `<rev1>...<rev2>`。"

#. type: Labeled list
#: en/git-range-diff.txt:95
#, no-wrap, priority:100
msgid "<base> <rev1> <rev2>"
msgstr "<基础> <修订 1> <修订 2>"

#. type: Plain text
#: en/git-range-diff.txt:101
#, placeholders:'git range-diff':'{u}':'{1}', priority:100
msgid "Equivalent to passing `<base>..<rev1>` and `<base>..<rev2>`. Note that `<base>` does not need to be the exact branch point of the branches. Example: after rebasing a branch `my-topic`, `git range-diff my-topic@{u} my-topic@{1} my-topic` would show the differences introduced by the rebase."
msgstr "等同于传递 `<base>...<rev1>` 和 `<base>...<rev2>`。 注意 `<base>` 不需要是分支的确切分支点。例如： 在重定向分支 `my-topic` 之后， `git range-diff my-topic@{u} my-topic@{1} my-topic` 将显示重定向带来的差异。"

#. type: Plain text
#: en/git-range-diff.txt:108
#, placeholders:'git range-diff':'linkgit:git-diff[1]':'`--color=[':'`--no-color`', priority:100
msgid "`git range-diff` also accepts the regular diff options (see linkgit:git-diff[1]), most notably the `--color=[<when>]` and `--no-color` options. These options are used when generating the \"diff between patches\", i.e. to compare the author, commit message and diff of corresponding old/new commits. There is currently no means to tweak most of the diff options passed to `git log` when generating those patches."
msgstr "`git range-diff` 也接受常规的 diff 选项 (参见 linkgit:git-diff[1])，特别是 `--color=[<when>]` 和 `--no-color` 选项。这些选项用于生成 “补丁间的差异”，即比较新旧提交的作者、提交信息和差异。目前还没有办法调整生成补丁时传递给 `git log` 的大部分 diff 选项。"

#. type: Title -
#: en/git-range-diff.txt:110
#, no-wrap, priority:100
msgid "OUTPUT STABILITY"
msgstr "输出稳定性"

#. type: Plain text
#: en/git-range-diff.txt:119
#, placeholders:'`--stable`':'linkgit:git-patch-id[1]':'linkgit:git-apply[1]', priority:100
msgid "The output of the `range-diff` command is subject to change. It is intended to be human-readable porcelain output, not something that can be used across versions of Git to get a textually stable `range-diff` (as opposed to something like the `--stable` option to linkgit:git-patch-id[1]). There's also no equivalent of linkgit:git-apply[1] for `range-diff`, the output is not intended to be machine-readable."
msgstr "`range-diff` 命令的输出可能会改变。它的目的是提供人类可读的上层命令输出，而不是可以在不同版本的 Git 中使用以获得文本稳定的 `range-diff` (与 linkgit:git-patch-id[1] 的 `--stable` 选项不同)。对于 `range-diff` 来说，也没有与 linkgit:git-apply[1] 等价的东西，其输出不是机器可读的。"

#. type: Plain text
#: en/git-range-diff.txt:126
#, placeholders:'`--stat`':'`--stat`', priority:100
msgid "This is particularly true when passing in diff options. Currently some options like `--stat` can, as an emergent effect, produce output that's quite useless in the context of `range-diff`. Future versions of `range-diff` may learn to interpret such options in a manner specific to `range-diff` (e.g. for `--stat` producing human-readable output which summarizes how the diffstat changed)."
msgstr "当传递 diff 选项时尤其如此。目前，一些选项，例如 `--stat`，会在 `range-diff` 的上下文中产生无用的输出。未来版本的 `range-diff` 可能会学习如何以 `range-diff` 特有的方式来解释这些选项 (例如， `--stat` 产生人类可读的输出，总结了 diffstat 的变化情况)。"

#. type: Plain text
#: en/git-range-diff.txt:132
#, placeholders:'diff.color':'pager.range':'linkgit:git-config[1]', priority:100
msgid "This command uses the `diff.color.*` and `pager.range-diff` settings (the latter is on by default). See linkgit:git-config[1]."
msgstr "该命令使用 `diff.color.*` 和 `pager.range-diff` 设置（后者默认开启）。 参见 linkgit:git-config[1]。"

#. type: Plain text
#: en/git-range-diff.txt:139
#, priority:100
msgid "When a rebase required merge conflicts to be resolved, compare the changes introduced by the rebase directly afterwards using:"
msgstr "当重置需要解决合并冲突时，直接比较重置后引入的更改，使用 :"

#. type: delimited block -
#: en/git-range-diff.txt:142
#, no-wrap, placeholders:'git range-diff':'{u}':'{1}', priority:100
msgid "$ git range-diff @{u} @{1} @\n"
msgstr "$ git range-diff @{u} @{1} @\n"

#. type: Plain text
#: en/git-range-diff.txt:146
#, placeholders:'git range-diff', priority:100
msgid "A typical output of `git range-diff` would look like this:"
msgstr "`git range-diff` 的典型输出如下："

#. type: delimited block -
#: en/git-range-diff.txt:153
#, no-wrap, placeholders:'-------', priority:100
msgid ""
"-:  ------- > 1:  0ddba11 Prepare for the inevitable!\n"
"1:  c0debee = 2:  cab005e Add a helpful message at the start\n"
"2:  f00dbal ! 3:  decafe1 Describe a bug\n"
"    @@ -1,3 +1,3 @@\n"
"     Author: A U Thor <author@example.com>\n"
msgstr ""
"-:  ------- > 1:  0ddba11 Prepare for the inevitable!\n"
"1:  c0debee = 2:  cab005e Add a helpful message at the start\n"
"2:  f00dbal ! 3:  decafe1 Describe a bug\n"
"    @@ -1,3 +1,3 @@\n"
"     Author: A U Thor <author@example.com>\n"

#. type: delimited block -
#: en/git-range-diff.txt:158
#, no-wrap, priority:100
msgid ""
"    -TODO: Describe a bug\n"
"    +Describe a bug\n"
"    @@ -324,5 +324,6\n"
"      This is expected.\n"
msgstr ""
"    -TODO: 描述一个错误\n"
"    +描述一个错误\n"
"    @@ -324,5 +324,6\n"
"      这是意料之中的。\n"

#. type: delimited block -
#: en/git-range-diff.txt:162
#, no-wrap, priority:100
msgid ""
"    -+What is unexpected is that it will also crash.\n"
"    ++Unexpectedly, it also crashes. This is a bug, and the jury is\n"
"    ++still out there how to fix it best. See ticket #314 for details.\n"
msgstr ""
"    -+出乎意料的是，它也会崩溃。\n"
"    ++出乎意料的是，它也会崩溃。这是一个bug，陪审团还在讨论如何最好地修复它。\n"
"    ++如何最好地修复它，还没有定论。详见 #314 号记录。\n"

#. type: delimited block -
#: en/git-range-diff.txt:165
#, no-wrap, placeholders:'-------', priority:100
msgid ""
"      Contact\n"
"3:  bedead < -:  ------- TO-UNDO\n"
msgstr ""
"      Contact\n"
"3:  bedead < -:  ------- TO-UNDO\n"

#. type: Plain text
#: en/git-range-diff.txt:170
#, priority:100
msgid "In this example, there are 3 old and 3 new commits, where the developer removed the 3rd, added a new one before the first two, and modified the commit message of the 2nd commit as well as its diff."
msgstr "在这个例子中，有 3 个旧提交和 3 个新提交，开发人员删除了第 3 个提交，在前两个提交之前添加了一个新提交，并修改了第 2 个提交的提交信息及其差异。"

#. type: Plain text
#: en/git-range-diff.txt:177
#, priority:100
msgid "When the output goes to a terminal, it is color-coded by default, just like regular `git diff`'s output. In addition, the first line (adding a commit) is green, the last line (deleting a commit) is red, the second line (with a perfect match) is yellow like the commit header of `git show`'s output, and the third line colors the old commit red, the new one green and the rest like `git show`'s commit header."
msgstr "当输出到终端时，默认是用颜色编码的，就像普通的 `git diff` 输出一样。此外，第一行（添加提交）是绿色的，最后一行（删除提交）是红色的，第二行（完全匹配）是黄色的，就像 `git show` 输出的提交头一样，第三行旧提交是红色的，新提交是绿色的，其余的就像 `git show` 的提交头一样。"

#. type: Plain text
#: en/git-range-diff.txt:182
#, priority:100
msgid "A naive color-coded diff of diffs is actually a bit hard to read, though, as it colors the entire lines red or green. The line that added \"What is unexpected\" in the old commit, for example, is completely red, even if the intent of the old commit was to add something."
msgstr "不过，用颜色编码的原 diff 实际上有点难读，因为它会把整行都染成红色或绿色。例如，在旧提交中添加了 \"What is unexpected\" 的那行就完全是红色的，即使旧提交的意图是添加一些东西。"

#. type: Plain text
#: en/git-range-diff.txt:188
#, placeholders:'`--dual-color`', priority:100
msgid "To help with that, `range` uses the `--dual-color` mode by default. In this mode, the diff of diffs will retain the original diff colors, and prefix the lines with -/+ markers that have their *background* red or green, to make it more obvious that they describe how the diff itself changed."
msgstr "为了解决这个问题，`range` 默认使用 `--dual-color` 模式。在这种模式下，diffs 的 diff 将保留原始的 diff 颜色，并在行的前缀加上 -/+ 标记，其 *背景* 为红色或绿色，以便更明显地描述 diff 本身是如何改变的。"

#. type: Title -
#: en/git-range-diff.txt:191
#, no-wrap, priority:100
msgid "Algorithm"
msgstr "算法"

#. type: Plain text
#: en/git-range-diff.txt:195
#, priority:100
msgid "The general idea is this: we generate a cost matrix between the commits in both commit ranges, then solve the least-cost assignment."
msgstr "总体思路是这样的：我们在两个提交范围内的提交之间生成一个成本矩阵，然后求解最小成本分配。"

#. type: Plain text
#: en/git-range-diff.txt:199
#, priority:100
msgid "The cost matrix is populated thusly: for each pair of commits, both diffs are generated and the \"diff of diffs\" is generated, with 3 context lines, then the number of lines in that diff is used as cost."
msgstr "成本矩阵是这样填充的：对于每一对提交，生成两个差异，并生成 “差异的差异”，其中包含 3 行上下文，然后将差异中的行数作为成本。"

#. type: Plain text
#: en/git-range-diff.txt:204
#, priority:100
msgid "To avoid false positives (e.g. when a patch has been removed, and an unrelated patch has been added between two iterations of the same patch series), the cost matrix is extended to allow for that, by adding fixed-cost entries for wholesale deletes/adds."
msgstr "为了避免假阳性（例如，当一个补丁被删除，而在同一补丁系列的两次迭代之间又添加了一个不相关的补丁），成本矩阵通过为整体删除/添加添加固定成本条目进行扩展，以考虑到这一点。"

#. type: Plain text
#: en/git-range-diff.txt:209
#, placeholders:'--2`':'--C`', priority:100
msgid "Example: Let commits `1--2` be the first iteration of a patch series and `A--C` the second iteration. Let's assume that `A` is a cherry-pick of `2,` and `C` is a cherry-pick of `1` but with a small modification (say, a fixed typo). Visualize the commits as a bipartite graph:"
msgstr "示例： 假设 `1--2` 是补丁系列的第一次迭代，`A--C`是第二次迭代。假设 `A`是从 `2` 中挑选出来的，而 `C` 是从 `1` 中挑选出来的，但做了一点修改（比如，一个固定的错别字）。将提交可视化为一个二元图："

#. type: delimited block -
#: en/git-range-diff.txt:212
#, no-wrap, priority:100
msgid "    1            A\n"
msgstr "    1            A\n"

#. type: delimited block -
#: en/git-range-diff.txt:214
#, no-wrap, priority:100
msgid "    2            B\n"
msgstr "    2            B\n"

#. type: delimited block -
#: en/git-range-diff.txt:216 en/git-range-diff.txt:228
#, no-wrap, priority:100
msgid "\t\t C\n"
msgstr "\t\t C\n"

#. type: Plain text
#: en/git-range-diff.txt:220
#, priority:100
msgid "We are looking for a \"best\" explanation of the new series in terms of the old one. We can represent an \"explanation\" as an edge in the graph:"
msgstr "我们正在寻找新系列对旧系列的 “最佳” 解释。我们可以将 “解释” 表示为图中的一条边："

#. type: delimited block -
#: en/git-range-diff.txt:226
#, no-wrap, placeholders:'--------', priority:100
msgid ""
"    1            A\n"
"\t       /\n"
"    2 --------'  B\n"
msgstr ""
"    1            A\n"
"\t       /\n"
"    2 --------'  B\n"

#. type: Plain text
#: en/git-range-diff.txt:233
#, priority:100
msgid "This explanation comes for \"free\" because there was no change. Similarly `C` could be explained using `1`, but that comes at some cost c>0 because of the modification:"
msgstr "这个解释是 “免费” 的，因为没有任何改变。同样地，`C` 可以用 `1`来解释，但由于修改，这需要付出一定的代价 c>0 :"

#. type: delimited block -
#: en/git-range-diff.txt:241
#, no-wrap, placeholders:'----':'----':'---':'`-----', priority:100
msgid ""
"    1 ----.      A\n"
"\t  |    /\n"
"    2 ----+---'  B\n"
"\t  |\n"
"\t  `----- C\n"
"\t  c>0\n"
msgstr ""
"    1 ----.      A\n"
"\t  |    /\n"
"    2 ----+---'  B\n"
"\t  |\n"
"\t  `----- C\n"
"\t  c>0\n"

#. type: Plain text
#: en/git-range-diff.txt:249
#, priority:100
msgid "In mathematical terms, what we are looking for is some sort of a minimum cost bipartite matching; `1` is matched to `C` at some cost, etc. The underlying graph is in fact a complete bipartite graph; the cost we associate with every edge is the size of the diff between the two commits' patches. To explain also new commits, we introduce dummy nodes on both sides:"
msgstr "用数学术语来说，我们要寻找的是某种最小代价的双栅格匹配；`1` 以某种代价匹配到 `C`，等等。底层图实际上是一个完整的双向图；我们与每条边相关联的代价是两个提交补丁之间的差值大小。为了解释新提交，我们在两边都引入了虚节点："

#. type: delimited block -
#: en/git-range-diff.txt:258
#, no-wrap, placeholders:'----':'----':'---':'`-----', priority:100
msgid ""
"    1 ----.      A\n"
"\t  |    /\n"
"    2 ----+---'  B\n"
"\t  |\n"
"    o     `----- C\n"
"\t  c>0\n"
"    o            o\n"
msgstr ""
"    1 ----.      A\n"
"\t  |    /\n"
"    2 ----+---'  B\n"
"\t  |\n"
"    o     `----- C\n"
"\t  c>0\n"
"    o            o\n"

#. type: delimited block -
#: en/git-range-diff.txt:260
#, no-wrap, priority:100
msgid "    o            o\n"
msgstr "    o            o\n"

#. type: Plain text
#: en/git-range-diff.txt:270
#, placeholders:'--C`':'o--o':'--C`':'o--o':'--o`':'--C`', priority:100
msgid "The cost of an edge `o--C` is the size of `C`'s diff, modified by a fudge factor that should be smaller than 100%. The cost of an edge `o--o` is free. The fudge factor is necessary because even if `1` and `C` have nothing in common, they may still share a few empty lines and such, possibly making the assignment `1--C`, `o--o` slightly cheaper than `1--o`, `o--C` even if `1` and `C` have nothing in common. With the fudge factor we require a much larger common part to consider patches as corresponding."
msgstr "边 `o--C` 的代价是 `C` 的差值大小，再加上一个应小于 100% 的修正系数。边 `o--o` 的代价是免费的。修正系数是必要的，因为即使 `1` 和 `C` 没有共同点，它们仍可能共享一些空行等，这可能会使赋值 `1--C`, `o--o` 比 `1--o`, `o--C` 稍微便宜一些，即使 `1` 和 `C` 没有共同点。有了模糊因子，我们需要更大的公共部分才能将补丁视为一对的。"

#. type: Plain text
#: en/git-range-diff.txt:277
#, priority:100
msgid "The overall time needed to compute this algorithm is the time needed to compute n+m commit diffs and then n*m diffs of patches, plus the time needed to compute the least-cost assignment between n and m diffs. Git uses an implementation of the Jonker-Volgenant algorithm to solve the assignment problem, which has cubic runtime complexity. The matching found in this case will look like this:"
msgstr "计算该算法所需的总时间是计算 n+m 个提交差异和 n*m 个补丁差异所需的时间，再加上计算 n 和 m 个差异之间的最小成本赋值所需的时间。Git 使用 Jonker-Volgenant 算法来解决分配问题，该算法的运行复杂度为立方。在这种情况下找到的匹配结果是这样的 :"

#. type: delimited block -
#: en/git-range-diff.txt:286
#, no-wrap, placeholders:'----':'----':'---':'-----':'`-----':'----------', priority:100
msgid ""
"    1 ----.      A\n"
"\t  |    /\n"
"    2 ----+---'  B\n"
"       .--+-----'\n"
"    o -'  `----- C\n"
"\t  c>0\n"
"    o ---------- o\n"
msgstr ""
"    1 ----.      A\n"
"\t  |    /\n"
"    2 ----+---'  B\n"
"       .--+-----'\n"
"    o -'  `----- C\n"
"\t  c>0\n"
"    o ---------- o\n"

#. type: delimited block -
#: en/git-range-diff.txt:288
#, no-wrap, placeholders:'----------', priority:100
msgid "    o ---------- o\n"
msgstr "    o ---------- o\n"

#. type: Title =
#: en/git-read-tree.txt:2
#, ignore-same, no-wrap, priority:80
msgid "git-read-tree(1)"
msgstr "git-read-tree(1)"

#. type: Plain text
#: en/git-read-tree.txt:7
#, placeholders:'git-read-tree', priority:80
msgid "git-read-tree - Reads tree information into the index"
msgstr "git-read-tree - 将树信息读入索引"

#. type: Plain text
#: en/git-read-tree.txt:15
#, no-wrap, placeholders:'git read-tree':'[--trivial]':'[--aggressive]':'--reset':'--prefix=':'[--index-output=':'[--no-sparse-checkout]':'--empty', priority:80
msgid ""
"'git read-tree' [(-m [--trivial] [--aggressive] | --reset | --prefix=<prefix>)\n"
"\t\t[-u | -i]] [--index-output=<file>] [--no-sparse-checkout]\n"
"\t\t(--empty | <tree-ish1> [<tree-ish2> [<tree-ish3>]])\n"
msgstr ""
"'git read-tree' [(-m [--trivial] [--aggressive] | --reset | --prefix=<前缀>)\n"
"\t\t[-u | -i]] [--index-output=<文件>] [--no-sparse-checkout]\n"
"\t\t(--empty | <目录树对象 1> [<目录树对象 2> [<目录树对象 3>]])\n"

#. type: Plain text
#: en/git-read-tree.txt:22
#, placeholders:'linkgit:git-checkout-index[1]', priority:80
msgid "Reads the tree information given by <tree-ish> into the index, but does not actually *update* any of the files it \"caches\". (see: linkgit:git-checkout-index[1])"
msgstr "将 <树状对象> 提供的树信息读入索引，但实际上不会 *更新* 其 “缓存” 的任何文件。(参见：linkgit:git-checkout-index[1]）"

#. type: Plain text
#: en/git-read-tree.txt:27
#, placeholders:'`-m`':'`-m`':'`-u`', priority:80
msgid "Optionally, it can merge a tree into the index, perform a fast-forward (i.e. 2-way) merge, or a 3-way merge, with the `-m` flag. When used with `-m`, the `-u` flag causes it to also update the files in the work tree with the result of the merge."
msgstr "可以选择使用 `-m` 标志将工作区合并到索引中、执行快进（即双向）合并或三向合并。 当与 `-m` 一起使用时，`-u` 标志会使它用合并的结果更新工作区中的文件。"

#. type: Plain text
#: en/git-read-tree.txt:30
#, placeholders:'git read-tree':'git read-tree', priority:80
msgid "Only trivial merges are done by 'git read-tree' itself. Only conflicting paths will be in an unmerged state when 'git read-tree' returns."
msgstr "'git read-tree' 本身只会进行琐碎的合并。 当 'git read-tree' 返回时，只有冲突路径才会处于未合并状态。"

#. type: Plain text
#: en/git-read-tree.txt:38
#, priority:80
msgid "Perform a merge, not just a read. The command will refuse to run if your index file has unmerged entries, indicating that you have not finished a previous merge you started."
msgstr "执行合并，而不仅仅是读取。 如果索引文件中有未合并的条目，说明你还没有完成之前开始的合并，命令将拒绝运行。"

#. type: Labeled list
#: en/git-read-tree.txt:39
#, ignore-same, no-wrap, priority:80
msgid "--reset"
msgstr "--reset"

#. type: Plain text
#: en/git-read-tree.txt:44
#, placeholders:'`-u`', priority:80
msgid "Same as -m, except that unmerged entries are discarded instead of failing. When used with `-u`, updates leading to loss of working tree changes or untracked files or directories will not abort the operation."
msgstr "与 -m 相同，只是未合并的条目会被丢弃，而不是失败。 与 `-u` 一起使用时，导致丢失工作树更改或未跟踪文件或目录的更新不会中止操作。"

#. type: Plain text
#: en/git-read-tree.txt:48
#, priority:80
msgid "After a successful merge, update the files in the work tree with the result of the merge."
msgstr "合并成功后，用合并结果更新工作目录树中的文件。"

#. type: Plain text
#: en/git-read-tree.txt:57
#, priority:80
msgid "Usually a merge requires the index file as well as the files in the working tree to be up to date with the current head commit, in order not to lose local changes. This flag disables the check with the working tree and is meant to be used when creating a merge of trees that are not directly related to the current working tree status into a temporary index file."
msgstr "通常情况下，合并需要索引文件和工作区中的文件都与当前的头提交保持一致，以免丢失本地变更。 此标记会禁用与工作区的检查，用于将与当前工作树状态无直接关系的目录树合并到临时索引文件中。"

#. type: Plain text
#: en/git-read-tree.txt:62
#, priority:80
msgid "Check if the command would error out, without updating the index or the files in the working tree for real."
msgstr "检查该命令是否会出错，而不会真正更新索引或工作区中的文件。"

#. type: Plain text
#: en/git-read-tree.txt:65
#, priority:80
msgid "Show the progress of checking files out."
msgstr "显示签出文件的进度。"

#. type: Labeled list
#: en/git-read-tree.txt:66
#, ignore-same, no-wrap, priority:80
msgid "--trivial"
msgstr "--trivial"

#. type: Plain text
#: en/git-read-tree.txt:71
#, placeholders:'git read-tree', priority:80
msgid "Restrict three-way merge by 'git read-tree' to happen only if there is no file-level merging required, instead of resolving merge for trivial cases and leaving conflicting files unresolved in the index."
msgstr "限制使用 'git read-tree' 进行三向合并，只有在不需要文件级合并的情况下才会发生，而不是在琐碎的情况下解决合并问题，并在索引中留下未解决的冲突文件。"

#. type: Plain text
#: en/git-read-tree.txt:78
#, placeholders:'git read-tree', priority:80
msgid "Usually a three-way merge by 'git read-tree' resolves the merge for really trivial cases and leaves other cases unresolved in the index, so that porcelains can implement different merge policies. This flag makes the command resolve a few more cases internally:"
msgstr "通常情况下，通过 'git read-tree' 进行的三方合并会解决真正琐碎的合并问题，而将其他问题保留在索引中不予解决，这样就可以实现不同的合并策略。 这个标记会让命令在内部解决更多情况："

#. type: Plain text
#: en/git-read-tree.txt:81
#, priority:80
msgid "when one side removes a path and the other side leaves the path unmodified. The resolution is to remove that path."
msgstr "当一方删除一条路径，而另一方不修改路径时。 解决方法就是删除该路径。"

#. type: Plain text
#: en/git-read-tree.txt:82
#, priority:80
msgid "when both sides remove a path. The resolution is to remove that path."
msgstr "当双方都删除一条路径时。 解决方法就是移除该路径。"

#. type: Plain text
#: en/git-read-tree.txt:84
#, priority:80
msgid "when both sides add a path identically. The resolution is to add that path."
msgstr "当双方添加的路径相同时。 解决方法就是增加这条路径。"

#. type: Labeled list
#: en/git-read-tree.txt:85 en/git-svn.txt:75
#, no-wrap, placeholders:'--prefix=', priority:100
msgid "--prefix=<prefix>"
msgstr "--prefix=<前缀>"

#. type: Plain text
#: en/git-read-tree.txt:90
#, priority:80
msgid "Keep the current index contents, and read the contents of the named tree-ish under the directory at `<prefix>`. The command will refuse to overwrite entries that already existed in the original index file."
msgstr "保留当前索引内容，并读取位于 `<前缀>` 目录下的命名树的内容。 该命令将拒绝覆盖原始索引文件中已存在的条目。"

#. type: Labeled list
#: en/git-read-tree.txt:91
#, no-wrap, placeholders:'--index-output=', priority:80
msgid "--index-output=<file>"
msgstr "--index-output=<文件>"

#. type: Plain text
#: en/git-read-tree.txt:102
#, placeholders:'$GIT_INDEX_FILE', priority:80
msgid "Instead of writing the results out to `$GIT_INDEX_FILE`, write the resulting index in the named file. While the command is operating, the original index file is locked with the same mechanism as usual. The file must allow to be rename(2)ed into from a temporary file that is created next to the usual index file; typically this means it needs to be on the same filesystem as the index file itself, and you need write permission to the directories the index file and index output file are located in."
msgstr "不将结果写入 `$GIT_INDEX_FILE` ，而是将生成的索引写入指定文件。 在执行命令时，原始索引文件会以与平常相同的机制被锁定。 该文件必须允许从通常的索引文件旁边创建的临时文件重命名 (2) 进入；这通常意味着它需要与索引文件本身位于同一文件系统，并且需要获得索引文件和索引输出文件所在目录的写入权限。"

#. type: Labeled list
#: en/git-read-tree.txt:103 en/git-reset.txt:93
#, ignore-same, no-wrap, priority:280
msgid "--[no-]recurse-submodules"
msgstr "--[no-]recurse-submodules"

#. type: Plain text
#: en/git-read-tree.txt:108
#, placeholders:'--recurse-submodules':'HEAD', priority:80
msgid "Using --recurse-submodules will update the content of all active submodules according to the commit recorded in the superproject by calling read-tree recursively, also setting the submodules' HEAD to be detached at that commit."
msgstr "使用 --recurse-submodules 会通过递归调用 read-tree 来根据超项目中记录的提交更新所有活动子模块的内容，并在该提交时将子模块的 HEAD 设置为分离。"

#. type: Labeled list
#: en/git-read-tree.txt:109
#, ignore-same, no-wrap, priority:80
msgid "--no-sparse-checkout"
msgstr "--no-sparse-checkout"

#. type: Plain text
#: en/git-read-tree.txt:112
#, placeholders:'core.sparseCheckout', priority:80
msgid "Disable sparse checkout support even if `core.sparseCheckout` is true."
msgstr "即使 `core.sparseCheckout` 为 true，也会禁用稀疏签出支持。"

#. type: Labeled list
#: en/git-read-tree.txt:113
#, ignore-same, no-wrap, priority:80
msgid "--empty"
msgstr "--empty"

#. type: Plain text
#: en/git-read-tree.txt:116
#, priority:80
msgid "Instead of reading tree object(s) into the index, just empty it."
msgstr "与其在索引中读取目录树对象，不如直接清空索引。"

#. type: Labeled list
#: en/git-read-tree.txt:121
#, no-wrap, priority:80
msgid "<tree-ish#>"
msgstr "<树状对象#>"

#. type: Plain text
#: en/git-read-tree.txt:123
#, priority:80
msgid "The id of the tree object(s) to be read/merged."
msgstr "要读取/合并的树对象的 ID。"

#. type: Title -
#: en/git-read-tree.txt:126
#, no-wrap, priority:80
msgid "MERGING"
msgstr "合并"

#. type: Plain text
#: en/git-read-tree.txt:131
#, placeholders:'`-m`':'git read-tree', priority:80
msgid "If `-m` is specified, 'git read-tree' can perform 3 kinds of merge, a single tree merge if only 1 tree is given, a fast-forward merge with 2 trees, or a 3-way merge if 3 or more trees are provided."
msgstr "如果指定了 `-m` 选项，'git read-tree' 可以执行 3 种合并：如果只提供了 1 个目录树，则执行单棵目录树合并；如果提供了 2 棵目录树，则执行快进合并；如果提供了 3 棵或更多的目录树，则执行 3 方合并。"

#. type: Title ~
#: en/git-read-tree.txt:134
#, no-wrap, priority:80
msgid "Single Tree Merge"
msgstr "单棵树合并"

#. type: Plain text
#: en/git-read-tree.txt:140
#, placeholders:'git read-tree':'`-m`', priority:80
msgid "If only 1 tree is specified, 'git read-tree' operates as if the user did not specify `-m`, except that if the original index has an entry for a given pathname, and the contents of the path match with the tree being read, the stat info from the index is used. (In other words, the index's stat()s take precedence over the merged tree's)."
msgstr "如果只指定了一棵树，'git read-tree' 就会像用户未指定 `-m` 一样运行，但如果原始索引中有给定路径名的条目，且该路径的内容与正在读取的树相匹配，则会使用索引中的统计信息。换句话说，索引的 stat() 优先于合并目录树的 stat()）。"

#. type: Plain text
#: en/git-read-tree.txt:144
#, placeholders:'git read-tree':'git checkout-index':'git checkout-index', priority:80
msgid "That means that if you do a `git read-tree -m <newtree>` followed by a `git checkout-index -f -u -a`, the 'git checkout-index' only checks out the stuff that really changed."
msgstr "这就意味着，如果先执行 `git read-tree -m <新目录树>`，然后再执行 `git checkout-index -f -u -a`，'git checkout-index' 只会检查出真正发生变化的内容。"

#. type: Plain text
#: en/git-read-tree.txt:147
#, placeholders:'git diff-files':'git read-tree', priority:80
msgid "This is used to avoid unnecessary false hits when 'git diff-files' is run after 'git read-tree'."
msgstr "当在 'git read-tree' 之后运行 'git diff-files' 时，可避免不必要的误报。"

#. type: Title ~
#: en/git-read-tree.txt:150
#, no-wrap, priority:80
msgid "Two Tree Merge"
msgstr "两棵目录树合并"

#. type: Plain text
#: en/git-read-tree.txt:156
#, placeholders:'git read-tree', priority:80
msgid "Typically, this is invoked as `git read-tree -m $H $M`, where $H is the head commit of the current repository, and $M is the head of a foreign tree, which is simply ahead of $H (i.e. we are in a fast-forward situation)."
msgstr "通常的调用方式是 `git read-tree -m $H $M`，其中 $H 是当前仓库的头提交，$M 是另一棵目录树的头提交，它只是在 $H 之前（即我们处于快速合并状态）。"

#. type: Plain text
#: en/git-read-tree.txt:159
#, placeholders:'git read-tree', priority:80
msgid "When two trees are specified, the user is telling 'git read-tree' the following:"
msgstr "当指定了两棵目录树时，用户就是在告诉 'git read-tree' 以下内容："

#. type: Plain text
#: en/git-read-tree.txt:161
#, priority:80
msgid "The current index and work tree is derived from $H, but"
msgstr "当前索引和工作区来自 $H，但"

#. type: Plain text
#: en/git-read-tree.txt:162
#, priority:80
msgid "the user may have local changes in them since $H."
msgstr "用户可能在 $H 后对其进行了本地更改。"

#. type: Plain text
#: en/git-read-tree.txt:164
#, priority:80
msgid "The user wants to fast-forward to $M."
msgstr "用户希望快速合并到 $M。"

#. type: Plain text
#: en/git-read-tree.txt:170
#, placeholders:'git read-tree', priority:80
msgid "In this case, the `git read-tree -m $H $M` command makes sure that no local change is lost as the result of this \"merge\". Here are the \"carry forward\" rules, where \"I\" denotes the index, \"clean\" means that index and work tree coincide, and \"exists\"/\"nothing\" refer to the presence of a path in the specified commit:"
msgstr "在这种情况下，`git read-tree -m $H $M` 命令会确保 \"merge\" （合并）不会丢失任何本地变更。 以下是 “结转” 规则，其中 \"I\" 表示索引，\"clean\" 表示索引和工作区重合，\"exists\"/\"nothing\" 表示指定提交中存在路径："

#. type: delimited block .
#: en/git-read-tree.txt:181
#, no-wrap, placeholders:'-------------------------------------------------------', priority:80
msgid ""
"\tI                   H        M        Result\n"
"       -------------------------------------------------------\n"
"     0  nothing             nothing  nothing  (does not happen)\n"
"     1  nothing             nothing  exists   use M\n"
"     2  nothing             exists   nothing  remove path from index\n"
"     3  nothing             exists   exists,  use M if \"initial checkout\",\n"
"\t\t\t\t     H == M   keep index otherwise\n"
"\t\t\t\t     exists,  fail\n"
"\t\t\t\t     H != M\n"
msgstr ""
"\tI                   H        M        结果\n"
"       -------------------------------------------------------\n"
"     0  无             无  无  (不会出现这种情况)\n"
"     1  无             无  有   使用 M\n"
"     2  无             有   无  从索引中移除路径\n"
"     3  无             有   有,  如果是 “初次检出”，则使用 M\n"
"\t\t\t\t     H == M   keep index otherwise\n"
"\t\t\t\t     exists,  fail\n"
"\t\t\t\t     H != M\n"

#. type: delimited block .
#: en/git-read-tree.txt:186
#, no-wrap, placeholders:'------------------', priority:80
msgid ""
"        clean I==H  I==M\n"
"       ------------------\n"
"     4  yes   N/A   N/A     nothing  nothing  keep index\n"
"     5  no    N/A   N/A     nothing  nothing  keep index\n"
msgstr ""
"        clean I==H  I==M\n"
"       ------------------\n"
"     4  yes   N/A   N/A     无  无  保持索引\n"
"     5  no    N/A   N/A     无  无  保持索引\n"

#. type: delimited block .
#: en/git-read-tree.txt:191
#, no-wrap, priority:80
msgid ""
"     6  yes   N/A   yes     nothing  exists   keep index\n"
"     7  no    N/A   yes     nothing  exists   keep index\n"
"     8  yes   N/A   no      nothing  exists   fail\n"
"     9  no    N/A   no      nothing  exists   fail\n"
msgstr ""
"     6  yes   N/A   yes     无  有   保持索引\n"
"     7  no    N/A   yes     无  有   保持索引\n"
"     8  yes   N/A   no      无  有   失败\n"
"     9  no    N/A   no      无  有   失败\n"

#. type: delimited block .
#: en/git-read-tree.txt:196
#, no-wrap, priority:80
msgid ""
"     10 yes   yes   N/A     exists   nothing  remove path from index\n"
"     11 no    yes   N/A     exists   nothing  fail\n"
"     12 yes   no    N/A     exists   nothing  fail\n"
"     13 no    no    N/A     exists   nothing  fail\n"
msgstr ""
"     10 yes   yes   N/A     有   无  从索引中移除目录\n"
"     11 no    yes   N/A     有   无  失败\n"
"     12 yes   no    N/A     有   无  失败\n"
"     13 no    no    N/A     有   无  失败\n"

#. type: delimited block .
#: en/git-read-tree.txt:201
#, no-wrap, placeholders:'------', priority:80
msgid ""
"\tclean (H==M)\n"
"       ------\n"
"     14 yes                 exists   exists   keep index\n"
"     15 no                  exists   exists   keep index\n"
msgstr ""
"\tclean (H==M)\n"
"       ------\n"
"     14 yes                 有   有   保持索引\n"
"     15 no                  有   有   保持索引\n"

#. type: delimited block .
#: en/git-read-tree.txt:210
#, no-wrap, placeholders:'------------------', priority:80
msgid ""
"        clean I==H  I==M (H!=M)\n"
"       ------------------\n"
"     16 yes   no    no      exists   exists   fail\n"
"     17 no    no    no      exists   exists   fail\n"
"     18 yes   no    yes     exists   exists   keep index\n"
"     19 no    no    yes     exists   exists   keep index\n"
"     20 yes   yes   no      exists   exists   use M\n"
"     21 no    yes   no      exists   exists   fail\n"
msgstr ""
"        clean I==H  I==M (H!=M)\n"
"       ------------------\n"
"     16 yes   no    no      有   有   失败\n"
"     17 no    no    no      有   有   失败\n"
"     18 yes   no    yes     有   有   保持索引\n"
"     19 no    no    yes     有   有   保持索引\n"
"     20 yes   yes   no      有   有   使用 M\n"
"     21 no    yes   no      有   有   失败\n"

#. type: Plain text
#: en/git-read-tree.txt:216
#, placeholders:'git read-tree', priority:80
msgid "In all \"keep index\" cases, the index entry stays as in the original index file. If the entry is not up to date, 'git read-tree' keeps the copy in the work tree intact when operating under the -u flag."
msgstr "在所有 “保留索引” 的情况下，索引条目都会保留在原始索引文件中。 如果条目不是最新的，在使用 -u 标志时，'git read-tree' 会在工作树中保留完整的副本。"

#. type: Plain text
#: en/git-read-tree.txt:227
#, placeholders:'git read-tree':'git diff-index':'--cached':'git diff-index':'--cached':'git diff-index':'--cached':'git diff-index':'--cached', priority:80
msgid "When this form of 'git read-tree' returns successfully, you can see which of the \"local changes\" that you made were carried forward by running `git diff-index --cached $M`. Note that this does not necessarily match what `git diff-index --cached $H` would have produced before such a two tree merge. This is because of cases 18 and 19 -- if you already had the changes in $M (e.g. maybe you picked it up via e-mail in a patch form), `git diff-index --cached $H` would have told you about the change before this merge, but it would not show in `git diff-index --cached $M` output after the two-tree merge."
msgstr "当这种形式的 'git read-tree' 成功返回时，你可以通过运行 `git diff-index --cached $M` 来查看你所做的哪些 “本地改动” 被继承了下来。 请注意，这并不一定与 `git diff-index --cached $H` 在两棵目录树合并前的结果一致。 这是因为第 18 和 19 种情况 -- 如果 $M 中已经有了这些改动 (例如，你通过电子邮件以补丁的形式获取了它)，`git diff-index --cached $H` 会在合并前告诉你这些改动，但两个目录树合并后，它不会显示在 `git diff-index --cached $M` 的输出中。"

#. type: Plain text
#: en/git-read-tree.txt:234
#, priority:80
msgid "Case 3 is slightly tricky and needs explanation. The result from this rule logically should be to remove the path if the user staged the removal of the path and then switching to a new branch. That however will prevent the initial checkout from happening, so the rule is modified to use M (new tree) only when the content of the index is empty. Otherwise the removal of the path is kept as long as $H and $M are the same."
msgstr "情况 3 稍显棘手，需要解释一下。 如果用户分阶段删除路径，然后切换到新的分支，那么从逻辑上讲，这条规则的结果应该是删除路径。 然而，这将阻止初始检出的发生，因此该规则被修改为只有在索引内容为空时才使用 M（新目录树）。 否则，只要 $H 和 $M 相同，就会保留路径的删除。"

#. type: Title ~
#: en/git-read-tree.txt:236
#, no-wrap, priority:80
msgid "3-Way Merge"
msgstr "三方合并"

#. type: Plain text
#: en/git-read-tree.txt:239
#, priority:80
msgid "Each \"index\" entry has two bits worth of \"stage\" state. stage 0 is the normal one, and is the only one you'd see in any kind of normal use."
msgstr "每个 “索引” 条目都有两个比特的 “阶段” 状态。“阶段 0” 是正常状态，也是你在任何正常使用中唯一会看到的状态。"

#. type: Plain text
#: en/git-read-tree.txt:242
#, placeholders:'git read-tree', priority:80
msgid "However, when you do 'git read-tree' with three trees, the \"stage\" starts out at 1."
msgstr "但是，当您使用 'git read-tree' 读取三棵树时，“阶段” 会从 1 开始。"

#. type: Plain text
#: en/git-read-tree.txt:244
#, priority:80
msgid "This means that you can do"
msgstr "这意味着您可以"

#. type: delimited block -
#: en/git-read-tree.txt:247
#, no-wrap, placeholders:'git read-tree', priority:80
msgid "$ git read-tree -m <tree1> <tree2> <tree3>\n"
msgstr "$ git read-tree -m <目录树 1> <目录树 2> <目录树 3>\n"

#. type: Plain text
#: en/git-read-tree.txt:255
#, priority:80
msgid "and you will end up with an index with all of the <tree1> entries in \"stage1\", all of the <tree2> entries in \"stage2\" and all of the <tree3> entries in \"stage3\". When performing a merge of another branch into the current branch, we use the common ancestor tree as <tree1>, the current branch head as <tree2>, and the other branch head as <tree3>."
msgstr "最终，您将得到一个包含 “阶段 1” 中所有 <目录树 1> 条目，“阶段 2” 中所有 <目录树 2> 条目和 “阶段 3” 中所有 <目录树 3> 条目的索引。 在将另一个分支合并到当前分支时，我们使用共同祖先树作为 <目录树 1>，当前分支头作为 <目录树 2>，另一个分支头作为 <目录树 3>。"

#. type: Plain text
#: en/git-read-tree.txt:259
#, placeholders:'git read-tree', priority:80
msgid "Furthermore, 'git read-tree' has special-case logic that says: if you see a file that matches in all respects in the following states, it \"collapses\" back to \"stage0\":"
msgstr "此外，'git read-tree' 还有一个特殊情况逻辑：如果你看到一个文件在以下状态中各方面都符合要求，它就会 “折叠” 回 “阶段 0” ："

#. type: Plain text
#: en/git-read-tree.txt:263
#, priority:80
msgid "stage 2 and 3 are the same; take one or the other (it makes no difference - the same work has been done on our branch in stage 2 and their branch in stage 3)"
msgstr "第 2 阶段和第 3 阶段是相同的，可以选择其中之一（这没有区别--第 2 阶段我们的分支和第 3 阶段他们的分支所做的工作是相同的）"

#. type: Plain text
#: en/git-read-tree.txt:268
#, priority:80
msgid "stage 1 and stage 2 are the same and stage 3 is different; take stage 3 (our branch in stage 2 did not do anything since the ancestor in stage 1 while their branch in stage 3 worked on it)"
msgstr "阶段 1 和阶段 2 相同，阶段 3 不同；取阶段 3（我们在阶段 2 中的分支没有对阶段 1 中的祖先做任何事情，而他们在阶段 3 中的分支在做这件事）"

#. type: Plain text
#: en/git-read-tree.txt:271
#, priority:80
msgid "stage 1 and stage 3 are the same and stage 2 is different take stage 2 (we did something while they did nothing)"
msgstr "第 1 阶段和第 3 阶段相同，第 2 阶段与第 2 阶段不同（我们做了一些事情，而他们什么也没做）"

#. type: Plain text
#: en/git-read-tree.txt:275
#, placeholders:'git write-tree', priority:80
msgid "The 'git write-tree' command refuses to write a nonsensical tree, and it will complain about unmerged entries if it sees a single entry that is not stage 0."
msgstr "'git write-tree' 命令会拒绝写入无意义的树，如果它看到一个非第 0 阶段的条目，就会抱怨存在未合并条目。"

#. type: Plain text
#: en/git-read-tree.txt:281
#, priority:80
msgid "OK, this all sounds like a collection of totally nonsensical rules, but it's actually exactly what you want in order to do a fast merge. The different stages represent the \"result tree\" (stage 0, aka \"merged\"), the original tree (stage 1, aka \"orig\"), and the two trees you are trying to merge (stage 2 and 3 respectively)."
msgstr "好吧，这听起来像是一堆毫无意义的规则，但实际上这正是快速合并所需要的。不同的阶段分别代表 “结果树”（第 0 阶段，又名 “合并”）、原始树（第 1 阶段，又名 “原始”）和你要合并的两棵树（分别为第 2 阶段和第 3 阶段）。"

#. type: Plain text
#: en/git-read-tree.txt:286
#, priority:80
msgid "The order of stages 1, 2 and 3 (hence the order of three <tree-ish> command-line arguments) are significant when you start a 3-way merge with an index file that is already populated. Here is an outline of how the algorithm works:"
msgstr "当你使用一个已经填充好的索引文件开始 3 向合并时，第 1、2 和 3 阶段的顺序（因此是三个 <树状对象> 命令行参数的顺序）非常重要。 以下是该算法的工作原理概要："

#. type: Plain text
#: en/git-read-tree.txt:289
#, placeholders:'git read-tree', priority:80
msgid "if a file exists in identical format in all three trees, it will automatically collapse to \"merged\" state by 'git read-tree'."
msgstr "如果一个文件以完全相同的格式存在于三棵目录树中，它将通过 'git read-tree' 自动折叠为 “合并” 状态。"

#. type: Plain text
#: en/git-read-tree.txt:294
#, priority:80
msgid "a file that has _any_ difference what-so-ever in the three trees will stay as separate entries in the index. It's up to \"porcelain policy\" to determine how to remove the non-0 stages, and insert a merged version."
msgstr "如果文件在三棵目录树中存在任何差异，都将作为独立条目保留在索引中。至于如何删除非 0 阶段，并插入合并版本，则由 “上层命令的策略” 决定。"

#. type: Plain text
#: en/git-read-tree.txt:299
#, priority:80
msgid "the index file saves and restores with all this information, so you can merge things incrementally, but as long as it has entries in stages 1/2/3 (i.e., \"unmerged entries\") you can't write the result. So now the merge algorithm ends up being really simple:"
msgstr "索引文件在保存和恢复时会包含所有这些信息，因此可以逐步合并，但只要索引文件中的条目还处于第 1/2/3 阶段（即 “未合并条目”），就无法写入合并结果。因此，现在的合并算法非常简单："

#. type: Plain text
#: en/git-read-tree.txt:302
#, priority:80
msgid "you walk the index in order, and ignore all entries of stage 0, since they've already been done."
msgstr "你会按顺序执行索引，并忽略第 0 阶段的所有条目，因为它们已经执行过了。"

#. type: Plain text
#: en/git-read-tree.txt:306
#, priority:80
msgid "if you find a \"stage1\", but no matching \"stage2\" or \"stage3\", you know it's been removed from both trees (it only existed in the original tree), and you remove that entry."
msgstr "如果找到了 “阶段 1”，但没有找到匹配的 “阶段 2” 或 “阶段 3”，就说明它已从两棵目录树中删除（它只存在于原始目录树中），因此要删除该条目。"

#. type: Plain text
#: en/git-read-tree.txt:311
#, priority:80
msgid "if you find a matching \"stage2\" and \"stage3\" tree, you remove one of them, and turn the other into a \"stage0\" entry. Remove any matching \"stage1\" entry if it exists too. .. all the normal trivial rules .."
msgstr "如果找到匹配的 “阶段 2” 和 “阶段 3” 树，则删除其中一个，并将另一个变成 “阶段 0” 条目。如果还存在匹配的“阶段 1” 条目，则将其删除。 ... 这些就是所有琐碎但正常的规则 ..."

#. type: Plain text
#: en/git-read-tree.txt:316
#, placeholders:'git merge-index':'git merge-one-file', priority:80
msgid "You would normally use 'git merge-index' with supplied 'git merge-one-file' to do this last step. The script updates the files in the working tree as it merges each path and at the end of a successful merge."
msgstr "通常，你会使用 'git merge-index' 和 'git merge-one-file' 来完成最后一步。 脚本会在合并每个路径和合并成功后更新工作区中的文件。"

#. type: Plain text
#: en/git-read-tree.txt:324
#, priority:80
msgid "When you start a 3-way merge with an index file that is already populated, it is assumed that it represents the state of the files in your work tree, and you can even have files with changes unrecorded in the index file. It is further assumed that this state is \"derived\" from the stage 2 tree. The 3-way merge refuses to run if it finds an entry in the original index file that does not match stage 2."
msgstr "当你使用一个已填充的索引文件开始 3 向合并时，我们假定它代表了工作区中文件的状态，你甚至可以拥有索引文件中未记录更改的文件。 此外，我们还假定这种状态是从第二阶段树中 “派生” 出来的。 如果在原始索引文件中发现与第二阶段不匹配的条目，三方合并就会拒绝运行。"

#. type: Plain text
#: en/git-read-tree.txt:329
#, priority:80
msgid "This is done to prevent you from losing your work-in-progress changes, and mixing your random changes in an unrelated merge commit. To illustrate, suppose you start from what has been committed last to your repository:"
msgstr "这样做是为了防止丢失正在进行中的更改，以及将随机更改混入不相关的合并提交中。 举例说明，假设你从上次提交到仓库的内容开始："

#. type: delimited block -
#: en/git-read-tree.txt:333
#, no-wrap, placeholders:'git rev-parse':'--verify':'HEAD':'git checkout-index':'$JC', priority:80
msgid ""
"$ JC=`git rev-parse --verify \"HEAD^0\"`\n"
"$ git checkout-index -f -u -a $JC\n"
msgstr ""
"$ JC=`git rev-parse --verify \"HEAD^0\"`\n"
"$ git checkout-index -f -u -a $JC\n"

#. type: Plain text
#: en/git-read-tree.txt:338
#, placeholders:'git update-index', priority:80
msgid "You do random edits, without running 'git update-index'. And then you notice that the tip of your \"upstream\" tree has advanced since you pulled from him:"
msgstr "你在没有运行 'git update-index' 的情况下进行了随机编辑。 然后你会发现，你的 “上游” 目录树的顶端在你从他那里拉出来之后又前进了一步："

#. type: delimited block -
#: en/git-read-tree.txt:342
#, ignore-ellipsis, no-wrap, placeholders:'git rev-parse':'FETCH_HEAD', priority:80
msgid ""
"$ git fetch git://.... linus\n"
"$ LT=`git rev-parse FETCH_HEAD`\n"
msgstr ""
"$ git fetch git://.... linus\n"
"$ LT=`git rev-parse FETCH_HEAD`\n"

#. type: Plain text
#: en/git-read-tree.txt:348
#, placeholders:'HEAD':'$JC':'$JC', priority:80
msgid "Your work tree is still based on your HEAD ($JC), but you have some edits since. Three-way merge makes sure that you have not added or modified index entries since $JC, and if you haven't, then does the right thing. So with the following sequence:"
msgstr "你的工作区仍然基于你的 HEAD ($JC)，但你在此之后进行了一些编辑。 三方合并会确保你在 $JC 之后没有添加或修改索引项，如果没有，就会做正确的事情。 因此，顺序如下："

#. type: delimited block -
#: en/git-read-tree.txt:354
#, no-wrap, placeholders:'git read-tree':'git merge-base':'$JC':'$LT':'$JC':'$LT':'git merge-index':'git-merge-one-file':'git commit-tree':'git write-tree':'$JC':'$LT', priority:80
msgid ""
"$ git read-tree -m -u `git merge-base $JC $LT` $JC $LT\n"
"$ git merge-index git-merge-one-file -a\n"
"$ echo \"Merge with Linus\" | \\\n"
"  git commit-tree `git write-tree` -p $JC -p $LT\n"
msgstr ""
"$ git read-tree -m -u `git merge-base $JC $LT` $JC $LT\n"
"$ git merge-index git-merge-one-file -a\n"
"$ echo \"Merge with Linus\" | \\\n"
"  git commit-tree `git write-tree` -p $JC -p $LT\n"

#. type: Plain text
#: en/git-read-tree.txt:359
#, placeholders:'$JC':'$LT', priority:80
msgid "what you would commit is a pure merge between $JC and $LT without your work-in-progress changes, and your work tree would be updated to the result of the merge."
msgstr "你要提交的是 $JC 和 $LT 之间的纯合并，不包含你正在进行的工作修改，你的工作区将被更新为合并后的结果。"

#. type: Plain text
#: en/git-read-tree.txt:363
#, placeholders:'git read-tree', priority:80
msgid "However, if you have local changes in the working tree that would be overwritten by this merge, 'git read-tree' will refuse to run to prevent your changes from being lost."
msgstr "不过，如果您在工作树中的本地改动会被此次合并覆盖，'git read-tree' 将拒绝运行，以防止您的改动丢失。"

#. type: Plain text
#: en/git-read-tree.txt:373
#, placeholders:'git read-tree', priority:80
msgid "In other words, there is no need to worry about what exists only in the working tree. When you have local changes in a part of the project that is not involved in the merge, your changes do not interfere with the merge, and are kept intact. When they *do* interfere, the merge does not even start ('git read-tree' complains loudly and fails without modifying anything). In such a case, you can simply continue doing what you were in the middle of doing, and when your working tree is ready (i.e. you have finished your work-in-progress), attempt the merge again."
msgstr "换句话说，无需担心只存在于工作区中的内容。 当你对项目中不参与合并的部分进行本地修改时，你的修改不会干扰合并，而是保持原样。 如果这些改动 *干扰了* 合并，那么合并甚至都不会开始（'git read-tree' 会大声抱怨，并在不修改任何内容的情况下失败）。 在这种情况下，你只需继续做你正在做的事情，当你的工作区准备就绪时（即你已经完成了正在进行的工作），再尝试合并。"

#. type: Title -
#: en/git-read-tree.txt:376
#, no-wrap, priority:80
msgid "SPARSE CHECKOUT"
msgstr "SPARSE CHECKOUT"

#. type: Plain text
#: en/git-read-tree.txt:385
#, placeholders:'linkgit:git-update-index[1]':'linkgit:git-sparse-checkout[1]', priority:80
msgid "Note: The skip-worktree capabilities in linkgit:git-update-index[1] and `read-tree` predated the introduction of linkgit:git-sparse-checkout[1]. Users are encouraged to use the `sparse-checkout` command in preference to these plumbing commands for sparse-checkout/skip-worktree related needs. However, the information below might be useful to users trying to understand the pattern style used in non-cone mode of the `sparse-checkout` command."
msgstr "注意：linkgit:git-update-index[1] 和 `read-tree` 中的跳过工作区功能早于 linkgit:git-sparse-checkout[1] 的引入。 我们鼓励用户优先使用 `sparse-checkout` 命令，而不是这些底层命令来满足稀疏校验/跳转工作树的相关需求。 不过，以下信息对于试图理解 `sparse-checkout` 命令的非锥形模式中使用的模式样式的用户可能会有所帮助。"

#. type: Plain text
#: en/git-read-tree.txt:389
#, placeholders:'linkgit:git-update-index[1]', priority:80
msgid "\"Sparse checkout\" allows populating the working directory sparsely. It uses the skip-worktree bit (see linkgit:git-update-index[1]) to tell Git whether a file in the working directory is worth looking at."
msgstr "“稀疏签出” 允许稀疏地填充工作目录。 它使用 skip-worktree 位（参见 linkgit:git-update-index[1]）来告诉 Git 工作目录中的文件是否值得查看。"

#. type: Plain text
#: en/git-read-tree.txt:399
#, ignore-ellipsis, placeholders:'git read-tree':'$GIT_DIR':'git read-tree':'.gitignore', priority:80
msgid "'git read-tree' and other merge-based commands ('git merge', 'git checkout'...) can help maintaining the skip-worktree bitmap and working directory update. `$GIT_DIR/info/sparse-checkout` is used to define the skip-worktree reference bitmap. When 'git read-tree' needs to update the working directory, it resets the skip-worktree bit in the index based on this file, which uses the same syntax as .gitignore files. If an entry matches a pattern in this file, or the entry corresponds to a file present in the working tree, then skip-worktree will not be set on that entry. Otherwise, skip-worktree will be set."
msgstr "'git read-tree' 和其他基于合并的命令（'git merge'、'git checkout'...）可以帮助维护 skip-worktree 位图和工作目录更新。`$GIT_DIR/info/sparse-checkout` 用于定义跳过工作树的参考位图。当 'git read-tree' 需要更新工作目录时，它会根据该文件重置索引中的跳过工作树位，其语法与 .gitignore 文件相同。 如果某个条目与该文件中的模式匹配，或者该条目与工作树中的某个文件相对应，则不会在该条目上设置跳过工作树。否则，将设置跳过工作区。"

#. type: Plain text
#: en/git-read-tree.txt:403
#, priority:80
msgid "Then it compares the new skip-worktree value with the previous one. If skip-worktree turns from set to unset, it will add the corresponding file back. If it turns from unset to set, that file will be removed."
msgstr "然后将新的 skip-worktree 值与之前的值进行比较。如果 skip-worktree 从已设变成未设，它就会重新添加相应的文件。如果从未设改为已设，则会删除该文件。"

#. type: Plain text
#: en/git-read-tree.txt:407
#, placeholders:'$GIT_DIR', priority:80
msgid "While `$GIT_DIR/info/sparse-checkout` is usually used to specify what files are in, you can also specify what files are _not_ in, using negate patterns. For example, to remove the file `unwanted`:"
msgstr "虽然 `$GIT_DIR/info/sparse-checkout` 通常用于指定包含哪些文件，但也可以使用否定模式来指定 _not_ 包含哪些文件。例如，要删除文件 `unwanted`："

#. type: delimited block -
#: en/git-read-tree.txt:411
#, no-wrap, priority:80
msgid ""
"/*\n"
"!unwanted\n"
msgstr ""
"/*\n"
"!unwanted\n"

#. type: Plain text
#: en/git-read-tree.txt:419
#, placeholders:'$GIT_DIR', priority:80
msgid "Another tricky thing is fully repopulating the working directory when you no longer want sparse checkout. You cannot just disable \"sparse checkout\" because skip-worktree bits are still in the index and your working directory is still sparsely populated. You should re-populate the working directory with the `$GIT_DIR/info/sparse-checkout` file content as follows:"
msgstr "另一个棘手的问题是，当你不再需要稀疏检出时，如何完全重新填充工作目录。你不能直接禁用 “稀疏检出”，因为跳过的工作区位仍在索引中，你的工作目录仍是稀疏填充的。你应该用 `$GIT_DIR/info/sparse-checkout` 文件内容重新填充工作目录，如下所示："

#. type: delimited block -
#: en/git-read-tree.txt:422
#, no-wrap, priority:80
msgid "/*\n"
msgstr "/*\n"

#. type: Plain text
#: en/git-read-tree.txt:428
#, placeholders:'git read-tree':'core.sparseCheckout', priority:80
msgid "Then you can disable sparse checkout. Sparse checkout support in 'git read-tree' and similar commands is disabled by default. You need to turn `core.sparseCheckout` on in order to have sparse checkout support."
msgstr "然后就可以禁用稀疏签出。'git read-tree' 和类似命令中的稀疏签出支持默认是禁用的。你需要打开 `core.sparseCheckout` 才能获得稀疏签出支持。"

#. type: Plain text
#: en/git-read-tree.txt:434
#, ignore-same, priority:80
msgid "linkgit:git-write-tree[1], linkgit:git-ls-files[1], linkgit:gitignore[5], linkgit:git-sparse-checkout[1]"
msgstr "linkgit:git-write-tree[1], linkgit:git-ls-files[1], linkgit:gitignore[5], linkgit:git-sparse-checkout[1]"

#. type: Title =
#: en/git-rebase.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-rebase(1)"
msgstr "git-rebase(1)"

#. type: Plain text
#: en/git-rebase.txt:7
#, placeholders:'git-rebase', priority:100
msgid "git-rebase - Reapply commits on top of another base tip"
msgstr "git-rebase - 在另一个基础提示之上重新应用提交内容"

#. type: Plain text
#: en/git-rebase.txt:16
#, no-wrap, placeholders:'--interactive]':'[--exec':'[--onto':'--keep-base]':'--interactive]':'[--exec':'[--onto':'--root':'--continue':'--skip':'--abort':'--quit':'--edit-todo':'--show-current-patch', priority:100
msgid ""
"'git rebase' [-i | --interactive] [<options>] [--exec <cmd>]\n"
"\t[--onto <newbase> | --keep-base] [<upstream> [<branch>]]\n"
"'git rebase' [-i | --interactive] [<options>] [--exec <cmd>] [--onto <newbase>]\n"
"\t--root [<branch>]\n"
"'git rebase' (--continue | --skip | --abort | --quit | --edit-todo | --show-current-patch)\n"
msgstr ""
"'git rebase' [-i | --interactive] [<选项>] [--exec <命令>]\n"
"\t[--onto <新基础> | --keep-base] [<上游仓库> [<分支>]]\n"
"'git rebase' [-i | --interactive] [<选项>] [--exec <命令>] [--onto <新基础>]\n"
"\t--root [<分支>]\n"
"'git rebase' (--continue | --skip | --abort | --quit | --edit-todo | --show-current-patch)\n"

#. type: Plain text
#: en/git-rebase.txt:22
#, priority:100
msgid "If `<branch>` is specified, `git rebase` will perform an automatic `git switch <branch>` before doing anything else. Otherwise it remains on the current branch."
msgstr "如果指定了 `<branch>`，`git rebase` 会自动执行 `git switch <branch>`，然后再做其他事情。 否则，它会保留在当前分支上。"

#. type: Plain text
#: en/git-rebase.txt:28
#, placeholders:'linkgit:git-config[1]':'`--fork-point`', priority:100
msgid "If `<upstream>` is not specified, the upstream configured in `branch.<name>.remote` and `branch.<name>.merge` options will be used (see linkgit:git-config[1] for details) and the `--fork-point` option is assumed. If you are currently not on any branch or if the current branch does not have a configured upstream, the rebase will abort."
msgstr "如果未指定 `<upstream>`，将使用 `branch.<name>.remote` 和 `branch.<name>.merge` 选项中配置的上游（详见 linkgit:git-config[1]），并假定使用 `--fork-point`选项。 如果您当前不在任何分支上，或者当前分支没有配置上游，变基操作会中止。"

#. type: Plain text
#: en/git-rebase.txt:35
#, placeholders:'HEAD':'fork_point':'HEAD':'`--fork-point`':'`--fork-point`':'HEAD':'`--root`', priority:100
msgid "All changes made by commits in the current branch but that are not in `<upstream>` are saved to a temporary area. This is the same set of commits that would be shown by `git log <upstream>..HEAD`; or by `git log 'fork_point'..HEAD`, if `--fork-point` is active (see the description on `--fork-point` below); or by `git log HEAD`, if the `--root` option is specified."
msgstr "当前分支中的所有提交所做的改动，但不在 `<upstream>` 中的，都会被保存到一个临时区域。 这与 `git log <upstream>..HEAD` 或 `git log 'fork_point'..HEAD` 所显示的提交相同（如果启用了 `--fork-point`，请参阅下文关于 `--fork-point`的描述）；或者，如果指定了 `--root` 选项，则与 `git log HEAD` 所显示的提交相同。"

#. type: Plain text
#: en/git-rebase.txt:40
#, placeholders:'`--onto`':'--hard':'ORIG_HEAD', priority:100
msgid "The current branch is reset to `<upstream>` or `<newbase>` if the `--onto` option was supplied. This has the exact same effect as `git reset --hard <upstream>` (or `<newbase>`). `ORIG_HEAD` is set to point at the tip of the branch before the reset."
msgstr "如果提供了 `--onto` 选项，当前分支会重置为 `<upstream>` 或 `<newbase>`。 这与 `git reset --hard <upstream>`（或 `<newbase>`）的效果完全相同。`ORIG_HEAD` 设置为指向重置前分支的顶端。"

#. type: Plain text
#: en/git-rebase.txt:47
#, placeholders:'ORIG_HEAD':'{1}':'linkgit:gitrevisions[7]', priority:100
msgid "`ORIG_HEAD` is not guaranteed to still point to the previous branch tip at the end of the rebase if other commands that write that pseudo-ref (e.g. `git reset`) are used during the rebase. The previous branch tip, however, is accessible using the reflog of the current branch (i.e. `@{1}`, see linkgit:gitrevisions[7])."
msgstr "如果在重置过程中使用了其他写入伪引用的命令（例如 `git reset`），就不能保证 `ORIG_HEAD` 在重置结束时仍然指向前一个分支的分支提示。不过，使用当前分支的 引用日志（即 `@{1}`，参见 linkgit:gitrevisions[7]）可以访问前一个分支的分支提示。"

#. type: Plain text
#: en/git-rebase.txt:53
#, placeholders:'HEAD':'HEAD', priority:100
msgid "The commits that were previously saved into the temporary area are then reapplied to the current branch, one by one, in order. Note that any commits in `HEAD` which introduce the same textual changes as a commit in `HEAD..<upstream>` are omitted (i.e., a patch already accepted upstream with a different commit message or timestamp will be skipped)."
msgstr "然后，先前保存在临时区域的提交将按顺序逐一重新应用到当前分支。请注意，`HEAD` 中任何与 `HEAD...<upstream>` 中的提交有相同文字改动的提交都会被省略（也就是说，上游已经接受的补丁，如果提交信息或时间戳不同，就会被跳过）。"

#. type: Plain text
#: en/git-rebase.txt:60
#, placeholders:'--continue`':'--skip`':'--abort`', priority:100
msgid "It is possible that a merge failure will prevent this process from being completely automatic. You will have to resolve any such merge failure and run `git rebase --continue`. Another option is to bypass the commit that caused the merge failure with `git rebase --skip`. To check out the original `<branch>` and remove the `.git/rebase-apply` working files, use the command `git rebase --abort` instead."
msgstr "合并失败有可能导致该过程无法完全自动进行。 您必须解决合并失败问题，然后运行 `git rebase --continue`。 另一种方法是使用 `git rebase --skip` 绕过导致合并失败的提交。 要检查原始的 `<branch>` 并移除 `.git/rebase-apply` 工作文件，请使用 `git rebase --abort` 命令。"

#. type: Plain text
#: en/git-rebase.txt:62
#, priority:100
msgid "Assume the following history exists and the current branch is \"topic\":"
msgstr "假设存在以下历史记录，当前分支为 \"topic\"："

#. type: delimited block -
#: en/git-rebase.txt:67
#, no-wrap, placeholders:'---B---C':'---E---F---G', priority:100
msgid ""
"          A---B---C topic\n"
"         /\n"
"    D---E---F---G master\n"
msgstr ""
"          A---B---C topic\n"
"         /\n"
"    D---E---F---G master\n"

#. type: Plain text
#: en/git-rebase.txt:70
#, priority:100
msgid "From this point, the result of either of the following commands:"
msgstr "从这一点来看，以下任一命令的结果都是如此："

#. type: Plain text
#: en/git-rebase.txt:74
#, no-wrap, priority:100
msgid ""
"    git rebase master\n"
"    git rebase master topic\n"
msgstr ""
"    git rebase master\n"
"    git rebase master topic\n"

#. type: Plain text
#: en/git-rebase.txt:76
#, priority:100
msgid "would be:"
msgstr "那就是 :"

#. type: delimited block -
#: en/git-rebase.txt:81
#, no-wrap, placeholders:'--B':'--C':'---E---F---G', priority:100
msgid ""
"                  A'--B'--C' topic\n"
"                 /\n"
"    D---E---F---G master\n"
msgstr ""
"                  A'--B'--C' topic\n"
"                 /\n"
"    D---E---F---G master\n"

#. type: Plain text
#: en/git-rebase.txt:86
#, priority:100
msgid "*NOTE:* The latter form is just a short-hand of `git checkout topic` followed by `git rebase master`. When rebase exits `topic` will remain the checked-out branch."
msgstr "*注：* 后一种形式只是 `git checkout topic` 的简写。后接 `git rebase master`。当 rebase 退出时，`topic` 将仍是已签出的分支。"

#. type: Plain text
#: en/git-rebase.txt:93
#, priority:100
msgid "If the upstream branch already contains a change you have made (e.g., because you mailed a patch which was applied upstream), then that commit will be skipped and warnings will be issued (if the 'merge' backend is used). For example, running `git rebase master` on the following history (in which `A'` and `A` introduce the same set of changes, but have different committer information):"
msgstr "如果上游分支已经包含了您所做的修改（例如，因为您邮寄的补丁被应用到了上游），那么该提交将被跳过，并发出警告（如果使用了 “合并” 后台）。 例如，在以下历史记录上运行 `git rebase master`（其中 `A'` 和 `A` 引入了相同的变更集，但提交者信息不同）："

#. type: delimited block -
#: en/git-rebase.txt:98
#, no-wrap, placeholders:'---B---C':'---E---A':'---F', priority:100
msgid ""
"          A---B---C topic\n"
"         /\n"
"    D---E---A'---F master\n"
msgstr ""
"          A---B---C topic\n"
"         /\n"
"    D---E---A'---F master\n"

#. type: Plain text
#: en/git-rebase.txt:101
#, priority:100
msgid "will result in:"
msgstr "将导致 :"

#. type: delimited block -
#: en/git-rebase.txt:106
#, no-wrap, placeholders:'---C':'---E---A':'---F', priority:100
msgid ""
"                   B'---C' topic\n"
"                  /\n"
"    D---E---A'---F master\n"
msgstr ""
"                   B'---C' topic\n"
"                  /\n"
"    D---E---A'---F master\n"

#. type: Plain text
#: en/git-rebase.txt:111
#, placeholders:'--onto`', priority:100
msgid "Here is how you would transplant a topic branch based on one branch to another, to pretend that you forked the topic branch from the latter branch, using `rebase --onto`."
msgstr "下面是如何使用 `rebase --onto` 将基于一个分支的特性分支移植到另一个分支，以假装特性分支是从后一个分支分叉而来。"

#. type: Plain text
#: en/git-rebase.txt:115
#, priority:100
msgid "First let's assume your 'topic' is based on branch 'next'. For example, a feature developed in 'topic' depends on some functionality which is found in 'next'."
msgstr "首先，我们假设 'topic' 基于 'next' 分支。 例如，'topic' 中开发的功能依赖于 'next' 中的某些功能。"

#. type: delimited block -
#: en/git-rebase.txt:122
#, no-wrap, placeholders:'o---o---o---o---o':'o---o---o---o---o':'o---o---o', priority:100
msgid ""
"    o---o---o---o---o  master\n"
"         \\\n"
"          o---o---o---o---o  next\n"
"                           \\\n"
"                            o---o---o  topic\n"
msgstr ""
"    o---o---o---o---o  master\n"
"         \\\n"
"          o---o---o---o---o  next\n"
"                           \\\n"
"                            o---o---o  topic\n"

#. type: Plain text
#: en/git-rebase.txt:127
#, priority:100
msgid "We want to make 'topic' forked from branch 'master'; for example, because the functionality on which 'topic' depends was merged into the more stable 'master' branch. We want our tree to look like this:"
msgstr "我们想让 'topic' 从分支 'master' 中分叉出来；例如，因为 'topic' 所依赖的功能已经合并到了更稳定的分支 'master' 中。我们希望我们的提交树看起来像这样 :"

#. type: delimited block -
#: en/git-rebase.txt:134
#, no-wrap, placeholders:'o---o---o---o---o':'--o':'--o':'o---o---o---o---o', priority:100
msgid ""
"    o---o---o---o---o  master\n"
"        |            \\\n"
"        |             o'--o'--o'  topic\n"
"         \\\n"
"          o---o---o---o---o  next\n"
msgstr ""
"    o---o---o---o---o  master\n"
"        |            \\\n"
"        |             o'--o'--o'  topic\n"
"         \\\n"
"          o---o---o---o---o  next\n"

#. type: Plain text
#: en/git-rebase.txt:137
#, priority:100
msgid "We can get this using the following command:"
msgstr "我们可以使用以下命令来获取 :"

#. type: Plain text
#: en/git-rebase.txt:139
#, no-wrap, placeholders:'--onto', priority:100
msgid "    git rebase --onto master next topic\n"
msgstr "    git rebase --onto master next topic\n"

#. type: Plain text
#: en/git-rebase.txt:143
#, placeholders:'--onto', priority:100
msgid "Another example of --onto option is to rebase part of a branch. If we have the following situation:"
msgstr "--onto 选项的另一个示例是重新基点分支的一部分。 如果我们有以下情况："

#. type: delimited block -
#: en/git-rebase.txt:150
#, no-wrap, placeholders:'---I---J':'---F---G':'---B---C---D', priority:100
msgid ""
"                            H---I---J topicB\n"
"                           /\n"
"                  E---F---G  topicA\n"
"                 /\n"
"    A---B---C---D  master\n"
msgstr ""
"                            H---I---J topicB\n"
"                           /\n"
"                  E---F---G  topicA\n"
"                 /\n"
"    A---B---C---D  master\n"

#. type: Plain text
#: en/git-rebase.txt:153 en/git-rebase.txt:176
#, priority:100
msgid "then the command"
msgstr "那么命令"

#. type: Plain text
#: en/git-rebase.txt:155
#, no-wrap, placeholders:'--onto', priority:100
msgid "    git rebase --onto master topicA topicB\n"
msgstr "    git rebase --onto master topicA topicB\n"

#. type: Plain text
#: en/git-rebase.txt:157
#, priority:100
msgid "would result in:"
msgstr "将导致 :"

#. type: delimited block -
#: en/git-rebase.txt:164
#, no-wrap, placeholders:'--I':'--J':'---F---G':'---B---C---D', priority:100
msgid ""
"                 H'--I'--J'  topicB\n"
"                /\n"
"                | E---F---G  topicA\n"
"                |/\n"
"    A---B---C---D  master\n"
msgstr ""
"                 H'--I'--J'  topicB\n"
"                /\n"
"                | E---F---G  topicA\n"
"                |/\n"
"    A---B---C---D  master\n"

#. type: Plain text
#: en/git-rebase.txt:167
#, priority:100
msgid "This is useful when topicB does not depend on topicA."
msgstr "这在主题 B 不依赖于主题 A 的情况下非常有用。"

#. type: Plain text
#: en/git-rebase.txt:170
#, priority:100
msgid "A range of commits could also be removed with rebase. If we have the following situation:"
msgstr "也可以用变基删除一系列提交。 如果我们遇到以下情况 :"

#. type: delimited block -
#: en/git-rebase.txt:173
#, no-wrap, placeholders:'---F---G---H---I---J', priority:100
msgid "    E---F---G---H---I---J  topicA\n"
msgstr "    E---F---G---H---I---J  topicA\n"

#. type: Plain text
#: en/git-rebase.txt:178
#, no-wrap, placeholders:'--onto', priority:100
msgid "    git rebase --onto topicA~5 topicA~3 topicA\n"
msgstr "    git rebase --onto topicA~5 topicA~3 topicA\n"

#. type: Plain text
#: en/git-rebase.txt:180
#, priority:100
msgid "would result in the removal of commits F and G:"
msgstr "将导致删除 F 和 G 项："

#. type: delimited block -
#: en/git-rebase.txt:183
#, no-wrap, placeholders:'---H':'---I':'---J', priority:100
msgid "    E---H'---I'---J'  topicA\n"
msgstr "    E---H'---I'---J'  topicA\n"

#. type: Plain text
#: en/git-rebase.txt:188
#, placeholders:'`--onto`', priority:100
msgid "This is useful if F and G were flawed in some way, or should not be part of topicA. Note that the argument to `--onto` and the `<upstream>` parameter can be any valid commit-ish."
msgstr "如果 F 和 G 在某些方面有缺陷，或者不应该是 topicA 的一部分，这一点就很有用。 请注意，`--onto` 参数和 `<upstream>` 参数可以是任何有效的提交。"

#. type: Plain text
#: en/git-rebase.txt:194
#, priority:100
msgid "In case of conflict, `git rebase` will stop at the first problematic commit and leave conflict markers in the tree. You can use `git diff` to locate the markers (<<<<<<) and make edits to resolve the conflict. For each file you edit, you need to tell Git that the conflict has been resolved, typically this would be done with"
msgstr "如果出现冲突，`git rebase` 会在第一个有问题的提交处停止，并在树中留下冲突标记。 你可以用 `git diff` 找到这些标记 (<<<<<<)，并进行编辑以解决冲突。 每编辑一个文件，都需要告诉 Git 冲突已被解决，通常可以用"

#. type: Plain text
#: en/git-rebase.txt:197
#, no-wrap, priority:100
msgid "    git add <filename>\n"
msgstr "    git add <filename>\n"

#. type: Plain text
#: en/git-rebase.txt:201
#, priority:100
msgid "After resolving the conflict manually and updating the index with the desired resolution, you can continue the rebasing process with"
msgstr "手动解决冲突并以所需的分辨率更新索引后，您可以使用"

#. type: Plain text
#: en/git-rebase.txt:204
#, no-wrap, placeholders:'--continue', priority:100
msgid "    git rebase --continue\n"
msgstr "    git rebase --continue\n"

#. type: Plain text
#: en/git-rebase.txt:207
#, priority:100
msgid "Alternatively, you can undo the 'git rebase' with"
msgstr "或者，您也可以通过以下方法撤销 'git rebase' 操作"

#. type: Plain text
#: en/git-rebase.txt:210
#, no-wrap, placeholders:'--abort', priority:100
msgid "    git rebase --abort\n"
msgstr "    git rebase --abort\n"

#. type: Title -
#: en/git-rebase.txt:212
#, no-wrap, priority:100
msgid "MODE OPTIONS"
msgstr "模式选项"

#. type: Plain text
#: en/git-rebase.txt:216
#, priority:100
msgid "The options in this section cannot be used with any other option, including not with each other:"
msgstr "本节中的选项不能与任何其他选项一起使用，包括不能相互使用："

#. type: Plain text
#: en/git-rebase.txt:219
#, priority:100
msgid "Restart the rebasing process after having resolved a merge conflict."
msgstr "解决合并冲突后，重新启动重新分区进程。"

#. type: Plain text
#: en/git-rebase.txt:222
#, priority:100
msgid "Restart the rebasing process by skipping the current patch."
msgstr "跳过当前补丁，重新启动重新分区进程。"

#. type: Plain text
#: en/git-rebase.txt:229
#, placeholders:'HEAD':'HEAD':'HEAD', priority:100
msgid "Abort the rebase operation and reset HEAD to the original branch. If `<branch>` was provided when the rebase operation was started, then `HEAD` will be reset to `<branch>`. Otherwise `HEAD` will be reset to where it was when the rebase operation was started."
msgstr "终止变基操作并将 HEAD 重置为原始分支。如果在启动变基操作时提供了 `<分支>`，那么 `HEAD` 将被重置为 `<分支>`。否则，`HEAD` 将被重置为启动变基操作时的位置。"

#. type: Plain text
#: en/git-rebase.txt:235
#, placeholders:'HEAD':'`--autostash`', priority:100
msgid "Abort the rebase operation but `HEAD` is not reset back to the original branch. The index and working tree are also left unchanged as a result. If a temporary stash entry was created using `--autostash`, it will be saved to the stash list."
msgstr "放弃变基操作，但 `HEAD` 不会重置回原始分支。索引和工作树也会因此保持不变。如果使用 `--autostash` 创建了临时储藏条目，它将被保存到储藏列表中。"

#. type: Labeled list
#: en/git-rebase.txt:236
#, ignore-same, no-wrap, priority:100
msgid "--edit-todo"
msgstr "--edit-todo"

#. type: Plain text
#: en/git-rebase.txt:238
#, priority:100
msgid "Edit the todo list during an interactive rebase."
msgstr "在交互式变基过程中编辑待办事项列表。"

#. type: Labeled list
#: en/git-rebase.txt:239
#, ignore-same, no-wrap, priority:100
msgid "--show-current-patch"
msgstr "--show-current-patch"

#. type: Plain text
#: en/git-rebase.txt:243
#, placeholders:'REBASE_HEAD', priority:100
msgid "Show the current patch in an interactive rebase or when rebase is stopped because of conflicts. This is the equivalent of `git show REBASE_HEAD`."
msgstr "在交互式变基或因冲突而停止变基时显示当前补丁。相当于 `git show REBASE_HEAD`。"

#. type: Labeled list
#: en/git-rebase.txt:246
#, no-wrap, placeholders:'--onto', priority:100
msgid "--onto <newbase>"
msgstr "--onto <新基础>"

#. type: Plain text
#: en/git-rebase.txt:251
#, placeholders:'`--onto`', priority:100
msgid "Starting point at which to create the new commits. If the `--onto` option is not specified, the starting point is `<upstream>`. May be any valid commit, and not just an existing branch name."
msgstr "创建新提交的起点。如果未指定 `--onto` 选项，则起点为 `<upstream>`。 可以是任何有效的提交，而不仅仅是现有的分支名称。"

#. type: Plain text
#: en/git-rebase.txt:255
#, ignore-ellipsis, placeholders:'HEAD', priority:100
msgid "As a special case, you may use \"A\\...B\" as a shortcut for the merge base of A and B if there is exactly one merge base. You can leave out at most one of A and B, in which case it defaults to HEAD."
msgstr "作为一种特殊情况，如果 A 和 B 的合并库只有一个，则可以使用 \"A\\...B \"作为合并库的快捷方式。您最多可以省略 A 和 B 中的一个，在这种情况下，它默认为 HEAD。"

#. type: Labeled list
#: en/git-rebase.txt:256
#, ignore-same, no-wrap, priority:100
msgid "--keep-base"
msgstr "--keep-base"

#. type: Plain text
#: en/git-rebase.txt:262
#, ignore-ellipsis, placeholders:'--keep-base':'--reapply-cherry-picks':'--no-fork-point':'--onto', priority:100
msgid "Set the starting point at which to create the new commits to the merge base of `<upstream>` and `<branch>`. Running `git rebase --keep-base <upstream> <branch>` is equivalent to running `git rebase --reapply-cherry-picks --no-fork-point --onto <upstream>...<branch> <upstream> <branch>`."
msgstr "将创建新提交的起点设为 `<upstream>` 和 `<branch>` 的合并库。运行 `git rebase --keep-base <upstream> <branch>` 相当于运行 `git rebase --reapply-cherry-picks --no-fork-point --onto <upstream>...<branch> <upstream> <branch>` 。"

#. type: Plain text
#: en/git-rebase.txt:269
#, placeholders:'`--reapply-cherry-picks`', priority:100
msgid "This option is useful in the case where one is developing a feature on top of an upstream branch. While the feature is being worked on, the upstream branch may advance and it may not be the best idea to keep rebasing on top of the upstream but to keep the base commit as-is. As the base commit is unchanged this option implies `--reapply-cherry-picks` to avoid losing commits."
msgstr "该选项适用于在上游分支上开发功能的情况。在开发功能的过程中，上游分支可能会前进，这时最好的办法可能不是继续在上游分支上重新加载，而是保持基本提交不变。由于基本提交保持不变，该选项意味着 `--reapply-cherry-picks`，以避免丢失提交。"

#. type: Plain text
#: en/git-rebase.txt:274
#, placeholders:'`--fork-point`':'`--fork-point`', priority:100
msgid "Although both this option and `--fork-point` find the merge base between `<upstream>` and `<branch>`, this option uses the merge base as the _starting point_ on which new commits will be created, whereas `--fork-point` uses the merge base to determine the _set of commits_ which will be rebased."
msgstr "虽然该选项和 `--fork-point` 都能找到 `<upstream>` 和 `<branch>` 之间的合并基数，但该选项使用合并基数作为创建新提交的_起点_，而 `--fork-point`则使用合并基数来确定将被重定向的_提交集_。"

#. type: Plain text
#: en/git-rebase.txt:276 en/git-rebase.txt:291 en/git-rebase.txt:311 en/git-rebase.txt:332 en/git-rebase.txt:354 en/git-rebase.txt:362 en/git-rebase.txt:374 en/git-rebase.txt:386 en/git-rebase.txt:395 en/git-rebase.txt:437 en/git-rebase.txt:472 en/git-rebase.txt:497 en/git-rebase.txt:510 en/git-rebase.txt:517 en/git-rebase.txt:529 en/git-rebase.txt:582 en/git-rebase.txt:589 en/git-rebase.txt:615 en/git-rebase.txt:650
#, priority:100
msgid "See also INCOMPATIBLE OPTIONS below."
msgstr "另请参阅下面的不兼容选项。"

#. type: Plain text
#: en/git-rebase.txt:281
#, priority:100
msgid "Upstream branch to compare against. May be any valid commit, not just an existing branch name. Defaults to the configured upstream for the current branch."
msgstr "要与之比较的上游分支。 可以是任何有效的提交，而不仅仅是现有的分支名称。默认为当前分支配置的上游分支。"

#. type: Plain text
#: en/git-rebase.txt:284
#, placeholders:'HEAD', priority:100
msgid "Working branch; defaults to `HEAD`."
msgstr "工作分支；默认为 `HEAD`。"

#. type: Plain text
#: en/git-rebase.txt:289
#, placeholders:'git-am', priority:100
msgid "Use applying strategies to rebase (calling `git-am` internally). This option may become a no-op in the future once the merge backend handles everything the apply one does."
msgstr "使用应用策略来变基（内部调用 `git-am`）。 一旦合并后端处理了应用后端所做的一切，这个选项将来可能就不再适用了。"

#. type: Labeled list
#: en/git-rebase.txt:292
#, ignore-same, no-wrap, priority:100
msgid "--empty=(drop|keep|ask)"
msgstr "--empty=(drop|keep|ask)"

#. type: Plain text
#: en/git-rebase.txt:303
#, placeholders:'`--interactive`':'`--exec`':'`-i`':'`--interactive`', priority:100
msgid "How to handle commits that are not empty to start and are not clean cherry-picks of any upstream commit, but which become empty after rebasing (because they contain a subset of already upstream changes). With drop (the default), commits that become empty are dropped. With keep, such commits are kept. With ask (implied by `--interactive`), the rebase will halt when an empty commit is applied allowing you to choose whether to drop it, edit files more, or just commit the empty changes. Other options, like `--exec`, will use the default of drop unless `-i`/`--interactive` is explicitly specified."
msgstr "如何处理开始时不是空的提交，也不是对上游提交的纯粹撷取，但在重排序后变为空的提交（因为它们包含了上游修改的子集）。 如果使用 drop（默认），则会丢弃变为空的提交。 如果使用 keep，则会保留此类提交。 如果使用 ask（隐含 `--interactive`），当应用空提交时，变基停止，允许你选择是丢弃它、编辑更多文件，还是只提交空改动。 其他选项，如 `--exec`，除非明确指定了 `-i`/`-interactive`，否则将使用默认的 drop。"

#. type: Plain text
#: en/git-rebase.txt:309
#, ignore-ellipsis, placeholders:'`--no-keep-empty`':'--cherry-mark':'`--reapply-cherry-picks`':'`--keep-base`', priority:100
msgid "Note that commits which start empty are kept (unless `--no-keep-empty` is specified), and commits which are clean cherry-picks (as determined by `git log --cherry-mark ...`) are detected and dropped as a preliminary step (unless `--reapply-cherry-picks` or `--keep-base` is passed)."
msgstr "需要注意的是，开始时为空的提交会被保留（除非指定了 `--no-keep-empty`），而干净的 cherry-picks 提交（由 `git log --cherry-mark ...`）会被检测到并作为第一步被丢弃（除非通过了 `--reapply-cherry-picks`或 `--keep-base`）。"

#. type: Plain text
#: en/git-rebase.txt:312 en/git-rebase.txt:670
#, ignore-same, no-wrap, priority:100
msgid "--no-keep-empty"
msgstr "--no-keep-empty"

#. type: Labeled list
#: en/git-rebase.txt:313
#, ignore-same, no-wrap, priority:100
msgid "--keep-empty"
msgstr "--keep-empty"

#. type: Plain text
#: en/git-rebase.txt:321
#, placeholders:'`--allow-empty`', priority:100
msgid "Do not keep commits that start empty before the rebase (i.e. that do not change anything from its parent) in the result. The default is to keep commits which start empty, since creating such commits requires passing the `--allow-empty` override flag to `git commit`, signifying that a user is very intentionally creating such a commit and thus wants to keep it."
msgstr "不在结果中保留重置前开始为空的提交（即不改变父提交的任何内容）。 默认情况下保留开始时为空的提交，因为创建此类提交需要向 `git commit` 传递 `--allow-empty` 覆盖标志，表明用户非常有意地创建此类提交，因此希望保留它。"

#. type: Plain text
#: en/git-rebase.txt:327
#, priority:100
msgid "Usage of this flag will probably be rare, since you can get rid of commits that start empty by just firing up an interactive rebase and removing the lines corresponding to the commits you don't want. This flag exists as a convenient shortcut, such as for cases where external tools generate many empty commits and you want them all removed."
msgstr "使用这个标记的情况可能很少，因为你只需启动交互式变基，并删除与你不想要的提交对应的行，就能删除开始时为空的提交。 该标记是一种方便的快捷方式，比如当外部工具生成许多空提交，而你希望将它们全部删除时。"

#. type: Plain text
#: en/git-rebase.txt:330
#, placeholders:'`--empty`', priority:100
msgid "For commits which do not start empty but become empty after rebasing, see the `--empty` flag."
msgstr "如果提交开始时不是空的，但重定向后变成空的，参阅 `--empty` 标志。"

#. type: Labeled list
#: en/git-rebase.txt:333
#, ignore-same, no-wrap, priority:100
msgid "--reapply-cherry-picks"
msgstr "--reapply-cherry-picks"

#. type: Labeled list
#: en/git-rebase.txt:334
#, ignore-same, no-wrap, priority:100
msgid "--no-reapply-cherry-picks"
msgstr "--no-reapply-cherry-picks"

#. type: Plain text
#: en/git-rebase.txt:340
#, placeholders:'`--empty`', priority:100
msgid "Reapply all clean cherry-picks of any upstream commit instead of preemptively dropping them. (If these commits then become empty after rebasing, because they contain a subset of already upstream changes, the behavior towards them is controlled by the `--empty` flag.)"
msgstr "重新应用任何上游提交中所有干净的拣选，而不是先发制人地丢弃它们。(如果这些提交在重排后成为空提交，因为它们包含了上游修改的子集，则对它们的行为由 `--empty` 标志控制。）"

#. type: Plain text
#: en/git-rebase.txt:349
#, placeholders:'`--keep-base`':'`--no-reapply-cherry-picks`':'`--quiet`':'advice.skippedCherryPicks':'linkgit:git-config[1]', priority:100
msgid "In the absence of `--keep-base` (or if `--no-reapply-cherry-picks` is given), these commits will be automatically dropped. Because this necessitates reading all upstream commits, this can be expensive in repositories with a large number of upstream commits that need to be read. When using the 'merge' backend, warnings will be issued for each dropped commit (unless `--quiet` is given). Advice will also be issued unless `advice.skippedCherryPicks` is set to false (see linkgit:git-config[1])."
msgstr "如果没有 `--keep-base`（或给出了 `--no-reapply-cherry-picks`），这些提交将被自动放弃。 由于这需要读取所有上游提交，对于需要读取大量上游提交的仓库来说，代价可能会很高。使用 'merge' 后端时，每次丢弃提交都会发出警告（除非给出 `--quiet`）。除非将 `advice.skippedCherryPicks` 设为 false，否则也会发出警告（参见 linkgit:git-config[1]）。"

#. type: Plain text
#: en/git-rebase.txt:352
#, placeholders:'`--reapply-cherry-picks`', priority:100
msgid "`--reapply-cherry-picks` allows rebase to forgo reading all upstream commits, potentially improving performance."
msgstr "`--reapply-cherry-picks` 允许变基操作放弃读取所有上游提交，从而可能提高性能。"

#. type: Plain text
#: en/git-rebase.txt:360
#, priority:100
msgid "No-op. Rebasing commits with an empty message used to fail and this option would override that behavior, allowing commits with empty messages to be rebased. Now commits with an empty message do not cause rebasing to halt."
msgstr "无操作。 过去，重写带空信息的提交会失败，而该选项会覆盖这一行为，允许重写带空信息的提交。 现在，带空信息的提交不会导致重定向失败。"

#. type: Plain text
#: en/git-rebase.txt:366
#, priority:100
msgid "Using merging strategies to rebase (default)."
msgstr "使用合并策略重定向（默认）。"

#. type: Plain text
#: en/git-rebase.txt:372
#, priority:100
msgid "Note that a rebase merge works by replaying each commit from the working branch on top of the `<upstream>` branch. Because of this, when a merge conflict happens, the side reported as 'ours' is the so-far rebased series, starting with `<upstream>`, and 'theirs' is the working branch. In other words, the sides are swapped."
msgstr "请注意，变基合并是通过在 `<上游>` 分支上重放工作分支的每次提交来实现的。 因此，当发生合并冲突时，被报告为 'ours' 的一方是迄今为止以 `<上游>` 为起点的重定向系列，而 'theirs' 则是工作分支。 换句话说，双方是对调的。"

#. type: Plain text
#: en/git-rebase.txt:379
#, placeholders:'`--merge`', priority:100
msgid "Use the given merge strategy, instead of the default `ort`. This implies `--merge`."
msgstr "使用给定的合并策略，而不是默认的 `ort`。暗指 `--merge`。"

#. type: Plain text
#: en/git-rebase.txt:384
#, priority:100
msgid "Because `git rebase` replays each commit from the working branch on top of the `<upstream>` branch using the given strategy, using the `ours` strategy simply empties all patches from the `<branch>`, which makes little sense."
msgstr "由于 `git rebase` 会使用给定的策略在 `<上游>` 分支之上重复工作分支的每次提交，因此使用 `ours` 策略只会清空 `<分支>` 中的所有补丁，这没有什么意义。"

#. type: Labeled list
#: en/git-rebase.txt:387
#, no-wrap, priority:100
msgid "-X <strategy-option>"
msgstr "-X <策略选项>"

#. type: Labeled list
#: en/git-rebase.txt:388
#, no-wrap, placeholders:'--strategy-option=', priority:100
msgid "--strategy-option=<strategy-option>"
msgstr "--strategy-option=<策略选项>"

#. type: Plain text
#: en/git-rebase.txt:393
#, placeholders:'`--merge`':'`-m`', priority:100
msgid "Pass the <strategy-option> through to the merge strategy. This implies `--merge` and, if no strategy has been specified, `-s ort`. Note the reversal of 'ours' and 'theirs' as noted above for the `-m` option."
msgstr "将 <策略选项> 传递给合并策略。 这意味着 `--merge`，如果没有指定策略，则是 `--s ort`。 请注意 'ours' 和 'theirs' 的颠倒，就像上面的 `-m`选项一样。"

#. type: Plain text
#: en/git-rebase.txt:410
#, placeholders:'`--no-stat`', priority:100
msgid "Be quiet. Implies `--no-stat`."
msgstr "静默。暗含 `--no-stat` 选项。"

# ERROR: --stat not found in translation
#. type: Plain text
#: en/git-rebase.txt:414
#, placeholders:'`--stat`', priority:100
msgid "Be verbose. Implies `--stat`."
msgstr "详尽输出。暗含 `--stat` 选项。"

#. type: Plain text
#: en/git-rebase.txt:418
#, placeholders:'rebase.stat', priority:100
msgid "Show a diffstat of what changed upstream since the last rebase. The diffstat is also controlled by the configuration option rebase.stat."
msgstr "显示上次变基后上游变化的差异状态。差异状态也由配置选项 rebase.stat 控制。"

#. type: Plain text
#: en/git-rebase.txt:422
#, priority:100
msgid "Do not show a diffstat as part of the rebase process."
msgstr "不要将差异状态作为变基过程的一部分。"

#. type: Plain text
#: en/git-rebase.txt:425
#, placeholders:'linkgit:githooks[5]', priority:100
msgid "This option bypasses the pre-rebase hook. See also linkgit:githooks[5]."
msgstr "该选项会绕过 pre-rebase 钩子。 另请参阅 linkgit:githooks[5]。"

#. type: Labeled list
#: en/git-rebase.txt:426 en/git-rev-parse.txt:98 en/git-show-ref.txt:67 en/git-tag.txt:88
#, ignore-same, no-wrap, priority:240
msgid "--verify"
msgstr "--verify"

#. type: Plain text
#: en/git-rebase.txt:429
#, placeholders:'`--no-verify`':'linkgit:githooks[5]', priority:100
msgid "Allows the pre-rebase hook to run, which is the default. This option can be used to override `--no-verify`. See also linkgit:githooks[5]."
msgstr "允许运行 pre-rebase 钩子，这是默认选项。 该选项可用于覆盖 `--no-verify`。 另请参见 linkgit:githooks[5]。"

#. type: Plain text
#: en/git-rebase.txt:435
#, placeholders:'`--apply`', priority:100
msgid "Ensure at least `<n>` lines of surrounding context match before and after each change. When fewer lines of surrounding context exist they all must match. By default no context is ever ignored. Implies `--apply`."
msgstr "确保每次更改前后至少有 `<n>` 行周围上下文匹配。 如果周围的上下文行数较少，则必须全部匹配。 默认情况下，不会忽略任何上下文。 暗指 `--apply`。"

#. type: Labeled list
#: en/git-rebase.txt:438 en/merge-options.txt:47 en/merge-options.txt:62
#, ignore-same, no-wrap, priority:240
msgid "--no-ff"
msgstr "--no-ff"

#. type: Labeled list
#: en/git-rebase.txt:439
#, ignore-same, no-wrap, priority:100
msgid "--force-rebase"
msgstr "--force-rebase"

#. type: Plain text
#: en/git-rebase.txt:444
#, priority:100
msgid "Individually replay all rebased commits instead of fast-forwarding over the unchanged ones. This ensures that the entire history of the rebased branch is composed of new commits."
msgstr "单独重放所有重定向的提交，而不是快进不变的提交。 这样就能确保重建分支的整个历史都是由新提交组成的。"

#. type: Plain text
#: en/git-rebase.txt:450
#, placeholders:'link:howto/revert-a-faulty-merge.html[', priority:100
msgid "You may find this helpful after reverting a topic branch merge, as this option recreates the topic branch with fresh commits so it can be remerged successfully without needing to \"revert the reversion\" (see the link:howto/revert-a-faulty-merge.html[revert-a-faulty-merge How-To] for details)."
msgstr "在还原主题分支合并后，你可能会发现这很有帮助，因为该选项会用新提交的内容重新创建主题分支，这样就可以成功地重新合并，而无需 “恢复原状”（详见link:howto/revert-a-faulty-merge.html[如何还原故障合并]）。"

#. type: Labeled list
#: en/git-rebase.txt:452
#, ignore-same, no-wrap, priority:100
msgid "--no-fork-point"
msgstr "--no-fork-point"

#. type: Plain text
#: en/git-rebase.txt:456
#, priority:100
msgid "Use reflog to find a better common ancestor between `<upstream>` and `<branch>` when calculating which commits have been introduced by `<branch>`."
msgstr "在计算哪些提交由 `<分支>` 引入时，使用引用日志在 `<上游仓库>` 和 `<分支>` 之间找到更好的共同祖先。"

#. type: Plain text
#: en/git-rebase.txt:462
#, placeholders:'`--fork-point`':'fork_point':'fork_point':'git merge-base':'--fork-point':'linkgit:git-merge-base[1]':'fork_point', priority:100
msgid "When `--fork-point` is active, 'fork_point' will be used instead of `<upstream>` to calculate the set of commits to rebase, where 'fork_point' is the result of `git merge-base --fork-point <upstream> <branch>` command (see linkgit:git-merge-base[1]). If 'fork_point' ends up being empty, the `<upstream>` will be used as a fallback."
msgstr "当启用 `--fork-point` 时，将使用 'fork_point' 而不是 `<上游仓库>` 来计算要重置的提交集，其中 'fork_point' 是 `git merge-base --fork-point <上游仓库> <分支>` 命令的结果（参见 linkgit:git-merge-base[1]）。 如果 'fork_point' 最终为空，`<上游仓库>` 将作为备用。"

# ERROR: `--keep-base` not found in translation
#. type: Plain text
#: en/git-rebase.txt:466
#, placeholders:'`--keep-base`':'`--no-fork-point`':'`--fork-point`':'rebase.forkpoint':'linkgit:git-config[1]', priority:100
msgid "If `<upstream>` or `--keep-base` is given on the command line, then the default is `--no-fork-point`, otherwise the default is `--fork-point`. See also `rebase.forkpoint` in linkgit:git-config[1]."
msgstr "如果在命令行中提供了 `<上游仓库> ` 或 `--keep-base` 参数，则默认为 `--no-fork-point`，否则默认为 `--fork-point`。另请参阅 linkgit:git-config[1] 中的 `rebase.forkpoint`。"

#. type: Plain text
#: en/git-rebase.txt:470
#, placeholders:'`--keep-base`', priority:100
msgid "If your branch was based on `<upstream>` but `<upstream>` was rewound and your branch contains commits which were dropped, this option can be used with `--keep-base` in order to drop those commits from your branch."
msgstr "如果你的分支基于 `<上游仓库>`，但 `<上游仓库>` 被回退了，而你的分支包含了被删除的提交，那么可以使用 `--keep-base` 选项来从你的分支中删除那些提交。"

#. type: Plain text
#: en/git-rebase.txt:477
#, priority:100
msgid "Ignore whitespace differences when trying to reconcile differences. Currently, each backend implements an approximation of this behavior:"
msgstr "在尝试协调差异时空格的差异。目前，每个后端都实现了对此行为的近似处理："

#. type: Labeled list
#: en/git-rebase.txt:478
#, no-wrap, priority:100
msgid "apply backend"
msgstr "应用后端"

#. type: Plain text
#: en/git-rebase.txt:484
#, priority:100
msgid "When applying a patch, ignore changes in whitespace in context lines. Unfortunately, this means that if the \"old\" lines being replaced by the patch differ only in whitespace from the existing file, you will get a merge conflict instead of a successful patch application."
msgstr "在应用补丁时，忽略上下文行中的空格更改。不幸的是，这意味着如果补丁中要替换的“旧”行与现有文件中的行仅在空格方面有差异，你将得到一个合并冲突而不是成功的补丁应用。"

#. type: Labeled list
#: en/git-rebase.txt:485
#, no-wrap, priority:100
msgid "merge backend"
msgstr "合并后端"

#. type: Plain text
#: en/git-rebase.txt:490
#, priority:100
msgid "Treat lines with only whitespace changes as unchanged when merging. Unfortunately, this means that any patch hunks that were intended to modify whitespace and nothing else will be dropped, even if the other side had no changes that conflicted."
msgstr "在合并时，将仅包含空格更改的行视为未更改。不幸的是，这意味着任何旨在修改空格而不涉及其他更改的补丁块将被丢弃，即使另一方没有发生冲突的更改。"

#. type: Labeled list
#: en/git-rebase.txt:491
#, no-wrap, placeholders:'--whitespace=', priority:100
msgid "--whitespace=<option>"
msgstr "--whitespace=<选项>"

#. type: Plain text
#: en/git-rebase.txt:495
#, placeholders:'linkgit:git-apply[1]':'`--apply`', priority:100
msgid "This flag is passed to the `git apply` program (see linkgit:git-apply[1]) that applies the patch. Implies `--apply`."
msgstr "这个标志被传递给应用补丁的 `git apply` 程序（参阅 linkgit:git-apply[1]）。它隐含了 `--apply`。"

#. type: Plain text
#: en/git-rebase.txt:502
#, placeholders:'`--force-rebase`', priority:100
msgid "Instead of using the current time as the committer date, use the author date of the commit being rebased as the committer date. This option implies `--force-rebase`."
msgstr "不使用当前时间作为提交者日期，而是使用被重定向的提交的作者日期作为提交者日期。该选项暗含 `--force-rebase` 选项。"

#. type: Labeled list
#: en/git-rebase.txt:504
#, ignore-same, no-wrap, priority:100
msgid "--reset-author-date"
msgstr "--reset-author-date"

#. type: Plain text
#: en/git-rebase.txt:508
#, placeholders:'`--force-rebase`', priority:100
msgid "Instead of using the author date of the original commit, use the current time as the\tauthor date of the rebased commit. This option implies `--force-rebase`."
msgstr "不使用原始提交的作者日期，而使用当前时间作为重建提交的作者日期。 此选项暗含 `--force-rebase` 选项。"

#. type: Plain text
#: en/git-rebase.txt:515
#, placeholders:'`--interactive`', priority:100
msgid "Add a `Signed-off-by` trailer to all the rebased commits. Note that if `--interactive` is given then only commits marked to be picked, edited or reworded will have the trailer added."
msgstr "在所有重写的提交中添加 `Signed-off-by` 尾注。请注意，如果给定了 `--interactive`，则只有标记为被选中、编辑或重写的提交才会添加尾注。"

#. type: Plain text
#: en/git-rebase.txt:523
#, priority:100
msgid "Make a list of the commits which are about to be rebased. Let the user edit that list before rebasing. This mode can also be used to split commits (see SPLITTING COMMITS below)."
msgstr "列出即将重写的提交列表。 让用户在重写前编辑该列表。 这种模式也可用于拆分提交（见下文的拆分提交）。"

#. type: Plain text
#: en/git-rebase.txt:527
#, placeholders:'rebase.instructionFormat', priority:100
msgid "The commit list format can be changed by setting the configuration option rebase.instructionFormat. A customized instruction format will automatically have the commit hash prepended to the format."
msgstr "提交列表格式可通过设置配置选项 rebase.instructionFormat 进行更改。 自定义的指令格式会自动在格式前加上长提交哈希值。"

#. type: Labeled list
#: en/git-rebase.txt:531
#, ignore-same, no-wrap, priority:100
msgid "--rebase-merges[=(rebase-cousins|no-rebase-cousins)]"
msgstr "--rebase-merges[=(rebase-cousins|no-rebase-cousins)]"

#. type: Labeled list
#: en/git-rebase.txt:532
#, ignore-same, no-wrap, priority:100
msgid "--no-rebase-merges"
msgstr "--no-rebase-merges"

#. type: Plain text
#: en/git-rebase.txt:542
#, placeholders:'`--rebase-merges`':'`--no-rebase-merges`':'rebase.rebaseMerges':'`--rebase-merges`', priority:100
msgid "By default, a rebase will simply drop merge commits from the todo list, and put the rebased commits into a single, linear branch. With `--rebase-merges`, the rebase will instead try to preserve the branching structure within the commits that are to be rebased, by recreating the merge commits. Any resolved merge conflicts or manual amendments in these merge commits will have to be resolved/re-applied manually. `--no-rebase-merges` can be used to countermand both the `rebase.rebaseMerges` config option and a previous `--rebase-merges`."
msgstr "默认情况下，变基操作会简单地从待办事项列表中删除合并提交，并将被重置的提交放入一个单一的线性分支中。 使用 `--rebase-merges` 后，变基操作会通过重新创建合并提交，尝试保留要被重置的提交中的分支结构。在这些合并提交中，任何已解决的合并冲突或手动修正都必须手动解决/重新应用。`--no-rebase-merges` 可以用来抵消 `rebase.rebaseMerges` 配置选项和之前的 `--rebase-merges 选项。"

#. type: Plain text
#: en/git-rebase.txt:551
#, placeholders:'linkgit:git-log[1]':'`--ancestry-path`', priority:100
msgid "When rebasing merges, there are two modes: `rebase-cousins` and `no-rebase-cousins`. If the mode is not specified, it defaults to `no-rebase-cousins`. In `no-rebase-cousins` mode, commits which do not have `<upstream>` as direct ancestor will keep their original branch point, i.e. commits that would be excluded by linkgit:git-log[1]'s `--ancestry-path` option will keep their original ancestry by default. In `rebase-cousins` mode, such commits are instead rebased onto `<upstream>` (or `<onto>`, if specified)."
msgstr "重定向合并时，有两种模式： `rebase-cousins` 和 `no-rebase-cousins`。如果未指定模式，则默认为 `no-rebase-cousins`。在 `no-rebase-cousins` 模式下，没有 `<上游仓库>` 作为直接祖先的提交将保留其原始分支点，也就是说，被 linkgit:git-log[1] 的 `--ancestry-path` 选项排除在外的提交将默认保留其原始祖先。在 `rebase-cousins` 模式下，此类提交会被重定向到 `<上游仓库>`（或是`<onto>`，如果指定了）。"

#. type: Plain text
#: en/git-rebase.txt:555
#, ignore-ellipsis, priority:100
msgid "It is currently only possible to recreate the merge commits using the `ort` merge strategy; different merge strategies can be used only via explicit `exec git merge -s <strategy> [...]` commands."
msgstr "目前只能使用 `ort` 合并策略重新创建合并提交；只有通过明确的 `exec git merge -s <strategy> [...]` 命令才能使用不同的合并策略。"

#. type: Plain text
#: en/git-rebase.txt:557
#, priority:100
msgid "See also REBASING MERGES and INCOMPATIBLE OPTIONS below."
msgstr "另请参阅下面的重置合并和不兼容选项。"

#. type: Labeled list
#: en/git-rebase.txt:558
#, no-wrap, priority:100
msgid "-x <cmd>"
msgstr "-x <命令>"

#. type: Labeled list
#: en/git-rebase.txt:559
#, no-wrap, placeholders:'--exec', priority:100
msgid "--exec <cmd>"
msgstr "--exec <命令>"

#. type: Plain text
#: en/git-rebase.txt:564
#, priority:100
msgid "Append \"exec <cmd>\" after each line creating a commit in the final history. `<cmd>` will be interpreted as one or more shell commands. Any command that fails will interrupt the rebase, with exit code 1."
msgstr "在最终历史记录中创建提交的每一行后添加 \"exec <命令>\"。`<命令>` 将被解释为一个或多个 shell 命令。任何失败的命令都会中断重置，退出代码为 1。"

#. type: Plain text
#: en/git-rebase.txt:567
#, placeholders:'`--exec`', priority:100
msgid "You may execute several commands by either using one instance of `--exec` with several commands:"
msgstr "您可以通过使用一个包含多个命令的 `--exec` 实例来执行多个命令："

#. type: Plain text
#: en/git-rebase.txt:569
#, ignore-ellipsis, no-wrap, placeholders:'--exec', priority:100
msgid "\tgit rebase -i --exec \"cmd1 && cmd2 && ...\"\n"
msgstr "\tgit rebase -i --exec \"cmd1 && cmd2 && ...\"\n"

#. type: Plain text
#: en/git-rebase.txt:571
#, placeholders:'`--exec`', priority:100
msgid "or by giving more than one `--exec`:"
msgstr "或给出多个 `--exec`："

#. type: Plain text
#: en/git-rebase.txt:573
#, ignore-ellipsis, no-wrap, placeholders:'--exec':'--exec':'--exec', priority:100
msgid "\tgit rebase -i --exec \"cmd1\" --exec \"cmd2\" --exec ...\n"
msgstr "\tgit rebase -i --exec \"cmd1\" --exec \"cmd2\" --exec ...\n"

#. type: Plain text
#: en/git-rebase.txt:577
#, placeholders:'`--autosquash`', priority:100
msgid "If `--autosquash` is used, `exec` lines will not be appended for the intermediate commits, and will only appear at the end of each squash/fixup series."
msgstr "如果使用了 `--autosquash`，则不会为中间提交附加 `exec` 行，而只会出现在每个 squash/fixup 系列的末尾。"

#. type: Plain text
#: en/git-rebase.txt:580
#, placeholders:'`--interactive`':'`--interactive`', priority:100
msgid "This uses the `--interactive` machinery internally, but it can be run without an explicit `--interactive`."
msgstr "它在内部使用 `--interactive` 机制，但也可以在没有显式 `--interactive` 的情况下运行。"

#. type: Plain text
#: en/git-rebase.txt:587
#, priority:100
msgid "Rebase all commits reachable from `<branch>`, instead of limiting them with an `<upstream>`. This allows you to rebase the root commit(s) on a branch."
msgstr "重置从 `<分支>` 到的所有提交，而不是用 `<上游分支>` 来限制它们。 这样就可以重定向分支上的根提交。"

#. type: Plain text
#: en/git-rebase.txt:590 en/git-rebase.txt:666
#, ignore-same, no-wrap, priority:100
msgid "--autosquash"
msgstr "--autosquash"

#. type: Labeled list
#: en/git-rebase.txt:591
#, ignore-same, no-wrap, priority:100
msgid "--no-autosquash"
msgstr "--no-autosquash"

#. type: Plain text
#: en/git-rebase.txt:599
#, priority:100
msgid "Automatically squash commits with specially formatted messages into previous commits being rebased. If a commit message starts with \"squash! \", \"fixup! \" or \"amend! \", the remainder of the subject line is taken as a commit specifier, which matches a previous commit if it matches the subject line or the hash of that commit. If no commit matches fully, matches of the specifier with the start of commit subjects are considered."
msgstr "自动将带有特殊格式信息的提交压制到正在重建的前提交中。如果提交信息以 \"squash!\"、\"fixup!\" 或 \"amend!\" 开头，则主题行的其余部分将作为提交说明符，如果与主题行或该提交的哈希值相匹配，则与之前的提交相匹配。如果没有完全匹配的提交，则会考虑与提交主题开头的指定符匹配。"

#. type: Plain text
#: en/git-rebase.txt:604
#, placeholders:'`--interactive`', priority:100
msgid "In the rebase todo list, the actions of squash, fixup and amend commits are changed from `pick` to `squash`, `fixup` or `fixup -C`, respectively, and they are moved right after the commit they modify. The `--interactive` option can be used to review and edit the todo list before proceeding."
msgstr "在 rebase todo 列表中，squash、fixup 和 amend 提交的操作将分别从 `pick` 改为 `squash`、`fixup` 或 `fixup -C`，而且它们会被移到所修改的提交之后。在继续之前，可以使用 `--interactive` 选项查看和编辑待办事项列表。"

#. type: Plain text
#: en/git-rebase.txt:609
#, placeholders:'`--squash`':'`--fixup`':'`--fixup=amend':'`--fixup=reword':'linkgit:git-commit[1]', priority:100
msgid "The recommended way to create commits with squash markers is by using the `--squash`, `--fixup`, `--fixup=amend:` or `--fixup=reword:` options of linkgit:git-commit[1], which take the target commit as an argument and automatically fill in the subject line of the new commit from that."
msgstr "建议使用 linkgit:git-commit[1] 的 `--squash`、`--fixup`、`--fixup=amend:` 或 `--fixup=reword:` 选项来创建带有压扁标记的提交。"

#. type: Plain text
#: en/git-rebase.txt:613
#, placeholders:'rebase.autoSquash':'`--no-autosquash`', priority:100
msgid "Settting configuration variable `rebase.autoSquash` to true enables auto-squashing by default for interactive rebase. The `--no-autosquash` option can be used to override that setting."
msgstr "将配置变量 `rebase.autoSquash` 设为 true，可启用交互式变基默认自动清空功能。可以使用 `--no-autosquash`选项来覆盖该设置。"

#. type: Labeled list
#: en/git-rebase.txt:616 en/merge-options.txt:191
#, ignore-same, no-wrap, priority:240
msgid "--autostash"
msgstr "--autostash"

#. type: Labeled list
#: en/git-rebase.txt:617 en/merge-options.txt:192
#, ignore-same, no-wrap, priority:240
msgid "--no-autostash"
msgstr "--no-autostash"

#. type: Plain text
#: en/git-rebase.txt:623
#, priority:100
msgid "Automatically create a temporary stash entry before the operation begins, and apply it after the operation ends. This means that you can run rebase on a dirty worktree. However, use with care: the final stash application after a successful rebase might result in non-trivial conflicts."
msgstr "在操作开始前自动创建临时存储条目，并在操作结束后应用它。 这意味着你可以在脏工作树上运行变基操作。 不过，请谨慎使用：成功重储后的最终储藏应用可能会导致非实质性冲突。"

#. type: Labeled list
#: en/git-rebase.txt:624
#, ignore-same, no-wrap, priority:100
msgid "--reschedule-failed-exec"
msgstr "--reschedule-failed-exec"

#. type: Labeled list
#: en/git-rebase.txt:625
#, ignore-same, no-wrap, priority:100
msgid "--no-reschedule-failed-exec"
msgstr "--no-reschedule-failed-exec"

#. type: Plain text
#: en/git-rebase.txt:628
#, placeholders:'`--exec`', priority:100
msgid "Automatically reschedule `exec` commands that failed. This only makes sense in interactive mode (or when an `--exec` option was provided)."
msgstr "自动重新安排执行失败的 `exec` 命令。这只有在交互模式下（或提供了 `--exec` 选项时）才有意义。"

#. type: Plain text
#: en/git-rebase.txt:633
#, placeholders:'rebase.rescheduleFailedExec':'linkgit:git-config[1]', priority:100
msgid "This option applies once a rebase is started. It is preserved for the whole rebase based on, in order, the command line option provided to the initial `git rebase`, the `rebase.rescheduleFailedExec` configuration (see linkgit:git-config[1] or \"CONFIGURATION\" below), or it defaults to false."
msgstr "一旦启动变基程序，该选项就会生效。它会在整个变基过程和中保留，依次基于初始 `git rebase` 所提供的命令行选项、`rebase.rescheduleFailedExec` 配置（参见 linkgit:git-config[1] 或下文的“配置”），或者默认为 false。"

#. type: Plain text
#: en/git-rebase.txt:639
#, placeholders:'`--no-reschedule-failed-exec`':'rebase.rescheduleFailedExec':'--continue`':'--continue`', priority:100
msgid "Recording this option for the whole rebase is a convenience feature. Otherwise an explicit `--no-reschedule-failed-exec` at the start would be overridden by the presence of a `rebase.rescheduleFailedExec=true` configuration when `git rebase --continue` is invoked. Currently, you cannot pass `--[no-]reschedule-failed-exec` to `git rebase --continue`."
msgstr "为整个 rebase 记录该选项是为了方便起见。否则，当调用 `git rebase --continue` 时，在开始时显式的 `--no-reschedule-failed-exec` 会被 `rebase.rescheduleFailedExec=true` 配置覆盖。目前，不能向 `git rebase --continue` 传递 `--[no-]reschedule-failed-exec`。"

#. type: Plain text
#: en/git-rebase.txt:640 en/git-rebase.txt:673
#, ignore-same, no-wrap, priority:100
msgid "--update-refs"
msgstr "--update-refs"

#. type: Labeled list
#: en/git-rebase.txt:641
#, ignore-same, no-wrap, priority:100
msgid "--no-update-refs"
msgstr "--no-update-refs"

#. type: Plain text
#: en/git-rebase.txt:645
#, priority:100
msgid "Automatically force-update any branches that point to commits that are being rebased. Any branches that are checked out in a worktree are not updated in this way."
msgstr "自动强制更新任何指向正在重定向的提交的分支。任何在工作区中签出的分支都不会以这种方式更新。"

#. type: Plain text
#: en/git-rebase.txt:648
#, placeholders:'rebase.updateRefs', priority:100
msgid "If the configuration variable `rebase.updateRefs` is set, then this option can be used to override and disable this setting."
msgstr "如果设置了配置变量 `rebase.updateRefs`, 则可使用此选项覆盖并禁用此设置。"

#. type: Title -
#: en/git-rebase.txt:652
#, no-wrap, priority:100
msgid "INCOMPATIBLE OPTIONS"
msgstr "不兼容选项"

#. type: Plain text
#: en/git-rebase.txt:655
#, priority:100
msgid "The following options:"
msgstr "下列选项："

#. type: Plain text
#: en/git-rebase.txt:658
#, ignore-same, priority:100
msgid "--whitespace"
msgstr "--whitespace"

#. type: Plain text
#: en/git-rebase.txt:661
#, priority:100
msgid "are incompatible with the following options:"
msgstr "与下列选项不兼容："

#. type: Plain text
#: en/git-rebase.txt:664
#, ignore-same, priority:100
msgid "--strategy"
msgstr "--strategy"

#. type: Plain text
#: en/git-rebase.txt:665
#, ignore-same, priority:100
msgid "--strategy-option"
msgstr "--strategy-option"

#. type: Labeled list
#: en/git-rebase.txt:667 en/git-svn.txt:680
#, ignore-same, no-wrap, priority:100
msgid "--rebase-merges"
msgstr "--rebase-merges"

#. type: Plain text
#: en/git-rebase.txt:669
#, ignore-same, priority:100
msgid "--exec"
msgstr "--exec"

#. type: Plain text
#: en/git-rebase.txt:671
#, ignore-same, priority:100
msgid "--empty="
msgstr "--empty="

#. type: Plain text
#: en/git-rebase.txt:672
#, placeholders:'--keep-base', priority:100
msgid "--[no-]reapply-cherry-picks when used without --keep-base"
msgstr "--[no-]reapply-cherry-picks when used without --keep-base"

#. type: Plain text
#: en/git-rebase.txt:674
#, placeholders:'--root':'--onto', priority:100
msgid "--root when used without --onto"
msgstr "--root when used without --onto"

#. type: Plain text
#: en/git-rebase.txt:676
#, priority:100
msgid "In addition, the following pairs of options are incompatible:"
msgstr "此外，以下几对选项是不兼容的："

#. type: Plain text
#: en/git-rebase.txt:678
#, placeholders:'--keep-base':'--onto', priority:100
msgid "--keep-base and --onto"
msgstr "--keep-base and --onto"

#. type: Plain text
#: en/git-rebase.txt:679
#, placeholders:'--keep-base':'--root', priority:100
msgid "--keep-base and --root"
msgstr "--keep-base and --root"

#. type: Plain text
#: en/git-rebase.txt:680
#, placeholders:'--fork-point':'--root', priority:100
msgid "--fork-point and --root"
msgstr "--fork-point and --root"

#. type: Title -
#: en/git-rebase.txt:682
#, no-wrap, priority:100
msgid "BEHAVIORAL DIFFERENCES"
msgstr "行为差异"

#. type: Plain text
#: en/git-rebase.txt:691
#, priority:100
msgid "`git rebase` has two primary backends: 'apply' and 'merge'. (The 'apply' backend used to be known as the 'am' backend, but the name led to confusion as it looks like a verb instead of a noun. Also, the 'merge' backend used to be known as the interactive backend, but it is now used for non-interactive cases as well. Both were renamed based on lower-level functionality that underpinned each.) There are some subtle differences in how these two backends behave:"
msgstr "`git rebase` 有两个主要的后台：‘应用’ 和 ‘合并’（‘应用’ 后台曾被称为 'am' 后台，但这个名字看起来像动词而非名词，因此引起了混淆）。 此外，‘合并’ 后台曾被称为交互式后台，但现在也用于非交互式情况。 两者都是根据各自的底层功能重新命名的）。这两个后台在行为方式上有一些微妙的区别："

#. type: Title ~
#: en/git-rebase.txt:693
#, no-wrap, priority:100
msgid "Empty commits"
msgstr "空提交"

#. type: Plain text
#: en/git-rebase.txt:699
#, priority:100
msgid "The 'apply' backend unfortunately drops intentionally empty commits, i.e. commits that started empty, though these are rare in practice. It also drops commits that become empty and has no option for controlling this behavior."
msgstr "不幸的是，‘应用’ 后台会丢弃故意为空的提交，即开始时为空的提交，不过这种情况在实践中并不多见。 它还会丢弃变为空的提交，而且没有控制这种行为的选项。"

#. type: Plain text
#: en/git-rebase.txt:703
#, placeholders:'`-i`':'`--no-keep-empty`', priority:100
msgid "The 'merge' backend keeps intentionally empty commits by default (though with `-i` they are marked as empty in the todo list editor, or they can be dropped automatically with `--no-keep-empty`)."
msgstr "默认情况下，‘合并’ 后台会保留故意为空的提交（不过，如果使用 `-i` 选项，这些提交会在待办事项列表编辑器中标记为空，或者使用 `--no-keep-empty` 自动删除）。"

#. type: Plain text
#: en/git-rebase.txt:709
#, placeholders:'`-i`':'`--interactive`':'`--empty=(drop|keep|ask)`', priority:100
msgid "Similar to the apply backend, by default the merge backend drops commits that become empty unless `-i`/`--interactive` is specified (in which case it stops and asks the user what to do). The merge backend also has an `--empty=(drop|keep|ask)` option for changing the behavior of handling commits that become empty."
msgstr "与应用后端类似，合并后端默认情况下也会丢弃变为空的提交，除非指定了 `-i` 或 `--interactive` 选项（在这种情况下，合并会停止并询问用户该怎么做）。 合并后端还有一个 `--empty=(drop|keep|ask)` 选项，用于改变处理变为空的提交的行为。"

#. type: Title ~
#: en/git-rebase.txt:711
#, no-wrap, priority:100
msgid "Directory rename detection"
msgstr "目录重命名检测"

#. type: Plain text
#: en/git-rebase.txt:721
#, priority:100
msgid "Due to the lack of accurate tree information (arising from constructing fake ancestors with the limited information available in patches), directory rename detection is disabled in the 'apply' backend. Disabled directory rename detection means that if one side of history renames a directory and the other adds new files to the old directory, then the new files will be left behind in the old directory without any warning at the time of rebasing that you may want to move these files into the new directory."
msgstr "由于缺乏准确的目录树信息（利用补丁中的有限信息构建假祖先），‘应用’ 后台禁用了目录重命名检测。 禁用目录重命名检测意味着，如果历史记录的一方重命名了一个目录，而另一方在旧目录中添加了新文件，那么新文件就会被留在旧目录中，而不会在重新编排时发出任何警告，提醒您可能需要将这些文件移到新目录中。"

#. type: Plain text
#: en/git-rebase.txt:724
#, priority:100
msgid "Directory rename detection works with the 'merge' backend to provide you warnings in such cases."
msgstr "目录重命名检测与 ‘合并’ 后台协同工作，在这种情况下会向你发出警告。"

#. type: Title ~
#: en/git-rebase.txt:726
#, no-wrap, priority:100
msgid "Context"
msgstr "上下文"

#. type: Plain text
#: en/git-rebase.txt:742
#, placeholders:'diff.context', priority:100
msgid "The 'apply' backend works by creating a sequence of patches (by calling `format-patch` internally), and then applying the patches in sequence (calling `am` internally). Patches are composed of multiple hunks, each with line numbers, a context region, and the actual changes. The line numbers have to be taken with some fuzz, since the other side will likely have inserted or deleted lines earlier in the file. The context region is meant to help find how to adjust the line numbers in order to apply the changes to the right lines. However, if multiple areas of the code have the same surrounding lines of context, the wrong one can be picked. There are real-world cases where this has caused commits to be reapplied incorrectly with no conflicts reported. Setting `diff.context` to a larger value may prevent such types of problems, but increases the chance of spurious conflicts (since it will require more lines of matching context to apply)."
msgstr "‘应用’ 后台的工作方式是创建一系列补丁（在内部调用 `format-patch`），然后依次应用这些补丁（在内部调用 `am`）。 补丁由多个块组成，每个块包含行号、上下文区域和实际更改。 行号的获取必须谨慎，因为另一方很可能在文件中插入或删除了更早的行。 上下文区域的目的是帮助找到如何调整行号，以便将更改应用到正确的行上。 但是，如果代码的多个区域有相同的上下文行，就可能选错。 在现实世界中，这种情况曾导致提交被错误地重新应用，而没有报告任何冲突。 将 `diff.context` 设置为更大的值可能会避免此类问题，但会增加发生虚假冲突的几率（因为需要更多行匹配的上下文才能应用）。"

#. type: Plain text
#: en/git-rebase.txt:745
#, priority:100
msgid "The 'merge' backend works with a full copy of each relevant file, insulating it from these types of problems."
msgstr "‘合并’ 后台使用每个相关文件的完整副本，从而避免了此类问题。"

#. type: Title ~
#: en/git-rebase.txt:747
#, no-wrap, priority:100
msgid "Labelling of conflicts markers"
msgstr "给冲突标记贴标签"

#. type: Plain text
#: en/git-rebase.txt:759
#, placeholders:'merge.conflictStyle', priority:100
msgid "When there are content conflicts, the merge machinery tries to annotate each side's conflict markers with the commits where the content came from. Since the 'apply' backend drops the original information about the rebased commits and their parents (and instead generates new fake commits based off limited information in the generated patches), those commits cannot be identified; instead it has to fall back to a commit summary. Also, when `merge.conflictStyle` is set to `diff3` or `zdiff3`, the 'apply' backend will use \"constructed merge base\" to label the content from the merge base, and thus provide no information about the merge base commit whatsoever."
msgstr "当出现内容冲突时，合并机制会尝试在每一方的冲突标记上标注内容来源的提交。 由于 ‘应用’ 后台丢弃了关于重建的提交及其父提交的原始信息（而是根据生成的补丁中的有限信息生成新的假提交），因此无法识别这些提交，而只能使用提交摘要。 此外，当 `merge.conflictStyle` 设置为 `diff3` 或 `zdiff3` 时，‘应用’ 后端将使用 \"constructed merge base\"（构建的合并基础）来标注来自合并基础的内容，因此不会提供任何关于合并基础提交的信息。"

#. type: Plain text
#: en/git-rebase.txt:762
#, priority:100
msgid "The 'merge' backend works with the full commits on both sides of history and thus has no such limitations."
msgstr "‘合并’ 后台使用历史上双方的完整提交，因此没有这些限制。"

#. type: Title ~
#: en/git-rebase.txt:764
#, no-wrap, priority:100
msgid "Hooks"
msgstr "钩子"

#. type: Plain text
#: en/git-rebase.txt:778
#, priority:100
msgid "The 'apply' backend has not traditionally called the post-commit hook, while the 'merge' backend has. Both have called the post-checkout hook, though the 'merge' backend has squelched its output. Further, both backends only call the post-checkout hook with the starting point commit of the rebase, not the intermediate commits nor the final commit. In each case, the calling of these hooks was by accident of implementation rather than by design (both backends were originally implemented as shell scripts and happened to invoke other commands like `git checkout` or `git commit` that would call the hooks). Both backends should have the same behavior, though it is not entirely clear which, if any, is correct. We will likely make rebase stop calling either of these hooks in the future."
msgstr "传统上，‘应用’ 后台并不调用提交后（post-commit）钩子，而 ‘合并’ 后台却调用了。 虽然 ‘合并’ 后台已取消了其输出，但两者都调用了检出后（post-checkout）钩子。 此外，这两个后端都只调用了变基操作的起点提交，而不是中间提交或最终提交的检出后（post-checkout）钩子。 在每种情况下，调用这些钩子都是偶然的，而不是设计出来的（两个后台最初都是以 shell 脚本的形式实现的，碰巧调用了其他会调用钩子的命令，如 `git checkout` 或 `git commit`）。 这两个后台应该具有相同的行为，但目前还不完全清楚哪一个才是正确的。 我们将来可能会让变基操作停止调用这些钩子。"

#. type: Title ~
#: en/git-rebase.txt:780
#, no-wrap, priority:100
msgid "Interruptability"
msgstr "可中断性"

#. type: Plain text
#: en/git-rebase.txt:789
#, placeholders:'--abort`':'lore.kernel.org':'szeder.dev', priority:100
msgid "The 'apply' backend has safety problems with an ill-timed interrupt; if the user presses Ctrl-C at the wrong time to try to abort the rebase, the rebase can enter a state where it cannot be aborted with a subsequent `git rebase --abort`. The 'merge' backend does not appear to suffer from the same shortcoming. (See https://lore.kernel.org/git/20200207132152.GC2868@szeder.dev/ for details.)"
msgstr "如果用户在错误的时间按下 Ctrl-C 试图终止重置，重置就会进入无法通过后续的 `git rebase --abort` 终止的状态。 ‘合并’ 后台似乎不存在同样的缺陷。 (详见 https://lore.kernel.org/git/20200207132152.GC2868@szeder.dev/）"

#. type: Title ~
#: en/git-rebase.txt:791
#, no-wrap, priority:100
msgid "Commit Rewording"
msgstr "重写提交"

#. type: Plain text
#: en/git-rebase.txt:799
#, placeholders:'--continue`', priority:100
msgid "When a conflict occurs while rebasing, rebase stops and asks the user to resolve. Since the user may need to make notable changes while resolving conflicts, after conflicts are resolved and the user has run `git rebase --continue`, the rebase should open an editor and ask the user to update the commit message. The 'merge' backend does this, while the 'apply' backend blindly applies the original commit message."
msgstr "当重建过程中发生冲突时，变基操作停止并要求用户解决。 由于用户可能需要在解决冲突的同时做一些显著的改动，因此在冲突解决且用户运行了 `git rebase --continue` 之后，变基时应打开一个编辑器并要求用户更新提交信息。 ‘合并’ 后台会这样做，而 ‘应用’ 后台则会盲目应用原始的提交信息。"

#. type: Title ~
#: en/git-rebase.txt:801
#, no-wrap, priority:100
msgid "Miscellaneous differences"
msgstr "其他差异"

#. type: Plain text
#: en/git-rebase.txt:806
#, priority:100
msgid "There are a few more behavioral differences that most folks would probably consider inconsequential but which are mentioned for completeness:"
msgstr "还有一些行为上的差异，大多数人可能会认为无关紧要，但为了完整起见，还是要提一下："

#. type: Plain text
#: en/git-rebase.txt:810
#, priority:100
msgid "Reflog: The two backends will use different wording when describing the changes made in the reflog, though both will make use of the word \"rebase\"."
msgstr "引用日志： 两个后台在描述引用日志中的更改时会使用不同的措辞，但都会使用 “变基（rebase）” 一词。"

#. type: Plain text
#: en/git-rebase.txt:816
#, ignore-ellipsis, priority:100
msgid "Progress, informational, and error messages: The two backends provide slightly different progress and informational messages. Also, the apply backend writes error messages (such as \"Your files would be overwritten...\") to stdout, while the merge backend writes them to stderr."
msgstr "进度、信息和错误信息： 两个后端提供的进度和信息略有不同。 此外，应用后端会将错误信息（如 “您的文件将被覆盖......”）写入标准输出流，而合并后台则写入标准错误流。"

#. type: Plain text
#: en/git-rebase.txt:819
#, priority:100
msgid "State directories: The two backends keep their state in different directories under `.git/`"
msgstr "状态目录：两个后台将状态保存在不同的目录中，分别位于`.git/`下"

#. type: Plain text
#: en/git-rebase.txt:828
#, priority:100
msgid "You should understand the implications of using `git rebase` on a repository that you share. See also RECOVERING FROM UPSTREAM REBASE below."
msgstr "您应该了解在共享的版本库中使用 `git rebase` 的影响。 另请参阅下面的从上游重建中恢复。"

#. type: Plain text
#: en/git-rebase.txt:833
#, priority:100
msgid "When the rebase is run, it will first execute a `pre-rebase` hook if one exists. You can use this hook to do sanity checks and reject the rebase if it isn't appropriate. Please see the template `pre-rebase` hook script for an example."
msgstr "在运行变基命令时，如果存在 `pre-rebase` （变基前）钩子，它会首先执行该钩子。 您可以使用此钩子进行正确性检查，并在不合适时拒绝重置。 有关示例，请参阅模板 `pre-rebase`（变基前） 钩子脚本。"

#. type: Plain text
#: en/git-rebase.txt:835
#, priority:100
msgid "Upon completion, `<branch>` will be the current branch."
msgstr "完成后，`<分支>` 将成为当前分支。"

#. type: Plain text
#: en/git-rebase.txt:842
#, priority:100
msgid "Rebasing interactively means that you have a chance to edit the commits which are rebased. You can reorder the commits, and you can remove them (weeding out bad or otherwise unwanted patches)."
msgstr "交互式重定向意味着你有机会编辑被重定向的提交。 你可以重新排列提交的顺序，也可以删除它们（剔除坏的或不需要的补丁）。"

#. type: Plain text
#: en/git-rebase.txt:844
#, priority:100
msgid "The interactive mode is meant for this type of workflow:"
msgstr "互动模式就是为这种工作流程设计的："

#. type: Plain text
#: en/git-rebase.txt:846
#, priority:100
msgid "have a wonderful idea"
msgstr "灵机一动"

#. type: Plain text
#: en/git-rebase.txt:847
#, priority:100
msgid "hack on the code"
msgstr "敲代码"

#. type: Plain text
#: en/git-rebase.txt:848
#, priority:100
msgid "prepare a series for submission"
msgstr "编写提交系列"

#. type: Plain text
#: en/git-rebase.txt:849
#, priority:100
msgid "submit"
msgstr "提交"

#. type: Plain text
#: en/git-rebase.txt:851
#, priority:100
msgid "where point 2. consists of several instances of"
msgstr "其中第 2 点由以下几个实例组成"

#. type: Plain text
#: en/git-rebase.txt:853
#, priority:100
msgid "regular use"
msgstr "常规使用"

#. type: Plain text
#: en/git-rebase.txt:855
#, priority:100
msgid "finish something worthy of a commit"
msgstr "完成值得提交的事情"

#. type: Labeled list
#: en/git-rebase.txt:856 en/git-update-ref.txt:136
#, no-wrap, priority:100
msgid "commit"
msgstr "提交"

#. type: Plain text
#: en/git-rebase.txt:858
#, priority:100
msgid "independent fixup"
msgstr "独立修复"

#. type: Plain text
#: en/git-rebase.txt:860
#, priority:100
msgid "realize that something does not work"
msgstr "发现有什么东西没有用"

#. type: Plain text
#: en/git-rebase.txt:861
#, priority:100
msgid "fix that"
msgstr "解决这个问题"

#. type: Plain text
#: en/git-rebase.txt:862
#, priority:100
msgid "commit it"
msgstr "提交"

#. type: Plain text
#: en/git-rebase.txt:868
#, priority:100
msgid "Sometimes the thing fixed in b.2. cannot be amended to the not-quite perfect commit it fixes, because that commit is buried deeply in a patch series. That is exactly what interactive rebase is for: use it after plenty of \"a\"s and \"b\"s, by rearranging and editing commits, and squashing multiple commits into one."
msgstr "有时，b.2.中修正的内容无法修正到它所修正的并不完美的提交中，因为该提交深埋在一系列补丁中。 这正是交互式变基的用途：在大量的 \"a\" 和 \"b\" 之后使用它，重新排列和编辑提交，将多个提交合并为一个提交。"

#. type: Plain text
#: en/git-rebase.txt:870
#, priority:100
msgid "Start it with the last commit you want to retain as-is:"
msgstr "从您希望保留原样的最后一次提交开始："

#. type: Plain text
#: en/git-rebase.txt:872
#, no-wrap, priority:100
msgid "\tgit rebase -i <after-this-commit>\n"
msgstr "\tgit rebase -i <本次提交后>\n"

#. type: Plain text
#: en/git-rebase.txt:877
#, priority:100
msgid "An editor will be fired up with all the commits in your current branch (ignoring merge commits), which come after the given commit. You can reorder the commits in this list to your heart's content, and you can remove them. The list looks more or less like this:"
msgstr "编辑器会弹出当前分支的所有提交（忽略合并提交），这些提交都在给定提交之后。 你可以随心所欲地调整列表中提交的顺序，也可以删除它们。 列表大致如下："

#. type: delimited block -
#: en/git-rebase.txt:882
#, ignore-ellipsis, no-wrap, priority:100
msgid ""
"pick deadbee The oneline of this commit\n"
"pick fa1afe1 The oneline of the next commit\n"
"...\n"
msgstr ""
"选择 deadbee ，本次提交的上线\n"
"选中 fa1afe1 ，下一次提交的上线\n"
"...\n"

#. type: Plain text
#: en/git-rebase.txt:887
#, priority:100
msgid "The oneline descriptions are purely for your pleasure; 'git rebase' will not look at them but at the commit names (\"deadbee\" and \"fa1afe1\" in this example), so do not delete or edit the names."
msgstr "上线描述纯粹是为了方便您查看；'git rebase' 不会查看这些描述，只会查看提交名称（本例中为 \"deadbee\" 和 \"fa1afe1\"），因此请勿删除或编辑这些名称。"

#. type: Plain text
#: en/git-rebase.txt:892
#, priority:100
msgid "By replacing the command \"pick\" with the command \"edit\", you can tell `git rebase` to stop after applying that commit, so that you can edit the files and/or the commit message, amend the commit, and continue rebasing."
msgstr "用 \"edit\" 命令替换 \"pick\" 命令后，你可以告诉 `git rebase` 在应用该提交后停止，这样你就可以编辑文件和/或提交信息，修改提交，然后继续重置。"

#. type: Plain text
#: en/git-rebase.txt:895
#, priority:100
msgid "To interrupt the rebase (just like an \"edit\" command would do, but without cherry-picking any commit first), use the \"break\" command."
msgstr "要中断重置（就像 \"edit\" 命令一样，但不会先选择任何提交），请使用 \"break \"命令。"

#. type: Plain text
#: en/git-rebase.txt:898
#, priority:100
msgid "If you just want to edit the commit message for a commit, replace the command \"pick\" with the command \"reword\"."
msgstr "如果只想编辑提交信息，请用 \"reword\" 命令替换 \"pick\" 命令。"

#. type: Plain text
#: en/git-rebase.txt:901
#, priority:100
msgid "To drop a commit, replace the command \"pick\" with \"drop\", or just delete the matching line."
msgstr "要放弃提交，请用 \"drop\" 替换 \"pick\" 命令，或直接删除匹配的行。"

#. type: Plain text
#: en/git-rebase.txt:916
#, priority:100
msgid "If you want to fold two or more commits into one, replace the command \"pick\" for the second and subsequent commits with \"squash\" or \"fixup\". If the commits had different authors, the folded commit will be attributed to the author of the first commit. The suggested commit message for the folded commit is the concatenation of the first commit's message with those identified by \"squash\" commands, omitting the messages of commits identified by \"fixup\" commands, unless \"fixup -c\" is used. In that case the suggested commit message is only the message of the \"fixup -c\" commit, and an editor is opened allowing you to edit the message. The contents (patch) of the \"fixup -c\" commit are still incorporated into the folded commit. If there is more than one \"fixup -c\" commit, the message from the final one is used. You can also use \"fixup -C\" to get the same behavior as \"fixup -c\" except without opening an editor."
msgstr "如果要将两个或更多提交折叠为一个提交，请用 \"squash\" 或 \"fixup\" 代替命令 \"pick\" 来处理第二个及后续提交。 如果提交的作者不同，折叠后的提交将归属于第一个提交的作者。 除非使用了 \"fixup -c\" 命令，否则折叠提交的建议提交信息是第一个提交信息与 \"squash\" 命令确定的提交信息的合并，省略了 \"fixup\" 命令确定的提交信息。 在这种情况下，建议的提交信息只是 \"fixup -c\" 提交的信息，而且会打开一个编辑器允许你编辑信息。 \"fixup -c\" 提交的内容（补丁）仍然包含在折叠提交中。如果有多个 \"fixup -c\" 提交，则使用最后一个提交的信息。 您也可以使用 \"fixup -C\" 获得与 \"fixup -c\" 相同的效果，但不需要打开编辑器。"

#. type: Plain text
#: en/git-rebase.txt:920
#, placeholders:'--continue`', priority:100
msgid "`git rebase` will stop when \"pick\" has been replaced with \"edit\" or when a command fails due to merge errors. When you are done editing and/or resolving conflicts you can continue with `git rebase --continue`."
msgstr "当 \"pick\" 命令被替换为 \"编辑\" 命令或命令因合并错误而失败时，`git rebase` 将停止。完成编辑和/或解决冲突后，可以使用 `git rebase --continue` 继续。"

#. type: Plain text
#: en/git-rebase.txt:924
#, placeholders:'HEAD':'HEAD', priority:100
msgid "For example, if you want to reorder the last 5 commits, such that what was `HEAD~4` becomes the new `HEAD`. To achieve that, you would call `git rebase` like this:"
msgstr "例如，如果您想重新排列最近 5 次提交的顺序，让原来的 `HEAD~4` 变成新的 `HEAD`。要做到这一点，可以这样调用 `git rebase`："

#. type: delimited block -
#: en/git-rebase.txt:927
#, no-wrap, placeholders:'HEAD', priority:100
msgid "$ git rebase -i HEAD~5\n"
msgstr "$ git rebase -i HEAD~5\n"

#. type: Plain text
#: en/git-rebase.txt:930
#, priority:100
msgid "And move the first patch to the end of the list."
msgstr "并将第一个补丁移到列表末尾。"

#. type: Plain text
#: en/git-rebase.txt:933
#, priority:100
msgid "You might want to recreate merge commits, e.g. if you have a history like this:"
msgstr "例如，如果您有这样的历史记录，您可能需要重新创建合并提交："

#. type: delimited block -
#: en/git-rebase.txt:940
#, no-wrap, placeholders:'---M---B':'---o---O---P---Q', priority:100
msgid ""
"           X\n"
"            \\\n"
"         A---M---B\n"
"        /\n"
"---o---O---P---Q\n"
msgstr ""
"           X\n"
"            \\\n"
"         A---M---B\n"
"        /\n"
"---o---O---P---Q\n"

#. type: Plain text
#: en/git-rebase.txt:944
#, placeholders:'HEAD', priority:100
msgid "Suppose you want to rebase the side branch starting at \"A\" to \"Q\". Make sure that the current `HEAD` is \"B\", and call"
msgstr "假设要将从 \"A\" 开始的侧分支重置为 \"Q\"。确保当前的 `HEAD` 是 \"B\"，然后调用"

#. type: delimited block -
#: en/git-rebase.txt:947
#, no-wrap, placeholders:'--onto', priority:100
msgid "$ git rebase -i -r --onto Q O\n"
msgstr "$ git rebase -i -r --onto Q O\n"

#. type: Plain text
#: en/git-rebase.txt:954
#, priority:100
msgid "Reordering and editing commits usually creates untested intermediate steps. You may want to check that your history editing did not break anything by running a test, or at least recompiling at intermediate points in history by using the \"exec\" command (shortcut \"x\"). You may do so by creating a todo list like this one:"
msgstr "重新排序和编辑提交通常会产生未经测试的中间步骤。 您可能想通过运行测试来检查您的历史编辑是否破坏了任何东西，或者至少使用 \"exec\" 命令（快捷键 \"x\"）在历史的中间点重新编译。 为此，您可以创建类似这样的待办事项列表："

#. type: delimited block -
#: en/git-rebase.txt:963
#, ignore-ellipsis, no-wrap, priority:100
msgid ""
"pick deadbee Implement feature XXX\n"
"fixup f1a5c00 Fix to feature XXX\n"
"exec make\n"
"pick c0ffeee The oneline of the next commit\n"
"edit deadbab The oneline of the commit after\n"
"exec cd subdir; make test\n"
"...\n"
msgstr ""
"选择 deadbee 执行功能 XXX\n"
"修复 f1a5c00 修复功能 XXX\n"
"执行 make\n"
"选取 c0ffeee 下一次提交的上线\n"
"编辑 deadbab 之后提交的上线\n"
"exec cd subdir; make test\n"
"...\n"

#. type: Plain text
#: en/git-rebase.txt:968
#, placeholders:'--continue`', priority:100
msgid "The interactive rebase will stop when a command fails (i.e. exits with non-0 status) to give you an opportunity to fix the problem. You can continue with `git rebase --continue`."
msgstr "当命令失败（即以非 0 状态退出）时，交互式变基操作就会停止，以便您有机会解决问题。您可以使用 `git rebase --continue` 继续。"

#. type: Plain text
#: en/git-rebase.txt:972
#, ignore-ellipsis, priority:100
msgid "The \"exec\" command launches the command in a shell (the default one, usually /bin/sh), so you can use shell features (like \"cd\", \">\", \";\" ...). The command is run from the root of the working tree."
msgstr "\"exec\" 命令在 shell（默认的 shell，通常是/bin/sh）中执行命令，因此可以使用 shell 功能（如 \"cd\"、\">\"、\";\"......）。命令从工作目录树的根目录运行。"

#. type: delimited block -
#: en/git-rebase.txt:975
#, no-wrap, placeholders:'--exec', priority:100
msgid "$ git rebase -i --exec \"make test\"\n"
msgstr "$ git rebase -i --exec \"make test\"\n"

#. type: Plain text
#: en/git-rebase.txt:979
#, priority:100
msgid "This command lets you check that intermediate commits are compilable. The todo list becomes like that:"
msgstr "该命令用于检查中间提交是否可编译。 待办事项列表就会变成这样："

#. type: delimited block -
#: en/git-rebase.txt:989
#, no-wrap, priority:100
msgid ""
"pick 5928aea one\n"
"exec make test\n"
"pick 04d0fda two\n"
"exec make test\n"
"pick ba46169 three\n"
"exec make test\n"
"pick f4593f9 four\n"
"exec make test\n"
msgstr ""
"选择 5928aea one\n"
"exec make test\n"
"选 04d0fda 二\n"
"exec make test\n"
"选择 ba46169 三\n"
"执行制作测试\n"
"选择 f4593F9 四\n"
"exec make test\n"

#. type: Title -
#: en/git-rebase.txt:992
#, no-wrap, priority:100
msgid "SPLITTING COMMITS"
msgstr "拆分提交"

#. type: Plain text
#: en/git-rebase.txt:998
#, priority:100
msgid "In interactive mode, you can mark commits with the action \"edit\". However, this does not necessarily mean that `git rebase` expects the result of this edit to be exactly one commit. Indeed, you can undo the commit, or you can add other commits. This can be used to split a commit into two:"
msgstr "在交互模式下，可以用 \"edit\"（编辑）来标记提交。 不过，这并不一定意味着 `git rebase` 希望编辑的结果是一个提交。 事实上，你可以撤销提交，也可以添加其他提交。 这可以用来将一个提交一分为二："

#. type: Plain text
#: en/git-rebase.txt:1002
#, priority:100
msgid "Start an interactive rebase with `git rebase -i <commit>^`, where `<commit>` is the commit you want to split. In fact, any commit range will do, as long as it contains that commit."
msgstr "使用 `git rebase -i <提交>^` 开始交互式变基，其中 `<提交>`是要分割的提交。 事实上，只要包含该提交，任何提交范围都可以。"

#. type: Plain text
#: en/git-rebase.txt:1004
#, priority:100
msgid "Mark the commit you want to split with the action \"edit\"."
msgstr "用 \"edit\" 操作标记要分割的提交。"

#. type: Plain text
#: en/git-rebase.txt:1008
#, placeholders:'HEAD':'HEAD', priority:100
msgid "When it comes to editing that commit, execute `git reset HEAD^`. The effect is that the `HEAD` is rewound by one, and the index follows suit. However, the working tree stays the same."
msgstr "在编辑该提交时，执行 `git reset HEAD^`。 其效果是将 `HEAD` 重绕一圈，索引也跟着重绕一圈。 但工作区保持不变。"

#. type: Plain text
#: en/git-rebase.txt:1012
#, priority:100
msgid "Now add the changes to the index that you want to have in the first commit. You can use `git add` (possibly interactively) or `git gui` (or both) to do that."
msgstr "现在，将您希望在第一次提交中的改动添加到索引中。 你可以使用 `git add` （可能是交互式的）或 `git gui` （或两者）来完成。"

#. type: Plain text
#: en/git-rebase.txt:1015
#, priority:100
msgid "Commit the now-current index with whatever commit message is appropriate now."
msgstr "以任何合适的提交信息提交当前索引。"

#. type: Plain text
#: en/git-rebase.txt:1017
#, priority:100
msgid "Repeat the last two steps until your working tree is clean."
msgstr "重复最后两个步骤，直到工作区干净为止。"

#. type: Plain text
#: en/git-rebase.txt:1019
#, placeholders:'--continue`', priority:100
msgid "Continue the rebase with `git rebase --continue`."
msgstr "使用 `git rebase --continue` 继续变基。"

#. type: Plain text
#: en/git-rebase.txt:1024
#, priority:100
msgid "If you are not absolutely sure that the intermediate revisions are consistent (they compile, pass the testsuite, etc.) you should use `git stash` to stash away the not-yet-committed changes after each commit, test, and amend the commit if fixes are necessary."
msgstr "如果不能绝对确定中间修订是一致的（编译、通过 testsuite 等），则应使用 `git stash` 在每次提交、测试之后，将尚未提交的改动保存起来，并在必要时修改提交。"

#. type: Title -
#: en/git-rebase.txt:1027
#, no-wrap, priority:100
msgid "RECOVERING FROM UPSTREAM REBASE"
msgstr "从上有仓库变基中恢复"

#. type: Plain text
#: en/git-rebase.txt:1034
#, priority:100
msgid "Rebasing (or any other form of rewriting) a branch that others have based work on is a bad idea: anyone downstream of it is forced to manually fix their history. This section explains how to do the fix from the downstream's point of view. The real fix, however, would be to avoid rebasing the upstream in the first place."
msgstr "变基（或以任何其他形式改写）他人基于其工作的分支是个坏主意：其下游的任何人都不得不手动修正自己的历史。 本节将从下游的角度解释如何进行修复。 不过，真正的修复方法是首先避免重置上游分支。"

#. type: Plain text
#: en/git-rebase.txt:1039
#, priority:100
msgid "To illustrate, suppose you are in a situation where someone develops a 'subsystem' branch, and you are working on a 'topic' that is dependent on this 'subsystem'. You might end up with a history like the following:"
msgstr "举例说明，假设有人开发了一个 ‘子系统’ 分支，而你正在开发一个依赖于该 ‘子系统’ 的 ‘主题’。 你可能会有如下的历史记录："

#. type: delimited block -
#: en/git-rebase.txt:1046
#, no-wrap, placeholders:'o---o---o---o---o---o---o---o':'o---o---o---o---o':'---':'---', priority:100
msgid ""
"    o---o---o---o---o---o---o---o  master\n"
"\t \\\n"
"\t  o---o---o---o---o  subsystem\n"
"\t\t\t   \\\n"
"\t\t\t    *---*---*  topic\n"
msgstr ""
"    o---o---o---o---o---o---o---o  master\n"
"\t \\\n"
"\t  o---o---o---o---o  subsystem\n"
"\t\t\t   \\\n"
"\t\t\t    *---*---*  topic\n"

#. type: Plain text
#: en/git-rebase.txt:1049
#, priority:100
msgid "If 'subsystem' is rebased against 'master', the following happens:"
msgstr "如果 ‘子系统’ 针对 'master' 进行重定向，会出现以下情况："

#. type: delimited block -
#: en/git-rebase.txt:1056
#, no-wrap, placeholders:'o---o---o---o---o---o---o---o':'o---o---o---o---o':'--o':'--o':'--o':'--o':'---':'---', priority:100
msgid ""
"    o---o---o---o---o---o---o---o  master\n"
"\t \\\t\t\t \\\n"
"\t  o---o---o---o---o\t  o'--o'--o'--o'--o'  subsystem\n"
"\t\t\t   \\\n"
"\t\t\t    *---*---*  topic\n"
msgstr ""
"    o---o---o---o---o---o---o---o  master\n"
"\t \\\t\t\t \\\n"
"\t  o---o---o---o---o\t  o'--o'--o'--o'--o'  subsystem\n"
"\t\t\t   \\\n"
"\t\t\t    *---*---*  topic\n"

#. type: Plain text
#: en/git-rebase.txt:1060
#, priority:100
msgid "If you now continue development as usual, and eventually merge 'topic' to 'subsystem', the commits from 'subsystem' will remain duplicated forever:"
msgstr "如果现在像往常一样继续开发，并最终将 ‘主题’ 合并到 ‘子系统’，那么 ‘子系统’ 中的提交将永远重复："

#. type: delimited block -
#: en/git-rebase.txt:1067
#, ignore-ellipsis, no-wrap, placeholders:'o---o---o---o---o---o---o---o':'o---o---o---o---o':'--o':'--o':'--o':'--o':'--M':'---':'---', priority:100
msgid ""
"    o---o---o---o---o---o---o---o  master\n"
"\t \\\t\t\t \\\n"
"\t  o---o---o---o---o\t  o'--o'--o'--o'--o'--M\t subsystem\n"
"\t\t\t   \\\t\t\t     /\n"
"\t\t\t    *---*---*-..........-*--*  topic\n"
msgstr ""
"    o---o---o---o---o---o---o---o  master\n"
"\t \\\t\t\t \\\n"
"\t  o---o---o---o---o\t  o'--o'--o'--o'--o'--M\t subsystem\n"
"\t\t\t   \\\t\t\t     /\n"
"\t\t\t    *---*---*-..........-*--*  topic\n"

#. type: Plain text
#: en/git-rebase.txt:1074
#, priority:100
msgid "Such duplicates are generally frowned upon because they clutter up history, making it harder to follow. To clean things up, you need to transplant the commits on 'topic' to the new 'subsystem' tip, i.e., rebase 'topic'. This becomes a ripple effect: anyone downstream from 'topic' is forced to rebase too, and so on!"
msgstr "这种重复通常是不受欢迎的，因为它们会使历史记录变得杂乱无章，难以跟踪。 要清理这些重复提交，就需要将 ‘主题’ 上的提交移植到新的 ‘子系统’ tip 上，即重置 ‘主题’。 这就会产生连锁反应：‘主题’ 的任何下游提交都会被迫重置，依此类推！"

#. type: Plain text
#: en/git-rebase.txt:1076
#, priority:100
msgid "There are two kinds of fixes, discussed in the following subsections:"
msgstr "有两种修复方法，将在下面的小节中讨论："

#. type: Labeled list
#: en/git-rebase.txt:1077
#, no-wrap, priority:100
msgid "Easy case: The changes are literally the same."
msgstr "简单的例子： 变化完全相同。"

#. type: Plain text
#: en/git-rebase.txt:1081
#, priority:100
msgid "This happens if the 'subsystem' rebase was a simple rebase and had no conflicts."
msgstr "如果 ‘子系统’ 变基是简单的重置，没有冲突，就会出现这种情况。"

#. type: Labeled list
#: en/git-rebase.txt:1082
#, no-wrap, priority:100
msgid "Hard case: The changes are not the same."
msgstr "较难的例子： 变化不一样。"

#. type: Plain text
#: en/git-rebase.txt:1089
#, placeholders:'`--interactive`':'--amend`':'https://github.com/newren/git-filter-repo[', priority:100
msgid "This happens if the 'subsystem' rebase had conflicts, or used `--interactive` to omit, edit, squash, or fixup commits; or if the upstream used one of `commit --amend`, `reset`, or a full history rewriting command like https://github.com/newren/git-filter-repo[`filter-repo`]."
msgstr "如果 ‘子系统’ 变基有冲突，或者使用了 `--interactive` 来省略、编辑、压制或修复提交，或者上游使用了 `commit --amend`, `reset` 或完整历史重写命令（如 https://github.com/newren/git-filter-repo[`filter-repo`]），就会发生这种情况。"

#. type: Title ~
#: en/git-rebase.txt:1092
#, no-wrap, priority:100
msgid "The easy case"
msgstr "简单案例"

#. type: Plain text
#: en/git-rebase.txt:1097
#, priority:100
msgid "Only works if the changes (patch IDs based on the diff contents) on 'subsystem' are literally the same before and after the rebase 'subsystem' did."
msgstr "只有当 ‘子系统’ 上的更改（基于差异内容的补丁 ID）在 ‘子系统’ 变基前后完全相同时才有效。"

#. type: Plain text
#: en/git-rebase.txt:1102
#, placeholders:'`--reapply-cherry-picks`', priority:100
msgid "In that case, the fix is easy because 'git rebase' knows to skip changes that are already present in the new upstream (unless `--reapply-cherry-picks` is given). So if you say (assuming you're on 'topic')"
msgstr "在这种情况下，修复就很简单了，因为 'git rebase' 知道跳过新上游中已经存在的改动（除非给出 `--reapply-cherry-picks` 选项）。所以，如果你说（假设你在 ‘主题’ 分支上）"

#. type: delimited block -
#: en/git-rebase.txt:1104
#, no-wrap, priority:100
msgid "    $ git rebase subsystem\n"
msgstr "    $ git rebase subsystem\n"

#. type: Plain text
#: en/git-rebase.txt:1106
#, priority:100
msgid "you will end up with the fixed history"
msgstr "您将获得固定的历史记录"

#. type: delimited block -
#: en/git-rebase.txt:1112
#, no-wrap, placeholders:'o---o---o---o---o---o---o---o':'--o':'--o':'--o':'--o':'---':'---', priority:100
msgid ""
"    o---o---o---o---o---o---o---o  master\n"
"\t\t\t\t \\\n"
"\t\t\t\t  o'--o'--o'--o'--o'  subsystem\n"
"\t\t\t\t\t\t   \\\n"
"\t\t\t\t\t\t    *---*---*  topic\n"
msgstr ""
"    o---o---o---o---o---o---o---o  master\n"
"\t\t\t\t \\\n"
"\t\t\t\t  o'--o'--o'--o'--o'  subsystem\n"
"\t\t\t\t\t\t   \\\n"
"\t\t\t\t\t\t    *---*---*  topic\n"

#. type: Title ~
#: en/git-rebase.txt:1116
#, no-wrap, priority:100
msgid "The hard case"
msgstr "困难的例子"

#. type: Plain text
#: en/git-rebase.txt:1120
#, priority:100
msgid "Things get more complicated if the 'subsystem' changes do not exactly correspond to the ones before the rebase."
msgstr "如果 ‘子系统’ 的变化与重置前的变化不完全一致，情况就会变得更加复杂。"

#. type: Plain text
#: en/git-rebase.txt:1125
#, no-wrap, placeholders:'--interactive`', priority:100
msgid ""
"While an \"easy case recovery\" sometimes appears to be successful\n"
"      even in the hard case, it may have unintended consequences.  For\n"
"      example, a commit that was removed via `git rebase\n"
"      --interactive` will be **resurrected**!\n"
msgstr ""
"虽然 ‘简单恢复案例’ 有时看似成功\n"
"      即使在疑难案件中，也可能产生意想不到的后果。 \n"
"      例如，通过 `git rebase\n"
"      --interactive` 删除的提交将被**恢复**！\n"

#. type: Plain text
#: en/git-rebase.txt:1130
#, priority:100
msgid "The idea is to manually tell `git rebase` \"where the old 'subsystem' ended and your 'topic' began\", that is, what the old merge base between them was. You will have to find a way to name the last commit of the old 'subsystem', for example:"
msgstr "我们的想法是手动告诉 `git rebase` “旧的 ‘子系统’ 分支在哪里结束，而您的 ‘主题’ 分支在哪里开始”，也就是说，它们之间的旧合并基础是什么。 例如，你必须找到一种方法来命名旧 ‘子系统’ 分支的最后一次提交："

#. type: Plain text
#: en/git-rebase.txt:1134
#, placeholders:'{1}':'linkgit:git-reflog[1]', priority:100
msgid "With the 'subsystem' reflog: after `git fetch`, the old tip of 'subsystem' is at `subsystem@{1}`. Subsequent fetches will increase the number. (See linkgit:git-reflog[1].)"
msgstr "使用 ‘子系统’ 引用日志：在 `git fetch` 之后，‘子系统’ 的旧 tip 位于 `subsystem@{1}`。 随后的获取将增加这个数字。 (参见 linkgit:git-reflog[1]）"

#. type: Plain text
#: en/git-rebase.txt:1137
#, priority:100
msgid "Relative to the tip of 'topic': knowing that your 'topic' has three commits, the old tip of 'subsystem' must be `topic~3`."
msgstr "与 ‘主题’ 分支的 tip 有关：由于 ‘topic’ 分支有三次提交，所以 ‘子系统’ 分支的旧提示必须是 `topic~3`。"

#. type: Plain text
#: en/git-rebase.txt:1140
#, priority:100
msgid "You can then transplant the old `subsystem..topic` to the new tip by saying (for the reflog case, and assuming you are on 'topic' already):"
msgstr "然后，您可以将旧的 `subsystem..topic`（子系统..主题）移植到新的提示中，方法是（对于引用日志的情况，假设您已经在 ‘主题’ 分支中）："

#. type: delimited block -
#: en/git-rebase.txt:1142
#, no-wrap, placeholders:'--onto':'{1}', priority:100
msgid "    $ git rebase --onto subsystem subsystem@{1}\n"
msgstr "    $ git rebase --onto subsystem subsystem@{1}\n"

#. type: Plain text
#: en/git-rebase.txt:1147
#, priority:100
msgid "The ripple effect of a \"hard case\" recovery is especially bad: 'everyone' downstream from 'topic' will now have to perform a \"hard case\" recovery too!"
msgstr "“困难例子” 恢复的连锁反应尤其糟糕：‘主题’ 下游的 ‘每个人’ 现在也必须执行 “困难例子” 恢复！"

#. type: Title -
#: en/git-rebase.txt:1149
#, no-wrap, priority:100
msgid "REBASING MERGES"
msgstr "变基合并"

#. type: Plain text
#: en/git-rebase.txt:1157
#, priority:100
msgid "The interactive rebase command was originally designed to handle individual patch series. As such, it makes sense to exclude merge commits from the todo list, as the developer may have merged the then-current `master` while working on the branch, only to rebase all the commits onto `master` eventually (skipping the merge commits)."
msgstr "交互式变基命令最初是为处理单个补丁系列而设计的。因此，将合并提交排除在待办事项列表之外是有道理的，因为开发人员在分支上工作时，可能已经合并了当时的 `master`，只是最终将所有提交重置到了 `master`上（跳过了合并提交）。"

#. type: Plain text
#: en/git-rebase.txt:1161
#, priority:100
msgid "However, there are legitimate reasons why a developer may want to recreate merge commits: to keep the branch structure (or \"commit topology\") when working on multiple, inter-related branches."
msgstr "不过，开发人员想要重新创建合并提交也有合理的原因：在多个相互关联的分支上工作时，为了保持分支结构（或 “提交拓扑”）。"

#. type: Plain text
#: en/git-rebase.txt:1166
#, placeholders:'--graph':'--format=', priority:100
msgid "In the following example, the developer works on a topic branch that refactors the way buttons are defined, and on another topic branch that uses that refactoring to implement a \"Report a bug\" button. The output of `git log --graph --format=%s -5` may look like this:"
msgstr "在下面的示例中，开发人员在一个重构了按钮定义方式的特性分支上工作，并在另一个特性分支上使用重构实现了 “报告错误” 按钮。`git log --graph --format=%s -5` 的输出可能是这样的："

#. type: delimited block -
#: en/git-rebase.txt:1176
#, no-wrap, priority:100
msgid ""
"*   Merge branch 'report-a-bug'\n"
"|\\\n"
"| * Add the feedback button\n"
"* | Merge branch 'refactor-button'\n"
"|\\ \\\n"
"| |/\n"
"| * Use the Button class for all buttons\n"
"| * Extract a generic Button class from the DownloadButton one\n"
msgstr ""
"*   合并分支 'report-a-bug'\n"
"|\\\n"
"| * 添加反馈按钮\n"
"* | 合并分支 'refactor-button'\n"
"|\\ \\\n"
"| |/\n"
"| * 为所有的按钮使用 Button 类\n"
"| * 从 DownloadButton 类中提取一个通用 Button 类\n"

#. type: Plain text
#: en/git-rebase.txt:1183
#, priority:100
msgid "The developer might want to rebase those commits to a newer `master` while keeping the branch topology, for example when the first topic branch is expected to be integrated into `master` much earlier than the second one, say, to resolve merge conflicts with changes to the DownloadButton class that made it into `master`."
msgstr "开发人员可能希望在保留分支拓扑的同时，将这些提交重定向到更新的 `master` 分支，例如，当第一个特性分支比第二个分支更早集成到 `master` 分支时，开发人员可能希望解决与 “下载按钮” 类的合并冲突，因为 “下载按钮” 类已经集成到了 `master` 分支。"

#. type: Plain text
#: en/git-rebase.txt:1186
#, placeholders:'`--rebase-merges`', priority:100
msgid "This rebase can be performed using the `--rebase-merges` option. It will generate a todo list looking like this:"
msgstr "可以使用 `--rebase-merges` 选项进行重置。 它将生成如下的待办事项列表："

#. type: delimited block -
#: en/git-rebase.txt:1189 en/git-rebase.txt:1270
#, no-wrap, priority:100
msgid "label onto\n"
msgstr "标签上的\n"

#. type: delimited block -
#: en/git-rebase.txt:1195
#, no-wrap, priority:100
msgid ""
"# Branch: refactor-button\n"
"reset onto\n"
"pick 123456 Extract a generic Button class from the DownloadButton one\n"
"pick 654321 Use the Button class for all buttons\n"
"label refactor-button\n"
msgstr ""
"# 分支：重构按钮\n"
"重置到\n"
"选 123456 从下载按钮类中提取一个通用按钮类\n"
"选取 654321 对所有按钮使用按钮类\n"
"label refactor-button（重构按钮）\n"

#. type: delimited block -
#: en/git-rebase.txt:1200
#, no-wrap, priority:100
msgid ""
"# Branch: report-a-bug\n"
"reset refactor-button # Use the Button class for all buttons\n"
"pick abcdef Add the feedback button\n"
"label report-a-bug\n"
msgstr ""
"# 分支：报告一个错误\n"
"reset refactor-button （重构按钮）# 所有按钮都使用按钮类\n"
"pick abcdef 添加反馈按钮\n"
"label report-a-bug（报告一个错误）\n"

#. type: delimited block -
#: en/git-rebase.txt:1204
#, no-wrap, priority:100
msgid ""
"reset onto\n"
"merge -C a1b2c3 refactor-button # Merge 'refactor-button'\n"
"merge -C 6f5e4d report-a-bug # Merge 'report-a-bug'\n"
msgstr ""
"重置到\n"
"merge -C a1b2c3 refactor-button # 合并 “重构按钮”\n"
"merge -C 6f5e4d report-a-bug # 合并 “报告一个错误”\n"

#. type: Plain text
#: en/git-rebase.txt:1208
#, priority:100
msgid "In contrast to a regular interactive rebase, there are `label`, `reset` and `merge` commands in addition to `pick` ones."
msgstr "与常规的交互式变基不同，除了 `pick`（选取）命令外，还有 `label`（标签）、`reset`（重置） 和 `merge`（合并） 命令。"

#. type: Plain text
#: en/git-rebase.txt:1216
#, placeholders:'HEAD', priority:100
msgid "The `label` command associates a label with the current HEAD when that command is executed. These labels are created as worktree-local refs (`refs/rewritten/<label>`) that will be deleted when the rebase finishes. That way, rebase operations in multiple worktrees linked to the same repository do not interfere with one another. If the `label` command fails, it is rescheduled immediately, with a helpful message how to proceed."
msgstr "`label` 命令会在执行该命令时将一个标签与当前 HEAD 关联。这些标签被创建为工作树本地引用（`refs/rewritten/<label>`），并将在重置完成后被删除。这样，链接到同一仓库的多个工作树中的重置操作就不会相互干扰。如果 `label` 命令失败，会立即重新安排，并给出如何继续的提示信息。"

#. type: Plain text
#: en/git-rebase.txt:1223
#, placeholders:'HEAD':'--hard', priority:100
msgid "The `reset` command resets the HEAD, index and worktree to the specified revision. It is similar to an `exec git reset --hard <label>`, but refuses to overwrite untracked files. If the `reset` command fails, it is rescheduled immediately, with a helpful message how to edit the todo list (this typically happens when a `reset` command was inserted into the todo list manually and contains a typo)."
msgstr "`reset` 命令会将 HEAD、索引和工作树重置为指定的版本。它类似于 `exec git reset --hard <label>`，但拒绝覆盖未跟踪的文件。如果 `reset` 命令失败，会立即重新安排，并附带如何编辑待办事项列表的提示信息（这种情况通常发生在 `reset` 命令被手动插入待办事项列表且包含错字的情况下）。"

#. type: Plain text
#: en/git-rebase.txt:1229
#, placeholders:'HEAD':'`-C`':'`-c`', priority:100
msgid "The `merge` command will merge the specified revision(s) into whatever is HEAD at that time. With `-C <original-commit>`, the commit message of the specified merge commit will be used. When the `-C` is changed to a lower-case `-c`, the message will be opened in an editor after a successful merge so that the user can edit the message."
msgstr "`merge`（合并）命令会将指定的版本合并到当时的 HEAD 中。使用 `-C <源提交>` 时，将使用指定合并提交的提交信息。如果将 `-C` 改为小写的 `-c`，合并成功后，提交信息将在编辑器中打开，以便用户编辑信息。"

#. type: Plain text
#: en/git-rebase.txt:1232
#, priority:100
msgid "If a `merge` command fails for any reason other than merge conflicts (i.e. when the merge operation did not even start), it is rescheduled immediately."
msgstr "如果 `merge`（合并）命令因合并冲突以外的任何原因失败（即合并操作甚至没有开始），则会立即重新安排。"

#. type: Plain text
#: en/git-rebase.txt:1243
#, placeholders:'`--strategy`':'`--strategy`', priority:100
msgid "By default, the `merge` command will use the `ort` merge strategy for regular merges, and `octopus` for octopus merges. One can specify a default strategy for all merges using the `--strategy` argument when invoking rebase, or can override specific merges in the interactive list of commands by using an `exec` command to call `git merge` explicitly with a `--strategy` argument. Note that when calling `git merge` explicitly like this, you can make use of the fact that the labels are worktree-local refs (the ref `refs/rewritten/onto` would correspond to the label `onto`, for example) in order to refer to the branches you want to merge."
msgstr "默认情况下，`merge`（合并）命令将对常规合并使用 `ort ` 合并策略，对多路合并使用 `octopus` 合并策略。 我们可以在调用变基命令时使用 `--strategy` 参数为所有合并指定一个默认策略，也可以在交互式命令列表中使用 `exec` 命令显式地调用 `git merge` 并加上 `--strategy` 参数来覆盖特定的合并策略。 需要注意的是，像这样显式调用 `git merge` 时，可以利用标签是工作区本地引用（例如，引用 `refs/rewritten/onto` 将对应标签 `onto`）这一事实来引用要合并的分支。"

#. type: Plain text
#: en/git-rebase.txt:1247
#, placeholders:'`--onto`', priority:100
msgid "Note: the first command (`label onto`) labels the revision onto which the commits are rebased; The name `onto` is just a convention, as a nod to the `--onto` option."
msgstr "注意：第一条命令（`label onto`）会标注提交所基于的修订版本；`onto ` 只是一个约定俗成的名称，是对 `--onto` 选项的一种提示。"

#. type: Plain text
#: en/git-rebase.txt:1254
#, priority:100
msgid "It is also possible to introduce completely new merge commits from scratch by adding a command of the form `merge <merge-head>`. This form will generate a tentative commit message and always open an editor to let the user edit it. This can be useful e.g. when a topic branch turns out to address more than a single concern and wants to be split into two or even more topic branches. Consider this todo list:"
msgstr "也可以通过添加 `merge <合并起点>` 命令，从头开始引入全新的合并提交。这种形式会生成暂定提交信息，并始终打开编辑器让用户编辑。例如，当一个特性分支要解决的问题不止一个，需要拆分成两个甚至更多特性分支时，这个命令就很有用。请看这个待办事项列表："

#. type: delimited block -
#: en/git-rebase.txt:1261
#, no-wrap, priority:100
msgid ""
"pick 192837 Switch from GNU Makefiles to CMake\n"
"pick 5a6c7e Document the switch to CMake\n"
"pick 918273 Fix detection of OpenSSL in CMake\n"
"pick afbecd http: add support for TLS v1.3\n"
"pick fdbaec Fix detection of cURL in CMake on Windows\n"
msgstr ""
"pick 192837 从 GNU Makefiles 切换到 CMake\n"
"pick 5a6c7e 记录切换到 CMake 的过程\n"
"pick 918273 修复 CMake 中的 OpenSSL 检测问题\n"
"pick afbecd http：添加对 TLS v1.3 的支持\n"
"pick fdbaec 在 Windows 上修复 CMake 对 cURL 的检测\n"

#. type: Plain text
#: en/git-rebase.txt:1267
#, priority:100
msgid "The one commit in this list that is not related to CMake may very well have been motivated by working on fixing all those bugs introduced by switching to CMake, but it addresses a different concern. To split this branch into two topic branches, the todo list could be edited like this:"
msgstr "该列表中与 CMake 无关的一个提交很可能是为了修复所有因改用 CMake 而引入的错误，但它解决的是另一个问题。要把这个分支分成两个主题分支，可以这样编辑待办事项列表："

#. type: delimited block -
#: en/git-rebase.txt:1273
#, no-wrap, priority:100
msgid ""
"pick afbecd http: add support for TLS v1.3\n"
"label tlsv1.3\n"
msgstr ""
"选择 afbecd http：添加对 TLS v1.3 的支持\n"
"label tlsv1.3\n"

#. type: delimited block -
#: en/git-rebase.txt:1280
#, no-wrap, priority:100
msgid ""
"reset onto\n"
"pick 192837 Switch from GNU Makefiles to CMake\n"
"pick 918273 Fix detection of OpenSSL in CMake\n"
"pick fdbaec Fix detection of cURL in CMake on Windows\n"
"pick 5a6c7e Document the switch to CMake\n"
"label cmake\n"
msgstr ""
"reset onto\n"
"pick 192837 从 GNU Makefiles 切换到 CMake\n"
"pick 918273 修复 CMake 中的 OpenSSL 检测问题\n"
"pick fdbaec 在 Windows 上修复 CMake 对 cURL 的检测\n"
"pick 5a6c7e 记录切换到 CMake 的过程\n"
"label cmake\n"

#. type: delimited block -
#: en/git-rebase.txt:1284
#, no-wrap, priority:100
msgid ""
"reset onto\n"
"merge tlsv1.3\n"
"merge cmake\n"
msgstr ""
"reset onto\n"
"merge tlsv1.3\n"
"merge cmake\n"

#. type: Title =
#: en/git-receive-pack.txt:2
#, ignore-same, no-wrap, priority:90
msgid "git-receive-pack(1)"
msgstr "git-receive-pack(1)"

#. type: Plain text
#: en/git-receive-pack.txt:7
#, placeholders:'git-receive-pack', priority:90
msgid "git-receive-pack - Receive what is pushed into the repository"
msgstr "git-receive-pack - 接收推送到仓库的内容"

#. type: Plain text
#: en/git-receive-pack.txt:13
#, no-wrap, placeholders:'git receive-pack', priority:90
msgid "'git receive-pack' <git-dir>\n"
msgstr "'git receive-pack' <Git 目录>\n"

#. type: Plain text
#: en/git-receive-pack.txt:18
#, placeholders:'git send-pack', priority:90
msgid "Invoked by 'git send-pack' and updates the repository with the information fed from the remote end."
msgstr "由 'git send-pack' 调用，并根据远程仓库提供的信息更新仓库。"

#. type: Plain text
#: en/git-receive-pack.txt:23
#, placeholders:'git send-pack':'linkgit:git-fetch-pack[1]', priority:90
msgid "This command is usually not invoked directly by the end user. The UI for the protocol is on the 'git send-pack' side, and the program pair is meant to be used to push updates to a remote repository. For pull operations, see linkgit:git-fetch-pack[1]."
msgstr "终端用户通常不会直接调用该命令。 该协议的用户界面在 'git send-pack' 端，程序对用于向远程仓库推送更新。 关于拉取操作，请参阅 linkgit:git-fetch-pack[1]。"

#. type: Plain text
#: en/git-receive-pack.txt:28
#, placeholders:'git-receive-pack', priority:90
msgid "The command allows for the creation and fast-forwarding of sha1 refs (heads/tags) on the remote end (strictly speaking, it is the local end 'git-receive-pack' runs, but to the user who is sitting at the send-pack end, it is updating the remote. Confused?)"
msgstr "该命令允许在远程端创建并快速转发 sha1 refs（头/标签）（严格来说，运行 'git-receive-pack' 的是本地端，但对于坐在 send-pack 端的用户来说，它是在更新远程端）。 不明白吗？）"

#. type: Plain text
#: en/git-receive-pack.txt:31
#, priority:90
msgid "There are other real-world examples of using update and post-update hooks found in the Documentation/howto directory."
msgstr "文档 /howto 目录中还有其他使用更新和更新后钩子的实际例子。"

#. type: Plain text
#: en/git-receive-pack.txt:35
#, placeholders:'git-receive-pack':'receive.denyNonFastForwards', priority:90
msgid "'git-receive-pack' honours the receive.denyNonFastForwards config option, which tells it if updates to a ref should be denied if they are not fast-forwards."
msgstr "'git-receive-pack' 遵循 receive.denyNonFastForwards 配置选项，该选项会告诉它，如果引用的更新不是快速转发的，是否应拒绝更新。"

#. type: Plain text
#: en/git-receive-pack.txt:38
#, placeholders:'linkgit:git-config[1]', priority:90
msgid "A number of other receive.* config options are available to tweak its behavior, see linkgit:git-config[1]."
msgstr "还有许多其他 receive.* 配置选项可用于调整其行为，参见 linkgit:git-config[1]。"

#. type: Labeled list
#: en/git-receive-pack.txt:41
#, no-wrap, priority:90
msgid "<git-dir>"
msgstr "<Git 目录>"

#. type: Plain text
#: en/git-receive-pack.txt:43
#, priority:90
msgid "The repository to sync into."
msgstr "要同步到的仓库。"

#. type: Labeled list
#: en/git-receive-pack.txt:44 en/git-upload-pack.txt:39
#, ignore-same, no-wrap, priority:100
msgid "--http-backend-info-refs"
msgstr "--http-backend-info-refs"

#. type: Plain text
#: en/git-receive-pack.txt:48
#, placeholders:'linkgit:git-http-backend[1]':'$GIT_URL':'git-receive-pack':'`--http-backend-info-refs`':'linkgit:git-upload-pack[1]', priority:90
msgid "Used by linkgit:git-http-backend[1] to serve up `$GIT_URL/info/refs?service=git-receive-pack` requests. See `--http-backend-info-refs` in linkgit:git-upload-pack[1]."
msgstr "由 linkgit:git-http-backend[1] 使用，用于提供`$GIT_URL/info/refs?service=git-receive-pack`请求。参见 linkgit:git-upload-pack[1] 中的 `--http-backend-info-refs`。"

#. type: Title -
#: en/git-receive-pack.txt:50
#, no-wrap, priority:90
msgid "PRE-RECEIVE HOOK"
msgstr "接收前钩子"

#. type: Plain text
#: en/git-receive-pack.txt:54
#, placeholders:'$GIT_DIR', priority:90
msgid "Before any ref is updated, if $GIT_DIR/hooks/pre-receive file exists and is executable, it will be invoked once with no parameters. The standard input of the hook will be one line per ref to be updated:"
msgstr "在更新任何引用之前，如果 $GIT_DIR/hooks/pre-receive 文件存在且可执行，则会无参数调用一次。 钩子的标准输入将为每个要更新的引用一行："

#. type: Plain text
#: en/git-receive-pack.txt:56 en/git-receive-pack.txt:155
#, no-wrap, priority:90
msgid "       sha1-old SP sha1-new SP refname LF\n"
msgstr "       旧 sha1SP 新 sha1 SP 引用名称 LF\n"

#. type: Plain text
#: en/git-receive-pack.txt:63
#, placeholders:'$GIT_DIR':'{40}':'{40}', priority:90
msgid "The refname value is relative to $GIT_DIR; e.g. for the master head this is \"refs/heads/master\". The two sha1 values before each refname are the object names for the refname before and after the update. Refs to be created will have sha1-old equal to 0\\{40}, while refs to be deleted will have sha1-new equal to 0\\{40}, otherwise sha1-old and sha1-new should be valid objects in the repository."
msgstr "引用名值是相对于 $GIT_DIR 的；例如，主磁头的引用名值是 \"refs/heads/master\"。 每个引用名前面的两个 sha1 值是更新前后引用名的对象名称。 要创建的引用的 sha1-old 值应等于 0\\{40}，而要删除的引用的 sha1-new 值应等于 0\\{40}，否则 sha1-old 和 sha1-new 应是仓库中的有效对象。"

#. type: Plain text
#: en/git-receive-pack.txt:70
#, placeholders:'linkgit:git-push[1]':'GIT_PUSH_CERT', priority:90
msgid "When accepting a signed push (see linkgit:git-push[1]), the signed push certificate is stored in a blob and an environment variable `GIT_PUSH_CERT` can be consulted for its object name. See the description of `post-receive` hook for an example. In addition, the certificate is verified using GPG and the result is exported with the following environment variables:"
msgstr "接受已签名的推送（参见 linkgit:git-push[1]）时，已签名的推送证书会保存在 blob 中，环境变量 `GIT_PUSH_CERT` 可以查看其对象名称。 示例参见 `post-receive` 钩子的描述。 此外，证书将使用 GPG 验证，验证结果将通过以下环境变量导出："

#. type: Labeled list
#: en/git-receive-pack.txt:71
#, ignore-same, no-wrap, priority:90
msgid "`GIT_PUSH_CERT_SIGNER`"
msgstr "`GIT_PUSH_CERT_SIGNER`"

#. type: Plain text
#: en/git-receive-pack.txt:74
#, priority:90
msgid "The name and the e-mail address of the owner of the key that signed the push certificate."
msgstr "签署推送证书的密钥所有者的姓名和电子邮件地址。"

#. type: Labeled list
#: en/git-receive-pack.txt:75
#, ignore-same, no-wrap, priority:90
msgid "`GIT_PUSH_CERT_KEY`"
msgstr "`GIT_PUSH_CERT_KEY`"

#. type: Plain text
#: en/git-receive-pack.txt:77
#, priority:90
msgid "The GPG key ID of the key that signed the push certificate."
msgstr "签署推送证书的 GPG 密钥 ID。"

#. type: Labeled list
#: en/git-receive-pack.txt:78
#, ignore-same, no-wrap, priority:90
msgid "`GIT_PUSH_CERT_STATUS`"
msgstr "`GIT_PUSH_CERT_STATUS`"

#. type: Plain text
#: en/git-receive-pack.txt:82
#, placeholders:'linkgit:git-log[1]', priority:90
msgid "The status of GPG verification of the push certificate, using the same mnemonic as used in `%G?` format of `git log` family of commands (see linkgit:git-log[1])."
msgstr "推送证书的 GPG 验证状态，使用与 `git log` 系列命令（参见 linkgit:git-log[1]）的 `%G?` 格式相同的助记符。"

#. type: Labeled list
#: en/git-receive-pack.txt:83
#, ignore-same, no-wrap, priority:90
msgid "`GIT_PUSH_CERT_NONCE`"
msgstr "`GIT_PUSH_CERT_NONCE`"

#. type: Plain text
#: en/git-receive-pack.txt:89
#, priority:90
msgid "The nonce string the process asked the signer to include in the push certificate. If this does not match the value recorded on the \"nonce\" header in the push certificate, it may indicate that the certificate is a valid one that is being replayed from a separate \"git push\" session."
msgstr "进程要求签名者在推送证书中包含的 nonce 字符串。 如果该字符串与推送证书中 \"nonce\" 标头记录的值不一致，则可能表明该证书是有效的，但是从另一个 \"git push\" 会话中重放的。"

#. type: Labeled list
#: en/git-receive-pack.txt:90
#, ignore-same, no-wrap, priority:90
msgid "`GIT_PUSH_CERT_NONCE_STATUS`"
msgstr "`GIT_PUSH_CERT_NONCE_STATUS`"

#. type: Labeled list
#: en/git-receive-pack.txt:91
#, ignore-same, no-wrap, priority:90
msgid "`UNSOLICITED`"
msgstr "`UNSOLICITED`"

#. type: Plain text
#: en/git-receive-pack.txt:94
#, placeholders:'--signed', priority:90
msgid "\"git push --signed\" sent a nonce when we did not ask it to send one."
msgstr "\"git push --signed\" 发送了一个 nonce，而我们并没有要求它发送。"

#. type: Labeled list
#: en/git-receive-pack.txt:94
#, ignore-same, no-wrap, priority:90
msgid "`MISSING`"
msgstr "`MISSING`"

#. type: Plain text
#: en/git-receive-pack.txt:96
#, placeholders:'--signed', priority:90
msgid "\"git push --signed\" did not send any nonce header."
msgstr "\"git push --signed\" 不发送任何 nonce 头信息。"

#. type: Labeled list
#: en/git-receive-pack.txt:96
#, ignore-same, no-wrap, priority:90
msgid "`BAD`"
msgstr "`BAD`"

#. type: Plain text
#: en/git-receive-pack.txt:98
#, placeholders:'--signed', priority:90
msgid "\"git push --signed\" sent a bogus nonce."
msgstr "\"git push --signed\"发送了一个假的 nonce。"

#. type: Labeled list
#: en/git-receive-pack.txt:98
#, ignore-same, no-wrap, priority:90
msgid "`OK`"
msgstr "`OK`"

#. type: Plain text
#: en/git-receive-pack.txt:100
#, placeholders:'--signed', priority:90
msgid "\"git push --signed\" sent the nonce we asked it to send."
msgstr "\"git push --signed\" 没有发送任何 nonce 头信息。"

#. type: Labeled list
#: en/git-receive-pack.txt:100
#, ignore-same, no-wrap, priority:90
msgid "`SLOP`"
msgstr "`SLOP`"

#. type: Plain text
#: en/git-receive-pack.txt:104
#, placeholders:'--signed':'GIT_PUSH_CERT_NONCE_SLOP', priority:90
msgid "\"git push --signed\" sent a nonce different from what we asked it to send now, but in a previous session. See `GIT_PUSH_CERT_NONCE_SLOP` environment variable."
msgstr "\"git push --signed\" 发送的 nonce 与我们现在要求它发送的不同，但在之前的会话中。 参见 `GIT_PUSH_CERT_NONCE_SLOP` 环境变量。"

#. type: Labeled list
#: en/git-receive-pack.txt:105
#, ignore-same, no-wrap, priority:90
msgid "`GIT_PUSH_CERT_NONCE_SLOP`"
msgstr "`GIT_PUSH_CERT_NONCE_SLOP`"

#. type: Plain text
#: en/git-receive-pack.txt:113
#, placeholders:'--signed':'GIT_PUSH_CERT_NONCE_STATUS':'receive.certNonceSlop':'linkgit:git-config[1]', priority:90
msgid "\"git push --signed\" sent a nonce different from what we asked it to send now, but in a different session whose starting time is different by this many seconds from the current session. Only meaningful when `GIT_PUSH_CERT_NONCE_STATUS` says `SLOP`. Also read about `receive.certNonceSlop` variable in linkgit:git-config[1]."
msgstr "\"git push --signed\" 发送了一个与我们现在要求它发送的不同的 nonce，但它是在一个不同的会话中发送的，该会话的起始时间与当前会话的起始时间相差这么多秒。 只有当 `GIT_PUSH_CERT_NONCE_STATUS` 显示`SLOP` 时才有意义。 另请参阅 linkgit:git-config[1] 中的 `receive.certNonceSlop` 变量。"

#. type: Plain text
#: en/git-receive-pack.txt:116
#, priority:90
msgid "This hook is called before any refname is updated and before any fast-forward checks are performed."
msgstr "在更新任何引用名和执行任何快进检查之前，都会调用此钩子。"

#. type: Plain text
#: en/git-receive-pack.txt:121
#, priority:90
msgid "If the pre-receive hook exits with a non-zero exit status no updates will be performed, and the update, post-receive and post-update hooks will not be invoked either. This can be useful to quickly bail out if the update is not to be supported."
msgstr "如果预接收钩子以非零的退出状态退出，则不会执行更新，也不会调用更新、后接收和后更新钩子。 如果不支持更新，这将有助于快速退出。"

#. type: Plain text
#: en/git-receive-pack.txt:123
#, priority:90
msgid "See the notes on the quarantine environment below."
msgstr "请参阅下文有关隔离环境的说明。"

#. type: Title -
#: en/git-receive-pack.txt:125
#, no-wrap, priority:90
msgid "UPDATE HOOK"
msgstr "更新钩子"

#. type: Plain text
#: en/git-receive-pack.txt:128
#, placeholders:'$GIT_DIR', priority:90
msgid "Before each ref is updated, if $GIT_DIR/hooks/update file exists and is executable, it is invoked once per ref, with three parameters:"
msgstr "在更新每个引用之前，如果 $GIT_DIR/hooks/update 文件存在且可执行，则每个引用都会调用一次该文件，其中包含三个参数："

#. type: Plain text
#: en/git-receive-pack.txt:130
#, no-wrap, placeholders:'$GIT_DIR', priority:90
msgid "       $GIT_DIR/hooks/update refname sha1-old sha1-new\n"
msgstr "       $GIT_DIR/hooks/update refname sha1-old sha1-new\n"

#. type: Plain text
#: en/git-receive-pack.txt:137
#, placeholders:'$GIT_DIR':'{40}', priority:90
msgid "The refname parameter is relative to $GIT_DIR; e.g. for the master head this is \"refs/heads/master\". The two sha1 arguments are the object names for the refname before and after the update. Note that the hook is called before the refname is updated, so either sha1-old is 0\\{40} (meaning there is no such ref yet), or it should match what is recorded in refname."
msgstr "引用名参数是相对于 $GIT_DIR 的；例如，主文件头的引用名是 \"refs/heads/master\"。 两个 sha1 参数分别是更新前后引用名的对象名称。 请注意，钩子是在引用名更新之前调用的，因此要么 sha1-old 是 0\\{40}（意思是还没有这样的 ref），要么它应该与引用名中记录的一致。"

#. type: Plain text
#: en/git-receive-pack.txt:140
#, priority:90
msgid "The hook should exit with non-zero status if it wants to disallow updating the named ref. Otherwise it should exit with zero."
msgstr "如果钩子不允许更新指定的引用，则应以非零状态退出。 否则，钩子将以 0 状态退出。"

#. type: Plain text
#: en/git-receive-pack.txt:145
#, priority:90
msgid "Successful execution (a zero exit status) of this hook does not ensure the ref will actually be updated, it is only a prerequisite. As such it is not a good idea to send notices (e.g. email) from this hook. Consider using the post-receive hook instead."
msgstr "成功执行此钩子（退出状态为零）并不能确保 ref 会被更新，这只是一个前提条件。 因此，使用此钩子发送通知（如电子邮件）不是一个好主意。 请考虑使用 post-receive 钩子。"

#. type: Title -
#: en/git-receive-pack.txt:147
#, no-wrap, priority:90
msgid "POST-RECEIVE HOOK"
msgstr "接收后钩子"

#. type: Plain text
#: en/git-receive-pack.txt:153
#, placeholders:'$GIT_DIR', priority:90
msgid "After all refs were updated (or attempted to be updated), if any ref update was successful, and if $GIT_DIR/hooks/post-receive file exists and is executable, it will be invoked once with no parameters. The standard input of the hook will be one line for each successfully updated ref:"
msgstr "在所有引用被更新（或试图更新）后，如果有任何 引用更新成功，并且 $GIT_DIR/hooks/post-receive 文件存在且可执行，则将无参数调用一次。 钩子的标准输入将为每个成功更新的引用写一行："

#. type: Plain text
#: en/git-receive-pack.txt:163
#, placeholders:'$GIT_DIR':'{40}':'{40}', priority:90
msgid "The refname value is relative to $GIT_DIR; e.g. for the master head this is \"refs/heads/master\". The two sha1 values before each refname are the object names for the refname before and after the update. Refs that were created will have sha1-old equal to 0\\{40}, while refs that were deleted will have sha1-new equal to 0\\{40}, otherwise sha1-old and sha1-new should be valid objects in the repository."
msgstr "引用名的值是相对于 $GIT_DIR 的；例如，主磁头的 refname 值是 \"refs/heads/master\"。 每个引用名前的两个 sha1 值是更新前后引用名的对象名称。 创建的引用的 sha1-old 值将等于 0\\{40}，而删除的引用的 sha1-new 值将等于 0\\{40}，否则 sha1-old 和 sha1-new 应该是仓库中的有效对象。"

#. type: Plain text
#: en/git-receive-pack.txt:166
#, placeholders:'GIT_PUSH_CERT', priority:90
msgid "The `GIT_PUSH_CERT*` environment variables can be inspected, just as in `pre-receive` hook, after accepting a signed push."
msgstr "在接受签名推送后，可以检查 `GIT_PUSH_CERT*` 环境变量，就像在 `pre-receive` 钩子中一样。"

#. type: Plain text
#: en/git-receive-pack.txt:172
#, priority:90
msgid "Using this hook, it is easy to generate mails describing the updates to the repository. This example script sends one mail message per ref listing the commits pushed to the repository, and logs the push certificates of signed pushes with good signatures to a logger service:"
msgstr "使用这个钩子，就能轻松生成描述版本库更新的邮件。 本示例脚本会为每个引用发送一封邮件，列出推送到仓库的提交，并将签名良好的推送证书记录到日志服务中："

#. type: delimited block -
#: en/git-receive-pack.txt:197
#, no-wrap, placeholders:'$oval':'git rev-list':'--pretty':'$nval':'git rev-list':'--pretty':'$nval':'$oval':'$ref':'${GIT_PUSH_CERT-}':'${GIT_PUSH_CERT_STATUS}':'${GIT_PUSH_NONCE}':'git cat-file':'${GIT_PUSH_CERT}':'$GIT_PUSH_CERT_SIGNER', priority:90
msgid ""
"#!/bin/sh\n"
"# mail out commit update information.\n"
"while read oval nval ref\n"
"do\n"
"\tif expr \"$oval\" : '0*$' >/dev/null\n"
"\tthen\n"
"\t\techo \"Created a new ref, with the following commits:\"\n"
"\t\tgit rev-list --pretty \"$nval\"\n"
"\telse\n"
"\t\techo \"New commits:\"\n"
"\t\tgit rev-list --pretty \"$nval\" \"^$oval\"\n"
"\tfi |\n"
"\tmail -s \"Changes to ref $ref\" commit-list@mydomain\n"
"done\n"
"# log signed push certificate, if any\n"
"if test -n \"${GIT_PUSH_CERT-}\" && test ${GIT_PUSH_CERT_STATUS} = G\n"
"then\n"
"\t(\n"
"\t\techo expected nonce is ${GIT_PUSH_NONCE}\n"
"\t\tgit cat-file blob ${GIT_PUSH_CERT}\n"
"\t) | mail -s \"push certificate from $GIT_PUSH_CERT_SIGNER\" push-log@mydomain\n"
"fi\n"
"exit 0\n"
msgstr ""
"#!/bin/sh\n"
"# 发送提交更新的信息\n"
"while read oval nval ref\n"
"do\n"
"\tif expr \"$oval\" : '0*$' >/dev/null\n"
"\tthen\n"
"\t\techo \"Created a new ref, with the following commits:\"\n"
"\t\tgit rev-list --pretty \"$nval\"\n"
"\telse\n"
"\t\techo \"New commits:\"\n"
"\t\tgit rev-list --pretty \"$nval\" \"^$oval\"\n"
"\tfi |\n"
"\tmail -s \"Changes to ref $ref\" commit-list@mydomain\n"
"done\n"
"# 记录已经签署的推送证书如果\n"
"if test -n \"${GIT_PUSH_CERT-}\" && test ${GIT_PUSH_CERT_STATUS} = G\n"
"then\n"
"\t(\n"
"\t\techo expected nonce is ${GIT_PUSH_NONCE}\n"
"\t\tgit cat-file blob ${GIT_PUSH_CERT}\n"
"\t) | mail -s \"push certificate from $GIT_PUSH_CERT_SIGNER\" push-log@mydomain\n"
"fi\n"
"exit 0\n"

#. type: Plain text
#: en/git-receive-pack.txt:201
#, priority:90
msgid "The exit code from this hook invocation is ignored, however a non-zero exit code will generate an error message."
msgstr "该钩子调用的退出代码将被忽略，但如果退出代码为非零，则会生成错误信息。"

#. type: Plain text
#: en/git-receive-pack.txt:207
#, placeholders:'git-receive-pack', priority:90
msgid "Note that it is possible for refname to not have sha1-new when this hook runs. This can easily occur if another user modifies the ref after it was updated by 'git-receive-pack', but before the hook was able to evaluate it. It is recommended that hooks rely on sha1-new rather than the current value of refname."
msgstr "请注意，当该钩子运行时，引用名有可能没有 sha1-new。 如果在 'git-receive-pack' 更新引用之后，但在钩子评估之前，其他用户修改了引用，就很容易发生这种情况。 建议钩子依赖 sha1-new 而不是引用名的当前值。"

#. type: Title -
#: en/git-receive-pack.txt:209
#, no-wrap, priority:90
msgid "POST-UPDATE HOOK"
msgstr "更新后钩子"

#. type: Plain text
#: en/git-receive-pack.txt:214
#, placeholders:'$GIT_DIR', priority:90
msgid "After all other processing, if at least one ref was updated, and if $GIT_DIR/hooks/post-update file exists and is executable, then post-update will be called with the list of refs that have been updated. This can be used to implement any repository wide cleanup tasks."
msgstr "在所有其他处理之后，如果至少有一个引用被更新，并且 $GIT_DIR/hooks/post-update 文件存在且可执行，那么 post-update 就会被调用，并显示已更新的引用列表。 这可用于执行任何仓库范围内的清理任务。"

# ERROR: git-receive-pack not found in translation
# ERROR: git-receive-pack not found in translation
#. type: Plain text
#: en/git-receive-pack.txt:218
#, placeholders:'git-receive-pack', priority:90
msgid "The exit code from this hook invocation is ignored; the only thing left for 'git-receive-pack' to do at that point is to exit itself anyway."
msgstr "该钩子调用的退出代码将被忽略；此时 'git-receive-pack' 唯一要做的就是退出。"

#. type: Plain text
#: en/git-receive-pack.txt:221
#, placeholders:'git update-server-info', priority:90
msgid "This hook can be used, for example, to run `git update-server-info` if the repository is packed and is served via a dumb transport."
msgstr "例如，如果仓库已打包并通过哑传输提供服务，则可使用此钩子运行 `git update-server-info`。"

#. type: delimited block -
#: en/git-receive-pack.txt:225
#, no-wrap, placeholders:'git update-server-info', priority:90
msgid ""
"#!/bin/sh\n"
"exec git update-server-info\n"
msgstr ""
"#!/bin/sh\n"
"exec git update-server-info\n"

#. type: Title -
#: en/git-receive-pack.txt:229
#, no-wrap, priority:90
msgid "QUARANTINE ENVIRONMENT"
msgstr "隔离环境"

#. type: Plain text
#: en/git-receive-pack.txt:236
#, placeholders:'$GIT_DIR', priority:90
msgid "When `receive-pack` takes in objects, they are placed into a temporary \"quarantine\" directory within the `$GIT_DIR/objects` directory and migrated into the main object store only after the `pre-receive` hook has completed. If the push fails before then, the temporary directory is removed entirely."
msgstr "当 `receive-pack` 接收对象时，它们会被放置到 `$GIT_DIR/objects` 目录中的临时 “隔离” 目录，只有在 `pre-receive` 钩子完成后才会迁移到主对象存储区。如果在此之前推送失败，临时目录将被完全删除。"

#. type: Plain text
#: en/git-receive-pack.txt:238
#, priority:90
msgid "This has a few user-visible effects and caveats:"
msgstr "这有一些用户可见的效果和注意事项："

#. type: Plain text
#: en/git-receive-pack.txt:244
#, priority:90
msgid "Pushes which fail due to problems with the incoming pack, missing objects, or due to the `pre-receive` hook will not leave any on-disk data. This is usually helpful to prevent repeated failed pushes from filling up your disk, but can make debugging more challenging."
msgstr "由于传入数据包问题、对象丢失或由于 `pre-receive` 钩子而导致的推送失败不会在磁盘上留下任何数据。这通常有助于防止重复失败的推送占满磁盘，但会增加调试难度。"

#. type: Plain text
#: en/git-receive-pack.txt:247
#, priority:90
msgid "Any objects created by the `pre-receive` hook will be created in the quarantine directory (and migrated only if it succeeds)."
msgstr "任何由 `pre-receive` 钩子创建的对象都将在隔离区目录中创建（只有在成功时才会迁移）。"

#. type: Plain text
#: en/git-receive-pack.txt:253
#, priority:90
msgid "The `pre-receive` hook MUST NOT update any refs to point to quarantined objects. Other programs accessing the repository will not be able to see the objects (and if the pre-receive hook fails, those refs would become corrupted). For safety, any ref updates from within `pre-receive` are automatically rejected."
msgstr "`pre-receive` 钩子不得更新任何引用以指向被隔离的对象。访问版本库的其他程序将无法看到这些对象（如果预接收钩子失败，这些引用就会损坏）。为了安全起见，任何来自 `pre-receive` 钩子的引用更新都会被自动拒绝。"

#. type: Plain text
#: en/git-receive-pack.txt:258
#, ignore-same, priority:90
msgid "linkgit:git-send-pack[1], linkgit:gitnamespaces[7]"
msgstr "linkgit:git-send-pack[1], linkgit:gitnamespaces[7]"

#. type: Title =
#: en/git-reflog.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-reflog(1)"
msgstr "git-reflog(1)"

#. type: Plain text
#: en/git-reflog.txt:7
#, placeholders:'git-reflog', priority:100
msgid "git-reflog - Manage reflog information"
msgstr "git-reflog - 管理重引用日志信息"

#. type: Plain text
#: en/git-reflog.txt:19
#, ignore-ellipsis, no-wrap, placeholders:'[--expire=':'[--expire-unreachable=':'[--rewrite]':'[--updateref]':'[--stale-fix]':'[--dry-run':'[--verbose]':'[--all':'[--single-worktree]':'[--rewrite]':'[--updateref]':'[--dry-run':'[--verbose]', priority:100
msgid ""
"'git reflog' [show] [<log-options>] [<ref>]\n"
"'git reflog expire' [--expire=<time>] [--expire-unreachable=<time>]\n"
"\t[--rewrite] [--updateref] [--stale-fix]\n"
"\t[--dry-run | -n] [--verbose] [--all [--single-worktree] | <refs>...]\n"
"'git reflog delete' [--rewrite] [--updateref]\n"
"\t[--dry-run | -n] [--verbose] <ref>@{<specifier>}...\n"
"'git reflog exists' <ref>\n"
msgstr ""
"'git reflog' [show] [<日志选项>] [<引用>]\n"
"'git reflog expire' [--expire=<时间>] [--expire-unreachable=<时间>]\n"
"\t[--rewrite] [--updateref] [--stale-fix]\n"
"\t[--dry-run | -n] [--verbose] [--all [--single-worktree] | <引用>...]\n"
"'git reflog delete' [--rewrite] [--updateref]\n"
"\t[--dry-run | -n] [--verbose] <引用>@{<标注>}...\n"
"'git reflog exists' <引用>\n"

#. type: Plain text
#: en/git-reflog.txt:23
#, priority:100
msgid "This command manages the information recorded in the reflogs."
msgstr "该命令管理记录在引用日志中的信息。"

#. type: Plain text
#: en/git-reflog.txt:31
#, placeholders:'HEAD':'{2}':'HEAD':'one.week.ago':'linkgit:gitrevisions[7]', priority:100
msgid "Reference logs, or \"reflogs\", record when the tips of branches and other references were updated in the local repository. Reflogs are useful in various Git commands, to specify the old value of a reference. For example, `HEAD@{2}` means \"where HEAD used to be two moves ago\", `master@{one.week.ago}` means \"where master used to point to one week ago in this local repository\", and so on. See linkgit:gitrevisions[7] for more details."
msgstr "引用日志（或称 \"reflogs\"）记录了本地仓库中分支和其他引用的提示更新时间。参考日志在各种 Git 命令中都很有用，可以用来指定引用的旧值。例如，`HEAD@{2}` 表示 “两步前 HEAD 所在的位置”，`master@{one.week.ago}` 表示 “一周前本仓库中 master 所在的位置”，等等。详见 linkgit:gitrevisions[7]。"

#. type: Plain text
#: en/git-reflog.txt:41
#, placeholders:'HEAD':'HEAD':'--abbrev-commit':'--pretty=oneline`':'linkgit:git-log[1]', priority:100
msgid "The \"show\" subcommand (which is also the default, in the absence of any subcommands) shows the log of the reference provided in the command-line (or `HEAD`, by default). The reflog covers all recent actions, and in addition the `HEAD` reflog records branch switching. `git reflog show` is an alias for `git log -g --abbrev-commit --pretty=oneline`; see linkgit:git-log[1] for more information."
msgstr "\"show\" 子命令（也是默认命令，在没有任何子命令的情况下）显示命令行中提供的引用日志（或默认的 `HEAD`）。引用日志包括所有最近的操作，此外，`HEAD` 引用日志还记录分支切换。 `git reflog show` 是 `git log -g --abbrev-commit --pretty=oneline` 的别名；详见 linkgit:git-log[1]。"

#. type: Plain text
#: en/git-reflog.txt:47
#, placeholders:'linkgit:git-gc[1]', priority:100
msgid "The \"expire\" subcommand prunes older reflog entries. Entries older than `expire` time, or entries older than `expire-unreachable` time and not reachable from the current tip, are removed from the reflog. This is typically not used directly by end users -- instead, see linkgit:git-gc[1]."
msgstr "\"expire\" 子命令用于删除旧的引用日志条目。超过 `expire` 时间的条目，或超过 `expire-unreachable` 时间且当前 tip 无法访问的条目，都会从引用日志中删除。 终端用户通常不会直接使用该子项，请参见 linkgit:git-gc[1]。"

#. type: Plain text
#: en/git-reflog.txt:52
#, placeholders:'{2}', priority:100
msgid "The \"delete\" subcommand deletes single entries from the reflog. Its argument must be an _exact_ entry (e.g. \"`git reflog delete master@{2}`\"). This subcommand is also typically not used directly by end users."
msgstr "\"delete\" 子命令用于删除应用日志中的单个条目。其参数必须是一个_exact_条目（例如\"`git reflog delete master@{2}`\"）。最终用户通常也不会直接使用该子命令。"

#. type: Plain text
#: en/git-reflog.txt:56
#, priority:100
msgid "The \"exists\" subcommand checks whether a ref has a reflog. It exits with zero status if the reflog exists, and non-zero status if it does not."
msgstr "\"exists\" 子命令检查引用是否有引用日志。 如果引用日志存在，则以零状态退出；如果不存在，则以非零状态退出。"

#. type: Title ~
#: en/git-reflog.txt:61
#, no-wrap, priority:100
msgid "Options for `show`"
msgstr "`show`（显示）的选项"

#. type: Plain text
#: en/git-reflog.txt:64
#, priority:100
msgid "`git reflog show` accepts any of the options accepted by `git log`."
msgstr "`git reflog show` 接受 `git log` 接受的任何选项。"

#. type: Title ~
#: en/git-reflog.txt:67
#, no-wrap, priority:100
msgid "Options for `expire`"
msgstr "`expire` 的选项"

#. type: Plain text
#: en/git-reflog.txt:71
#, priority:100
msgid "Process the reflogs of all references."
msgstr "处理所有引用的引用日志。"

#. type: Labeled list
#: en/git-reflog.txt:72 en/rev-list-options.txt:222
#, ignore-same, no-wrap, priority:260
msgid "--single-worktree"
msgstr "--single-worktree"

#. type: Plain text
#: en/git-reflog.txt:76
#, placeholders:'`--all`', priority:100
msgid "By default when `--all` is specified, reflogs from all working trees are processed. This option limits the processing to reflogs from the current working tree only."
msgstr "默认情况下，如果指定了 `--all`选项，所有工作区的引用日志都会被处理。此选项限制只处理当前工作区的引用日志。"

#. type: Labeled list
#: en/git-reflog.txt:77
#, no-wrap, placeholders:'--expire=', priority:100
msgid "--expire=<time>"
msgstr "--expire=<时间>"

#. type: Plain text
#: en/git-reflog.txt:84
#, placeholders:'gc.reflogExpire':'`--expire=all`':'`--expire=never`':'`--expire-unreachable`', priority:100
msgid "Prune entries older than the specified time. If this option is not specified, the expiration time is taken from the configuration setting `gc.reflogExpire`, which in turn defaults to 90 days. `--expire=all` prunes entries regardless of their age; `--expire=never` turns off pruning of reachable entries (but see `--expire-unreachable`)."
msgstr "剪除超过指定时间的条目。如果未指定此选项，则过期时间取自配置设置 `gc.reflogExpire`，默认为 90 天。`--expire=all` 会剪除任何年龄的条目；`--expire=never` 会关闭剪除可到达条目的功能（但请参阅 `--expire-unreachable`）。"

#. type: Labeled list
#: en/git-reflog.txt:85
#, no-wrap, placeholders:'--expire-unreachable=', priority:100
msgid "--expire-unreachable=<time>"
msgstr "--expire-unreachable=<时间>"

#. type: Plain text
#: en/git-reflog.txt:94
#, placeholders:'gc.reflogExpireUnreachable':'`--expire-unreachable=all`':'`--expire-unreachable=never`':'`--expire`', priority:100
msgid "Prune entries older than `<time>` that are not reachable from the current tip of the branch. If this option is not specified, the expiration time is taken from the configuration setting `gc.reflogExpireUnreachable`, which in turn defaults to 30 days. `--expire-unreachable=all` prunes unreachable entries regardless of their age; `--expire-unreachable=never` turns off early pruning of unreachable entries (but see `--expire`)."
msgstr "剪除从分支当前顶端无法到达的超过 `<时间>` 的条目。如果未指定此选项，则过期时间取自配置设置 `gc.reflogExpireUnreachable`，默认为 30 天。`--expire-unreachable=all` 会修剪无法访问的条目，无论其年龄大小；`--expire-unreachable=never` 会关闭对无法访问条目的早期修剪（但请参见 `--expire`）。"

#. type: Labeled list
#: en/git-reflog.txt:95
#, ignore-same, no-wrap, priority:100
msgid "--updateref"
msgstr "--updateref"

#. type: Plain text
#: en/git-reflog.txt:99
#, priority:100
msgid "Update the reference to the value of the top reflog entry (i.e. <ref>@\\{0\\}) if the previous top entry was pruned. (This option is ignored for symbolic references.)"
msgstr "如果前一个顶层条目已被剪枝，则将引用更新为顶层引用日志条目的值（即 <引用>@\\{0\\}）。 (符号引用将忽略此选项）"

#. type: Labeled list
#: en/git-reflog.txt:100
#, ignore-same, no-wrap, priority:100
msgid "--rewrite"
msgstr "--rewrite"

#. type: Plain text
#: en/git-reflog.txt:104
#, priority:100
msgid "If a reflog entry's predecessor is pruned, adjust its \"old\" SHA-1 to be equal to the \"new\" SHA-1 field of the entry that now precedes it."
msgstr "如果重写日志条目的前一个条目被剪枝，则调整其 “旧” SHA-1，使其等于现在排在其前面的条目的 “新” SHA-1 字段。"

#. type: Labeled list
#: en/git-reflog.txt:105
#, ignore-same, no-wrap, priority:100
msgid "--stale-fix"
msgstr "--stale-fix"

#. type: Plain text
#: en/git-reflog.txt:110
#, priority:100
msgid "Prune any reflog entries that point to \"broken commits\". A broken commit is a commit that is not reachable from any of the reference tips and that refers, directly or indirectly, to a missing commit, tree, or blob object."
msgstr "删除任何指向 “中断提交” 的引用日志条目。中断提交是指从任何引用提示都无法到达的提交，它直接或间接地指向丢失的提交、树或二进制对象。"

#. type: Plain text
#: en/git-reflog.txt:115
#, priority:100
msgid "This computation involves traversing all the reachable objects, i.e. it has the same cost as 'git prune'. It is primarily intended to fix corruption caused by garbage collecting using older versions of Git, which didn't protect objects referred to by reflogs."
msgstr "这种计算涉及遍历所有可到达的对象，也就是说，其代价与 'git prune' 相同。 它的主要目的是修复旧版本 Git 垃圾回收所造成的损坏，因为旧版本的 Git 无法保护引用日志所引用的对象。"

#. type: Plain text
#: en/git-reflog.txt:120
#, priority:100
msgid "Do not actually prune any entries; just show what would have been pruned."
msgstr "不要实际修剪任何条目，只需显示本应修剪的内容。"

#. type: Plain text
#: en/git-reflog.txt:123
#, priority:100
msgid "Print extra information on screen."
msgstr "在屏幕上打印额外信息。"

#. type: Title ~
#: en/git-reflog.txt:126
#, no-wrap, priority:100
msgid "Options for `delete`"
msgstr "`delete`（删除）的选项"

#. type: Plain text
#: en/git-reflog.txt:131
#, placeholders:'`--updateref`':'`--rewrite`':'`-n`':'`--dry-run`':'`--verbose`', priority:100
msgid "`git reflog delete` accepts options `--updateref`, `--rewrite`, `-n`, `--dry-run`, and `--verbose`, with the same meanings as when they are used with `expire`."
msgstr "`git reflog delete` 接受选项 `--updateref`、`--rewrite`、`-n`、`--dry-run` 和 `--verbose`，其含义与与 `expire` 一起使用时相同。"

#. type: Title =
#: en/git-remote-ext.txt:2
#, ignore-same, no-wrap, priority:90
msgid "git-remote-ext(1)"
msgstr "git-remote-ext(1)"

#. type: Plain text
#: en/git-remote-ext.txt:7
#, placeholders:'git-remote-ext', priority:90
msgid "git-remote-ext - Bridge smart transport to external command."
msgstr "git-remote-ext - 桥接智能传输与外部命令。"

#. type: Plain text
#: en/git-remote-ext.txt:12
#, ignore-ellipsis, no-wrap, priority:90
msgid "git remote add <nick> \"ext::<command>[ <arguments>...]\"\n"
msgstr "git remote add <别名> \"ext::<命令>[ <参数>...]\"\n"

#. type: Plain text
#: en/git-remote-ext.txt:17
#, priority:90
msgid "This remote helper uses the specified '<command>' to connect to a remote Git server."
msgstr "该远程助手使用指定的 '<命令>' 连接远程 Git 服务器。"

#. type: Plain text
#: en/git-remote-ext.txt:23
#, placeholders:'git-upload-pack':'git-receive-pack', priority:90
msgid "Data written to stdin of the specified '<command>' is assumed to be sent to a git:// server, git-upload-pack, git-receive-pack or git-upload-archive (depending on situation), and data read from stdout of <command> is assumed to be received from the same service."
msgstr "写入指定 '<命令>' 的标准输入流的数据被假定为发送到 git:// 服务器、git-upload-pack、git-receive-pack 或 git-upload-archive（视情况而定），而从 <命令> 的标准输出流读取的数据被假定为从同一服务接收。"

#. type: Plain text
#: en/git-remote-ext.txt:25
#, priority:90
msgid "Command and arguments are separated by an unescaped space."
msgstr "命令和参数之间用空格隔开。"

#. type: Plain text
#: en/git-remote-ext.txt:27
#, priority:90
msgid "The following sequences have a special meaning:"
msgstr "以下序列具有特殊含义："

#. type: Labeled list
#: en/git-remote-ext.txt:28
#, no-wrap, priority:90
msgid "'% '"
msgstr "'% '"

#. type: Plain text
#: en/git-remote-ext.txt:30
#, priority:90
msgid "Literal space in command or argument."
msgstr "命令或参数中的字面空格。"

#. type: Labeled list
#: en/git-remote-ext.txt:31 en/pretty-formats.txt:124
#, no-wrap, priority:260
msgid "'%%'"
msgstr "'%%'"

#. type: Plain text
#: en/git-remote-ext.txt:33
#, priority:90
msgid "Literal percent sign."
msgstr "字面百分号。"

#. type: Labeled list
#: en/git-remote-ext.txt:34 en/pretty-formats.txt:266
#, ignore-same, no-wrap, priority:260
msgid "'%s'"
msgstr "'%s'"

#. type: Plain text
#: en/git-remote-ext.txt:37
#, priority:90
msgid "Replaced with name (receive-pack, upload-pack, or upload-archive) of the service Git wants to invoke."
msgstr "替换为 Git 希望调用的服务名称（receive-pack、upload-pack 或 upload-archive）。"

#. type: Labeled list
#: en/git-remote-ext.txt:38 en/pretty-formats.txt:263
#, ignore-same, no-wrap, priority:260
msgid "'%S'"
msgstr "'%S'"

#. type: Plain text
#: en/git-remote-ext.txt:42
#, placeholders:'git-receive-pack':'git-upload-pack', priority:90
msgid "Replaced with long name (git-receive-pack, git-upload-pack, or git-upload-archive) of the service Git wants to invoke."
msgstr "替换为 Git 希望调用的服务的长名称（git-receive-pack、git-upload-pack 或 git-upload-archive）。"

#. type: Labeled list
#: en/git-remote-ext.txt:43
#, no-wrap, priority:90
msgid "'%G' (must be the first characters in an argument)"
msgstr "'%G'（必须是参数中的第一个字符）"

#. type: Plain text
#: en/git-remote-ext.txt:49
#, priority:90
msgid "This argument will not be passed to '<command>'. Instead, it will cause the helper to start by sending git:// service requests to the remote side with the service field set to an appropriate value and the repository field set to the rest of the argument. Default is not to send such a request."
msgstr "这个参数不会传给 '<命令>'。相反，它会导致辅助程序向远端发送 git:// 服务请求，其中服务字段设置为合适的值，版本库字段则设置为参数的其余部分。默认情况下不发送此类请求。"

#. type: Plain text
#: en/git-remote-ext.txt:52
#, priority:90
msgid "This is useful if the remote side is git:// server accessed over some tunnel."
msgstr "如果远端是通过隧道访问的 git:// 服务器，这个功能就很有用。"

#. type: Labeled list
#: en/git-remote-ext.txt:53
#, no-wrap, priority:90
msgid "'%V' (must be first characters in argument)"
msgstr "'%V' （必须是参数中的第一个字符）"

#. type: Plain text
#: en/git-remote-ext.txt:57
#, priority:90
msgid "This argument will not be passed to '<command>'. Instead it sets the vhost field in the git:// service request (to the rest of the argument). Default is not to send vhost in such request (if sent)."
msgstr "该参数不会传递给 '<命令>'。相反，它会在 git:// 服务请求中设置 vhost 字段（与参数的其余部分相同）。 默认情况是不在此类请求中发送 vhost（如果发送）。"

#. type: Title -
#: en/git-remote-ext.txt:59 en/git-remote-fd.txt:32
#, no-wrap, priority:90
msgid "ENVIRONMENT VARIABLES"
msgstr "环境变量"

#. type: Labeled list
#: en/git-remote-ext.txt:61 en/git-remote-fd.txt:33
#, ignore-same, no-wrap, priority:90
msgid "GIT_TRANSLOOP_DEBUG"
msgstr "GIT_TRANSLOOP_DEBUG"

#. type: Plain text
#: en/git-remote-ext.txt:63 en/git-remote-fd.txt:35
#, priority:90
msgid "If set, prints debugging information about various reads/writes."
msgstr "如果设置，则打印各种读/写的调试信息。"

#. type: Title -
#: en/git-remote-ext.txt:65
#, no-wrap, priority:90
msgid "ENVIRONMENT VARIABLES PASSED TO COMMAND"
msgstr "传递给命令的环境变量"

#. type: Labeled list
#: en/git-remote-ext.txt:67
#, ignore-same, no-wrap, priority:90
msgid "GIT_EXT_SERVICE"
msgstr "GIT_EXT_SERVICE"

#. type: Plain text
#: en/git-remote-ext.txt:70
#, ignore-ellipsis, placeholders:'git-upload-pack', priority:90
msgid "Set to long name (git-upload-pack, etc...) of service helper needs to invoke."
msgstr "设置为辅助程序需要调用的服务的长名称（git-upload-pack 等......）。"

#. type: Labeled list
#: en/git-remote-ext.txt:71
#, ignore-same, no-wrap, priority:90
msgid "GIT_EXT_SERVICE_NOPREFIX"
msgstr "GIT_EXT_SERVICE_NOPREFIX"

#. type: Plain text
#: en/git-remote-ext.txt:74
#, ignore-ellipsis, priority:90
msgid "Set to long name (upload-pack, etc...) of service helper needs to invoke."
msgstr "设置为辅助程序需要调用的服务的长名称（upload-pack 等......）。"

#. type: Plain text
#: en/git-remote-ext.txt:82
#, priority:90
msgid "This remote helper is transparently used by Git when you use commands such as \"git fetch <URL>\", \"git clone <URL>\", , \"git push <URL>\" or \"git remote add <nick> <URL>\", where <URL> begins with `ext::`. Examples:"
msgstr "当您使用 \"git fetch <URL>\", \"git clone <URL>\", , \"git push <URL>\" 或 \"git remote add <nick> <URL>\" 等命令时，Git 会透明地使用这个远程助手，其中 <URL> 是以 `ext::` 开头的。 例如："

#. type: Labeled list
#: en/git-remote-ext.txt:83
#, no-wrap, placeholders:'host.example', priority:90
msgid "\"ext::ssh -i /home/foo/.ssh/somekey user&#64;host.example %S 'foo/repo'\""
msgstr "\"ext::ssh -i /home/foo/.ssh/somekey user&#64;host.example %S 'foo/repo'\""

#. type: Plain text
#: en/git-remote-ext.txt:87
#, placeholders:'host.example', priority:90
msgid "Like host.example:foo/repo, but use /home/foo/.ssh/somekey as keypair and user as the user on the remote side. This avoids the need to edit .ssh/config."
msgstr "类似 host.example:foo/repo，但使用 /home/foo/.ssh/somekey 作为密钥对，user 作为远程用户。这样就无需编辑 .ssh/config。"

#. type: Labeled list
#: en/git-remote-ext.txt:88
#, no-wrap, placeholders:'git-server', priority:90
msgid "\"ext::socat -t3600 - ABSTRACT-CONNECT:/git-server %G/somerepo\""
msgstr "\"ext::socat -t3600 - ABSTRACT-CONNECT:/git-server %G/somerepo\""

#. type: Plain text
#: en/git-remote-ext.txt:91
#, placeholders:'git-server', priority:90
msgid "Represents repository with path /somerepo accessible over git protocol at the abstract namespace address /git-server."
msgstr "代表通过抽象命名空间地址 /git-server 的 git 协议访问的仓库，路径为 /somerepo。"

#. type: Labeled list
#: en/git-remote-ext.txt:92
#, no-wrap, placeholders:'git-server-alias', priority:90
msgid "\"ext::git-server-alias foo %G/repo\""
msgstr "\"ext::git-server-alias foo %G/repo\""

#. type: Plain text
#: en/git-remote-ext.txt:98
#, placeholders:'git-server-alias', priority:90
msgid "Represents a repository with path /repo accessed using the helper program \"git-server-alias foo\". The path to the repository and type of request are not passed on the command line but as part of the protocol stream, as usual with git:// protocol."
msgstr "代表使用辅助程序 \"git-server-alias foo\" 访问的仓库，路径为 /repo。 仓库路径和请求类型不在命令行中传递，而是作为协议流的一部分，与 git:// 协议一样。"

#. type: Labeled list
#: en/git-remote-ext.txt:99
#, no-wrap, placeholders:'git-server-alias', priority:90
msgid "\"ext::git-server-alias foo %G/repo %Vfoo\""
msgstr "\"ext::git-server-alias foo %G/repo %Vfoo\""

#. type: Plain text
#: en/git-remote-ext.txt:105
#, placeholders:'git-server-alias', priority:90
msgid "Represents a repository with path /repo accessed using the helper program \"git-server-alias foo\". The hostname for the remote server passed in the protocol stream will be \"foo\" (this allows multiple virtual Git servers to share a link-level address)."
msgstr "代表使用辅助程序 \"git-server-alias foo\" 访问的仓库，路径为 /repo。 协议流中传递的远程服务器主机名将是 \"foo\"（这允许多个虚拟 Git 服务器共享一个链接级地址）。"

#. type: Labeled list
#: en/git-remote-ext.txt:106
#, no-wrap, placeholders:'git-server-alias', priority:90
msgid "\"ext::git-server-alias foo %G/repo% with% spaces %Vfoo\""
msgstr "\"ext::git-server-alias foo %G/repo% with% spaces %Vfoo\""

#. type: Plain text
#: en/git-remote-ext.txt:112
#, placeholders:'git-server-alias', priority:90
msgid "Represents a repository with path `/repo with spaces` accessed using the helper program \"git-server-alias foo\". The hostname for the remote server passed in the protocol stream will be \"foo\" (this allows multiple virtual Git servers to share a link-level address)."
msgstr "代表使用辅助程序 \"git-server-alias foo\" 访问的仓库，路径为 \"/repo with spaces\"。 协议流中传递的远程服务器主机名将是 \"foo\"（这允许多个虚拟 Git 服务器共享一个链接级地址）。"

#. type: Labeled list
#: en/git-remote-ext.txt:113
#, no-wrap, placeholders:'git-ssl', priority:90
msgid "\"ext::git-ssl foo.example /bar\""
msgstr "\"ext::git-ssl foo.example /bar\""

#. type: Plain text
#: en/git-remote-ext.txt:118
#, placeholders:'git-ssl', priority:90
msgid "Represents a repository accessed using the helper program \"git-ssl foo.example /bar\". The type of request can be determined by the helper using environment variables (see above)."
msgstr "代表使用辅助程序 \"git-ssl foo.example /bar\" 访问的仓库。 请求类型可由辅助程序使用环境变量确定（见上文）。"

#. type: Title =
#: en/git-remote-fd.txt:2
#, ignore-same, no-wrap, priority:90
msgid "git-remote-fd(1)"
msgstr "git-remote-fd(1)"

#. type: Plain text
#: en/git-remote-fd.txt:7
#, placeholders:'git-remote-fd', priority:90
msgid "git-remote-fd - Reflect smart transport stream back to caller"
msgstr "git-remote-fd - 将智能传输流反射回调用者"

#. type: Plain text
#: en/git-remote-fd.txt:11
#, priority:90
msgid "\"fd::<infd>[,<outfd>][/<anything>]\" (as URL)"
msgstr "\"fd::<infd>[,<outfd>][/<anything>]\"（作为 URL）"

#. type: Plain text
#: en/git-remote-fd.txt:17
#, priority:90
msgid "This helper uses specified file descriptors to connect to a remote Git server. This is not meant for end users but for programs and scripts calling git fetch, push, or archive."
msgstr "该辅助程序使用指定的文件描述符连接远程 Git 服务器。 它不是为最终用户设计的，而是为调用 git fetch、push 或 archive 的程序和脚本设计的。"

#. type: Plain text
#: en/git-remote-fd.txt:23
#, placeholders:'git-upload-pack':'git-receive-pack', priority:90
msgid "If only <infd> is given, it is assumed to be a bidirectional socket connected to a remote Git server (git-upload-pack, git-receive-pack, or git-upload-archive). If both <infd> and <outfd> are given, they are assumed to be pipes connected to a remote Git server (<infd> being the inbound pipe and <outfd> being the outbound pipe)."
msgstr "如果只给出 <infd>，则假定它是连接远程 Git 服务器（git-upload-pack、git-receive-pack 或 git-upload-archive）的双向套接字。如果同时给出 <infd> 和 <outfd>，则假定它们是连接到远程 Git 服务器的管道（<infd> 是入站管道，<outfd> 是出站管道）。"

#. type: Plain text
#: en/git-remote-fd.txt:26
#, priority:90
msgid "It is assumed that any handshaking procedures have already been completed (such as sending service request for git://) before this helper is started."
msgstr "假定在启动该辅助程序之前，任何握手程序都已完成（例如发送 git:// 服务请求）。"

#. type: Plain text
#: en/git-remote-fd.txt:30
#, priority:90
msgid "<anything> can be any string. It is ignored. It is meant for providing information to the user in the URL in case that URL is displayed in some context."
msgstr "<anything> 可以是任何字符串。它将被忽略。它的作用是在 URL 在某些上下文中显示时向用户提供信息。"

#. type: Labeled list
#: en/git-remote-fd.txt:38
#, no-wrap, priority:90
msgid "`git fetch fd::17 master`"
msgstr "`git fetch fd::17 master`"

#. type: Plain text
#: en/git-remote-fd.txt:41
#, placeholders:'git-upload-pack', priority:90
msgid "Fetch master, using file descriptor #17 to communicate with git-upload-pack."
msgstr "取回主文件，使用文件描述符 #17 与 git-upload-pack 通信。"

#. type: Labeled list
#: en/git-remote-fd.txt:42
#, no-wrap, priority:90
msgid "`git fetch fd::17/foo master`"
msgstr "`git fetch fd::17/foo master`"

#. type: Labeled list
#: en/git-remote-fd.txt:45
#, no-wrap, priority:90
msgid "`git push fd::7,8 master (as URL)`"
msgstr "`git push fd::7,8 master (as URL)`"

#. type: Plain text
#: en/git-remote-fd.txt:49
#, placeholders:'git-receive-pack', priority:90
msgid "Push master, using file descriptor #7 to read data from git-receive-pack and file descriptor #8 to write data to the same service."
msgstr "使用 7 号文件描述符从 git-receive-pack 读取数据，使用 8 号文件描述符向同一服务写入数据，推送主站。"

#. type: Labeled list
#: en/git-remote-fd.txt:50
#, no-wrap, priority:90
msgid "`git push fd::7,8/bar master`"
msgstr "`git push fd::7,8/bar master`"

#. type: Title =
#: en/git-remote.txt:2
#, ignore-same, no-wrap, priority:220
msgid "git-remote(1)"
msgstr "git-remote(1)"

#. type: Plain text
#: en/git-remote.txt:7
#, placeholders:'git-remote', priority:220
msgid "git-remote - Manage set of tracked repositories"
msgstr "git-remote - 管理一组追踪的仓库"

#. type: Plain text
#: en/git-remote.txt:25
#, ignore-ellipsis, no-wrap, placeholders:'--verbose]':'[--mirror=(fetch|push)]':'--auto':'--delete':'[--add]':'[--push]':'[--all]':'[--push]':'--add':'[--push]':'--delete':'[--push]':'--verbose]':'--dry-run]':'--verbose]':'--prune]', priority:220
msgid ""
"'git remote' [-v | --verbose]\n"
"'git remote add' [-t <branch>] [-m <master>] [-f] [--[no-]tags] [--mirror=(fetch|push)] <name> <URL>\n"
"'git remote rename' [--[no-]progress] <old> <new>\n"
"'git remote remove' <name>\n"
"'git remote set-head' <name> (-a | --auto | -d | --delete | <branch>)\n"
"'git remote set-branches' [--add] <name> <branch>...\n"
"'git remote get-url' [--push] [--all] <name>\n"
"'git remote set-url' [--push] <name> <newurl> [<oldurl>]\n"
"'git remote set-url --add' [--push] <name> <newurl>\n"
"'git remote set-url --delete' [--push] <name> <URL>\n"
"'git remote' [-v | --verbose] 'show' [-n] <name>...\n"
"'git remote prune' [-n | --dry-run] <name>...\n"
"'git remote' [-v | --verbose] 'update' [-p | --prune] [(<group> | <remote>)...]\n"
msgstr ""
"'git remote' [-v | --verbose]\n"
"'git remote add' [-t <分支>] [-m <master>] [-f] [--[no-]tags] [--mirror=(fetch|push)] <名称> <URL>\n"
"'git remote rename' [--[no-]progress] <旧名> <新名>\n"
"'git remote remove' <名称>\n"
"'git remote set-head' <名称> (-a | --auto | -d | --delete | <分支>)\n"
"'git remote set-branches' [--add] <名称> <分支>...\n"
"'git remote get-url' [--push] [--all] <名称>\n"
"'git remote set-url' [--push] <名称> <新地址> [<旧地址>]\n"
"'git remote set-url --add' [--push] <名称> <新地址>\n"
"'git remote set-url --delete' [--push] <名称> <地址>\n"
"'git remote' [-v | --verbose] 'show' [-n] <名称>...\n"
"'git remote prune' [-n | --dry-run] <名称>...\n"
"'git remote' [-v | --verbose] 'update' [-p | --prune] [(<组> | <远程仓库>)...]\n"

#. type: Plain text
#: en/git-remote.txt:30
#, priority:220
msgid "Manage the set of repositories (\"remotes\") whose branches you track."
msgstr "管理仓库（\"远程\"）的集合，这些仓库的分支由你跟踪。"

#. type: Plain text
#: en/git-remote.txt:41
#, priority:220
msgid "Be a little more verbose and show remote url after name. For promisor remotes, also show which filter (`blob:none` etc.) are configured. NOTE: This must be placed between `remote` and subcommand."
msgstr "更详细一点，在名称后显示远程 URL。对于允诺者远程，还要显示配置了哪个过滤器(` blob: none` 等)。注意: 这必须放在 `remote` 和子命令之间。"

#. type: Plain text
#: en/git-remote.txt:48
#, priority:220
msgid "With no arguments, shows a list of existing remotes. Several subcommands are available to perform operations on the remotes."
msgstr "不带参数，显示现有远程的列表。有几个子命令可用于对远程执行操作。"

#. type: Labeled list
#: en/git-remote.txt:49
#, no-wrap, priority:220
msgid "'add'"
msgstr "'add'"

#. type: Plain text
#: en/git-remote.txt:54
#, priority:220
msgid "Add a remote named <name> for the repository at <URL>. The command `git fetch <name>` can then be used to create and update remote-tracking branches <name>/<branch>."
msgstr "在 <URL> 为存储库添加一个名为 <名称> 的远程名称。然后可以使用命令 `git get <名称>`创建和更新远程跟踪分支 <名称>/<分支> 。"

#. type: Plain text
#: en/git-remote.txt:57
#, placeholders:'`-f`', priority:220
msgid "With `-f` option, `git fetch <name>` is run immediately after the remote information is set up."
msgstr "使用 `-f` 选项，在设置远程信息之后立即运行 `git get <名称>`。"

#. type: Plain text
#: en/git-remote.txt:60
#, placeholders:'`--tags`', priority:220
msgid "With `--tags` option, `git fetch <name>` imports every tag from the remote repository."
msgstr "使用 `--tags` 选项，`git get <名称>` 从远程仓库导入每个标记。"

#. type: Plain text
#: en/git-remote.txt:63
#, placeholders:'`--no-tags`', priority:220
msgid "With `--no-tags` option, `git fetch <name>` does not import tags from the remote repository."
msgstr "使用 `--no-tags` 选项，`git fetch <名称>` 不会从远程仓库导入标签。"

#. type: Plain text
#: en/git-remote.txt:66
#, placeholders:'linkgit:git-fetch[1]', priority:220
msgid "By default, only tags on fetched branches are imported (see linkgit:git-fetch[1])."
msgstr "默认情况下，只导入获取的分支上的标记（参见 linkgit:git-fetch[1]）。"

#. type: Plain text
#: en/git-remote.txt:72
#, priority:220
msgid "With `-t <branch>` option, instead of the default glob refspec for the remote to track all branches under the `refs/remotes/<name>/` namespace, a refspec to track only `<branch>` is created. You can give more than one `-t <branch>` to track multiple branches without grabbing all branches."
msgstr "使用 `-t <分支>` 选项，将创建一个仅跟踪 `refs/remotes/<名称>/` 命名空间下的所有分支的引用规范，而不是用于远程跟踪的默认引用规范通配符。您可以提供多个 `-t <分支>` 来跟踪多个分支，而不需要获取所有分支。"

#. type: Plain text
#: en/git-remote.txt:75
#, placeholders:'HEAD', priority:220
msgid "With `-m <master>` option, a symbolic-ref `refs/remotes/<name>/HEAD` is set up to point at remote's `<master>` branch. See also the set-head command."
msgstr "使用 `-m <master>` 选项，可以设置一个符号引用 `/remotes/<名称>/HEAD` 来指向远程仓库的 `<master>` 分支。另请参见 set-head 命令。"

#. type: Plain text
#: en/git-remote.txt:81
#, placeholders:'`--mirror=fetch`', priority:220
msgid "When a fetch mirror is created with `--mirror=fetch`, the refs will not be stored in the 'refs/remotes/' namespace, but rather everything in 'refs/' on the remote will be directly mirrored into 'refs/' in the local repository. This option only makes sense in bare repositories, because a fetch would overwrite any local commits."
msgstr "当用 `--mirror=fetch` 创建一个 fetch 镜像时， 引用不会被存储在 'refs/remotes/' 命名空间中，而是远程的 'refs/' 中的所有内容将直接被镜像到本地版本库的 'refs/' 中。这个选项只有在裸库中才有意义，因为获取会覆盖任何本地提交。"

#. type: Plain text
#: en/git-remote.txt:84
#, placeholders:'`--mirror=push`':'`--mirror`', priority:220
msgid "When a push mirror is created with `--mirror=push`, then `git push` will always behave as if `--mirror` was passed."
msgstr "当用 `--mirror=push` 创建推送镜像时，`git push` 的行为就像传递 `--mirror` 一样。"

#. type: Labeled list
#: en/git-remote.txt:85
#, no-wrap, priority:220
msgid "'rename'"
msgstr "'rebase'"

#. type: Plain text
#: en/git-remote.txt:89
#, priority:220
msgid "Rename the remote named <old> to <new>. All remote-tracking branches and configuration settings for the remote are updated."
msgstr "将名为 < 旧名称 > 的远程重命名为 < 新名称 > 。所有远程跟踪的分支和远程的配置设置都被更新。"

#. type: Plain text
#: en/git-remote.txt:93
#, placeholders:'$GIT_DIR':'$GIT_DIR', priority:220
msgid "In case <old> and <new> are the same, and <old> is a file under `$GIT_DIR/remotes` or `$GIT_DIR/branches`, the remote is converted to the configuration file format."
msgstr "如果 <旧名称 >和< 新名称 >相同，并且< 旧名称 >是 `$GIT_DIR/remotes` 或 `$GIT_DIR/branches` 下的文件，远程将被转换为配置文件格式。"

#. type: Labeled list
#: en/git-remote.txt:94
#, no-wrap, priority:220
msgid "'remove'"
msgstr "'remove'"

#. type: Labeled list
#: en/git-remote.txt:95
#, no-wrap, priority:220
msgid "'rm'"
msgstr "'rm'"

#. type: Plain text
#: en/git-remote.txt:99
#, priority:220
msgid "Remove the remote named <name>. All remote-tracking branches and configuration settings for the remote are removed."
msgstr "删除名为 < 名称 > 的远程。该远程的所有远程跟踪分支和配置设置都被删除。"

#. type: Labeled list
#: en/git-remote.txt:100
#, no-wrap, priority:220
msgid "'set-head'"
msgstr "'set-head'"

#. type: Plain text
#: en/git-remote.txt:109
#, placeholders:'HEAD', priority:220
msgid "Sets or deletes the default branch (i.e. the target of the symbolic-ref `refs/remotes/<name>/HEAD`) for the named remote. Having a default branch for a remote is not required, but allows the name of the remote to be specified in lieu of a specific branch. For example, if the default branch for `origin` is set to `master`, then `origin` may be specified wherever you would normally specify `origin/master`."
msgstr "设置或删除命名远程仓库的默认分支（即符号引用 `refs/remotes/<名称>/HEAD` 的目标）。不需要为远程仓库设置默认分支，但允许指定远程仓库的名称来代替特定分支。例如，如果 `origin` 的默认分支设置为 `master`，则可以在通常指定 `origin/master` 的任何位置指定 `origin`。"

#. type: Plain text
#: en/git-remote.txt:111
#, placeholders:'`-d`':'`--delete`':'HEAD', priority:220
msgid "With `-d` or `--delete`, the symbolic ref `refs/remotes/<name>/HEAD` is deleted."
msgstr "设置 `-d` 或 `--delete` 选项，符号引用 `refs/remotes/<名称>/HEAD` 将被删除."

#. type: Plain text
#: en/git-remote.txt:118
#, placeholders:'`-a`':'`--auto`':'HEAD':'HEAD':'HEAD':'HEAD', priority:220
msgid "With `-a` or `--auto`, the remote is queried to determine its `HEAD`, then the symbolic-ref `refs/remotes/<name>/HEAD` is set to the same branch. e.g., if the remote `HEAD` is pointed at `next`, `git remote set-head origin -a` will set the symbolic-ref `refs/remotes/origin/HEAD` to `refs/remotes/origin/next`. This will only work if `refs/remotes/origin/next` already exists; if not it must be fetched first."
msgstr "使用 `-a` 或 `--auto`，查询远程仓库以确定其 `HEAD`，然后将符号引用 `refs/remotes/<名称>/HEAD` 设置为同一分支。 例如，如果远程 `HEAD` 指向`next`，`git remote set-head origin -a`会将符号引用 `refs/remotes/origin/HEAD` 设置为 `refs/remotes/origin/next`。这仅在 `refs/remotes/origin/next` 已经存在时才有效；如果不是，则必须首先获取它。"

#. type: Plain text
#: en/git-remote.txt:123
#, placeholders:'HEAD':'HEAD', priority:220
msgid "Use `<branch>` to set the symbolic-ref `refs/remotes/<name>/HEAD` explicitly. e.g., `git remote set-head origin master` will set the symbolic-ref `refs/remotes/origin/HEAD` to `refs/remotes/origin/master`. This will only work if `refs/remotes/origin/master` already exists; if not it must be fetched first."
msgstr "使用 `<branch>` 显式地设置符号引用 `refs/remotes/<名称>/HEAD`。例如，`git remote set-head source master` 会将这个符号引用 ` refs/remotes/source/HEAD`设置为 `ref/remotes/source/master`。这只有在 `refs/remote/source/master` 已经存在的情况下才能工作；如果不存在，则必须首先获取它。"

#. type: Labeled list
#: en/git-remote.txt:125
#, no-wrap, priority:220
msgid "'set-branches'"
msgstr "'set-branches'"

#. type: Plain text
#: en/git-remote.txt:130
#, priority:220
msgid "Changes the list of branches tracked by the named remote. This can be used to track a subset of the available remote branches after the initial setup for a remote."
msgstr "改变命名的远程所追踪的分支列表。 这可以用来在最初设置一个远程分支后，追踪一个可用的远程分支子集。"

#. type: Plain text
#: en/git-remote.txt:133
#, placeholders:'`-t`', priority:220
msgid "The named branches will be interpreted as if specified with the `-t` option on the `git remote add` command line."
msgstr "被命名的分支将被解释为在 `git remote add`命令中用 `-t` 选项指定的。"

#. type: Plain text
#: en/git-remote.txt:136
#, placeholders:'`--add`', priority:220
msgid "With `--add`, instead of replacing the list of currently tracked branches, adds to that list."
msgstr "使用 `--add`，不是替换当前跟踪分支列表，而是添加到该列表中。"

#. type: Labeled list
#: en/git-remote.txt:137
#, no-wrap, priority:220
msgid "'get-url'"
msgstr "'get-url'"

#. type: Plain text
#: en/git-remote.txt:141
#, priority:220
msgid "Retrieves the URLs for a remote. Configurations for `insteadOf` and `pushInsteadOf` are expanded here. By default, only the first URL is listed."
msgstr "检索一个远程的 URLs。`insteadOf` 和 `pushInsteadOf` 的配置在此列出。默认情况下，只有第一个 URL 被列出。"

#. type: Plain text
#: en/git-remote.txt:143
#, placeholders:'`--push`', priority:220
msgid "With `--push`, push URLs are queried rather than fetch URLs."
msgstr "使用 `--push`，查询的是推送的URLs，而不是获取的URLs。"

#. type: Plain text
#: en/git-remote.txt:145
#, placeholders:'`--all`', priority:220
msgid "With `--all`, all URLs for the remote will be listed."
msgstr "使用 `--all`选项，远程仓库的所有 URL 将被列出。"

#. type: Labeled list
#: en/git-remote.txt:146
#, no-wrap, priority:220
msgid "'set-url'"
msgstr "'set-url'"

#. type: Plain text
#: en/git-remote.txt:151
#, priority:220
msgid "Changes URLs for the remote. Sets first URL for remote <name> that matches regex <oldurl> (first URL if no <oldurl> is given) to <newurl>. If <oldurl> doesn't match any URL, an error occurs and nothing is changed."
msgstr "改变远程的URLs。将远程 <名称> 的第一个匹配正则表达式 <旧url> 的URL（如果没有给出 <旧url>，则为第一个URL）设置为 <新url>。如果 <旧url> 不匹配任何URL，就会发生错误，并且什么都不会被改变。"

#. type: Plain text
#: en/git-remote.txt:153
#, placeholders:'`--push`', priority:220
msgid "With `--push`, push URLs are manipulated instead of fetch URLs."
msgstr "使用 `--push` ，推送 URLs 被操作，而不是获取 URLs。"

#. type: Plain text
#: en/git-remote.txt:155
#, placeholders:'`--add`', priority:220
msgid "With `--add`, instead of changing existing URLs, new URL is added."
msgstr "使用 `--add`，不改变现有的 URLs，而是添加新的 URL。"

#. type: Plain text
#: en/git-remote.txt:159
#, placeholders:'`--delete`', priority:220
msgid "With `--delete`, instead of changing existing URLs, all URLs matching regex <URL> are deleted for remote <name>. Trying to delete all non-push URLs is an error."
msgstr "使用 `--delete`选项，不是改变现有的 URL，而是删除远程 <名称> 的所有正则匹配 <URL> 的 URL。 试图删除所有非推送 URLs 是错的。"

#. type: Plain text
#: en/git-remote.txt:166
#, priority:220
msgid "Note that the push URL and the fetch URL, even though they can be set differently, must still refer to the same place. What you pushed to the push URL should be what you would see if you immediately fetched from the fetch URL. If you are trying to fetch from one place (e.g. your upstream) and push to another (e.g. your publishing repository), use two separate remotes."
msgstr "请注意，推送 URL 和获取 URL，即使它们的设置不同，也必须指的是同一个地方。 你推送到推送 URL 的内容应该是你立即从获取的 URL 中获取的内容。 如果你试图从一个地方（如你的上游）获取并推送到另一个地方（如你的发布库），请使用两个独立的远程。"

#. type: Labeled list
#: en/git-remote.txt:168
#, no-wrap, priority:220
msgid "'show'"
msgstr "'show'"

#. type: Plain text
#: en/git-remote.txt:171
#, priority:220
msgid "Gives some information about the remote <name>."
msgstr "提供关于远程 <名称> 的一些信息。"

#. type: Plain text
#: en/git-remote.txt:174
#, placeholders:'`-n`':'git ls-remote', priority:220
msgid "With `-n` option, the remote heads are not queried first with `git ls-remote <name>`; cached information is used instead."
msgstr "使用 `-n` 选项，就不会先用 `git ls-remote <名称>` 查询远程头指针，而是使用缓存的信息。"

#. type: Labeled list
#: en/git-remote.txt:175
#, no-wrap, priority:220
msgid "'prune'"
msgstr "'prune'"

#. type: Plain text
#: en/git-remote.txt:182
#, placeholders:'--prune', priority:220
msgid "Deletes stale references associated with <name>. By default, stale remote-tracking branches under <name> are deleted, but depending on global configuration and the configuration of the remote we might even prune local tags that haven't been pushed there. Equivalent to `git fetch --prune <name>`, except that no new references will be fetched."
msgstr "删除与 <名称> 相关的陈旧引用。默认情况下，<名称>下的陈旧远程跟踪分支会被删除，但根据全局配置和远程的配置，我们甚至可能修剪没有被推送到那里的本地标签。相当于 `git fetch --prune <名称>`，只是不会取到新的引用。"

#. type: Plain text
#: en/git-remote.txt:185
#, placeholders:'linkgit:git-fetch[1]', priority:220
msgid "See the PRUNING section of linkgit:git-fetch[1] for what it'll prune depending on various configuration."
msgstr "参见 linkgit:git-fetch[1] 的剪枝部分，了解它将根据不同的配置修剪什么。"

#. type: Plain text
#: en/git-remote.txt:188
#, placeholders:'`--dry-run`', priority:220
msgid "With `--dry-run` option, report what branches would be pruned, but do not actually prune them."
msgstr "使用 `--dry-run` 选项，报告哪些分支将被修剪，但实际上不修剪它们。"

#. type: Labeled list
#: en/git-remote.txt:189
#, no-wrap, priority:220
msgid "'update'"
msgstr "'update'"

#. type: Plain text
#: en/git-remote.txt:197
#, placeholders:'remotes.default':'remotes.default':'linkgit:git-config[1]', priority:220
msgid "Fetch updates for remotes or remote groups in the repository as defined by `remotes.<group>`. If neither group nor remote is specified on the command line, the configuration parameter remotes.default will be used; if remotes.default is not defined, all remotes which do not have the configuration parameter `remote.<name>.skipDefaultUpdate` set to true will be updated. (See linkgit:git-config[1])."
msgstr "为仓库中由 `remotes.<组>` 定义的远程或远程组获取更新。如果在命令行中既没有指定组也没有指定远程，将使用配置参数 remotes.default；如果没有定义 remotes.default，所有没有将配置参数 `remote.<名称>.skipDefaultUpdate` 设置为 true 的远程将被更新。 (参见 linkgit:git-config[1]）。"

#. type: Plain text
#: en/git-remote.txt:199
#, placeholders:'`--prune`', priority:220
msgid "With `--prune` option, run pruning against all the remotes that are updated."
msgstr "使用 `--prune` 选项，对所有被更新的远程进行修剪。"

#. type: Plain text
#: en/git-remote.txt:207
#, placeholders:'remote.origin.url':'remote.origin.fetch':'linkgit:git-config[1]', priority:220
msgid "The remote configuration is achieved using the `remote.origin.url` and `remote.origin.fetch` configuration variables. (See linkgit:git-config[1])."
msgstr "远程配置是通过 `remote.origin.url` 和 `remote.origin.fetch` 配置变量实现的。 (见 linkgit:git-config[1]）。"

#. type: Plain text
#: en/git-remote.txt:212
#, priority:220
msgid "On success, the exit status is `0`."
msgstr "成功的时候，退出状态码为 `0`。"

#. type: Plain text
#: en/git-remote.txt:216
#, priority:220
msgid "When subcommands such as 'add', 'rename', and 'remove' can't find the remote in question, the exit status is `2`. When the remote already exists, the exit status is `3`."
msgstr "当诸如 'add'、'rename' 和 'remove' 等子命令不能找到相关的远程，退出状态码为 `2`。当远程已经存在时，退出状态码是 `3`。"

#. type: Plain text
#: en/git-remote.txt:218
#, priority:220
msgid "On any other error, the exit status may be any other non-zero value."
msgstr "对于其他错误，退出状态码可能是任何其他非零值。"

#. type: Plain text
#: en/git-remote.txt:223
#, priority:220
msgid "Add a new remote, fetch, and check out a branch from it"
msgstr "添加一个新的远程，获取并检出一个分支"

#. type: delimited block -
#: en/git-remote.txt:248
#, ignore-ellipsis, no-wrap, placeholders:'HEAD':'git.kernel.org':'staging.git':'git.kernel.org':'HEAD', priority:220
msgid ""
"$ git remote\n"
"origin\n"
"$ git branch -r\n"
"  origin/HEAD -> origin/master\n"
"  origin/master\n"
"$ git remote add staging git://git.kernel.org/.../gregkh/staging.git\n"
"$ git remote\n"
"origin\n"
"staging\n"
"$ git fetch staging\n"
"...\n"
"From git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/staging\n"
" * [new branch]      master     -> staging/master\n"
" * [new branch]      staging-linus -> staging/staging-linus\n"
" * [new branch]      staging-next -> staging/staging-next\n"
"$ git branch -r\n"
"  origin/HEAD -> origin/master\n"
"  origin/master\n"
"  staging/master\n"
"  staging/staging-linus\n"
"  staging/staging-next\n"
"$ git switch -c staging staging/master\n"
"...\n"
msgstr ""
"$ git remote\n"
"origin\n"
"$ git branch -r\n"
"  origin/HEAD -> origin/master\n"
"  origin/master\n"
"$ git remote add staging git://git.kernel.org/.../gregkh/staging.git\n"
"$ git remote\n"
"origin\n"
"staging\n"
"$ git fetch staging\n"
"...\n"
"From git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/staging\n"
" * [new branch]      master     -> staging/master\n"
" * [new branch]      staging-linus -> staging/staging-linus\n"
" * [new branch]      staging-next -> staging/staging-next\n"
"$ git branch -r\n"
"  origin/HEAD -> origin/master\n"
"  origin/master\n"
"  staging/master\n"
"  staging/staging-linus\n"
"  staging/staging-next\n"
"$ git switch -c staging staging/master\n"
"...\n"

#. type: Plain text
#: en/git-remote.txt:251
#, priority:220
msgid "Imitate 'git clone' but track only selected branches"
msgstr "模仿 'git clone'，但只跟踪选定的分支"

#. type: delimited block -
#: en/git-remote.txt:258
#, no-wrap, placeholders:'git.git', priority:220
msgid ""
"$ mkdir project.git\n"
"$ cd project.git\n"
"$ git init\n"
"$ git remote add -f -t master -m master origin git://example.com/git.git/\n"
"$ git merge origin\n"
msgstr ""
"$ mkdir project.git\n"
"$ cd project.git\n"
"$ git init\n"
"$ git remote add -f -t master -m master origin git://example.com/git.git/\n"
"$ git merge origin\n"

#. type: Plain text
#: en/git-remote.txt:266
#, ignore-same, priority:220
msgid "linkgit:git-fetch[1] linkgit:git-branch[1] linkgit:git-config[1]"
msgstr "linkgit:git-fetch[1] linkgit:git-branch[1] linkgit:git-config[1]"

#. type: Title =
#: en/git-repack.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-repack(1)"
msgstr "git-repack(1)"

#. type: Plain text
#: en/git-repack.txt:7
#, placeholders:'git-repack', priority:100
msgid "git-repack - Pack unpacked objects in a repository"
msgstr "git-repack - 在仓库中打包未打包对象"

#. type: Plain text
#: en/git-repack.txt:13
#, no-wrap, placeholders:'[--window=':'[--depth=':'[--threads=':'[--keep-pack=':'[--write-midx]', priority:100
msgid "'git repack' [-a] [-A] [-d] [-f] [-F] [-l] [-n] [-q] [-b] [-m] [--window=<n>] [--depth=<n>] [--threads=<n>] [--keep-pack=<pack-name>] [--write-midx]\n"
msgstr "'git repack' [-a] [-A] [-d] [-f] [-F] [-l] [-n] [-q] [-b] [-m] [--window=<n>] [--depth=<n>] [--threads=<n>] [--keep-pack=<包名>] [--write-midx]\n"

#. type: Plain text
#: en/git-repack.txt:20
#, priority:100
msgid "This command is used to combine all objects that do not currently reside in a \"pack\", into a pack. It can also be used to re-organize existing packs into a single, more efficient pack."
msgstr "该命令用于将当前不在 “数据包” 中的所有对象合并到一个数据包中。 它还可以用来将现有的数据包重新组织成一个更有效的数据包。"

#. type: Plain text
#: en/git-repack.txt:39
#, placeholders:'`-d`':'--full':'--dangling`', priority:100
msgid "Instead of incrementally packing the unpacked objects, pack everything referenced into a single pack. Especially useful when packing a repository that is used for private development. Use with `-d`. This will clean up the objects that `git prune` leaves behind, but `git fsck --full --dangling` shows as dangling."
msgstr "将所有引用对象打包成一个包，而不是逐步打包未打包的对象。 在打包用于私人开发的版本库时尤其有用。与 `-d` 一起使用。 这将清理 `git prune` 留下的对象，但 `git fsck --full --dangling` 显示为悬空。"

#. type: Plain text
#: en/git-repack.txt:43
#, priority:100
msgid "Note that users fetching over dumb protocols will have to fetch the whole new pack in order to get any contained object, no matter how many other objects in that pack they already have locally."
msgstr "请注意，通过哑协议获取的用户必须获取整个新数据包，才能获得其中包含的任何对象，无论他们本地已经拥有多少该数据包中的其他对象。"

#. type: Plain text
#: en/git-repack.txt:48
#, priority:100
msgid "Promisor packfiles are repacked separately: if there are packfiles that have an associated \".promisor\" file, these packfiles will be repacked into another separate pack, and an empty \".promisor\" file corresponding to the new separate pack will be written."
msgstr "Promisor 包文件将单独重新打包：如果有的包文件有一个相关的 \".promisor \" 文件，这些包文件将被重新打包到另一个单独的包中，并写入一个与新的单独包相对应的空 \".promisor \" 文件。"

#. type: Plain text
#: en/git-repack.txt:59
#, placeholders:'`-a`':'`-d`':'linkgit:git-gc[1]', priority:100
msgid "Same as `-a`, unless `-d` is used. Then any unreachable objects in a previous pack become loose, unpacked objects, instead of being left in the old pack. Unreachable objects are never intentionally added to a pack, even when repacking. This option prevents unreachable objects from being immediately deleted by way of being left in the old pack and then removed. Instead, the loose unreachable objects will be pruned according to normal expiry rules with the next 'git gc' invocation. See linkgit:git-gc[1]."
msgstr "与 `-a` 相同，除非使用了 `-d`。 这样，以前的数据包中任何无法到达的对象都会变成松散的、未打包的对象，而不是留在旧数据包中。 即使在重新打包时，也不会有意将无法到达的对象添加到数据包中。 该选项可以防止无法到达的对象留在旧数据包中后被立即删除。 相反，松散的不可达对象将在下一次调用 'git gc' 时根据正常的过期规则进行修剪。参见 linkgit:git-gc[1]。"

#. type: Plain text
#: en/git-repack.txt:65
#, placeholders:'git prune-packed', priority:100
msgid "After packing, if the newly created packs make some existing packs redundant, remove the redundant packs. Also run 'git prune-packed' to remove redundant loose object files."
msgstr "打包后，如果新创建的包使得某些现有包变得多余，则删除多余的包。 同时运行 'git prune-packed' 删除多余的松散对象文件。"

#. type: Plain text
#: en/git-repack.txt:71
#, placeholders:'`-a`':'`-d`':'linkgit:git-gc[1]':'`-k`', priority:100
msgid "Same as `-a`, unless `-d` is used. Then any unreachable objects are packed into a separate cruft pack. Unreachable objects can be pruned using the normal expiry rules with the next `git gc` invocation (see linkgit:git-gc[1]). Incompatible with `-k`."
msgstr "与 `-a` 相同，除非使用了 `-d`。然后，任何无法访问的对象都会被打包到一个单独的压缩包中。无法访问的对象可以在下一次调用 `git gc` 时使用正常的过期规则进行剪枝（参见 linkgit:git-gc[1]）。与 `-k` 不兼容。"

#. type: Plain text
#: en/git-repack.txt:76
#, placeholders:'`--cruft', priority:100
msgid "Expire unreachable objects older than `<approxidate>` immediately instead of waiting for the next `git gc` invocation. Only useful with `--cruft -d`."
msgstr "立即过期超过 `<approxidate>` 的不可访问对象，而不是等待下一次调用 `git gc`。 仅在使用 `--cruft -d` 选项时有用。"

#. type: Plain text
#: en/git-repack.txt:87
#, placeholders:'`--cruft', priority:100
msgid "Repack cruft objects into packs as large as `<n>` bytes before creating new packs. As long as there are enough cruft packs smaller than `<n>`, repacking will cause a new cruft pack to be created containing objects from any combined cruft packs, along with any new unreachable objects. Cruft packs larger than `<n>` will not be modified. When the new cruft pack is larger than `<n>` bytes, it will be split into multiple packs, all of which are guaranteed to be at most `<n>` bytes in size. Only useful with `--cruft -d`."
msgstr "在创建新的数据包之前，会先将 Cruft 物件重新打包到大小为 `<n>` 字节的数据包中。只要有足够的小于 `<n>` 的 Cruft 包，重新打包将导致创建一个新的 Cruft 包，其中包含来自任何合并 Cruft 包的对象，以及任何新的无法访问的对象。大于 `<n>` 的压缩包不会被修改。当新的 Cruft 包大于 `<n>` 字节时，它将被拆分成多个包，所有包的大小保证最多为 `<n>` 字节。仅在使用 `--cruft -d` 时有用。"

#. type: Labeled list
#: en/git-repack.txt:88
#, no-wrap, placeholders:'--expire-to=', priority:100
msgid "--expire-to=<dir>"
msgstr "--expire-to=<目录>"

#. type: Plain text
#: en/git-repack.txt:93
#, placeholders:'`--cruft', priority:100
msgid "Write a cruft pack containing pruned objects (if any) to the directory `<dir>`. This option is useful for keeping a copy of any pruned objects in a separate directory as a backup. Only useful with `--cruft -d`."
msgstr "将包含修剪对象（如果有）的压缩包写入目录 `<路径>`。该选项可用于在单独的目录中保留剪枝对象的副本作为备份。仅在使用 `--cruft -d` 时有用。"

#. type: Plain text
#: en/git-repack.txt:97
#, placeholders:'`--local`':'git pack-objects':'linkgit:git-pack-objects[1]', priority:100
msgid "Pass the `--local` option to 'git pack-objects'. See linkgit:git-pack-objects[1]."
msgstr "向 'git pack-objects' 传递 `--local` 选项。参见 linkgit:git-pack-objects[1]。"

#. type: Plain text
#: en/git-repack.txt:101
#, placeholders:'`--no-reuse-delta`':'git-pack-objects':'linkgit:git-pack-objects[1]', priority:100
msgid "Pass the `--no-reuse-delta` option to `git-pack-objects`, see linkgit:git-pack-objects[1]."
msgstr "向 `git-pack-objects` 传递 `--no-reuse-delta` 选项，参见 linkgit:git-pack-objects[1]。"

#. type: Plain text
#: en/git-repack.txt:105
#, placeholders:'`--no-reuse-object`':'git-pack-objects':'linkgit:git-pack-objects[1]', priority:100
msgid "Pass the `--no-reuse-object` option to `git-pack-objects`, see linkgit:git-pack-objects[1]."
msgstr "向 `git-pack-objects` 传递 `--no-reuse-object` 选项，参见 linkgit:git-pack-objects[1]。"

#. type: Plain text
#: en/git-repack.txt:110
#, placeholders:'`-q`':'git pack-objects':'linkgit:git-pack-objects[1]', priority:100
msgid "Show no progress over the standard error stream and pass the `-q` option to 'git pack-objects'. See linkgit:git-pack-objects[1]."
msgstr "在标准错误流中不显示进度，并向 'git pack-objects' 传递 `-q` 选项。参见 linkgit:git-pack-objects[1]。"

#. type: Plain text
#: en/git-repack.txt:117
#, placeholders:'git update-server-info':'linkgit:git-update-server-info[1]', priority:100
msgid "Do not update the server information with 'git update-server-info'. This option skips updating local catalog files needed to publish this repository (or a direct copy of it) over HTTP or FTP. See linkgit:git-update-server-info[1]."
msgstr "不使用 'git update-server-info' 更新服务器信息。 该选项会跳过更新通过 HTTP 或 FTP 发布该仓库（或其直接副本）所需的本地目录文件。 参见 linkgit:git-update-server-info[1]。"

#. type: Plain text
#: en/git-repack.txt:127
#, placeholders:'`--window`':'`--depth`', priority:100
msgid "These two options affect how the objects contained in the pack are stored using delta compression. The objects are first internally sorted by type, size and optionally names and compared against the other objects within `--window` to see if using delta compression saves space. `--depth` limits the maximum delta depth; making it too deep affects the performance on the unpacker side, because delta data needs to be applied that many times to get to the necessary object."
msgstr "这两个选项会影响如何使用 delta 压缩来存储数据包中的对象。对象首先会按类型、大小和可选名称进行内部排序，然后与 `--window`中的其他对象进行比较，以确定使用 delta 压缩是否能节省空间。`--depth` 限制了 delta 深度的最大值；过深会影响解包器的性能，因为需要多次应用 delta 数据才能找到所需的对象。"

#. type: Plain text
#: en/git-repack.txt:133
#, placeholders:'git pack-objects', priority:100
msgid "This option is passed through to `git pack-objects`."
msgstr "该选项将传递给 `git pack-objects`。"

#. type: Plain text
#: en/git-repack.txt:146
#, placeholders:'`--window`':'`--window-memory=0`':'pack.windowMemory':'linkgit:git-pack-objects[1]', priority:100
msgid "This option provides an additional limit on top of `--window`; the window size will dynamically scale down so as to not take up more than '<n>' bytes in memory. This is useful in repositories with a mix of large and small objects to not run out of memory with a large window, but still be able to take advantage of the large window for the smaller objects. The size can be suffixed with \"k\", \"m\", or \"g\". `--window-memory=0` makes memory usage unlimited. The default is taken from the `pack.windowMemory` configuration variable. Note that the actual memory usage will be the limit multiplied by the number of threads used by linkgit:git-pack-objects[1]."
msgstr "该选项在 `--window` 的基础上提供了额外的限制；窗口大小会动态缩减，以避免占用超过 '<n>' 字节的内存。 这对于大小对象混杂的版本库非常有用，既不会因为窗口过大而耗尽内存，又能利用大窗口处理小对象。 大小后缀可以是 \"k\"、\"m\" 或 \"g\"。`--window-memory=0` 表示内存使用不受限制。 默认值取自 `pack.windowMemory` 配置变量。 请注意，实际内存使用量将是 linkgit:git-pack-objects[1] 使用的线程数乘以限制值。"

#. type: Plain text
#: en/git-repack.txt:156
#, placeholders:'pack.packSizeLimit':'pack.packSizeLimit', priority:100
msgid "Maximum size of each output pack file. The size can be suffixed with \"k\", \"m\", or \"g\". The minimum size allowed is limited to 1 MiB. If specified, multiple packfiles may be created, which also prevents the creation of a bitmap index. The default is unlimited, unless the config variable `pack.packSizeLimit` is set. Note that this option may result in a larger and slower repository; see the discussion in `pack.packSizeLimit`."
msgstr "每个输出包文件的最大大小。大小可以后缀为 \"k\"、\"m\" 或 \"g\"。允许的最小大小限制为 1MB。 如果指定，可能会创建多个数据包文件，这也会阻止位图索引的创建。 默认值是无限大，除非设置了配置变量 `pack.packSizeLimit`。请注意，该选项可能会导致版本库变大、变慢；请参阅 `pack.packSizeLimit` 中的讨论。"

#. type: Plain text
#: en/git-repack.txt:168
#, placeholders:'`-a`':'`-d`':'`--no-write-bitmap-index`':'repack.writebitmaps':'linkgit:git-rev-list[1]', priority:100
msgid "Remove objects matching the filter specification from the resulting packfile and put them into a separate packfile. Note that objects used in the working directory are not filtered out. So for the split to fully work, it's best to perform it in a bare repo and to use the `-a` and `-d` options along with this option. Also `--no-write-bitmap-index` (or the `repack.writebitmaps` config option set to `false`) should be used otherwise writing bitmap index will fail, as it supposes a single packfile containing all the objects. See linkgit:git-rev-list[1] for valid `<filter-spec>` forms."
msgstr "从生成的包文件中移除符合过滤规范的对象，并将其放入一个单独的包文件中。请注意，工作目录中使用的对象不会被过滤掉。因此，要使拆分完全有效，最好在裸 仓库中执行拆分，并将 `-a` 和 `-d` 选项与此选项一起使用。 此外，还应使用 `--no-write-bitmap-index`（或将 `repack.writebitmaps` 配置选项设为 `false`），否则写入位图索引会失败，因为它假定只有一个包文件包含所有对象。有关有效的 `<filter-spec>` 形式，请参见 linkgit:git-rev-list[1]。"

#. type: Labeled list
#: en/git-repack.txt:169
#, no-wrap, placeholders:'--filter-to=', priority:100
msgid "--filter-to=<dir>"
msgstr "--filter-to=<目录>"

#. type: Plain text
#: en/git-repack.txt:179
#, placeholders:'`--filter`':'linkgit:gitrepository-layout[5]', priority:100
msgid "Write the pack containing filtered out objects to the directory `<dir>`. Only useful with `--filter`. This can be used for putting the pack on a separate object directory that is accessed through the Git alternates mechanism. **WARNING:** If the packfile containing the filtered out objects is not accessible, the repo can become corrupt as it might not be possible to access the objects in that packfile. See the `objects` and `objects/info/alternates` sections of linkgit:gitrepository-layout[5]."
msgstr "将包含筛选出的对象的数据包写入目录 `<目录>`。仅在使用 `--filter` 时有用。这可用于将数据包放在通过 Git 替代机制访问的单独对象目录中。**警告：** 如果包含过滤掉的对象的包文件无法访问，则 repo 可能会损坏，因为可能无法访问该包文件的对象。请参阅 linkgit:gitrepository-layout[5] 的 `objects` 和 `objects/info/alternates` 部分。"

#. type: Labeled list
#: en/git-repack.txt:181
#, ignore-same, no-wrap, priority:100
msgid "--write-bitmap-index"
msgstr "--write-bitmap-index"

#. type: Plain text
#: en/git-repack.txt:188
#, placeholders:'`-a`':'`-A`':'`-m`':'repack.writeBitmaps', priority:100
msgid "Write a reachability bitmap index as part of the repack. This only makes sense when used with `-a`, `-A` or `-m`, as the bitmaps must be able to refer to all reachable objects. This option overrides the setting of `repack.writeBitmaps`. This option has no effect if multiple packfiles are created, unless writing a MIDX (in which case a multi-pack bitmap is created)."
msgstr "作为重新打包的一部分，写入可达性位图索引。这只有在与 `-a`、`-A` 或 `-m` 参数一起使用时才有意义，因为位图必须能够指向所有可达对象。此选项会覆盖 `repack.writeBitmaps` 的设置。如果创建了多个包文件，此选项将不起作用，除非正在写入一个 MIDX（在这种情况下将创建一个多包位图）。"

#. type: Labeled list
#: en/git-repack.txt:189
#, ignore-same, no-wrap, priority:100
msgid "--pack-kept-objects"
msgstr "--pack-kept-objects"

#. type: Plain text
#: en/git-repack.txt:197
#, placeholders:'`-b`':'repack.writeBitmaps', priority:100
msgid "Include objects in `.keep` files when repacking. Note that we still do not delete `.keep` packs after `pack-objects` finishes. This means that we may duplicate objects, but this makes the option safe to use when there are concurrent pushes or fetches. This option is generally only useful if you are writing bitmaps with `-b` or `repack.writeBitmaps`, as it ensures that the bitmapped packfile has the necessary objects."
msgstr "重新打包时将对象包含在 `.keep` 文件中。 请注意，在 `pack-objects` 完成后，我们仍不会删除 `.keep` 包。 这意味着我们可能会重复对象，但这使得该选项在有并发推送或获取时可以安全使用。 通常只有在使用 `-b` 或 `repack.writeBitmaps` 编写位图时，该选项才会有用，因为它可以确保位图包文件中包含必要的对象。"

#. type: Plain text
#: en/git-repack.txt:204
#, priority:100
msgid "Exclude the given pack from repacking. This is the equivalent of having `.keep` file on the pack. `<pack-name>` is the pack file name without leading directory (e.g. `pack-123.pack`). The option can be specified multiple times to keep multiple packs."
msgstr "将给定的软件包排除在重新打包之外。这相当于在软件包中加入 `.keep` 文件。`<包名>`是软件包文件名，不含前导目录（如 `pack-123.pack`）。 可多次指定该选项以保留多个软件包。"

#. type: Labeled list
#: en/git-repack.txt:205
#, no-wrap, placeholders:'--unpack-unreachable=', priority:100
msgid "--unpack-unreachable=<when>"
msgstr "--unpack-unreachable=<何时>"

#. type: Plain text
#: en/git-repack.txt:210
#, priority:100
msgid "When loosening unreachable objects, do not bother loosening any objects older than `<when>`. This can be used to optimize out the write of any objects that would be immediately pruned by a follow-up `git prune`."
msgstr "当松动无法访问的对象时，不要费心松动任何早于 `<时候>`的对象。这可以用来优化写入对象的过程，因为后续的 `git prune` 会立即剪枝这些对象。"

#. type: Plain text
#: en/git-repack.txt:217
#, priority:100
msgid "When used with `-ad`, any unreachable objects from existing packs will be appended to the end of the packfile instead of being removed. In addition, any unreachable loose objects will be packed (and their loose counterparts removed)."
msgstr "与 `-ad` 一起使用时，现有数据包中任何无法访问的对象将被附加到数据包文件的末尾，而不是被移除。此外，任何无法访问的松散对象也将被打包（并移除其松散对应对象）。"

#. type: Plain text
#: en/git-repack.txt:222
#, placeholders:'`--delta-islands`':'git-pack-objects':'linkgit:git-pack-objects[1]', priority:100
msgid "Pass the `--delta-islands` option to `git-pack-objects`, see linkgit:git-pack-objects[1]."
msgstr "向 `git-pack-objects` 传递 `--delta-islands` 选项，参见 linkgit:git-pack-objects[1]。"

#. type: Labeled list
#: en/git-repack.txt:223
#, no-wrap, priority:100
msgid "-g<factor>"
msgstr "-g<条件>"

#. type: Labeled list
#: en/git-repack.txt:224
#, no-wrap, placeholders:'--geometric=', priority:100
msgid "--geometric=<factor>"
msgstr "--geometric=<条件>"

#. type: Plain text
#: en/git-repack.txt:228
#, priority:100
msgid "Arrange resulting pack structure so that each successive pack contains at least `<factor>` times the number of objects as the next-largest pack."
msgstr "排列生成的数据包结构，使每个连续的数据包包含的对象数量至少是下一个最大数据包的 `<条件>` 倍。"

#. type: Plain text
#: en/git-repack.txt:234
#, priority:100
msgid "`git repack` ensures this by determining a \"cut\" of packfiles that need to be repacked into one in order to ensure a geometric progression. It picks the smallest set of packfiles such that as many of the larger packfiles (by count of objects contained in that pack) may be left intact."
msgstr "`git repack` 通过 “切割” 需要重新打包成一个的文件包来确保几何级数的增长。它会挑选最小的文件包集合，以便尽可能多地保留较大的文件包（按该文件包所含对象的数量计算）。"

#. type: Plain text
#: en/git-repack.txt:239
#, priority:100
msgid "Unlike other repack modes, the set of objects to pack is determined uniquely by the set of packs being \"rolled-up\"; in other words, the packs determined to need to be combined in order to restore a geometric progression."
msgstr "与其他重新包装模式不同的是，需要包装的对象集是由 “卷起” 的包装集唯一决定的；换句话说，为了恢复几何级数，确定需要组合的包装。"

#. type: Plain text
#: en/git-repack.txt:242
#, priority:100
msgid "Loose objects are implicitly included in this \"roll-up\", without respect to their reachability. This is subject to change in the future."
msgstr "松散对象隐含在此 “滚动” 中，而不考虑它们的可达性。今后可能会有变化。"

#. type: Plain text
#: en/git-repack.txt:246
#, placeholders:'linkgit:git-multi-pack-index[1]', priority:100
msgid "When writing a multi-pack bitmap, `git repack` selects the largest resulting pack as the preferred pack for object selection by the MIDX (see linkgit:git-multi-pack-index[1])."
msgstr "在编写多包位图时，`git repack` 会选择生成的最大包作为 MIDX 选择对象的首选包（参见 linkgit:git-multi-pack-index[1]）。"

#. type: Labeled list
#: en/git-repack.txt:248
#, ignore-same, no-wrap, priority:100
msgid "--write-midx"
msgstr "--write-midx"

#. type: Plain text
#: en/git-repack.txt:251
#, placeholders:'linkgit:git-multi-pack-index[1]', priority:100
msgid "Write a multi-pack index (see linkgit:git-multi-pack-index[1]) containing the non-redundant packs."
msgstr "编写包含非冗余软件包的多软件包索引（参见 linkgit:git-multi-pack-index[1]）。"

#. type: Plain text
#: en/git-repack.txt:267
#, placeholders:'`--delta-base-offset`':'git pack-objects', priority:100
msgid "By default, the command passes `--delta-base-offset` option to 'git pack-objects'; this typically results in slightly smaller packs, but the generated packs are incompatible with versions of Git older than version 1.4.4. If you need to share your repository with such ancient Git versions, either directly or via the dumb http protocol, then you need to set the configuration variable `repack.UseDeltaBaseOffset` to \"false\" and repack. Access from old Git versions over the native protocol is unaffected by this option as the conversion is performed on the fly as needed in that case."
msgstr "默认情况下，该命令会在 'git pack-objects' 中传递 `--delta-base-offset` 选项；这通常会导致生成的数据包略小，但生成的数据包与版本 1.4.4 以上的 Git 版本不兼容。如果你需要直接或通过笨重的 http 协议与这些古老的 Git 版本共享你的仓库，那么你需要将配置变量 `repack.UseDeltaBaseOffset` 设为 \"false\"，然后重新打包。通过本地协议访问旧版本的 Git 不受此选项影响，因为在这种情况下，转换是根据需要即时进行的。"

#. type: Plain text
#: en/git-repack.txt:271
#, placeholders:'core.bigFileThreshold', priority:100
msgid "Delta compression is not used on objects larger than the `core.bigFileThreshold` configuration variable and on files with the attribute `delta` set to false."
msgstr "对于大于 `core.bigFileThreshold` 配置变量的对象和属性 `delta` 设置为 false 的文件，不会使用 Delta 压缩。"

#. type: Plain text
#: en/git-repack.txt:276
#, ignore-same, priority:100
msgid "linkgit:git-pack-objects[1] linkgit:git-prune-packed[1]"
msgstr "linkgit:git-pack-objects[1] linkgit:git-prune-packed[1]"

#. type: Title =
#: en/git-replace.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-replace(1)"
msgstr "git-replace(1)"

#. type: Plain text
#: en/git-replace.txt:7
#, placeholders:'git-replace', priority:100
msgid "git-replace - Create, list, delete refs to replace objects"
msgstr "git-replace - 创建、列出、删除用于替换对象的引用"

#. type: Plain text
#: en/git-replace.txt:17
#, ignore-ellipsis, no-wrap, placeholders:'--edit':'--graft':'--convert-graft-file':'[--format=', priority:100
msgid ""
"'git replace' [-f] <object> <replacement>\n"
"'git replace' [-f] --edit <object>\n"
"'git replace' [-f] --graft <commit> [<parent>...]\n"
"'git replace' [-f] --convert-graft-file\n"
"'git replace' -d <object>...\n"
"'git replace' [--format=<format>] [-l [<pattern>]]\n"
msgstr ""
"'git replace' [-f] <对象> <更换>\n"
"'git replace' [-f] --edit <对象>\n"
"'git replace' [-f] --graft <提交> [<父>...]\n"
"'git replace' [-f] --convert-graft-file\n"
"'git replace' -d <对象>...\n"
"'git replace' [--format=<格式>] [-l [<模式>]]\n"

#. type: Plain text
#: en/git-replace.txt:21
#, priority:100
msgid "Adds a 'replace' reference in `refs/replace/` namespace."
msgstr "在 `refs/replace/` 命名空间中添加 'replace' 引用。"

#. type: Plain text
#: en/git-replace.txt:25
#, priority:100
msgid "The name of the 'replace' reference is the SHA-1 of the object that is replaced. The content of the 'replace' reference is the SHA-1 of the replacement object."
msgstr "'replace' 引用的名称是被替换对象的 SHA-1 'replace' 引用的内容是被替换对象的 SHA-1 值。"

#. type: Plain text
#: en/git-replace.txt:28
#, placeholders:'`-f`', priority:100
msgid "The replaced object and the replacement object must be of the same type. This restriction can be bypassed using `-f`."
msgstr "被替换对象和替换对象必须是同一类型。 使用 `-f` 可以绕过这一限制。"

#. type: Plain text
#: en/git-replace.txt:30
#, placeholders:'`-f`', priority:100
msgid "Unless `-f` is given, the 'replace' reference must not yet exist."
msgstr "除非给出 `-f`，否则 'replace' 引用必须不存在。"

#. type: Plain text
#: en/git-replace.txt:33
#, priority:100
msgid "There is no other restriction on the replaced and replacement objects. Merge commits can be replaced by non-merge commits and vice versa."
msgstr "被替换和替换对象没有其他限制。 合并提交可以被非合并提交替换，反之亦然。"

#. type: Plain text
#: en/git-replace.txt:37
#, priority:100
msgid "Replacement references will be used by default by all Git commands except those doing reachability traversal (prune, pack transfer and fsck)."
msgstr "除了进行可达性遍历的命令（剪枝、打包转移和 fsck）外，所有 Git 命令都将默认使用替换引用。"

#. type: Plain text
#: en/git-replace.txt:40
#, placeholders:'`--no-replace-objects`', priority:100
msgid "It is possible to disable the use of replacement references for any command using the `--no-replace-objects` option just after 'git'."
msgstr "使用 'git' 后面的 `--no-replace-objects` 选项，可以禁止在任何命令中使用替换引用。"

#. type: Plain text
#: en/git-replace.txt:42
#, priority:100
msgid "For example if commit 'foo' has been replaced by commit 'bar':"
msgstr "例如，如果提交 'foo' 已被提交 'bar' 取代："

#. type: delimited block -
#: en/git-replace.txt:45
#, no-wrap, placeholders:'--no-replace-objects', priority:100
msgid "$ git --no-replace-objects cat-file commit foo\n"
msgstr "$ git --no-replace-objects cat-file commit foo\n"

#. type: Plain text
#: en/git-replace.txt:48
#, priority:100
msgid "shows information about commit 'foo', while:"
msgstr "显示有关提交 'foo' 的信息，而："

#. type: delimited block -
#: en/git-replace.txt:51
#, no-wrap, placeholders:'git cat-file', priority:100
msgid "$ git cat-file commit foo\n"
msgstr "$ git cat-file commit foo\n"

#. type: Plain text
#: en/git-replace.txt:54
#, priority:100
msgid "shows information about commit 'bar'."
msgstr "显示有关提交 'bar' 的信息。"

#. type: Plain text
#: en/git-replace.txt:57
#, placeholders:'GIT_NO_REPLACE_OBJECTS':'`--no-replace-objects`', priority:100
msgid "The `GIT_NO_REPLACE_OBJECTS` environment variable can be set to achieve the same effect as the `--no-replace-objects` option."
msgstr "可以设置 `GIT_NO_REPLACE_OBJECTS` 环境变量，以达到与 `--no-replace-objects` 选项相同的效果。"

#. type: Plain text
#: en/git-replace.txt:64
#, priority:100
msgid "If an existing replace ref for the same object exists, it will be overwritten (instead of failing)."
msgstr "如果同一对象已有一个替换引用，它将被覆盖（而不是失效）。"

#. type: Plain text
#: en/git-replace.txt:68
#, priority:100
msgid "Delete existing replace refs for the given objects."
msgstr "删除给定对象的现有替换引用。"

#. type: Labeled list
#: en/git-replace.txt:69
#, no-wrap, placeholders:'--edit', priority:100
msgid "--edit <object>"
msgstr "--edit <对象>"

#. type: Plain text
#: en/git-replace.txt:77
#, placeholders:'linkgit:git-var[1]', priority:100
msgid "Edit an object's content interactively. The existing content for <object> is pretty-printed into a temporary file, an editor is launched on the file, and the result is parsed to create a new object of the same type as <object>. A replacement ref is then created to replace <object> with the newly created object. See linkgit:git-var[1] for details about how the editor will be chosen."
msgstr "交互式编辑对象的内容。<对象> 的现有内容会被漂亮地打印到一个临时文件中，然后在该文件上启动编辑器，并对结果进行解析，以创建一个与 <对象> 类型相同的新对象。然后创建一个替换引用，用新创建的对象替换 <对象>。关于如何选择编辑器，详见 linkgit:git-var[1]。"

#. type: Plain text
#: en/git-replace.txt:85
#, priority:100
msgid "When editing, provide the raw object contents rather than pretty-printed ones. Currently this only affects trees, which will be shown in their binary form. This is harder to work with, but can help when repairing a tree that is so corrupted it cannot be pretty-printed. Note that you may need to configure your editor to cleanly read and write binary data."
msgstr "编辑时，请提供原始对象内容，而不是格式化打印的内容。目前这只影响目录树，因为目录树将以二进制形式显示。这比较难处理，但在修复已损坏到无法格式化打印的目录树时可以有所帮助。需要注意的是，你可能需要对编辑器进行配置，以便干净利落地读写二进制数据。"

#. type: Labeled list
#: en/git-replace.txt:86
#, ignore-ellipsis, no-wrap, placeholders:'--graft', priority:100
msgid "--graft <commit> [<parent>...]"
msgstr "--graft <提交> [<父提交>...]"

#. type: Plain text
#: en/git-replace.txt:93
#, ignore-ellipsis, placeholders:'`--convert-graft-file`':'$GIT_DIR', priority:100
msgid "Create a graft commit. A new commit is created with the same content as <commit> except that its parents will be [<parent>...] instead of <commit>'s parents. A replacement ref is then created to replace <commit> with the newly created commit. Use `--convert-graft-file` to convert a `$GIT_DIR/info/grafts` file and use replace refs instead."
msgstr "创建嫁接提交。新创建的提交内容与 <提交> 相同，只是它的父提交将是 [<父提交>...]，而不是 <提交> 的父提交。然后会创建一个替换引用，用新创建的提交替换 <提交>。使用 `--convert-graft-file`，转换 `$GIT_DIR/info/grafts` 文件并使用替换引用代替。"

#. type: Labeled list
#: en/git-replace.txt:94
#, ignore-same, no-wrap, priority:100
msgid "--convert-graft-file"
msgstr "--convert-graft-file"

#. type: Plain text
#: en/git-replace.txt:98
#, placeholders:'$GIT_DIR', priority:100
msgid "Creates graft commits for all entries in `$GIT_DIR/info/grafts` and deletes that file upon success. The purpose is to help users with transitioning off of the now-deprecated graft file."
msgstr "为 `$GIT_DIR/info/grafts` 中的所有条目创建嫁接提交，并在成功后删除该文件。目的是帮助用户从现已过时的 graft 文件过渡。"

#. type: Labeled list
#: en/git-replace.txt:99
#, no-wrap, priority:100
msgid "-l <pattern>"
msgstr "-l <模式>"

#. type: Labeled list
#: en/git-replace.txt:100
#, no-wrap, placeholders:'--list', priority:100
msgid "--list <pattern>"
msgstr "--list <模式>"

#. type: Plain text
#: en/git-replace.txt:105
#, priority:100
msgid "List replace refs for objects that match the given pattern (or all if no pattern is given). Typing \"git replace\" without arguments, also lists all replace refs."
msgstr "列出与给定模式匹配的对象的替换反射（如果没有给定模式，则列出所有对象）。 输入不带参数的 \"git replace\"，也会列出所有替换反射。"

#. type: Plain text
#: en/git-replace.txt:110
#, priority:100
msgid "When listing, use the specified <format>, which can be one of 'short', 'medium' and 'long'. When omitted, the format defaults to 'short'."
msgstr "列表时，使用指定的 <格式>，它可以是 'short'（短）、'medium'（中）和 'long'（长）格式之一。如果省略，格式默认为 'short'（短）。"

#. type: Title -
#: en/git-replace.txt:112
#, no-wrap, priority:100
msgid "FORMATS"
msgstr "格式"

#. type: Plain text
#: en/git-replace.txt:115
#, priority:100
msgid "The following formats are available:"
msgstr "提供以下格式："

#. type: Plain text
#: en/git-replace.txt:117
#, priority:100
msgid "'short':"
msgstr "'short'："

#. type: Plain text
#: en/git-replace.txt:118
#, priority:100
msgid "<replaced-sha1>"
msgstr "<替换后的 sha1>"

#. type: Plain text
#: en/git-replace.txt:119
#, priority:100
msgid "'medium':"
msgstr "'medium':"

#. type: Plain text
#: en/git-replace.txt:120
#, priority:100
msgid "<replaced-sha1> -> <replacement-sha1>"
msgstr "<replaced-sha1> -> <replacement-sha1>"

#. type: Plain text
#: en/git-replace.txt:121
#, priority:100
msgid "'long':"
msgstr "'long':"

#. type: Plain text
#: en/git-replace.txt:122
#, priority:100
msgid "<replaced-sha1> (<replaced-type>) -> <replacement-sha1> (<replacement-type>)"
msgstr "<replaced-sha1> (<replaced-type>) -> <replacement-sha1> (<replacement-type>)"

#. type: Title -
#: en/git-replace.txt:124
#, no-wrap, priority:100
msgid "CREATING REPLACEMENT OBJECTS"
msgstr "创建替换对象"

#. type: Plain text
#: en/git-replace.txt:131
#, placeholders:'linkgit:git-hash-object[1]':'linkgit:git-rebase[1]':'https://github.com/newren/git-filter-repo[':'git-filter-repo':'`--edit`', priority:100
msgid "linkgit:git-hash-object[1], linkgit:git-rebase[1], and https://github.com/newren/git-filter-repo[git-filter-repo], among other git commands, can be used to create replacement objects from existing objects. The `--edit` option can also be used with 'git replace' to create a replacement object by editing an existing object."
msgstr "linkgit:git-hash-object[1]、linkgit:git-rebase[1]、https://github.com/newren/git-filter-repo[git-filter-repo] 等 git 命令可以用来从现有对象创建替换对象。此外，`--edit` 选项也可以与 'git replace' 一起使用，通过编辑现有对象来创建替换对象。"

#. type: Plain text
#: en/git-replace.txt:137
#, priority:100
msgid "If you want to replace many blobs, trees or commits that are part of a string of commits, you may just want to create a replacement string of commits and then only replace the commit at the tip of the target string of commits with the commit at the tip of the replacement string of commits."
msgstr "如果您想替换属于提交串一部分的许多二进制对象、目录树或提交，您可能只想创建一个替换提交串，然后只用替换提交串顶端的提交替换目标提交串顶端的提交。"

#. type: Plain text
#: en/git-replace.txt:144
#, placeholders:'--hard`', priority:100
msgid "Comparing blobs or trees that have been replaced with those that replace them will not work properly. And using `git reset --hard` to go back to a replaced commit will move the branch to the replacement commit instead of the replaced commit."
msgstr "比较被替换的二进制对象或目录树与替换它们的二进制对象或目录树将无法正常工作。使用 `git reset --hard` 回到被替换的提交，会将分支移动到替换提交，而不是被替换的提交。"

#. type: Plain text
#: en/git-replace.txt:147
#, placeholders:'git rev-list', priority:100
msgid "There may be other problems when using 'git rev-list' related to pending objects."
msgstr "使用 'git rev-list' 时，可能会遇到与待处理对象相关的其他问题。"

#. type: Plain text
#: en/git-replace.txt:158
#, placeholders:'linkgit:git-hash-object[1]':'linkgit:git-rebase[1]':'linkgit:git-tag[1]':'linkgit:git-commit[1]':'linkgit:git-var[1]':'linkgit:git[1]':'https://github.com/newren/git-filter-repo[':'git-filter-repo', priority:100
msgid "linkgit:git-hash-object[1] linkgit:git-rebase[1] linkgit:git-tag[1] linkgit:git-branch[1] linkgit:git-commit[1] linkgit:git-var[1] linkgit:git[1] https://github.com/newren/git-filter-repo[git-filter-repo]"
msgstr "linkgit:git-hash-object[1] linkgit:git-rebase[1] linkgit:git-tag[1] linkgit:git-branch[1] linkgit:git-commit[1] linkgit:git-var[1] linkgit:git[1] https://github.com/newren/git-filter-repo[git-filter-repo]"

#. type: Title =
#: en/git-request-pull.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-request-pull(1)"
msgstr "git-request-pull(1)"

#. type: Plain text
#: en/git-request-pull.txt:7
#, placeholders:'git-request-pull', priority:100
msgid "git-request-pull - Generates a summary of pending changes"
msgstr "git-request-pull - 生成待处理更改的摘要"

#. type: Plain text
#: en/git-request-pull.txt:12
#, no-wrap, placeholders:'git request-pull', priority:100
msgid "'git request-pull' [-p] <start> <URL> [<end>]\n"
msgstr "'git request-pull' [-p] <开始> <URL> [<结束>］\n"

#. type: Plain text
#: en/git-request-pull.txt:20
#, priority:100
msgid "Generate a request asking your upstream project to pull changes into their tree. The request, printed to the standard output, begins with the branch description, summarizes the changes, and indicates from where they can be pulled."
msgstr "生成一个请求，要求你的上游项目将变更拉入他们的分支树。 该请求会打印到标准输出中，以分支描述开头，总结变更内容，并指出可以从哪里拉取变更。"

#. type: Plain text
#: en/git-request-pull.txt:25
#, priority:100
msgid "The upstream project is expected to have the commit named by `<start>` and the output asks it to integrate the changes you made since that commit, up to the commit named by `<end>`, by visiting the repository named by `<URL>`."
msgstr "上游项目预计会有以 `<开始>` 命名的提交，输出会要求它通过访问以 `<URL>` 命名的仓库，整合您自该提交后所做的更改，直至以 `<结束>` 命名的提交。"

#. type: Plain text
#: en/git-request-pull.txt:31
#, priority:100
msgid "Include patch text in the output."
msgstr "在输出中包含补丁文本。"

#. type: Labeled list
#: en/git-request-pull.txt:32
#, no-wrap, priority:100
msgid "<start>"
msgstr "<起始>"

#. type: Plain text
#: en/git-request-pull.txt:35
#, priority:100
msgid "Commit to start at. This names a commit that is already in the upstream history."
msgstr "从提交开始。 这将命名一个已在上游历史中的提交。"

#. type: Labeled list
#: en/git-request-pull.txt:36
#, no-wrap, priority:100
msgid "<URL>"
msgstr "<URL>"

#. type: Plain text
#: en/git-request-pull.txt:38
#, priority:100
msgid "The repository URL to be pulled from."
msgstr "要提取的仓库 URL。"

#. type: Labeled list
#: en/git-request-pull.txt:39
#, no-wrap, priority:100
msgid "<end>"
msgstr "<终止>"

#. type: Plain text
#: en/git-request-pull.txt:42
#, placeholders:'HEAD', priority:100
msgid "Commit to end at (defaults to HEAD). This names the commit at the tip of the history you are asking to be pulled."
msgstr "提交结束于（默认为 HEAD）。 这将命名您要求提取的历史最前沿的提交。"

#. type: Plain text
#: en/git-request-pull.txt:47
#, priority:100
msgid "When the repository named by `<URL>` has the commit at a tip of a ref that is different from the ref you have locally, you can use the `<local>:<remote>` syntax, to have its local name, a colon `:`, and its remote name."
msgstr "当以 `<URL>` 命名的仓库的提交位于与本地仓库不同的引用的顶端时，可以使用 `<本地>:<远程>` 语法，以获得其本地名称、冒号 `:`和远程名称。"

#. type: Plain text
#: en/git-request-pull.txt:56
#, priority:100
msgid "Imagine that you built your work on your `master` branch on top of the `v1.0` release, and want it to be integrated into the project. First you push that change to your public repository for others to see:"
msgstr "想象一下，您在 `v1.0` 版本的基础上建立了自己的 `master` 分支，并希望将其集成到项目中。 首先，你将该变更推送到公共仓库，供其他人查看："

#. type: Plain text
#: en/git-request-pull.txt:58
#, no-wrap, placeholders:'git.ko.xz', priority:100
msgid "\tgit push https://git.ko.xz/project master\n"
msgstr "\tgit push https://git.ko.xz/project master\n"

#. type: Plain text
#: en/git-request-pull.txt:60
#, priority:100
msgid "Then, you run this command:"
msgstr "然后，运行这条命令："

#. type: Plain text
#: en/git-request-pull.txt:62
#, no-wrap, placeholders:'git request-pull':'git.ko.xz', priority:100
msgid "\tgit request-pull v1.0 https://git.ko.xz/project master\n"
msgstr "\tgit request-pull v1.0 https://git.ko.xz/project master\n"

#. type: Plain text
#: en/git-request-pull.txt:66
#, priority:100
msgid "which will produce a request to the upstream, summarizing the changes between the `v1.0` release and your `master`, to pull it from your public repository."
msgstr "会向上游发出请求，总结从 `v1.0` 版本到您的 `master` 版本之间的变化，以便从您的公共仓库中提取。"

#. type: Plain text
#: en/git-request-pull.txt:69
#, priority:100
msgid "If you pushed your change to a branch whose name is different from the one you have locally, e.g."
msgstr "如果您将更改推送到的分支名称与本地分支不同，例如。"

#. type: Plain text
#: en/git-request-pull.txt:71
#, no-wrap, placeholders:'git.ko.xz', priority:100
msgid "\tgit push https://git.ko.xz/project master:for-linus\n"
msgstr "\tgit push https://git.ko.xz/project master:for-linus\n"

#. type: Plain text
#: en/git-request-pull.txt:73
#, priority:100
msgid "then you can ask that to be pulled with"
msgstr "然后，您可以用"

#. type: Plain text
#: en/git-request-pull.txt:75
#, no-wrap, placeholders:'git request-pull':'git.ko.xz', priority:100
msgid "\tgit request-pull v1.0 https://git.ko.xz/project master:for-linus\n"
msgstr "\tgit request-pull v1.0 https://git.ko.xz/project master:for-linus\n"

#. type: Title =
#: en/git-rerere.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-rerere(1)"
msgstr "git-rerere(1)"

#. type: Plain text
#: en/git-rerere.txt:7
#, placeholders:'git-rerere', priority:100
msgid "git-rerere - Reuse recorded resolution of conflicted merges"
msgstr "git-rerere - 重复使用已记录的冲突合并解决方法"

#. type: Plain text
#: en/git-rerere.txt:12
#, ignore-ellipsis, no-wrap, priority:100
msgid "'git rerere' [clear | forget <pathspec>... | diff | status | remaining | gc]\n"
msgstr "'git rerere' ['clear'|'forget' <pathspec>|'diff'|'remaining'|'status'|'gc']\n"

#. type: Plain text
#: en/git-rerere.txt:20
#, priority:100
msgid "In a workflow employing relatively long lived topic branches, the developer sometimes needs to resolve the same conflicts over and over again until the topic branches are done (either merged to the \"release\" branch, or sent out and accepted upstream)."
msgstr "在采用相对较长的特性分支的工作流程中，开发人员有时需要反复解决相同的冲突，直到特性分支完成（要么合并到 “发布” 分支，要么发送到上游并被接受）。"

#. type: Plain text
#: en/git-rerere.txt:25
#, priority:100
msgid "This command assists the developer in this process by recording conflicted automerge results and corresponding hand resolve results on the initial manual merge, and applying previously recorded hand resolutions to their corresponding automerge results."
msgstr "在此过程中，该命令通过记录冲突的自动合并结果和初始手动合并的相应手工解析结果，并将先前记录的手工解析结果应用于相应的自动合并结果，来帮助开发人员。"

#. type: Plain text
#: en/git-rerere.txt:29
#, placeholders:'rerere.enabled', priority:100
msgid "You need to set the configuration variable `rerere.enabled` in order to enable this command."
msgstr "您需要设置配置变量 `rerere.enabled` 才能启用该命令。"

#. type: Plain text
#: en/git-rerere.txt:37
#, priority:100
msgid "Normally, 'git rerere' is run without arguments or user-intervention. However, it has several commands that allow it to interact with its working state."
msgstr "通常，'git rerere' 的运行不需要参数或用户干预。 不过，它有几条命令允许它与工作状态交互。"

#. type: Labeled list
#: en/git-rerere.txt:38
#, no-wrap, priority:100
msgid "'clear'"
msgstr "'clear'（清除）"

#. type: Plain text
#: en/git-rerere.txt:43
#, placeholders:'[--skip':'--abort]':'[--skip':'--abort]', priority:100
msgid "Reset the metadata used by rerere if a merge resolution is to be aborted. Calling 'git am [--skip|--abort]' or 'git rebase [--skip|--abort]' will automatically invoke this command."
msgstr "如果要中止合并解析，重置 rerere 使用的元数据。 调用 'git am [--skip|--abort]' 或 'git rebase [--skip|--abort]' 会自动调用此命令。"

#. type: Labeled list
#: en/git-rerere.txt:44
#, no-wrap, priority:100
msgid "'forget' <pathspec>"
msgstr "'forget' <路径规范>"

#. type: Plain text
#: en/git-rerere.txt:48
#, priority:100
msgid "Reset the conflict resolutions which rerere has recorded for the current conflict in <pathspec>."
msgstr "重置 rerere 在 <路径规范> 中记录的当前冲突的冲突决议。"

#. type: Labeled list
#: en/git-rerere.txt:49
#, no-wrap, priority:100
msgid "'diff'"
msgstr "'diff'"

#. type: Plain text
#: en/git-rerere.txt:55
#, priority:100
msgid "Display diffs for the current state of the resolution. It is useful for tracking what has changed while the user is resolving conflicts. Additional arguments are passed directly to the system 'diff' command installed in PATH."
msgstr "显示当前冲突解决状态的差异。 这对于跟踪用户在解决冲突时发生了哪些变化非常有用。 附加参数会直接传递给安装在 PATH 中的系统 'diff' 命令。"

#. type: Labeled list
#: en/git-rerere.txt:56
#, no-wrap, priority:100
msgid "'status'"
msgstr "'status'"

#. type: Plain text
#: en/git-rerere.txt:59
#, priority:100
msgid "Print paths with conflicts whose merge resolution rerere will record."
msgstr "打印有冲突的路径，rerere 将记录其合并解决方案。"

#. type: Labeled list
#: en/git-rerere.txt:60
#, no-wrap, priority:100
msgid "'remaining'"
msgstr "'remaining'"

#. type: Plain text
#: en/git-rerere.txt:65
#, priority:100
msgid "Print paths with conflicts that have not been autoresolved by rerere. This includes paths whose resolutions cannot be tracked by rerere, such as conflicting submodules."
msgstr "打印 rerere 尚未自动解决冲突的路径。 这包括 rerere 无法跟踪其解决的路径，如冲突的子模块。"

#. type: Labeled list
#: en/git-rerere.txt:66 en/git-svn.txt:511
#, no-wrap, priority:100
msgid "'gc'"
msgstr "'gc'"

#. type: Plain text
#: en/git-rerere.txt:74
#, placeholders:'gc.rerereUnresolved':'gc.rerereResolved', priority:100
msgid "Prune records of conflicted merges that occurred a long time ago. By default, unresolved conflicts older than 15 days and resolved conflicts older than 60 days are pruned. These defaults are controlled via the `gc.rerereUnresolved` and `gc.rerereResolved` configuration variables respectively."
msgstr "修剪很久以前发生的冲突合并记录。 默认情况下，超过 15 天的未解决冲突和超过 60 天的已解决冲突会被剪除。 这些默认值分别由 `gc.rerereUnresolved` 和 `gc.rerereResolved` 配置变量控制。"

#. type: Plain text
#: en/git-rerere.txt:83
#, priority:100
msgid "When your topic branch modifies an overlapping area that your master branch (or upstream) touched since your topic branch forked from it, you may want to test it with the latest master, even before your topic branch is ready to be pushed upstream:"
msgstr "当你的特性分支修改了主分支（或上游分支）从特性分支分叉出来后接触过的重叠区域时，你可能想用最新的主分支进行测试，甚至在特性分支准备好推送到上游之前："

#. type: delimited block -
#: en/git-rerere.txt:88
#, no-wrap, placeholders:'o---':'---o':'o---o---o---':'---o---o', priority:100
msgid ""
"              o---*---o topic\n"
"             /\n"
"    o---o---o---*---o---o master\n"
msgstr ""
"              o---*---o topic\n"
"             /\n"
"    o---o---o---*---o---o master\n"

#. type: Plain text
#: en/git-rerere.txt:92
#, priority:100
msgid "For such a test, you need to merge master and topic somehow. One way to do it is to pull master into the topic branch:"
msgstr "要进行这样的测试，需要以某种方式合并主分支和特性分支。 一种方法是将主分支拉入特性分支："

#. type: delimited block -
#: en/git-rerere.txt:96
#, no-wrap, priority:100
msgid ""
"\t$ git switch topic\n"
"\t$ git merge master\n"
msgstr ""
"\t$ git switch topic\n"
"\t$ git merge master\n"

#. type: delimited block -
#: en/git-rerere.txt:100
#, no-wrap, placeholders:'o---':'---o---':'o---o---o---':'---o---o', priority:100
msgid ""
"              o---*---o---+ topic\n"
"             /           /\n"
"    o---o---o---*---o---o master\n"
msgstr ""
"              o---*---o---+ topic\n"
"             /           /\n"
"    o---o---o---*---o---o master\n"

#. type: Plain text
#: en/git-rerere.txt:106
#, priority:100
msgid "The commits marked with `*` touch the same area in the same file; you need to resolve the conflicts when creating the commit marked with `+`. Then you can test the result to make sure your work-in-progress still works with what is in the latest master."
msgstr "标有 `*` 的提交涉及同一文件中的同一区域；您需要在创建标有 `+` 的提交时解决冲突。 然后，您就可以测试结果，以确保您正在进行的工作仍能与最新的 master 中的内容一起运行。"

#. type: Plain text
#: en/git-rerere.txt:114
#, priority:100
msgid "After this test merge, there are two ways to continue your work on the topic. The easiest is to build on top of the test merge commit `+`, and when your work in the topic branch is finally ready, pull the topic branch into master, and/or ask the upstream to pull from you. By that time, however, the master or the upstream might have been advanced since the test merge `+`, in which case the final commit graph would look like this:"
msgstr "测试合并后，有两种方法可以继续主题工作。 最简单的方法是建立在测试合并提交 `+` 之上，当你在特性分支中的工作最终准备就绪时，将特性分支拉入主分支，和/或请求上游从你那里拉取。 不过，到那时，主分支或上游分支可能已经在测试合并 `+` 后提前了，在这种情况下，最终的提交图会是这样的："

#. type: delimited block -
#: en/git-rerere.txt:121
#, ignore-ellipsis, no-wrap, priority:100
msgid ""
"\t$ git switch topic\n"
"\t$ git merge master\n"
"\t$ ... work on both topic and master branches\n"
"\t$ git switch master\n"
"\t$ git merge topic\n"
msgstr ""
"\t$ git switch topic\n"
"\t$ git merge master\n"
"\t$ ... work on both topic and master branches\n"
"\t$ git switch master\n"
"\t$ git merge topic\n"

#. type: delimited block -
#: en/git-rerere.txt:125
#, no-wrap, placeholders:'o---':'---o---':'---o---o':'o---o---o---':'---o---o---o---o---', priority:100
msgid ""
"              o---*---o---+---o---o topic\n"
"             /           /         \\\n"
"    o---o---o---*---o---o---o---o---+ master\n"
msgstr ""
"              o---*---o---+---o---o topic\n"
"             /           /         \\\n"
"    o---o---o---*---o---o---o---o---+ master\n"

#. type: Plain text
#: en/git-rerere.txt:133
#, priority:100
msgid "When your topic branch is long-lived, however, your topic branch would end up having many such \"Merge from master\" commits on it, which would unnecessarily clutter the development history. Readers of the Linux kernel mailing list may remember that Linus complained about such too frequent test merges when a subsystem maintainer asked to pull from a branch full of \"useless merges\"."
msgstr "然而，当你的特性分支寿命很长时，你的特性分支上就会有很多这样的 “从主分支合并” 提交，这将不必要地扰乱开发历史。 Linux 内核邮件列表的读者可能还记得，当一个子系统维护者要求从一个充满 “无用合并” 的分支中拉取代码时，Linus 抱怨过这种过于频繁的测试合并。"

#. type: Plain text
#: en/git-rerere.txt:137
#, priority:100
msgid "As an alternative, to keep the topic branch clean of test merges, you could blow away the test merge, and keep building on top of the tip before the test merge:"
msgstr "作为一种替代方法，为了使主题分支不受测试合并的影响，可以删除测试合并，并在测试合并之前继续在提示之上构建："

#. type: delimited block -
#: en/git-rerere.txt:145
#, ignore-ellipsis, no-wrap, placeholders:'--hard':'HEAD', priority:100
msgid ""
"\t$ git switch topic\n"
"\t$ git merge master\n"
"\t$ git reset --hard HEAD^ ;# rewind the test merge\n"
"\t$ ... work on both topic and master branches\n"
"\t$ git switch master\n"
"\t$ git merge topic\n"
msgstr ""
"\t$ git switch topic\n"
"\t$ git merge master\n"
"\t$ git reset --hard HEAD^ ;# 倒带测试合并\n"
"\t$ ... 同时在 topic 分支和 master 分支工作\n"
"\t$ git switch master\n"
"\t$ git merge topic\n"

#. type: delimited block -
#: en/git-rerere.txt:149
#, no-wrap, placeholders:'o---':'---o-------o---o':'o---o---o---':'---o---o---o---o---', priority:100
msgid ""
"              o---*---o-------o---o topic\n"
"             /                     \\\n"
"    o---o---o---*---o---o---o---o---+ master\n"
msgstr ""
"              o---*---o-------o---o topic\n"
"             /                     \\\n"
"    o---o---o---*---o---o---o---o---+ master\n"

#. type: Plain text
#: en/git-rerere.txt:159
#, priority:100
msgid "This would leave only one merge commit when your topic branch is finally ready and merged into the master branch. This merge would require you to resolve the conflict, introduced by the commits marked with `*`. However, this conflict is often the same conflict you resolved when you created the test merge you blew away. 'git rerere' helps you resolve this final conflicted merge using the information from your earlier hand resolve."
msgstr "这样，当你的特性分支最终准备就绪并合并到主分支时，就只剩下一个合并提交了。 这次合并需要解决标有 `*` 的提交所带来的冲突。 然而，这个冲突往往就是你在创建测试合并时解决的冲突。 'git rerere' 可以帮助你使用之前手工解决的信息来解决最终的冲突合并。"

#. type: Plain text
#: en/git-rerere.txt:167
#, priority:100
msgid "Running the 'git rerere' command immediately after a conflicted automerge records the conflicted working tree files, with the usual conflict markers `<<<<<<<`, `=======`, and `>>>>>>>` in them. Later, after you are done resolving the conflicts, running 'git rerere' again will record the resolved state of these files. Suppose you did this when you created the test merge of master into the topic branch."
msgstr "在自动合成冲突后立即运行 'git rerere' 命令，会记录下冲突的工作树文件，并在其中加上通常的冲突标记`<<<<<<<`、`=======` 和 `>>>>>>>`。 稍后，当你解决完冲突后，再次运行 'git rerere' 就会记录下这些文件已解决的状态。 假设你在创建将 master 合并到主题分支的测试时做了这个操作。"

#. type: Plain text
#: en/git-rerere.txt:177
#, priority:100
msgid "Next time, after seeing the same conflicted automerge, running 'git rerere' will perform a three-way merge between the earlier conflicted automerge, the earlier manual resolution, and the current conflicted automerge. If this three-way merge resolves cleanly, the result is written out to your working tree file, so you do not have to manually resolve it. Note that 'git rerere' leaves the index file alone, so you still need to do the final sanity checks with `git diff` (or `git diff -c`) and 'git add' when you are satisfied."
msgstr "下一次，在看到相同的自动生成器冲突后，运行 'git rerere' 将在之前的自动生成器冲突、之前的手动解决和当前的自动生成器冲突之间执行一次三向合并。 如果这次三方合并解决得很干净，结果就会写入工作区的文件中，因此你就不必再手动解决了。 请注意，'git rerere' 不会影响索引文件，因此您仍需要使用 `git diff`（或 `git diff -c`）和 `git add` 进行最后的正确性检查。"

#. type: Plain text
#: en/git-rerere.txt:185
#, placeholders:'rerere.enabled', priority:100
msgid "As a convenience measure, 'git merge' automatically invokes 'git rerere' upon exiting with a failed automerge and 'git rerere' records the hand resolve when it is a new conflict, or reuses the earlier hand resolve when it is not. 'git commit' also invokes 'git rerere' when committing a merge result. What this means is that you do not have to do anything special yourself (besides enabling the rerere.enabled config variable)."
msgstr "为了方便起见，'git merge' 会在自动合并失败退出时自动调用 'git rerere'，如果是新的冲突，'git rerere' 会记录手工解析，如果不是，则重用之前的手工解析。 在提交合并结果时，'git commit' 也会调用 'git rerere' 。 这意味着，除了启用 rerere.enabled 配置变量外，你无需做任何特别的事情。"

#. type: Plain text
#: en/git-rerere.txt:190
#, priority:100
msgid "In our example, when you do the test merge, the manual resolution is recorded, and it will be reused when you do the actual merge later with the updated master and topic branch, as long as the recorded resolution is still applicable."
msgstr "在我们的示例中，当你进行测试合并时，手动解决方法会被记录下来，只要记录下来的解决方法仍然适用，就会在稍后与更新的主分支和主题分支进行实际合并时重复使用。"

#. type: Plain text
#: en/git-rerere.txt:194
#, priority:100
msgid "The information 'git rerere' records is also used when running 'git rebase'. After blowing away the test merge and continuing development on the topic branch:"
msgstr "'git rerere' 记录的信息也会在运行 'git rebase' 时使用。 将测试合并后，继续在主题分支上进行开发："

#. type: delimited block -
#: en/git-rerere.txt:199
#, no-wrap, placeholders:'o---':'---o-------o---o':'o---o---o---':'---o---o---o---o', priority:100
msgid ""
"              o---*---o-------o---o topic\n"
"             /\n"
"    o---o---o---*---o---o---o---o   master\n"
msgstr ""
"              o---*---o-------o---o topic\n"
"             /\n"
"    o---o---o---*---o---o---o---o   master\n"

#. type: delimited block -
#: en/git-rerere.txt:201
#, no-wrap, priority:100
msgid "\t$ git rebase master topic\n"
msgstr "\t$ git rebase master topic\n"

#. type: delimited block -
#: en/git-rerere.txt:205
#, no-wrap, placeholders:'o---':'---o-------o---o':'o---o---o---':'---o---o---o---o', priority:100
msgid ""
"\t\t\t\t  o---*---o-------o---o topic\n"
"\t\t\t\t /\n"
"    o---o---o---*---o---o---o---o   master\n"
msgstr ""
"\t\t\t\t  o---*---o-------o---o topic\n"
"\t\t\t\t /\n"
"    o---o---o---*---o---o---o---o   master\n"

#. type: Plain text
#: en/git-rerere.txt:213
#, priority:100
msgid "you could run `git rebase master topic`, to bring yourself up to date before your topic is ready to be sent upstream. This would result in falling back to a three-way merge, and it would conflict the same way as the test merge you resolved earlier. 'git rerere' will be run by 'git rebase' to help you resolve this conflict."
msgstr "您可以运行 `git rebase master topic`，在您的主题准备好被发送到上游之前更新自己。 这将导致退回到三方合并，而且会和之前的测试合并产生冲突。 ' git rebase' 会运行 'git rerere' 来帮你解决这个冲突。"

#. type: Plain text
#: en/git-rerere.txt:219
#, placeholders:'linkgit:gitattributes[5]', priority:100
msgid "[NOTE] 'git rerere' relies on the conflict markers in the file to detect the conflict. If the file already contains lines that look the same as lines with conflict markers, 'git rerere' may fail to record a conflict resolution. To work around this, the `conflict-marker-size` setting in linkgit:gitattributes[5] can be used."
msgstr "[注意] 'git rerere' 依靠文件中的冲突标记来检测冲突。 如果文件中已经包含了与冲突标记相同的行，'git rerere' 可能无法记录冲突解决。 要解决这个问题，可以使用 linkgit:gitattributes[5] 中的 `conflict-marker-size` 设置。"

#. type: Title =
#: en/git-reset.txt:2
#, ignore-same, no-wrap, priority:280
msgid "git-reset(1)"
msgstr "git-reset(1)"

#. type: Plain text
#: en/git-reset.txt:7
#, placeholders:'git-reset':'HEAD', priority:280
msgid "git-reset - Reset current HEAD to the specified state"
msgstr "git-reset - 重置当前HEAD到指定的状态"

#. type: Plain text
#: en/git-reset.txt:15
#, ignore-ellipsis, no-wrap, placeholders:'[--pathspec-from-file=':'[--pathspec-file-nul]':'--patch':'[--soft':'--mixed':'--hard':'--merge':'--keep]', priority:280
msgid ""
"'git reset' [-q] [<tree-ish>] [--] <pathspec>...\n"
"'git reset' [-q] [--pathspec-from-file=<file> [--pathspec-file-nul]] [<tree-ish>]\n"
"'git reset' (--patch | -p) [<tree-ish>] [--] [<pathspec>...]\n"
"'git reset' [--soft | --mixed [-N] | --hard | --merge | --keep] [-q] [<commit>]\n"
msgstr ""
"'git reset' [-q] [<目录树对象>] [--] <路径规范>...\n"
"'git reset' [-q] [--pathspec-from-file=<文件> [--pathspec-file-nul]] [<目录树对象>]\n"
"'git reset' (--patch | -p) [<目录树对象>] [--] [<路径规范>...]\n"
"'git reset' [--soft | --mixed [-N] | --hard | --merge | --keep] [-q] [<提交>]\n"

#. type: Plain text
#: en/git-reset.txt:22
#, placeholders:'HEAD':'HEAD', priority:280
msgid "In the first three forms, copy entries from `<tree-ish>` to the index. In the last form, set the current branch head (`HEAD`) to `<commit>`, optionally modifying index and working tree to match. The `<tree-ish>`/`<commit>` defaults to `HEAD` in all forms."
msgstr "在前三种形式中，从`<treeish>`复制条目到索引。 在最后一个表格中，将当前的分支头(`HEAD`)设置为`<commit>`，可以选择修改索引和工作树来匹配。 `<tree-ish>`/`<commit>`在所有表格中默认为`HEAD`。"

#. type: Labeled list
#: en/git-reset.txt:23
#, ignore-ellipsis, no-wrap, priority:280
msgid "'git reset' [-q] [<tree-ish>] [--] <pathspec>..."
msgstr "'git reset' [-q] [<目录树对象>] [--] <路径规范>..."

#. type: Labeled list
#: en/git-reset.txt:24
#, no-wrap, placeholders:'[--pathspec-from-file=':'[--pathspec-file-nul]', priority:280
msgid "'git reset' [-q] [--pathspec-from-file=<file> [--pathspec-file-nul]] [<tree-ish>]"
msgstr "'git reset' [-q] [--pathspec-from-file=<文件> [--pathspec-file-nul]] [<目录树对象>]"

#. type: Plain text
#: en/git-reset.txt:28
#, priority:280
msgid "These forms reset the index entries for all paths that match the `<pathspec>` to their state at `<tree-ish>`. (It does not affect the working tree or the current branch.)"
msgstr "这些表格将所有符合 `<路径规范>` 的路径的索引项重置为 `<目录树对象>` 时的状态。 (它不影响工作目录树或当前分支。)"

#. type: Plain text
#: en/git-reset.txt:32
#, ignore-ellipsis, placeholders:'[--source=':'--staged', priority:280
msgid "This means that `git reset <pathspec>` is the opposite of `git add <pathspec>`. This command is equivalent to `git restore [--source=<tree-ish>] --staged <pathspec>...`."
msgstr "这意味着，`git reset <pathspec>`与`git add <pathspec>`相反。该命令等同于`git restore [--source=<treeish>] --staged <pathspec>...`。"

#. type: Plain text
#: en/git-reset.txt:39
#, placeholders:'linkgit:git-restore[1]':'linkgit:git-restore[1]':'`--source`', priority:280
msgid "After running `git reset <pathspec>` to update the index entry, you can use linkgit:git-restore[1] to check the contents out of the index to the working tree. Alternatively, using linkgit:git-restore[1] and specifying a commit with `--source`, you can copy the contents of a path out of a commit to the index and to the working tree in one go."
msgstr "运行 `git reset <pathspec>` 来更新索引条目后，您可以使用 linkgit:git-restore[1] 来检查索引中的内容到工作树上。另外，使用 linkgit:git-restore[1] 并用 `--source` 指定一个提交，你可以一次性将一个路径的内容从提交中复制到索引和工作树上。"

#. type: Labeled list
#: en/git-reset.txt:40
#, ignore-ellipsis, no-wrap, placeholders:'--patch', priority:280
msgid "'git reset' (--patch | -p) [<tree-ish>] [--] [<pathspec>...]"
msgstr "'git reset' (--patch | -p) [<目录树对象>] [--] [<路径规范>...]"

#. type: Plain text
#: en/git-reset.txt:44
#, placeholders:'HEAD', priority:280
msgid "Interactively select hunks in the difference between the index and `<tree-ish>` (defaults to `HEAD`). The chosen hunks are applied in reverse to the index."
msgstr "在索引和`<tree-ish>`（默认为`HEAD`）之间的差异中交互式地选择猎物。 选择的猎物将被反向应用到索引中。"

#. type: Plain text
#: en/git-reset.txt:48
#, placeholders:'linkgit:git-add[1]':'`--patch`', priority:280
msgid "This means that `git reset -p` is the opposite of `git add -p`, i.e. you can use it to selectively reset hunks. See the ``Interactive Mode'' section of linkgit:git-add[1] to learn how to operate the `--patch` mode."
msgstr "这意味着 `git reset -p` 与 `git add -p` 相反，也就是说，你可以用它来有选择地重置 hunks。参见 linkgit:git-add[1] 的 ``互动模式''部分，了解如何操作`--patch`模式。"

#. type: Labeled list
#: en/git-reset.txt:49
#, no-wrap, priority:280
msgid "'git reset' [<mode>] [<commit>]"
msgstr "'git reset' [<模式>] [<提交>]"

#. type: Plain text
#: en/git-reset.txt:55
#, placeholders:'ORIG_HEAD':'`--mixed`', priority:280
msgid "This form resets the current branch head to `<commit>` and possibly updates the index (resetting it to the tree of `<commit>`) and the working tree depending on `<mode>`. Before the operation, `ORIG_HEAD` is set to the tip of the current branch. If `<mode>` is omitted, defaults to `--mixed`. The `<mode>` must be one of the following:"
msgstr "此表单会将当前分支的头重置为 `<提交>`，并可能根据 `<模式>`更新索引（重置为 `<提交>`的目录树）和工作目录树。在操作之前，`ORIG_HEAD` 会被设置为当前分支的顶端。如果省略了 `<模式>`，则默认为 `--mixed`。`<模式>` 必须是以下之一："

#. type: Labeled list
#: en/git-reset.txt:57
#, ignore-same, no-wrap, priority:280
msgid "--soft"
msgstr "--soft"

#. type: Plain text
#: en/git-reset.txt:62
#, priority:280
msgid "Does not touch the index file or the working tree at all (but resets the head to `<commit>`, just like all modes do). This leaves all your changed files \"Changes to be committed\", as `git status` would put it."
msgstr "完全不碰索引文件或工作树（但将头部重置为`<commit>`，就像所有模式一样）。这使你的所有更改的文件都是 \"待提交的更改\"，正如`git status`所说的。"

#. type: Labeled list
#: en/git-reset.txt:63
#, ignore-same, no-wrap, priority:280
msgid "--mixed"
msgstr "--mixed"

#. type: Plain text
#: en/git-reset.txt:67
#, priority:280
msgid "Resets the index but not the working tree (i.e., the changed files are preserved but not marked for commit) and reports what has not been updated. This is the default action."
msgstr "重置索引，但不重置工作树（即保留已修改的文件，但不标记为提交）并报告未更新的内容。这是默认动作。"

#. type: Plain text
#: en/git-reset.txt:70
#, placeholders:'`-N`':'linkgit:git-add[1]', priority:280
msgid "If `-N` is specified, removed paths are marked as intent-to-add (see linkgit:git-add[1])."
msgstr "如果指定了 `-N`，则删除的路径将被标记为要添加（请参阅 linkgit:git-add[1]）。"

#. type: Labeled list
#: en/git-reset.txt:71
#, ignore-same, no-wrap, priority:280
msgid "--hard"
msgstr "--hard"

#. type: Plain text
#: en/git-reset.txt:75
#, priority:280
msgid "Resets the index and working tree. Any changes to tracked files in the working tree since `<commit>` are discarded. Any untracked files or directories in the way of writing any tracked files are simply deleted."
msgstr "重置索引和工作树。工作树中自 `<提交>` 以来对跟踪文件的任何更改都会被丢弃。 任何妨碍写入跟踪文件的未跟踪文件或目录都会被删除。"

#. type: Plain text
#: en/git-reset.txt:83
#, placeholders:'HEAD', priority:280
msgid "Resets the index and updates the files in the working tree that are different between `<commit>` and `HEAD`, but keeps those which are different between the index and working tree (i.e. which have changes which have not been added). If a file that is different between `<commit>` and the index has unstaged changes, reset is aborted."
msgstr "重置索引并更新工作树中在`<commit>`和`HEAD`之间不同的文件，但保留那些在索引和工作树之间不同的文件（即那些有未被添加的修改）。 如果一个在`<commit>`和索引之间不同的文件有未分阶段的变化，重置将被中止。"

#. type: Plain text
#: en/git-reset.txt:86
#, placeholders:'`--merge`':'git read-tree', priority:280
msgid "In other words, `--merge` does something like a `git read-tree -u -m <commit>`, but carries forward unmerged index entries."
msgstr "换句话说，`--merge`做的是类似于`git read-tree -u -m <commit>`的事情，但会转发未合并的索引条目。"

#. type: Plain text
#: en/git-reset.txt:92
#, placeholders:'HEAD':'HEAD', priority:280
msgid "Resets index entries and updates files in the working tree that are different between `<commit>` and `HEAD`. If a file that is different between `<commit>` and `HEAD` has local changes, reset is aborted."
msgstr "重置索引项并更新工作树中`<commit>`和`HEAD`之间不同的文件。 如果一个在`<commit>`和`HEAD`之间不同的文件有本地修改，重置将被中止。"

#. type: Plain text
#: en/git-reset.txt:98
#, placeholders:'--recurse-submodules':'HEAD', priority:280
msgid "When the working tree is updated, using --recurse-submodules will also recursively reset the working tree of all active submodules according to the commit recorded in the superproject, also setting the submodules' HEAD to be detached at that commit."
msgstr "当工作树被更新时，使用 --recurse-submodules 也将根据超级项目中记录的提交，递归地重置所有活动的子模块的工作树，同时也将子模块的 HEAD 设置为在该提交中被分离。"

#. type: Plain text
#: en/git-reset.txt:102 en/git-restore.txt:30 en/git-revert.txt:33
#, placeholders:'linkgit:git[1]', priority:280
msgid "See \"Reset, restore and revert\" in linkgit:git[1] for the differences between the three commands."
msgstr "关于这三个命令的区别，见linkgit:git[1]中的 \"重置、恢复和还原\"。"

#. type: Plain text
#: en/git-reset.txt:110
#, priority:280
msgid "Be quiet, only report errors."
msgstr "静默模式，只报告错误。"

#. type: Labeled list
#: en/git-reset.txt:112
#, ignore-same, no-wrap, priority:280
msgid "--no-refresh"
msgstr "--no-refresh"

#. type: Plain text
#: en/git-reset.txt:114
#, priority:280
msgid "Refresh the index after a mixed reset. Enabled by default."
msgstr "在混合重置后刷新索引，默认启用。"

#. type: Labeled list
#: en/git-reset.txt:139
#, no-wrap, priority:280
msgid "Undo add"
msgstr "撤销添加"

#. type: delimited block -
#: en/git-reset.txt:147
#, no-wrap, priority:280
msgid ""
"$ edit                                     <1>\n"
"$ git add frotz.c filfre.c\n"
"$ mailx                                    <2>\n"
"$ git reset                                <3>\n"
"$ git pull git://info.example.com/ nitfol  <4>\n"
msgstr ""
"$ edit                                     <1>\n"
"$ git add frotz.c filfre.c\n"
"$ mailx                                    <2>\n"
"$ git reset                                <3>\n"
"$ git pull git://info.example.com/ nitfol  <4>\n"

#. type: Plain text
#: en/git-reset.txt:153
#, priority:280
msgid "You are happily working on something, and find the changes in these files are in good order. You do not want to see them when you run `git diff`, because you plan to work on other files and changes with these files are distracting."
msgstr "你正在愉快地工作，发现这些文件中的修改都很有秩序。 你不希望在运行`git diff'时看到它们，因为你打算在其他文件上工作，而这些文件的变化会让你分心。"

#. type: Plain text
#: en/git-reset.txt:154
#, priority:280
msgid "Somebody asks you to pull, and the changes sound worthy of merging."
msgstr "有人要求你拉，而且这些变化听起来值得合并。"

#. type: Plain text
#: en/git-reset.txt:159
#, placeholders:'HEAD', priority:280
msgid "However, you already dirtied the index (i.e. your index does not match the `HEAD` commit). But you know the pull you are going to make does not affect `frotz.c` or `filfre.c`, so you revert the index changes for these two files. Your changes in working tree remain there."
msgstr "然而，你已经破坏了索引（也就是说，你的索引与`HEAD`提交不匹配）。 但你知道你要做的拉动并不影响`frotz.c`或`filfre.c`，所以你恢复了这两个文件的索引修改。 你在工作树上的修改仍然存在。"

#. type: Plain text
#: en/git-reset.txt:161
#, priority:280
msgid "Then you can pull and merge, leaving `frotz.c` and `filfre.c` changes still in the working tree."
msgstr "然后你可以拉出并合并，留下`frotz.c`和`filfre.c`的修改仍在工作树上。"

#. type: Labeled list
#: en/git-reset.txt:162
#, no-wrap, priority:280
msgid "Undo a commit and redo"
msgstr "撤销一个提交并重做"

#. type: delimited block -
#: en/git-reset.txt:169
#, ignore-ellipsis, no-wrap, placeholders:'--soft':'HEAD':'ORIG_HEAD', priority:280
msgid ""
"$ git commit ...\n"
"$ git reset --soft HEAD^      <1>\n"
"$ edit                        <2>\n"
"$ git commit -a -c ORIG_HEAD  <3>\n"
msgstr ""
"$ git commit ...\n"
"$ git reset --soft HEAD^      <1>\n"
"$ edit                        <2>\n"
"$ git commit -a -c ORIG_HEAD  <3>\n"

#. type: Plain text
#: en/git-reset.txt:174
#, priority:280
msgid "This is most often done when you remembered what you just committed is incomplete, or you misspelled your commit message, or both. Leaves working tree as it was before \"reset\"."
msgstr "这通常是在你记得你刚提交的内容不完整，或者你的提交信息拼错了，或者两者都是。 留下工作树在 \"重置 \"之前的样子。"

#. type: Plain text
#: en/git-reset.txt:175
#, priority:280
msgid "Make corrections to working tree files."
msgstr "对工作树文件进行修正。"

#. type: Plain text
#: en/git-reset.txt:178
#, placeholders:'.git/ORIG_HEAD':'`-C`', priority:280
msgid "\"reset\" copies the old head to `.git/ORIG_HEAD`; redo the commit by starting with its log message. If you do not need to edit the message further, you can give `-C` option instead."
msgstr "\"reset \"将旧的头部复制到`.git/ORIG_HEAD`；从其日志信息开始重做提交。 如果你不需要进一步编辑信息，你可以给`-C`选项代替。"

#. type: Plain text
#: en/git-reset.txt:180
#, placeholders:'`--amend`':'linkgit:git-commit[1]', priority:280
msgid "See also the `--amend` option to linkgit:git-commit[1]."
msgstr "参见linkgit:git-commit[1]的`--amend`选项。"

#. type: Labeled list
#: en/git-reset.txt:181
#, no-wrap, priority:280
msgid "Undo a commit, making it a topic branch"
msgstr "撤销一个提交，使其成为一个主题分支"

#. type: delimited block -
#: en/git-reset.txt:187
#, no-wrap, placeholders:'--hard':'HEAD', priority:280
msgid ""
"$ git branch topic/wip          <1>\n"
"$ git reset --hard HEAD~3       <2>\n"
"$ git switch topic/wip          <3>\n"
msgstr ""
"$ git branch topic/wip          <1>\n"
"$ git reset --hard HEAD~3       <2>\n"
"$ git switch topic/wip          <3>\n"

#. type: Plain text
#: en/git-reset.txt:193
#, placeholders:'HEAD', priority:280
msgid "You have made some commits, but realize they were premature to be in the `master` branch. You want to continue polishing them in a topic branch, so create `topic/wip` branch off of the current `HEAD`."
msgstr "你已经做了一些提交，但意识到它们在 \"master \"分支中还不成熟。 你想在一个主题分支中继续完善它们，所以在当前的`HEAD'之外创建了`topic/wip'分支。"

#. type: Plain text
#: en/git-reset.txt:194
#, priority:280
msgid "Rewind the master branch to get rid of those three commits."
msgstr "回溯主分支，去掉这三个提交。"

#. type: Plain text
#: en/git-reset.txt:195
#, priority:280
msgid "Switch to `topic/wip` branch and keep working."
msgstr "切换到`topic/wip`分支并继续工作。"

#. type: Labeled list
#: en/git-reset.txt:196
#, no-wrap, priority:280
msgid "Undo commits permanently"
msgstr "永久撤销提交"

#. type: delimited block -
#: en/git-reset.txt:201
#, ignore-ellipsis, no-wrap, placeholders:'--hard':'HEAD', priority:280
msgid ""
"$ git commit ...\n"
"$ git reset --hard HEAD~3   <1>\n"
msgstr ""
"$ git commit ...\n"
"$ git reset --hard HEAD~3 <1>\n"

#. type: Plain text
#: en/git-reset.txt:208
#, placeholders:'HEAD':'HEAD':'HEAD':'linkgit:git-rebase[1]', priority:280
msgid "The last three commits (`HEAD`, `HEAD^`, and `HEAD~2`) were bad and you do not want to ever see them again. Do *not* do this if you have already given these commits to somebody else. (See the \"RECOVERING FROM UPSTREAM REBASE\" section in linkgit:git-rebase[1] for the implications of doing so.)"
msgstr "最后三个提交（`HEAD`，`HEAD^`，和`HEAD~2`）是坏的，你不希望再看到它们。 如果你已经把这些提交给了别人，请 *不要* 这样做。 参见 linkgit:git-rebase[1] 中的 “从上游仓库重建中恢复” 一节，了解这样做的意义。）"

#. type: Labeled list
#: en/git-reset.txt:209
#, no-wrap, priority:280
msgid "Undo a merge or pull"
msgstr "撤销合并或拉动"

#. type: delimited block -
#: en/git-reset.txt:221
#, ignore-ellipsis, no-wrap, placeholders:'--hard':'--hard':'ORIG_HEAD', priority:280
msgid ""
"$ git pull                         <1>\n"
"Auto-merging nitfol\n"
"CONFLICT (content): Merge conflict in nitfol\n"
"Automatic merge failed; fix conflicts and then commit the result.\n"
"$ git reset --hard                 <2>\n"
"$ git pull . topic/branch          <3>\n"
"Updating from 41223... to 13134...\n"
"Fast-forward\n"
"$ git reset --hard ORIG_HEAD       <4>\n"
msgstr ""
"$ git pull <1>\n"
"自动合并nitfol\n"
"CONFLICT（内容）。nitfol的合并冲突\n"
"自动合并失败；修复冲突，然后提交结果。\n"
"$ git reset --hard <2>\n"
"$ git pull . topic/branch <3>\n"
"从41223...更新到13134...\n"
"快进\n"
"$ git reset --hard ORIG_HEAD <4>\n"

#. type: Plain text
#: en/git-reset.txt:226
#, priority:280
msgid "Try to update from the upstream resulted in a lot of conflicts; you were not ready to spend a lot of time merging right now, so you decide to do that later."
msgstr "试图从上游更新导致了很多冲突；你现在还没有准备好花费大量的时间来合并，所以你决定以后再做这个。"

#. type: Plain text
#: en/git-reset.txt:229
#, placeholders:'--hard`':'--hard':'HEAD', priority:280
msgid "\"pull\" has not made merge commit, so `git reset --hard` which is a synonym for `git reset --hard HEAD` clears the mess from the index file and the working tree."
msgstr "\"pull \"没有进行合并提交，所以`git reset --hard`是`git reset --hard HEAD`的同义词，它清除了索引文件和工作树上的混乱。"

#. type: Plain text
#: en/git-reset.txt:231
#, priority:280
msgid "Merge a topic branch into the current branch, which resulted in a fast-forward."
msgstr "将一个主题分支合并到当前分支，这导致了快进。"

#. type: Plain text
#: en/git-reset.txt:236
#, placeholders:'ORIG_HEAD', priority:280
msgid "But you decided that the topic branch is not ready for public consumption yet. \"pull\" or \"merge\" always leaves the original tip of the current branch in `ORIG_HEAD`, so resetting hard to it brings your index file and the working tree back to that state, and resets the tip of the branch to that commit."
msgstr "但你决定这个主题分支还不适合公开使用。 \"pull \"或 \"merge \"总是在`ORIG_HEAD`中留下当前分支的原始提示，所以硬重置到它会使你的索引文件和工作树回到那个状态，并将分支的提示重置到那个提交。"

#. type: Labeled list
#: en/git-reset.txt:237
#, no-wrap, priority:280
msgid "Undo a merge or pull inside a dirty working tree"
msgstr "撤消合并或拉动肮脏的工作树的行为"

#. type: delimited block -
#: en/git-reset.txt:246
#, ignore-ellipsis, no-wrap, placeholders:'++----':'--merge':'ORIG_HEAD', priority:280
msgid ""
"$ git pull                         <1>\n"
"Auto-merging nitfol\n"
"Merge made by recursive.\n"
" nitfol                |   20 +++++----\n"
" ...\n"
"$ git reset --merge ORIG_HEAD      <2>\n"
msgstr ""
"$ git pull                         <1>\n"
"Auto-merging nitfol\n"
"Merge made by recursive.\n"
" nitfol                |   20 +++++----\n"
" ...\n"
"$ git reset --merge ORIG_HEAD      <2>\n"

#. type: Plain text
#: en/git-reset.txt:252
#, priority:280
msgid "Even if you may have local modifications in your working tree, you can safely say `git pull` when you know that the change in the other branch does not overlap with them."
msgstr "即使你的工作树中可能有局部的修改，当你知道另一个分支中的修改没有与之重叠时，你可以放心地说`git pull`。"

#. type: Plain text
#: en/git-reset.txt:257
#, placeholders:'--hard':'ORIG_HEAD':'--merge`', priority:280
msgid "After inspecting the result of the merge, you may find that the change in the other branch is unsatisfactory. Running `git reset --hard ORIG_HEAD` will let you go back to where you were, but it will discard your local changes, which you do not want. `git reset --merge` keeps your local changes."
msgstr "在检查了合并的结果后，你可能会发现另一个分支的修改不尽人意。 运行`git reset --hard ORIG_HEAD`可以让你回到原来的位置，但它会丢弃你的本地修改，这是你不想要的。 `git reset --merge`会保留你的本地修改。"

#. type: Labeled list
#: en/git-reset.txt:259 en/git-stash.txt:309
#, no-wrap, priority:280
msgid "Interrupted workflow"
msgstr "中断的工作流程"

#. type: Plain text
#: en/git-reset.txt:265
#, priority:280
msgid "Suppose you are interrupted by an urgent fix request while you are in the middle of a large change. The files in your working tree are not in any shape to be committed yet, but you need to get to the other branch for a quick bugfix."
msgstr "假设你在做一个大的改动时被一个紧急的修复请求打断了。 你工作树上的文件还没到可以提交的地步，但你需要到另一个分支去快速修复错误。"

#. type: delimited block -
#: en/git-reset.txt:276
#, no-wrap, placeholders:'--soft':'HEAD', priority:280
msgid ""
"$ git switch feature  ;# you were working in \"feature\" branch and\n"
"$ work work work      ;# got interrupted\n"
"$ git commit -a -m \"snapshot WIP\"                 <1>\n"
"$ git switch master\n"
"$ fix fix fix\n"
"$ git commit ;# commit with real log\n"
"$ git switch feature\n"
"$ git reset --soft HEAD^ ;# go back to WIP state  <2>\n"
"$ git reset                                       <3>\n"
msgstr ""
"$ git switch feature ;# 你在 \"feature \"分支工作，并且\n"
"$ work work work;# 被打断了\n"
"$ git commit -a -m \"snapshot WIP\" <1\n"
"$ git switch master\n"
"$ fix fix fix\n"
"$ git commit ;# 提交时有真实日志\n"
"$ git switch feature\n"
"$ git reset --soft HEAD^ ;# 回到 WIP 状态 <2>\n"
"$ git reset <3>\n"

#. type: Plain text
#: en/git-reset.txt:279
#, priority:280
msgid "This commit will get blown away so a throw-away log message is OK."
msgstr "这个提交会被吹走，所以扔掉的日志信息是可以的。"

#. type: Plain text
#: en/git-reset.txt:281
#, priority:280
msgid "This removes the 'WIP' commit from the commit history, and sets your working tree to the state just before you made that snapshot."
msgstr "这将从提交历史中删除 \"WIP \"提交，并将你的工作树设置为刚刚做出快照之前的状态。"

#. type: Plain text
#: en/git-reset.txt:284
#, priority:280
msgid "At this point the index file still has all the WIP changes you committed as 'snapshot WIP'. This updates the index to show your WIP files as uncommitted."
msgstr "在这一点上，索引文件仍然有你提交的所有WIP修改，作为 \"快照WIP\"。 这样就可以更新索引，将你的WIP文件显示为未提交的。"

#. type: Plain text
#: en/git-reset.txt:286
#, placeholders:'linkgit:git-stash[1]', priority:280
msgid "See also linkgit:git-stash[1]."
msgstr "也请参见 linkgit:git-stash[1]。"

#. type: Labeled list
#: en/git-reset.txt:287
#, no-wrap, priority:280
msgid "Reset a single file in the index"
msgstr "重置索引中的单个文件"

#. type: Plain text
#: en/git-reset.txt:292
#, priority:280
msgid "Suppose you have added a file to your index, but later decide you do not want to add it to your commit. You can remove the file from the index while keeping your changes with git reset."
msgstr "假设你在索引中添加了一个文件，但后来决定不想把它加入你的提交中。你可以用git reset将该文件从索引中删除，同时保留你的修改。"

#. type: delimited block -
#: en/git-reset.txt:297
#, no-wrap, priority:280
msgid ""
"$ git reset -- frotz.c                      <1>\n"
"$ git commit -m \"Commit files in index\"     <2>\n"
"$ git add frotz.c                           <3>\n"
msgstr ""
"$ git reset -- frotz.c <1>.\n"
"$ git commit -m \"将文件存入索引\" <2>\n"
"$ git add frotz.c <3>\n"

#. type: Plain text
#: en/git-reset.txt:301
#, priority:280
msgid "This removes the file from the index while keeping it in the working directory."
msgstr "这将从索引中删除该文件，同时将其保留在工作目录中。"

#. type: Plain text
#: en/git-reset.txt:302
#, priority:280
msgid "This commits all other changes in the index."
msgstr "这将提交索引中的所有其他变化。"

#. type: Plain text
#: en/git-reset.txt:303
#, priority:280
msgid "Adds the file to the index again."
msgstr "再次将该文件添加到索引中。"

#. type: Labeled list
#: en/git-reset.txt:304
#, no-wrap, priority:280
msgid "Keep changes in working tree while discarding some previous commits"
msgstr "在工作树中保留修改，同时丢弃一些以前的提交内容"

#. type: Plain text
#: en/git-reset.txt:311
#, priority:280
msgid "Suppose you are working on something and you commit it, and then you continue working a bit more, but now you think that what you have in your working tree should be in another branch that has nothing to do with what you committed previously. You can start a new branch and reset it while keeping the changes in your working tree."
msgstr "假设你正在做某件事，并提交了它，然后你又继续做了一会儿，但现在你认为你工作树中的内容应该在另一个分支中，而这个分支与你之前提交的内容毫无关系。你可以启动一个新的分支，并重置它，同时保留工作树中的变化。"

#. type: delimited block -
#: en/git-reset.txt:320
#, ignore-ellipsis, no-wrap, placeholders:'--keep', priority:280
msgid ""
"$ git tag start\n"
"$ git switch -c branch1\n"
"$ edit\n"
"$ git commit ...                            <1>\n"
"$ edit\n"
"$ git switch -c branch2                     <2>\n"
"$ git reset --keep start                    <3>\n"
msgstr ""
"$ git tag start\n"
"$ git switch -c branch1\n"
"$ 编辑\n"
"$ git commit ...                            <1>\n"
"$ 编辑\n"
"$ git switch -c branch2                     <2>\n"
"$ git reset --keep start                    <3>\n"

#. type: Plain text
#: en/git-reset.txt:323
#, priority:280
msgid "This commits your first edits in `branch1`."
msgstr "这将提交你在 `branch1`中的第一次编辑。"

#. type: Plain text
#: en/git-reset.txt:327
#, priority:280
msgid "In the ideal world, you could have realized that the earlier commit did not belong to the new topic when you created and switched to `branch2` (i.e. `git switch -c branch2 start`), but nobody is perfect."
msgstr "在理想的世界里，你可以在创建并切换到 \"分支2\"（即 \"git switch -c branch2 start\"）时意识到先前的提交不属于新主题，但人无完人。"

#. type: Plain text
#: en/git-reset.txt:329
#, placeholders:'--keep`', priority:280
msgid "But you can use `reset --keep` to remove the unwanted commit after you switched to `branch2`."
msgstr "但你可以用`reset --keep`来删除你切换到`branch2`后不需要的提交。"

#. type: Labeled list
#: en/git-reset.txt:330
#, no-wrap, priority:280
msgid "Split a commit apart into a sequence of commits"
msgstr "将一个提交分割成一连串的提交"

#. type: Plain text
#: en/git-reset.txt:338
#, priority:280
msgid "Suppose that you have created lots of logically separate changes and committed them together. Then, later you decide that it might be better to have each logical chunk associated with its own commit. You can use git reset to rewind history without changing the contents of your local files, and then successively use `git add -p` to interactively select which hunks to include into each commit, using `git commit -c` to pre-populate the commit message."
msgstr "假设你创建了很多逻辑上独立的修改，并将它们一起提交。然后，后来你决定让每个逻辑块与自己的提交相关联可能更好。你可以使用 git reset 来回溯历史，而不改变本地文件的内容，然后连续使用 `git add -p` 来交互式地选择哪些块包含在每个提交中，使用 `git commit -c` 来预先填入提交信息。"

#. type: delimited block -
#: en/git-reset.txt:348
#, ignore-ellipsis, no-wrap, placeholders:'HEAD':'--cached':'HEAD':'{1}':'--cached', priority:280
msgid ""
"$ git reset -N HEAD^                        <1>\n"
"$ git add -p                                <2>\n"
"$ git diff --cached                         <3>\n"
"$ git commit -c HEAD@{1}                    <4>\n"
"...                                         <5>\n"
"$ git add ...                               <6>\n"
"$ git diff --cached                         <7>\n"
"$ git commit ...                            <8>\n"
msgstr ""
"$ git reset -N HEAD^ <1>\n"
"$ git add -p <2>\n"
"$ git diff --cached <3>\n"
"$ git commit -c HEAD@{1}.                    <4>\n"
"...                                         <5>\n"
"$ git add ...                               <6>\n"
"$ git diff --cached <7>\n"
"$ git commit ...                            <8>\n"

#. type: Plain text
#: en/git-reset.txt:354
#, placeholders:'HEAD', priority:280
msgid "First, reset the history back one commit so that we remove the original commit, but leave the working tree with all the changes. The -N ensures that any new files added with `HEAD` are still marked so that `git add -p` will find them."
msgstr "首先，将历史记录向后重设一次提交，这样我们就删除了原始提交，但保留了工作树上的所有修改。N确保任何用`HEAD`添加的新文件仍然被标记，以便`git add -p`能够找到它们。"

#. type: Plain text
#: en/git-reset.txt:358
#, priority:280
msgid "Next, we interactively select diff hunks to add using the `git add -p` facility. This will ask you about each diff hunk in sequence and you can use simple commands such as \"yes, include this\", \"No don't include this\" or even the very powerful \"edit\" facility."
msgstr "接下来，我们使用 \"git add -p \"工具，交互式地选择要添加的diff hunks。这将依次询问每个差异块，你可以使用简单的命令，如 \"是，包括这个\"，\"不，不包括这个\"，甚至是非常强大的 \"编辑 \"工具。"

#. type: Plain text
#: en/git-reset.txt:362
#, placeholders:'--cached`', priority:280
msgid "Once satisfied with the hunks you want to include, you should verify what has been prepared for the first commit by using `git diff --cached`. This shows all the changes that have been moved into the index and are about to be committed."
msgstr "一旦对你想要包括的hunks感到满意，你应该通过使用`git diff --cached`来验证为第一次提交准备了什么。这将显示所有已经移入索引并即将提交的修改。"

#. type: Plain text
#: en/git-reset.txt:369
#, placeholders:'`-c`':'HEAD':'{1}':'HEAD':'linkgit:git-reflog[1]', priority:280
msgid "Next, commit the changes stored in the index. The `-c` option specifies to pre-populate the commit message from the original message that you started with in the first commit. This is helpful to avoid retyping it. The `HEAD@{1}` is a special notation for the commit that `HEAD` used to be at prior to the original reset commit (1 change ago). See linkgit:git-reflog[1] for more details. You may also use any other valid commit reference."
msgstr "接下来，提交存储在索引中的修改。`-c`选项指定从你第一次提交时的原始信息中预先填入提交信息。这对避免重复输入很有帮助。`HEAD@{1}`是一个特殊的符号，表示`HEAD`在最初的重置提交（1次变更前）之前曾经处于的提交。 更多细节见 linkgit:git-reflog[1]。你也可以使用任何其他有效的提交参考。"

#. type: Plain text
#: en/git-reset.txt:371
#, priority:280
msgid "You can repeat steps 2-4 multiple times to break the original code into any number of commits."
msgstr "你可以多次重复第2-4步，将原始代码分解成任意数量的提交。"

#. type: Plain text
#: en/git-reset.txt:374
#, priority:280
msgid "Now you've split out many of the changes into their own commits, and might no longer use the patch mode of `git add`, in order to select all remaining uncommitted changes."
msgstr "现在你已经把许多修改拆成了自己的提交，可能不再使用`git add`的补丁模式，以便选择所有剩余的未提交的修改。"

#. type: Plain text
#: en/git-reset.txt:377
#, priority:280
msgid "Once again, check to verify that you've included what you want to. You may also wish to verify that git diff doesn't show any remaining changes to be committed later."
msgstr "再一次检查以确认你已经包含了你想要的东西。你可能还想确认git diff没有显示任何剩余的修改，以便以后提交。"

#. type: Plain text
#: en/git-reset.txt:378
#, priority:280
msgid "And finally create the final commit."
msgstr "最后创建最后的提交。"

#. type: Plain text
#: en/git-reset.txt:384
#, priority:280
msgid "The tables below show what happens when running:"
msgstr "下面的表格显示了运行时发生的情况："

#. type: delimited block -
#: en/git-reset.txt:387
#, no-wrap, placeholders:'--option', priority:280
msgid "git reset --option target\n"
msgstr "git reset --option 目标\n"

#. type: Plain text
#: en/git-reset.txt:391
#, placeholders:'HEAD', priority:280
msgid "to reset the `HEAD` to another commit (`target`) with the different reset options depending on the state of the files."
msgstr "来重置`HEAD`到另一个提交（`target`），根据文件的状态，有不同的重置选项。"

#. type: Plain text
#: en/git-reset.txt:400
#, placeholders:'HEAD':'--soft':'HEAD', priority:280
msgid "In these tables, `A`, `B`, `C` and `D` are some different states of a file. For example, the first line of the first table means that if a file is in state `A` in the working tree, in state `B` in the index, in state `C` in `HEAD` and in state `D` in the target, then `git reset --soft target` will leave the file in the working tree in state `A` and in the index in state `B`. It resets (i.e. moves) the `HEAD` (i.e. the tip of the current branch, if you are on one) to `target` (which has the file in state `D`)."
msgstr "在这些表中，`A`、`B`、`C`和`D`是一个文件的一些不同状态。例如，第一个表格的第一行意味着如果一个文件在工作树中处于`A`状态，在索引中处于`B`状态，在`HEAD`中处于`C`状态，在目标中处于`D`状态，那么`git reset --soft target`将使文件在工作树中处于`A`状态，在索引中处于`B`状态。 它重设（即移动）`HEAD`（即当前分支的顶端，如果你在一个分支上）到`target`（它的文件处于`D`状态）。"

#. type: delimited block .
#: en/git-reset.txt:409
#, no-wrap, placeholders:'HEAD':'HEAD':'----------------------------------------------------':'--soft':'--mixed':'--hard':'--merge':'--keep', priority:280
msgid ""
"working index HEAD target         working index HEAD\n"
"----------------------------------------------------\n"
" A       B     C    D     --soft   A       B     D\n"
"\t\t\t  --mixed  A       D     D\n"
"\t\t\t  --hard   D       D     D\n"
"\t\t\t  --merge (disallowed)\n"
"\t\t\t  --keep  (disallowed)\n"
msgstr ""
"工作索引 HEAD 目标工作索引 HEAD\n"
"----------------------------------------------------\n"
" A B C D --soft(软的) A B D\n"
"\t\t\t  --mixed(混合型) A D D\n"
"\t\t\t  --hard(硬的) D D D\n"
"\t\t\t  --merge(合并) (不允许)\n"
"\t\t\t  --keep(保持) (不允许)\n"

#. type: delimited block .
#: en/git-reset.txt:419
#, no-wrap, placeholders:'HEAD':'HEAD':'----------------------------------------------------':'--soft':'--mixed':'--hard':'--merge':'--keep', priority:280
msgid ""
"working index HEAD target         working index HEAD\n"
"----------------------------------------------------\n"
" A       B     C    C     --soft   A       B     C\n"
"\t\t\t  --mixed  A       C     C\n"
"\t\t\t  --hard   C       C     C\n"
"\t\t\t  --merge (disallowed)\n"
"\t\t\t  --keep   A       C     C\n"
msgstr ""
"工作索引 HEAD 目标工作索引 HEAD\n"
"----------------------------------------------------\n"
" A B C C --soft(软的) A B C\n"
"\t\t\t  --mixed(混合型) A C C\n"
"\t\t\t  --hard(硬性) C C C\n"
"\t\t\t  --merge(合并)(不允许)\n"
"\t\t\t  --keep(保持) A C C\n"

#. type: delimited block .
#: en/git-reset.txt:429
#, no-wrap, placeholders:'HEAD':'HEAD':'----------------------------------------------------':'--soft':'--mixed':'--hard':'--merge':'--keep', priority:280
msgid ""
"working index HEAD target         working index HEAD\n"
"----------------------------------------------------\n"
" B       B     C    D     --soft   B       B     D\n"
"\t\t\t  --mixed  B       D     D\n"
"\t\t\t  --hard   D       D     D\n"
"\t\t\t  --merge  D       D     D\n"
"\t\t\t  --keep  (disallowed)\n"
msgstr ""
"工作索引 HEAD 目标工作索引 HEAD\n"
"----------------------------------------------------\n"
" B B C D --soft(软) B B D\n"
"\t\t\t  --mixed(混合型) B D D\n"
"\t\t\t  --hard(硬的) D D D\n"
"\t\t\t  --merge(合并) D D D\n"
"\t\t\t  --keep(保持)(不允许)\n"

#. type: delimited block .
#: en/git-reset.txt:439
#, no-wrap, placeholders:'HEAD':'HEAD':'----------------------------------------------------':'--soft':'--mixed':'--hard':'--merge':'--keep', priority:280
msgid ""
"working index HEAD target         working index HEAD\n"
"----------------------------------------------------\n"
" B       B     C    C     --soft   B       B     C\n"
"\t\t\t  --mixed  B       C     C\n"
"\t\t\t  --hard   C       C     C\n"
"\t\t\t  --merge  C       C     C\n"
"\t\t\t  --keep   B       C     C\n"
msgstr ""
"工作索引 HEAD 目标工作索引 HEAD\n"
"----------------------------------------------------\n"
" B B C C --soft(软) B B C\n"
"\t\t\t  --mixed(混合型) B C C\n"
"\t\t\t  --hard(硬性) C C C\n"
"\t\t\t  --merge(合并) C C C\n"
"\t\t\t  --keep(保持) B C C\n"

#. type: delimited block .
#: en/git-reset.txt:449
#, no-wrap, placeholders:'HEAD':'HEAD':'----------------------------------------------------':'--soft':'--mixed':'--hard':'--merge':'--keep', priority:280
msgid ""
"working index HEAD target         working index HEAD\n"
"----------------------------------------------------\n"
" B       C     C    D     --soft   B       C     D\n"
"\t\t\t  --mixed  B       D     D\n"
"\t\t\t  --hard   D       D     D\n"
"\t\t\t  --merge (disallowed)\n"
"\t\t\t  --keep  (disallowed)\n"
msgstr ""
"工作索引 HEAD 目标工作索引 HEAD\n"
"----------------------------------------------------\n"
" B C C D --soft(软) B C D\n"
"\t\t\t  --mixed(混合型) B D D\n"
"\t\t\t  --hard(硬的) D D D\n"
"\t\t\t  --merge(合并) (不允许)\n"
"\t\t\t  --keep(保持) (不允许)\n"

#. type: delimited block .
#: en/git-reset.txt:459
#, no-wrap, placeholders:'HEAD':'HEAD':'----------------------------------------------------':'--soft':'--mixed':'--hard':'--merge':'--keep', priority:280
msgid ""
"working index HEAD target         working index HEAD\n"
"----------------------------------------------------\n"
" B       C     C    C     --soft   B       C     C\n"
"\t\t\t  --mixed  B       C     C\n"
"\t\t\t  --hard   C       C     C\n"
"\t\t\t  --merge  B       C     C\n"
"\t\t\t  --keep   B       C     C\n"
msgstr ""
"工作索引 HEAD 目标工作索引 HEAD\n"
"----------------------------------------------------\n"
" B C C C --soft(软B) C C\n"
"\t\t\t  --mixed(混合型) B C C\n"
"\t\t\t  --hard(硬性) C C C\n"
"\t\t\t  --merge(合并) B C C\n"
"\t\t\t  --keep(保持) B C C\n"

# ERROR: `--merge` not found in translation
#. type: Plain text
#: en/git-reset.txt:469
#, placeholders:'--merge`':'`--merge`', priority:280
msgid "`reset --merge` is meant to be used when resetting out of a conflicted merge. Any mergy operation guarantees that the working tree file that is involved in the merge does not have a local change with respect to the index before it starts, and that it writes the result out to the working tree. So if we see some difference between the index and the target and also between the index and the working tree, then it means that we are not resetting out from a state that a mergy operation left after failing with a conflict. That is why we disallow `--merge` option in this case."
msgstr "`reset --merge`是指在重设冲突的合并时使用。任何合并操作都会保证参与合并的工作树文件在开始之前没有相对于索引的局部变化，并且会将结果写入工作树。因此，如果我们看到索引和目标之间，以及索引和工作树之间有一些差异，那么这意味着我们没有从一个合并操作失败后留下的冲突状态中重新设置出来。这就是为什么我们在这种情况下不允许使用 `--merge` 选项。"

# ERROR: --keep` not found in translation
#. type: Plain text
#: en/git-reset.txt:478
#, placeholders:'--keep`':'HEAD':'HEAD', priority:280
msgid "`reset --keep` is meant to be used when removing some of the last commits in the current branch while keeping changes in the working tree. If there could be conflicts between the changes in the commit we want to remove and the changes in the working tree we want to keep, the reset is disallowed. That's why it is disallowed if there are both changes between the working tree and `HEAD`, and between `HEAD` and the target. To be safe, it is also disallowed when there are unmerged entries."
msgstr "`reset --keep` 意思是在删除当前分支中的一些最后的提交，同时保留工作树中的修改时使用。如果我们想删除的提交和我们想保留的工作树上的修改之间可能存在冲突，那么重置是不允许的。这就是为什么如果工作树和 `HEAD` 之间，以及 `HEAD` 和目标之间都有变化，那么就不允许重置。为了安全起见，当有未合并的条目时，也不允许这样做。"

#. type: Plain text
#: en/git-reset.txt:481
#, priority:280
msgid "The following tables show what happens when there are unmerged entries:"
msgstr "下表显示了有未合并的条目时发生的情况："

#. type: delimited block .
#: en/git-reset.txt:490
#, no-wrap, placeholders:'HEAD':'HEAD':'----------------------------------------------------':'--soft':'--mixed':'--hard':'--merge':'--keep', priority:280
msgid ""
"working index HEAD target         working index HEAD\n"
"----------------------------------------------------\n"
" X       U     A    B     --soft  (disallowed)\n"
"\t\t\t  --mixed  X       B     B\n"
"\t\t\t  --hard   B       B     B\n"
"\t\t\t  --merge  B       B     B\n"
"\t\t\t  --keep  (disallowed)\n"
msgstr ""
"工作索引 HEAD 目标工作索引 HEAD\n"
"----------------------------------------------------\n"
" X U A B --soft(软)（不允许）。\n"
"\t\t\t  --mixed(混合型) X B B\n"
"\t\t\t  --hard(硬的) B B B\n"
"\t\t\t  --merge(合并) B B B\n"
"\t\t\t  --keep(保持) (不允许)\n"

#. type: delimited block .
#: en/git-reset.txt:500
#, no-wrap, placeholders:'HEAD':'HEAD':'----------------------------------------------------':'--soft':'--mixed':'--hard':'--merge':'--keep', priority:280
msgid ""
"working index HEAD target         working index HEAD\n"
"----------------------------------------------------\n"
" X       U     A    A     --soft  (disallowed)\n"
"\t\t\t  --mixed  X       A     A\n"
"\t\t\t  --hard   A       A     A\n"
"\t\t\t  --merge  A       A     A\n"
"\t\t\t  --keep  (disallowed)\n"
msgstr ""
"工作索引 HEAD 目标工作索引 HEAD\n"
"----------------------------------------------------\n"
" X U A A --soft(软) (不允许)\n"
"\t\t\t  --mixed(混合型) X A A\n"
"\t\t\t  --hard(硬性) A A A\n"
"\t\t\t  --merge(合并) A A A\n"
"\t\t\t  --keep(保持) (不允许)\n"

#. type: Plain text
#: en/git-reset.txt:503
#, priority:280
msgid "`X` means any state and `U` means an unmerged index."
msgstr "`X`指任何状态，`U`指未合并的索引。"

#. type: Title =
#: en/git-restore.txt:2
#, ignore-same, no-wrap, priority:280
msgid "git-restore(1)"
msgstr "git-restore(1)"

#. type: Plain text
#: en/git-restore.txt:7
#, placeholders:'git-restore', priority:280
msgid "git-restore - Restore working tree files"
msgstr "git-restore - 恢复工作树文件"

#. type: Plain text
#: en/git-restore.txt:14
#, ignore-ellipsis, no-wrap, placeholders:'[--source=':'[--staged]':'[--worktree]':'[--source=':'[--staged]':'[--worktree]':'--pathspec-from-file=':'[--pathspec-file-nul]':'--patch':'[--source=':'[--staged]':'[--worktree]', priority:280
msgid ""
"'git restore' [<options>] [--source=<tree>] [--staged] [--worktree] [--] <pathspec>...\n"
"'git restore' [<options>] [--source=<tree>] [--staged] [--worktree] --pathspec-from-file=<file> [--pathspec-file-nul]\n"
"'git restore' (-p|--patch) [<options>] [--source=<tree>] [--staged] [--worktree] [--] [<pathspec>...]\n"
msgstr ""
"'git restore' [<options>] [--source=<tree>] [--staged] [--worktree] [--] <pathspec>...\n"
"'git restore' [<options>] [--source=<tree>] [--staged] [--worktree] --pathspec-from-file=<file> [--pathspec-file-nul] 。\n"
"'git restore' (-p|--patch) [<options>] [--source=<tree>] [--staged] [--worktree] [--] [<pathspec>...]\n"

#. type: Plain text
#: en/git-restore.txt:20
#, priority:280
msgid "Restore specified paths in the working tree with some contents from a restore source. If a path is tracked but does not exist in the restore source, it will be removed to match the source."
msgstr "用还原源的一些内容还原工作树中的指定路径。如果一个路径被跟踪，但在还原源中不存在，它将被删除以匹配源。"

#. type: Plain text
#: en/git-restore.txt:24
#, placeholders:'`--staged`':'`--staged':'--worktree`', priority:280
msgid "The command can also be used to restore the content in the index with `--staged`, or restore both the working tree and the index with `--staged --worktree`."
msgstr "该命令还可以用来用`--staged`恢复索引中的内容，或者用`--staged --worktree`同时恢复工作树和索引。"

#. type: Plain text
#: en/git-restore.txt:27
#, placeholders:'`--staged`':'HEAD':'`--source`', priority:280
msgid "By default, if `--staged` is given, the contents are restored from `HEAD`, otherwise from the index. Use `--source` to restore from a different commit."
msgstr "默认情况下，如果给了`--staged`，内容将从`HEAD`恢复，否则从索引恢复。使用`--source`来恢复不同的提交。"

#. type: Plain text
#: en/git-restore.txt:32 en/git-switch.txt:33
#, priority:280
msgid "THIS COMMAND IS EXPERIMENTAL. THE BEHAVIOR MAY CHANGE."
msgstr "这个命令是试验性的。其行为可能会改变。"

#. type: Labeled list
#: en/git-restore.txt:35
#, no-wrap, priority:280
msgid "-s <tree>"
msgstr "-s <目录树>"

#. type: Labeled list
#: en/git-restore.txt:36
#, no-wrap, placeholders:'--source=', priority:280
msgid "--source=<tree>"
msgstr "--source=<目录树>"

#. type: Plain text
#: en/git-restore.txt:40
#, priority:280
msgid "Restore the working tree files with the content from the given tree. It is common to specify the source tree by naming a commit, branch or tag associated with it."
msgstr "用给定树的内容恢复工作树的文件。通常是通过命名与之相关的提交、分支或标签来指定源树。"

#. type: Plain text
#: en/git-restore.txt:43
#, placeholders:'HEAD':'`--staged`', priority:280
msgid "If not specified, the contents are restored from `HEAD` if `--staged` is given, otherwise from the index."
msgstr "如果没有指定，如果给了`--staged`，则从`HEAD`恢复内容，否则从索引恢复。"

# ERROR: --patch not found in translation
#. type: Plain text
#: en/git-restore.txt:54
#, placeholders:'linkgit:git-add[1]':'`--patch`', priority:280
msgid "Interactively select hunks in the difference between the restore source and the restore location. See the ``Interactive Mode'' section of linkgit:git-add[1] to learn how to operate the `--patch` mode."
msgstr "交互式地选择还原源和还原位置之间的差异中的猎物。参见 linkgit:git-add[1] 的 ''互动模式'' 部分，了解如何操作 `--patch` 模式。"

#. type: Plain text
#: en/git-restore.txt:57
#, placeholders:'`--patch`', priority:280
msgid "Note that `--patch` can accept no pathspec and will prompt to restore all modified paths."
msgstr "请注意，`--patch`可以不接受任何pathspec，并会提示恢复所有修改的路径。"

#. type: Labeled list
#: en/git-restore.txt:60 en/git-stash.txt:211
#, ignore-same, no-wrap, priority:280
msgid "-S"
msgstr "-S"

#. type: Labeled list
#: en/git-restore.txt:61 en/git-stash.txt:212
#, ignore-same, no-wrap, priority:280
msgid "--staged"
msgstr "--staged"

#. type: Plain text
#: en/git-restore.txt:65
#, placeholders:'`--staged`', priority:280
msgid "Specify the restore location. If neither option is specified, by default the working tree is restored. Specifying `--staged` will only restore the index. Specifying both restores both."
msgstr "指定恢复的位置。如果两个选项都没有指定，默认情况下会还原工作树。指定`--staged`将只恢复索引。指定两个选项将同时还原。"

# ERROR: `--no-progress` not found in translation
#. type: Plain text
#: en/git-restore.txt:69
#, placeholders:'`--no-progress`', priority:280
msgid "Quiet, suppress feedback messages. Implies `--no-progress`."
msgstr "安静，抑制反馈信息。意味着 `--no-progress`。"

#. type: Plain text
#: en/git-restore.txt:83
#, placeholders:'`--source`', priority:280
msgid "When restoring files in the working tree from the index, use stage #2 ('ours') or #3 ('theirs') for unmerged paths. This option cannot be used when checking out paths from a tree-ish (i.e. with the `--source` option)."
msgstr "从索引中恢复工作目录树中的文件时，未合并的路径应使用第 #2 阶段（‘我们的’）或第 #3 阶段（‘他们的’）。 从工作目录树（即使用 `--source` 选项）中检出路径时，不能使用该选项。"

#. type: Plain text
#: en/git-restore.txt:87
#, placeholders:'--rebase`':'linkgit:git-checkout[1]', priority:280
msgid "Note that during `git rebase` and `git pull --rebase`, 'ours' and 'theirs' may appear swapped. See the explanation of the same options in linkgit:git-checkout[1] for details."
msgstr "注意，在`git rebase`和`git pull --rebase`过程中，'我们的'和'他们的'可能会出现互换。详见 linkgit:git-checkout[1] 中对相同选项的解释。"

#. type: Plain text
#: en/git-restore.txt:94
#, placeholders:'`--source`', priority:280
msgid "When restoring files on the working tree from the index, recreate the conflicted merge in the unmerged paths. This option cannot be used when checking out paths from a tree-ish (i.e. with the `--source` option)."
msgstr "从索引中恢复工作目录树上的文件时，在未合并路径中重新创建冲突合并。 该选项不能用于从工作目录树中检出路径（即使用 `--source` 选项）。"

#. type: Labeled list
#: en/git-restore.txt:101
#, ignore-same, no-wrap, priority:280
msgid "--ignore-unmerged"
msgstr "--ignore-unmerged"

# ERROR: --ours not found in translation
# ERROR: --theirs not found in translation
# ERROR: --merge not found in translation
# ERROR: --conflict not found in translation
#. type: Plain text
#: en/git-restore.txt:106
#, placeholders:'`--ours`':'`--theirs`':'`--merge`':'`--conflict`', priority:280
msgid "When restoring files on the working tree from the index, do not abort the operation if there are unmerged entries and neither `--ours`, `--theirs`, `--merge` or `--conflict` is specified. Unmerged paths on the working tree are left alone."
msgstr "当从索引中恢复工作目录树上的文件时，如果有未合并的条目，并且没有指定 `--ours`、`--theirs` 、`--merge` 或 `--conflict` ，不要中止操作。工作目录树上未合并的路径将被忽略。"

#. type: Plain text
#: en/git-restore.txt:113
#, placeholders:'$GIT_DIR', priority:280
msgid "In sparse checkout mode, the default is to only update entries matched by `<pathspec>` and sparse patterns in $GIT_DIR/info/sparse-checkout. This option ignores the sparse patterns and unconditionally restores any files in `<pathspec>`."
msgstr "在稀疏检出模式下，默认情况下只更新由`<路径规范>`和$GIT_DIR/info/sparse-checkout 中稀疏模式匹配的条目。这个选项忽略了稀疏模式，无条件地恢复了符合 `<路径规范>` 中的任何文件。"

#. type: Plain text
#: en/git-restore.txt:124
#, placeholders:'`--no-recurse-submodules`':'linkgit:git-checkout[1]':'HEAD', priority:280
msgid "If `<pathspec>` names an active submodule and the restore location includes the working tree, the submodule will only be updated if this option is given, in which case its working tree will be restored to the commit recorded in the superproject, and any local modifications overwritten. If nothing (or `--no-recurse-submodules`) is used, submodules working trees will not be updated. Just like linkgit:git-checkout[1], this will detach `HEAD` of the submodule."
msgstr "如果`<pathspec>`命名了一个活动的子模块，并且恢复的位置包括工作树，只有在给出这个选项的情况下，子模块才会被更新，在这种情况下，它的工作树将被恢复到超级项目中记录的提交，并且任何本地修改都会被覆盖。如果什么都不使用（或`--no-recurse-submodules`），子模块的工作树将不会被更新。就像linkgit:git-checkout[1]，这将分离子模块的`HEAD`。"

# ERROR: --source not found in translation
#. type: Plain text
#: en/git-restore.txt:131
#, placeholders:'`--source`', priority:280
msgid "In overlay mode, the command never removes files when restoring. In no-overlay mode, tracked files that do not appear in the `--source` tree are removed, to make them match `<tree>` exactly. The default is no-overlay mode."
msgstr "在覆盖模式下，该命令在恢复时不会删除文件。在无覆盖模式下，不出现在 `--source` 树中的被追踪文件会被删除，以使它们与 `<目录树>` 完全匹配。默认是无覆盖模式。"

#. type: Plain text
#: en/git-restore.txt:159
#, priority:280
msgid "The following sequence switches to the `master` branch, reverts the `Makefile` to two revisions back, deletes hello.c by mistake, and gets it back from the index."
msgstr "下面的序列切换到 \"master \"分支，将 \"Makefile \"恢复到两个修订版，错误地删除了hello.c，并从索引中取回它。"

#. type: delimited block -
#: en/git-restore.txt:165
#, no-wrap, placeholders:'--source', priority:280
msgid ""
"$ git switch master\n"
"$ git restore --source master~2 Makefile  <1>\n"
"$ rm -f hello.c\n"
"$ git restore hello.c                     <2>\n"
msgstr ""
"$ git switch master\n"
"$ git restore --source master~2 Makefile  <1>\n"
"$ rm -f hello.c\n"
"$ git restore hello.c                     <2>\n"

#. type: Plain text
#: en/git-restore.txt:169
#, priority:280
msgid "restore hello.c from the index"
msgstr "从索引中恢复 hello.c"

#. type: Plain text
#: en/git-restore.txt:172
#, priority:280
msgid "If you want to restore _all_ C source files to match the version in the index, you can say"
msgstr "如果你想恢复_所有的C源文件，使之与索引中的版本一致，你可以说"

#. type: delimited block -
#: en/git-restore.txt:175
#, no-wrap, priority:280
msgid "$ git restore '*.c'\n"
msgstr "$ git restore '*.c'\n"

#. type: Plain text
#: en/git-restore.txt:181
#, priority:280
msgid "Note the quotes around `*.c`. The file `hello.c` will also be restored, even though it is no longer in the working tree, because the file globbing is used to match entries in the index (not in the working tree by the shell)."
msgstr "注意 \"*.c \"周围的引号。 文件`hello.c`也将被恢复，尽管它已经不在工作树中了，因为文件globbing是用来匹配索引中的条目的（不是由shell在工作树中）。"

#. type: Plain text
#: en/git-restore.txt:183
#, priority:280
msgid "To restore all files in the current directory"
msgstr "要恢复当前目录下的所有文件"

#. type: delimited block -
#: en/git-restore.txt:186
#, no-wrap, priority:280
msgid "$ git restore .\n"
msgstr "$ git restore .\n"

#. type: Plain text
#: en/git-restore.txt:190
#, placeholders:'linkgit:gitglossary[7]', priority:280
msgid "or to restore all working tree files with 'top' pathspec magic (see linkgit:gitglossary[7])"
msgstr "或者用 'top' 路径规范恢复所有工作目录树文件（见linkgit:gitglossary[7]）"

#. type: delimited block -
#: en/git-restore.txt:193
#, no-wrap, priority:280
msgid "$ git restore :/\n"
msgstr "$ git restore :/\n"

#. type: Plain text
#: en/git-restore.txt:197
#, placeholders:'HEAD':'linkgit:git-reset[1]', priority:280
msgid "To restore a file in the index to match the version in `HEAD` (this is the same as using linkgit:git-reset[1])"
msgstr "将索引中的文件恢复到与 `HEAD` 中的版本一致（这与使用linkgit:git-reset[1]相同）"

#. type: delimited block -
#: en/git-restore.txt:200
#, no-wrap, placeholders:'--staged', priority:280
msgid "$ git restore --staged hello.c\n"
msgstr "$ git restore --staged hello.c\n"

#. type: Plain text
#: en/git-restore.txt:204
#, placeholders:'linkgit:git-checkout[1]', priority:280
msgid "or you can restore both the index and the working tree (this is the same as using linkgit:git-checkout[1])"
msgstr "或者你可以同时恢复索引和工作目录树（这与使用 linkgit:git-checkout[1] 相同）"

#. type: delimited block -
#: en/git-restore.txt:207
#, no-wrap, placeholders:'--source=HEAD':'--staged':'--worktree', priority:280
msgid "$ git restore --source=HEAD --staged --worktree hello.c\n"
msgstr "$ git restore --source=HEAD --staged --worktree hello.c\n"

#. type: Plain text
#: en/git-restore.txt:210
#, priority:280
msgid "or the short form which is more practical but less readable:"
msgstr "或更实用但可读性较差的简短形式："

#. type: delimited block -
#: en/git-restore.txt:213
#, no-wrap, priority:280
msgid "$ git restore -s@ -SW hello.c\n"
msgstr "$ git restore -s@ -SW hello.c\n"

#. type: Plain text
#: en/git-restore.txt:219
#, ignore-same, priority:280
msgid "linkgit:git-checkout[1], linkgit:git-reset[1]"
msgstr "linkgit:git-checkout[1], linkgit:git-reset[1]"

#. type: Title =
#: en/git-revert.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-revert(1)"
msgstr "git-revert(1)"

#. type: Plain text
#: en/git-revert.txt:7
#, placeholders:'git-revert', priority:100
msgid "git-revert - Revert some existing commits"
msgstr "git-revert - 还原某些现有提交"

#. type: Plain text
#: en/git-revert.txt:13
#, ignore-ellipsis, no-wrap, placeholders:'--continue':'--skip':'--abort':'--quit', priority:100
msgid ""
"'git revert' [--[no-]edit] [-n] [-m <parent-number>] [-s] [-S[<keyid>]] <commit>...\n"
"'git revert' (--continue | --skip | --abort | --quit)\n"
msgstr ""
"'git revert' [--[no-]edit] [-n] [-m <父提交数量>] [-s] [-S[<键 ID>]] <提交>...\n"
"'git revert' (--continue | --skip | --abort | --quit)\n"

#. type: Plain text
#: en/git-revert.txt:21
#, placeholders:'HEAD', priority:100
msgid "Given one or more existing commits, revert the changes that the related patches introduce, and record some new commits that record them. This requires your working tree to be clean (no modifications from the HEAD commit)."
msgstr "给定一个或多个现有提交，还原相关补丁引入的更改，并记录一些新提交来记录这些更改。 这要求你的工作区是干净的（没有对 HEAD 提交的修改）。"

#. type: Plain text
#: en/git-revert.txt:30
#, placeholders:'linkgit:git-reset[1]':'`--hard`':'linkgit:git-restore[1]':'`--source`', priority:100
msgid "Note: 'git revert' is used to record some new commits to reverse the effect of some earlier commits (often only a faulty one). If you want to throw away all uncommitted changes in your working directory, you should see linkgit:git-reset[1], particularly the `--hard` option. If you want to extract specific files as they were in another commit, you should see linkgit:git-restore[1], specifically the `--source` option. Take care with these alternatives as both will discard uncommitted changes in your working directory."
msgstr "注意：'git revert' 用于记录一些新的提交，以扭转先前提交（通常只是错误的提交）的影响。 如果您想丢弃工作目录中所有未提交的改动，请参阅 linkgit:git-reset[1]，尤其是 `--hard` 选项。 如果你想提取其他提交中的特定文件，请参阅 linkgit:git-restore[1]，尤其是 `--source`选项。使用这些选项时要小心，因为它们都会丢弃工作目录中未提交的改动。"

#. type: Plain text
#: en/git-revert.txt:43
#, placeholders:'linkgit:gitrevisions[7]':'linkgit:git-rev-list[1]':'`--no-walk`', priority:100
msgid "Commits to revert. For a more complete list of ways to spell commit names, see linkgit:gitrevisions[7]. Sets of commits can also be given but no traversal is done by default, see linkgit:git-rev-list[1] and its `--no-walk` option."
msgstr "要还原的提交。 更完整的提交名拼写方式，请参见 linkgit:gitrevisions[7]。 也可以给出提交集，但默认情况下不进行遍历，参见 linkgit:git-rev-list[1] 及其 `--no-walk`选项。"

#. type: Plain text
#: en/git-revert.txt:49
#, priority:100
msgid "With this option, 'git revert' will let you edit the commit message prior to committing the revert. This is the default if you run the command from a terminal."
msgstr "有了这个选项，'git revert' 会让你在提交之前编辑提交信息。如果从终端运行该命令，默认情况下也是如此。"

#. type: Labeled list
#: en/git-revert.txt:50
#, no-wrap, priority:100
msgid "-m parent-number"
msgstr "-m 父编号"

#. type: Labeled list
#: en/git-revert.txt:51
#, no-wrap, placeholders:'--mainline', priority:100
msgid "--mainline parent-number"
msgstr "--mainline parent-number"

#. type: Plain text
#: en/git-revert.txt:57
#, priority:100
msgid "Usually you cannot revert a merge because you do not know which side of the merge should be considered the mainline. This option specifies the parent number (starting from 1) of the mainline and allows revert to reverse the change relative to the specified parent."
msgstr "通常情况下，由于不知道合并的哪一方应被视为主线，因此无法还原合并。 该选项指定了主线的父线编号（从 1 开始），允许还原指令相对于指定的父线反向更改。"

#. type: Plain text
#: en/git-revert.txt:62
#, priority:100
msgid "Reverting a merge commit declares that you will never want the tree changes brought in by the merge. As a result, later merges will only bring in tree changes introduced by commits that are not ancestors of the previously reverted merge. This may or may not be what you want."
msgstr "还原合并提交就意味着你永远不需要合并带来的目录树变化。 因此，以后的合并只会引入目录树变化，而这些变化不是由先前已还原合并的祖先提交引入的。 这可能是你想要的，也可能不是。"

#. type: Plain text
#: en/git-revert.txt:65
#, placeholders:'link:howto/revert-a-faulty-merge.html[', priority:100
msgid "See the link:howto/revert-a-faulty-merge.html[revert-a-faulty-merge How-To] for more details."
msgstr "更多详情，请参阅 link:howto/revert-a-faulty-merge.html[revert-a-faulty-merge 如何操作]。"

#. type: Plain text
#: en/git-revert.txt:69
#, priority:100
msgid "With this option, 'git revert' will not start the commit message editor."
msgstr "使用该选项后，'git revert' 将不会启动提交信息编辑器。"

#. type: Plain text
#: en/git-revert.txt:87
#, placeholders:'HEAD', priority:100
msgid "Usually the command automatically creates some commits with commit log messages stating which commits were reverted. This flag applies the changes necessary to revert the named commits to your working tree and the index, but does not make the commits. In addition, when this option is used, your index does not have to match the HEAD commit. The revert is done against the beginning state of your index."
msgstr "通常，该命令会自动创建一些提交，并在提交日志信息中说明哪些提交被还原。 该标记会对工作区和索引进行必要的修改，以还原指定的提交，但不会进行提交。 此外，使用该选项时，索引不必与 HEAD 提交相匹配。 还原是针对索引的起始状态进行的。"

#. type: Plain text
#: en/git-revert.txt:90
#, priority:100
msgid "This is useful when reverting more than one commits' effect to your index in a row."
msgstr "这在连续恢复多个提交对索引的影响时非常有用。"

#. type: Labeled list
#: en/git-revert.txt:117
#, ignore-same, no-wrap, priority:100
msgid "--reference"
msgstr "--reference"

#. type: Plain text
#: en/git-revert.txt:124
#, placeholders:'--pretty=reference':'linkgit:git-log[1]':'revert.reference', priority:100
msgid "Instead of starting the body of the log message with \"This reverts <full-object-name-of-the-commit-being-reverted>.\", refer to the commit using \"--pretty=reference\" format (cf. linkgit:git-log[1]). The `revert.reference` configuration variable can be used to enable this option by default."
msgstr "而不是以 “他还原了 <完整的提交对象名称>。” 作为日志信息的开头，而是使用 \"--pretty=reference\" 格式来引用提交（参见 linkgit:git-log[1]）。 `revert.reference` 配置变量可用于默认启用此选项。"

#. type: Labeled list
#: en/git-revert.txt:132
#, no-wrap, placeholders:'HEAD', priority:100
msgid "`git revert HEAD~3`"
msgstr "`git revert HEAD~3`"

#. type: Plain text
#: en/git-revert.txt:136
#, placeholders:'HEAD', priority:100
msgid "Revert the changes specified by the fourth last commit in HEAD and create a new commit with the reverted changes."
msgstr "还原 HEAD 中倒数第四个提交指定的更改，并创建一个包含还原更改的新提交。"

#. type: Labeled list
#: en/git-revert.txt:137
#, no-wrap, priority:100
msgid "`git revert -n master~5..master~2`"
msgstr "`git revert -n master~5..master~2`"

#. type: Plain text
#: en/git-revert.txt:144
#, priority:100
msgid "Revert the changes done by commits from the fifth last commit in master (included) to the third last commit in master (included), but do not create any commit with the reverted changes. The revert only modifies the working tree and the index."
msgstr "将 master 中倒数第五次提交（包含）到 master 中倒数第三次提交（包含）的改动还原，但不创建任何包含还原改动的提交。还原只会修改工作区和索引。"

#. type: Plain text
#: en/git-revert.txt:154
#, priority:100
msgid "While git creates a basic commit message automatically, it is _strongly_ recommended to explain why the original commit is being reverted. In addition, repeatedly reverting reverts will result in increasingly unwieldy subject lines, for example 'Reapply \"Reapply \"<original-subject>\"\"'. Please consider rewording these to be shorter and more unique."
msgstr "虽然 git 会自动创建基本的提交信息，但强烈建议解释为什么要还原原始提交。 此外，反复还原会导致主题行越来越笨重，例如 \"Reapply \"Reapply \"<original subject>\"\"。 请考虑重新措辞，使其更简短、更独特。"

#. type: Title =
#: en/git-rev-list.txt:2
#, ignore-same, no-wrap, priority:80
msgid "git-rev-list(1)"
msgstr "git-rev-list(1)"

#. type: Plain text
#: en/git-rev-list.txt:7
#, placeholders:'git-rev-list', priority:80
msgid "git-rev-list - Lists commit objects in reverse chronological order"
msgstr "git-rev-list 按照时间倒序列出提交对象"

#. type: Plain text
#: en/git-rev-list.txt:13
#, ignore-ellipsis, no-wrap, placeholders:'git rev-list', priority:80
msgid "'git rev-list' [<options>] <commit>... [--] [<path>...]\n"
msgstr "'git rev-list' [<选项>] <提交>... [[--] <路径>...]\n"

#. type: Plain text
#: en/git-rev-list.txt:25
#, priority:80
msgid "'rev-list' is an essential Git command, since it provides the ability to build and traverse commit ancestry graphs. For this reason, it has a lot of different options that enable it to be used by commands as different as 'git bisect' and 'git repack'."
msgstr "'rev-list' 是一个非常必要的Git命令，因为它提供了构建和遍历祖先图的功能。正因如此，它有很多不同的选项，使得它可以被不同的命令使用，如 'git bisect' 和 'git repack'。"

#. type: Plain text
#: en/git-rev-list.txt:38
#, priority:80
msgid "Print the list of commits reachable from the current branch."
msgstr "打印可从当前分支访问的提交列表。"

#. type: delimited block -
#: en/git-rev-list.txt:41
#, no-wrap, placeholders:'git rev-list':'HEAD', priority:80
msgid "git rev-list HEAD\n"
msgstr "git rev-list HEAD\n"

#. type: Plain text
#: en/git-rev-list.txt:45
#, priority:80
msgid "Print the list of commits on this branch, but not present in the upstream branch."
msgstr "打印该分支上但上游分支中没有的提交列表。"

# ERROR: {upstream} not found in translation
#. type: delimited block -
#: en/git-rev-list.txt:48
#, no-wrap, placeholders:'git rev-list':'{upstream}':'HEAD', priority:80
msgid "git rev-list @{upstream}..HEAD\n"
msgstr "git rev-list @{upstream}..HEAD\n"

#. type: Plain text
#: en/git-rev-list.txt:52
#, placeholders:'linkgit:git-log[1]', priority:80
msgid "Format commits with their author and commit message (see also the porcelain linkgit:git-log[1])."
msgstr "将提交格式化为作者和提交信息（另见上层命令 linkgit:git-log[1]）。"

#. type: delimited block -
#: en/git-rev-list.txt:55
#, no-wrap, placeholders:'git rev-list':'--format=medium':'HEAD', priority:80
msgid "git rev-list --format=medium HEAD\n"
msgstr "git rev-list --format=medium HEAD\n"

#. type: Plain text
#: en/git-rev-list.txt:59
#, placeholders:'linkgit:git-log[1]', priority:80
msgid "Format commits along with their diffs (see also the porcelain linkgit:git-log[1], which can do this in a single process)."
msgstr "格式化提交及其差异（另请参阅上层命令 linkgit:git-log[1]，它可以在单个进程中完成此操作）。"

#. type: delimited block -
#: en/git-rev-list.txt:63
#, no-wrap, placeholders:'git rev-list':'HEAD':'git diff-tree':'--stdin':'--format=medium', priority:80
msgid ""
"git rev-list HEAD |\n"
"git diff-tree --stdin --format=medium -p\n"
msgstr ""
"git rev-list HEAD |\n"
"git diff-tree --stdin --format=medium -p\n"

#. type: Plain text
#: en/git-rev-list.txt:67
#, priority:80
msgid "Print the list of commits on the current branch that touched any file in the `Documentation` directory."
msgstr "打印当前分支中触及 `Documentation` 目录中任何文件的提交列表。"

#. type: delimited block -
#: en/git-rev-list.txt:70
#, no-wrap, placeholders:'git rev-list':'HEAD', priority:80
msgid "git rev-list HEAD -- Documentation/\n"
msgstr "git rev-list HEAD -- Documentation/\n"

#. type: Plain text
#: en/git-rev-list.txt:74
#, priority:80
msgid "Print the list of commits authored by you in the past year, on any branch, tag, or other ref."
msgstr "打印您在过去一年中在任何分支、标记或其他引用上提交的提交列表。"

#. type: delimited block -
#: en/git-rev-list.txt:77
#, no-wrap, placeholders:'git rev-list':'--author=you':'--since=1':'year.ago':'--all', priority:80
msgid "git rev-list --author=you@example.com --since=1.year.ago --all\n"
msgstr "git rev-list --author=you@example.com --since=1.year.ago --all\n"

#. type: Plain text
#: en/git-rev-list.txt:81
#, priority:80
msgid "Print the list of objects reachable from the current branch (i.e., all commits and the blobs and trees they contain)."
msgstr "打印可从当前分支到达的对象列表（即所有提交及其包含的 blobs 和目录树）。"

#. type: delimited block -
#: en/git-rev-list.txt:84
#, no-wrap, placeholders:'git rev-list':'--objects':'HEAD', priority:80
msgid "git rev-list --objects HEAD\n"
msgstr "git rev-list --objects HEAD\n"

#. type: Plain text
#: en/git-rev-list.txt:91
#, priority:80
msgid "Compare the disk size of all reachable objects, versus those reachable from reflogs, versus the total packed size. This can tell you whether running `git repack -ad` might reduce the repository size (by dropping unreachable objects), and whether expiring reflogs might help."
msgstr "比较所有可到达对象的磁盘大小、可从引用日志到达的对象的磁盘大小以及打包后的总大小。这可以告诉你运行 `git repack -ad` 是否会减少仓库的大小（通过丢弃无法访问的对象），以及过期的引用日志是否会有帮助。"

#. type: delimited block -
#: en/git-rev-list.txt:101
#, no-wrap, placeholders:'git rev-list':'--disk-usage':'--objects':'--all':'git rev-list':'--disk-usage':'--objects':'--all':'--reflog':'git count-objects', priority:80
msgid ""
"# reachable objects\n"
"git rev-list --disk-usage --objects --all\n"
"# plus reflogs\n"
"git rev-list --disk-usage --objects --all --reflog\n"
"# total disk size used\n"
"du -c .git/objects/pack/*.pack .git/objects/??/*\n"
"# alternative to du: add up \"size\" and \"size-pack\" fields\n"
"git count-objects -v\n"
msgstr ""
"# 可达对象\n"
"git rev-list --disk-usage --objects --all\n"
"# 加上 reflog\n"
"git rev-list --disk-usage --objects --all --reflog\n"
"# 所有占用的磁盘空间\n"
"du -c .git/objects/pack/*.pack .git/objects/??/*\n"
"# 切换到 du: 将 \"size\" 和 \"size-pack\" 字段合计\n"
"git count-objects -v\n"

#. type: Plain text
#: en/git-rev-list.txt:107
#, priority:80
msgid "Report the disk size of each branch, not including objects used by the current branch. This can find outliers that are contributing to a bloated repository size (e.g., because somebody accidentally committed large build artifacts)."
msgstr "报告每个分支的磁盘大小，不包括当前分支使用的对象。这样就能发现导致仓库大小臃肿的异常值（例如，因为有人不小心提交了大容量的构建工件）。"

#. type: delimited block -
#: en/git-rev-list.txt:116
#, no-wrap, placeholders:'git for-each-ref':'--format=':'git rev-list':'--disk-usage':'--objects':'HEAD':'$branch':'$size':'$branch', priority:80
msgid ""
"git for-each-ref --format='%(refname)' |\n"
"while read branch\n"
"do\n"
"\tsize=$(git rev-list --disk-usage --objects HEAD..$branch)\n"
"\techo \"$size $branch\"\n"
"done |\n"
"sort -n\n"
msgstr ""
"git for-each-ref --format='%(引用名)' |\n"
"while read branch\n"
"do\n"
"\tsize=$(git rev-list --disk-usage --objects HEAD..$branch)\n"
"\techo \"$size $branch\"\n"
"done |\n"
"sort -n\n"

#. type: Plain text
#: en/git-rev-list.txt:122
#, priority:80
msgid "Compare the on-disk size of branches in one group of refs, excluding another. If you co-mingle objects from multiple remotes in a single repository, this can show which remotes are contributing to the repository size (taking the size of `origin` as a baseline)."
msgstr "比较一组分支的磁盘大小，排除另一组分支。如果在单个版本库中共同混合了来自多个远程的对象，这可以显示哪些远程对仓库的大小有影响（以 `origin` 的大小为基准）。"

#. type: delimited block -
#: en/git-rev-list.txt:125
#, no-wrap, placeholders:'git rev-list':'--disk-usage':'--objects':'--remotes=':'$suspect':'--not':'--remotes=origin', priority:80
msgid "git rev-list --disk-usage --objects --remotes=$suspect --not --remotes=origin\n"
msgstr "git rev-list --disk-usage --objects --remotes=$suspect --not --remotes=origin\n"

#. type: Title =
#: en/git-rev-parse.txt:2
#, ignore-same, no-wrap, priority:80
msgid "git-rev-parse(1)"
msgstr "git-rev-parse(1)"

#. type: Plain text
#: en/git-rev-parse.txt:7
#, placeholders:'git-rev-parse', priority:80
msgid "git-rev-parse - Pick out and massage parameters"
msgstr "git-rev-parse - 挑选并调整参数"

#. type: Plain text
#: en/git-rev-parse.txt:13
#, ignore-ellipsis, no-wrap, placeholders:'git rev-parse', priority:80
msgid "'git rev-parse' [<options>] <args>...\n"
msgstr "'git rev-parse' [<选项>] <参数>...\n"

#. type: Plain text
#: en/git-rev-parse.txt:23
#, placeholders:'git rev-list':'git rev-list', priority:80
msgid "Many Git porcelainish commands take a mixture of flags (i.e. parameters that begin with a dash '-') and parameters meant for the underlying 'git rev-list' command they use internally and flags and parameters for the other commands they use downstream of 'git rev-list'. This command is used to distinguish between them."
msgstr "许多 Git 上层命令会混合使用一些标记（即以破折号 '-' 开头的参数）和参数，这些标记和参数既用于内部使用的底层 'git rev-list' 命令，也用于 'git rev-list' 下游的其他命令。 这条命令就是用来区分它们的。"

#. type: Title ~
#: en/git-rev-parse.txt:29
#, no-wrap, priority:80
msgid "Operation Modes"
msgstr "操作模式"

#. type: Plain text
#: en/git-rev-parse.txt:32
#, priority:80
msgid "Each of these options must appear first on the command line."
msgstr "这些选项都必须在命令行中首先出现。"

#. type: Labeled list
#: en/git-rev-parse.txt:33
#, ignore-same, no-wrap, priority:80
msgid "--parseopt"
msgstr "--parseopt"

#. type: Plain text
#: en/git-rev-parse.txt:35
#, placeholders:'git rev-parse', priority:80
msgid "Use 'git rev-parse' in option parsing mode (see PARSEOPT section below)."
msgstr "在选项解析模式下使用 'git rev-parse' （见下文 PARSEOPT 部分）。"

#. type: Labeled list
#: en/git-rev-parse.txt:36
#, ignore-same, no-wrap, priority:80
msgid "--sq-quote"
msgstr "--sq-quote"

#. type: Plain text
#: en/git-rev-parse.txt:40
#, placeholders:'git rev-parse':'`--sq`', priority:80
msgid "Use 'git rev-parse' in shell quoting mode (see SQ-QUOTE section below). In contrast to the `--sq` option below, this mode only does quoting. Nothing else is done to command input."
msgstr "在 shell 引用模式下使用 'git rev-parse'（见下文 SQ-QUOTE 部分）。与下面的 `--sq` 选项不同，该模式只进行引用。对命令输入不做任何其他处理。"

#. type: Title ~
#: en/git-rev-parse.txt:42
#, no-wrap, placeholders:'--parseopt', priority:80
msgid "Options for --parseopt"
msgstr "--parseopt 的选项"

#. type: Labeled list
#: en/git-rev-parse.txt:44
#, ignore-same, no-wrap, priority:80
msgid "--keep-dashdash"
msgstr "--keep-dashdash"

#. type: Plain text
#: en/git-rev-parse.txt:47
#, placeholders:'`--parseopt`', priority:80
msgid "Only meaningful in `--parseopt` mode. Tells the option parser to echo out the first `--` met instead of skipping it."
msgstr "仅在 `--parseopt` 模式下有效。告诉选项解析器回显第一个`--` 而不是跳过它。"

#. type: Labeled list
#: en/git-rev-parse.txt:48
#, ignore-same, no-wrap, priority:80
msgid "--stop-at-non-option"
msgstr "--stop-at-non-option"

#. type: Plain text
#: en/git-rev-parse.txt:52
#, placeholders:'`--parseopt`', priority:80
msgid "Only meaningful in `--parseopt` mode. Lets the option parser stop at the first non-option argument. This can be used to parse sub-commands that take options themselves."
msgstr "仅在 `--parseopt` 模式下有效。 让选项解析器在第一个非选项参数时停止。 这可用于解析本身包含选项的子命令。"

#. type: Labeled list
#: en/git-rev-parse.txt:53
#, ignore-same, no-wrap, priority:80
msgid "--stuck-long"
msgstr "--stuck-long"

#. type: Plain text
#: en/git-rev-parse.txt:56
#, placeholders:'`--parseopt`', priority:80
msgid "Only meaningful in `--parseopt` mode. Output the options in their long form if available, and with their arguments stuck."
msgstr "仅在 `--parseopt` 模式下有效。如果有的话，以长形式输出选项，并保留参数。"

#. type: Title ~
#: en/git-rev-parse.txt:58
#, no-wrap, priority:80
msgid "Options for Filtering"
msgstr "筛选选项"

#. type: Labeled list
#: en/git-rev-parse.txt:60
#, ignore-same, no-wrap, priority:80
msgid "--revs-only"
msgstr "--revs-only"

#. type: Plain text
#: en/git-rev-parse.txt:63
#, placeholders:'git rev-list', priority:80
msgid "Do not output flags and parameters not meant for 'git rev-list' command."
msgstr "不输出与 'git rev-list' 命令无关的标志和参数。"

#. type: Labeled list
#: en/git-rev-parse.txt:64
#, ignore-same, no-wrap, priority:80
msgid "--no-revs"
msgstr "--no-revs"

#. type: Plain text
#: en/git-rev-parse.txt:67
#, placeholders:'git rev-list', priority:80
msgid "Do not output flags and parameters meant for 'git rev-list' command."
msgstr "不输出用于 'git rev-list' 命令的标志和参数。"

#. type: Labeled list
#: en/git-rev-parse.txt:68
#, ignore-same, no-wrap, priority:80
msgid "--flags"
msgstr "--flags"

#. type: Plain text
#: en/git-rev-parse.txt:70
#, priority:80
msgid "Do not output non-flag parameters."
msgstr "不输出非标志参数。"

#. type: Labeled list
#: en/git-rev-parse.txt:71
#, ignore-same, no-wrap, priority:80
msgid "--no-flags"
msgstr "--no-flags"

#. type: Plain text
#: en/git-rev-parse.txt:73
#, priority:80
msgid "Do not output flag parameters."
msgstr "不输出标记参数。"

#. type: Title ~
#: en/git-rev-parse.txt:75
#, no-wrap, priority:80
msgid "Options for Output"
msgstr "输出选项"

#. type: Labeled list
#: en/git-rev-parse.txt:77
#, no-wrap, placeholders:'--default', priority:80
msgid "--default <arg>"
msgstr "--default <参数>"

#. type: Plain text
#: en/git-rev-parse.txt:80
#, priority:80
msgid "If there is no parameter given by the user, use `<arg>` instead."
msgstr "如果用户没有提供参数，则使用 `<参数>` 代替。"

#. type: Labeled list
#: en/git-rev-parse.txt:81
#, no-wrap, placeholders:'--prefix', priority:80
msgid "--prefix <arg>"
msgstr "--prefix <参数>"

#. type: Plain text
#: en/git-rev-parse.txt:86
#, placeholders:'git rev-parse', priority:80
msgid "Behave as if 'git rev-parse' was invoked from the `<arg>` subdirectory of the working tree. Any relative filenames are resolved as if they are prefixed by `<arg>` and will be printed in that form."
msgstr "就像从工作树的 `<参数>` 子目录调用 'git rev-parse'一样。 任何相对文件名都会被解析为以 `<参数>` 为前缀，并以这种形式打印。"

#. type: Plain text
#: en/git-rev-parse.txt:90
#, priority:80
msgid "This can be used to convert arguments to a command run in a subdirectory so that they can still be used after moving to the top-level of the repository. For example:"
msgstr "这可用于转换在子目录中运行的命令的参数，以便在移动到仓库顶层后仍可使用。 例如："

#. type: delimited block -
#: en/git-rev-parse.txt:96
#, no-wrap, placeholders:'git rev-parse':'--show-prefix':'git rev-parse':'--show-toplevel':'git rev-parse':'--sq':'--prefix':'$prefix', priority:80
msgid ""
"prefix=$(git rev-parse --show-prefix)\n"
"cd \"$(git rev-parse --show-toplevel)\"\n"
"# rev-parse provides the -- needed for 'set'\n"
"eval \"set $(git rev-parse --sq --prefix \"$prefix\" -- \"$@\")\"\n"
msgstr ""
"prefix=$(git rev-parse --show-prefix)\n"
"cd \"$(git rev-parse --show-toplevel)\"\n"
"# rev-parse 提供 'set' 所需的 --\n"
"eval \"set $(git rev-parse --sq --prefix \"$prefix\" -- \"$@\")\"\n"

#. type: Plain text
#: en/git-rev-parse.txt:103
#, priority:80
msgid "Verify that exactly one parameter is provided, and that it can be turned into a raw 20-byte SHA-1 that can be used to access the object database. If so, emit it to the standard output; otherwise, error out."
msgstr "验证是否正好提供了一个参数，并且该参数可以转化为原始的 20 字节 SHA-1 用于访问对象数据库。如果可以，则将其输出到标准输出；否则，出错。"

#. type: Plain text
#: en/git-rev-parse.txt:112
#, placeholders:'{type}':'git rev-parse':'$VAR':'{commit}':'$VAR':'$VAR':'git rev-parse':'$VAR':'{object}', priority:80
msgid "If you want to make sure that the output actually names an object in your object database and/or can be used as a specific type of object you require, you can add the `^{type}` peeling operator to the parameter. For example, `git rev-parse \"$VAR^{commit}\"` will make sure `$VAR` names an existing object that is a commit-ish (i.e. a commit, or an annotated tag that points at a commit). To make sure that `$VAR` names an existing object of any type, `git rev-parse \"$VAR^{object}\"` can be used."
msgstr "如果您想确保输出结果确实命名了对象数据库中的对象，并且/或者可以用作您需要的特定类型的对象，您可以在参数中添加 `^{type}` 剥离运算符。 例如，`git rev-parse \"$VAR^{commit}\"` 将确保 `$VAR` 命名的现有对象是一个类似提交的对象（即一个提交，或一个指向提交的注释标记）。 要确保 `$VAR` 命名的是任何类型的现有对象，可以使用 `git rev-parse \"$VAR^{object}\"。"

#. type: Plain text
#: en/git-rev-parse.txt:116
#, placeholders:'`--end-of-options`', priority:80
msgid "Note that if you are verifying a name from an untrusted source, it is wise to use `--end-of-options` so that the name argument is not mistaken for another option."
msgstr "请注意，如果要验证来自不可信来源的名称，最好使用 `--end-of-options`，以免名称参数被误认为其他选项。"

#. type: Plain text
#: en/git-rev-parse.txt:123
#, placeholders:'`--verify`', priority:80
msgid "Only meaningful in `--verify` mode. Do not output an error message if the first argument is not a valid object name; instead exit with non-zero status silently. SHA-1s for valid object names are printed to stdout on success."
msgstr "仅在 `--verify` 模式下有效。如果第一个参数不是有效的对象名，则不输出错误信息；而是以非零状态无声退出。 成功时，有效对象名称的 SHA-1 会打印到标准输出流。"

#. type: Labeled list
#: en/git-rev-parse.txt:124
#, ignore-same, no-wrap, priority:80
msgid "--sq"
msgstr "--sq"

# ERROR: --sq-quote not found in translation
#. type: Plain text
#: en/git-rev-parse.txt:132
#, placeholders:'`-S`':'{asterisk}':'`--sq-quote`', priority:80
msgid "Usually the output is made one line per flag and parameter. This option makes output a single line, properly quoted for consumption by shell. Useful when you expect your parameter to contain whitespaces and newlines (e.g. when using pickaxe `-S` with 'git diff-{asterisk}'). In contrast to the `--sq-quote` option, the command input is still interpreted as usual."
msgstr "通常情况下，每个标志和参数的输出为一行。 该选项使输出成为单行，并适当加引号供 shell 使用。 当你希望你的参数包含空格和换行符时（例如在使用 pickaxe `-S` 和 'git diff-{asterisk}'时），这个选项很有用。与 `--sq-quote` 选项相反，命令输入仍按常规解释。"

# ERROR: --short[=length] not found in translation
#. type: Labeled list
#: en/git-rev-parse.txt:133
#, ignore-same, no-wrap, priority:80
msgid "--short[=length]"
msgstr "--short[=length]"

#. type: Plain text
#: en/git-rev-parse.txt:138
#, placeholders:'`--verify`':'core.abbrev':'linkgit:git-config[1]', priority:80
msgid "Same as `--verify` but shortens the object name to a unique prefix with at least `length` characters. The minimum length is 4, the default is the effective value of the `core.abbrev` configuration variable (see linkgit:git-config[1])."
msgstr "与 `--verify` 模式相同，但会将对象名称缩短为至少包含 `长度` 字符的唯一前缀。最小长度为 4，默认值为配置变量 `core.abbrev` 的有效值（参见 linkgit:git-config[1]）。"

#. type: Plain text
#: en/git-rev-parse.txt:143
#, placeholders:'{caret}':'{caret}', priority:80
msgid "When showing object names, prefix them with '{caret}' and strip '{caret}' prefix from the object names that already have one."
msgstr "显示对象名称时，以 '{caret}' 作为前缀，并从已有前缀的对象名称中去掉 '{caret}'。"

#. type: Labeled list
#: en/git-rev-parse.txt:144
#, ignore-same, no-wrap, priority:80
msgid "--abbrev-ref[=(strict|loose)]"
msgstr "--abbrev-ref[=(strict|loose)]"

#. type: Plain text
#: en/git-rev-parse.txt:148
#, placeholders:'core.warnAmbiguousRefs', priority:80
msgid "A non-ambiguous short name of the objects name. The option core.warnAmbiguousRefs is used to select the strict abbreviation mode."
msgstr "对象名称的非含混简称。 选项 core.warnAmbiguousRefs 用于选择严格缩写模式。"

#. type: Labeled list
#: en/git-rev-parse.txt:149
#, ignore-same, no-wrap, priority:80
msgid "--symbolic"
msgstr "--symbolic"

#. type: Plain text
#: en/git-rev-parse.txt:153
#, placeholders:'{caret}', priority:80
msgid "Usually the object names are output in SHA-1 form (with possible '{caret}' prefix); this option makes them output in a form as close to the original input as possible."
msgstr "通常情况下，对象名称以 SHA-1 形式输出（可能带有 '{caret}' 前缀）；该选项使其输出形式尽可能接近原始输入。"

#. type: Labeled list
#: en/git-rev-parse.txt:154
#, ignore-same, no-wrap, priority:80
msgid "--symbolic-full-name"
msgstr "--symbolic-full-name"

#. type: Plain text
#: en/git-rev-parse.txt:161
#, placeholders:'--symbolic', priority:80
msgid "This is similar to --symbolic, but it omits input that are not refs (i.e. branch or tag names; or more explicitly disambiguating \"heads/master\" form, when you want to name the \"master\" branch when there is an unfortunately named tag \"master\"), and shows them as full refnames (e.g. \"refs/heads/master\")."
msgstr "这与 --symbolic 类似，但它会省略非引用输入（即分支或标记名称；或更明确的消歧义 \"heads/master\" 形式，当你想命名 \"master\" 分支时，却有一个不幸命名为 \"master\" 的标记），而显示为完整的引用名称（例如 \"refs/heads/master\"）。"

#. type: Title ~
#: en/git-rev-parse.txt:163
#, no-wrap, priority:80
msgid "Options for Objects"
msgstr "对象选项"

#. type: Plain text
#: en/git-rev-parse.txt:167
#, priority:80
msgid "Show all refs found in `refs/`."
msgstr "显示在 `refs/` 中找到的所有引用。"

#. type: Labeled list
#: en/git-rev-parse.txt:168
#, ignore-same, no-wrap, priority:80
msgid "--branches[=pattern]"
msgstr "--branches[=pattern]"

#. type: Labeled list
#: en/git-rev-parse.txt:169
#, ignore-same, no-wrap, priority:80
msgid "--tags[=pattern]"
msgstr "--tags[=pattern]"

#. type: Labeled list
#: en/git-rev-parse.txt:170
#, ignore-same, no-wrap, priority:80
msgid "--remotes[=pattern]"
msgstr "--remotes[=pattern]"

#. type: Plain text
#: en/git-rev-parse.txt:174
#, priority:80
msgid "Show all branches, tags, or remote-tracking branches, respectively (i.e., refs found in `refs/heads`, `refs/tags`, or `refs/remotes`, respectively)."
msgstr "分别显示所有分支、标记或远程跟踪分支（即分别在 `refs/heads`、`refs/tags` 或 `refs/remotes`中找到的引用）。"

#. type: Plain text
#: en/git-rev-parse.txt:178
#, priority:80
msgid "If a `pattern` is given, only refs matching the given shell glob are shown. If the pattern does not contain a globbing character (`?`, `*`, or `[`), it is turned into a prefix match by appending `/*`."
msgstr "如果给定了 `pattern`, 则只显示与给定 shell glob 匹配的引用。 如果模式不包含 globing 字符（ `?`、 `*` 或 `[` ），则通过添加 `/*` 将其转换为前缀匹配。"

#. type: Labeled list
#: en/git-rev-parse.txt:179
#, ignore-same, no-wrap, priority:80
msgid "--glob=pattern"
msgstr "--glob=pattern"

#. type: Plain text
#: en/git-rev-parse.txt:185
#, priority:80
msgid "Show all refs matching the shell glob pattern `pattern`. If the pattern does not start with `refs/`, this is automatically prepended. If the pattern does not contain a globbing character (`?`, `*`, or `[`), it is turned into a prefix match by appending `/*`."
msgstr "显示与 shell glob 模式 `模式` 匹配的所有引用。如果模式不以 `refs/` 开头，则会自动预输入。 如果模式不包含 globing 字符（ `?` 、 `*` 或 `[` ），则会通过添加 `/*` 将其转换为前缀匹配。"

#. type: Labeled list
#: en/git-rev-parse.txt:186 en/rev-list-options.txt:187
#, no-wrap, placeholders:'--exclude=', priority:260
msgid "--exclude=<glob-pattern>"
msgstr "--exclude=<通配符模式>"

#. type: Plain text
#: en/git-rev-parse.txt:193 en/rev-list-options.txt:195
#, placeholders:'`--all`':'`--branches`':'`--tags`':'`--remotes`':'`--glob`':'`--all`':'`--branches`':'`--tags`':'`--remotes`':'`--glob`', priority:260
msgid "Do not include refs matching '<glob-pattern>' that the next `--all`, `--branches`, `--tags`, `--remotes`, or `--glob` would otherwise consider. Repetitions of this option accumulate exclusion patterns up to the next `--all`, `--branches`, `--tags`, `--remotes`, or `--glob` option (other options or arguments do not clear accumulated patterns)."
msgstr "不包括匹配\"<glob-pattern>\"的参考文献，否则下一个`--all`、`--branches`、`--tags`、`--remotes`或`--glob`会考虑这些参考文献。重复这个选项可以累积排除模式，直到下一个`----all`、`---branches`、`---tags`、`---remotes`或`---glob`选项（其他选项或参数不清除累积模式）。"

# ERROR: --branches not found in translation
# ERROR: --tags not found in translation
# ERROR: --remotes not found in translation
# ERROR: --all not found in translation
# ERROR: --tags not found in translation
#. type: Plain text
#: en/git-rev-parse.txt:199 en/rev-list-options.txt:201
#, placeholders:'`--branches`':'`--tags`':'`--remotes`':'`--glob`':'`--all`':'{asterisk}', priority:260
msgid "The patterns given should not begin with `refs/heads`, `refs/tags`, or `refs/remotes` when applied to `--branches`, `--tags`, or `--remotes`, respectively, and they must begin with `refs/` when applied to `--glob` or `--all`. If a trailing '/{asterisk}' is intended, it must be given explicitly."
msgstr "当应用于 `--branches`、 `--tags` 或 `--remotes` 时，所给出的模式不应以 `refs/heads`、`refs/tags` 或 `refs/remotes` 开头；当应用于 `--glob` 或 `--all` 选项时，必须以 `refs/` 开头。如果要使用尾部的 '/{asterisk}'，则必须明确给出。"

#. type: Labeled list
#: en/git-rev-parse.txt:200 en/rev-list-options.txt:202
#, ignore-same, no-wrap, priority:260
msgid "--exclude-hidden=[fetch|receive|uploadpack]"
msgstr "--exclude-hidden=[fetch|receive|uploadpack]"

#. type: Plain text
#: en/git-rev-parse.txt:207 en/rev-list-options.txt:209
#, placeholders:'git-fetch':'git-receive-pack':'git-upload-pack':'fetch.hideRefs':'receive.hideRefs':'uploadpack.hideRefs':'transfer.hideRefs':'linkgit:git-config[1]':'`--all`':'`--glob`', priority:260
msgid "Do not include refs that would be hidden by `git-fetch`, `git-receive-pack` or `git-upload-pack` by consulting the appropriate `fetch.hideRefs`, `receive.hideRefs` or `uploadpack.hideRefs` configuration along with `transfer.hideRefs` (see linkgit:git-config[1]). This option affects the next pseudo-ref option `--all` or `--glob` and is cleared after processing them."
msgstr "通过查阅相应的 `fetch.hideRefs` 、`receive.hideRefs` 或 `uploadpack.hideRefs` 配置和 `transfer.hideRefs` 配置（参见 linkgit:git-config[1]），不要包含会被 `git-fetch` 、`git-receive-pack` 或 `git-upload-pack` 隐藏的引用。该选项会影响下一个伪引用选项 `--all` 或 `--glob`，并在处理后清除。"

#. type: Labeled list
#: en/git-rev-parse.txt:208
#, no-wrap, placeholders:'--disambiguate=', priority:80
msgid "--disambiguate=<prefix>"
msgstr "--disambiguate=<前缀>"

#. type: Plain text
#: en/git-rev-parse.txt:213
#, priority:80
msgid "Show every object whose name begins with the given prefix. The <prefix> must be at least 4 hexadecimal digits long to avoid listing each and every object in the repository by mistake."
msgstr "显示名称以给定前缀开头的所有对象。 <前缀> 的长度必须至少为 4 个十六进制数字，以避免错误地列出仓库中的每个对象。"

#. type: Title ~
#: en/git-rev-parse.txt:215
#, no-wrap, priority:80
msgid "Options for Files"
msgstr "文件选项"

#. type: Labeled list
#: en/git-rev-parse.txt:217
#, ignore-same, no-wrap, priority:80
msgid "--local-env-vars"
msgstr "--local-env-vars"

#. type: Plain text
#: en/git-rev-parse.txt:222
#, placeholders:'GIT_DIR':'GIT_WORK_TREE':'GIT_EDITOR', priority:80
msgid "List the GIT_* environment variables that are local to the repository (e.g. GIT_DIR or GIT_WORK_TREE, but not GIT_EDITOR). Only the names of the variables are listed, not their value, even if they are set."
msgstr "列出仓库本地的 GIT_* 环境变量（例如 GIT_DIR 或 GIT_WORK_TREE，但不包括 GIT_EDITOR）。 只列出变量名，不列出变量值，即使变量已被设置。"

# ERROR: --path-format=(absolute|relative) not found in translation
#. type: Labeled list
#: en/git-rev-parse.txt:223
#, ignore-same, no-wrap, priority:80
msgid "--path-format=(absolute|relative)"
msgstr "--path-format=(absolute|relative)"

#. type: Plain text
#: en/git-rev-parse.txt:228
#, priority:80
msgid "Controls the behavior of certain other options. If specified as absolute, the paths printed by those options will be absolute and canonical. If specified as relative, the paths will be relative to the current working directory if that is possible. The default is option specific."
msgstr "控制某些其他选项的行为。如果指定为绝对路径，这些选项打印的路径将是绝对和规范的。如果指定为相对路径，路径将相对于当前工作目录（如果可能）。 默认情况下，路径将与选项相关。"

#. type: Plain text
#: en/git-rev-parse.txt:232
#, priority:80
msgid "This option may be specified multiple times and affects only the arguments that follow it on the command line, either to the end of the command line or the next instance of this option."
msgstr "该选项可以多次指定，并且只影响命令行中该选项后面的参数，要么影响到命令行的末尾，要么影响到该选项的下一个实例。"

#. type: Plain text
#: en/git-rev-parse.txt:234
#, placeholders:'`--path-format`', priority:80
msgid "The following options are modified by `--path-format`:"
msgstr "以下选项会被 `--path-format` 修改："

#. type: Labeled list
#: en/git-rev-parse.txt:235
#, ignore-same, no-wrap, priority:80
msgid "--git-dir"
msgstr "--git-dir"

#. type: Plain text
#: en/git-rev-parse.txt:239
#, placeholders:'$GIT_DIR', priority:80
msgid "Show `$GIT_DIR` if defined. Otherwise show the path to the .git directory. The path shown, when relative, is relative to the current working directory."
msgstr "如果已定义，则显示 `$GIT_DIR`。否则显示 .git 目录的路径。如果是相对路径，则显示当前工作目录的相对路径。"

#. type: Plain text
#: en/git-rev-parse.txt:243
#, placeholders:'$GIT_DIR', priority:80
msgid "If `$GIT_DIR` is not defined and the current directory is not detected to lie in a Git repository or work tree print a message to stderr and exit with nonzero status."
msgstr "如果未定义 `$GIT_DIR`，且未检测到当前目录位于 Git 仓库或工作区中，则向标准错误流打印一条信息，并以非零状态退出。"

#. type: Labeled list
#: en/git-rev-parse.txt:244
#, ignore-same, no-wrap, priority:80
msgid "--git-common-dir"
msgstr "--git-common-dir"

#. type: Plain text
#: en/git-rev-parse.txt:246
#, placeholders:'$GIT_COMMON_DIR':'$GIT_DIR', priority:80
msgid "Show `$GIT_COMMON_DIR` if defined, else `$GIT_DIR`."
msgstr "如果定义了 `$GIT_COMMON_DIR`，则显示 `$GIT_COMMON_DIR` ，否则显示 `$GIT_DIR`。"

#. type: Labeled list
#: en/git-rev-parse.txt:247
#, no-wrap, priority:80
msgid "--resolve-git-dir <path>"
msgstr "--resolve-git-dir <路径>"

#. type: Plain text
#: en/git-rev-parse.txt:252
#, priority:80
msgid "Check if <path> is a valid repository or a gitfile that points at a valid repository, and print the location of the repository. If <path> is a gitfile then the resolved path to the real repository is printed."
msgstr "检查 <路径> 是否为有效的版本库或指向有效仓库的 gitfile，并打印仓库的位置。 如果 <路径> 是 gitfile，则打印指向真实仓库的解析路径。"

#. type: Labeled list
#: en/git-rev-parse.txt:253
#, no-wrap, placeholders:'--git-path', priority:80
msgid "--git-path <path>"
msgstr "--git-path <路径>"

#. type: Plain text
#: en/git-rev-parse.txt:259
#, ignore-ellipsis, placeholders:'$GIT_DIR':'$GIT_OBJECT_DIRECTORY':'$GIT_INDEX_FILE':'$GIT_OBJECT_DIRECTORY':'git rev-parse':'--git-path', priority:80
msgid "Resolve \"$GIT_DIR/<path>\" and takes other path relocation variables such as $GIT_OBJECT_DIRECTORY, $GIT_INDEX_FILE... into account. For example, if $GIT_OBJECT_DIRECTORY is set to /foo/bar then \"git rev-parse --git-path objects/abc\" returns /foo/bar/abc."
msgstr "解析 \"$GIT_DIR/<路径>\"，并考虑其他路径重定位变量，如 $GIT_OBJECT_DIRECTORY、$GIT_INDEX_FILE...。例如，如果 $GIT_OBJECT_DIRECTORY 设置为 /foo/bar，那么 \"git rev-parse --git-path objects/abc\" 就会返回 /foo/bar/abc。"

#. type: Labeled list
#: en/git-rev-parse.txt:260
#, ignore-same, no-wrap, priority:80
msgid "--show-toplevel"
msgstr "--show-toplevel"

#. type: Plain text
#: en/git-rev-parse.txt:263
#, priority:80
msgid "Show the (by default, absolute) path of the top-level directory of the working tree. If there is no working tree, report an error."
msgstr "显示工作树顶层目录的路径（默认为绝对路径）。如果没有工作区，则会报错。"

#. type: Labeled list
#: en/git-rev-parse.txt:264
#, ignore-same, no-wrap, priority:80
msgid "--show-superproject-working-tree"
msgstr "--show-superproject-working-tree"

#. type: Plain text
#: en/git-rev-parse.txt:269
#, priority:80
msgid "Show the absolute path of the root of the superproject's working tree (if exists) that uses the current repository as its submodule. Outputs nothing if the current repository is not used as a submodule by any project."
msgstr "显示使用当前仓库作为子模块的父项目工作区（如果存在）根目录的绝对路径。 如果当前仓库未被任何项目用作子模块，则不输出任何内容。"

#. type: Labeled list
#: en/git-rev-parse.txt:270
#, ignore-same, no-wrap, priority:80
msgid "--shared-index-path"
msgstr "--shared-index-path"

#. type: Plain text
#: en/git-rev-parse.txt:273
#, priority:80
msgid "Show the path to the shared index file in split index mode, or empty if not in split-index mode."
msgstr "在分割索引模式下显示共享索引文件的路径，如果不在分割索引模式下则显示空路径。"

#. type: Plain text
#: en/git-rev-parse.txt:275
#, placeholders:'`--path-format`', priority:80
msgid "The following options are unaffected by `--path-format`:"
msgstr "以下选项不受 `--path-format` 影响："

#. type: Labeled list
#: en/git-rev-parse.txt:276
#, ignore-same, no-wrap, priority:80
msgid "--absolute-git-dir"
msgstr "--absolute-git-dir"

#. type: Plain text
#: en/git-rev-parse.txt:279
#, priority:80
msgid "Like `--git-dir`, but its output is always the canonicalized absolute path."
msgstr "类似于 `--git-dir`，但其输出始终是规范化的绝对路径。"

#. type: Labeled list
#: en/git-rev-parse.txt:280
#, ignore-same, no-wrap, priority:80
msgid "--is-inside-git-dir"
msgstr "--is-inside-git-dir"

#. type: Plain text
#: en/git-rev-parse.txt:283
#, priority:80
msgid "When the current working directory is below the repository directory print \"true\", otherwise \"false\"."
msgstr "当当前工作目录低于仓库目录时，打印 \"true\"，否则打印 \"false\"。"

#. type: Labeled list
#: en/git-rev-parse.txt:284
#, ignore-same, no-wrap, priority:80
msgid "--is-inside-work-tree"
msgstr "--is-inside-work-tree"

#. type: Plain text
#: en/git-rev-parse.txt:287
#, priority:80
msgid "When the current working directory is inside the work tree of the repository print \"true\", otherwise \"false\"."
msgstr "当当前工作目录位于仓库工作区内时，打印 \"true\"，否则打印 \"false\"。"

#. type: Labeled list
#: en/git-rev-parse.txt:288
#, ignore-same, no-wrap, priority:80
msgid "--is-bare-repository"
msgstr "--is-bare-repository"

#. type: Plain text
#: en/git-rev-parse.txt:290
#, priority:80
msgid "When the repository is bare print \"true\", otherwise \"false\"."
msgstr "当仓库为裸仓库时，打印 \"true\"，否则打印 \"false\"。"

#. type: Labeled list
#: en/git-rev-parse.txt:291
#, ignore-same, no-wrap, priority:80
msgid "--is-shallow-repository"
msgstr "--is-shallow-repository"

#. type: Plain text
#: en/git-rev-parse.txt:293
#, priority:80
msgid "When the repository is shallow print \"true\", otherwise \"false\"."
msgstr "当仓库是浅克隆时打印 \"true\"，否则打印 \"false\"。"

#. type: Labeled list
#: en/git-rev-parse.txt:294
#, ignore-same, no-wrap, priority:80
msgid "--show-cdup"
msgstr "--show-cdup"

#. type: Plain text
#: en/git-rev-parse.txt:298
#, priority:80
msgid "When the command is invoked from a subdirectory, show the path of the top-level directory relative to the current directory (typically a sequence of \"../\", or an empty string)."
msgstr "从子目录调用命令时，显示顶层目录相对于当前目录的路径（通常是 \".../\" 序列或空字符串）。"

#. type: Labeled list
#: en/git-rev-parse.txt:299
#, ignore-same, no-wrap, priority:80
msgid "--show-prefix"
msgstr "--show-prefix"

#. type: Plain text
#: en/git-rev-parse.txt:303
#, priority:80
msgid "When the command is invoked from a subdirectory, show the path of the current directory relative to the top-level directory."
msgstr "从子目录调用命令时，显示当前目录相对于顶层目录的路径。"

# ERROR: --show-object-format[=(storage|input|output)] not found in translation
#. type: Labeled list
#: en/git-rev-parse.txt:304
#, ignore-same, no-wrap, priority:80
msgid "--show-object-format[=(storage|input|output)]"
msgstr "--show-object-format[=(storage|input|output)]"

#. type: Plain text
#: en/git-rev-parse.txt:309
#, priority:80
msgid "Show the object format (hash algorithm) used for the repository for storage inside the `.git` directory, input, or output. For input, multiple algorithms may be printed, space-separated. If not specified, the default is \"storage\"."
msgstr "显示用于存储在 `.git` 目录内、输入或输出的仓库的对象格式（散列算法）。对于输入，可打印多种算法，以空格分隔。 如果未指定，默认为 “存储”。"

#. type: Labeled list
#: en/git-rev-parse.txt:310
#, ignore-same, no-wrap, priority:80
msgid "--show-ref-format"
msgstr "--show-ref-format"

#. type: Plain text
#: en/git-rev-parse.txt:312
#, priority:80
msgid "Show the reference storage format used for the repository."
msgstr "显示仓库使用的参考存储格式。"

#. type: Title ~
#: en/git-rev-parse.txt:315
#, no-wrap, priority:80
msgid "Other Options"
msgstr "其他选项"

# ERROR: --since=datestring not found in translation
#. type: Labeled list
#: en/git-rev-parse.txt:317
#, ignore-same, no-wrap, priority:80
msgid "--since=datestring"
msgstr "--since=datestring"

#. type: Labeled list
#: en/git-rev-parse.txt:318
#, ignore-same, no-wrap, priority:80
msgid "--after=datestring"
msgstr "--after=datestring"

#. type: Plain text
#: en/git-rev-parse.txt:321
#, placeholders:'--max-age=':'git rev-list', priority:80
msgid "Parse the date string, and output the corresponding --max-age= parameter for 'git rev-list'."
msgstr "解析日期字符串，并为 'git rev-list' 输出相应的 --max-age= 参数。"

#. type: Labeled list
#: en/git-rev-parse.txt:322
#, ignore-same, no-wrap, priority:80
msgid "--until=datestring"
msgstr "--until=datestring"

# ERROR: --before=datestring not found in translation
#. type: Labeled list
#: en/git-rev-parse.txt:323
#, ignore-same, no-wrap, priority:80
msgid "--before=datestring"
msgstr "--before=datestring"

#. type: Plain text
#: en/git-rev-parse.txt:326
#, placeholders:'--min-age=':'git rev-list', priority:80
msgid "Parse the date string, and output the corresponding --min-age= parameter for 'git rev-list'."
msgstr "解析日期字符串，并为 'git rev-list' 输出相应的 --min-age= 参数。"

#. type: Labeled list
#: en/git-rev-parse.txt:327
#, ignore-ellipsis, no-wrap, priority:80
msgid "<args>..."
msgstr "<多个参数>..."

#. type: Plain text
#: en/git-rev-parse.txt:329
#, priority:80
msgid "Flags and parameters to be parsed."
msgstr "要解析的标志和参数。"

#. type: Title -
#: en/git-rev-parse.txt:334
#, no-wrap, priority:80
msgid "PARSEOPT"
msgstr "PARSEOPT"

#. type: Plain text
#: en/git-rev-parse.txt:339
#, placeholders:'`--parseopt`':'git rev-parse', priority:80
msgid "In `--parseopt` mode, 'git rev-parse' helps massaging options to bring to shell scripts the same facilities C builtins have. It works as an option normalizer (e.g. splits single switches aggregate values), a bit like `getopt(1)` does."
msgstr "在 `--parseopt` 模式下，'git rev-parse' 可以帮助处理选项，为 shell 脚本带来与 C 语言内置程序相同的功能。它可以作为一个选项规范化器工作（例如分割单值和总值），有点像 `getopt(1)`。"

#. type: Plain text
#: en/git-rev-parse.txt:344
#, priority:80
msgid "It takes on the standard input the specification of the options to parse and understand, and echoes on the standard output a string suitable for `sh(1)` `eval` to replace the arguments with normalized ones. In case of error, it outputs usage on the standard error stream, and exits with code 129."
msgstr "它在标准输入端接收要解析和理解的选项说明，并在标准输出端回声一个适合 `sh(1)` `eval` 的字符串，以便用规范化参数替换参数。 如果出现错误，它会在标准错误流中输出使用情况，并以代码 129 退出。"

#. type: Plain text
#: en/git-rev-parse.txt:347
#, priority:80
msgid "Note: Make sure you quote the result when passing it to `eval`. See below for an example."
msgstr "注意：在将结果传递给 `eval` 时，请务必加上引号。 请参阅下面的示例。"

#. type: Title ~
#: en/git-rev-parse.txt:349
#, no-wrap, priority:80
msgid "Input Format"
msgstr "输入格式"

#. type: Plain text
#: en/git-rev-parse.txt:355
#, placeholders:'git rev-parse':'--parseopt', priority:80
msgid "'git rev-parse --parseopt' input format is fully text based. It has two parts, separated by a line that contains only `--`. The lines before the separator (should be one or more) are used for the usage. The lines after the separator describe the options."
msgstr "'git rev-parse --parseopt' 输入格式完全基于文本。它由两部分组成，中间用只包含 `--` 的行隔开。分隔符前的几行（应为一行或多行）用于说明用法。 分隔符之后的行描述选项。"

#. type: Plain text
#: en/git-rev-parse.txt:357
#, priority:80
msgid "Each line of options has this format:"
msgstr "每行选项的格式如下："

#. type: delimited block -
#: en/git-rev-parse.txt:360
#, no-wrap, priority:80
msgid "<opt-spec><flags>*<arg-hint>? SP+ help LF\n"
msgstr "<指定选项><标记>*<参数提示>? SP+ help LF\n"

#. type: Labeled list
#: en/git-rev-parse.txt:362
#, no-wrap, priority:80
msgid "`<opt-spec>`"
msgstr "`<opt-spec>`"

#. type: Plain text
#: en/git-rev-parse.txt:367
#, priority:80
msgid "its format is the short option character, then the long option name separated by a comma. Both parts are not required, though at least one is necessary. May not contain any of the `<flags>` characters. `h,help`, `dry-run` and `f` are examples of correct `<opt-spec>`."
msgstr "其格式是短选项字符，然后是用逗号分隔的长选项名称。两部分都不是必需的，但至少有一部分是必需的。不得包含任何 `<标记>` 字符。 `h,help` 、 `dry-run` 和 `f` 是正确的 `<指定选项>` 的例子。"

#. type: Labeled list
#: en/git-rev-parse.txt:368
#, no-wrap, priority:80
msgid "`<flags>`"
msgstr "`<标志>`"

#. type: Plain text
#: en/git-rev-parse.txt:370
#, priority:80
msgid "`<flags>` are of `*`, `=`, `?` or `!`."
msgstr "`<标志>` 是 `*`, `=`, `?` 或 `!` 其中一个。"

#. type: Plain text
#: en/git-rev-parse.txt:371
#, priority:80
msgid "Use `=` if the option takes an argument."
msgstr "如果选项需要一个参数，则使用 `=`。"

#. type: Plain text
#: en/git-rev-parse.txt:375
#, placeholders:'`--stuck-long`', priority:80
msgid "Use `?` to mean that the option takes an optional argument. You probably want to use the `--stuck-long` mode to be able to unambiguously parse the optional argument."
msgstr "使用 `?` 表示选项包含一个可选参数。你可能希望使用 `--stuck-long` 模式来明确地解析可选参数。"

#. type: Plain text
#: en/git-rev-parse.txt:379
#, placeholders:'`-h`':'`--help-all`':'linkgit:gitcli[7]', priority:80
msgid "Use `*` to mean that this option should not be listed in the usage generated for the `-h` argument. It's shown for `--help-all` as documented in linkgit:gitcli[7]."
msgstr "使用 `*` 表示该选项不应列在为 `-h` 参数生成的用法中。linkgit:gitcli[7] 中记录了 `--help-all` 的用法。"

#. type: Plain text
#: en/git-rev-parse.txt:381
#, priority:80
msgid "Use `!` to not make the corresponding negated long option available."
msgstr "使用 `!` 不提供相应的否定长选项。"

#. type: Labeled list
#: en/git-rev-parse.txt:382
#, no-wrap, priority:80
msgid "`<arg-hint>`"
msgstr "`<参数提示>`"

#. type: Plain text
#: en/git-rev-parse.txt:387
#, priority:80
msgid "`<arg-hint>`, if specified, is used as a name of the argument in the help output, for options that take arguments. `<arg-hint>` is terminated by the first whitespace. It is customary to use a dash to separate words in a multi-word argument hint."
msgstr "如果指定了 `<arg-hint>`，则在帮助输出中用作参数的名称。`<arg-hint>` 以第一个空格结束。 通常使用破折号分隔多字参数提示中的单词。"

#. type: Plain text
#: en/git-rev-parse.txt:390
#, priority:80
msgid "The remainder of the line, after stripping the spaces, is used as the help associated with the option."
msgstr "去掉空格后的剩余部分将用作与该选项相关的帮助。"

#. type: Plain text
#: en/git-rev-parse.txt:394
#, priority:80
msgid "Blank lines are ignored, and lines that don't match this specification are used as option group headers (start the line with a space to create such lines on purpose)."
msgstr "空行将被忽略，不符合此规范的行将用作选项组标题（以空格开头，以便有意创建此类行）。"

#. type: delimited block -
#: en/git-rev-parse.txt:401
#, ignore-ellipsis, no-wrap, placeholders:'OPTS_SPEC', priority:80
msgid ""
"OPTS_SPEC=\"\\\n"
"some-command [<options>] <args>...\n"
msgstr ""
"OPTS_SPEC=\"\\\n"
"some-command [<选项>] <参数>...\n"

#. type: delimited block -
#: en/git-rev-parse.txt:403
#, no-wrap, priority:80
msgid ""
"some-command does foo and bar!\n"
"--\n"
msgstr ""
"some-command 会执行 foo 和 bar!\n"
"--\n"

#. type: delimited block -
#: en/git-rev-parse.txt:405
#, priority:80
msgid "h,help! show the help"
msgstr "h,help! 显示帮助"

#. type: delimited block -
#: en/git-rev-parse.txt:410
#, placeholders:'--foo':'--bar':'--baz', priority:80
msgid "foo some nifty option --foo bar= some cool option --bar with an argument baz=arg another cool option --baz with a named argument qux?path qux may take a path argument but has meaning by itself"
msgstr "foo 一些简便的选项 --foo bar= 一些很酷的选项 --bar 带着一个参数 baz=arg 其他很酷的选项 --baz 带着指定名称的参数 qux?path qux 会带上一个 path 参数，但是对它自己有意义"

#. type: delimited block -
#: en/git-rev-parse.txt:413
#, no-wrap, priority:80
msgid ""
"  An option group Header\n"
"C?        option C with an optional argument\"\n"
msgstr ""
"  一个选项组头\n"
"C?        带着一个可选参数的 C 选项\n"

#. type: delimited block -
#: en/git-rev-parse.txt:415
#, no-wrap, placeholders:'$OPTS_SPEC':'git rev-parse':'--parseopt', priority:80
msgid "eval \"$(echo \"$OPTS_SPEC\" | git rev-parse --parseopt -- \"$@\" || echo exit $?)\"\n"
msgstr "eval \"$(echo \"$OPTS_SPEC\" | git rev-parse --parseopt -- \"$@\" || echo exit $?)\"\n"

#. type: Title ~
#: en/git-rev-parse.txt:419
#, no-wrap, priority:80
msgid "Usage text"
msgstr "使用文本"

#. type: Plain text
#: en/git-rev-parse.txt:423
#, placeholders:'`-h`':'`--help`', priority:80
msgid "When `\"$@\"` is `-h` or `--help` in the above example, the following usage text would be shown:"
msgstr "当 `\"$@\"` 为上例中的 `-h`或 `--help` 时，将显示以下使用文本："

#. type: delimited block -
#: en/git-rev-parse.txt:426
#, ignore-ellipsis, no-wrap, priority:80
msgid "usage: some-command [<options>] <args>...\n"
msgstr "usage: some-command [<选项>] <参数>...\n"

#. type: delimited block -
#: en/git-rev-parse.txt:428
#, no-wrap, priority:80
msgid "    some-command does foo and bar!\n"
msgstr "    some-command 会执行 foo 和 bar!\n"

#. type: delimited block -
#: en/git-rev-parse.txt:434
#, ignore-ellipsis, no-wrap, placeholders:'--help':'--foo':'--bar':'--baz', priority:80
msgid ""
"    -h, --help            show the help\n"
"    --[no-]foo            some nifty option --foo\n"
"    --[no-]bar ...        some cool option --bar with an argument\n"
"    --[no-]baz <arg>      another cool option --baz with a named argument\n"
"    --[no-]qux[=<path>]   qux may take a path argument but has meaning by itself\n"
msgstr ""
"    -h, --help            显示磅帮助\n"
"    --[no-]foo            一些简便的选项 --foo\n"
"    --[no-]bar ...        一些很酷的选项 --bar 带着一个参数\n"
"    --[no-]baz <arg>      另外很酷的选项 --baz 带着指定名称的参数\n"
"    --[no-]qux[=<路径>]   qux 可能会带上一个对它自己有意义的路径参数\n"

#. type: delimited block -
#: en/git-rev-parse.txt:437
#, ignore-ellipsis, no-wrap, priority:80
msgid ""
"An option group Header\n"
"    -C[...]               option C with an optional argument\n"
msgstr ""
"一个选项组的头部\n"
"    -C[...]               带着一个可选参数的选项 C\n"

#. type: Title -
#: en/git-rev-parse.txt:440
#, no-wrap, priority:80
msgid "SQ-QUOTE"
msgstr "SQ-QUOTE"

# ERROR: --sq-quote not found in translation
# ERROR: --sq-quote not found in translation
#. type: Plain text
#: en/git-rev-parse.txt:446
#, placeholders:'`--sq-quote`':'git rev-parse':'`--sq-quote`', priority:80
msgid "In `--sq-quote` mode, 'git rev-parse' echoes on the standard output a single line suitable for `sh(1)` `eval`. This line is made by normalizing the arguments following `--sq-quote`. Nothing other than quoting the arguments is done."
msgstr "在 `--sq-quote` 模式下，'git rev-parse' 会在标准输出中输出一行适合 `sh(1)` `eval` 的参数。这一行是通过将 `--sq-quote` 后面的参数规范化而生成的。除了给参数加引号之外，不会做任何其他操作。"

#. type: Plain text
#: en/git-rev-parse.txt:450
#, placeholders:'git rev-parse':'`--sq`', priority:80
msgid "If you want command input to still be interpreted as usual by 'git rev-parse' before the output is shell quoted, see the `--sq` option."
msgstr "如果希望在输出被 shell 引述之前，'git rev-parse' 仍能像往常一样解释命令输入，请参阅 `--sq` 选项。"

#. type: delimited block -
#: en/git-rev-parse.txt:462
#, no-wrap, placeholders:'git-script':'git rev-parse':'--sq-quote':'$args', priority:80
msgid ""
"$ cat >your-git-script.sh <<\\EOF\n"
"#!/bin/sh\n"
"args=$(git rev-parse --sq-quote \"$@\")   # quote user-supplied arguments\n"
"command=\"git frotz -n24 $args\"          # and use it inside a handcrafted\n"
"\t\t\t\t\t# command line\n"
"eval \"$command\"\n"
"EOF\n"
msgstr ""
"$ cat >your-git-script.sh <<\\EOF\n"
"#!/bin/sh\n"
"args=$(git rev-parse --sq-quote \"$@\")   # 引用用户提供的参数\n"
"command=\"git frotz -n24 $args\"          # 并手动将它在内部使用\n"
"\t\t\t\t\t# 命令行\n"
"eval \"$command\"\n"
"EOF\n"

#. type: delimited block -
#: en/git-rev-parse.txt:464
#, no-wrap, placeholders:'git-script', priority:80
msgid "$ sh your-git-script.sh \"a b'c\"\n"
msgstr "$ sh your-git-script.sh \"a b'c\"\n"

#. type: Plain text
#: en/git-rev-parse.txt:470
#, priority:80
msgid "Print the object name of the current commit:"
msgstr "打印当前提交的对象名称："

#. type: delimited block -
#: en/git-rev-parse.txt:473
#, no-wrap, placeholders:'git rev-parse':'--verify':'HEAD', priority:80
msgid "$ git rev-parse --verify HEAD\n"
msgstr "$ git rev-parse --verify HEAD\n"

#. type: Plain text
#: en/git-rev-parse.txt:476
#, placeholders:'$REV', priority:80
msgid "Print the commit object name from the revision in the $REV shell variable:"
msgstr "在 $REV shell 变量中打印修订版本中的提交对象名称："

#. type: delimited block -
#: en/git-rev-parse.txt:479
#, no-wrap, placeholders:'git rev-parse':'--verify':'--end-of-options':'$REV':'{commit}', priority:80
msgid "$ git rev-parse --verify --end-of-options $REV^{commit}\n"
msgstr "$ git rev-parse --verify --end-of-options $REV^{commit}\n"

#. type: Plain text
#: en/git-rev-parse.txt:482
#, placeholders:'$REV', priority:80
msgid "This will error out if $REV is empty or not a valid revision."
msgstr "如果 $REV 为空或不是有效版本，则会出错。"

#. type: Plain text
#: en/git-rev-parse.txt:484
#, priority:80
msgid "Similar to above:"
msgstr "与上述类似："

#. type: delimited block -
#: en/git-rev-parse.txt:487
#, no-wrap, placeholders:'git rev-parse':'--default':'--verify':'--end-of-options':'$REV', priority:80
msgid "$ git rev-parse --default master --verify --end-of-options $REV\n"
msgstr "$ git rev-parse --default master --verify --end-of-options $REV\n"

#. type: Plain text
#: en/git-rev-parse.txt:490
#, placeholders:'$REV', priority:80
msgid "but if $REV is empty, the commit object name from master will be printed."
msgstr "但如果 $REV 为空，则会打印 master 中的提交对象名称。"

#. type: Title =
#: en/git-rm.txt:2
#, ignore-same, no-wrap, priority:280
msgid "git-rm(1)"
msgstr "git-rm(1)"

#. type: Plain text
#: en/git-rm.txt:7
#, placeholders:'git-rm', priority:280
msgid "git-rm - Remove files from the working tree and from the index"
msgstr "git-rm - 从工作树和索引中删除文件"

#. type: Plain text
#: en/git-rm.txt:14
#, ignore-ellipsis, no-wrap, placeholders:'--force]':'[--cached]':'[--ignore-unmatch]':'[--quiet]':'[--pathspec-from-file=':'[--pathspec-file-nul]', priority:280
msgid ""
"'git rm' [-f | --force] [-n] [-r] [--cached] [--ignore-unmatch]\n"
"\t  [--quiet] [--pathspec-from-file=<file> [--pathspec-file-nul]]\n"
"\t  [--] [<pathspec>...]\n"
msgstr ""
"'git rm' [-f | --force] [-n] [-r] [--cached] [--ignore-unmatch]\n"
"\t  [--quiet] [--pathspec-from-file=<文件> [--pathspec-file-nul]]\n"
"\t  [--] [<路径规范>...]\n"

#. type: Plain text
#: en/git-rm.txt:29
#, placeholders:'`-f`':'`--cached`':'linkgit:git-sparse-checkout[1]', priority:280
msgid "Remove files matching pathspec from the index, or from the working tree and the index. `git rm` will not remove a file from just your working directory. (There is no option to remove a file only from the working tree and yet keep it in the index; use `/bin/rm` if you want to do that.) The files being removed have to be identical to the tip of the branch, and no updates to their contents can be staged in the index, though that default behavior can be overridden with the `-f` option. When `--cached` is given, the staged content has to match either the tip of the branch or the file on disk, allowing the file to be removed from just the index. When sparse-checkouts are in use (see linkgit:git-sparse-checkout[1]), `git rm` will only remove paths within the sparse-checkout patterns."
msgstr "从索引中，或从工作树和索引中删除与pathspec匹配的文件。`git rm`不会只从你的工作目录中删除一个文件。(没有选项可以只从工作树中删除一个文件，但在索引中保留它；如果你想这样做，就用`/bin/rm`)。被删除的文件必须与分支的顶端相同，而且它们的内容不能在索引中进行更新，尽管可以用`-f`选项覆盖这一默认行为。 当给定`--cached`时，缓存的内容必须与分支的顶端或磁盘上的文件相匹配，允许文件只从索引中被删除。当使用稀疏检查时（见linkgit:git-sparse-checkout[1]），`git rm`将只删除稀疏检查模式内的路径。"

#. type: Plain text
#: en/git-rm.txt:38
#, placeholders:'`-r`', priority:280
msgid "Files to remove. A leading directory name (e.g. `dir` to remove `dir/file1` and `dir/file2`) can be given to remove all files in the directory, and recursively all sub-directories, but this requires the `-r` option to be explicitly given."
msgstr "要删除的文件。 可以给一个领先的目录名（例如，`dir`删除`dir/file1`和`dir/file2`）来删除该目录下的所有文件，并递归所有子目录，但这需要明确给出`-r`选项。"

#. type: Plain text
#: en/git-rm.txt:40
#, priority:280
msgid "The command removes only the paths that are known to Git."
msgstr "该命令只删除Git已知的路径。"

#. type: Plain text
#: en/git-rm.txt:45
#, priority:280
msgid "File globbing matches across directory boundaries. Thus, given two directories `d` and `d2`, there is a difference between using `git rm 'd*'` and `git rm 'd/*'`, as the former will also remove all of directory `d2`."
msgstr "文件球化可以跨越目录边界进行匹配。 因此，给定两个目录`d`和`d2`，使用`git rm 'd*'`和`git rm 'd/*'`是有区别的，因为前者会同时删除`d2`目录的所有内容。"

#. type: Plain text
#: en/git-rm.txt:51
#, priority:280
msgid "Override the up-to-date check."
msgstr "覆盖最新的检查。"

#. type: Plain text
#: en/git-rm.txt:57
#, priority:280
msgid "Don't actually remove any file(s). Instead, just show if they exist in the index and would otherwise be removed by the command."
msgstr "实际上不要删除任何文件。 相反，只是显示它们是否存在于索引中，否则会被命令删除。"

#. type: Plain text
#: en/git-rm.txt:61
#, priority:280
msgid "Allow recursive removal when a leading directory name is given."
msgstr "当给出一个领先的目录名称时，允许递归删除。"

#. type: Plain text
#: en/git-rm.txt:71
#, priority:280
msgid "Use this option to unstage and remove paths only from the index. Working tree files, whether modified or not, will be left alone."
msgstr "使用这个选项，只从索引中解开阶段并删除路径。 工作树文件，无论是否被修改过，都将被单独留下。"

#. type: Labeled list
#: en/git-rm.txt:72
#, ignore-same, no-wrap, priority:280
msgid "--ignore-unmatch"
msgstr "--ignore-unmatch"

#. type: Plain text
#: en/git-rm.txt:74
#, priority:280
msgid "Exit with a zero status even if no files matched."
msgstr "即使没有文件匹配，也以零状态退出。"

#. type: Plain text
#: en/git-rm.txt:80
#, placeholders:'linkgit:git-sparse-checkout[1]', priority:280
msgid "Allow updating index entries outside of the sparse-checkout cone. Normally, `git rm` refuses to update index entries whose paths do not fit within the sparse-checkout cone. See linkgit:git-sparse-checkout[1] for more."
msgstr "允许更新稀疏结帐锥之外的索引条目。通常，`git rm` 拒绝更新其路径不适合稀疏结帐锥的索引条目。有关更多信息，请参见 linkgit:git-sparse-checkout[1]。"

#. type: Plain text
#: en/git-rm.txt:85
#, priority:280
msgid "`git rm` normally outputs one line (in the form of an `rm` command) for each file removed. This option suppresses that output."
msgstr "`git rm` 通常会为每个删除的文件输出一行（以 `rm` 命令的形式）。这个选项会抑制输出。"

#. type: Title -
#: en/git-rm.txt:101
#, no-wrap, priority:280
msgid "REMOVING FILES THAT HAVE DISAPPEARED FROM THE FILESYSTEM"
msgstr "删除从文件系统中消失的文件"

#. type: Plain text
#: en/git-rm.txt:106
#, priority:280
msgid "There is no option for `git rm` to remove from the index only the paths that have disappeared from the filesystem. However, depending on the use case, there are several ways that can be done."
msgstr "`git rm`没有选项可以从索引中只删除已经从文件系统中消失的路径。然而，根据不同的使用情况，有几种方法可以做到这一点。"

#. type: Title ~
#: en/git-rm.txt:108
#, no-wrap, priority:280
msgid "Using ``git commit -a''"
msgstr "使用``git commit -a''"

#. type: Plain text
#: en/git-rm.txt:115
#, priority:280
msgid "If you intend that your next commit should record all modifications of tracked files in the working tree and record all removals of files that have been removed from the working tree with `rm` (as opposed to `git rm`), use `git commit -a`, as it will automatically notice and record all removals. You can also have a similar effect without committing by using `git add -u`."
msgstr "如果你想让你的下一次提交记录工作树中所有被跟踪的文件的修改，并记录所有用`rm`从工作树中删除的文件（而不是`git rm`），请使用`git commit -a`，它将自动注意并记录所有的删除。 你也可以通过使用`git add -u`在不提交的情况下获得类似的效果。"

#. type: Title ~
#: en/git-rm.txt:117
#, no-wrap, priority:280
msgid "Using ``git add -A''"
msgstr "使用``git add -A''"

#. type: Plain text
#: en/git-rm.txt:121
#, priority:280
msgid "When accepting a new code drop for a vendor branch, you probably want to record both the removal of paths and additions of new paths as well as modifications of existing paths."
msgstr "当接受一个供应商分支的新代码投放时，你可能想同时记录删除路径和增加新路径以及修改现有路径的内容。"

#. type: Plain text
#: en/git-rm.txt:124
#, priority:280
msgid "Typically you would first remove all tracked files from the working tree using this command:"
msgstr "通常情况下，你会先用这个命令从工作目录树上删除所有被追踪的文件："

#. type: delimited block -
#: en/git-rm.txt:127
#, no-wrap, placeholders:'git ls-files', priority:280
msgid "git ls-files -z | xargs -0 rm -f\n"
msgstr "git ls-files -z | xargs -0 rm -f\n"

#. type: Plain text
#: en/git-rm.txt:131
#, priority:280
msgid "and then untar the new code in the working tree. Alternately you could 'rsync' the changes into the working tree."
msgstr "然后解开工作树上的新代码。另外，你也可以通过 \"rsync \"把修改的内容放到工作树上。"

#. type: Plain text
#: en/git-rm.txt:134
#, priority:280
msgid "After that, the easiest way to record all removals, additions, and modifications in the working tree is:"
msgstr "之后，记录工作目录树中所有的删除、添加和修改的最简单方法是："

#. type: delimited block -
#: en/git-rm.txt:137
#, no-wrap, priority:280
msgid "git add -A\n"
msgstr "git add -A\n"

#. type: Plain text
#: en/git-rm.txt:140
#, placeholders:'linkgit:git-add[1]', priority:280
msgid "See linkgit:git-add[1]."
msgstr "参见 linkgit:git-add[1]。"

#. type: Title ~
#: en/git-rm.txt:142
#, no-wrap, priority:280
msgid "Other ways"
msgstr "其他方式"

#. type: Plain text
#: en/git-rm.txt:147
#, priority:280
msgid "If all you really want to do is to remove from the index the files that are no longer present in the working tree (perhaps because your working tree is dirty so that you cannot use `git commit -a`), use the following command:"
msgstr "如果你真正想做的只是从索引中删除那些不再出现在工作目录树中的文件（也许是因为你的工作目录树很脏，所以你不能使用 `git commit -a` ），使用以下命令："

#. type: delimited block -
#: en/git-rm.txt:150
#, no-wrap, placeholders:'--name-only':'--diff-filter=D':'--cached', priority:280
msgid "git diff --name-only --diff-filter=D -z | xargs -0 git rm --cached\n"
msgstr "git diff --name-only --diff-filter=D -z | xargs -0 git rm --cached\n"

#. type: Plain text
#: en/git-rm.txt:163
#, placeholders:'linkgit:gitmodules[5]':'--cached', priority:280
msgid "Only submodules using a gitfile (which means they were cloned with a Git version 1.7.8 or newer) will be removed from the work tree, as their repository lives inside the .git directory of the superproject. If a submodule (or one of those nested inside it) still uses a .git directory, `git rm` will move the submodules git directory into the superprojects git directory to protect the submodule's history. If it exists the submodule.<name> section in the linkgit:gitmodules[5] file will also be removed and that file will be staged (unless --cached or -n are used)."
msgstr "只有使用 gitfile 的子模块（这意味着它们是用 1.7.8 或更新的 Git 版本克隆的）才会从工作树中移除，因为它们的仓库住在超级项目的 .git 目录中。如果一个子模块（或嵌套在它里面的一个）仍然使用.git目录，`git rm`将把子模块的git目录移到超级项目的git目录中，以保护子模块的历史。如果它存在，linkgit:gitmodules[5]文件中的submodule.<name>部分也将被移除，该文件将被暂存（除非使用了--cached或-n）。"

#. type: Plain text
#: en/git-rm.txt:169
#, placeholders:'HEAD', priority:280
msgid "A submodule is considered up to date when the HEAD is the same as recorded in the index, no tracked files are modified and no untracked files that aren't ignored are present in the submodule's work tree. Ignored files are deemed expendable and won't stop a submodule's work tree from being removed."
msgstr "当 HEAD 与索引中记录的相同时，一个子模块被认为是最新的，没有跟踪的文件被修改，在子模块的工作目录树中没有没有被忽略的未跟踪的文件。 忽略的文件被认为是可消耗的，不会阻止一个子模块的工作目录树被删除。"

#. type: Plain text
#: en/git-rm.txt:173
#, placeholders:'linkgit:git-submodule[1]':'linkgit:gitsubmodules[7]', priority:280
msgid "If you only want to remove the local checkout of a submodule from your work tree without committing the removal, use linkgit:git-submodule[1] `deinit` instead. Also see linkgit:gitsubmodules[7] for details on submodule removal."
msgstr "如果你只想从你的工作树中移除一个子模块的本地签出而不提交移除，使用linkgit:git-submodule[1] `deinit`代替。也请看 linkgit:gitsubmodules[7] 了解关于子模块移除的细节。"

#. type: Labeled list
#: en/git-rm.txt:176
#, no-wrap, priority:280
msgid "`git rm Documentation/\\*.txt`"
msgstr "`git rm Documentation/\\*.txt`"

#. type: Plain text
#: en/git-rm.txt:179
#, priority:280
msgid "Removes all `*.txt` files from the index that are under the `Documentation` directory and any of its subdirectories."
msgstr "从索引中删除所有`*.txt`文件，这些文件在`Documentation`目录和它的任何子目录下。"

#. type: Plain text
#: en/git-rm.txt:183
#, priority:280
msgid "Note that the asterisk `*` is quoted from the shell in this example; this lets Git, and not the shell, expand the pathnames of files and subdirectories under the `Documentation/` directory."
msgstr "注意，在这个例子中，星号`*`被引自shell；这让Git，而不是shell，扩展`Documentation/`目录下的文件和子目录的路径名。"

#. type: Labeled list
#: en/git-rm.txt:184
#, no-wrap, priority:280
msgid "`git rm -f git-*.sh`"
msgstr "`git rm -f git-*.sh`"

#. type: Plain text
#: en/git-rm.txt:188
#, priority:280
msgid "Because this example lets the shell expand the asterisk (i.e. you are listing the files explicitly), it does not remove `subdir/git-foo.sh`."
msgstr "因为这个例子让shell展开星号（即你明确列出了文件），它没有删除`subdir/git-foo.sh`。"

#. type: Plain text
#: en/git-rm.txt:197
#, priority:280
msgid "Each time a superproject update removes a populated submodule (e.g. when switching between commits before and after the removal) a stale submodule checkout will remain in the old location. Removing the old directory is only safe when it uses a gitfile, as otherwise the history of the submodule will be deleted too. This step will be obsolete when recursive submodule update has been implemented."
msgstr "每次超级项目更新删除一个已填充的子模块（例如，在删除前后的提交之间切换时），一个陈旧的子模块检出将保留在旧的位置。只有在使用gitfile时，删除旧目录才是安全的，否则子模块的历史也会被删除。当递归子模块更新被实施后，这个步骤将被淘汰。"

#. type: Title =
#: en/git-send-email.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-send-email(1)"
msgstr "git-send-email(1)"

#. type: Plain text
#: en/git-send-email.txt:7
#, placeholders:'git-send-email', priority:100
msgid "git-send-email - Send a collection of patches as emails"
msgstr "git-send-email - 以电子邮件形式发送补丁集"

#. type: Plain text
#: en/git-send-email.txt:15
#, ignore-ellipsis, no-wrap, placeholders:'git send-email':'git send-email':'git send-email':'--dump-aliases', priority:100
msgid ""
"'git send-email' [<options>] <file|directory>...\n"
"'git send-email' [<options>] <format-patch-options>\n"
"'git send-email' --dump-aliases\n"
msgstr ""
"'git send-email' [<选项>] <文件或是目录>...\n"
"git send-email' [<选项>] <格式补丁选项>\n"
"git send-email' --dump-aliases\n"

#. type: Plain text
#: en/git-send-email.txt:25
#, placeholders:'linkgit:git-format-patch[1]':'git send-email':'linkgit:git-format-patch[1]', priority:100
msgid "Takes the patches given on the command line and emails them out. Patches can be specified as files, directories (which will send all files in the directory), or directly as a revision list. In the last case, any format accepted by linkgit:git-format-patch[1] can be passed to git send-email, as well as options understood by linkgit:git-format-patch[1]."
msgstr "获取命令行中给出的补丁并将其发送出去。 补丁可以指定为文件、目录（将发送目录中的所有文件），或直接指定为修订列表。 在最后一种情况下，linkgit:git-format-patch[1] 接受的任何格式，以及 linkgit:git-format-patch[1] 可以理解的选项，都可以传递给 git send-email。"

#. type: Plain text
#: en/git-send-email.txt:29
#, priority:100
msgid "The header of the email is configurable via command-line options. If not specified on the command line, the user will be prompted with a ReadLine enabled interface to provide the necessary information."
msgstr "电子邮件的标题可通过命令行选项进行配置。 如果未在命令行中指定，系统将在启用读取行的界面上提示用户提供必要的信息。"

#. type: Plain text
#: en/git-send-email.txt:31
#, priority:100
msgid "There are two formats accepted for patch files:"
msgstr "补丁文件有两种格式："

#. type: Plain text
#: en/git-send-email.txt:33
#, priority:100
msgid "mbox format files"
msgstr "mbox 格式文件"

#. type: Plain text
#: en/git-send-email.txt:36
#, placeholders:'linkgit:git-format-patch[1]', priority:100
msgid "This is what linkgit:git-format-patch[1] generates. Most headers and MIME formatting are ignored."
msgstr "这就是 linkgit:git-format-patch[1] 生成的内容。 大部分头文件和 MIME 格式都会被忽略。"

#. type: Plain text
#: en/git-send-email.txt:39
#, placeholders:'send_lots_of_email', priority:100
msgid "The original format used by Greg Kroah-Hartman's 'send_lots_of_email.pl' script"
msgstr "Greg Kroah-Hartman 的 'send_lots_of_email.pl' 脚本使用的原始格式"

#. type: Plain text
#: en/git-send-email.txt:42
#, priority:100
msgid "This format expects the first line of the file to contain the \"Cc:\" value and the \"Subject:\" of the message as the second line."
msgstr "这种格式希望文件的第一行包含 \"Cc:\"（抄送）值，第二行包含邮件的 \"主题：\"。"

#. type: Title ~
#: en/git-send-email.txt:48
#, no-wrap, priority:100
msgid "Composing"
msgstr "撰写"

#. type: Labeled list
#: en/git-send-email.txt:50 en/git-tag.txt:61
#, ignore-same, no-wrap, priority:240
msgid "--annotate"
msgstr "--annotate"

#. type: Plain text
#: en/git-send-email.txt:54
#, placeholders:'sendemail.annotate':'sendemail.multiEdit', priority:100
msgid "Review and edit each patch you're about to send. Default is the value of `sendemail.annotate`. See the CONFIGURATION section for `sendemail.multiEdit`."
msgstr "审核并编辑您即将发送的每个补丁。默认为 `sendemail.annotate` 的值。有关 `sendemail.multiEdit` 请参阅配置部分。"

#. type: Labeled list
#: en/git-send-email.txt:55
#, ignore-ellipsis, no-wrap, placeholders:'--bcc=', priority:100
msgid "--bcc=<address>,..."
msgstr "--bcc=<地址>,..."

#. type: Plain text
#: en/git-send-email.txt:58
#, placeholders:'sendemail.bcc', priority:100
msgid "Specify a \"Bcc:\" value for each email. Default is the value of `sendemail.bcc`."
msgstr "为每封电子邮件指定一个 \"Bcc：\"（密送）值。默认为 `sendemail.bcc` 的值。"

#. type: Plain text
#: en/git-send-email.txt:60 en/git-send-email.txt:66 en/git-send-email.txt:129
#, priority:100
msgid "This option may be specified multiple times."
msgstr "该选项可指定多次。"

#. type: Labeled list
#: en/git-send-email.txt:61
#, ignore-ellipsis, no-wrap, placeholders:'--cc=', priority:100
msgid "--cc=<address>,..."
msgstr "--cc=<地址>,..."

#. type: Plain text
#: en/git-send-email.txt:64
#, placeholders:'sendemail.cc', priority:100
msgid "Specify a starting \"Cc:\" value for each email. Default is the value of `sendemail.cc`."
msgstr "为每封电子邮件指定一个起始 \"Cc：\"（抄送）值。 默认值为 `sendemail.cc`。"

#. type: Labeled list
#: en/git-send-email.txt:67
#, ignore-same, no-wrap, priority:100
msgid "--compose"
msgstr "--compose"

#. type: Plain text
#: en/git-send-email.txt:70
#, placeholders:'GIT_EDITOR':'linkgit:git-var[1]', priority:100
msgid "Invoke a text editor (see GIT_EDITOR in linkgit:git-var[1]) to edit an introductory message for the patch series."
msgstr "调用文本编辑器（参见 linkgit:git-var[1] 中的 GIT_EDITOR）编辑补丁系列的介绍信息。"

# ERROR: --compose not found in translation
#. type: Plain text
#: en/git-send-email.txt:77
#, placeholders:'`--compose`':'git send-email', priority:100
msgid "When `--compose` is used, git send-email will use the From, To, Cc, Bcc, Subject, Reply-To, and In-Reply-To headers specified in the message. If the body of the message (what you type after the headers and a blank line) only contains blank (or Git: prefixed) lines, the summary won't be sent, but the headers mentioned above will be used unless they are removed."
msgstr "当使用 `--compose` 时，git send-email 将使用邮件中指定的发件人、收件人、抄送人、密送人、主题、回复人和收件人标题。如果邮件正文（在标题和空行之后输入的内容）只包含空行（或 Git: 前缀），摘要将不会被发送，但上述标题将被使用，除非它们被移除。"

#. type: Plain text
#: en/git-send-email.txt:79
#, priority:100
msgid "Missing From or In-Reply-To headers will be prompted for."
msgstr "将提示是否有缺失的发件人或收件人标题。"

#. type: Plain text
#: en/git-send-email.txt:81
#, placeholders:'sendemail.multiEdit', priority:100
msgid "See the CONFIGURATION section for `sendemail.multiEdit`."
msgstr "请参阅 `sendemail.multiEdit` 的配置部分。"

#. type: Labeled list
#: en/git-send-email.txt:82
#, no-wrap, placeholders:'--from=', priority:100
msgid "--from=<address>"
msgstr "--from=<地址>"

#. type: Plain text
#: en/git-send-email.txt:89
#, placeholders:'sendemail.from':'sendemail.from':'GIT_AUTHOR_IDENT':'GIT_COMMITTER_IDENT', priority:100
msgid "Specify the sender of the emails. If not specified on the command line, the value of the `sendemail.from` configuration option is used. If neither the command-line option nor `sendemail.from` are set, then the user will be prompted for the value. The default for the prompt will be the value of GIT_AUTHOR_IDENT, or GIT_COMMITTER_IDENT if that is not set, as returned by \"git var -l\"."
msgstr "指定电子邮件的发件人。 如果未在命令行中指定，则使用配置选项 `sendemail.from` 的值。 如果命令行选项和 `sendemail.from` 均未设置，则会提示用户输入值。 提示的默认值是 GIT_AUTHOR_IDENT 的值，如果没有设置 GIT_COMMITTER_IDENT，则使用 \"git var -l\" 返回的值。"

#. type: Labeled list
#: en/git-send-email.txt:90
#, no-wrap, placeholders:'--reply-to=', priority:100
msgid "--reply-to=<address>"
msgstr "--reply-to=<地址>"

#. type: Plain text
#: en/git-send-email.txt:94
#, placeholders:'--from', priority:100
msgid "Specify the address where replies from recipients should go to. Use this if replies to messages should go to another address than what is specified with the --from parameter."
msgstr "指定收件人回复的地址。 如果邮件的回复地址与 --from 参数指定的地址不同，请使用此参数。"

#. type: Labeled list
#: en/git-send-email.txt:95
#, no-wrap, placeholders:'--in-reply-to=', priority:100
msgid "--in-reply-to=<identifier>"
msgstr "--in-reply-to=<标识符>"

#. type: Plain text
#: en/git-send-email.txt:101
#, placeholders:'`--no-thread`', priority:100
msgid "Make the first mail (or all the mails with `--no-thread`) appear as a reply to the given Message-ID, which avoids breaking threads to provide a new patch series. The second and subsequent emails will be sent as replies according to the `--[no-]chain-reply-to` setting."
msgstr "使第一封邮件（或所有带有 `--no-thread`（无线程）的邮件）作为给定 Message-ID 的回复出现，从而避免为提供新的补丁系列而中断线程。 第二封及其后的邮件将根据 \"--[no-]chain-reply-to \"设置作为回复发送。"

#. type: Plain text
#: en/git-send-email.txt:105
#, placeholders:'`--thread`':'`--no-chain-reply-to`', priority:100
msgid "So for example when `--thread` and `--no-chain-reply-to` are specified, the second and subsequent patches will be replies to the first one like in the illustration below where `[PATCH v2 0/3]` is in reply to `[PATCH 0/2]`:"
msgstr "例如，如果指定了 `--thread` 和 `--no-chain-reply-to`，则第二个和后续补丁将是对第一个补丁的回复，如下图所示，`[PATCH v2 0/3]` 是对 `[PATCH 0/2]` 的回复："

#. type: Plain text
#: en/git-send-email.txt:113
#, ignore-ellipsis, no-wrap, priority:100
msgid ""
"  [PATCH 0/2] Here is what I did...\n"
"    [PATCH 1/2] Clean up and tests\n"
"    [PATCH 2/2] Implementation\n"
"    [PATCH v2 0/3] Here is a reroll\n"
"      [PATCH v2 1/3] Clean up\n"
"      [PATCH v2 2/3] New tests\n"
"      [PATCH v2 3/3] Implementation\n"
msgstr ""
"  [PATCH 0/2] 我是这样做的...\n"
"    [PATCH 1/2] 清理和测试\n"
"    [PATCH 2/2] 实施情况\n"
"    [PATCH v2 0/3] 这里是重选\n"
"      [PATCH v2 1/3] 清理\n"
"      [PATCH v2 2/3] 新测试\n"
"      [PATCH v2 3/3] 实施情况\n"

#. type: Plain text
#: en/git-send-email.txt:116
#, placeholders:'--compose':'--compose', priority:100
msgid "Only necessary if --compose is also set. If --compose is not set, this will be prompted for."
msgstr "只有同时设置了 --compose 时才有必要。 如果未设置 --compose，则会提示。"

#. type: Labeled list
#: en/git-send-email.txt:117
#, no-wrap, placeholders:'--subject=', priority:100
msgid "--subject=<string>"
msgstr "--subject=<字符串>"

#. type: Plain text
#: en/git-send-email.txt:121
#, placeholders:'--compose':'--compose', priority:100
msgid "Specify the initial subject of the email thread. Only necessary if --compose is also set. If --compose is not set, this will be prompted for."
msgstr "指定电子邮件线程的初始主题。 只有同时设置了 --compose 时才需要。 如果未设置 --compose，系统将提示输入。"

#. type: Labeled list
#: en/git-send-email.txt:122
#, ignore-ellipsis, no-wrap, placeholders:'--to=', priority:100
msgid "--to=<address>,..."
msgstr "--to=<地址>,..."

#. type: Plain text
#: en/git-send-email.txt:127
#, placeholders:'sendemail.to':'--to-cmd', priority:100
msgid "Specify the primary recipient of the emails generated. Generally, this will be the upstream maintainer of the project involved. Default is the value of the `sendemail.to` configuration value; if that is unspecified, and --to-cmd is not specified, this will be prompted for."
msgstr "指定所生成电子邮件的主要收件人。一般来说，这将是相关项目的上游维护者。默认值是 `sendemail.to` 配置值的值，如果未指定该值，且未指定 --to-cmd 参数，则会提示该值。"

#. type: Labeled list
#: en/git-send-email.txt:130
#, no-wrap, placeholders:'--8bit-encoding=', priority:100
msgid "--8bit-encoding=<encoding>"
msgstr "--8bit-encoding=<编码>"

#. type: Plain text
#: en/git-send-email.txt:136
#, priority:100
msgid "When encountering a non-ASCII message or subject that does not declare its encoding, add headers/quoting to indicate it is encoded in <encoding>. Default is the value of the 'sendemail.assume8bitEncoding'; if that is unspecified, this will be prompted for if any non-ASCII files are encountered."
msgstr "当遇到未声明其编码的非 ASCII 邮件或主题时，添加标头/引号以表明它是以 <编码> 编码的。 默认值是 'sendemail.assume8bitEncoding ' 的值；如果未指定该值，则在遇到任何非 ASCII 文件时会提示使用该值。"

#. type: Plain text
#: en/git-send-email.txt:138
#, priority:100
msgid "Note that no attempts whatsoever are made to validate the encoding."
msgstr "请注意，我们不会尝试验证编码。"

#. type: Labeled list
#: en/git-send-email.txt:139
#, no-wrap, placeholders:'--compose-encoding=', priority:100
msgid "--compose-encoding=<encoding>"
msgstr "--compose-encoding=<编码>"

#. type: Plain text
#: en/git-send-email.txt:142
#, placeholders:'sendemail.composeencoding', priority:100
msgid "Specify encoding of compose message. Default is the value of the 'sendemail.composeencoding'; if that is unspecified, UTF-8 is assumed."
msgstr "指定撰写邮件的编码。默认值是 'sendemail.composeencoding' 的值；如果未指定，则假定为 UTF-8。"

#. type: Labeled list
#: en/git-send-email.txt:143
#, ignore-same, no-wrap, priority:100
msgid "--transfer-encoding=(7bit|8bit|quoted-printable|base64|auto)"
msgstr "--transfer-encoding=(7bit|8bit|quoted-printable|base64|auto)"

#. type: Plain text
#: en/git-send-email.txt:151
#, priority:100
msgid "Specify the transfer encoding to be used to send the message over SMTP. 7bit will fail upon encountering a non-ASCII message. quoted-printable can be useful when the repository contains files that contain carriage returns, but makes the raw patch email file (as saved from a MUA) much harder to inspect manually. base64 is even more fool proof, but also even more opaque. auto will use 8bit when possible, and quoted-printable otherwise."
msgstr "指定通过 SMTP 发送邮件时使用的传输编码。 如仓本库中包含含有回车的文件，quoted-printable 会很有用，但会使原始补丁邮件文件（从 MUA 中保存）更难手动检查。"

#. type: Plain text
#: en/git-send-email.txt:154
#, placeholders:'sendemail.transferEncoding', priority:100
msgid "Default is the value of the `sendemail.transferEncoding` configuration value; if that is unspecified, default to `auto`."
msgstr "默认为 `sendemail.transferEncoding` 配置值的值，如果未指定，则默认为 `auto`。"

#. type: Labeled list
#: en/git-send-email.txt:155
#, ignore-same, no-wrap, priority:100
msgid "--xmailer"
msgstr "--xmailer"

#. type: Labeled list
#: en/git-send-email.txt:156
#, ignore-same, no-wrap, priority:100
msgid "--no-xmailer"
msgstr "--no-xmailer"

#. type: Plain text
#: en/git-send-email.txt:160
#, placeholders:'sendemail.xmailer', priority:100
msgid "Add (or prevent adding) the \"X-Mailer:\" header. By default, the header is added, but it can be turned off by setting the `sendemail.xmailer` configuration variable to `false`."
msgstr "添加（或阻止添加）\"X-Mailer: \" 标头。 默认情况下会添加，但可以通过将配置变量 `sendemail.xmailer` 设为 `false`来关闭。"

#. type: Title ~
#: en/git-send-email.txt:162
#, no-wrap, priority:100
msgid "Sending"
msgstr "发送中"

#. type: Labeled list
#: en/git-send-email.txt:164
#, no-wrap, placeholders:'--envelope-sender=', priority:100
msgid "--envelope-sender=<address>"
msgstr "--envelope-sender=<地址>"

#. type: Plain text
#: en/git-send-email.txt:172
#, placeholders:'sendemail.envelopeSender', priority:100
msgid "Specify the envelope sender used to send the emails. This is useful if your default address is not the address that is subscribed to a list. In order to use the 'From' address, set the value to \"auto\". If you use the sendmail binary, you must have suitable privileges for the -f parameter. Default is the value of the `sendemail.envelopeSender` configuration variable; if that is unspecified, choosing the envelope sender is left to your MTA."
msgstr "指定用于发送电子邮件的信封发件人。 如果您的默认地址不是订阅列表的地址，这将非常有用。为了使用 'From'（发件人）地址，请将值设置为 \"auto\"。如果使用 sendmail 二进制文件，必须为 -f 参数设置适当的权限。 默认值是 `sendemail.envelopeSender` 配置变量的值；如果未指定，则由 MTA 选择信封发件人。"

#. type: Labeled list
#: en/git-send-email.txt:173
#, no-wrap, placeholders:'--sendmail-cmd=', priority:100
msgid "--sendmail-cmd=<command>"
msgstr "--sendmail-cmd=<命令>"

#. type: Plain text
#: en/git-send-email.txt:180
#, placeholders:'`-i`':'sendemail.sendmailcmd':'--smtp-server':'git-send-email':'$PATH', priority:100
msgid "Specify a command to run to send the email. The command should be sendmail-like; specifically, it must support the `-i` option. The command will be executed in the shell if necessary. Default is the value of `sendemail.sendmailcmd`. If unspecified, and if --smtp-server is also unspecified, git-send-email will search for `sendmail` in `/usr/sbin`, `/usr/lib` and $PATH."
msgstr "指定发送电子邮件时要运行的命令。该命令应类似于 sendmail；具体来说，它必须支持 `-i` 选项。 如有必要，该命令将在 shell 中执行。 默认值为 `sendemail.sendmailcmd`。 如果未指定，并且 --smtp-server 也未指定，git-send-email 将在 `/usr/sbin`、`/usr/lib` 和 $PATH 中搜索 `sendmail`。"

#. type: Labeled list
#: en/git-send-email.txt:181
#, no-wrap, placeholders:'--smtp-encryption=', priority:100
msgid "--smtp-encryption=<encryption>"
msgstr "--smtp-encryption=<加密>"

#. type: Plain text
#: en/git-send-email.txt:194
#, placeholders:'sendemail.smtpEncryption', priority:100
msgid "Specify in what way encrypting begins for the SMTP connection. Valid values are 'ssl' and 'tls'. Any other value reverts to plain (unencrypted) SMTP, which defaults to port 25. Despite the names, both values will use the same newer version of TLS, but for historic reasons have these names. 'ssl' refers to \"implicit\" encryption (sometimes called SMTPS), that uses port 465 by default. 'tls' refers to \"explicit\" encryption (often known as STARTTLS), that uses port 25 by default. Other ports might be used by the SMTP server, which are not the default. Commonly found alternative port for 'tls' and unencrypted is 587. You need to check your provider's documentation or your server configuration to make sure for your own case. Default is the value of `sendemail.smtpEncryption`."
msgstr "指定 SMTP 连接的加密方式。 有效值为 'ssl' 和 'tls'。任何其他值都将恢复为普通（未加密）SMTP，默认端口为 25。 尽管名称不同，但这两个值都将使用相同的 TLS 更新版本，只是由于历史原因才使用了这些名称。'ssl' 指 “隐式” 加密（有时称为 SMTPS），默认使用 465 端口。 'tls' 指 “显式” 加密（通常称为 STARTTLS），默认使用 25 端口。SMTP 服务器还可能使用其他端口，但这些端口并非默认端口。常见的 'tls' 和未加密的替代端口是 587。您需要查看供应商的文档或服务器配置，以确定自己的情况。默认值为 `sendemail.smtpEncryption`。"

#. type: Labeled list
#: en/git-send-email.txt:195
#, no-wrap, placeholders:'--smtp-domain=', priority:100
msgid "--smtp-domain=<FQDN>"
msgstr "--smtp-domain=<FQDN>"

#. type: Plain text
#: en/git-send-email.txt:201
#, placeholders:'git send-email':'sendemail.smtpDomain', priority:100
msgid "Specifies the Fully Qualified Domain Name (FQDN) used in the HELO/EHLO command to the SMTP server. Some servers require the FQDN to match your IP address. If not set, git send-email attempts to determine your FQDN automatically. Default is the value of `sendemail.smtpDomain`."
msgstr "指定发送到 SMTP 服务器的 HELO/EHLO 命令中使用的完全限定域名 (FQDN)。 有些服务器要求 FQDN 与您的 IP 地址匹配。 如果未设置，git send-email 会尝试自动确定您的 FQDN。 默认值为 `sendemail.smtpDomain`。"

#. type: Labeled list
#: en/git-send-email.txt:202
#, no-wrap, placeholders:'--smtp-auth=', priority:100
msgid "--smtp-auth=<mechanisms>"
msgstr "--smtp-auth=<验证机制>"

#. type: Plain text
#: en/git-send-email.txt:205
#, priority:100
msgid "Whitespace-separated list of allowed SMTP-AUTH mechanisms. This setting forces using only the listed mechanisms. Example:"
msgstr "以空白分隔的允许 SMTP-AUTH 机制列表。此设置只强制使用列出的机制。例如："

#. type: delimited block -
#: en/git-send-email.txt:208
#, ignore-ellipsis, no-wrap, placeholders:'git send-email':'--smtp-auth=', priority:100
msgid "$ git send-email --smtp-auth=\"PLAIN LOGIN GSSAPI\" ...\n"
msgstr "$ git send-email --smtp-auth=\"PLAIN LOGIN GSSAPI\" ...\n"

#. type: Plain text
#: en/git-send-email.txt:216
#, placeholders:'sendemail.smtpAuth':'`--smtp-auth`':'`--smtp-user`', priority:100
msgid "If at least one of the specified mechanisms matches the ones advertised by the SMTP server and if it is supported by the utilized SASL library, the mechanism is used for authentication. If neither 'sendemail.smtpAuth' nor `--smtp-auth` is specified, all mechanisms supported by the SASL library can be used. The special value 'none' maybe specified to completely disable authentication independently of `--smtp-user`"
msgstr "如果指定的机制中至少有一种与 SMTP 服务器公布的机制相匹配，且受所使用的 SASL 库支持，则该机制将用于身份验证。如果既未指定 'sendemail.smtpAuth'，也未指定 `--smtp-auth`参数，则可使用 SASL 库支持的所有机制。如果指定了特殊值 'none'，则可以完全禁用与 `--smtp-user` 参数无关的身份验证"

#. type: Labeled list
#: en/git-send-email.txt:217
#, no-wrap, placeholders:'--smtp-pass', priority:100
msgid "--smtp-pass[=<password>]"
msgstr "--smtp-pass[=<密码>]"

#. type: Plain text
#: en/git-send-email.txt:222
#, placeholders:'sendemail.smtpPass':'`--smtp-pass`', priority:100
msgid "Password for SMTP-AUTH. The argument is optional: If no argument is specified, then the empty string is used as the password. Default is the value of `sendemail.smtpPass`, however `--smtp-pass` always overrides this value."
msgstr "SMTP-AUTH 的密码。参数为可选参数：如果未指定参数，则使用空字符串作为密码。默认值是 `sendemail.smtpPass` 的值，但 `--smtp-pass` 始终会覆盖该值。"

#. type: Plain text
#: en/git-send-email.txt:228
#, placeholders:'`--smtp-user`':'sendemail.smtpUser':'`--smtp-pass`':'sendemail.smtpPass':'git-credential', priority:100
msgid "Furthermore, passwords need not be specified in configuration files or on the command line. If a username has been specified (with `--smtp-user` or a `sendemail.smtpUser`), but no password has been specified (with `--smtp-pass` or `sendemail.smtpPass`), then a password is obtained using 'git-credential'."
msgstr "此外，无需在配置文件或命令行中指定密码。如果已指定用户名（使用 `--smtp-user` 或 `sendemail.smtpUser`），但未指定密码（使用 `--smtp-pass` 或 `sendemail.smtpPass`），则使用 'git-credential' 获取密码。"

#. type: Labeled list
#: en/git-send-email.txt:229
#, ignore-same, no-wrap, priority:100
msgid "--no-smtp-auth"
msgstr "--no-smtp-auth"

#. type: Plain text
#: en/git-send-email.txt:231
#, placeholders:'`--smtp-auth=none`', priority:100
msgid "Disable SMTP authentication. Short hand for `--smtp-auth=none`"
msgstr "禁用 SMTP 验证。`--smtp-auth=none` 的简称"

#. type: Labeled list
#: en/git-send-email.txt:232
#, no-wrap, placeholders:'--smtp-server=', priority:100
msgid "--smtp-server=<host>"
msgstr "--smtp-server=<主机>"

#. type: Plain text
#: en/git-send-email.txt:238
#, placeholders:'`--sendmail-cmd`':'$PATH', priority:100
msgid "If set, specifies the outgoing SMTP server to use (e.g. `smtp.example.com` or a raw IP address). If unspecified, and if `--sendmail-cmd` is also unspecified, the default is to search for `sendmail` in `/usr/sbin`, `/usr/lib` and $PATH if such a program is available, falling back to `localhost` otherwise."
msgstr "如果设置，则指定要使用的外发 SMTP 服务器（例如 `smtp.example.com` 或原始 IP 地址）。 如果未指定，而且`--sendmail-cmd` 也未指定，默认情况下会在`/usr/sbin`、`/usr/lib` 和 $PATH 中搜索 `sendmail`（如果有），否则会返回到 `localhost`。"

#. type: Plain text
#: en/git-send-email.txt:244
#, placeholders:'`-i`':'`--sendmail-cmd`', priority:100
msgid "For backward compatibility, this option can also specify a full pathname of a sendmail-like program instead; the program must support the `-i` option. This method does not support passing arguments or using plain command names. For those use cases, consider using `--sendmail-cmd` instead."
msgstr "为了向后兼容，该选项也可以指定一个类似于 sendmail 的程序的完整路径名；该程序必须支持 `-i` 选项。 这种方法不支持传递参数或使用纯命令名。 在这些情况下，请考虑使用 `--sendmail-cmd`。"

#. type: Labeled list
#: en/git-send-email.txt:245
#, no-wrap, placeholders:'--smtp-server-port=', priority:100
msgid "--smtp-server-port=<port>"
msgstr "--smtp-server-port=<端口>"

#. type: Plain text
#: en/git-send-email.txt:252
#, placeholders:'sendemail.smtpServerPort', priority:100
msgid "Specifies a port different from the default port (SMTP servers typically listen to smtp port 25, but may also listen to submission port 587, or the common SSL smtp port 465); symbolic port names (e.g. \"submission\" instead of 587) are also accepted. The port can also be set with the `sendemail.smtpServerPort` configuration variable."
msgstr "指定一个不同于默认端口的端口（SMTP 服务器通常监听 smtp 端口 25，但也可能监听 submission 端口 587 或常用的 SSL smtp 端口 465）；也接受符号端口名称（如用 \"submission\" 代替 587）。端口也可以通过 `sendemail.smtpServerPort` 配置变量来设置。"

#. type: Labeled list
#: en/git-send-email.txt:253
#, no-wrap, placeholders:'--smtp-server-option=', priority:100
msgid "--smtp-server-option=<option>"
msgstr "--smtp-server-option=<选项>"

#. type: Plain text
#: en/git-send-email.txt:257
#, placeholders:'sendemail.smtpServerOption', priority:100
msgid "If set, specifies the outgoing SMTP server option to use. Default value can be specified by the `sendemail.smtpServerOption` configuration option."
msgstr "如果设置，则指定要使用的外发 SMTP 服务器选项。 默认值可由 `sendemail.smtpServerOption` 配置选项指定。"

#. type: Plain text
#: en/git-send-email.txt:261
#, placeholders:'--smtp-server-option', priority:100
msgid "The --smtp-server-option option must be repeated for each option you want to pass to the server. Likewise, different lines in the configuration files must be used for each option."
msgstr "对于要传递给服务器的每个选项，都必须重复使用 --smtp-server-option 选项。同样，每个选项必须在配置文件中使用不同的行。"

#. type: Labeled list
#: en/git-send-email.txt:262
#, ignore-same, no-wrap, priority:100
msgid "--smtp-ssl"
msgstr "--smtp-ssl"

#. type: Plain text
#: en/git-send-email.txt:264
#, placeholders:'--smtp-encryption', priority:100
msgid "Legacy alias for '--smtp-encryption ssl'."
msgstr "'--smtp-encryption ssl' 的遗留别名。"

#. type: Labeled list
#: en/git-send-email.txt:265
#, ignore-same, no-wrap, priority:100
msgid "--smtp-ssl-cert-path"
msgstr "--smtp-ssl-cert-path"

#. type: Plain text
#: en/git-send-email.txt:275
#, placeholders:'c_rehash':'sendemail.smtpsslcertpath', priority:100
msgid "Path to a store of trusted CA certificates for SMTP SSL/TLS certificate validation (either a directory that has been processed by 'c_rehash', or a single file containing one or more PEM format certificates concatenated together: see verify(1) -CAfile and -CApath for more information on these). Set it to an empty string to disable certificate verification. Defaults to the value of the `sendemail.smtpsslcertpath` configuration variable, if set, or the backing SSL library's compiled-in default otherwise (which should be the best choice on most platforms)."
msgstr "用于 SMTP SSL/TLS 证书验证的可信 CA 证书存储的路径（可以是已被 'c_rehash' 处理过的目录，也可以是包含一个或多个 PEM 格式证书的单个文件：请参阅 verify(1) -CAfile 和 -CApath，了解更多相关信息）。将其设置为空字符串可禁用证书验证。如果设置了，默认值为 `sendemail.smtpsslcertpath` 配置变量的值，否则默认值为备用 SSL 库编译后的默认值（这应该是大多数平台上的最佳选择）。"

#. type: Labeled list
#: en/git-send-email.txt:276
#, no-wrap, placeholders:'--smtp-user=', priority:100
msgid "--smtp-user=<user>"
msgstr "--smtp-user=<用户>"

#. type: Plain text
#: en/git-send-email.txt:280
#, placeholders:'sendemail.smtpUser':'`--smtp-user`':'sendemail.smtpUser', priority:100
msgid "Username for SMTP-AUTH. Default is the value of `sendemail.smtpUser`; if a username is not specified (with `--smtp-user` or `sendemail.smtpUser`), then authentication is not attempted."
msgstr "SMTP-AUTH 的用户名。默认值是 `sendemail.smtpUser` 的值；如果未指定用户名（使用 `--smtp-user` 或 `sendemail.smtpUser`），则不会尝试验证。"

#. type: Labeled list
#: en/git-send-email.txt:281
#, ignore-same, no-wrap, priority:100
msgid "--smtp-debug=0|1"
msgstr "--smtp-debug=0|1"

#. type: Plain text
#: en/git-send-email.txt:285
#, priority:100
msgid "Enable (1) or disable (0) debug output. If enabled, SMTP commands and replies will be printed. Useful to debug TLS connection and authentication problems."
msgstr "启用 (1) 或禁用 (0) 调试输出。如果启用，将打印 SMTP 命令和回复。用于调试 TLS 连接和身份验证问题。"

#. type: Labeled list
#: en/git-send-email.txt:286
#, no-wrap, placeholders:'--batch-size=', priority:100
msgid "--batch-size=<num>"
msgstr "--batch-size=<数值>"

#. type: Plain text
#: en/git-send-email.txt:295
#, placeholders:'--relogin-delay':'sendemail.smtpBatchSize', priority:100
msgid "Some email servers (e.g. smtp.163.com) limit the number emails to be sent per session (connection) and this will lead to a failure when sending many messages. With this option, send-email will disconnect after sending $<num> messages and wait for a few seconds (see --relogin-delay) and reconnect, to work around such a limit. You may want to use some form of credential helper to avoid having to retype your password every time this happens. Defaults to the `sendemail.smtpBatchSize` configuration variable."
msgstr "某些邮件服务器（如 smtp.163.com）限制每次会话（连接）发送的邮件数量，这将导致发送大量邮件时出现故障。 有了这个选项，send-email 会在发送 $<数值> 邮件后断开连接，等待几秒钟（参见 --relogin-delay ），然后重新连接，以规避这种限制。 你可能需要使用某种形式的凭证助手，以避免每次都要重新输入密码。 默认为 `sendemail.smtpBatchSize` 配置变量。"

#. type: Labeled list
#: en/git-send-email.txt:296
#, no-wrap, placeholders:'--relogin-delay=', priority:100
msgid "--relogin-delay=<int>"
msgstr "--relogin-delay=<整数>"

#. type: Plain text
#: en/git-send-email.txt:300
#, placeholders:'--batch-size':'sendemail.smtpReloginDelay', priority:100
msgid "Waiting $<int> seconds before reconnecting to SMTP server. Used together with --batch-size option. Defaults to the `sendemail.smtpReloginDelay` configuration variable."
msgstr "重新连接 SMTP 服务器前等待 $<整数> 秒。与 --batch-size 选项一起使用。 默认为 `sendemail.smtpReloginDelay` 配置变量。"

#. type: Title ~
#: en/git-send-email.txt:302
#, no-wrap, priority:100
msgid "Automating"
msgstr "自动化"

#. type: Labeled list
#: en/git-send-email.txt:304
#, no-wrap, placeholders:'--no-', priority:100
msgid "--no-[to|cc|bcc]"
msgstr "--no-[to|cc|bcc]"

#. type: Plain text
#: en/git-send-email.txt:307
#, priority:100
msgid "Clears any list of \"To:\", \"Cc:\", \"Bcc:\" addresses previously set via config."
msgstr "清除之前通过配置设置的 \"To:\"（收件人）、\"Cc:\"（抄送人）、\"Bcc:\"（密送人）地址列表。"

#. type: Labeled list
#: en/git-send-email.txt:308
#, ignore-same, no-wrap, priority:100
msgid "--no-identity"
msgstr "--no-identity"

#. type: Plain text
#: en/git-send-email.txt:311
#, placeholders:'sendemail.identity', priority:100
msgid "Clears the previously read value of `sendemail.identity` set via config, if any."
msgstr "清除先前读取的通过配置设置的 `sendemail.identity` 值（如果有）。"

#. type: Labeled list
#: en/git-send-email.txt:312
#, no-wrap, placeholders:'--to-cmd=', priority:100
msgid "--to-cmd=<command>"
msgstr "--to-cmd=<命令>"

#. type: Plain text
#: en/git-send-email.txt:317
#, placeholders:'sendemail.tocmd', priority:100
msgid "Specify a command to execute once per patch file which should generate patch file specific \"To:\" entries. Output of this command must be single email address per line. Default is the value of 'sendemail.tocmd' configuration value."
msgstr "指定每个补丁文件执行一次的命令，该命令应生成补丁文件特定的 \"To:\"（收件人）条目。 该命令的输出必须是每行一个电子邮件地址。 默认值为 'sendemail.tocmd' 配置值。"

#. type: Labeled list
#: en/git-send-email.txt:318
#, no-wrap, placeholders:'--cc-cmd=', priority:100
msgid "--cc-cmd=<command>"
msgstr "--cc-cmd=<命令>"

#. type: Plain text
#: en/git-send-email.txt:323
#, placeholders:'sendemail.ccCmd', priority:100
msgid "Specify a command to execute once per patch file which should generate patch file specific \"Cc:\" entries. Output of this command must be single email address per line. Default is the value of `sendemail.ccCmd` configuration value."
msgstr "指定每个补丁文件执行一次的命令，该命令应生成补丁文件特定的 \"Cc:\"（抄送人）条目。 该命令的输出必须是每行一个电子邮件地址。 默认值为 `sendemail.ccCmd` 配置值。"

#. type: Labeled list
#: en/git-send-email.txt:324
#, no-wrap, placeholders:'--header-cmd=', priority:100
msgid "--header-cmd=<command>"
msgstr "--header-cmd=<命令>"

#. type: Plain text
#: en/git-send-email.txt:331
#, placeholders:'sendemail.headerCmd':'--header-cmd':'sendemail.headerCmd', priority:100
msgid "Specify a command that is executed once per outgoing message and output RFC 2822 style header lines to be inserted into them. When the `sendemail.headerCmd` configuration variable is set, its value is always used. When --header-cmd is provided at the command line, its value takes precedence over the `sendemail.headerCmd` configuration variable."
msgstr "指定一条命令，每封发送邮件执行一次，并输出 RFC 2822 样式的标题行插入其中。如果设置了 `sendemail.headerCmd` 配置变量，则始终使用其值。在命令行中提供 --header-cmd 参数时，其值优先于 `sendemail.headerCmd` 配置变量。"

#. type: Labeled list
#: en/git-send-email.txt:332
#, ignore-same, no-wrap, priority:100
msgid "--no-header-cmd"
msgstr "--no-header-cmd"

#. type: Plain text
#: en/git-send-email.txt:334
#, priority:100
msgid "Disable any header command in use."
msgstr "禁用任何正在使用的标题命令。"

#. type: Labeled list
#: en/git-send-email.txt:335
#, ignore-same, no-wrap, priority:100
msgid "--[no-]chain-reply-to"
msgstr "--[no-]chain-reply-to"

#. type: Plain text
#: en/git-send-email.txt:342
#, placeholders:'--no-chain-reply-to':'sendemail.chainReplyTo', priority:100
msgid "If this is set, each email will be sent as a reply to the previous email sent. If disabled with \"--no-chain-reply-to\", all emails after the first will be sent as replies to the first email sent. When using this, it is recommended that the first file given be an overview of the entire patch series. Disabled by default, but the `sendemail.chainReplyTo` configuration variable can be used to enable it."
msgstr "如果设置了此项，每封邮件都将作为对前一封邮件的回复发送。 如果使用 \"--no-chain-reply-to\" 禁用该选项，则第一封邮件之后的所有邮件都将作为对第一封邮件的回复发送。 使用此功能时，建议给出的第一个文件是整个补丁系列的概述。默认情况下已禁用，但可以使用 `sendemail.chainReplyTo` 配置变量启用它。"

#. type: Labeled list
#: en/git-send-email.txt:343
#, no-wrap, placeholders:'--identity=', priority:100
msgid "--identity=<identity>"
msgstr "--identity=<身份>"

#. type: Plain text
#: en/git-send-email.txt:348
#, placeholders:'sendemail.identity', priority:100
msgid "A configuration identity. When given, causes values in the 'sendemail.<identity>' subsection to take precedence over values in the 'sendemail' section. The default identity is the value of `sendemail.identity`."
msgstr "配置标识。给定后，'sendemail.<认证>' 分节中的值将优先于 'sendemail' 部分中的值。默认身份是 `sendemail.identity` 的值。"

#. type: Labeled list
#: en/git-send-email.txt:349
#, ignore-same, no-wrap, priority:100
msgid "--[no-]signed-off-by-cc"
msgstr "--[no-]signed-off-by-cc"

#. type: Plain text
#: en/git-send-email.txt:353
#, placeholders:'sendemail.signedoffbycc':'--signed-off-by-cc', priority:100
msgid "If this is set, add emails found in the `Signed-off-by` trailer or Cc: lines to the cc list. Default is the value of `sendemail.signedoffbycc` configuration value; if that is unspecified, default to --signed-off-by-cc."
msgstr "如果设置了此选项，请将“ Signed-off-by”预告或抄送：行中的电子邮件添加到抄送列表中。默认为`sendemail.signedoffbycc`配置值的值；如果未指定，则默认为--signed-off-by-cc。"

#. type: Labeled list
#: en/git-send-email.txt:354
#, ignore-same, no-wrap, priority:100
msgid "--[no-]cc-cover"
msgstr "--[no-]cc-cover"

#. type: Plain text
#: en/git-send-email.txt:359
#, placeholders:'sendemail.cccover':'--no-cc-cover', priority:100
msgid "If this is set, emails found in Cc: headers in the first patch of the series (typically the cover letter) are added to the cc list for each email set. Default is the value of 'sendemail.cccover' configuration value; if that is unspecified, default to --no-cc-cover."
msgstr "如果设置了此项，在系列邮件的第一个补丁（通常是封面信）的抄送标题中找到的电子邮件将被添加到每个邮件集的抄送列表中。默认值为 'sendemail.cccover' 配置值；如果未指定，默认值为 --no-cc-cover。"

#. type: Labeled list
#: en/git-send-email.txt:360
#, ignore-same, no-wrap, priority:100
msgid "--[no-]to-cover"
msgstr "--[no-]to-cover"

#. type: Plain text
#: en/git-send-email.txt:365
#, placeholders:'sendemail.tocover':'--no-to-cover', priority:100
msgid "If this is set, emails found in To: headers in the first patch of the series (typically the cover letter) are added to the to list for each email set. Default is the value of 'sendemail.tocover' configuration value; if that is unspecified, default to --no-to-cover."
msgstr "如果设置了此项，在系列邮件的第一个补丁（通常是封面信函）的收件人标题中找到的邮件将被添加到每个邮件集的收件人列表中。默认值为 'sendemail.tocover' 配置值；如果未指定，默认值为--no-to-cover。"

#. type: Labeled list
#: en/git-send-email.txt:366
#, no-wrap, placeholders:'--suppress-cc=', priority:100
msgid "--suppress-cc=<category>"
msgstr "--suppress-cc=<类别>"

#. type: Plain text
#: en/git-send-email.txt:369
#, priority:100
msgid "Specify an additional category of recipients to suppress the auto-cc of:"
msgstr "指定一个额外的收件人类别，以禁止自动收件："

#. type: Plain text
#: en/git-send-email.txt:372
#, priority:100
msgid "'author' will avoid including the patch author."
msgstr "'author' 将避免包含补丁作者。"

#. type: Plain text
#: en/git-send-email.txt:373
#, priority:100
msgid "'self' will avoid including the sender."
msgstr "'self' 将避免包括发件人。"

#. type: Plain text
#: en/git-send-email.txt:375
#, priority:100
msgid "'cc' will avoid including anyone mentioned in Cc lines in the patch header except for self (use 'self' for that)."
msgstr "'cc' 将避免包括补丁头中抄送行提到的任何人，但自己除外（使用 'self' 即可）。"

#. type: Plain text
#: en/git-send-email.txt:377
#, priority:100
msgid "'bodycc' will avoid including anyone mentioned in Cc lines in the patch body (commit message) except for self (use 'self' for that)."
msgstr "'bodycc' 将避免在补丁正文（提交信息）中包含抄送行中提到的任何人，但自己除外（为此使用 'self'）。"

#. type: Plain text
#: en/git-send-email.txt:379
#, priority:100
msgid "'sob' will avoid including anyone mentioned in the Signed-off-by trailers except for self (use 'self' for that)."
msgstr "'sob' 将避免包括签名行中提到的任何人， 除了自我 （为此使用 \"自我\" ）。"

#. type: Plain text
#: en/git-send-email.txt:382
#, priority:100
msgid "'misc-by' will avoid including anyone mentioned in Acked-by, Reviewed-by, Tested-by and other \"-by\" lines in the patch body, except Signed-off-by (use 'sob' for that)."
msgstr "'misc-by' 将避免包含补丁正文中的 Acked-by、Reviewed-by、Tested-by 和其他 \"-by \" 行提到的任何人，但 Signed-off-by 除外（使用 'sob' ）。"

#. type: Plain text
#: en/git-send-email.txt:383
#, placeholders:'--cc-cmd', priority:100
msgid "'cccmd' will avoid running the --cc-cmd."
msgstr "'cccmd' 将避免运行 --cc-cmd 命令。"

#. type: Plain text
#: en/git-send-email.txt:384
#, priority:100
msgid "'body' is equivalent to 'sob' + 'bodycc' + 'misc-by'."
msgstr "'body' 等同于 'sob' + 'bodycc' + 'misc-by'。"

#. type: Plain text
#: en/git-send-email.txt:385
#, priority:100
msgid "'all' will suppress all auto cc values."
msgstr "'all' 会抑制所有自动抄送值。"

#. type: Plain text
#: en/git-send-email.txt:390
#, placeholders:'sendemail.suppresscc':'--suppress-from':'--no-signed-off-cc', priority:100
msgid "Default is the value of `sendemail.suppresscc` configuration value; if that is unspecified, default to 'self' if --suppress-from is specified, as well as 'body' if --no-signed-off-cc is specified."
msgstr "默认值是 `sendemail.suppresscc` 配置值的值，如果未指定，则在指定 --suppress-from 参数时默认为 'self'，在指定 --no-signed-off-cc 参数时默认为 'body'。"

#. type: Labeled list
#: en/git-send-email.txt:391
#, ignore-same, no-wrap, priority:100
msgid "--[no-]suppress-from"
msgstr "--[no-]suppress-from"

#. type: Plain text
#: en/git-send-email.txt:395
#, placeholders:'sendemail.suppressFrom':'--no-suppress-from', priority:100
msgid "If this is set, do not add the From: address to the cc: list. Default is the value of `sendemail.suppressFrom` configuration value; if that is unspecified, default to --no-suppress-from."
msgstr "如果设置了此项，则不会将发件人地址添加到抄送地址列表中。 默认值是 `sendemail.suppressFrom` 配置值的值，如果未指定，则默认为 --no-suppress-from 参数。"

#. type: Labeled list
#: en/git-send-email.txt:396
#, ignore-same, no-wrap, priority:100
msgid "--[no-]thread"
msgstr "--[no-]thread"

#. type: Plain text
#: en/git-send-email.txt:402
#, placeholders:'git format-patch', priority:100
msgid "If this is set, the In-Reply-To and References headers will be added to each email sent. Whether each mail refers to the previous email (`deep` threading per 'git format-patch' wording) or to the first email (`shallow` threading) is governed by \"--[no-]chain-reply-to\"."
msgstr "如果设置了此项，每封邮件都会添加 In-Reply-To 和 References 标头。 每封邮件是引用前一封邮件（'git format-patch' 中的 `deep` 线程），还是引用第一封邮件（`shallow` 线程），由 \"--[no-]chain-reply-to\" 决定。"

#. type: Plain text
#: en/git-send-email.txt:407
#, placeholders:'--no-thread':'--in-reply-to':'sendemail.thread':'--thread', priority:100
msgid "If disabled with \"--no-thread\", those headers will not be added (unless specified with --in-reply-to). Default is the value of the `sendemail.thread` configuration value; if that is unspecified, default to --thread."
msgstr "如果使用\"--no-thread\" 禁用，则不会添加这些标题（除非使用 --in-reply-to 指定）。 默认值是 \"sendemail.thread\" 配置值；如果未指定，则默认为 --thread 选项。"

#. type: Plain text
#: en/git-send-email.txt:413
#, placeholders:'git send-email':'git format-patch', priority:100
msgid "It is up to the user to ensure that no In-Reply-To header already exists when 'git send-email' is asked to add it (especially note that 'git format-patch' can be configured to do the threading itself). Failure to do so may not produce the expected result in the recipient's MUA."
msgstr "当 'git send-email' 被要求添加 In-Reply-To 头信息时，用户应确保该头条信息不存在（特别要注意的是，'git format-patch' 可被配置为自行进行线程处理）。 否则可能无法在收件人的 MUA 中产生预期结果。"

#. type: Title ~
#: en/git-send-email.txt:416
#, no-wrap, priority:100
msgid "Administering"
msgstr "管理"

#. type: Labeled list
#: en/git-send-email.txt:418
#, no-wrap, placeholders:'--confirm=', priority:100
msgid "--confirm=<mode>"
msgstr "--confirm=<模式>"

#. type: Plain text
#: en/git-send-email.txt:420
#, priority:100
msgid "Confirm just before sending:"
msgstr "发送前确认："

#. type: Plain text
#: en/git-send-email.txt:423
#, priority:100
msgid "'always' will always confirm before sending"
msgstr "'always' 总会在发送前确认"

#. type: Plain text
#: en/git-send-email.txt:424
#, priority:100
msgid "'never' will never confirm before sending"
msgstr "'never' 在发送前不会确认"

#. type: Plain text
#: en/git-send-email.txt:426
#, priority:100
msgid "'cc' will confirm before sending when send-email has automatically added addresses from the patch to the Cc list"
msgstr "如果发送邮件已自动将补丁中的地址添加到抄送列表中，'cc' 将在发送前进行确认"

#. type: Plain text
#: en/git-send-email.txt:427
#, placeholders:'--compose', priority:100
msgid "'compose' will confirm before sending the first message when using --compose."
msgstr "当使用 --compose 选项时，'compose' 会在发送第一条信息前进行确认。"

#. type: Plain text
#: en/git-send-email.txt:428
#, priority:100
msgid "'auto' is equivalent to 'cc' + 'compose'"
msgstr "'auto' 等同于 'cc' + 'compose'"

#. type: Plain text
#: en/git-send-email.txt:433
#, placeholders:'sendemail.confirm', priority:100
msgid "Default is the value of `sendemail.confirm` configuration value; if that is unspecified, default to 'auto' unless any of the suppress options have been specified, in which case default to 'compose'."
msgstr "默认值是 `sendemail.confirm` 配置值的值，如果未指定，则默认为 'auto'，除非指定了任何抑制选项，在这种情况下默认为 'compose'。"

#. type: Plain text
#: en/git-send-email.txt:436
#, priority:100
msgid "Do everything except actually send the emails."
msgstr "除了实际发送邮件外，什么都做。"

#. type: Labeled list
#: en/git-send-email.txt:437
#, ignore-same, no-wrap, priority:100
msgid "--[no-]format-patch"
msgstr "--[no-]format-patch"

#. type: Plain text
#: en/git-send-email.txt:442
#, placeholders:'`--format-patch`':'`--no-format-patch`':'git send-email', priority:100
msgid "When an argument may be understood either as a reference or as a file name, choose to understand it as a format-patch argument (`--format-patch`) or as a file name (`--no-format-patch`). By default, when such a conflict occurs, git send-email will fail."
msgstr "当参数可以理解为引用或文件名时，选择将其理解为格式补丁参数（`--format-patch`）或文件名（`--no-format-patch`）。默认情况下，当出现这种冲突时，git send-email 操作将失败。"

#. type: Plain text
#: en/git-send-email.txt:446
#, placeholders:'git-send-email', priority:100
msgid "Make git-send-email less verbose. One line per email should be all that is output."
msgstr "让 git-send-email 少输出一些。 每封邮件只输出一行即可。"

#. type: Labeled list
#: en/git-send-email.txt:447
#, ignore-same, no-wrap, priority:100
msgid "--[no-]validate"
msgstr "--[no-]validate"

#. type: Plain text
#: en/git-send-email.txt:450
#, priority:100
msgid "Perform sanity checks on patches. Currently, validation means the following:"
msgstr "对补丁进行正确性检查。 目前，验证的含义如下："

#. type: Plain text
#: en/git-send-email.txt:453
#, placeholders:'linkgit:githooks[5]', priority:100
msgid "Invoke the sendemail-validate hook if present (see linkgit:githooks[5])."
msgstr "调用 sendemail-validate （发送邮件验证）钩子（如果存在）（参见 linkgit:githooks[5])。"

#. type: Plain text
#: en/git-send-email.txt:454
#, priority:100
msgid "Warn of patches that contain lines longer than"
msgstr "警告含有长于"

#. type: Plain text
#: en/git-send-email.txt:458
#, no-wrap, placeholders:'www.ietf.org', priority:100
msgid ""
"998 characters unless a suitable transfer encoding\n"
"('auto', 'base64', or 'quoted-printable') is used;\n"
"this is due to SMTP limits as described by\n"
"https://www.ietf.org/rfc/rfc5322.txt.\n"
msgstr ""
"998 个字符，除非使用了合适的传输编码\n"
"('auto'、'base64' 或 'quoted-printable'）都会使用；\n"
"这是因为 SMTP 的限制，如\n"
"https://www.ietf.org/rfc/rfc5322.txt。\n"

#. type: Plain text
#: en/git-send-email.txt:462
#, placeholders:'sendemail.validate':'`--validate`', priority:100
msgid "Default is the value of `sendemail.validate`; if this is not set, default to `--validate`."
msgstr "默认为 `sendemail.validate` 的值；如果未设置，则默认为 `--validate` 参数。"

#. type: Plain text
#: en/git-send-email.txt:465
#, priority:100
msgid "Send emails even if safety checks would prevent it."
msgstr "即使安全检查不允许，也要发送电子邮件。"

#. type: Title ~
#: en/git-send-email.txt:468
#, no-wrap, priority:100
msgid "Information"
msgstr "信息"

#. type: Labeled list
#: en/git-send-email.txt:470
#, ignore-same, no-wrap, priority:100
msgid "--dump-aliases"
msgstr "--dump-aliases"

#. type: Plain text
#: en/git-send-email.txt:475
#, placeholders:'sendemail.aliasesfile', priority:100
msgid "Instead of the normal operation, dump the shorthand alias names from the configured alias file(s), one per line in alphabetical order. Note that this only includes the alias name and not its expanded email addresses. See 'sendemail.aliasesfile' for more information about aliases."
msgstr "不执行正常操作，而是从配置的别名文件中按字母顺序每行转存一个速记别名。注意，这只包括别名，不包括其扩展的电子邮件地址。 有关别名的更多信息，请参阅 'sendemail.aliasesfile'。"

#. type: Title ~
#: en/git-send-email.txt:487
#, no-wrap, priority:100
msgid "Use gmail as the smtp server"
msgstr "使用 gmail 作为 smtp 服务器"

#. type: Plain text
#: en/git-send-email.txt:490
#, placeholders:'git send-email', priority:100
msgid "To use 'git send-email' to send your patches through the GMail SMTP server, edit ~/.gitconfig to specify your account settings:"
msgstr "要使用 'git send-email' 通过 GMail SMTP 服务器发送补丁，请编辑 ~/.gitconfig 指定账户设置："

#. type: delimited block -
#: en/git-send-email.txt:497
#, no-wrap, placeholders:'smtp.gmail.com':'gmail.com', priority:100
msgid ""
"[sendemail]\n"
"\tsmtpEncryption = tls\n"
"\tsmtpServer = smtp.gmail.com\n"
"\tsmtpUser = yourname@gmail.com\n"
"\tsmtpServerPort = 587\n"
msgstr ""
"[sendemail]\n"
"\tsmtpEncryption = tls\n"
"\tsmtpServer = smtp.gmail.com\n"
"\tsmtpUser = yourname@gmail.com\n"
"\tsmtpServerPort = 587\n"

#. type: Plain text
#: en/git-send-email.txt:502
#, placeholders:'git send-email':'security.google.com', priority:100
msgid "If you have multi-factor authentication set up on your Gmail account, you can generate an app-specific password for use with 'git send-email'. Visit https://security.google.com/settings/security/apppasswords to create it."
msgstr "如果您的 Gmail 账户设置了多因素身份验证，您可以生成一个应用程序专用密码，供 'git send-email' 使用。请访问 https://security.google.com/settings/security/apppasswords 创建密码。"

#. type: Plain text
#: en/git-send-email.txt:505
#, priority:100
msgid "Once your commits are ready to be sent to the mailing list, run the following commands:"
msgstr "一旦您的提交已准备好发送至邮件列表，请运行以下命令："

#. type: Plain text
#: en/git-send-email.txt:509
#, no-wrap, placeholders:'git format-patch':'--cover-letter':'git send-email', priority:100
msgid ""
"\t$ git format-patch --cover-letter -M origin/master -o outgoing/\n"
"\t$ edit outgoing/0000-*\n"
"\t$ git send-email outgoing/*\n"
msgstr ""
"\t$ git format-patch --cover-letter -M origin/master -o outgoing/\n"
"\t$ edit outgoing/0000-*\n"
"\t$ git send-email outgoing/*\n"

#. type: Plain text
#: en/git-send-email.txt:514
#, placeholders:'linkgit:git-credential[1]', priority:100
msgid "The first time you run it, you will be prompted for your credentials. Enter the app-specific or your regular password as appropriate. If you have credential helper configured (see linkgit:git-credential[1]), the password will be saved in the credential store so you won't have to type it the next time."
msgstr "首次运行时，系统会提示您输入凭据。 请根据情况输入特定于应用程序的密码或常规密码。 如果配置了凭据助手（参见 linkgit:git-credential[1]），密码会保存在凭据存储区，下次就不用再输入了。"

#. type: Plain text
#: en/git-send-email.txt:520
#, priority:100
msgid "Note: the following core Perl modules that may be installed with your distribution of Perl are required: MIME::Base64, MIME::QuotedPrint, Net::Domain and Net::SMTP. These additional Perl modules are also required: Authen::SASL and Mail::Address."
msgstr "注意：需要安装以下 Perl 核心模块，这些模块可能已随 Perl 发行版一起安装： MIME::Base64、MIME::QuotedPrint、Net::Domain 和 Net::SMTP。 还需要安装这些额外的 Perl 模块： Authen::SASL 和 Mail::Address。"

#. type: Plain text
#: en/git-send-email.txt:525
#, placeholders:'linkgit:git-format-patch[1]':'linkgit:git-imap-send[1]', priority:100
msgid "linkgit:git-format-patch[1], linkgit:git-imap-send[1], mbox(5)"
msgstr "linkgit:git-format-patch[1], linkgit:git-imap-send[1], mbox(5)"

#. type: Title =
#: en/git-send-pack.txt:2
#, ignore-same, no-wrap, priority:90
msgid "git-send-pack(1)"
msgstr "git-send-pack(1)"

#. type: Plain text
#: en/git-send-pack.txt:7
#, placeholders:'git-send-pack', priority:90
msgid "git-send-pack - Push objects over Git protocol to another repository"
msgstr "git-send-pack - 通过 Git 协议将对象推送到另一个仓库"

#. type: Plain text
#: en/git-send-pack.txt:17
#, ignore-ellipsis, no-wrap, placeholders:'git send-pack':'[--mirror]':'[--dry-run]':'[--force]':'[--receive-pack=':'git-receive-pack':'[--verbose]':'[--thin]':'[--atomic]':'--signed=(true|false|if-asked)]':'--all', priority:90
msgid ""
"'git send-pack' [--mirror] [--dry-run] [--force]\n"
"\t\t[--receive-pack=<git-receive-pack>]\n"
"\t\t[--verbose] [--thin] [--atomic]\n"
"\t\t[--[no-]signed | --signed=(true|false|if-asked)]\n"
"\t\t[<host>:]<directory> (--all | <ref>...)\n"
msgstr ""
"'git send-pack' [--mirror] [--dry-run] [--force]\n"
"\t\t[--receive-pack=<git-receive-pack>]\n"
"\t\t[--verbose] [--thin] [--atomic]\n"
"\t\t[--[no-]signed | --signed=(true|false|if-asked)]\n"
"\t\t[<主机地址>:]<目录> (--all | <引用>...)\n"

#. type: Plain text
#: en/git-send-pack.txt:22
#, placeholders:'linkgit:git-push[1]', priority:90
msgid "Usually you would want to use 'git push', which is a higher-level wrapper of this command, instead. See linkgit:git-push[1]."
msgstr "通常情况下，您需要使用 'git push'，它是该命令的高级封装。参见 linkgit:git-push[1]。"

#. type: Plain text
#: en/git-send-pack.txt:25
#, placeholders:'git-receive-pack', priority:90
msgid "Invokes 'git-receive-pack' on a possibly remote repository, and updates it from the current repository, sending named refs."
msgstr "在可能的远程仓库上调用 'git-receive-pack'，并从当前仓库更新，同时发送命名的引用。"

#. type: Plain text
#: en/git-send-pack.txt:37
#, placeholders:'--receive-pack=':'git-receive-pack', priority:90
msgid "Same as --receive-pack=<git-receive-pack>."
msgstr "与 --receive-pack=<git-receive-pack> 相同。"

#. type: Plain text
#: en/git-send-pack.txt:41
#, priority:90
msgid "Instead of explicitly specifying which refs to update, update all heads that locally exist."
msgstr "无需明确指定要更新的索引，而是更新本地存在的所有索引头。"

#. type: Plain text
#: en/git-send-pack.txt:61
#, priority:90
msgid "Usually, the command refuses to update a remote ref that is not an ancestor of the local ref used to overwrite it. This flag disables the check. This means that the remote repository can lose commits; use it with care."
msgstr "通常情况下，命令拒绝更新一个不是用来覆盖它的本地引用的祖先远程引用。 这个标志可以禁止这种检查。 这意味着远程仓库可能会丢失提交，使用时要小心。"

#. type: Plain text
#: en/git-send-pack.txt:68
#, priority:90
msgid "Send a \"thin\" pack, which records objects in deltified form based on objects not included in the pack to reduce network traffic."
msgstr "发送 “瘦” 数据包，根据未包含在数据包中的对象，以简化形式记录对象，以减少网络流量。"

#. type: Plain text
#: en/git-send-pack.txt:73
#, priority:90
msgid "Use an atomic transaction for updating the refs. If any of the refs fails to update then the entire push will fail without changing any refs."
msgstr "使用原子事务更新一些引用。如果任何一个引用更新失败，那么整个推送都将失败，而不会更改任何引用。"

#. type: Labeled list
#: en/git-send-pack.txt:85
#, no-wrap, placeholders:'--push-option=', priority:90
msgid "--push-option=<string>"
msgstr "--push-option=<字符串>"

#. type: Plain text
#: en/git-send-pack.txt:90
#, placeholders:'linkgit:git-push[1]':'linkgit:githooks[5]', priority:90
msgid "Pass the specified string as a push option for consumption by hooks on the server side. If the server doesn't support push options, error out. See linkgit:git-push[1] and linkgit:githooks[5] for details."
msgstr "传递指定字符串作为推送选项，供服务器端的钩子使用。 如果服务器不支持推送选项，则会出错。 详情参见 linkgit:git-push[1] 和 linkgit:githooks[5]。"

#. type: Labeled list
#: en/git-send-pack.txt:91
#, no-wrap, priority:90
msgid "<host>"
msgstr "<主机>"

#. type: Plain text
#: en/git-send-pack.txt:95
#, placeholders:'git-receive-pack', priority:90
msgid "A remote host to house the repository. When this part is specified, 'git-receive-pack' is invoked via ssh."
msgstr "存放仓库的远程主机。 如果指定了这一部分，就会通过 ssh 调用 \"git-receive-pack\"。"

#. type: Plain text
#: en/git-send-pack.txt:98
#, priority:90
msgid "The repository to update."
msgstr "要更新的仓库。"

#. type: Plain text
#: en/git-send-pack.txt:108
#, priority:90
msgid "There are three ways to specify which refs to update on the remote end."
msgstr "有三种方法可以指定在远程端更新哪些参考文件。"

#. type: Plain text
#: en/git-send-pack.txt:112
#, placeholders:'`--all`', priority:90
msgid "With the `--all` flag, all refs that exist locally are transferred to the remote side. You cannot specify any '<ref>' if you use this flag."
msgstr "使用 `--all` 标志时，本地存在的所有引用都会被传输到远端。 使用该标记时，不能指定任何 `<引用>`。"

#. type: Plain text
#: en/git-send-pack.txt:115
#, placeholders:'`--all`', priority:90
msgid "Without `--all` and without any '<ref>', the heads that exist both on the local side and on the remote side are updated."
msgstr "如果不使用 `--all`，也不使用任何 `<引用>`，本地和远程都存在的磁头都会被更新。"

#. type: Plain text
#: en/git-send-pack.txt:121
#, placeholders:'`--stdin`', priority:90
msgid "When one or more '<ref>' are specified explicitly (whether on the command line or via `--stdin`), it can be either a single pattern, or a pair of such patterns separated by a colon \":\" (this means that a ref name cannot have a colon in it). A single pattern '<name>' is just shorthand for '<name>:<name>'."
msgstr "当一个或多个 '<引用>' 被明确指定时（无论是在命令行还是通过 `--stdin`），它既可以是一个单独的模式，也可以是一对由冒号 \":\" 分隔的模式（这意味着引用名称中不能有冒号）。 单一模式 '<名称>' 只是 '<名称>:<名称>' 的简称。"

#. type: Plain text
#: en/git-send-pack.txt:129
#, placeholders:'git rev-parse':'linkgit:git-rev-parse[1]', priority:90
msgid "Each pattern pair consists of the source side (before the colon) and the destination side (after the colon). The ref to be pushed is determined by finding a match that matches the source side, and where it is pushed is determined by using the destination side. The rules used to match a ref are the same rules used by 'git rev-parse' to resolve a symbolic ref name. See linkgit:git-rev-parse[1]."
msgstr "每个模式对包括源端（冒号前）和目标端（冒号后）。 要推送的引用是通过找到与源侧相匹配的匹配来确定的，而推送到哪里则是通过目的地侧来确定的。用于匹配引用的规则与 \"git rev-parse\" 用于解析符号引用名称的规则相同。参见 linkgit:git-rev-parse[1]。"

#. type: Plain text
#: en/git-send-pack.txt:132
#, priority:90
msgid "It is an error if <src> does not match exactly one of the local refs."
msgstr "如果 <源端> 与一个本地引用不完全匹配，则会出错。"

#. type: Plain text
#: en/git-send-pack.txt:134
#, priority:90
msgid "It is an error if <dst> matches more than one remote ref."
msgstr "如果 <目标> 匹配多个远程引用，则会出错。"

#. type: Plain text
#: en/git-send-pack.txt:136
#, priority:90
msgid "If <dst> does not match any remote ref, either"
msgstr "如果 <目的端> 与任何远程引用不匹配，或者"

#. type: Plain text
#: en/git-send-pack.txt:149
#, placeholders:'`--force`', priority:90
msgid "Without `--force`, the <src> ref is stored at the remote only if <dst> does not exist, or <dst> is a proper subset (i.e. an ancestor) of <src>. This check, known as the \"fast-forward check\", is performed to avoid accidentally overwriting the remote ref and losing other people's commits from there."
msgstr "如果不使用 `--force`，只有当 <目标> 不存在，或者 <目标> 是 <源> 的适当子集（即祖先）时，<源> 引用才会被存储到远程引用中。 这种检查被称为 \"快进检查\"（fast-forward check），执行这种检查是为了避免意外覆盖远程引用并丢失其他人从那里提交的内容。"

#. type: Title =
#: en/git-shell.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-shell(1)"
msgstr "git-shell(1)"

#. type: Plain text
#: en/git-shell.txt:7
#, placeholders:'git-shell', priority:100
msgid "git-shell - Restricted login shell for Git-only SSH access"
msgstr "git-shell - 仅限 Git SSH 访问的受限登录 shell"

#. type: Plain text
#: en/git-shell.txt:15
#, no-wrap, placeholders:'git-shell', priority:100
msgid ""
"'chsh' -s $(command -v git-shell) <user>\n"
"'git clone' <user>`@localhost:/path/to/repo.git`\n"
"'ssh' <user>`@localhost`\n"
msgstr ""
"'chsh' -s $(command -v git-shell) <用户>\n"
"'git clone' <用户>`@localhost:/path/to/repo.git`\n"
"'ssh' <用户>`@localhost`\n"

#. type: Plain text
#: en/git-shell.txt:23
#, placeholders:'git-shell-commands', priority:100
msgid "This is a login shell for SSH accounts to provide restricted Git access. It permits execution only of server-side Git commands implementing the pull/push functionality, plus custom commands present in a subdirectory named `git-shell-commands` in the user's home directory."
msgstr "这是 SSH 账户的登录 shell，提供受限的 Git 访问权限。 它只允许执行实现拉/推功能的服务器端 Git 命令，以及用户主目录中名为 `git-shell-commands` 子目录下的自定义命令。"

#. type: Plain text
#: en/git-shell.txt:28
#, placeholders:'`-c`', priority:100
msgid "'git shell' accepts the following commands after the `-c` option:"
msgstr "'git shell' 接受在 `-c` 选项之后的下列命令："

#. type: Labeled list
#: en/git-shell.txt:29
#, no-wrap, placeholders:'git receive-pack', priority:100
msgid "'git receive-pack <argument>'"
msgstr "'git receive-pack <参数>'"

#. type: Labeled list
#: en/git-shell.txt:30
#, no-wrap, placeholders:'git upload-pack', priority:100
msgid "'git upload-pack <argument>'"
msgstr "'git upload-pack <参数>'"

#. type: Labeled list
#: en/git-shell.txt:31
#, no-wrap, placeholders:'git upload-archive', priority:100
msgid "'git upload-archive <argument>'"
msgstr "'git upload-archive <参数>'"

#. type: Plain text
#: en/git-shell.txt:35
#, placeholders:'--remote', priority:100
msgid "Call the corresponding server-side command to support the client's 'git push', 'git fetch', or 'git archive --remote' request."
msgstr "调用相应的服务器端命令，以支持客户端的 'git push'、'git fetch' 或 'git archive --remote' 请求。"

#. type: Labeled list
#: en/git-shell.txt:35
#, no-wrap, priority:100
msgid "'cvs server'"
msgstr "‘cvs 服务器’"

#. type: Plain text
#: en/git-shell.txt:37
#, placeholders:'linkgit:git-cvsserver[1]', priority:100
msgid "Imitate a CVS server. See linkgit:git-cvsserver[1]."
msgstr "模仿 CVS 服务器。 参见 linkgit:git-cvsserver[1]。"

#. type: Plain text
#: en/git-shell.txt:42
#, placeholders:'git-shell-commands':'git-shell-commands', priority:100
msgid "If a `~/git-shell-commands` directory is present, 'git shell' will also handle other, custom commands by running \"`git-shell-commands/<command> <arguments>`\" from the user's home directory."
msgstr "如果有 `~/git-shell-commands` 目录，'git shell' 也会处理其他自定义命令，方法是从用户的主目录运行 \"`git-shell-commands/<命令> <参数>`\"。"

#. type: Title -
#: en/git-shell.txt:44
#, no-wrap, priority:100
msgid "INTERACTIVE USE"
msgstr "交互式使用"

#. type: Plain text
#: en/git-shell.txt:48
#, placeholders:'`-c`', priority:100
msgid "By default, the commands above can be executed only with the `-c` option; the shell is not interactive."
msgstr "默认情况下，上述命令只能通过 `-c` 选项执行；shell 不是交互式的。"

#. type: Plain text
#: en/git-shell.txt:56
#, placeholders:'git-shell-commands':'git-shell-commands':'git-shell-commands', priority:100
msgid "If a `~/git-shell-commands` directory is present, 'git shell' can also be run interactively (with no arguments). If a `help` command is present in the `git-shell-commands` directory, it is run to provide the user with an overview of allowed actions. Then a \"git> \" prompt is presented at which one can enter any of the commands from the `git-shell-commands` directory, or `exit` to close the connection."
msgstr "如果有 `~/git-shell-commands` 目录，'git shell' 也可以交互式运行（不带参数）。 如果 `git-shell-commands` 目录中有 `help` 命令，则会运行该命令向用户提供允许操作的概览。 然后会出现 \"git>\" 提示，用户可以在此输入`git-shell-commands`目录下的任何命令，或`exit`关闭连接。"

#. type: Plain text
#: en/git-shell.txt:61
#, priority:100
msgid "Generally this mode is used as an administrative interface to allow users to list repositories they have access to, create, delete, or rename repositories, or change repository descriptions and permissions."
msgstr "一般情况下，该模式用作管理界面，允许用户列出他们可以访问的资源库，创建、删除或重命名资源库，或更改资源库说明和权限。"

#. type: Plain text
#: en/git-shell.txt:64
#, priority:100
msgid "If a `no-interactive-login` command exists, then it is run and the interactive shell is aborted."
msgstr "如果存在 `no-interactive-login` 命令，则运行该命令并终止交互式 shell。"

#. type: Plain text
#: en/git-shell.txt:69
#, priority:100
msgid "To disable interactive logins, displaying a greeting instead:"
msgstr "禁用交互式登录，显示问候语："

#. type: delimited block -
#: en/git-shell.txt:80
#, no-wrap, placeholders:'git-shell':'$HOME':'git-shell-commands':'$HOME':'git-shell-commands':'$USER':'$HOME':'git-shell-commands', priority:100
msgid ""
"$ chsh -s /usr/bin/git-shell\n"
"$ mkdir $HOME/git-shell-commands\n"
"$ cat >$HOME/git-shell-commands/no-interactive-login <<\\EOF\n"
"#!/bin/sh\n"
"printf '%s\\n' \"Hi $USER! You've successfully authenticated, but I do not\"\n"
"printf '%s\\n' \"provide interactive shell access.\"\n"
"exit 128\n"
"EOF\n"
"$ chmod +x $HOME/git-shell-commands/no-interactive-login\n"
msgstr ""
"$ chsh -s /usr/bin/git-shell\n"
"$ mkdir $HOME/git-shell-commands\n"
"$ cat >$HOME/git-shell-commands/no-interactive-login <<\\EOF\n"
"#!/bin/sh\n"
"printf '%s\\n' \"你好，$USER！您已成功通过身份验证，但我没有\"\n"
"printf '%s\\n' \"提供交互式 shell 访问。\"\n"
"exit 128\n"
"EOF\n"
"$ chmod +x $HOME/git-shell-commands/no-interactive-login\n"

#. type: Plain text
#: en/git-shell.txt:85
#, placeholders:'git-cvsserver':'git-shell-commands', priority:100
msgid "To enable git-cvsserver access (which should generally have the `no-interactive-login` example above as a prerequisite, as creating the git-shell-commands directory allows interactive logins):"
msgstr "要启用 git-cvsserver 访问权限（一般应以上面的 `no-interactive-login` 示例为前提，因为创建 git-shell-commands 目录允许交互式登录）："

#. type: delimited block -
#: en/git-shell.txt:96
#, no-wrap, placeholders:'$HOME':'git-shell-commands':'git-cvsserver':'$HOME':'git-shell-commands', priority:100
msgid ""
"$ cat >$HOME/git-shell-commands/cvs <<\\EOF\n"
"if ! test $# = 1 && test \"$1\" = \"server\"\n"
"then\n"
"\techo >&2 \"git-cvsserver only handles \\\"server\\\"\"\n"
"\texit 1\n"
"fi\n"
"exec git cvsserver server\n"
"EOF\n"
"$ chmod +x $HOME/git-shell-commands/cvs\n"
msgstr ""
"$ cat >$HOME/git-shell-commands/cvs <<\\EOF\n"
"if ! test $# = 1 && test \"$1\" = \"server\"\n"
"then\n"
"\techo >&2 \"git-cvsserver only handles \\\"server\\\"\"\n"
"\texit 1\n"
"fi\n"
"exec git cvsserver server\n"
"EOF\n"
"$ chmod +x $HOME/git-shell-commands/cvs\n"

#. type: Plain text
#: en/git-shell.txt:103
#, placeholders:'linkgit:git-daemon[1]':'git-shell-commands', priority:100
msgid "ssh(1), linkgit:git-daemon[1], contrib/git-shell-commands/README"
msgstr "ssh(1), linkgit:git-daemon[1], contrib/git-shell-commands/README"

#. type: Title =
#: en/git-sh-i18n--envsubst.txt:2
#, no-wrap, placeholders:'git-sh-i':'{litdd}', priority:90
msgid "git-sh-i18n{litdd}envsubst(1)"
msgstr "git-sh-i18n{litdd}envsubst(1)"

#. type: Plain text
#: en/git-sh-i18n--envsubst.txt:7
#, placeholders:'git-sh-i':'--envsubst', priority:90
msgid "git-sh-i18n--envsubst - Git's own envsubst(1) for i18n fallbacks"
msgstr "git-sh-i18n--envsubst - Git 自带的 envsubst(1) i18n 回退功能"

#. type: Plain text
#: en/git-sh-i18n--envsubst.txt:17
#, no-wrap, placeholders:'eval_gettext':'git sh-i':'{litdd}':'--variables':'git sh-i':'{litdd}', priority:90
msgid ""
"eval_gettext () {\n"
"\tprintf \"%s\" \"$1\" | (\n"
"\t\texport PATH $('git sh-i18n{litdd}envsubst' --variables \"$1\");\n"
"\t\t'git sh-i18n{litdd}envsubst' \"$1\"\n"
"\t)\n"
"}\n"
msgstr ""
"eval_gettext () {\n"
"\tprintf \"%s\" \"$1\" | (\n"
"\t\texport PATH $('git sh-i18n{litdd}envsubst' --variables \"$1\");\n"
"\t\t'git sh-i18n{litdd}envsubst' \"$1\"\n"
"\t)\n"
"}\n"

#. type: Plain text
#: en/git-sh-i18n--envsubst.txt:24
#, priority:90
msgid "This is not a command the end user would want to run. Ever. This documentation is meant for people who are studying the plumbing scripts and/or are writing new ones."
msgstr "这不是最终用户想要运行的命令。 永远不会 本文档是为研究管道脚本和/或编写新脚本的人员准备的。"

#. type: Plain text
#: en/git-sh-i18n--envsubst.txt:29
#, placeholders:'git sh-i':'{litdd}':'linkgit:git-sh-i18n[1]':'eval_gettext', priority:90
msgid "'git sh-i18n{litdd}envsubst' is Git's stripped-down copy of the GNU `envsubst(1)` program that comes with the GNU gettext package. It's used internally by linkgit:git-sh-i18n[1] to interpolate the variables passed to the `eval_gettext` function."
msgstr "'git sh-i18n{litdd}envsubst' 是 Git 对 GNU gettext 软件包中的 GNU `envsubst(1)` 程序的精简拷贝。linkgit:git-sh-i18n[1] 内部使用它来插值传递给 `eval_gettext` 函数的变量。"

#. type: Plain text
#: en/git-sh-i18n--envsubst.txt:33
#, priority:90
msgid "No promises are made about the interface, or that this program won't disappear without warning in the next version of Git. Don't use it."
msgstr "不保证界面，也不保证该程序不会在下一版 Git 中毫无征兆地消失。不要使用它。"

#. type: Title =
#: en/git-sh-i18n.txt:2
#, ignore-same, no-wrap, priority:90
msgid "git-sh-i18n(1)"
msgstr "git-sh-i18n(1)"

#. type: Plain text
#: en/git-sh-i18n.txt:7
#, placeholders:'git-sh-i', priority:90
msgid "git-sh-i18n - Git's i18n setup code for shell scripts"
msgstr "git-sh-i18n - 用于 shell 脚本的 Git i18n 设置代码"

#. type: Plain text
#: en/git-sh-i18n.txt:12
#, no-wrap, placeholders:'--exec-path':'git-sh-i', priority:90
msgid "'. \"$(git --exec-path)/git-sh-i18n\"'\n"
msgstr "'. \"$(git --exec-path)/git-sh-i18n\"'\n"

#. type: Plain text
#: en/git-sh-i18n.txt:26
#, placeholders:'git sh-i':'eval_gettext':'gettext.sh', priority:90
msgid "The 'git sh-i18n scriptlet is designed to be sourced (using `.`) by Git's porcelain programs implemented in shell script. It provides wrappers for the GNU `gettext` and `eval_gettext` functions accessible through the `gettext.sh` script, and provides pass-through fallbacks on systems without GNU gettext."
msgstr "’git sh-i18n‘ 脚本小程序是专为 Git 的 shell 脚本实现的瓷器程序而设计的（使用 `.`）。它为通过 `gettext.sh` 脚本访问的 GNU `gettext` 和 `eval_gettext` 函数提供了封装，并为没有 GNU gettext 的系统提供了直通回退。"

#. type: Labeled list
#: en/git-sh-i18n.txt:30
#, no-wrap, priority:90
msgid "gettext"
msgstr "gettext"

#. type: Plain text
#: en/git-sh-i18n.txt:34
#, priority:90
msgid "Currently a dummy fall-through function implemented as a wrapper around `printf(1)`. Will be replaced by a real gettext implementation in a later version."
msgstr "目前是作为 `printf(1)` 的包装器实现的虚假直通函数。在以后的版本中，它将被真正的 gettext 实现所取代。"

#. type: Labeled list
#: en/git-sh-i18n.txt:35
#, no-wrap, placeholders:'eval_gettext', priority:90
msgid "eval_gettext"
msgstr "eval_gettext"

#. type: Plain text
#: en/git-sh-i18n.txt:40
#, placeholders:'linkgit:git-sh-i18n{litdd}envsubst[1]', priority:90
msgid "Currently a dummy fall-through function implemented as a wrapper around `printf(1)` with variables expanded by the linkgit:git-sh-i18n{litdd}envsubst[1] helper. Will be replaced by a real gettext implementation in a later version."
msgstr "目前是一个虚假的直通函数，作为` printf(1)` 的包装器实现，变量由 linkgit:git-sh-i18n{litdd}envsubst[1] 辅助器展开。在以后的版本中将被真正的 gettext 实现所取代。"

#. type: Title =
#: en/git-shortlog.txt:2
#, ignore-same, no-wrap, priority:260
msgid "git-shortlog(1)"
msgstr "git-shortlog(1)"

#. type: Plain text
#: en/git-shortlog.txt:7
#, placeholders:'git-shortlog', priority:260
msgid "git-shortlog - Summarize 'git log' output"
msgstr "git-shortlog - 汇总 'git log' 输出"

#. type: Plain text
#: en/git-shortlog.txt:13
#, ignore-ellipsis, no-wrap, placeholders:'--pretty=short', priority:260
msgid ""
"'git shortlog' [<options>] [<revision-range>] [[--] <path>...]\n"
"git log --pretty=short | 'git shortlog' [<options>]\n"
msgstr ""
"'git shortlog' [<选项>] [<修订范围>] [[--] <路径>...] 。\n"
"git log --pretty=short | 'git shortlog' [<多个选项>] 。\n"

#. type: Plain text
#: en/git-shortlog.txt:18
#, priority:260
msgid "Summarizes 'git log' output in a format suitable for inclusion in release announcements. Each commit will be grouped by author and title."
msgstr "将'git log'输出总结为适合纳入发布公告的格式。每个提交将按作者和标题分组。"

#. type: Plain text
#: en/git-shortlog.txt:20
#, priority:260
msgid "Additionally, \"[PATCH]\" will be stripped from the commit description."
msgstr "此外，\"[PATCH]\"将从提交描述中被剥离。"

#. type: Plain text
#: en/git-shortlog.txt:25
#, priority:260
msgid "If no revisions are passed on the command line and either standard input is not a terminal or there is no current branch, 'git shortlog' will output a summary of the log read from standard input, without reference to the current repository."
msgstr "如果命令行上没有传递修订版，而且标准输入不是终端，或者没有当前分支，'git shortlog'将输出从标准输入读取的日志摘要，而不参考当前版本库。"

#. type: Plain text
#: en/git-shortlog.txt:33
#, priority:260
msgid "Sort output according to the number of commits per author instead of author alphabetic order."
msgstr "根据每个作者的提交数量对输出进行排序，而不是按照作者的字母顺序。"

#. type: Plain text
#: en/git-shortlog.txt:37
#, priority:260
msgid "Suppress commit description and provide a commit count summary only."
msgstr "抑制提交描述，只提供提交计数摘要。"

#. type: Labeled list
#: en/git-shortlog.txt:39
#, ignore-same, no-wrap, priority:260
msgid "--email"
msgstr "--email"

#. type: Plain text
#: en/git-shortlog.txt:41
#, priority:260
msgid "Show the email address of each author."
msgstr "显示每个作者的电子邮件地址。"

#. type: Labeled list
#: en/git-shortlog.txt:42
#, no-wrap, placeholders:'--format', priority:260
msgid "--format[=<format>]"
msgstr "--format[=<格式>]"

#. type: Plain text
#: en/git-shortlog.txt:47
#, placeholders:'`--format`':'linkgit:git-log[1]', priority:260
msgid "Instead of the commit subject, use some other information to describe each commit. '<format>' can be any string accepted by the `--format` option of 'git log', such as '* [%h] %s'. (See the \"PRETTY FORMATS\" section of linkgit:git-log[1].)"
msgstr "代替提交主题，使用一些其他信息来描述每个提交。 '<格式>' 可以是任何被 'git log' 的 `--format` 选项接受的字符串，比如 '* [%h] %s'。 参见 linkgit:git-log[1] 的 “漂亮的格式” 部分。）"

#. type: Plain text
#: en/git-shortlog.txt:49
#, priority:260
msgid "Each pretty-printed commit will be rewrapped before it is shown."
msgstr "每个漂亮的印刷品承诺在展示之前都会被重新包装。"

#. type: Labeled list
#: en/git-shortlog.txt:50 en/rev-list-options.txt:1059
#, no-wrap, placeholders:'--date=', priority:260
msgid "--date=<format>"
msgstr "--date=<格式>"

#. type: Plain text
#: en/git-shortlog.txt:54
#, placeholders:'`--date`':'linkgit:git-log[1]':'`--group=format', priority:260
msgid "Show dates formatted according to the given date string. (See the `--date` option in the \"Commit Formatting\" section of linkgit:git-log[1]). Useful with `--group=format:<format>`."
msgstr "显示根据给定日期字符串格式化的日期。(参见linkgit:git-log[1]中 \"提交格式化\"部分的`--date`选项）。与 `--group=format:<format>`一起使用会非常有用。"

#. type: Labeled list
#: en/git-shortlog.txt:55
#, no-wrap, placeholders:'--group=', priority:260
msgid "--group=<type>"
msgstr "--group=<类型>"

# ERROR: --group not found in translation
#. type: Plain text
#: en/git-shortlog.txt:58
#, placeholders:'`--group`', priority:260
msgid "Group commits based on `<type>`. If no `--group` option is specified, the default is `author`. `<type>` is one of:"
msgstr "根据 `<类型>`对提交进行分组。如果没有指定 `--group` 选项，默认为 `作者` 。`<类型>` 是以下之一："

#. type: Plain text
#: en/git-shortlog.txt:61
#, priority:260
msgid "`author`, commits are grouped by author"
msgstr "\"作者\"，提交内容按作者分组"

#. type: Plain text
#: en/git-shortlog.txt:62
#, placeholders:'`-c`', priority:260
msgid "`committer`, commits are grouped by committer (the same as `-c`)"
msgstr "`提交者` ，提交内容按提交人分组（与 `-c` 相同）"

#. type: Plain text
#: en/git-shortlog.txt:67
#, placeholders:'linkgit:git-interpret-trailers[1]':'--group=trailer', priority:260
msgid "`trailer:<field>`, the `<field>` is interpreted as a case-insensitive commit message trailer (see linkgit:git-interpret-trailers[1]). For example, if your project uses `Reviewed-by` trailers, you might want to see who has been reviewing with `git shortlog -ns --group=trailer:reviewed-by`."
msgstr "`trailer:<field>`，`<field>`被解释为不区分大小写的提交消息预告片（见 linkgit:git-interpret-trailers[1]）。例如，如果你的项目使用 `Reviewed-by` 拖车，你可能想用 `git shortlog -ns --group=trailer:reviewed-by` 来查看谁在审核。"

# ERROR: `--format` not found in translation
#. type: Plain text
#: en/git-shortlog.txt:70
#, placeholders:'`--format`':'linkgit:git-log[1]', priority:260
msgid "`format:<format>`, any string accepted by the `--format` option of 'git log'. (See the \"PRETTY FORMATS\" section of linkgit:git-log[1].)"
msgstr "`格式：<format>` 可以是任何被 'git log' 的 `--format` 选项接受的字符串。（参见 linkgit:git-log[1] 的 \"PRETTY FORMATS\" 部分）。"

#. type: Plain text
#: en/git-shortlog.txt:75
#, priority:260
msgid "Note that commits that do not include the trailer will not be counted. Likewise, commits with multiple trailers (e.g., multiple signoffs) may be counted more than once (but only once per unique trailer value in that commit)."
msgstr "请注意，不包括拖车的提交将不被计算在内。 同样地，有多个拖车的提交（例如多个签收）可以被计算一次（但该提交中每个独特的拖车值只能计算一次）。"

#. type: Plain text
#: en/git-shortlog.txt:80
#, placeholders:'`--email`', priority:260
msgid "Shortlog will attempt to parse each trailer value as a `name <email>` identity. If successful, the mailmap is applied and the email is omitted unless the `--email` option is specified. If the value cannot be parsed as an identity, it will be taken literally and completely."
msgstr "Shortlog将尝试把每个拖车值解析为`name <email>`的身份。如果成功，将应用mailmap，除非指定`--email`选项，否则将省略email。如果该值不能被解析为一个身份，那么它将被完全视为字面意思。"

# ERROR: `--group` not found in translation
#. type: Plain text
#: en/git-shortlog.txt:86
#, placeholders:'`--group`':'--group=author':'--group=trailer', priority:260
msgid "If `--group` is specified multiple times, commits are counted under each value (but again, only once per unique value in that commit). For example, `git shortlog --group=author --group=trailer:co-authored-by` counts both authors and co-authors."
msgstr "如果 `--group` 被多次指定，每个值下的提交都会被计算（但同样，每个提交中的唯一值只能计算一次）。例如，`git shortlog --group=author --group=trailer:co-authored-by` 同时计算作者和共同作者。"

#. type: Labeled list
#: en/git-shortlog.txt:88
#, ignore-same, no-wrap, priority:260
msgid "--committer"
msgstr "--committer"

#. type: Plain text
#: en/git-shortlog.txt:90
#, placeholders:'`--group=committer`', priority:260
msgid "This is an alias for `--group=committer`."
msgstr "这是`--group=committer`的一个别名。"

#. type: Labeled list
#: en/git-shortlog.txt:91
#, no-wrap, priority:260
msgid "-w[<width>[,<indent1>[,<indent2>]]]"
msgstr "-w[<width>[,<indent1>[,<indent2>]]]"

#. type: Plain text
#: en/git-shortlog.txt:96
#, priority:260
msgid "Linewrap the output by wrapping each line at `width`. The first line of each entry is indented by `indent1` spaces, and the second and subsequent lines are indented by `indent2` spaces. `width`, `indent1`, and `indent2` default to 76, 6 and 9 respectively."
msgstr "通过以`width`包裹每一行来对输出进行换行。 每个条目的第一行缩进`缩进1`个空格，第二行和后续行缩进`缩进2`个空格。`width`, `indent1`, 和`indent2`分别默认为76, 6和9。"

#. type: Plain text
#: en/git-shortlog.txt:99
#, priority:260
msgid "If width is `0` (zero) then indent the lines of the output without wrapping them."
msgstr "如果宽度为`0`（零），则缩进输出的行数而不包裹它们。"

#. type: Plain text
#: en/git-shortlog.txt:108
#, placeholders:'HEAD':'HEAD':'HEAD':'linkgit:gitrevisions[7]', priority:260
msgid "Show only commits in the specified revision range. When no <revision-range> is specified, it defaults to `HEAD` (i.e. the whole history leading to the current commit). `origin..HEAD` specifies all the commits reachable from the current commit (i.e. `HEAD`), but not from `origin`. For a complete list of ways to spell <revision-range>, see the \"Specifying Ranges\" section of linkgit:gitrevisions[7]."
msgstr "只显示指定修订范围内的提交。 当没有指定 <修订范围> 时，默认为 `HEAD` （即导致当前提交的整个历史）。 `origin...HEAD` 指定了从当前提交（即`HEAD` ）可以到达的所有提交，但不是从 `origin `。关于 <修订范围> 的完整拼写方式，见 linkgit:gitrevisions[7] 的 “指定范围” 部分。"

#. type: Plain text
#: en/git-shortlog.txt:112
#, priority:260
msgid "Consider only commits that are enough to explain how the files that match the specified paths came to be."
msgstr "只考虑那些足以解释符合指定路径的文件是如何产生的提交。"

#. type: Plain text
#: en/git-shortlog.txt:127
#, priority:260
msgid "Note that if `git shortlog` is run outside of a repository (to process log contents on standard input), it will look for a `.mailmap` file in the current directory."
msgstr "注意，如果`git shortlog`在版本库外运行（处理标准输入的日志内容），它将在当前目录下寻找一个`.mailmap`文件。"

#. type: Title =
#: en/git-show-branch.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-show-branch(1)"
msgstr "git-show-branch(1)"

#. type: Plain text
#: en/git-show-branch.txt:7
#, placeholders:'git-show-branch', priority:100
msgid "git-show-branch - Show branches and their commits"
msgstr "git-show-branch - 显示分支及其提交情况"

#. type: Plain text
#: en/git-show-branch.txt:17
#, ignore-ellipsis, no-wrap, placeholders:'git show-branch':'--all]':'--remotes]':'[--topo-order':'--date-order]':'[--current]':'[--color':'--no-color]':'[--sparse]':'[--more=':'--list':'--independent':'--merge-base]':'[--no-name':'--sha1-name]':'[--topics]':'git show-branch':'--reflog':'[--list]', priority:100
msgid ""
"'git show-branch' [-a | --all] [-r | --remotes] [--topo-order | --date-order]\n"
"\t\t[--current] [--color[=<when>] | --no-color] [--sparse]\n"
"\t\t[--more=<n> | --list | --independent | --merge-base]\n"
"\t\t[--no-name | --sha1-name] [--topics]\n"
"\t\t[(<rev> | <glob>)...]\n"
"'git show-branch' (-g | --reflog)[=<n>[,<base>]] [--list] [<ref>]\n"
msgstr ""
"'git show-branch' [-a|--all] [-r|--remotes] [--topo-order | --date-order]\n"
"\t\t[--current] [--color[=<合适>] | --no-color] [--sparse]\n"
"\t\t[--more=<n> | --list | --independent | --merge-base]\n"
"\t\t[--no-name | --sha1-name] [--topics]\n"
"\t\t[(<修订> | <通配符>)...]\n"
"'git show-branch' (-g|--reflog)[=<n>[,<基础>]] [--list] [<引用>]\n"

#. type: Plain text
#: en/git-show-branch.txt:24
#, priority:100
msgid "Shows the commit ancestry graph starting from the commits named with <rev>s or <glob>s (or all refs under refs/heads and/or refs/tags) semi-visually."
msgstr "以半直观的方式显示从以 <rev>s 或 <通配符>s 命名的提交（或 refs/heads 和/或 refs/tags 下的所有引用）开始的提交祖先图。"

#. type: Plain text
#: en/git-show-branch.txt:26
#, priority:100
msgid "It cannot show more than 29 branches and commits at a time."
msgstr "它不能同时显示超过 29 个分支和提交。"

#. type: Plain text
#: en/git-show-branch.txt:29
#, placeholders:'showbranch.default', priority:100
msgid "It uses `showbranch.default` multi-valued configuration items if no <rev> or <glob> is given on the command line."
msgstr "如果命令行中没有给出 <rev> 或 <通配符>，它会使用 `showbranch.default` 多值配置项。"

#. type: Labeled list
#: en/git-show-branch.txt:33
#, no-wrap, priority:100
msgid "<rev>"
msgstr "<rev>"

#. type: Plain text
#: en/git-show-branch.txt:36
#, placeholders:'linkgit:gitrevisions[7]', priority:100
msgid "Arbitrary extended SHA-1 expression (see linkgit:gitrevisions[7]) that typically names a branch head or a tag."
msgstr "任意扩展的 SHA-1 表达式（参见 linkgit:gitrevisions[7]），通常用于命名分支头或标签。"

#. type: Labeled list
#: en/git-show-branch.txt:37
#, no-wrap, priority:100
msgid "<glob>"
msgstr "<通配符>"

#. type: Plain text
#: en/git-show-branch.txt:42
#, priority:100
msgid "A glob pattern that matches branch or tag names under refs/. For example, if you have many topic branches under refs/heads/topic, giving `topic/*` would show all of them."
msgstr "匹配 refs/ 下分支或标记名称的通配模式。 例如，如果在 refs/heads/topic 下有许多主题分支，那么输入 `topic/*` 就会显示所有分支。"

#. type: Plain text
#: en/git-show-branch.txt:46
#, priority:100
msgid "Show the remote-tracking branches."
msgstr "显示远程跟踪分支。"

#. type: Plain text
#: en/git-show-branch.txt:50
#, priority:100
msgid "Show both remote-tracking branches and local branches."
msgstr "同时显示远程跟踪分支和本地分支。"

#. type: Labeled list
#: en/git-show-branch.txt:51
#, ignore-same, no-wrap, priority:100
msgid "--current"
msgstr "--current"

#. type: Plain text
#: en/git-show-branch.txt:55
#, priority:100
msgid "With this option, the command includes the current branch in the list of revs to be shown when it is not given on the command line."
msgstr "使用该选项后，当命令行中没有给出当前分支的版本号时，命令会将该分支包含在要显示的版本号列表中。"

#. type: Labeled list
#: en/git-show-branch.txt:56 en/rev-list-options.txt:859
#, ignore-same, no-wrap, priority:260
msgid "--topo-order"
msgstr "--topo-order"

#. type: Plain text
#: en/git-show-branch.txt:61
#, priority:100
msgid "By default, the branches and their commits are shown in reverse chronological order. This option makes them appear in topological order (i.e., descendant commits are shown before their parents)."
msgstr "默认情况下，分支及其提交按时间倒序显示。 此选项可使它们按拓扑顺序显示（即子分支提交显示在父分支之前）。"

#. type: Labeled list
#: en/git-show-branch.txt:62 en/rev-list-options.txt:851
#, ignore-same, no-wrap, priority:260
msgid "--date-order"
msgstr "--date-order"

#. type: Plain text
#: en/git-show-branch.txt:66
#, placeholders:'`--topo-order`', priority:100
msgid "This option is similar to `--topo-order` in the sense that no parent comes before all of its children, but otherwise commits are ordered according to their commit date."
msgstr "该选项类似于 `--topo-order`，即父提交不会排在所有子提交之前，但也会根据提交日期对提交进行排序。"

#. type: Plain text
#: en/git-show-branch.txt:71
#, priority:100
msgid "By default, the output omits merges that are reachable from only one tip being shown. This option makes them visible."
msgstr "默认情况下，输出会忽略只显示一个提示的合并。 该选项将使它们可见。"

#. type: Labeled list
#: en/git-show-branch.txt:72
#, no-wrap, placeholders:'--more=', priority:100
msgid "--more=<n>"
msgstr "--more=<n>"

#. type: Plain text
#: en/git-show-branch.txt:78
#, priority:100
msgid "Usually the command stops output upon showing the commit that is the common ancestor of all the branches. This flag tells the command to go <n> more common commits beyond that. When <n> is negative, display only the <ref>s given, without showing the commit ancestry tree."
msgstr "通常，命令会在显示所有分支的共同祖先提交后停止输出。 此标记会告诉命令在此基础上再显示 <n> 次共同提交。 当 <n> 为负数时，只显示给出的 <引用>，而不显示提交祖先树。"

#. type: Plain text
#: en/git-show-branch.txt:81
#, placeholders:'`--more=-1`', priority:100
msgid "Synonym to `--more=-1`"
msgstr "同 `--more=-1`"

#. type: Plain text
#: en/git-show-branch.txt:88
#, placeholders:'linkgit:git-merge-base[1]', priority:100
msgid "Instead of showing the commit list, determine possible merge bases for the specified commits. All merge bases will be contained in all specified commits. This is different from how linkgit:git-merge-base[1] handles the case of three or more commits."
msgstr "不显示提交列表，而是确定指定提交的可能合并库。所有合并库都将包含在所有指定的提交中。这与 linkgit:git-merge-base[1] 处理三个或更多提交的方式不同。"

#. type: Plain text
#: en/git-show-branch.txt:92
#, priority:100
msgid "Among the <ref>s given, display only the ones that cannot be reached from any other <ref>."
msgstr "在给出的多个 <引用> 中，只显示无法从其他 <引用> 到达的 <引用> 。"

#. type: Labeled list
#: en/git-show-branch.txt:93
#, ignore-same, no-wrap, priority:100
msgid "--no-name"
msgstr "--no-name"

#. type: Plain text
#: en/git-show-branch.txt:95
#, priority:100
msgid "Do not show naming strings for each commit."
msgstr "不显示每次提交的命名字符串。"

#. type: Labeled list
#: en/git-show-branch.txt:96
#, ignore-same, no-wrap, priority:100
msgid "--sha1-name"
msgstr "--sha1-name"

#. type: Plain text
#: en/git-show-branch.txt:101
#, priority:100
msgid "Instead of naming the commits using the path to reach them from heads (e.g. \"master~2\" to mean the grandparent of \"master\"), name them with the unique prefix of their object names."
msgstr "在命名提交时，不要使用从头到尾的路径（例如，\"master~2\" 表示 \"master\" 的祖先），而是使用对象名称的唯一前缀。"

#. type: Labeled list
#: en/git-show-branch.txt:102
#, ignore-same, no-wrap, priority:100
msgid "--topics"
msgstr "--topics"

#. type: Plain text
#: en/git-show-branch.txt:109
#, placeholders:'git show-branch':'--topics':'git rev-list':'{caret}', priority:100
msgid "Shows only commits that are NOT on the first branch given. This helps track topic branches by hiding any commit that is already in the main line of development. When given \"git show-branch --topics master topic1 topic2\", this will show the revisions given by \"git rev-list {caret}master topic1 topic2\""
msgstr "只显示不在第一个分支上的提交。 这有助于跟踪主题分支，隐藏任何已在主线开发中的提交。 当给出 \"git show-branch --topics master topic1 topic2\" 时，将显示 \"git rev-list {caret}master topic1 topic2\" 给出的修订版本"

#. type: Labeled list
#: en/git-show-branch.txt:111
#, no-wrap, placeholders:'--reflog', priority:100
msgid "--reflog[=<n>[,<base>]] [<ref>]"
msgstr "--reflog[=<n>[,<基础>]] [<引用>]"

#. type: Plain text
#: en/git-show-branch.txt:117
#, placeholders:'HEAD', priority:100
msgid "Shows <n> most recent ref-log entries for the given ref. If <base> is given, <n> entries going back from that entry. <base> can be specified as count or date. When no explicit <ref> parameter is given, it defaults to the current branch (or `HEAD` if it is detached)."
msgstr "显示给定引用的 <n> 条最新引用日志记录。 如果给定 <基点>，则显示从该条目开始的 <n> 条目。 <基点> 可以指定为计数或日期。 如果没有给出明确的 <引用> 参数，则默认为当前分支（如果是分离分支，则为 `HEAD`）。"

#. type: Plain text
#: en/git-show-branch.txt:122
#, priority:100
msgid "Color the status sign (one of these: `*` `!` `+` `-`) of each commit corresponding to the branch it's in. The value must be always (the default), never, or auto."
msgstr "为每个提交的状态符号（其中之一：`*``！```+```-`）着色，与它所在的分支相对应。 值必须是 always（总是）（默认值）、never（从不）或 auto（自动）。"

#. type: Plain text
#: en/git-show-branch.txt:127
#, placeholders:'`--color=never`', priority:100
msgid "Turn off colored output, even when the configuration file gives the default to color output. Same as `--color=never`."
msgstr "关闭彩色输出，即使配置文件默认为彩色输出。 与 `--color=never` 相同。"

#. type: Plain text
#: en/git-show-branch.txt:130
#, placeholders:'--more':'--list':'--independent':'--merge-base', priority:100
msgid "Note that --more, --list, --independent, and --merge-base options are mutually exclusive."
msgstr "请注意，--more、--list、--independent 和 --merge-base 选项是互斥的。"

#. type: Plain text
#: en/git-show-branch.txt:139
#, placeholders:'$GIT_DIR':'HEAD', priority:100
msgid "Given N <ref>s, the first N lines are the one-line description from their commit message. The branch head that is pointed at by $GIT_DIR/HEAD is prefixed with an asterisk `*` character while other heads are prefixed with a `!` character."
msgstr "给定 N 个 <引用>，前 N 行是其提交信息中的单行描述。$GIT_DIR/HEAD 所指向的分支头前缀为星号 `*` 字符，而其他分支头前缀为 `!` 字符。"

#. type: Plain text
#: en/git-show-branch.txt:146
#, priority:100
msgid "Following these N lines, a one-line log for each commit is displayed, indented N places. If a commit is on the I-th branch, the I-th indentation character shows a `+` sign; otherwise it shows a space. Merge commits are denoted by a `-` sign. Each commit shows a short name that can be used as an extended SHA-1 to name that commit."
msgstr "在这 N 行之后，会显示每个提交的单行日志，缩进 N 位。 如果提交在第 I 个分支上，则第 I 个缩进字符显示为 `+` 号，否则显示为空格。 合并提交用 `-` 符号表示。 每个提交都会显示一个简短的名称，可以作为扩展 SHA-1 来命名该提交。"

#. type: Plain text
#: en/git-show-branch.txt:149
#, priority:100
msgid "The following example shows three branches, \"master\", \"fixes\", and \"mhf\":"
msgstr "下面的示例显示了三个分支：\"master\"、\"fixes\" 和 \"mhf\"："

#. type: delimited block -
#: en/git-show-branch.txt:155
#, no-wrap, placeholders:'git show-branch':'git show-branch':'--force':'---', priority:100
msgid ""
"$ git show-branch master fixes mhf\n"
"* [master] Add 'git show-branch'.\n"
" ! [fixes] Introduce \"reset type\" flag to \"git reset\"\n"
"  ! [mhf] Allow \"+remote:local\" refspec to cause --force when fetching.\n"
"---\n"
msgstr ""
"$ git show-branch master fixes mhf\n"
"* [master] Add 'git show-branch'.\n"
" ! [fixes] 在 \"git reset \"中引入 \"reset type\" 标志\n"
"  ! [mhf] 允许 \"+remote:local\" 引用规范在获取数据时导致 --force。\n"
"---\n"

#. type: delimited block -
#: en/git-show-branch.txt:167
#, no-wrap, placeholders:'--force':'git-octopus':'--force':'git-parse-remote':'$GIT_DIR':'git show-branch', priority:100
msgid ""
"  + [mhf] Allow \"+remote:local\" refspec to cause --force when fetching.\n"
"  + [mhf~1] Use git-octopus when pulling more than one head.\n"
" +  [fixes] Introduce \"reset type\" flag to \"git reset\"\n"
"  + [mhf~2] \"git fetch --force\".\n"
"  + [mhf~3] Use .git/remote/origin, not .git/branches/origin.\n"
"  + [mhf~4] Make \"git pull\" and \"git fetch\" default to origin\n"
"  + [mhf~5] Infamous 'octopus merge'\n"
"  + [mhf~6] Retire git-parse-remote.\n"
"  + [mhf~7] Multi-head fetch.\n"
"  + [mhf~8] Start adding the $GIT_DIR/remotes/ support.\n"
"*++ [master] Add 'git show-branch'.\n"
msgstr ""
"  + [mhf] 允许 \"+remote:local\" 引用规范在获取时导致 --force。\n"
"  + [mhf~1] 拉取多个头时使用 git-octopus。\n"
" + [fixes] 在 \"git reset\" 中引入 \"reset type\" 标志\n"
"  + [mhf~2] \"git fetch --force\".\n"
"  + [mhf~3] 使用 .git/remote/origin，而不是 .git/branches/origin。\n"
"  + [mhf~4] 将 \"git pull\" 和 \"git fetch\" 默认为 origin\n"
"  + [mhf~5] 臭名昭著的 ‘章鱼（多路）合并’\n"
"  + [mhf~6] 重试 git-parse-remote。\n"
"  + [mhf~7] 获取多个头\n"
"  + [mhf~8] 开始添加 $GIT_DIR/remotes/ 支持。\n"
"*++ [master] 添加 'git show-branch'。\n"

#. type: Plain text
#: en/git-show-branch.txt:174
#, placeholders:'git show-branch', priority:100
msgid "These three branches all forked from a common commit, [master], whose commit message is \"Add \\'git show-branch'\". The \"fixes\" branch adds one commit \"Introduce \"reset type\" flag to \"git reset\"\". The \"mhf\" branch adds many other commits. The current branch is \"master\"."
msgstr "这三个分支都分叉自一个共同的提交 [master]，其提交信息是 “添加 \\'git show-branch'”。 \"fixes\" 分支增加了一个提交 \"在 \"git reset \"中引入 \"reset type\" 标志\"。\"mhf\" 分支增加了许多其他提交。 当前分支是 \"master\"。"

#. type: Plain text
#: en/git-show-branch.txt:182
#, priority:100
msgid "If you keep your primary branches immediately under `refs/heads`, and topic branches in subdirectories of it, having the following in the configuration file may help:"
msgstr "如果你将主分支放在 `refs/heads` 下，而主题分支放在其子目录中，那么在配置文件中加入以下内容可能会有所帮助："

#. type: delimited block -
#: en/git-show-branch.txt:187
#, no-wrap, placeholders:'--topo-order', priority:100
msgid ""
"[showbranch]\n"
"\tdefault = --topo-order\n"
"\tdefault = heads/*\n"
msgstr ""
"[showbranch]\n"
"\tdefault = --topo-order\n"
"\tdefault = heads/*\n"

#. type: Plain text
#: en/git-show-branch.txt:193
#, placeholders:'git show-branch', priority:100
msgid "With this, `git show-branch` without extra parameters would show only the primary branches. In addition, if you happen to be on your topic branch, it is shown as well."
msgstr "这样，不带额外参数的 `git show-branch` 就只能显示主分支。 此外，如果您恰好在您的主题分支上，它也会显示出来。"

#. type: delimited block -
#: en/git-show-branch.txt:196
#, no-wrap, placeholders:'git show-branch':'--reflog=':'--list', priority:100
msgid "$ git show-branch --reflog=\"10,1 hour ago\" --list master\n"
msgstr "$ git show-branch --reflog=\"10,1 hour ago\" --list master\n"

#. type: Plain text
#: en/git-show-branch.txt:201
#, placeholders:'`--list`', priority:100
msgid "shows 10 reflog entries going back from the tip as of 1 hour ago. Without `--list`, the output also shows how these tips are topologically related to each other."
msgstr "显示了 10 条从 1 小时前的提示开始的引用日志条目。 如果不使用 `--list`，输出结果还会显示这些提示之间的拓扑关系。"

#. type: Title =
#: en/git-show-index.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-show-index(1)"
msgstr "git-show-index(1)"

#. type: Plain text
#: en/git-show-index.txt:7
#, placeholders:'git-show-index', priority:100
msgid "git-show-index - Show packed archive index"
msgstr "git-show-index - 显示打包的档案索引"

#. type: Plain text
#: en/git-show-index.txt:13
#, no-wrap, placeholders:'git show-index':'[--object-format=', priority:100
msgid "'git show-index' [--object-format=<hash-algorithm>]\n"
msgstr "'git show-index' [--object-format=<哈希算法>]\n"

#. type: Plain text
#: en/git-show-index.txt:22
#, placeholders:'linkgit:git-pack-objects[1]':'linkgit:git-index-pack[1]', priority:100
msgid "Read the `.idx` file for a Git packfile (created with linkgit:git-pack-objects[1] or linkgit:git-index-pack[1]) from the standard input, and dump its contents. The output consists of one object per line, with each line containing two or three space-separated columns:"
msgstr "从标准输入读取 Git packfile 的 `.idx` 文件（使用 linkgit:git-pack-objects[1] 或 linkgit:git-index-pack[1] 创建），并转储其内容。输出包括每行一个对象，每行包含两到三个空格分隔的列："

#. type: Plain text
#: en/git-show-index.txt:25
#, priority:100
msgid "the first column is the offset in bytes of the object within the corresponding packfile"
msgstr "第一列是对象在相应打包文件中的偏移量（以字节为单位）"

#. type: Plain text
#: en/git-show-index.txt:27
#, priority:100
msgid "the second column is the object id of the object"
msgstr "第二列是对象的对象 ID"

#. type: Plain text
#: en/git-show-index.txt:30
#, priority:100
msgid "if the index version is 2 or higher, the third column contains the CRC32 of the object data"
msgstr "如果索引版本为 2 或更高，第三列包含对象数据的 CRC32"

#. type: Plain text
#: en/git-show-index.txt:34
#, priority:100
msgid "The objects are output in the order in which they are found in the index file, which should be (in a correctly constructed file) sorted by object id."
msgstr "对象将按照在索引文件中找到的顺序输出，索引文件应（在正确构建的文件中）按照对象 ID 排序。"

#. type: Plain text
#: en/git-show-index.txt:38
#, placeholders:'linkgit:git-verify-pack[1]', priority:100
msgid "Note that you can get more information on a packfile by calling linkgit:git-verify-pack[1]. However, as this command considers only the index file itself, it's both faster and more flexible."
msgstr "请注意，您可以通过调用 linkgit:git-verify-pack[1] 获取更多关于打包文件的信息。不过，由于该命令只考虑索引文件本身，因此速度更快，也更灵活。"

#. type: Plain text
#: en/git-show-index.txt:47
#, placeholders:'extensions.objectFormat', priority:100
msgid "Specify the given object format (hash algorithm) for the index file. The valid values are 'sha1' and (if enabled) 'sha256'. The default is the algorithm for the current repository (set by `extensions.objectFormat`), or 'sha1' if no value is set or outside a repository.."
msgstr "指定索引文件的给定对象格式（哈希算法）。 有效值为 'sha1' 和（如果启用）'sha256'。 默认值是当前仓库的算法（由 `extensions.objectFormat` 设置），如果未设置值或在仓库之外，则为 'sha1'。"

#. type: Title =
#: en/git-show-ref.txt:2
#, ignore-same, no-wrap, priority:80
msgid "git-show-ref(1)"
msgstr "git-show-ref(1)"

#. type: Plain text
#: en/git-show-ref.txt:7
#, placeholders:'git-show-ref', priority:80
msgid "git-show-ref - List references in a local repository"
msgstr "git-show-ref - 列出本地仓库中的引用"

#. type: Plain text
#: en/git-show-ref.txt:19
#, ignore-ellipsis, no-wrap, placeholders:'git show-ref':'[--head]':'--dereference]':'--hash':'[--abbrev':'[--tags]':'[--heads]':'git show-ref':'--verify':'--quiet]':'--dereference]':'--hash':'[--abbrev':'git show-ref':'--exclude-existing':'git show-ref':'--exists', priority:80
msgid ""
"'git show-ref' [--head] [-d | --dereference]\n"
"\t     [-s | --hash[=<n>]] [--abbrev[=<n>]] [--tags]\n"
"\t     [--heads] [--] [<pattern>...]\n"
"'git show-ref' --verify [-q | --quiet] [-d | --dereference]\n"
"\t     [-s | --hash[=<n>]] [--abbrev[=<n>]]\n"
"\t     [--] [<ref>...]\n"
"'git show-ref' --exclude-existing[=<pattern>]\n"
"'git show-ref' --exists <ref>\n"
msgstr ""
"'git show-ref' [--head] [-d | --dereference]\n"
"\t     [-s | --hash[=<n>]] [--abbrev[=<n>]] [--tags]\n"
"\t     [--heads] [--] [<模式>...]\n"
"'git show-ref' --verify [-q | --quiet] [-d | --dereference]\n"
"\t     [-s | --hash[=<n>]] [--abbrev[=<n>]]\n"
"\t     [--] [<ref>...]\n"
"'git show-ref' --exclude-existing[=<模式>]\n"
"'git show-ref' --exists <引用>\n"

#. type: Plain text
#: en/git-show-ref.txt:27
#, priority:80
msgid "Displays references available in a local repository along with the associated commit IDs. Results can be filtered using a pattern and tags can be dereferenced into object IDs. Additionally, it can be used to test whether a particular ref exists."
msgstr "显示本地仓库中可用的引用以及相关的提交 ID。可使用模式对结果进行过滤，并将标记反引用到对象 ID 中。此外，它还可用于测试特定引用是否存在。"

#. type: Plain text
#: en/git-show-ref.txt:29
#, priority:80
msgid "By default, shows the tags, heads, and remote refs."
msgstr "默认情况下，显示标签、标题和远程引用。"

#. type: Plain text
#: en/git-show-ref.txt:33
#, placeholders:'`--exclude-existing`', priority:80
msgid "The `--exclude-existing` form is a filter that does the inverse. It reads refs from stdin, one ref per line, and shows those that don't exist in the local repository."
msgstr "`--exclude-existing` 表单是一个反向过滤器。它从标准输入流中读取引用，每行一个引用，并显示那些不存在于本地仓库中的引用。"

#. type: Plain text
#: en/git-show-ref.txt:37
#, placeholders:'`--exists`', priority:80
msgid "The `--exists` form can be used to check for the existence of a single references. This form does not verify whether the reference resolves to an actual object."
msgstr "`--exists` 表单可用于检查单个引用是否存在。此表单不会验证引用是否解析到实际对象。"

#. type: Plain text
#: en/git-show-ref.txt:40
#, priority:80
msgid "Use of this utility is encouraged in favor of directly accessing files under the `.git` directory."
msgstr "我们鼓励使用该工具，而不是直接访问 `.git` 目录下的文件。"

#. type: Labeled list
#: en/git-show-ref.txt:44
#, ignore-same, no-wrap, priority:80
msgid "--head"
msgstr "--head"

#. type: Plain text
#: en/git-show-ref.txt:47
#, placeholders:'HEAD', priority:80
msgid "Show the HEAD reference, even if it would normally be filtered out."
msgstr "显示 HEAD 参考，即使它通常会被过滤掉。"

#. type: Plain text
#: en/git-show-ref.txt:54
#, priority:80
msgid "Limit to \"refs/heads\" and \"refs/tags\", respectively. These options are not mutually exclusive; when given both, references stored in \"refs/heads\" and \"refs/tags\" are displayed."
msgstr "分别限制为 \"refs/heads\" 和 \"refs/tags\"。 这些选项并不相互排斥；如果同时给定这两个选项，则会显示存储在 \"refs/heads\" 和 \"refs/tags\" 中的引用。"

#. type: Labeled list
#: en/git-show-ref.txt:56
#, ignore-same, no-wrap, priority:80
msgid "--dereference"
msgstr "--dereference"

#. type: Plain text
#: en/git-show-ref.txt:60
#, priority:80
msgid "Dereference tags into object IDs as well. They will be shown with `^{}` appended."
msgstr "也可将引用标记转换为对象 ID。它们将以 `^{}` 的形式显示。"

#. type: Labeled list
#: en/git-show-ref.txt:62
#, no-wrap, placeholders:'--hash', priority:80
msgid "--hash[=<n>]"
msgstr "--hash[=<n>]"

#. type: Plain text
#: en/git-show-ref.txt:66
#, placeholders:'`--dereference`', priority:80
msgid "Only show the OID, not the reference name. When combined with `--dereference`, the dereferenced tag will still be shown after the OID."
msgstr "只显示 OID（对象 ID），不显示引用名称。与 `--dereference` 结合使用时，在 OID 之后仍将显示取消引用的标记。"

#. type: Plain text
#: en/git-show-ref.txt:72
#, placeholders:'`--quiet`', priority:80
msgid "Enable stricter reference checking by requiring an exact ref path. Aside from returning an error code of 1, it will also print an error message if `--quiet` was not specified."
msgstr "通过要求精确的引用路径，启用更严格的引用检查。 除返回错误代码 1 外，如果未指定 `--quiet` ，还会打印错误信息。"

#. type: Labeled list
#: en/git-show-ref.txt:73
#, ignore-same, no-wrap, priority:80
msgid "--exists"
msgstr "--exists"

#. type: Plain text
#: en/git-show-ref.txt:78
#, priority:80
msgid "Check whether the given reference exists. Returns an exit code of 0 if it does, 2 if it is missing, and 1 in case looking up the reference failed with an error other than the reference being missing."
msgstr "检查给定的引用是否存在。如果存在，则返回 0 的退出代码；如果不存在，则返回 2 的退出代码；如果查找引用失败，则返回 1 的退出代码。"

#. type: Plain text
#: en/git-show-ref.txt:83
#, placeholders:'`--hash`':'`--hash':'--abbrev`':'`--hash=n`', priority:80
msgid "Abbreviate the object name. When using `--hash`, you do not have to say `--hash --abbrev`; `--hash=n` would do."
msgstr "缩写对象名称。 使用 `--hash` 时，不必说 `--hash --abbrev` ; `--hash=n` 也可以。"

#. type: Plain text
#: en/git-show-ref.txt:89
#, placeholders:'`--verify`', priority:80
msgid "Do not print any results to stdout. Can be used with `--verify` to silently check if a reference exists."
msgstr "不向标准输出流打印任何结果。可与 `--verify` 一起使用，静默检查引用是否存在。"

#. type: Labeled list
#: en/git-show-ref.txt:90
#, no-wrap, placeholders:'--exclude-existing', priority:80
msgid "--exclude-existing[=<pattern>]"
msgstr "--exclude-existing[=<模式>]"

#. type: Plain text
#: en/git-show-ref.txt:95
#, placeholders:'git show-ref', priority:80
msgid "Make `git show-ref` act as a filter that reads refs from stdin of the form `^(?:<anything>\\s)?<refname>(?:\\^{})?$` and performs the following actions on each:"
msgstr "让 `git show-ref` 成为一个过滤器，从标准输入流中读取格式为 `^(?:<任何东西>\\s)?<引用名称>(?:\\^{})?$` 的多个引用，并对每个引用执行以下操作："

#. type: Plain text
#: en/git-show-ref.txt:96
#, priority:80
msgid "strip `^{}` at the end of line if any;"
msgstr "如果行末有 `^{}` ，则在行末去掉 `^{}`；"

#. type: Plain text
#: en/git-show-ref.txt:97
#, priority:80
msgid "ignore if pattern is provided and does not head-match refname;"
msgstr "如果提供的模式与引用名称不匹配，则忽略；"

#. type: Plain text
#: en/git-show-ref.txt:98
#, priority:80
msgid "warn if refname is not a well-formed refname and skip;"
msgstr "如果引用名不是格式正确的引用名，则警告并跳过；"

#. type: Plain text
#: en/git-show-ref.txt:99
#, priority:80
msgid "ignore if refname is a ref that exists in the local repository;"
msgstr "如果引用名称是本地仓库中存在的引用，则忽略；"

#. type: Plain text
#: en/git-show-ref.txt:100
#, priority:80
msgid "otherwise output the line."
msgstr "否则输出该行。"

#. type: Plain text
#: en/git-show-ref.txt:109
#, priority:80
msgid "Show references matching one or more patterns. Patterns are matched from the end of the full name, and only complete parts are matched, e.g. 'master' matches 'refs/heads/master', 'refs/remotes/origin/master', 'refs/tags/jedi/master' but not 'refs/heads/mymaster' or 'refs/remotes/master/jedi'."
msgstr "显示与一个或多个模式匹配的引用。模式从全名末尾开始匹配，只匹配完整的部分，例如，'master' 匹配 'refs/heads/master'、 'refs/remotes/origin/master'、 'refs/tags/jedi/master'，但不匹配 'refs/heads/mymaster' 或 'refs/remotes/master/jedi'。"

#. type: delimited block -
#: en/git-show-ref.txt:117
#, no-wrap, priority:80
msgid "<oid> SP <ref> LF\n"
msgstr "<oid> SP <引用> LF\n"

#. type: Plain text
#: en/git-show-ref.txt:120 en/git-show-ref.txt:140
#, priority:80
msgid "For example,"
msgstr "例如，"

#. type: delimited block -
#: en/git-show-ref.txt:131
#, ignore-ellipsis, no-wrap, placeholders:'git show-ref':'--head':'--dereference':'HEAD', priority:80
msgid ""
"$ git show-ref --head --dereference\n"
"832e76a9899f560a90ffd62ae2ce83bbeff58f54 HEAD\n"
"832e76a9899f560a90ffd62ae2ce83bbeff58f54 refs/heads/master\n"
"832e76a9899f560a90ffd62ae2ce83bbeff58f54 refs/heads/origin\n"
"3521017556c5de4159da4615a39fa4d5d2c279b5 refs/tags/v0.99.9c\n"
"6ddc0964034342519a87fe013781abf31c6db6ad refs/tags/v0.99.9c^{}\n"
"055e4ae3ae6eb344cbabf2a5256a49ea66040131 refs/tags/v1.0rc4\n"
"423325a2d24638ddcc82ce47be5e40be550f4507 refs/tags/v1.0rc4^{}\n"
"...\n"
msgstr ""
"$ git show-ref --head --dereference\n"
"832e76a9899f560a90ffd62ae2ce83bbeff58f54 HEAD\n"
"832e76a9899f560a90ffd62ae2ce83bbeff58f54 refs/heads/master\n"
"832e76a9899f560a90ffd62ae2ce83bbeff58f54 refs/heads/origin\n"
"3521017556c5de4159da4615a39fa4d5d2c279b5 refs/tags/v0.99.9c\n"
"6ddc0964034342519a87fe013781abf31c6db6ad refs/tags/v0.99.9c^{}\n"
"055e4ae3ae6eb344cbabf2a5256a49ea66040131 refs/tags/v1.0rc4\n"
"423325a2d24638ddcc82ce47be5e40be550f4507 refs/tags/v1.0rc4^{}\n"
"...\n"

# ERROR: --hash not found in translation
#. type: Plain text
#: en/git-show-ref.txt:134
#, placeholders:'`--hash`':'`--dereference`', priority:80
msgid "When using `--hash` (and not `--dereference`), the output is in the format:"
msgstr "使用 `--hash`（而不是 `--dereference`）选项时，输出格式为："

#. type: delimited block -
#: en/git-show-ref.txt:137
#, no-wrap, priority:80
msgid "<oid> LF\n"
msgstr "<对象 ID> LF\n"

#. type: delimited block -
#: en/git-show-ref.txt:147
#, ignore-ellipsis, no-wrap, placeholders:'git show-ref':'--heads':'--hash', priority:80
msgid ""
"$ git show-ref --heads --hash\n"
"2e3ba0114a1f52b47df29743d6915d056be13278\n"
"185008ae97960c8d551adcd9e23565194651b5d1\n"
"03adf42c988195b50e1a1935ba5fcbc39b2b029b\n"
"...\n"
msgstr ""
"$ git show-ref --heads --hash\n"
"2e3ba0114a1f52b47df29743d6915d056be13278\n"
"185008ae97960c8d551adcd9e23565194651b5d1\n"
"03adf42c988195b50e1a1935ba5fcbc39b2b029b\n"
"...\n"

#. type: Plain text
#: en/git-show-ref.txt:155
#, priority:80
msgid "To show all references called \"master\", whether tags or heads or anything else, and regardless of how deep in the reference naming hierarchy they are, use:"
msgstr "要显示所有称为 \"master\" 的引用，无论是标记、标头还是其他，也不管它们在引用命名层次中的位置有多深，都可以使用 \"master\"："

#. type: delimited block -
#: en/git-show-ref.txt:158
#, no-wrap, placeholders:'git show-ref', priority:80
msgid "\tgit show-ref master\n"
msgstr "\tgit show-ref master\n"

#. type: Plain text
#: en/git-show-ref.txt:162
#, priority:80
msgid "This will show \"refs/heads/master\" but also \"refs/remote/other-repo/master\", if such references exist."
msgstr "这不仅会显示 \"refs/heads/master\"，还会显示 \"refs/remote/other-repo/master\"（如果存在此类引用）。"

#. type: Plain text
#: en/git-show-ref.txt:164
#, placeholders:'`--verify`', priority:80
msgid "When using the `--verify` flag, the command requires an exact path:"
msgstr "当使用 `--verify` 标志时，命令需要精确的路径："

#. type: delimited block -
#: en/git-show-ref.txt:167
#, no-wrap, placeholders:'git show-ref':'--verify', priority:80
msgid "\tgit show-ref --verify refs/heads/master\n"
msgstr "\tgit show-ref --verify refs/heads/master\n"

#. type: Plain text
#: en/git-show-ref.txt:170
#, priority:80
msgid "will only match the exact branch called \"master\"."
msgstr "只会匹配名为 \"master\" 的确切分支。"

#. type: Plain text
#: en/git-show-ref.txt:173
#, placeholders:'git show-ref', priority:80
msgid "If nothing matches, `git show-ref` will return an error code of 1, and in the case of verification, it will show an error message."
msgstr "如果没有匹配的内容，`git show-ref` 将返回错误代码 1，在验证的情况下，它将显示一条错误信息。"

#. type: Plain text
#: en/git-show-ref.txt:176
#, placeholders:'`--quiet`', priority:80
msgid "For scripting, you can ask it to be quiet with the `--quiet` flag, which allows you to do things like"
msgstr "在编写脚本时，可以使用 `--quiet` 标记要求它保持安静，这样就可以执行以下操作"

#. type: delimited block -
#: en/git-show-ref.txt:180
#, no-wrap, placeholders:'git show-ref':'--quiet':'--verify':'$headname':'$headname', priority:80
msgid ""
"\tgit show-ref --quiet --verify -- \"refs/heads/$headname\" ||\n"
"\t\techo \"$headname is not a valid branch\"\n"
msgstr ""
"\tgit show-ref --quiet --verify -- \"refs/heads/$headname\" ||\n"
"\t\techo \"$headname 不是一个有效的分支\"\n"

#. type: Plain text
#: en/git-show-ref.txt:185
#, priority:80
msgid "to check whether a particular branch exists or not (notice how we don't actually want to show any results, and we want to use the full refname for it in order to not trigger the problem with ambiguous partial matches)."
msgstr "来检查某个分支是否存在（请注意，我们实际上并不想显示任何结果，而且我们希望使用完整的引用名称，以避免引发部分匹配不明确的问题）。"

#. type: Plain text
#: en/git-show-ref.txt:189
#, placeholders:'`--tags`':'`--heads`', priority:80
msgid "To show only tags, or only proper branch heads, use `--tags` and/or `--heads` respectively (using both means that it shows tags and heads, but not other random references under the refs/ subdirectory)."
msgstr "要只显示标签，或只显示适当的分支标题，请分别使用 `--tags` 和/或 `--heads` （同时使用这两种方法意味着会显示标签和标题，但不会显示 refs/ 子目录下的其他随机引用）。"

#. type: Plain text
#: en/git-show-ref.txt:192
#, placeholders:'`-d`':'`--dereference`', priority:80
msgid "To do automatic tag object dereferencing, use the `-d` or `--dereference` flag, so you can do"
msgstr "要自动取消引用标记对象，请使用 `-d` 或 `--dereference` 标志，这样就可以执行"

#. type: delimited block -
#: en/git-show-ref.txt:195
#, no-wrap, placeholders:'git show-ref':'--tags':'--dereference', priority:80
msgid "\tgit show-ref --tags --dereference\n"
msgstr "\tgit show-ref --tags --dereference\n"

#. type: Plain text
#: en/git-show-ref.txt:198
#, priority:80
msgid "to get a listing of all tags together with what they dereference."
msgstr "来获取所有标记及其引用内容的列表。"

#. type: Plain text
#: en/git-show-ref.txt:202
#, priority:80
msgid "`.git/refs/*`, `.git/packed-refs`"
msgstr "`.git/refs/*`, `.git/packed-refs`"

#. type: Plain text
#: en/git-show-ref.txt:209
#, ignore-same, priority:80
msgid "linkgit:git-for-each-ref[1], linkgit:git-ls-remote[1], linkgit:git-update-ref[1], linkgit:gitrepository-layout[5]"
msgstr "linkgit:git-for-each-ref[1], linkgit:git-ls-remote[1], linkgit:git-update-ref[1], linkgit:gitrepository-layout[5]"

#. type: Title =
#: en/git-show.txt:2
#, ignore-same, no-wrap, priority:240
msgid "git-show(1)"
msgstr "git-show(1)"

#. type: Plain text
#: en/git-show.txt:7
#, placeholders:'git-show', priority:240
msgid "git-show - Show various types of objects"
msgstr "git-show - 显示各种类型的对象"

#. type: Plain text
#: en/git-show.txt:13
#, ignore-ellipsis, no-wrap, priority:240
msgid "'git show' [<options>] [<object>...]\n"
msgstr "'git show' [<选项>] [<对象>...]\n"

#. type: Plain text
#: en/git-show.txt:17
#, priority:240
msgid "Shows one or more objects (blobs, trees, tags and commits)."
msgstr "显示一个或多个对象（Blobs、树、标签和提交）。"

#. type: Plain text
#: en/git-show.txt:21
#, placeholders:'git diff-tree':'--cc', priority:240
msgid "For commits it shows the log message and textual diff. It also presents the merge commit in a special format as produced by 'git diff-tree --cc'."
msgstr "对于提交，它显示日志信息和文本差异。并会以一种特殊的格式显示合并提交，就像 'git diff-tree --cc' 所产生的信息那样。"

#. type: Plain text
#: en/git-show.txt:23
#, priority:240
msgid "For tags, it shows the tag message and the referenced objects."
msgstr "对于标签，它显示标签信息和引用的对象。"

# ERROR: --name-only) not found in translation
#. type: Plain text
#: en/git-show.txt:26
#, placeholders:'git ls-tree':'--name-only', priority:240
msgid "For trees, it shows the names (equivalent to 'git ls-tree' with --name-only)."
msgstr "对于目录树，它显示名字（相当于 'git ls-tree' 添加了 --name-only 选项）。"

#. type: Plain text
#: en/git-show.txt:28
#, priority:240
msgid "For plain blobs, it shows the plain contents."
msgstr "对于普通二进制对象，它显示普通内容。"

#. type: Plain text
#: en/git-show.txt:31
#, priority:240
msgid "Some options that 'git log' command understands can be used to control how the changes the commit introduces are shown."
msgstr "'git log' 命令理解的一些选项可以用来控制如何显示提交带来的改动。"

#. type: Plain text
#: en/git-show.txt:33
#, priority:240
msgid "This manual page describes only the most frequently used options."
msgstr "本手册页只描述了最常用的选项。"

#. type: Labeled list
#: en/git-show.txt:37
#, ignore-ellipsis, no-wrap, priority:240
msgid "<object>..."
msgstr "<对象>..."

#. type: Plain text
#: en/git-show.txt:41
#, placeholders:'HEAD':'linkgit:gitrevisions[7]', priority:240
msgid "The names of objects to show (defaults to 'HEAD'). For a more complete list of ways to spell object names, see \"SPECIFYING REVISIONS\" section in linkgit:gitrevisions[7]."
msgstr "要显示的对象的名称（默认为'HEAD'）。 更完整的对象名称拼写方式列表，请参见 linkgit:gitrevisions[7] 中的 \"特别修订\" 部分。"

#. type: Plain text
#: en/git-show.txt:52
#, priority:240
msgid "The options below can be used to change the way `git show` generates diff output."
msgstr "下面的选项可以用来改变`git show`生成差异输出的方式。"

#. type: Labeled list
#: en/git-show.txt:63
#, no-wrap, priority:240
msgid "`git show v1.0.0`"
msgstr "`git show v1.0.0`"

#. type: Plain text
#: en/git-show.txt:66
#, priority:240
msgid "Shows the tag `v1.0.0`, along with the object the tag points at."
msgstr "显示标签 `v1.0.0`，以及标签指向的对象。"

#. type: Labeled list
#: en/git-show.txt:67
#, no-wrap, placeholders:'{tree}', priority:240
msgid "`git show v1.0.0^{tree}`"
msgstr "`git show v1.0.0^{tree}`"

#. type: Plain text
#: en/git-show.txt:69
#, priority:240
msgid "Shows the tree pointed to by the tag `v1.0.0`."
msgstr "显示标签`v1.0.0`所指向的树。"

#. type: Labeled list
#: en/git-show.txt:70
#, no-wrap, placeholders:'--format=':'{commit}', priority:240
msgid "`git show -s --format=%s v1.0.0^{commit}`"
msgstr "`git show -s --format=%s v1.0.0^{commit}`"

#. type: Plain text
#: en/git-show.txt:73
#, priority:240
msgid "Shows the subject of the commit pointed to by the tag `v1.0.0`."
msgstr "显示由标签`v1.0.0`指向的提交的主题。"

#. type: Labeled list
#: en/git-show.txt:74
#, no-wrap, priority:240
msgid "`git show next~10:Documentation/README`"
msgstr "`git show next~10:Documentation/README`"

#. type: Plain text
#: en/git-show.txt:78
#, priority:240
msgid "Shows the contents of the file `Documentation/README` as they were current in the 10th last commit of the branch `next`."
msgstr "显示`Documentation/README`文件的内容，因为它们在分支`next`的最后10次提交中是当前的。"

#. type: Labeled list
#: en/git-show.txt:79
#, no-wrap, priority:240
msgid "`git show master:Makefile master:t/Makefile`"
msgstr "`git show master:Makefile master:t/Makefile`"

#. type: Plain text
#: en/git-show.txt:82
#, priority:240
msgid "Concatenates the contents of said Makefiles in the head of the branch `master`."
msgstr "将上述Makefiles的内容串联在分支`master`的头部。"

#. type: Title =
#: en/git-sh-setup.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-sh-setup(1)"
msgstr "git-sh-setup(1)"

#. type: Plain text
#: en/git-sh-setup.txt:7
#, placeholders:'git-sh-setup', priority:100
msgid "git-sh-setup - Common Git shell script setup code"
msgstr "git-sh-setup - 常见 Git shell 脚本设置代码"

#. type: Plain text
#: en/git-sh-setup.txt:12
#, no-wrap, placeholders:'--exec-path':'git-sh-setup', priority:100
msgid "'. \"$(git --exec-path)/git-sh-setup\"'\n"
msgstr "'. \"$(git --exec-path)/git-sh-setup\"'\n"

#. type: Plain text
#: en/git-sh-setup.txt:23
#, placeholders:'git sh-setup', priority:100
msgid "The 'git sh-setup' scriptlet is designed to be sourced (using `.`) by other shell scripts to set up some variables pointing at the normal Git directories and a few helper shell functions."
msgstr "'git sh-setup' 脚本小程序的设计目的是让其他 shell 脚本（使用 `.`）设置一些指向正常 Git 目录的变量和一些辅助 shell 函数。"

#. type: Plain text
#: en/git-sh-setup.txt:29
#, placeholders:'LONG_USAGE':'SUBDIRECTORY_OK', priority:100
msgid "Before sourcing it, your script should set up a few variables; `USAGE` (and `LONG_USAGE`, if any) is used to define the message given by `usage()` shell function. `SUBDIRECTORY_OK` can be set if the script can run from a subdirectory of the working tree (some commands do not)."
msgstr "在源码化之前，脚本应该设置一些变量；`USAGE`（和 `LONG_USAGE`，如果有的话）用于定义 shell 函数 `usage()` 给出的信息。 如果脚本可以从工作目录树的子目录运行，则可以设置 `SUBDIRECTORY_OK`（某些命令不能从子目录运行）。"

#. type: Plain text
#: en/git-sh-setup.txt:32
#, placeholders:'GIT_DIR':'GIT_OBJECT_DIRECTORY', priority:100
msgid "The scriptlet sets `GIT_DIR` and `GIT_OBJECT_DIRECTORY` shell variables, but does *not* export them to the environment."
msgstr "脚本小程序会设置 `GIT_DIR` 和 `GIT_OBJECT_DIRECTORY` shell 变量，但*不会*导出它们到环境中。"

#. type: Labeled list
#: en/git-sh-setup.txt:36
#, ignore-same, no-wrap, priority:100
msgid "die"
msgstr "die"

#. type: Plain text
#: en/git-sh-setup.txt:39
#, priority:100
msgid "exit after emitting the supplied error message to the standard error stream."
msgstr "将提供的错误信息发送到标准错误流后退出。"

#. type: Labeled list
#: en/git-sh-setup.txt:40
#, ignore-same, no-wrap, priority:100
msgid "usage"
msgstr "usage"

#. type: Plain text
#: en/git-sh-setup.txt:42
#, priority:100
msgid "die with the usage message."
msgstr "结束，并显示使用信息。"

#. type: Labeled list
#: en/git-sh-setup.txt:43
#, ignore-same, no-wrap, priority:100
msgid "set_reflog_action"
msgstr "set_reflog_action"

#. type: Plain text
#: en/git-sh-setup.txt:49
#, placeholders:'GIT_REFLOG_ACTION', priority:100
msgid "Set `GIT_REFLOG_ACTION` environment to a given string (typically the name of the program) unless it is already set. Whenever the script runs a `git` command that updates refs, a reflog entry is created using the value of this string to leave the record of what command updated the ref."
msgstr "将 `GIT_REFLOG_ACTION` 环境设置为给定的字符串（通常是程序名称），除非它已经被设置。 每当脚本运行更新引用的 `git` 命令时，就会使用该字符串的值创建一个引用日志条目，以记录更新引用的命令。"

#. type: Labeled list
#: en/git-sh-setup.txt:50
#, ignore-same, no-wrap, priority:100
msgid "git_editor"
msgstr "git_editor"

#. type: Plain text
#: en/git-sh-setup.txt:54
#, placeholders:'GIT_EDITOR':'core.editor', priority:100
msgid "runs an editor of user's choice (GIT_EDITOR, core.editor, VISUAL or EDITOR) on a given file, but error out if no editor is specified and the terminal is dumb."
msgstr "在给定文件上运行用户选择的编辑器（GIT_EDITOR、core.editor、VISUAL 或 EDITOR），但如果未指定编辑器且终端为哑终端，则会出错。"

#. type: Labeled list
#: en/git-sh-setup.txt:55
#, no-wrap, placeholders:'is_bare_repository', priority:100
msgid "is_bare_repository"
msgstr "is_bare_repository"

#. type: Plain text
#: en/git-sh-setup.txt:59
#, priority:100
msgid "outputs `true` or `false` to the standard output stream to indicate if the repository is a bare repository (i.e. without an associated working tree)."
msgstr "会向标准输出流输出 `true` 或 `false`，以指示版本库是否为裸仓库（即没有任何关联的工作区）。"

#. type: Labeled list
#: en/git-sh-setup.txt:60
#, ignore-same, no-wrap, priority:100
msgid "cd_to_toplevel"
msgstr "cd_to_toplevel"

#. type: Plain text
#: en/git-sh-setup.txt:62
#, priority:100
msgid "runs chdir to the toplevel of the working tree."
msgstr "运行 chdir 到工作树的顶层。"

#. type: Labeled list
#: en/git-sh-setup.txt:63
#, ignore-same, no-wrap, priority:100
msgid "require_work_tree"
msgstr "require_work_tree"

#. type: Plain text
#: en/git-sh-setup.txt:66
#, priority:100
msgid "checks if the current directory is within the working tree of the repository, and otherwise dies."
msgstr "会检查当前目录是否在仓库的工作区中，否则就挂起。"

#. type: Labeled list
#: en/git-sh-setup.txt:67
#, ignore-same, no-wrap, priority:100
msgid "require_work_tree_exists"
msgstr "require_work_tree_exists"

#. type: Plain text
#: en/git-sh-setup.txt:72
#, placeholders:'cd_to_toplevel', priority:100
msgid "checks if the working tree associated with the repository exists, and otherwise dies. Often done before calling cd_to_toplevel, which is impossible to do if there is no working tree."
msgstr "检查与仓库相关联的工作区是否存在，否则挂掉。 通常在调用 cd_to_toplevel 之前进行，如果没有工作区，就不可能调用 cd_to_toplevel。"

#. type: Labeled list
#: en/git-sh-setup.txt:73
#, no-wrap, placeholders:'require_clean_work_tree', priority:100
msgid "require_clean_work_tree <action> [<hint>]"
msgstr "require_clean_work_tree <行为> [<提示>]"

#. type: Plain text
#: en/git-sh-setup.txt:78
#, priority:100
msgid "checks that the working tree and index associated with the repository have no uncommitted changes to tracked files. Otherwise it emits an error message of the form `Cannot <action>: <reason>. <hint>`, and dies. Example:"
msgstr "会检查与仓库关联的工作区和索引中是否有未提交的跟踪文件变更。 否则，它将发出 \"无法执行 <行为>:<原因>. <提示>\"，然后挂掉。例如："

#. type: delimited block -
#: en/git-sh-setup.txt:81
#, no-wrap, placeholders:'require_clean_work_tree', priority:100
msgid "require_clean_work_tree rebase \"Please commit or stash them.\"\n"
msgstr "require_clean_work_tree rebase \"请提交或者贮藏他们。\"\n"

#. type: Labeled list
#: en/git-sh-setup.txt:83
#, ignore-same, no-wrap, priority:100
msgid "get_author_ident_from_commit"
msgstr "get_author_ident_from_commit"

#. type: Plain text
#: en/git-sh-setup.txt:86
#, placeholders:'GIT_AUTHOR_NAME':'GIT_AUTHOR_EMAIL':'GIT_AUTHOR_DATE', priority:100
msgid "outputs code for use with eval to set the GIT_AUTHOR_NAME, GIT_AUTHOR_EMAIL and GIT_AUTHOR_DATE variables for a given commit."
msgstr "输出与 eval 配合使用的代码，以设置指定提交的 GIT_AUTHOR_NAME、GIT_AUTHOR_EMAIL 和 GIT_AUTHOR_DATE 变量。"

#. type: Labeled list
#: en/git-sh-setup.txt:87
#, ignore-same, no-wrap, priority:100
msgid "create_virtual_base"
msgstr "create_virtual_base"

#. type: Plain text
#: en/git-sh-setup.txt:92
#, priority:100
msgid "modifies the first file so only lines in common with the second file remain. If there is insufficient common material, then the first file is left empty. The result is suitable as a virtual base input for a 3-way merge."
msgstr "修改第一个文件，只保留与第二个文件相同的行。如果共同内容不足，则第一个文件留空。结果适合作为三向合并的虚拟基础输入。"

#. type: Title =
#: en/git-stage.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-stage(1)"
msgstr "git-stage(1)"

#. type: Plain text
#: en/git-stage.txt:7
#, placeholders:'git-stage', priority:100
msgid "git-stage - Add file contents to the staging area"
msgstr "git-stage - 将文件内容添加到暂存区"

#. type: Plain text
#: en/git-stage.txt:13
#, ignore-ellipsis, no-wrap, priority:100
msgid "'git stage' <arg>...\n"
msgstr "'git stage' <参数>...\n"

#. type: Plain text
#: en/git-stage.txt:20
#, placeholders:'linkgit:git-add[1]', priority:100
msgid "This is a synonym for linkgit:git-add[1]. Please refer to the documentation of that command."
msgstr "这是 linkgit:git-add[1] 的同义词。 请参阅该命令的文档。"

#. type: Title =
#: en/git-stash.txt:2
#, ignore-same, no-wrap, priority:240
msgid "git-stash(1)"
msgstr "git-stash(1)"

#. type: Plain text
#: en/git-stash.txt:7
#, placeholders:'git-stash', priority:240
msgid "git-stash - Stash the changes in a dirty working directory away"
msgstr "git-stash - 将变化藏在一个脏工作区中"

#. type: Plain text
#: en/git-stash.txt:26
#, ignore-ellipsis, no-wrap, placeholders:'--include-untracked':'--only-untracked]':'--quiet]':'[--index]':'--quiet]':'[--index]':'--quiet]':'--patch]':'--staged]':'--quiet]':'--include-untracked]':'--all]':'--message':'[--pathspec-from-file=':'[--pathspec-file-nul]':'--patch]':'--staged]':'--quiet]':'--include-untracked]':'--all]':'--message':'--quiet]', priority:240
msgid ""
"'git stash' list [<log-options>]\n"
"'git stash' show [-u | --include-untracked | --only-untracked] [<diff-options>] [<stash>]\n"
"'git stash' drop [-q | --quiet] [<stash>]\n"
"'git stash' pop [--index] [-q | --quiet] [<stash>]\n"
"'git stash' apply [--index] [-q | --quiet] [<stash>]\n"
"'git stash' branch <branchname> [<stash>]\n"
"'git stash' [push [-p | --patch] [-S | --staged] [-k | --[no-]keep-index] [-q | --quiet]\n"
"\t     [-u | --include-untracked] [-a | --all] [(-m | --message) <message>]\n"
"\t     [--pathspec-from-file=<file> [--pathspec-file-nul]]\n"
"\t     [--] [<pathspec>...]]\n"
"'git stash' save [-p | --patch] [-S | --staged] [-k | --[no-]keep-index] [-q | --quiet]\n"
"\t     [-u | --include-untracked] [-a | --all] [<message>]\n"
"'git stash' clear\n"
"'git stash' create [<message>]\n"
"'git stash' store [(-m | --message) <message>] [-q | --quiet] <commit>\n"
msgstr ""
"'git stash' list [<日志选项>]\n"
"'git stash' show [-u | --include-untracked | --only-untracked] [<差异选项>] [<暂存>]\n"
"'git stash' drop [-q | --quiet] [<暂存>]\n"
"'git stash' pop [--index] [-q | --quiet] [<暂存>]\n"
"'git stash' apply [--index] [-q | --quiet] [<暂存>]\n"
"'git stash' branch <分支名> [<暂存>]\n"
"'git stash' [push [-p | --patch] [-S | --staged] [-k | --[no-]keep-index] [-q | --quiet]\n"
"\t     [-u | --include-untracked] [-a | --all] [(-m | --message) <信息>]\n"
"\t     [--pathspec-from-file=<文件> [--pathspec-file-nul]]\n"
"\t     [--] [<路径规范>...]]\n"
"'git stash' save [-p | --patch] [-S | --staged] [-k | --[no-]keep-index] [-q | --quiet]\n"
"\t     [-u | --include-untracked] [-a | --all] [<信息>]\n"
"'git stash' clear\n"
"'git stash' create [<信息>]\n"
"'git stash' store [(-m | --message) <信息>] [-q | --quiet] <提交>\n"

#. type: Plain text
#: en/git-stash.txt:34
#, placeholders:'HEAD', priority:240
msgid "Use `git stash` when you want to record the current state of the working directory and the index, but want to go back to a clean working directory. The command saves your local modifications away and reverts the working directory to match the `HEAD` commit."
msgstr "当你想记录工作目录和索引的当前状态，但又想回到一个干净的工作目录时，请使用`git stash`。 该命令将你的本地修改保存起来，并将工作目录还原为与`HEAD`提交相匹配。"

#. type: Plain text
#: en/git-stash.txt:42
#, ignore-ellipsis, priority:240
msgid "The modifications stashed away by this command can be listed with `git stash list`, inspected with `git stash show`, and restored (potentially on top of a different commit) with `git stash apply`. Calling `git stash` without any arguments is equivalent to `git stash push`. A stash is by default listed as \"WIP on 'branchname' ...\", but you can give a more descriptive message on the command line when you create one."
msgstr "这个命令所存储的修改可以用`git stash list`列出，用`git stash show`检查，用`git stash apply`恢复（可能是在不同的提交之上）。 在没有任何参数的情况下调用`git stash`等同于`git stash push`。 默认情况下，储藏库被列为 \"WIP on 'branchname' ...\"，但你可以在创建储藏库时在命令行中给出更多描述性信息。"

#. type: Plain text
#: en/git-stash.txt:49
#, placeholders:'{0}':'{1}':'hours.ago':'{n}', priority:240
msgid "The latest stash you created is stored in `refs/stash`; older stashes are found in the reflog of this reference and can be named using the usual reflog syntax (e.g. `stash@{0}` is the most recently created stash, `stash@{1}` is the one before it, `stash@{2.hours.ago}` is also possible). Stashes may also be referenced by specifying just the stash index (e.g. the integer `n` is equivalent to `stash@{n}`)."
msgstr "你最近创建的储藏库被保存在`refs/stash`中；旧的储藏库可以在这个引用的引用日志中找到，并且可以使用通常的引用日志语法来命名（例如，`stash@{0}`是最近创建的储藏库，`stash@{1}`是它之前的储藏库，`stash@{2.hours.ago}`也是可以的）。也可以通过指定储藏库的索引来引用储藏库（例如，整数`n`等同于`stash@{n}`）。"

# ERROR: --message) not found in translation
#. type: Labeled list
#: en/git-stash.txt:53
#, ignore-ellipsis, no-wrap, placeholders:'--patch]':'--staged]':'--include-untracked]':'--all]':'--quiet]':'--message':'[--pathspec-from-file=':'[--pathspec-file-nul]', priority:240
msgid "push [-p|--patch] [-S|--staged] [-k|--[no-]keep-index] [-u|--include-untracked] [-a|--all] [-q|--quiet] [(-m|--message) <message>] [--pathspec-from-file=<file> [--pathspec-file-nul]] [--] [<pathspec>...]"
msgstr "push [-p|--patch] [-S|--staged] [-k|--[no-]keep-index] [-u|--include-untracked] [-a|--all] [-q|--quiet] [(-m|--message) <信息>] [--pathspec-from-file=<文件> [--pathspec-file-nul]] [--] [<路径规范>...]"

#. type: Plain text
#: en/git-stash.txt:59
#, placeholders:'HEAD', priority:240
msgid "Save your local modifications to a new 'stash entry' and roll them back to HEAD (in the working tree and in the index). The <message> part is optional and gives the description along with the stashed state."
msgstr "将你的本地修改保存到一个新的 \"存储条目 \"中，并将它们回滚到 HEAD（在工作区和索引中）。 <信息>部分是可选的，它给出了描述和储藏的状态。"

#. type: Plain text
#: en/git-stash.txt:65
#, priority:240
msgid "For quickly making a snapshot, you can omit \"push\". In this mode, non-option arguments are not allowed to prevent a misspelled subcommand from making an unwanted stash entry. The two exceptions to this are `stash -p` which acts as alias for `stash push -p` and pathspec elements, which are allowed after a double hyphen `--` for disambiguation."
msgstr "为了快速制作快照，你可以省略 \"push\"。 在这种模式下，非选项参数是不允许的，以防止拼写错误的子命令产生不需要的储藏条目。 这方面的两个例外是`stash -p`，它作为`stash push -p`的别名，以及为消除歧义允许在双连字符`--`之后的路径规范元素。"

#. type: Labeled list
#: en/git-stash.txt:66
#, no-wrap, placeholders:'--patch]':'--staged]':'--include-untracked]':'--all]':'--quiet]', priority:240
msgid "save [-p|--patch] [-S|--staged] [-k|--[no-]keep-index] [-u|--include-untracked] [-a|--all] [-q|--quiet] [<message>]"
msgstr "save [-p|--patch] [-S|--staged] [-k|--[no-]keep-index] [-u|--include-untracked] [-a|--all] [-q|--quiet] [<信息>]"

#. type: Plain text
#: en/git-stash.txt:72
#, priority:240
msgid "This option is deprecated in favour of 'git stash push'. It differs from \"stash push\" in that it cannot take pathspec. Instead, all non-option arguments are concatenated to form the stash message."
msgstr "该选项已被弃用，改为 \"git stash push\"。 它与 \"stash push \"的不同之处在于，它不能接受路径规范。 取而代之的是，所有非选项的参数都被串联起来，形成储藏消息。"

#. type: Labeled list
#: en/git-stash.txt:73
#, no-wrap, priority:240
msgid "list [<log-options>]"
msgstr "list [<日志选项>]"

#. type: Plain text
#: en/git-stash.txt:80
#, placeholders:'{0}':'{1}', priority:240
msgid "List the stash entries that you currently have. Each 'stash entry' is listed with its name (e.g. `stash@{0}` is the latest entry, `stash@{1}` is the one before, etc.), the name of the branch that was current when the entry was made, and a short description of the commit the entry was based on."
msgstr "列出你目前拥有的储藏目录。 每个 \"储藏目录 \"都列出了它的名字（例如，`stash@{0}`是最新的条目，`stash@{1}`是之前的条目，等等），条目产生时的分支名称，以及该条目所基于的提交的简短描述。"

#. type: delimited block -
#: en/git-stash.txt:84
#, ignore-ellipsis, no-wrap, placeholders:'{0}':'git-stash':'{1}':'git-stash', priority:240
msgid ""
"stash@{0}: WIP on submit: 6ebd0e2... Update git-stash documentation\n"
"stash@{1}: On master: 9cc0589... Add git-stash\n"
msgstr ""
"stash@{0}: WIP on submit: 6ebd0e2...更新 git-stash 文档\n"
"stash@{1}: On master: 9cc0589... 添加 git-stash\n"

#. type: Plain text
#: en/git-stash.txt:88
#, placeholders:'linkgit:git-log[1]', priority:240
msgid "The command takes options applicable to the 'git log' command to control what is shown and how. See linkgit:git-log[1]."
msgstr "该命令采用适用于 'git log' 命令的选项来控制显示的内容和方式。参见 linkgit:git-log[1]。"

#. type: Labeled list
#: en/git-stash.txt:89
#, no-wrap, placeholders:'--include-untracked':'--only-untracked]', priority:240
msgid "show [-u|--include-untracked|--only-untracked] [<diff-options>] [<stash>]"
msgstr "show [-u|--include-untracked|--only-untracked] [<diff选项>] [<储藏目录>]"

#. type: Plain text
#: en/git-stash.txt:101
#, placeholders:'{1}':'stash.showStat':'stash.showPatch':'stash.showIncludeUntracked':'`--include-untracked`', priority:240
msgid "Show the changes recorded in the stash entry as a diff between the stashed contents and the commit back when the stash entry was first created. By default, the command shows the diffstat, but it will accept any format known to 'git diff' (e.g., `git stash show -p stash@{1}` to view the second most recent entry in patch form). If no `<diff-option>` is provided, the default behavior will be given by the `stash.showStat`, and `stash.showPatch` config variables. You can also use `stash.showIncludeUntracked` to set whether `--include-untracked` is enabled by default."
msgstr "显示贮藏中记录的修改，作为贮藏内容与贮藏库条目首次创建时的提交之间的差异。 默认情况下，该命令显示diff统计，但它会接受 \"git diff \"已知的任何格式（例如，`git stash show -p stash@{1}`以补丁形式查看第二条最新条目）。 如果没有提供`<diff选项>`，默认行为将由`stash.showStat`和`stash.showPatch`配置变量给出。你也可以使用`stash.showIncludeUntracked`来设置是否默认启用`--include-untracked`。"

#. type: Labeled list
#: en/git-stash.txt:102
#, no-wrap, placeholders:'[--index]':'--quiet]', priority:240
msgid "pop [--index] [-q|--quiet] [<stash>]"
msgstr "pop [--index] [-q|--quiet] [<暂存>]"

#. type: Plain text
#: en/git-stash.txt:108
#, priority:240
msgid "Remove a single stashed state from the stash list and apply it on top of the current working tree state, i.e., do the inverse operation of `git stash push`. The working directory must match the index."
msgstr "从贮藏库列表中移除一个单一的贮藏状态，并将其应用于当前工作区状态之上，也就是做`git stash push`的逆向操作。工作目录必须与索引匹配。"

#. type: Plain text
#: en/git-stash.txt:112
#, priority:240
msgid "Applying the state can fail with conflicts; in this case, it is not removed from the stash list. You need to resolve the conflicts by hand and call `git stash drop` manually afterwards."
msgstr "应用状态可能会因为冲突而失败；在这种情况下，它不会被从贮藏库列表中删除。你需要手动解决冲突，并在之后调用 `git stash drop`。"

#. type: Labeled list
#: en/git-stash.txt:113
#, no-wrap, placeholders:'[--index]':'--quiet]', priority:240
msgid "apply [--index] [-q|--quiet] [<stash>]"
msgstr "apply [--index] [-q|--quiet] [<暂存>]"

#. type: Plain text
#: en/git-stash.txt:118
#, priority:240
msgid "Like `pop`, but do not remove the state from the stash list. Unlike `pop`, `<stash>` may be any commit that looks like a commit created by `stash push` or `stash create`."
msgstr "和 `pop` 一样，但不从贮藏库列表中删除该状态。与`pop`不同，`<贮藏项>`可以是任何看起来像由`stash push`或`stash create`创建的提交。"

#. type: Labeled list
#: en/git-stash.txt:119
#, no-wrap, priority:240
msgid "branch <branchname> [<stash>]"
msgstr "branch <分支名> [<贮藏项>]"

#. type: Plain text
#: en/git-stash.txt:126
#, priority:240
msgid "Creates and checks out a new branch named `<branchname>` starting from the commit at which the `<stash>` was originally created, applies the changes recorded in `<stash>` to the new working tree and index. If that succeeds, and `<stash>` is a reference of the form `stash@{<revision>}`, it then drops the `<stash>`."
msgstr "创建并检查一个名为 `<分支名>` 的新分支，从最初创建 `<贮藏项>` 的提交开始，将 `<贮藏项>` 中记录的修改应用到新的工作树和索引。 如果成功了，并且`<贮藏项>`是`stash@{<版本>}`形式的引用，那么它将删除`<贮藏项>`。"

# ERROR: HEAD not found in translation
#. type: Plain text
#: en/git-stash.txt:132
#, placeholders:'HEAD', priority:240
msgid "This is useful if the branch on which you ran `git stash push` has changed enough that `git stash apply` fails due to conflicts. Since the stash entry is applied on top of the commit that was HEAD at the time `git stash` was run, it restores the originally stashed state with no conflicts."
msgstr "如果你运行 `git stash push` 的分支发生了足够的变化，以至于 `git stash apply` 因冲突而失败，那么这就很有用。由于贮藏条目是在运行 `git stash` 时的 HEAD 提交之上应用的，它没有冲突地恢复了最初的贮藏状态。"

#. type: Labeled list
#: en/git-stash.txt:133
#, no-wrap, priority:240
msgid "clear"
msgstr "清除"

#. type: Plain text
#: en/git-stash.txt:137
#, priority:240
msgid "Remove all the stash entries. Note that those entries will then be subject to pruning, and may be impossible to recover (see 'Examples' below for a possible strategy)."
msgstr "删除所有的贮藏条目。直接切断任何联系，而且可能无法恢复（可能的策略见下面的 \"例子\"）。"

#. type: Labeled list
#: en/git-stash.txt:138
#, no-wrap, placeholders:'--quiet]', priority:240
msgid "drop [-q|--quiet] [<stash>]"
msgstr "Drop [-q|--quiet] [<贮藏项>]"

#. type: Plain text
#: en/git-stash.txt:141
#, priority:240
msgid "Remove a single stash entry from the list of stash entries."
msgstr "从贮藏条目列表中删除一个单一的贮藏条目。"

#. type: Labeled list
#: en/git-stash.txt:142 en/git-update-ref.txt:108
#, ignore-same, no-wrap, priority:240
msgid "create"
msgstr "create"

#. type: Plain text
#: en/git-stash.txt:149
#, priority:240
msgid "Create a stash entry (which is a regular commit object) and return its object name, without storing it anywhere in the ref namespace. This is intended to be useful for scripts. It is probably not the command you want to use; see \"push\" above."
msgstr "创建一个贮藏条目（这是一个普通的提交对象），并返回其对象名称，而不将其存储在引用命名空间的任何地方。 这是为了对脚本有用。 你可能不想用这个命令；可以看看前面的 \"push\"。"

#. type: Labeled list
#: en/git-stash.txt:150
#, no-wrap, priority:240
msgid "store"
msgstr "保存"

#. type: Plain text
#: en/git-stash.txt:156
#, priority:240
msgid "Store a given stash created via 'git stash create' (which is a dangling merge commit) in the stash ref, updating the stash reflog. This is intended to be useful for scripts. It is probably not the command you want to use; see \"push\" above."
msgstr "将通过'git stash create'（这是一个悬空的合并提交）创建的特定贮藏库存储在贮藏库引用中，更新贮藏库参考文件。 这是为了对脚本有用。 这条命令可能不是你想要的；见上文\"push\"。"

#. type: Plain text
#: en/git-stash.txt:162 en/git-stash.txt:193 en/git-stash.txt:199 en/git-stash.txt:214
#, priority:240
msgid "This option is only valid for `push` and `save` commands."
msgstr "这个选项只对`push`和`save`命令有效。"

#. type: Plain text
#: en/git-stash.txt:165
#, priority:240
msgid "All ignored and untracked files are also stashed and then cleaned up with `git clean`."
msgstr "所有被忽略的和未被追踪的文件也被贮藏起来，然后用`git clean`来清理。"

#. type: Labeled list
#: en/git-stash.txt:167
#, ignore-same, no-wrap, priority:240
msgid "--include-untracked"
msgstr "--include-untracked"

#. type: Labeled list
#: en/git-stash.txt:168
#, ignore-same, no-wrap, priority:240
msgid "--no-include-untracked"
msgstr "--no-include-untracked"

#. type: Plain text
#: en/git-stash.txt:172
#, priority:240
msgid "When used with the `push` and `save` commands, all untracked files are also stashed and then cleaned up with `git clean`."
msgstr "当与`push`和`save`命令一起使用时，所有未被追踪的文件也被贮藏起来，然后用`git clean`来清理。"

#. type: Plain text
#: en/git-stash.txt:175
#, priority:240
msgid "When used with the `show` command, show the untracked files in the stash entry as part of the diff."
msgstr "当与`show`命令一起使用时，显示贮藏库条目中未被追踪的文件作为差异的一部分。"

#. type: Labeled list
#: en/git-stash.txt:176
#, ignore-same, no-wrap, priority:240
msgid "--only-untracked"
msgstr "--only-untracked"

#. type: Plain text
#: en/git-stash.txt:178
#, priority:240
msgid "This option is only valid for the `show` command."
msgstr "这个选项只对`show`命令有效。"

#. type: Plain text
#: en/git-stash.txt:180
#, priority:240
msgid "Show only the untracked files in the stash entry as part of the diff."
msgstr "只显示贮藏库条目中未被追踪的文件作为差异的一部分。"

#. type: Plain text
#: en/git-stash.txt:183
#, priority:240
msgid "This option is only valid for `pop` and `apply` commands."
msgstr "这个选项只对`pop`和`apply`命令有效。"

#. type: Plain text
#: en/git-stash.txt:188
#, priority:240
msgid "Tries to reinstate not only the working tree's changes, but also the index's ones. However, this can fail, when you have conflicts (which are stored in the index, where you therefore can no longer apply the changes as they were originally)."
msgstr "不仅试图恢复工作区的变化，而且恢复索引的变化。然而，这可能会在出现冲突时失败（这些冲突被存储在索引中，因此你不能再按原来的方式应用这些变化）。"

#. type: Labeled list
#: en/git-stash.txt:190
#, ignore-same, no-wrap, priority:240
msgid "--keep-index"
msgstr "--keep-index"

#. type: Labeled list
#: en/git-stash.txt:191
#, ignore-same, no-wrap, priority:240
msgid "--no-keep-index"
msgstr "--no-keep-index"

#. type: Plain text
#: en/git-stash.txt:195
#, priority:240
msgid "All changes already added to the index are left intact."
msgstr "所有已经添加到索引中的变化都保持原样。"

#. type: Plain text
#: en/git-stash.txt:207
#, placeholders:'HEAD':'linkgit:git-add[1]':'`--patch`', priority:240
msgid "Interactively select hunks from the diff between HEAD and the working tree to be stashed. The stash entry is constructed such that its index state is the same as the index state of your repository, and its worktree contains only the changes you selected interactively. The selected changes are then rolled back from your worktree. See the ``Interactive Mode'' section of linkgit:git-add[1] to learn how to operate the `--patch` mode."
msgstr "交互式地从 HEAD 和工作区之间的差异中选择要存储的内容。 藏匿条目的构造是这样的：它的索引状态与你仓库的索引状态相同，它的工作区只包含你交互选择的变化。 被选中的修改会从你的工作区中回滚。参见 linkgit:git-add[1] 中的 ''互动模式'' 一节，了解如何操作`--patch`模式。"

# ERROR: `--patch` not found in translation
# ERROR: `--keep-index` not found in translation
#. type: Plain text
#: en/git-stash.txt:210
#, placeholders:'`--patch`':'`--keep-index`':'`--no-keep-index`', priority:240
msgid "The `--patch` option implies `--keep-index`. You can use `--no-keep-index` to override this."
msgstr "选项 `--patch` 意味着 `--keep-index`。 你可以使用 `--no-keep-index` 来覆盖它。"

#. type: Plain text
#: en/git-stash.txt:218
#, priority:240
msgid "Stash only the changes that are currently staged. This is similar to basic `git commit` except the state is committed to the stash instead of current branch."
msgstr "只存放当前分阶段的修改。这类似于基本的`git commit`，只不过是将状态提交到贮藏室而不是当前分支。"

#. type: Plain text
#: en/git-stash.txt:220
#, placeholders:'`--patch`', priority:240
msgid "The `--patch` option has priority over this one."
msgstr "`--patch`选项要优先于这个选项。"

#. type: Plain text
#: en/git-stash.txt:223 en/git-stash.txt:233 en/git-stash.txt:247 en/git-stash.txt:252
#, priority:240
msgid "This option is only valid for `push` command."
msgstr "这个选项只对`push`命令有效。"

#. type: Plain text
#: en/git-stash.txt:242
#, priority:240
msgid "This option is only valid for `apply`, `drop`, `pop`, `push`, `save`, `store` commands."
msgstr "这个选项只对`apply`、`drop`、`pop`、`push`、`save`、`store`命令有效。"

#. type: Plain text
#: en/git-stash.txt:249
#, priority:240
msgid "Separates pathspec from options for disambiguation purposes."
msgstr "为了消除歧义，将路径规范与选项分开。"

#. type: Plain text
#: en/git-stash.txt:257
#, placeholders:'HEAD', priority:240
msgid "The new stash entry records the modified states only for the files that match the pathspec. The index entries and working tree files are then rolled back to the state in HEAD only for these files, too, leaving files that do not match the pathspec intact."
msgstr "新的贮藏条目只记录了符合路径规范文件的修改状态。 然后索引条目和工作区文件也被回滚到 HEAD 中的状态，只留下不符合路径规范的文件。"

#. type: Labeled list
#: en/git-stash.txt:260
#, no-wrap, priority:240
msgid "<stash>"
msgstr "<暂存>"

#. type: Plain text
#: en/git-stash.txt:263
#, priority:240
msgid "This option is only valid for `apply`, `branch`, `drop`, `pop`, `show` commands."
msgstr "这个选项只对`apply`、`branch`、`drop`、`pop`、`show`命令有效。"

#. type: Plain text
#: en/git-stash.txt:266
#, placeholders:'{0}', priority:240
msgid "A reference of the form `stash@{<revision>}`. When no `<stash>` is given, the latest stash is assumed (that is, `stash@{0}`)."
msgstr "一个形式为`stash@{<版本>}`的引用。如果没有给出`<贮藏项>`，则假定是最新的储藏库（即`stash@{0}`）。"

#. type: Plain text
#: en/git-stash.txt:275
#, placeholders:'HEAD':'HEAD', priority:240
msgid "A stash entry is represented as a commit whose tree records the state of the working directory, and its first parent is the commit at `HEAD` when the entry was created. The tree of the second parent records the state of the index when the entry is made, and it is made a child of the `HEAD` commit. The ancestry graph looks like this:"
msgstr "一个贮藏库条目被表示为一个提交，它的目录树记录了工作目录的状态，它的第一个父节点是创建该条目时在`HEAD`的提交。 第二个父节点的树记录了条目生成时索引的状态，它是`HEAD`提交的一个子节点。 祖先图看起来像这样："

#. type: Plain text
#: en/git-stash.txt:279
#, no-wrap, placeholders:'----W':'-----H----I', priority:240
msgid ""
"            .----W\n"
"           /    /\n"
"     -----H----I\n"
msgstr ""
"            .----W\n"
"           /    /\n"
"     -----H----I\n"

#. type: Plain text
#: en/git-stash.txt:283
#, placeholders:'HEAD', priority:240
msgid "where `H` is the `HEAD` commit, `I` is a commit that records the state of the index, and `W` is a commit that records the state of the working tree."
msgstr "其中`H`是`HEAD`提交，`I`是记录索引状态的提交，`W`是记录工作区状态的提交。"

#. type: Labeled list
#: en/git-stash.txt:288
#, no-wrap, priority:240
msgid "Pulling into a dirty tree"
msgstr "拉进一个脏目录树"

#. type: Plain text
#: en/git-stash.txt:294
#, priority:240
msgid "When you are in the middle of something, you learn that there are upstream changes that are possibly relevant to what you are doing. When your local changes do not conflict with the changes in the upstream, a simple `git pull` will let you move forward."
msgstr "当你在做某件事的时候，你得知上游有一些变化可能与你正在做的事情有关。 当你的本地修改与上游的修改不冲突时，一个简单的`git pull'就可以让你继续前进。"

#. type: Plain text
#: en/git-stash.txt:299
#, priority:240
msgid "However, there are cases in which your local changes do conflict with the upstream changes, and `git pull` refuses to overwrite your changes. In such a case, you can stash your changes away, perform a pull, and then unstash, like this:"
msgstr "然而，在有些情况下，你的本地修改确实与上游修改有冲突，而`git pull`拒绝覆盖你的修改。 在这种情况下，你可以把你的进度保存起来，执行一次拉取，然后再解开，像这样："

#. type: delimited block -
#: en/git-stash.txt:307
#, ignore-ellipsis, no-wrap, priority:240
msgid ""
"$ git pull\n"
" ...\n"
"file foobar not up to date, cannot merge.\n"
"$ git stash\n"
"$ git pull\n"
"$ git stash pop\n"
msgstr ""
"$ git pull\n"
" ...\n"
"文件 foobar 不是最新的，无法合并。\n"
"$ git stash\n"
"$ git pull\n"
"$ git stash pop\n"

#. type: Plain text
#: en/git-stash.txt:315
#, priority:240
msgid "When you are in the middle of something, your boss comes in and demands that you fix something immediately. Traditionally, you would make a commit to a temporary branch to store your changes away, and return to your original branch to make the emergency fix, like this:"
msgstr "当你正在做某件事的时候，你的老板来了，要求你立即修复某件事。 传统上，你会向一个临时分支提交，以储存你的修改，然后返回到你的原始分支进行紧急修复，就像这样："

#. type: delimited block -
#: en/git-stash.txt:326
#, ignore-ellipsis, no-wrap, placeholders:'my_wip':'my_wip':'--soft':'HEAD', priority:240
msgid ""
"# ... hack hack hack ...\n"
"$ git switch -c my_wip\n"
"$ git commit -a -m \"WIP\"\n"
"$ git switch master\n"
"$ edit emergency fix\n"
"$ git commit -a -m \"Fix in a hurry\"\n"
"$ git switch my_wip\n"
"$ git reset --soft HEAD^\n"
"# ... continue hacking ...\n"
msgstr ""
"# ... 嗨骇害 ...\n"
"$ git switch -c my_wip\n"
"$ git commit -a -m \"我待会还得写点东西\"\n"
"$ git switch master\n"
"$ edit emergency fix\n"
"$ git commit -a -m \"速速修复BUG\"\n"
"$ git switch my_wip\n"
"$ git reset --soft HEAD^\n"
"# ... 继续骇入 ...\n"

#. type: Plain text
#: en/git-stash.txt:329
#, priority:240
msgid "You can use 'git stash' to simplify the above, like this:"
msgstr "你可以用'git stash'来简化上述工作，像这样："

#. type: delimited block -
#: en/git-stash.txt:337
#, ignore-ellipsis, no-wrap, priority:240
msgid ""
"# ... hack hack hack ...\n"
"$ git stash\n"
"$ edit emergency fix\n"
"$ git commit -a -m \"Fix in a hurry\"\n"
"$ git stash pop\n"
"# ... continue hacking ...\n"
msgstr ""
"# ... 嗨骇害 ...\n"
"$ git stash\n"
"$ edit emergency fix\n"
"$ git commit -a -m \"紧急修复\"\n"
"$ git stash pop\n"
"# ... 继续骇入 ...\n"

#. type: Labeled list
#: en/git-stash.txt:339
#, no-wrap, priority:240
msgid "Testing partial commits"
msgstr "部分测试提交"

#. type: Plain text
#: en/git-stash.txt:344
#, placeholders:'--keep-index`', priority:240
msgid "You can use `git stash push --keep-index` when you want to make two or more commits out of the changes in the work tree, and you want to test each change before committing:"
msgstr "当你想把工作区上的改动做两个或更多的提交，并且想在提交前测试每个改动时，你可以使用`git stash push --keep-index`："

#. type: delimited block -
#: en/git-stash.txt:355
#, ignore-ellipsis, no-wrap, placeholders:'--patch':'--keep-index', priority:240
msgid ""
"# ... hack hack hack ...\n"
"$ git add --patch foo            # add just first part to the index\n"
"$ git stash push --keep-index    # save all other changes to the stash\n"
"$ edit/build/test first part\n"
"$ git commit -m 'First part'     # commit fully tested change\n"
"$ git stash pop                  # prepare to work on all other changes\n"
"# ... repeat above five steps until one commit remains ...\n"
"$ edit/build/test remaining parts\n"
"$ git commit foo -m 'Remaining parts'\n"
msgstr ""
"# ... 嗨骇害 ...\n"
"$ git add --patch foo # 仅将第一部分添加到索引中\n"
"$ git stash push --keep-index # 将所有其他改动保存到储藏室中\n"
"$ edit/build/test first part\n"
"$ git commit -m '第一个部分' # 提交完全测试过的改动\n"
"$ git stash pop # 准备处理所有其他改动\n"
"# ... 重复以上五个步骤，直到剩下一个提交...\n"
"$ 编辑/构建/测试剩余部分\n"
"$ git commit foo -m '剩余部分'。\n"

#. type: Labeled list
#: en/git-stash.txt:357
#, no-wrap, priority:240
msgid "Saving unrelated changes for future use"
msgstr "保存不相关的变化供将来使用"

#. type: Plain text
#: en/git-stash.txt:364
#, placeholders:'--staged`', priority:240
msgid "When you are in the middle of massive changes and you find some unrelated issue that you don't want to forget to fix, you can do the change(s), stage them, and use `git stash push --staged` to stash them out for future use. This is similar to committing the staged changes, only the commit ends-up being in the stash and not on the current branch."
msgstr "当你在进行大规模修改时，发现一些不相关的问题，你不想忘记修复，你可以进行修改，将其分阶段，然后使用 `git stash push --staged` 将其存放起来，以便将来使用。这类似于提交阶段性修改，只是提交的结果是在贮藏库而不是在当前分支。"

#. type: delimited block -
#: en/git-stash.txt:373
#, ignore-ellipsis, no-wrap, placeholders:'--patch':'--staged', priority:240
msgid ""
"# ... hack hack hack ...\n"
"$ git add --patch foo           # add unrelated changes to the index\n"
"$ git stash push --staged       # save these changes to the stash\n"
"# ... hack hack hack, finish current changes ...\n"
"$ git commit -m 'Massive'       # commit fully tested changes\n"
"$ git switch fixup-branch       # switch to another branch\n"
"$ git stash pop                 # to finish work on the saved changes\n"
msgstr ""
"# ... 嗨骇害 ...\n"
"$ git add --patch foo               # 将不相关的改动添加到索引中\n"
"$ git stash push --staged       # 将这些改动保存到储藏库中\n"
"# ... 嗨骇害， 完成当前改动 ...\n"
"$ git commit -m '大规模测试'        # 提交完全测试过的改动\n"
"$ git switch fixup-branch        # 切换到另一个分支\n"
"$ git stash pop                  # 完成已保存更改的工作\n"

#. type: Labeled list
#: en/git-stash.txt:375
#, no-wrap, priority:240
msgid "Recovering stash entries that were cleared/dropped erroneously"
msgstr "恢复被错误地清除/丢弃的贮藏库条目"

#. type: Plain text
#: en/git-stash.txt:381
#, priority:240
msgid "If you mistakenly drop or clear stash entries, they cannot be recovered through the normal safety mechanisms. However, you can try the following incantation to get a list of stash entries that are still in your repository, but not reachable any more:"
msgstr "如果你错误地丢弃或清除了贮藏库条目，它们无法通过正常的安全机制恢复。 然而，你可以试试下面的咒语，以获得仍在你的版本库中，但无法到达的贮藏库条目列表："

#. type: delimited block -
#: en/git-stash.txt:386
#, no-wrap, placeholders:'--unreachable':'--merges':'--no-walk':'--grep=WIP', priority:240
msgid ""
"git fsck --unreachable |\n"
"grep commit | cut -d\\  -f3 |\n"
"xargs git log --merges --no-walk --grep=WIP\n"
msgstr ""
"git fsck --unreachable |\n"
"grep commit | cut -d -f3 |\n"
"xargs git log --merges --no-walk --grep=WIP\n"

#. type: Plain text
#: en/git-stash.txt:403
#, ignore-same, priority:240
msgid "linkgit:git-checkout[1], linkgit:git-commit[1], linkgit:git-reflog[1], linkgit:git-reset[1], linkgit:git-switch[1]"
msgstr "linkgit:git-checkout[1], linkgit:git-commit[1], linkgit:git-reflog[1], linkgit:git-reset[1], linkgit:git-switch[1]"

#. type: Title =
#: en/git-status.txt:2
#, ignore-same, no-wrap, priority:280
msgid "git-status(1)"
msgstr "git-status(1)"

#. type: Plain text
#: en/git-status.txt:7
#, placeholders:'git-status', priority:280
msgid "git-status - Show the working tree status"
msgstr "git-status - 显示工作树状态"

#. type: Plain text
#: en/git-status.txt:13
#, ignore-ellipsis, no-wrap, priority:280
msgid "'git status' [<options>] [--] [<pathspec>...]\n"
msgstr "'git status' [<选项>...] [--] [<路径规范>...]\n"

#. type: Plain text
#: en/git-status.txt:23
#, placeholders:'HEAD':'linkgit:gitignore[5]', priority:280
msgid "Displays paths that have differences between the index file and the current HEAD commit, paths that have differences between the working tree and the index file, and paths in the working tree that are not tracked by Git (and are not ignored by linkgit:gitignore[5]). The first are what you _would_ commit by running `git commit`; the second and third are what you _could_ commit by running 'git add' before running `git commit`."
msgstr "显示索引文件和当前HEAD提交有差异的路径，工作树和索引文件有差异的路径，以及工作树中不被Git追踪的路径（也不被linkgit:gitignore[5]忽略）。前者是你通过运行 \"git commit \"会提交的东西；第二和第三者是你在运行 \"git commit \"之前通过运行 \"git add \"可以提交的东西。"

#. type: Plain text
#: en/git-status.txt:30
#, priority:280
msgid "Give the output in the short-format."
msgstr "以简短的形式给出输出。"

#. type: Labeled list
#: en/git-status.txt:35
#, ignore-same, no-wrap, priority:280
msgid "--show-stash"
msgstr "--show-stash"

#. type: Plain text
#: en/git-status.txt:37
#, priority:280
msgid "Show the number of entries currently stashed away."
msgstr "显示目前藏匿的条目数量。"

#. type: Labeled list
#: en/git-status.txt:38
#, no-wrap, placeholders:'--porcelain', priority:280
msgid "--porcelain[=<version>]"
msgstr "--porcelain[=<版本>]"

#. type: Plain text
#: en/git-status.txt:43
#, priority:280
msgid "Give the output in an easy-to-parse format for scripts. This is similar to the short output, but will remain stable across Git versions and regardless of user configuration. See below for details."
msgstr "以易于解析的格式给出脚本的输出。 这类似于简短的输出，但在不同的Git版本中，无论用户配置如何，都会保持稳定。详见下文。"

#. type: Plain text
#: en/git-status.txt:46
#, priority:280
msgid "The version parameter is used to specify the format version. This is optional and defaults to the original version 'v1' format."
msgstr "版本参数用于指定格式版本。 这是可选的，默认为原始版本的 \"v1 \"格式。"

#. type: Plain text
#: en/git-status.txt:49
#, priority:280
msgid "Give the output in the long-format. This is the default."
msgstr "给出长格式的输出。这是默认的。"

#. type: Plain text
#: en/git-status.txt:57
#, placeholders:'--cached`':'`-v`', priority:280
msgid "In addition to the names of files that have been changed, also show the textual changes that are staged to be committed (i.e., like the output of `git diff --cached`). If `-v` is specified twice, then also show the changes in the working tree that have not yet been staged (i.e., like the output of `git diff`)."
msgstr "除了显示被修改的文件名外，还显示被分阶段提交的文本修改（即，像`git diff --cached`的输出）。如果`-v`被指定了两次，那么也会显示工作树中尚未分阶段的变化（即，像`git diff`的输出）。"

#. type: Plain text
#: en/git-status.txt:66
#, priority:280
msgid "The mode parameter is used to specify the handling of untracked files. It is optional: it defaults to 'all', and if specified, it must be stuck to the option (e.g. `-uno`, but not `-u no`)."
msgstr "模式参数用于指定对未跟踪文件的处理。 它是可选的：默认为 \"所有\"，如果指定，必须与选项卡在一起（例如，`-uno`，但不是`-u no`）。"

#. type: Plain text
#: en/git-status.txt:70
#, priority:280
msgid "'no' - Show no untracked files."
msgstr "'no' - 显示未跟踪的文件。"

#. type: Plain text
#: en/git-status.txt:71
#, priority:280
msgid "'normal' - Shows untracked files and directories."
msgstr "'normal' - 显示未被追踪的文件和目录。"

#. type: Plain text
#: en/git-status.txt:82
#, placeholders:'`-u`':'git update-index':'--untracked-cache`':'git update-index':'--split-index`', priority:280
msgid "When `-u` option is not used, untracked files and directories are shown (i.e. the same as specifying `normal`), to help you avoid forgetting to add newly created files. Because it takes extra work to find untracked files in the filesystem, this mode may take some time in a large working tree. Consider enabling untracked cache and split index if supported (see `git update-index --untracked-cache` and `git update-index --split-index`), Otherwise you can use `no` to have `git status` return more quickly without showing untracked files."
msgstr "当不使用`-u`选项时，将显示未跟踪的文件和目录（即与指定`normal`相同），以帮助你避免忘记添加新创建的文件。 因为在文件系统中寻找未跟踪的文件需要额外的工作，在一个大的工作树中，这种模式可能需要一些时间。 如果支持的话，考虑启用无痕缓存和分割索引（见`git update-index --untracked-cache`和`git update-index --split-index`），否则你可以使用`no`来让`git status`更快地返回而不显示无痕文件。"

# ERROR: HEAD not found in translation
#. type: Plain text
#: en/git-status.txt:101
#, placeholders:'HEAD':'linkgit:git-config[1]':'linkgit:gitmodules[5]':'status.submoduleSummary', priority:280
msgid "Ignore changes to submodules when looking for changes. <when> can be either \"none\", \"untracked\", \"dirty\" or \"all\", which is the default. Using \"none\" will consider the submodule modified when it either contains untracked or modified files or its HEAD differs from the commit recorded in the superproject and can be used to override any settings of the 'ignore' option in linkgit:git-config[1] or linkgit:gitmodules[5]. When \"untracked\" is used submodules are not considered dirty when they only contain untracked content (but they are still scanned for modified content). Using \"dirty\" ignores all changes to the work tree of submodules, only changes to the commits stored in the superproject are shown (this was the behavior before 1.7.0). Using \"all\" hides all changes to submodules (and suppresses the output of submodule summaries when the config option `status.submoduleSummary` is set)."
msgstr "在查找更改时忽略子模块的更改。<when> 可以是 \"none\"（无）、\"untracked\"（未跟踪）、\"dirty\"（脏）或 \"all\"（全部），这是默认值。使用 \"none \"时，如果子模块包含未跟踪或已修改的文件，或者其 HEAD 与上层项目中记录的提交不一致，则该子模块将被视为已修改，并可用于覆盖 linkgit:git-config[1] 或 linkgit:gitmodules[5] 中 \"忽略 \"选项的任何设置。当使用 \"untracked \"时，如果子模块只包含未跟踪的内容，则不会被视为 dirty（但仍会扫描修改过的内容）。使用 \"dirty\" 会忽略对子模块工作树的所有修改，只显示对存储在超级项目中的提交的修改（这是 1.7.0 之前的行为）。使用 \"all \"则会隐藏子模块的所有更改（并在设置配置选项 `status.submoduleSummary` 时抑制子模块摘要的输出）。"

#. type: Labeled list
#: en/git-status.txt:102
#, no-wrap, placeholders:'--ignored', priority:280
msgid "--ignored[=<mode>]"
msgstr "--ignored[=<模式>]"

#. type: Plain text
#: en/git-status.txt:104
#, priority:280
msgid "Show ignored files as well."
msgstr "也显示忽略的文件。"

#. type: Plain text
#: en/git-status.txt:108
#, priority:280
msgid "The mode parameter is used to specify the handling of ignored files. It is optional: it defaults to 'traditional'."
msgstr "模式参数用于指定对被忽略文件的处理。 它是可选的：默认为 \"传统\"。"

#. type: Plain text
#: en/git-status.txt:112
#, priority:280
msgid "'traditional' - Shows ignored files and directories, unless"
msgstr "'传统' - 显示被忽略的文件和目录，除非"

#. type: Plain text
#: en/git-status.txt:115
#, no-wrap, placeholders:'--untracked-files=all', priority:280
msgid ""
"--untracked-files=all is specified, in which case\n"
"individual files in ignored directories are\n"
"displayed.\n"
msgstr ""
"如果指定--untracked-files=all，\n"
"则会显示忽略目录中的\n"
"单个文件。\n"

#. type: Plain text
#: en/git-status.txt:116
#, no-wrap, priority:280
msgid "'no'\t        - Show no ignored files.\n"
msgstr "'no' - 不显示被忽略的文件。\n"

#. type: Plain text
#: en/git-status.txt:117
#, no-wrap, priority:280
msgid "'matching'    - Shows ignored files and directories matching an\n"
msgstr "'matching' - 显示忽略的文件和目录，这些文件和目录符合\n"

#. type: Plain text
#: en/git-status.txt:118
#, no-wrap, priority:280
msgid "ignore pattern.\n"
msgstr "无视模式。\n"

#. type: Plain text
#: en/git-status.txt:124
#, priority:280
msgid "When 'matching' mode is specified, paths that explicitly match an ignored pattern are shown. If a directory matches an ignore pattern, then it is shown, but not paths contained in the ignored directory. If a directory does not match an ignore pattern, but all contents are ignored, then the directory is not shown, but all contents are shown."
msgstr "当指定 \"匹配 \"模式时，明确匹配忽略模式的路径会被显示。如果一个目录与忽略模式相匹配，那么它就会被显示，但不显示被忽略目录中包含的路径。如果一个目录不匹配忽略模式，但所有内容都被忽略，那么该目录不被显示，但所有内容被显示。"

#. type: Plain text
#: en/git-status.txt:129
#, placeholders:'`--porcelain=v1`', priority:280
msgid "Terminate entries with NUL, instead of LF. This implies the `--porcelain=v1` output format if no other format is given."
msgstr "用NUL而不是LF来终止条目。 如果没有给出其他格式，这就意味着`--porcelain=v1`的输出格式。"

#. type: Plain text
#: en/git-status.txt:136
#, placeholders:'column.status':'`--column`':'`--no-column`', priority:280
msgid "Display untracked files in columns. See configuration variable `column.status` for option syntax. `--column` and `--no-column` without options are equivalent to 'always' and 'never' respectively."
msgstr "在列中显示未跟踪的文件。选项语法见配置变量`column.status`。`--column`和`--no-column`没有选项，分别相当于'always'和'never'。"

#. type: Labeled list
#: en/git-status.txt:137
#, ignore-same, no-wrap, priority:280
msgid "--ahead-behind"
msgstr "--ahead-behind"

#. type: Labeled list
#: en/git-status.txt:138
#, ignore-same, no-wrap, priority:280
msgid "--no-ahead-behind"
msgstr "--no-ahead-behind"

#. type: Plain text
#: en/git-status.txt:141
#, priority:280
msgid "Display or do not display detailed ahead/behind counts for the branch relative to its upstream branch. Defaults to true."
msgstr "显示或不显示该分支相对于其上游分支的详细超前/滞后计数。 默认为true。"

#. type: Labeled list
#: en/git-status.txt:142
#, ignore-same, no-wrap, priority:280
msgid "--renames"
msgstr "--renames"

#. type: Plain text
#: en/git-status.txt:146
#, placeholders:'linkgit:git-diff[1]':'`--no-renames`', priority:280
msgid "Turn on/off rename detection regardless of user configuration. See also linkgit:git-diff[1] `--no-renames`."
msgstr "开启/关闭重名检测，不受用户配置影响。 参见linkgit:git-diff[1] `--no-renames`。"

#. type: Plain text
#: en/git-status.txt:151
#, placeholders:'linkgit:git-diff[1]':'`--find-renames`', priority:280
msgid "Turn on rename detection, optionally setting the similarity threshold. See also linkgit:git-diff[1] `--find-renames`."
msgstr "开启重名检测，可选择设置相似度阈值。 参见 linkgit:git-diff[1] `--find-renames`。"

#. type: Plain text
#: en/git-status.txt:154
#, placeholders:'linkgit:gitglossary[7]', priority:280
msgid "See the 'pathspec' entry in linkgit:gitglossary[7]."
msgstr "参见 linkgit:gitglossary[7] 中的'pathspec'条目。"

#. type: Plain text
#: en/git-status.txt:162
#, priority:280
msgid "The output from this command is designed to be used as a commit template comment. The default, long format, is designed to be human readable, verbose and descriptive. Its contents and format are subject to change at any time."
msgstr "这个命令的输出是用来作为提交模板注释的。 默认的长篇格式是为了让人可读性强、言简意赅和描述性好。 其内容和格式可以随时更改。"

#. type: Plain text
#: en/git-status.txt:167
#, placeholders:'status.relativePaths', priority:280
msgid "The paths mentioned in the output, unlike many other Git commands, are made relative to the current directory if you are working in a subdirectory (this is on purpose, to help cutting and pasting). See the status.relativePaths config option below."
msgstr "与许多其他 Git 命令不同，如果你在子目录中工作，输出中提到的路径是相对于当前目录的（这是故意的，以帮助剪切和粘贴）。参见下面的 status.relativePaths 配置选项。"

#. type: Title ~
#: en/git-status.txt:169
#, no-wrap, priority:280
msgid "Short Format"
msgstr "简短格式"

#. type: Plain text
#: en/git-status.txt:173
#, priority:280
msgid "In the short-format, the status of each path is shown as one of these forms"
msgstr "在简短的格式中，每个路径的状态显示为以下形式之一"

#. type: Plain text
#: en/git-status.txt:176
#, no-wrap, priority:280
msgid ""
"\tXY PATH\n"
"\tXY ORIG_PATH -> PATH\n"
msgstr ""
"\tXY PATH\n"
"\tXY ORIG_PATH -> PATH\n"

#. type: Plain text
#: en/git-status.txt:180
#, priority:280
msgid "where `ORIG_PATH` is where the renamed/copied contents came from. `ORIG_PATH` is only shown when the entry is renamed or copied. The `XY` is a two-letter status code."
msgstr "其中`ORIG_PATH`是重命名/复制的内容的来源。`ORIG_PATH`只有在条目被重命名或复制时才会显示。`XY`是一个双字母的状态代码。"

#. type: Plain text
#: en/git-status.txt:186
#, priority:280
msgid "The fields (including the `->`) are separated from each other by a single space. If a filename contains whitespace or other nonprintable characters, that field will be quoted in the manner of a C string literal: surrounded by ASCII double quote (34) characters, and with interior special characters backslash-escaped."
msgstr "各个字段（包括`->`）之间用一个空格隔开。如果一个文件名包含空白或其他不可打印的字符，该字段将以C语言字符串字面的方式被引用：由ASCII双引号（34）字符包围，内部的特殊字符被反斜线省略。"

#. type: Plain text
#: en/git-status.txt:189
#, priority:280
msgid "There are three different types of states that are shown using this format, and each one uses the `XY` syntax differently:"
msgstr "有三种不同类型的状态是使用这种格式显示的，每一种都以不同的方式使用 `XY` 语法："

#. type: Plain text
#: en/git-status.txt:191
#, priority:280
msgid "When a merge is occurring and the merge was successful, or outside of a merge"
msgstr "当一个合并正在发生并且合并成功时，或者在合并之外"

#. type: Plain text
#: en/git-status.txt:193
#, priority:280
msgid "situation, `X` shows the status of the index and `Y` shows the status of the working tree."
msgstr "情况，`X`显示索引的状态，`Y`显示工作树的状态。"

#. type: Plain text
#: en/git-status.txt:194
#, priority:280
msgid "When a merge conflict has occurred and has not yet been resolved, `X` and `Y`"
msgstr "当发生合并冲突且尚未解决时，`X` 和 `Y` 就会出现"

#. type: Plain text
#: en/git-status.txt:196
#, priority:280
msgid "show the state introduced by each head of the merge, relative to the common ancestor. These paths are said to be _unmerged_."
msgstr "显示了相对于共同祖先而言，合并的每个头所引入的状态。这些路径被称为_未合并_。"

#. type: Plain text
#: en/git-status.txt:197
#, priority:280
msgid "When a path is untracked, `X` and `Y` are always the same, since they are"
msgstr "当一个路径没有被追踪时，`X`和`Y`总是相同的，因为它们是"

#. type: Plain text
#: en/git-status.txt:200
#, placeholders:'`--ignored`', priority:280
msgid "unknown to the index. `??` is used for untracked paths. Ignored files are not listed unless `--ignored` is used; if it is, ignored files are indicated by `!!`."
msgstr "未知的索引。`??`用于未跟踪的路径。除非使用了`--ignored`，否则不列出被忽略的文件；如果使用了，则用`！！`表示被忽略的文件。"

#. type: Plain text
#: en/git-status.txt:203
#, placeholders:'`--merge`', priority:280
msgid "Note that the term _merge_ here also includes rebases using the default `--merge` strategy, cherry-picks, and anything else using the merge machinery."
msgstr "请注意，这里的_merge_也包括使用默认的`--merge`策略的rebases，cherry-pick，以及其他任何使用merge机制的东西。"

#. type: Plain text
#: en/git-status.txt:207
#, priority:280
msgid "In the following table, these three classes are shown in separate sections, and these characters are used for `X` and `Y` fields for the first two sections that show tracked paths:"
msgstr "在下面的表格中，这三个类别分别显示在不同的部分，这些字符用于显示跟踪路径的前两个部分的 `X` 和 `Y` 字段："

#. type: Plain text
#: en/git-status.txt:209
#, priority:280
msgid "' ' = unmodified"
msgstr "'' = 未修改的"

#. type: Plain text
#: en/git-status.txt:210
#, priority:280
msgid "'M' = modified"
msgstr "'M' = 修改过的"

#. type: Plain text
#: en/git-status.txt:211
#, priority:280
msgid "'T' = file type changed (regular file, symbolic link or submodule)"
msgstr "'T' = 文件类型已更改（常规文件、符号链接或子模块）"

#. type: Plain text
#: en/git-status.txt:212
#, priority:280
msgid "'A' = added"
msgstr "'A'=添加"

#. type: Plain text
#: en/git-status.txt:213
#, priority:280
msgid "'D' = deleted"
msgstr "'D' = 删除"

#. type: Plain text
#: en/git-status.txt:214
#, priority:280
msgid "'R' = renamed"
msgstr "'R' = 重命名"

#. type: Plain text
#: en/git-status.txt:215
#, placeholders:'status.renames', priority:280
msgid "'C' = copied (if config option status.renames is set to \"copies\")"
msgstr "'C' = 已复制（如果配置选项 status.renames 设置为 “副本”）"

#. type: Plain text
#: en/git-status.txt:216
#, priority:280
msgid "'U' = updated but unmerged"
msgstr "'U'=更新但未合并"

#. type: delimited block .
#: en/git-status.txt:245
#, no-wrap, placeholders:'-------------------------------------------------':'-------------------------------------------------':'-------------------------------------------------':'-------------------------------------------------', priority:280
msgid ""
"X          Y     Meaning\n"
"-------------------------------------------------\n"
"\t [AMD]   not updated\n"
"M        [ MTD]  updated in index\n"
"T        [ MTD]  type changed in index\n"
"A        [ MTD]  added to index\n"
"D                deleted from index\n"
"R        [ MTD]  renamed in index\n"
"C        [ MTD]  copied in index\n"
"[MTARC]          index and work tree matches\n"
"[ MTARC]    M    work tree changed since index\n"
"[ MTARC]    T    type changed in work tree since index\n"
"[ MTARC]    D    deleted in work tree\n"
"\t    R    renamed in work tree\n"
"\t    C    copied in work tree\n"
"-------------------------------------------------\n"
"D           D    unmerged, both deleted\n"
"A           U    unmerged, added by us\n"
"U           D    unmerged, deleted by them\n"
"U           A    unmerged, added by them\n"
"D           U    unmerged, deleted by us\n"
"A           A    unmerged, both added\n"
"U           U    unmerged, both modified\n"
"-------------------------------------------------\n"
"?           ?    untracked\n"
"!           !    ignored\n"
"-------------------------------------------------\n"
msgstr ""
"X Y的含义\n"
"-------------------------------------------------\n"
"\t [AMD]未更新\n"
"M [MTD] 在索引中更新\n"
"T [MTD] 类型在索引中有所改变\n"
"A [MTD] 添加到索引中\n"
"D 从索引中删除\n"
"R [MTD] 在索引中重新命名\n"
"C [MTD] 在索引中被复制\n"
"[MTARC] 索引和工作树匹配\n"
"[MTARC] 自索引以来，M工作树发生了变化\n"
"[MTARC] 工作树中的T类型自索引以来发生了变化\n"
"[MTARC] D在工作树中被删除\n"
"\t    R在工作树中重新命名\n"
"\t    C在工作树中被复制\n"
"-------------------------------------------------\n"
"D D未合并，均已删除\n"
"A U 未合并，由我们添加\n"
"U D未合并，被他人删除\n"
"U A 未合并，由他人添加\n"
"D U未合并，被我们删除\n"
"A A未合并，都被添加\n"
"U U未合并，都被修改\n"
"-------------------------------------------------\n"
"?           未被追踪的\n"
"!           忽略不计\n"
"-------------------------------------------------\n"

#. type: Plain text
#: en/git-status.txt:248
#, priority:280
msgid "Submodules have more state and instead report"
msgstr "子模块有更多的状态，而不是报告"

#. type: Plain text
#: en/git-status.txt:250
#, placeholders:'HEAD', priority:280
msgid "'M' = the submodule has a different HEAD than recorded in the index"
msgstr "'M' = 子模块的 HEAD 与索引中记录的不同"

#. type: Plain text
#: en/git-status.txt:251
#, priority:280
msgid "'m' = the submodule has modified content"
msgstr "'m' = 子模块修改了内容"

#. type: Plain text
#: en/git-status.txt:252
#, priority:280
msgid "'?' = the submodule has untracked files"
msgstr "'?' = 子模块有未跟踪文件"

#. type: Plain text
#: en/git-status.txt:255
#, priority:280
msgid "This is since modified content or untracked files in a submodule cannot be added via `git add` in the superproject to prepare a commit."
msgstr "这是因为子模块中已修改的内容或未跟踪的文件无法在超级项目中通过 `git add` 添加，以准备提交。"

#. type: Plain text
#: en/git-status.txt:258
#, priority:280
msgid "'m' and '?' are applied recursively. For example if a nested submodule in a submodule contains an untracked file, this is reported as '?' as well."
msgstr "'m' 和 '?' 是递归应用的。例如，如果一个子模块中的嵌套子模块包含一个未跟踪的文件，这也会报告为 '?'。"

#. type: Plain text
#: en/git-status.txt:260
#, priority:280
msgid "If -b is used the short-format status is preceded by a line"
msgstr "如果使用了-b，短格式的状态前面会有一行"

#. type: Plain text
#: en/git-status.txt:262
#, no-wrap, priority:280
msgid "    ## branchname tracking info\n"
msgstr "    ## 分支名称跟踪信息\n"

#. type: Title ~
#: en/git-status.txt:264
#, no-wrap, priority:280
msgid "Porcelain Format Version 1"
msgstr "瓷器格式版本1"

#. type: Plain text
#: en/git-status.txt:271
#, priority:280
msgid "Version 1 porcelain format is similar to the short format, but is guaranteed not to change in a backwards-incompatible way between Git versions or based on user configuration. This makes it ideal for parsing by scripts. The description of the short format above also describes the porcelain format, with a few exceptions:"
msgstr "第 1 版的上层命令格式与短格式类似，但保证不会在 Git 版本之间以向后兼容的方式或基于用户配置而改变。这使得它成为脚本解析的理想选择。 上面对短格式的描述也是对瓷器格式的描述，但有一些例外："

#. type: Plain text
#: en/git-status.txt:274
#, placeholders:'color.status', priority:280
msgid "The user's color.status configuration is not respected; color will always be off."
msgstr "用户的color.status配置不被尊重，颜色将永远是关闭的。"

#. type: Plain text
#: en/git-status.txt:277
#, placeholders:'status.relativePaths', priority:280
msgid "The user's status.relativePaths configuration is not respected; paths shown will always be relative to the repository root."
msgstr "用户的 status.relativePaths 配置不被尊重；显示的路径将总是相对于版本库根目录。"

#. type: Plain text
#: en/git-status.txt:287
#, priority:280
msgid "There is also an alternate -z format recommended for machine parsing. In that format, the status field is the same, but some other things change. First, the '\\->' is omitted from rename entries and the field order is reversed (e.g 'from \\-> to' becomes 'to from'). Second, a NUL (ASCII 0) follows each filename, replacing space as a field separator and the terminating newline (but a space still separates the status field from the first filename). Third, filenames containing special characters are not specially formatted; no quoting or backslash-escaping is performed."
msgstr "还有一种替代的-z格式，建议用于机器解析。在这种格式中，状态字段是相同的，但其他一些事情发生了变化。 首先，重命名条目中的\"\\->\"被省略，字段顺序被颠倒（例如 \"from\\-> to \"变成 \"to from\"）。第二，每个文件名后面都有一个NUL（ASCII 0），取代空格作为字段分隔符和终止换行符（但空格仍然将状态字段与第一个文件名分开）。 第三，包含特殊字符的文件名不被特别格式化；不进行引号或反斜线escaping。"

#. type: Plain text
#: en/git-status.txt:289
#, priority:280
msgid "Any submodule changes are reported as modified `M` instead of `m` or single `?`."
msgstr "任何子模块的变化都被报告为修改的`M'，而不是`m'或单一的`?'。"

#. type: Title ~
#: en/git-status.txt:291
#, no-wrap, priority:280
msgid "Porcelain Format Version 2"
msgstr "瓷器格式版本2"

#. type: Plain text
#: en/git-status.txt:296
#, priority:280
msgid "Version 2 format adds more detailed information about the state of the worktree and changed items. Version 2 also defines an extensible set of easy to parse optional headers."
msgstr "第二版格式增加了关于工作树的状态和变化的项目的更多详细信息。 第2版还定义了一套可扩展的、易于解析的可选头文件。"

#. type: Plain text
#: en/git-status.txt:300
#, priority:280
msgid "Header lines start with \"#\" and are added in response to specific command line arguments. Parsers should ignore headers they don't recognize."
msgstr "标头行以 \"#\"开头，是为响应特定的命令行参数而添加的。 解析器应该忽略他们不认识的标题。"

#. type: Title ^
#: en/git-status.txt:302
#, no-wrap, priority:280
msgid "Branch Headers"
msgstr "分支机构负责人"

#. type: Plain text
#: en/git-status.txt:306
#, placeholders:'`--branch`', priority:280
msgid "If `--branch` is given, a series of header lines are printed with information about the current branch."
msgstr "如果给了`--branch`，就会打印出一系列标题行，其中有关于当前分支的信息。"

#. type: delimited block .
#: en/git-status.txt:316
#, no-wrap, placeholders:'------------------------------------------------------------':'branch.oid':'branch.head':'branch.upstream':'branch.ab':'------------------------------------------------------------', priority:280
msgid ""
"Line                                     Notes\n"
"------------------------------------------------------------\n"
"# branch.oid <commit> | (initial)        Current commit.\n"
"# branch.head <branch> | (detached)      Current branch.\n"
"# branch.upstream <upstream-branch>      If upstream is set.\n"
"# branch.ab +<ahead> -<behind>           If upstream is set and\n"
"\t\t\t\t\t the commit is present.\n"
"------------------------------------------------------------\n"
msgstr ""
"线路说明\n"
"------------------------------------------------------------\n"
"# branch.oid <commit> | (初始) 当前的提交。\n"
"# branch.head <branch> | (detached) 当前分支。\n"
"# branch.upstream <upstream_branch> 如果upstream被设置。\n"
"# branch.ab +<ahead> -<behind> 如果上游被设置且\n"
"\t\t\t\t\t 的提交是存在的。\n"
"------------------------------------------------------------\n"

#. type: Title ^
#: en/git-status.txt:319
#, no-wrap, priority:280
msgid "Stash Information"
msgstr "暂存信息"

#. type: Plain text
#: en/git-status.txt:323
#, placeholders:'`--show-stash`', priority:280
msgid "If `--show-stash` is given, one line is printed showing the number of stash entries if non-zero:"
msgstr "如果给出了 `--show-stash`，则打印一行，如果非零，则显示暂存条目的数量："

#. type: Plain text
#: en/git-status.txt:325
#, no-wrap, priority:280
msgid "    # stash <N>\n"
msgstr "    # 暂存 <N>\n"

#. type: Title ^
#: en/git-status.txt:327
#, no-wrap, priority:280
msgid "Changed Tracked Entries"
msgstr "变更后的跟踪条目"

#. type: Plain text
#: en/git-status.txt:334
#, priority:280
msgid "Following the headers, a series of lines are printed for tracked entries. One of three different line formats may be used to describe an entry depending on the type of change. Tracked entries are printed in an undefined order; parsers should allow for a mixture of the 3 line types in any order."
msgstr "在页眉之后，一系列的行被打印出来，用于追踪条目。 根据变化的类型，三种不同的行格式之一可用于描述一个条目。 追踪条目是以未定义的顺序打印的；解析器应允许以任何顺序混合使用这三种行类型。"

#. type: Plain text
#: en/git-status.txt:336
#, priority:280
msgid "Ordinary changed entries have the following format:"
msgstr "普通更改的条目有以下格式："

#. type: Plain text
#: en/git-status.txt:338
#, no-wrap, priority:280
msgid "    1 <XY> <sub> <mH> <mI> <mW> <hH> <hI> <path>\n"
msgstr "    1 <XY> <sub> <mH> <mI> <mW> <hH> <hI> <路径>\n"

#. type: Plain text
#: en/git-status.txt:340
#, priority:280
msgid "Renamed or copied entries have the following format:"
msgstr "重命名或复制的条目有以下格式："

#. type: Plain text
#: en/git-status.txt:342
#, no-wrap, priority:280
msgid "    2 <XY> <sub> <mH> <mI> <mW> <hH> <hI> <X><score> <path><sep><origPath>\n"
msgstr "    2 <XY> <sub> <mH> <mI> <mW> <hH> <hI> <X><score> <path><sep><origPath>\n"

#. type: delimited block .
#: en/git-status.txt:373
#, ignore-ellipsis, no-wrap, placeholders:'--------------------------------------------------------':'HEAD':'HEAD':'`-z`':'HEAD':'--------------------------------------------------------', priority:280
msgid ""
"Field       Meaning\n"
"--------------------------------------------------------\n"
"<XY>        A 2 character field containing the staged and\n"
"\t    unstaged XY values described in the short format,\n"
"\t    with unchanged indicated by a \".\" rather than\n"
"\t    a space.\n"
"<sub>       A 4 character field describing the submodule state.\n"
"\t    \"N...\" when the entry is not a submodule.\n"
"\t    \"S<c><m><u>\" when the entry is a submodule.\n"
"\t    <c> is \"C\" if the commit changed; otherwise \".\".\n"
"\t    <m> is \"M\" if it has tracked changes; otherwise \".\".\n"
"\t    <u> is \"U\" if there are untracked changes; otherwise \".\".\n"
"<mH>        The octal file mode in HEAD.\n"
"<mI>        The octal file mode in the index.\n"
"<mW>        The octal file mode in the worktree.\n"
"<hH>        The object name in HEAD.\n"
"<hI>        The object name in the index.\n"
"<X><score>  The rename or copy score (denoting the percentage\n"
"\t    of similarity between the source and target of the\n"
"\t    move or copy). For example \"R100\" or \"C75\".\n"
"<path>      The pathname.  In a renamed/copied entry, this\n"
"\t    is the target path.\n"
"<sep>       When the `-z` option is used, the 2 pathnames are separated\n"
"\t    with a NUL (ASCII 0x00) byte; otherwise, a tab (ASCII 0x09)\n"
"\t    byte separates them.\n"
"<origPath>  The pathname in the commit at HEAD or in the index.\n"
"\t    This is only present in a renamed/copied entry, and\n"
"\t    tells where the renamed/copied contents came from.\n"
"--------------------------------------------------------\n"
msgstr ""
"领域含义\n"
"--------------------------------------------------------\n"
"<XY> 一个2个字符的字段，包含短格式中描述的阶段性和非阶段性XY值。\n"
"\t    阶段性和非阶段性的XY值。\n"
"\t    不变的用\". \"表示，而不是用空格。\n"
"\t    而不是空格。\n"
"<sub> 一个4个字符的字段，描述子模块的状态。\n"
"\t    \"N... \"当条目不是一个子模块时。\n"
"\t    \"S<c><m><u>\" 当条目是一个子模块。\n"
"\t    <c>是 \"C\"，如果提交改变了；否则是\".\"。\n"
"\t    <m> 如果它有跟踪的变化，则为 \"M\"；否则为\".\"。\n"
"\t    <u> 如果有未追踪的修改，则为 \"U\"；否则为\".\"。\n"
"<mH> HEAD中的八进制文件模式。\n"
"<mI> 索引中的八进制文件模式。\n"
"<mW> 工作树中的八进制文件模式。\n"
"<hH> HEAD中的对象名称。\n"
"<hI> 索引中的对象名称。\n"
"<X><score> 重命名或复制分数（表示源文件和目标文件之间的相似百分比）。\n"
"\t    源和目标之间的相似度）。\n"
"\t    移动或复制的目标之间的相似度）。)例如，\"R100 \"或 \"C75\"。\n"
"<path> 路径名。  在一个重命名/复制的条目中，这\n"
"\t    是目标路径。\n"
"<sep> 当使用`-z`选项时，两个路径名用NUL(ASCII 0x00)分隔。\n"
"\t    用一个NUL(ASCII 0x00)字节分开；否则，用一个TAB(ASCII 0x09)\n"
"\t    字节来分隔它们。\n"
"<origPath> 在HEAD或索引中提交的路径名。\n"
"\t    这只存在于重命名/复制的条目中，并且\n"
"\t    告诉你重命名/复制的内容来自哪里。\n"
"--------------------------------------------------------\n"

#. type: Plain text
#: en/git-status.txt:377
#, priority:280
msgid "Unmerged entries have the following format; the first character is a \"u\" to distinguish from ordinary changed entries."
msgstr "未合并的条目有以下格式；第一个字符是 \"u\"，以区别于普通的变更条目。"

#. type: Plain text
#: en/git-status.txt:379
#, no-wrap, priority:280
msgid "    u <XY> <sub> <m1> <m2> <m3> <mW> <h1> <h2> <h3> <path>\n"
msgstr "    u <xy> <sub> <m1> <m2> <m3> <mW> <h1> <h2> <h3> <路径>\n"

#. type: delimited block .
#: en/git-status.txt:396
#, no-wrap, placeholders:'--------------------------------------------------------':'--------------------------------------------------------', priority:280
msgid ""
"Field       Meaning\n"
"--------------------------------------------------------\n"
"<XY>        A 2 character field describing the conflict type\n"
"\t    as described in the short format.\n"
"<sub>       A 4 character field describing the submodule state\n"
"\t    as described above.\n"
"<m1>        The octal file mode in stage 1.\n"
"<m2>        The octal file mode in stage 2.\n"
"<m3>        The octal file mode in stage 3.\n"
"<mW>        The octal file mode in the worktree.\n"
"<h1>        The object name in stage 1.\n"
"<h2>        The object name in stage 2.\n"
"<h3>        The object name in stage 3.\n"
"<path>      The pathname.\n"
"--------------------------------------------------------\n"
msgstr ""
"领域含义\n"
"--------------------------------------------------------\n"
"<XY> 一个2个字符的字段，描述冲突类型\n"
"\t    描述冲突类型。\n"
"<sub> 一个4个字符的字段，描述子模块的状态\n"
"\t    如上所述。\n"
"<m1> 阶段1中的八进制文件模式。\n"
"<m2> 阶段2中的八进制文件模式。\n"
"<m3> 阶段3中的八进制文件模式。\n"
"<mW> 工作树中的八进制文件模式。\n"
"<h1> 阶段1中的对象名称。\n"
"<h2> 第二阶段的对象名称。\n"
"<h3> 第三阶段的对象名称。\n"
"<path> 路径名。\n"
"--------------------------------------------------------\n"

#. type: Title ^
#: en/git-status.txt:399
#, no-wrap, priority:280
msgid "Other Items"
msgstr "其他项目"

#. type: Plain text
#: en/git-status.txt:404
#, priority:280
msgid "Following the tracked entries (and if requested), a series of lines will be printed for untracked and then ignored items found in the worktree."
msgstr "在跟踪的条目之后（如果要求的话），将打印一系列未跟踪的行，然后是在工作树中发现的忽略的条目。"

#. type: Plain text
#: en/git-status.txt:406
#, priority:280
msgid "Untracked items have the following format:"
msgstr "未跟踪的项目有以下格式："

#. type: Plain text
#: en/git-status.txt:408
#, no-wrap, priority:280
msgid "    ? <path>\n"
msgstr "    ?<路径>\n"

#. type: Plain text
#: en/git-status.txt:410
#, priority:280
msgid "Ignored items have the following format:"
msgstr "被忽略的项目有以下格式："

#. type: Plain text
#: en/git-status.txt:412
#, no-wrap, priority:280
msgid "    ! <path>\n"
msgstr "    !<路径>的情况下\n"

#. type: Title ^
#: en/git-status.txt:414
#, no-wrap, priority:280
msgid "Pathname Format Notes and -z"
msgstr "路径名格式说明和-z"

# ERROR: `-z` not found in translation
#. type: Plain text
#: en/git-status.txt:419
#, placeholders:'`-z`', priority:280
msgid "When the `-z` option is given, pathnames are printed as is and without any quoting and lines are terminated with a NUL (ASCII 0x00) byte."
msgstr "当给定 `-z` 选项时，路径名将按原样打印，没有任何引号，并且以NUL（ASCII 0x00）字节结束行。"

#. type: Plain text
#: en/git-status.txt:423
#, placeholders:'`-z`':'core.quotePath':'linkgit:git-config[1]', priority:280
msgid "Without the `-z` option, pathnames with \"unusual\" characters are quoted as explained for the configuration variable `core.quotePath` (see linkgit:git-config[1])."
msgstr "如果没有`-z`选项，带有 \"不寻常 \"字符的路径名将被引用，正如对配置变量`core.quotePath`的解释（见linkgit:git-config[1]）。"

#. type: Plain text
#: en/git-status.txt:432
#, placeholders:'color.status':'status.color':'color.status', priority:280
msgid "The command honors `color.status` (or `status.color` -- they mean the same thing and the latter is kept for backward compatibility) and `color.status.<slot>` configuration variables to colorize its output."
msgstr "该命令使用`color.status`（或`status.color`--它们的意思是一样的，为了向后兼容，保留后者）和`color.status.<slot>`配置变量来为其输出着色。"

#. type: Plain text
#: en/git-status.txt:436
#, placeholders:'status.relativePaths', priority:280
msgid "If the config variable `status.relativePaths` is set to false, then all paths shown are relative to the repository root, not to the current directory."
msgstr "如果配置变量`status.relativePaths`被设置为false，那么所有显示的路径都是相对于版本库根目录的，而不是当前目录。"

#. type: Plain text
#: en/git-status.txt:447
#, placeholders:'status.submoduleSummary':'--summary-limit':'linkgit:git-submodule[1]':'diff.ignoreSubmodules':'--ignore-submodules=dirty', priority:280
msgid "If `status.submoduleSummary` is set to a non zero number or true (identical to -1 or an unlimited number), the submodule summary will be enabled for the long format and a summary of commits for modified submodules will be shown (see --summary-limit option of linkgit:git-submodule[1]). Please note that the summary output from the status command will be suppressed for all submodules when `diff.ignoreSubmodules` is set to 'all' or only for those submodules where `submodule.<name>.ignore=all`. To also view the summary for ignored submodules you can either use the --ignore-submodules=dirty command line option or the 'git submodule summary' command, which shows a similar output but does not honor these settings."
msgstr "如果`status.submoduleSummary`被设置为一个非零的数字或true（与-1或无限制的数字相同），子模块摘要将启用长格式，并显示修改的子模块的提交摘要（见linkgit:git-submodule[1]的--summary-limit选项）。请注意，当`diff.ignoreSubmodules`被设置为'all'或仅为那些`submodule.<name>.ignore=all'的子模块，状态命令的摘要输出将被抑制。要查看被忽略的子模块的摘要，你可以使用 --ignore-submodules=dirty 命令行选项或 \"git submodule summary \"命令，它显示类似的输出，但不尊重这些设置。"

#. type: Title -
#: en/git-status.txt:449
#, no-wrap, priority:280
msgid "BACKGROUND REFRESH"
msgstr "背景刷新"

#. type: Plain text
#: en/git-status.txt:460
#, placeholders:'--no-optional-locks':'linkgit:git[1]', priority:280
msgid "By default, `git status` will automatically refresh the index, updating the cached stat information from the working tree and writing out the result. Writing out the updated index is an optimization that isn't strictly necessary (`status` computes the values for itself, but writing them out is just to save subsequent programs from repeating our computation). When `status` is run in the background, the lock held during the write may conflict with other simultaneous processes, causing them to fail. Scripts running `status` in the background should consider using `git --no-optional-locks status` (see linkgit:git[1] for details)."
msgstr "默认情况下，`git status`会自动刷新索引，更新工作树上缓存的状态信息，并将结果写出来。写出更新的索引是一种优化，严格来说并无必要（`status`为自己计算数值，但写出它们只是为了避免后续程序重复我们的计算）。当`status`在后台运行时，在写入过程中持有的锁可能与其他同时进行的进程发生冲突，导致它们失败。在后台运行`status`的脚本应该考虑使用`git --no-optional-locks status`（详见linkgit:git[1]）。"

#. type: Title -
#: en/git-status.txt:462
#, no-wrap, priority:280
msgid "UNTRACKED FILES AND PERFORMANCE"
msgstr "未跟踪的文件和性能"

#. type: Plain text
#: en/git-status.txt:473
#, priority:280
msgid "`git status` can be very slow in large worktrees if/when it needs to search for untracked files and directories. There are many configuration options available to speed this up by either avoiding the work or making use of cached results from previous Git commands. There is no single optimum set of settings right for everyone. We'll list a summary of the relevant options to help you, but before going into the list, you may want to run `git status` again, because your configuration may already be caching `git status` results, so it could be faster on subsequent runs."
msgstr "`git status`在大型工作树中，如果/当它需要搜索未被追踪的文件和目录时，速度会非常慢。有许多配置选项可以通过避免这种操作或是利用以前的 Git 命令的缓存结果来加快速度。但是没有一套适合所有人的最佳设置。我们将列出相关选项的摘要以帮助你，但在进入列表之前，你可能想再次运行`git status`，因为你的配置可能已经缓存了`git status`的结果，所以在随后的运行中可能会更快。"

#. type: Plain text
#: en/git-status.txt:475
#, placeholders:'`--untracked-files=no`', priority:280
msgid "The `--untracked-files=no` flag or the"
msgstr "`--untracked-files=no` 标志或"

#. type: Plain text
#: en/git-status.txt:480
#, placeholders:'status.showUntrackedfiles', priority:280
msgid "`status.showUntrackedfiles=false` config (see above for both): indicate that `git status` should not report untracked files. This is the fastest option. `git status` will not list the untracked files, so you need to be careful to remember if you create any new files and manually `git add` them."
msgstr "设置`status.showUntrackedfiles=false`：表示`git status`不应该报告未跟踪的文件。这是最快的选项。`git status`不会列出未跟踪的文件，所以你得注意，在创建任何新的文件后，需要手动`git add`它们。"

#. type: Plain text
#: en/git-status.txt:482
#, placeholders:'advice.statusUoption':'linkgit:git-config[1]', priority:280
msgid "`advice.statusUoption=false` (see linkgit:git-config[1]):"
msgstr "`advice.statusUoption=false`（见linkgit:git-config[1]）："

#. type: Plain text
#: en/git-status.txt:489
#, priority:280
msgid "setting this variable to `false` disables the warning message given when enumerating untracked files takes more than 2 seconds. In a large project, it may take longer and the user may have already accepted the trade off (e.g. using \"-uno\" may not be an acceptable option for the user), in which case, there is no point issuing the warning message, and in such a case, disabling the warning may be the best."
msgstr "将此变量设置为 \"false\"，当列举未跟踪的文件需要超过2秒时，将禁用警告信息。 在一个大型项目中，可能需要更长的时间，而且用户可能已经接受了这种设置（例如，使用\"-uno\"可能不是用户可以接受的选项）。在这种情况下，发出警告信息没有意义，禁用警告可能是最好的。"

#. type: Plain text
#: en/git-status.txt:491
#, placeholders:'core.untrackedCache':'linkgit:git-update-index[1]', priority:280
msgid "`core.untrackedCache=true` (see linkgit:git-update-index[1]):"
msgstr "`core.untrackedCache=true`（参见 linkgit:git-update-index[1]）："

#. type: Plain text
#: en/git-status.txt:503
#, priority:280
msgid "enable the untracked cache feature and only search directories that have been modified since the previous `git status` command. Git remembers the set of untracked files within each directory and assumes that if a directory has not been modified, then the set of untracked files within has not changed. This is much faster than enumerating the contents of every directory, but still not without cost, because Git still has to search for the set of modified directories. The untracked cache is stored in the `.git/index` file. The reduced cost of searching for untracked files is offset slightly by the increased size of the index and the cost of keeping it up-to-date. That reduced search time is usually worth the additional size."
msgstr "启用未跟踪缓存功能，只搜索自上一个 `git status` 命令以来修改过的目录。 Git 会记住每个目录中的未跟踪文件集，并假定如果目录未被修改，则其中的未跟踪文件集不会更改。这比枚举每个目录的内容要快得多，但这依然有代价，因为 Git 仍然需要搜索修改目录的集合。未跟踪的缓存存储在 .git/index 文件中。搜索未跟踪文件的成本降低被索引大小的增加和保持最新的成本所抵消。缩短的搜索时间通常值得新增额外的大小。"

#. type: Plain text
#: en/git-status.txt:505
#, placeholders:'core.untrackedCache':'core.fsmonitor', priority:280
msgid "`core.untrackedCache=true` and `core.fsmonitor=true` or"
msgstr "`core.untrackedCache=true`和`core.fsmonitor=true`或"

#. type: Plain text
#: en/git-status.txt:515
#, placeholders:'core.fsmonitor':'linkgit:git-update-index[1]', priority:280
msgid "`core.fsmonitor=<hook-command-pathname>` (see linkgit:git-update-index[1]): enable both the untracked cache and FSMonitor features and only search directories that have been modified since the previous `git status` command. This is faster than using just the untracked cache alone because Git can also avoid searching for modified directories. Git only has to enumerate the exact set of directories that have changed recently. While the FSMonitor feature can be enabled without the untracked cache, the benefits are greatly reduced in that case."
msgstr "`core.fsmonitor=<hook_command_pathname>`（见linkgit:git-update-index[1]）：同时启用无痕缓存和FSMonitor功能，只搜索自上一条`git status'命令以来被修改的目录。 这比单独使用无痕缓存要快，因为Git也可以避免搜索被修改的目录。 Git只需要列举出最近有变化的确切目录集。虽然FSMonitor功能可以在没有无痕缓存的情况下启用，但在这种情况下好处会大大减少。"

#. type: Plain text
#: en/git-status.txt:520
#, priority:280
msgid "Note that after you turn on the untracked cache and/or FSMonitor features it may take a few `git status` commands for the various caches to warm up before you see improved command times. This is normal."
msgstr "请注意，在你打开无痕缓存和/或FSMonitor功能后，可能需要几个`git status'命令来让各种缓存活动起来，然后你才能看到命令耗时的改善，这很正常。"

#. type: Title =
#: en/git-stripspace.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-stripspace(1)"
msgstr "git-stripspace(1)"

#. type: Plain text
#: en/git-stripspace.txt:7
#, placeholders:'git-stripspace', priority:100
msgid "git-stripspace - Remove unnecessary whitespace"
msgstr "git-stripspace - 去除不必要的空白"

#. type: Plain text
#: en/git-stripspace.txt:14
#, no-wrap, placeholders:'--strip-comments]':'--comment-lines]', priority:100
msgid ""
"'git stripspace' [-s | --strip-comments]\n"
"'git stripspace' [-c | --comment-lines]\n"
msgstr ""
"'git stripspace' [-s | --strip-comments]\n"
"'git stripspace' [-c | --comment-lines]\n"

#. type: Plain text
#: en/git-stripspace.txt:21
#, priority:100
msgid "Read text, such as commit messages, notes, tags and branch descriptions, from the standard input and clean it in the manner used by Git."
msgstr "从标准输入中读取文本，如提交信息、注释、标签和分支描述，并按照 Git 使用的方式进行清理。"

#. type: Plain text
#: en/git-stripspace.txt:23
#, priority:100
msgid "With no arguments, this will:"
msgstr "如果没有任何参数，就会这样："

#. type: Plain text
#: en/git-stripspace.txt:25
#, priority:100
msgid "remove trailing whitespace from all lines"
msgstr "删除所有行的尾部空白"

#. type: Plain text
#: en/git-stripspace.txt:26
#, priority:100
msgid "collapse multiple consecutive empty lines into one empty line"
msgstr "将多个连续空行折叠为一个空行"

#. type: Plain text
#: en/git-stripspace.txt:27
#, priority:100
msgid "remove empty lines from the beginning and end of the input"
msgstr "删除输入内容开头和结尾的空行"

#. type: Plain text
#: en/git-stripspace.txt:28
#, priority:100
msgid "add a missing '\\n' to the last line if necessary."
msgstr "如有必要，在最后一行添加一个缺失的 '\\n'。"

#. type: Plain text
#: en/git-stripspace.txt:31
#, priority:100
msgid "In the case where the input consists entirely of whitespace characters, no output will be produced."
msgstr "如果输入完全由空白字符组成，则不会产生任何输出。"

# ERROR: linkgit:git-apply[1] not found in translation
#. type: Plain text
#: en/git-stripspace.txt:35
#, placeholders:'`--whitespace=fix`':'linkgit:git-apply[1]', priority:100
msgid "*NOTE*: This is intended for cleaning metadata. Prefer the `--whitespace=fix` mode of linkgit:git-apply[1] for correcting whitespace of patches or files in the repository."
msgstr "*注意*： 这是用来清理元数据的，请优先使用 linkgit:git-apply[1] 中的 `--whitespace=fix` 模式来修正补丁或文件中的空白。"

#. type: Labeled list
#: en/git-stripspace.txt:39
#, ignore-same, no-wrap, priority:100
msgid "--strip-comments"
msgstr "--strip-comments"

#. type: Plain text
#: en/git-stripspace.txt:41
#, priority:100
msgid "Skip and remove all lines starting with a comment character (default '#')."
msgstr "跳过并删除所有以注释字符（默认为 \"#\"）开头的行。"

#. type: Labeled list
#: en/git-stripspace.txt:43
#, ignore-same, no-wrap, priority:100
msgid "--comment-lines"
msgstr "--comment-lines"

#. type: Plain text
#: en/git-stripspace.txt:47
#, priority:100
msgid "Prepend the comment character and a blank space to each line. Lines will automatically be terminated with a newline. On empty lines, only the comment character will be prepended."
msgstr "在每行前添加注释字符和空白。行将自动以换行符结束。对于空行，只会预置注释字符。"

#. type: Plain text
#: en/git-stripspace.txt:52
#, priority:100
msgid "Given the following noisy input with '$' indicating the end of a line:"
msgstr "给定以下噪音输入，'$' 表示一行的结束："

#. type: delimited block -
#: en/git-stripspace.txt:65
#, no-wrap, priority:100
msgid ""
"|A brief introduction   $\n"
"|   $\n"
"|$\n"
"|A new paragraph$\n"
"|# with a commented-out line    $\n"
"|explaining lots of stuff.$\n"
"|$\n"
"|# An old paragraph, also commented-out. $\n"
"|      $\n"
"|The end.$\n"
"|  $\n"
msgstr ""
"|A brief introduction   $\n"
"|   $\n"
"|$\n"
"|A new paragraph$\n"
"|# 带有注释的一行 $\n"
"|explaining lots of stuff.$\n"
"|$\n"
"|# 旧的一段，也被注释掉了。$\n"
"|      $\n"
"|The end.$\n"
"|  $\n"

#. type: Plain text
#: en/git-stripspace.txt:68
#, priority:100
msgid "Use 'git stripspace' with no arguments to obtain:"
msgstr "使用不带参数的 'git stripspace' 获取："

#. type: delimited block -
#: en/git-stripspace.txt:79
#, no-wrap, priority:100
msgid ""
"|A brief introduction$\n"
"|$\n"
"|A new paragraph$\n"
"|# with a commented-out line$\n"
"|explaining lots of stuff.$\n"
"|$\n"
"|# An old paragraph, also commented-out.$\n"
"|$\n"
"|The end.$\n"
msgstr ""
"|A brief introduction$\n"
"|$\n"
"|A new paragraph$\n"
"|# 带注释行$\n"
"|explaining lots of stuff.$\n"
"|$\n"
"|# 旧段落，也已注释。$\n"
"|$\n"
"|The end.$\n"

#. type: Plain text
#: en/git-stripspace.txt:82
#, placeholders:'--strip-comments', priority:100
msgid "Use 'git stripspace --strip-comments' to obtain:"
msgstr "使用 'git stripspace --strip-comments' 获取："

#. type: delimited block -
#: en/git-stripspace.txt:90
#, no-wrap, priority:100
msgid ""
"|A brief introduction$\n"
"|$\n"
"|A new paragraph$\n"
"|explaining lots of stuff.$\n"
"|$\n"
"|The end.$\n"
msgstr ""
"|A brief introduction$\n"
"|$\n"
"|A new paragraph$\n"
"|explaining lots of stuff.$\n"
"|$\n"
"|The end.$\n"

#. type: Title =
#: en/git-submodule.txt:2
#, ignore-same, no-wrap, priority:220
msgid "git-submodule(1)"
msgstr "git-submodule(1)"

#. type: Plain text
#: en/git-submodule.txt:7
#, placeholders:'git-submodule', priority:220
msgid "git-submodule - Initialize, update or inspect submodules"
msgstr "git-submodule - 初始化、更新或检查子模块"

#. type: Plain text
#: en/git-submodule.txt:24
#, ignore-ellipsis, no-wrap, placeholders:'[--quiet]':'[--cached]':'[--quiet]':'[--quiet]':'[--cached]':'[--recursive]':'[--quiet]':'[--quiet]':'--force]':'--all':'[--quiet]':'[--quiet]':'[--quiet]':'[--quiet]':'[--quiet]':'[--recursive]':'[--quiet]':'[--recursive]':'[--quiet]', priority:220
msgid ""
"'git submodule' [--quiet] [--cached]\n"
"'git submodule' [--quiet] add [<options>] [--] <repository> [<path>]\n"
"'git submodule' [--quiet] status [--cached] [--recursive] [--] [<path>...]\n"
"'git submodule' [--quiet] init [--] [<path>...]\n"
"'git submodule' [--quiet] deinit [-f|--force] (--all|[--] <path>...)\n"
"'git submodule' [--quiet] update [<options>] [--] [<path>...]\n"
"'git submodule' [--quiet] set-branch [<options>] [--] <path>\n"
"'git submodule' [--quiet] set-url [--] <path> <newurl>\n"
"'git submodule' [--quiet] summary [<options>] [--] [<path>...]\n"
"'git submodule' [--quiet] foreach [--recursive] <command>\n"
"'git submodule' [--quiet] sync [--recursive] [--] [<path>...]\n"
"'git submodule' [--quiet] absorbgitdirs [--] [<path>...]\n"
msgstr ""
"'git submodule' [--quiet] [--cached]\n"
"'git submodule' [--quiet] add [<单/多个选项>] [--] <仓库> [<路径>]\n"
"'git submodule' [--quiet] status [--cached] [--recursive] [--] [<路径>...]\n"
"'git submodule' [--quiet] init [--] [<路径>...]\n"
"'git submodule' [--quiet] deinit [-f|--force] (--all|[--] <路径>...)\n"
"'git submodule' [--quiet] update [<单/多个选项>] [--] [<路径>...]\n"
"'git submodule' [--quiet] set-branch [<单/多个选项>] [--] <路径>\n"
"'git submodule' [--quiet] set-url [--] <路径> <newurl>\n"
"'git submodule' [--quiet] summary [<单/多个选项>] [--] [<路径>...]\n"
"'git submodule' [--quiet] foreach [--recursive] <命令>\n"
"'git submodule' [--quiet] sync [--recursive] [--] [<路径>...]\n"
"'git submodule' [--quiet] absorbgitdirs [--] [<路径>...]\n"

#. type: Plain text
#: en/git-submodule.txt:29
#, priority:220
msgid "Inspects, updates and manages submodules."
msgstr "检查、更新和管理子模块。"

#. type: Plain text
#: en/git-submodule.txt:31
#, placeholders:'linkgit:gitsubmodules[7]', priority:220
msgid "For more information about submodules, see linkgit:gitsubmodules[7]."
msgstr "关于子模块的更多信息，见 linkgit:gitsubmodules[7]。"

#. type: Plain text
#: en/git-submodule.txt:36
#, priority:220
msgid "With no arguments, shows the status of existing submodules. Several subcommands are available to perform operations on the submodules."
msgstr "没有参数，显示现有子模块的状态。 有几个子命令可用于对子模块进行操作。"

#. type: Labeled list
#: en/git-submodule.txt:37
#, no-wrap, placeholders:'--force]':'[--name':'[--reference':'[--depth', priority:220
msgid "add [-b <branch>] [-f|--force] [--name <name>] [--reference <repository>] [--depth <depth>] [--] <repository> [<path>]"
msgstr "add [-b <分支>] [-f|--force] [--name <名称>] [--reference <仓库>] [--depth <深度>] [--] <仓库> [<路径>]"

#. type: Plain text
#: en/git-submodule.txt:41
#, priority:220
msgid "Add the given repository as a submodule at the given path to the changeset to be committed next to the current project: the current project is termed the \"superproject\"."
msgstr "将给定的版本库作为子模块在给定的路径上添加到当前项目旁边要提交的变更集：当前项目被称为 \"父项目\"。"

#. type: Plain text
#: en/git-submodule.txt:50
#, placeholders:'foo.git':'bar.git':'foo.git':'foo.git', priority:220
msgid "<repository> is the URL of the new submodule's origin repository. This may be either an absolute URL, or (if it begins with ./ or ../), the location relative to the superproject's default remote repository (Please note that to specify a repository 'foo.git' which is located right next to a superproject 'bar.git', you'll have to use `../foo.git` instead of `./foo.git` - as one might expect when following the rules for relative URLs - because the evaluation of relative URLs in Git is identical to that of relative directories)."
msgstr "<仓库> 是新子模块仓库的 URL。 这可以是一个绝对 URL，或者（如果它以 ./ 或 ../ 开头），相对于父项目的默认远程仓库的位置（请注意，要指定一个紧挨着父项目 'bar.git' 的仓库 'foo.git'，你必须使用 `../foo.git` 而不是 `./foo.git` 正如人们在遵循相对 URL 的规则时可能期望的那样，因为 Git 中相对 URLs 的解释与相对目录是一样的）。"

#. type: Plain text
#: en/git-submodule.txt:57
#, placeholders:'HEAD', priority:220
msgid "The default remote is the remote of the remote-tracking branch of the current branch. If no such remote-tracking branch exists or the HEAD is detached, \"origin\" is assumed to be the default remote. If the superproject doesn't have a default remote configured the superproject is its own authoritative upstream and the current working directory is used instead."
msgstr "默认的远程是当前分支的远程跟踪分支的远程。如果没有这样的远程跟踪分支，或者 HEAD 被分离了，\"origin\" 就会被假定为默认远程。 如果父项目没有配置默认的远程，那么父项目就是它自己的权威上游，并使用当前工作目录代替。"

#. type: Plain text
#: en/git-submodule.txt:66
#, placeholders:'`--name`', priority:220
msgid "The optional argument <path> is the relative location for the cloned submodule to exist in the superproject. If <path> is not given, the canonical part of the source repository is used (\"repo\" for \"/path/to/repo.git\" and \"foo\" for \"host.xz:foo/.git\"). If <path> exists and is already a valid Git repository, then it is staged for commit without cloning. The <path> is also used as the submodule's logical name in its configuration entries unless `--name` is used to specify a logical name."
msgstr "可选参数 <路径> 是克隆的子模块在父项目中存在的相对位置。如果没有给出 <路径>，则使用源仓库的规范部分（\"repo\" 表示 \"/path/to/repo.git\"，\"foo\" 表示 \"host.xz:foo/.git\"）。如果 <路径> 存在并且已经是一个有效的 Git 仓库，那么它将被暂存提交，而无需克隆。<路径> 也被用作子模块在其配置项中的逻辑名称，除非用 `--name` 来指定一个逻辑名称。"

#. type: Plain text
#: en/git-submodule.txt:74
#, placeholders:'git-submodule', priority:220
msgid "The given URL is recorded into `.gitmodules` for use by subsequent users cloning the superproject. If the URL is given relative to the superproject's repository, the presumption is the superproject and submodule repositories will be kept together in the same relative location, and only the superproject's URL needs to be provided. git-submodule will correctly locate the submodule using the relative URL in `.gitmodules`."
msgstr "给定的 URL 被记录到 `.gitmodules` 中，供后续用户克隆父项目时使用。如果 URL 是相对于父项目的仓库给出的，则假定父项目和子模块仓库将被保存在同一相对位置，只需要提供父项目的URL。git-submodule 将使用 `.gitmodules` 中的相对 URL 正确定位子模块。"

#. type: Labeled list
#: en/git-submodule.txt:75
#, ignore-ellipsis, no-wrap, placeholders:'[--cached]':'[--recursive]', priority:220
msgid "status [--cached] [--recursive] [--] [<path>...]"
msgstr "status [--cached] [--recursive] [--] [<路径>...]"

#. type: Plain text
#: en/git-submodule.txt:83
#, priority:220
msgid "Show the status of the submodules. This will print the SHA-1 of the currently checked out commit for each submodule, along with the submodule path and the output of 'git describe' for the SHA-1. Each SHA-1 will possibly be prefixed with `-` if the submodule is not initialized, `+` if the currently checked out submodule commit does not match the SHA-1 found in the index of the containing repository and `U` if the submodule has merge conflicts."
msgstr "显示子模块的状态。这将打印每个子模块当前检出提交的 SHA-1，以及子模块的路径和 SHA-1 的 'git describe' 的输出。如果子模块没有被初始化，每个SHA-1 的前缀可能是 `-`；如果当前签出的子模块提交与包含仓库的索引中发现的 SHA-1 不匹配，则是 `+`；如果子模块有合并冲突，则是 `U`。"

#. type: Plain text
#: en/git-submodule.txt:86
#, placeholders:'`--cached`', priority:220
msgid "If `--cached` is specified, this command will instead print the SHA-1 recorded in the superproject for each submodule."
msgstr "如果指定了 `--cached`，这个命令将代替打印每个子模块父项目中记录的 SHA-1。"

#. type: Plain text
#: en/git-submodule.txt:89
#, placeholders:'`--recursive`', priority:220
msgid "If `--recursive` is specified, this command will recurse into nested submodules, and show their status as well."
msgstr "如果指定了 `--recursive`，该命令将递归到嵌套的子模块，并显示它们的状态。"

#. type: Plain text
#: en/git-submodule.txt:94
#, placeholders:'HEAD':'linkgit:git-status[1]':'linkgit:git-diff[1]', priority:220
msgid "If you are only interested in changes of the currently initialized submodules with respect to the commit recorded in the index or the HEAD, linkgit:git-status[1] and linkgit:git-diff[1] will provide that information too (and can also report changes to a submodule's work tree)."
msgstr "如果你只对当前初始化的子模块相对于索引或 HEAD 中记录的提交的变化感兴趣，linkgit:git-status[1] 和 linkgit:git-diff[1] 也会提供这些信息（也可以报告一个子模块工作目录的变化）。"

#. type: Labeled list
#: en/git-submodule.txt:95
#, ignore-ellipsis, no-wrap, priority:220
msgid "init [--] [<path>...]"
msgstr "init [--] [<路径>...]"

#. type: Plain text
#: en/git-submodule.txt:102
#, priority:220
msgid "Initialize the submodules recorded in the index (which were added and committed elsewhere) by setting `submodule.$name.url` in `.git/config`, using the same setting from `.gitmodules` as a template. If the URL is relative, it will be resolved using the default remote. If there is no default remote, the current repository will be assumed to be upstream."
msgstr "通过在 `.git/config` 中设置 `submodule.$name.url` ，以 `.gitmodules` 中的相同设置为模板，初始化索引中记录的子模块（已在其他地方添加并提交）。如果地址 是相对的，则会使用默认远程地址解析。如果没有默认远程，则当前仓库将被假定为上游仓库。"

#. type: Plain text
#: en/git-submodule.txt:107
#, placeholders:'submodule.active', priority:220
msgid "Optional <path> arguments limit which submodules will be initialized. If no path is specified and submodule.active has been configured, submodules configured to be active will be initialized, otherwise all submodules are initialized."
msgstr "可选的 <路径> 参数限制哪些子模块将被初始化。 如果没有指定路径，并且已经配置了 submodule.active，配置为激活的子模块将被初始化，否则所有的子模块都被初始化。"

#. type: Plain text
#: en/git-submodule.txt:112
#, priority:220
msgid "It will also copy the value of `submodule.$name.update`, if present in the `.gitmodules` file, to `.git/config`, but (1) this command does not alter existing information in `.git/config`, and (2) `submodule.$name.update` that is set to a custom command is *not* copied for security reasons."
msgstr "如果 `.gitmodules` 文件中存在 `submodule.$name.update`，它也会将其值复制到 `.git/config`，但 (1) 该命令不会更改 `.git/config` 中的现有信息，(2) 出于安全考虑，设置为自定义命令的 `submodule.$name.update` 不会被复制。"

#. type: Plain text
#: en/git-submodule.txt:118
#, placeholders:'--init`', priority:220
msgid "You can then customize the submodule clone URLs in `.git/config` for your local setup and proceed to `git submodule update`; you can also just use `git submodule update --init` without the explicit 'init' step if you do not intend to customize any submodule locations."
msgstr "然后，你可以在 `.git/config` 中根据你的本地设置自定义子模块克隆地址，然后继续 `git submodule update` ；如果你不打算自定义任何子模块的位置，也可以直接使用 `git submodule update --init` 而不需要明确的 'init' 步骤。"

#. type: Plain text
#: en/git-submodule.txt:120
#, priority:220
msgid "See the add subcommand for the definition of default remote."
msgstr "关于默认远程的定义，请参见 add 的子命令。"

#. type: Labeled list
#: en/git-submodule.txt:121
#, ignore-ellipsis, no-wrap, placeholders:'--force]':'--all', priority:220
msgid "deinit [-f|--force] (--all|[--] <path>...)"
msgstr "deinit [-f|--force] (--all|[--] <路径>...)"

#. type: Plain text
#: en/git-submodule.txt:128
#, priority:220
msgid "Unregister the given submodules, i.e. remove the whole `submodule.$name` section from .git/config together with their work tree. Further calls to `git submodule update`, `git submodule foreach` and `git submodule sync` will skip any unregistered submodules until they are initialized again, so use this command if you don't want to have a local checkout of the submodule in your working tree anymore."
msgstr "取消注册给定的子模块，即从 .git/config 中删除整个 `submodule.$name` 部分以及它们的工作目录。进一步调用 `git submodule update`，`git submodule foreach` 和 `git submodule sync` 将跳过任何未注册的子模块，直到它们再次被初始化，所以如果你不想在你的工作区上有一个本地的子模块检出，请使用这个命令。"

#. type: Plain text
#: en/git-submodule.txt:131
#, priority:220
msgid "When the command is run without pathspec, it errors out, instead of deinit-ing everything, to prevent mistakes."
msgstr "当命令在没有路径规范的情况下运行时，它会出错，而不是删除所有内容，以防错误。"

#. type: Plain text
#: en/git-submodule.txt:134
#, placeholders:'`--force`', priority:220
msgid "If `--force` is specified, the submodule's working tree will be removed even if it contains local modifications."
msgstr "如果指定了 `--force`，子模块的工作目录将被删除，即使它包含了本地的修改。"

#. type: Plain text
#: en/git-submodule.txt:138
#, placeholders:'linkgit:git-rm[1]':'linkgit:gitsubmodules[7]', priority:220
msgid "If you really want to remove a submodule from the repository and commit that use linkgit:git-rm[1] instead. See linkgit:gitsubmodules[7] for removal options."
msgstr "如果你真的想从仓库中删除一个子模块并提交，请使用 linkgit:git-rm[1] 代替。参见 linkgit:gitsubmodules[7] 的删除选项。"

#. type: Labeled list
#: en/git-submodule.txt:139
#, ignore-ellipsis, no-wrap, placeholders:'[--init]':'[--remote]':'--no-fetch]':'--force]':'[--checkout':'--rebase':'--merge]':'[--reference':'[--depth':'[--recursive]':'[--jobs':'[--filter', priority:220
msgid "update [--init] [--remote] [-N|--no-fetch] [--[no-]recommend-shallow] [-f|--force] [--checkout|--rebase|--merge] [--reference <repository>] [--depth <depth>] [--recursive] [--jobs <n>] [--[no-]single-branch] [--filter <filter-spec>] [--] [<path>...]"
msgstr "update [--init] [--remote] [-N|--no-fetch] [--[no-]recommend-shallow] [-f|--force] [--checkout|--rebase|--merge] [--reference <仓库>] [--depth <深度>] [--recursive] [--jobs <数量>] [--[no-]single-branch] [--filter <过滤规范>] [--] [<路径>...]"

#. type: Plain text
#: en/git-submodule.txt:153
#, priority:220
msgid "Update the registered submodules to match what the superproject expects by cloning missing submodules, fetching missing commits in submodules and updating the working tree of the submodules. The \"updating\" can be done in several ways depending on command line options and the value of `submodule.<name>.update` configuration variable. The command line option takes precedence over the configuration variable. If neither is given, a 'checkout' is performed. (note: what is in `.gitmodules` file is irrelevant at this point; see `git submodule init` above for how `.gitmodules` is used). The 'update' procedures supported both from the command line as well as through the `submodule.<name>.update` configuration are:"
msgstr "通过克隆缺失的子模块、获取子模块中缺失的提交以及更新子模块的工作目录树，更新已注册的子模块，使其符合超级项目的预期。“更新” 有多种方式，取决于命令行选项和配置变量 `submodule.<名称>.update` 的值。命令行选项优先于配置变量。如果命令行选项和配置变量都没有给出，则会执行 \"chackout\"。 (注意：`.gitmodules` 文件中的内容与此无关；关于 `.gitmodules` 的使用方法，请参见上文的 `Git 子模块初始化`）。 通过命令行和 `submodule.<名称>.update` 配置支持的 “更新” 程序如下："

#. type: Labeled list
#: en/git-submodule.txt:154
#, no-wrap, priority:220
msgid "checkout"
msgstr "检出"

#. type: Plain text
#: en/git-submodule.txt:156
#, placeholders:'HEAD', priority:220
msgid "the commit recorded in the superproject will be checked out in the submodule on a detached HEAD."
msgstr "在父项目中记录的提交将在分离的 HEAD 上的子模块中检出。"

#. type: Plain text
#: en/git-submodule.txt:161
#, placeholders:'`--force`':'--force`', priority:220
msgid "If `--force` is specified, the submodule will be checked out (using `git checkout --force`), even if the commit specified in the index of the containing repository already matches the commit checked out in the submodule."
msgstr "如果指定了 `--force` ，子模块将被检出（使用 `git checkout --force`），即使在包含仓库的索引中指定的提交已经与子模块中检出的提交匹配。"

#. type: Labeled list
#: en/git-submodule.txt:162
#, no-wrap, priority:220
msgid "rebase"
msgstr "rebase"

#. type: Plain text
#: en/git-submodule.txt:164
#, priority:220
msgid "the current branch of the submodule will be rebased onto the commit recorded in the superproject."
msgstr "子模块的当前分支将被变基到父项目中记录的提交上。"

#. type: Plain text
#: en/git-submodule.txt:167
#, priority:220
msgid "the commit recorded in the superproject will be merged into the current branch in the submodule."
msgstr "父项目中记录的提交将被合并到子模块中的当前分支。"

#. type: Plain text
#: en/git-submodule.txt:169
#, priority:220
msgid "The following update procedures have additional limitations:"
msgstr "以下更新程序有其他限制："

#. type: Labeled list
#: en/git-submodule.txt:170
#, no-wrap, priority:220
msgid "custom command"
msgstr "自定义命令"

#. type: Plain text
#: en/git-submodule.txt:177
#, priority:220
msgid "mechanism for running arbitrary commands with the commit ID as an argument. Specifically, if the `submodule.<name>.update` configuration variable is set to `!custom command`, the object name of the commit recorded in the superproject for the submodule is appended to the `custom command` string and executed. Note that this mechanism is not supported in the `.gitmodules` file or on the command line."
msgstr "以提交 ID 作为参数运行任意命令的机制。具体来说，如果 `submodule.<name>.update` 配置变量被设置为 `!custom command`，子模块的超级项目中记录的提交对象名称就会被附加到 `custom command` 字符串中并被执行。请注意，`.gitmodules` 文件或命令行均不支持该机制。"

#. type: Plain text
#: en/git-submodule.txt:180
#, priority:220
msgid "the submodule is not updated. This update procedure is not allowed on the command line."
msgstr "子模块不会更新。命令行中不允许使用此更新程序。"

#. type: Plain text
#: en/git-submodule.txt:184
#, placeholders:'`--init`', priority:220
msgid "If the submodule is not yet initialized, and you just want to use the setting as stored in `.gitmodules`, you can automatically initialize the submodule with the `--init` option."
msgstr "如果子模块还没有被初始化，而你只是想使用存储在 `.gitmodules` 中的设置，你可以用 `--init` 选项自动初始化子模块。"

#. type: Plain text
#: en/git-submodule.txt:187
#, placeholders:'`--recursive`', priority:220
msgid "If `--recursive` is specified, this command will recurse into the registered submodules, and update any nested submodules within."
msgstr "如果指定了`--recursive`，该命令将递归到已注册的子模块中，并更新其中的任何嵌套子模块。"

#. type: Plain text
#: en/git-submodule.txt:191
#, placeholders:'`--filter':'linkgit:git-rev-list[1]', priority:220
msgid "If `--filter <filter-spec>` is specified, the given partial clone filter will be applied to the submodule. See linkgit:git-rev-list[1] for details on filter specifications."
msgstr "如果指定了 `--filter <过滤规范>`，给定的部分克隆过滤器将被应用于子模块。关于过滤器规格细节，见 linkgit:git-rev-list[1]。"

#. type: Labeled list
#: en/git-submodule.txt:192
#, no-wrap, placeholders:'--branch', priority:220
msgid "set-branch (-b|--branch) <branch> [--] <path>"
msgstr "set-branch (-b|--branch) <分支> [--] <路径>"

#. type: Labeled list
#: en/git-submodule.txt:193
#, no-wrap, placeholders:'--default', priority:220
msgid "set-branch (-d|--default) [--] <path>"
msgstr "set-branch (-d|--default) [--] <路径>"

#. type: Plain text
#: en/git-submodule.txt:198
#, placeholders:'`--branch`':'`--default`':'HEAD', priority:220
msgid "Sets the default remote tracking branch for the submodule. The `--branch` option allows the remote branch to be specified. The `--default` option removes the submodule.<name>.branch configuration key, which causes the tracking branch to default to the remote 'HEAD'."
msgstr "设置子模块的默认远程跟踪分支。`--branch` 选项允许指定远程分支。`--default` 选项删除 submodule.<名称>.branch 配置键，使跟踪分支默认为远程 'HEAD'。"

#. type: Labeled list
#: en/git-submodule.txt:199
#, no-wrap, priority:220
msgid "set-url [--] <path> <newurl>"
msgstr "set-url [--] <路径> <新url>"

#. type: Plain text
#: en/git-submodule.txt:203
#, priority:220
msgid "Sets the URL of the specified submodule to <newurl>. Then, it will automatically synchronize the submodule's new remote URL configuration."
msgstr "将指定子模块的 URL 设置为 <新url>。然后，它将自动同步子模块的新远程 URL 配置。"

#. type: Labeled list
#: en/git-submodule.txt:204
#, ignore-ellipsis, no-wrap, placeholders:'[--cached':'--files]':'--summary-limit', priority:220
msgid "summary [--cached|--files] [(-n|--summary-limit) <n>] [commit] [--] [<path>...]"
msgstr "summary [--cached|--files] [(-n|--summary-limit) <数量>] [commit] [--] [<路径>...]"

#. type: Plain text
#: en/git-submodule.txt:213
#, placeholders:'HEAD':'`--cached`':'`--files`':'`--cached`', priority:220
msgid "Show commit summary between the given commit (defaults to HEAD) and working tree/index. For a submodule in question, a series of commits in the submodule between the given super project commit and the index or working tree (switched by `--cached`) are shown. If the option `--files` is given, show the series of commits in the submodule between the index of the super project and the working tree of the submodule (this option doesn't allow to use the `--cached` option or to provide an explicit commit)."
msgstr "显示指定的提交（默认为 HEAD）和工作区/索引之间的提交摘要。对于一个相关的子模块，显示该子模块在给定的父项目提交和索引或工作区（由 `--cached` 切换）之间的一系列提交。如果给出选项 `--files`，则显示父项目的索引和子模块的工作区之间的一系列提交（这个选项不允许使用 `--cached` 选项或提供明确的提交）。"

#. type: Plain text
#: en/git-submodule.txt:216
#, placeholders:'`--submodule=log`':'linkgit:git-diff[1]', priority:220
msgid "Using the `--submodule=log` option with linkgit:git-diff[1] will provide that information too."
msgstr "使用 linkgit:git-diff[1] 的 `--submodule=log` 选项也会提供这些信息。"

#. type: Labeled list
#: en/git-submodule.txt:217
#, no-wrap, placeholders:'[--recursive]', priority:220
msgid "foreach [--recursive] <command>"
msgstr "foreach [--recursive] <命令>"

#. type: Plain text
#: en/git-submodule.txt:238
#, placeholders:'$sm_path':'$displaypath':'$sha1':'$toplevel':'$sm_path':'$displaypath':'$sha1':'$toplevel':'$PATH':'$path':'$sm_path':'`--quiet`':'`--recursive`', priority:220
msgid "Evaluates an arbitrary shell command in each checked out submodule. The command has access to the variables $name, $sm_path, $displaypath, $sha1 and $toplevel: $name is the name of the relevant submodule section in `.gitmodules`, $sm_path is the path of the submodule as recorded in the immediate superproject, $displaypath contains the relative path from the current working directory to the submodules root directory, $sha1 is the commit as recorded in the immediate superproject, and $toplevel is the absolute path to the top-level of the immediate superproject. Note that to avoid conflicts with '$PATH' on Windows, the '$path' variable is now a deprecated synonym of '$sm_path' variable. Any submodules defined in the superproject but not checked out are ignored by this command. Unless given `--quiet`, foreach prints the name of each submodule before evaluating the command. If `--recursive` is given, submodules are traversed recursively (i.e. the given shell command is evaluated in nested submodules as well). A non-zero return from the command in any submodule causes the processing to terminate. This can be overridden by adding '|| :' to the end of the command."
msgstr "在每个签出的子模块中评估一个任意的 shell 命令。 该命令可以访问变量 $name、$sm_path、$displaypath、$sha1 和 $toplevel：$name 是 `.gitmodules` 中相关子模块部分的名称，$sm_path 是即时父项目中记录的子模块的路径，$displaypath 包含从当前工作目录到子模块根目录的相对路径，$sha1 是即时父项目中记录的提交，而$toplevel 是即时父项目的顶级的绝对路径。 注意，为了避免与 Windows 上的 '$PATH' 冲突，'$path' 变量现在是 '$sm_path' 变量的一个废弃的同义词。 任何在父项目中定义但没有检查出来的子模块都会被这个命令忽略。除非给出 `--quiet`，否则 foreach 在评估命令前会打印出每个子模块的名字。 如果给定 `--recursive`，子模块将被递归遍历（即给定的 shel l命令在嵌套的子模块中也被评估）。 在任何子模块中，命令的非零返回将导致处理的终止。这可以通过在命令的末尾添加 '||:' 来覆盖。"

#. type: Plain text
#: en/git-submodule.txt:241
#, priority:220
msgid "As an example, the command below will show the path and currently checked out commit for each submodule:"
msgstr "作为一个例子，下面的命令将显示每个子模块的路径和当前检出的提交："

#. type: delimited block -
#: en/git-submodule.txt:244
#, no-wrap, placeholders:'$sm_path':'git rev-parse':'HEAD', priority:220
msgid "git submodule foreach 'echo $sm_path `git rev-parse HEAD`'\n"
msgstr "git submodule foreach 'echo $sm_path `git rev-parse HEAD`'\n"

#. type: Labeled list
#: en/git-submodule.txt:246
#, ignore-ellipsis, no-wrap, placeholders:'[--recursive]', priority:220
msgid "sync [--recursive] [--] [<path>...]"
msgstr "sync [--recursive] [--] [<路径>...]"

#. type: Plain text
#: en/git-submodule.txt:253
#, priority:220
msgid "Synchronizes submodules' remote URL configuration setting to the value specified in `.gitmodules`. It will only affect those submodules which already have a URL entry in .git/config (that is the case when they are initialized or freshly added). This is useful when submodule URLs change upstream and you need to update your local repositories accordingly."
msgstr "将子模块的远程 URL 配置设置同步到 `.gitmodules` 中指定的值。它只会影响那些在 .git/config 中已经有一个 URL 条目的子模块（也就是当它们被初始化或新添加时的情况）。当子模块的 URL 在上游发生变化，你需要相应地更新你的本地仓库时，这很有用。"

#. type: Plain text
#: en/git-submodule.txt:256
#, priority:220
msgid "`git submodule sync` synchronizes all submodules while `git submodule sync -- A` synchronizes submodule \"A\" only."
msgstr "`git submodule sync` 同步所有子模块，而 `git submodule sync -- A` 只同步子模块 \"A\"。"

#. type: Plain text
#: en/git-submodule.txt:259
#, placeholders:'`--recursive`', priority:220
msgid "If `--recursive` is specified, this command will recurse into the registered submodules, and sync any nested submodules within."
msgstr "如果指定了 `--recursive`，该命令将递归到已注册的子模块中，并同步其中的任何嵌套子模块。"

#. type: Labeled list
#: en/git-submodule.txt:260
#, no-wrap, priority:220
msgid "absorbgitdirs"
msgstr "吸附 gitdirs"

#. type: Plain text
#: en/git-submodule.txt:267
#, placeholders:'$GIT_DIR':'core.worktree', priority:220
msgid "If a git directory of a submodule is inside the submodule, move the git directory of the submodule into its superproject's `$GIT_DIR/modules` path and then connect the git directory and its working directory by setting the `core.worktree` and adding a .git file pointing to the git directory embedded in the superprojects git directory."
msgstr "如果一个子模块的 git 目录在子模块内部，将子模块的 git 目录移入其父项目的 `$GIT_DIR/modules` 路径，然后通过设置 `core.worktree` 连接 git 目录和其工作目录，并添加一个指向嵌入父项目 git 目录的 .git 文件。"

#. type: Plain text
#: en/git-submodule.txt:271
#, priority:220
msgid "A repository that was cloned independently and later added as a submodule or old setups have the submodules git directory inside the submodule instead of embedded into the superprojects git directory."
msgstr "一个独立克隆的仓库，后来被添加为子模块或旧的设置，其子模块的 git 目录在子模块内，而不是嵌入到父项目的 git 目录。"

#. type: Plain text
#: en/git-submodule.txt:273
#, priority:220
msgid "This command is recursive by default."
msgstr "这个命令默认是递归的。"

#. type: Plain text
#: en/git-submodule.txt:279
#, priority:220
msgid "Only print error messages."
msgstr "只打印出错误信息。"

#. type: Plain text
#: en/git-submodule.txt:286
#, priority:220
msgid "This option is only valid for add and update commands. Progress status is reported on the standard error stream by default when it is attached to a terminal, unless -q is specified. This flag forces progress status even if the standard error stream is not directed to a terminal."
msgstr "这个选项只对添加和更新命令有效。 当标准错误流连接到终端时，除非指定了 -q，否则默认情况下进度状态会在标准错误流中报告。即使标准错误流没有指向终端，这个标志也会强制显示进度状态。"

#. type: Plain text
#: en/git-submodule.txt:290
#, priority:220
msgid "This option is only valid for the deinit command. Unregister all submodules in the working tree."
msgstr "这个选项只对 deinit 命令有效。取消工作区中所有子模块的注册。"

#. type: Labeled list
#: en/git-submodule.txt:291
#, no-wrap, priority:220
msgid "-b <branch>"
msgstr "-b <分支>"

#. type: Plain text
#: en/git-submodule.txt:299
#, placeholders:'--remote`':'HEAD', priority:220
msgid "Branch of repository to add as submodule. The name of the branch is recorded as `submodule.<name>.branch` in `.gitmodules` for `update --remote`. A special value of `.` is used to indicate that the name of the branch in the submodule should be the same name as the current branch in the current repository. If the option is not specified, it defaults to the remote 'HEAD'."
msgstr "仓库的分支，作为子模块添加。 分支的名称在 `.gitmodules` 中记录为 `submodule.<名称>.branch`，用于 `update --remote`。 一个特殊的值 `.` 用来表示子模块中的分支名称应该与当前版本库中的当前分支名称相同。 如果没有指定该选项，则默认为远程 'HEAD'。"

#. type: Plain text
#: en/git-submodule.txt:312
#, priority:220
msgid "This option is only valid for add, deinit and update commands. When running add, allow adding an otherwise ignored submodule path. When running deinit the submodule working trees will be removed even if they contain local changes. When running update (only effective with the checkout procedure), throw away local changes in submodules when switching to a different commit; and always run a checkout operation in the submodule, even if the commit listed in the index of the containing repository matches the commit checked out in the submodule."
msgstr "这个选项只对 add、deinit 和 update 命令有效。 当运行 add 时，允许添加一个原本被忽略的子模块路径。 当运行 deinit 时，子模块的工作目录将被删除，即使它们包含本地的变化。 当运行 update（仅对 checkout 程序有效）时，当切换到不同的提交时，丢弃子模块中的本地修改；并且总是在子模块中运行 checkout 操作，即使在包含仓库的索引中列出的提交与子模块中签出的提交相匹配。"

#. type: Plain text
#: en/git-submodule.txt:317
#, placeholders:'HEAD', priority:220
msgid "This option is only valid for status and summary commands. These commands typically use the commit found in the submodule HEAD, but with this option, the commit stored in the index is used instead."
msgstr "这个选项只对状态和摘要命令有效。 这些命令通常使用在子模块 HEAD 中找到的提交，但有了这个选项，就会使用存储在索引中的提交。"

#. type: Labeled list
#: en/git-submodule.txt:318
#, ignore-same, no-wrap, priority:220
msgid "--files"
msgstr "--files"

#. type: Plain text
#: en/git-submodule.txt:322
#, placeholders:'HEAD', priority:220
msgid "This option is only valid for the summary command. This command compares the commit in the index with that in the submodule HEAD when this option is used."
msgstr "这个选项只对 summary 命令有效。当使用这个选项时，该命令将索引中的提交与子模块 HEAD 中的提交进行比较。"

#. type: Labeled list
#: en/git-submodule.txt:324
#, ignore-same, no-wrap, priority:220
msgid "--summary-limit"
msgstr "--summary-limit"

#. type: Plain text
#: en/git-submodule.txt:330
#, priority:220
msgid "This option is only valid for the summary command. Limit the summary size (number of commits shown in total). Giving 0 will disable the summary; a negative number means unlimited (the default). This limit only applies to modified submodules. The size is always limited to 1 for added/deleted/typechanged submodules."
msgstr "这个选项只对 summary 命令有效。 限制摘要的大小（总共显示的提交数量）。 给予 0 将禁用摘要；负数意味着无限（默认）。这个限制只适用于修改过的子模块。对于新增/删除/类型改变的子模块，其大小总是限制为 1。"

#. type: Labeled list
#: en/git-submodule.txt:331
#, ignore-same, no-wrap, priority:220
msgid "--remote"
msgstr "--remote"

#. type: Plain text
#: en/git-submodule.txt:340
#, placeholders:'HEAD', priority:220
msgid "This option is only valid for the update command. Instead of using the superproject's recorded SHA-1 to update the submodule, use the status of the submodule's remote-tracking branch. The remote used is branch's remote (`branch.<name>.remote`), defaulting to `origin`. The remote branch used defaults to the remote `HEAD`, but the branch name may be overridden by setting the `submodule.<name>.branch` option in either `.gitmodules` or `.git/config` (with `.git/config` taking precedence)."
msgstr "这个选项只对更新命令有效。 不使用超级项目记录的 SHA-1 来更新子模块，而使用子模块的远程跟踪分支的状态。 使用的远程是分支的远程（`branch.<名称>.remote`），默认为 `origin`。 使用的远程分支默认为远程的 `HEAD`，但分支的名称可以通过在 `.gitmodules` 或 `.git/config` 中设置 `submodule.<名称>.branch` 选项来覆盖（以`.git/config`为先）。"

#. type: Plain text
#: en/git-submodule.txt:346
#, placeholders:'`--checkout`':'`--rebase`':'--remote':'--merge`':'--merge`', priority:220
msgid "This works for any of the supported update procedures (`--checkout`, `--rebase`, etc.). The only change is the source of the target SHA-1. For example, `submodule update --remote --merge` will merge upstream submodule changes into the submodules, while `submodule update --merge` will merge superproject gitlink changes into the submodules."
msgstr "这适用于任何支持的更新程序（`--checkout`，`--rebase`，等等）。 唯一的变化是目标 SHA-1 的来源。 例如，`submodule update --remote --merge` 将把上游子模块的变化合并到子模块中，而 `submodule update --merge` 将把父项目的 gitlink 变化合并到子模块。"

#. type: Plain text
#: en/git-submodule.txt:351
#, placeholders:'--remote`':'--remote':'--no-fetch`', priority:220
msgid "In order to ensure a current tracking branch state, `update --remote` fetches the submodule's remote repository before calculating the SHA-1. If you don't want to fetch, you should use `submodule update --remote --no-fetch`."
msgstr "为了确保当前的跟踪分支状态，`update --remote` 在计算 SHA-1 之前会获取子模块的远程仓库。 如果你不想获取，你应该使用`submodule update --remote --no-fetch`。"

#. type: Plain text
#: en/git-submodule.txt:361
#, placeholders:'HEAD':'--remote`', priority:220
msgid "Use this option to integrate changes from the upstream subproject with your submodule's current HEAD. Alternatively, you can run `git pull` from the submodule, which is equivalent except for the remote branch name: `update --remote` uses the default upstream repository and `submodule.<name>.branch`, while `git pull` uses the submodule's `branch.<name>.merge`. Prefer `submodule.<name>.branch` if you want to distribute the default upstream branch with the superproject and `branch.<name>.merge` if you want a more native feel while working in the submodule itself."
msgstr "使用这个选项可以将上游子项目的变化与你的子模块的当前 HEAD 集成。 或者，你可以从子模块运行 `git pull`，除了远程分支名称外，其他都是一样的：`update --remote` 使用默认的上游仓库和 `submodule.<名称>.branch`，而 `git pull` 使用子模块的 `branch.<名称>.merge`。 如果你想和父项目一起发布默认的上游分支，那么首选 `submodule.<名称>.branch`，如果你想在子模块本身工作时有更多的本地感觉，那么首选 `branch.<名称>.merge`。"

#. type: Labeled list
#: en/git-submodule.txt:363
#, ignore-same, no-wrap, priority:220
msgid "--no-fetch"
msgstr "--no-fetch"

#. type: Plain text
#: en/git-submodule.txt:366
#, priority:220
msgid "This option is only valid for the update command. Don't fetch new objects from the remote site."
msgstr "这个选项只对 update 命令有效。 不要从远程站点获取新对象。"

#. type: Labeled list
#: en/git-submodule.txt:367
#, ignore-same, no-wrap, priority:220
msgid "--checkout"
msgstr "--checkout"

#. type: Plain text
#: en/git-submodule.txt:375
#, placeholders:'HEAD', priority:220
msgid "This option is only valid for the update command. Checkout the commit recorded in the superproject on a detached HEAD in the submodule. This is the default behavior, the main use of this option is to override `submodule.$name.update` when set to a value other than `checkout`. If the key `submodule.$name.update` is either not explicitly set or set to `checkout`, this option is implicit."
msgstr "这个选项只对 update 命令有效。 检出父项目中记录在子模块中的分离 HEAD 上的提交。这是默认行为，这个选项的主要用途是在设置为 `checkout` 以外的值时覆盖 `submodule.$name.update`。 如果键 `submodule.$name.update` 没有明确设置或设置为 `checkout`，这个选项是隐含的。"

#. type: Plain text
#: en/git-submodule.txt:385
#, placeholders:'HEAD', priority:220
msgid "This option is only valid for the update command. Merge the commit recorded in the superproject into the current branch of the submodule. If this option is given, the submodule's HEAD will not be detached. If a merge failure prevents this process, you will have to resolve the resulting conflicts within the submodule with the usual conflict resolution tools. If the key `submodule.$name.update` is set to `merge`, this option is implicit."
msgstr "这个选项只对更新命令有效。 将父项目中记录的提交合并到子模块的当前分支中。如果给出这个选项，子模块的 HEAD 将不会被分离。如果合并失败阻止了这个过程，你将不得不用通常的冲突解决工具来解决子模块内产生的冲突。 如果键 `submodule.$name.update` 被设置为 `merge`，这个选项是隐含的。"

#. type: Labeled list
#: en/git-submodule.txt:386
#, ignore-same, no-wrap, priority:220
msgid "--rebase"
msgstr "--rebase"

#. type: Plain text
#: en/git-submodule.txt:394
#, placeholders:'HEAD':'linkgit:git-rebase[1]', priority:220
msgid "This option is only valid for the update command. Rebase the current branch onto the commit recorded in the superproject. If this option is given, the submodule's HEAD will not be detached. If a merge failure prevents this process, you will have to resolve these failures with linkgit:git-rebase[1]. If the key `submodule.$name.update` is set to `rebase`, this option is implicit."
msgstr "这个选项只对 update 命令有效。 将当前分支重新归入超级项目中记录的提交。如果给了这个选项，子模块的 HEAD 将不会被分离。如果合并失败阻止了这个过程，你将不得不用 linkgit:git-rebase[1] 解决这些失败。 如果键 `submodule.$name.update` 被设置为 `rebase`，这个选项是隐含的。"

#. type: Labeled list
#: en/git-submodule.txt:395
#, ignore-same, no-wrap, priority:220
msgid "--init"
msgstr "--init"

#. type: Plain text
#: en/git-submodule.txt:399
#, priority:220
msgid "This option is only valid for the update command. Initialize all submodules for which \"git submodule init\" has not been called so far before updating."
msgstr "这个选项只对 update 命令有效。 在更新前初始化所有到目前为止还没有调用过 \"git submodule init \" 的子模块。"

#. type: Labeled list
#: en/git-submodule.txt:400
#, ignore-same, no-wrap, priority:220
msgid "--name"
msgstr "--name"

#. type: Plain text
#: en/git-submodule.txt:404
#, priority:220
msgid "This option is only valid for the add command. It sets the submodule's name to the given string instead of defaulting to its path. The name must be valid as a directory name and may not end with a '/'."
msgstr "这个选项只对 add 命令有效。它将子模块的名称设置为给定的字符串，而不是默认为其路径。这个名字必须是有效的目录名，并且不能以 '/' 结尾。"

#. type: Labeled list
#: en/git-submodule.txt:405
#, no-wrap, placeholders:'--reference', priority:220
msgid "--reference <repository>"
msgstr "--reference <仓库>"

#. type: Plain text
#: en/git-submodule.txt:409 en/git-submodule.txt:418
#, placeholders:'linkgit:git-clone[1]', priority:220
msgid "This option is only valid for add and update commands. These commands sometimes need to clone a remote repository. In this case, this option will be passed to the linkgit:git-clone[1] command."
msgstr "这个选项只对添加和更新命令有效。 这些命令有时需要克隆一个远程版本库。在这种情况下，这个选项将被传递给 linkgit:git-clone[1] 命令。"

#. type: Plain text
#: en/git-submodule.txt:413
#, placeholders:'linkgit:git-clone[1]':'`--reference`':'`--shared`':'`--dissociate`', priority:220
msgid "*NOTE*: Do *not* use this option unless you have read the note for linkgit:git-clone[1]'s `--reference`, `--shared`, and `--dissociate` options carefully."
msgstr "*注意*： 请*不要*使用这个选项，在阅读 linkgit:git-clone[1] 的 `--reference`, `--shared`, 和 `--dissociate` 选项前谨慎使用这个选项。"

#. type: Plain text
#: en/git-submodule.txt:420
#, placeholders:'`--reference`', priority:220
msgid "*NOTE*: see the NOTE for the `--reference` option."
msgstr "*注意*：参见 `--reference` 选项的说明。"

#. type: Plain text
#: en/git-submodule.txt:426
#, priority:220
msgid "This option is only valid for foreach, update, status and sync commands. Traverse submodules recursively. The operation is performed not only in the submodules of the current repo, but also in any nested submodules inside those submodules (and so on)."
msgstr "这个选项只对 foreach、update、status 和 sync 命令有效。 递归地遍历子模块。该操作不仅在当前仓库的子模块中执行，而且在这些子模块内部的任何嵌套子模块中也执行（以此类推）。"

#. type: Labeled list
#: en/git-submodule.txt:427
#, ignore-same, no-wrap, priority:220
msgid "--depth"
msgstr "--depth"

#. type: Plain text
#: en/git-submodule.txt:431
#, placeholders:'linkgit:git-clone[1]', priority:220
msgid "This option is valid for add and update commands. Create a 'shallow' clone with a history truncated to the specified number of revisions. See linkgit:git-clone[1]"
msgstr "这个选项对 update 和 add 命令有效。创建一个 'shallow' 克隆，其历史被截断到指定的修订次数。 参见 linkgit:git-clone[1]"

#. type: Labeled list
#: en/git-submodule.txt:432
#, ignore-same, no-wrap, priority:220
msgid "--[no-]recommend-shallow"
msgstr "--[no-]recommend-shallow"

#. type: Plain text
#: en/git-submodule.txt:437
#, placeholders:'`--no-recommend-shallow`', priority:220
msgid "This option is only valid for the update command. The initial clone of a submodule will use the recommended `submodule.<name>.shallow` as provided by the `.gitmodules` file by default. To ignore the suggestions use `--no-recommend-shallow`."
msgstr "这个选项只对更新命令有效。 一个子模块的初始克隆将默认使用 `.gitmodules` 文件提供的推荐的 `submodule.<名称>.shallow`。要忽略这些建议，请使用 `--no-recommend-shallow`。"

#. type: Plain text
#: en/git-submodule.txt:443
#, placeholders:'submodule.fetchJobs', priority:220
msgid "This option is only valid for the update command. Clone new submodules in parallel with as many jobs. Defaults to the `submodule.fetchJobs` option."
msgstr "这个选项只对更新命令有效。 克隆新的子模块与尽可能多的作业并行。 默认为 `submodule.fetchJobs` 选项。"

#. type: Plain text
#: en/git-submodule.txt:447
#, placeholders:'HEAD':'--branch', priority:220
msgid "This option is only valid for the update command. Clone only one branch during update: HEAD or one specified by --branch."
msgstr "这个选项只对 update 命令有效。 在更新过程中只克隆一个分支：HEAD 或由 --branch 指定的一个分支。"

#. type: Plain text
#: en/git-submodule.txt:452
#, priority:220
msgid "Paths to submodule(s). When specified this will restrict the command to only operate on the submodules found at the specified paths. (This argument is required with add)."
msgstr "子模块的路径。当指定时，这将限制该命令只对在指定路径上发现的子模块进行操作。 (这个参数在添加时是必需的）。"

#. type: Plain text
#: en/git-submodule.txt:460
#, placeholders:'$GIT_DIR':'linkgit:gitmodules[5]', priority:220
msgid "When initializing submodules, a `.gitmodules` file in the top-level directory of the containing repository is used to find the url of each submodule. This file should be formatted in the same way as `$GIT_DIR/config`. The key to each submodule url is \"submodule.$name.url\". See linkgit:gitmodules[5] for details."
msgstr "当初始化子模块时，在包含仓库的顶级目录中的 `.gitmodules` 文件被用来寻找每个子模块的 URL。 这个文件的格式应该与 `$GIT_DIR/config` 相同。每个子模块网址的键是 \"submodule.$name.url\"。 详情见 linkgit:gitmodules[5]。"

#. type: Plain text
#: en/git-submodule.txt:464
#, ignore-same, priority:220
msgid "linkgit:gitsubmodules[7], linkgit:gitmodules[5]."
msgstr "linkgit:gitsubmodules[7], linkgit:gitmodules[5]."

#. type: Title =
#: en/git-svn.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-svn(1)"
msgstr "git-svn(1)"

#. type: Plain text
#: en/git-svn.txt:7
#, placeholders:'git-svn', priority:100
msgid "git-svn - Bidirectional operation between a Subversion repository and Git"
msgstr "git-svn - Subversion 仓库和 Git 之间的双向操作"

#. type: Plain text
#: en/git-svn.txt:12
#, no-wrap, priority:100
msgid "'git svn' <command> [<options>] [<arguments>]\n"
msgstr "'git svn' <命令> [<选项>] [<参数>]\n"

#. type: Plain text
#: en/git-svn.txt:18
#, priority:100
msgid "'git svn' is a simple conduit for changesets between Subversion and Git. It provides a bidirectional flow of changes between a Subversion and a Git repository."
msgstr "'git svn' 是一个 Subversion 和 Git 之间变更集的简单通道。 它用于 Subversion 和 Git 仓库之间变更的双向流动。"

#. type: Plain text
#: en/git-svn.txt:23
#, placeholders:'--stdlayout', priority:100
msgid "'git svn' can track a standard Subversion repository, following the common \"trunk/branches/tags\" layout, with the --stdlayout option. It can also follow branches and tags in any layout with the -T/-t/-b options (see options to 'init' below, and also the 'clone' command)."
msgstr "'git svn' 可以跟踪标准 Subversion 仓库，遵循常见的 “主干/分支/标记” 布局，使用 --stdlayout 选项。 它还可以使用 -T/-t/-b 选项在任何布局中跟踪分支和标记（请参阅下面的 'init' 选项以及 'clone' 命令）。"

#. type: Plain text
#: en/git-svn.txt:27
#, priority:100
msgid "Once tracking a Subversion repository (with any of the above methods), the Git repository can be updated from Subversion by the 'fetch' command and Subversion updated from Git by the 'dcommit' command."
msgstr "跟踪 Subversion 仓库（使用上述任何方法）后，可以通过 'fetch' 命令从 Subversion 更新 Git 仓库，并通过 'dcommit' 命令从 Git 更新 Subversion 仓库。"

#. type: Labeled list
#: en/git-svn.txt:31
#, ignore-same, no-wrap, priority:100
msgid "'init'"
msgstr "'init'"

#. type: Plain text
#: en/git-svn.txt:39
#, priority:100
msgid "Initializes an empty Git repository with additional metadata directories for 'git svn'. The Subversion URL may be specified as a command-line argument, or as full URL arguments to -T/-t/-b. Optionally, the target directory to operate on can be specified as a second argument. Normally this command initializes the current directory."
msgstr "为 'git svn' 初始化一个空的 Git 仓库，并添加元数据目录。 Subversion 的 URL 可以作为命令行参数，也可以作为 -T/-t/-b 的完整 URL 参数。 或者，可以指定要操作的目标目录作为第二参数。 通常情况下这个命令会在当前目录进行初始化。"

#. type: Labeled list
#: en/git-svn.txt:40
#, no-wrap, priority:100
msgid "-T<trunk-subdir>"
msgstr "-T<trunk_subdir>"

#. type: Labeled list
#: en/git-svn.txt:41
#, no-wrap, placeholders:'--trunk=', priority:100
msgid "--trunk=<trunk-subdir>"
msgstr "--trunk=<trunk-subdir>"

#. type: Labeled list
#: en/git-svn.txt:42
#, no-wrap, priority:100
msgid "-t<tags-subdir>"
msgstr "-t<tags-subdir>"

#. type: Labeled list
#: en/git-svn.txt:43
#, no-wrap, placeholders:'--tags=', priority:100
msgid "--tags=<tags-subdir>"
msgstr "--tags=<tags-subdir>"

#. type: Labeled list
#: en/git-svn.txt:44
#, no-wrap, priority:100
msgid "-b<branches-subdir>"
msgstr "-b<branches-subdir>"

#. type: Labeled list
#: en/git-svn.txt:45
#, no-wrap, placeholders:'--branches=', priority:100
msgid "--branches=<branches-subdir>"
msgstr "--branches=<branches-subdir>"

#. type: Labeled list
#: en/git-svn.txt:47
#, ignore-same, no-wrap, priority:100
msgid "--stdlayout"
msgstr "--stdlayout"

# ERROR: --tags=project not found in translation
# ERROR: --tags=https not found in translation
#. type: Plain text
#: en/git-svn.txt:58
#, placeholders:'--tags=project':'--tags=https':'foo.org':'--tags':'--branches':'--stdlayout', priority:100
msgid "These are optional command-line options for init. Each of these flags can point to a relative repository path (--tags=project/tags) or a full url (--tags=https://foo.org/project/tags). You can specify more than one --tags and/or --branches options, in case your Subversion repository places tags or branches under multiple paths. The option --stdlayout is a shorthand way of setting trunk,tags,branches as the relative paths, which is the Subversion default. If any of the other options are given as well, they take precedence."
msgstr "这些是用于 init 的可选命令行选项。 每个标志都可以指向相对的版本库路径 (--tags=project/tags) 或完整的 url (--tags=https://foo.org/project/tags)。 你可以指定多个 --tags 和/或 --branches 选项，以防你的 Subversion 仓库将标记或分支放在多个路径下。 选项 --stdlayout 是将 主干、标记、分支设置为相对路径的一种快捷方式，这是 Subversion 的默认设置。如果使用了其他的选项，它们将被优先考虑。"

#. type: Labeled list
#: en/git-svn.txt:58
#, ignore-same, no-wrap, priority:100
msgid "--no-metadata"
msgstr "--no-metadata"

#. type: Plain text
#: en/git-svn.txt:62
#, placeholders:'svn.noMetadata', priority:100
msgid "Set the 'noMetadata' option in the [svn-remote] config. This option is not recommended, please read the 'svn.noMetadata' section of this manpage before using this option."
msgstr "设置 [svn-remote] 配置的 'noMetadata' 选项。 不建议使用该选项，请在使用该选项前阅读本手册中 'svn.noMetadata' 部分。"

#. type: Labeled list
#: en/git-svn.txt:62
#, ignore-same, no-wrap, priority:100
msgid "--use-svm-props"
msgstr "--use-svm-props"

#. type: Plain text
#: en/git-svn.txt:64
#, priority:100
msgid "Set the 'useSvmProps' option in the [svn-remote] config."
msgstr "设置[svn-remote] 配置的 'useSvmProps' 选项。"

#. type: Labeled list
#: en/git-svn.txt:64
#, ignore-same, no-wrap, priority:100
msgid "--use-svnsync-props"
msgstr "--use-svnsync-props"

#. type: Plain text
#: en/git-svn.txt:66
#, priority:100
msgid "Set the 'useSvnsyncProps' option in the [svn-remote] config."
msgstr "设置 [svn-remote] 配置的 'useSvnsyncProps' 选项。"

#. type: Labeled list
#: en/git-svn.txt:66
#, no-wrap, placeholders:'--rewrite-root=', priority:100
msgid "--rewrite-root=<URL>"
msgstr "--rewrite-root=<地址>"

#. type: Plain text
#: en/git-svn.txt:68
#, priority:100
msgid "Set the 'rewriteRoot' option in the [svn-remote] config."
msgstr "设置 [svn-remote] 配置的 'rewriteRoot' 选项。"

#. type: Labeled list
#: en/git-svn.txt:68
#, no-wrap, placeholders:'--rewrite-uuid=', priority:100
msgid "--rewrite-uuid=<UUID>"
msgstr "--rewrite-uuid=<UUID>"

#. type: Plain text
#: en/git-svn.txt:70
#, priority:100
msgid "Set the 'rewriteUUID' option in the [svn-remote] config."
msgstr "设置 [svn-remote] 配置的 'rewriteUUID' 选项。"

#. type: Labeled list
#: en/git-svn.txt:70
#, no-wrap, placeholders:'--username=', priority:100
msgid "--username=<user>"
msgstr "--username=<用户>"

#. type: Plain text
#: en/git-svn.txt:75
#, placeholders:'svn.bar.com', priority:100
msgid "For transports that SVN handles authentication for (http, https, and plain svn), specify the username. For other transports (e.g. `svn+ssh://`), you must include the username in the URL, e.g. `svn+ssh://foo@svn.bar.com/project`"
msgstr "对于由 SVN 处理认证的传输类型（http、https和纯svn），请指定用户名。 对于其他的传输类型(例如`svn+ssh:///`)，你必须在URL中包含用户名，例如：`svn+ssh://foo@svn.bar.com/project`"

#. type: Plain text
#: en/git-svn.txt:90
#, placeholders:'--branches':'$prefix':'$remote', priority:100
msgid "This allows one to specify a prefix which is prepended to the names of remotes if trunk/branches/tags are specified. The prefix does not automatically include a trailing slash, so be sure you include one in the argument if that is what you want. If --branches/-b is specified, the prefix must include a trailing slash. Setting a prefix (with a trailing slash) is strongly encouraged in any case, as your SVN-tracking refs will then be located at \"refs/remotes/$prefix/*\", which is compatible with Git's own remote-tracking ref layout (refs/remotes/$remote/*). Setting a prefix is also useful if you wish to track multiple projects that share a common repository. By default, the prefix is set to 'origin/'."
msgstr "如果指定了 trunk/branches/tags，则可以指定一个前缀，将其添加到远程设备名称的前缀中。 前缀不会自动包含斜线，因此如果需要，请确保在参数中包含斜线。 如果指定了 --branches/-b，前缀必须包含斜线。 在任何情况下，我们都强烈建议设置前缀（带尾部斜线），因为这样你的 SVN 跟踪引用就会位于 \"refs/remotes/$prefix/*\"，这与 Git 自己的远程跟踪引用布局（refs/remotes/$remote/*）是兼容的。如果想跟踪共享一个仓库的多个项目，设置前缀也很有用。 默认情况下，前缀设置为 \"origin/\"。"

#. type: Plain text
#: en/git-svn.txt:97
#, placeholders:'`--prefix':'`--prefix=', priority:100
msgid "Before Git v2.0, the default prefix was \"\" (no prefix). This meant that SVN-tracking refs were put at \"refs/remotes/*\", which is incompatible with how Git's own remote-tracking refs are organized. If you still want the old default, you can get it by passing `--prefix \"\"` on the command line (`--prefix=\"\"` may not work if your Perl's Getopt::Long is < v2.37)."
msgstr "在 Git v2.0 之前，默认前缀是\"\"（无前缀）。这意味着 SVN 跟踪的引用被放在 \"refs/remotes/*\" 目录下，这与 Git 自身远程跟踪引用的组织方式不兼容。 如果你还想要旧的默认值，可以通过在命令行中传递 `--prefix\"\"` 来实现（如果你的 Perl Getopt::Long 版本小于 2.37，则 `--prefix=\"\"` 可能不起作用）。"

#. type: Labeled list
#: en/git-svn.txt:98 en/git-svn.txt:145
#, no-wrap, placeholders:'--ignore-refs=', priority:100
msgid "--ignore-refs=<regex>"
msgstr "--ignore-refs=<正则表达式>"

#. type: Plain text
#: en/git-svn.txt:102
#, placeholders:'`--ignore-refs`', priority:100
msgid "When passed to 'init' or 'clone' this regular expression will be preserved as a config key. See 'fetch' for a description of `--ignore-refs`."
msgstr "当传递给 'init' 或 'clone' 时，该正则表达式将作为配置键保留。 有关 `--ignore-refs` 的描述，请参阅 'fetch'。"

#. type: Labeled list
#: en/git-svn.txt:102 en/git-svn.txt:157
#, no-wrap, placeholders:'--ignore-paths=', priority:100
msgid "--ignore-paths=<regex>"
msgstr "--ignore-paths=<正则表达式>"

#. type: Plain text
#: en/git-svn.txt:106
#, placeholders:'`--ignore-paths`', priority:100
msgid "When passed to 'init' or 'clone' this regular expression will be preserved as a config key. See 'fetch' for a description of `--ignore-paths`."
msgstr "当传递给 'init' 或 'clone' 时，该正则表达式将作为配置键保留。 有关 `--ignore-paths` 的描述，请参阅 'fetch'。"

#. type: Labeled list
#: en/git-svn.txt:106 en/git-svn.txt:186
#, no-wrap, placeholders:'--include-paths=', priority:100
msgid "--include-paths=<regex>"
msgstr "--include-paths=<正则表达式>"

#. type: Plain text
#: en/git-svn.txt:110
#, placeholders:'`--include-paths`', priority:100
msgid "When passed to 'init' or 'clone' this regular expression will be preserved as a config key. See 'fetch' for a description of `--include-paths`."
msgstr "当传递给 'init' 或 'clone' 时，该正则表达式将作为配置键保留。 有关 `--include-paths` 的描述，请参阅 'fetch'。"

#. type: Labeled list
#: en/git-svn.txt:110
#, ignore-same, no-wrap, priority:100
msgid "--no-minimize-url"
msgstr "--no-minimize-url"

#. type: Plain text
#: en/git-svn.txt:121
#, placeholders:'--stdlayout':'--branches':'--tags':'`--no-minimize-url`', priority:100
msgid "When tracking multiple directories (using --stdlayout, --branches, or --tags options), git svn will attempt to connect to the root (or highest allowed level) of the Subversion repository. This default allows better tracking of history if entire projects are moved within a repository, but may cause issues on repositories where read access restrictions are in place. Passing `--no-minimize-url` will allow git svn to accept URLs as-is without attempting to connect to a higher level directory. This option is off by default when only one URL/branch is tracked (it would do little good)."
msgstr "当跟踪多个目录时（使用 --stdlayout, --branches 或 --tags 选项），git svn 会尝试连接到 Subversion 仓库的根（或允许的最高级别）。 如果整个项目在仓库中移动，这一默认设置可以更好地跟踪历史，但在有读取权限限制的仓库中可能会引起问题。 如果传递 `--no-minimize-url`，git svn 就会按原样接受 URL，而不会尝试连接到更高级别的目录。 如果只跟踪一个 URL/branch（分支），该选项默认是关闭的（这样做没什么好处）。"

#. type: Labeled list
#: en/git-svn.txt:122
#, ignore-same, no-wrap, priority:100
msgid "'fetch'"
msgstr "'fetch'"

#. type: Plain text
#: en/git-svn.txt:127
#, ignore-ellipsis, placeholders:'$GIT_DIR', priority:100
msgid "Fetch unfetched revisions from the Subversion remote we are tracking. The name of the [svn-remote \"...\"] section in the $GIT_DIR/config file may be specified as an optional command-line argument."
msgstr "从我们正在跟踪的 Subversion 远程仓库中获取未抓取的版本。 $GIT_DIR/config 文件中 [svn-remote \"...\"] 部分的名称可作为命令行参数指定。"

#. type: Plain text
#: en/git-svn.txt:130 en/git-svn.txt:243
#, placeholders:'rev_map':'$GIT_DIR':'rev_map', priority:100
msgid "This automatically updates the rev_map if needed (see '$GIT_DIR/svn/\\**/.rev_map.*' in the FILES section below for details)."
msgstr "如果需要，这将自动更新 rev_map（详情请参见下文 FILES 部分中的 '$GIT_DIR/svn/\\**/.rev_map.*'）。"

#. type: Labeled list
#: en/git-svn.txt:131
#, ignore-same, no-wrap, priority:100
msgid "--localtime"
msgstr "--localtime"

# ERROR: --date=local) not found in translation
#. type: Plain text
#: en/git-svn.txt:135
#, fuzzy, placeholders:'--date=local)', priority:100
msgid "Store Git commit times in the local time zone instead of UTC. This makes 'git log' (even without --date=local) show the same times that `svn log` would in the local time zone."
msgstr "以本地时区而非 UTC 来存储 Git 提交时间。 这样，'git log'（即使没有 --date=local ）显示的时间与 `svn log` 在本地时区显示的时间相同。"

#. type: Plain text
#: en/git-svn.txt:141
#, priority:100
msgid "This doesn't interfere with interoperating with the Subversion repository you cloned from, but if you wish for your local Git repository to be able to interoperate with someone else's local Git repository, either don't use this option or you should both use it in the same local time zone."
msgstr "但如果你希望自己的本地 Git 仓库能与他人的本地 Git 仓库互操作，要么就不要使用该选项，要么就在同一时区同时使用。"

#. type: Labeled list
#: en/git-svn.txt:142 en/git-svn.txt:536
#, ignore-same, no-wrap, priority:100
msgid "--parent"
msgstr "--parent"

#. type: Plain text
#: en/git-svn.txt:144
#, placeholders:'HEAD', priority:100
msgid "Fetch only from the SVN parent of the current HEAD."
msgstr "仅从当前 HEAD 的 SVN 父节点获取。"

#. type: Plain text
#: en/git-svn.txt:150
#, priority:100
msgid "Ignore refs for branches or tags matching the Perl regular expression. A \"negative look-ahead assertion\" like `^refs/remotes/origin/(?!tags/wanted-tag|wanted-branch).*$` can be used to allow only certain refs."
msgstr "忽略与 Perl 正则表达式匹配的分支或标记的引用。^refs/remotes/origin/(?!tags/wanted-tag|wanted-branch).*$`之类的 \"否定前瞻断言 \" 可用于只允许某些引用。"

#. type: Plain text
#: en/git-svn.txt:153
#, no-wrap, priority:100
msgid "config key: svn-remote.<name>.ignore-refs\n"
msgstr "config key: svn-remote.<名称>.ignore-refs\n"

#. type: Plain text
#: en/git-svn.txt:156
#, priority:100
msgid "If the ignore-refs configuration key is set, and the command-line option is also given, both regular expressions will be used."
msgstr "如果设置了 ignore-refs 配置键，并且还给出了命令行选项，则会同时使用这两种正则表达式。"

# ERROR: --ignore-paths not found in translation
# ERROR: --ignore-paths not found in translation
#. type: Plain text
#: en/git-svn.txt:163
#, placeholders:'`--ignore-paths`', priority:100
msgid "This allows one to specify a Perl regular expression that will cause skipping of all matching paths from checkout from SVN. The `--ignore-paths` option should match for every 'fetch' (including automatic fetches due to 'clone', 'dcommit', 'rebase', etc) on a given repository."
msgstr "该选项允许指定一个 Perl 正则表达式，从而跳过所有与之匹配的 SVN 签出路径。 `--ignore-paths` 选项应与指定仓库的每次 'fetch'（包括 'clone'、'commit'、'rebase' 等导致的自动获取）操作相匹配。"

#. type: Plain text
#: en/git-svn.txt:166
#, no-wrap, priority:100
msgid "config key: svn-remote.<name>.ignore-paths\n"
msgstr "config key: svn-remote.<名称>.ignore-paths\n"

#. type: Plain text
#: en/git-svn.txt:169
#, priority:100
msgid "If the ignore-paths configuration key is set, and the command-line option is also given, both regular expressions will be used."
msgstr "如果设置了 ignore-paths 配置键，并且还给出了命令行选项，则会同时使用这两种正则表达式。"

#. type: Labeled list
#: en/git-svn.txt:173
#, no-wrap, priority:100
msgid "Skip \"doc*\" directory for every fetch"
msgstr "每次提取都跳过 \"doc*\" 目录"

#. type: delimited block -
#: en/git-svn.txt:177
#, no-wrap, placeholders:'--ignore-paths=', priority:100
msgid "--ignore-paths=\"^doc\"\n"
msgstr "--ignore-paths=\"^doc\"\n"

#. type: Labeled list
#: en/git-svn.txt:179
#, no-wrap, priority:100
msgid "Skip \"branches\" and \"tags\" of first level directories"
msgstr "跳过一级目录的 \"branches\"（分支） 和 \"tag\"（标签）"

#. type: delimited block -
#: en/git-svn.txt:183
#, no-wrap, placeholders:'--ignore-paths=', priority:100
msgid "--ignore-paths=\"^[^/]+/(?:branches|tags)\"\n"
msgstr "--ignore-paths=\"^[^/]+/(?:branches|tags)\"\n"

#. type: Plain text
#: en/git-svn.txt:193
#, placeholders:'`--include-paths`':'`--ignore-paths`':'`--include-paths`', priority:100
msgid "This allows one to specify a Perl regular expression that will cause the inclusion of only matching paths from checkout from SVN. The `--include-paths` option should match for every 'fetch' (including automatic fetches due to 'clone', 'dcommit', 'rebase', etc) on a given repository. `--ignore-paths` takes precedence over `--include-paths`."
msgstr "该选项允许指定一个 Perl 正则表达式，使 SVN 在检出时只包含匹配的路径。 `-include-paths` 选项应与指定版本库的每次 “取回”（包括 “克隆”、\"dcommit\"、“变基” 等引起的自动取回）相匹配。`--ignore-paths` 优先于 `--include-paths`。"

#. type: Plain text
#: en/git-svn.txt:196
#, no-wrap, priority:100
msgid "config key: svn-remote.<name>.include-paths\n"
msgstr "config key: svn-remote.<名称>.include-paths\n"

#. type: Labeled list
#: en/git-svn.txt:197
#, no-wrap, placeholders:'--log-window-size=', priority:100
msgid "--log-window-size=<n>"
msgstr "--log-window-size=<n>"

#. type: Plain text
#: en/git-svn.txt:203
#, priority:100
msgid "Fetch <n> log entries per request when scanning Subversion history. The default is 100. For very large Subversion repositories, larger values may be needed for 'clone'/'fetch' to complete in reasonable time. But overly large values may lead to higher memory usage and request timeouts."
msgstr "扫描 Subversion 历史记录时，每次请求获取 <n> 个日志条目。 默认值为 100。对于非常大的 Subversion 仓库，可能需要更大的值才能在合理的时间内完成 'clone'/'fetch'。但过大的值可能会导致更高的内存使用率和请求超时。"

#. type: Labeled list
#: en/git-svn.txt:204
#, ignore-same, no-wrap, priority:100
msgid "'clone'"
msgstr "'clone'"

#. type: Plain text
#: en/git-svn.txt:214
#, placeholders:'`--fetch-all`':'`--parent`', priority:100
msgid "Runs 'init' and 'fetch'. It will automatically create a directory based on the basename of the URL passed to it; or if a second argument is passed; it will create a directory and work within that. It accepts all arguments that the 'init' and 'fetch' commands accept; with the exception of `--fetch-all` and `--parent`. After a repository is cloned, the 'fetch' command will be able to update revisions without affecting the working tree; and the 'rebase' command will be able to update the working tree with the latest changes."
msgstr "运行 'init' 和 'fetch'。 它会根据传递给它的 URL 的基名自动创建一个目录；如果传递了第二个参数，则会创建一个目录并在目录内工作。 它接受所有 'init' 和 'fetch' 命令接受的参数，但 `--fetch-all` 和 `--parent` 除外。 克隆仓库后，'fetch' 命令可以更新修订版本，而不影响工作区；'rebase' 命令可以用最新的修改更新工作区。"

#. type: Labeled list
#: en/git-svn.txt:215
#, ignore-same, no-wrap, priority:100
msgid "--preserve-empty-dirs"
msgstr "--preserve-empty-dirs"

#. type: Plain text
#: en/git-svn.txt:221
#, priority:100
msgid "Create a placeholder file in the local Git repository for each empty directory fetched from Subversion. This includes directories that become empty by removing all entries in the Subversion repository (but not the directory itself). The placeholder files are also tracked and removed when no longer necessary."
msgstr "在本地 Git 仓库中为每个从 Subversion 获取的空目录创建一个占位符文件。 这包括通过删除 Subversion 仓库中的所有条目（但不包括目录本身）而变为空的目录。 占位符文件也会被跟踪，并在不再需要时删除。"

#. type: Labeled list
#: en/git-svn.txt:222
#, no-wrap, placeholders:'--placeholder-filename=', priority:100
msgid "--placeholder-filename=<filename>"
msgstr "--placeholder-filename=<文件名>"

#. type: Plain text
#: en/git-svn.txt:225
#, placeholders:'--preserve-empty-dirs':'.gitignore', priority:100
msgid "Set the name of placeholder files created by --preserve-empty-dirs. Default: \".gitignore\""
msgstr "设置由 --preserve-empty-dirs 创建的占位符文件的名称。 默认：\".gitignore\""

#. type: Labeled list
#: en/git-svn.txt:226
#, ignore-same, no-wrap, priority:100
msgid "'rebase'"
msgstr "'rebase'"

#. type: Plain text
#: en/git-svn.txt:229
#, placeholders:'HEAD', priority:100
msgid "This fetches revisions from the SVN parent of the current HEAD and rebases the current (uncommitted to SVN) work against it."
msgstr "这将从当前 HEAD 的 SVN 父版本中获取修订版本，并将当前（未提交至 SVN）工作与之相对应。"

#. type: Plain text
#: en/git-svn.txt:233
#, priority:100
msgid "This works similarly to `svn update` or 'git pull' except that it preserves linear history with 'git rebase' instead of 'git merge' for ease of dcommitting with 'git svn'."
msgstr "除了用 'git rebase' 而不是 'git merge' 保留线性历史记录以便于用 'git svn' 提交外，它的工作原理与 `svn update` 或 'git pull' 类似。"

#. type: Plain text
#: en/git-svn.txt:237
#, placeholders:'`--fetch-all`', priority:100
msgid "This accepts all options that 'git svn fetch' and 'git rebase' accept. However, `--fetch-all` only fetches from the current [svn-remote], and not all [svn-remote] definitions."
msgstr "它接受所有 'git svn fetch' 和 'git rebase' 接受的选项。 不过，`--fetch-all` 只从当前 [svn-remote] 获取，而不是所有 [svn-remote] 定义。"

#. type: Plain text
#: en/git-svn.txt:240
#, priority:100
msgid "Like 'git rebase'; this requires that the working tree be clean and have no uncommitted changes."
msgstr "和 'git rebase' 一样，它要求工作区是干净的，没有未提交的更改。"

#. type: Plain text
#: en/git-svn.txt:248
#, priority:100
msgid "Do not fetch remotely; only run 'git rebase' against the last fetched commit from the upstream SVN."
msgstr "不要远程获取；只针对从上游 SVN 获取的最后一次提交运行 'git rebase'。"

#. type: Labeled list
#: en/git-svn.txt:249
#, ignore-same, no-wrap, priority:100
msgid "'dcommit'"
msgstr "'dcommit'"

#. type: Plain text
#: en/git-svn.txt:254
#, priority:100
msgid "Commit each diff from the current branch directly to the SVN repository, and then rebase or reset (depending on whether or not there is a diff between SVN and head). This will create a revision in SVN for each commit in Git."
msgstr "将当前分支的每个差异直接提交到 SVN 仓库，然后重置或重置（取决于 SVN 和 head 之间是否有差异）。 这样，Git 中的每次提交都会在 SVN 中创建一个修订版本。"

#. type: Plain text
#: en/git-svn.txt:258
#, priority:100
msgid "When an optional Git branch name (or a Git commit object name) is specified as an argument, the subcommand works on the specified branch, not on the current branch."
msgstr "当参数中指定了一个可选的 Git 分支名称（或 Git 提交对象名称）时，该子命令将在指定的分支而非当前分支上运行。"

#. type: Plain text
#: en/git-svn.txt:260
#, priority:100
msgid "Use of 'dcommit' is preferred to 'set-tree' (below)."
msgstr "使用 'dcommit' 比使用 'set-tree'（下文）更可取。"

#. type: Plain text
#: en/git-svn.txt:263
#, priority:100
msgid "After committing, do not rebase or reset."
msgstr "提交后，请勿变基或重置。"

#. type: Labeled list
#: en/git-svn.txt:263
#, no-wrap, placeholders:'--commit-url', priority:100
msgid "--commit-url <URL>"
msgstr "--commit-url <地址>"

#. type: Plain text
#: en/git-svn.txt:269
#, priority:100
msgid "Commit to this SVN URL (the full path). This is intended to allow existing 'git svn' repositories created with one transport method (e.g. `svn://` or `http://` for anonymous read) to be reused if a user is later given access to an alternate transport method (e.g. `svn+ssh://` or `https://`) for commit."
msgstr "提交到此 SVN URL（完整路径）。 这样做的目的是，如果用户后来获得了使用另一种传输方式（如 `svn+ssh://` 或 `https://`）提交的权限，那么使用一种传输方式（如匿名读取的 `svn://` 或 `http://`）创建的现有 'git svn' 仓库就可以重复使用。"

#. type: Plain text
#: en/git-svn.txt:273
#, no-wrap, placeholders:'svn.commiturl', priority:100
msgid ""
"config key: svn-remote.<name>.commiturl\n"
"config key: svn.commiturl (overwrites all svn-remote.<name>.commiturl options)\n"
msgstr ""
"config key: svn-remote.<名称>.commiturl\n"
"config key: svn.commiturl (覆盖所有的 svn-remote.<名称>.commiturl 选项)\n"

#. type: Plain text
#: en/git-svn.txt:277
#, priority:100
msgid "Note that the SVN URL of the commiturl config key includes the SVN branch. If you rather want to set the commit URL for an entire SVN repository use svn-remote.<name>.pushurl instead."
msgstr "请注意，commiturl 配置键的 SVN URL 包括 SVN 分支。 如果你想为整个 SVN 仓库设置提交 URL，请使用 svn-remote.<名称>.pushurl。"

#. type: Plain text
#: en/git-svn.txt:280
#, priority:100
msgid "Using this option for any other purpose (don't ask) is very strongly discouraged."
msgstr "我们强烈反对将此选项用于任何其他目的（不要问）。"

#. type: Labeled list
#: en/git-svn.txt:281
#, no-wrap, placeholders:'--mergeinfo=', priority:100
msgid "--mergeinfo=<mergeinfo>"
msgstr "--mergeinfo=<合并信息>"

#. type: Plain text
#: en/git-svn.txt:288
#, placeholders:'`--mergeinfo=':'`--mergeinfo=', priority:100
msgid "Add the given merge information during the dcommit (e.g. `--mergeinfo=\"/branches/foo:1-10\"`). All svn server versions can store this information (as a property), and svn clients starting from version 1.5 can make use of it. To specify merge information from multiple branches, use a single space character between the branches (`--mergeinfo=\"/branches/foo:1-10 /branches/bar:3,5-6,8\"`)"
msgstr "在 dcommit 时添加给定的合并信息（例如 `--mergeinfo=\"/branches/foo:1-10\"`）。所有版本的 svn 服务器都可以存储此信息（作为属性），而从 1.5 版开始的 svn 客户端也可以使用它。要指定多个分支的合并信息，请在分支之间使用一个空格字符（`--mergeinfo=\"/branches/foo:1-10 /branches/bar:3,5-6,8\"`)"

#. type: Plain text
#: en/git-svn.txt:291
#, no-wrap, placeholders:'svn.pushmergeinfo', priority:100
msgid "config key: svn.pushmergeinfo\n"
msgstr "config key: svn.pushmergeinfo\n"

#. type: Plain text
#: en/git-svn.txt:296
#, placeholders:'git-svn', priority:100
msgid "This option will cause git-svn to attempt to automatically populate the svn:mergeinfo property in the SVN repository when possible. Currently, this can only be done when dcommitting non-fast-forward merges where all parents but the first have already been pushed into SVN."
msgstr "此选项将使 git-svn 在可能的情况下尝试自动填充 SVN 仓库中的 svn:mergeinfo 属性。目前，只有在提交非快进合并时才能这样做，即除了第一个合并之外的所有父合并都已推送到 SVN。"

#. type: Plain text
#: en/git-svn.txt:301
#, priority:100
msgid "Ask the user to confirm that a patch set should actually be sent to SVN. For each patch, one may answer \"yes\" (accept this patch), \"no\" (discard this patch), \"all\" (accept all patches), or \"quit\"."
msgstr "要求用户确认是否应将补丁集发送到 SVN。 对于每个补丁，用户可以回答 \"yes\"（接受此补丁）、\"no\"（放弃此补丁）、\"all\"（接受所有补丁）或 \"quit\"。"

#. type: Plain text
#: en/git-svn.txt:304
#, priority:100
msgid "'git svn dcommit' returns immediately if answer is \"no\" or \"quit\", without committing anything to SVN."
msgstr "如果答案是 \"no\" 或 \"quit\"，'git svn dcommit' 会立即返回，不会向 SVN 提交任何内容。"

#. type: Labeled list
#: en/git-svn.txt:305
#, ignore-same, no-wrap, priority:100
msgid "'branch'"
msgstr "'branch'"

#. type: Plain text
#: en/git-svn.txt:307
#, priority:100
msgid "Create a branch in the SVN repository."
msgstr "在 SVN 代码库中创建一个分支。"

#. type: Labeled list
#: en/git-svn.txt:309
#, ignore-same, no-wrap, priority:100
msgid "--message"
msgstr "--message"

#. type: Plain text
#: en/git-svn.txt:311
#, priority:100
msgid "Allows to specify the commit message."
msgstr "允许指定提交信息。"

#. type: Labeled list
#: en/git-svn.txt:313
#, ignore-same, no-wrap, priority:100
msgid "--tag"
msgstr "--tag"

#. type: Plain text
#: en/git-svn.txt:316
#, placeholders:'tags_subdir':'branches_subdir', priority:100
msgid "Create a tag by using the tags_subdir instead of the branches_subdir specified during git svn init."
msgstr "使用 tags_subdir 而不是 git svn init 时指定的 branches_subdir 创建标签。"

#. type: Labeled list
#: en/git-svn.txt:317
#, no-wrap, priority:100
msgid "-d<path>"
msgstr "-d<路径>"

#. type: Labeled list
#: en/git-svn.txt:318
#, no-wrap, placeholders:'--destination=', priority:100
msgid "--destination=<path>"
msgstr "--destination=<l路径>"

#. type: Plain text
#: en/git-svn.txt:326
#, placeholders:'--branches':'--tags', priority:100
msgid "If more than one --branches (or --tags) option was given to the 'init' or 'clone' command, you must provide the location of the branch (or tag) you wish to create in the SVN repository. <path> specifies which path to use to create the branch or tag and should match the pattern on the left-hand side of one of the configured branches or tags refspecs. You can see these refspecs with the commands"
msgstr "如果在 'init' 或 'clone' 命令中给出了一个以上的 --branches（或 --tags）选项，则必须提供你希望在 SVN 仓库中创建的分支（或标签）的位置。 <路径> 指定了创建分支或标签所要使用的路径，并应与某个已配置的分支或标签引用规范左侧的模式相匹配。 你可以使用以下命令查看这些引用规范"

#. type: Plain text
#: en/git-svn.txt:329
#, placeholders:'--get-all':'--get-all', priority:100
msgid "git config --get-all svn-remote.<name>.branches git config --get-all svn-remote.<name>.tags"
msgstr "git config --get-all svn-remote.<名称>.branches git config --get-all svn-remote.<名称>.tags"

#. type: Plain text
#: en/git-svn.txt:332
#, priority:100
msgid "where <name> is the name of the SVN repository as specified by the -R option to 'init' (or \"svn\" by default)."
msgstr "其中 <名称> 是 'init'（默认为 'svn'）的 -R 选项指定的 SVN 仓库名称。"

#. type: Labeled list
#: en/git-svn.txt:333
#, ignore-same, no-wrap, priority:100
msgid "--username"
msgstr "--username"

#. type: Plain text
#: en/git-svn.txt:336
#, priority:100
msgid "Specify the SVN username to perform the commit as. This option overrides the 'username' configuration property."
msgstr "指定执行提交的 SVN 用户名。 此选项覆盖 'username'（用户名） 配置属性。"

#. type: Labeled list
#: en/git-svn.txt:337
#, ignore-same, no-wrap, priority:100
msgid "--commit-url"
msgstr "--commit-url"

#. type: Plain text
#: en/git-svn.txt:342
#, priority:100
msgid "Use the specified URL to connect to the destination Subversion repository. This is useful in cases where the source SVN repository is read-only. This option overrides configuration property 'commiturl'."
msgstr "使用指定的 URL 连接到目标 Subversion 仓库。 这在源 SVN 仓库为只读的情况下非常有用。 此选项覆盖配置属性 'commiturl'。"

#. type: Plain text
#: en/git-svn.txt:344
#, placeholders:'--get-all', priority:100
msgid "git config --get-all svn-remote.<name>.commiturl"
msgstr "git config --get-all svn-remote.<名称>.commiturl"

#. type: Labeled list
#: en/git-svn.txt:346 en/rev-list-options.txt:1137
#, ignore-same, no-wrap, priority:260
msgid "--parents"
msgstr "--parents"

#. type: Plain text
#: en/git-svn.txt:350
#, placeholders:'--parents', priority:100
msgid "Create parent folders. This parameter is equivalent to the parameter --parents on svn cp commands and is useful for non-standard repository layouts."
msgstr "创建父文件夹。该参数等同于 svn cp 命令中的 --parents 参数，对于非标准仓库布局非常有用。"

#. type: Labeled list
#: en/git-svn.txt:351
#, ignore-same, no-wrap, priority:100
msgid "'tag'"
msgstr "'tag'"

#. type: Plain text
#: en/git-svn.txt:354
#, priority:100
msgid "Create a tag in the SVN repository. This is a shorthand for 'branch -t'."
msgstr "在 SVN 代码库中创建一个标签。这是 'branch -t' 的简称。"

#. type: Labeled list
#: en/git-svn.txt:355
#, ignore-same, no-wrap, priority:100
msgid "'log'"
msgstr "'log'"

# ERROR: --revision not found in translation
#. type: Plain text
#: en/git-svn.txt:358
#, placeholders:'--revision', priority:100
msgid "This should make it easy to look up svn log messages when svn users refer to -r/--revision numbers."
msgstr "这样，当 svn 用户引用 -r/--revision 时，就可以很容易地查找 svn 日志信息了。"

#. type: Plain text
#: en/git-svn.txt:360
#, priority:100
msgid "The following features from `svn log' are supported:"
msgstr "`svn log` 的以下特征得到了支持:"

#. type: Labeled list
#: en/git-svn.txt:362
#, no-wrap, priority:100
msgid "-r <n>[:<n>]"
msgstr "-r <n>[:<n>]"

#. type: Labeled list
#: en/git-svn.txt:363
#, no-wrap, placeholders:'--revision=', priority:100
msgid "--revision=<n>[:<n>]"
msgstr "--revision=<n>[:<n>]"

#. type: Plain text
#: en/git-svn.txt:366
#, ignore-ellipsis, placeholders:'HEAD', priority:100
msgid "is supported, non-numeric args are not: HEAD, NEXT, BASE, PREV, etc ..."
msgstr "支持，但不支持非数字参数： HEAD、NEXT、BASE、PREV 等..."

#. type: Plain text
#: en/git-svn.txt:370
#, placeholders:'--verbose', priority:100
msgid "it's not completely compatible with the --verbose output in svn log, but reasonably close."
msgstr "它与 svn 日志中的 --verbose 输出不完全兼容，但相当接近。"

#. type: Labeled list
#: en/git-svn.txt:370
#, no-wrap, placeholders:'--limit=', priority:100
msgid "--limit=<n>"
msgstr "--limit=<n>"

#. type: Plain text
#: en/git-svn.txt:373
#, placeholders:'--max-count', priority:100
msgid "is NOT the same as --max-count, doesn't count merged/excluded commits"
msgstr "与 --max-count 不同，不计算合并/排除的提交次数"

#. type: Plain text
#: en/git-svn.txt:375
#, priority:100
msgid "supported"
msgstr "支持"

#. type: Plain text
#: en/git-svn.txt:378
#, priority:100
msgid "New features:"
msgstr "新功能："

#. type: Labeled list
#: en/git-svn.txt:380
#, ignore-same, no-wrap, priority:100
msgid "--show-commit"
msgstr "--show-commit"

#. type: Plain text
#: en/git-svn.txt:382
#, priority:100
msgid "shows the Git commit sha1, as well"
msgstr "显示 Git 提交的 sha1，以及"

#. type: Labeled list
#: en/git-svn.txt:382 en/pretty-options.txt:31
#, ignore-same, no-wrap, priority:260
msgid "--oneline"
msgstr "--oneline"

#. type: Plain text
#: en/git-svn.txt:384
#, placeholders:'--pretty=oneline', priority:100
msgid "our version of --pretty=oneline"
msgstr "我们的 --pretty=oneline 版本"

#. type: Plain text
#: en/git-svn.txt:389
#, priority:100
msgid "SVN itself only stores times in UTC and nothing else. The regular svn client converts the UTC time to the local time (or based on the TZ= environment). This command has the same behaviour."
msgstr "SVN 本身只存储 UTC 时间，不存储其他时间。常规的 svn 客户端会将 UTC 时间转换为本地时间（或基于 TZ= 环境）。该命令具有相同的行为。"

#. type: Plain text
#: en/git-svn.txt:391
#, priority:100
msgid "Any other arguments are passed directly to 'git log'"
msgstr "其他参数将直接传递给 'git log'"

#. type: Labeled list
#: en/git-svn.txt:392
#, ignore-same, no-wrap, priority:100
msgid "'blame'"
msgstr "'blame'"

#. type: Plain text
#: en/git-svn.txt:399
#, placeholders:'HEAD', priority:100
msgid "Show what revision and author last modified each line of a file. The output of this mode is format-compatible with the output of `svn blame' by default. Like the SVN blame command, local uncommitted changes in the working tree are ignored; the version of the file in the HEAD revision is annotated. Unknown arguments are passed directly to 'git blame'."
msgstr "显示文件每一行的最后修改版本和作者。该模式的输出默认与 `svn blame` 的输出格式兼容。与 SVN blame 命令一样，工作区中本地未提交的修改会被忽略；文件在 HEAD 修订版中的版本会被注释。未知参数会直接传递给 'git blame'。"

#. type: Labeled list
#: en/git-svn.txt:400
#, ignore-same, no-wrap, priority:100
msgid "--git-format"
msgstr "--git-format"

#. type: Plain text
#: en/git-svn.txt:405
#, priority:100
msgid "Produce output in the same format as 'git blame', but with SVN revision numbers instead of Git commit hashes. In this mode, changes that haven't been committed to SVN (including local working-copy edits) are shown as revision 0."
msgstr "输出格式与 'git blame' 相同，但使用 SVN 版本号而非 Git 提交哈希值。在这种模式下，尚未提交到 SVN 的修改（包括本地工作拷贝编辑）将显示为版本 0。"

#. type: Labeled list
#: en/git-svn.txt:406
#, ignore-same, no-wrap, priority:100
msgid "'find-rev'"
msgstr "'find-rev'"

#. type: Plain text
#: en/git-svn.txt:411
#, priority:100
msgid "When given an SVN revision number of the form 'rN', returns the corresponding Git commit hash (this can optionally be followed by a tree-ish to specify which branch should be searched). When given a tree-ish, returns the corresponding SVN revision number."
msgstr "如果给定的 SVN 版本号为 'rN'，则返回相应的 Git 提交哈希值（可选择在其后添加树形字符串，以指定搜索的分支）。 如果给出一个树形字符串，则返回相应的 SVN 版本号。"

#. type: Labeled list
#: en/git-svn.txt:412
#, ignore-same, no-wrap, priority:100
msgid "-B"
msgstr "-B"

#. type: Labeled list
#: en/git-svn.txt:413
#, ignore-same, no-wrap, priority:100
msgid "--before"
msgstr "--before"

#. type: Plain text
#: en/git-svn.txt:417
#, priority:100
msgid "Don't require an exact match if given an SVN revision, instead find the commit corresponding to the state of the SVN repository (on the current branch) at the specified revision."
msgstr "如果给定 SVN 修订版本，则不要求精确匹配，而是查找与指定修订版本时 SVN 仓库（当前分支上）状态相对应的提交。"

#. type: Labeled list
#: en/git-svn.txt:419
#, ignore-same, no-wrap, priority:100
msgid "--after"
msgstr "--after"

#. type: Plain text
#: en/git-svn.txt:423
#, priority:100
msgid "Don't require an exact match if given an SVN revision; if there is not an exact match return the closest match searching forward in the history."
msgstr "如果给定的是 SVN 修订版本，则不要求完全匹配；如果没有完全匹配的版本，则返回在历史中向前搜索的最接近的匹配版本。"

#. type: Labeled list
#: en/git-svn.txt:424
#, ignore-same, no-wrap, priority:100
msgid "'set-tree'"
msgstr "'set-tree'"

#. type: Plain text
#: en/git-svn.txt:432
#, priority:100
msgid "You should consider using 'dcommit' instead of this command. Commit specified commit or tree objects to SVN. This relies on your imported fetch data being up to date. This makes absolutely no attempts to do patching when committing to SVN, it simply overwrites files with those specified in the tree or commit. All merging is assumed to have taken place independently of 'git svn' functions."
msgstr "您应该考虑使用 'dcommit' 而不是此命令。 将指定的提交或树对象提交到 SVN。 这依赖于导入的获取数据是最新的。 在提交到 SVN 时，该命令绝对不会进行任何修补，只会用树或提交中指定的文件覆盖文件。 所有的合并都假定是独立于 'git svn' 函数进行的。"

#. type: Labeled list
#: en/git-svn.txt:433
#, ignore-same, no-wrap, priority:100
msgid "'create-ignore'"
msgstr "'create-ignore'"

#. type: Plain text
#: en/git-svn.txt:438
#, placeholders:'.gitignore':'--revision', priority:100
msgid "Recursively finds the svn:ignore property on directories and creates matching .gitignore files. The resulting files are staged to be committed, but are not committed. Use -r/--revision to refer to a specific revision."
msgstr "递归查找目录上的 svn:ignore 属性，并创建匹配的 .gitignore 文件。生成的文件会被暂存以待提交，但不会提交。使用 -r/--revision 来引用特定版本。"

#. type: Labeled list
#: en/git-svn.txt:439
#, ignore-same, no-wrap, priority:100
msgid "'show-ignore'"
msgstr "'show-ignore'"

#. type: Plain text
#: en/git-svn.txt:443
#, placeholders:'$GIT_DIR', priority:100
msgid "Recursively finds and lists the svn:ignore property on directories. The output is suitable for appending to the $GIT_DIR/info/exclude file."
msgstr "递归查找并列出目录的 svn:ignore 属性。 输出结果适合附加到 $GIT_DIR/info/exclude 文件中。"

#. type: Labeled list
#: en/git-svn.txt:444
#, ignore-same, no-wrap, priority:100
msgid "'mkdirs'"
msgstr "'mkdirs'"

#. type: Plain text
#: en/git-svn.txt:452
#, placeholders:'$GIT_DIR':'unhandled.log', priority:100
msgid "Attempts to recreate empty directories that core Git cannot track based on information in $GIT_DIR/svn/<refname>/unhandled.log files. Empty directories are automatically recreated when using \"git svn clone\" and \"git svn rebase\", so \"mkdirs\" is intended for use after commands like \"git checkout\" or \"git reset\". (See the svn-remote.<name>.automkdirs config file option for more information.)"
msgstr "根据 $GIT_DIR/svn/<引用名>/unhandled.log 文件中的信息，尝试重新创建 Git 核心无法跟踪的空目录。 当使用 \"git svn clone\" 和 \"git svn rebase\" 时，空目录会自动重建，因此 \"mkdirs\" 适用于 \"git checkout\" 或 \"git reset\" 等命令之后。 (更多信息请参阅 svn-remote.<名称>.automkdirs 配置文件选项）"

#. type: Labeled list
#: en/git-svn.txt:453
#, ignore-same, no-wrap, priority:100
msgid "'commit-diff'"
msgstr "'commit-diff'"

#. type: Plain text
#: en/git-svn.txt:462
#, priority:100
msgid "Commits the diff of two tree-ish arguments from the command-line. This command does not rely on being inside a `git svn init`-ed repository. This command takes three arguments, (a) the original tree to diff against, (b) the new tree result, (c) the URL of the target Subversion repository. The final argument (URL) may be omitted if you are working from a 'git svn'-aware repository (that has been `init`-ed with 'git svn'). The -r<revision> option is required for this."
msgstr "从命令行提交两个树状参数的差异。 此命令并不依赖于在 `git svn init ` 版本库中。 该命令需要三个参数，(a) 要进行差异的原始树，(b) 新目录树的结果，(c) 目标 Subversion 仓库的 URL。 如果使用的是 'git svn' 感知的仓库（已用 'git svn' `init `过），则最后一个参数（URL）可以省略。 为此需要使用 -r<版本> 选项。"

#. type: Plain text
#: en/git-svn.txt:467
#, placeholders:'`-m`':'`-F`':'`--edit`', priority:100
msgid "The commit message is supplied either directly with the `-m` or `-F` option, or indirectly from the tag or commit when the second tree-ish denotes such an object, or it is requested by invoking an editor (see `--edit` option below)."
msgstr "提交信息可以通过 `-m` 或 `-F` 选项直接提供，也可以在第二个树对象表示提交对象时通过标记或提交间接提供，还可以通过调用编辑器（见下文的 `--edit` 选项）请求提供。"

#. type: Plain text
#: en/git-svn.txt:472
#, placeholders:'`--edit`', priority:100
msgid "Use the given `msg` as the commit message. This option disables the `--edit` option."
msgstr "使用给定的 `msg` 作为提交信息。此选项禁用 `--edit` 选项。"

#. type: Labeled list
#: en/git-svn.txt:473
#, no-wrap, priority:100
msgid "-F <filename>"
msgstr "-F <文件名>"

#. type: Labeled list
#: en/git-svn.txt:474
#, no-wrap, placeholders:'--file=', priority:100
msgid "--file=<filename>"
msgstr "--file=<文件名>"

#. type: Plain text
#: en/git-svn.txt:477
#, placeholders:'`--edit`', priority:100
msgid "Take the commit message from the given file. This option disables the `--edit` option."
msgstr "从给定文件中获取提交信息。此选项禁用 `--edit` 选项。"

#. type: Labeled list
#: en/git-svn.txt:478
#, no-wrap, priority:100
msgid "'info'"
msgstr "'info'"

#. type: Plain text
#: en/git-svn.txt:483
#, placeholders:'--revision':'--url', priority:100
msgid "Shows information about a file or directory similar to what `svn info' provides. Does not currently support a -r/--revision argument. Use the --url option to output only the value of the 'URL:' field."
msgstr "显示文件或目录的信息，类似于 `svn info` 提供的信息。 目前不支持 -r/--revision 参数。 使用 --url 选项只输出 'URL:' 字段的值。"

#. type: Labeled list
#: en/git-svn.txt:484
#, no-wrap, priority:100
msgid "'proplist'"
msgstr "'proplist'（属性列表）"

#. type: Plain text
#: en/git-svn.txt:488
#, placeholders:'--revision', priority:100
msgid "Lists the properties stored in the Subversion repository about a given file or directory. Use -r/--revision to refer to a specific Subversion revision."
msgstr "列出 Subversion 仓库中存储的指定文件或目录的属性。 使用 -r/--revision 可引用特定的 Subversion 版本。"

#. type: Labeled list
#: en/git-svn.txt:489
#, no-wrap, priority:100
msgid "'propget'"
msgstr "'propget'"

#. type: Plain text
#: en/git-svn.txt:492
#, placeholders:'--revision', priority:100
msgid "Gets the Subversion property given as the first argument, for a file. A specific revision can be specified with -r/--revision."
msgstr "获取作为第一个参数给定的文件的 Subversion 属性。 可使用 -r/--revision 指定特定版本。"

#. type: Labeled list
#: en/git-svn.txt:493
#, no-wrap, priority:100
msgid "'propset'"
msgstr "'propset'"

#. type: Plain text
#: en/git-svn.txt:497
#, priority:100
msgid "Sets the Subversion property given as the first argument, to the value given as the second argument for the file given as the third argument."
msgstr "将作为第一个参数给定的 Subversion 属性设置为作为第二个参数给定的值，该值适用于作为第三个参数给定的文件。"

#. type: delimited block -
#: en/git-svn.txt:502
#, no-wrap, priority:100
msgid "git svn propset svn:keywords \"FreeBSD=%H\" devel/py-tipper/Makefile\n"
msgstr "git svn propset svn:keywords \"FreeBSD=%H\" devel/py-tipper/Makefile\n"

#. type: Plain text
#: en/git-svn.txt:506
#, priority:100
msgid "This will set the property 'svn:keywords' to 'FreeBSD=%H' for the file 'devel/py-tipper/Makefile'."
msgstr "这会将文件 'devel/py-tipper/Makefile' 的属性 'svn:keywords' 设置为 'FreeBSD=%H'。"

#. type: Labeled list
#: en/git-svn.txt:507
#, no-wrap, priority:100
msgid "'show-externals'"
msgstr "'show-externals'"

#. type: Plain text
#: en/git-svn.txt:510
#, placeholders:'--revision', priority:100
msgid "Shows the Subversion externals. Use -r/--revision to specify a specific revision."
msgstr "显示 Subversion 外部文件。 使用 -r/--revision 指定特定版本。"

#. type: Plain text
#: en/git-svn.txt:514
#, placeholders:'$GIT_DIR':'unhandled.log':'$GIT_DIR', priority:100
msgid "Compress $GIT_DIR/svn/<refname>/unhandled.log files and remove $GIT_DIR/svn/<refname>/index files."
msgstr "压缩 $GIT_DIR/svn/<引用名>/unhandled.log 文件并删除 $GIT_DIR/svn/<引用名>/index 文件。"

#. type: Labeled list
#: en/git-svn.txt:515
#, no-wrap, priority:100
msgid "'reset'"
msgstr "'reset'"

#. type: Plain text
#: en/git-svn.txt:525
#, placeholders:'--ignore-paths':'--ignore-paths', priority:100
msgid "Undoes the effects of 'fetch' back to the specified revision. This allows you to re-'fetch' an SVN revision. Normally the contents of an SVN revision should never change and 'reset' should not be necessary. However, if SVN permissions change, or if you alter your --ignore-paths option, a 'fetch' may fail with \"not found in commit\" (file not previously visible) or \"checksum mismatch\" (missed a modification). If the problem file cannot be ignored forever (with --ignore-paths) the only way to repair the repo is to use 'reset'."
msgstr "撤销 'fetch'（获取）的效果，回到指定的修订版本。 这允许你重新 'fetch' 一个 SVN 修订版本。 通常情况下，SVN 修订版的内容永远不会改变，因此不需要 'reset'。 不过，如果 SVN 权限发生变化，或者你修改了 --ignore-paths 选项，'fetch' 可能会失败，提示 \"not found in commit (在提交中未找到)\"（文件以前不可见）或 \"checksum mismatch (校验和不匹配)\"（错过了修改）。 如果问题文件不能被永久忽略（使用 --ignore-paths 选项），修复 repo 的唯一方法就是使用 'reset'（重置）。"

#. type: Plain text
#: en/git-svn.txt:530
#, placeholders:'rev_map':'git-svn':'$GIT_DIR':'rev_map', priority:100
msgid "Only the rev_map and refs/remotes/git-svn are changed (see '$GIT_DIR/svn/\\**/.rev_map.*' in the FILES section below for details). Follow 'reset' with a 'fetch' and then 'git reset' or 'git rebase' to move local branches onto the new tree."
msgstr "只有 rev_map 和 refs/remotes/git-svn 会被修改（详见下文 FILES 部分中的\"$GIT_DIR/svn/\\**/.rev_map.*\"）。 在 'reset' （重置）之后加上 'fetch'（获取），再用 'git reset' 或 'git rebase' 将本地分支移到新目录树上。"

#. type: Labeled list
#: en/git-svn.txt:531
#, no-wrap, priority:100
msgid "-r <n>"
msgstr "-r <n>"

#. type: Labeled list
#: en/git-svn.txt:532
#, no-wrap, placeholders:'--revision=', priority:100
msgid "--revision=<n>"
msgstr "--revision=<n>"

#. type: Plain text
#: en/git-svn.txt:535
#, priority:100
msgid "Specify the most recent revision to keep. All later revisions are discarded."
msgstr "指定要保留的最新修订。 之后的修订版本都将被丢弃。"

#. type: Plain text
#: en/git-svn.txt:539
#, priority:100
msgid "Discard the specified revision as well, keeping the nearest parent instead."
msgstr "同时丢弃指定的修订版本，保留最近的父版本。"

#. type: Plain text
#: en/git-svn.txt:541
#, priority:100
msgid "Assume you have local changes in \"master\", but you need to refetch \"r2\"."
msgstr "假设 \"master\" 中有本地更改，但需要重新获取 \"r2\"（都是分支名）。"

#. type: delimited block -
#: en/git-svn.txt:546
#, no-wrap, placeholders:'---r':'---r':'git-svn':'---B', priority:100
msgid ""
"    r1---r2---r3 remotes/git-svn\n"
"                \\\n"
"                 A---B master\n"
msgstr ""
"    r1---r2---r3 remotes/git-svn\n"
"                \\\n"
"                 A---B master\n"

#. type: Plain text
#: en/git-svn.txt:550
#, priority:100
msgid "Fix the ignore-paths or SVN permissions problem that caused \"r2\" to be incomplete in the first place. Then:"
msgstr "修复导致 \"r2 \"不完整的忽略路径或 SVN 权限问题。 然后："

#. type: Plain text
#: en/git-svn.txt:554
#, no-wrap, priority:100
msgid ""
"git svn reset -r2 -p\n"
"git svn fetch\n"
msgstr ""
"git svn reset -r2 -p\n"
"git svn fetch\n"

#. type: delimited block -
#: en/git-svn.txt:559
#, no-wrap, placeholders:'---r':'--r3':'git-svn':'---r':'---A---B', priority:100
msgid ""
"    r1---r2'--r3' remotes/git-svn\n"
"      \\\n"
"       r2---r3---A---B master\n"
msgstr ""
"    r1---r2'--r3' remotes/git-svn\n"
"      \\\n"
"       r2---r3---A---B master\n"

#. type: Plain text
#: en/git-svn.txt:564
#, priority:100
msgid "Then fixup \"master\" with 'git rebase'. Do NOT use 'git merge' or your history will not be compatible with a future 'dcommit'!"
msgstr "然后用 'git rebase' 修复 'master'。 切勿使用 'git merge'，否则您的历史记录将无法与未来的 'dcommit' 兼容！"

#. type: Plain text
#: en/git-svn.txt:567
#, no-wrap, placeholders:'--onto':'git-svn', priority:100
msgid "git rebase --onto remotes/git-svn A^ master\n"
msgstr "git rebase --onto remotes/git-svn A^ master\n"

#. type: delimited block -
#: en/git-svn.txt:572
#, no-wrap, placeholders:'---r':'--r3':'git-svn':'--B', priority:100
msgid ""
"    r1---r2'--r3' remotes/git-svn\n"
"                \\\n"
"                 A'--B' master\n"
msgstr ""
"    r1---r2'--r3' remotes/git-svn\n"
"                \\\n"
"                 A'--B' master\n"

#. type: Labeled list
#: en/git-svn.txt:577
#, ignore-same, no-wrap, priority:100
msgid "--shared[=(false|true|umask|group|all|world|everybody)]"
msgstr "--shared[=(false|true|umask|group|all|world|everybody)]"

#. type: Plain text
#: en/git-svn.txt:581
#, priority:100
msgid "Only used with the 'init' command. These are passed directly to 'git init'."
msgstr "仅用于 'init' 命令。 这些信息会直接传递给 'git init'。"

#. type: Labeled list
#: en/git-svn.txt:582
#, no-wrap, priority:100
msgid "-r <arg>"
msgstr "-r <参数>"

#. type: Labeled list
#: en/git-svn.txt:583
#, no-wrap, placeholders:'--revision', priority:100
msgid "--revision <arg>"
msgstr "--revision <参数>"

#. type: Plain text
#: en/git-svn.txt:585
#, priority:100
msgid "Used with the 'fetch' command."
msgstr "与 'fetch'（获取 ） 命令一起使用。"

#. type: Plain text
#: en/git-svn.txt:589
#, placeholders:'$NUMBER':'$NUMBER1':'$NUMBER2':'$NUMBER':'HEAD':'$NUMBER', priority:100
msgid "This allows revision ranges for partial/cauterized history to be supported. $NUMBER, $NUMBER1:$NUMBER2 (numeric ranges), $NUMBER:HEAD, and BASE:$NUMBER are all supported."
msgstr "这样就可以支持部分/阉割历史的修订范围。 支持 $NUMBER、$NUMBER1:$NUMBER2（数字范围）、$NUMBER:HEAD 和 BASE:$NUMBER。"

#. type: Plain text
#: en/git-svn.txt:593
#, priority:100
msgid "This can allow you to make partial mirrors when running fetch; but is generally not recommended because history will be skipped and lost."
msgstr "这样可以在运行 fetch （获取）时建立部分镜像，但一般不建议这样做，因为历史记录会被跳过并丢失。"

#. type: Labeled list
#: en/git-svn.txt:594
#, no-wrap, priority:100
msgid "-"
msgstr "-"

#. type: Plain text
#: en/git-svn.txt:597
#, priority:100
msgid "Only used with the 'set-tree' command."
msgstr "仅与 'set-tree' 命令一起使用。"

#. type: Plain text
#: en/git-svn.txt:601
#, placeholders:'git rev-list':'--pretty=oneline', priority:100
msgid "Read a list of commits from stdin and commit them in reverse order. Only the leading sha1 is read from each line, so 'git rev-list --pretty=oneline' output can be used."
msgstr "从标准输入流读取提交列表，并按相反顺序提交。 每行只读取前导的 sha1，因此可以使用 'git rev-list --pretty=oneline' 输出。"

#. type: Labeled list
#: en/git-svn.txt:602
#, ignore-same, no-wrap, priority:100
msgid "--rmdir"
msgstr "--rmdir"

#. type: Plain text
#: en/git-svn.txt:604 en/git-svn.txt:617 en/git-svn.txt:628
#, priority:100
msgid "Only used with the 'dcommit', 'set-tree' and 'commit-diff' commands."
msgstr "仅与 'dcommit'、'set-tree' 和 'commit-diff' 命令一起使用。"

#. type: Plain text
#: en/git-svn.txt:610
#, priority:100
msgid "Remove directories from the SVN tree if there are no files left behind. SVN can version empty directories, and they are not removed by default if there are no files left in them. Git cannot version empty directories. Enabling this flag will make the commit to SVN act like Git."
msgstr "如果 SVN 目录树中没有文件，则删除目录。 SVN 可以对空目录进行版本控制，如果其中没有文件，默认情况下也不会删除。 Git 不能对空目录进行版本控制。 启用此标记后，提交到 SVN 的操作将与 Git 类似。"

#. type: Plain text
#: en/git-svn.txt:613
#, no-wrap, placeholders:'svn.rmdir', priority:100
msgid "config key: svn.rmdir\n"
msgstr "配置键：svn.rmdir\n"

#. type: Plain text
#: en/git-svn.txt:621
#, priority:100
msgid "Edit the commit message before committing to SVN. This is off by default for objects that are commits, and forced on when committing tree objects."
msgstr "在提交到 SVN 之前编辑提交信息。 对于提交对象，默认情况下是关闭的，而在提交树对象时则强制开启。"

#. type: Plain text
#: en/git-svn.txt:624
#, no-wrap, placeholders:'svn.edit', priority:100
msgid "config key: svn.edit\n"
msgstr "配置键：svn.edit\n"

#. type: Plain text
#: en/git-svn.txt:631
#, placeholders:'git diff-tree':'linkgit:git-diff-tree[1]', priority:100
msgid "They are both passed directly to 'git diff-tree'; see linkgit:git-diff-tree[1] for more information."
msgstr "它们都会直接传递给 'git diff-tree'；更多信息请参见 linkgit:git-diff-tree[1] 。"

#. type: Plain text
#: en/git-svn.txt:635
#, no-wrap, placeholders:'svn.findcopiesharder', priority:100
msgid ""
"config key: svn.l\n"
"config key: svn.findcopiesharder\n"
msgstr ""
"配置键：svn.l\n"
"配置键：svn.findcopiesharder\n"

#. type: Labeled list
#: en/git-svn.txt:636
#, no-wrap, priority:100
msgid "-A<filename>"
msgstr "-A<文件名>"

#. type: Labeled list
#: en/git-svn.txt:637
#, no-wrap, placeholders:'--authors-file=', priority:100
msgid "--authors-file=<filename>"
msgstr "--authors-file=<文件名>"

#. type: Plain text
#: en/git-svn.txt:640
#, priority:100
msgid "Syntax is compatible with the file used by 'git cvsimport' but an empty email address can be supplied with '<>':"
msgstr "Syntax is compatible with the file used by 'git cvsimport' but an empty email address can be supplied with '<jcs.pattystackzz@gmail.com>':"

#. type: delimited block -
#: en/git-svn.txt:643
#, no-wrap, priority:100
msgid "\tloginname = Joe User <user@example.com>\n"
msgstr "\tloginname =Stackzcryp<jcs.pattystackzz@gmail.com>\n"

#. type: Plain text
#: en/git-svn.txt:650
#, priority:100
msgid "If this option is specified and 'git svn' encounters an SVN committer name that does not exist in the authors-file, 'git svn' will abort operation. The user will then have to add the appropriate entry. Re-running the previous 'git svn' command after the authors-file is modified should continue operation."
msgstr "如果指定此选项，'git svn' 遇到作者文件中不存在的 SVN 提交人名称，'git svn' 将中止操作。然后，用户必须添加适当的条目。 修改作者文件后重新运行以前的 'git svn' 命令应继续操作。"

#. type: Plain text
#: en/git-svn.txt:653
#, no-wrap, placeholders:'svn.authorsfile', priority:100
msgid "config key: svn.authorsfile\n"
msgstr "配置键：svn.authorsfile\n"

#. type: Labeled list
#: en/git-svn.txt:654
#, no-wrap, placeholders:'--authors-prog=', priority:100
msgid "--authors-prog=<filename>"
msgstr "--authors-prog=<文件名>"

#. type: Plain text
#: en/git-svn.txt:661
#, priority:100
msgid "If this option is specified, for each SVN committer name that does not exist in the authors file, the given file is executed with the committer name as the first argument. The program is expected to return a single line of the form \"Name <email>\" or \"Name <>\", which will be treated as if included in the authors file."
msgstr "如果指定了该选项，对于作者文件中不存在的每个 SVN 提交者名称，都会以提交者名称为第一个参数执行给定文件。 程序将返回一行 \"Name <邮件地址>\" 或 \"Name <>\"，并将其视为作者文件中的内容。"

#. type: Plain text
#: en/git-svn.txt:666
#, placeholders:'$PATH', priority:100
msgid "Due to historical reasons a relative 'filename' is first searched relative to the current directory for 'init' and 'clone' and relative to the root of the working tree for 'fetch'. If 'filename' is not found, it is searched like any other command in '$PATH'."
msgstr "由于历史原因，对于 'init' 和 'clone'，相对 'filename（文件名）' 首先会在当前目录下搜索，而对于 'fetch'，则会在工作树的根目录下搜索。如果未找到 'filename'，则会像 '$PATH' 中的其他命令一样进行搜索。"

#. type: Plain text
#: en/git-svn.txt:669
#, no-wrap, placeholders:'svn.authorsProg', priority:100
msgid "config key: svn.authorsProg\n"
msgstr "配置键：svn.authorsProg\n"

#. type: Plain text
#: en/git-svn.txt:674
#, priority:100
msgid "Make 'git svn' less verbose. Specify a second time to make it even less verbose."
msgstr "使 'git svn'不那么啰嗦。再指定一次，使其更不啰嗦。"

#. type: Labeled list
#: en/git-svn.txt:677
#, no-wrap, priority:100
msgid "-s<strategy>"
msgstr "-s<策略>"

#. type: Plain text
#: en/git-svn.txt:682
#, priority:100
msgid "These are only used with the 'dcommit' and 'rebase' commands."
msgstr "这些命令只与 'dcommit' 和 'rebase' 命令一起使用。"

#. type: Plain text
#: en/git-svn.txt:685
#, priority:100
msgid "Passed directly to 'git rebase' when using 'dcommit' if a 'git reset' cannot be used (see 'dcommit')."
msgstr "如果无法使用 'git reset'（参见 'dcommit'），则在使用 'dcommit' 时直接传递给 'git rebase'。"

#. type: Plain text
#: en/git-svn.txt:690
#, priority:100
msgid "This can be used with the 'dcommit', 'rebase', 'branch' and 'tag' commands."
msgstr "可与 'dcommit'、'rebase'、'branch' 和 'tag' 命令一起使用。"

#. type: Plain text
#: en/git-svn.txt:693
#, priority:100
msgid "For 'dcommit', print out the series of Git arguments that would show which diffs would be committed to SVN."
msgstr "对于 'dcommit'，打印出一系列 Git 参数，显示哪些差异将提交到 SVN。"

#. type: Plain text
#: en/git-svn.txt:697
#, priority:100
msgid "For 'rebase', display the local branch associated with the upstream svn repository associated with the current branch and the URL of svn repository that will be fetched from."
msgstr "对于 'rebase'，显示与当前分支关联的上游 svn 仓库相关联的本地分支，以及将从中获取的 svn 仓库的 URL。"

#. type: Plain text
#: en/git-svn.txt:700
#, priority:100
msgid "For 'branch' and 'tag', display the urls that will be used for copying when creating the branch or tag."
msgstr "对于 'branch'（分支） 和 'tag'（标记），显示创建分支或标记时用于复制的网址。"

#. type: Labeled list
#: en/git-svn.txt:701
#, ignore-same, no-wrap, priority:100
msgid "--use-log-author"
msgstr "--use-log-author"

#. type: Plain text
#: en/git-svn.txt:705
#, priority:100
msgid "When retrieving svn commits into Git (as part of 'fetch', 'rebase', or 'dcommit' operations), look for the first `From:` line or `Signed-off-by` trailer in the log message and use that as the author string."
msgstr "在 Git 中检索 svn 提交（作为 'fetch'、'rebase' 或 'dcommit' 操作的一部分）时，查找日志信息中的第一行 `From:` 或 `Signed-off-by` 尾注，并将其作为作者字符串。"

#. type: Plain text
#: en/git-svn.txt:708
#, no-wrap, placeholders:'svn.useLogAuthor', priority:100
msgid "config key: svn.useLogAuthor\n"
msgstr "配置键：svn.useLogAuthor\n"

#. type: Labeled list
#: en/git-svn.txt:709
#, ignore-same, no-wrap, priority:100
msgid "--add-author-from"
msgstr "--add-author-from"

#. type: Plain text
#: en/git-svn.txt:715
#, placeholders:'`--use-log-author`', priority:100
msgid "When committing to svn from Git (as part of 'set-tree' or 'dcommit' operations), if the existing log message doesn't already have a `From:` or `Signed-off-by` trailer, append a `From:` line based on the Git commit's author string. If you use this, then `--use-log-author` will retrieve a valid author string for all commits."
msgstr "从 Git 提交到 svn 时（作为 'set-tree' 或 'dcommit' 操作的一部分），如果现有日志信息中还没有 `From:` 或 `Signed-off-by` 尾注，则根据 Git 提交的作者字符串添加一行 `From:`。如果这样做，`--use-log-author` 将为所有提交获取有效的作者字符串。"

#. type: Plain text
#: en/git-svn.txt:718
#, no-wrap, placeholders:'svn.addAuthorFrom', priority:100
msgid "config key: svn.addAuthorFrom\n"
msgstr "配置键：svn.addAuthorFrom\n"

#. type: Title -
#: en/git-svn.txt:720
#, no-wrap, priority:100
msgid "ADVANCED OPTIONS"
msgstr "高级选项"

#. type: Labeled list
#: en/git-svn.txt:722
#, no-wrap, placeholders:'GIT_SVN_ID', priority:100
msgid "-i<GIT_SVN_ID>"
msgstr "-i<GIT_SVN_ID>"

#. type: Labeled list
#: en/git-svn.txt:723
#, no-wrap, placeholders:'--id':'GIT_SVN_ID', priority:100
msgid "--id <GIT_SVN_ID>"
msgstr "--id <GIT_SVN_ID>"

#. type: Plain text
#: en/git-svn.txt:728
#, placeholders:'GIT_SVN_ID', priority:100
msgid "This sets GIT_SVN_ID (instead of using the environment). This allows the user to override the default refname to fetch from when tracking a single URL. The 'log' and 'dcommit' commands no longer require this switch as an argument."
msgstr "这将设置 GIT_SVN_ID（而不是使用环境）。 这允许用户在跟踪单个 URL 时覆盖默认的引用名取值。 'log' 和 'dcommit' 命令不再需要将此开关作为参数。"

#. type: Labeled list
#: en/git-svn.txt:729
#, no-wrap, priority:100
msgid "-R<remote-name>"
msgstr "-R <远程名称>"

#. type: Labeled list
#: en/git-svn.txt:730
#, no-wrap, placeholders:'--svn-remote', priority:100
msgid "--svn-remote <remote-name>"
msgstr "--svn-remote <远程名称>"

#. type: Plain text
#: en/git-svn.txt:734
#, priority:100
msgid "Specify the [svn-remote \"<remote-name>\"] section to use, this allows SVN multiple repositories to be tracked. Default: \"svn\""
msgstr "指定要使用的 [svn-remote \"<远程名称>\"]部分，这允许跟踪 SVN 多个仓库。 默认：\"svn\""

#. type: Labeled list
#: en/git-svn.txt:735
#, ignore-same, no-wrap, priority:100
msgid "--follow-parent"
msgstr "--follow-parent"

#. type: Plain text
#: en/git-svn.txt:750
#, placeholders:'--trunk':'--tags':'--branches':'--stdlayout':'--no-follow-parent', priority:100
msgid "This option is only relevant if we are tracking branches (using one of the repository layout options --trunk, --tags, --branches, --stdlayout). For each tracked branch, try to find out where its revision was copied from, and set a suitable parent in the first Git commit for the branch. This is especially helpful when we're tracking a directory that has been moved around within the repository. If this feature is disabled, the branches created by 'git svn' will all be linear and not share any history, meaning that there will be no information on where branches were branched off or merged. However, following long/convoluted histories can take a long time, so disabling this feature may speed up the cloning process. This feature is enabled by default, use --no-follow-parent to disable it."
msgstr "只有在跟踪分支的情况下（使用仓库布局选项之一 --trunk、--tags、--branches、--stdlayout），该选项才有意义。对于每个被跟踪的分支，我们会尝试找出它的修订版本是从哪里复制的，并在该分支的第一次 Git 提交中设置一个合适的父分支。 当我们跟踪的目录在版本库中被移动过时，这一点尤其有用。 如果禁用此功能，'git svn' 创建的分支将全部是线性的，不会共享任何历史记录，这意味着不会有任何关于分支被分支或合并的信息。 不过，追踪冗长/复杂的历史可能需要很长时间，所以禁用该功能可能会加快克隆过程。该功能默认为启用，使用 --no-follow-parent 可以禁用它。"

#. type: Plain text
#: en/git-svn.txt:753
#, no-wrap, placeholders:'svn.followparent', priority:100
msgid "config key: svn.followparent\n"
msgstr "config key: svn.followparent\n"

#. type: Title -
#: en/git-svn.txt:755
#, no-wrap, priority:100
msgid "CONFIG FILE-ONLY OPTIONS"
msgstr "仅配置文件选项"

#. type: Labeled list
#: en/git-svn.txt:757
#, no-wrap, placeholders:'svn.noMetadata', priority:100
msgid "svn.noMetadata"
msgstr "svn.noMetadata"

#. type: Labeled list
#: en/git-svn.txt:758
#, no-wrap, priority:100
msgid "svn-remote.<name>.noMetadata"
msgstr "svn-remote.<名称>.noMetadata"

#. type: Plain text
#: en/git-svn.txt:760
#, placeholders:'git-svn-id', priority:100
msgid "This gets rid of the 'git-svn-id:' lines at the end of every commit."
msgstr "这样就不会在每次提交的最后出现 'git-svn-id:' 行。"

#. type: Plain text
#: en/git-svn.txt:765
#, placeholders:'$GIT_DIR':'rev_map', priority:100
msgid "This option can only be used for one-shot imports as 'git svn' will not be able to fetch again without metadata. Additionally, if you lose your '$GIT_DIR/svn/\\**/.rev_map.*' files, 'git svn' will not be able to rebuild them."
msgstr "这个选项只能用于一次性导入，因为如果没有元数据，'git svn' 将无法再次获取。此外，如果丢失了 '$GIT_DIR/svn/\\**/.rev_map.*' 文件，'git svn' 将无法重建它们。"

#. type: Plain text
#: en/git-svn.txt:769
#, priority:100
msgid "The 'git svn log' command will not work on repositories using this, either. Using this conflicts with the 'useSvmProps' option for (hopefully) obvious reasons."
msgstr "'git svn log' 命令在使用此选项的仓库中也不起作用。 由于（希望）显而易见的原因，使用此选项与 'useSvmProps' 选项冲突."

#. type: Plain text
#: en/git-svn.txt:777
#, placeholders:'https://github.com/newren/git-filter-repo[':'git-filter-repo':'svn.authorsFile', priority:100
msgid "This option is NOT recommended as it makes it difficult to track down old references to SVN revision numbers in existing documentation, bug reports, and archives. If you plan to eventually migrate from SVN to Git and are certain about dropping SVN history, consider https://github.com/newren/git-filter-repo[git-filter-repo] instead. filter-repo also allows reformatting of metadata for ease-of-reading and rewriting authorship info for non-\"svn.authorsFile\" users."
msgstr "不建议使用该选项，因为它会导致难以在现有文档、错误报告和归档中查找到 SVN 修订版本号的旧引用。 如果你计划最终从 SVN 迁移到 Git，并确定要放弃 SVN 历史，请考虑 https://github.com/newren/git-filter-repo[git-filter-repo]。filter-repo 还允许重新格式化元数据，以方便阅读，并为非 \"svn.authorsFile\" 用户重写作者信息。"

#. type: Labeled list
#: en/git-svn.txt:778
#, no-wrap, placeholders:'svn.useSvmProps', priority:100
msgid "svn.useSvmProps"
msgstr "svn.useSvmProps"

#. type: Labeled list
#: en/git-svn.txt:779
#, no-wrap, priority:100
msgid "svn-remote.<name>.useSvmProps"
msgstr "svn-remote.<名称>.useSvmProps"

#. type: Plain text
#: en/git-svn.txt:782
#, priority:100
msgid "This allows 'git svn' to re-map repository URLs and UUIDs from mirrors created using SVN::Mirror (or svk) for metadata."
msgstr "这样，'git svn' 就能从使用 SVN::Mirror （或 svk）创建的元数据镜像中重新映射仓库 URL 和 UUID。"

#. type: Plain text
#: en/git-svn.txt:790
#, priority:100
msgid "If an SVN revision has a property, \"svm:headrev\", it is likely that the revision was created by SVN::Mirror (also used by SVK). The property contains a repository UUID and a revision. We want to make it look like we are mirroring the original URL, so introduce a helper function that returns the original identity URL and UUID, and use it when generating metadata in commit messages."
msgstr "如果 SVN 修订版有 \"svm:headrev\" 属性，则该修订版很可能是由 SVN::Mirror（SVK 也在使用）创建的。 该属性包含一个仓库 UUID 和一个修订版本。 我们想让它看起来像是在镜像原始 URL，因此引入了一个辅助函数来返回原始身份 URL 和 UUID，并在提交消息中生成元数据时使用它。"

#. type: Labeled list
#: en/git-svn.txt:791
#, no-wrap, placeholders:'svn.useSvnsyncProps', priority:100
msgid "svn.useSvnsyncProps"
msgstr "svn.useSvnsyncProps"

#. type: Labeled list
#: en/git-svn.txt:792
#, no-wrap, priority:100
msgid "svn-remote.<name>.useSvnsyncprops"
msgstr "svn-remote.<名称>.useSvnsyncprops"

#. type: Plain text
#: en/git-svn.txt:796
#, priority:100
msgid "Similar to the useSvmProps option; this is for users of the svnsync(1) command distributed with SVN 1.4.x and later."
msgstr "与 useSvmProps 选项类似；适用于使用随 SVN 1.4.x 及更高版本发布的 svnsync(1) 命令的用户。"

#. type: Labeled list
#: en/git-svn.txt:797
#, no-wrap, priority:100
msgid "svn-remote.<name>.rewriteRoot"
msgstr "svn-remote.<名称>.rewriteRoot"

#. type: Plain text
#: en/git-svn.txt:803
#, priority:100
msgid "This allows users to create repositories from alternate URLs. For example, an administrator could run 'git svn' on the server locally (accessing via file://) but wish to distribute the repository with a public http:// or svn:// URL in the metadata so users of it will see the public URL."
msgstr "这样，用户就可以通过其他 URL 创建仓库。 例如，管理员可以在本地服务器上运行 'git svn'（通过 file:// 访问），但希望在元数据中发布带有公共 http:// 或 svn:// URL 的仓库，这样用户就能看到公共 URL。"

#. type: Labeled list
#: en/git-svn.txt:804
#, no-wrap, priority:100
msgid "svn-remote.<name>.rewriteUUID"
msgstr "svn-remote.<名称>.rewriteUUID"

#. type: Plain text
#: en/git-svn.txt:809
#, priority:100
msgid "Similar to the useSvmProps option; this is for users who need to remap the UUID manually. This may be useful in situations where the original UUID is not available via either useSvmProps or useSvnsyncProps."
msgstr "与 useSvmProps 选项类似，适用于需要手动重新映射 UUID 的用户。在无法通过 useSvmProps 或 useSvnsyncProps 获取原始 UUID 的情况下，该选项可能非常有用。"

#. type: Labeled list
#: en/git-svn.txt:810
#, no-wrap, priority:100
msgid "svn-remote.<name>.pushurl"
msgstr "svn-remote.<名称>.pushurl"

#. type: Plain text
#: en/git-svn.txt:819
#, priority:100
msgid "Similar to Git's `remote.<name>.pushurl`, this key is designed to be used in cases where 'url' points to an SVN repository via a read-only transport, to provide an alternate read/write transport. It is assumed that both keys point to the same repository. Unlike 'commiturl', 'pushurl' is a base path. If either 'commiturl' or 'pushurl' could be used, 'commiturl' takes precedence."
msgstr "与 Git 的 `remote.<名称>.pushurl` 类似，该键设计用于 'url' 通过只读传输指向 SVN 仓库的情况，以提供另一种读/写传输。假定这两个键都指向同一个仓库。与 'commiturl' 不同，'pushurl' 是一个基本路径。如果可以使用 'commiturl' 或 'pushurl'，则 'commiturl' 优先。"

#. type: Labeled list
#: en/git-svn.txt:820
#, no-wrap, placeholders:'svn.brokenSymlinkWorkaround', priority:100
msgid "svn.brokenSymlinkWorkaround"
msgstr "svn.brokenSymlinkWorkaround"

#. type: Plain text
#: en/git-svn.txt:828
#, priority:100
msgid "This disables potentially expensive checks to workaround broken symlinks checked into SVN by broken clients. Set this option to \"false\" if you track a SVN repository with many empty blobs that are not symlinks. This option may be changed while 'git svn' is running and take effect on the next revision fetched. If unset, 'git svn' assumes this option to be \"true\"."
msgstr "此选项会禁用潜在的高代价检查，以解决因客户端损坏而检查到 SVN 中的符号链接的问题。 如果你追踪的 SVN 版本库中有很多不是符号链接的空 blob，请将此选项设为 \"false\"。 该选项可在运行 'git svn' 时修改，并在下一个版本获取时生效。 如果不设置，'git svn ' 将假定该选项为 \"true\"。"

#. type: Labeled list
#: en/git-svn.txt:829
#, no-wrap, placeholders:'svn.pathnameencoding', priority:100
msgid "svn.pathnameencoding"
msgstr "svn.pathnameencoding"

#. type: Plain text
#: en/git-svn.txt:834
#, priority:100
msgid "This instructs git svn to recode pathnames to a given encoding. It can be used by windows users and by those who work in non-utf8 locales to avoid corrupted file names with non-ASCII characters. Valid encodings are the ones supported by Perl's Encode module."
msgstr "指示 git svn 将路径名重新编码为给定的编码。 Windows 用户和在非 UTF8 本地环境中工作的用户可以使用它来避免文件名被非 ASCII 字符破坏。 有效的编码是 Perl 的编码模块所支持的编码。"

#. type: Labeled list
#: en/git-svn.txt:835
#, no-wrap, priority:100
msgid "svn-remote.<name>.automkdirs"
msgstr "svn-remote.<名称>.automkdirs"

#. type: Plain text
#: en/git-svn.txt:842
#, priority:100
msgid "Normally, the \"git svn clone\" and \"git svn rebase\" commands attempt to recreate empty directories that are in the Subversion repository. If this option is set to \"false\", then empty directories will only be created if the \"git svn mkdirs\" command is run explicitly. If unset, 'git svn' assumes this option to be \"true\"."
msgstr "通常，\"git svn clone\" 和 \"git svn rebase\" 命令会尝试重新创建 Subversion 仓库中的空目录。 如果将此选项设为 \"false\"，那么只有在显式运行 \"git svn mkdirs\" 命令时才会创建空目录。 如果不设置，'git svn' 将假定该选项为 \"true\"。"

#. type: Plain text
#: en/git-svn.txt:847
#, priority:100
msgid "Since the noMetadata, rewriteRoot, rewriteUUID, useSvnsyncProps and useSvmProps options all affect the metadata generated and used by 'git svn'; they *must* be set in the configuration file before any history is imported and these settings should never be changed once they are set."
msgstr "由于 noMetadata、rewriteRoot、rewriteUUID、useSvnsyncProps 和 useSvmProps 选项都会影响 'git svn' 生成和使用的元数据，因此必须在导入任何历史记录之前在配置文件中设置这些选项，而且一旦设置后就不得更改。"

#. type: Plain text
#: en/git-svn.txt:851
#, placeholders:'git-svn-id', priority:100
msgid "Additionally, only one of these options can be used per svn-remote section because they affect the 'git-svn-id:' metadata line, except for rewriteRoot and rewriteUUID which can be used together."
msgstr "此外，每个 svn-remote 部分只能使用其中一个选项，因为它们会影响 'git-svn-id:' 元数据行，但 rewriteRoot 和 rewriteUUID 可以一起使用。"

#. type: Title -
#: en/git-svn.txt:854
#, no-wrap, priority:100
msgid "BASIC EXAMPLES"
msgstr "基本示例"

#. type: Plain text
#: en/git-svn.txt:858
#, priority:100
msgid "Tracking and contributing to the trunk of a Subversion-managed project (ignoring tags and branches):"
msgstr "跟踪和贡献 Subversion 管理项目的主干（忽略标签和分支）："

#. type: delimited block -
#: en/git-svn.txt:876
#, ignore-ellipsis, no-wrap, placeholders:'HEAD':'.git/info/exclude', priority:100
msgid ""
"# Clone a repo (like git clone):\n"
"\tgit svn clone http://svn.example.com/project/trunk\n"
"# Enter the newly cloned directory:\n"
"\tcd trunk\n"
"# You should be on master branch, double-check with 'git branch'\n"
"\tgit branch\n"
"# Do some work and commit locally to Git:\n"
"\tgit commit ...\n"
"# Something is committed to SVN, rebase your local changes against the\n"
"# latest changes in SVN:\n"
"\tgit svn rebase\n"
"# Now commit your changes (that were committed previously using Git) to SVN,\n"
"# as well as automatically updating your working HEAD:\n"
"\tgit svn dcommit\n"
"# Append svn:ignore settings to the default Git exclude file:\n"
"\tgit svn show-ignore >> .git/info/exclude\n"
msgstr ""
"# 克隆一个仓库（类似 git clone）：\n"
"\tgit svn clone http://svn.example.com/project/trunk\n"
"# 进入新克隆仓库的文件夹：\n"
"\tcd trunk\n"
"# 用 git branch 再次确认目前在 master（主）分支上\n"
"\tgit branch\n"
"# 将一些工作进行本地的 Git 提交\n"
"\tgit commit ...\n"
"# 提交到 SVN 的内容，根据\n"
"# SVN 中的最新更改：\n"
"\tgit svn rebase\n"
"# 现在将（之前用 Git 提交的）修改提交到 SVN、\n"
"# 同时自动更新您的工作 HEAD：\n"
"\tgit svn dcommit\n"
"# 将 svn:ignore 设置附加到默认的 Git 排除文件\n"
"\tgit svn show-ignore >> .git/info/exclude\n"

#. type: Plain text
#: en/git-svn.txt:880
#, priority:100
msgid "Tracking and contributing to an entire Subversion-managed project (complete with a trunk, tags and branches):"
msgstr "跟踪和参与整个 Subversion 管理的项目（包括主干、标签和分支）："

#. type: delimited block -
#: en/git-svn.txt:895
#, no-wrap, placeholders:'--stdlayout':'--prefix':'--prefix':'--hard', priority:100
msgid ""
"# Clone a repo with standard SVN directory layout (like git clone):\n"
"\tgit svn clone http://svn.example.com/project --stdlayout --prefix svn/\n"
"# Or, if the repo uses a non-standard directory layout:\n"
"\tgit svn clone http://svn.example.com/project -T tr -b branch -t tag --prefix svn/\n"
"# View all branches and tags you have cloned:\n"
"\tgit branch -r\n"
"# Create a new branch in SVN\n"
"\tgit svn branch waldo\n"
"# Reset your master to trunk (or any other branch, replacing 'trunk'\n"
"# with the appropriate name):\n"
"\tgit reset --hard svn/trunk\n"
"# You may only dcommit to one branch/tag/trunk at a time.  The usage\n"
"# of dcommit/rebase/show-ignore should be the same as above.\n"
msgstr ""
"# 用标准 SVN 目录布局克隆一个仓库（与 git clone 类似）：\n"
"\tgit svn clone http://svn.example.com/project --stdlayout --prefix svn/\n"
"# 或者，如果仓库使用非标准目录布局：\n"
"\tgit svn clone http://svn.example.com/project -T tr -b branch -t tag --prefix svn/\n"
"# 查看您克隆的所有分支和标签：\n"
"\tgit branch -r\n"
"# 在 SVN 中创建一个新分支\n"
"\tgit svn branch waldo\n"
"# 重置您的主分支为 trunk（或任何其他分支，用适当的名称替换 'trunk'\n"
"# 替换为合适的名称）：\n"
"\tgit reset --hard svn/trunk\n"
"# 一次只能提交到一个分支/标签/主干。 使用\n"
"# dcommit/rebase/show-ignore 的用法应与上述相同。\n"

#. type: Plain text
#: en/git-svn.txt:903
#, priority:100
msgid "The initial 'git svn clone' can be quite time-consuming (especially for large Subversion repositories). If multiple people (or one person with multiple machines) want to use 'git svn' to interact with the same Subversion repository, you can do the initial 'git svn clone' to a repository on a server and have each person clone that repository with 'git clone':"
msgstr "最初的 'git svn clone' 可能相当耗时（尤其是对于大型 Subversion 仓库）。如果多人（或一人拥有多台机器）想用 'git svn' 与同一个 Subversion 仓库交互，可以先用 'git svn clone' 克隆服务器上的仓库，然后让每个人用 'git clone' 克隆该仓库："

#. type: delimited block -
#: en/git-svn.txt:924
#, ignore-ellipsis, no-wrap, placeholders:'--replace-all':'remote.origin.fetch':'--remove-section':'remote.origin':'FETCH_HEAD':'--stdlayout':'--prefix', priority:100
msgid ""
"# Do the initial import on a server\n"
"\tssh server \"cd /pub && git svn clone http://svn.example.com/project [options...]\"\n"
"# Clone locally - make sure the refs/remotes/ space matches the server\n"
"\tmkdir project\n"
"\tcd project\n"
"\tgit init\n"
"\tgit remote add origin server:/pub/project\n"
"\tgit config --replace-all remote.origin.fetch '+refs/remotes/*:refs/remotes/*'\n"
"\tgit fetch\n"
"# Prevent fetch/pull from remote Git server in the future,\n"
"# we only want to use git svn for future updates\n"
"\tgit config --remove-section remote.origin\n"
"# Create a local branch from one of the branches just fetched\n"
"\tgit checkout -b master FETCH_HEAD\n"
"# Initialize 'git svn' locally (be sure to use the same URL and\n"
"# --stdlayout/-T/-b/-t/--prefix options as were used on server)\n"
"\tgit svn init http://svn.example.com/project [options...]\n"
"# Pull the latest changes from Subversion\n"
"\tgit svn rebase\n"
msgstr ""
"# 在服务器上进行初始导入\n"
"\tssh server \"cd /pub && git svn clone http://svn.example.com/project [options...]\"\n"
"# 克隆到本地 - 确保 refs/remotes/ 空间与服务器一致\n"
"\tmkdir project\n"
"\tcd project\n"
"\tgit init\n"
"\tgit remote add origin server:/pub/project\n"
"\tgit config --replace-all remote.origin.fetch '+refs/remotes/*:refs/remotes/*'\n"
"\tgit fetch\n"
"# 防止将来从远程 Git 服务器获取/拉取、\n"
"# 我们只想在将来的更新中使用 git svn\n"
"\tgit config --remove-section remote.origin\n"
"# 从刚刚获取的分支中创建一个本地分支\n"
"\tgit checkout -b master FETCH_HEAD\n"
"# 在本地初始化 \"git svn\"（确保使用相同的 URL 和\n"
"--stdlayout/-T/-b/-t/-t--prefix 选项）。\n"
"\tgit svn init http://svn.example.com/project [options...]\n"
"# 从 Subversion 拉取最新修改\n"
"\tgit svn rebase\n"

#. type: Title -
#: en/git-svn.txt:927
#, no-wrap, priority:100
msgid "REBASE VS. PULL/MERGE"
msgstr "REBASE VS. PULL/MERGE （变基与拉取/合并对比）"

#. type: Plain text
#: en/git-svn.txt:933
#, priority:100
msgid "Prefer to use 'git svn rebase' or 'git rebase', rather than 'git pull' or 'git merge' to synchronize unintegrated commits with a 'git svn' branch. Doing so will keep the history of unintegrated commits linear with respect to the upstream SVN repository and allow the use of the preferred 'git svn dcommit' subcommand to push unintegrated commits back into SVN."
msgstr "优先使用 'git svn rebase' 或 'git rebase'，而不是 'git pull' 或 'git merge' 来同步未整合提交与 'git svn' 分支。这样做将使未整合提交的历史与上游 SVN 仓库保持线性关系，并允许使用首选的 'git svn dcommit' 子命令将未整合提交推回 SVN。"

#. type: Plain text
#: en/git-svn.txt:941
#, priority:100
msgid "Originally, 'git svn' recommended that developers pulled or merged from the 'git svn' branch. This was because the author favored `git svn set-tree B` to commit a single head rather than the `git svn set-tree A..B` notation to commit multiple commits. Use of 'git pull' or 'git merge' with `git svn set-tree A..B` will cause non-linear history to be flattened when committing into SVN and this can lead to merge commits unexpectedly reversing previous commits in SVN."
msgstr "最初，'git svn' 建议开发者从 'git svn' 分支拉取或合并。 这是因为作者倾向于用 `git svn set-tree B` 来提交单个头，而不是用 `git svn set-tree A..B` 来提交多个头。使用 'git pull' 或 'git merge' 和 `git svn set-tree A..B` 会导致非线性历史在提交到 SVN 时被扁平化，这可能会导致合并提交意外地在 SVN 中逆转之前的提交。"

#. type: Title -
#: en/git-svn.txt:943
#, no-wrap, priority:100
msgid "MERGE TRACKING"
msgstr "合并跟踪"

#. type: Plain text
#: en/git-svn.txt:950
#, priority:100
msgid "While 'git svn' can track copy history (including branches and tags) for repositories adopting a standard layout, it cannot yet represent merge history that happened inside git back upstream to SVN users. Therefore it is advised that users keep history as linear as possible inside Git to ease compatibility with SVN (see the CAVEATS section below)."
msgstr "虽然 'git svn' 可以跟踪采用标准布局的仓库的复制历史（包括分支和标记），但它还不能将发生在 git 内部的合并历史回溯到 SVN 用户的上游。 因此，我们建议用户尽可能在 Git 内部保持线性的历史记录，以方便与 SVN 兼容（见下文 “注意事项” 部分）。"

#. type: Title -
#: en/git-svn.txt:952
#, no-wrap, priority:100
msgid "HANDLING OF SVN BRANCHES"
msgstr "处理 svn 分支"

#. type: Plain text
#: en/git-svn.txt:960
#, placeholders:'--follow-branches', priority:100
msgid "If 'git svn' is configured to fetch branches (and --follow-branches is in effect), it sometimes creates multiple Git branches for one SVN branch, where the additional branches have names of the form 'branchname@nnn' (with nnn an SVN revision number). These additional branches are created if 'git svn' cannot find a parent commit for the first commit in an SVN branch, to connect the branch to the history of the other branches."
msgstr "如果 'git svn' 被配置为获取分支（且 --follow-branches 有效），它有时会为一个 SVN 分支创建多个 Git 分支，这些附加分支的名称为 'branchname@nnn'（nnn 为 SVN 修订版本号）。 如果 'git svn' 无法为 SVN 分支的第一次提交找到父提交，就会创建这些附加分支，以便将该分支与其他分支的历史连接起来。"

#. type: Plain text
#: en/git-svn.txt:976
#, placeholders:'`--revision`', priority:100
msgid "Normally, the first commit in an SVN branch consists of a copy operation. 'git svn' will read this commit to get the SVN revision the branch was created from. It will then try to find the Git commit that corresponds to this SVN revision, and use that as the parent of the branch. However, it is possible that there is no suitable Git commit to serve as parent. This will happen, among other reasons, if the SVN branch is a copy of a revision that was not fetched by 'git svn' (e.g. because it is an old revision that was skipped with `--revision`), or if in SVN a directory was copied that is not tracked by 'git svn' (such as a branch that is not tracked at all, or a subdirectory of a tracked branch). In these cases, 'git svn' will still create a Git branch, but instead of using an existing Git commit as the parent of the branch, it will read the SVN history of the directory the branch was copied from and create appropriate Git commits. This is indicated by the message \"Initializing parent: <branchname>\"."
msgstr "通常，SVN 分支的第一次提交包括复制操作。'git svn' 会读取该提交，以获得创建分支的 SVN 版本。然后，它会尝试找到与该 SVN 版本相对应的 Git 提交，并将其作为分支的父分支。不过，也有可能没有合适的 Git 提交作为父分支。 除其他原因外，如果 SVN 分支是一个修订版本的副本，而 'git svn' 没有获取该修订版本（例如，因为它是一个用 `--revision` 跳过的旧修订版本），或者在 SVN 中复制了一个 'git svn' 不跟踪的目录（例如一个根本不跟踪的分支，或者一个已跟踪分支的子目录），就会出现这种情况。在这种情况下，'git svn' 仍会创建一个 Git 分支，但它不会使用现有的 Git 提交作为该分支的父提交，而是会读取该分支被复制的目录的 SVN 历史记录，并创建适当的 Git 提交。 信息 \"Initializing parent:<分支名>\"信息来表示。"

#. type: Plain text
#: en/git-svn.txt:983
#, priority:100
msgid "Additionally, it will create a special branch named '<branchname>@<SVN-Revision>', where <SVN-Revision> is the SVN revision number the branch was copied from. This branch will point to the newly created parent commit of the branch. If in SVN the branch was deleted and later recreated from a different version, there will be multiple such branches with an '@'."
msgstr "此外，它还会创建一个名为 '<分支名>@<SVN-版本>' 的特殊分支，其中 <SVN-版本> 是该分支复制自的 SVN 版本号。 该分支将指向该分支新创建的父提交。 如果该分支在 SVN 中被删除，后来又从不同版本重新创建，则会出现多个带 '@' 的分支。"

#. type: Plain text
#: en/git-svn.txt:986
#, priority:100
msgid "Note that this may mean that multiple Git commits are created for a single SVN revision."
msgstr "请注意，这可能意味着一个 SVN 修订版会创建多个 Git 提交。"

#. type: Plain text
#: en/git-svn.txt:996
#, priority:100
msgid "An example: in an SVN repository with a standard trunk/tags/branches layout, a directory trunk/sub is created in r.100. In r.200, trunk/sub is branched by copying it to branches/. 'git svn clone -s' will then create a branch 'sub'. It will also create new Git commits for r.100 through r.199 and use these as the history of branch 'sub'. Thus there will be two Git commits for each revision from r.100 to r.199 (one containing trunk/, one containing trunk/sub/). Finally, it will create a branch 'sub@200' pointing to the new parent commit of branch 'sub' (i.e. the commit for r.200 and trunk/sub/)."
msgstr "举个例子：在一个采用标准 trunk/tags/branches 布局的 SVN 代码库中，r.100 中创建了 trunk/sub 目录。 在 r.200 中，trunk/sub 被复制到 branches/ 中，从而被分支。'git svn clone -s' 会创建一个分支 'sub'。它还会为 r.100 至 r.199 创建新的 Git 提交，并将其作为分支 'sub' 的历史。这样，从 r.100 到 r.199 的每个修订版本都会有两个 Git 提交（一个包含 trunk/，一个包含 trunk/sub/）。最后，它会创建一个分支 'sub@200'，指向分支 'sub' 的新父提交（即 r.200 和 trunk/sub/ 的提交）。"

#. type: Plain text
#: en/git-svn.txt:1006
#, placeholders:'git format-patch', priority:100
msgid "For the sake of simplicity and interoperating with Subversion, it is recommended that all 'git svn' users clone, fetch and dcommit directly from the SVN server, and avoid all 'git clone'/'pull'/'merge'/'push' operations between Git repositories and branches. The recommended method of exchanging code between Git branches and users is 'git format-patch' and 'git am', or just 'dcommit'ing to the SVN repository."
msgstr "为简单起见并与 Subversion 互操作，建议所有 'git svn' 用户直接从 SVN 服务器 clone、fetch 和 dcommit，避免在 Git 仓库和分支之间进行所有 'git clone'/'pull'/'merge'/'push' 操作。 在 Git 分支和用户之间交换代码的推荐方法是 'git format-patch' 和 'git am'，或直接 'dcommit' 到 SVN 仓库。"

#. type: Plain text
#: en/git-svn.txt:1012
#, priority:100
msgid "Running 'git merge' or 'git pull' is NOT recommended on a branch you plan to 'dcommit' from because Subversion users cannot see any merges you've made. Furthermore, if you merge or pull from a Git branch that is a mirror of an SVN branch, 'dcommit' may commit to the wrong branch."
msgstr "不建议在计划 'dcommit' 的分支上运行 'git merge' 或 'git pull'，因为 Subversion 用户无法看到你所做的任何合并。 此外，如果您从 SVN 分支的镜像 Git 分支合并或拉取，'dcommit' 可能会提交到错误的分支。"

#. type: Plain text
#: en/git-svn.txt:1015
#, priority:100
msgid "If you do merge, note the following rule: 'git svn dcommit' will attempt to commit on top of the SVN commit named in"
msgstr "如果进行合并，请注意以下规则：'git svn dcommit' 会尝试提交在 SVN 的顶部提交"

#. type: delimited block -
#: en/git-svn.txt:1017
#, no-wrap, placeholders:'--grep=':'git-svn-id':'--first-parent', priority:100
msgid "git log --grep=^git-svn-id: --first-parent -1\n"
msgstr "git log --grep=^git-svn-id: --first-parent -1\n"

#. type: Plain text
#: en/git-svn.txt:1022
#, priority:100
msgid "You 'must' therefore ensure that the most recent commit of the branch you want to dcommit to is the 'first' parent of the merge. Chaos will ensue otherwise, especially if the first parent is an older commit on the same SVN branch."
msgstr "因此，您 “必须” 确保您要提交到的分支的最新提交是合并的 'first' 父提交。 否则就会出现混乱，尤其是当第一父提交是同一 SVN 分支上的旧提交时。"

#. type: Plain text
#: en/git-svn.txt:1027
#, priority:100
msgid "'git clone' does not clone branches under the refs/remotes/ hierarchy or any 'git svn' metadata, or config. So repositories created and managed with using 'git svn' should use 'rsync' for cloning, if cloning is to be done at all."
msgstr "'git clone' 不会克隆 refs/remotes/ 层次结构下的分支，也不会克隆任何 'git svn' 元数据或配置。 因此，如果要克隆，使用 'git svn' 创建和管理的仓库应该使用 'rsync' 来克隆。"

#. type: Plain text
#: en/git-svn.txt:1032
#, placeholders:'linkgit:git-push[1]', priority:100
msgid "Since 'dcommit' uses rebase internally, any Git branches you 'git push' to before 'dcommit' on will require forcing an overwrite of the existing ref on the remote repository. This is generally considered bad practice, see the linkgit:git-push[1] documentation for details."
msgstr "由于 'dcommit' 在内部使用变基操作，因此在 'dcommit' 之前 'git push' 的任何 Git 分支都需要强制覆盖远程仓库中的现有引用。 这通常被认为是不好的做法，详见 linkgit:git-push[1] 文档。"

#. type: Plain text
#: en/git-svn.txt:1037
#, placeholders:'--amend':'linkgit:git-commit[1]':'--amend', priority:100
msgid "Do not use the --amend option of linkgit:git-commit[1] on a change you've already dcommitted. It is considered bad practice to --amend commits you've already pushed to a remote repository for other users, and dcommit with SVN is analogous to that."
msgstr "不要在已经提交的变更上使用 linkgit:git-commit[1] 的 --amend 选项。 为其他用户修改已推送到远程仓库的提交被认为是不好的做法，SVN 中的 dcommit 就类似于这种做法。"

#. type: Plain text
#: en/git-svn.txt:1052
#, placeholders:'--trunk':'--tags':'--branches':'--stdlayout':'`--stdlayout`':'`--trunk`':'`--branches`':'`--tags`', priority:100
msgid "When cloning an SVN repository, if none of the options for describing the repository layout is used (--trunk, --tags, --branches, --stdlayout), 'git svn clone' will create a Git repository with completely linear history, where branches and tags appear as separate directories in the working copy. While this is the easiest way to get a copy of a complete repository, for projects with many branches it will lead to a working copy many times larger than just the trunk. Thus for projects using the standard directory structure (trunk/branches/tags), it is recommended to clone with option `--stdlayout`. If the project uses a non-standard structure, and/or if branches and tags are not required, it is easiest to only clone one directory (typically trunk), without giving any repository layout options. If the full history with branches and tags is required, the options `--trunk` / `--branches` / `--tags` must be used."
msgstr "克隆 SVN 仓库时，如果没有使用描述仓库布局的选项（--trunk、--tags、--branches、--stdlayout），'git svn clone' 将创建一个完全线性历史的 Git 仓库，其中分支和标签在工作副本中显示为单独的目录。 虽然这是获取完整版本库副本的最简单方法，但对于有很多分支的项目来说，这会导致工作副本比主干大很多倍。因此，对于使用标准目录结构（trunk/branches/tags）的项目，建议克隆时使用选项 `--stdlayout`。如果项目使用非标准结构，和/或不需要分支和标签，最简单的做法是只克隆一个目录（通常是主干），而不提供任何仓库布局选项。 如果需要包含分支和标签的完整历史，则必须使用选项 `--trunk` / `--branches` / `--tags`。"

#. type: Plain text
#: en/git-svn.txt:1059
#, placeholders:'--branches':'--tags':'$GIT_DIR', priority:100
msgid "When using multiple --branches or --tags, 'git svn' does not automatically handle name collisions (for example, if two branches from different paths have the same name, or if a branch and a tag have the same name). In these cases, use 'init' to set up your Git repository then, before your first 'fetch', edit the $GIT_DIR/config file so that the branches and tags are associated with different name spaces. For example:"
msgstr "当使用多个 --branches 或 --tags 时，'git svn' 不会自动处理名称碰撞（例如，来自不同路径的两个分支具有相同的名称，或者一个分支和一个标签具有相同的名称）。 在这种情况下，使用 'init' 设置 Git 仓库，然后在第一次 'fetch' 之前，编辑 $GIT_DIR/config 文件，将分支和标签关联到不同的名称空间。 例如:"

#. type: Plain text
#: en/git-svn.txt:1062
#, no-wrap, priority:100
msgid ""
"\tbranches = stable/*:refs/remotes/svn/stable/*\n"
"\tbranches = debug/*:refs/remotes/svn/debug/*\n"
msgstr ""
"\tbranches = stable/*:refs/remotes/svn/stable/*\n"
"\tbranches = debug/*:refs/remotes/svn/debug/*\n"

#. type: Plain text
#: en/git-svn.txt:1073
#, placeholders:'$GIT_DIR', priority:100
msgid "'git svn' stores [svn-remote] configuration information in the repository $GIT_DIR/config file. It is similar the core Git [remote] sections except 'fetch' keys do not accept glob arguments; but they are instead handled by the 'branches' and 'tags' keys. Since some SVN repositories are oddly configured with multiple projects glob expansions such those listed below are allowed:"
msgstr "'git svn' 在版本库 $GIT_DIR/config 文件中存储 [svn-remote] 配置信息。 除了 'fetch' 键不接受通配符参数外，它与 Git 核心的 [remote] 部分类似，但它们由 'branch' 和 'tags' 键处理。 由于有些 SVN 仓库的配置比较奇怪，有多个项目，因此允许使用下面列出的通配符扩展："

#. type: delimited block -
#: en/git-svn.txt:1082
#, no-wrap, placeholders:'server.org', priority:100
msgid ""
"[svn-remote \"project-a\"]\n"
"\turl = http://server.org/svn\n"
"\tfetch = trunk/project-a:refs/remotes/project-a/trunk\n"
"\tbranches = branches/*/project-a:refs/remotes/project-a/branches/*\n"
"\tbranches = branches/release_*:refs/remotes/project-a/branches/release_*\n"
"\tbranches = branches/re*se:refs/remotes/project-a/branches/*\n"
"\ttags = tags/*/project-a:refs/remotes/project-a/tags/*\n"
msgstr ""
"[svn-remote \"project-a\"]\n"
"\turl = http://server.org/svn\n"
"\tfetch = trunk/project-a:refs/remotes/project-a/trunk\n"
"\tbranches = branches/*/project-a:refs/remotes/project-a/branches/*\n"
"\tbranches = branches/release_*:refs/remotes/project-a/branches/release_*\n"
"\tbranches = branches/re*se:refs/remotes/project-a/branches/*\n"
"\ttags = tags/*/project-a:refs/remotes/project-a/tags/*\n"

#. type: Plain text
#: en/git-svn.txt:1090
#, priority:100
msgid "Keep in mind that the `*` (asterisk) wildcard of the local ref (right of the `:`) *must* be the farthest right path component; however the remote wildcard may be anywhere as long as it's an independent path component (surrounded by `/` or EOL). This type of configuration is not automatically created by 'init' and should be manually entered with a text-editor or using 'git config'."
msgstr "请记住，本地引用中的 `*`（星号）通配符（位于 `:` 右边）*必须*是最右边的路径组件；*必须*是最右边的路径组件。(`:`右边）的通配符必须是最右边的路径组件；但是，远程通配符可以是任何地方的通配符，只要它是一个独立的路径组件（由 `:` 包围）。但远程通配符可以是任何位置，只要它是一个独立的路径组件（由 `/` 或 EOL 包围）。 这种类型的配置不会由 \"init \"自动创建，而应使用文本编辑器或 'git config' 手动输入。"

#. type: Plain text
#: en/git-svn.txt:1092
#, priority:100
msgid "Also note that only one asterisk is allowed per word. For example:"
msgstr "另请注意，每个单词只允许使用一个星号。例如："

#. type: Plain text
#: en/git-svn.txt:1094
#, no-wrap, priority:100
msgid "\tbranches = branches/re*se:refs/remotes/project-a/branches/*\n"
msgstr "\tbranches = branches/re*se:refs/remotes/project-a/branches/*\n"

#. type: Plain text
#: en/git-svn.txt:1096
#, priority:100
msgid "will match branches 'release', 'rese', 're123se', however"
msgstr "将匹配分支 'release'、'rese'、're123se'，但"

#. type: Plain text
#: en/git-svn.txt:1098
#, no-wrap, priority:100
msgid "\tbranches = branches/re*s*e:refs/remotes/project-a/branches/*\n"
msgstr "\tbranches = branches/re*s*e:refs/remotes/project-a/branches/*\n"

#. type: Plain text
#: en/git-svn.txt:1100
#, priority:100
msgid "will produce an error."
msgstr "会产生错误。"

#. type: Plain text
#: en/git-svn.txt:1103
#, priority:100
msgid "It is also possible to fetch a subset of branches or tags by using a comma-separated list of names within braces. For example:"
msgstr "也可以使用大括号中以逗号分隔的名称列表来获取分支或标记的子集。例如："

#. type: delimited block -
#: en/git-svn.txt:1110
#, no-wrap, placeholders:'server.org', priority:100
msgid ""
"[svn-remote \"huge-project\"]\n"
"\turl = http://server.org/svn\n"
"\tfetch = trunk/src:refs/remotes/trunk\n"
"\tbranches = branches/{red,green}/src:refs/remotes/project-a/branches/*\n"
"\ttags = tags/{1.0,2.0}/src:refs/remotes/project-a/tags/*\n"
msgstr ""
"[svn-remote \"huge-project\"]\n"
"\turl = http://server.org/svn\n"
"\tfetch = trunk/src:refs/remotes/trunk\n"
"\tbranches = branches/{red,green}/src:refs/remotes/project-a/branches/*\n"
"\ttags = tags/{1.0,2.0}/src:refs/remotes/project-a/tags/*\n"

#. type: Plain text
#: en/git-svn.txt:1113
#, priority:100
msgid "Multiple fetch, branches, and tags keys are supported:"
msgstr "支持多个提取、分支和标记键："

#. type: delimited block -
#: en/git-svn.txt:1122
#, no-wrap, placeholders:'server.org', priority:100
msgid ""
"[svn-remote \"messy-repo\"]\n"
"\turl = http://server.org/svn\n"
"\tfetch = trunk/project-a:refs/remotes/project-a/trunk\n"
"\tfetch = branches/demos/june-project-a-demo:refs/remotes/project-a/demos/june-demo\n"
"\tbranches = branches/server/*:refs/remotes/project-a/branches/*\n"
"\tbranches = branches/demos/2011/*:refs/remotes/project-a/2011-demos/*\n"
"\ttags = tags/server/*:refs/remotes/project-a/tags/*\n"
msgstr ""
"[svn-remote \"messy-repo\"]\n"
"\turl = http://server.org/svn\n"
"\tfetch = trunk/project-a:refs/remotes/project-a/trunk\n"
"\tfetch = branches/demos/june-project-a-demo:refs/remotes/project-a/demos/june-demo\n"
"\tbranches = branches/server/*:refs/remotes/project-a/branches/*\n"
"\tbranches = branches/demos/2011/*:refs/remotes/project-a/2011-demos/*\n"
"\ttags = tags/server/*:refs/remotes/project-a/tags/*\n"

#. type: Plain text
#: en/git-svn.txt:1126
#, placeholders:'--destination', priority:100
msgid "Creating a branch in such a configuration requires disambiguating which location to use using the -d or --destination flag:"
msgstr "在这种配置下创建分支，需要使用 -d 或 --destination 标志来明确使用哪个位置："

#. type: delimited block -
#: en/git-svn.txt:1129
#, no-wrap, priority:100
msgid "$ git svn branch -d branches/server release-2-3-0\n"
msgstr "$ git svn branch -d branches/server release-2-3-0\n"

#. type: Plain text
#: en/git-svn.txt:1135
#, placeholders:'git-svn':'$GIT_DIR', priority:100
msgid "Note that git-svn keeps track of the highest revision in which a branch or tag has appeared. If the subset of branches or tags is changed after fetching, then $GIT_DIR/svn/.metadata must be manually edited to remove (or reset) branches-maxRev and/or tags-maxRev as appropriate."
msgstr "请注意，git-svn 会记录分支或标签出现过的最高修订版本。如果分支或标签的子集在获取后发生了变化，则必须手动编辑 $GIT_DIR/svn/.metadata，以根据情况移除（或重置）分支-最高修订和/或标签-最高修订。"

#. type: Labeled list
#: en/git-svn.txt:1138
#, no-wrap, placeholders:'$GIT_DIR':'rev_map', priority:100
msgid "$GIT_DIR/svn/\\**/.rev_map.*"
msgstr "$GIT_DIR/svn/\\**/.rev_map.*"

#. type: Plain text
#: en/git-svn.txt:1144
#, placeholders:'git-svn-id':'svn.noMetadata', priority:100
msgid "Mapping between Subversion revision numbers and Git commit names. In a repository where the noMetadata option is not set, this can be rebuilt from the git-svn-id: lines that are at the end of every commit (see the 'svn.noMetadata' section above for details)."
msgstr "Subversion 版本号与 Git 提交名之间的映射。 在未设置 noMetadata 选项的仓库中，可以根据每次提交末尾的 git-svn-id: 行重建该映射（详见上文 'svn.noMetadata' 部分）。"

#. type: Plain text
#: en/git-svn.txt:1148
#, placeholders:'rev_map', priority:100
msgid "'git svn fetch' and 'git svn rebase' automatically update the rev_map if it is missing or not up to date. 'git svn reset' automatically rewinds it."
msgstr "如果 rev_map 丢失或不是最新的，'git svn fetch' 和 'git svn rebase' 会自动更新它。 'git svn reset' 会自动将其倒退。"

#. type: Plain text
#: en/git-svn.txt:1154
#, placeholders:'$GIT_DIR':'unhandled.log', priority:100
msgid "We ignore all SVN properties except svn:executable. Any unhandled properties are logged to $GIT_DIR/svn/<refname>/unhandled.log"
msgstr "我们会忽略除 svn:executable 之外的所有 SVN 属性。 任何未处理的属性都会记录到 $GIT_DIR/svn/<引用名>/unhandled.log 中"

#. type: Plain text
#: en/git-svn.txt:1161
#, priority:100
msgid "Renamed and copied directories are not detected by Git and hence not tracked when committing to SVN. I do not plan on adding support for this as it's quite difficult and time-consuming to get working for all the possible corner cases (Git doesn't do it, either). Committing renamed and copied files is fully supported if they're similar enough for Git to detect them."
msgstr "重命名和复制的目录不会被 Git 检测到，因此在提交到 SVN 时也不会被跟踪。 我不打算添加这方面的支持，因为要在所有可能的情况下都能正常工作是相当困难和耗时的（Git 也做不到这一点）。 如果重命名和复制的文件足够相似，Git 可以检测到它们，那么我们就完全支持提交这些文件。"

#. type: Plain text
#: en/git-svn.txt:1167
#, priority:100
msgid "In SVN, it is possible (though discouraged) to commit changes to a tag (because a tag is just a directory copy, thus technically the same as a branch). When cloning an SVN repository, 'git svn' cannot know if such a commit to a tag will happen in the future. Thus it acts conservatively and imports all SVN tags as branches, prefixing the tag name with 'tags/'."
msgstr "在 SVN 中，提交修改到标签是可能的（尽管不鼓励）（因为标签只是一个目录副本，因此在技术上与分支相同）。在克隆 SVN 仓库时，'git svn' 无法知道将来是否会发生对标签的提交。因此它会采取保守做法，将所有 SVN 标签作为分支导入，并在标签名称前加上 'tags/'。"

#. type: Title =
#: en/git-switch.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-switch(1)"
msgstr "git-switch(1)"

#. type: Plain text
#: en/git-switch.txt:7
#, placeholders:'git-switch', priority:100
msgid "git-switch - Switch branches"
msgstr "git-switch - 切换分支"

#. type: Plain text
#: en/git-switch.txt:15
#, no-wrap, placeholders:'[--no-guess]':'--detach':'--orphan', priority:100
msgid ""
"'git switch' [<options>] [--no-guess] <branch>\n"
"'git switch' [<options>] --detach [<start-point>]\n"
"'git switch' [<options>] (-c|-C) <new-branch> [<start-point>]\n"
"'git switch' [<options>] --orphan <new-branch>\n"
msgstr ""
"'git switch' [<选项>] [--no-guess] <分支>\n"
"'git switch' [<选项>] --detach [<起点>]\n"
"'git switch' [<选项>] (-c|-C) <新分支> [<起点>]\n"
"'git switch' [<选项>] --orphan <新分支>\n"

#. type: Plain text
#: en/git-switch.txt:21
#, priority:100
msgid "Switch to a specified branch. The working tree and the index are updated to match the branch. All new commits will be added to the tip of this branch."
msgstr "切换到指定分支。工作区和索引会更新以匹配该分支。所有新提交的内容都会添加到该分支的顶端。"

#. type: Plain text
#: en/git-switch.txt:26
#, placeholders:'`-c`':'`-C`':'`--guess`':'`--detach`', priority:100
msgid "Optionally a new branch could be created with either `-c`, `-C`, automatically from a remote branch of same name (see `--guess`), or detach the working tree from any branch with `--detach`, along with switching."
msgstr "可选择使用 `-c`、`-C`，自动从同名的远程分支创建新分支（参见 `--guess`），或使用 `--detach`，从任何分支分离工作区，同时进行切换。"

#. type: Plain text
#: en/git-switch.txt:31
#, placeholders:'HEAD':'`--discard-changes`':'`--merge`', priority:100
msgid "Switching branches does not require a clean index and working tree (i.e. no differences compared to `HEAD`). The operation is aborted however if the operation leads to loss of local changes, unless told otherwise with `--discard-changes` or `--merge`."
msgstr "切换分支不需要干净的索引和工作区（即与 `HEAD` 相比没有差异）。但是，如果该操作会导致本地变更的丢失，除非使用 `--discard-changes` 或 `--merge`，否则该操作将被中止。"

#. type: Plain text
#: en/git-switch.txt:38
#, priority:100
msgid "Branch to switch to."
msgstr "转到的分支。"

#. type: Plain text
#: en/git-switch.txt:48
#, placeholders:'HEAD':'`--detach`', priority:100
msgid "The starting point for the new branch. Specifying a `<start-point>` allows you to create a branch based on some other point in history than where HEAD currently points. (Or, in the case of `--detach`, allows you to inspect and detach from some other point.)"
msgstr "新分支的起点。指定 `<起始点>` 后，就可以根据历史上的其他点创建分支，而不是 HEAD 当前指向的点。(或者，在 `--detach` 的情况下，允许你检查并从其他点分离。）"

#. type: Plain text
#: en/git-switch.txt:54
#, placeholders:'{-N}':'{-1}', priority:100
msgid "You can use the `@{-N}` syntax to refer to the N-th last branch/commit switched to using \"git switch\" or \"git checkout\" operation. You may also specify `-` which is synonymous to `@{-1}`. This is often used to switch quickly between two branches, or to undo a branch switch by mistake."
msgstr "您可以使用 `@{-N}` 语法来指使用 \"git switch\" 或 \"git checkout\" 操作切换到的第 N 个分支或提交。您也可以指定与 `@{-1}` 同义的 `-`。 这通常用于在两个分支之间快速切换，或撤销错误的分支切换。"

#. type: Labeled list
#: en/git-switch.txt:59
#, no-wrap, priority:100
msgid "-c <new-branch>"
msgstr "-c <新分支>"

#. type: Labeled list
#: en/git-switch.txt:60
#, no-wrap, placeholders:'--create', priority:100
msgid "--create <new-branch>"
msgstr "--create <新分支>"

#. type: Plain text
#: en/git-switch.txt:64
#, priority:100
msgid "Create a new branch named `<new-branch>` starting at `<start-point>` before switching to the branch. This is the transactional equivalent of"
msgstr "在切换到分支之前，从 `<起点>` 开始创建一个名为 `<新分支>` 的新分支。这相当于"

#. type: delimited block -
#: en/git-switch.txt:68
#, no-wrap, priority:100
msgid ""
"$ git branch <new-branch>\n"
"$ git switch <new-branch>\n"
msgstr ""
"$ git branch <新分支>\n"
"$ git switch <新分支>\n"

#. type: Plain text
#: en/git-switch.txt:74
#, priority:100
msgid "that is to say, the branch is not reset/created unless \"git switch\" is successful (e.g., when the branch is in use in another worktree, not just the current branch stays the same, but the branch is not reset to the start-point, either)."
msgstr "也就是说，除非 \"git switch\" 成功，否则不会重置/创建分支（例如，当分支在另一个工作树中使用时，不仅当前分支保持不变，分支也不会重置为起点）。"

#. type: Labeled list
#: en/git-switch.txt:75
#, no-wrap, priority:100
msgid "-C <new-branch>"
msgstr "-C <新分支>"

#. type: Labeled list
#: en/git-switch.txt:76
#, no-wrap, placeholders:'--force-create', priority:100
msgid "--force-create <new-branch>"
msgstr "--force-create <新分支>"

#. type: Plain text
#: en/git-switch.txt:80
#, placeholders:'`--create`', priority:100
msgid "Similar to `--create` except that if `<new-branch>` already exists, it will be reset to `<start-point>`. This is a convenient shortcut for:"
msgstr "类似于 `--create`，但如果 `<新分支>` 已经存在，它将被重置为 `<起点>`。这是一个方便的快捷方式："

#. type: delimited block -
#: en/git-switch.txt:84
#, no-wrap, priority:100
msgid ""
"$ git branch -f <new-branch>\n"
"$ git switch <new-branch>\n"
msgstr ""
"$ git branch -f <新分支>\n"
"$ git switch <新分支>\n"

#. type: Plain text
#: en/git-switch.txt:91
#, placeholders:'HEAD':'linkgit:git-checkout[1]', priority:100
msgid "Switch to a commit for inspection and discardable experiments. See the \"DETACHED HEAD\" section in linkgit:git-checkout[1] for details."
msgstr "切换到用于检查和可丢弃实验的提交。详见 linkgit:git-checkout[1] 中的 “分离式 HEAD” 部分。"

#. type: delimited block -
#: en/git-switch.txt:100
#, no-wrap, placeholders:'--track', priority:100
msgid "$ git switch -c <branch> --track <remote>/<branch>\n"
msgstr "$ git switch -c <分支> --track <远程仓库>/<分支>\n"

#. type: Plain text
#: en/git-switch.txt:118
#, placeholders:'`--discard-changes`', priority:100
msgid "An alias for `--discard-changes`."
msgstr "`--discard-changes` 的别名。"

#. type: Labeled list
#: en/git-switch.txt:119
#, ignore-same, no-wrap, priority:100
msgid "--discard-changes"
msgstr "--discard-changes"

#. type: Plain text
#: en/git-switch.txt:125
#, placeholders:'HEAD':'`--recurse-submodules`', priority:100
msgid "Proceed even if the index or the working tree differs from `HEAD`. Both the index and working tree are restored to match the switching target. If `--recurse-submodules` is specified, submodule content is also restored to match the switching target. This is used to throw away local changes."
msgstr "即使索引或工作树与 `HEAD` 不同，也要继续。索引和工作树都会被恢复以匹配切换目标。如果指定了 `--recurse-submodules`，子模块内容也会恢复到与切换目标一致。这用于丢弃本地更改。"

#. type: Plain text
#: en/git-switch.txt:135
#, priority:100
msgid "If you have local modifications to one or more files that are different between the current branch and the branch to which you are switching, the command refuses to switch branches in order to preserve your modifications in context. However, with this option, a three-way merge between the current branch, your working tree contents, and the new branch is done, and you will be on the new branch."
msgstr "如果你对一个或多个文件所做的本地修改在当前分支和要切换到的分支之间有所不同，命令会拒绝切换分支，以保留你在上下文中的修改。 不过，如果使用了该选项，当前分支、工作树内容和新分支之间的三方合并就会完成，而你也将进入新分支。"

#. type: Labeled list
#: en/git-switch.txt:159
#, no-wrap, placeholders:'--track', priority:100
msgid "--track [direct|inherit]"
msgstr "--track [direct|inherit]"

#. type: Plain text
#: en/git-switch.txt:163
#, placeholders:'`-c`':'`--track`', priority:100
msgid "When creating a new branch, set up \"upstream\" configuration. `-c` is implied. See `--track` in linkgit:git-branch[1] for details."
msgstr "创建新分支时，请设置 \"upstream\"（上游仓库）配置。 选项 `-c` 是隐含的。详见 linkgit:git-branch[1] 中的 `--track`。"

#. type: Plain text
#: en/git-switch.txt:173
#, placeholders:'`-c`':'`-c`', priority:100
msgid "If no `-c` option is given, the name of the new branch will be derived from the remote-tracking branch, by looking at the local part of the refspec configured for the corresponding remote, and then stripping the initial part up to the \"*\". This would tell us to use `hack` as the local branch when branching off of `origin/hack` (or `remotes/origin/hack`, or even `refs/remotes/origin/hack`). If the given name has no slash, or the above guessing results in an empty name, the guessing is aborted. You can explicitly give a name with `-c` in such a case."
msgstr "如果没有给定 `-c` 选项，新分支的名称将从远程跟踪分支中导出，方法是查看为相应远程配置的引用规范的本地部分，然后去掉首部至 \"*\" 的部分。 这将告诉我们，在从 `origin/hack` （或 `remotes/origin/hack`，甚至 `refs/remotes/origin/hack`）分支时，使用 `hack` 作为本地分支。 如果给定的名称中没有斜线，或者上述猜测的结果是空名，猜测就会中止。 在这种情况下，可以用 `-c` 明确地给出一个名称。"

#. type: Plain text
#: en/git-switch.txt:181
#, priority:100
msgid "Create a new unborn branch, named `<new-branch>`. All tracked files are removed."
msgstr "创建一个新的 'unborn' （未出生）分支，命名为 `<新分支>`。所有被跟踪的文件都会被删除。"

#. type: Plain text
#: en/git-switch.txt:187
#, priority:100
msgid "`git switch` refuses when the wanted ref is already checked out by another worktree. This option makes it check the ref out anyway. In other words, the ref can be held by more than one worktree."
msgstr "当想要的引用已被另一个工作树签出时，`git switch` 会拒绝签出。这个选项会让它无论如何都把引用签出。换句话说，该引用可以被多个工作树持有。"

#. type: Plain text
#: en/git-switch.txt:196
#, placeholders:'`--recurse-submodules`':'`--no-recurse-submodules`':'linkgit:git-submodule[1]':'HEAD', priority:100
msgid "Using `--recurse-submodules` will update the content of all active submodules according to the commit recorded in the superproject. If nothing (or `--no-recurse-submodules`) is used, submodules working trees will not be updated. Just like linkgit:git-submodule[1], this will detach `HEAD` of the submodules."
msgstr "使用 `--recurse-submodules`，将根据超级项目中记录的提交更新所有活动子模块的内容。如果什么都不使用（或 `--no-recurse-submodules`），子模块工作树将不会被更新。就像 linkgit:git-submodule[1]，这会分离子模块的 `HEAD`。"

#. type: Plain text
#: en/git-switch.txt:201
#, priority:100
msgid "The following command switches to the \"master\" branch:"
msgstr "下面的命令会切换到 \"master\" 分支："

#. type: delimited block -
#: en/git-switch.txt:204
#, no-wrap, priority:100
msgid "$ git switch master\n"
msgstr "$ git switch master\n"

#. type: delimited block -
#: en/git-switch.txt:211
#, no-wrap, priority:100
msgid "$ git switch mytopic\n"
msgstr "$ git switch mytopic\n"

#. type: Plain text
#: en/git-switch.txt:216
#, priority:100
msgid "However, your \"wrong\" branch and correct \"mytopic\" branch may differ in files that you have modified locally, in which case the above switch would fail like this:"
msgstr "但是，您的 \"wrong\" 分支和正确的 \"mytopic\" 分支可能在您本地修改的文件中存在差异，在这种情况下，上述开关就会像这样失败："

#. type: delimited block -
#: en/git-switch.txt:220
#, no-wrap, priority:100
msgid ""
"$ git switch mytopic\n"
"error: You have local changes to 'frotz'; not switching branches.\n"
msgstr ""
"$ git switch mytopic\n"
"error: 你对 'footz' 进行了本地更改，而不是切换分支。\n"

#. type: delimited block -
#: en/git-switch.txt:228
#, no-wrap, priority:100
msgid ""
"$ git switch -m mytopic\n"
"Auto-merging frotz\n"
msgstr ""
"$ git switch -m mytopic\n"
"自动合并 frotz 中\n"

#. type: Plain text
#: en/git-switch.txt:236
#, priority:100
msgid "To switch back to the previous branch before we switched to mytopic (i.e. \"master\" branch):"
msgstr "切换回切换到 mytopic 之前的分支（即 \"master\" 分支）："

#. type: delimited block -
#: en/git-switch.txt:239
#, no-wrap, priority:100
msgid "$ git switch -\n"
msgstr "$ git switch -\n"

#. type: Plain text
#: en/git-switch.txt:243
#, placeholders:'HEAD', priority:100
msgid "You can grow a new branch from any commit. For example, switch to \"HEAD~3\" and create branch \"fixup\":"
msgstr "你可以从任何提交创建一个新分支。例如，切换到 \"HEAD~3\" 并创建分支 \"fixup\"："

#. type: delimited block -
#: en/git-switch.txt:247
#, no-wrap, placeholders:'HEAD', priority:100
msgid ""
"$ git switch -c fixup HEAD~3\n"
"Switched to a new branch 'fixup'\n"
msgstr ""
"$ git switch -c fixup HEAD~3\n"
"切换到新分支 'fixup'\n"

#. type: Plain text
#: en/git-switch.txt:251
#, priority:100
msgid "If you want to start a new branch from a remote branch of the same name:"
msgstr "如果要从同名的远程分支启动一个新分支："

#. type: delimited block -
#: en/git-switch.txt:256
#, no-wrap, priority:100
msgid ""
"$ git switch new-topic\n"
"Branch 'new-topic' set up to track remote branch 'new-topic' from 'origin'\n"
"Switched to a new branch 'new-topic'\n"
msgstr ""
"$ git switch new-topic\n"
"设置了分支 'new-topic'，以跟踪来自 'origin' 的远程分支 'new-topic'\n"
"切换到一个新分支 'new-topic'\n"

#. type: Plain text
#: en/git-switch.txt:260
#, placeholders:'HEAD', priority:100
msgid "To check out commit `HEAD~3` for temporary inspection or experiment without creating a new branch:"
msgstr "查看提交 `HEAD~3` 以进行临时检查或实验，而无需创建新分支："

#. type: delimited block -
#: en/git-switch.txt:264
#, no-wrap, placeholders:'--detach':'HEAD':'HEAD', priority:100
msgid ""
"$ git switch --detach HEAD~3\n"
"HEAD is now at 9fc9555312 Merge branch 'cc/shared-index-permbits'\n"
msgstr ""
"$ git switch --detach HEAD~3\n"
"HEAD 现为 9fc9555312 合并分支 'cc/shared-index-permbits'\n"

#. type: Plain text
#: en/git-switch.txt:268
#, priority:100
msgid "If it turns out whatever you have done is worth keeping, you can always create a new name for it (without switching away):"
msgstr "如果发现你所做的任何事情都值得保留，你可以随时为它创建一个新名称（不需要换掉）："

#. type: delimited block -
#: en/git-switch.txt:271
#, no-wrap, priority:100
msgid "$ git switch -c good-surprises\n"
msgstr "$ git switch -c good-surprises\n"

#. type: Plain text
#: en/git-switch.txt:284
#, ignore-same, priority:100
msgid "linkgit:git-checkout[1], linkgit:git-branch[1]"
msgstr "linkgit:git-checkout[1], linkgit:git-branch[1]"

#. type: Title =
#: en/git-symbolic-ref.txt:2
#, ignore-same, no-wrap, priority:80
msgid "git-symbolic-ref(1)"
msgstr "git-symbolic-ref(1)"

#. type: Plain text
#: en/git-symbolic-ref.txt:7
#, placeholders:'git-symbolic-ref', priority:80
msgid "git-symbolic-ref - Read, modify and delete symbolic refs"
msgstr "git-symbolic-ref - 读取、修改和删除符号引用"

#. type: Plain text
#: en/git-symbolic-ref.txt:14
#, no-wrap, placeholders:'git symbolic-ref':'git symbolic-ref':'[--short]':'[--no-recurse]':'git symbolic-ref':'--delete', priority:80
msgid ""
"'git symbolic-ref' [-m <reason>] <name> <ref>\n"
"'git symbolic-ref' [-q] [--short] [--no-recurse] <name>\n"
"'git symbolic-ref' --delete [-q] <name>\n"
msgstr ""
"'git symbolic-ref' [-m <原因>] <名称> <引用>\n"
"'git symbolic-ref' [-q] [--short] [--no-recurse] <名称>\n"
"'git symbolic-ref' --delete [-q] <名称>\n"

#. type: Plain text
#: en/git-symbolic-ref.txt:21
#, placeholders:'HEAD', priority:80
msgid "Given one argument, reads which branch head the given symbolic ref refers to and outputs its path, relative to the `.git/` directory. Typically you would give `HEAD` as the <name> argument to see which branch your working tree is on."
msgstr "给定一个参数，读取给定符号引用指向的分支头，并输出其相对于 `.git/` 目录的路径。 通常情况下，你会将 `HEAD` 作为 <名称> 参数，以查看工作区所在的分支。"

#. type: Plain text
#: en/git-symbolic-ref.txt:24
#, priority:80
msgid "Given two arguments, creates or updates a symbolic ref <name> to point at the given branch <ref>."
msgstr "在给定两个参数的情况下，创建或更新符号引用 <名称> 以指向给定的分支 <引用>。"

#. type: Plain text
#: en/git-symbolic-ref.txt:27
#, placeholders:'`--delete`', priority:80
msgid "Given `--delete` and an additional argument, deletes the given symbolic ref."
msgstr "给定 `--delete` 和一个附加参数，删除给定的符号引用。"

#. type: Plain text
#: en/git-symbolic-ref.txt:31
#, placeholders:'.git/HEAD', priority:80
msgid "A symbolic ref is a regular file that stores a string that begins with `ref: refs/`. For example, your `.git/HEAD` is a regular file whose content is `ref: refs/heads/master`."
msgstr "符号引用是一个存储以 `ref: refs/` 开头的字符串的常规文件。 例如，你的 `.git/HEAD` 就是一个内容为 `ref: refs/heads/master` 的常规文件。"

#. type: Plain text
#: en/git-symbolic-ref.txt:38
#, priority:80
msgid "Delete the symbolic ref <name>."
msgstr "删除符号引用 <名称>。"

#. type: Plain text
#: en/git-symbolic-ref.txt:44
#, placeholders:'HEAD', priority:80
msgid "Do not issue an error message if the <name> is not a symbolic ref but a detached HEAD; instead exit with non-zero status silently."
msgstr "如果 <名称> 不是符号引用，而是分离的 HEAD，则不会发出错误信息；而是以非零状态静默退出。"

#. type: Plain text
#: en/git-symbolic-ref.txt:48
#, priority:80
msgid "When showing the value of <name> as a symbolic ref, try to shorten the value, e.g. from `refs/heads/master` to `master`."
msgstr "将 <名称> 的值作为符号引用显示时，请尽量缩短该值，例如将 `refs/heads/master` 改为 `master`。"

#. type: Labeled list
#: en/git-symbolic-ref.txt:49
#, ignore-same, no-wrap, priority:80
msgid "--recurse"
msgstr "--recurse"

#. type: Labeled list
#: en/git-symbolic-ref.txt:50
#, ignore-same, no-wrap, priority:80
msgid "--no-recurse"
msgstr "--no-recurse"

#. type: Plain text
#: en/git-symbolic-ref.txt:57
#, placeholders:'`--recurse`':'`--no-recurse`', priority:80
msgid "When showing the value of <name> as a symbolic ref, if <name> refers to another symbolic ref, follow such a chain of symbolic refs until the result no longer points at a symbolic ref (`--recurse`, which is the default). `--no-recurse` stops after dereferencing only a single level of symbolic ref."
msgstr "在以符号引用形式显示 <名称> 的值时，如果 <名称> 指向了另一个符号引用，则跟踪该符号引用链，直到结果不再指向一个符号引用为止（ `--recurse` ，这是默认设置）。 而 `--no-recurse` 只在取消引用单级符号引用后停止。"

#. type: Plain text
#: en/git-symbolic-ref.txt:61
#, priority:80
msgid "Update the reflog for <name> with <reason>. This is valid only when creating or updating a symbolic ref."
msgstr "用 <原因> 更新 <名称> 的 引用日志。 这仅在创建或更新符号引用时有效。"

#. type: Plain text
#: en/git-symbolic-ref.txt:71
#, placeholders:'.git/HEAD':'.git/HEAD':'.git/HEAD', priority:80
msgid "In the past, `.git/HEAD` was a symbolic link pointing at `refs/heads/master`. When we wanted to switch to another branch, we did `ln -sf refs/heads/newbranch .git/HEAD`, and when we wanted to find out which branch we are on, we did `readlink .git/HEAD`. But symbolic links are not entirely portable, so they are now deprecated and symbolic refs (as described above) are used by default."
msgstr "过去，\".git/HEAD\" 是指向 \"refs/heads/master\" 的符号链接。 当我们想切换到另一个分支时，可以使用 `ln -sf refs/heads/newbranch .git/HEAD`，当我们想知道自己在哪个分支时，可以使用 `readlink .git/HEAD`。 但符号链接并非完全可移植，所以现在已被弃用，默认使用符号引用（如上所述）。"

#. type: Plain text
#: en/git-symbolic-ref.txt:75
#, placeholders:'git symbolic-ref', priority:80
msgid "'git symbolic-ref' will exit with status 0 if the contents of the symbolic ref were printed correctly, with status 1 if the requested name is not a symbolic ref, or 128 if another error occurs."
msgstr "如果符号引用的内容打印正确，'git symbolic-ref' 将以状态 0 退出；如果请求的名称不是符号引用，则以状态 1 退出；如果出现其他错误，则以 128 退出。"

#. type: Title =
#: en/git-tag.txt:2
#, ignore-same, no-wrap, priority:240
msgid "git-tag(1)"
msgstr "git-tag(1)"

#. type: Plain text
#: en/git-tag.txt:7
#, placeholders:'git-tag', priority:240
msgid "git-tag - Create, list, delete or verify a tag object signed with GPG"
msgstr "git-tag - 创建、列出、删除或验证使用GPG签名的tag对象"

#. type: Plain text
#: en/git-tag.txt:20
#, ignore-ellipsis, no-wrap, placeholders:'[--contains':'[--no-contains':'[--points-at':'[--column':'--no-column]':'[--create-reflog]':'[--sort=':'[--format=':'[--merged':'[--no-merged':'[--format=', priority:240
msgid ""
"'git tag' [-a | -s | -u <key-id>] [-f] [-m <msg> | -F <file>] [-e]\n"
"\t<tagname> [<commit> | <object>]\n"
"'git tag' -d <tagname>...\n"
"'git tag' [-n[<num>]] -l [--contains <commit>] [--no-contains <commit>]\n"
"\t[--points-at <object>] [--column[=<options>] | --no-column]\n"
"\t[--create-reflog] [--sort=<key>] [--format=<format>]\n"
"\t[--merged <commit>] [--no-merged <commit>] [<pattern>...]\n"
"'git tag' -v [--format=<format>] <tagname>...\n"
msgstr ""
"'git tag' [-a | -s | -u <键-id>] [-f] [-m <信息> | -F <文件>] [-e]\n"
"\t<标签名> [<提交> | <对象>]\n"
"'git tag' -d <标签名>...\n"
"'git tag' [-n[<数字>]] -l [--contains <提交>] [--no-contains <提交>]\n"
"\t[--points-at <对象>] [--column[=<选项>] | --no-column]\n"
"\t[--create-reflog] [--sort=<键>] [--format=<格式>]\n"
"\t[--merged <提交>] [--no-merged <提交>] [<模式>...]\n"
"'git tag' -v [--format=<format>] <标签名>...\n"

#. type: Plain text
#: en/git-tag.txt:26
#, priority:240
msgid "Add a tag reference in `refs/tags/`, unless `-d/-l/-v` is given to delete, list or verify tags."
msgstr "在`refs/tags/`中添加一个标签引用，除非给出`-d/-l/-v`来删除、列出或验证标签。"

#. type: Plain text
#: en/git-tag.txt:28
#, placeholders:'`-f`', priority:240
msgid "Unless `-f` is given, the named tag must not yet exist."
msgstr "除非给出`-f`，否则命名的标签必须还不存在。"

# ERROR: `-a` not found in translation
# ERROR: `-s` not found in translation
#. type: Plain text
#: en/git-tag.txt:33
#, placeholders:'`-a`':'`-s`', priority:240
msgid "If one of `-a`, `-s`, or `-u <key-id>` is passed, the command creates a 'tag' object, and requires a tag message. Unless `-m <msg>` or `-F <file>` is given, an editor is started for the user to type in the tag message."
msgstr "如果传递了 `-a`、 `-s` 或 `-u <key-id>`中的一个，该命令会创建一个 '标签' 对象，并要求提供一个标签信息。 除非给出`-m <信息>`或`-F <文件>`，否则会启动一个编辑器，让用户输入标签信息。"

#. type: Plain text
#: en/git-tag.txt:36
#, placeholders:'`-a`':'`-s`':'`-a`', priority:240
msgid "If `-m <msg>` or `-F <file>` is given and `-a`, `-s`, and `-u <key-id>` are absent, `-a` is implied."
msgstr "如果给定了`-m <消息>`或`-F <文件>`，并且没有`-a`、`-s`和`-u <键-id>`，则默认为`-a`。"

#. type: Plain text
#: en/git-tag.txt:39
#, priority:240
msgid "Otherwise, a tag reference that points directly at the given object (i.e., a lightweight tag) is created."
msgstr "否则，就会创建一个直接指向给定对象的标签引用（即一个轻量级标签）。"

#. type: Plain text
#: en/git-tag.txt:45
#, placeholders:'`-s`':'gpg.program', priority:240
msgid "A GnuPG signed tag object will be created when `-s` or `-u <key-id>` is used. When `-u <key-id>` is not used, the committer identity for the current user is used to find the GnuPG key for signing. \tThe configuration variable `gpg.program` is used to specify custom GnuPG binary."
msgstr "当使用`-s`或`-u <键-id>`时，将创建一个GnuPG签名标签对象。 当没有使用`-u <键-id>`时，当前用户的提交者身份会被用来寻找GnuPG密钥进行签名。 \t配置变量 `gpg.program` 用于指定自定义 GnuPG 二进制文件。"

#. type: Plain text
#: en/git-tag.txt:51
#, placeholders:'`-a`':'`-s`':'`-u`', priority:240
msgid "Tag objects (created with `-a`, `-s`, or `-u`) are called \"annotated\" tags; they contain a creation date, the tagger name and e-mail, a tagging message, and an optional GnuPG signature. Whereas a \"lightweight\" tag is simply a name for an object (usually a commit object)."
msgstr "标签对象（用`-a`、`-s`或`-u`创建）被称为 \"注释 \"标签；它们包含创建日期、标记者姓名和电子邮件、标记信息和可选的GnuPG签名。而 \"轻量级 \"标签只是一个对象（通常是一个提交对象）的名称。"

#. type: Plain text
#: en/git-tag.txt:56
#, priority:240
msgid "Annotated tags are meant for release while lightweight tags are meant for private or temporary object labels. For this reason, some git commands for naming objects (like `git describe`) will ignore lightweight tags by default."
msgstr "注释性标签是用来发布的，而轻量级标签则是用于私人或临时对象的标签。由于这个原因，一些命名对象的git命令（如`git describe`）默认会忽略轻量级标签。"

#. type: Plain text
#: en/git-tag.txt:63
#, priority:240
msgid "Make an unsigned, annotated tag object"
msgstr "制作一个无符号、有注释的标签对象"

#. type: Labeled list
#: en/git-tag.txt:65
#, ignore-same, no-wrap, priority:240
msgid "--sign"
msgstr "--sign"

#. type: Plain text
#: en/git-tag.txt:70
#, placeholders:'tag.gpgSign':'linkgit:git-config[1]', priority:240
msgid "Make a GPG-signed tag, using the default e-mail address's key. The default behavior of tag GPG-signing is controlled by `tag.gpgSign` configuration variable if it exists, or disabled otherwise. See linkgit:git-config[1]."
msgstr "制作一个GPG签名的标签，使用默认电子邮件地址的密钥。 标签GPG签名的默认行为由`tag.gpgSign`配置变量控制（如果存在），否则禁用。 参见 linkgit:git-config[1]。"

#. type: Labeled list
#: en/git-tag.txt:71
#, ignore-same, no-wrap, priority:240
msgid "--no-sign"
msgstr "--no-sign"

#. type: Plain text
#: en/git-tag.txt:74
#, placeholders:'tag.gpgSign', priority:240
msgid "Override `tag.gpgSign` configuration variable that is set to force each and every tag to be signed."
msgstr "覆盖`tag.gpgSign`配置变量，该变量被设置为强制每一个标签都被签名。"

#. type: Labeled list
#: en/git-tag.txt:75
#, no-wrap, priority:240
msgid "-u <key-id>"
msgstr "-u <键 ID>"

#. type: Labeled list
#: en/git-tag.txt:76
#, no-wrap, placeholders:'--local-user=', priority:240
msgid "--local-user=<key-id>"
msgstr "--local-user=<键 ID>"

#. type: Plain text
#: en/git-tag.txt:78
#, priority:240
msgid "Make a GPG-signed tag, using the given key."
msgstr "制作一个GPG签名的标签，使用给定的密钥。"

#. type: Plain text
#: en/git-tag.txt:82
#, priority:240
msgid "Replace an existing tag with the given name (instead of failing)"
msgstr "用给定的名称替换一个现有的标签（而不是失败）"

#. type: Plain text
#: en/git-tag.txt:86
#, priority:240
msgid "Delete existing tags with the given names."
msgstr "删除给定名字的现存标签。"

#. type: Plain text
#: en/git-tag.txt:90
#, priority:240
msgid "Verify the GPG signature of the given tag names."
msgstr "验证给定标签名称的GPG签名。"

#. type: Labeled list
#: en/git-tag.txt:91
#, no-wrap, priority:240
msgid "-n<num>"
msgstr "-n<num>"

# ERROR: `--list` not found in translation
#. type: Plain text
#: en/git-tag.txt:94
#, placeholders:'`--list`', priority:240
msgid "<num> specifies how many lines from the annotation, if any, are printed when using -l. Implies `--list`."
msgstr "<数字>指定在使用-l时打印多少行注释，-l 是指 `--list`。"

# ERROR: `-n` not found in translation
#. type: Plain text
#: en/git-tag.txt:98
#, placeholders:'`-n`', priority:240
msgid "The default is not to print any annotation lines. If no number is given to `-n`, only the first line is printed. If the tag is not annotated, the commit message is displayed instead."
msgstr "默认是不打印任何注释行。 如果没有给 `-n` 加上数字，则只打印第一行。 如果标签没有注释，则会显示提交信息。"

#. type: Plain text
#: en/git-tag.txt:103
#, ignore-ellipsis, placeholders:'--list', priority:240
msgid "List tags. With optional `<pattern>...`, e.g. `git tag --list 'v-*'`, list only the tags that match the pattern(s)."
msgstr "列出标签。使用可选的`<模式>...`，例如`git tag --list 'v-*'`，只列出符合模式的标签。"

#. type: Plain text
#: en/git-tag.txt:107
#, priority:240
msgid "Running \"git tag\" without arguments also lists all tags. The pattern is a shell wildcard (i.e., matched using fnmatch(3)). Multiple patterns may be given; if any of them matches, the tag is shown."
msgstr "运行 \"git tag \"时不加参数也会列出所有标签。模式是一个shell通配符（即用fnmatch(3)匹配）。可以给出多个模式；如果其中任何一个匹配，就会显示该标签。"

#. type: Plain text
#: en/git-tag.txt:111
#, placeholders:'`--contains`', priority:240
msgid "This option is implicitly supplied if any other list-like option such as `--contains` is provided. See the documentation for each of those options for details."
msgstr "如果提供任何其他类似列表的选项，如`--contains`，则隐含地提供该选项。详情请参见这些选项的文档。"

#. type: Plain text
#: en/git-tag.txt:124
#, placeholders:'--sort=':'versionsort.suffix':'git for-each-ref':'tag.sort':'linkgit:git-config[1]', priority:240
msgid "Sort based on the key given. Prefix `-` to sort in descending order of the value. You may use the --sort=<key> option multiple times, in which case the last key becomes the primary key. Also supports \"version:refname\" or \"v:refname\" (tag names are treated as versions). The \"version:refname\" sort order can also be affected by the \"versionsort.suffix\" configuration variable. The keys supported are the same as those in `git for-each-ref`. Sort order defaults to the value configured for the `tag.sort` variable if it exists, or lexicographic order otherwise. See linkgit:git-config[1]."
msgstr "根据给定的键进行排序。 前缀 `-` 表示按照数值的降序排序。你可以多次使用 --sort=<键> 选项，在这种情况下，最后一个键成为主键。也支持 \"version:refname\" 或 \"v:refname\"（标签名被视为版本）。\"version:refname\" 的排序顺序也可以由 \"versionsort.suffix\" 配置变量影响。 支持的键与 `git for-each-ref` 中的相同。 排序顺序默认为 `tag.sort` 变量的配置值（如果存在的话），否则为词法顺序。见 linkgit:git-config[1]。"

#. type: Plain text
#: en/git-tag.txt:133
#, priority:240
msgid "Sorting and filtering tags are case insensitive."
msgstr "排序和过滤标签不区分大小写。"

#. type: Plain text
#: en/git-tag.txt:143
#, placeholders:'column.tag':'`--column`':'`--no-column`', priority:240
msgid "Display tag listing in columns. See configuration variable `column.tag` for option syntax. `--column` and `--no-column` without options are equivalent to 'always' and 'never' respectively."
msgstr "在列中显示标签列表。选项语法见配置变量`column.tag`。`--column`和`--no-column`没有选项，分别等同于'永远'和'从不'。"

#. type: Plain text
#: en/git-tag.txt:145
#, priority:240
msgid "This option is only applicable when listing tags without annotation lines."
msgstr "这个选项只适用于列出没有注释线的标签。"

# ERROR: HEAD not found in translation
#. type: Plain text
#: en/git-tag.txt:149
#, placeholders:'HEAD':'`--list`', priority:240
msgid "Only list tags which contain the specified commit (HEAD if not specified). Implies `--list`."
msgstr "只列出包含指定提交内容的标签（如果没有指定则为 HEAD）。暗指`--list`。"

# ERROR: HEAD not found in translation
#. type: Plain text
#: en/git-tag.txt:153
#, placeholders:'HEAD':'`--list`', priority:240
msgid "Only list tags which don't contain the specified commit (HEAD if not specified). Implies `--list`."
msgstr "只列出包含指定提交内容的标签（如果没有指定则为 HEAD）。暗指`--list`。"

#. type: Plain text
#: en/git-tag.txt:157
#, placeholders:'HEAD', priority:240
msgid "Only list tags whose commits are reachable from the specified commit (`HEAD` if not specified)."
msgstr "只列出其提交可以从指定提交（如果没有指定则为`HEAD`）到达的标签。"

#. type: Plain text
#: en/git-tag.txt:161
#, placeholders:'HEAD', priority:240
msgid "Only list tags whose commits are not reachable from the specified commit (`HEAD` if not specified)."
msgstr "只列出其提交可以从指定提交（如果没有指定则为`HEAD`）到达的标签。"

# ERROR: HEAD not found in translation
#. type: Plain text
#: en/git-tag.txt:165
#, placeholders:'HEAD':'`--list`', priority:240
msgid "Only list tags of the given object (HEAD if not specified). Implies `--list`."
msgstr "只列出给定对象的标签（如果没有指定则为 HEAD）。暗指`--list`。"

#. type: Plain text
#: en/git-tag.txt:173
#, placeholders:'`-m`':'`-a`':'`-a`':'`-s`', priority:240
msgid "Use the given tag message (instead of prompting). If multiple `-m` options are given, their values are concatenated as separate paragraphs. Implies `-a` if none of `-a`, `-s`, or `-u <key-id>` is given."
msgstr "使用给定的标签信息（而不是提示）。 如果给出多个 `-m` 选项，它们的值将作为单独的段落连接起来。 如果未给出 `-a`、`-s` 或 `-u <键 ID>` 选项，则默认为 `-a`。"

#. type: Plain text
#: en/git-tag.txt:180
#, placeholders:'`-a`':'`-a`':'`-s`', priority:240
msgid "Take the tag message from the given file. Use '-' to read the message from the standard input. Implies `-a` if none of `-a`, `-s`, or `-u <key-id>` is given."
msgstr "从给定文件中获取标记信息。 使用 '-' 从标准输入读取信息。 如果未给出 `-a` 、`-s` 或 `-u <键 ID>` 则默认为 `-a`。"

#. type: Plain text
#: en/git-tag.txt:186
#, placeholders:'`-F`':'`-m`', priority:240
msgid "The message taken from file with `-F` and command line with `-m` are usually used as the tag message unmodified. This option lets you further edit the message taken from these sources."
msgstr "用`-F`从文件中获取的信息和用`-m`从命令行中获取的信息通常被用作未修改的标签信息。 这个选项可以让你进一步编辑从这些来源获取的信息。"

#. type: Plain text
#: en/git-tag.txt:193
#, priority:240
msgid "This option sets how the tag message is cleaned up. The '<mode>' can be one of 'verbatim', 'whitespace' and 'strip'. The 'strip' mode is default. The 'verbatim' mode does not change message at all, 'whitespace' removes just leading/trailing whitespace lines and 'strip' removes both whitespace and commentary."
msgstr "这个选项设置了标签信息的清理方式。 '<模式>'可以是'verbatim'（逐字记录）、'whitespace'（空白）和'strip'（剥离）中的一个。 其中，'strip'模式是默认的。'verbatim'模式完全不改变信息，'whitespace'只删除前导/后导的空白行，'strip'同时删除空白和注释。"

#. type: Plain text
#: en/git-tag.txt:200
#, placeholders:'core.logAllRefUpdates':'linkgit:git-config[1]':'`--no-create-reflog`':'`--create-reflog`':'core.logAllRefUpdates', priority:240
msgid "Create a reflog for the tag. To globally enable reflogs for tags, see `core.logAllRefUpdates` in linkgit:git-config[1]. The negated form `--no-create-reflog` only overrides an earlier `--create-reflog`, but currently does not negate the setting of `core.logAllRefUpdates`."
msgstr "为标签创建一个引用日志。要全局性地启用标签的引用日志，请参见 linkgit:git-config[1] 中的 `core.logAllRefUpdates`。 否定形式的 `--no-create-reflog` 会覆盖先前的 `--create-reflog` ，但目前不会否定 `core.logAllRefUpdates` 的设置。"

#. type: Plain text
#: en/git-tag.txt:206
#, placeholders:'linkgit:git-for-each-ref[1]', priority:240
msgid "A string that interpolates `%(fieldname)` from a tag ref being shown and the object it points at. The format is the same as that of linkgit:git-for-each-ref[1]. When unspecified, defaults to `%(refname:strip=2)`."
msgstr "一个字符串，从正在显示的标签引用和它所指向的对象中插值`%(fieldname)'。 其格式与linkgit:git-for-each-ref[1]相同。 当未指定时，默认为`%(refname:strip=2)`。"

#. type: Labeled list
#: en/git-tag.txt:207
#, no-wrap, priority:240
msgid "<tagname>"
msgstr "<标签名>"

#. type: Plain text
#: en/git-tag.txt:212
#, placeholders:'linkgit:git-check-ref-format[1]', priority:240
msgid "The name of the tag to create, delete, or describe. The new tag name must pass all checks defined by linkgit:git-check-ref-format[1]. Some of these checks may restrict the characters allowed in a tag name."
msgstr "要创建、删除或描述的标签的名称。 新标签名必须通过 linkgit:git-check-ref-format[1] 定义的所有检查。 其中一些检查可能限制了标签名称中允许的字符。"

#. type: Labeled list
#: en/git-tag.txt:213 en/git.txt:399
#, no-wrap, priority:240
msgid "<commit>"
msgstr "<提交>"

#. type: Plain text
#: en/git-tag.txt:217
#, placeholders:'HEAD', priority:240
msgid "The object that the new tag will refer to, usually a commit. Defaults to HEAD."
msgstr "新标签将引用的对象，通常是一个提交。 默认为 HEAD。"

#. type: Plain text
#: en/git-tag.txt:224
#, priority:240
msgid "By default, 'git tag' in sign-with-default mode (-s) will use your committer identity (of the form `Your Name <your@email.address>`) to find a key. If you want to use a different default key, you can specify it in the repository configuration as follows:"
msgstr "默认情况下，sign-with-default模式下的'git tag'（-s）会使用你的提交者身份（形式为`你的名字<your@email.address>`）来寻找一个密钥。 如果你想使用一个不同的默认密钥，你可以在仓库配置中指定它，如下："

#. type: delimited block -
#: en/git-tag.txt:228
#, no-wrap, priority:240
msgid ""
"[user]\n"
"    signingKey = <gpg-key-id>\n"
msgstr ""
"[user]\n"
"    signingKey = <GPG 键 ID>\n"

#. type: Plain text
#: en/git-tag.txt:233
#, placeholders:'pager.tag':'`-l`':'linkgit:git-config[1]', priority:240
msgid "`pager.tag` is only respected when listing tags, i.e., when `-l` is used or implied. The default is to use a pager. See linkgit:git-config[1]."
msgstr "`pager.tag`只在列出标签时被尊重，即使用或暗示使用`-l`时。默认是使用分页器。 参见 linkgit:git-config[1]。"

#. type: Title ~
#: en/git-tag.txt:238
#, no-wrap, priority:240
msgid "On Re-tagging"
msgstr "关于重新打标签"

#. type: Plain text
#: en/git-tag.txt:242
#, priority:240
msgid "What should you do when you tag a wrong commit and you would want to re-tag?"
msgstr "当你标记了一个错误的提交，而你想重新标记时，你应该怎么做？"

#. type: Plain text
#: en/git-tag.txt:245
#, priority:240
msgid "If you never pushed anything out, just re-tag it. Use \"-f\" to replace the old one. And you're done."
msgstr "如果你从未推送到其他地方，只需重新标记。使用\"-f \"来替换旧的标签。然后你就完成了。"

#. type: Plain text
#: en/git-tag.txt:249
#, priority:240
msgid "But if you have pushed things out (or others could just read your repository directly), then others will have already seen the old tag. In that case you can do one of two things:"
msgstr "但如果你已经推送了（或者别人可以直接读取你的版本库），那么别人就已经看到了旧标签。在这种情况下，你可以在以下两种做法任选其一："

#. type: Plain text
#: en/git-tag.txt:256
#, priority:240
msgid "The sane thing. Just admit you screwed up, and use a different name. Others have already seen one tag-name, and if you keep the same name, you may be in the situation that two people both have \"version X\", but they actually have 'different' \"X\"'s. So just call it \"X.1\" and be done with it."
msgstr "理智的做法是。 只要承认你搞砸了，并使用一个不同的名字。其他人已经看到了一个标签名称，如果你保持相同的名称，你可能会出现这样的情况：两个人都有 \"X版\"，但他们实际上有 \"不同 \"的 \"X\"。 所以，只要叫它 \"X.1 \"就可以了。"

#. type: Plain text
#: en/git-tag.txt:261
#, priority:240
msgid "The insane thing. You really want to call the new version \"X\" too, 'even though' others have already seen the old one. So just use 'git tag -f' again, as if you hadn't already published the old one."
msgstr "疯狂的做法。 你真的想把新版本也称为 \"X\"，⌊尽管⌉别人已经看到了旧版本。所以就再用'git tag -f'，就好像你还没有发布过旧版本一样。"

#. type: Plain text
#: en/git-tag.txt:266
#, priority:240
msgid "However, Git does *not* (and it should not) change tags behind users back. So if somebody already got the old tag, doing a 'git pull' on your tree shouldn't just make them overwrite the old one."
msgstr "然而，Git*不会*（也不应该）背着用户改变标签。所以如果有人已经得到了旧的标签，在你的树上做 \"git pull \"不应该让他们覆盖旧的标签。"

#. type: Plain text
#: en/git-tag.txt:273
#, priority:240
msgid "If somebody got a release tag from you, you cannot just change the tag for them by updating your own one. This is a big security issue, in that people MUST be able to trust their tag-names. If you really want to do the insane thing, you need to just fess up to it, and tell people that you messed up. You can do that by making a very public announcement saying:"
msgstr "如果有人从你那里得到一个发布标签，你不能通过更新你自己的标签来为他们改变标签。这是一个很大的安全问题，因为人们必须能够信任他们的标签名。 如果你真的想做一件疯狂的事情，你需要承认这一点，并告诉人们你搞砸了。你可以通过发布一个非常公开的公告来做到这一点，比如说："

#. type: delimited block -
#: en/git-tag.txt:277
#, no-wrap, priority:240
msgid ""
"Ok, I messed up, and I pushed out an earlier version tagged as X. I\n"
"then fixed something, and retagged the *fixed* tree as X again.\n"
msgstr ""
"好吧，我搞砸了，我推送了一个标记为X的早期版本。\n"
"然后修复了一些东西，又把这个*修复的*目录树重新标记为X。\n"

#. type: delimited block -
#: en/git-tag.txt:280
#, no-wrap, priority:240
msgid ""
"If you got the wrong tag, and want the new one, please delete\n"
"the old one and fetch the new one by doing:\n"
msgstr ""
"如果你得到了错误的标签，并希望得到新的标签，\n"
"请删除旧的标签，并通过以下方式获取新的标签：\n"

#. type: delimited block -
#: en/git-tag.txt:283
#, no-wrap, priority:240
msgid ""
"\tgit tag -d X\n"
"\tgit fetch origin tag X\n"
msgstr ""
"\tgit tag -d X\n"
"\tgit fetch origin tag X\n"

#. type: delimited block -
#: en/git-tag.txt:285
#, no-wrap, priority:240
msgid "to get my updated tag.\n"
msgstr "以获得我的最新标签。\n"

#. type: delimited block -
#: en/git-tag.txt:287
#, no-wrap, priority:240
msgid "You can test which tag you have by doing\n"
msgstr "你可以通过以下方式测试你的标签\n"

#. type: delimited block -
#: en/git-tag.txt:289
#, no-wrap, placeholders:'git rev-parse', priority:240
msgid "\tgit rev-parse X\n"
msgstr "\tgit rev-parse X\n"

#. type: delimited block -
#: en/git-tag.txt:291
#, no-wrap, priority:240
msgid "which should return 0123456789abcdef.. if you have the new version.\n"
msgstr "如果你有新的版本，应该返回0123456789abcdef。\n"

#. type: delimited block -
#: en/git-tag.txt:293
#, no-wrap, priority:240
msgid "Sorry for the inconvenience.\n"
msgstr "不便之处，敬请原谅。\n"

#. type: Plain text
#: en/git-tag.txt:298
#, priority:240
msgid "Does this seem a bit complicated? It *should* be. There is no way that it would be correct to just \"fix\" it automatically. People need to know that their tags might have been changed."
msgstr "这看起来是不是有点复杂？它*应该*是这样的。自动 \"修复 \"它是不可能的。 人们需要知道他们的标签可能已经被改变。"

#. type: Title ~
#: en/git-tag.txt:301
#, no-wrap, priority:240
msgid "On Automatic following"
msgstr "在下列情况下自动进行"

#. type: Plain text
#: en/git-tag.txt:306
#, priority:240
msgid "If you are following somebody else's tree, you are most likely using remote-tracking branches (eg. `refs/remotes/origin/master`). You usually want the tags from the other end."
msgstr "如果你在跟踪别人的树目录，你很可能在使用远程跟踪的分支（例如：`refs/remotes/origin/master`）。 你通常希望得到另一端的标签。"

#. type: Plain text
#: en/git-tag.txt:313
#, priority:240
msgid "On the other hand, if you are fetching because you would want a one-shot merge from somebody else, you typically do not want to get tags from there. This happens more often for people near the toplevel but not limited to them. Mere mortals when pulling from each other do not necessarily want to automatically get private anchor point tags from the other person."
msgstr "另一方面，如果你是因为想从别人那里获得一次性合并而取的，你通常不希望从那里获得标签。 这种情况更经常发生在接近高层的人身上，但不限于他们。 普通人从对方那里取东西时，不一定想从对方那里自动获得私人锚点标签。"

#. type: Plain text
#: en/git-tag.txt:318
#, priority:240
msgid "Often, \"please pull\" messages on the mailing list just provide two pieces of information: a repo URL and a branch name; this is designed to be easily cut&pasted at the end of a 'git fetch' command line:"
msgstr "通常，邮件列表上的 \"请拉\"信息只提供了两条信息：一个 仓库URL 和一个分支名称；这被设计成可以轻松地剪切和粘贴在 \"git fetch \"命令行的末尾："

#. type: delimited block -
#: en/git-tag.txt:321
#, no-wrap, priority:240
msgid "Linus, please pull from\n"
msgstr "Linus，请从这里拉取\n"

#. type: delimited block -
#: en/git-tag.txt:323
#, ignore-ellipsis, no-wrap, placeholders:'proj.git', priority:240
msgid "\tgit://git..../proj.git master\n"
msgstr "\tgit://git..../proj.git master\n"

#. type: delimited block -
#: en/git-tag.txt:325
#, ignore-ellipsis, no-wrap, priority:240
msgid "to get the following updates...\n"
msgstr "以获得以下更新...\n"

#. type: Plain text
#: en/git-tag.txt:328
#, priority:240
msgid "becomes:"
msgstr "成为："

#. type: delimited block -
#: en/git-tag.txt:331
#, ignore-ellipsis, no-wrap, placeholders:'proj.git', priority:240
msgid "$ git pull git://git..../proj.git master\n"
msgstr "$ git pull git://git..../proj.git master\n"

#. type: Plain text
#: en/git-tag.txt:335
#, priority:240
msgid "In such a case, you do not want to automatically follow the other person's tags."
msgstr "在这种情况下，你不希望自动跟随对方的标签。"

#. type: Plain text
#: en/git-tag.txt:343
#, priority:240
msgid "One important aspect of Git is its distributed nature, which largely means there is no inherent \"upstream\" or \"downstream\" in the system. On the face of it, the above example might seem to indicate that the tag namespace is owned by the upper echelon of people and that tags only flow downwards, but that is not the case. It only shows that the usage pattern determines who are interested in whose tags."
msgstr "Git 的一个重要方面是它的分布式性质，这很大程度上意味着系统中没有固有的 \"上游 \"或 \"下游\"。 从表面上看，上面的例子似乎表明标签命名空间是由上层人士拥有的，而标签只能向下流动，但事实并非如此。 它只是表明，使用模式决定了谁对谁的标签感兴趣。"

#. type: Plain text
#: en/git-tag.txt:355
#, priority:240
msgid "A one-shot pull is a sign that a commit history is now crossing the boundary between one circle of people (e.g. \"people who are primarily interested in the networking part of the kernel\") who may have their own set of tags (e.g. \"this is the third release candidate from the networking group to be proposed for general consumption with 2.6.21 release\") to another circle of people (e.g. \"people who integrate various subsystem improvements\"). The latter are usually not interested in the detailed tags used internally in the former group (that is what \"internal\" means). That is why it is desirable not to follow tags automatically in this case."
msgstr "一次性拉取是一个标志，表明一个提交历史正在跨越一个圈子（例如 \"主要对内核的网络部分感兴趣的人\"）和另一个圈子（例如 \"整合各种子系统改进的人\"）之间的界限，后者可能有自己的一套标签（例如 \"这是网络组的第三个候选版本，将在2.6.21版本中被建议用于一般消费\"）。 后者通常对前一组内部使用的详细标签不感兴趣（这就是 \"内部 \"的意思）。 这就是为什么在这种情况下最好不要自动跟随标签。"

#. type: Plain text
#: en/git-tag.txt:361
#, priority:240
msgid "It may well be that among networking people, they may want to exchange the tags internal to their group, but in that workflow they are most likely tracking each other's progress by having remote-tracking branches. Again, the heuristic to automatically follow such tags is a good thing."
msgstr "在这个网络知州，他们可能想交换他们小组内部的标签，但在那个工作流程中，他们很可能是通过有远程跟踪的分支来跟踪对方的进展。 同样，自动跟踪这种标签的启发式方法也是一个好东西。"

#. type: Title ~
#: en/git-tag.txt:364
#, no-wrap, priority:240
msgid "On Backdating Tags"
msgstr "关于回溯标签"

#. type: Plain text
#: en/git-tag.txt:371
#, priority:240
msgid "If you have imported some changes from another VCS and would like to add tags for major releases of your work, it is useful to be able to specify the date to embed inside of the tag object; such data in the tag object affects, for example, the ordering of tags in the gitweb interface."
msgstr "如果你从另一个VCS导入了一些修改，并想为你工作的主要版本添加标签，能够指定嵌入标签对象内部的日期是很有用的；标签对象中的这种数据会产生影响，例如，gitweb界面中标签的排序。"

#. type: Plain text
#: en/git-tag.txt:375
#, placeholders:'GIT_COMMITTER_DATE', priority:240
msgid "To set the date used in future tag objects, set the environment variable GIT_COMMITTER_DATE (see the later discussion of possible values; the most common form is \"YYYY-MM-DD HH:MM\")."
msgstr "要设置未来标签对象中使用的日期，请设置环境变量GIT_COMMITTER_DATE（见后面关于可能数值的讨论；最常见的形式是 \"YYY-MM-DD HH:MM\"）。"

#. type: delimited block -
#: en/git-tag.txt:380
#, no-wrap, placeholders:'GIT_COMMITTER_DATE', priority:240
msgid "$ GIT_COMMITTER_DATE=\"2006-10-02 10:31\" git tag -s v1.0.1\n"
msgstr "$ GIT_COMMITTER_DATE=\"2006-10-02 10:31\" git tag -s v1.0.1\n"

#. type: Labeled list
#: en/git-tag.txt:387
#, no-wrap, placeholders:'$GIT_DIR':'TAG_EDITMSG', priority:240
msgid "`$GIT_DIR/TAG_EDITMSG`"
msgstr "`$GIT_DIR/TAG_EDITMSG`"

#. type: Plain text
#: en/git-tag.txt:393
#, priority:240
msgid "This file contains the message of an in-progress annotated tag. If `git tag` exits due to an error before creating an annotated tag then the tag message that has been provided by the user in an editor session will be available in this file, but may be overwritten by the next invocation of `git tag`."
msgstr "该文件包含一个进行中的注释标记的信息。如果 `git tag` 在创建注释标记前出错退出，则用户在编辑器会话中提供的标记信息将在此文件中提供，但可能会被下一次调用 `git tag` 时覆盖。"

#. type: Plain text
#: en/git-tag.txt:403
#, placeholders:'linkgit:git-check-ref-format[1]':'linkgit:git-config[1]', priority:240
msgid "linkgit:git-check-ref-format[1]. linkgit:git-config[1]."
msgstr "linkgit:git-check-ref-format[1]. linkgit:git-config[1]."

#. type: Title =
#: en/git.txt:2
#, no-wrap, priority:100
msgid "git(1)"
msgstr "git(1)"

#. type: Plain text
#: en/git.txt:7
#, priority:100
msgid "git - the stupid content tracker"
msgstr "git - 简单的内容追踪系统"

#. type: Plain text
#: en/git.txt:17
#, no-wrap, placeholders:'--version]':'--help]':'[--exec-path':'[--html-path]':'[--man-path]':'[--info-path]':'--paginate':'--no-pager]':'[--no-replace-objects]':'[--bare]':'[--work-tree=':'[--namespace=':'[--config-env=', priority:100
msgid ""
"'git' [-v | --version] [-h | --help] [-C <path>] [-c <name>=<value>]\n"
"    [--exec-path[=<path>]] [--html-path] [--man-path] [--info-path]\n"
"    [-p|--paginate|-P|--no-pager] [--no-replace-objects] [--bare]\n"
"    [--git-dir=<path>] [--work-tree=<path>] [--namespace=<name>]\n"
"    [--config-env=<name>=<envvar>] <command> [<args>]\n"
msgstr ""
"'git' [-v | --version] [-h | --help] [-C <启动路径>] [-c <配置名>=<配置值>]\n"
"    [--exec-path[=<核心程序路径>]] [--html-path] [--man-path] [--info-path]\n"
"    [-p|--paginate|-P|--no-pager] [--no-replace-objects] [--bare]\n"
"    [--git-dir=<仓库路径>] [--work-tree=<工作目录路径>] [--namespace=<命名空间名>]\n"
"    [--config-env=<配置名>=<环境变量>] <命令> [<参数>]\n"

#. type: Plain text
#: en/git.txt:23
#, priority:100
msgid "Git is a fast, scalable, distributed revision control system with an unusually rich command set that provides both high-level operations and full access to internals."
msgstr "Git 是一个快速、可扩展的分布式版本控制系统，它拥有异常丰富的命令集，可以提供高级操作和对内部的完全访问。"

#. type: Plain text
#: en/git.txt:28
#, placeholders:'linkgit:gittutorial[7]':'linkgit:giteveryday[7]':'link:user-manual.html[', priority:100
msgid "See linkgit:gittutorial[7] to get started, then see linkgit:giteveryday[7] for a useful minimum set of commands. The link:user-manual.html[Git User's Manual] has a more in-depth introduction."
msgstr "参阅 linkgit:gittutorial[7] 开始使用，然后查看 linkgit:giteveryday[7] 以获取一组有用的基础命令。 link:user-manual.html[Git 用户手册]中有对 Git 更为深入的介绍。"

#. type: Plain text
#: en/git.txt:33
#, placeholders:'linkgit:gitcli[7]', priority:100
msgid "After you mastered the basic concepts, you can come back to this page to learn what commands Git offers. You can learn more about individual Git commands with \"git help command\". linkgit:gitcli[7] manual page gives you an overview of the command-line command syntax."
msgstr "在掌握了基本概念之后，你可以回到本页了解 Git 提供的命令。 你可以通过 \"git help\" 命令了解更多关于单个 Git 命令的信息。 linkgit:gitcli[7] 手册页面提供了命令行命令语法的概述。"

#. type: Plain text
#: en/git.txt:37
#, placeholders:'git.github.io':'git.html':'git-scm', priority:100
msgid "A formatted and hyperlinked copy of the latest Git documentation can be viewed at https://git.github.io/htmldocs/git.html or https://git-scm.com/docs."
msgstr "最新 Git 文档的格式化和超文本副本可以在 https://git.github.io/htmldocs/git.html 或 https://git-scm.com/docs上查看。"

#. type: Plain text
#: en/git.txt:44
#, priority:100
msgid "Prints the Git suite version that the 'git' program came from."
msgstr "打印 'git' 程序的 Git 套件版本。"

#. type: Plain text
#: en/git.txt:48
#, ignore-ellipsis, placeholders:'linkgit:git-version[1]':'`--help`':'`--version`', priority:100
msgid "This option is internally converted to `git version ...` and accepts the same options as the linkgit:git-version[1] command. If `--help` is also given, it takes precedence over `--version`."
msgstr "此选项在内部转换为 `git version ...` 并接受与linkgit:git-version[1] 命令相同的选项。如果 `--version` 后接 `--help` 选项，则会优先展示 `--version` 选项的帮助信息。"

#. type: Plain text
#: en/git.txt:55
#, placeholders:'`--all`':'`-a`', priority:100
msgid "Prints the synopsis and a list of the most commonly used commands. If the option `--all` or `-a` is given then all available commands are printed. If a Git command is named this option will bring up the manual page for that command."
msgstr "打印概要和最常用的命令列表。如果给出选项 `--all` 或 `-a`，则打印所有可用的命令。如果给出某个命令，该选项将调出该命令的手册页面。"

#. type: Plain text
#: en/git.txt:60
#, ignore-ellipsis, placeholders:'linkgit:git-help[1]':'--help', priority:100
msgid "Other options are available to control how the manual page is displayed. See linkgit:git-help[1] for more information, because `git --help ...` is converted internally into `git help ...`."
msgstr "因为 `git --help ...` 会在内部转换为 `git help ...`，所以有关其他可以控制手册页面显示方式的选项可以参阅 linkgit:git-help[1] 来获得更详细的信息。"

#. type: Labeled list
#: en/git.txt:61
#, no-wrap, priority:100
msgid "-C <path>"
msgstr "-C <启动路径>"

#. type: Plain text
#: en/git.txt:67
#, placeholders:'`-C`', priority:100
msgid "Run as if git was started in '<path>' instead of the current working directory. When multiple `-C` options are given, each subsequent non-absolute `-C <path>` is interpreted relative to the preceding `-C <path>`. If '<path>' is present but empty, e.g. `-C \"\"`, then the current working directory is left unchanged."
msgstr "运行时就像 git 命令在 '<启动路径>' 而不是在当前工作目录下启动一样。 当给出多个 `-C` 选项时，每个后续的非绝对的 `-C <启动路径>` 都是相对于前一个 `-C <启动路径>` 解释的。 如果 '<启动路径>' 存在但为空，例如 `-C \"\"`，那么命令就在当前工作目录启动。"

#. type: Plain text
#: en/git.txt:72
#, placeholders:'`--work-tree`':'`-C`', priority:100
msgid "This option affects options that expect path name like `--git-dir` and `--work-tree` in that their interpretations of the path names would be made relative to the working directory caused by the `-C` option. For example the following invocations are equivalent:"
msgstr "这个选项会影响到像 `--git-dir` 和 `--work-tree` 这样的需要路径名的选项，因为它们会用 `-C` 选项设置的启动路径进行相对路径的解释。例如，以下的调用是等价的："

#. type: Plain text
#: en/git.txt:75
#, no-wrap, placeholders:'--work-tree=b':'a.git':'--work-tree=c', priority:100
msgid ""
"    git --git-dir=a.git --work-tree=b -C c status\n"
"    git --git-dir=c/a.git --work-tree=c/b status\n"
msgstr ""
"    git --git-dir=a.git --work-tree=b -C c status\n"
"    git --git-dir=c/a.git --work-tree=c/b status\n"

#. type: Labeled list
#: en/git.txt:76
#, no-wrap, priority:100
msgid "-c <name>=<value>"
msgstr "-c <配置名>=<配置值>"

#. type: Plain text
#: en/git.txt:81
#, priority:100
msgid "Pass a configuration parameter to the command. The value given will override values from configuration files. The <name> is expected in the same format as listed by 'git config' (subkeys separated by dots)."
msgstr "向命令传递一个配置参数。给出的值将覆盖配置文件的值。 <配置名> 的格式应与 'git config' 列出的格式相同（子键由 `.` 分隔）。"

#. type: Plain text
#: en/git.txt:87
#, ignore-ellipsis, placeholders:'foo.bar':'foo.bar':'foo.bar':'foo.bar':'--type=bool`', priority:100
msgid "Note that omitting the `=` in `git -c foo.bar ...` is allowed and sets `foo.bar` to the boolean true value (just like `[foo]bar` would in a config file). Including the equals but with an empty value (like `git -c foo.bar= ...`) sets `foo.bar` to the empty string which `git config --type=bool` will convert to `false`."
msgstr "注意在 `git -c foo.bar ...` 中省略 `=` 是允许的，并会将 `foo.bar` 设置为布尔值 true（就像配置文件中的 `[foo]bar` 一样）。包括等号但有一个空值（如 `git -c foo.bar= ...` ）会将 `foo.bar` 设置为空字符串，如果 `git config --type=bool` 空值会转换为 `false`。"

#. type: Labeled list
#: en/git.txt:88
#, no-wrap, placeholders:'--config-env=', priority:100
msgid "--config-env=<name>=<envvar>"
msgstr "--config-env=<配置名>=<环境变量>"

#. type: Plain text
#: en/git.txt:97
#, placeholders:'`-c`', priority:100
msgid "Like `-c <name>=<value>`, give configuration variable '<name>' a value, where <envvar> is the name of an environment variable from which to retrieve the value. Unlike `-c` there is no shortcut for directly setting the value to an empty string, instead the environment variable itself must be set to the empty string. It is an error if the `<envvar>` does not exist in the environment. `<envvar>` may not contain an equals sign to avoid ambiguity with `<name>` containing one."
msgstr "像 `-c <配置名>=<配置值>` 一样，给配置变量 '<配置名>' 一个值，其中 <环境变量> 是一个环境变量的名字，可以从中获取该环境变量的值。与 `-c` 选项不同的是，没有直接将值设置为空字符串的快捷方式，除非环境变量本身就设置为空字符串。 如果 `<环境变量>` 在环境变量中不存在，则会报错。`<环境变量>` 不应当包含等号，以避免与包含等号的 `<配置名>` 产生歧义。"

#. type: Plain text
#: en/git.txt:104
#, priority:100
msgid "This is useful for cases where you want to pass transitory configuration options to git, but are doing so on operating systems where other processes might be able to read your command line (e.g. `/proc/self/cmdline`), but not your environment (e.g. `/proc/self/environ`). That behavior is the default on Linux, but may not be on your system."
msgstr "当你想把临时配置选项传递给 Git，但在操作系统上，其他进程可能能读取你的命令行（如 `/proc/self/cmdline`），但不能读取你的环境（如 `/proc/self/environ`）时，这个功能就很有用了。这种行为在 Linux 上是默认的，但在你的系统上可能不是。"

#. type: Plain text
#: en/git.txt:109
#, placeholders:'http.extraHeader', priority:100
msgid "Note that this might add security for variables such as `http.extraHeader` where the sensitive information is part of the value, but not e.g. `url.<base>.insteadOf` where the sensitive information can be part of the key."
msgstr "请注意，这可能会增加变量的安全性，例如 `http.extraHeader`，因为他的敏感信息包含在值中，但并不会增加例如 `url.<原始 URL 前缀>.insteadOf` 这种变量的安全性，因为其敏感信息可能会包含在部分键中。"

#. type: Labeled list
#: en/git.txt:110
#, no-wrap, placeholders:'--exec-path', priority:100
msgid "--exec-path[=<path>]"
msgstr "--exec-path[=<核心程序路径>]"

#. type: Plain text
#: en/git.txt:115
#, placeholders:'GIT_EXEC_PATH', priority:100
msgid "Path to wherever your core Git programs are installed. This can also be controlled by setting the GIT_EXEC_PATH environment variable. If no path is given, 'git' will print the current setting and then exit."
msgstr "安装 Git 核心程序的路径。 这也可以通过设置 GIT_EXEC_PATH 环境变量来控制。如果没有给出路径，'git' 会打印当前的设置，然后退出。"

#. type: Labeled list
#: en/git.txt:116
#, ignore-same, no-wrap, priority:100
msgid "--html-path"
msgstr "--html-path"

#. type: Plain text
#: en/git.txt:119
#, priority:100
msgid "Print the path, without trailing slash, where Git's HTML documentation is installed and exit."
msgstr "打印 Git 的 HTML 文档的安装路径（尾部不带斜杠）然后退出。"

#. type: Labeled list
#: en/git.txt:120
#, ignore-same, no-wrap, priority:100
msgid "--man-path"
msgstr "--man-path"

#. type: Plain text
#: en/git.txt:123
#, priority:100
msgid "Print the manpath (see `man(1)`) for the man pages for this version of Git and exit."
msgstr "打印该版本 Git man page 的 manpath（参阅 `man(1)`）之后退出。"

#. type: Labeled list
#: en/git.txt:124
#, ignore-same, no-wrap, priority:100
msgid "--info-path"
msgstr "--info-path"

#. type: Plain text
#: en/git.txt:127
#, priority:100
msgid "Print the path where the Info files documenting this version of Git are installed and exit."
msgstr "打印记录该版本 Git 信息文件的安装路径并退出。"

#. type: Labeled list
#: en/git.txt:129
#, ignore-same, no-wrap, priority:100
msgid "--paginate"
msgstr "--paginate"

#. type: Plain text
#: en/git.txt:134
#, placeholders:'$PAGER', priority:100
msgid "Pipe all output into 'less' (or if set, $PAGER) if standard output is a terminal. This overrides the `pager.<cmd>` configuration options (see the \"Configuration Mechanism\" section below)."
msgstr "如果标准输出是一个终端，则将所有的输出输出到 'less（git 默认的分页器）'（或者是 $PAGER 变量设置的值）中。 这会覆盖 `pager.<cmd>` 配置选项（参阅下面的 “配置机制” 部分）。"

#. type: Labeled list
#: en/git.txt:136
#, ignore-same, no-wrap, priority:100
msgid "--no-pager"
msgstr "--no-pager"

#. type: Plain text
#: en/git.txt:138
#, priority:100
msgid "Do not pipe Git output into a pager."
msgstr "不使用分页器进行 Git 的输出。"

#. type: Labeled list
#: en/git.txt:139
#, no-wrap, priority:100
msgid "--git-dir=<path>"
msgstr "--git-dir=<仓库路径>"

#. type: Plain text
#: en/git.txt:143
#, placeholders:'GIT_DIR', priority:100
msgid "Set the path to the repository (\".git\" directory). This can also be controlled by setting the `GIT_DIR` environment variable. It can be an absolute path or relative path to current working directory."
msgstr "设置仓库的路径（\".git\" 目录）。这也可以通过设置 `GIT_DIR` 环境变量来控制。<仓库路径> 可以是绝对路径或是当前工作目录的相对路径。"

#. type: Plain text
#: en/git.txt:154
#, placeholders:'GIT_DIR':'`--work-tree=':'GIT_WORK_TREE', priority:100
msgid "Specifying the location of the \".git\" directory using this option (or `GIT_DIR` environment variable) turns off the repository discovery that tries to find a directory with \".git\" subdirectory (which is how the repository and the top-level of the working tree are discovered), and tells Git that you are at the top level of the working tree. If you are not at the top-level directory of the working tree, you should tell Git where the top-level of the working tree is, with the `--work-tree=<path>` option (or `GIT_WORK_TREE` environment variable)"
msgstr "使用该选项（或 `GIT_DIR` 环境变量）指定 \".git\" 目录的位置，这会关闭对带有 \".git\" 子目录仓库的扫描（这是找到仓库和顶级工作区的方式），并告诉 Git 当前在顶级工作区。 如果当前并不在工作区的顶级目录，你应该用 `--work-tree=<工作区路径>` 选项（或 `GIT_WORK_TREE` 环境变量）告诉 Git 顶级工作区在哪里"

#. type: Plain text
#: en/git.txt:157
#, priority:100
msgid "If you just want to run git as if it was started in `<path>` then use `git -C <path>`."
msgstr "如果你只是想在 `<启动路径>` 中运行 Git，可以使用 `git -C <启动路径>`。"

#. type: Labeled list
#: en/git.txt:158
#, no-wrap, placeholders:'--work-tree=', priority:100
msgid "--work-tree=<path>"
msgstr "--work-tree=<工作区路径>"

#. type: Plain text
#: en/git.txt:165
#, placeholders:'GIT_WORK_TREE':'core.worktree':'core.worktree':'linkgit:git-config[1]', priority:100
msgid "Set the path to the working tree. It can be an absolute path or a path relative to the current working directory. This can also be controlled by setting the GIT_WORK_TREE environment variable and the core.worktree configuration variable (see core.worktree in linkgit:git-config[1] for a more detailed discussion)."
msgstr "设置工作树的路径。<工作区路径> 可以是一个绝对路径或与当前工作目录相对的路径。 这也可以通过设置 GIT_WORK_TREE 环境变量和 core.worktree 配置变量来控制（参阅 linkgit:git-config[1] 中的 core.worktree 获取更为详细的论述）。"

#. type: Labeled list
#: en/git.txt:166
#, no-wrap, placeholders:'--namespace=', priority:100
msgid "--namespace=<path>"
msgstr "--namespace=<路径>"

#. type: Plain text
#: en/git.txt:170
#, placeholders:'linkgit:gitnamespaces[7]':'GIT_NAMESPACE', priority:100
msgid "Set the Git namespace. See linkgit:gitnamespaces[7] for more details. Equivalent to setting the `GIT_NAMESPACE` environment variable."
msgstr "设置 Git 命名空间。 参阅 linkgit:gitnamespaces[7] 以了解更多细节。 这相当于设置 `GIT_NAMESPACE` 环境变量。"

#. type: Plain text
#: en/git.txt:175
#, placeholders:'GIT_DIR', priority:100
msgid "Treat the repository as a bare repository. If GIT_DIR environment is not set, it is set to the current working directory."
msgstr "将该仓库视为裸仓库。 如果没有设置 GIT_DIR 环境变量，它将在当前工作目录生成仓库。"

#. type: Labeled list
#: en/git.txt:176
#, ignore-same, no-wrap, priority:100
msgid "--no-replace-objects"
msgstr "--no-replace-objects"

#. type: Plain text
#: en/git.txt:179
#, placeholders:'linkgit:git-replace[1]', priority:100
msgid "Do not use replacement refs to replace Git objects. See linkgit:git-replace[1] for more information."
msgstr "不使用候补引用来替换 Git 对象。更多信息参阅 linkgit:git-replace[1]。"

#. type: Labeled list
#: en/git.txt:180
#, ignore-same, no-wrap, priority:100
msgid "--literal-pathspecs"
msgstr "--literal-pathspecs"

#. type: Plain text
#: en/git.txt:184
#, placeholders:'GIT_LITERAL_PATHSPECS', priority:100
msgid "Treat pathspecs literally (i.e. no globbing, no pathspec magic). This is equivalent to setting the `GIT_LITERAL_PATHSPECS` environment variable to `1`."
msgstr "按字面意思处理路径规格（即不使用通配符，不使用路径规范功能）。 这相当于将 `GIT_LITERAL_PATHSPECS` 环境变量设置为 `1`。"

#. type: Labeled list
#: en/git.txt:185
#, ignore-same, no-wrap, priority:100
msgid "--glob-pathspecs"
msgstr "--glob-pathspecs"

#. type: Plain text
#: en/git.txt:190
#, placeholders:'GIT_GLOB_PATHSPECS', priority:100
msgid "Add \"glob\" magic to all pathspec. This is equivalent to setting the `GIT_GLOB_PATHSPECS` environment variable to `1`. Disabling globbing on individual pathspecs can be done using pathspec magic \":(literal)\""
msgstr "在所有的路径规范中添加 \"glob\" 模式匹配功能。这相当于将 `GIT_GLOB_PATHSPECS` 环境变量设置为 `1`。可以用路径规范字符 \":(literal)\" 在单个路径规格上禁用 \"glob\" 模式匹配功能。"

#. type: Labeled list
#: en/git.txt:191
#, ignore-same, no-wrap, priority:100
msgid "--noglob-pathspecs"
msgstr "--noglob-pathspecs"

#. type: Plain text
#: en/git.txt:196
#, placeholders:'GIT_NOGLOB_PATHSPECS', priority:100
msgid "Add \"literal\" magic to all pathspec. This is equivalent to setting the `GIT_NOGLOB_PATHSPECS` environment variable to `1`. Enabling globbing on individual pathspecs can be done using pathspec magic \":(glob)\""
msgstr "在所有路径规范中添加 \"literal\" 模式匹配功能。这相当于将 `GIT_NOGLOB_PATHSPECS` 环境变量设为 `1`。可以使用路径规范字符 \":(glob)\" 在单个路径规范上启用通配符模式匹配功能。"

#. type: Labeled list
#: en/git.txt:197
#, ignore-same, no-wrap, priority:100
msgid "--icase-pathspecs"
msgstr "--icase-pathspecs"

#. type: Plain text
#: en/git.txt:200
#, placeholders:'GIT_ICASE_PATHSPECS', priority:100
msgid "Add \"icase\" magic to all pathspec. This is equivalent to setting the `GIT_ICASE_PATHSPECS` environment variable to `1`."
msgstr "在所有的路径规范中添加 \"icase\" 模式匹配功能。这相当于将 `GIT_ICASE_PATHSPECS` 环境变量设置为 `1`。"

#. type: Labeled list
#: en/git.txt:201
#, ignore-same, no-wrap, priority:100
msgid "--no-optional-locks"
msgstr "--no-optional-locks"

#. type: Plain text
#: en/git.txt:204
#, placeholders:'GIT_OPTIONAL_LOCKS', priority:100
msgid "Do not perform optional operations that require locks. This is equivalent to setting the `GIT_OPTIONAL_LOCKS` to `0`."
msgstr "禁止执行需要文件锁的可选操作。这相当于将 `GIT_OPTIONAL_LOCKS` 设置为 `0`。"

#. type: Labeled list
#: en/git.txt:205
#, ignore-ellipsis, no-wrap, placeholders:'--list-cmds=', priority:100
msgid "--list-cmds=<group>[,<group>...]"
msgstr "--list-cmds=<命令组>[,<命令组>...]"

#. type: Plain text
#: en/git.txt:214
#, placeholders:'$PATH':'list.txt':'completion.commands', priority:100
msgid "List commands by group. This is an internal/experimental option and may change or be removed in the future. Supported groups are: builtins, parseopt (builtin commands that use parse-options), main (all commands in libexec directory), others (all other commands in `$PATH` that have git- prefix), list-<category> (see categories in command-list.txt), nohelpers (exclude helper commands), alias and config (retrieve command list from config variable completion.commands)"
msgstr "按组列出命令。这是一个内部/实验性的选项，将来可能会改变或删除。支持的组有：buildins、parseopt（使用 parse-options 的内置命令）、main（libexec 目录下的所有命令）、others（ `$PATH` 中其他带有 git- 前缀的命令）、list-<目录>（参阅 command-list.txt 中的目录【原文是这么说的，但是下面那个 Git 命令章节已经列出了所有命令列表】）、nohelpers（排除辅助命令）、alias 和 config（在配置 completion.commands 中检索命令列表）"

#. type: Labeled list
#: en/git.txt:215
#, no-wrap, placeholders:'--attr-source=', priority:100
msgid "--attr-source=<tree-ish>"
msgstr "--attr-source=<树对象>"

#. type: Plain text
#: en/git.txt:219
#, placeholders:'linkgit:gitattributes[5]':'GIT_ATTR_SOURCE', priority:100
msgid "Read gitattributes from <tree-ish> instead of the worktree. See linkgit:gitattributes[5]. This is equivalent to setting the `GIT_ATTR_SOURCE` environment variable."
msgstr "从 <树对象> 而不是工作区中读取 gitattributes。参见 linkgit:gitattributes[5]。这相当于设置 `GIT_ATTR_SOURCE` 环境变量。"

#. type: Title -
#: en/git.txt:221
#, no-wrap, priority:100
msgid "GIT COMMANDS"
msgstr "Git 命令"

#. type: Plain text
#: en/git.txt:225
#, priority:100
msgid "We divide Git into high level (\"porcelain\") commands and low level (\"plumbing\") commands."
msgstr "我们把 Git 分为上层封装命令（“瓷件”）和底层核心命令（“管件”）。"

#. type: Title -
#: en/git.txt:227
#, no-wrap, priority:100
msgid "High-level commands (porcelain)"
msgstr "上层封装命令（瓷件）"

#. type: Plain text
#: en/git.txt:231
#, priority:100
msgid "We separate the porcelain commands into the main commands and some ancillary user utilities."
msgstr "我们将瓷件命令分为主要命令和一些辅助性的用户工具。"

#. type: Title ~
#: en/git.txt:233
#, no-wrap, priority:100
msgid "Main porcelain commands"
msgstr "主要瓷件命令"

#. type: Title ~
#: en/git.txt:238
#, no-wrap, priority:100
msgid "Ancillary Commands"
msgstr "辅助命令"

#. type: Plain text
#: en/git.txt:240
#, priority:100
msgid "Manipulators:"
msgstr "操控："

#. type: Plain text
#: en/git.txt:244
#, priority:100
msgid "Interrogators:"
msgstr "审阅："

#. type: Title ~
#: en/git.txt:249
#, no-wrap, priority:100
msgid "Interacting with Others"
msgstr "与其他应用交互"

#. type: Plain text
#: en/git.txt:253
#, priority:100
msgid "These commands are to interact with foreign SCM and with other people via patch over e-mail."
msgstr "这些命令是为了与外部 SCM（源代码管理工具）以及通过电子邮件与其他人进行交互。"

#. type: Title ~
#: en/git.txt:257
#, no-wrap, priority:100
msgid "Reset, restore and revert"
msgstr "重置、恢复和还原"

#. type: Plain text
#: en/git.txt:260
#, priority:100
msgid "There are three commands with similar names: `git reset`, `git restore` and `git revert`."
msgstr "包括了三个名称相似的命令：`git reset`、`git restore` 和 `git revert`。"

#. type: Plain text
#: en/git.txt:263
#, placeholders:'linkgit:git-revert[1]', priority:100
msgid "linkgit:git-revert[1] is about making a new commit that reverts the changes made by other commits."
msgstr "linkgit:git-revert[1] 是关于进行新的提交，以还原其他提交所做更改的命令。"

#. type: Plain text
#: en/git.txt:268
#, placeholders:'linkgit:git-restore[1]', priority:100
msgid "linkgit:git-restore[1] is about restoring files in the working tree from either the index or another commit. This command does not update your branch. The command can also be used to restore files in the index from another commit."
msgstr "linkgit:git-restore[1] 是有关从索引或其他提交中恢复工作区中文件的命令。这个命令不会更新你的分支。该命令也可以用来从另一个提交中恢复索引中的文件。"

#. type: Plain text
#: en/git.txt:272
#, placeholders:'linkgit:git-reset[1]', priority:100
msgid "linkgit:git-reset[1] is about updating your branch, moving the tip in order to add or remove commits from the branch. This operation changes the commit history."
msgstr "linkgit:git-reset[1] 是有关更新分支、移动提示的命令，以便从分支中添加或删除提交。这个操作会修改提交历史。"

#. type: Plain text
#: en/git.txt:275
#, priority:100
msgid "`git reset` can also be used to restore the index, overlapping with `git restore`."
msgstr "`git reset` 也可以用来恢复索引，这个功能 `git restore` 的功能有些重合。"

#. type: Title -
#: en/git.txt:278
#, no-wrap, priority:100
msgid "Low-level commands (plumbing)"
msgstr "底层核心命令（管件）"

#. type: Plain text
#: en/git.txt:285
#, placeholders:'linkgit:git-update-index[1]':'linkgit:git-read-tree[1]', priority:100
msgid "Although Git includes its own porcelain layer, its low-level commands are sufficient to support development of alternative porcelains. Developers of such porcelains might start by reading about linkgit:git-update-index[1] and linkgit:git-read-tree[1]."
msgstr "尽管 Git 包含了它自己的上层封装命令，但它的底层核心命令足以支持替代上层封装命令的开发。 上层封装命令开发者可以从阅读 linkgit:git-update-index[1] 和 linkgit:git-read-tree[1] 开始。"

#. type: Plain text
#: en/git.txt:292
#, priority:100
msgid "The interface (input, output, set of options and the semantics) to these low-level commands are meant to be a lot more stable than Porcelain level commands, because these commands are primarily for scripted use. The interface to Porcelain commands on the other hand are subject to change in order to improve the end user experience."
msgstr "这些底层命令的界面（输入、输出、选项集和语义）要比上层封装命令稳定得多，因为这些命令主要是用于脚本的使用。 另一方面，为了改善终端用户的体验，上层封装命令接口是可以改变的。"

#. type: Plain text
#: en/git.txt:298
#, priority:100
msgid "The following description divides the low-level commands into commands that manipulate objects (in the repository, index, and working tree), commands that interrogate and compare objects, and commands that move objects and references between repositories."
msgstr "下面的描述将底层核心命令分为操作对象（在仓库、索引和工作目录树中）的命令、审阅和比较对象的命令，以及在仓库之间移动对象和引用的命令。"

#. type: Title ~
#: en/git.txt:301
#, no-wrap, priority:100
msgid "Manipulation commands"
msgstr "控制命令"

#. type: Title ~
#: en/git.txt:307
#, no-wrap, priority:100
msgid "Interrogation commands"
msgstr "审阅命令"

#. type: Plain text
#: en/git.txt:313
#, priority:100
msgid "In general, the interrogate commands do not touch the files in the working tree."
msgstr "一般来说，审阅命令不接触工作区中的文件。"

#. type: Title ~
#: en/git.txt:316
#, no-wrap, priority:100
msgid "Syncing repositories"
msgstr "同步仓库"

#. type: Plain text
#: en/git.txt:322
#, priority:100
msgid "The following are helper commands used by the above; end users typically do not use them directly."
msgstr "以下是上面使用的辅助命令，终端用户一般不会直接使用这些命令。"

#. type: Title ~
#: en/git.txt:327
#, no-wrap, priority:100
msgid "Internal helper commands"
msgstr "内部辅助命令"

#. type: Plain text
#: en/git.txt:331
#, priority:100
msgid "These are internal helper commands used by other commands; end users typically do not use them directly."
msgstr "这些是其他命令使用的内部辅助命令；终端用户一般不会直接使用这些命令。"

#. type: Title -
#: en/git.txt:335
#, no-wrap, priority:100
msgid "Guides"
msgstr "指南"

#. type: Plain text
#: en/git.txt:338
#, priority:100
msgid "The following documentation pages are guides about Git concepts."
msgstr "以下文档页是关于 Git 概念的指南。"

#. type: Title -
#: en/git.txt:342
#, no-wrap, priority:100
msgid "Repository, command and file interfaces"
msgstr "仓库、命令和文件接口"

#. type: Plain text
#: en/git.txt:347
#, placeholders:'`--user-formats`':'linkgit:git-help[1]', priority:100
msgid "This documentation discusses repository and command interfaces which users are expected to interact with directly. See `--user-formats` in linkgit:git-help[1] for more details on the criteria."
msgstr "本文档讨论了用户希望直接与之交互的仓库和命令接口。有关标准的更多细节，请参阅 linkgit:git-help[1] 中的 `--user-formats`。"

#. type: Title -
#: en/git.txt:351
#, no-wrap, priority:100
msgid "File formats, protocols and other developer interfaces"
msgstr "文件格式、协议和其他开发者接口"

#. type: Plain text
#: en/git.txt:356
#, placeholders:'`--developer-interfaces`':'linkgit:git-help[1]', priority:100
msgid "This documentation discusses file formats, over-the-wire protocols and other git developer interfaces. See `--developer-interfaces` in linkgit:git-help[1]."
msgstr "本文档讨论了文件格式、线上协议和其他 git 开发者接口。参阅 linkgit:git-help[1] 中的 `--developer-interfaces` 。"

#. type: Title -
#: en/git.txt:360
#, no-wrap, priority:100
msgid "Configuration Mechanism"
msgstr "配置机制"

#. type: Plain text
#: en/git.txt:365
#, priority:100
msgid "Git uses a simple text format to store customizations that are per repository and are per user. Such a configuration file may look like this:"
msgstr "Git 使用一种简单的文本格式来存储每个仓库和每个用户的定制内容。 这样的配置文件可能是像这样："

#. type: delimited block -
#: en/git.txt:370
#, no-wrap, priority:100
msgid ""
"#\n"
"# A '#' or ';' character indicates a comment.\n"
"#\n"
msgstr ""
"#\n"
"# 符号 '#' 或是 ';' 表示本行是注释信息\n"
"#\n"

#. type: delimited block -
#: en/git.txt:380
#, no-wrap, placeholders:'pobox.com', priority:100
msgid ""
"; user identity\n"
"[user]\n"
"\tname = \"Junio C Hamano\"\n"
"\temail = \"gitster@pobox.com\"\n"
msgstr ""
"; 用户身份信息\n"
"[user]\n"
"\tname = \"Junio C Hamano\"\n"
"\temail = \"gitster@pobox.com\"\n"

#. type: Plain text
#: en/git.txt:386
#, placeholders:'linkgit:git-config[1]', priority:100
msgid "Various commands read from the configuration file and adjust their operation accordingly. See linkgit:git-config[1] for a list and more details about the configuration mechanism."
msgstr "各种命令从配置文件中读取并相应地调整其操作。有关配置机制的列表和更多细节，请参阅 linkgit:git-config[1]。"

#. type: Title -
#: en/git.txt:389
#, no-wrap, priority:100
msgid "Identifier Terminology"
msgstr "标识符术语"

#. type: Plain text
#: en/git.txt:392
#, priority:100
msgid "Indicates the object name for any type of object."
msgstr "表示任何类型的对象的名称。"

#. type: Labeled list
#: en/git.txt:393 en/git-unpack-file.txt:23
#, no-wrap, priority:100
msgid "<blob>"
msgstr "<blob>"

#. type: Plain text
#: en/git.txt:395
#, priority:100
msgid "Indicates a blob object name."
msgstr "表示一个数据对象的名称。"

#. type: Plain text
#: en/git.txt:398
#, priority:100
msgid "Indicates a tree object name."
msgstr "表示一个树对象名称。"

#. type: Plain text
#: en/git.txt:401
#, priority:100
msgid "Indicates a commit object name."
msgstr "表示一个提交对象名称。"

#. type: Plain text
#: en/git.txt:407
#, priority:100
msgid "Indicates a tree, commit or tag object name. A command that takes a <tree-ish> argument ultimately wants to operate on a <tree> object but automatically dereferences <commit> and <tag> objects that point at a <tree>."
msgstr "表示一个树、提交或标签对象的名称。 一个需要 <树对象> 参数的命令最终会对 <树> 对象进行操作，但会自动解除对指向 <树> 对象的 <提交> 和 <标签> 对象的引用。"

#. type: Labeled list
#: en/git.txt:408
#, no-wrap, priority:100
msgid "<commit-ish>"
msgstr "<提交号>"

#. type: Plain text
#: en/git.txt:413
#, priority:100
msgid "Indicates a commit or tag object name. A command that takes a <commit-ish> argument ultimately wants to operate on a <commit> object but automatically dereferences <tag> objects that point at a <commit>."
msgstr "表示一个提交或标记对象的名称。 一个需要 <提交号> 参数的命令最终要对 <提交> 对象进行操作，但会自动解除对指向 <提交> 的 <标签> 对象的引用。"

#. type: Plain text
#: en/git.txt:417
#, priority:100
msgid "Indicates that an object type is required. Currently one of: `blob`, `tree`, `commit`, or `tag`."
msgstr "表示需要一个对象类型。 目前是其中之一：`blob`、`tree`、`commit` 或 `tag`。"

#. type: Plain text
#: en/git.txt:421
#, placeholders:'GIT_INDEX_FILE', priority:100
msgid "Indicates a filename - almost always relative to the root of the tree structure `GIT_INDEX_FILE` describes."
msgstr "表示一个文件名——几乎总是相对于 `GIT_INDEX_FILE` 描述的树状结构的根部文件。"

#. type: Title -
#: en/git.txt:423
#, no-wrap, priority:100
msgid "Symbolic Identifiers"
msgstr "符号标识符"

#. type: Plain text
#: en/git.txt:426
#, priority:100
msgid "Any Git command accepting any <object> can also use the following symbolic notation:"
msgstr "任何接受任意 <对象> 的 Git 命令也可以使用下面的符号表示法："

#. type: Plain text
#: en/git.txt:429
#, priority:100
msgid "indicates the head of the current branch."
msgstr "表示当前分支。"

#. type: Labeled list
#: en/git.txt:430
#, no-wrap, priority:100
msgid "<tag>"
msgstr "<标签>"

#. type: Plain text
#: en/git.txt:433
#, priority:100
msgid "a valid tag 'name' (i.e. a `refs/tags/<tag>` reference)."
msgstr "一个有效的标签 ‘名称’（即一个 `refs/tags/<标签>` 引用）。"

#. type: Plain text
#: en/git.txt:437
#, priority:100
msgid "a valid head 'name' (i.e. a `refs/heads/<head>` reference)."
msgstr "一个有效的分支 ‘名称’（即一个 `refs/heads/<head>` 引用）。"

#. type: Plain text
#: en/git.txt:440
#, placeholders:'linkgit:gitrevisions[7]', priority:100
msgid "For a more complete list of ways to spell object names, see \"SPECIFYING REVISIONS\" section in linkgit:gitrevisions[7]."
msgstr "更完整的对象名称列表，请参阅 linkgit:gitrevisions[7] 中的 “校正说明” 部分。"

#. type: Title -
#: en/git.txt:443
#, no-wrap, priority:100
msgid "File/Directory Structure"
msgstr "文件/目录结构"

#. type: Plain text
#: en/git.txt:446
#, placeholders:'linkgit:gitrepository-layout[5]', priority:100
msgid "Please see the linkgit:gitrepository-layout[5] document."
msgstr "请参阅 linkgit:gitrepository-layout[5] 文档。"

#. type: Plain text
#: en/git.txt:448
#, placeholders:'linkgit:githooks[5]', priority:100
msgid "Read linkgit:githooks[5] for more details about each hook."
msgstr "阅读 linkgit:githooks[5] 了解关于每个钩子的更多细节。"

#. type: Plain text
#: en/git.txt:451
#, placeholders:'$GIT_DIR', priority:100
msgid "Higher level SCMs may provide and manage additional information in the `$GIT_DIR`."
msgstr "更高级别的源代码管理工具(SCM)可以在 `$GIT_DIR ` 中提供和管理额外的信息。"

#. type: Title -
#: en/git.txt:454
#, no-wrap, priority:100
msgid "Terminology"
msgstr "术语"

#. type: Plain text
#: en/git.txt:456
#, placeholders:'linkgit:gitglossary[7]', priority:100
msgid "Please see linkgit:gitglossary[7]."
msgstr "请参阅 linkgit:gitglossary[7]。"

#. type: Plain text
#: en/git.txt:464
#, priority:100
msgid "Various Git commands pay attention to environment variables and change their behavior. The environment variables marked as \"Boolean\" take their values the same way as Boolean valued configuration variables, e.g. \"true\", \"yes\", \"on\" and positive numbers are taken as \"yes\"."
msgstr "各种 Git 命令都会关注环境变量并改变自身的行为。 以 “布尔值” 为标记的环境变量，其取值方式与布尔值配置变量相同，例如，\"true\"、\"yes\"、\"on\" 和正数都被视为 \"yes\"。"

#. type: Plain text
#: en/git.txt:466
#, priority:100
msgid "Here are the variables:"
msgstr "常规变量："

#. type: Title ~
#: en/git.txt:468
#, no-wrap, priority:100
msgid "The Git Repository"
msgstr "Git 仓库"

#. type: Plain text
#: en/git.txt:472
#, priority:100
msgid "These environment variables apply to 'all' core Git commands. Nb: it is worth noting that they may be used/overridden by SCMS sitting above Git so take care if using a foreign front-end."
msgstr "这些环境变量适用于 Git 的 ‘所有’ 核心命令。需要注意的是，如果使用位于 Git 之上的版本控制系统（SCMS），这些环境变量可能会被使用或覆盖，所以在使用非 Git 原生的前端界面时要特别小心。"

#. type: Labeled list
#: en/git.txt:473
#, ignore-same, no-wrap, priority:100
msgid "`GIT_INDEX_FILE`"
msgstr "`GIT_INDEX_FILE`"

#. type: Plain text
#: en/git.txt:477
#, placeholders:'$GIT_DIR', priority:100
msgid "This environment variable specifies an alternate index file. If not specified, the default of `$GIT_DIR/index` is used."
msgstr "这个环境变量指定了一个备用的索引文件。如果没有指定，则默认使用 `$GIT_DIR/index`。"

#. type: Labeled list
#: en/git.txt:478
#, ignore-same, no-wrap, priority:100
msgid "`GIT_INDEX_VERSION`"
msgstr "`GIT_INDEX_VERSION`"

#. type: Plain text
#: en/git.txt:483
#, placeholders:'linkgit:git-update-index[1]', priority:100
msgid "This environment variable specifies what index version is used when writing the index file out. It won't affect existing index files. By default index file version 2 or 3 is used. See linkgit:git-update-index[1] for more information."
msgstr "这个环境变量指定在写出索引文件时使用什么版本。 它不会影响现有的索引文件。 默认情况下，索引文件的版本为 2 或 3。参见 linkgit:git-update-index[1] 获取更多信息。"

#. type: Labeled list
#: en/git.txt:484
#, ignore-same, no-wrap, priority:100
msgid "`GIT_OBJECT_DIRECTORY`"
msgstr "`GIT_OBJECT_DIRECTORY`"

#. type: Plain text
#: en/git.txt:489
#, placeholders:'$GIT_DIR', priority:100
msgid "If the object storage directory is specified via this environment variable then the sha1 directories are created underneath - otherwise the default `$GIT_DIR/objects` directory is used."
msgstr "如果对象存储目录是通过这个环境变量指定的，那么 sha1 目录将在该目录下创建 ， 否则将使用默认的 `$GIT_DIR/objects` 目录。"

#. type: Labeled list
#: en/git.txt:490
#, ignore-same, no-wrap, priority:100
msgid "`GIT_ALTERNATE_OBJECT_DIRECTORIES`"
msgstr "`GIT_ALTERNATE_OBJECT_DIRECTORIES`"

#. type: Plain text
#: en/git.txt:496
#, priority:100
msgid "Due to the immutable nature of Git objects, old objects can be archived into shared, read-only directories. This variable specifies a \":\" separated (on Windows \";\" separated) list of Git object directories which can be used to search for Git objects. New objects will not be written to these directories."
msgstr "由于 Git 对象的不可改变性，旧的对象可以被归档到共享的只读目录中。这个变量指定了一个由 \":\" 分隔（在 Windows 下为 \";\" 分隔）的 Git 对象目录列表，可以用来搜索 Git 对象。新的对象将不会写入这些目录中。"

#. type: Plain text
#: en/git.txt:502
#, priority:100
msgid "Entries that begin with `\"` (double-quote) will be interpreted as C-style quoted paths, removing leading and trailing double-quotes and respecting backslash escapes. E.g., the value `\"path-with-\\\"-and-:-in-it\":vanilla-path` has two paths: `path-with-\"-and-:-in-it` and `vanilla-path`."
msgstr "以 `\"`（双引号）开头的条目将被解释为 C 语言风格字符串路径，去掉前导和后导的双引号，并支持反斜杠转义。例如，`\"path-with-\\\"-and-:-in-it\":vanilla-path` 有两个路径：`path-with-\"-and-:-in-it` 和 `vanilla-path`。"

#. type: Labeled list
#: en/git.txt:503
#, ignore-same, no-wrap, priority:100
msgid "`GIT_DIR`"
msgstr "`GIT_DIR`"

#. type: Plain text
#: en/git.txt:508
#, placeholders:'GIT_DIR', priority:100
msgid "If the `GIT_DIR` environment variable is set then it specifies a path to use instead of the default `.git` for the base of the repository. The `--git-dir` command-line option also sets this value."
msgstr "如果设置了 `GIT_DIR` 环境变量，那么它会指定一个路径来代替默认的 `.git` 作为仓库的基础目录。 `--git-dir` 命令行选项也能够设置这个值。"

#. type: Labeled list
#: en/git.txt:509
#, ignore-same, no-wrap, priority:100
msgid "`GIT_WORK_TREE`"
msgstr "`GIT_WORK_TREE`"

#. type: Plain text
#: en/git.txt:513
#, placeholders:'`--work-tree`':'core.worktree', priority:100
msgid "Set the path to the root of the working tree. This can also be controlled by the `--work-tree` command-line option and the core.worktree configuration variable."
msgstr "设置到工作区的根路径。 这也可以由 `--work-tree` 命令行选项和 core.worktree 配置变量设置。"

#. type: Labeled list
#: en/git.txt:514
#, ignore-same, no-wrap, priority:100
msgid "`GIT_NAMESPACE`"
msgstr "`GIT_NAMESPACE`"

#. type: Plain text
#: en/git.txt:517
#, placeholders:'linkgit:gitnamespaces[7]':'`--namespace`', priority:100
msgid "Set the Git namespace; see linkgit:gitnamespaces[7] for details. The `--namespace` command-line option also sets this value."
msgstr "设置 Git 命名空间；详见 linkgit:gitnamespaces[7]。 `--namespace` 命令行选项也可以设置这个值。"

#. type: Labeled list
#: en/git.txt:518
#, ignore-same, no-wrap, priority:100
msgid "`GIT_CEILING_DIRECTORIES`"
msgstr "`GIT_CEILING_DIRECTORIES`"

#. type: Plain text
#: en/git.txt:532
#, placeholders:'GIT_DIR':'GIT_CEILING_DIRECTORIES', priority:100
msgid "This should be a colon-separated list of absolute paths. If set, it is a list of directories that Git should not chdir up into while looking for a repository directory (useful for excluding slow-loading network directories). It will not exclude the current working directory or a GIT_DIR set on the command line or in the environment. Normally, Git has to read the entries in this list and resolve any symlink that might be present in order to compare them with the current directory. However, if even this access is slow, you can add an empty entry to the list to tell Git that the subsequent entries are not symlinks and needn't be resolved; e.g., `GIT_CEILING_DIRECTORIES=/maybe/symlink::/very/slow/non/symlink`."
msgstr "这个变量值应该是一个用冒号分隔的绝对路径列表。 如果设置了这个变量，它是一个 Git 在寻找仓库目录时不会检查的目录列表（对于排除缓慢加载的网络目录很有用）。 它不会排除当前工作目录或在命令行或环境中设置的 GIT_DIR。 通常情况下，Git 需要读取这个列表中的条目，并解析任何可能存在的符号链接，以便将它们与当前目录进行比较。 然而，如果连这个访问都很慢，你可以在列表中添加一个空条目，告诉 Git 后面的条目不是符号链接，不需要解析；例如，`GIT_CEILING_DIRECTORIES=/maybe/symlink::/very/slow/non/symlink`。"

#. type: Labeled list
#: en/git.txt:533
#, ignore-same, no-wrap, priority:100
msgid "`GIT_DISCOVERY_ACROSS_FILESYSTEM`"
msgstr "`GIT_DISCOVERY_ACROSS_FILESYSTEM`"

#. type: Plain text
#: en/git.txt:542
#, placeholders:'GIT_CEILING_DIRECTORIES':'GIT_DIR', priority:100
msgid "When run in a directory that does not have \".git\" repository directory, Git tries to find such a directory in the parent directories to find the top of the working tree, but by default it does not cross filesystem boundaries. This Boolean environment variable can be set to true to tell Git not to stop at filesystem boundaries. Like `GIT_CEILING_DIRECTORIES`, this will not affect an explicit repository directory set via `GIT_DIR` or on the command line."
msgstr "当在一个没有 \".git \" 仓库目录的目录下运行时，Git 会尝试在父目录中找到这样的目录来寻找工作区的顶端，但默认情况下它不会跨越文件系统的边界。 这个布尔环境变量可以被设置为 \"true\"，以告诉 Git 不要在文件系统边界处停止。 和 `GIT_CEILING_DIRECTORIES` 一样，这不会影响通过 `GIT_DIR` 或在命令行中设置的明确的仓库目录。"

#. type: Labeled list
#: en/git.txt:543
#, ignore-same, no-wrap, priority:100
msgid "`GIT_COMMON_DIR`"
msgstr "`GIT_COMMON_DIR`"

#. type: Plain text
#: en/git.txt:551
#, ignore-ellipsis, placeholders:'$GIT_DIR':'HEAD':'$GIT_DIR':'linkgit:gitrepository-layout[5]':'linkgit:git-worktree[1]':'GIT_INDEX_FILE':'GIT_OBJECT_DIRECTORY', priority:100
msgid "If this variable is set to a path, non-worktree files that are normally in $GIT_DIR will be taken from this path instead. Worktree-specific files such as HEAD or index are taken from $GIT_DIR. See linkgit:gitrepository-layout[5] and linkgit:git-worktree[1] for details. This variable has lower precedence than other path variables such as GIT_INDEX_FILE, GIT_OBJECT_DIRECTORY..."
msgstr "如果这个变量被设置为一个路径，通常在 $GIT_DIR 中的非工作区文件将被从这个路径中取出。工作区中特定的文件，如 HEAD 或 index，则从 $GIT_DIR 取出。详情见 linkgit:gitrepository-layout[5] 和 linkgit:git-worktree[1]。这个变量的优先级低于其他路径变量，如 GIT_INDEX_FILE、GIT_OBJECT_DIRECTORY..."

#. type: Labeled list
#: en/git.txt:552
#, ignore-same, no-wrap, priority:100
msgid "`GIT_DEFAULT_HASH`"
msgstr "`GIT_DEFAULT_HASH`"

#. type: Plain text
#: en/git.txt:558
#, placeholders:'`--object-format`':'linkgit:git-init[1]', priority:100
msgid "If this variable is set, the default hash algorithm for new repositories will be set to this value. This value is ignored when cloning and the setting of the remote repository is always used. The default is \"sha1\". See `--object-format` in linkgit:git-init[1]."
msgstr "如果设置了该变量，新仓库的默认哈希算法将设置为该值。克隆时将忽略此值，始终使用远程仓库的设置。默认值为 \"sha1\"。 参见 linkgit:git-init[1] 中的 `--object-format`。"

#. type: Labeled list
#: en/git.txt:559
#, ignore-same, no-wrap, priority:100
msgid "`GIT_DEFAULT_REF_FORMAT`"
msgstr "`GIT_DEFAULT_REF_FORMAT`"

#. type: Plain text
#: en/git.txt:563
#, placeholders:'`--ref-format`':'linkgit:git-init[1]', priority:100
msgid "If this variable is set, the default reference backend format for new repositories will be set to this value. The default is \"files\". See `--ref-format` in linkgit:git-init[1]."
msgstr "如果设置了该变量，新仓库的默认引用后端格式将设置为该值。默认为 \"files\"。参见 linkgit:git-init[1] 中的 `--ref-format`。"

#. type: Title ~
#: en/git.txt:565
#, no-wrap, priority:100
msgid "Git Commits"
msgstr "Git 提交"

#. type: Labeled list
#: en/git.txt:566
#, ignore-same, no-wrap, priority:100
msgid "`GIT_AUTHOR_NAME`"
msgstr "`GIT_AUTHOR_NAME`"

#. type: Plain text
#: en/git.txt:570
#, placeholders:'user.name':'author.name', priority:100
msgid "The human-readable name used in the author identity when creating commit or tag objects, or when writing reflogs. Overrides the `user.name` and `author.name` configuration settings."
msgstr "在创建提交、标签对象或在编写日志时，作者身份中使用的可读名称。这会覆盖 `user.name` 和 `author.name` 配置的值。"

#. type: Labeled list
#: en/git.txt:571
#, ignore-same, no-wrap, priority:100
msgid "`GIT_AUTHOR_EMAIL`"
msgstr "`GIT_AUTHOR_EMAIL`"

#. type: Plain text
#: en/git.txt:575
#, placeholders:'user.email':'author.email', priority:100
msgid "The email address used in the author identity when creating commit or tag objects, or when writing reflogs. Overrides the `user.email` and `author.email` configuration settings."
msgstr "在创建提交、标签对象或在编写引用日志时，用以表明作者身份所使用的电子邮件地址。这会覆盖 `user.email` 和 `author.email` 的配置值。"

#. type: Labeled list
#: en/git.txt:576
#, ignore-same, no-wrap, priority:100
msgid "`GIT_AUTHOR_DATE`"
msgstr "`GIT_AUTHOR_DATE`"

#. type: Plain text
#: en/git.txt:579
#, placeholders:'linkgit:git-commit[1]', priority:100
msgid "The date used for the author identity when creating commit or tag objects, or when writing reflogs. See linkgit:git-commit[1] for valid formats."
msgstr "在创建提交、标签对象或在编写引用日志时，用于标注作者修改的日期。有效格式见 linkgit:git-commit[1]。"

#. type: Labeled list
#: en/git.txt:580
#, ignore-same, no-wrap, priority:100
msgid "`GIT_COMMITTER_NAME`"
msgstr "`GIT_COMMITTER_NAME`"

#. type: Plain text
#: en/git.txt:584
#, placeholders:'user.name':'committer.name', priority:100
msgid "The human-readable name used in the committer identity when creating commit or tag objects, or when writing reflogs. Overrides the `user.name` and `committer.name` configuration settings."
msgstr "在创建提交、标签对象或在编写引用日志时，提交者身份中使用的可读名称。这会覆盖 `user.name` 和 `committer.name` 的配置值。"

#. type: Labeled list
#: en/git.txt:585
#, ignore-same, no-wrap, priority:100
msgid "`GIT_COMMITTER_EMAIL`"
msgstr "`GIT_COMMITTER_EMAIL`"

# ERROR: committer.email not found in translation
# ERROR: committer.email not found in translation
#. type: Plain text
#: en/git.txt:589
#, placeholders:'user.email':'committer.email', priority:100
msgid "The email address used in the author identity when creating commit or tag objects, or when writing reflogs. Overrides the `user.email` and `committer.email` configuration settings."
msgstr "在创建提交、标签对象或在编写引用日志时，用以表明提交者所使用的电子邮件地址。这会覆盖 `user.email` 和 `committer.email` 的配置值。"

#. type: Labeled list
#: en/git.txt:590
#, ignore-same, no-wrap, priority:100
msgid "`GIT_COMMITTER_DATE`"
msgstr "`GIT_COMMITTER_DATE`"

#. type: Plain text
#: en/git.txt:593
#, placeholders:'linkgit:git-commit[1]', priority:100
msgid "The date used for the committer identity when creating commit or tag objects, or when writing reflogs. See linkgit:git-commit[1] for valid formats."
msgstr "在创建提交、标签对象或在编写 reflogs 时，用于标注提交者所作修改的日期。有效格式见 linkgit:git-commit[1]。"

#. type: Labeled list
#: en/git.txt:594
#, ignore-same, no-wrap, priority:100
msgid "`EMAIL`"
msgstr "`EMAIL`"

#. type: Plain text
#: en/git.txt:597
#, priority:100
msgid "The email address used in the author and committer identities if no other relevant environment variable or configuration setting has been set."
msgstr "如果没有设置其他相关的环境变量或配置设置，作者和提交者的电子邮件地址会参考该值。"

#. type: Title ~
#: en/git.txt:599
#, no-wrap, priority:100
msgid "Git Diffs"
msgstr "Git 差异比较（Diffs）"

#. type: Labeled list
#: en/git.txt:600
#, ignore-same, no-wrap, priority:100
msgid "`GIT_DIFF_OPTS`"
msgstr "`GIT_DIFF_OPTS`"

#. type: Plain text
#: en/git.txt:605
#, placeholders:'--unified=':'--unified', priority:100
msgid "Only valid setting is \"--unified=??\" or \"-u??\" to set the number of context lines shown when a unified diff is created. This takes precedence over any \"-U\" or \"--unified\" option value passed on the Git diff command line."
msgstr "唯一有效的设置是 \"--unified=??\" 或 \"-u??\"，用于设置创建统一的差异时显示的文本行数。 这优先于 Git diff 命令行中传递的任何 \"-U\" 或 \"--unified\" 选项值。"

#. type: Labeled list
#: en/git.txt:606
#, ignore-same, no-wrap, priority:100
msgid "`GIT_EXTERNAL_DIFF`"
msgstr "`GIT_EXTERNAL_DIFF`"

#. type: Plain text
#: en/git.txt:612
#, placeholders:'GIT_EXTERNAL_DIFF':'GIT_EXTERNAL_DIFF', priority:100
msgid "When the environment variable `GIT_EXTERNAL_DIFF` is set, the program named by it is called to generate diffs, and Git does not use its builtin diff machinery. For a path that is added, removed, or modified, `GIT_EXTERNAL_DIFF` is called with 7 parameters:"
msgstr "当环境变量 `GIT_EXTERNAL_DIFF` 被设置时，由它命名的程序被调用来生成差异文本，而不使用 Git 内置的差异比较工具。 对于一个被添加、删除或修改的操作， `GIT_EXTERNAL_DIFF` 会被调用，一共接收 7 个参数："

#. type: Plain text
#: en/git.txt:614
#, priority:100
msgid "path old-file old-hex old-mode new-file new-hex new-mode"
msgstr "path old-file old-hex old-mode new-file new-hex new-mode"

#. type: Plain text
#: en/git.txt:616
#, priority:100
msgid "where:"
msgstr "使用："

#. type: Labeled list
#: en/git.txt:617
#, no-wrap, priority:100
msgid "<old|new>-file"
msgstr "<old|new>-file"

#. type: Plain text
#: en/git.txt:619
#, placeholders:'GIT_EXTERNAL_DIFF', priority:100
msgid "are files GIT_EXTERNAL_DIFF can use to read the contents of <old|new>,"
msgstr "是 GIT_EXTERNAL_DIFF 用来读取 <old|new> 内容的文件，"

#. type: Labeled list
#: en/git.txt:619
#, no-wrap, priority:100
msgid "<old|new>-hex"
msgstr "<old|new>-hex"

#. type: Plain text
#: en/git.txt:620
#, priority:100
msgid "are the 40-hexdigit SHA-1 hashes,"
msgstr "是 40 个十六进制的 SHA-1 哈希值，"

#. type: Labeled list
#: en/git.txt:620
#, no-wrap, priority:100
msgid "<old|new>-mode"
msgstr "<old|new>-mode"

#. type: Plain text
#: en/git.txt:621
#, priority:100
msgid "are the octal representation of the file modes."
msgstr "是文件模式的八进制表示法。"

#. type: Plain text
#: en/git.txt:627
#, placeholders:'git-diff-files':'GIT_EXTERNAL_DIFF':'GIT_EXTERNAL_DIFF', priority:100
msgid "The file parameters can point at the user's working file (e.g. `new-file` in \"git-diff-files\"), `/dev/null` (e.g. `old-file` when a new file is added), or a temporary file (e.g. `old-file` in the index). `GIT_EXTERNAL_DIFF` should not worry about unlinking the temporary file -- it is removed when `GIT_EXTERNAL_DIFF` exits."
msgstr "文件参数可以指向用户的工作文件（例如 \"git-diff-files\" 中的 `new-file`），`/dev/null`（例如在添加新文件时的 `old-file`），或一个临时文件（例如索引中的 `old-file`）。 无需担心 `GIT_EXTERNAL_DIFF` 对临时文件的链接是否解除——当 `GIT_EXTERNAL_DIFF` 退出时，工具对临时文件的链接会被删除。"

#. type: Plain text
#: en/git.txt:630
#, placeholders:'GIT_EXTERNAL_DIFF', priority:100
msgid "For a path that is unmerged, `GIT_EXTERNAL_DIFF` is called with 1 parameter, <path>."
msgstr "`GIT_EXTERNAL_DIFF` 被调用时，对于未合并的路径可通过 <path> 进行设置。"

#. type: Plain text
#: en/git.txt:633
#, placeholders:'GIT_EXTERNAL_DIFF':'GIT_DIFF_PATH_COUNTER':'GIT_DIFF_PATH_TOTAL', priority:100
msgid "For each path `GIT_EXTERNAL_DIFF` is called, two environment variables, `GIT_DIFF_PATH_COUNTER` and `GIT_DIFF_PATH_TOTAL` are set."
msgstr "在调用每个路径 `GIT_EXTERNAL_DIFF` 时，都会设置两个环境变量 `GIT_DIFF_PATH_COUNTER` 和 `GIT_DIFF_PATH_TOTAL`。"

#. type: Labeled list
#: en/git.txt:634
#, ignore-same, no-wrap, priority:100
msgid "`GIT_DIFF_PATH_COUNTER`"
msgstr "`GIT_DIFF_PATH_COUNTER`"

#. type: Plain text
#: en/git.txt:636
#, priority:100
msgid "A 1-based counter incremented by one for every path."
msgstr "以 1 为单位的计数器，每条路径递增 1。"

#. type: Labeled list
#: en/git.txt:637
#, ignore-same, no-wrap, priority:100
msgid "`GIT_DIFF_PATH_TOTAL`"
msgstr "`GIT_DIFF_PATH_TOTAL`"

#. type: Plain text
#: en/git.txt:639
#, priority:100
msgid "The total number of paths."
msgstr "路径总数。"

#. type: Title ~
#: en/git.txt:641
#, no-wrap, priority:100
msgid "other"
msgstr "其他"

#. type: Labeled list
#: en/git.txt:642
#, ignore-same, no-wrap, priority:100
msgid "`GIT_MERGE_VERBOSITY`"
msgstr "`GIT_MERGE_VERBOSITY`"

#. type: Plain text
#: en/git.txt:646
#, placeholders:'merge.verbosity':'linkgit:git-merge[1]', priority:100
msgid "A number controlling the amount of output shown by the recursive merge strategy. Overrides merge.verbosity. See linkgit:git-merge[1]"
msgstr "一个用于控制递归合并策略输出量的数字。 会覆盖 merge.verbosity 设置。 参见 linkgit:git-merge[1]"

#. type: Labeled list
#: en/git.txt:647
#, ignore-same, no-wrap, priority:100
msgid "`GIT_PAGER`"
msgstr "`GIT_PAGER`"

#. type: Plain text
#: en/git.txt:652
#, placeholders:'$PAGER':'core.pager':'linkgit:git-config[1]', priority:100
msgid "This environment variable overrides `$PAGER`. If it is set to an empty string or to the value \"cat\", Git will not launch a pager. See also the `core.pager` option in linkgit:git-config[1]."
msgstr "该环境变量优先于 `$PAGER`。如果设置为空字符串或 \"cat\"，Git 将不会启动分页器。 参见 linkgit:git-config[1] 中的 `core.pager` 选项。"

#. type: Labeled list
#: en/git.txt:653
#, ignore-same, no-wrap, priority:100
msgid "`GIT_PROGRESS_DELAY`"
msgstr "`GIT_PROGRESS_DELAY`"

#. type: Plain text
#: en/git.txt:656
#, priority:100
msgid "A number controlling how many seconds to delay before showing optional progress indicators. Defaults to 2."
msgstr "一个数字，用于控制延迟多少秒后才显示可选的进度指示器。默认为 2。"

#. type: Labeled list
#: en/git.txt:657
#, ignore-same, no-wrap, priority:100
msgid "`GIT_EDITOR`"
msgstr "`GIT_EDITOR`"

#. type: Plain text
#: en/git.txt:662
#, placeholders:'$EDITOR':'$VISUAL':'linkgit:git-var[1]':'core.editor':'linkgit:git-config[1]', priority:100
msgid "This environment variable overrides `$EDITOR` and `$VISUAL`. It is used by several Git commands when, on interactive mode, an editor is to be launched. See also linkgit:git-var[1] and the `core.editor` option in linkgit:git-config[1]."
msgstr "该环境变量覆盖 `$EDITOR` 和 `$VISUAL`。 有几条 Git 命令在交互模式下启动编辑器时会用到它。参见 linkgit:git-var[1] 和 linkgit:git-config[1] 中的 `core.editor` 选项。"

#. type: Labeled list
#: en/git.txt:663
#, ignore-same, no-wrap, priority:100
msgid "`GIT_SEQUENCE_EDITOR`"
msgstr "`GIT_SEQUENCE_EDITOR`"

#. type: Plain text
#: en/git.txt:668
#, placeholders:'linkgit:git-rebase[1]':'sequence.editor':'linkgit:git-config[1]', priority:100
msgid "This environment variable overrides the configured Git editor when editing the todo list of an interactive rebase. See also linkgit:git-rebase[1] and the `sequence.editor` option in linkgit:git-config[1]."
msgstr "在编辑交互式变基的待办事项列表时，该环境变量会覆盖配置的 Git 编辑器。参见 linkgit:git-rebase[1] 和 linkgit:git-config[1] 中的 `sequence.editor` 选项。"

#. type: Labeled list
#: en/git.txt:669
#, ignore-same, no-wrap, priority:100
msgid "`GIT_SSH`"
msgstr "`GIT_SSH`"

#. type: Labeled list
#: en/git.txt:670
#, ignore-same, no-wrap, priority:100
msgid "`GIT_SSH_COMMAND`"
msgstr "`GIT_SSH_COMMAND`"

#. type: Plain text
#: en/git.txt:677
#, placeholders:'ssh.variant':'linkgit:git-config[1]', priority:100
msgid "If either of these environment variables is set then 'git fetch' and 'git push' will use the specified command instead of 'ssh' when they need to connect to a remote system. The command-line parameters passed to the configured command are determined by the ssh variant. See `ssh.variant` option in linkgit:git-config[1] for details."
msgstr "如果设置了这两个环境变量中的任何一个，'git fetch' 和 'git push' 在连接远程系统时就会使用指定的命令而不是 'ssh'。 传递给配置命令的命令行参数由 ssh 变量决定。 详见 linkgit:git-config[1] 中的 `ssh.variant` 选项。"

#. type: Plain text
#: en/git.txt:683
#, placeholders:'$GIT_SSH_COMMAND':'$GIT_SSH':'$GIT_SSH', priority:100
msgid "`$GIT_SSH_COMMAND` takes precedence over `$GIT_SSH`, and is interpreted by the shell, which allows additional arguments to be included. `$GIT_SSH` on the other hand must be just the path to a program (which can be a wrapper shell script, if additional arguments are needed)."
msgstr "`$GIT_SSH_COMMAND` 优先于 `$GIT_SSH`，由 shell 解释，允许包含额外参数。 另一方面，`$GIT_SSH` 必须是一个程序的路径（如果程序需要额外参数，可以是一个 shell 脚本）。"

#. type: Plain text
#: en/git.txt:687
#, priority:100
msgid "Usually it is easier to configure any desired options through your personal `.ssh/config` file. Please consult your ssh documentation for further details."
msgstr "通常，通过个人的 `.ssh/config` 文件配置任何所需的选项会更容易。 详情请查阅 ssh 文档。"

#. type: Labeled list
#: en/git.txt:688
#, ignore-same, no-wrap, priority:100
msgid "`GIT_SSH_VARIANT`"
msgstr "`GIT_SSH_VARIANT`"

#. type: Plain text
#: en/git.txt:693
#, placeholders:'GIT_SSH':'GIT_SSH_COMMAND':'core.sshCommand':'ssh.variant', priority:100
msgid "If this environment variable is set, it overrides Git's autodetection whether `GIT_SSH`/`GIT_SSH_COMMAND`/`core.sshCommand` refer to OpenSSH, plink or tortoiseplink. This variable overrides the config setting `ssh.variant` that serves the same purpose."
msgstr "如果设置了这个环境变量，Git 会自动检测 `GIT_SSH`/`GIT_SSH_COMMAND`/`core.sshCommand` 是否指向 OpenSSH、plink 或 tortoiseplink。该变量覆盖了具有相同作用的配置设置 `ssh.variant`。"

#. type: Labeled list
#: en/git.txt:694
#, ignore-same, no-wrap, priority:100
msgid "`GIT_SSL_NO_VERIFY`"
msgstr "`GIT_SSL_NO_VERIFY`"

#. type: Plain text
#: en/git.txt:698
#, priority:100
msgid "Setting and exporting this environment variable to any value tells Git not to verify the SSL certificate when fetching or pushing over HTTPS."
msgstr "将此环境变量设置并导出为任意值，Git 就不会在通过 HTTPS 获取或推送数据时验证 SSL 证书。"

#. type: Labeled list
#: en/git.txt:699
#, ignore-same, no-wrap, priority:100
msgid "`GIT_ATTR_SOURCE`"
msgstr "`GIT_ATTR_SOURCE`"

#. type: Plain text
#: en/git.txt:701
#, priority:100
msgid "Sets the treeish that gitattributes will be read from."
msgstr "设置读取 gitattributes 的树状对象。"

#. type: Labeled list
#: en/git.txt:702
#, ignore-same, no-wrap, priority:100
msgid "`GIT_ASKPASS`"
msgstr "`GIT_ASKPASS`"

#. type: Plain text
#: en/git.txt:708
#, placeholders:'core.askPass':'linkgit:git-config[1]', priority:100
msgid "If this environment variable is set, then Git commands which need to acquire passwords or passphrases (e.g. for HTTP or IMAP authentication) will call this program with a suitable prompt as command-line argument and read the password from its STDOUT. See also the `core.askPass` option in linkgit:git-config[1]."
msgstr "如果设置了这个环境变量，那么需要获取密码或口令的 Git 命令（例如用于 HTTP 或 IMAP 身份验证）就会调用这个程序，并将合适的提示符作为命令行参数，然后从其 STDOUT 中读取密码。参见 linkgit:git-config[1] 中的 `core.askPass` 选项。"

#. type: Labeled list
#: en/git.txt:709
#, ignore-same, no-wrap, priority:100
msgid "`GIT_TERMINAL_PROMPT`"
msgstr "`GIT_TERMINAL_PROMPT`"

#. type: Plain text
#: en/git.txt:712
#, priority:100
msgid "If this Boolean environment variable is set to false, git will not prompt on the terminal (e.g., when asking for HTTP authentication)."
msgstr "如果将此布尔环境变量设为 false，git 将不会在终端上提示（例如，要求 HTTP 认证时）。"

#. type: Labeled list
#: en/git.txt:713
#, ignore-same, no-wrap, priority:100
msgid "`GIT_CONFIG_GLOBAL`"
msgstr "`GIT_CONFIG_GLOBAL`"

#. type: Labeled list
#: en/git.txt:714
#, ignore-same, no-wrap, priority:100
msgid "`GIT_CONFIG_SYSTEM`"
msgstr "`GIT_CONFIG_SYSTEM`"

#. type: Plain text
#: en/git.txt:722
#, placeholders:'GIT_CONFIG_SYSTEM':'GIT_CONFIG_GLOBAL':'$HOME':'$XDG_CONFIG_HOME', priority:100
msgid "Take the configuration from the given files instead from global or system-level configuration files. If `GIT_CONFIG_SYSTEM` is set, the system config file defined at build time (usually `/etc/gitconfig`) will not be read. Likewise, if `GIT_CONFIG_GLOBAL` is set, neither `$HOME/.gitconfig` nor `$XDG_CONFIG_HOME/git/config` will be read. Can be set to `/dev/null` to skip reading configuration files of the respective level."
msgstr "从给定文件中获取配置，而不是从全局或系统级配置文件中获取。如果设置了 `GIT_CONFIG_SYSTEM`，则不会读取构建时定义的系统配置文件（通常是 `/etc/gitconfig`）。同样，如果设置了 `GIT_CONFIG_GLOBAL`，则既不会读取 `$HOME/.gitconfig` 也不会读取 `$XDG_CONFIG_HOME/git/config`。可以设置为 `/dev/null`，以跳过读取相应级别的配置文件。"

#. type: Labeled list
#: en/git.txt:723
#, ignore-same, no-wrap, priority:100
msgid "`GIT_CONFIG_NOSYSTEM`"
msgstr "`GIT_CONFIG_NOSYSTEM`"

#. type: Plain text
#: en/git.txt:730
#, placeholders:'$(prefix)':'$HOME':'$XDG_CONFIG_HOME', priority:100
msgid "Whether to skip reading settings from the system-wide `$(prefix)/etc/gitconfig` file. This Boolean environment variable can be used along with `$HOME` and `$XDG_CONFIG_HOME` to create a predictable environment for a picky script, or you can set it to true to temporarily avoid using a buggy `/etc/gitconfig` file while waiting for someone with sufficient permissions to fix it."
msgstr "是否跳过从系统范围内的 `$(prefix)/etc/gitconfig` 文件读取设置。 这个布尔环境变量可以与 `$HOME` 和 `$XDG_CONFIG_HOME` 一起使用，为挑剔的脚本创建一个可预测的环境，也可以设为 true 以暂时避免使用有错误的 `/etc/gitconfig` 文件，等待有足够权限的人来修复它。"

#. type: Labeled list
#: en/git.txt:731
#, ignore-same, no-wrap, priority:100
msgid "`GIT_FLUSH`"
msgstr "`GIT_FLUSH`"

#. type: Plain text
#: en/git.txt:741
#, placeholders:'git rev-list':'git check-attr':'git check-ignore', priority:100
msgid "If this Boolean environment variable is set to true, then commands such as 'git blame' (in incremental mode), 'git rev-list', 'git log', 'git check-attr' and 'git check-ignore' will force a flush of the output stream after each record have been flushed. If this variable is set to false, the output of these commands will be done using completely buffered I/O. If this environment variable is not set, Git will choose buffered or record-oriented flushing based on whether stdout appears to be redirected to a file or not."
msgstr "如果该布尔环境变量设置为 true，那么诸如 'git blame'（增量模式）、'git rev-list'、'git log'、'git check-attr' 和 'git check-ignore' 等命令将会在每条记录被刷新后强制刷新输出流。强制刷新输出流。如果该变量设置为 false，这些命令的输出将使用完全缓冲的 I/O 方式进行使用完全缓冲的 I/O 输出。 如果不设置这个环境变量不设置，Git 将根据标准输出流是否重定向到文件，选择缓冲或面向记录的刷新方式根据标准输出流是否被重定向到文件。"

#. type: Labeled list
#: en/git.txt:742
#, ignore-same, no-wrap, priority:100
msgid "`GIT_TRACE`"
msgstr "`GIT_TRACE`"

#. type: Plain text
#: en/git.txt:745
#, priority:100
msgid "Enables general trace messages, e.g. alias expansion, built-in command execution and external command execution."
msgstr "启用一般跟踪信息，如别名扩展、内置命令执行和外部命令执行。"

#. type: Plain text
#: en/git.txt:749 en/git.txt:829
#, priority:100
msgid "If this variable is set to \"1\", \"2\" or \"true\" (comparison is case insensitive), trace messages will be printed to stderr."
msgstr "如果该变量设置为 \"1\"、\"2\" 或 \"true\"（比较不区分大小写），跟踪信息将被打印到标准错误流。"

#. type: Plain text
#: en/git.txt:754 en/git.txt:834
#, priority:100
msgid "If the variable is set to an integer value greater than 2 and lower than 10 (strictly) then Git will interpret this value as an open file descriptor and will try to write the trace messages into this file descriptor."
msgstr "如果变量设置为大于 2 小于 10（严格意义上）的整数值，那么 Git 会将该值解释为一个打开的文件描述符，并尝试将跟踪信息写入该文件描述符。"

#. type: Plain text
#: en/git.txt:759
#, priority:100
msgid "Alternatively, if the variable is set to an absolute path (starting with a '/' character), Git will interpret this as a file path and will try to append the trace messages to it."
msgstr "另外，如果变量设置为绝对路径（以 '/' 字符开头），Git 会将其理解为文件路径，并尝试将跟踪信息附加到该路径上。"

#. type: Plain text
#: en/git.txt:762 en/git.txt:851
#, priority:100
msgid "Unsetting the variable, or setting it to empty, \"0\" or \"false\" (case insensitive) disables trace messages."
msgstr "取消对变量的设置，或将其设置为空、\"0\" 或 \"false\"（不区分大小写），将禁用跟踪信息。"

#. type: Labeled list
#: en/git.txt:763
#, ignore-same, no-wrap, priority:100
msgid "`GIT_TRACE_FSMONITOR`"
msgstr "`GIT_TRACE_FSMONITOR`"

#. type: Plain text
#: en/git.txt:766
#, placeholders:'GIT_TRACE', priority:100
msgid "Enables trace messages for the filesystem monitor extension. See `GIT_TRACE` for available trace output options."
msgstr "启用文件系统监视器扩展的跟踪信息。 有关可用的跟踪输出选项，请参阅 `GIT_TRACE`。"

#. type: Labeled list
#: en/git.txt:767
#, ignore-same, no-wrap, priority:100
msgid "`GIT_TRACE_PACK_ACCESS`"
msgstr "`GIT_TRACE_PACK_ACCESS`"

#. type: Plain text
#: en/git.txt:773
#, placeholders:'GIT_TRACE', priority:100
msgid "Enables trace messages for all accesses to any packs. For each access, the pack file name and an offset in the pack is recorded. This may be helpful for troubleshooting some pack-related performance problems. See `GIT_TRACE` for available trace output options."
msgstr "启用对所有数据包访问的跟踪信息。每次访问都会记录包文件名和包中的偏移量。这可能有助于排除一些与包相关的性能问题。 有关可用的跟踪输出选项，请参阅 `GIT_TRACE`。"

#. type: Labeled list
#: en/git.txt:774
#, ignore-same, no-wrap, priority:100
msgid "`GIT_TRACE_PACKET`"
msgstr "`GIT_TRACE_PACKET`"

#. type: Plain text
#: en/git.txt:780
#, placeholders:'GIT_TRACE_PACKFILE':'GIT_TRACE', priority:100
msgid "Enables trace messages for all packets coming in or out of a given program. This can help with debugging object negotiation or other protocol issues. Tracing is turned off at a packet starting with \"PACK\" (but see `GIT_TRACE_PACKFILE` below). See `GIT_TRACE` for available trace output options."
msgstr "启用对进出指定程序的所有数据包的跟踪信息。这有助于调试对象协商或其他协议问题。以 \"PACK\" 开头的数据包会关闭跟踪（但请参阅下文的 `GIT_TRACE_PACKFILE`）。 有关可用的跟踪输出选项，请参见 `GIT_TRACE`。"

#. type: Labeled list
#: en/git.txt:781
#, ignore-same, no-wrap, priority:100
msgid "`GIT_TRACE_PACKFILE`"
msgstr "`GIT_TRACE_PACKFILE`"

#. type: Plain text
#: en/git.txt:788
#, placeholders:'GIT_TRACE_PACKFILE', priority:100
msgid "Enables tracing of packfiles sent or received by a given program. Unlike other trace output, this trace is verbatim: no headers, and no quoting of binary data. You almost certainly want to direct into a file (e.g., `GIT_TRACE_PACKFILE=/tmp/my.pack`) rather than displaying it on the terminal or mixing it with other trace output."
msgstr "可跟踪指定程序发送或接收的打包文件。与其他跟踪输出不同，这种跟踪是逐字的：没有标题，也不引用二进制数据。你几乎肯定希望将其直接存入一个文件（例如 `GIT_TRACE_PACKFILE=/tmp/my.pack`），而不是显示在终端上或与其他跟踪输出混在一起。"

#. type: Plain text
#: en/git.txt:791
#, priority:100
msgid "Note that this is currently only implemented for the client side of clones and fetches."
msgstr "请注意，目前仅在克隆和获取的客户端实施了这一功能。"

#. type: Labeled list
#: en/git.txt:792
#, ignore-same, no-wrap, priority:100
msgid "`GIT_TRACE_PERFORMANCE`"
msgstr "`GIT_TRACE_PERFORMANCE`"

#. type: Plain text
#: en/git.txt:796
#, placeholders:'GIT_TRACE', priority:100
msgid "Enables performance related trace messages, e.g. total execution time of each Git command. See `GIT_TRACE` for available trace output options."
msgstr "启用与性能相关的跟踪信息，例如每条 Git 命令的总执行时间。 有关可用的跟踪输出选项，请参见 `GIT_TRACE`。"

#. type: Labeled list
#: en/git.txt:797
#, ignore-same, no-wrap, priority:100
msgid "`GIT_TRACE_REFS`"
msgstr "`GIT_TRACE_REFS`"

#. type: Plain text
#: en/git.txt:800
#, placeholders:'GIT_TRACE', priority:100
msgid "Enables trace messages for operations on the ref database. See `GIT_TRACE` for available trace output options."
msgstr "启用引用数据库操作的跟踪信息。 有关可用的跟踪输出选项，请参见 `GIT_TRACE`。"

#. type: Labeled list
#: en/git.txt:801
#, ignore-same, no-wrap, priority:100
msgid "`GIT_TRACE_SETUP`"
msgstr "`GIT_TRACE_SETUP`"

#. type: Plain text
#: en/git.txt:805
#, placeholders:'GIT_TRACE', priority:100
msgid "Enables trace messages printing the .git, working tree and current working directory after Git has completed its setup phase. See `GIT_TRACE` for available trace output options."
msgstr "在 Git 完成设置阶段后，启用打印 .git、工作树和当前工作目录的跟踪信息。 有关可用的跟踪输出选项，请参见 `GIT_TRACE`。"

#. type: Labeled list
#: en/git.txt:806
#, ignore-same, no-wrap, priority:100
msgid "`GIT_TRACE_SHALLOW`"
msgstr "`GIT_TRACE_SHALLOW`"

#. type: Plain text
#: en/git.txt:810
#, placeholders:'GIT_TRACE', priority:100
msgid "Enables trace messages that can help debugging fetching / cloning of shallow repositories. See `GIT_TRACE` for available trace output options."
msgstr "启用可帮助调试获取/克隆浅仓库的跟踪信息。 有关可用的跟踪输出选项，请参见 `GIT_TRACE`。"

#. type: Labeled list
#: en/git.txt:811
#, ignore-same, no-wrap, priority:100
msgid "`GIT_TRACE_CURL`"
msgstr "`GIT_TRACE_CURL`"

#. type: Plain text
#: en/git.txt:816
#, placeholders:'`--trace-ascii`':'GIT_TRACE', priority:100
msgid "Enables a curl full trace dump of all incoming and outgoing data, including descriptive information, of the git transport protocol. This is similar to doing curl `--trace-ascii` on the command line. See `GIT_TRACE` for available trace output options."
msgstr "启用对 git 传输协议所有传入和传出数据（包括描述性信息）的 curl 完整跟踪转储。 这类似于在命令行上执行 curl `--trace-ascii`。 有关可用的跟踪输出选项，请参阅 `GIT_TRACE`。"

#. type: Labeled list
#: en/git.txt:817
#, ignore-same, no-wrap, priority:100
msgid "`GIT_TRACE_CURL_NO_DATA`"
msgstr "`GIT_TRACE_CURL_NO_DATA`"

#. type: Plain text
#: en/git.txt:820
#, placeholders:'GIT_TRACE_CURL', priority:100
msgid "When a curl trace is enabled (see `GIT_TRACE_CURL` above), do not dump data (that is, only dump info lines and headers)."
msgstr "启用 curl 跟踪时（见上文 `GIT_TRACE_CURL`），不要转储数据（即只转储信息行和头文件）。"

#. type: Labeled list
#: en/git.txt:821
#, ignore-same, no-wrap, priority:100
msgid "`GIT_TRACE2`"
msgstr "`GIT_TRACE2`"

#. type: Plain text
#: en/git.txt:825
#, placeholders:'GIT_TRACE2', priority:100
msgid "Enables more detailed trace messages from the \"trace2\" library. Output from `GIT_TRACE2` is a simple text-based format for human readability."
msgstr "启用来自 \"trace2\" 库的更详细的跟踪信息。 `GIT_TRACE2` 的输出是一种简单的文本格式，可读性高。"

#. type: Plain text
#: en/git.txt:843
#, priority:100
msgid "Alternatively, if the variable is set to an absolute path (starting with a '/' character), Git will interpret this as a file path and will try to append the trace messages to it. If the path already exists and is a directory, the trace messages will be written to files (one per process) in that directory, named according to the last component of the SID and an optional counter (to avoid filename collisions)."
msgstr "另外，如果变量设置为绝对路径（以 '/' 字符开头），Git 会将其理解为文件路径，并尝试将跟踪信息附加到该路径上。 如果路径已经存在且是一个目录，跟踪信息将被写入该目录下的文件（每个进程一个），文件名根据 SID 的最后一个分量和一个可选的计数器命名（以避免文件名冲突）。"

#. type: Plain text
#: en/git.txt:848
#, placeholders:'af_unix', priority:100
msgid "In addition, if the variable is set to `af_unix:[<socket-type>:]<absolute-pathname>`, Git will try to open the path as a Unix Domain Socket. The socket type can be either `stream` or `dgram`."
msgstr "此外，如果变量设置为 `af_unix:[<套接字类型>:]<绝对文件路径>`，Git 将尝试以 Unix 域套接字的方式打开路径。 套接字类型可以是 `stream` 或 `dgram`。"

#. type: Plain text
#: en/git.txt:854
#, placeholders:'link:technical/api-trace2.html[', priority:100
msgid "See link:technical/api-trace2.html[Trace2 documentation] for full details."
msgstr "详见 link:technical/api-trace2.html[Trace2 文档]。"

#. type: Labeled list
#: en/git.txt:856
#, ignore-same, no-wrap, priority:100
msgid "`GIT_TRACE2_EVENT`"
msgstr "`GIT_TRACE2_EVENT`"

#. type: Plain text
#: en/git.txt:861
#, placeholders:'GIT_TRACE2':'link:technical/api-trace2.html[', priority:100
msgid "This setting writes a JSON-based format that is suited for machine interpretation. See `GIT_TRACE2` for available trace output options and link:technical/api-trace2.html[Trace2 documentation] for full details."
msgstr "此设置会写入适合机器解释的基于 JSON 的格式。 有关可用的跟踪输出选项，请参阅 `GIT_TRACE2`，以及 link:technical/api-trace2.html[Trace2 文档] 了解更多详情。"

#. type: Labeled list
#: en/git.txt:862
#, ignore-same, no-wrap, priority:100
msgid "`GIT_TRACE2_PERF`"
msgstr "`GIT_TRACE2_PERF`"

#. type: Plain text
#: en/git.txt:868
#, placeholders:'GIT_TRACE2':'GIT_TRACE2':'link:technical/api-trace2.html[', priority:100
msgid "In addition to the text-based messages available in `GIT_TRACE2`, this setting writes a column-based format for understanding nesting regions. See `GIT_TRACE2` for available trace output options and link:technical/api-trace2.html[Trace2 documentation] for full details."
msgstr "除了 `GIT_TRACE2` 中可用的基于文本的信息外，此设置还可写入基于列的格式，以了解嵌套区域。 有关可用的跟踪输出选项，请参阅 `GIT_TRACE2`，以及 link:technical/api-trace2.html[Trace2 文档] 了解更多详情。"

#. type: Labeled list
#: en/git.txt:869
#, ignore-same, no-wrap, priority:100
msgid "`GIT_TRACE_REDACT`"
msgstr "`GIT_TRACE_REDACT`"

#. type: Plain text
#: en/git.txt:874
#, priority:100
msgid "By default, when tracing is activated, Git redacts the values of cookies, the \"Authorization:\" header, the \"Proxy-Authorization:\" header and packfile URIs. Set this Boolean environment variable to false to prevent this redaction."
msgstr "默认情况下，启动跟踪后，Git 会编辑 cookie、\"Authorization:\"（授权：）标头、\"Proxy-Authorization:\"（代理授权：）标头和 packfile URI 的值。将此布尔环境变量设为 false，可阻止这种编辑。"

#. type: Labeled list
#: en/git.txt:875
#, ignore-same, no-wrap, priority:100
msgid "`GIT_LITERAL_PATHSPECS`"
msgstr "`GIT_LITERAL_PATHSPECS`"

#. type: Plain text
#: en/git.txt:883
#, placeholders:'GIT_LITERAL_PATHSPECS':'git ls-tree':'`--raw`', priority:100
msgid "Setting this Boolean environment variable to true will cause Git to treat all pathspecs literally, rather than as glob patterns. For example, running `GIT_LITERAL_PATHSPECS=1 git log -- '*.c'` will search for commits that touch the path `*.c`, not any paths that the glob `*.c` matches. You might want this if you are feeding literal paths to Git (e.g., paths previously given to you by `git ls-tree`, `--raw` diff output, etc)."
msgstr "将这个布尔环境变量设为 true 会导致 Git 按字面意思而非通配符模式来处理所有路径规范。例如，运行 `GIT_LITERAL_PATHSPECS=1 git log -- '*.c'` 将搜索涉及路径 `*.c` 的提交，而不是任何与通配符 `*.c` 匹配的路径。如果你正在向 Git 输入字面路径（例如，之前由 `git ls-tree`、`--raw` 差异输出等提供的路径），你可能需要这样做。"

#. type: Labeled list
#: en/git.txt:884
#, ignore-same, no-wrap, priority:100
msgid "`GIT_GLOB_PATHSPECS`"
msgstr "`GIT_GLOB_PATHSPECS`"

#. type: Plain text
#: en/git.txt:887
#, priority:100
msgid "Setting this Boolean environment variable to true will cause Git to treat all pathspecs as glob patterns (aka \"glob\" magic)."
msgstr "将这个布尔环境变量设置为 true 会导致 Git 将所有路径规范视为通配符模式（又称 \"glob\" 魔法）。"

#. type: Labeled list
#: en/git.txt:888
#, ignore-same, no-wrap, priority:100
msgid "`GIT_NOGLOB_PATHSPECS`"
msgstr "`GIT_NOGLOB_PATHSPECS`"

#. type: Plain text
#: en/git.txt:891
#, priority:100
msgid "Setting this Boolean environment variable to true will cause Git to treat all pathspecs as literal (aka \"literal\" magic)."
msgstr "将这个布尔环境变量设置为 true，Git 就会将所有路径规范都视为字面意思（又称 \"literal\"（字面）魔法）。"

#. type: Labeled list
#: en/git.txt:892
#, ignore-same, no-wrap, priority:100
msgid "`GIT_ICASE_PATHSPECS`"
msgstr "`GIT_ICASE_PATHSPECS`"

#. type: Plain text
#: en/git.txt:895
#, priority:100
msgid "Setting this Boolean environment variable to true will cause Git to treat all pathspecs as case-insensitive."
msgstr "将此布尔环境变量设置为 true 会导致 Git 将所有路径规范视为不区分大小写。"

#. type: Labeled list
#: en/git.txt:896
#, ignore-same, no-wrap, priority:100
msgid "`GIT_REFLOG_ACTION`"
msgstr "`GIT_REFLOG_ACTION`"

#. type: Plain text
#: en/git.txt:905
#, placeholders:'set_reflog_action':'git-sh-setup', priority:100
msgid "When a ref is updated, reflog entries are created to keep track of the reason why the ref was updated (which is typically the name of the high-level command that updated the ref), in addition to the old and new values of the ref. A scripted Porcelain command can use set_reflog_action helper function in `git-sh-setup` to set its name to this variable when it is invoked as the top level command by the end user, to be recorded in the body of the reflog."
msgstr "更新引用时，会创建引用日志条目来记录更新引用的原因（通常是更新引用的高级命令的名称），以及引用的新旧值。 脚本化的上层命令可以使用 `git-sh-setup` 中的 set_reflog_action 辅助函数，在被最终用户作为顶级命令调用时将其名称设置为该变量，并记录在引用日志的正文中。"

#. type: Labeled list
#: en/git.txt:906
#, ignore-same, no-wrap, priority:100
msgid "`GIT_REF_PARANOIA`"
msgstr "`GIT_REF_PARANOIA`"

#. type: Plain text
#: en/git.txt:917
#, placeholders:'linkgit:git-prune[1]', priority:100
msgid "If this Boolean environment variable is set to false, ignore broken or badly named refs when iterating over lists of refs. Normally Git will try to include any such refs, which may cause some operations to fail. This is usually preferable, as potentially destructive operations (e.g., linkgit:git-prune[1]) are better off aborting rather than ignoring broken refs (and thus considering the history they point to as not worth saving). The default value is `1` (i.e., be paranoid about detecting and aborting all operations). You should not normally need to set this to `0`, but it may be useful when trying to salvage data from a corrupted repository."
msgstr "如果将此布尔环境变量设置为 false，则在遍历引用列表时会忽略已损坏或命名不正确的引用。通常情况下，Git 会尝试包含任何此类引用，这可能会导致某些操作失败。这通常是可取的，因为潜在的破坏性操作（例如 linkgit:git-prune[1]）最好是中止，而不是忽略破损的引用（从而认为它们指向的历史不值得保存）。默认值是 `1`（即偏执地检测并终止所有操作）。通常不需要将其设置为 `0`，但在试图从损坏的版本库中挽救数据时可能会有用。"

#. type: Labeled list
#: en/git.txt:918
#, ignore-same, no-wrap, priority:100
msgid "`GIT_COMMIT_GRAPH_PARANOIA`"
msgstr "`GIT_COMMIT_GRAPH_PARANOIA`"

#. type: Plain text
#: en/git.txt:923
#, priority:100
msgid "When loading a commit object from the commit-graph, Git performs an existence check on the object in the object database. This is done to avoid issues with stale commit-graphs that contain references to already-deleted commits, but comes with a performance penalty."
msgstr "从提交图加载提交对象时，Git 会对对象数据库中的对象执行存在性检查。这样做是为了避免出现陈旧的提交图（其中包含对已删除提交的引用），但同时也会影响性能。"

#. type: Plain text
#: en/git.txt:927
#, priority:100
msgid "The default is \"false\", which disables the aforementioned behavior. Setting this to \"true\" enables the existence check so that stale commits will never be returned from the commit-graph at the cost of performance."
msgstr "默认值为 \"false\"，即禁用上述行为。将其设置为 \"true\" 可启用存在性检查，这样就不会从提交图中返回过时的提交，但这也会影响性能。"

#. type: Labeled list
#: en/git.txt:928
#, ignore-same, no-wrap, priority:100
msgid "`GIT_ALLOW_PROTOCOL`"
msgstr "`GIT_ALLOW_PROTOCOL`"

#. type: Plain text
#: en/git.txt:934
#, placeholders:'protocol.allow':'protocol.allow':'linkgit:git-config[1]', priority:100
msgid "If set to a colon-separated list of protocols, behave as if `protocol.allow` is set to `never`, and each of the listed protocols has `protocol.<name>.allow` set to `always` (overriding any existing configuration). See the description of `protocol.allow` in linkgit:git-config[1] for more details."
msgstr "如果设置为以冒号分隔的协议列表，其行为就好像 `protocol.allow` 被设置为 `never` 而每个列出的协议都被 `protocol.<名称>.allow` 设置为 `always`（覆盖任何现有配置）。详见 linkgit:git-config[1] 中关于 `protocol.allow` 的描述。"

#. type: Labeled list
#: en/git.txt:935
#, ignore-same, no-wrap, priority:100
msgid "`GIT_PROTOCOL_FROM_USER`"
msgstr "`GIT_PROTOCOL_FROM_USER`"

#. type: Plain text
#: en/git.txt:941
#, placeholders:'linkgit:git-config[1]', priority:100
msgid "Set this Boolean environment variable to false to prevent protocols used by fetch/push/clone which are configured to the `user` state. This is useful to restrict recursive submodule initialization from an untrusted repository or for programs which feed potentially-untrusted URLS to git commands. See linkgit:git-config[1] for more details."
msgstr "将此布尔环境变量设为 false，以防止 fetch/push/clone 使用配置为 `user` 状态的协议。 这对于限制从不可信任的仓库或向 git 命令提供可能不可信任的 URLS 的程序递归初始化子模块非常有用。 详见 linkgit:git-config[1]。"

#. type: Labeled list
#: en/git.txt:942 en/git-upload-pack.txt:53
#, ignore-same, no-wrap, priority:100
msgid "`GIT_PROTOCOL`"
msgstr "`GIT_PROTOCOL`"

#. type: Plain text
#: en/git.txt:947
#, priority:100
msgid "For internal use only. Used in handshaking the wire protocol. Contains a colon ':' separated list of keys with optional values 'key[=value]'. Presence of unknown keys and values must be ignored."
msgstr "仅供内部使用。 用于有线协议握手。 包含一个用冒号 ':' 分隔的键列表，可选值为 'key[=value]'。 必须忽略未知键和值的存在。"

#. type: Plain text
#: en/git.txt:956
#, placeholders:'git-over-http':'linkgit:git-http-backend[1]':'git-over-ssh':'GIT_PROTOCOL', priority:100
msgid "Note that servers may need to be configured to allow this variable to pass over some transports. It will be propagated automatically when accessing local repositories (i.e., `file://` or a filesystem path), as well as over the `git://` protocol. For git-over-http, it should work automatically in most configurations, but see the discussion in linkgit:git-http-backend[1]. For git-over-ssh, the ssh server may need to be configured to allow clients to pass this variable (e.g., by using `AcceptEnv GIT_PROTOCOL` with OpenSSH)."
msgstr "请注意，可能需要对服务器进行配置，以允许该变量通过某些传输方式传递。在访问本地仓库（即 `file://` 或文件系统路径）以及通过 `git://` 协议时，它会自动传播。对于 git-over-http，它在大多数配置中都会自动工作，但请参阅 linkgit:git-http-backend[1] 中的讨论。对于 git-over-ssh，可能需要配置 ssh 服务器以允许客户端传递此变量（例如，在 OpenSSH 中使用 `AcceptEnv GIT_PROTOCOL`）。"

#. type: Plain text
#: en/git.txt:962
#, priority:100
msgid "This configuration is optional. If the variable is not propagated, then clients will fall back to the original \"v0\" protocol (but may miss out on some performance improvements or features). This variable currently only affects clones and fetches; it is not yet used for pushes (but may be in the future)."
msgstr "此配置为可选配置。如果不传播该变量，客户端将退回到原始的 \"v0\" 协议（但可能会错过某些性能改进或功能）。该变量目前只影响克隆和获取，尚未用于推送（但将来可能会）。"

#. type: Labeled list
#: en/git.txt:963
#, ignore-same, no-wrap, priority:100
msgid "`GIT_OPTIONAL_LOCKS`"
msgstr "`GIT_OPTIONAL_LOCKS`"

#. type: Plain text
#: en/git.txt:970
#, priority:100
msgid "If this Boolean environment variable is set to false, Git will complete any requested operation without performing any optional sub-operations that require taking a lock. For example, this will prevent `git status` from refreshing the index as a side effect. This is useful for processes running in the background which do not want to cause lock contention with other operations on the repository. Defaults to `1`."
msgstr "如果把这个布尔环境变量设置为 false，Git 将在不执行任何需要加锁的可选子操作的情况下完成任何请求的操作。 例如，这将防止 `git status` 刷新索引的副作用。这对后台运行的进程非常有用，因为它们不希望与仓库中的其他操作造成锁争用。 默认值为 `1`。"

#. type: Labeled list
#: en/git.txt:971
#, ignore-same, no-wrap, priority:100
msgid "`GIT_REDIRECT_STDIN`"
msgstr "`GIT_REDIRECT_STDIN`"

#. type: Labeled list
#: en/git.txt:972
#, ignore-same, no-wrap, priority:100
msgid "`GIT_REDIRECT_STDOUT`"
msgstr "`GIT_REDIRECT_STDOUT`"

#. type: Labeled list
#: en/git.txt:973
#, ignore-same, no-wrap, priority:100
msgid "`GIT_REDIRECT_STDERR`"
msgstr "`GIT_REDIRECT_STDERR`"

#. type: Plain text
#: en/git.txt:983
#, priority:100
msgid "Windows-only: allow redirecting the standard input/output/error handles to paths specified by the environment variables. This is particularly useful in multi-threaded applications where the canonical way to pass standard handles via `CreateProcess()` is not an option because it would require the handles to be marked inheritable (and consequently *every* spawned process would inherit them, possibly blocking regular Git operations). The primary intended use case is to use named pipes for communication (e.g. `\\\\.\\pipe\\my-git-stdin-123`)."
msgstr "仅限 Windows：允许将标准输入/输出/错误句柄重定向到环境变量指定的路径。这在多线程应用程序中特别有用，因为通过 `CreateProcess()` 传递标准句柄的标准方式并不可行，因为这需要将句柄标记为可继承（因此 *每个* 生成的进程都会继承它们，可能会阻塞常规的 Git 操作）。主要的预期用例是使用命名管道进行通信（例如 `\\\\.\\pipe\\my-git-stdin-123`）。"

#. type: Plain text
#: en/git.txt:988
#, placeholders:'GIT_REDIRECT_STDERR', priority:100
msgid "Two special values are supported: `off` will simply close the corresponding standard handle, and if `GIT_REDIRECT_STDERR` is `2>&1`, standard error will be redirected to the same handle as standard output."
msgstr "支持两个特殊值： 如果 `GIT_REDIRECT_STDERR` 是 `2>&1` ，标准错误将重定向到与标准输出相同的句柄。"

#. type: Labeled list
#: en/git.txt:989
#, no-wrap, placeholders:'GIT_PRINT_SHA1_ELLIPSIS', priority:100
msgid "`GIT_PRINT_SHA1_ELLIPSIS` (deprecated)"
msgstr "GIT_PRINT_SHA1_ELLIPSIS（已弃用）"

#. type: Plain text
#: en/git.txt:997
#, placeholders:'HEAD':'linkgit:git-checkout[1]':'linkgit:git-diff[1]', priority:100
msgid "If set to `yes`, print an ellipsis following an (abbreviated) SHA-1 value. This affects indications of detached HEADs (linkgit:git-checkout[1]) and the raw diff output (linkgit:git-diff[1]). Printing an ellipsis in the cases mentioned is no longer considered adequate and support for it is likely to be removed in the foreseeable future (along with the variable)."
msgstr "如果设置为 `yes`，会在 SHA-1 值（缩写）后打印省略号。 这会影响分离 HEAD 的指示（linkgit:git-checkout[1]）和原始差异输出（linkgit:git-diff[1]）。 在上述情况下打印省略号不再被认为是适当的，在可预见的将来，对它的支持可能会被移除（连同变量）。"

# ERROR: [[Discussion]] not found in translation
#. type: Title -
#: en/git.txt:999
#, no-wrap, placeholders:'[[Discussion]]', priority:100
msgid "Discussion[[Discussion]]"
msgstr "讨论[[Discussion]]"

#. type: Plain text
#: en/git.txt:1004
#, placeholders:'link:user-manual.html#git-concepts[':'linkgit:gitcore-tutorial[7]', priority:100
msgid "More detail on the following is available from the link:user-manual.html#git-concepts[Git concepts chapter of the user-manual] and linkgit:gitcore-tutorial[7]."
msgstr "有关以下内容的更多详情，请参阅link:user-manual.html#git-concepts[用户手册中的 Git 概念章节]和 linkgit:gitcore-tutorial[7]。"

#. type: Plain text
#: en/git.txt:1011
#, priority:100
msgid "A Git project normally consists of a working directory with a \".git\" subdirectory at the top level. The .git directory contains, among other things, a compressed object database representing the complete history of the project, an \"index\" file which links that history to the current contents of the working tree, and named pointers into that history such as tags and branch heads."
msgstr "Git 项目通常由一个工作目录和一个位于顶层的 \".git \" 子目录组成。 除其他内容外，.git 目录还包含一个压缩对象数据库，代表项目的完整历史；一个 \"index\" 文件，将历史记录与当前工作区的内容相链接；以及指向历史记录的命名指针，如标签和分支头。"

#. type: Plain text
#: en/git.txt:1016
#, priority:100
msgid "The object database contains objects of three main types: blobs, which hold file data; trees, which point to blobs and other trees to build up directory hierarchies; and commits, which each reference a single tree and some number of parent commits."
msgstr "对象数据库包含三种主要类型的对象：blobs，用于保存文件数据；tree，用于指向 blobs 和其他树，以建立目录层次结构；commits，用于引用单个树和一定数量的父提交。"

#. type: Plain text
#: en/git.txt:1021
#, priority:100
msgid "The commit, equivalent to what other systems call a \"changeset\" or \"version\", represents a step in the project's history, and each parent represents an immediately preceding step. Commits with more than one parent represent merges of independent lines of development."
msgstr "提交相当于其他系统所说的 \"changeset\" 或 \"version\"，代表项目历史中的一个步骤，每个父提交代表紧接着的前一个步骤。 有多个父提交的提交代表独立开发线的合并。"

#. type: Plain text
#: en/git.txt:1027
#, priority:100
msgid "All objects are named by the SHA-1 hash of their contents, normally written as a string of 40 hex digits. Such names are globally unique. The entire history leading up to a commit can be vouched for by signing just that commit. A fourth object type, the tag, is provided for this purpose."
msgstr "所有对象都以其内容的 SHA-1 哈希值命名，通常写成由 40 个十六进制数字组成的字符串。 这些名称具有全局唯一性。 只需对某个提交进行签名，就能证明该提交之前的整个历史。 为此，我们提供了第四种对象类型——tag（标签）。"

#. type: Plain text
#: en/git.txt:1030
#, priority:100
msgid "When first created, objects are stored in individual files, but for efficiency may later be compressed together into \"pack files\"."
msgstr "首次创建时，对象存储在单个文件中，但为了提高效率，以后可能会压缩成 \"pack files\"。"

#. type: Plain text
#: en/git.txt:1038
#, placeholders:'HEAD', priority:100
msgid "Named pointers called refs mark interesting points in history. A ref may contain the SHA-1 name of an object or the name of another ref (the latter is called a \"symbolic ref\"). Refs with names beginning `refs/head/` contain the SHA-1 name of the most recent commit (or \"head\") of a branch under development. SHA-1 names of tags of interest are stored under `refs/tags/`. A symbolic ref named `HEAD` contains the name of the currently checked-out branch."
msgstr "被称为引用的已命名指针会标记历史中的有趣点。一个引用可以包含一个对象的 SHA-1 名称或另一个引用的名称（后者称为“符号引用”）。名称以 `refs/head/` 开头的引用包含开发中分支的最新提交（或 \"head\"）的 SHA-1 名称。相关标记的 SHA-1 名称存储在 `refs/tags/` 下。名为 `HEAD` 的符号引用包含当前已签出分支的名称。"

#. type: Plain text
#: en/git.txt:1047
#, priority:100
msgid "The index file is initialized with a list of all paths and, for each path, a blob object and a set of attributes. The blob object represents the contents of the file as of the head of the current branch. The attributes (last modified time, size, etc.) are taken from the corresponding file in the working tree. Subsequent changes to the working tree can be found by comparing these attributes. The index may be updated with new content, and new commits may be created from the content stored in the index."
msgstr "索引文件初始化时包含一个所有路径的列表，以及每个路径的一个二进制对象和一组属性。 二进制对象代表当前分支头部的文件内容。 属性（最后修改时间、大小等）取自工作树中的相应文件。 通过比较这些属性，可以发现工作区的后续更改。 索引可根据新内容进行更新，也可根据索引中存储的内容创建新提交。"

#. type: Plain text
#: en/git.txt:1051
#, priority:100
msgid "The index is also capable of storing multiple entries (called \"stages\") for a given pathname. These stages are used to hold the various unmerged version of a file when a merge is in progress."
msgstr "索引还能为给定路径名存储多个条目（称为 \"stages\"（阶段））。 在合并过程中，这些阶段用于保存文件的各种未合并版本。"

#. type: Title -
#: en/git.txt:1053
#, no-wrap, priority:100
msgid "FURTHER DOCUMENTATION"
msgstr "更多文件"

#. type: Plain text
#: en/git.txt:1058
#, priority:100
msgid "See the references in the \"description\" section to get started using Git. The following is probably more detail than necessary for a first-time user."
msgstr "请参阅 “说明” 部分的参考资料，开始使用 Git。 对于初次使用 Git 的用户来说，以下内容可能过于详细。"

#. type: Plain text
#: en/git.txt:1062
#, placeholders:'link:user-manual.html#git-concepts[':'linkgit:gitcore-tutorial[7]', priority:100
msgid "The link:user-manual.html#git-concepts[Git concepts chapter of the user-manual] and linkgit:gitcore-tutorial[7] both provide introductions to the underlying Git architecture."
msgstr "link:user-manual.html#git-concepts[用户手册中的 Git 概念章节]和 linkgit:gitcore-tutorial[7] 都介绍了 Git 的底层架构。"

#. type: Plain text
#: en/git.txt:1064
#, placeholders:'linkgit:gitworkflows[7]', priority:100
msgid "See linkgit:gitworkflows[7] for an overview of recommended workflows."
msgstr "请参阅 linkgit:gitworkflows[7] 了解推荐的工作流程。"

#. type: Plain text
#: en/git.txt:1067
#, placeholders:'link:howto-index.html[', priority:100
msgid "See also the link:howto-index.html[howto] documents for some useful examples."
msgstr "另请参阅 link:howto-index.html[howto] 文档，了解一些有用的示例。"

# ERROR: link:technical/api-index.html[ not found in translation
#. type: Plain text
#: en/git.txt:1070
#, placeholders:'link:technical/api-index.html[', priority:100
msgid "The internals are documented in the link:technical/api-index.html[Git API documentation]."
msgstr "link:technical/api-index.html[Git API 文档]中介绍了内部结构。"

#. type: Plain text
#: en/git.txt:1073
#, placeholders:'linkgit:gitcvs-migration[7]', priority:100
msgid "Users migrating from CVS may also want to read linkgit:gitcvs-migration[7]."
msgstr "从 CVS 迁移的用户可能还需要阅读 linkgit:gitcvs-migration[7]。"

#. type: Title -
#: en/git.txt:1076
#, no-wrap, priority:100
msgid "Authors"
msgstr "作者"

#. type: Plain text
#: en/git.txt:1081
#, placeholders:'vger.kernel.org':'openhub.net', priority:100
msgid "Git was started by Linus Torvalds, and is currently maintained by Junio C Hamano. Numerous contributions have come from the Git mailing list <git@vger.kernel.org>. https://openhub.net/p/git/contributors/summary gives you a more complete list of contributors."
msgstr "Git 由 Linus Torvalds 发起，目前由 Junio C Hamano 维护。许多贡献来自 Git 邮件列表 <git@vger.kernel.org>。http://www.openhub.net/p/git/contributors/summary 提供了更完整的贡献者名单。"

#. type: Plain text
#: en/git.txt:1085
#, placeholders:'git.git':'linkgit:git-shortlog[1]':'linkgit:git-blame[1]', priority:100
msgid "If you have a clone of git.git itself, the output of linkgit:git-shortlog[1] and linkgit:git-blame[1] can show you the authors for specific parts of the project."
msgstr "如果克隆了 git.git，linkgit:git-shortlog[1] 和 linkgit:git-blame[1] 的输出结果可以显示项目特定部分的作者。"

#. type: Title -
#: en/git.txt:1087
#, no-wrap, priority:100
msgid "Reporting Bugs"
msgstr "报告缺陷"

#. type: Plain text
#: en/git.txt:1094
#, placeholders:'vger.kernel.org':'lore.kernel.org', priority:100
msgid "Report bugs to the Git mailing list <git@vger.kernel.org> where the development and maintenance is primarily done. You do not have to be subscribed to the list to send a message there. See the list archive at https://lore.kernel.org/git for previous bug reports and other discussions."
msgstr "向 Git 邮件列表 <git@vger.kernel.org> 报告错误，开发和维护工作主要在此进行。 您无需订阅该列表即可在此发送信息。 有关以前的错误报告和其他讨论，请参阅 https://lore.kernel.org/git 的列表档案。"

#. type: Plain text
#: en/git.txt:1097
#, placeholders:'git-security':'googlegroups.com', priority:100
msgid "Issues which are security relevant should be disclosed privately to the Git Security mailing list <git-security@googlegroups.com>."
msgstr "与安全相关的问题应在 Git 安全邮件列表 <git-security@googlegroups.com> 中私下披露。"

#. type: Plain text
#: en/git.txt:1105
#, placeholders:'linkgit:gittutorial[7]':'linkgit:gittutorial-2[7]':'linkgit:giteveryday[7]':'linkgit:gitcvs-migration[7]':'linkgit:gitglossary[7]':'linkgit:gitcore-tutorial[7]':'linkgit:gitcli[7]':'link:user-manual.html[':'linkgit:gitworkflows[7]', priority:100
msgid "linkgit:gittutorial[7], linkgit:gittutorial-2[7], linkgit:giteveryday[7], linkgit:gitcvs-migration[7], linkgit:gitglossary[7], linkgit:gitcore-tutorial[7], linkgit:gitcli[7], link:user-manual.html[The Git User's Manual], linkgit:gitworkflows[7]"
msgstr "linkgit:gittutorial[7], linkgit:gittutorial-2[7], linkgit:giteveryday[7], linkgit:gitcvs-migration[7], linkgit:gitglossary[7], linkgit:gitcore-tutorial[7], linkgit:gitcli[7], link:user-manual.html[Git 用户手册], linkgit:gitworkflows[7]"

#. type: Title =
#: en/git-unpack-file.txt:2
#, ignore-same, no-wrap, priority:90
msgid "git-unpack-file(1)"
msgstr "git-unpack-file(1)"

#. type: Plain text
#: en/git-unpack-file.txt:7
#, placeholders:'git-unpack-file', priority:90
msgid "git-unpack-file - Creates a temporary file with a blob's contents"
msgstr "git-unpack-file - 创建一个包含 blob 内容的临时文件"

#. type: Plain text
#: en/git-unpack-file.txt:14
#, no-wrap, placeholders:'git unpack-file', priority:90
msgid "'git unpack-file' <blob>\n"
msgstr "'git unpack-file' <blob>\n"

#. type: Plain text
#: en/git-unpack-file.txt:20
#, no-wrap, placeholders:'merge_file_XXXXX', priority:90
msgid ""
"Creates a file holding the contents of the blob specified by sha1. It\n"
"returns the name of the temporary file in the following format:\n"
"\t.merge_file_XXXXX\n"
msgstr ""
"创建一个文件，保存由 sha1 指定的 blob 内容。\n"
"它将以以下格式返回临时文件的名称：\n"
"\t.merge_file_XXXXX\n"

#. type: Plain text
#: en/git-unpack-file.txt:25
#, priority:90
msgid "Must be a blob id"
msgstr "必须是 Blob id"

#. type: Title =
#: en/git-unpack-objects.txt:2
#, ignore-same, no-wrap, priority:90
msgid "git-unpack-objects(1)"
msgstr "git-unpack-objects(1)"

#. type: Plain text
#: en/git-unpack-objects.txt:7
#, placeholders:'git-unpack-objects', priority:90
msgid "git-unpack-objects - Unpack objects from a packed archive"
msgstr "git-unpack-objects - 从打包的压缩包中解压对象"

#. type: Plain text
#: en/git-unpack-objects.txt:13
#, no-wrap, placeholders:'git unpack-objects':'[--strict]', priority:90
msgid "'git unpack-objects' [-n] [-q] [-r] [--strict]\n"
msgstr "'git unpack-objects' [-n] [-q] [-r] [--strict]\n"

#. type: Plain text
#: en/git-unpack-objects.txt:20
#, priority:90
msgid "Read a packed archive (.pack) from the standard input, expanding the objects contained within and writing them into the repository in \"loose\" (one object per file) format."
msgstr "从标准输入读取打包压缩包（.pack），展开其中包含的对象，并以 “松散”（每个文件一个对象）格式写入仓库。"

#. type: Plain text
#: en/git-unpack-objects.txt:24
#, priority:90
msgid "Objects that already exist in the repository will *not* be unpacked from the packfile. Therefore, nothing will be unpacked if you use this command on a packfile that exists within the target repository."
msgstr "仓库中已存在的对象将 *不* 会从 packfile 中解包。 因此，如果在目标仓库中存在的 packfile 上使用此命令，将不会解包任何内容。"

#. type: Plain text
#: en/git-unpack-objects.txt:27
#, placeholders:'linkgit:git-repack[1]', priority:90
msgid "See linkgit:git-repack[1] for options to generate new packs and replace existing ones."
msgstr "请参阅 linkgit:git-repack[1] 了解生成新包和替换现有包的选项。"

#. type: Plain text
#: en/git-unpack-objects.txt:33
#, priority:90
msgid "Dry run. Check the pack file without actually unpacking the objects."
msgstr "模拟运行。 在不实际解压对象的情况下检查软件包文件。"

#. type: Plain text
#: en/git-unpack-objects.txt:37
#, priority:90
msgid "The command usually shows percentage progress. This flag suppresses it."
msgstr "该命令通常会显示进度百分比。 该标记会抑制显示。"

#. type: Plain text
#: en/git-unpack-objects.txt:43
#, priority:90
msgid "When unpacking a corrupt packfile, the command dies at the first corruption. This flag tells it to keep going and make the best effort to recover as many objects as possible."
msgstr "在解压缩损坏的软件包文件时，命令会在第一次损坏时停止运行。 该标记会让命令继续运行，尽最大努力恢复尽可能多的对象。"

#. type: Plain text
#: en/git-unpack-objects.txt:46
#, priority:90
msgid "Don't write objects with broken content or links."
msgstr "不要编写内容或链接已损坏的对象。"

#. type: Title =
#: en/git-update-index.txt:2
#, ignore-same, no-wrap, priority:80
msgid "git-update-index(1)"
msgstr "git-update-index(1)"

#. type: Plain text
#: en/git-update-index.txt:7
#, placeholders:'git-update-index', priority:80
msgid "git-update-index - Register file contents in the working tree to the index"
msgstr "git-update-index - 将工作区中的文件内容注册到索引中"

#. type: Plain text
#: en/git-update-index.txt:30
#, ignore-ellipsis, no-wrap, placeholders:'git update-index':'[--add]':'[--remove':'--force-remove]':'[--replace]':'[--refresh]':'[--unmerged]':'[--ignore-missing]':'--cacheinfo':'[--chmod=(+|-)x]':'[--ignore-submodules]':'[--really-refresh]':'[--unresolve]':'[--again':'[--info-only]':'[--index-info]':'[--stdin]':'[--index-version':'[--verbose]', priority:80
msgid ""
"'git update-index'\n"
"\t     [--add] [--remove | --force-remove] [--replace]\n"
"\t     [--refresh] [-q] [--unmerged] [--ignore-missing]\n"
"\t     [(--cacheinfo <mode>,<object>,<file>)...]\n"
"\t     [--chmod=(+|-)x]\n"
"\t     [--[no-]assume-unchanged]\n"
"\t     [--[no-]skip-worktree]\n"
"\t     [--[no-]ignore-skip-worktree-entries]\n"
"\t     [--[no-]fsmonitor-valid]\n"
"\t     [--ignore-submodules]\n"
"\t     [--[no-]split-index]\n"
"\t     [--[no-|test-|force-]untracked-cache]\n"
"\t     [--[no-]fsmonitor]\n"
"\t     [--really-refresh] [--unresolve] [--again | -g]\n"
"\t     [--info-only] [--index-info]\n"
"\t     [-z] [--stdin] [--index-version <n>]\n"
"\t     [--verbose]\n"
"\t     [--] [<file>...]\n"
msgstr ""
"'git update-index'\n"
"\t     [--add] [--remove | --force-remove] [--replace]\n"
"\t     [--refresh] [-q] [--unmerged] [--ignore-missing]\n"
"\t     [(--cacheinfo <模式>,<对象>,<文件>)...]\n"
"\t     [--chmod=(+|-)x]\n"
"\t     [--[no-]assume-unchanged]\n"
"\t     [--[no-]skip-worktree]\n"
"\t     [--[no-]ignore-skip-worktree-entries]\n"
"\t     [--[no-]fsmonitor-valid]\n"
"\t     [--ignore-submodules]\n"
"\t     [--[no-]split-index]\n"
"\t     [--[no-|test-|force-]untracked-cache]\n"
"\t     [--[no-]fsmonitor]\n"
"\t     [--really-refresh] [--unresolve] [--again | -g]\n"
"\t     [--info-only] [--index-info]\n"
"\t     [-z] [--stdin] [--index-version <n>]\n"
"\t     [--verbose]\n"
"\t     [--] [<文件>...]\n"

#. type: Plain text
#: en/git-update-index.txt:35
#, priority:80
msgid "Modifies the index. Each file mentioned is updated into the index and any 'unmerged' or 'needs updating' state is cleared."
msgstr "修改索引。提到的每个文件都会更新到索引中，任何 “未合并” 或 “需要更新” 的状态都会被清除。"

#. type: Plain text
#: en/git-update-index.txt:38
#, placeholders:'linkgit:git-add[1]', priority:80
msgid "See also linkgit:git-add[1] for a more user-friendly way to do some of the most common operations on the index."
msgstr "参见 linkgit:git-add[1]，以获取更友好的索引操作方法。"

#. type: Plain text
#: en/git-update-index.txt:41
#, placeholders:'git update-index', priority:80
msgid "The way 'git update-index' handles files it is told about can be modified using the various options:"
msgstr "'git update-index' 处理文件的方式可以通过各种选项来修改："

#. type: Plain text
#: en/git-update-index.txt:48
#, priority:80
msgid "If a specified file isn't in the index already then it's added. Default behaviour is to ignore new files."
msgstr "如果索引中还没有指定文件，则会添加该文件。 默认行为是忽略新文件。"

#. type: Labeled list
#: en/git-update-index.txt:49
#, ignore-same, no-wrap, priority:80
msgid "--remove"
msgstr "--remove"

#. type: Plain text
#: en/git-update-index.txt:53
#, priority:80
msgid "If a specified file is in the index but is missing then it's removed. Default behavior is to ignore removed files."
msgstr "如果指定的文件在索引中但丢失了，则会被移除。 默认行为是忽略已删除的文件。"

#. type: Plain text
#: en/git-update-index.txt:57
#, priority:80
msgid "Looks at the current index and checks to see if merges or updates are needed by checking stat() information."
msgstr "查看当前索引，并通过检查 stat() 信息查看是否需要合并或更新。"

#. type: Plain text
#: en/git-update-index.txt:62
#, placeholders:'--refresh':'git update-index', priority:80
msgid "Quiet. If --refresh finds that the index needs an update, the default behavior is to error out. This option makes 'git update-index' continue anyway."
msgstr "安静 如果 --refresh 发现索引需要更新，默认行为是出错。 该选项会让 'git update-index' 继续执行。"

#. type: Labeled list
#: en/git-update-index.txt:63
#, ignore-same, no-wrap, priority:80
msgid "--ignore-submodules"
msgstr "--ignore-submodules"

#. type: Plain text
#: en/git-update-index.txt:66
#, placeholders:'--refresh', priority:80
msgid "Do not try to update submodules. This option is only respected when passed before --refresh."
msgstr "不尝试更新子模块。 该选项只有在 --refresh 之前使用时才会被遵守。"

#. type: Plain text
#: en/git-update-index.txt:71
#, placeholders:'--refresh':'git update-index', priority:80
msgid "If --refresh finds unmerged changes in the index, the default behavior is to error out. This option makes 'git update-index' continue anyway."
msgstr "如果 --refresh 在索引中发现未合并的更改，默认行为是出错。 这个选项会让 'git update-index' 继续执行。"

# ERROR: --refresh not found in translation
#. type: Plain text
#: en/git-update-index.txt:74
#, placeholders:'--refresh', priority:80
msgid "Ignores missing files during a --refresh"
msgstr "在 --refresh 过程中忽略丢失的文件"

#. type: Labeled list
#: en/git-update-index.txt:75
#, no-wrap, placeholders:'--cacheinfo', priority:80
msgid "--cacheinfo <mode>,<object>,<path>"
msgstr "--cacheinfo <模式>,<对象>,<路径>"

#. type: Labeled list
#: en/git-update-index.txt:76
#, no-wrap, placeholders:'--cacheinfo', priority:80
msgid "--cacheinfo <mode> <object> <path>"
msgstr "--cacheinfo <模式> <对象> <路径>"

#. type: Plain text
#: en/git-update-index.txt:81
#, priority:80
msgid "Directly insert the specified info into the index. For backward compatibility, you can also give these three arguments as three separate parameters, but new users are encouraged to use a single-parameter form."
msgstr "将指定信息直接插入索引。 为了向后兼容，也可以将这三个参数分别作为三个参数，但建议新用户使用单参数形式。"

#. type: Labeled list
#: en/git-update-index.txt:82
#, ignore-same, no-wrap, priority:80
msgid "--index-info"
msgstr "--index-info"

#. type: Plain text
#: en/git-update-index.txt:84
#, priority:80
msgid "Read index information from stdin."
msgstr "从标准输入流读取索引信息。"

#. type: Plain text
#: en/git-update-index.txt:87
#, priority:80
msgid "Set the execute permissions on the updated files."
msgstr "设置更新文件的执行权限。"

#. type: Labeled list
#: en/git-update-index.txt:88
#, ignore-same, no-wrap, priority:80
msgid "--[no-]assume-unchanged"
msgstr "--[no-]assume-unchanged"

#. type: Plain text
#: en/git-update-index.txt:100
#, priority:80
msgid "When this flag is specified, the object names recorded for the paths are not updated. Instead, this option sets/unsets the \"assume unchanged\" bit for the paths. When the \"assume unchanged\" bit is on, the user promises not to change the file and allows Git to assume that the working tree file matches what is recorded in the index. If you want to change the working tree file, you need to unset the bit to tell Git. This is sometimes helpful when working with a big project on a filesystem that has a very slow lstat(2) system call (e.g. cifs)."
msgstr "指定此标志后，路径记录的对象名称不会更新。 相反，该选项会设置/取消路径的 “假设不变” 位。 当 “假设不变” 位开启时，用户承诺不更改文件，并允许 Git 假设工作区文件与索引中记录的一致。 如果你想修改工作区文件，就需要取消设置来告诉 Git。 有时，在使用 lstat(2) 系统调用（如 cifs）非常慢的文件系统上处理大型项目时，这一点会很有用。"

#. type: Plain text
#: en/git-update-index.txt:105
#, priority:80
msgid "Git will fail (gracefully) in case it needs to modify this file in the index e.g. when merging in a commit; thus, in case the assumed-untracked file is changed upstream, you will need to handle the situation manually."
msgstr "如果 Git 需要在索引中修改该文件，例如在合并提交时，Git 会（优雅地）失败；因此，如果假定未跟踪的文件在上游被修改，你需要手动处理这种情况。"

#. type: Labeled list
#: en/git-update-index.txt:106
#, ignore-same, no-wrap, priority:80
msgid "--really-refresh"
msgstr "--really-refresh"

#. type: Plain text
#: en/git-update-index.txt:109
#, placeholders:'`--refresh`', priority:80
msgid "Like `--refresh`, but checks stat information unconditionally, without regard to the \"assume unchanged\" setting."
msgstr "类似于 `--refresh`，但无条件检查统计信息，不考虑 “假设不变” 设置。"

#. type: Labeled list
#: en/git-update-index.txt:110
#, ignore-same, no-wrap, priority:80
msgid "--[no-]skip-worktree"
msgstr "--[no-]skip-worktree"

#. type: Plain text
#: en/git-update-index.txt:115
#, priority:80
msgid "When one of these flags is specified, the object names recorded for the paths are not updated. Instead, these options set and unset the \"skip-worktree\" bit for the paths. See section \"Skip-worktree bit\" below for more information."
msgstr "如果指定了这些标志之一，路径记录的对象名称将不会更新。相反，这些选项会设置或取消路径的 “跳过工作树” 位。更多信息，请参阅下文 “跳过工作树位” 部分。"

#. type: Labeled list
#: en/git-update-index.txt:117
#, ignore-same, no-wrap, priority:80
msgid "--[no-]ignore-skip-worktree-entries"
msgstr "--[no-]ignore-skip-worktree-entries"

#. type: Plain text
#: en/git-update-index.txt:120
#, placeholders:'`--remove`', priority:80
msgid "Do not remove skip-worktree (AKA \"index-only\") entries even when the `--remove` option was specified."
msgstr "即使指定了 `--remove` 选项，也不会删除跳过工作区（又称 “仅索引” ）条目。"

#. type: Labeled list
#: en/git-update-index.txt:121
#, ignore-same, no-wrap, priority:80
msgid "--[no-]fsmonitor-valid"
msgstr "--[no-]fsmonitor-valid"

#. type: Plain text
#: en/git-update-index.txt:126
#, priority:80
msgid "When one of these flags is specified, the object names recorded for the paths are not updated. Instead, these options set and unset the \"fsmonitor valid\" bit for the paths. See section \"File System Monitor\" below for more information."
msgstr "如果指定了这些标志之一，则不会更新路径记录的对象名称。相反，这些选项会设置或取消路径的 \"fsmonitor valid\" 位。更多信息，请参阅下文 “文件系统监视器” 部分。"

#. type: Labeled list
#: en/git-update-index.txt:128
#, ignore-same, no-wrap, priority:80
msgid "--again"
msgstr "--again"

#. type: Plain text
#: en/git-update-index.txt:131
#, placeholders:'git update-index':'HEAD', priority:80
msgid "Runs 'git update-index' itself on the paths whose index entries are different from those of the `HEAD` commit."
msgstr "在索引项与 `HEAD` 提交不同的路径上运行 'git update-index'。"

#. type: Labeled list
#: en/git-update-index.txt:132
#, ignore-same, no-wrap, priority:80
msgid "--unresolve"
msgstr "--unresolve"

#. type: Plain text
#: en/git-update-index.txt:135
#, priority:80
msgid "Restores the 'unmerged' or 'needs updating' state of a file during a merge if it was cleared by accident."
msgstr "在合并过程中，如果意外清除了文件的 “未合并” 或 “需要更新” 状态，则恢复该状态。"

#. type: Labeled list
#: en/git-update-index.txt:136
#, ignore-same, no-wrap, priority:80
msgid "--info-only"
msgstr "--info-only"

#. type: Plain text
#: en/git-update-index.txt:140
#, priority:80
msgid "Do not create objects in the object database for all <file> arguments that follow this flag; just insert their object IDs into the index."
msgstr "不在对象数据库中为所有使用此标记的 <文件> 参数创建对象；只将其对象 ID 插入索引。"

#. type: Labeled list
#: en/git-update-index.txt:141
#, ignore-same, no-wrap, priority:80
msgid "--force-remove"
msgstr "--force-remove"

#. type: Plain text
#: en/git-update-index.txt:144
#, placeholders:'--remove', priority:80
msgid "Remove the file from the index even when the working directory still has such a file. (Implies --remove.)"
msgstr "从索引中删除文件，即使工作目录中仍有该文件。(意味着 --remove 。）"

#. type: Labeled list
#: en/git-update-index.txt:145
#, ignore-same, no-wrap, priority:80
msgid "--replace"
msgstr "--replace"

#. type: Plain text
#: en/git-update-index.txt:152
#, placeholders:'git update-index':'--replace', priority:80
msgid "By default, when a file `path` exists in the index, 'git update-index' refuses an attempt to add `path/file`. Similarly if a file `path/file` exists, a file `path` cannot be added. With --replace flag, existing entries that conflict with the entry being added are automatically removed with warning messages."
msgstr "默认情况下，当索引中存在文件 `path` 时，'git update-index' 会拒绝添加文件 `path/file` 的尝试。 同样，如果文件 `path/file` 已经存在，则无法添加文件 `path`。 使用 --replace 标志，与正在添加的条目冲突的现有条目会被自动删除，并伴有警告信息。"

#. type: Plain text
#: en/git-update-index.txt:157
#, priority:80
msgid "Instead of taking a list of paths from the command line, read a list of paths from the standard input. Paths are separated by LF (i.e. one path per line) by default."
msgstr "从标准输入中读取路径列表，而不是从命令行中读取路径列表。 默认情况下，路径之间用 LF 分隔（即每行一个路径）。"

#. type: Plain text
#: en/git-update-index.txt:160
#, priority:80
msgid "Report what is being added and removed from the index."
msgstr "报告索引中添加和删除的内容。"

#. type: Labeled list
#: en/git-update-index.txt:161
#, no-wrap, placeholders:'--index-version', priority:80
msgid "--index-version <n>"
msgstr "--index-version <n>"

#. type: Plain text
#: en/git-update-index.txt:167
#, placeholders:'`--verbose`', priority:80
msgid "Write the resulting index out in the named on-disk format version. Supported versions are 2, 3, and 4. The current default version is 2 or 3, depending on whether extra features are used, such as `git add -N`. With `--verbose`, also report the version the index file uses before and after this command."
msgstr "以指定的磁盘格式版本写出生成的索引。 支持的版本有 2、3 和 4。当前默认版本为 2 或 3，取决于是否使用了额外功能，如 `git add -N`。 使用 `--verbose`，还可以报告索引文件在此命令前后使用的版本。"

#. type: Plain text
#: en/git-update-index.txt:174
#, priority:80
msgid "Version 4 performs a simple pathname compression that reduces index size by 30%-50% on large repositories, which results in faster load time. Git supports it since version 1.8.0, released in October 2012, and support for it was added to libgit2 in 2016 and to JGit in 2020. Older versions of this manual page called it \"relatively young\", but it should be considered mature technology these days."
msgstr "版本 4 执行了简单的路径名压缩，可将大型软件仓库的索引大小减少 30%-50%，从而加快加载速度。 Git 从 2012 年 10 月发布的 1.8.0 版开始支持该功能，2016 年 libgit2 和 2020 年 JGit 也分别添加了对该功能的支持。 本手册页面的旧版本称其为 “相对年轻”，但如今应被视为成熟技术。"

#. type: Labeled list
#: en/git-update-index.txt:175
#, ignore-same, no-wrap, priority:80
msgid "--show-index-version"
msgstr "--show-index-version"

#. type: Plain text
#: en/git-update-index.txt:178
#, placeholders:'`--index-version`', priority:80
msgid "Report the index format version used by the on-disk index file. See `--index-version` above."
msgstr "报告磁盘索引文件使用的索引格式版本。 参见上文的 `--index-version`。"

#. type: Plain text
#: en/git-update-index.txt:182
#, placeholders:'`--stdin`':'`--index-info`', priority:80
msgid "Only meaningful with `--stdin` or `--index-info`; paths are separated with NUL character instead of LF."
msgstr "只有在使用 `--stdin` 或 `--index-info` 时才有意义；路径用 NUL 字符分隔，而不用 LF。"

#. type: Labeled list
#: en/git-update-index.txt:183
#, ignore-same, no-wrap, priority:80
msgid "--split-index"
msgstr "--split-index"

#. type: Labeled list
#: en/git-update-index.txt:184
#, ignore-same, no-wrap, priority:80
msgid "--no-split-index"
msgstr "--no-split-index"

#. type: Plain text
#: en/git-update-index.txt:189
#, placeholders:'`--split-index`':'$GIT_DIR', priority:80
msgid "Enable or disable split index mode. If split-index mode is already enabled and `--split-index` is given again, all changes in $GIT_DIR/index are pushed back to the shared index file."
msgstr "启用或禁用分割索引模式。如果已启用拆分索引模式，且再次给出 `--split-index`，则 $GIT_DIR/index 中的所有更改都会推送回共享索引文件。"

#. type: Plain text
#: en/git-update-index.txt:195
#, placeholders:'core.splitIndex':'linkgit:git-config[1]', priority:80
msgid "These options take effect whatever the value of the `core.splitIndex` configuration variable (see linkgit:git-config[1]). But a warning is emitted when the change goes against the configured value, as the configured value will take effect next time the index is read and this will remove the intended effect of the option."
msgstr "无论 `core.splitIndex` 配置变量（参见 linkgit:git-config[1]）的值如何，这些选项都会生效。但当更改与配置值相悖时，系统会发出警告，因为配置值会在下次读取索引时生效，这将消除选项的预期效果。"

#. type: Labeled list
#: en/git-update-index.txt:196
#, ignore-same, no-wrap, priority:80
msgid "--untracked-cache"
msgstr "--untracked-cache"

#. type: Labeled list
#: en/git-update-index.txt:197
#, ignore-same, no-wrap, priority:80
msgid "--no-untracked-cache"
msgstr "--no-untracked-cache"

# ERROR: --test-untracked-cache not found in translation
#. type: Plain text
#: en/git-update-index.txt:200
#, placeholders:'`--test-untracked-cache`', priority:80
msgid "Enable or disable untracked cache feature. Please use `--test-untracked-cache` before enabling it."
msgstr "启用或禁用非跟踪缓存功能。启用前请使用 `--test-untracked-cache`。"

#. type: Plain text
#: en/git-update-index.txt:206
#, placeholders:'core.untrackedCache':'linkgit:git-config[1]', priority:80
msgid "These options take effect whatever the value of the `core.untrackedCache` configuration variable (see linkgit:git-config[1]). But a warning is emitted when the change goes against the configured value, as the configured value will take effect next time the index is read and this will remove the intended effect of the option."
msgstr "无论 `core.untrackedCache` 配置变量的值是多少，这些选项都会生效（参见 linkgit:git-config[1]）。但当更改与配置值相悖时，系统会发出警告，因为配置值会在下次读取索引时生效，从而消除选项的预期效果。"

#. type: Labeled list
#: en/git-update-index.txt:207
#, ignore-same, no-wrap, priority:80
msgid "--test-untracked-cache"
msgstr "--test-untracked-cache"

# ERROR: --force-untracked-cache not found in translation
#. type: Plain text
#: en/git-update-index.txt:216
#, placeholders:'`--untracked-cache`':'`--force-untracked-cache`':'core.untrackedCache', priority:80
msgid "Only perform tests on the working directory to make sure untracked cache can be used. You have to manually enable untracked cache using `--untracked-cache` or `--force-untracked-cache` or the `core.untrackedCache` configuration variable afterwards if you really want to use it. If a test fails the exit code is 1 and a message explains what is not working as needed, otherwise the exit code is 0 and OK is printed."
msgstr "只在工作目录下进行测试，以确保可以使用非跟踪缓存。如果真的要使用非跟踪缓存，必须使用 `--untracked-cache` 、`--force-untracked-cache` 或 `core.untrackedCache` 配置变量手动启用它。如果测试失败，则退出代码为 1，并根据需要给出一条信息，说明测试失败的原因，否则退出代码为 0，并打印 OK。"

#. type: Labeled list
#: en/git-update-index.txt:217
#, ignore-same, no-wrap, priority:80
msgid "--force-untracked-cache"
msgstr "--force-untracked-cache"

# ERROR: --test-untracked-cache not found in translation
#. type: Plain text
#: en/git-update-index.txt:222
#, placeholders:'`--untracked-cache`':'`--untracked-cache`':'`--test-untracked-cache`', priority:80
msgid "Same as `--untracked-cache`. Provided for backwards compatibility with older versions of Git where `--untracked-cache` used to imply `--test-untracked-cache` but this option would enable the extension unconditionally."
msgstr "与 `--untracked-cache` 相同。提供该选项是为了向后兼容旧版本的 Git，在旧版本中，`--untracked-cache` 意味着 `--test-untracked-cache` ，但该选项将无条件启用扩展。"

#. type: Labeled list
#: en/git-update-index.txt:223
#, ignore-same, no-wrap, priority:80
msgid "--fsmonitor"
msgstr "--fsmonitor"

#. type: Labeled list
#: en/git-update-index.txt:224
#, ignore-same, no-wrap, priority:80
msgid "--no-fsmonitor"
msgstr "--no-fsmonitor"

#. type: Plain text
#: en/git-update-index.txt:231
#, placeholders:'core.fsmonitor':'linkgit:git-config[1]', priority:80
msgid "Enable or disable files system monitor feature. These options take effect whatever the value of the `core.fsmonitor` configuration variable (see linkgit:git-config[1]). But a warning is emitted when the change goes against the configured value, as the configured value will take effect next time the index is read and this will remove the intended effect of the option."
msgstr "启用或禁用文件系统监视器功能。无论 `core.fsmonitor` 配置变量的值是多少，这些选项都会生效（参见 linkgit:git-config[1]）。但如果更改与配置值相反，则会发出警告，因为配置值会在下次读取索引时生效，从而消除选项的预期效果。"

#. type: Plain text
#: en/git-update-index.txt:241
#, priority:80
msgid "Files to act on. Note that files beginning with '.' are discarded. This includes `./file` and `dir/./file`. If you don't want this, then use cleaner names. The same applies to directories ending '/' and paths with '//'"
msgstr "要处理的文件。 请注意，以 '. ' 开头的文件将被丢弃。这包括 `./file` 和 `dir/./file` 。如果不想这样，可以使用更干净的名称。 这同样适用于以 '/' 结尾的目录和以 '//' 结尾的路径"

#. type: Title -
#: en/git-update-index.txt:243
#, no-wrap, placeholders:'--REFRESH', priority:80
msgid "USING --REFRESH"
msgstr "使用 --REFRESH"

#. type: Plain text
#: en/git-update-index.txt:249
#, placeholders:'`--refresh`', priority:80
msgid "`--refresh` does not calculate a new sha1 file or bring the index up to date for mode/content changes. But what it *does* do is to \"re-match\" the stat information of a file with the index, so that you can refresh the index for a file that hasn't been changed but where the stat entry is out of date."
msgstr "`--refresh` 选项不会计算新的 sha1 文件，也不会为模式/内容更改更新索引。但是，它要做的是将文件的统计信息与索引 “重新匹配”，以便您可以刷新未更改但统计条目已过期的文件的索引。"

#. type: Plain text
#: en/git-update-index.txt:252
#, placeholders:'git read-tree', priority:80
msgid "For example, you'd want to do this after doing a 'git read-tree', to link up the stat index details with the proper files."
msgstr "例如，您需要在执行 'git read-tree' 后执行此操作，以便将统计索引详情与适当的文件联系起来。"

#. type: Title -
#: en/git-update-index.txt:254
#, no-wrap, placeholders:'--CACHEINFO':'--INFO-ONLY', priority:80
msgid "USING --CACHEINFO OR --INFO-ONLY"
msgstr "使用 --CACHEINFO 或 --INFO-ONLY"

#. type: Plain text
#: en/git-update-index.txt:258
#, placeholders:'`--cacheinfo`', priority:80
msgid "`--cacheinfo` is used to register a file that is not in the current working directory. This is useful for minimum-checkout merging."
msgstr "`--cacheinfo` 用于注册不在当前工作目录中的文件。 这对最小检查合并很有用。"

#. type: Plain text
#: en/git-update-index.txt:260
#, priority:80
msgid "To pretend you have a file at path with mode and sha1, say:"
msgstr "假设路径下有一个文件，带有模式和 sha1，例如："

#. type: delimited block -
#: en/git-update-index.txt:263
#, no-wrap, placeholders:'git update-index':'--add':'--cacheinfo', priority:80
msgid "$ git update-index --add --cacheinfo <mode>,<sha1>,<path>\n"
msgstr "$ git update-index --add --cacheinfo <模式>,<sha1>,<路径>\n"

#. type: Plain text
#: en/git-update-index.txt:267
#, placeholders:'`--info-only`', priority:80
msgid "`--info-only` is used to register files without placing them in the object database. This is useful for status-only repositories."
msgstr "`--info-only` 用于注册文件而不将其放入对象数据库。 这对仅有状态的仓库非常有用。"

#. type: Plain text
#: en/git-update-index.txt:273
#, placeholders:'`--cacheinfo`':'`--info-only`':'`--cacheinfo`':'`--info-only`', priority:80
msgid "Both `--cacheinfo` and `--info-only` behave similarly: the index is updated but the object database isn't. `--cacheinfo` is useful when the object is in the database but the file isn't available locally. `--info-only` is useful when the file is available, but you do not wish to update the object database."
msgstr "`--cacheinfo` 和 `--info-only` 的行为类似：索引会更新，但对象数据库不会更新。 当对象在数据库中但文件在本地不可用时，`--cacheinfo` 很有用。 当文件可用但不希望更新对象数据库时，`--info-only` 很有用。"

#. type: Title -
#: en/git-update-index.txt:276
#, no-wrap, placeholders:'--INDEX-INFO', priority:80
msgid "USING --INDEX-INFO"
msgstr "使用 --INDEX-INFO"

# ERROR: --index-info not found in translation
#. type: Plain text
#: en/git-update-index.txt:281
#, placeholders:'`--index-info`', priority:80
msgid "`--index-info` is a more powerful mechanism that lets you feed multiple entry definitions from the standard input, and designed specifically for scripts. It can take inputs of three formats:"
msgstr "`--index-info` 是一种更强大的机制，可让你从标准输入中输入多个条目定义，专为脚本设计。 它可以接受三种格式的输入："

#. type: Plain text
#: en/git-update-index.txt:283
#, priority:80
msgid "mode SP type SP sha1 TAB path"
msgstr "模式 SP 类型 SP sha1 TAB 路径"

#. type: Plain text
#: en/git-update-index.txt:285
#, placeholders:'git ls-tree', priority:80
msgid "This format is to stuff `git ls-tree` output into the index."
msgstr "这种格式是将 `git ls-tree` 输出塞入索引。"

#. type: Plain text
#: en/git-update-index.txt:287
#, priority:80
msgid "mode SP sha1 SP stage TAB path"
msgstr "模式 SP sha1 SP 阶段 TAB 路径"

#. type: Plain text
#: en/git-update-index.txt:290
#, placeholders:'git ls-files':'--stage', priority:80
msgid "This format is to put higher order stages into the index file and matches 'git ls-files --stage' output."
msgstr "这种格式是为了将更高阶的阶段放入索引文件，与 'git ls-files --stage' 的输出相匹配。"

#. type: Plain text
#: en/git-update-index.txt:292
#, priority:80
msgid "mode SP sha1 TAB path"
msgstr "模式 SP 类型 SP sha1 TAB 路径"

#. type: Plain text
#: en/git-update-index.txt:295
#, placeholders:'--index-info`', priority:80
msgid "This format is no longer produced by any Git command, but is and will continue to be supported by `update-index --index-info`."
msgstr "任何 Git 命令都不再生成这种格式，但 `update-index --index-info` 将继续支持这种格式。"

#. type: Plain text
#: en/git-update-index.txt:299
#, priority:80
msgid "To place a higher stage entry to the index, the path should first be removed by feeding a mode=0 entry for the path, and then feeding necessary input lines in the third format."
msgstr "若要在索引中输入更高一级的条目，应首先删除路径，为路径输入模式 =0 的条目，然后按第三种格式输入必要的输入行。"

#. type: Plain text
#: en/git-update-index.txt:301
#, priority:80
msgid "For example, starting with this index:"
msgstr "例如，从这个索引开始："

#. type: delimited block -
#: en/git-update-index.txt:305
#, no-wrap, placeholders:'git ls-files', priority:80
msgid ""
"$ git ls-files -s\n"
"100644 8a1218a1024a212bb3db30becd860315f9f3ac52 0       frotz\n"
msgstr ""
"$ git ls-files -s\n"
"100644 8a1218a1024a212bb3db30becd860315f9f3ac52 0       frotz\n"

#. type: Plain text
#: en/git-update-index.txt:308
#, placeholders:'`--index-info`', priority:80
msgid "you can feed the following input to `--index-info`:"
msgstr "你可以向 `--index-info` 输入以下内容："

#. type: delimited block -
#: en/git-update-index.txt:314
#, no-wrap, placeholders:'git update-index':'--index-info', priority:80
msgid ""
"$ git update-index --index-info\n"
"0 0000000000000000000000000000000000000000\tfrotz\n"
"100644 8a1218a1024a212bb3db30becd860315f9f3ac52 1\tfrotz\n"
"100755 8a1218a1024a212bb3db30becd860315f9f3ac52 2\tfrotz\n"
msgstr ""
"$ git update-index --index-info\n"
"0 0000000000000000000000000000000000000000\tfrotz\n"
"100644 8a1218a1024a212bb3db30becd860315f9f3ac52 1\tfrotz\n"
"100755 8a1218a1024a212bb3db30becd860315f9f3ac52 2\tfrotz\n"

#. type: Plain text
#: en/git-update-index.txt:320
#, priority:80
msgid "The first line of the input feeds 0 as the mode to remove the path; the SHA-1 does not matter as long as it is well formatted. Then the second and third line feeds stage 1 and stage 2 entries for that path. After the above, we would end up with this:"
msgstr "输入的第一行输入 0 作为删除路径的模式；只要格式正确，SHA-1 并不重要。 然后，第二行和第三行分别输入该路径的阶段 1 和阶段 2 条目。 经过上述操作后，我们将得到以下结果："

#. type: delimited block -
#: en/git-update-index.txt:325
#, no-wrap, placeholders:'git ls-files', priority:80
msgid ""
"$ git ls-files -s\n"
"100644 8a1218a1024a212bb3db30becd860315f9f3ac52 1\tfrotz\n"
"100755 8a1218a1024a212bb3db30becd860315f9f3ac52 2\tfrotz\n"
msgstr ""
"$ git ls-files -s\n"
"100644 8a1218a1024a212bb3db30becd860315f9f3ac52 1\tfrotz\n"
"100755 8a1218a1024a212bb3db30becd860315f9f3ac52 2\tfrotz\n"

#. type: Title -
#: en/git-update-index.txt:329
#, no-wrap, priority:80
msgid "USING ``ASSUME UNCHANGED'' BIT"
msgstr "使用 ''假设不变'' 位"

#. type: Plain text
#: en/git-update-index.txt:344
#, placeholders:'st_mtime', priority:80
msgid "Many operations in Git depend on your filesystem to have an efficient `lstat(2)` implementation, so that `st_mtime` information for working tree files can be cheaply checked to see if the file contents have changed from the version recorded in the index file. Unfortunately, some filesystems have inefficient `lstat(2)`. If your filesystem is one of them, you can set \"assume unchanged\" bit to paths you have not changed to cause Git not to do this check. Note that setting this bit on a path does not mean Git will check the contents of the file to see if it has changed -- it makes Git to omit any checking and assume it has *not* changed. When you make changes to working tree files, you have to explicitly tell Git about it by dropping \"assume unchanged\" bit, either before or after you modify them."
msgstr "Git 中的许多操作都依赖于文件系统高效的 `lstat(2)` 实现，这样就能以低成本检查工作树文件的 `st_mtime` 信息，查看文件内容是否与索引文件中记录的版本有所变化。 遗憾的是，有些文件系统的 `lstat(2)` 效率很低。 如果你的文件系统属于这种情况，你可以在没有更改过的路径上设置 “假设未更改” 位，这样 Git 就不会进行这种检查了。 需要注意的是，在路径上设置这个位并不意味着 Git 会检查文件的内容是否有变化，而是让 Git 忽略任何检查，假设文件 *没有* 变化。 当你对工作区文件进行修改时，你必须在修改之前或之后，通过丢弃 “假定不变” 位来明确告知 Git。"

#. type: Plain text
#: en/git-update-index.txt:349
#, placeholders:'`--assume-unchanged`':'`--no-assume-unchanged`':'git ls-files':'linkgit:git-ls-files[1]', priority:80
msgid "In order to set \"assume unchanged\" bit, use `--assume-unchanged` option. To unset, use `--no-assume-unchanged`. To see which files have the \"assume unchanged\" bit set, use `git ls-files -v` (see linkgit:git-ls-files[1])."
msgstr "要设置 “假设不变” 位，请使用 `--assume-unchanged` 选项。 要取消设置，使用 `--no-assume-unchanged` 选项。使用 `git ls-files -v` 查看哪些文件设置了 “假设不变” 位（参见 linkgit:git-ls-files[1]）。"

#. type: Plain text
#: en/git-update-index.txt:359
#, ignore-ellipsis, placeholders:'core.ignorestat':'git update-index':'--index':'git checkout-index':'git read-tree':'git update-index':'--refresh`':'git update-index':'--really-refresh`', priority:80
msgid "The command looks at `core.ignorestat` configuration variable. When this is true, paths updated with `git update-index paths...` and paths updated with other Git commands that update both index and working tree (e.g. 'git apply --index', 'git checkout-index -u', and 'git read-tree -u') are automatically marked as \"assume unchanged\". Note that \"assume unchanged\" bit is *not* set if `git update-index --refresh` finds the working tree file matches the index (use `git update-index --really-refresh` if you want to mark them as \"assume unchanged\")."
msgstr "该命令会查看 `core.ignorestat` 配置变量。 为真时，用 `git update-index paths...` 更新的路径，以及用其他同时更新索引和工作区的 Git 命令（例如 'git apply --index', 'git checkout-index -u', 和 'git read-tree -u'）更新的路径，都会被自动标记为 “假设不变”。 请注意，如果 `git update-index --refresh` 发现工作区文件与索引匹配，“假设不变” 位将不会被设置（如果想标记为 “假设不变”，请使用 `git update-index --really-refresh`）。"

#. type: Plain text
#: en/git-update-index.txt:363
#, priority:80
msgid "Sometimes users confuse the assume-unchanged bit with the skip-worktree bit. See the final paragraph in the \"Skip-worktree bit\" section below for an explanation of the differences."
msgstr "有时用户会将假定不变位与跳过工作区位混淆。 关于两者的区别，请参阅下文 “跳过工作区位” 部分的最后一段。"

#. type: Plain text
#: en/git-update-index.txt:368
#, priority:80
msgid "To update and refresh only the files already checked out:"
msgstr "只更新和刷新已签出的文件："

#. type: Labeled list
#: en/git-update-index.txt:373
#, no-wrap, placeholders:'core.ignorestat', priority:80
msgid "On an inefficient filesystem with `core.ignorestat` set"
msgstr "在设置了 `core.ignorestat` 的低效文件系统上"

#. type: delimited block -
#: en/git-update-index.txt:389
#, no-wrap, placeholders:'git update-index':'--really-refresh':'git update-index':'--no-assume-unchanged':'--name-only':'--name-only':'git update-index':'--name-only':'--name-only':'git update-index':'--no-assume-unchanged':'--name-only', priority:80
msgid ""
"$ git update-index --really-refresh              <1>\n"
"$ git update-index --no-assume-unchanged foo.c   <2>\n"
"$ git diff --name-only                           <3>\n"
"$ edit foo.c\n"
"$ git diff --name-only                           <4>\n"
"M foo.c\n"
"$ git update-index foo.c                         <5>\n"
"$ git diff --name-only                           <6>\n"
"$ edit foo.c\n"
"$ git diff --name-only                           <7>\n"
"$ git update-index --no-assume-unchanged foo.c   <8>\n"
"$ git diff --name-only                           <9>\n"
"M foo.c\n"
msgstr ""
"$ git update-index --really-refresh              <1>\n"
"$ git update-index --no-assume-unchanged foo.c   <2>\n"
"$ git diff --name-only                           <3>\n"
"$ edit foo.c\n"
"$ git diff --name-only                           <4>\n"
"M foo.c\n"
"$ git update-index foo.c                         <5>\n"
"$ git diff --name-only                           <6>\n"
"$ edit foo.c\n"
"$ git diff --name-only                           <7>\n"
"$ git update-index --no-assume-unchanged foo.c   <8>\n"
"$ git diff --name-only                           <9>\n"
"M foo.c\n"

#. type: Plain text
#: en/git-update-index.txt:392
#, priority:80
msgid "forces lstat(2) to set \"assume unchanged\" bits for paths that match index."
msgstr "强制 lstat(2) 设置与索引匹配的路径的 “假设不变” 位。"

#. type: Plain text
#: en/git-update-index.txt:393
#, priority:80
msgid "mark the path to be edited."
msgstr "标记要编辑的路径。"

#. type: Plain text
#: en/git-update-index.txt:394
#, priority:80
msgid "this does lstat(2) and finds index matches the path."
msgstr "执行 lstat(2)，找到与路径匹配的索引。"

#. type: Plain text
#: en/git-update-index.txt:395
#, priority:80
msgid "this does lstat(2) and finds index does *not* match the path."
msgstr "这将执行 lstat(2)，发现索引与路径 *不* 匹配。"

#. type: Plain text
#: en/git-update-index.txt:396
#, priority:80
msgid "registering the new version to index sets \"assume unchanged\" bit."
msgstr "将新版本注册到索引中会设置 “假设不变” 位。"

#. type: Plain text
#: en/git-update-index.txt:397
#, priority:80
msgid "and it is assumed unchanged."
msgstr "并假定其保持不变。"

#. type: Plain text
#: en/git-update-index.txt:398
#, priority:80
msgid "even after you edit it."
msgstr "即使在编辑之后也是如此。"

#. type: Plain text
#: en/git-update-index.txt:399
#, priority:80
msgid "you can tell about the change after the fact."
msgstr "你可以在事后了解变化。"

#. type: Plain text
#: en/git-update-index.txt:400
#, priority:80
msgid "now it checks with lstat(2) and finds it has been changed."
msgstr "现在它使用 lstat(2) 进行检查，发现它已被更改。"

#. type: Title -
#: en/git-update-index.txt:403
#, no-wrap, priority:80
msgid "SKIP-WORKTREE BIT"
msgstr "跳过工作区位"

#. type: Plain text
#: en/git-update-index.txt:409
#, priority:80
msgid "Skip-worktree bit can be defined in one (long) sentence: Tell git to avoid writing the file to the working directory when reasonably possible, and treat the file as unchanged when it is not present in the working directory."
msgstr "跳过工作区位可以用一句（长）话来定义：告诉 Git 在合理的情况下避免将文件写入工作目录，当文件不在工作目录中时，将其视为不变文件。"

#. type: Plain text
#: en/git-update-index.txt:412
#, priority:80
msgid "Note that not all git commands will pay attention to this bit, and some only partially support it."
msgstr "请注意，并非所有的 Git 命令都会关注这一点，有些命令仅部分支持这一点。"

#. type: Plain text
#: en/git-update-index.txt:421
#, placeholders:'linkgit:git-sparse-checkout[1]':'linkgit:git-sparse-checkout[1]', priority:80
msgid "The update-index flags and the read-tree capabilities relating to the skip-worktree bit predated the introduction of the linkgit:git-sparse-checkout[1] command, which provides a much easier way to configure and handle the skip-worktree bits. If you want to reduce your working tree to only deal with a subset of the files in the repository, we strongly encourage the use of linkgit:git-sparse-checkout[1] in preference to the low-level update-index and read-tree primitives."
msgstr "linkgit:git-sparse-checkout[1] 命令为配置和处理跳过工作树位提供了更简便的方法。 如果你想缩减工作区，只处理仓库中的部分文件，我们强烈建议你使用 linkgit:git-sparse-checkout[1] 而不是底层的 update-index 和 read-tree 原语。"

#. type: Plain text
#: en/git-update-index.txt:432
#, priority:80
msgid "The primary purpose of the skip-worktree bit is to enable sparse checkouts, i.e. to have working directories with only a subset of paths present. When the skip-worktree bit is set, Git commands (such as `switch`, `pull`, `merge`) will avoid writing these files. However, these commands will sometimes write these files anyway in important cases such as conflicts during a merge or rebase. Git commands will also avoid treating the lack of such files as an intentional deletion; for example `git add -u` will not stage a deletion for these files and `git commit -a` will not make a commit deleting them either."
msgstr "跳过工作树位的主要目的是实现稀疏签出，即工作目录中只存在路径的子集。 设置了跳过工作树位后，Git 命令（如 `switch` 、`pull` 、`merge` ）将避免写入这些文件。 不过，在一些重要的情况下，比如合并或重置过程中的冲突，这些命令有时还是会写入这些文件。 Git 命令也会避免将缺少这些文件视为有意删除；例如 `git add -u` 不会阶段性删除这些文件，而 `git commit -a` 也不会提交删除这些文件。"

#. type: Plain text
#: en/git-update-index.txt:446
#, placeholders:'git sparse-checkout':'core.sparseCheckout', priority:80
msgid "Although this bit looks similar to assume-unchanged bit, its goal is different. The assume-unchanged bit is for leaving the file in the working tree but having Git omit checking it for changes and presuming that the file has not been changed (though if it can determine without stat'ing the file that it has changed, it is free to record the changes). skip-worktree tells Git to ignore the absence of the file, avoid updating it when possible with commands that normally update much of the working directory (e.g. `checkout`, `switch`, `pull`, etc.), and not have its absence be recorded in commits. Note that in sparse checkouts (setup by `git sparse-checkout` or by configuring core.sparseCheckout to true), if a file is marked as skip-worktree in the index but is found in the working tree, Git will clear the skip-worktree bit for that file."
msgstr "虽然这个位看起来与假定未修改位相似，但目标不同。 假定未修改位用于将文件保留在工作树中，但让 Git 忽略检查文件是否被修改，并假定文件未被修改（当然，如果 Git 可以在不统计文件的情况下确定文件已被修改，它也可以自由地记录这些修改）。 skip-worktree 则告诉 Git 忽略文件的缺失，尽可能避免使用通常会更新大部分工作目录的命令（如 `checkout` 、`switch` 、`pull` 等）更新文件，并且不在提交中记录文件的缺失。 需要注意的是，在稀疏签出中（通过 `git sparse-checkout` 或将 core.sparseCheckout 配置为 true 设置），如果某个文件在索引中被标记为跳过工作区，但在工作区中找到了，Git 会清除该文件的跳过工作区位。"

#. type: Title -
#: en/git-update-index.txt:448
#, no-wrap, priority:80
msgid "SPLIT INDEX"
msgstr "SPLIT INDEX"

#. type: Plain text
#: en/git-update-index.txt:452
#, priority:80
msgid "This mode is designed for repositories with very large indexes, and aims at reducing the time it takes to repeatedly write these indexes."
msgstr "该模式专为拥有超大索引的仓库而设计，旨在减少重复写入这些索引所需的时间。"

#. type: Plain text
#: en/git-update-index.txt:457
#, placeholders:'$GIT_DIR':'$GIT_DIR':'$GIT_DIR', priority:80
msgid "In this mode, the index is split into two files, $GIT_DIR/index and $GIT_DIR/sharedindex.<SHA-1>. Changes are accumulated in $GIT_DIR/index, the split index, while the shared index file contains all index entries and stays unchanged."
msgstr "在这种模式下，索引被分割成两个文件：$GIT_DIR/index 和 $GIT_DIR/sharedindex.<SHA-1>。更改会累积到分割索引的 $GIT_DIR/index，而共享索引文件则包含所有索引条目并保持不变。"

#. type: Plain text
#: en/git-update-index.txt:462
#, placeholders:'splitIndex.maxPercentChange':'linkgit:git-config[1]', priority:80
msgid "All changes in the split index are pushed back to the shared index file when the number of entries in the split index reaches a level specified by the splitIndex.maxPercentChange config variable (see linkgit:git-config[1])."
msgstr "当拆分索引中的条目数达到 splitIndex.maxPercentChange 配置变量（参见 linkgit:git-config[1]）指定的水平时，拆分索引中的所有更改都会被推送回共享索引文件。"

#. type: Plain text
#: en/git-update-index.txt:467
#, placeholders:'splitIndex.sharedIndexExpire':'linkgit:git-config[1]', priority:80
msgid "Each time a new shared index file is created, the old shared index files are deleted if their modification time is older than what is specified by the splitIndex.sharedIndexExpire config variable (see linkgit:git-config[1])."
msgstr "每次创建新的共享索引文件时，如果旧的共享索引文件的修改时间早于 splitIndex.sharedIndexExpire 配置变量（参见 linkgit:git-config[1]）的指定时间，则会被删除。"

#. type: Plain text
#: en/git-update-index.txt:471
#, priority:80
msgid "To avoid deleting a shared index file that is still used, its modification time is updated to the current time every time a new split index based on the shared index file is either created or read from."
msgstr "为避免删除仍在使用的共享索引文件，每次创建或读取基于共享索引文件的新拆分索引时，都会将其修改时间更新为当前时间。"

#. type: Title -
#: en/git-update-index.txt:473
#, no-wrap, priority:80
msgid "UNTRACKED CACHE"
msgstr "UNTRACKED CACHE"

#. type: Plain text
#: en/git-update-index.txt:477
#, priority:80
msgid "This cache is meant to speed up commands that involve determining untracked files such as `git status`."
msgstr "该缓存的目的是加快涉及确定未跟踪文件（如 `git status` ）的命令的执行速度。"

#. type: Plain text
#: en/git-update-index.txt:484
#, placeholders:'st_mtime', priority:80
msgid "This feature works by recording the mtime of the working tree directories and then omitting reading directories and stat calls against files in those directories whose mtime hasn't changed. For this to work the underlying operating system and file system must change the `st_mtime` field of directories if files in the directory are added, modified or deleted."
msgstr "该功能的工作原理是记录工作树目录的 mtime，然后省略读取目录和对 mtime 未发生变化的目录中文件的 stat 调用。要实现这一功能，如果目录中的文件被添加、修改或删除，底层操作系统和文件系统必须更改目录的 `st_mtime` 字段。"

#. type: Plain text
#: en/git-update-index.txt:489
#, placeholders:'`--test-untracked-cache`':'`--untracked-cache`', priority:80
msgid "You can test whether the filesystem supports that with the `--test-untracked-cache` option. The `--untracked-cache` option used to implicitly perform that test in older versions of Git, but that's no longer the case."
msgstr "你可以使用`--test-untracked-cache` 选项来测试文件系统是否支持该功能。在旧版本的 Git 中，`--untracked-cache` 选项曾隐含地执行该测试，但现在已不再如此。"

#. type: Plain text
#: en/git-update-index.txt:497
#, placeholders:'core.untrackedCache':'linkgit:git-config[1]':'`--untracked-cache`':'git update-index':'$HOME', priority:80
msgid "If you want to enable (or disable) this feature, it is easier to use the `core.untrackedCache` configuration variable (see linkgit:git-config[1]) than using the `--untracked-cache` option to `git update-index` in each repository, especially if you want to do so across all repositories you use, because you can set the configuration variable to `true` (or `false`) in your `$HOME/.gitconfig` just once and have it affect all repositories you touch."
msgstr "如果你想启用（或禁用）这项功能，使用 `core.untrackedCache` 配置变量（参见 linkgit:git-config[1]）比在每个版本库中使用 `--untracked-cache` 选项来 `git update-index` 要容易得多，尤其是如果你想在你使用的所有仓库中都这样做的话，因为你只需在 `$HOME/.gitconfig` 中将配置变量设置为 `true` （或 `false` ）一次，它就会影响你接触的所有仓库。"

#. type: Plain text
#: en/git-update-index.txt:503
#, placeholders:'core.untrackedCache', priority:80
msgid "When the `core.untrackedCache` configuration variable is changed, the untracked cache is added to or removed from the index the next time a command reads the index; while when `--[no-|force-]untracked-cache` are used, the untracked cache is immediately added to or removed from the index."
msgstr "当更改 `core.untrackedCache` 配置变量时，未跟踪缓存会在下一次命令读取索引时添加到索引中或从索引中移除；而当使用 `--[no-|force-]untracked-cache` 时，未跟踪缓存会立即添加到索引中或从索引中移除。"

#. type: Plain text
#: en/git-update-index.txt:510
#, placeholders:'core.untrackedCache':'git.git', priority:80
msgid "Before 2.17, the untracked cache had a bug where replacing a directory with a symlink to another directory could cause it to incorrectly show files tracked by git as untracked. See the \"status: add a failing test showing a core.untrackedCache bug\" commit to git.git. A workaround for that is (and this might work for other undiscovered bugs in the future):"
msgstr "在 2.17 之前，untracked 缓存有一个 bug，即用指向另一个目录的符号链接替换一个目录会导致它错误地将 Git 追踪的文件显示为未追踪。参见 git.git 上的 \"status: add a failing test showing a core.untrackedCache bug\" 。解决这个问题的方法是（将来也可能适用于其他未被发现的 bug）："

#. type: delimited block -
#: en/git-update-index.txt:513
#, no-wrap, placeholders:'core.untrackedCache', priority:80
msgid "$ git -c core.untrackedCache=false status\n"
msgstr "$ git -c core.untrackedCache=false status\n"

#. type: Plain text
#: en/git-update-index.txt:519
#, priority:80
msgid "This bug has also been shown to affect non-symlink cases of replacing a directory with a file when it comes to the internal structures of the untracked cache, but no case has been reported where this resulted in wrong \"git status\" output."
msgstr "当涉及到非跟踪缓存的内部结构时，这个 bug 也会影响到用文件替换目录的非符号链接情况，但还没有报告说这会导致错误的 \"git status\" 输出。"

#. type: Plain text
#: en/git-update-index.txt:525
#, priority:80
msgid "There are also cases where existing indexes written by git versions before 2.17 will reference directories that don't exist anymore, potentially causing many \"could not open directory\" warnings to be printed on \"git status\". These are new warnings for existing issues that were previously silently discarded."
msgstr "在某些情况下，由 2.17 之前版本的 Git 编写的现有索引会引用已不存在的目录，这可能会在 \"git status\" 上打印出许多 \"could not open directory\" （无法打开目录）的警告。这些警告是针对以前被默默丢弃的现有问题的新警告。"

#. type: Plain text
#: en/git-update-index.txt:529
#, placeholders:'core.untrackedCache', priority:80
msgid "As with the bug described above the solution is to one-off do a \"git status\" run with `core.untrackedCache=false` to flush out the leftover bad data."
msgstr "与上述错误一样，解决办法是一次性运行 `core.untrackedCache=false` 的 \"git status\" ，以清除剩余的坏数据。"

#. type: Title -
#: en/git-update-index.txt:531
#, no-wrap, priority:80
msgid "FILE SYSTEM MONITOR"
msgstr "文件系统监视器"

#. type: Plain text
#: en/git-update-index.txt:535
#, priority:80
msgid "This feature is intended to speed up git operations for repos that have large working directories."
msgstr "该功能旨在加快工作目录较大的仓库的 Git 操作速度。"

#. type: Plain text
#: en/git-update-index.txt:542
#, placeholders:'linkgit:git-fsmonitor{litdd}daemon[1]':'linkgit:githooks[5]', priority:80
msgid "It enables git to work together with a file system monitor (see linkgit:git-fsmonitor{litdd}daemon[1] and the \"fsmonitor-watchman\" section of linkgit:githooks[5]) that can inform it as to what files have been modified. This enables git to avoid having to lstat() every file to find modified files."
msgstr "它能让 Git 与文件系统监视器（参见 linkgit:git-fsmonitor{litdd}daemon[1] 和 linkgit:githooks[5] 中的 \"fsmonitor-watchman\" 部分）协同工作，监视器会告诉 Git 哪些文件被修改了。这样，Git 就不必通过 lstat() 来查找修改过的文件了。"

#. type: Plain text
#: en/git-update-index.txt:546
#, priority:80
msgid "When used in conjunction with the untracked cache, it can further improve performance by avoiding the cost of scanning the entire working directory looking for new files."
msgstr "与非跟踪缓存结合使用时，可以避免扫描整个工作目录寻找新文件的成本，从而进一步提高性能。"

#. type: Plain text
#: en/git-update-index.txt:554
#, placeholders:'core.fsmonitor':'linkgit:git-config[1]':'`--fsmonitor`':'git update-index':'$HOME', priority:80
msgid "If you want to enable (or disable) this feature, it is easier to use the `core.fsmonitor` configuration variable (see linkgit:git-config[1]) than using the `--fsmonitor` option to `git update-index` in each repository, especially if you want to do so across all repositories you use, because you can set the configuration variable in your `$HOME/.gitconfig` just once and have it affect all repositories you touch."
msgstr "如果您想启用（或禁用）此功能，使用 `core.fsmonitor` 配置变量（参见 linkgit:git-config[1]）比在每个仓库中使用 `-git update-index` 的 `--fsmonitor` 选项更方便，尤其是如果您想在您使用的所有仓库中启用（或禁用）此功能，因为您只需在 `$HOME/.gitconfig` 中设置一次配置变量，就能影响您接触的所有仓库。"

#. type: Plain text
#: en/git-update-index.txt:559
#, placeholders:'core.fsmonitor', priority:80
msgid "When the `core.fsmonitor` configuration variable is changed, the file system monitor is added to or removed from the index the next time a command reads the index. When `--[no-]fsmonitor` are used, the file system monitor is immediately added to or removed from the index."
msgstr "更改 `core.fsmonitor` 配置变量后，文件系统监视器将在下一次命令读取索引时添加到索引或从索引中移除。当使用 `--[no-]fsmonitor` 时，文件系统监视器会立即添加到索引或从索引中移除。"

#. type: Plain text
#: en/git-update-index.txt:570
#, placeholders:'core.filemode':'linkgit:git-config[1]':'git update-index':'--chmod=', priority:80
msgid "The command honors `core.filemode` configuration variable. If your repository is on a filesystem whose executable bits are unreliable, this should be set to 'false' (see linkgit:git-config[1]). This causes the command to ignore differences in file modes recorded in the index and the file mode on the filesystem if they differ only on executable bit. On such an unfortunate filesystem, you may need to use 'git update-index --chmod='."
msgstr "命令尊重 `core.filemode` 配置变量。 如果您的仓库位于可执行位不可靠的文件系统上则应将其设置为 'false'（参见 linkgit:git-config[1]）。 如果索引中记录的文件模式与文件系统上的文件模式仅在可执行位上不同，则命令会忽略两者之间的差异。 在这种不幸的文件系统上，你可能需要使用 \"git update-index --chmod= \"。"

#. type: Plain text
#: en/git-update-index.txt:575
#, placeholders:'core.symlinks':'linkgit:git-config[1]', priority:80
msgid "Quite similarly, if `core.symlinks` configuration variable is set to 'false' (see linkgit:git-config[1]), symbolic links are checked out as plain files, and this command does not modify a recorded file mode from symbolic link to regular file."
msgstr "与此类似，如果将 `core.symlinks` 配置变量设为 'false'（参见 linkgit:git-config[1]），符号链接将作为普通文件签出，此命令不会将记录的文件模式从符号链接修改为普通文件。"

#. type: Plain text
#: en/git-update-index.txt:578
#, placeholders:'core.ignorestat', priority:80
msgid "The command looks at `core.ignorestat` configuration variable. See 'Using \"assume unchanged\" bit' section above."
msgstr "该命令会查看 `core.ignorestat` 配置变量。 请参阅上文 “使用 ‘假设不变’ 位 ”部分。"

#. type: Plain text
#: en/git-update-index.txt:583
#, placeholders:'core.trustctime':'linkgit:git-config[1]', priority:80
msgid "The command also looks at `core.trustctime` configuration variable. It can be useful when the inode change time is regularly modified by something outside Git (file system crawlers and backup systems use ctime for marking files processed) (see linkgit:git-config[1])."
msgstr "该命令还会查看 `core.trustctime` 配置变量。 当 Git 以外的东西（文件系统爬虫和备份系统使用 ctime 来标记处理过的文件）定期修改 inode 变更时间时，这个变量会很有用（参见 linkgit:git-config[1]）。"

#. type: Plain text
#: en/git-update-index.txt:587
#, placeholders:'core.untrackedCache':'linkgit:git-config[1]', priority:80
msgid "The untracked cache extension can be enabled by the `core.untrackedCache` configuration variable (see linkgit:git-config[1])."
msgstr "非跟踪缓存扩展可以通过 `core.untrackedCache` 配置变量启用（参见 linkgit:git-config[1]）。"

#. type: Plain text
#: en/git-update-index.txt:597
#, priority:80
msgid "Users often try to use the assume-unchanged and skip-worktree bits to tell Git to ignore changes to files that are tracked. This does not work as expected, since Git may still check working tree files against the index when performing certain operations. In general, Git does not provide a way to ignore changes to tracked files, so alternate solutions are recommended."
msgstr "用户经常尝试使用假设不变和跳过工作区位来告诉 Git 忽略对已跟踪文件的修改。 但这并不尽如人意，因为在执行某些操作时，Git 仍会根据索引检查工作区文件。 一般来说，Git 并不提供忽略被跟踪文件的方法，因此建议使用其他解决方案。"

#. type: Plain text
#: en/git-update-index.txt:603
#, priority:80
msgid "For example, if the file you want to change is some sort of config file, the repository can include a sample config file that can then be copied into the ignored name and modified. The repository can even include a script to treat the sample file as a template, modifying and copying it automatically."
msgstr "例如，如果要修改的文件是某种配置文件，仓库可以包含一个样本配置文件，然后将其复制到被忽略的文件名中并进行修改。 仓库甚至可以包含一个脚本，将样本文件作为模板，自动修改和复制。"

#. type: Plain text
#: en/git-update-index.txt:609
#, ignore-same, priority:80
msgid "linkgit:git-config[1], linkgit:git-add[1], linkgit:git-ls-files[1]"
msgstr "linkgit:git-config[1], linkgit:git-add[1], linkgit:git-ls-files[1]"

#. type: Title =
#: en/git-update-ref.txt:2
#, ignore-same, no-wrap, priority:80
msgid "git-update-ref(1)"
msgstr "git-update-ref(1)"

#. type: Plain text
#: en/git-update-ref.txt:7
#, placeholders:'git-update-ref', priority:80
msgid "git-update-ref - Update the object name stored in a ref safely"
msgstr "git-update-ref - 安全地更新存储在引用中的对象名称"

#. type: Plain text
#: en/git-update-ref.txt:12
#, no-wrap, placeholders:'git update-ref':'[--no-deref]':'[--create-reflog]':'--stdin', priority:80
msgid "'git update-ref' [-m <reason>] [--no-deref] (-d <ref> [<oldvalue>] | [--create-reflog] <ref> <newvalue> [<oldvalue>] | --stdin [-z])\n"
msgstr "'git update-ref' [-m <原因>] [--no-deref] (-d <引用> [<旧值>] | [--create-reflog] <引用> <新值> [<旧值>] | --stdin [-z])\n"

#. type: Plain text
#: en/git-update-ref.txt:18
#, placeholders:'git update-ref':'HEAD', priority:80
msgid "Given two arguments, stores the <newvalue> in the <ref>, possibly dereferencing the symbolic refs. E.g. `git update-ref HEAD <newvalue>` updates the current branch head to the new object."
msgstr "给定两个参数后，将 <新值> 保存到 <引用> 中，并可能取消引用符号引用。 例如，`git update-ref HEAD <新值>` 会将当前分支的头更新为新对象。"

#. type: Plain text
#: en/git-update-ref.txt:27
#, placeholders:'git update-ref', priority:80
msgid "Given three arguments, stores the <newvalue> in the <ref>, possibly dereferencing the symbolic refs, after verifying that the current value of the <ref> matches <oldvalue>. E.g. `git update-ref refs/heads/master <newvalue> <oldvalue>` updates the master branch head to <newvalue> only if its current value is <oldvalue>. You can specify 40 \"0\" or an empty string as <oldvalue> to make sure that the ref you are creating does not exist."
msgstr "给定三个参数，在验证 <引用> 的当前值是否与 <旧值> 匹配后，将 <新值> 保存到 <引用> 中，并可能取消引用符号引用。 例如，`git update-ref refs/heads/master <新值> <旧值>` 只有在 master 分支头的当前值是 <旧值> 时，才会将其更新为 <新值>。 您可以指定 40 个 \"0\" 或空字符串作为 <旧值> 以确保您要创建的引用不存在。"

#. type: Plain text
#: en/git-update-ref.txt:31
#, priority:80
msgid "It also allows a \"ref\" file to be a symbolic pointer to another ref file by starting with the four-byte header sequence of \"ref:\"."
msgstr "它还允许一个 “引用” 文件以 \"ref: \" 的四字节头序列作为另一个引用文件的符号指针。"

#. type: Plain text
#: en/git-update-ref.txt:39
#, priority:80
msgid "More importantly, it allows the update of a ref file to follow these symbolic pointers, whether they are symlinks or these \"regular file symbolic refs\". It follows *real* symlinks only if they start with \"refs/\": otherwise it will just try to read them and update them as a regular file (i.e. it will allow the filesystem to follow them, but will overwrite such a symlink to somewhere else with a regular filename)."
msgstr "更重要的是，它允许更新引用文件时跟踪这些符号指针，无论它们是符号链接还是这些 “普通文件符号引用”。 只有当符号链接以 \"refs/\" 开头时，它才会跟踪 *真正* 的符号链接：否则，它只会尝试读取这些符号链接，并将其作为普通文件进行更新（也就是说，它允许文件系统跟踪这些符号链接，但会将这些符号链接覆盖到其他具有普通文件名的地方）。"

#. type: Plain text
#: en/git-update-ref.txt:42
#, placeholders:'--no-deref', priority:80
msgid "If --no-deref is given, <ref> itself is overwritten, rather than the result of following the symbolic pointers."
msgstr "如果给出--no-deref，<引用> 本身将被覆盖，而不是跟随符号指针的结果。"

#. type: Plain text
#: en/git-update-ref.txt:44
#, priority:80
msgid "In general, using"
msgstr "一般来说，使用"

#. type: Plain text
#: en/git-update-ref.txt:46
#, no-wrap, placeholders:'git update-ref':'HEAD':'$head', priority:80
msgid "\tgit update-ref HEAD \"$head\"\n"
msgstr "\tgit update-ref HEAD \"$head\"\n"

#. type: Plain text
#: en/git-update-ref.txt:48
#, priority:80
msgid "should be a _lot_ safer than doing"
msgstr "应该比下面的做法安全得多"

#. type: Plain text
#: en/git-update-ref.txt:50
#, no-wrap, placeholders:'$head':'$GIT_DIR':'HEAD', priority:80
msgid "\techo \"$head\" > \"$GIT_DIR/HEAD\"\n"
msgstr "\techo \"$head\" > \"$GIT_DIR/HEAD\"\n"

#. type: Plain text
#: en/git-update-ref.txt:57
#, priority:80
msgid "both from a symlink following standpoint *and* an error checking standpoint. The \"refs/\" rule for symlinks means that symlinks that point to \"outside\" the tree are safe: they'll be followed for reading but not for writing (so we'll never write through a ref symlink to some other tree, if you have copied a whole archive by creating a symlink tree)."
msgstr "和错误检查的角度来看都是如此。 符号链接的 \"refs/\" 规则意味着指向树 “外部” 的符号链接是安全的：它们在读取时会被跟踪，但在写入时不会被跟踪（因此，如果你通过创建一个符号链接目录复制了整个归档文件，我们永远不会通过引用符号链接写入其他目录树）。"

#. type: Plain text
#: en/git-update-ref.txt:60
#, placeholders:'`-d`', priority:80
msgid "With `-d` flag, it deletes the named <ref> after verifying it still contains <oldvalue>."
msgstr "如果使用 `-d` 标志，则会在确认命名的 <引用> 仍然包含 <旧值> 后将其删除。"

#. type: Plain text
#: en/git-update-ref.txt:63
#, placeholders:'`--stdin`', priority:80
msgid "With `--stdin`, update-ref reads instructions from standard input and performs all modifications together. Specify commands of the form:"
msgstr "如果使用 `--stdin`，update-ref 会从标准输入读取指令，并一并执行所有修改。 指定命令格式为："

#. type: Plain text
#: en/git-update-ref.txt:73
#, no-wrap, priority:80
msgid ""
"\tupdate SP <ref> SP <newvalue> [SP <oldvalue>] LF\n"
"\tcreate SP <ref> SP <newvalue> LF\n"
"\tdelete SP <ref> [SP <oldvalue>] LF\n"
"\tverify SP <ref> [SP <oldvalue>] LF\n"
"\toption SP <opt> LF\n"
"\tstart LF\n"
"\tprepare LF\n"
"\tcommit LF\n"
"\tabort LF\n"
msgstr ""
"\tupdate SP <引用> SP <新值> [SP <旧值>] LF\n"
"\tcreate SP <引用> SP <新值> LF\n"
"\tdelete SP <引用> [SP <旧值>] LF\n"
"\tverify SP <引用> [SP <旧值>] LF\n"
"\toption SP <选项> LF\n"
"\tstart LF\n"
"\tprepare LF\n"
"\tcommit LF\n"
"\tabort LF\n"

#. type: Plain text
#: en/git-update-ref.txt:76
#, placeholders:'`--create-reflog`', priority:80
msgid "With `--create-reflog`, update-ref will create a reflog for each ref even if one would not ordinarily be created."
msgstr "如果使用 `--create-reflog`，update-ref 将为每个引用创建一个引用日志，即使通常不会创建引用日志。"

#. type: Plain text
#: en/git-update-ref.txt:81
#, priority:80
msgid "Quote fields containing whitespace as if they were strings in C source code; i.e., surrounded by double-quotes and with backslash escapes. Use 40 \"0\" characters or the empty string to specify a zero value. To specify a missing value, omit the value and its preceding SP entirely."
msgstr "引用包含空白的字段，就像引用 C 源代码中的字符串一样，即用双引号和反斜杠包围。 使用 40 个 \"0 \"字符或空字符串指定零值。 若要指定一个缺失值，请完全省略该值及其前面的 SP。"

#. type: Plain text
#: en/git-update-ref.txt:84
#, placeholders:'`-z`', priority:80
msgid "Alternatively, use `-z` to specify in NUL-terminated format, without quoting:"
msgstr "或者，使用 `-z` 以 NULL 结尾格式指定，不加引号："

#. type: Plain text
#: en/git-update-ref.txt:94
#, no-wrap, priority:80
msgid ""
"\tupdate SP <ref> NUL <newvalue> NUL [<oldvalue>] NUL\n"
"\tcreate SP <ref> NUL <newvalue> NUL\n"
"\tdelete SP <ref> NUL [<oldvalue>] NUL\n"
"\tverify SP <ref> NUL [<oldvalue>] NUL\n"
"\toption SP <opt> NUL\n"
"\tstart NUL\n"
"\tprepare NUL\n"
"\tcommit NUL\n"
"\tabort NUL\n"
msgstr ""
"\tupdate SP <引用> NUL <新值> NUL [<旧值>] NUL\n"
"\tcreate SP <引用> NUL <新值> NUL\n"
"\tdelete SP <引用> NUL [<旧值>] NUL\n"
"\tverify SP <引用> NUL [<旧值>] NUL\n"
"\toption SP <选项> NUL\n"
"\tstart NUL\n"
"\tprepare NUL\n"
"\tcommit NUL\n"
"\tabort NUL\n"

#. type: Plain text
#: en/git-update-ref.txt:97
#, priority:80
msgid "In this format, use 40 \"0\" to specify a zero value, and use the empty string to specify a missing value."
msgstr "在此格式中，使用 40 个 \"0 \" 指定零值，使用空字符串指定缺失值。"

#. type: Plain text
#: en/git-update-ref.txt:101
#, priority:80
msgid "In either format, values can be specified in any form that Git recognizes as an object name. Commands in any other format or a repeated <ref> produce an error. Command meanings are:"
msgstr "在这两种格式中，值可以以任何 Git 能识别的对象名形式指定。 任何其他格式的命令或重复的 <引用> 都会产生错误。 命令含义如下："

#. type: Plain text
#: en/git-update-ref.txt:107
#, priority:80
msgid "Set <ref> to <newvalue> after verifying <oldvalue>, if given. Specify a zero <newvalue> to ensure the ref does not exist after the update and/or a zero <oldvalue> to make sure the ref does not exist before the update."
msgstr "验证 <旧值> 后，将 <引用> 设置为 <新值>（如果给定）。 指定一个零 <新值>，以确保更新后引用不存在，和/或指定一个零 <旧值> 以确保更新前引用不存在。"

#. type: Plain text
#: en/git-update-ref.txt:111
#, priority:80
msgid "Create <ref> with <newvalue> after verifying it does not exist. The given <newvalue> may not be zero."
msgstr "在确认 <新值> 不存在后，用 <新值> 创建 <引用>。 给定的 <新值> 可能不为零。"

#. type: Labeled list
#: en/git-update-ref.txt:112
#, ignore-same, no-wrap, priority:80
msgid "delete"
msgstr "delete"

#. type: Plain text
#: en/git-update-ref.txt:115
#, priority:80
msgid "Delete <ref> after verifying it exists with <oldvalue>, if given. If given, <oldvalue> may not be zero."
msgstr "使用 <旧值> 验证 <引用> 是否存在（如果给定），然后删除 <引用>。 如果给定，<旧值> 可能不为零。"

#. type: Labeled list
#: en/git-update-ref.txt:116
#, ignore-same, no-wrap, priority:80
msgid "verify"
msgstr "verify"

#. type: Plain text
#: en/git-update-ref.txt:119
#, priority:80
msgid "Verify <ref> against <oldvalue> but do not change it. If <oldvalue> is zero or missing, the ref must not exist."
msgstr "对照 <旧值> 验证 <引用> 但不要更改。 如果 <旧值> 为零或缺失，则引用一定不存在。"

#. type: Labeled list
#: en/git-update-ref.txt:120
#, ignore-same, no-wrap, priority:80
msgid "option"
msgstr "option"

#. type: Plain text
#: en/git-update-ref.txt:124
#, priority:80
msgid "Modify the behavior of the next command naming a <ref>. The only valid option is `no-deref` to avoid dereferencing a symbolic ref."
msgstr "修改命名 <引用> 的下一条命令的行为。 唯一有效的选项是 \"no-deref\"，以避免引用符号引用。"

#. type: Plain text
#: en/git-update-ref.txt:130
#, priority:80
msgid "Start a transaction. In contrast to a non-transactional session, a transaction will automatically abort if the session ends without an explicit commit. This command may create a new empty transaction when the current one has been committed or aborted already."
msgstr "启动事务。与非事务会话不同，如果会话在没有明确提交的情况下结束，事务会自动终止。当当前事务已提交或中止时，该命令可能会创建一个新的空事务。"

#. type: Labeled list
#: en/git-update-ref.txt:131
#, no-wrap, priority:80
msgid "prepare"
msgstr "准备"

#. type: Plain text
#: en/git-update-ref.txt:135
#, priority:80
msgid "Prepare to commit the transaction. This will create lock files for all queued reference updates. If one reference could not be locked, the transaction will be aborted."
msgstr "准备提交事务。这将为所有排队的引用更新创建锁定文件。如果一个引用无法锁定，事务将被中止。"

#. type: Plain text
#: en/git-update-ref.txt:139
#, priority:80
msgid "Commit all reference updates queued for the transaction, ending the transaction."
msgstr "提交为该事务排队的所有引用更新，结束该事务。"

#. type: Labeled list
#: en/git-update-ref.txt:140
#, no-wrap, priority:80
msgid "abort"
msgstr "中止"

#. type: Plain text
#: en/git-update-ref.txt:143
#, priority:80
msgid "Abort the transaction, releasing all locks if the transaction is in prepared state."
msgstr "中止事务，如果事务处于准备状态，则释放所有锁。"

#. type: Plain text
#: en/git-update-ref.txt:149
#, priority:80
msgid "If all <ref>s can be locked with matching <oldvalue>s simultaneously, all modifications are performed. Otherwise, no modifications are performed. Note that while each individual <ref> is updated or deleted atomically, a concurrent reader may still see a subset of the modifications."
msgstr "如果所有 <引用> 都能同时锁定匹配的 <旧值>，则会执行所有修改。 否则，不会执行任何修改。 请注意，虽然每个 <引用> 都是以原子方式更新或删除的，但并发读者仍可能看到修改的子集。"

#. type: Title -
#: en/git-update-ref.txt:151
#, no-wrap, priority:80
msgid "LOGGING UPDATES"
msgstr "日志更新"

#. type: Plain text
#: en/git-update-ref.txt:159
#, placeholders:'core.logAllRefUpdates':'HEAD':'ORIG_HEAD':'$GIT_DIR':'git update-ref':'$GIT_DIR', priority:80
msgid "If config parameter \"core.logAllRefUpdates\" is true and the ref is one under \"refs/heads/\", \"refs/remotes/\", \"refs/notes/\", or a pseudoref like HEAD or ORIG_HEAD; or the file \"$GIT_DIR/logs/<ref>\" exists then `git update-ref` will append a line to the log file \"$GIT_DIR/logs/<ref>\" (dereferencing all symbolic refs before creating the log name) describing the change in ref value. Log lines are formatted as:"
msgstr "如果配置参数 \"core.logAllRefUpdates\" 为 true，且引用是 \"refs/heads/\"、 \"refs/remotes/\"、 \"refs/notes/\" 或类似 HEAD 或 ORIG_HEAD 的伪指；或文件 \"$GIT_DIR/logs/<引用>\" 存在，那么 `git update-ref` 就会在日志文件 \"$GIT_DIR/logs/<引用>\" 中添加一行，描述引用值的变化（在创建日志名之前取消引用所有符号 ref）。 日志行的格式为："

#. type: Plain text
#: en/git-update-ref.txt:161
#, no-wrap, priority:80
msgid "    oldsha1 SP newsha1 SP committer LF\n"
msgstr "    旧 sha1 值 SP 新 sha1 值 SP 提交者 LF\n"

#. type: Plain text
#: en/git-update-ref.txt:166
#, priority:80
msgid "Where \"oldsha1\" is the 40 character hexadecimal value previously stored in <ref>, \"newsha1\" is the 40 character hexadecimal value of <newvalue> and \"committer\" is the committer's name, email address and date in the standard Git committer ident format."
msgstr "其中，\"oldsha1\" 是之前存储在 <引用> 中的 40 个字符的十六进制值，\"newsha1\" 是 <新值> 的 40 个字符的十六进制值，\"committer\" 是标准 Git committer 标识格式中的 committer 姓名、电子邮件地址和日期。"

#. type: Plain text
#: en/git-update-ref.txt:168
#, priority:80
msgid "Optionally with -m:"
msgstr "可选择使用 -m："

#. type: Plain text
#: en/git-update-ref.txt:170
#, no-wrap, priority:80
msgid "    oldsha1 SP newsha1 SP committer TAB message LF\n"
msgstr "    旧 sha1 SP 新 sha1 SP 提交值 TAB 信息 LF\n"

#. type: Plain text
#: en/git-update-ref.txt:173
#, priority:80
msgid "Where all fields are as described above and \"message\" is the value supplied to the -m option."
msgstr "其中，所有字段如上所述，“信息” 为 -m 选项提供的值。"

#. type: Plain text
#: en/git-update-ref.txt:177
#, priority:80
msgid "An update will fail (without changing <ref>) if the current user is unable to create a new log file, append to the existing log file or does not have committer information available."
msgstr "如果当前用户无法创建新日志文件、追加现有日志文件或没有可用的提交者信息，更新将失败（不会更改 <引用>）。"

#. type: Title =
#: en/git-update-server-info.txt:2
#, ignore-same, no-wrap, priority:90
msgid "git-update-server-info(1)"
msgstr "git-update-server-info(1)"

#. type: Plain text
#: en/git-update-server-info.txt:7
#, placeholders:'git-update-server-info', priority:90
msgid "git-update-server-info - Update auxiliary info file to help dumb servers"
msgstr "git-update-server-info - 更新辅助信息文件以帮助哑服务器"

#. type: Plain text
#: en/git-update-server-info.txt:13
#, no-wrap, placeholders:'git update-server-info':'--force]', priority:90
msgid "'git update-server-info' [-f | --force]\n"
msgstr "'git update-server-info' [-f | --force]\n"

#. type: Plain text
#: en/git-update-server-info.txt:21
#, placeholders:'$GIT_DIR':'$GIT_OBJECT_DIRECTORY', priority:90
msgid "A dumb server that does not do on-the-fly pack generations must have some auxiliary information files in $GIT_DIR/info and $GIT_OBJECT_DIRECTORY/info directories to help clients discover what references and packs the server has. This command generates such auxiliary files."
msgstr "不进行即时包生成的哑服务器必须在 $GIT_DIR/info 和 $GIT_OBJECT_DIRECTORY/info 目录中保存一些辅助信息文件，以帮助客户端发现服务器上有哪些引用和包。 此命令可生成此类辅助文件。"

#. type: Plain text
#: en/git-update-server-info.txt:27
#, priority:90
msgid "Update the info files from scratch."
msgstr "从头开始更新信息文件。"

#. type: Plain text
#: en/git-update-server-info.txt:34
#, placeholders:'linkgit:gitrepository-layout[5]', priority:90
msgid "Currently the command updates the following files. Please see linkgit:gitrepository-layout[5] for a description of what they are for:"
msgstr "目前，该命令会更新以下文件。 请参阅 linkgit:gitrepository-layout[5] 了解它们的用途："

#. type: Plain text
#: en/git-update-server-info.txt:36
#, priority:90
msgid "objects/info/packs"
msgstr "objects/info/packs"

#. type: Plain text
#: en/git-update-server-info.txt:38
#, priority:90
msgid "info/refs"
msgstr "info/refs"

#. type: Title =
#: en/git-upload-archive.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-upload-archive(1)"
msgstr "git-upload-archive(1)"

#. type: Plain text
#: en/git-upload-archive.txt:7
#, placeholders:'git-archive', priority:100
msgid "git-upload-archive - Send archive back to git-archive"
msgstr "git-upload-archive - 将存档发回 git-archive"

#. type: Plain text
#: en/git-upload-archive.txt:13
#, no-wrap, placeholders:'git upload-archive', priority:100
msgid "'git upload-archive' <repository>\n"
msgstr "'git upload-archive' <仓库>\n"

#. type: Plain text
#: en/git-upload-archive.txt:18
#, placeholders:'--remote', priority:100
msgid "Invoked by 'git archive --remote' and sends a generated archive to the other end over the Git protocol."
msgstr "由 'git archive--remote' 调用，通过 Git 协议向另一端发送生成的归档文件。"

#. type: Plain text
#: en/git-upload-archive.txt:22
#, priority:100
msgid "This command is usually not invoked directly by the end user. The UI for the protocol is on the 'git archive' side, and the program pair is meant to be used to get an archive from a remote repository."
msgstr "终端用户通常不会直接调用该命令。 该协议的用户界面在 'git archive'（存档）端，程序对用于从远程仓库获取存档。"

#. type: Title -
#: en/git-upload-archive.txt:24 en/transfer-data-leaks.txt:2
#, no-wrap, priority:220
msgid "SECURITY"
msgstr "安全"

#. type: Plain text
#: en/git-upload-archive.txt:32
#, priority:100
msgid "In order to protect the privacy of objects that have been removed from history but may not yet have been pruned, `git-upload-archive` avoids serving archives for commits and trees that are not reachable from the repository's refs. However, because calculating object reachability is computationally expensive, `git-upload-archive` implements a stricter but easier-to-check set of rules:"
msgstr "为了保护已从历史中删除但可能尚未被剪枝的对象的隐私，`git-upload-archive` 避免为从版本库的 refs 无法访问的提交和树提供存档。 不过，由于计算对象可达性的计算成本很高，`git-upload-archive` 实现了一套更严格但更容易检查的规则："

#. type: Plain text
#: en/git-upload-archive.txt:35
#, placeholders:'--remote=origin', priority:100
msgid "Clients may request a commit or tree that is pointed to directly by a ref. E.g., `git archive --remote=origin v1.0`."
msgstr "客户端可以请求由 ref 直接指向的提交或树。例如，`git archive --remote=origin v1.0`。"

#. type: Plain text
#: en/git-upload-archive.txt:38
#, placeholders:'--remote=origin', priority:100
msgid "Clients may request a sub-tree within a commit or tree using the `ref:path` syntax. E.g., `git archive --remote=origin v1.0:Documentation`."
msgstr "客户端可以使用 `ref:path` 语法请求提交或树中的子树。例如，`git archive --remote=origin v1.0:Documentation`。"

#. type: Plain text
#: en/git-upload-archive.txt:43
#, priority:100
msgid "Clients may _not_ use other sha1 expressions, even if the end result is reachable. E.g., neither a relative commit like `master^` nor a literal sha1 like `abcd1234` is allowed, even if the result is reachable from the refs."
msgstr "客户端不得_使用其他 sha1 表达式，即使最终结果是可达的。例如，既不允许使用像 `master^` 这样的相对提交，也不允许使用像 `abcd1234` 这样的字面 sha1 表达式，即便结果能够从引用中找到。"

#. type: Plain text
#: en/git-upload-archive.txt:48
#, placeholders:'--remote`', priority:100
msgid "Note that rule 3 disallows many cases that do not have any privacy implications. These rules are subject to change in future versions of git, and the server accessed by `git archive --remote` may or may not follow these exact rules."
msgstr "请注意，规则 3 不允许许多不涉及隐私的情况。这些规则可能会在未来的 git 版本中修改，而通过 `git archive --remote` 访问的服务器可能会也可能不会完全遵循这些规则。"

#. type: Plain text
#: en/git-upload-archive.txt:54
#, placeholders:'uploadArchive.allowUnreachable', priority:100
msgid "If the config option `uploadArchive.allowUnreachable` is true, these rules are ignored, and clients may use arbitrary sha1 expressions. This is useful if you do not care about the privacy of unreachable objects, or if your object database is already publicly available for access via non-smart-http."
msgstr "如果配置选项 `uploadArchive.allowUnreachable` 为 true，这些规则将被忽略，客户端可以使用任意的 sha1 表达式。 如果你不关心无法访问对象的隐私，或者如果你的对象数据库已经公开，可以通过非智能 HTTP 访问，那么这将非常有用。"

#. type: Plain text
#: en/git-upload-archive.txt:59
#, priority:100
msgid "The repository to get a tar archive from."
msgstr "要获取 tar 压缩包的仓库。"

#. type: Title =
#: en/git-upload-pack.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-upload-pack(1)"
msgstr "git-upload-pack(1)"

#. type: Plain text
#: en/git-upload-pack.txt:7
#, placeholders:'git-upload-pack':'git-fetch-pack', priority:100
msgid "git-upload-pack - Send objects packed back to git-fetch-pack"
msgstr "git-upload-pack - 将打包的对象发送回 git-fetch-pack"

#. type: Plain text
#: en/git-upload-pack.txt:14
#, no-wrap, placeholders:'git-upload-pack':'[--timeout=':'[--stateless-rpc]':'[--advertise-refs]', priority:100
msgid ""
"'git-upload-pack' [--[no-]strict] [--timeout=<n>] [--stateless-rpc]\n"
"\t\t  [--advertise-refs] <directory>\n"
msgstr ""
"'git-upload-pack' [--[no-]strict] [--timeout=<n>] [--stateless-rpc]\n"
"\t\t  [--advertise-refs] <目录>\n"

#. type: Plain text
#: en/git-upload-pack.txt:19
#, placeholders:'git fetch-pack', priority:100
msgid "Invoked by 'git fetch-pack', learns what objects the other side is missing, and sends them after packing."
msgstr "由 'git fetch-pack' 调用，了解对方缺少哪些对象，并在打包后发送。"

#. type: Plain text
#: en/git-upload-pack.txt:24
#, placeholders:'git fetch-pack':'git send-pack', priority:100
msgid "This command is usually not invoked directly by the end user. The UI for the protocol is on the 'git fetch-pack' side, and the program pair is meant to be used to pull updates from a remote repository. For push operations, see 'git send-pack'."
msgstr "终端用户通常不会直接调用该命令。 该协议的用户界面在 'git fetch-pack' 端，程序对用于从远程仓库拉取更新。 关于推送操作，请参阅 'git send-pack'。"

#. type: Labeled list
#: en/git-upload-pack.txt:28
#, ignore-same, no-wrap, priority:100
msgid "--[no-]strict"
msgstr "--[no-]strict"

#. type: Plain text
#: en/git-upload-pack.txt:30
#, priority:100
msgid "Do not try <directory>/.git/ if <directory> is not a Git directory."
msgstr "如果 <目录> 不是 Git 目录，请不要尝试 <目录>/.git/ 。"

#. type: Plain text
#: en/git-upload-pack.txt:33
#, priority:100
msgid "Interrupt transfer after <n> seconds of inactivity."
msgstr "<n> 秒不活动后中断传输。"

#. type: Labeled list
#: en/git-upload-pack.txt:34
#, ignore-same, no-wrap, priority:100
msgid "--stateless-rpc"
msgstr "--stateless-rpc"

#. type: Plain text
#: en/git-upload-pack.txt:38
#, priority:100
msgid "Perform only a single read-write cycle with stdin and stdout. This fits with the HTTP POST request processing model where a program may read the request, write a response, and must exit."
msgstr "只对标准输入和标准输出执行一次读写循环。 这符合 HTTP POST 请求处理模式，即程序可以读取请求、写入响应，然后必须退出。"

#. type: Plain text
#: en/git-upload-pack.txt:46
#, placeholders:'linkgit:git-http-backend[1]':'$GIT_URL':'git-upload-pack':'linkgit:gitprotocol-http[5]':'linkgit:gitprotocol-v2[5]':'linkgit:git-receive-pack[1]', priority:100
msgid "Used by linkgit:git-http-backend[1] to serve up `$GIT_URL/info/refs?service=git-upload-pack` requests. See \"Smart Clients\" in linkgit:gitprotocol-http[5] and \"HTTP Transport\" in the linkgit:gitprotocol-v2[5] documentation. Also understood by linkgit:git-receive-pack[1]."
msgstr "由 linkgit:git-http-backend[1] 使用，用于提供 `$GIT_URL/info/refs?service=git-upload-pack` 请求。参见 linkgit:gitprotocol-http[5] 中的 “智能客户端” 和 linkgit:gitprotocol-v2[5] 文档中的 “HTTP 传输”。也可理解为 linkgit:git-receive-pack[1]。"

#. type: Plain text
#: en/git-upload-pack.txt:49
#, priority:100
msgid "The repository to sync from."
msgstr "要同步的仓库。"

#. type: Plain text
#: en/git-upload-pack.txt:57
#, placeholders:'linkgit:git[1]', priority:100
msgid "Internal variable used for handshaking the wire protocol. Server admins may need to configure some transports to allow this variable to be passed. See the discussion in linkgit:git[1]."
msgstr "用于与传输协议握手的内部变量。服务器管理员可能需要配置某些传输协议，以允许传递此变量。请参阅 linkgit:git[1] 中的讨论。"

#. type: Title =
#: en/git-var.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-var(1)"
msgstr "git-var(1)"

#. type: Plain text
#: en/git-var.txt:7
#, placeholders:'git-var', priority:100
msgid "git-var - Show a Git logical variable"
msgstr "git-var - 显示 Git 逻辑变量"

#. type: Plain text
#: en/git-var.txt:13
#, no-wrap, priority:100
msgid "'git var' (-l | <variable>)\n"
msgstr "'git var' ( -l | <变量> )\n"

#. type: Plain text
#: en/git-var.txt:18
#, priority:100
msgid "Prints a Git logical variable. Exits with code 1 if the variable has no value."
msgstr "打印 Git 逻辑变量。如果变量没有值，则以代码 1 退出。"

#. type: Plain text
#: en/git-var.txt:26
#, priority:100
msgid "Display the logical variables. In addition, all the variables of the Git configuration file .git/config are listed as well. (However, the configuration variables listing functionality is deprecated in favor of `git config -l`.)"
msgstr "显示逻辑变量。此外，Git 配置文件 .git/config 中的所有变量也会被列出。(不过，配置变量列表功能已被弃用，改用 `git config -l`）"

#. type: Plain text
#: en/git-var.txt:31
#, no-wrap, placeholders:'GIT_AUTHOR_IDENT':'lnxi.com', priority:100
msgid ""
"\t$ git var GIT_AUTHOR_IDENT\n"
"\tEric W. Biederman <ebiederm@lnxi.com> 1121223278 -0600\n"
msgstr ""
"\t$ git var GIT_AUTHOR_IDENT\n"
"\tEric W. Biederman <ebiederm@lnxi.com> 1121223278 -0600\n"

#. type: Title -
#: en/git-var.txt:34
#, no-wrap, priority:100
msgid "VARIABLES"
msgstr "变量"

#. type: Labeled list
#: en/git-var.txt:35
#, ignore-same, no-wrap, priority:100
msgid "GIT_AUTHOR_IDENT"
msgstr "GIT_AUTHOR_IDENT"

#. type: Plain text
#: en/git-var.txt:37
#, priority:100
msgid "The author of a piece of code."
msgstr "一段代码的作者。"

#. type: Labeled list
#: en/git-var.txt:38
#, ignore-same, no-wrap, priority:100
msgid "GIT_COMMITTER_IDENT"
msgstr "GIT_COMMITTER_IDENT"

#. type: Plain text
#: en/git-var.txt:40
#, priority:100
msgid "The person who put a piece of code into Git."
msgstr "将代码放入 Git 的人。"

#. type: Labeled list
#: en/git-var.txt:41
#, ignore-same, no-wrap, priority:100
msgid "GIT_EDITOR"
msgstr "GIT_EDITOR"

#. type: Plain text
#: en/git-var.txt:49
#, placeholders:'gvim.exe':'--nofork`':'$GIT_EDITOR':'core.editor':'$VISUAL':'$EDITOR', priority:100
msgid "Text editor for use by Git commands. The value is meant to be interpreted by the shell when it is used. Examples: `~/bin/vi`, `$SOME_ENVIRONMENT_VARIABLE`, `\"C:\\Program Files\\Vim\\gvim.exe\" --nofork`. The order of preference is the `$GIT_EDITOR` environment variable, then `core.editor` configuration, then `$VISUAL`, then `$EDITOR`, and then the default chosen at compile time, which is usually 'vi'."
msgstr "供 Git 命令使用的文本编辑器。 该值在使用时由 shell 解释。 例如~/bin/vi`、`$SOME_ENVIRONMENT_VARIABLE`、`\"C:\\Program Files\\Vim\\gvim.exe\" --nofork`。 首选顺序是 `$GIT_EDITOR` 环境变量，然后是 `core.editor` 配置，然后是 `$VISUAL`，然后是 `$EDITOR`，然后是编译时选择的默认值，通常是 'vi'。"

#. type: Plain text
#: en/git-var.txt:51
#, no-wrap, placeholders:'{git-default-editor}', priority:100
msgid "    The build you are using chose '{git-default-editor}' as the default.\n"
msgstr "    您正在使用的版本选择了 '{git-default-editor}' 作为默认编辑器。\n"

#. type: Labeled list
#: en/git-var.txt:53
#, ignore-same, no-wrap, priority:100
msgid "GIT_SEQUENCE_EDITOR"
msgstr "GIT_SEQUENCE_EDITOR"

#. type: Plain text
#: en/git-var.txt:60
#, placeholders:'GIT_EDITOR':'$GIT_SEQUENCE_EDITOR':'sequence.editor':'GIT_EDITOR', priority:100
msgid "Text editor used to edit the 'todo' file while running `git rebase -i`. Like `GIT_EDITOR`, the value is meant to be interpreted by the shell when it is used. The order of preference is the `$GIT_SEQUENCE_EDITOR` environment variable, then `sequence.editor` configuration, and then the value of `git var GIT_EDITOR`."
msgstr "用于在运行 `git rebase -i` 时编辑 'todo' 文件的文本编辑器。与 `GIT_EDITOR`一样，该值在使用时由 shell 解释。首选顺序是 `$GIT_SEQUENCE_EDITOR` 环境变量，然后是 `sequence.editor` 配置，最后是 `git var GIT_EDITOR` 的值。"

#. type: Labeled list
#: en/git-var.txt:61
#, ignore-same, no-wrap, priority:100
msgid "GIT_PAGER"
msgstr "GIT_PAGER"

#. type: Plain text
#: en/git-var.txt:67
#, placeholders:'$GIT_PAGER':'core.pager':'$PAGER', priority:100
msgid "Text viewer for use by Git commands (e.g., 'less'). The value is meant to be interpreted by the shell. The order of preference is the `$GIT_PAGER` environment variable, then `core.pager` configuration, then `$PAGER`, and then the default chosen at compile time (usually 'less')."
msgstr "供 Git 命令（如 'less'）使用的文本查看器。 该值由 shell 解释。 首选顺序是 `$GIT_PAGER` 环境变量，然后是 `core.pager` 配置，然后是 `$PAGER`，然后是编译时选择的默认值（通常是 'less'）。"

#. type: Plain text
#: en/git-var.txt:69
#, no-wrap, placeholders:'{git-default-pager}', priority:100
msgid "    The build you are using chose '{git-default-pager}' as the default.\n"
msgstr "    您正在使用的构建选择了 '{git-default-pager}' 作为默认设置。\n"

#. type: Labeled list
#: en/git-var.txt:71
#, ignore-same, no-wrap, priority:100
msgid "GIT_DEFAULT_BRANCH"
msgstr "GIT_DEFAULT_BRANCH"

#. type: Plain text
#: en/git-var.txt:73
#, priority:100
msgid "The name of the first branch created in newly initialized repositories."
msgstr "在新初始化的仓库中创建的第一个分支的名称。"

#. type: Labeled list
#: en/git-var.txt:74
#, ignore-same, no-wrap, priority:100
msgid "GIT_SHELL_PATH"
msgstr "GIT_SHELL_PATH"

#. type: Plain text
#: en/git-var.txt:76
#, priority:100
msgid "The path of the binary providing the POSIX shell for commands which use the shell."
msgstr "为使用 shell 的命令提供 POSIX shell 的二进制文件路径。"

#. type: Labeled list
#: en/git-var.txt:77
#, ignore-same, no-wrap, priority:100
msgid "GIT_ATTR_SYSTEM"
msgstr "GIT_ATTR_SYSTEM"

#. type: Plain text
#: en/git-var.txt:79
#, placeholders:'linkgit:gitattributes[5]', priority:100
msgid "The path to the system linkgit:gitattributes[5] file, if one is enabled."
msgstr "系统 linkgit:gitattributes[5] 文件的路径（如果已启用）。"

#. type: Labeled list
#: en/git-var.txt:80
#, ignore-same, no-wrap, priority:100
msgid "GIT_ATTR_GLOBAL"
msgstr "GIT_ATTR_GLOBAL"

#. type: Plain text
#: en/git-var.txt:82
#, placeholders:'linkgit:gitattributes[5]', priority:100
msgid "The path to the global (per-user) linkgit:gitattributes[5] file."
msgstr "全局（每个用户）linkgit:gitattributes[5] 文件的路径。"

#. type: Plain text
#: en/git-var.txt:85
#, priority:100
msgid "The path to the system configuration file, if one is enabled."
msgstr "系统配置文件的路径（如果已启用）。"

#. type: Plain text
#: en/git-var.txt:88
#, priority:100
msgid "The path to the global (per-user) configuration files, if any."
msgstr "全局（按用户）配置文件的路径（如果有）。"

#. type: Plain text
#: en/git-var.txt:93
#, priority:100
msgid "Most path values contain only one value. However, some can contain multiple values, which are separated by newlines, and are listed in order from highest to lowest priority. Callers should be prepared for any such path value to contain multiple items."
msgstr "大多数路径值只包含一个值。不过，有些路径值可能包含多个值，这些值之间用换行分隔，并按优先级从高到低排列。 调用者应做好任何此类路径值包含多个项目的准备。"

#. type: Plain text
#: en/git-var.txt:96
#, priority:100
msgid "Note that paths are printed even if they do not exist, but not if they are disabled by other environment variables."
msgstr "请注意，即使路径不存在，也会打印出来，但如果路径被其他环境变量禁用，则不会打印出来。"

#. type: Plain text
#: en/git-var.txt:102
#, ignore-same, priority:100
msgid "linkgit:git-commit-tree[1] linkgit:git-tag[1] linkgit:git-config[1]"
msgstr "linkgit:git-commit-tree[1] linkgit:git-tag[1] linkgit:git-config[1]"

#. type: Title =
#: en/git-verify-commit.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-verify-commit(1)"
msgstr "git-verify-commit(1)"

#. type: Plain text
#: en/git-verify-commit.txt:7
#, placeholders:'git-verify-commit', priority:100
msgid "git-verify-commit - Check the GPG signature of commits"
msgstr "git-verify-commit - 检查提交的 GPG 签名"

#. type: Plain text
#: en/git-verify-commit.txt:12
#, ignore-ellipsis, no-wrap, placeholders:'git verify-commit':'--verbose]':'[--raw]', priority:100
msgid "'git verify-commit' [-v | --verbose] [--raw] <commit>...\n"
msgstr "'git verify-commit' [-v | --verbose] [--raw] <提交>...\n"

#. type: Plain text
#: en/git-verify-commit.txt:16
#, priority:100
msgid "Validates the GPG signature created by 'git commit -S'."
msgstr "验证 'git commit -S' 创建的 GPG 签名。"

#. type: Plain text
#: en/git-verify-commit.txt:22 en/git-verify-tag.txt:22
#, priority:100
msgid "Print the raw gpg status output to standard error instead of the normal human-readable output."
msgstr "将原始 gpg 状态输出打印到标准错误，而不是正常的人类可读输出。"

#. type: Plain text
#: en/git-verify-commit.txt:26
#, priority:100
msgid "Print the contents of the commit object before validating it."
msgstr "在验证之前打印提交对象的内容。"

#. type: Plain text
#: en/git-verify-commit.txt:29
#, priority:100
msgid "SHA-1 identifiers of Git commit objects."
msgstr "Git 提交对象的 SHA-1 标识符。"

#. type: Title =
#: en/git-verify-pack.txt:2
#, ignore-same, no-wrap, priority:80
msgid "git-verify-pack(1)"
msgstr "git-verify-pack(1)"

#. type: Plain text
#: en/git-verify-pack.txt:7
#, placeholders:'git-verify-pack', priority:80
msgid "git-verify-pack - Validate packed Git archive files"
msgstr "git-verify-pack - 验证打包的 Git 压缩文件"

#. type: Plain text
#: en/git-verify-pack.txt:13
#, ignore-ellipsis, no-wrap, placeholders:'git verify-pack':'--verbose]':'--stat-only]', priority:80
msgid "'git verify-pack' [-v | --verbose] [-s | --stat-only] [--] <pack>.idx...\n"
msgstr "'git verify-pack' [-v | --verbose] [-s | --stat-only] [--] <包>.idx...\n"

#. type: Plain text
#: en/git-verify-pack.txt:20
#, placeholders:'git pack-objects', priority:80
msgid "Reads given idx file for packed Git archive created with the 'git pack-objects' command and verifies the idx file and the corresponding pack file."
msgstr "读取用 'git pack-objects' 命令创建的 Git 压缩包的 idx 文件，并验证 idx 文件和相应的压缩包文件。"

#. type: Labeled list
#: en/git-verify-pack.txt:23
#, ignore-ellipsis, no-wrap, priority:80
msgid "<pack>.idx ..."
msgstr "<包>.idx ..."

#. type: Plain text
#: en/git-verify-pack.txt:25
#, priority:80
msgid "The idx files to verify."
msgstr "要验证的 idx 文件。"

#. type: Plain text
#: en/git-verify-pack.txt:30
#, priority:80
msgid "After verifying the pack, show the list of objects contained in the pack and a histogram of delta chain length."
msgstr "验证数据包后，显示数据包中包含的对象列表和 delta 链长度直方图。"

#. type: Labeled list
#: en/git-verify-pack.txt:32
#, ignore-same, no-wrap, priority:80
msgid "--stat-only"
msgstr "--stat-only"

#. type: Plain text
#: en/git-verify-pack.txt:35
#, placeholders:'`--verbose`', priority:80
msgid "Do not verify the pack contents; only show the histogram of delta chain length. With `--verbose`, the list of objects is also shown."
msgstr "不验证数据包内容；只显示三角链长度直方图。 如果使用 `--verbose` ，还会显示对象列表。"

#. type: Title -
#: en/git-verify-pack.txt:40
#, no-wrap, priority:80
msgid "OUTPUT FORMAT"
msgstr "输出格式"

#. type: Plain text
#: en/git-verify-pack.txt:42
#, priority:80
msgid "When specifying the -v option the format used is:"
msgstr "当指定 -v 选项时，使用的格式为："

#. type: Plain text
#: en/git-verify-pack.txt:44
#, no-wrap, priority:80
msgid "\tSHA-1 type size size-in-packfile offset-in-packfile\n"
msgstr "\tSHA-1 类型 大小 包文件中的偏移量\n"

#. type: Plain text
#: en/git-verify-pack.txt:46
#, priority:80
msgid "for objects that are not deltified in the pack, and"
msgstr "用于未在数据包中删除的对象，以及"

#. type: Plain text
#: en/git-verify-pack.txt:48
#, no-wrap, priority:80
msgid "\tSHA-1 type size size-in-packfile offset-in-packfile depth base-SHA-1\n"
msgstr "\tSHA-1 类型 大小 包文件中的大小 包文件中的偏移深度 base-SHA-1\n"

#. type: Plain text
#: en/git-verify-pack.txt:50
#, priority:80
msgid "for objects that are deltified."
msgstr "对于被矢量化了的物体。"

#. type: Title =
#: en/git-verify-tag.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-verify-tag(1)"
msgstr "git-verify-tag(1)"

#. type: Plain text
#: en/git-verify-tag.txt:7
#, placeholders:'git-verify-tag', priority:100
msgid "git-verify-tag - Check the GPG signature of tags"
msgstr "git-verify-tag - 检查标签的 GPG 签名"

#. type: Plain text
#: en/git-verify-tag.txt:12
#, ignore-ellipsis, no-wrap, placeholders:'git verify-tag':'--verbose]':'[--format=':'[--raw]', priority:100
msgid "'git verify-tag' [-v | --verbose] [--format=<format>] [--raw] <tag>...\n"
msgstr "'git verify-tag' [-v | --verbose] [--format=<格式>] [--raw] <标签>...\n"

#. type: Plain text
#: en/git-verify-tag.txt:16
#, priority:100
msgid "Validates the gpg signature created by 'git tag'."
msgstr "验证由 'git tag' 创建的 gpg 签名。"

#. type: Plain text
#: en/git-verify-tag.txt:26
#, priority:100
msgid "Print the contents of the tag object before validating it."
msgstr "在验证之前打印标记对象的内容。"

#. type: Labeled list
#: en/git-verify-tag.txt:27
#, ignore-ellipsis, no-wrap, priority:100
msgid "<tag>..."
msgstr "<标签>..."

#. type: Plain text
#: en/git-verify-tag.txt:29
#, priority:100
msgid "SHA-1 identifiers of Git tag objects."
msgstr "Git 标签对象的 SHA-1 标识符。"

#. type: Title =
#: en/git-web--browse.txt:2
#, no-wrap, placeholders:'git-web':'{litdd}', priority:100
msgid "git-web{litdd}browse(1)"
msgstr "git-web{litdd}browse(1)"

#. type: Plain text
#: en/git-web--browse.txt:7
#, placeholders:'git-web--browse', priority:100
msgid "git-web--browse - Git helper script to launch a web browser"
msgstr "git-web--browse - 启动网络浏览器的 Git 辅助脚本"

#. type: Plain text
#: en/git-web--browse.txt:12
#, ignore-ellipsis, no-wrap, placeholders:'{litdd}', priority:100
msgid "'git web{litdd}browse' [<options>] (<URL>|<file>)...\n"
msgstr "'git web{litdd}browse' [<选项>] (<地址>|<文件>)...\n"

#. type: Plain text
#: en/git-web--browse.txt:19
#, priority:100
msgid "This script tries, as much as possible, to display the URLs and FILEs that are passed as arguments, as HTML pages in new tabs on an already opened web browser."
msgstr "该脚本尽可能将作为参数传递的 URL 和 FILE 作为 HTML 页面显示在已打开的网页浏览器的新标签页中。"

#. type: Plain text
#: en/git-web--browse.txt:21
#, priority:100
msgid "The following browsers (or commands) are currently supported:"
msgstr "目前支持以下浏览器（或命令）："

#. type: Plain text
#: en/git-web--browse.txt:23
#, priority:100
msgid "firefox (this is the default under X Window when not using KDE)"
msgstr "firefox（不使用 KDE 时，这是 X Window 下的默认设置）"

#. type: Plain text
#: en/git-web--browse.txt:24
#, priority:100
msgid "iceweasel"
msgstr "iceweasel"

#. type: Plain text
#: en/git-web--browse.txt:25
#, priority:100
msgid "seamonkey"
msgstr "seamonkey"

#. type: Plain text
#: en/git-web--browse.txt:26
#, priority:100
msgid "iceape"
msgstr "iceape"

#. type: Plain text
#: en/git-web--browse.txt:27
#, priority:100
msgid "chromium (also supported as chromium-browser)"
msgstr "chromium (也支持其他 chromium 内核浏览器)"

#. type: Plain text
#: en/git-web--browse.txt:28
#, priority:100
msgid "google-chrome (also supported as chrome)"
msgstr "谷歌浏览器（也支持chrome浏览器）"

#. type: Plain text
#: en/git-web--browse.txt:29
#, priority:100
msgid "konqueror (this is the default under KDE, see 'Note about konqueror' below)"
msgstr "konqueror（这是 KDE 下的默认设置，参见下文 ‘关于 konqueror 的说明’）"

#. type: Plain text
#: en/git-web--browse.txt:30
#, priority:100
msgid "opera"
msgstr "opera"

#. type: Plain text
#: en/git-web--browse.txt:31
#, priority:100
msgid "w3m (this is the default outside graphical environments)"
msgstr "w3m（这是图形环境之外的默认设置）"

#. type: Plain text
#: en/git-web--browse.txt:32
#, priority:100
msgid "elinks"
msgstr "elinks"

#. type: Plain text
#: en/git-web--browse.txt:33
#, priority:100
msgid "links"
msgstr "链接"

#. type: Plain text
#: en/git-web--browse.txt:34
#, priority:100
msgid "lynx"
msgstr "lynx"

#. type: Plain text
#: en/git-web--browse.txt:35
#, priority:100
msgid "dillo"
msgstr "dillo"

#. type: Plain text
#: en/git-web--browse.txt:36
#, priority:100
msgid "open (this is the default under Mac OS X GUI)"
msgstr "open（这是 Mac OS X 图形用户界面下的默认设置）"

#. type: Plain text
#: en/git-web--browse.txt:37
#, priority:100
msgid "start (this is the default under MinGW)"
msgstr "start（这是 MinGW 下的默认设置）"

#. type: Plain text
#: en/git-web--browse.txt:38
#, priority:100
msgid "cygstart (this is the default under Cygwin)"
msgstr "cygstart（这是 Cygwin 下的默认设置）"

#. type: Plain text
#: en/git-web--browse.txt:39
#, priority:100
msgid "xdg-open"
msgstr "xdg-open"

#. type: Plain text
#: en/git-web--browse.txt:41
#, priority:100
msgid "Custom commands may also be specified."
msgstr "也可指定自定义命令。"

#. type: Labeled list
#: en/git-web--browse.txt:44
#, no-wrap, priority:100
msgid "-b <browser>"
msgstr "-b <浏览器>"

#. type: Labeled list
#: en/git-web--browse.txt:45
#, no-wrap, placeholders:'--browser=', priority:100
msgid "--browser=<browser>"
msgstr "--browser=<浏览器>"

#. type: Plain text
#: en/git-web--browse.txt:48
#, priority:100
msgid "Use the specified browser. It must be in the list of supported browsers."
msgstr "使用指定的浏览器。它必须在支持的浏览器列表中。"

#. type: Labeled list
#: en/git-web--browse.txt:49
#, no-wrap, priority:100
msgid "-t <browser>"
msgstr "-t <浏览器>"

#. type: Labeled list
#: en/git-web--browse.txt:50
#, no-wrap, placeholders:'--tool=', priority:100
msgid "--tool=<browser>"
msgstr "--tool=<浏览器>"

#. type: Labeled list
#: en/git-web--browse.txt:53
#, no-wrap, placeholders:'conf.var', priority:100
msgid "-c <conf.var>"
msgstr "-c <conf.var>"

#. type: Labeled list
#: en/git-web--browse.txt:54
#, no-wrap, placeholders:'--config=':'conf.var', priority:100
msgid "--config=<conf.var>"
msgstr "--config=<conf.var>"

#. type: Plain text
#: en/git-web--browse.txt:57
#, priority:100
msgid "CONF.VAR is looked up in the Git config files. If it's set, then its value specifies the browser that should be used."
msgstr "CONF.VAR 会在 Git 配置文件中查找。如果设置了 CONF.VAR，则其值将指定应使用的浏览器。"

#. type: Title ~
#: en/git-web--browse.txt:62
#, no-wrap, placeholders:'web.browser', priority:100
msgid "CONF.VAR (from -c option) and web.browser"
msgstr "CONF.VAR（来自 -c 选项）和 web.browser"

# ERROR: --config) not found in translation
#. type: Plain text
#: en/git-web--browse.txt:67
#, placeholders:'--config':'web.browser', priority:100
msgid "The web browser can be specified using a configuration variable passed with the -c (or --config) command-line option, or the `web.browser` configuration variable if the former is not used."
msgstr "网络浏览器可以通过与 -c（或 --config）命令行选项一起传递的配置变量来指定，如果不使用前者，则使用 `web.browser` 配置变量。"

#. type: Title ~
#: en/git-web--browse.txt:69
#, no-wrap, priority:100
msgid "browser.<tool>.path"
msgstr "browser.<工具>.path"

#. type: Plain text
#: en/git-web--browse.txt:76
#, placeholders:'browser.firefox.path':'{litdd}', priority:100
msgid "You can explicitly provide a full path to your preferred browser by setting the configuration variable `browser.<tool>.path`. For example, you can configure the absolute path to firefox by setting 'browser.firefox.path'. Otherwise, 'git web{litdd}browse' assumes the tool is available in PATH."
msgstr "您可以通过设置配置变量 `browser.<工具>.path`，明确提供首选浏览器的完整路径。例如，可以通过设置 'browser.firefox.path' 来配置 firefox 的绝对路径。否则，'git web{litdd}browse' 会假定该工具在 PATH 中可用。"

#. type: Title ~
#: en/git-web--browse.txt:78
#, no-wrap, priority:100
msgid "browser.<tool>.cmd"
msgstr "browser.<工具>.cmd"

#. type: Plain text
#: en/git-web--browse.txt:86
#, placeholders:'{litdd}', priority:100
msgid "When the browser, specified by options or configuration variables, is not among the supported ones, then the corresponding `browser.<tool>.cmd` configuration variable will be looked up. If this variable exists then 'git web{litdd}browse' will treat the specified tool as a custom command and will use a shell eval to run the command with the URLs passed as arguments."
msgstr "如果选项或配置变量指定的浏览器不在支持之列，则会查找相应的 `browser.<工具>.cmd` 配置变量。如果该变量存在，'git web{litdd}browse' 就会将指定的工具视为自定义命令，并使用 shell eval 以传递的 URL 作为参数运行该命令。"

#. type: Title -
#: en/git-web--browse.txt:88
#, no-wrap, priority:100
msgid "NOTE ABOUT KONQUEROR"
msgstr "关于 Konqueror 的说明"

#. type: Plain text
#: en/git-web--browse.txt:93
#, priority:100
msgid "When 'konqueror' is specified by a command-line option or a configuration variable, we launch 'kfmclient' to try to open the HTML man page on an already opened konqueror in a new tab if possible."
msgstr "当命令行选项或配置变量指定了 'konqueror' 时，我们会启动 'kfmclient'，尽可能在已打开的 konqueror 上以新标签页打开 HTML man 页面。"

#. type: Plain text
#: en/git-web--browse.txt:97
#, placeholders:'browser.konqueror.path', priority:100
msgid "For consistency, we also try such a trick if 'browser.konqueror.path' is set to something like `A_PATH_TO/konqueror`. That means we will try to launch `A_PATH_TO/kfmclient` instead."
msgstr "为了保持一致性，如果 'browser.konqueror.path ' 被设置为 `A_PATH_TO/konqueror`，我们也会尝试这样做。这意味着我们将尝试启动 `A_PATH_TO/kfmclient`，而不是 `A_PATH_TO/kfmclient`。"

#. type: delimited block -
#: en/git-web--browse.txt:104
#, no-wrap, priority:100
msgid ""
"\t[web]\n"
"\t\tbrowser = konq\n"
msgstr ""
"\t[web]\n"
"\t\tbrowser = konq\n"

#. type: delimited block -
#: en/git-web--browse.txt:107
#, no-wrap, priority:100
msgid ""
"\t[browser \"konq\"]\n"
"\t\tcmd = A_PATH_TO/konqueror\n"
msgstr ""
"\t[browser \"konq\"]\n"
"\t\tcmd = A_PATH_TO/konqueror\n"

#. type: Title ~
#: en/git-web--browse.txt:110
#, no-wrap, placeholders:'git-config':'--global', priority:100
msgid "Note about git-config --global"
msgstr "关于 git-config --global 的注意事项"

#. type: Plain text
#: en/git-web--browse.txt:114
#, placeholders:'`--global`', priority:100
msgid "Note that these configuration variables should probably be set using the `--global` flag, for example like this:"
msgstr "请注意，这些配置变量可能应该使用 `--global` 标志来设置，例如像这样："

#. type: delimited block -
#: en/git-web--browse.txt:117
#, no-wrap, placeholders:'--global':'web.browser', priority:100
msgid "$ git config --global web.browser firefox\n"
msgstr "$ git config --global web.browser firefox\n"

#. type: Title =
#: en/git-whatchanged.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-whatchanged(1)"
msgstr "git-whatchanged(1)"

#. type: Plain text
#: en/git-whatchanged.txt:7
#, placeholders:'git-whatchanged', priority:100
msgid "git-whatchanged - Show logs with differences each commit introduces"
msgstr "git-whatchanged - 显示每次提交引入的差异日志"

#. type: Plain text
#: en/git-whatchanged.txt:13
#, ignore-ellipsis, no-wrap, priority:100
msgid "'git whatchanged' <option>...\n"
msgstr "'git whatchanged' <选项>...\n"

#. type: Plain text
#: en/git-whatchanged.txt:18
#, priority:100
msgid "Shows commit logs and diff output each commit introduces."
msgstr "显示每次提交引入的提交日志和差异输出。"

#. type: Plain text
#: en/git-whatchanged.txt:22
#, placeholders:'linkgit:git-log[1]':'linkgit:git-log[1]', priority:100
msgid "New users are encouraged to use linkgit:git-log[1] instead. The `whatchanged` command is essentially the same as linkgit:git-log[1] but defaults to showing the raw format diff output and skipping merges."
msgstr "建议新用户使用 linkgit:git-log[1] 代替。 `whatchanged` 命令与 linkgit:git-log[1] 基本相同，但默认显示原始格式的差异输出并跳过合并。"

#. type: Plain text
#: en/git-whatchanged.txt:26
#, priority:100
msgid "The command is primarily kept for historical reasons; fingers of many people who learned Git long before `git log` was invented by reading the Linux kernel mailing list are trained to type it."
msgstr "保留该命令主要是出于历史原因；早在 `git log` 被发明之前，许多人就通过阅读 Linux 内核邮件列表学会了输入该命令。"

#. type: Labeled list
#: en/git-whatchanged.txt:30
#, no-wrap, priority:100
msgid "`git whatchanged -p v2.6.12.. include/scsi drivers/scsi`"
msgstr "`git whatchanged -p v2.6.12.. include/scsi drivers/scsi`"

#. type: Plain text
#: en/git-whatchanged.txt:34
#, priority:100
msgid "Show as patches the commits since version 'v2.6.12' that changed any file in the include/scsi or drivers/scsi subdirectories"
msgstr "以补丁形式显示自版本 'v2.6.12' 以来修改了 include/scsi 或 drivers/scsi 子目录中任何文件的提交内容"

#. type: Labeled list
#: en/git-whatchanged.txt:35
#, no-wrap, placeholders:'--since=', priority:100
msgid "`git whatchanged --since=\"2 weeks ago\" -- gitk`"
msgstr "`git whatchanged --since=\"2 weeks ago\" -- gitk`"

#. type: Plain text
#: en/git-whatchanged.txt:40
#, priority:100
msgid "Show the changes during the last two weeks to the file 'gitk'. The \"--\" is necessary to avoid confusion with the *branch* named 'gitk'"
msgstr "显示过去两周内 'gitk' 文件的改动。 为了避免与名为 'gitk' 的*分支*混淆，\"--\" 是必要的"

#. type: Title =
#: en/git-worktree.txt:2
#, ignore-same, no-wrap, priority:240
msgid "git-worktree(1)"
msgstr "git-worktree(1)"

#. type: Plain text
#: en/git-worktree.txt:7
#, placeholders:'git-worktree', priority:240
msgid "git-worktree - Manage multiple working trees"
msgstr "git-worktree - 管理多个工作区"

#. type: Plain text
#: en/git-worktree.txt:21
#, ignore-ellipsis, no-wrap, placeholders:'[--detach]':'[--checkout]':'[--lock':'[--reason':'[--orphan]':'--porcelain':'[--reason':'[--expire', priority:240
msgid ""
"'git worktree add' [-f] [--detach] [--checkout] [--lock [--reason <string>]]\n"
"\t\t   [--orphan] [(-b | -B) <new-branch>] <path> [<commit-ish>]\n"
"'git worktree list' [-v | --porcelain [-z]]\n"
"'git worktree lock' [--reason <string>] <worktree>\n"
"'git worktree move' <worktree> <new-path>\n"
"'git worktree prune' [-n] [-v] [--expire <expire>]\n"
"'git worktree remove' [-f] <worktree>\n"
"'git worktree repair' [<path>...]\n"
"'git worktree unlock' <worktree>\n"
msgstr ""
"'git worktree add' [-f] [--detach] [--checkout] [--lock [--reason <字符串>]]\n"
"\t\t   [--orphan] [(-b | -B) <新分支>] <路径> [<提交号>]\n"
"'git worktree list' [-v | --porcelain [-z]]\n"
"'git worktree lock' [--reason <字符串>] <工作区>\n"
"'git worktree move' <工作区> <新分支>\n"
"'git worktree prune' [-n] [-v] [--expire <到期>]\n"
"'git worktree remove' [-f] <工作区>\n"
"'git worktree repair' [<路径>...]\n"
"'git worktree unlock' <工作区>\n"

#. type: Plain text
#: en/git-worktree.txt:26
#, priority:240
msgid "Manage multiple working trees attached to the same repository."
msgstr "管理附属于同一仓库的多个工作区。"

#. type: Plain text
#: en/git-worktree.txt:32
#, priority:240
msgid "A git repository can support multiple working trees, allowing you to check out more than one branch at a time. With `git worktree add` a new working tree is associated with the repository, along with additional metadata that differentiates that working tree from others in the same repository. The working tree, along with this metadata, is called a \"worktree\"."
msgstr "一个 git 仓库可以支持多个工作区，允许你一次签出多个分支。 通过`git worktree add`，一个新的工作区与仓库相关联，同时还有额外的元数据，以区分该工作区与同一仓库中的其他工作区。 工作区目录树，连同这些元数据，被称为 \"工作区\"。"

#. type: Plain text
#: en/git-worktree.txt:38
#, placeholders:'linkgit:git-init[1]':'linkgit:git-clone[1]', priority:240
msgid "This new worktree is called a \"linked worktree\" as opposed to the \"main worktree\" prepared by linkgit:git-init[1] or linkgit:git-clone[1]. A repository has one main worktree (if it's not a bare repository) and zero or more linked worktrees. When you are done with a linked worktree, remove it with `git worktree remove`."
msgstr "这个新的工作区被称为 \"链接工作区\"，与 linkgit:git-init[1] 或 linkgit:git-clone[1] 所准备的 \"主工作区 \"相对应。 一个仓库有一个主工作区（如果它不是一个裸仓库）和零个或多个链接工作区。当你用完一个链接工作区后，用 `git worktree remove` 删除它。"

#. type: Plain text
#: en/git-worktree.txt:50
#, placeholders:'HEAD', priority:240
msgid "In its simplest form, `git worktree add <path>` automatically creates a new branch whose name is the final component of `<path>`, which is convenient if you plan to work on a new topic. For instance, `git worktree add ../hotfix` creates new branch `hotfix` and checks it out at path `../hotfix`. To instead work on an existing branch in a new worktree, use `git worktree add <path> <branch>`. On the other hand, if you just plan to make some experimental changes or do testing without disturbing existing development, it is often convenient to create a 'throwaway' worktree not associated with any branch. For instance, `git worktree add -d <path>` creates a new worktree with a detached `HEAD` at the same commit as the current branch."
msgstr "在其最简单的形式中，`git worktree add <路径>`自动创建一个新的分支，其名称是`<路径>`的最后一个组成部分，如果你计划在一个新的主题上工作，这很方便。例如，`git worktree add .../hotfix`创建了新的分支`hotfix`，并在路径`.../hotfix`处签出它。如果要在一个新的工作区中处理现有的分支，可以使用`git worktree add <路径> <分支>`。另一方面，如果你只是打算做一些实验性的修改，或者在不影响现有开发的情况下进行测试，创建一个不与任何分支相关联的 \"抛弃式 \"工作区通常是很方便的。例如，`git worktree add -d <路径>`在与当前分支相同的提交中，创建一个带有分离`HEAD`的新工作区。"

#. type: Plain text
#: en/git-worktree.txt:57
#, placeholders:'gc.worktreePruneExpire':'linkgit:git-config[1]', priority:240
msgid "If a working tree is deleted without using `git worktree remove`, then its associated administrative files, which reside in the repository (see \"DETAILS\" below), will eventually be removed automatically (see `gc.worktreePruneExpire` in linkgit:git-config[1]), or you can run `git worktree prune` in the main or any linked worktree to clean up any stale administrative files."
msgstr "如果没有使用 `git worktree remove` 就删除了工作区，那么它的相关管理文件，即驻扎在仓库中的文件（见下面的 \"详细说明\"），最终会被自动删除（见 linkgit:git-config[1] 中的 `gc.worktreePruneExpire`），或者你可以在主工作区或任何链接工作区中运行`git worktree prune` 来清理任何过时的管理文件。"

#. type: Plain text
#: en/git-worktree.txt:63
#, placeholders:'`--reason`', priority:240
msgid "If the working tree for a linked worktree is stored on a portable device or network share which is not always mounted, you can prevent its administrative files from being pruned by issuing the `git worktree lock` command, optionally specifying `--reason` to explain why the worktree is locked."
msgstr "如果一个链接的工作区存储在便携设备或网络共享上，而这些设备并不总是被挂载，你可以通过发布`git worktree lock`命令来防止其管理文件被修剪，可以使用选项`--reason`来解释为什么工作树被锁定。"

#. type: Labeled list
#: en/git-worktree.txt:66
#, no-wrap, priority:240
msgid "add <path> [<commit-ish>]"
msgstr "add <路径> [<提交号>]"

#. type: Plain text
#: en/git-worktree.txt:72
#, placeholders:'HEAD':'{-1}', priority:240
msgid "Create a worktree at `<path>` and checkout `<commit-ish>` into it. The new worktree is linked to the current repository, sharing everything except per-worktree files such as `HEAD`, `index`, etc. As a convenience, `<commit-ish>` may be a bare \"`-`\", which is synonymous with `@{-1}`."
msgstr "在`<路径>`创建一个工作树，并将`<提交号>`签入其中。新的工作区被链接到当前仓库，共享除每个工作区文件（如`HEAD`、`index`等）之外的一切。为了方便起见，`<提交号>`可以是一个光秃秃的\"`-`\"，它与`@{-1}`同义。"

#. type: Plain text
#: en/git-worktree.txt:77
#, placeholders:'`-b`':'`-B`':'`--detach`', priority:240
msgid "If `<commit-ish>` is a branch name (call it `<branch>`) and is not found, and neither `-b` nor `-B` nor `--detach` are used, but there does exist a tracking branch in exactly one remote (call it `<remote>`) with a matching name, treat as equivalent to:"
msgstr "如果`<提交号>`是一个分支名称（称其为`<分支>`），并且没有找到，也没有使用`-b`或`-B`或`--detach`，但确实在正好一个远程仓库（称其为`<远程仓库>`）中存在一个名称匹配的跟踪分支，则视为等同于："

#. type: delimited block -
#: en/git-worktree.txt:80
#, no-wrap, placeholders:'--track', priority:240
msgid "$ git worktree add --track -b <branch> <path> <remote>/<branch>\n"
msgstr "$ git worktree add --track -b <分支> <路径> <远程仓库>/<分支>\n"

#. type: Plain text
#: en/git-worktree.txt:90
#, placeholders:'checkout.defaultRemote':'checkout.defaultRemote':'checkout.defaultRemote':'linkgit:git-config[1]', priority:240
msgid "If the branch exists in multiple remotes and one of them is named by the `checkout.defaultRemote` configuration variable, we'll use that one for the purposes of disambiguation, even if the `<branch>` isn't unique across all remotes. Set it to e.g. `checkout.defaultRemote=origin` to always checkout remote branches from there if `<branch>` is ambiguous but exists on the `origin` remote. See also `checkout.defaultRemote` in linkgit:git-config[1]."
msgstr "如果该分支存在于多个远程仓库，并且其中一个是由`checkout.defaultRemote`配置变量命名的，为了消除歧义，我们将使用该变量，即使`<分支>`在所有远程中并不唯一。将其设置为例如 `checkout.defaultRemote=origin`，以便在`<分支>`不明确但存在于'origin'远程时，总是从那里签出远程分支。参见 linkgit:git-config[1] 中的 `checkout.defaultRemote`。"

# ERROR: --detach not found in translation
#. type: Plain text
#: en/git-worktree.txt:98
#, placeholders:'`-b`':'`-B`':'`--detach`':'HEAD':'`--force`', priority:240
msgid "If `<commit-ish>` is omitted and neither `-b` nor `-B` nor `--detach` used, then, as a convenience, the new worktree is associated with a branch (call it `<branch>`) named after `$(basename <path>)`. If `<branch>` doesn't exist, a new branch based on `HEAD` is automatically created as if `-b <branch>` was given. If `<branch>` does exist, it will be checked out in the new worktree, if it's not checked out anywhere else, otherwise the command will refuse to create the worktree (unless `--force` is used)."
msgstr "如果省略了 `<提交号>`，也没有使用 `-b` 或 `-B` 或 `--detach` ，那么作为一种方便，新的工作区将与一个以 `$(basename <路径>)` 命名的分支（称为 `<分支>` ）相关联。 如果 `<分支>` 不存在，一个基于 `HEAD` 的新分支将被自动创建，就像给出 `-b <分支>` 一样。 如果 `<分支>` 确实存在，它将在新的工作区中被签出，如果它没有在其他地方被签出，否则命令将拒绝创建工作区（除非使用 `--force`）。"

#. type: Plain text
#: en/git-worktree.txt:108
#, placeholders:'`--detach`':'`--orphan`':'`--guess-remote`':'`-b`':'`-B`':'`--orphan`':'`--guess-remote`':'--force`', priority:240
msgid "If `<commit-ish>` is omitted, neither `--detach`, or `--orphan` is used, and there are no valid local branches (or remote branches if `--guess-remote` is specified) then, as a convenience, the new worktree is associated with a new unborn branch named `<branch>` (after `$(basename <path>)` if neither `-b` or `-B` is used) as if `--orphan` was passed to the command. In the event the repository has a remote and `--guess-remote` is used, but no remote or local branches exist, then the command fails with a warning reminding the user to fetch from their remote first (or override by using `-f/--force`)."
msgstr "如果省略了 `<commit-ish>`，既没有使用 `--detach`，也没有使用 `--orphan`，并且没有有效的本地分支（或远程分支，如果指定了 `--guess-remote`），那么为了方便起见，新的工作树会与一个名为 `<branch>` 的未出生分支关联（如果没有使用 `-b` 或 `-B`，则在 `$(basename <path>)`之后），就像向命令传递了 `--orphan`一样。如果仓库有远程分支，并且使用了 `--guess-remote`，但不存在远程或本地分支，则命令会失败，并发出警告，提醒用户先从远程获取（或使用 `-f/--force` 覆盖）。"

#. type: Plain text
#: en/git-worktree.txt:117
#, placeholders:'HEAD', priority:240
msgid "List details of each worktree. The main worktree is listed first, followed by each of the linked worktrees. The output details include whether the worktree is bare, the revision currently checked out, the branch currently checked out (or \"detached HEAD\" if none), \"locked\" if the worktree is locked, \"prunable\" if the worktree can be pruned by the `prune` command."
msgstr "列出每个工作区的细节。 主工作区被首先列出，接着是每个链接工作区。 输出的细节包括该工作区是否为裸树，当前签出的修订版，当前检出的分支（如果没有则为 \"分离的HEAD\"），如果工作树被锁定则为 \"锁定\"，如果工作树可以被`prune`命令修剪则为 \"可修剪\"。"

#. type: Labeled list
#: en/git-worktree.txt:118
#, ignore-same, no-wrap, priority:240
msgid "lock"
msgstr "lock"

#. type: Plain text
#: en/git-worktree.txt:124
#, placeholders:'`--reason`', priority:240
msgid "If a worktree is on a portable device or network share which is not always mounted, lock it to prevent its administrative files from being pruned automatically. This also prevents it from being moved or deleted. Optionally, specify a reason for the lock with `--reason`."
msgstr "如果一个工作区在便携式设备或网络共享上，而这个设备或网络共享并不总是被挂载，请锁定它以防止其管理文件被自动修剪。这也可以防止它被移动或删除。 可以选择用`--reason`选项来指定锁定的原因。"

#. type: Labeled list
#: en/git-worktree.txt:125
#, ignore-same, no-wrap, priority:240
msgid "move"
msgstr "move"

#. type: Plain text
#: en/git-worktree.txt:131
#, priority:240
msgid "Move a worktree to a new location. Note that the main worktree or linked worktrees containing submodules cannot be moved with this command. (The `git worktree repair` command, however, can reestablish the connection with linked worktrees if you move the main worktree manually.)"
msgstr "将一个工作区移动到一个新的位置。注意，主工作区或包含子模块的链接工作区不能用此命令移动。(然而，如果你手动移动主工作区，`git worktree repair`命令可以重新建立与链接工作区的连接。）"

#. type: Plain text
#: en/git-worktree.txt:135
#, placeholders:'$GIT_DIR', priority:240
msgid "Prune worktree information in `$GIT_DIR/worktrees`."
msgstr "修剪`$GIT_DIR/worktrees`中的工作区信息。"

#. type: Plain text
#: en/git-worktree.txt:142
#, placeholders:'`--force`', priority:240
msgid "Remove a worktree. Only clean worktrees (no untracked files and no modification in tracked files) can be removed. Unclean worktrees or ones with submodules can be removed with `--force`. The main worktree cannot be removed."
msgstr "移除一个工作区。只有干净的工作区（没有未跟踪的文件和未修改的跟踪文件）可以被删除。脏工作区或有子模块的工作区可以用 `--force` 删除。主工作区不能被删除。"

#. type: Labeled list
#: en/git-worktree.txt:143
#, ignore-ellipsis, no-wrap, priority:240
msgid "repair [<path>...]"
msgstr "repair [<路径>...]"

#. type: Plain text
#: en/git-worktree.txt:147
#, priority:240
msgid "Repair worktree administrative files, if possible, if they have become corrupted or outdated due to external factors."
msgstr "如果可能的话，修复工作区的管理文件，如果它们由于外部因素而变得损坏或过时。"

#. type: Plain text
#: en/git-worktree.txt:152
#, priority:240
msgid "For instance, if the main worktree (or bare repository) is moved, linked worktrees will be unable to locate it. Running `repair` in the main worktree will reestablish the connection from linked worktrees back to the main worktree."
msgstr "例如，如果主工作区（或裸仓库）被移动，链接工作区将无法找到它。在主工作区中运行 `repair` 将重新建立从链接工作区到主工作区的连接。"

#. type: Plain text
#: en/git-worktree.txt:159
#, priority:240
msgid "Similarly, if the working tree for a linked worktree is moved without using `git worktree move`, the main worktree (or bare repository) will be unable to locate it. Running `repair` within the recently-moved worktree will reestablish the connection. If multiple linked worktrees are moved, running `repair` from any worktree with each tree's new `<path>` as an argument, will reestablish the connection to all the specified paths."
msgstr "同样地，如果没有使用 `git worktree move` 就移动了链接工作区，主工作区（或裸仓库）将无法定位它。在最近移动的工作区中运行`repair`将重新建立连接。如果多个链接工作区被移动，在任何工作区中运行`repair`，以每个树的新`<路径>`作为参数，将重新建立与所有指定路径的连接。"

#. type: Plain text
#: en/git-worktree.txt:164
#, priority:240
msgid "If both the main worktree and linked worktrees have been moved manually, then running `repair` in the main worktree and specifying the new `<path>` of each linked worktree will reestablish all connections in both directions."
msgstr "如果主工作区和链接工作区都被手动移动，那么在主工作区中运行`repair`并指定每个链接工作树的新`<路径>`将重新建立两个方向的所有连接。"

#. type: Labeled list
#: en/git-worktree.txt:165
#, ignore-same, no-wrap, priority:240
msgid "unlock"
msgstr "unlock"

#. type: Plain text
#: en/git-worktree.txt:168
#, priority:240
msgid "Unlock a worktree, allowing it to be pruned, moved or deleted."
msgstr "解锁一个工作区，允许它被修剪、移动或删除。"

#. type: Plain text
#: en/git-worktree.txt:180
#, placeholders:'`--force`', priority:240
msgid "By default, `add` refuses to create a new worktree when `<commit-ish>` is a branch name and is already checked out by another worktree, or if `<path>` is already assigned to some worktree but is missing (for instance, if `<path>` was deleted manually). This option overrides these safeguards. To add a missing but locked worktree path, specify `--force` twice."
msgstr "默认情况下，当`<提交号>`是一个分支名称，并且已经被另一个工作树签出，或者`<路径>`已经被分配给某个工作树，但丢失了（例如，如果`<路径>`被手动删除），`add`拒绝创建一个新的工作树。这个选项覆盖了这些保护措施。要添加一个缺失但锁定的工作区路径，请指定`--force`两次。"

#. type: Plain text
#: en/git-worktree.txt:185
#, placeholders:'`--force`':'`--force`':'`--force`', priority:240
msgid "`move` refuses to move a locked worktree unless `--force` is specified twice. If the destination is already assigned to some other worktree but is missing (for instance, if `<new-path>` was deleted manually), then `--force` allows the move to proceed; use `--force` twice if the destination is locked."
msgstr "`move`拒绝移动一个被锁定的工作区，除非`--force`被指定两次。如果目的地已经被分配给其他工作区，但没有找到（例如，如果`<新路径>`被手动删除），那么`--force`允许移动；如果目的地被锁定，则使用`--force`两次。"

#. type: Plain text
#: en/git-worktree.txt:188
#, placeholders:'`--force`':'`--force`', priority:240
msgid "`remove` refuses to remove an unclean worktree unless `--force` is used. To remove a locked worktree, specify `--force` twice."
msgstr "`remove`拒绝删除一个脏工作区，除非使用`--force`。 要删除一个锁定的工作区，需要指定`--force`两次。"

#. type: Plain text
#: en/git-worktree.txt:197
#, placeholders:'HEAD':'`-b`':'`-B`', priority:240
msgid "With `add`, create a new branch named `<new-branch>` starting at `<commit-ish>`, and check out `<new-branch>` into the new worktree. If `<commit-ish>` is omitted, it defaults to `HEAD`. By default, `-b` refuses to create a new branch if it already exists. `-B` overrides this safeguard, resetting `<new-branch>` to `<commit-ish>`."
msgstr "通过`add`，创建一个名为`<新分支>`的新分支，从`<提交号>`开始，并将`<新分支>`检出到新的工作树。 如果省略了`<提交号>`，则默认为`HEAD`。 默认情况下，如果一个新的分支已经存在，`-b`会拒绝创建它。`-B`则不会拒绝创建，将`<新分支>`重置为`<提交号>`。"

#. type: Plain text
#: en/git-worktree.txt:202
#, placeholders:'HEAD':'HEAD':'linkgit:git-checkout[1]', priority:240
msgid "With `add`, detach `HEAD` in the new worktree. See \"DETACHED HEAD\" in linkgit:git-checkout[1]."
msgstr "通过 `add`，在新的工作树中分离出 `HEAD`。参见 linkgit:git-checkout[1] 中的 “分离式 HEAD”。"

#. type: Labeled list
#: en/git-worktree.txt:203
#, ignore-same, no-wrap, priority:240
msgid "--[no-]checkout"
msgstr "--[no-]checkout"

#. type: Plain text
#: en/git-worktree.txt:208
#, placeholders:'`--no-checkout`':'linkgit:git-read-tree[1]', priority:240
msgid "By default, `add` checks out `<commit-ish>`, however, `--no-checkout` can be used to suppress checkout in order to make customizations, such as configuring sparse-checkout. See \"Sparse checkout\" in linkgit:git-read-tree[1]."
msgstr "默认情况下，`add`会检出`<提交号>`，然而，`--no-checkout`可以用来抑制检出，以便进行定制，比如配置稀疏检出。参见 linkgit:git-read-tree[1] 中的 \"稀疏检出\"。"

#. type: Labeled list
#: en/git-worktree.txt:209
#, ignore-same, no-wrap, priority:240
msgid "--[no-]guess-remote"
msgstr "--[no-]guess-remote"

#. type: Plain text
#: en/git-worktree.txt:215
#, placeholders:'HEAD', priority:240
msgid "With `worktree add <path>`, without `<commit-ish>`, instead of creating a new branch from `HEAD`, if there exists a tracking branch in exactly one remote matching the basename of `<path>`, base the new branch on the remote-tracking branch, and mark the remote-tracking branch as \"upstream\" from the new branch."
msgstr "在`worktree add <路径>`下，如果没有`<提交号>`，则不从`HEAD`创建新的分支，而是在正好有一个与`<路径>`的基名相匹配的远程跟踪分支的情况下，将新的分支建立在远程跟踪分支上，并将远程跟踪分支标记为新分支的 \"上游\"。"

#. type: Plain text
#: en/git-worktree.txt:218
#, placeholders:'worktree.guessRemote', priority:240
msgid "This can also be set up as the default behaviour by using the `worktree.guessRemote` config option."
msgstr "这也可以通过使用`worktree.guessRemote`配置选项设置为默认行为。"

#. type: Labeled list
#: en/git-worktree.txt:219
#, ignore-same, no-wrap, priority:240
msgid "--[no-]track"
msgstr "--[no-]track"

#. type: Plain text
#: en/git-worktree.txt:224
#, placeholders:'`--track`', priority:240
msgid "When creating a new branch, if `<commit-ish>` is a branch, mark it as \"upstream\" from the new branch. This is the default if `<commit-ish>` is a remote-tracking branch. See `--track` in linkgit:git-branch[1] for details."
msgstr "当创建一个新的分支时，如果 `<提交号>` 是一个分支，则将其标记为新分支的 \"上游\"。 默认认为 `<提交号>` 是一个远程跟踪分支。 详情见 linkgit:git-branch[1] 中的 `--track`。"

#. type: Labeled list
#: en/git-worktree.txt:225
#, ignore-same, no-wrap, priority:240
msgid "--lock"
msgstr "--lock"

#. type: Plain text
#: en/git-worktree.txt:229
#, priority:240
msgid "Keep the worktree locked after creation. This is the equivalent of `git worktree lock` after `git worktree add`, but without a race condition."
msgstr "在创建后保持工作区的锁定。这相当于在`git worktree add`之后执行`git worktree lock`，但没有资源竞争。"

#. type: Plain text
#: en/git-worktree.txt:234
#, priority:240
msgid "With `prune`, do not remove anything; just report what it would remove."
msgstr "在使用`prune`时，不会删除任何文件；只会报告它要删除的东西。"

#. type: Labeled list
#: en/git-worktree.txt:235
#, ignore-same, no-wrap, priority:240
msgid "--orphan"
msgstr "--orphan"

#. type: Plain text
#: en/git-worktree.txt:238
#, priority:240
msgid "With `add`, make the new worktree and index empty, associating the worktree with a new unborn branch named `<new-branch>`."
msgstr "使用 `add` 使新的工作区和索引为空，并将工作树与名为 `<new-branch>` 的新孤儿/未出生分支关联起来。"

#. type: Plain text
#: en/git-worktree.txt:244
#, placeholders:'`-z`', priority:240
msgid "With `list`, output in an easy-to-parse format for scripts. This format will remain stable across Git versions and regardless of user configuration. It is recommended to combine this with `-z`. See below for details."
msgstr "使用 `list` 时，脚本会以易于解析的格式输出。 这种格式在不同的 Git 版本和用户配置下都会保持稳定。 建议与 `-z` 搭配使用。 详见下文。"

#. type: Plain text
#: en/git-worktree.txt:250
#, placeholders:'`--porcelain`', priority:240
msgid "Terminate each line with a NUL rather than a newline when `--porcelain` is specified with `list`. This makes it possible to parse the output when a worktree path contains a newline character."
msgstr "当`--porcelain`与`list`一起指定时，用NUL而不是换行来结束每一行。这使得在工作区路径包含换行符时，可以解析输出。"

#. type: Plain text
#: en/git-worktree.txt:254
#, priority:240
msgid "With `add`, suppress feedback messages."
msgstr "用`add`，抑制反馈信息。"

#. type: Plain text
#: en/git-worktree.txt:258
#, priority:240
msgid "With `prune`, report all removals."
msgstr "使用`prune`，报告所有的移除情况。"

#. type: Plain text
#: en/git-worktree.txt:260
#, priority:240
msgid "With `list`, output additional information about worktrees (see below)."
msgstr "用`list`，输出关于工作区的额外信息（见下文）。"

#. type: Plain text
#: en/git-worktree.txt:263
#, priority:240
msgid "With `prune`, only expire unused worktrees older than `<time>`."
msgstr "使用 `prune`，只对超过`<时间>`未使用的工作区进行淘汰。"

#. type: Plain text
#: en/git-worktree.txt:266
#, priority:240
msgid "With `list`, annotate missing worktrees as prunable if they are older than `<time>`."
msgstr "使用`list`，如果丢失的工作区比`<时间>`早，则将其注释为可修剪。"

#. type: Labeled list
#: en/git-worktree.txt:267
#, no-wrap, placeholders:'--reason', priority:240
msgid "--reason <string>"
msgstr "--reason <字符串>"

#. type: Plain text
#: en/git-worktree.txt:270
#, placeholders:'--lock`', priority:240
msgid "With `lock` or with `add --lock`, an explanation why the worktree is locked."
msgstr "用`lock`或用`add --lock`，解释为什么工作区被锁定。"

#. type: Labeled list
#: en/git-worktree.txt:271
#, no-wrap, priority:240
msgid "<worktree>"
msgstr "<工作区>"

#. type: Plain text
#: en/git-worktree.txt:273
#, priority:240
msgid "Worktrees can be identified by path, either relative or absolute."
msgstr "工作区可以通过相对或绝对路径来识别。"

#. type: Plain text
#: en/git-worktree.txt:278
#, priority:240
msgid "If the last path components in the worktree's path is unique among worktrees, it can be used to identify a worktree. For example if you only have two worktrees, at `/abc/def/ghi` and `/abc/def/ggg`, then `ghi` or `def/ghi` is enough to point to the former worktree."
msgstr "如果工作区路径中的后几个层次在工作树中是唯一的，则它可以用来识别一个工作树。例如，如果你只有两个工作区，在`/abc/def/ghi`和`/abc/def/ggg`，那么使用`ghi`或`def/ghi`就足以指向前一个工作区。"

#. type: Title -
#: en/git-worktree.txt:280
#, no-wrap, priority:240
msgid "REFS"
msgstr "引用"

#. type: Plain text
#: en/git-worktree.txt:285
#, placeholders:'HEAD', priority:240
msgid "When using multiple worktrees, some refs are shared between all worktrees, but others are specific to an individual worktree. One example is `HEAD`, which is different for each worktree. This section is about the sharing rules and how to access refs of one worktree from another."
msgstr "当使用多个工作区时，一些引用在所有工作区之间共享，但其他引用是特定于单个工作区的。比如：`HEAD`，它对每个工作树都是不同的。本节是关于共享规则，以及如何从另一个工作区访问一个工作区的引用。"

#. type: Plain text
#: en/git-worktree.txt:291
#, placeholders:'HEAD':'$GIT_DIR':'$GIT_DIR', priority:240
msgid "In general, all pseudo refs are per-worktree and all refs starting with `refs/` are shared. Pseudo refs are ones like `HEAD` which are directly under `$GIT_DIR` instead of inside `$GIT_DIR/refs`. There are exceptions, however: refs inside `refs/bisect`, `refs/worktree` and `refs/rewritten` are not shared."
msgstr "一般来说，所有伪引用都是按工作区划分的，而所有以 `refs/` 开头的引用都是共享的。伪引用与 `HEAD` 类似，直接位于 `$GIT_DIR` 下，而不是 `$GIT_DIR/refs` 内。但也有例外：`refs/bisect`、`refs/worktree` 和`refs/rewitten` 中的引用不共享。"

#. type: Plain text
#: en/git-worktree.txt:296
#, priority:240
msgid "Refs that are per-worktree can still be accessed from another worktree via two special paths, `main-worktree` and `worktrees`. The former gives access to per-worktree refs of the main worktree, while the latter to all linked worktrees."
msgstr "每个工作区的引用仍然可以通过两个特殊的路径，即 `主工作区`和 `从工作区`，从另一个工作区访问。前者可以访问主工作区的每个工作区的引用，而后者可以访问所有链接的工作区。"

#. type: Plain text
#: en/git-worktree.txt:303
#, placeholders:'HEAD':'HEAD':'HEAD':'$GIT_COMMON_DIR':'HEAD':'$GIT_COMMON_DIR', priority:240
msgid "For example, `main-worktree/HEAD` or `main-worktree/refs/bisect/good` resolve to the same value as the main worktree's `HEAD` and `refs/bisect/good` respectively. Similarly, `worktrees/foo/HEAD` or `worktrees/bar/refs/bisect/bad` are the same as `$GIT_COMMON_DIR/worktrees/foo/HEAD` and `$GIT_COMMON_DIR/worktrees/bar/refs/bisect/bad`."
msgstr "例如，`main-worktree/HEAD`或`main-worktree/refs/bisect/good`分别解析到与主工作区的`HEAD`和`refs/bisect/good`相同的值。类似地，`worktrees/foo/HEAD`或`worktrees/bar/refs/bisect/bad`与`$GIT_COMMON_DIR/worktrees/foo/HEAD`和`$GIT_COMMON_DIR/worktrees/bar/refs/bisect/bad`相同。"

#. type: Plain text
#: en/git-worktree.txt:307
#, placeholders:'$GIT_DIR':'linkgit:git-rev-parse[1]':'linkgit:git-update-ref[1]', priority:240
msgid "To access refs, it's best not to look inside `$GIT_DIR` directly. Instead use commands such as linkgit:git-rev-parse[1] or linkgit:git-update-ref[1] which will handle refs correctly."
msgstr "要访问引用，最好不要直接在 `$GIT_DIR` 中查找。相反，使用 linkgit:git-rev-parse[1] 或 linkgit:git-update-ref[1] 这样的命令可以正确处理引用。"

#. type: Plain text
#: en/git-worktree.txt:314
#, placeholders:'core.bare':'core.worktree':'extensions.worktreeConfig', priority:240
msgid "By default, the repository `config` file is shared across all worktrees. If the config variables `core.bare` or `core.worktree` are present in the common config file and `extensions.worktreeConfig` is disabled, then they will be applied to the main worktree only."
msgstr "默认情况下，资源库的`config`文件在所有工作区上共享。 如果配置变量`core.bare`或`core.worktree`存在于公共配置文件中，并且`extensions.worktreeConfig`被禁用，那么它们将只应用于主工作区。"

#. type: Plain text
#: en/git-worktree.txt:317
#, priority:240
msgid "In order to have worktree-specific configuration, you can turn on the `worktreeConfig` extension, e.g.:"
msgstr "为了对工作区进行特定配置，你可以打开`worktreeConfig`扩展，例如："

#. type: delimited block -
#: en/git-worktree.txt:320
#, no-wrap, placeholders:'extensions.worktreeConfig', priority:240
msgid "$ git config extensions.worktreeConfig true\n"
msgstr "$ git config extensions.worktreeConfig true\n"

#. type: Plain text
#: en/git-worktree.txt:326
#, placeholders:'git rev-parse':'--git-path':'config.worktree':'--worktree`', priority:240
msgid "In this mode, specific configuration stays in the path pointed by `git rev-parse --git-path config.worktree`. You can add or update configuration in this file with `git config --worktree`. Older Git versions will refuse to access repositories with this extension."
msgstr "在这种模式下，特定的配置保持在`git rev-parse --git-path config.worktree`所指向的路径中。你可以用`git config --worktree`添加或更新该文件中的配置。旧版本的Git会拒绝访问带有这个扩展的仓库。"

#. type: Plain text
#: en/git-worktree.txt:332
#, placeholders:'core.bare':'core.worktree':'$GIT_DIR':'config.worktree', priority:240
msgid "Note that in this file, the exception for `core.bare` and `core.worktree` is gone. If they exist in `$GIT_DIR/config`, you must move them to the `config.worktree` of the main worktree. You may also take this opportunity to review and move other configuration that you do not want to share to all worktrees:"
msgstr "注意，在这个文件中，`core.bare`和`core.worktree`的例外情况已经消失。如果它们存在于`$GIT_DIR/config`中，你必须把它们移到主工作区的`config.worktree`中。你也可以借此机会审查和移动其他你不想共享到所有工作区的配置："

#. type: Plain text
#: en/git-worktree.txt:334
#, placeholders:'core.worktree', priority:240
msgid "`core.worktree` should never be shared."
msgstr "`core.worktree`不应该被共享。"

#. type: Plain text
#: en/git-worktree.txt:336
#, placeholders:'core.bare':'core.bare', priority:240
msgid "`core.bare` should not be shared if the value is `core.bare=true`."
msgstr "如果`core.bare`的值为`core.bare=true`，则不应共享。"

#. type: Plain text
#: en/git-worktree.txt:339
#, placeholders:'core.sparseCheckout', priority:240
msgid "`core.sparseCheckout` should not be shared, unless you are sure you always use sparse checkout for all worktrees."
msgstr "`core.sparseCheckout`不应该被共享，除非你确信你总是对所有工作区使用稀疏检出。"

#. type: Plain text
#: en/git-worktree.txt:342
#, placeholders:'extensions.worktreeConfig':'linkgit:git-config[1]', priority:240
msgid "See the documentation of `extensions.worktreeConfig` in linkgit:git-config[1] for more details."
msgstr "更多细节请参见 linkgit:git-config[1] 中的 `extensions.worktreeConfig` 文档。"

#. type: Title -
#: en/git-worktree.txt:344
#, no-wrap, priority:240
msgid "DETAILS"
msgstr "详细信息"

#. type: Plain text
#: en/git-worktree.txt:353
#, placeholders:'$GIT_DIR':'$GIT_DIR':'$GIT_DIR':'$GIT_DIR', priority:240
msgid "Each linked worktree has a private sub-directory in the repository's `$GIT_DIR/worktrees` directory. The private sub-directory's name is usually the base name of the linked worktree's path, possibly appended with a number to make it unique. For example, when `$GIT_DIR=/path/main/.git` the command `git worktree add /path/other/test-next next` creates the linked worktree in `/path/other/test-next` and also creates a `$GIT_DIR/worktrees/test-next` directory (or `$GIT_DIR/worktrees/test-next1` if `test-next` is already taken)."
msgstr "每个链接工作区在仓库的`$GIT_DIR/worktrees`目录下都有一个私有子目录。 私有子目录的名称通常是被链接的工作树路径的基本名称，但可能加上一个数字以使成为唯一目录。 例如，当`$GIT_DIR=/path/main/.git`时，命令`git worktree add /path/other/test-next next`会在`/path/other/test-next`中创建链接工作区，同时创建一个`$GIT_DIR/worktrees/test-next`目录（如果`test-next`已经被占用，则创建`$GIT_DIR/worktrees/test-next1`）。"

#. type: Plain text
#: en/git-worktree.txt:359
#, placeholders:'$GIT_DIR':'$GIT_COMMON_DIR':'$GIT_DIR', priority:240
msgid "Within a linked worktree, `$GIT_DIR` is set to point to this private directory (e.g. `/path/main/.git/worktrees/test-next` in the example) and `$GIT_COMMON_DIR` is set to point back to the main worktree's `$GIT_DIR` (e.g. `/path/main/.git`). These settings are made in a `.git` file located at the top directory of the linked worktree."
msgstr "在一个链接工作区中，`$GIT_DIR`设置为指向这个私有目录（例如，例子中的`/path/main/.git/worktrees/test-next`），`$GIT_COMMON_DIR`会被设置为指向主工作区的`$GIT_DIR`（例如，`/path/main/.git`）。这些设置是在位于链接工作区顶级目录的`.git`文件中进行的。"

#. type: Plain text
#: en/git-worktree.txt:369
#, placeholders:'git rev-parse':'--git-path`':'$GIT_DIR':'$GIT_COMMON_DIR':'git rev-parse':'--git-path':'HEAD':'HEAD':'.git/HEAD':'.git/HEAD':'git rev-parse':'--git-path':'$GIT_COMMON_DIR', priority:240
msgid "Path resolution via `git rev-parse --git-path` uses either `$GIT_DIR` or `$GIT_COMMON_DIR` depending on the path. For example, in the linked worktree `git rev-parse --git-path HEAD` returns `/path/main/.git/worktrees/test-next/HEAD` (not `/path/other/test-next/.git/HEAD` or `/path/main/.git/HEAD`) while `git rev-parse --git-path refs/heads/master` uses `$GIT_COMMON_DIR` and returns `/path/main/.git/refs/heads/master`, since refs are shared across all worktrees, except `refs/bisect`, `refs/worktree` and `refs/rewritten`."
msgstr "通过 `git rev-parse --git-path` 进行路径解析时，会根据路径使用 `$GIT_DIR` 或 `$GIT_COMMON_DIR`。例如，在链接的工作区中，`git rev-parse --git-path HEAD` 返回 `/path/main/.git/worktrees/test-next/HEAD` （而不是 `/path/other/test-next/.git/HEAD` 或 `/path/main/.git/HEAD`），而 `git rev-parse --git-path refs/heads/master` 使用 `$GIT_COMMON_DIR`，并返回 `/path/main/.git/refs/heads/master`，因为除了 `refs/bisect`、`refs/worktree` 和 `refs/rewitten`，所有工作区都共享引用。"

#. type: Plain text
#: en/git-worktree.txt:374
#, placeholders:'linkgit:gitrepository-layout[5]':'$GIT_DIR':'$GIT_COMMON_DIR':'$GIT_DIR':'git rev-parse':'--git-path`', priority:240
msgid "See linkgit:gitrepository-layout[5] for more information. The rule of thumb is do not make any assumption about whether a path belongs to `$GIT_DIR` or `$GIT_COMMON_DIR` when you need to directly access something inside `$GIT_DIR`. Use `git rev-parse --git-path` to get the final path."
msgstr "更多信息见 linkgit:gitrepository-layout[5]。经验法则是，当你需要直接访问`$GIT_DIR`或`$GIT_COMMON_DIR`内的东西时，不要对路径是否属于`$GIT_DIR`做出任何假设。使用`git rev-parse --git-path`来获得最终路径。"

#. type: Plain text
#: en/git-worktree.txt:382
#, priority:240
msgid "If you manually move a linked worktree, you need to update the `gitdir` file in the entry's directory. For example, if a linked worktree is moved to `/newpath/test-next` and its `.git` file points to `/path/main/.git/worktrees/test-next`, then update `/path/main/.git/worktrees/test-next/gitdir` to reference `/newpath/test-next` instead. Better yet, run `git worktree repair` to reestablish the connection automatically."
msgstr "如果你手动移动一个链接工作区，你需要更新该条目目录下的`gitdir`文件。例如，如果一个链接工作区被移到`/newpath/test-next`，而它的`.git`文件指向`/path/main/.git/worktrees/test-next`，那么更新`/path/main/.git/worktrees/test-next/gitdir`以引用`/newpath/test-next`。除此之外，更好的选择是，运行`git worktree repair`来自动重新建立连接。"

#. type: Plain text
#: en/git-worktree.txt:393
#, placeholders:'$GIT_DIR':'linkgit:gitrepository-layout[5]', priority:240
msgid "To prevent a `$GIT_DIR/worktrees` entry from being pruned (which can be useful in some situations, such as when the entry's worktree is stored on a portable device), use the `git worktree lock` command, which adds a file named `locked` to the entry's directory. The file contains the reason in plain text. For example, if a linked worktree's `.git` file points to `/path/main/.git/worktrees/test-next` then a file named `/path/main/.git/worktrees/test-next/locked` will prevent the `test-next` entry from being pruned. See linkgit:gitrepository-layout[5] for details."
msgstr "为了防止`$GIT_DIR/worktrees`条目被修剪（这在某些情况下很有用，比如该条目的工作区存储在便携设备上），使用`git worktree lock`命令，它会在条目的目录中添加一个名为`locked`的文件。该文件包含纯文本的原因。例如，如果一个链接工作区的`.git`文件指向`/path/main/.git/worktrees/test-next`，那么一个名为`/path/main/.git/worktrees/test-next/locked`的文件将阻止`test-next`条目被剪除。 详情见linkgit:gitrepository-layout[5]。"

#. type: Plain text
#: en/git-worktree.txt:396
#, placeholders:'extensions.worktreeConfig':'config.worktree', priority:240
msgid "When `extensions.worktreeConfig` is enabled, the config file `.git/worktrees/<id>/config.worktree` is read after `.git/config` is."
msgstr "当`extensions.worktreeConfig`被启用时，在`.git/config`之后会读取`.git/worktrees/<id>/config.worktree`的配置文件。"

#. type: Title -
#: en/git-worktree.txt:398
#, no-wrap, priority:240
msgid "LIST OUTPUT FORMAT"
msgstr "列表输出格式"

#. type: Plain text
#: en/git-worktree.txt:401
#, priority:240
msgid "The `worktree list` command has two output formats. The default format shows the details on a single line with columns. For example:"
msgstr "`worktree list` 命令有两种输出格式。默认的格式是在单行上显示细节，并带有列。 例如："

#. type: delimited block -
#: en/git-worktree.txt:407
#, no-wrap, placeholders:'HEAD', priority:240
msgid ""
"$ git worktree list\n"
"/path/to/bare-source            (bare)\n"
"/path/to/linked-worktree        abcd1234 [master]\n"
"/path/to/other-linked-worktree  1234abc  (detached HEAD)\n"
msgstr ""
"$ git worktree list\n"
"/path/to/bare-source            (裸)\n"
"/path/to/linked-worktree        abcd1234 [master]\n"
"/path/to/other-linked-worktree  1234abc  (分离式HEAD)\n"

#. type: Plain text
#: en/git-worktree.txt:411
#, priority:240
msgid "The command also shows annotations for each worktree, according to its state. These annotations are:"
msgstr "该命令还根据每个工作区的状态，显示其注释。 这些注释是："

#. type: Plain text
#: en/git-worktree.txt:413
#, priority:240
msgid "`locked`, if the worktree is locked."
msgstr "`locked`，如果工作区被锁定。"

#. type: Plain text
#: en/git-worktree.txt:414
#, priority:240
msgid "`prunable`, if the worktree can be pruned via `git worktree prune`."
msgstr "`prunable`，如果工作区可以通过`git worktree prune`进行修剪。"

#. type: delimited block -
#: en/git-worktree.txt:420
#, no-wrap, placeholders:'HEAD', priority:240
msgid ""
"$ git worktree list\n"
"/path/to/linked-worktree    abcd1234 [master]\n"
"/path/to/locked-worktree    acbd5678 (brancha) locked\n"
"/path/to/prunable-worktree  5678abc  (detached HEAD) prunable\n"
msgstr ""
"$ git worktree list\n"
"/path/to/bare-source            (裸)\n"
"/path/to/linked-worktree        abcd1234 [master]\n"
"/path/to/other-linked-worktree  1234abc  (分离式HEAD)\n"

#. type: Plain text
#: en/git-worktree.txt:425
#, priority:240
msgid "For these annotations, a reason might also be available and this can be seen using the verbose mode. The annotation is then moved to the next line indented followed by the additional information."
msgstr "对于这些注释，也可能有一个原因，这可以通过verbose模式看到。然后注释被移到下一行缩进，后面是附加信息。"

#. type: delimited block -
#: en/git-worktree.txt:434
#, no-wrap, placeholders:'--verbose':'HEAD':'HEAD', priority:240
msgid ""
"$ git worktree list --verbose\n"
"/path/to/linked-worktree              abcd1234 [master]\n"
"/path/to/locked-worktree-no-reason    abcd5678 (detached HEAD) locked\n"
"/path/to/locked-worktree-with-reason  1234abcd (brancha)\n"
"\tlocked: worktree path is mounted on a portable device\n"
"/path/to/prunable-worktree            5678abc1 (detached HEAD)\n"
"\tprunable: gitdir file points to non-existent location\n"
msgstr ""
"$ git worktree list --verbose\n"
"/path/to/linked-worktree                           abcd1234 [master]\n"
"/path/to/locked-worktree-no-reason    abcd5678 (分离的 HEAD) locked\n"
"/path/to/locked-worktree-with-reason  1234abcd (brancha)\n"
"\t锁定：工作区路径被安装在一个可移动设备上\n"
"/path/to/prunable-worktree            5678abc1 (分离的 HEAD)\n"
"\t可修剪：gitdir 文件指向不存在的位置\n"

#. type: Plain text
#: en/git-worktree.txt:439
#, priority:240
msgid "Note that the annotation is moved to the next line if the additional information is available, otherwise it stays on the same line as the worktree itself."
msgstr "注意，如果有额外的信息，注释将被移到下一行，否则它将与工作区本身保持在同一行。"

#. type: Title ~
#: en/git-worktree.txt:441
#, no-wrap, priority:240
msgid "Porcelain Format"
msgstr "上层命令格式"

#. type: Plain text
#: en/git-worktree.txt:450
#, placeholders:'`-z`', priority:240
msgid "The porcelain format has a line per attribute. If `-z` is given then the lines are terminated with NUL rather than a newline. Attributes are listed with a label and value separated by a single space. Boolean attributes (like `bare` and `detached`) are listed as a label only, and are present only if the value is true. Some attributes (like `locked`) can be listed as a label only or with a value depending upon whether a reason is available. The first attribute of a worktree is always `worktree`, an empty line indicates the end of the record. For example:"
msgstr "上层命令的每个属性有一行。 如果给了`-z`，那么这几行将以NUL（空字符）而不是换行来结束。 属性以标签和值的形式列出，用一个空格隔开。 布尔属性（如`bare`和`detached`）仅作为标签列出，并且仅在值为真时出现。 一些属性（如`locked'）可以只作为标签列出，也可以根据是否有理由列出一个值。 工作区的第一个属性总是`工作树'，一个空行表示记录的结束。 比如说："

#. type: delimited block -
#: en/git-worktree.txt:455
#, no-wrap, placeholders:'--porcelain', priority:240
msgid ""
"$ git worktree list --porcelain\n"
"worktree /path/to/bare-source\n"
"bare\n"
msgstr ""
"$ git worktree list --porcelain\n"
"worktree /path/to/bare-source\n"
"bare\n"

#. type: delimited block -
#: en/git-worktree.txt:459
#, no-wrap, placeholders:'HEAD', priority:240
msgid ""
"worktree /path/to/linked-worktree\n"
"HEAD abcd1234abcd1234abcd1234abcd1234abcd1234\n"
"branch refs/heads/master\n"
msgstr ""
"worktree /path/to/linked-worktree\n"
"HEAD abcd1234abcd1234abcd1234abcd1234abcd1234\n"
"branch refs/heads/master\n"

#. type: delimited block -
#: en/git-worktree.txt:463
#, no-wrap, placeholders:'HEAD', priority:240
msgid ""
"worktree /path/to/other-linked-worktree\n"
"HEAD 1234abc1234abc1234abc1234abc1234abc1234a\n"
"detached\n"
msgstr ""
"worktree /path/to/other-linked-worktree\n"
"HEAD 1234abc1234abc1234abc1234abc1234abc1234a\n"
"detached\n"

#. type: delimited block -
#: en/git-worktree.txt:468
#, no-wrap, placeholders:'HEAD', priority:240
msgid ""
"worktree /path/to/linked-worktree-locked-no-reason\n"
"HEAD 5678abc5678abc5678abc5678abc5678abc5678c\n"
"branch refs/heads/locked-no-reason\n"
"locked\n"
msgstr ""
"worktree /path/to/linked-worktree-locked-no-reason\n"
"HEAD 5678abc5678abc5678abc5678abc5678abc5678c\n"
"branch refs/heads/locked-no-reason\n"
"locked\n"

#. type: delimited block -
#: en/git-worktree.txt:473
#, no-wrap, placeholders:'HEAD', priority:240
msgid ""
"worktree /path/to/linked-worktree-locked-with-reason\n"
"HEAD 3456def3456def3456def3456def3456def3456b\n"
"branch refs/heads/locked-with-reason\n"
"locked reason why is locked\n"
msgstr ""
"worktree /path/to/linked-worktree-locked-with-reason\n"
"HEAD 3456def3456def3456def3456def3456def3456b\n"
"branch refs/heads/locked-with-reason\n"
"locked reason why is locked\n"

#. type: delimited block -
#: en/git-worktree.txt:478
#, no-wrap, placeholders:'HEAD', priority:240
msgid ""
"worktree /path/to/linked-worktree-prunable\n"
"HEAD 1233def1234def1234def1234def1234def1234b\n"
"detached\n"
"prunable gitdir file points to non-existent location\n"
msgstr ""
"worktree /path/to/linked-worktree-prunable\n"
"HEAD 1233def1234def1234def1234def1234def1234b\n"
"detached\n"
"修剪的gitdir文件指向不存在的位置\n"

#. type: Plain text
#: en/git-worktree.txt:485
#, placeholders:'`-z`':'core.quotePath':'linkgit:git-config[1]', priority:240
msgid "Unless `-z` is used any \"unusual\" characters in the lock reason such as newlines are escaped and the entire reason is quoted as explained for the configuration variable `core.quotePath` (see linkgit:git-config[1]). For Example:"
msgstr "除非使用`-z`，否则锁定的原因中任何 \"不寻常\"的字符，如换行，都会被转义，并且整个原因被引用为配置变量`core.quotePath`（见linkgit:git-config[1]）。 举例来说："

#. type: delimited block -
#: en/git-worktree.txt:491
#, ignore-ellipsis, no-wrap, placeholders:'--porcelain', priority:240
msgid ""
"$ git worktree list --porcelain\n"
"...\n"
"locked \"reason\\nwhy is locked\"\n"
"...\n"
msgstr ""
"$ git worktree list --porcelain\n"
"…\n"
"locked \"reason\\nwhy is locked\"\n"
"…\n"

#. type: Plain text
#: en/git-worktree.txt:503
#, placeholders:'linkgit:git-stash[1]', priority:240
msgid "You are in the middle of a refactoring session and your boss comes in and demands that you fix something immediately. You might typically use linkgit:git-stash[1] to store your changes away temporarily, however, your working tree is in such a state of disarray (with new, moved, and removed files, and other bits and pieces strewn around) that you don't want to risk disturbing any of it. Instead, you create a temporary linked worktree to make the emergency fix, remove it when done, and then resume your earlier refactoring session."
msgstr "你正在进行重构工作，你的老板进来了，要求你立即修复一些东西。你通常会使用linkgit:git-stash[1]来暂时存储你的修改，然而你的工作树处于如此混乱的状态（有新的、被移动的、被删除的文件，以及其他散落的碎片），你不想冒险去打扰它。相反，你创建了一个临时的链接工作树来进行紧急修复，完成后将其删除，然后继续你先前的重构会话。"

#. type: delimited block -
#: en/git-worktree.txt:511
#, ignore-ellipsis, no-wrap, priority:240
msgid ""
"$ git worktree add -b emergency-fix ../temp master\n"
"$ pushd ../temp\n"
"# ... hack hack hack ...\n"
"$ git commit -a -m 'emergency fix for boss'\n"
"$ popd\n"
"$ git worktree remove ../temp\n"
msgstr ""
"$ git worktree add -b emergency-fix ../temp master\n"
"$ pushd ../temp\n"
"# ... 嗨骇害 ...\n"
"$ git commit -a -m '老板让我赶紧修复的问题'\n"
"$ popd\n"
"$ git worktree remove ../temp\n"

#. type: Plain text
#: en/git-worktree.txt:518
#, priority:240
msgid "Multiple checkout in general is still experimental, and the support for submodules is incomplete. It is NOT recommended to make multiple checkouts of a superproject."
msgstr "多重检出总体上仍处于试验阶段，对子模块的支持也不完整。我们 ⌈不⌋ 建议对一个父项目进行多重检出。"

#. type: Title =
#: en/git-write-tree.txt:2
#, ignore-same, no-wrap, priority:80
msgid "git-write-tree(1)"
msgstr "git-write-tree(1)"

#. type: Plain text
#: en/git-write-tree.txt:7
#, placeholders:'git-write-tree', priority:80
msgid "git-write-tree - Create a tree object from the current index"
msgstr "git-write-tree - 从当前索引创建目录树对象"

#. type: Plain text
#: en/git-write-tree.txt:13
#, no-wrap, placeholders:'git write-tree':'[--missing-ok]':'[--prefix=', priority:80
msgid "'git write-tree' [--missing-ok] [--prefix=<prefix>/]\n"
msgstr "'git write-tree' [--missing-ok] [--prefix=<前缀>/]\n"

#. type: Plain text
#: en/git-write-tree.txt:18
#, priority:80
msgid "Creates a tree object using the current index. The name of the new tree object is printed to standard output."
msgstr "使用当前索引创建一个树对象。新树对象的名称将打印到标准输出中。"

#. type: Plain text
#: en/git-write-tree.txt:20
#, priority:80
msgid "The index must be in a fully merged state."
msgstr "索引必须处于完全合并状态。"

#. type: Plain text
#: en/git-write-tree.txt:26
#, placeholders:'git write-tree':'git update-index':'git write-tree', priority:80
msgid "Conceptually, 'git write-tree' sync()s the current index contents into a set of tree files. In order to have that match what is actually in your directory right now, you need to have done a 'git update-index' phase before you did the 'git write-tree'."
msgstr "从概念上讲，'git write-tree' 是将当前索引内容同步到一组树文件中。 为了与当前目录中的内容相匹配，您需要在执行 'git write-tree' 之前执行 'git update-index' 阶段。"

#. type: Labeled list
#: en/git-write-tree.txt:30
#, ignore-same, no-wrap, priority:80
msgid "--missing-ok"
msgstr "--missing-ok"

#. type: Plain text
#: en/git-write-tree.txt:34
#, placeholders:'git write-tree', priority:80
msgid "Normally 'git write-tree' ensures that the objects referenced by the directory exist in the object database. This option disables this check."
msgstr "通常，'git write-tree' 会确保目录引用的对象存在于对象数据库中。 该选项会禁用这一检查。"

#. type: Plain text
#: en/git-write-tree.txt:39
#, priority:80
msgid "Writes a tree object that represents a subdirectory `<prefix>`. This can be used to write the tree object for a subproject that is in the named subdirectory."
msgstr "写入表示子目录 `<前缀>` 的树对象。 这可用于为指定子目录中的子项目写入树对象。"

#. type: Title =
#: en/gitglossary.txt:2
#, ignore-same, no-wrap, priority:310
msgid "gitglossary(7)"
msgstr "gitglossary(7)"

#. type: Plain text
#: en/gitglossary.txt:7
#, priority:310
msgid "gitglossary - A Git Glossary"
msgstr "gitglossary - Git 术语表"

#. type: Plain text
#: en/gitglossary.txt:11
#, priority:310
msgid "*"
msgstr "*"

# ERROR: link:user-manual.html[ not found in translation
#. type: Plain text
#: en/gitglossary.txt:24
#, placeholders:'linkgit:gittutorial[7]':'linkgit:gittutorial-2[7]':'linkgit:gitcvs-migration[7]':'linkgit:giteveryday[7]':'link:user-manual.html[', priority:310
msgid "linkgit:gittutorial[7], linkgit:gittutorial-2[7], linkgit:gitcvs-migration[7], linkgit:giteveryday[7], link:user-manual.html[The Git User's Manual]"
msgstr "linkgit:gittutorial[7], linkgit:gittutorial-2[7], linkgit:gitcvs-migration[7], linkgit:giteveryday[7], link:user-manual.html[Git 用户手册]"

#. type: Labeled list
#: en/glossary-content.txt:1
#, no-wrap, placeholders:'[[def_alternate_object_database]]', priority:310
msgid "[[def_alternate_object_database]]alternate object database"
msgstr "[[def_alternate_object_database]] 轮替对象库(alternate object database)"

#. type: Plain text
#: en/glossary-content.txt:5
#, placeholders:'<<def_repository,':'<<def_object_database,', priority:310
msgid "Via the alternates mechanism, a <<def_repository,repository>> can inherit part of its <<def_object_database,object database>> from another object database, which is called an \"alternate\"."
msgstr "通过替代机制, 一个 <<def_repository,repository>> 能够从另一个对象库中继承 <<def_object_database,object database>> 的一部分对象, 这被称作“轮替”。"

#. type: Labeled list
#: en/glossary-content.txt:6
#, no-wrap, placeholders:'[[def_bare_repository]]', priority:310
msgid "[[def_bare_repository]]bare repository"
msgstr "[[def_bare_repository]]裸仓库(bare repository)"

#. type: Plain text
#: en/glossary-content.txt:16
#, placeholders:'<<def_directory,':'repository.git', priority:310
msgid "A bare repository is normally an appropriately named <<def_directory,directory>> with a `.git` suffix that does not have a locally checked-out copy of any of the files under revision control. That is, all of the Git administrative and control files that would normally be present in the hidden `.git` sub-directory are directly present in the `repository.git` directory instead, and no other files are present and checked out. Usually publishers of public repositories make bare repositories available."
msgstr "一个裸仓库通常是一个有适当命名的<<def_directory,directory>>，后缀为`.git`，它没有任何版本控制下的文件的本地检出副本。也就是说，所有通常存在于隐藏的`.git`子目录中的Git管理和控制文件都直接存在于`repository.git`目录中，而没有其他文件存在并被检出。通常，公共仓库的发布者会提供裸仓库。"

#. type: Labeled list
#: en/glossary-content.txt:17
#, no-wrap, placeholders:'[[def_blob_object]]', priority:310
msgid "[[def_blob_object]]blob object"
msgstr "[[def_blob_object]] 数据对象 (blob object)"

#. type: Plain text
#: en/glossary-content.txt:19
#, placeholders:'<<def_object,', priority:310
msgid "Untyped <<def_object,object>>, e.g. the contents of a file."
msgstr "无类型的<<def_object,对象>>，比如一个文件的内容。"

#. type: Labeled list
#: en/glossary-content.txt:20
#, no-wrap, placeholders:'[[def_branch]]', priority:310
msgid "[[def_branch]]branch"
msgstr "[[def_branch]] 分支 (branch)"

#. type: Plain text
#: en/glossary-content.txt:30
#, placeholders:'<<def_commit,':'<<def_ref,':'<<def_head,':'<<def_repository,':'<<def_working_tree,':'<<def_HEAD,':'HEAD', priority:310
msgid "A \"branch\" is a line of development. The most recent <<def_commit,commit>> on a branch is referred to as the tip of that branch. The tip of the branch is <<def_ref,referenced>> by a branch <<def_head,head>>, which moves forward as additional development is done on the branch. A single Git <<def_repository,repository>> can track an arbitrary number of branches, but your <<def_working_tree,working tree>> is associated with just one of them (the \"current\" or \"checked out\" branch), and <<def_HEAD,HEAD>> points to that branch."
msgstr "一个 “分支” 就是一条开发线。 一个分支上最近的<<def_commit,提交>>被称为该分支的顶端。 分支的顶端被<<def_ref,引用>>分支 <<def_head,head>> 引用，当分支上有更多的开发工作时，它就会向前移动。 一个Git<<def_repository,仓库>>可以跟踪任意数量的分支，但你的<<def_working_tree,工作区>>只与其中一个分支（“当前(current) ” 或 “检出(checked out)” 分支）相关联，而<<def_HEAD,HEAD>>指向该分支。"

#. type: Labeled list
#: en/glossary-content.txt:31
#, no-wrap, placeholders:'[[def_cache]]', priority:310
msgid "[[def_cache]]cache"
msgstr "[[def_cache]] 缓存 (cache)"

# ERROR: <<def_index, not found in translation
#. type: Plain text
#: en/glossary-content.txt:33
#, placeholders:'<<def_index,', priority:310
msgid "Obsolete for: <<def_index,index>>."
msgstr "已过时：<<def_index,索引>>。"

#. type: Labeled list
#: en/glossary-content.txt:34
#, no-wrap, placeholders:'[[def_chain]]', priority:310
msgid "[[def_chain]]chain"
msgstr "[[def_chain]]（提交）链(chain)"

#. type: Plain text
#: en/glossary-content.txt:38
#, placeholders:'<<def_object,':'<<def_commit,':'<<def_parent,', priority:310
msgid "A list of objects, where each <<def_object,object>> in the list contains a reference to its successor (for example, the successor of a <<def_commit,commit>> could be one of its <<def_parent,parents>>)."
msgstr "一个对象的列表，列表中的每个<<def_object,对象>>都包含对其继承者的引用（例如，一个<<def_commit,提交（commit）>>的继承者可以是其<<def_parent,父对象>>之一）。"

#. type: Labeled list
#: en/glossary-content.txt:39
#, no-wrap, placeholders:'[[def_changeset]]', priority:310
msgid "[[def_changeset]]changeset"
msgstr "[[def_changeset]] 变更集 (changeset)"

#. type: Plain text
#: en/glossary-content.txt:43
#, placeholders:'<<def_commit,', priority:310
msgid "BitKeeper/cvsps speak for \"<<def_commit,commit>>\". Since Git does not store changes, but states, it really does not make sense to use the term \"changesets\" with Git."
msgstr "BitKeeper/cvsps 是指 \"<<def_commit,提交>>\"。由于 Git 并不存储变化，而是存储状态，所以在Git中使用 “变化集（changesets）” 这个词真的没有意义。"

#. type: Labeled list
#: en/glossary-content.txt:44
#, no-wrap, placeholders:'[[def_checkout]]', priority:310
msgid "[[def_checkout]]checkout"
msgstr "[[def_checkout]] 检出 (checkout)"

#. type: Plain text
#: en/glossary-content.txt:51
#, placeholders:'<<def_working_tree,':'<<def_tree_object,':'<<def_blob_object,':'<<def_object_database,':'<<def_index,':'<<def_HEAD,':'HEAD':'<<def_branch,', priority:310
msgid "The action of updating all or part of the <<def_working_tree,working tree>> with a <<def_tree_object,tree object>> or <<def_blob_object,blob>> from the <<def_object_database,object database>>, and updating the <<def_index,index>> and <<def_HEAD,HEAD>> if the whole working tree has been pointed at a new <<def_branch,branch>>."
msgstr "用<<def_object_database,对象库>>中的<<def_tree_object,树对象>>或 <<def_blob_object,blob>> 更新全部或部分<<def_working_tree,工作区>>，如果整个工作区已经指向一个新<<def_branch,分支>>，就更新<<def_index,暂存区>>和 <<def_HEAD,HEAD>>。"

#. type: Labeled list
#: en/glossary-content.txt:52
#, no-wrap, placeholders:'[[def_cherry-picking]]', priority:310
msgid "[[def_cherry-picking]]cherry-picking"
msgstr "[[def_cherry-picking]]拣选（cherry-picking）"

#. type: Plain text
#: en/glossary-content.txt:59
#, placeholders:'<<def_SCM,':'git cherry-pick':'<<def_commit,':'<<def_branch,', priority:310
msgid "In <<def_SCM,SCM>> jargon, \"cherry pick\" means to choose a subset of changes out of a series of changes (typically commits) and record them as a new series of changes on top of a different codebase. In Git, this is performed by the \"git cherry-pick\" command to extract the change introduced by an existing <<def_commit,commit>> and to record it based on the tip of the current <<def_branch,branch>> as a new commit."
msgstr "在 <<def_SCM,SCM>> 中，\"cherry pick\" 意味着从一系列的修改（通常是提交）中选择一个子集，并将其记录为不同仓库之上的一系列新修改。在 Git 中，这是由 \"git cherry-pick\" 命令执行的，提取现有<<def_commit,提交>>引入的修改，并根据当前<<def_branch,分支>>的提示，将其记录为新提交。"

#. type: Labeled list
#: en/glossary-content.txt:60
#, no-wrap, placeholders:'[[def_clean]]', priority:310
msgid "[[def_clean]]clean"
msgstr "[[def_clean]]干净（的工作区）"

#. type: Plain text
#: en/glossary-content.txt:64
#, placeholders:'<<def_working_tree,':'<<def_revision,':'<<def_head,':'<<def_dirty,', priority:310
msgid "A <<def_working_tree,working tree>> is clean, if it corresponds to the <<def_revision,revision>> referenced by the current <<def_head,head>>. Also see \"<<def_dirty,dirty>>\"."
msgstr "如果一个<<def_working_tree,工作区>>对应于当前<<def_revision,版本>>所引用的<<def_head,头、分支>>，它就是干净的（clean）。另请参见\"<<def_dirty,脏（的工作区）>>\"。"

#. type: Labeled list
#: en/glossary-content.txt:65
#, no-wrap, placeholders:'[[def_commit]]', priority:310
msgid "[[def_commit]]commit"
msgstr "[[def_commit]]提交"

#. type: Plain text
#: en/glossary-content.txt:72
#, placeholders:'<<def_commit_object,', priority:310
msgid "As a noun: A single point in the Git history; the entire history of a project is represented as a set of interrelated commits. The word \"commit\" is often used by Git in the same places other revision control systems use the words \"revision\" or \"version\". Also used as a short hand for <<def_commit_object,commit object>>."
msgstr "作为名词时，意为：Git 历史中的一个点；一个项目的整个历史被表示为一组相互关联的提交。 Git 经常使用 “提交(commit)” 这个词，就像其他版本控制系统使用 \"revision\" 或 \"version\" 一样。 也被用作<<def_commit_object,提交对象>>的简称。"

#. type: Plain text
#: en/glossary-content.txt:77
#, placeholders:'<<def_index,':'<<def_HEAD,':'HEAD', priority:310
msgid "As a verb: The action of storing a new snapshot of the project's state in the Git history, by creating a new commit representing the current state of the <<def_index,index>> and advancing <<def_HEAD,HEAD>> to point at the new commit."
msgstr "作为动词时，意为：在 Git 历史中存储一个该项目状态的新快照，通过创建一个代表当前<<def_index,暂存区>>状态的提交，并移动<<def_HEAD,HEAD>>指向此新提交。"

#. type: Labeled list
#: en/glossary-content.txt:78
#, no-wrap, placeholders:'[[def_commit_graph_general]]', priority:310
msgid "[[def_commit_graph_general]]commit graph concept, representations and usage"
msgstr "[[def_commit_graph_general]]提交图示(commit graph)的概念、结构表示和用途"

#. type: Plain text
#: en/glossary-content.txt:85
#, placeholders:'<<def_DAG,':'<<def_ref,':'<<def_chain,':'<<def_commit_graph_file,', priority:310
msgid "A synonym for the <<def_DAG,DAG>> structure formed by the commits in the object database, <<def_ref,referenced>> by branch tips, using their <<def_chain,chain>> of linked commits. This structure is the definitive commit graph. The graph can be represented in other ways, e.g. the <<def_commit_graph_file,\"commit-graph\" file>>."
msgstr "由对象数据库中的提交形成的<<def_DAG,有向无环图(DAG)>>，由被<<def_ref,引用>>的分支提示，使用其<<def_chain,对象链(chain)>>的链接提交。 这个结构就是明确的提交图。该图还有其他展示形式，例如<<def_commit_graph_file, “提交图示” 文件>>。"

#. type: Labeled list
#: en/glossary-content.txt:86
#, no-wrap, placeholders:'[[def_commit_graph_file]]', priority:310
msgid "[[def_commit_graph_file]]commit-graph file"
msgstr "[[def_commit_graph_file]]提交图示(commit-graph)文件"

#. type: Plain text
#: en/glossary-content.txt:92
#, placeholders:'<<def_commit_graph_general,', priority:310
msgid "The \"commit-graph\" (normally hyphenated) file is a supplemental representation of the <<def_commit_graph_general,commit graph>> which accelerates commit graph walks. The \"commit-graph\" file is stored either in the .git/objects/info directory or in the info directory of an alternate object database."
msgstr "“提交图示(ommit-graph)”（通常是连字符）文件是<<def_commit_graph_general,提交图(commit graph)>>的补充表示，可以加速提交图的生成。“提交图示” 文件存储在 .git/objects/info 目录下，或者存储在另一个对象数据库的 info 目录下。"

#. type: Labeled list
#: en/glossary-content.txt:93
#, no-wrap, placeholders:'[[def_commit_object]]', priority:310
msgid "[[def_commit_object]]commit object"
msgstr "[[def_commit_object]]提交对象(commit object)"

#. type: Plain text
#: en/glossary-content.txt:99
#, placeholders:'<<def_object,':'<<def_revision,':'<<def_parent,':'<<def_tree_object,':'<<def_directory,', priority:310
msgid "An <<def_object,object>> which contains the information about a particular <<def_revision,revision>>, such as <<def_parent,parents>>, committer, author, date and the <<def_tree_object,tree object>> which corresponds to the top <<def_directory,directory>> of the stored revision."
msgstr "一个<<def_object,对象 >>包含了关于某个特定<<def_revision,版本>>的信息，例如<<def_parent,父提交>>、提交者、作者、日期和<<def_tree_object, 树对象>>（对应于保存的版本顶部<<def_directory,目录>>）。"

#. type: Labeled list
#: en/glossary-content.txt:100
#, no-wrap, placeholders:'[[def_commit-ish]]', priority:310
msgid "[[def_commit-ish]]commit-ish (also committish)"
msgstr "[[def_commit-ish]]提交号[commit-ish (also committish)]"

#. type: Plain text
#: en/glossary-content.txt:110
#, placeholders:'<<def_commit_object,':'<<def_object,':'<<def_dereference,':'<<def_tag_object,', priority:310
msgid "A <<def_commit_object,commit object>> or an <<def_object,object>> that can be recursively <<def_dereference,dereferenced>> to a commit object. The following are all commit-ishes: a commit object, a <<def_tag_object,tag object>> that points to a commit object, a tag object that points to a tag object that points to a commit object, etc."
msgstr "一个<<def_commit_object,提交对象>>或一个<<def_object,对象>>可以递归<<def_dereference,解引用>>到一个提交对象。提交对象、指向提交对象的<<def_tag_object,标签对象>>、指向提交对象的标签对象的标签对象，等等。"

#. type: Labeled list
#: en/glossary-content.txt:111
#, no-wrap, placeholders:'[[def_core_git]]', priority:310
msgid "[[def_core_git]]core Git"
msgstr "[[def_core_git]]Git 核心(core Git)"

#. type: Plain text
#: en/glossary-content.txt:114
#, priority:310
msgid "Fundamental data structures and utilities of Git. Exposes only limited source code management tools."
msgstr "Git 的基本数据结构和实用工具。只暴露了有限的源代码管理工具。"

#. type: Labeled list
#: en/glossary-content.txt:115
#, no-wrap, placeholders:'[[def_DAG]]', priority:310
msgid "[[def_DAG]]DAG"
msgstr "[[def_DAG]]有向无环图 (DAG)"

#. type: Plain text
#: en/glossary-content.txt:120
#, placeholders:'<<def_commit_object,':'<<def_chain,':'<<def_object,', priority:310
msgid "Directed acyclic graph. The <<def_commit_object,commit objects>> form a directed acyclic graph, because they have parents (directed), and the graph of commit objects is acyclic (there is no <<def_chain,chain>> which begins and ends with the same <<def_object,object>>)."
msgstr "有向无环图。<<def_commit_object,提交对象>>形成了一个有向无环图，因为它们有父提交（有向），而且提交对象的图是无环的（没有<<def_chain,对象链>>以同一个<<def_object,对象>>开始和结束）。"

#. type: Labeled list
#: en/glossary-content.txt:121
#, no-wrap, placeholders:'[[def_dangling_object]]', priority:310
msgid "[[def_dangling_object]]dangling object"
msgstr "[[def_dangling_object]]悬空对象"

#. type: Plain text
#: en/glossary-content.txt:126
#, placeholders:'<<def_unreachable_object,':'<<def_reachable,':'<<def_object,':'<<def_repository,', priority:310
msgid "An <<def_unreachable_object,unreachable object>> which is not <<def_reachable,reachable>> even from other unreachable objects; a dangling object has no references to it from any reference or <<def_object,object>> in the <<def_repository,repository>>."
msgstr "一个<<def_unreachable_object,不可达对象>>，即使从其他无法可达对象也无法<<def_reachable,可达>>；一个悬空对象在<<def_repository,仓库>>中没有任何引用或<<def_object,对象>>。"

#. type: Labeled list
#: en/glossary-content.txt:127
#, no-wrap, placeholders:'[[def_dereference]]', priority:310
msgid "[[def_dereference]]dereference"
msgstr "[[def_dereference]]解引用"

#. type: Plain text
#: en/glossary-content.txt:132
#, placeholders:'<<def_symref,':'<<def_ref,', priority:310
msgid "Referring to a <<def_symref,symbolic ref>>: the action of accessing the <<def_ref,reference>> pointed at by a symbolic ref. Recursive dereferencing involves repeating the aforementioned process on the resulting ref until a non-symbolic reference is found."
msgstr "引用 <<def_symref,符号引用>>：访问符号引用所指向的 <<def_ref,引用>> 的操作。递归解引用是指对结果引用重复上述过程，直到找到非符号引用为止。"

#. type: Plain text
#: en/glossary-content.txt:139
#, placeholders:'<<def_tag_object,':'<<def_object,':'<<def_object_type,':'<<def_peel,', priority:310
msgid "Referring to a <<def_tag_object,tag object>>: the action of accessing the <<def_object,object>> a tag points at. Tags are recursively dereferenced by repeating the operation on the result object until the result has either a specified <<def_object_type,object type>> (where applicable) or any non-\"tag\" object type. A synonym for \"recursive dereference\" in the context of tags is \"<<def_peel,peel>>\"."
msgstr "引用 <<def_tag_object,标签对象>>：访问标签指向的 <<def_object,对象>> 的操作。通过重复对结果对象的操作来递归引用标记，直到结果对象具有指定的 <<def_object_type,对象类型>>（如适用）或任何非 “标签” 对象类型。标签中 “递归解引用” 的同义词是“<<def_peel,剥离>>”。"

#. type: Plain text
#: en/glossary-content.txt:142
#, placeholders:'<<def_commit_object,', priority:310
msgid "Referring to a <<def_commit_object,commit object>>: the action of accessing the commit's tree object. Commits cannot be dereferenced recursively."
msgstr "引用 <<def_commit_object,提交对象>>：访问提交的树对象的操作。提交不能被递归解引用。"

#. type: Plain text
#: en/glossary-content.txt:145
#, priority:310
msgid "Unless otherwise specified, \"dereferencing\" as it used in the context of Git commands or protocols is implicitly recursive."
msgstr "除非另有说明，在 Git 命令或协议中使用的 “解引用” 是隐式递归的。"

# ERROR: [[def_detached_HEAD]] not found in translation
#. type: Labeled list
#: en/glossary-content.txt:146
#, no-wrap, placeholders:'[[def_detached_HEAD]]':'HEAD', priority:310
msgid "[[def_detached_HEAD]]detached HEAD"
msgstr "[[def_detached_HEAD]]分离的头指针(detached HEAD)"

#. type: Plain text
#: en/glossary-content.txt:155
#, placeholders:'<<def_HEAD,':'HEAD':'<<def_branch,':'HEAD':'HEAD':'<<def_checkout,':'<<def_commit,':'HEAD', priority:310
msgid "Normally the <<def_HEAD,HEAD>> stores the name of a <<def_branch,branch>>, and commands that operate on the history HEAD represents operate on the history leading to the tip of the branch the HEAD points at. However, Git also allows you to <<def_checkout,check out>> an arbitrary <<def_commit,commit>> that isn't necessarily the tip of any particular branch. The HEAD in such a state is called \"detached\"."
msgstr "通常，<<def_HEAD,HEAD>> 存储的是一个<<def_branch,分支>>的名称，对 HEAD 所代表的历史进行操作的命令会对HEAD所指向的分支的顶端的历史进行操作。然而，Git 也允许你<<def_checkout,签出>>到一个任意的<<def_commit,提交>>，不一定是任何特定分支的顶端。处于这种状态的 HEAD 被称为 “分离”。"

#. type: Plain text
#: en/glossary-content.txt:164
#, placeholders:'HEAD':'HEAD':'--set-upstream-to`', priority:310
msgid "Note that commands that operate on the history of the current branch (e.g. `git commit` to build a new history on top of it) still work while the HEAD is detached. They update the HEAD to point at the tip of the updated history without affecting any branch. Commands that update or inquire information _about_ the current branch (e.g. `git branch --set-upstream-to` that sets what remote-tracking branch the current branch integrates with) obviously do not work, as there is no (real) current branch to ask about in this state."
msgstr "请注意，当 HEAD 分离时，对当前分支的历史进行操作的命令（例如，`git commit` 在其上建立一个新的历史）仍然有效。它们会更新 HEAD，使其指向更新的历史记录的顶端，而不影响任何分支。更新或查询关于当前分支的信息的命令（例如，`git branch --set-upstream-to`，设置当前分支与哪个远程跟踪分支集成）显然不起作用，因为在这种状态下没有（真正的）当前分支可以查询。"

#. type: Labeled list
#: en/glossary-content.txt:165
#, no-wrap, placeholders:'[[def_directory]]', priority:310
msgid "[[def_directory]]directory"
msgstr "[[def_directory]]目录"

#. type: Plain text
#: en/glossary-content.txt:167
#, priority:310
msgid "The list you get with \"ls\" :-)"
msgstr "你用 \"ls\" 命令得到的列表 :-)"

#. type: Labeled list
#: en/glossary-content.txt:168
#, no-wrap, placeholders:'[[def_dirty]]', priority:310
msgid "[[def_dirty]]dirty"
msgstr "[[def_dirty]]脏（的工作区）(dirty)"

#. type: Plain text
#: en/glossary-content.txt:172
#, placeholders:'<<def_working_tree,':'<<def_commit,':'<<def_branch,', priority:310
msgid "A <<def_working_tree,working tree>> is said to be \"dirty\" if it contains modifications which have not been <<def_commit,committed>> to the current <<def_branch,branch>>."
msgstr "如果<<def_working_tree,工作区>>包含的修改没有被<<def_commit,提交>>到当前的<<def_branch,分支>>，就被认为是 \"dirty（脏）\" 的。"

#. type: Labeled list
#: en/glossary-content.txt:173
#, no-wrap, placeholders:'[[def_evil_merge]]', priority:310
msgid "[[def_evil_merge]]evil merge"
msgstr "[[def_evil_merge]]坏合并（合并引入了父提交没有的修改）(evil merge)"

#. type: Plain text
#: en/glossary-content.txt:176
#, placeholders:'<<def_merge,':'<<def_parent,', priority:310
msgid "An evil merge is a <<def_merge,merge>> that introduces changes that do not appear in any <<def_parent,parent>>."
msgstr "一个坏合并，指引入了没有出现在任何<<def_parent,父提交>>中修改的<<def_merge,合并>>。"

#. type: Labeled list
#: en/glossary-content.txt:177
#, no-wrap, placeholders:'[[def_fast_forward]]', priority:310
msgid "[[def_fast_forward]]fast-forward"
msgstr "[[def_fast_forward]]快速合并"

#. type: Plain text
#: en/glossary-content.txt:186
#, placeholders:'<<def_merge,':'<<def_revision,':'<<def_branch,':'<<def_merge,':'<<def_commit,':'<<def_remote_tracking_branch,':'<<def_repository,', priority:310
msgid "A fast-forward is a special type of <<def_merge,merge>> where you have a <<def_revision,revision>> and you are \"merging\" another <<def_branch,branch>>'s changes that happen to be a descendant of what you have. In such a case, you do not make a new <<def_merge,merge>> <<def_commit,commit>> but instead just update your branch to point at the same revision as the branch you are merging. This will happen frequently on a <<def_remote_tracking_branch,remote-tracking branch>> of a remote <<def_repository,repository>>."
msgstr "快速合并是<<def_merge,合并>>的一种特殊类型，即你有一个<<def_revision,版本>>而你正在“合并”另一个<<def_branch,分支>>的修改，这些修改恰好是你的后续提交。在这种情况下，你不需要添加一个新的<<def_merge,合并>> <<def_commit,提交>>而只是更新你的分支，使其指向与你要合并的分支相同的版本。这种情况会经常发生在一个远程<<def_remote_tracking_branch,远程跟踪分支>>的<<def_repository,仓库>>。"

#. type: Labeled list
#: en/glossary-content.txt:187
#, no-wrap, placeholders:'[[def_fetch]]', priority:310
msgid "[[def_fetch]]fetch"
msgstr "[[def_fetch]]获取(fetch)"

#. type: Plain text
#: en/glossary-content.txt:193
#, placeholders:'<<def_branch,':'<<def_head_ref,':'<<def_repository,':'<<def_object_database,':'linkgit:git-fetch[1]', priority:310
msgid "Fetching a <<def_branch,branch>> means to get the branch's <<def_head_ref,head ref>> from a remote <<def_repository,repository>>, to find out which objects are missing from the local <<def_object_database,object database>>, and to get them, too. See also linkgit:git-fetch[1]."
msgstr "获取一个<<def_branch,分支>>意味着从远程<<def_repository,仓库>>获取该分支的<<def_head_ref,头引用>>，找出本地<<def_object_database,对象库>>中缺失的对象，并获取这些对象。另见 linkgit:git-fetch[1]。"

#. type: Labeled list
#: en/glossary-content.txt:194
#, no-wrap, placeholders:'[[def_file_system]]', priority:310
msgid "[[def_file_system]]file system"
msgstr "[[def_file_system]]文件系统"

#. type: Plain text
#: en/glossary-content.txt:198
#, priority:310
msgid "Linus Torvalds originally designed Git to be a user space file system, i.e. the infrastructure to hold files and directories. That ensured the efficiency and speed of Git."
msgstr "Linus Torvalds （林纳斯·本纳第克特·托瓦兹；Git的作者、Linux之父）最初将 Git 设计为用户空间文件系统，即用于保存文件和目录的基础结构。这确保了 Git 的效率和速度。"

#. type: Labeled list
#: en/glossary-content.txt:199
#, no-wrap, placeholders:'[[def_git_archive]]', priority:310
msgid "[[def_git_archive]]Git archive"
msgstr "[[def_git_archive]]仓库（对于 arch 用户）(Git archive)"

#. type: Plain text
#: en/glossary-content.txt:201
#, placeholders:'<<def_repository,', priority:310
msgid "Synonym for <<def_repository,repository>> (for arch people)."
msgstr "与<<def_repository,仓库>> 同义(对于arch用户)。"

#. type: Labeled list
#: en/glossary-content.txt:202
#, no-wrap, placeholders:'[[def_gitfile]]', priority:310
msgid "[[def_gitfile]]gitfile"
msgstr "[[def_gitfile]]gitfile（仓库链接文件）"

#. type: Plain text
#: en/glossary-content.txt:207
#, placeholders:'linkgit:git-worktree[1]':'linkgit:git-submodule[1]':'linkgit:gitrepository-layout[5]', priority:310
msgid "A plain file `.git` at the root of a working tree that points at the directory that is the real repository. For proper use see linkgit:git-worktree[1] or linkgit:git-submodule[1]. For syntax see linkgit:gitrepository-layout[5]."
msgstr "工作目录树根目录下的普通文件 `.git`，指向真正的仓库目录。正确用法参见 linkgit:git-worktree[1] 或 linkgit:git-submodule[1]。语法参见 linkgit:gitrepository-layout[5]。"

#. type: Labeled list
#: en/glossary-content.txt:208
#, no-wrap, placeholders:'[[def_grafts]]', priority:310
msgid "[[def_grafts]]grafts"
msgstr "[[def_grafts]]（提交）移植(grafts)"

#. type: Plain text
#: en/glossary-content.txt:214
#, placeholders:'<<def_parent,':'<<def_commit,', priority:310
msgid "Grafts enable two otherwise different lines of development to be joined together by recording fake ancestry information for commits. This way you can make Git pretend the set of <<def_parent,parents>> a <<def_commit,commit>> has is different from what was recorded when the commit was created. Configured via the `.git/info/grafts` file."
msgstr "移植（Grafts）通过记录提交的虚假祖先信息，使两条原本不同的开发线连接在一起。这样你就可以让 Git 假装<<def_commit,提交>>的一组<<def_parent,父提交>>与创建提交 (commit) 时的记录不同。通过 `.git/info/grafts` 文件进行配置。"

#. type: Plain text
#: en/glossary-content.txt:218
#, placeholders:'linkgit:git-replace[1]', priority:310
msgid "Note that the grafts mechanism is outdated and can lead to problems transferring objects between repositories; see linkgit:git-replace[1] for a more flexible and robust system to do the same thing."
msgstr "请注意，移植 (Grafts) 机制已经过时了，可能会导致在仓库之间转移对象的问题；参见 linkgit:git-replace[1] ，这是一个更灵活更强大的系统，可以做同样的事情。"

#. type: Labeled list
#: en/glossary-content.txt:219
#, no-wrap, placeholders:'[[def_hash]]', priority:310
msgid "[[def_hash]]hash"
msgstr "[[def_hash]]哈希（hash）"

#. type: Plain text
#: en/glossary-content.txt:221
#, placeholders:'<<def_object_name,', priority:310
msgid "In Git's context, synonym for <<def_object_name,object name>>."
msgstr "在 Git 的上下文中，是<<def_object_name,对象名称>>的同义词。"

#. type: Labeled list
#: en/glossary-content.txt:222
#, no-wrap, placeholders:'[[def_head]]', priority:310
msgid "[[def_head]]head"
msgstr "[[def_head]]头/分支(head)"

#. type: Plain text
#: en/glossary-content.txt:227
#, placeholders:'<<def_ref,':'<<def_commit,':'<<def_branch,':'$GIT_DIR':'linkgit:git-pack-refs[1]', priority:310
msgid "A <<def_ref,named reference>> to the <<def_commit,commit>> at the tip of a <<def_branch,branch>>. Heads are stored in a file in `$GIT_DIR/refs/heads/` directory, except when using packed refs. (See linkgit:git-pack-refs[1].)"
msgstr "一个<<def_ref,命名引用>>到<<def_commit,提交>>在<<def_branch,分支>>的顶端。头部存储在 `$GIT_DIR/refs/heads/` 目录下的一个文件中，除非使用打包的引用（参见 linkgit:git-pack-refs[1]。）"

#. type: Labeled list
#: en/glossary-content.txt:228
#, no-wrap, placeholders:'[[def_HEAD]]':'HEAD', priority:310
msgid "[[def_HEAD]]HEAD"
msgstr "[[def_HEAD]]HEAD（头指针，亦即当前分支）"

#. type: Plain text
#: en/glossary-content.txt:235
#, placeholders:'<<def_branch,':'<<def_working_tree,':'HEAD':'HEAD':'<<def_head,':'<<def_detached_HEAD,':'HEAD', priority:310
msgid "The current <<def_branch,branch>>. In more detail: Your <<def_working_tree, working tree>> is normally derived from the state of the tree referred to by HEAD. HEAD is a reference to one of the <<def_head,heads>> in your repository, except when using a <<def_detached_HEAD,detached HEAD>>, in which case it directly references an arbitrary commit."
msgstr "当前<<def_branch,分支>>。详细地讲，你的<<def_working_tree,工作区>>通常是由 HEAD 所指的树的状态衍生出来的。HEAD 是对你的版本库中的一个<<def_head,头>>的引用，除非使用<<def_detached_HEAD,分离的 HEAD>>，这种情况下它直接引用一个任意的提交。"

#. type: Labeled list
#: en/glossary-content.txt:236
#, no-wrap, placeholders:'[[def_head_ref]]', priority:310
msgid "[[def_head_ref]]head ref"
msgstr "[[def_head_ref]]头引用"

#. type: Plain text
#: en/glossary-content.txt:238
#, placeholders:'<<def_head,', priority:310
msgid "A synonym for <<def_head,head>>."
msgstr "<<def_head,头>>的同义词。"

# ERROR: [[def_hook]] not found in translation
#. type: Labeled list
#: en/glossary-content.txt:239
#, no-wrap, placeholders:'[[def_hook]]', priority:310
msgid "[[def_hook]]hook"
msgstr "[[def_hook]]钩子"

#. type: Plain text
#: en/glossary-content.txt:248
#, placeholders:'$GIT_DIR', priority:310
msgid "During the normal execution of several Git commands, call-outs are made to optional scripts that allow a developer to add functionality or checking. Typically, the hooks allow for a command to be pre-verified and potentially aborted, and allow for a post-notification after the operation is done. The hook scripts are found in the `$GIT_DIR/hooks/` directory, and are enabled by simply removing the `.sample` suffix from the filename. In earlier versions of Git you had to make them executable."
msgstr "在几个 Git 命令的正常执行过程中，会对可选的脚本进行调用，允许开发者添加功能或检查。通常情况下，钩子允许一个命令被预先验证并可能中止执行，并允许在操作完成后发出通知。钩子脚本可以在 `$GIT_DIR/hooks/` 目录下找到，只需将文件名中的 `.sample` 后缀去掉即可启用。在早期版本的 Git 中，你必须将它们设置为可执行。"

#. type: Labeled list
#: en/glossary-content.txt:249
#, no-wrap, placeholders:'[[def_index]]', priority:310
msgid "[[def_index]]index"
msgstr "[[def_index]]索引"

#. type: Plain text
#: en/glossary-content.txt:255
#, placeholders:'<<def_working_tree,':'<<def_merge,', priority:310
msgid "A collection of files with stat information, whose contents are stored as objects. The index is a stored version of your <<def_working_tree,working tree>>. Truth be told, it can also contain a second, and even a third version of a working tree, which are used when <<def_merge,merging>>."
msgstr "一个带有统计信息的文件集合，其内容以对象形式存储。索引是你的<<def_working_tree,工作区>>的一个存储版本。事实上它也可以包含第二个，甚至第三个版本的工作区，这些在<<def_merge,合并>>时使用。"

#. type: Labeled list
#: en/glossary-content.txt:256
#, no-wrap, placeholders:'[[def_index_entry]]', priority:310
msgid "[[def_index_entry]]index entry"
msgstr "[[def_index_entry]]索引项"

#. type: Plain text
#: en/glossary-content.txt:261
#, placeholders:'<<def_index,':'<<def_merge,', priority:310
msgid "The information regarding a particular file, stored in the <<def_index,index>>. An index entry can be unmerged, if a <<def_merge,merge>> was started, but not yet finished (i.e. if the index contains multiple versions of that file)."
msgstr "关于某个特定文件的信息，存储在<<def_index,索引/暂存区>>。如果<<def_merge,合并>>已经开始，但尚未完成（即如果索引包含该文件的多个版本），则索引条目可以取消合并。"

#. type: Labeled list
#: en/glossary-content.txt:262
#, no-wrap, placeholders:'[[def_master]]', priority:310
msgid "[[def_master]]master"
msgstr "[[def_master]]master（默认分支名）"

#. type: Plain text
#: en/glossary-content.txt:268
#, placeholders:'<<def_branch,':'<<def_repository,', priority:310
msgid "The default development <<def_branch,branch>>. Whenever you create a Git <<def_repository,repository>>, a branch named \"master\" is created, and becomes the active branch. In most cases, this contains the local development, though that is purely by convention and is not required."
msgstr "默认的开发<<def_branch,分支 >>。每当你创建一个 Git <<def_repository,仓库>>，就会创建一个名为 \"master\" 的分支，并成为活动分支。在大多数情况下，它包含了本地的开发内容，但这纯粹是惯例，并不是必须的。"

# ERROR: [[def_merge]] not found in translation
#. type: Labeled list
#: en/glossary-content.txt:269
#, no-wrap, placeholders:'[[def_merge]]', priority:310
msgid "[[def_merge]]merge"
msgstr "[[def_merge]]合并"

#. type: Plain text
#: en/glossary-content.txt:282
#, placeholders:'<<def_branch,':'<<def_repository,':'<<def_fetch,':'<<def_pull,', priority:310
msgid "As a verb: To bring the contents of another <<def_branch,branch>> (possibly from an external <<def_repository,repository>>) into the current branch. In the case where the merged-in branch is from a different repository, this is done by first <<def_fetch,fetching>> the remote branch and then merging the result into the current branch. This combination of fetch and merge operations is called a <<def_pull,pull>>. Merging is performed by an automatic process that identifies changes made since the branches diverged, and then applies all those changes together. In cases where changes conflict, manual intervention may be required to complete the merge."
msgstr "作为动词。将另一个<<def_branch,分支>>（可能来自外部<<def_repository,仓库>>）的内容引入当前分支。在被合并的分支来自不同的仓库的情况下，这是通过首先<<def_fetch,抓取>>远程分支，然后将结果合并到当前分支来实现的。这种获取和合并操作的组合被称为<<def_pull,拉取>>。合并是由一个自动过程进行的，该过程会识别自分支分歧以来的变化，然后将所有这些变化应用在一起。在变化发生冲突的情况下，可能需要人工干预来完成合并。"

#. type: Plain text
#: en/glossary-content.txt:289
#, placeholders:'<<def_fast_forward,':'<<def_commit,':'<<def_parent,':'<<def_branch,', priority:310
msgid "As a noun: unless it is a <<def_fast_forward,fast-forward>>, a successful merge results in the creation of a new <<def_commit,commit>> representing the result of the merge, and having as <<def_parent,parents>> the tips of the merged <<def_branch,branches>>. This commit is referred to as a \"merge commit\", or sometimes just a \"merge\"."
msgstr "作为名词，除非是<<def_fast_forward,快速合并>>，否则一个成功的合并会产生一个新的<<def_commit,提交>>，代表合并的结果，并且有<<def_parent,父提交>>与<<def_branch,分支>> 合并的提示。这种提交被称为 “合并提交”，或者有时只是 “合并”。"

#. type: Labeled list
#: en/glossary-content.txt:290
#, no-wrap, placeholders:'[[def_object]]', priority:310
msgid "[[def_object]]object"
msgstr "[[def_object]]对象"

#. type: Plain text
#: en/glossary-content.txt:294
#, placeholders:'<<def_SHA1,', priority:310
msgid "The unit of storage in Git. It is uniquely identified by the <<def_SHA1,SHA-1>> of its contents. Consequently, an object cannot be changed."
msgstr "Git中的存储单位。它由其内容的<<def_SHA1,SHA-1>>作为唯一的标识。因此，一个对象不能被改变。"

# ERROR: [[def_object_database]] not found in translation
#. type: Labeled list
#: en/glossary-content.txt:295
#, no-wrap, placeholders:'[[def_object_database]]', priority:310
msgid "[[def_object_database]]object database"
msgstr "[[def_object_database]]对象库"

#. type: Plain text
#: en/glossary-content.txt:299
#, placeholders:'<<def_object,':'<<def_object_name,':'$GIT_DIR', priority:310
msgid "Stores a set of \"objects\", and an individual <<def_object,object>> is identified by its <<def_object_name,object name>>. The objects usually live in `$GIT_DIR/objects/`."
msgstr "存储一组 “对象 (objects)”，一个单独的<<def_object,对象>>由其<<def_object_name,对象名称>>标识。这些对象通常存在于`$GIT_DIR/objects/`中。"

#. type: Labeled list
#: en/glossary-content.txt:300
#, no-wrap, placeholders:'[[def_object_identifier]]', priority:310
msgid "[[def_object_identifier]]object identifier (oid)"
msgstr "[[def_object_identifier]]对象标识符 [object identifier (oid)]"

#. type: Plain text
#: en/glossary-content.txt:302
#, placeholders:'<<def_object_name,', priority:310
msgid "Synonym for <<def_object_name,object name>>."
msgstr "<<def_object_name,对象名称>>的同义词。"

#. type: Labeled list
#: en/glossary-content.txt:303
#, no-wrap, placeholders:'[[def_object_name]]', priority:310
msgid "[[def_object_name]]object name"
msgstr "[[def_object_name]]对象名称"

#. type: Plain text
#: en/glossary-content.txt:307
#, placeholders:'<<def_object,':'<<def_SHA1,', priority:310
msgid "The unique identifier of an <<def_object,object>>. The object name is usually represented by a 40 character hexadecimal string. Also colloquially called <<def_SHA1,SHA-1>>."
msgstr "一个<<def_object,对象>>的唯一标识。对象名称通常由40个字符的十六进制字符串表示。也被称为 <<def_SHA1,SHA-1>>。"

#. type: Labeled list
#: en/glossary-content.txt:308
#, no-wrap, placeholders:'[[def_object_type]]', priority:310
msgid "[[def_object_type]]object type"
msgstr "[[def_object_type]]对象类型"

#. type: Plain text
#: en/glossary-content.txt:313
#, placeholders:'<<def_commit_object,':'<<def_tree_object,':'<<def_tag_object,':'<<def_blob_object,':'<<def_object,', priority:310
msgid "One of the identifiers \"<<def_commit_object,commit>>\", \"<<def_tree_object,tree>>\", \"<<def_tag_object,tag>>\" or \"<<def_blob_object,blob>>\" describing the type of an <<def_object,object>>."
msgstr "其中一个标识符\"<<def_commit_object,提交>>\", \"<<def_tree_object,树>>\", \"<<def_tag_object,标签>>\"或\"<<def_blob_object,blob>>\"描述一个<<def_object,对象>的类型。"

#. type: Labeled list
#: en/glossary-content.txt:314
#, no-wrap, placeholders:'[[def_octopus]]', priority:310
msgid "[[def_octopus]]octopus"
msgstr "[[def_octopus]]章鱼式合并（两分支以上的合并）(octopus)"

#. type: Plain text
#: en/glossary-content.txt:316
#, placeholders:'<<def_merge,':'<<def_branch,', priority:310
msgid "To <<def_merge,merge>> more than two <<def_branch,branches>>."
msgstr "<<def_merge,合并>>两个以上的<<def_branch,分支>>。"

#. type: Labeled list
#: en/glossary-content.txt:317
#, no-wrap, placeholders:'[[def_orphan]]', priority:310
msgid "[[def_orphan]]orphan"
msgstr "[[def_orphan]]orphan（孤儿分支）"

#. type: Plain text
#: en/glossary-content.txt:322
#, placeholders:'<<def_branch,':'<<def_unborn,', priority:310
msgid "The act of getting on a <<def_branch,branch>> that does not exist yet (i.e., an <<def_unborn,unborn>> branch). After such an operation, the commit first created becomes a commit without a parent, starting a new history."
msgstr "获取尚未存在的 <<def_branch,分支>> （即 <<def_unborn,未出>> 分支）的行为。执行此操作后，首次创建的提交将成为无父提交，并开始新的历史。"

#. type: Labeled list
#: en/glossary-content.txt:323
#, no-wrap, placeholders:'[[def_origin]]', priority:310
msgid "[[def_origin]]origin"
msgstr "[[def_origin]]origin（默认的远程名称）"

#. type: Plain text
#: en/glossary-content.txt:330
#, placeholders:'<<def_repository,':'<<def_remote_tracking_branch,', priority:310
msgid "The default upstream <<def_repository,repository>>. Most projects have at least one upstream project which they track. By default 'origin' is used for that purpose. New upstream updates will be fetched into <<def_remote_tracking_branch,remote-tracking branches>> named origin/name-of-upstream-branch, which you can see using `git branch -r`."
msgstr "默认的上游<<def_repository,仓库>>。大多数项目至少有一个上游项目，它们会对其进行跟踪。默认情况下，'origin' 被用于此目的。新的上游更新会被拉取到<<def_remote_tracking_branch,远程跟踪分支>>，名为 origin/name-of-upstream-branch，你可以用 `git branch -r` 看到。"

#. type: Labeled list
#: en/glossary-content.txt:331
#, no-wrap, placeholders:'[[def_overlay]]', priority:310
msgid "[[def_overlay]]overlay"
msgstr "[[def_overlay]]覆盖 (overlay)"

#. type: Plain text
#: en/glossary-content.txt:339
#, placeholders:'<<def_checkout,':'<<def_index,':'def_tree':'--delete', priority:310
msgid "Only update and add files to the working directory, but don't delete them, similar to how 'cp -R' would update the contents in the destination directory. This is the default mode in a <<def_checkout,checkout>> when checking out files from the <<def_index,index>> or a <<def_tree-ish,tree-ish>>. In contrast, no-overlay mode also deletes tracked files not present in the source, similar to 'rsync --delete'."
msgstr "只更新和添加文件到工作目录，但不删除它们，类似于 'cp -R' 会更新目标目录中的内容。这是<<def_checkout,检出>>中的默认模式，当从<<def_index,暂存区>>或<<def_tree-ish,树状标识>>中检出文件时。相反，非覆盖模式也会删除源文件中不存在的跟踪文件，类似于 'rsync --delete'。"

# ERROR: [[def_pack]] not found in translation
#. type: Labeled list
#: en/glossary-content.txt:340
#, no-wrap, placeholders:'[[def_pack]]', priority:310
msgid "[[def_pack]]pack"
msgstr "[[def_pack]]包 (pack)"

#. type: Plain text
#: en/glossary-content.txt:343
#, priority:310
msgid "A set of objects which have been compressed into one file (to save space or to transmit them efficiently)."
msgstr "一组被压缩成一个文件的对象（以节省空间或有效传输）。"

#. type: Labeled list
#: en/glossary-content.txt:344
#, no-wrap, placeholders:'[[def_pack_index]]', priority:310
msgid "[[def_pack_index]]pack index"
msgstr "[[def_pack_index]]包索引 (pack index)"

#. type: Plain text
#: en/glossary-content.txt:348
#, placeholders:'<<def_pack,', priority:310
msgid "The list of identifiers, and other information, of the objects in a <<def_pack,pack>>, to assist in efficiently accessing the contents of a pack."
msgstr "<<def_pack,包>>中的对象的标识符和其他信息的列表，以协助有效地访问一个包的内容。"

#. type: Labeled list
#: en/glossary-content.txt:349
#, no-wrap, placeholders:'[[def_pathspec]]', priority:310
msgid "[[def_pathspec]]pathspec"
msgstr "[[def_pathspec]]路径规范 (pathspec)"

#. type: Plain text
#: en/glossary-content.txt:351
#, priority:310
msgid "Pattern used to limit paths in Git commands."
msgstr "用来限制 Git 命令中的路径的模式。"

#. type: Plain text
#: en/glossary-content.txt:359
#, placeholders:'git ls-files':'git ls-tree', priority:310
msgid "Pathspecs are used on the command line of \"git ls-files\", \"git ls-tree\", \"git add\", \"git grep\", \"git diff\", \"git checkout\", and many other commands to limit the scope of operations to some subset of the tree or working tree. See the documentation of each command for whether paths are relative to the current directory or toplevel. The pathspec syntax is as follows:"
msgstr "在 \"git ls-files\"、\"git ls-tree\"、\"git add\"、\"git grep\"、\"git diff\"、\"git checkout\" 和许多其他命令的命令行中，路径规格被用来将操作范围限制在树或工作区的某个子集。 关于路径是相对于当前目录还是顶层，请参阅每个命令的文档。 路径规范的语法如下："

#. type: Plain text
#: en/glossary-content.txt:363
#, priority:310
msgid "any path matches itself"
msgstr "任何路径都与自己匹配"

#. type: Plain text
#: en/glossary-content.txt:366
#, priority:310
msgid "the pathspec up to the last slash represents a directory prefix. The scope of that pathspec is limited to that subtree."
msgstr "到最后一个斜线的路径规范代表一个目录前缀。 该路径规范的范围只限于该子树。"

#. type: Plain text
#: en/glossary-content.txt:370
#, priority:310
msgid "the rest of the pathspec is a pattern for the remainder of the pathname. Paths relative to the directory prefix will be matched against that pattern using fnmatch(3); in particular, '*' and '?' _can_ match directory separators."
msgstr "路径规范的其余部分是路径名其余部分的模式。 相对于目录前缀的路径将使用fnmatch(3)（匹配函数）与该模式进行匹配；特别是，'*' 和 '?' _可以_ 匹配目录分隔符。"

#. type: Plain text
#: en/glossary-content.txt:376
#, priority:310
msgid "For example, Documentation/*.jpg will match all .jpg files in the Documentation subtree, including Documentation/chapter_1/figure_1.jpg."
msgstr "例如，Documentation/*.jpg 将匹配 Documentation 子目录中的所有 .jpg 文件，包括 Documentation/chapter_1/figure_1.jpg。"

#. type: Plain text
#: en/glossary-content.txt:386
#, priority:310
msgid "A pathspec that begins with a colon `:` has special meaning. In the short form, the leading colon `:` is followed by zero or more \"magic signature\" letters (which optionally is terminated by another colon `:`), and the remainder is the pattern to match against the path. The \"magic signature\" consists of ASCII symbols that are neither alphanumeric, glob, regex special characters nor colon. The optional colon that terminates the \"magic signature\" can be omitted if the pattern begins with a character that does not belong to \"magic signature\" symbol set and is not a colon."
msgstr "以冒号 `:` 开头的路径规范有特殊含义。 在简短的形式中，前面的冒号 `:` 后面是 0 个或更多的 “魔术签名(magic signature)”（可以选择以另一个冒号 `:` 结束），剩下的部分是与路径匹配的模式。 “魔术签名” 由ASCII符号组成，这些符号既不是字母数字、通配符、正则表达式特殊字符也不是冒号。 如果模式以不属于 “魔术签名” 符号集的字符开始，并且不是冒号，那么结束 “魔术签名” 的可选冒号就可以省略。"

#. type: Plain text
#: en/glossary-content.txt:391
#, priority:310
msgid "In the long form, the leading colon `:` is followed by an open parenthesis `(`, a comma-separated list of zero or more \"magic words\", and a close parentheses `)`, and the remainder is the pattern to match against the path."
msgstr "在较长规范中，前面的冒号 `:` 后面是一个开放的小括号 `(`，一个用逗号分隔的 0 个或多个 “魔术单词” 列表，以及一个封闭的小括号 `)`，其余部分是要与路径匹配的模式。"

#. type: Plain text
#: en/glossary-content.txt:394
#, priority:310
msgid "A pathspec with only a colon means \"there is no pathspec\". This form should not be combined with other pathspec."
msgstr "一个只有冒号的路径规范意味着 “不使用路径规范”。这种形式不应该与其他路径规范结合。"

#. type: Labeled list
#: en/glossary-content.txt:396
#, no-wrap, priority:310
msgid "top"
msgstr "顶部 (top)"

#. type: Plain text
#: en/glossary-content.txt:400
#, priority:310
msgid "The magic word `top` (magic signature: `/`) makes the pattern match from the root of the working tree, even when you are running the command from inside a subdirectory."
msgstr "魔术词 `top`（魔术签名：`/`）使模式从工作区的根目录开始匹配，即使你从子目录内运行命令。"

#. type: Labeled list
#: en/glossary-content.txt:401
#, no-wrap, priority:310
msgid "literal"
msgstr "字面量 (literal)"

#. type: Plain text
#: en/glossary-content.txt:404
#, priority:310
msgid "Wildcards in the pattern such as `*` or `?` are treated as literal characters."
msgstr "模式中的通配符，如 `*` 或 `?` 被视为字面量字符。"

#. type: Labeled list
#: en/glossary-content.txt:405
#, no-wrap, priority:310
msgid "icase"
msgstr "不敏感匹配 (icase)"

#. type: Plain text
#: en/glossary-content.txt:407
#, priority:310
msgid "Case insensitive match."
msgstr "不区分大小写的匹配。"

#. type: Labeled list
#: en/glossary-content.txt:408
#, no-wrap, priority:310
msgid "glob"
msgstr "通配符"

#. type: Plain text
#: en/glossary-content.txt:415
#, placeholders:'FNM_PATHNAME':'{asterisk}':'git.html':'ppc.html':'perf.html', priority:310
msgid "Git treats the pattern as a shell glob suitable for consumption by fnmatch(3) with the FNM_PATHNAME flag: wildcards in the pattern will not match a / in the pathname. For example, \"Documentation/{asterisk}.html\" matches \"Documentation/git.html\" but not \"Documentation/ppc/ppc.html\" or \"tools/perf/Documentation/perf.html\"."
msgstr "Git 将模式视为适合 fnmatch(3)（匹配函数）使用 shell 的通配符模式（shell 所使用的简化了的正则表达式），带有FNM_PATHNAME 标志：模式中的通配符将不匹配路径名中的 /（即不对子目录或上级目录进行匹配）。例如，\"Documentation/{asterisk}.html\" 匹配 \"Documentation/git.html\"，而不是 \"Documentation/ppc/ppc.html\" 或 \"tools/perf/Documentation/perf.html\"。"

#. type: Plain text
#: en/glossary-content.txt:428
#, placeholders:'.gitignore', priority:310
msgid "A trailing \"`/**`\" matches everything inside. For example, \"`abc/**`\" matches all files inside directory \"abc\", relative to the location of the `.gitignore` file, with infinite depth."
msgstr "路径后跟有 \"`/**`\" 表示匹配这个目录里面的所有文件。例如，\"`abc/**`\" 匹配相对于 `.gitignore` 文件的位置中目录 \"abc \"内的所有文件，深度无限。"

#. type: Plain text
#: en/glossary-content.txt:434
#, priority:310
msgid "Other consecutive asterisks are considered invalid."
msgstr "其他连续的星号是无效的。"

#. type: Plain text
#: en/glossary-content.txt:436
#, priority:310
msgid "Glob magic is incompatible with literal magic."
msgstr "通配符魔术词 (glob) 与字面量魔术词 (literal) 是不相容的。"

#. type: Labeled list
#: en/glossary-content.txt:437
#, no-wrap, priority:310
msgid "attr"
msgstr "属性匹配"

#. type: Plain text
#: en/glossary-content.txt:443
#, placeholders:'linkgit:gitattributes[5]', priority:310
msgid "After `attr:` comes a space separated list of \"attribute requirements\", all of which must be met in order for the path to be considered a match; this is in addition to the usual non-magic pathspec pattern matching. See linkgit:gitattributes[5]."
msgstr "在 `attr:` 之后是一个空格分隔的 “属性要求” 列表，所有这些都必须满足才能被认为是匹配的路径;这是在通常的非魔法路径规范模式匹配之外的。参见 linkgit:gitattributes[5]。"

#. type: Plain text
#: en/glossary-content.txt:446
#, priority:310
msgid "Each of the attribute requirements for the path takes one of these forms:"
msgstr "以下包含了路径的每个属性要求："

#. type: Plain text
#: en/glossary-content.txt:448
#, priority:310
msgid "\"`ATTR`\" requires that the attribute `ATTR` be set."
msgstr "\"`ATTR`\" 表示要求设置 `ATTR` 属性。"

#. type: Plain text
#: en/glossary-content.txt:450
#, priority:310
msgid "\"`-ATTR`\" requires that the attribute `ATTR` be unset."
msgstr "\"`-ATTR`\" 要求属性 `ATTR` 没有被设置。"

#. type: Plain text
#: en/glossary-content.txt:453
#, priority:310
msgid "\"`ATTR=VALUE`\" requires that the attribute `ATTR` be set to the string `VALUE`."
msgstr "\"`ATTR=VALUE`\" 要求将属性 `ATTR` 设置为字符串 `VALUE`。"

#. type: Plain text
#: en/glossary-content.txt:456
#, priority:310
msgid "\"`!ATTR`\" requires that the attribute `ATTR` be unspecified."
msgstr "\"`!ATTR`\" 要求属性 `ATTR` 是未指定的。"

#. type: Plain text
#: en/glossary-content.txt:459
#, priority:310
msgid "Note that when matching against a tree object, attributes are still obtained from working tree, not from the given tree object."
msgstr "注意，当与树对象进行匹配时，属性仍然是从工作区中获得的，而不是从给定的树对象中获得。"

#. type: Labeled list
#: en/glossary-content.txt:460
#, no-wrap, priority:310
msgid "exclude"
msgstr "排除匹配 (exclude)"

#. type: Plain text
#: en/glossary-content.txt:466
#, priority:310
msgid "After a path matches any non-exclude pathspec, it will be run through all exclude pathspecs (magic signature: `!` or its synonym `^`). If it matches, the path is ignored. When there is no non-exclude pathspec, the exclusion is applied to the result set as if invoked without any pathspec."
msgstr "当一个路径匹配了任何规则之外的 (non-exclude) 路径规范后，它将遍历所有的排除性路径规范（魔术签名：`!` 或其同义词 `^`）。如果匹配，该路径将被忽略。 当没有规则之外路径规范时，排除法将应用于结果集，就像在没有任何路径规范的情况下调用。"

#. type: Labeled list
#: en/glossary-content.txt:468
#, no-wrap, placeholders:'[[def_parent]]', priority:310
msgid "[[def_parent]]parent"
msgstr "[[def_parent]]父提交 (parent)"

#. type: Plain text
#: en/glossary-content.txt:472
#, placeholders:'<<def_commit_object,', priority:310
msgid "A <<def_commit_object,commit object>> contains a (possibly empty) list of the logical predecessor(s) in the line of development, i.e. its parents."
msgstr "一个<<def_commit_object,提交对象>>包含一个开发中的逻辑前驱列表（可能是空的），即其父提交。"

#. type: Labeled list
#: en/glossary-content.txt:473
#, no-wrap, placeholders:'[[def_peel]]', priority:310
msgid "[[def_peel]]peel"
msgstr "[[def_peel]]剥离 (peel)"

#. type: Plain text
#: en/glossary-content.txt:476
#, placeholders:'<<def_dereference,':'<<def_tag_object,', priority:310
msgid "The action of recursively <<def_dereference,dereferencing>> a <<def_tag_object,tag object>>."
msgstr "递归<<def_dereference,解引用>>一个<<def_tag_object,标签对象>> 的操作。"

#. type: Labeled list
#: en/glossary-content.txt:477
#, no-wrap, placeholders:'[[def_pickaxe]]', priority:310
msgid "[[def_pickaxe]]pickaxe"
msgstr "[[def_pickaxe]]挖掘 (pickaxe)"

#. type: Plain text
#: en/glossary-content.txt:483
#, placeholders:'<<def_pickaxe,':'`--pickaxe-all`':'<<def_changeset,':'linkgit:git-diff[1]', priority:310
msgid "The term <<def_pickaxe,pickaxe>> refers to an option to the diffcore routines that help select changes that add or delete a given text string. With the `--pickaxe-all` option, it can be used to view the full <<def_changeset,changeset>> that introduced or removed, say, a particular line of text. See linkgit:git-diff[1]."
msgstr "术语<<def_pickaxe,挖掘>>指的是 diff 核心例程 (diffcore) 的一个选项，辅助选择增加或删除特定文本字符串的变化。通过 `--pickaxe-all` 选项，它可以用来查看引入或删除的全部<<def_changeset,变更集>>，例如某一行文字。参见 linkgit:git-diff[1]。"

#. type: Labeled list
#: en/glossary-content.txt:484
#, no-wrap, placeholders:'[[def_plumbing]]', priority:310
msgid "[[def_plumbing]]plumbing"
msgstr "[[def_plumbing]]管件 (plumbing)"

#. type: Plain text
#: en/glossary-content.txt:486
#, placeholders:'<<def_core_git,', priority:310
msgid "Cute name for <<def_core_git,core Git>>."
msgstr "<<def_core_git,Git 核心>>的昵称。"

#. type: Labeled list
#: en/glossary-content.txt:487
#, no-wrap, placeholders:'[[def_porcelain]]', priority:310
msgid "[[def_porcelain]]porcelain"
msgstr "[[def_porcelain]]瓷件 (porcelain)"

#. type: Plain text
#: en/glossary-content.txt:492
#, placeholders:'<<def_core_git,':'<<def_SCM,':'<<def_plumbing,', priority:310
msgid "Cute name for programs and program suites depending on <<def_core_git,core Git>>, presenting a high level access to core Git. Porcelains expose more of a <<def_SCM,SCM>> interface than the <<def_plumbing,plumbing>>."
msgstr "依靠<<def_core_git,Git 核心>>的程序和程序套件的昵称，是对Git核心上层封装。与<<def_plumbing,管件>>相比，瓷件暴露了更多 <<def_SCM,SCM>> 接口。"

#. type: Labeled list
#: en/glossary-content.txt:493
#, no-wrap, placeholders:'[[def_per_worktree_ref]]', priority:310
msgid "[[def_per_worktree_ref]]per-worktree ref"
msgstr "[[def_per_worktree_ref]]工作区引用(per-worktree ref)"

#. type: Plain text
#: en/glossary-content.txt:498
#, placeholders:'<<def_worktree,':'<<def_HEAD,':'HEAD', priority:310
msgid "Refs that are per-<<def_worktree,worktree>>, rather than global. This is presently only <<def_HEAD,HEAD>> and any refs that start with `refs/bisect/`, but might later include other unusual refs."
msgstr "相比于全局引用，它是对每个<<def_worktree,工作区>>的引用。 目前只有 <<def_HEAD,HEAD>> 和任何以 `refs/bisect/` 开头的引用，但以后可能包括其他不寻常的引用。"

#. type: Labeled list
#: en/glossary-content.txt:499
#, no-wrap, placeholders:'[[def_pseudoref]]', priority:310
msgid "[[def_pseudoref]]pseudoref"
msgstr "[[def_pseudoref]]伪引用 (pseudoref)"

#. type: Plain text
#: en/glossary-content.txt:514
#, placeholders:'$GIT_DIR':'<<def_SHA1,':'HEAD':'MERGE_HEAD':'CHERRY_PICK_HEAD':'<<def_per_worktree_ref,':'git rev-parse':'MERGE_HEAD', priority:310
msgid "Pseudorefs are a class of files under `$GIT_DIR` which behave like refs for the purposes of rev-parse, but which are treated specially by git. Pseudorefs both have names that are all-caps, and always start with a line consisting of a <<def_SHA1,SHA-1>> followed by whitespace. So, HEAD is not a pseudoref, because it is sometimes a symbolic ref. They might optionally contain some additional data. `MERGE_HEAD` and `CHERRY_PICK_HEAD` are examples. Unlike <<def_per_worktree_ref,per-worktree refs>>, these files cannot be symbolic refs, and never have reflogs. They also cannot be updated through the normal ref update machinery. Instead, they are updated by directly writing to the files. However, they can be read as if they were refs, so `git rev-parse MERGE_HEAD` will work."
msgstr "伪引用是 `$GIT_DIR` 下的一类文件，其行为与修订-剖析 (rev-parse) 中的引用一样，但被 Git 区分对待。 伪引用的名字一般是由由一行 <<def_SHA1,SHA-1>> 开始，然后是空格。 所以，HEAD 并不是一个伪引用，因为它有时是一个符号性引用。 它可能选择性地包含一些额外的数据。 比如 `MERGE_HEAD` 和 `CHERRY_PICK_HEAD`。 与<<def_per_worktree_ref,工作区引用>>不同，这些文件不能是符号引用，也没有引用日志。 它们也不能通过正常的引用更新机制进行更新。 相反，它们是通过直接写入文件来更新的。 不过，它们可以被当作引用读取，所以 `git rev-parse MERGE_HEAD` 仍可以运行。"

#. type: Labeled list
#: en/glossary-content.txt:515
#, no-wrap, placeholders:'[[def_pull]]', priority:310
msgid "[[def_pull]]pull"
msgstr "[[def_pull]]拉取 (pull)"

#. type: Plain text
#: en/glossary-content.txt:518
#, placeholders:'<<def_branch,':'<<def_fetch,':'<<def_merge,':'linkgit:git-pull[1]', priority:310
msgid "Pulling a <<def_branch,branch>> means to <<def_fetch,fetch>> it and <<def_merge,merge>> it. See also linkgit:git-pull[1]."
msgstr "拉取一个<<def_branch,分支>>意味着<<def_fetch,获取>>一个分支并且<<def_merge,合并>>这个分支。 另见 linkgit:git-pull[1]。"

#. type: Labeled list
#: en/glossary-content.txt:519
#, no-wrap, placeholders:'[[def_push]]', priority:310
msgid "[[def_push]]push"
msgstr "[[def_push]]推送 (push)"

#. type: Plain text
#: en/glossary-content.txt:530
#, placeholders:'<<def_branch,':'<<def_head_ref,':'<<def_repository,':'<<def_reachable,':'<<def_object_database,':'<<def_head,', priority:310
msgid "Pushing a <<def_branch,branch>> means to get the branch's <<def_head_ref,head ref>> from a remote <<def_repository,repository>>, find out if it is an ancestor to the branch's local head ref, and in that case, putting all objects, which are <<def_reachable,reachable>> from the local head ref, and which are missing from the remote repository, into the remote <<def_object_database,object database>>, and updating the remote head ref. If the remote <<def_head,head>> is not an ancestor to the local head, the push fails."
msgstr "推送一个<<def_branch,分支>>意味着从远程的<<def_repository,仓库>>获取该分支的<<def_head_ref,头引用>>，找出它是否是该分支的本地分支引用的一个祖先。在这种情况下，将所有从本地分支引用<<def_reachable,可达>>的对象，以及从远程仓库中丢失的对象，放入远程<<def_object_database,对象库>>，并更新远程分支引用。如果远程<<def_head,头/分支>>不是本地分支的祖先，则推送失败。"

#. type: Labeled list
#: en/glossary-content.txt:531
#, no-wrap, placeholders:'[[def_reachable]]', priority:310
msgid "[[def_reachable]]reachable"
msgstr "[[def_reachable]]可达的 (reachable)"

#. type: Plain text
#: en/glossary-content.txt:540
#, placeholders:'<<def_commit,':'<<def_object,':'<<def_chain,':'<<def_tag,':'<<def_commit_object,':'<<def_tree_object,':'<<def_blob_object,', priority:310
msgid "All of the ancestors of a given <<def_commit,commit>> are said to be \"reachable\" from that commit. More generally, one <<def_object,object>> is reachable from another if we can reach the one from the other by a <<def_chain,chain>> that follows <<def_tag,tags>> to whatever they tag, <<def_commit_object,commits>> to their parents or trees, and <<def_tree_object,trees>> to the trees or <<def_blob_object,blobs>> that they contain."
msgstr "一个给定的<<def_commit,提交>>的所有祖先都被称为可以从该提交 “到达”。更一般地说，如果一个<<def_object,对象>>可以通过<<def_chain,对象链>>从一个<<def_tag,标签>>到达任意一个对象链标记的<<def_tag,标签>>，那么该对象就是可达的，<<def_commit_object,提交>>到它们的父提交或树，以及<<def_tree_object,树>>到它们所包含的树或<<def_blob_object,二进制对象>>。"

#. type: Labeled list
#: en/glossary-content.txt:541
#, no-wrap, placeholders:'[[def_reachability_bitmap]]', priority:310
msgid "[[def_reachability_bitmap]]reachability bitmaps"
msgstr "[[def_reachability_bitmap]]可达性位图"

#. type: Plain text
#: en/glossary-content.txt:548
#, placeholders:'<<def_reachable,', priority:310
msgid "Reachability bitmaps store information about the <<def_reachable,reachability>> of a selected set of commits in a packfile, or a multi-pack index (MIDX), to speed up object search. The bitmaps are stored in a \".bitmap\" file. A repository may have at most one bitmap file in use. The bitmap file may belong to either one pack, or the repository's multi-pack index (if it exists)."
msgstr "可达性位图存储了包文件或多包索引（MIDX）中选定的一组提交的<<def_reachable,可达性>>的信息，以加快对象搜索。 位图被存储在 \".bitmap\" 文件中。一个仓库最多可以有一个位图文件在使用。这个位图文件可以属于一个包，也可以属于仓库的多包索引（如果有的话）。"

#. type: Labeled list
#: en/glossary-content.txt:549
#, no-wrap, placeholders:'[[def_rebase]]', priority:310
msgid "[[def_rebase]]rebase"
msgstr "[[def_rebase]]变基 (rebase)"

#. type: Plain text
#: en/glossary-content.txt:553
#, placeholders:'<<def_branch,':'<<def_head,', priority:310
msgid "To reapply a series of changes from a <<def_branch,branch>> to a different base, and reset the <<def_head,head>> of that branch to the result."
msgstr "将<<def_branch,分支>>的一系列修改重新应用于不同的分支上，并将<<def_head,头>>指针重置为该分支。"

#. type: Labeled list
#: en/glossary-content.txt:554
#, no-wrap, placeholders:'[[def_ref]]', priority:310
msgid "[[def_ref]]ref"
msgstr "[[def_ref]]引用 (ref)"

#. type: Plain text
#: en/glossary-content.txt:562
#, placeholders:'<<def_object_name,':'<<def_symref,':'linkgit:gitrevisions[7]':'<<def_repository,', priority:310
msgid "A name that begins with `refs/` (e.g. `refs/heads/master`) that points to an <<def_object_name,object name>> or another ref (the latter is called a <<def_symref,symbolic ref>>). For convenience, a ref can sometimes be abbreviated when used as an argument to a Git command; see linkgit:gitrevisions[7] for details. Refs are stored in the <<def_repository,repository>>."
msgstr "一个以 `refs/` 开头的名字（例如 `refs/heads/master`），它指向一个<<def_object_name,对象名称>>或另一个引用（后者被称为<<def_symref,符号引用>>）。 为方便起见，当作为 Git 命令的参数时，引用可以使用缩写；参见 linkgit:gitrevisions[7] 。 引用保存在<<def_repository,仓库>>中。"

#. type: Plain text
#: en/glossary-content.txt:566
#, priority:310
msgid "The ref namespace is hierarchical. Different subhierarchies are used for different purposes (e.g. the `refs/heads/` hierarchy is used to represent local branches)."
msgstr "引用的命名空间是分层次的。 不同的子层次表示不同的情况（例如，`refs/heads/` 层次用于代表本地分支）。"

#. type: Plain text
#: en/glossary-content.txt:569
#, placeholders:'HEAD', priority:310
msgid "There are a few special-purpose refs that do not begin with `refs/`. The most notable example is `HEAD`."
msgstr "有一些特殊意义的引用不以 `refs/` 开头。 最经典的例子就是 `HEAD`。"

#. type: Labeled list
#: en/glossary-content.txt:570
#, no-wrap, placeholders:'[[def_reflog]]', priority:310
msgid "[[def_reflog]]reflog"
msgstr "[[def_reflog]]引用日志 (reflog)"

#. type: Plain text
#: en/glossary-content.txt:575
#, placeholders:'linkgit:git-reflog[1]', priority:310
msgid "A reflog shows the local \"history\" of a ref. In other words, it can tell you what the 3rd last revision in _this_ repository was, and what was the current state in _this_ repository, yesterday 9:14pm. See linkgit:git-reflog[1] for details."
msgstr "引用日志显示一个引用的本地 “历史”。 换句话说，它可以告诉你，在昨天下午 9:14，_这个_ 仓库的最后三次修订是什么，以及 _这个_ 仓库的当前状态是什么。 详情见 linkgit:git-reflog[1]。"

#. type: Labeled list
#: en/glossary-content.txt:576
#, no-wrap, placeholders:'[[def_refspec]]', priority:310
msgid "[[def_refspec]]refspec"
msgstr "[[def_refspec]]引用规范 (refspec)"

#. type: Plain text
#: en/glossary-content.txt:580
#, placeholders:'<<def_fetch,':'<<def_push,':'<<def_ref,', priority:310
msgid "A \"refspec\" is used by <<def_fetch,fetch>> and <<def_push,push>> to describe the mapping between remote <<def_ref,ref>> and local ref."
msgstr "“引用规范” 是<<def_fetch,获取>>和<<def_push,推送>>用以描述远程<<def_ref,引用>>和本地引用之间的映射关系。"

#. type: Labeled list
#: en/glossary-content.txt:581
#, no-wrap, placeholders:'[[def_remote]]', priority:310
msgid "[[def_remote]]remote repository"
msgstr "[[def_remote]]远程仓库 (remote repository)"

#. type: Plain text
#: en/glossary-content.txt:585
#, placeholders:'<<def_repository,':'<<def_fetch,':'<<def_push,', priority:310
msgid "A <<def_repository,repository>> which is used to track the same project but resides somewhere else. To communicate with remotes, see <<def_fetch,fetch>> or <<def_push,push>>."
msgstr "一个部署在其他地方但用于跟踪同一个项目的<<def_repository,仓库>>。要与远程通信，请参阅<<def_fetch,获取>>或<<def_push,推送>>。"

#. type: Labeled list
#: en/glossary-content.txt:586
#, no-wrap, placeholders:'[[def_remote_tracking_branch]]', priority:310
msgid "[[def_remote_tracking_branch]]remote-tracking branch"
msgstr "[[def_remote_tracking_branch]]远程跟踪分支 (remote-tracking branch)"

#. type: Plain text
#: en/glossary-content.txt:594
#, placeholders:'<<def_ref,':'<<def_repository,':'<<def_refspec,', priority:310
msgid "A <<def_ref,ref>> that is used to follow changes from another <<def_repository,repository>>. It typically looks like 'refs/remotes/foo/bar' (indicating that it tracks a branch named 'bar' in a remote named 'foo'), and matches the right-hand-side of a configured fetch <<def_refspec,refspec>>. A remote-tracking branch should not contain direct modifications or have local commits made to it."
msgstr "一个用来跟踪另一个<<def_repository,仓库>>变化的<<def_ref,引用>>。它通常看起来像'refs/remotes/foo/bar'（表示它跟踪一个名为'foo'的远程中名为'bar'的分支），并对配置好的fetch<<def_refspec,引用规范>>右侧进行匹配。一个远程跟踪分支不应该由直接的修改或是本地的提交构成。"

# ERROR: [[def_repository]] not found in translation
#. type: Labeled list
#: en/glossary-content.txt:595
#, no-wrap, placeholders:'[[def_repository]]', priority:310
msgid "[[def_repository]]repository"
msgstr "[[def_repository]]仓库 (repository)"

#. type: Plain text
#: en/glossary-content.txt:602
#, placeholders:'<<def_ref,':'<<def_object_database,':'<<def_reachable,':'<<def_porcelain,':'<<def_alternate_object_database,', priority:310
msgid "A collection of <<def_ref,refs>> together with an <<def_object_database,object database>> containing all objects which are <<def_reachable,reachable>> from the refs, possibly accompanied by meta data from one or more <<def_porcelain,porcelains>>. A repository can share an object database with other repositories via <<def_alternate_object_database,alternates mechanism>>."
msgstr "一个<<def_ref,引用>>的集合和一个<<def_object_database,对象库>>的集合，包含了引用中所有的<<def_reachable,可达的>>对象，可能还有一个或多个<<def_porcelain,瓷件>>元数据。一个仓库可以通过<<def_alternate_object_database,轮替对象库>>与其他存储库共享对象数据库。"

#. type: Labeled list
#: en/glossary-content.txt:603
#, no-wrap, placeholders:'[[def_resolve]]', priority:310
msgid "[[def_resolve]]resolve"
msgstr "[[def_resolve]]解决 (resolve)"

#. type: Plain text
#: en/glossary-content.txt:606
#, placeholders:'<<def_merge,', priority:310
msgid "The action of fixing up manually what a failed automatic <<def_merge,merge>> left behind."
msgstr "手动修复由自动<<def_merge,合并>>产生的遗留错误。"

#. type: Labeled list
#: en/glossary-content.txt:607
#, no-wrap, placeholders:'[[def_revision]]', priority:310
msgid "[[def_revision]]revision"
msgstr "[[def_revision]]版本 (revision)"

#. type: Plain text
#: en/glossary-content.txt:609
#, placeholders:'<<def_commit,', priority:310
msgid "Synonym for <<def_commit,commit>> (the noun)."
msgstr "与<<def_commit,提交>>（名词形式）同义。"

#. type: Labeled list
#: en/glossary-content.txt:610
#, no-wrap, placeholders:'[[def_rewind]]', priority:310
msgid "[[def_rewind]]rewind"
msgstr "[[def_rewind]]回退 (rewind)"

#. type: Plain text
#: en/glossary-content.txt:613
#, placeholders:'<<def_head,':'<<def_revision,', priority:310
msgid "To throw away part of the development, i.e. to assign the <<def_head,head>> to an earlier <<def_revision,revision>>."
msgstr "删除一部分数据，即把<<def_head,头>>指针指向较早的<<def_revision,版本>>。"

#. type: Labeled list
#: en/glossary-content.txt:614
#, no-wrap, placeholders:'[[def_SCM]]', priority:310
msgid "[[def_SCM]]SCM"
msgstr "[[def_SCM]]SCM（源代码管理工具）"

#. type: Plain text
#: en/glossary-content.txt:616
#, priority:310
msgid "Source code management (tool)."
msgstr "源代码管理（工具）。"

#. type: Labeled list
#: en/glossary-content.txt:617
#, no-wrap, placeholders:'[[def_SHA1]]', priority:310
msgid "[[def_SHA1]]SHA-1"
msgstr "[[def_SHA1]]SHA-1"

#. type: Plain text
#: en/glossary-content.txt:620
#, placeholders:'<<def_object_name,', priority:310
msgid "\"Secure Hash Algorithm 1\"; a cryptographic hash function. In the context of Git used as a synonym for <<def_object_name,object name>>."
msgstr "“安全哈希算法 1”；一个加密哈希函数。 在 Git 的上下文中是<<def_object_name,对象名>>的同义词。"

#. type: Labeled list
#: en/glossary-content.txt:621
#, no-wrap, placeholders:'[[def_shallow_clone]]', priority:310
msgid "[[def_shallow_clone]]shallow clone"
msgstr "[[def_shallow_clone]]浅克隆 (shallow clone)"

#. type: Plain text
#: en/glossary-content.txt:625
#, ignore-ellipsis, placeholders:'<<def_shallow_repository,':'--depth=', priority:310
msgid "Mostly a synonym to <<def_shallow_repository,shallow repository>> but the phrase makes it more explicit that it was created by running `git clone --depth=...` command."
msgstr "大部分是指<<def_shallow_repository,浅仓库>>，但它更明确地表明其是通过运行 `git clone --depth=...` 命令创建的。"

# ERROR: [[def_shallow_repository]] not found in translation
#. type: Labeled list
#: en/glossary-content.txt:626
#, no-wrap, placeholders:'[[def_shallow_repository]]', priority:310
msgid "[[def_shallow_repository]]shallow repository"
msgstr "[[def_shallow_repository]]浅仓库 (shallow repository)"

#. type: Plain text
#: en/glossary-content.txt:636
#, placeholders:'<<def_repository,':'<<def_commit,':'<<def_parent,':'<<def_commit_object,':'`--depth`':'linkgit:git-clone[1]':'linkgit:git-fetch[1]', priority:310
msgid "A shallow <<def_repository,repository>> has an incomplete history some of whose <<def_commit,commits>> have <<def_parent,parents>> cauterized away (in other words, Git is told to pretend that these commits do not have the parents, even though they are recorded in the <<def_commit_object,commit object>>). This is sometimes useful when you are interested only in the recent history of a project even though the real history recorded in the upstream is much larger. A shallow repository is created by giving the `--depth` option to linkgit:git-clone[1], and its history can be later deepened with linkgit:git-fetch[1]."
msgstr "一个浅<<def_repository,仓库>>不会记录完整的提交历史，其中一些<<def_commit,提交>>的<<def_parent,父>>提交被销毁了（换句话说，Git 被告知假装这些提交没有父提交，尽管在<<def_commit_object,提交对象>>中有记录）。当你只对一个项目的近期历史感兴趣时，这是很有用的，尽管上游记录的真实历史要大得多。通过给 linkgit:git-clone[1]提供 `--depth` 选项，可以创建一个浅层的仓库，之后可以用 linkgit:git-fetch[1] 深掘它的历史。"

#. type: Labeled list
#: en/glossary-content.txt:637
#, no-wrap, placeholders:'[[def_stash]]', priority:310
msgid "[[def_stash]]stash entry"
msgstr "[[def_stash]]贮藏项 (stash entry)"

#. type: Plain text
#: en/glossary-content.txt:640
#, placeholders:'<<def_object,':'<<def_dirty,', priority:310
msgid "An <<def_object,object>> used to temporarily store the contents of a <<def_dirty,dirty>> working directory and the index for future reuse."
msgstr "一个<<def_object,对象>>，用于临时存储<<def_dirty,脏>>工作目录的内容和索引，以便将来重新使用。"

#. type: Labeled list
#: en/glossary-content.txt:641
#, no-wrap, placeholders:'[[def_special_ref]]', priority:310
msgid "[[def_special_ref]]special ref"
msgstr "[[def_special_ref]]特殊引用 (special ref )"

#. type: Plain text
#: en/glossary-content.txt:645
#, priority:310
msgid "A ref that has different semantics than normal refs. These refs can be accessed via normal Git commands but may not behave the same as a normal ref in some cases."
msgstr "语义不同于普通引用的引用。这些引用可以通过正常的 Git 命令访问，但在某些情况下可能与正常引用的行为不同。"

#. type: Plain text
#: en/glossary-content.txt:647
#, priority:310
msgid "The following special refs are known to Git:"
msgstr "Git 已知的特殊引用如下："

#. type: Plain text
#: en/glossary-content.txt:651
#, placeholders:'FETCH_HEAD':'linkgit:git-fetch[1]':'linkgit:git-pull[1]', priority:310
msgid "\"`FETCH_HEAD`\" is written by linkgit:git-fetch[1] or linkgit:git-pull[1]. It may refer to multiple object IDs. Each object ID is annotated with metadata indicating where it was fetched from and its fetch status."
msgstr "\"`FETCH_HEAD`\" 由 linkgit:git-fetch[1] 或 linkgit:git-pull[1] 写入。它可以指向多个对象 ID。每个对象 ID 都有元数据注释，说明其取自何处以及取回状态。"

#. type: Plain text
#: en/glossary-content.txt:654
#, placeholders:'MERGE_HEAD':'linkgit:git-merge[1]', priority:310
msgid "\"`MERGE_HEAD`\" is written by linkgit:git-merge[1] when resolving merge conflicts. It contains all commit IDs which are being merged."
msgstr "linkgit:git-merge[1] 在解决合并冲突时会写入 \"`MERGE_HEAD`\"。它包含所有正在合并的提交 ID。"

#. type: Labeled list
#: en/glossary-content.txt:655
#, no-wrap, placeholders:'[[def_submodule]]', priority:310
msgid "[[def_submodule]]submodule"
msgstr "[[def_submodule]]子模块 (submodule)"

#. type: Plain text
#: en/glossary-content.txt:659
#, placeholders:'<<def_repository,':'<<def_superproject,', priority:310
msgid "A <<def_repository,repository>> that holds the history of a separate project inside another repository (the latter of which is called <<def_superproject, superproject>>)."
msgstr "一个<<def_repository,仓库>>保存着另一个库内的独立项目的历史（后者被称为<<def_superproject, 父工程>>）。"

#. type: Labeled list
#: en/glossary-content.txt:660
#, no-wrap, placeholders:'[[def_superproject]]', priority:310
msgid "[[def_superproject]]superproject"
msgstr "[[def_superproject]]父工程 (superproject)"

#. type: Plain text
#: en/glossary-content.txt:665
#, placeholders:'<<def_repository,':'<<def_submodule,', priority:310
msgid "A <<def_repository,repository>> that references repositories of other projects in its working tree as <<def_submodule,submodules>>. The superproject knows about the names of (but does not hold copies of) commit objects of the contained submodules."
msgstr "一个<<def_repository,仓库>>在其工作区中引用其他项目的仓库，作为<<def_submodule,子模块>>。 父工程包含子模块的提交对象的名称（但不持有其副本）。"

#. type: Labeled list
#: en/glossary-content.txt:666
#, no-wrap, placeholders:'[[def_symref]]', priority:310
msgid "[[def_symref]]symref"
msgstr "[[def_symref]]符号引用 (symref)"

#. type: Plain text
#: en/glossary-content.txt:672
#, placeholders:'<<def_SHA1,':'<<def_dereference,':'<<def_HEAD,':'HEAD':'linkgit:git-symbolic-ref[1]', priority:310
msgid "Symbolic reference: instead of containing the <<def_SHA1,SHA-1>> id itself, it is of the format 'ref: refs/some/thing' and when referenced, it recursively <<def_dereference,dereferences>> to this reference. '<<def_HEAD,HEAD>>' is a prime example of a symref. Symbolic references are manipulated with the linkgit:git-symbolic-ref[1] command."
msgstr "符号引用：它本身不包含 <<def_SHA1,SHA-1>> ID，而是采用 'ref: refs/some/thing' 的格式，当被引用时，它会递归 <<def_dereference,解引用>> 到该引用。'<<def_HEAD,HEAD>>' 就是符号引用的一个典型例子。符号引用可以通过 linkgit:git-symbolic-ref[1] 命令来操作。"

#. type: Labeled list
#: en/glossary-content.txt:673
#, no-wrap, placeholders:'[[def_tag]]', priority:310
msgid "[[def_tag]]tag"
msgstr "[[def_tag]]标签 (tag)"

#. type: Plain text
#: en/glossary-content.txt:682
#, placeholders:'<<def_ref,':'<<def_tag_object,':'<<def_commit_object,':'<<def_head,':'<<def_object_type,':'<<def_chain,', priority:310
msgid "A <<def_ref,ref>> under `refs/tags/` namespace that points to an object of an arbitrary type (typically a tag points to either a <<def_tag_object,tag>> or a <<def_commit_object,commit object>>). In contrast to a <<def_head,head>>, a tag is not updated by the `commit` command. A Git tag has nothing to do with a Lisp tag (which would be called an <<def_object_type,object type>> in Git's context). A tag is most typically used to mark a particular point in the commit ancestry <<def_chain,chain>>."
msgstr "在 `refs/tags/` 命名空间下的一个<<def_ref,引用>>，指向一个任意类型的对象（通常一个标签指向一个<<def_tag_object,标签>>对象或者一个<<def_commit_object,提交对象>>）。 与<<def_head,head>>标记相比，标签不会被 `commit` 命令更新。Git 的标签与 Lisp 的标签（在Git的上下文中称为<<def_object_type,对象类型>>）毫无关系。标签最常用的是标记祖先提交中的一个特定<<def_chain,对象链>>。"

#. type: Labeled list
#: en/glossary-content.txt:683
#, no-wrap, placeholders:'[[def_tag_object]]', priority:310
msgid "[[def_tag_object]]tag object"
msgstr "[[def_tag_object]]标签对象 (tag object)"

#. type: Plain text
#: en/glossary-content.txt:688
#, placeholders:'<<def_object,':'<<def_ref,':'<<def_commit_object,', priority:310
msgid "An <<def_object,object>> containing a <<def_ref,ref>> pointing to another object, which can contain a message just like a <<def_commit_object,commit object>>. It can also contain a (PGP) signature, in which case it is called a \"signed tag object\"."
msgstr "一个<<def_object,对象>>包含一个指向另一个对象的<<def_ref,引用>>，它可以像<<def_commit_object,提交对象>>那样包含一个消息。它也可以包含一个（PGP）签名，这种情况下 PGP 被称为： “有签名的标签对象” (signed tag object)。"

#. type: Labeled list
#: en/glossary-content.txt:689
#, no-wrap, placeholders:'[[def_topic_branch]]', priority:310
msgid "[[def_topic_branch]]topic branch"
msgstr "[[def_topic_branch]]主题分支 (topic branch)"

#. type: Plain text
#: en/glossary-content.txt:695
#, placeholders:'<<def_branch,', priority:310
msgid "A regular Git <<def_branch,branch>> that is used by a developer to identify a conceptual line of development. Since branches are very easy and inexpensive, it is often desirable to have several small branches that each contain very well defined concepts or small incremental yet related changes."
msgstr "一个常规的 Git <<def_branch,分支>>，被开发者用来确定一个概念性的开发路线。由于新建一个分支通常需要很小的代价，所以通常开发中会包含几个小的分支，每个分支都有着非常明确的概念或小的增量但相关的变化。"

#. type: Labeled list
#: en/glossary-content.txt:696
#, no-wrap, placeholders:'[[def_tree]]', priority:310
msgid "[[def_tree]]tree"
msgstr "[[def_tree]]树/目录树 (tree)"

#. type: Plain text
#: en/glossary-content.txt:700
#, placeholders:'<<def_working_tree,':'<<def_tree_object,':'<<def_blob_object,', priority:310
msgid "Either a <<def_working_tree,working tree>>, or a <<def_tree_object,tree object>> together with the dependent <<def_blob_object,blob>> and tree objects (i.e. a stored representation of a working tree)."
msgstr "要么是一个<<def_working_tree,工作区>>，要么是一个<<def_tree_object,树对象>>连同附属的<<def_blob_object,二进制文件>>对对象和对象树（即一个工作区的存储表示）。"

#. type: Labeled list
#: en/glossary-content.txt:701
#, no-wrap, placeholders:'[[def_tree_object]]', priority:310
msgid "[[def_tree_object]]tree object"
msgstr "[[def_tree_object]]树对象 (tree object)"

#. type: Plain text
#: en/glossary-content.txt:705
#, placeholders:'<<def_object,':'<<def_tree,':'<<def_directory,', priority:310
msgid "An <<def_object,object>> containing a list of file names and modes along with refs to the associated blob and/or tree objects. A <<def_tree,tree>> is equivalent to a <<def_directory,directory>>."
msgstr "一个<<def_object,对象>>包含一个文件名和模式的列表，以及相关的二进制文件和/或对象树的引用。一个<<def_tree,树>>等同于一个<<def_directory,目录>>。"

#. type: Labeled list
#: en/glossary-content.txt:706
#, no-wrap, placeholders:'[[def_tree-ish]]', priority:310
msgid "[[def_tree-ish]]tree-ish (also treeish)"
msgstr "[[def_tree-ish]]树状标识 [tree-ish (also treeish)]"

#. type: Plain text
#: en/glossary-content.txt:719
#, placeholders:'<<def_tree_object,':'<<def_object,':'<<def_dereference,':'<<def_commit_object,':'<<def_revision,':'<<def_directory,':'def_commit':'<<def_tag_object,', priority:310
msgid "A <<def_tree_object,tree object>> or an <<def_object,object>> that can be recursively <<def_dereference,dereferenced>> to a tree object. Dereferencing a <<def_commit_object,commit object>> yields the tree object corresponding to the <<def_revision,revision>>'s top <<def_directory,directory>>. The following are all tree-ishes: a <<def_commit-ish,commit-ish>>, a tree object, a <<def_tag_object,tag object>> that points to a tree object, a tag object that points to a tag object that points to a tree object, etc."
msgstr "一个 <<def_tree_object,目录树对象>> 或一个 <<def_object,object>> 可以递归 <<def_dereference,解引用>> 到一个目录树对象。解引用 <<def_commit_object,提交对象>> 可以得到与 <<def_revision,修订>> 的顶层 <<def_directory,目录>> 相对应的目录树对象。以下都是树状对象：一个 <<def_commit-ish,提交号>>、一个树状对象、一个指向树状对象的 <<def_tag_object,标签对象>>、一个指向树状对象的标签对象、一个指向目录树对象的标签对象，等等。"

#. type: Labeled list
#: en/glossary-content.txt:720
#, no-wrap, placeholders:'[[def_unborn]]', priority:310
msgid "[[def_unborn]]unborn"
msgstr "[[def_unborn]]未出现（unborn）"

#. type: Plain text
#: en/glossary-content.txt:730
#, placeholders:'<<def_HEAD,':'HEAD':'<<def_branch,':'HEAD':'<<def_orphan,', priority:310
msgid "The <<def_HEAD,HEAD>> can point at a <<def_branch,branch>> that does not yet exist and that does not have any commit on it yet, and such a branch is called an unborn branch. The most typical way users encounter an unborn branch is by creating a repository anew without cloning from elsewhere. The HEAD would point at the 'main' (or 'master', depending on your configuration) branch that is yet to be born. Also some operations can get you on an unborn branch with their <<def_orphan,orphan>> option."
msgstr "<<def_HEAD,HEAD>> 可以指向一个<<def_branch,分支>>，而这个<<def_branch,分支>尚未存在，也没有任何提交，这样的分支被称为未诞生分支。用户遇到未诞生分支的最常见方式是不从其他地方克隆，而是重新创建一个仓库。HEAD 会指向尚未诞生的 'main'（或 'master'，取决于你的配置）分支。此外，某些操作也会通过 <<def_orphan,orphan>> 选项让你进入一个未诞生的分支。"

# ERROR: [[def_unmerged_index]] not found in translation
#. type: Labeled list
#: en/glossary-content.txt:732
#, no-wrap, placeholders:'[[def_unmerged_index]]', priority:310
msgid "[[def_unmerged_index]]unmerged index"
msgstr "[[def_unmerged_index]]未合并暂存区 (unmerged index)"

#. type: Plain text
#: en/glossary-content.txt:735
#, placeholders:'<<def_index,':'<<def_index_entry,', priority:310
msgid "An <<def_index,index>> which contains unmerged <<def_index_entry,index entries>>."
msgstr "一个<<def_index,暂存区>>，包含未合并的<<def_index_entry,索引项>>。"

#. type: Labeled list
#: en/glossary-content.txt:736
#, no-wrap, placeholders:'[[def_unreachable_object]]', priority:310
msgid "[[def_unreachable_object]]unreachable object"
msgstr "[[def_unreachable_object]]不可达对象 (unreachable object)"

#. type: Plain text
#: en/glossary-content.txt:739
#, placeholders:'<<def_object,':'<<def_reachable,':'<<def_branch,':'<<def_tag,', priority:310
msgid "An <<def_object,object>> which is not <<def_reachable,reachable>> from a <<def_branch,branch>>, <<def_tag,tag>>, or any other reference."
msgstr "一个从<<def_branch,分支>>、<<def_tag,标签>>或任何其他引用中都不<<def_reachable,可达的>><<def_object,对象>>。"

#. type: Labeled list
#: en/glossary-content.txt:740
#, no-wrap, priority:310
msgid "[[def_upstream_branch]]upstream branch"
msgstr "[[def_upstream_branch]]上游分支 (upstream branch)"

#. type: Plain text
#: en/glossary-content.txt:745
#, placeholders:'<<def_branch,', priority:310
msgid "The default <<def_branch,branch>> that is merged into the branch in question (or the branch in question is rebased onto). It is configured via branch.<name>.remote and branch.<name>.merge. If the upstream branch of 'A' is 'origin/B' sometimes we say \"'A' is tracking 'origin/B'\"."
msgstr "默认的 <<def_branch,分支>> 会被合并到相关的分支中（或相关的变基 (rebase) 分支）。它是通过 `branch.<name>.remote` 和 `branch.<name>.merge` 配置的。如果 'A' 的上游分支是 'origin/B'，这有时会称作 “'A' 正在跟踪 'origin/B'”。"

#. type: Labeled list
#: en/glossary-content.txt:746
#, no-wrap, placeholders:'[[def_working_tree]]', priority:310
msgid "[[def_working_tree]]working tree"
msgstr "[[def_working_tree]]工作区 (working tree)"

#. type: Plain text
#: en/glossary-content.txt:750
#, placeholders:'<<def_HEAD,':'HEAD', priority:310
msgid "The tree of actual checked out files. The working tree normally contains the contents of the <<def_HEAD,HEAD>> commit's tree, plus any local changes that you have made but not yet committed."
msgstr "实际检查出来的文件树。 工作区通常包含<<def_HEAD,HEAD>>提交树的内容，和一些你已经做了但还没有提交的本地修改。"

#. type: Labeled list
#: en/glossary-content.txt:751
#, no-wrap, placeholders:'[[def_worktree]]', priority:310
msgid "[[def_worktree]]worktree"
msgstr "[[def_worktree]]工作树(worktree)"

#. type: Plain text
#: en/glossary-content.txt:758
#, placeholders:'HEAD':'MERGE_HEAD', priority:310
msgid "A repository can have zero (i.e. bare repository) or one or more worktrees attached to it. One \"worktree\" consists of a \"working tree\" and repository metadata, most of which are shared among other worktrees of a single repository, and some of which are maintained separately per worktree (e.g. the index, HEAD and pseudorefs like MERGE_HEAD, per-worktree refs and per-worktree configuration file)."
msgstr "一个仓库可以没有（即裸仓库），也可以有一个或多个工作树附属于它。一个 “工作树 ”由 “工作区”和版本库元数据组成，其中大部分元数据在单个仓库的其他工作树中共享，有些元数据在每个工作树中单独维护（例如：索引、HEAD 和像MERGE_HEAD这样的伪引用 、每个工作树索引件和每个工作树）。"

#. type: Plain text
#: en/i18n.txt:2
#, priority:280
msgid "Git is to some extent character encoding agnostic."
msgstr "Git在某种程度上是与字符编码无关的。"

#. type: Plain text
#: en/i18n.txt:6
#, priority:280
msgid "The contents of the blob objects are uninterpreted sequences of bytes. There is no encoding translation at the core level."
msgstr "blob对象的内容是未经解释的字节序列。 在核心层没有编码转换。"

#. type: Plain text
#: en/i18n.txt:13
#, placeholders:'linkgit:git-config[1]':'linkgit:gitignore[5]':'linkgit:gitattributes[5]':'linkgit:gitmodules[5]', priority:280
msgid "Path names are encoded in UTF-8 normalization form C. This applies to tree objects, the index file, ref names, as well as path names in command line arguments, environment variables and config files (`.git/config` (see linkgit:git-config[1]), linkgit:gitignore[5], linkgit:gitattributes[5] and linkgit:gitmodules[5])."
msgstr "路径名以UTF-8规范化形式C编码，这适用于树对象、索引文件、参考名称，以及命令行参数、环境变量和配置文件（`.git/config`（见linkgit:git-config[1]），linkgit:gitignore[5]，linkgit:gitattributes[5] 和linkgit:gitmodules[5]）中的路径名。"

#. type: Plain text
#: en/i18n.txt:23
#, priority:280
msgid "Note that Git at the core level treats path names simply as sequences of non-NUL bytes, there are no path name encoding conversions (except on Mac and Windows). Therefore, using non-ASCII path names will mostly work even on platforms and file systems that use legacy extended ASCII encodings. However, repositories created on such systems will not work properly on UTF-8-based systems (e.g. Linux, Mac, Windows) and vice versa. Additionally, many Git-based tools simply assume path names to be UTF-8 and will fail to display other encodings correctly."
msgstr "请注意，Git 在核心层将路径名简单地视为非 NUL 字节的序列，没有路径名编码的转换（除了 Mac 和 Windows）。因此，即使在使用传统的扩展ASCII编码的平台和文件系统上，使用非ASCII的路径名大多也能工作。然而，在这种系统上创建的仓库在基于UTF-8的系统（如Linux、Mac、Windows）上将无法正常工作，反之亦然。 此外，许多基于Git的工具简单地认为路径名称是UTF-8，而不能正确显示其他编码。"

#. type: Plain text
#: en/i18n.txt:29
#, priority:280
msgid "Commit log messages are typically encoded in UTF-8, but other extended ASCII encodings are also supported. This includes ISO-8859-x, CP125x and many others, but _not_ UTF-16/32, EBCDIC and CJK multi-byte encodings (GBK, Shift-JIS, Big5, EUC-x, CP9xx etc.)."
msgstr "提交日志信息通常以UTF-8编码，但也支持其他扩展ASCII编码。这包括ISO-8859-x、CP125x和其他许多编码，但不包括UTF-16/32、EBCDIC和CJK多字节编码（GBK、Shift-JIS、Big5、EUC-x、CP9xx等）。"

#. type: Plain text
#: en/i18n.txt:36
#, priority:280
msgid "Although we encourage that the commit log messages are encoded in UTF-8, both the core and Git Porcelain are designed not to force UTF-8 on projects. If all participants of a particular project find it more convenient to use legacy encodings, Git does not forbid it. However, there are a few things to keep in mind."
msgstr "尽管我们鼓励提交日志信息使用UTF-8编码，但核心系统和Git Porcelain的设计并不强制要求项目使用UTF-8。 如果某个项目的所有参与者都认为使用传统编码更方便，Git也不会禁止。 然而，有几件事需要注意。"

#. type: Plain text
#: en/i18n.txt:42
#, placeholders:'git commit-tree', priority:280
msgid "'git commit' and 'git commit-tree' issue a warning if the commit log message given to it does not look like a valid UTF-8 string, unless you explicitly say your project uses a legacy encoding. The way to say this is to have `i18n.commitEncoding` in `.git/config` file, like this:"
msgstr "'git commit' 和 'git commit-tree' 如果收到的提交日志信息不像是有效的 UTF-8 字符串，就会发出警告，除非你明确表示你的项目使用的是传统编码。 说这个的方法是在 `.git/config` 文件中设置 `i18n.commitEncoding`，像这样："

#. type: delimited block -
#: en/i18n.txt:46
#, no-wrap, priority:280
msgid ""
"[i18n]\n"
"\tcommitEncoding = ISO-8859-1\n"
msgstr ""
"[i18n]\n"
"\tcommitEncoding = ISO-8859-1\n"

#. type: Plain text
#: en/i18n.txt:52
#, priority:280
msgid "Commit objects created with the above setting record the value of `i18n.commitEncoding` in their `encoding` header. This is to help other people who look at them later. Lack of this header implies that the commit log message is encoded in UTF-8."
msgstr "用上述设置创建的提交对象在它的 `encoding` 头中记录了 `i18n.commitEncoding` 的值。 这是为了帮助以后看这些对象的人。 缺少这个头意味着提交日志信息是以 UTF-8 编码的。"

#. type: Plain text
#: en/i18n.txt:58
#, priority:280
msgid "'git log', 'git show', 'git blame' and friends look at the `encoding` header of a commit object, and try to re-code the log message into UTF-8 unless otherwise specified. You can specify the desired output encoding with `i18n.logOutputEncoding` in `.git/config` file, like this:"
msgstr "'git log' 、'git show' 、'git blame' 和它们的朋友们会查看提交对象的 `encoding` 头，并尝试将日志信息重新编码为 UTF-8，除非另有指定。 您可以在`.git/config` 文件中使用 `i18n.logOutputEncoding` 指定所需的输出编码，像这样："

#. type: delimited block -
#: en/i18n.txt:62
#, no-wrap, priority:280
msgid ""
"[i18n]\n"
"\tlogOutputEncoding = ISO-8859-1\n"
msgstr ""
"[i18n]\n"
"\tlogOutputEncoding = ISO-8859-1\n"

#. type: Plain text
#: en/i18n.txt:66
#, priority:280
msgid "If you do not have this configuration variable, the value of `i18n.commitEncoding` is used instead."
msgstr "如果你没有这个配置变量，则使用`i18n.commitEncoding`的值来代替。"

#. type: Plain text
#: en/i18n.txt:70
#, priority:280
msgid "Note that we deliberately chose not to re-code the commit log message when a commit is made to force UTF-8 at the commit object level, because re-coding to UTF-8 is not necessarily a reversible operation."
msgstr "请注意，我们特意选择在提交对象层面上，不对提交日志信息进行重新编码，因为重新编码为UTF-8不一定是一个可逆的操作。"

#. type: Plain text
#: en/includes/cmd-config-section-all.txt:3
#, placeholders:'linkgit:git-config[1]', priority:300
msgid "Everything below this line in this section is selectively included from the linkgit:git-config[1] documentation. The content is the same as what's found there:"
msgstr "本节中这一行以下的内容都是从 linkgit:git-config[1] 文档中摘录的。其内容与那里的内容相同："

#. type: Plain text
#: en/includes/cmd-config-section-rest.txt:3
#, placeholders:'linkgit:git-config[1]', priority:280
msgid "Everything above this line in this section isn't included from the linkgit:git-config[1] documentation. The content that follows is the same as what's found there:"
msgstr "本节中这一行以上的内容并不包括在 linkgit:git-config[1] 文档中。下面的内容与那里的内容相同："

#. type: Plain text
#: en/line-range-format.txt:2
#, priority:260
msgid "'<start>' and '<end>' can take one of these forms:"
msgstr "'<开始>' 和 '<结束>' 可以采取这些形式之一："

#. type: Plain text
#: en/line-range-format.txt:4
#, priority:260
msgid "number"
msgstr "数目"

#. type: Plain text
#: en/line-range-format.txt:7
#, priority:260
msgid "If '<start>' or '<end>' is a number, it specifies an absolute line number (lines count from 1)."
msgstr "如果'<开始>'或'<结束>'是一个数字，它指定了一个绝对行数（行数从1开始计算）。"

#. type: Plain text
#: en/line-range-format.txt:10
#, priority:260
msgid "`/regex/`"
msgstr "`/正则表达式/`"

# ERROR: `-L` not found in translation
#. type: Plain text
#: en/line-range-format.txt:17
#, placeholders:'`-L`', priority:260
msgid "This form will use the first line matching the given POSIX regex. If '<start>' is a regex, it will search from the end of the previous `-L` range, if any, otherwise from the start of file. If '<start>' is `^/regex/`, it will search from the start of file. If '<end>' is a regex, it will search starting at the line given by '<start>'."
msgstr "这种形式将使用与给定的 POSIX 正则表达式匹配的第一行。如果 '<start>' 是一个重词，它将从前一个 `-L` 范围的末尾开始搜索，如果有的话，则从文件的开始。 如果 '<start>' 是 `^/regex/`，它将从文件的开始搜索。 如果 '<end>' 是一个正则表达式，它将从 '<start>' 所给的行开始搜索。"

#. type: Plain text
#: en/line-range-format.txt:20
#, priority:260
msgid "+offset or -offset"
msgstr "+offset或-offset"

#. type: Plain text
#: en/line-range-format.txt:23
#, priority:260
msgid "This is only valid for '<end>' and will specify a number of lines before or after the line given by '<start>'."
msgstr "这只对'<end>'有效，将指定'<start>'所给的行前或行后的数量。"

# ERROR: `-L` not found in translation
#. type: Plain text
#: en/line-range-format.txt:32
#, placeholders:'`-L`':'linkgit:gitattributes[5]', priority:260
msgid "If `:<funcname>` is given in place of '<start>' and '<end>', it is a regular expression that denotes the range from the first funcname line that matches '<funcname>', up to the next funcname line. `:<funcname>` searches from the end of the previous `-L` range, if any, otherwise from the start of file. `^:<funcname>` searches from the start of file. The function names are determined in the same way as `git diff` works out patch hunk headers (see 'Defining a custom hunk-header' in linkgit:gitattributes[5])."
msgstr "如果 `:<funcname>` 代替了 '<start>' 和 '<end>' ，它是一个正则表达式，表示从第一个匹配 '<funcname>' 的 funcname 行开始，直到下一个 funcname 行的范围。`:<funcname>` 从上一个 `-L` 范围的末尾开始搜索，如果有的话，则从文件的开始搜索。`^:<funcname>`从文件的开始搜索。函数名的确定方式与 `git diff` 确定补丁组头的方式相同（见 linkgit:gitattributes[5] 中的'定义自定义组头'）。"

#. type: Labeled list
#: en/line-range-options.txt:1
#, no-wrap, priority:260
msgid "-L<start>,<end>:<file>"
msgstr "-L<起始>,<结束>:<文件>"

#. type: Labeled list
#: en/line-range-options.txt:2
#, no-wrap, priority:260
msgid "-L:<funcname>:<file>"
msgstr "-L :<函数名称>:<文件>"

# ERROR: --patch not found in translation
# ERROR: --patch not found in translation
#. type: Plain text
#: en/line-range-options.txt:14
#, placeholders:'`--patch`':'`--no-patch`':'`--raw`':'`--numstat`':'`--shortstat`':'`--dirstat`':'`--summary`':'`--name-only`':'`--name-status`':'`--check`', priority:260
msgid "Trace the evolution of the line range given by '<start>,<end>', or by the function name regex '<funcname>', within the '<file>'. You may not give any pathspec limiters. This is currently limited to a walk starting from a single revision, i.e., you may only give zero or one positive revision arguments, and '<start>' and '<end>' (or '<funcname>') must exist in the starting revision. You can specify this option more than once. Implies `--patch`. Patch output can be suppressed using `--no-patch`, but other diff formats (namely `--raw`, `--numstat`, `--shortstat`, `--dirstat`, `--summary`, `--name-only`, `--name-status`, `--check`) are not currently implemented."
msgstr "追踪由 '<起始>,<结束>' 给出的行的范围，或由函数名称重合词 '<函数名称>' 给出的行的演变，在 '<文件>'中 。你不能给出任何路径规范限制条件。 目前这只限于从一个修订版开始的行走，也就是说，你只能给出零或一个正的修订版参数，而且 '<起始>' 和 '<结束>'（或 '<函数名称>'）必须存在于起始修订版中。 你可以多次指定这个选项。包含 `--patch` 选项。 补丁输出可以用 `--no-patch` 来抑制，但其他差异格式（即 `--raw` 、 `--numstat` 、 `--shortstat` 、 `--dirstat` 、 `--summary` 、 `--name-only` 、 `--name-status` 、 `--check`）目前没有实现。"

#. type: Plain text
#: en/merge-options.txt:5
#, placeholders:'--no-commit', priority:240
msgid "Perform the merge and commit the result. This option can be used to override --no-commit."
msgstr "执行合并并提交结果。这个选项可以用来覆盖 --no-commit。"

#. type: Plain text
#: en/merge-options.txt:7 en/merge-options.txt:100 en/merge-options.txt:141
#, no-wrap, priority:240
msgid "\tOnly useful when merging.\n"
msgstr "\t只有在合并的时候才有用。\n"

#. type: Plain text
#: en/merge-options.txt:12
#, placeholders:'--no-commit', priority:240
msgid "With --no-commit perform the merge and stop just before creating a merge commit, to give the user a chance to inspect and further tweak the merge result before committing."
msgstr "用 --no-commit 来执行合并，并在创建合并提交前停止，以便让用户有机会在提交前检查和进一步调整合并结果。"

#. type: Plain text
#: en/merge-options.txt:17
#, placeholders:'--no-commit':'--no-ff':'--no-commit', priority:240
msgid "Note that fast-forward updates do not create a merge commit and therefore there is no way to stop those merges with --no-commit. Thus, if you want to ensure your branch is not changed or updated by the merge command, use --no-ff with --no-commit."
msgstr "请注意，快进更新并不产生合并提交，因此没有办法用 --no-commit 停止这些合并。 因此，如果你想确保你的分支不被合并命令改变或更新，请一起使用 --no-ff 和 --no-commit选项。"

#. type: Plain text
#: en/merge-options.txt:26
#, placeholders:'`--no-edit`', priority:240
msgid "Invoke an editor before committing successful mechanical merge to further edit the auto-generated merge message, so that the user can explain and justify the merge. The `--no-edit` option can be used to accept the auto-generated message (this is generally discouraged)."
msgstr "在提交成功的机械合并之前，调用一个编辑器来进一步编辑自动生成的合并信息，以便用户可以解释和证明合并的合理性。可以使用`--no-edit`选项来接受自动生成的信息（但是不鼓励亲这么做）。"

#. type: Plain text
#: en/merge-options.txt:30
#, placeholders:'`--edit`':'`-e`':'`-m`', priority:240
msgid "The `--edit` (or `-e`) option is still useful if you are giving a draft message with the `-m` option from the command line and want to edit it in the editor."
msgstr "如果你在命令行中用`-m`选项给出一个草稿信息，并想在编辑器中编辑它，`--edit`（或`-e`）选项仍然有用。"

#. type: Plain text
#: en/merge-options.txt:37
#, placeholders:'GIT_MERGE_AUTOEDIT', priority:240
msgid "Older scripts may depend on the historical behaviour of not allowing the user to edit the merge log message. They will see an editor opened when they run `git merge`. To make it easier to adjust such scripts to the updated behaviour, the environment variable `GIT_MERGE_AUTOEDIT` can be set to `no` at the beginning of them."
msgstr "旧的脚本可能依赖于不允许用户编辑合并日志信息的历史行为。他们会在运行`git merge`时看到一个编辑器被打开。为了使这些脚本更容易调整到最新的行为，可以在脚本的开头将环境变量`GIT_MERGE_AUTOEDIT`设置为`no`。"

#. type: Plain text
#: en/merge-options.txt:44
#, placeholders:'linkgit:git-commit[1]':'MERGE_MSG', priority:240
msgid "This option determines how the merge message will be cleaned up before committing. See linkgit:git-commit[1] for more details. In addition, if the '<mode>' is given a value of `scissors`, scissors will be appended to `MERGE_MSG` before being passed on to the commit machinery in the case of a merge conflict."
msgstr "这个选项决定了在提交前如何清理合并信息。更多细节见linkgit:git-commit[1]。此外，如果`<模式>`的值为 `scissors`，在发生合并冲突时，scissors将被附加到 \"MERGE_MSG \"上，然后传递给提交机制。"

#. type: Labeled list
#: en/merge-options.txt:48 en/merge-options.txt:56
#, ignore-same, no-wrap, priority:240
msgid "--ff-only"
msgstr "--ff-only"

#. type: Plain text
#: en/merge-options.txt:54
#, placeholders:'`--ff`':'`--no-ff`', priority:240
msgid "Specifies how a merge is handled when the merged-in history is already a descendant of the current history. `--ff` is the default unless merging an annotated (and possibly signed) tag that is not stored in its natural place in the `refs/tags/` hierarchy, in which case `--no-ff` is assumed."
msgstr "指定当被合并的历史已经是当前历史的后代时，如何处理合并的问题。 默认为`--ff`，除非合并的是一个有注释的（可能是有签名的）标签，在这种情况下，`--no-ff`假设这个标签并没有存储在`refs/tags/`层次结构中的自然位置。"

#. type: Plain text
#: en/merge-options.txt:60
#, placeholders:'--rebase=', priority:240
msgid "Only update to the new history if there is no divergent local history. This is the default when no method for reconciling divergent histories is provided (via the --rebase=* flags)."
msgstr "只有在没有分歧的本地历史时才更新到新的历史。 当没有提供调和分歧历史的方法时（通过--rebase=*标志），这是默认的。"

#. type: Plain text
#: en/merge-options.txt:69
#, placeholders:'`--ff`':'`--no-ff`', priority:240
msgid "When merging rather than rebasing, specifies how a merge is handled when the merged-in history is already a descendant of the current history. If merging is requested, `--ff` is the default unless merging an annotated (and possibly signed) tag that is not stored in its natural place in the `refs/tags/` hierarchy, in which case `--no-ff` is assumed."
msgstr "当合并而不是变基时，指定当被合并的历史已经是当前历史的后代时如何处理合并。 如果要求合并，`--ff`是默认的，除非合并的是一个有注释的（可能是有签名的）标签，而这个标签没有存储在`refs/tags/`层次结构中的自然位置，在这种情况下，假定`--no-ff`。"

#. type: Plain text
#: en/merge-options.txt:75
#, placeholders:'`--ff`', priority:240
msgid "With `--ff`, when possible resolve the merge as a fast-forward (only update the branch pointer to match the merged branch; do not create a merge commit). When not possible (when the merged-in history is not a descendant of the current history), create a merge commit."
msgstr "如果使用 `--ff`，可能的话，以快进方式解决合并问题（只更新分支指针以匹配合并后的分支；不创建合并提交）。 当不可能时（当合并的历史不是当前历史的后代），创建一个合并提交。"

#. type: Plain text
#: en/merge-options.txt:78
#, placeholders:'`--no-ff`', priority:240
msgid "With `--no-ff`, create a merge commit in all cases, even when the merge could instead be resolved as a fast-forward."
msgstr "使用`--no-ff`，在所有情况下都创建一个合并提交，即使该合并可以作为一个快进解决。"

#. type: Plain text
#: en/merge-options.txt:82
#, placeholders:'`--ff-only`', priority:240
msgid "With `--ff-only`, resolve the merge as a fast-forward when possible. When not possible, refuse to merge and exit with a non-zero status."
msgstr "使用`--ff-only`，在可能的情况下，以快进的方式解决合并的问题。 当不可能时，拒绝合并并以非零状态退出。"

#. type: Plain text
#: en/merge-options.txt:92
#, placeholders:'`--no-gpg-sign`':'commit.gpgSign':'`--gpg-sign`', priority:240
msgid "GPG-sign the resulting merge commit. The `keyid` argument is optional and defaults to the committer identity; if specified, it must be stuck to the option without a space. `--no-gpg-sign` is useful to countermand both `commit.gpgSign` configuration variable, and earlier `--gpg-sign`."
msgstr "对合并后的提交进行 GPG 签名。`keyid` 参数是可选的，默认为提交者的身份；如果指定，它必须与选项连在一起，不能有空格。`--no-gpg-sign` 对于反命令 `commit.gpgSign` 配置变量和早期的 `--gpg-sign` 都很有用。"

#. type: Plain text
#: en/merge-options.txt:98
#, placeholders:'linkgit:git-fmt-merge-msg[1]', priority:240
msgid "In addition to branch names, populate the log message with one-line descriptions from at most <n> actual commits that are being merged. See also linkgit:git-fmt-merge-msg[1]."
msgstr "除了分支名称外，在日志信息中最多只用<n>个正在合并的实际提交的单行描述来填充。参见 linkgit:git-fmt-merge-msg[1]。"

#. type: Plain text
#: en/merge-options.txt:104
#, placeholders:'--no-log', priority:240
msgid "With --no-log do not list one-line descriptions from the actual commits being merged."
msgstr "如果使用 --no-log，则不列出被合并的实际提交内容的单行描述。"

#. type: Plain text
#: en/merge-options.txt:112
#, placeholders:'merge.stat', priority:240
msgid "Show a diffstat at the end of the merge. The diffstat is also controlled by the configuration option merge.stat."
msgstr "在合并结束时显示一个差异状态。差异状态也由配置选项merge.stat控制。"

#. type: Plain text
#: en/merge-options.txt:115
#, placeholders:'--no-stat', priority:240
msgid "With -n or --no-stat do not show a diffstat at the end of the merge."
msgstr "使用-n或--no-stat，在合并结束时不显示差异状态。"

#. type: Labeled list
#: en/merge-options.txt:116
#, ignore-same, no-wrap, priority:240
msgid "--squash"
msgstr "--squash"

#. type: Labeled list
#: en/merge-options.txt:117
#, ignore-same, no-wrap, priority:240
msgid "--no-squash"
msgstr "--no-squash"

#. type: Plain text
#: en/merge-options.txt:125
#, placeholders:'HEAD':'$GIT_DIR':'MERGE_HEAD', priority:240
msgid "Produce the working tree and index state as if a real merge happened (except for the merge information), but do not actually make a commit, move the `HEAD`, or record `$GIT_DIR/MERGE_HEAD` (to cause the next `git commit` command to create a merge commit). This allows you to create a single commit on top of the current branch whose effect is the same as merging another branch (or more in case of an octopus)."
msgstr "产生工作区和索引状态，就像发生了真正的合并一样（除了合并信息），但不实际提交，不移动`HEAD`，也不记录`$GIT_DIR/MERGE_HEAD`（以导致下一个`git commit`命令创建一个合并提交）。 这允许你在当前分支的基础上创建一个单一的提交，其效果与合并另一个分支相同（如果是多路分支，则更多）。"

#. type: Plain text
#: en/merge-options.txt:128
#, placeholders:'--no-squash':'--squash', priority:240
msgid "With --no-squash perform the merge and commit the result. This option can be used to override --squash."
msgstr "使用 --no-squash 进行合并并提交结果。这个选项可以用来覆盖 --squash 选项。"

#. type: Plain text
#: en/merge-options.txt:130
#, placeholders:'--squash':'--commit', priority:240
msgid "With --squash, --commit is not allowed, and will fail."
msgstr "使用 --squash，--commit 是不允许的，而且会失败。"

#. type: Plain text
#: en/merge-options.txt:133 en/merge-options.txt:166 en/merge-options.txt:210
#, priority:240
msgid "Only useful when merging."
msgstr "只有在合并的时候才有用。"

#. type: Plain text
#: en/merge-options.txt:139
#, placeholders:'`--no-verify`':'linkgit:githooks[5]', priority:240
msgid "By default, the pre-merge and commit-msg hooks are run. When `--no-verify` is given, these are bypassed. See also linkgit:githooks[5]."
msgstr "默认情况下，会运行 pre-merge 和 commit-msg 事件hook。 当给定 `--no-verify`时，这些将不会执行。 参见 linkgit:githooks[5]。"

#. type: Plain text
#: en/merge-options.txt:150
#, placeholders:'`-s`', priority:240
msgid "Use the given merge strategy; can be supplied more than once to specify them in the order they should be tried. If there is no `-s` option, a built-in list of strategies is used instead (`ort` when merging a single head, `octopus` otherwise)."
msgstr "使用给定的合并策略；可以多次提供，以指定它们应该被尝试的顺序。 如果没有`-s`选项，则使用一个内置的策略列表（当合并单个头时使用`ort`，否则使用`octopus`）。"

#. type: Labeled list
#: en/merge-options.txt:151
#, no-wrap, priority:240
msgid "-X <option>"
msgstr "-X <选项>"

#. type: Plain text
#: en/merge-options.txt:155
#, priority:240
msgid "Pass merge strategy specific option through to the merge strategy."
msgstr "将合并策略的特定选项传递给合并策略。"

#. type: Labeled list
#: en/merge-options.txt:156
#, ignore-same, no-wrap, priority:240
msgid "--verify-signatures"
msgstr "--verify-signatures"

#. type: Labeled list
#: en/merge-options.txt:157
#, ignore-same, no-wrap, priority:240
msgid "--no-verify-signatures"
msgstr "--no-verify-signatures"

#. type: Plain text
#: en/merge-options.txt:163
#, priority:240
msgid "Verify that the tip commit of the side branch being merged is signed with a valid key, i.e. a key that has a valid uid: in the default trust model, this means the signing key has been signed by a trusted key. If the tip commit of the side branch is not signed with a valid key, the merge is aborted."
msgstr "验证被合并的侧边分支的提示提交是否用有效的密钥签署，即一个具有有效uid的密钥：在默认的信任模型中，这意味着签署密钥是由一个受信任的密钥签署。 如果侧边分支的提示提交没有用有效的密钥签名，则合并被终止。"

#. type: Labeled list
#: en/merge-options.txt:169
#, ignore-same, no-wrap, priority:240
msgid "--no-summary"
msgstr "--no-summary"

#. type: Plain text
#: en/merge-options.txt:172
#, placeholders:'--stat':'--no-stat', priority:240
msgid "Synonyms to --stat and --no-stat; these are deprecated and will be removed in the future."
msgstr "与 --stat 和 --no-stat 同义；这些都弃用了，将来会被删除。"

#. type: Plain text
#: en/merge-options.txt:177
#, placeholders:'--no-progress', priority:240
msgid "Operate quietly. Implies --no-progress."
msgstr "安静地操作。暗指 --no-progress。"

#. type: Plain text
#: en/merge-options.txt:188
#, priority:240
msgid "Turn progress on/off explicitly. If neither is specified, progress is shown if standard error is connected to a terminal. Note that not all merge strategies may support progress reporting."
msgstr "明确地打开/关闭进度。如果两者都没有指定，如果标准错误连接到终端，就会显示进度。 注意，并非所有的合并策略都支持进度报告。"

#. type: Plain text
#: en/merge-options.txt:199
#, placeholders:'MERGE_AUTOSTASH', priority:240
msgid "Automatically create a temporary stash entry before the operation begins, record it in the ref `MERGE_AUTOSTASH` and apply it after the operation ends. This means that you can run the operation on a dirty worktree. However, use with care: the final stash application after a successful merge might result in non-trivial conflicts."
msgstr "在操作开始前自动创建临时储藏条目，将其记录在特殊引用 `MERGE_AUTOSTASH` 中，并在操作结束后应用。 这意味着可以在脏工作区上运行操作。 但是，请谨慎使用：成功合并后的最终暂存应用可能会导致非实质性冲突。"

#. type: Plain text
#: en/merge-options.txt:207
#, priority:240
msgid "By default, `git merge` command refuses to merge histories that do not share a common ancestor. This option can be used to override this safety when merging histories of two projects that started their lives independently. As that is a very rare occasion, no configuration variable to enable this by default exists and will not be added."
msgstr "默认情况下，`git merge`命令拒绝合并那些没有共同祖先的历史。 当合并两个独立开始的项目的历史时，这个选项可以用来覆盖这个安全性。由于这是一个非常罕见的情况，没有配置变量来默认启用，也不会被添加。"

#. type: Title -
#: en/merge-strategies.txt:2
#, no-wrap, priority:240
msgid "MERGE STRATEGIES"
msgstr "合并战略"

# ERROR: `-s` not found in translation
#. type: Plain text
#: en/merge-strategies.txt:8
#, placeholders:'`-s`', priority:240
msgid "The merge mechanism (`git merge` and `git pull` commands) allows the backend 'merge strategies' to be chosen with `-s` option. Some strategies can also take their own options, which can be passed by giving `-X<option>` arguments to `git merge` and/or `git pull`."
msgstr "合并机制（ `git merge` 和 `git pull` 命令）允许用 `-s` 选项来选择后端'合并策略'。 一些策略也可以采取自己的选项，可以通过给 `git merge` 和/或 `git pull` 的 `-X<选项>` 参数来传递。"

#. type: Labeled list
#: en/merge-strategies.txt:9
#, no-wrap, priority:240
msgid "ort"
msgstr "ort 策略"

#. type: Plain text
#: en/merge-strategies.txt:24
#, priority:240
msgid "This is the default merge strategy when pulling or merging one branch. This strategy can only resolve two heads using a 3-way merge algorithm. When there is more than one common ancestor that can be used for 3-way merge, it creates a merged tree of the common ancestors and uses that as the reference tree for the 3-way merge. This has been reported to result in fewer merge conflicts without causing mismerges by tests done on actual merge commits taken from Linux 2.6 kernel development history. Additionally this strategy can detect and handle merges involving renames. It does not make use of detected copies. The name for this algorithm is an acronym (\"Ostensibly Recursive's Twin\") and came from the fact that it was written as a replacement for the previous default algorithm, `recursive`."
msgstr "这是拉取或合并一个分支时的默认合并策略。 这个策略只能使用三方合并算法解决两个头。 当有一个以上的共同祖先可用于三方合并时，它会创建一个共同祖先的合并树，并将其作为三方合并的参考树。 据报道，通过对Linux 2.6内核开发历史中的实际合并提交的测试，这导致了较少的合并冲突，而不会引起错误的合并。 此外，这个策略可以检测并处理涉及重命名的合并。 它并不使用检测到的副本。 这个算法的名字是一个缩写（\"Ostensibly Recursive's Twin\"），来自于它是作为以前的默认算法`recursive`的替代而编写的。"

#. type: Plain text
#: en/merge-strategies.txt:26
#, priority:240
msgid "The 'ort' strategy can take the following options:"
msgstr "'ort' 策略可以采取以下选项："

#. type: Labeled list
#: en/merge-strategies.txt:27 en/merge-strategies.txt:132
#, ignore-same, no-wrap, priority:240
msgid "ours"
msgstr "ours"

#. type: Plain text
#: en/merge-strategies.txt:32
#, priority:240
msgid "This option forces conflicting hunks to be auto-resolved cleanly by favoring 'our' version. Changes from the other tree that do not conflict with our side are reflected in the merge result. For a binary file, the entire contents are taken from our side."
msgstr "这个选项通过倾向于 \"我们\" 的版本，迫使冲突的猎物被自动解决。 另一棵目录树上与我们这边不冲突的变化会反映在合并结果中。 对于一个二进制文件，整个内容都来自我们这边。"

#. type: Plain text
#: en/merge-strategies.txt:36
#, priority:240
msgid "This should not be confused with the 'ours' merge strategy, which does not even look at what the other tree contains at all. It discards everything the other tree did, declaring 'our' history contains all that happened in it."
msgstr "这不应该与 \"我们的\" 合并策略相混淆，后者甚至根本不看另一棵目录树包含了什么。 它抛弃了其他树所做的一切，宣布 \"我们的\" 历史包含了其中所发生的一切。"

#. type: Labeled list
#: en/merge-strategies.txt:37
#, ignore-same, no-wrap, priority:240
msgid "theirs"
msgstr "theirs"

#. type: Plain text
#: en/merge-strategies.txt:40
#, priority:240
msgid "This is the opposite of 'ours'; note that, unlike 'ours', there is no 'theirs' merge strategy to confuse this merge option with."
msgstr "这与 \"我们的\" 相反；注意，与 \"我们的\" 不同，没有 \"他们的\" 合并策略来混淆这个合并选项。"

#. type: Labeled list
#: en/merge-strategies.txt:44
#, ignore-same, no-wrap, priority:240
msgid "ignore-cr-at-eol"
msgstr "ignore-cr-at-eol"

#. type: Plain text
#: en/merge-strategies.txt:50
#, placeholders:'linkgit:git-diff[1]':'`-b`':'`-w`':'`--ignore-space-at-eol`':'`--ignore-cr-at-eol`', priority:240
msgid "Treats lines with the indicated type of whitespace change as unchanged for the sake of a three-way merge. Whitespace changes mixed with other changes to a line are not ignored. See also linkgit:git-diff[1] `-b`, `-w`, `--ignore-space-at-eol`, and `--ignore-cr-at-eol`."
msgstr "为了进行三方合并，将具有指定类型的空白变化的行视为没有变化。 但混合了其他改动的行的空白改动不会被忽略。 参见linkgit:git-diff[1] `-b`, `-w`, `--ignore-space-at-eol`, 和 `--ignore-cr-at-eol`。"

#. type: Plain text
#: en/merge-strategies.txt:53
#, priority:240
msgid "If 'their' version only introduces whitespace changes to a line, 'our' version is used;"
msgstr "如果 \"他们的\" 版本只在一行中引入了空白的变化，则使用 \"我们的\" 版本；"

#. type: Plain text
#: en/merge-strategies.txt:55
#, priority:240
msgid "If 'our' version introduces whitespace changes but 'their' version includes a substantial change, 'their' version is used;"
msgstr "如果 \"我们的\" 版本引入了空白的变化，但 \"他们的\" 版本包括一个实质性的变化，则使用 \"他们的\" 版本;"

#. type: Plain text
#: en/merge-strategies.txt:56
#, priority:240
msgid "Otherwise, the merge proceeds in the usual way."
msgstr "否则，合并将以常规方式进行。"

#. type: Labeled list
#: en/merge-strategies.txt:57
#, ignore-same, no-wrap, priority:240
msgid "renormalize"
msgstr "renormalize"

#. type: Plain text
#: en/merge-strategies.txt:64
#, placeholders:'linkgit:gitattributes[5]', priority:240
msgid "This runs a virtual check-out and check-in of all three stages of a file when resolving a three-way merge. This option is meant to be used when merging branches with different clean filters or end-of-line normalization rules. See \"Merging branches with differing checkin/checkout attributes\" in linkgit:gitattributes[5] for details."
msgstr "在解决三方合并时，这将对一个文件的所有三个阶段运行虚拟检出和检入。 这个选项是为了在合并具有不同清洁过滤器或行末规范化规则的分支时使用。 详情见 linkgit:gitattributes[5] 中的 \"合并具有不同检入/检出属性的分支\"。"

#. type: Labeled list
#: en/merge-strategies.txt:65
#, ignore-same, no-wrap, priority:240
msgid "no-renormalize"
msgstr "no-renormalize"

#. type: Plain text
#: en/merge-strategies.txt:68
#, placeholders:'merge.renormalize', priority:240
msgid "Disables the `renormalize` option. This overrides the `merge.renormalize` configuration variable."
msgstr "禁用 `renormalize` 选项。 这覆盖了 `merge.renormalize` 配置变量。"

#. type: Labeled list
#: en/merge-strategies.txt:69
#, no-wrap, priority:240
msgid "find-renames[=<n>]"
msgstr "find-renames[=<n>]"

#. type: Plain text
#: en/merge-strategies.txt:74
#, placeholders:'merge.renames':'linkgit:git-diff[1]':'`--find-renames`', priority:240
msgid "Turn on rename detection, optionally setting the similarity threshold. This is the default. This overrides the 'merge.renames' configuration variable. See also linkgit:git-diff[1] `--find-renames`."
msgstr "开启重名检测，可选择设置相似度阈值。 这是默认的。这覆盖了 'merge.renames' 配置变量。 参见linkgit:git-diff[1] `--find-renames`。"

#. type: Labeled list
#: en/merge-strategies.txt:75
#, no-wrap, priority:240
msgid "rename-threshold=<n>"
msgstr "rename-threshold=<n>"

#. type: Plain text
#: en/merge-strategies.txt:77
#, priority:240
msgid "Deprecated synonym for `find-renames=<n>`."
msgstr "废弃的，`find-renames=<n>` 的同义词。"

#. type: Labeled list
#: en/merge-strategies.txt:78
#, no-wrap, priority:240
msgid "subtree[=<path>]"
msgstr "subtree[=<路径>]"

#. type: Plain text
#: en/merge-strategies.txt:84
#, priority:240
msgid "This option is a more advanced form of 'subtree' strategy, where the strategy makes a guess on how two trees must be shifted to match with each other when merging. Instead, the specified path is prefixed (or stripped from the beginning) to make the shape of two trees to match."
msgstr "这个选项是 '子树' 策略的更高级形式，该策略对两棵树在合并时必须如何移位以相互匹配进行猜测。 相反，指定的路径是前缀（或从开始剥离），以使两棵树的形状相匹配。"

#. type: Labeled list
#: en/merge-strategies.txt:85
#, ignore-same, no-wrap, priority:240
msgid "recursive"
msgstr "recursive"

#. type: Plain text
#: en/merge-strategies.txt:98
#, priority:240
msgid "This can only resolve two heads using a 3-way merge algorithm. When there is more than one common ancestor that can be used for 3-way merge, it creates a merged tree of the common ancestors and uses that as the reference tree for the 3-way merge. This has been reported to result in fewer merge conflicts without causing mismerges by tests done on actual merge commits taken from Linux 2.6 kernel development history. Additionally this can detect and handle merges involving renames. It does not make use of detected copies. This was the default strategy for resolving two heads from Git v0.99.9k until v2.33.0."
msgstr "这只能用三方合并算法解决两个头。 当有一个以上的共同祖先可用于三方合并时，它会创建一个共同祖先的合并树，并使用它作为三方合并的参考树。 据报道，通过对Linux 2.6内核开发历史中的实际合并提交的测试，这导致了较少的合并冲突，而不会引起错误的合并。 此外，它可以检测并处理涉及重命名的合并。 它并不使用检测到的副本。 从Git v0.99.9k到v2.33.0，这是解决双头的默认策略。"

#. type: Plain text
#: en/merge-strategies.txt:102
#, priority:240
msgid "The 'recursive' strategy takes the same options as 'ort'. However, there are three additional options that 'ort' ignores (not documented above) that are potentially useful with the 'recursive' strategy:"
msgstr "'recursive' 策略采用与 'ort' 相同的选项。 然而，有三个 'ort' 忽略的额外选项（上面没有记录），对 'recursive' 策略有潜在的作用："

#. type: Labeled list
#: en/merge-strategies.txt:103
#, ignore-same, no-wrap, priority:240
msgid "patience"
msgstr "patience"

#. type: Plain text
#: en/merge-strategies.txt:105
#, priority:240
msgid "Deprecated synonym for `diff-algorithm=patience`."
msgstr "废弃的，`diff-algorithm=patience` 的同义词。"

#. type: Labeled list
#: en/merge-strategies.txt:106
#, ignore-same, no-wrap, priority:240
msgid "diff-algorithm=[patience|minimal|histogram|myers]"
msgstr "diff-algorithm=[patience|minimal|histogram|myers]"

#. type: Plain text
#: en/merge-strategies.txt:113
#, placeholders:'linkgit:git-diff[1]':'`--diff-algorithm`':'diff.algorithm', priority:240
msgid "Use a different diff algorithm while merging, which can help avoid mismerges that occur due to unimportant matching lines (such as braces from distinct functions). See also linkgit:git-diff[1] `--diff-algorithm`. Note that `ort` specifically uses `diff-algorithm=histogram`, while `recursive` defaults to the `diff.algorithm` config setting."
msgstr "在合并时使用不同的差异算法，这可以帮助避免由于不重要的匹配行（比如不同函数的大括号）而发生的错误合并。 参见linkgit:git-diff[1] `--diff-algorithm`。 注意，`ort` 特定 `diff-algorithm=histogram`，而`recursive`默认为`diff.algorithm`配置设置。"

#. type: Labeled list
#: en/merge-strategies.txt:114
#, ignore-same, no-wrap, priority:240
msgid "no-renames"
msgstr "no-renames"

#. type: Plain text
#: en/merge-strategies.txt:118
#, placeholders:'merge.renames':'linkgit:git-diff[1]':'`--no-renames`', priority:240
msgid "Turn off rename detection. This overrides the `merge.renames` configuration variable. See also linkgit:git-diff[1] `--no-renames`."
msgstr "关闭重名检测。这覆盖了 `merge.renames` 的配置变量。 参见linkgit:git-diff[1] `--no-renames`。"

#. type: Labeled list
#: en/merge-strategies.txt:119
#, ignore-same, no-wrap, priority:240
msgid "resolve"
msgstr "resolve"

#. type: Plain text
#: en/merge-strategies.txt:124
#, priority:240
msgid "This can only resolve two heads (i.e. the current branch and another branch you pulled from) using a 3-way merge algorithm. It tries to carefully detect criss-cross merge ambiguities. It does not handle renames."
msgstr "这只能用三方合并算法解决两个头（即当前分支和你拉来的另一个分支）。 它试图仔细检测纵横交错的合并歧义。 它不处理重名。"

#. type: Labeled list
#: en/merge-strategies.txt:125
#, ignore-same, no-wrap, priority:240
msgid "octopus"
msgstr "octopus"

#. type: Plain text
#: en/merge-strategies.txt:131
#, priority:240
msgid "This resolves cases with more than two heads, but refuses to do a complex merge that needs manual resolution. It is primarily meant to be used for bundling topic branch heads together. This is the default merge strategy when pulling or merging more than one branch."
msgstr "这可以解决有两个以上头的情况，但拒绝做复杂的合并，需要手动解决。 它主要是用于将主题分支头捆绑在一起。 当拉动或合并一个以上的分支时，这是默认的合并策略。"

#. type: Plain text
#: en/merge-strategies.txt:139
#, priority:240
msgid "This resolves any number of heads, but the resulting tree of the merge is always that of the current branch head, effectively ignoring all changes from all other branches. It is meant to be used to supersede old development history of side branches. Note that this is different from the -Xours option to the 'recursive' merge strategy."
msgstr "这可以解决任何数量的头，但合并的结果总是当前分支头的树，有效地忽略了所有其他分支的变化。 它是用来取代侧边分支的旧开发历史的。 注意，这与 'recursive' 合并策略的-Xours选项不同。"

#. type: Labeled list
#: en/merge-strategies.txt:140
#, ignore-same, no-wrap, priority:240
msgid "subtree"
msgstr "subtree"

#. type: Plain text
#: en/merge-strategies.txt:146
#, priority:240
msgid "This is a modified `ort` strategy. When merging trees A and B, if B corresponds to a subtree of A, B is first adjusted to match the tree structure of A, instead of reading the trees at the same level. This adjustment is also done to the common ancestor tree."
msgstr "这是一个修正的 `ort` 策略。当合并树A和B时，如果B对应于A的子树，B首先被调整为与A的树结构相匹配，而不是在同一级别读取树。这种调整也是针对共同祖先树进行的。"

#. type: Plain text
#: en/merge-strategies.txt:153
#, priority:240
msgid "With the strategies that use 3-way merge (including the default, 'ort'), if a change is made on both branches, but later reverted on one of the branches, that change will be present in the merged result; some people find this behavior confusing. It occurs because only the heads and the merge base are considered when performing a merge, not the individual commits. The merge algorithm therefore considers the reverted change as no change at all, and substitutes the changed version instead."
msgstr "对于使用三方合并的策略（包括默认的 'ort' 策略），如果在两个分支上都做了修改，但后来在其中一个分支上被撤销，那么这个修改就会出现在合并后的结果中；有些人觉得这种行为令人困惑。 出现这种情况是因为在执行合并时只考虑头部和合并基数，而不是单个提交。 因此，合并算法认为被恢复的修改根本就没有变化，而是用被修改的版本来代替。"

#. type: Labeled list
#: en/mergetools-merge.txt:1
#, ignore-same, no-wrap, priority:100
msgid "`araxis`"
msgstr "`araxis`"

#. type: Plain text
#: en/mergetools-merge.txt:2
#, priority:100
msgid "Use Araxis Merge (requires a graphical session)"
msgstr "使用 Araxis 合并（需要图形会话）"

#. type: Labeled list
#: en/mergetools-merge.txt:2
#, ignore-same, no-wrap, priority:100
msgid "`bc`"
msgstr "`bc`"

#. type: Plain text
#: en/mergetools-merge.txt:3 en/mergetools-merge.txt:4 en/mergetools-merge.txt:5
#, priority:100
msgid "Use Beyond Compare (requires a graphical session)"
msgstr "使用 Beyond Compare（需要图形会话）"

#. type: Labeled list
#: en/mergetools-merge.txt:3
#, no-wrap, priority:100
msgid "`bc3`"
msgstr "`bc3`"

#. type: Labeled list
#: en/mergetools-merge.txt:4
#, no-wrap, priority:100
msgid "`bc4`"
msgstr "`bc4`"

#. type: Labeled list
#: en/mergetools-merge.txt:5
#, ignore-same, no-wrap, priority:100
msgid "`codecompare`"
msgstr "`codecompare`"

#. type: Plain text
#: en/mergetools-merge.txt:6
#, priority:100
msgid "Use Code Compare (requires a graphical session)"
msgstr "使用代码比较（需要图形会话）"

#. type: Labeled list
#: en/mergetools-merge.txt:6
#, ignore-same, no-wrap, priority:100
msgid "`deltawalker`"
msgstr "`deltawalker`"

#. type: Plain text
#: en/mergetools-merge.txt:7
#, priority:100
msgid "Use DeltaWalker (requires a graphical session)"
msgstr "使用 DeltaWalker（需要图形会话）"

#. type: Labeled list
#: en/mergetools-merge.txt:7
#, ignore-same, no-wrap, priority:100
msgid "`diffmerge`"
msgstr "`diffmerge`"

#. type: Plain text
#: en/mergetools-merge.txt:8
#, priority:100
msgid "Use DiffMerge (requires a graphical session)"
msgstr "使用 DiffMerge（需要图形会话）"

#. type: Labeled list
#: en/mergetools-merge.txt:8
#, ignore-same, no-wrap, priority:100
msgid "`diffuse`"
msgstr "`diffuse`"

#. type: Plain text
#: en/mergetools-merge.txt:9
#, priority:100
msgid "Use Diffuse (requires a graphical session)"
msgstr "使用 Diffuse（需要图形会话）"

#. type: Labeled list
#: en/mergetools-merge.txt:9
#, ignore-same, no-wrap, priority:100
msgid "`ecmerge`"
msgstr "`ecmerge`"

#. type: Plain text
#: en/mergetools-merge.txt:10
#, priority:100
msgid "Use ECMerge (requires a graphical session)"
msgstr "使用 ECMerge（需要图形会话）"

#. type: Labeled list
#: en/mergetools-merge.txt:10
#, ignore-same, no-wrap, priority:100
msgid "`emerge`"
msgstr "`emerge`"

#. type: Plain text
#: en/mergetools-merge.txt:11
#, priority:100
msgid "Use Emacs' Emerge"
msgstr "使用 Emacs 的 Emerge"

#. type: Labeled list
#: en/mergetools-merge.txt:11
#, ignore-same, no-wrap, priority:100
msgid "`examdiff`"
msgstr "`examdiff`"

#. type: Plain text
#: en/mergetools-merge.txt:12
#, priority:100
msgid "Use ExamDiff Pro (requires a graphical session)"
msgstr "使用 ExamDiff Pro（需要图形会话）"

#. type: Labeled list
#: en/mergetools-merge.txt:12
#, ignore-same, no-wrap, priority:100
msgid "`guiffy`"
msgstr "`guiffy`"

#. type: Plain text
#: en/mergetools-merge.txt:13
#, priority:100
msgid "Use Guiffy's Diff Tool (requires a graphical session)"
msgstr "使用 Guiffy 的 Diff 工具（需要图形会话）"

#. type: Labeled list
#: en/mergetools-merge.txt:13
#, ignore-same, no-wrap, priority:100
msgid "`gvimdiff`"
msgstr "`gvimdiff`"

#. type: Plain text
#: en/mergetools-merge.txt:14
#, priority:100
msgid "Use gVim (requires a graphical session) with a custom layout (see `git help mergetool`'s `BACKEND SPECIFIC HINTS` section)"
msgstr "使用 gVim（需要图形会话）和自定义布局（参见 `git help mergetool` 的 `BACKEND SPECIFIC HINTS` 部分）"

#. type: Labeled list
#: en/mergetools-merge.txt:14
#, no-wrap, priority:100
msgid "`gvimdiff1`"
msgstr "`gvimdiff1`"

#. type: Plain text
#: en/mergetools-merge.txt:15
#, priority:100
msgid "Use gVim (requires a graphical session) with a 2 panes layout (LOCAL and REMOTE)"
msgstr "使用 gVim（需要图形会话），采用双窗格布局（本地和远程）"

#. type: Labeled list
#: en/mergetools-merge.txt:15
#, no-wrap, priority:100
msgid "`gvimdiff2`"
msgstr "`gvimdiff2`"

#. type: Plain text
#: en/mergetools-merge.txt:16
#, priority:100
msgid "Use gVim (requires a graphical session) with a 3 panes layout (LOCAL, MERGED and REMOTE)"
msgstr "使用 gVim（需要图形会话），采用 3 个面板布局（本地、合并和远程）"

#. type: Labeled list
#: en/mergetools-merge.txt:16
#, no-wrap, priority:100
msgid "`gvimdiff3`"
msgstr "`gvimdiff3`"

#. type: Plain text
#: en/mergetools-merge.txt:17
#, priority:100
msgid "Use gVim (requires a graphical session) where only the MERGED file is shown"
msgstr "使用 gVim（需要图形会话），只显示 MERGED 文件"

#. type: Labeled list
#: en/mergetools-merge.txt:17
#, no-wrap, priority:100
msgid "`kdiff3`"
msgstr "`kdiff3`"

#. type: Plain text
#: en/mergetools-merge.txt:18
#, priority:100
msgid "Use KDiff3 (requires a graphical session)"
msgstr "使用 KDiff3（需要图形会话）"

#. type: Labeled list
#: en/mergetools-merge.txt:18
#, ignore-same, no-wrap, priority:100
msgid "`meld`"
msgstr "`meld`"

#. type: Plain text
#: en/mergetools-merge.txt:19
#, priority:100
msgid "Use Meld (requires a graphical session) with optional `auto merge` (see `git help mergetool`'s `CONFIGURATION` section)"
msgstr "使用带可选 `auto merge` 功能的 Meld（需要图形会话）（请参阅 `git help mergetool` 的 `配置` 部分）"

#. type: Labeled list
#: en/mergetools-merge.txt:19
#, ignore-same, no-wrap, priority:100
msgid "`nvimdiff`"
msgstr "`nvimdiff`"

#. type: Plain text
#: en/mergetools-merge.txt:20
#, priority:100
msgid "Use Neovim with a custom layout (see `git help mergetool`'s `BACKEND SPECIFIC HINTS` section)"
msgstr "使用带有自定义布局的 Neovim（请参阅 `git help mergetool` 的 `BACKEND SPECIFIC HINTS` 部分）"

#. type: Labeled list
#: en/mergetools-merge.txt:20
#, no-wrap, priority:100
msgid "`nvimdiff1`"
msgstr "`nvimdiff1`"

#. type: Plain text
#: en/mergetools-merge.txt:21
#, priority:100
msgid "Use Neovim with a 2 panes layout (LOCAL and REMOTE)"
msgstr "使用 Neovim 的双窗格布局（本地和远程）"

#. type: Labeled list
#: en/mergetools-merge.txt:21
#, no-wrap, priority:100
msgid "`nvimdiff2`"
msgstr "`nvimdiff2`"

#. type: Plain text
#: en/mergetools-merge.txt:22
#, priority:100
msgid "Use Neovim with a 3 panes layout (LOCAL, MERGED and REMOTE)"
msgstr "使用 Neovim 的 3 个面板布局（本地、合并和远程）"

#. type: Labeled list
#: en/mergetools-merge.txt:22
#, no-wrap, priority:100
msgid "`nvimdiff3`"
msgstr "`nvimdiff3`"

#. type: Plain text
#: en/mergetools-merge.txt:23
#, priority:100
msgid "Use Neovim where only the MERGED file is shown"
msgstr "使用 Neovim，只显示合并文件"

#. type: Labeled list
#: en/mergetools-merge.txt:23
#, ignore-same, no-wrap, priority:100
msgid "`opendiff`"
msgstr "`opendiff`"

#. type: Plain text
#: en/mergetools-merge.txt:24
#, priority:100
msgid "Use FileMerge (requires a graphical session)"
msgstr "使用文件合并（需要图形会话）"

#. type: Labeled list
#: en/mergetools-merge.txt:24
#, no-wrap, priority:100
msgid "`p4merge`"
msgstr "`p4merge`"

#. type: Plain text
#: en/mergetools-merge.txt:25
#, priority:100
msgid "Use HelixCore P4Merge (requires a graphical session)"
msgstr "使用 HelixCore P4Merge（需要图形会话）"

#. type: Labeled list
#: en/mergetools-merge.txt:25
#, ignore-same, no-wrap, priority:100
msgid "`smerge`"
msgstr "`smerge`"

#. type: Plain text
#: en/mergetools-merge.txt:26
#, priority:100
msgid "Use Sublime Merge (requires a graphical session)"
msgstr "使用 Sublime Merge（需要图形会话）"

#. type: Labeled list
#: en/mergetools-merge.txt:26
#, ignore-same, no-wrap, priority:100
msgid "`tkdiff`"
msgstr "`tkdiff`"

#. type: Plain text
#: en/mergetools-merge.txt:27
#, priority:100
msgid "Use TkDiff (requires a graphical session)"
msgstr "使用 TkDiff（需要图形会话）"

#. type: Labeled list
#: en/mergetools-merge.txt:27
#, ignore-same, no-wrap, priority:100
msgid "`tortoisemerge`"
msgstr "`tortoisemerge`"

#. type: Plain text
#: en/mergetools-merge.txt:28
#, priority:100
msgid "Use TortoiseMerge (requires a graphical session)"
msgstr "使用 TortoiseMerge（需要图形会话）"

#. type: Labeled list
#: en/mergetools-merge.txt:28
#, ignore-same, no-wrap, priority:100
msgid "`vimdiff`"
msgstr "`vimdiff`"

#. type: Plain text
#: en/mergetools-merge.txt:29
#, priority:100
msgid "Use Vim with a custom layout (see `git help mergetool`'s `BACKEND SPECIFIC HINTS` section)"
msgstr "使用自定义布局的 Vim（请参阅 `git help mergetool` 的 `后端特定提示` 部分）"

#. type: Labeled list
#: en/mergetools-merge.txt:29
#, no-wrap, priority:100
msgid "`vimdiff1`"
msgstr "`vimdiff1`"

#. type: Plain text
#: en/mergetools-merge.txt:30
#, priority:100
msgid "Use Vim with a 2 panes layout (LOCAL and REMOTE)"
msgstr "使用双窗格布局（本地和远程）的 Vim"

#. type: Labeled list
#: en/mergetools-merge.txt:30
#, no-wrap, priority:100
msgid "`vimdiff2`"
msgstr "`vimdiff2`"

#. type: Plain text
#: en/mergetools-merge.txt:31
#, priority:100
msgid "Use Vim with a 3 panes layout (LOCAL, MERGED and REMOTE)"
msgstr "使用 Vim 的 3 个面板布局（本地、合并和远程）"

#. type: Labeled list
#: en/mergetools-merge.txt:31
#, no-wrap, priority:100
msgid "`vimdiff3`"
msgstr "`vimdiff3`"

#. type: Plain text
#: en/mergetools-merge.txt:32
#, priority:100
msgid "Use Vim where only the MERGED file is shown"
msgstr "使用 Vim，只显示合并后的文件"

#. type: Labeled list
#: en/mergetools-merge.txt:32
#, ignore-same, no-wrap, priority:100
msgid "`winmerge`"
msgstr "`winmerge`"

#. type: Plain text
#: en/mergetools-merge.txt:33
#, priority:100
msgid "Use WinMerge (requires a graphical session)"
msgstr "使用 WinMerge（需要图形会话）"

#. type: Labeled list
#: en/mergetools-merge.txt:33
#, ignore-same, no-wrap, priority:100
msgid "`xxdiff`"
msgstr "`xxdiff`"

#. type: Plain text
#: en/mergetools-merge.txt:33
#, priority:100
msgid "Use xxdiff (requires a graphical session)"
msgstr "使用 xxdiff（需要图形会话）"

#. type: Plain text
#: en/object-format-disclaimer.txt:3
#, priority:300
msgid "Note: At present, there is no interoperability between SHA-256 repositories and SHA-1 repositories."
msgstr "注：目前，SHA-256 仓库与 SHA-1 仓库之间不能相互操作。"

#. type: Plain text
#: en/object-format-disclaimer.txt:9
#, priority:300
msgid "Historically, we warned that SHA-256 repositories may later need backward incompatible changes when we introduce such interoperability features. Today, we only expect compatible changes. Furthermore, if such changes prove to be necessary, it can be expected that SHA-256 repositories created with today's Git will be usable by future versions of Git without data loss."
msgstr "过去，我们曾警告说，当我们引入此类互操作性功能时，SHA-256 仓库以后可能需要进行向后不兼容的更改。如今，我们只期待兼容的更改。此外，如果事实证明有必要进行此类修改，可以预期的是，用现在的 Git 创建的 SHA-256 仓库将可用于未来版本的 Git，而不会丢失数据。"

#. type: Title -
#: en/pretty-formats.txt:2
#, no-wrap, priority:260
msgid "PRETTY FORMATS"
msgstr "漂亮的格式"

#. type: Plain text
#: en/pretty-formats.txt:13
#, priority:260
msgid "If the commit is a merge, and if the pretty-format is not 'oneline', 'email' or 'raw', an additional line is inserted before the 'Author:' line. This line begins with \"Merge: \" and the hashes of ancestral commits are printed, separated by spaces. Note that the listed commits may not necessarily be the list of the *direct* parent commits if you have limited your view of history: for example, if you are only interested in changes related to a certain directory or file."
msgstr "如果提交是一个合并，并且如果pretty-format不是 \"oneline\"、\"email \"或 \"raw\"，那么在 \"Author: \"一行之前会插入一个附加行。 这一行的开头是 \"Merge:这一行以 \"Merge: \"开头，并打印出祖先提交的哈希值，用空格分隔。 请注意，如果你限制了你的历史视图，那么列出的提交不一定是*直接*父级提交的列表：例如，如果你只对与某个目录或文件有关的修改感兴趣。"

#. type: Plain text
#: en/pretty-formats.txt:20
#, placeholders:'linkgit:git-config[1]', priority:260
msgid "There are several built-in formats, and you can define additional formats by setting a pretty.<name> config option to either another format name, or a 'format:' string, as described below (see linkgit:git-config[1]). Here are the details of the built-in formats:"
msgstr "有几种内置的格式，你可以通过将 pretty.<名称> 配置选项设置为另一种格式名称或 'format:' 字符串来定义额外的格式，如下所述（见 linkgit:git-config[1] ）。下面是内置格式的细节："

#. type: Plain text
#: en/pretty-formats.txt:22
#, ignore-same, priority:260
msgid "'oneline'"
msgstr "'oneline'"

#. type: Plain text
#: en/pretty-formats.txt:24
#, no-wrap, priority:260
msgid "<hash> <title-line>\n"
msgstr "<哈希值> <标题行>\n"

#. type: Plain text
#: en/pretty-formats.txt:26
#, priority:260
msgid "This is designed to be as compact as possible."
msgstr "这个设计是为了尽可能的紧凑。"

#. type: Plain text
#: en/pretty-formats.txt:28
#, ignore-same, priority:260
msgid "'short'"
msgstr "'short'"

#. type: Plain text
#: en/pretty-formats.txt:31
#, no-wrap, priority:260
msgid ""
"commit <hash>\n"
"Author: <author>\n"
msgstr ""
"承诺<hash>\n"
"作者。<作者>的情况\n"

#. type: Plain text
#: en/pretty-formats.txt:33 en/pretty-formats.txt:41 en/pretty-formats.txt:51 en/pretty-formats.txt:63
#, no-wrap, priority:260
msgid "<title-line>\n"
msgstr "<标题行>\n"

#. type: Plain text
#: en/pretty-formats.txt:35
#, ignore-same, priority:260
msgid "'medium'"
msgstr "'medium'"

#. type: Plain text
#: en/pretty-formats.txt:39
#, no-wrap, priority:260
msgid ""
"commit <hash>\n"
"Author: <author>\n"
"Date:   <author-date>\n"
msgstr ""
"commit <哈希值>\n"
"Author: <作者>\n"
"Date:   <提交日期>\n"

#. type: Plain text
#: en/pretty-formats.txt:43 en/pretty-formats.txt:53 en/pretty-formats.txt:65 en/pretty-formats.txt:85
#, priority:260
msgid "<full-commit-message>"
msgstr "<完整的提交信息"

#. type: Plain text
#: en/pretty-formats.txt:45
#, ignore-same, priority:260
msgid "'full'"
msgstr "'full'"

#. type: Plain text
#: en/pretty-formats.txt:49
#, no-wrap, priority:260
msgid ""
"commit <hash>\n"
"Author: <author>\n"
"Commit: <committer>\n"
msgstr ""
"承诺<hash>\n"
"作者。< Author>\n"
"承诺。<committer>（提交者）。\n"

#. type: Plain text
#: en/pretty-formats.txt:55
#, ignore-same, priority:260
msgid "'fuller'"
msgstr "'fuller'"

#. type: Plain text
#: en/pretty-formats.txt:61
#, no-wrap, priority:260
msgid ""
"commit <hash>\n"
"Author:     <author>\n"
"AuthorDate: <author-date>\n"
"Commit:     <committer>\n"
"CommitDate: <committer-date>\n"
msgstr ""
"commit <哈希值>\n"
"Author:     <作者>\n"
"AuthorDate: <作者提交日期>\n"
"Commit:     <提交者>\n"
"CommitDate: <提交者提交日期>\n"

#. type: Plain text
#: en/pretty-formats.txt:67
#, priority:260
msgid "'reference'"
msgstr "‘引用’"

#. type: Plain text
#: en/pretty-formats.txt:69
#, no-wrap, priority:260
msgid "<abbrev-hash> (<title-line>, <short-author-date>)\n"
msgstr "<缩写哈希值>（<标题行>，<简短的作者日期>）\n"

#. type: Plain text
#: en/pretty-formats.txt:76
#, placeholders:'`--pretty=':'`--date=short`':'`--date`':'`--decorate`':'`--walk-reflogs`', priority:260
msgid "This format is used to refer to another commit in a commit message and is the same as `--pretty='format:%C(auto)%h (%s, %ad)'`. By default, the date is formatted with `--date=short` unless another `--date` option is explicitly specified. As with any `format:` with format placeholders, its output is not affected by other options like `--decorate` and `--walk-reflogs`."
msgstr "这种格式用于在提交信息中引用另一个提交，与`--pretty='format:%C(auto)%h (%s, %ad)'相同。 默认情况下，日期的格式为`--date=short`，除非明确指定其他`--date`选项。 与任何带有格式占位符的`format:`一样，其输出不受其他选项的影响，如`--decorate`和`--walk-reflogs`。"

#. type: Plain text
#: en/pretty-formats.txt:78
#, ignore-same, priority:260
msgid "'email'"
msgstr "'email'"

#. type: Plain text
#: en/pretty-formats.txt:83
#, no-wrap, priority:260
msgid ""
"From <hash> <date>\n"
"From: <author>\n"
"Date: <author-date>\n"
"Subject: [PATCH] <title-line>\n"
msgstr ""
"From <哈希> <日期>\n"
"From: <作者>\n"
"Date: <作者提交日期>\n"
"Subject: [PATCH] <标题行>\n"

#. type: Plain text
#: en/pretty-formats.txt:87
#, priority:260
msgid "'mboxrd'"
msgstr "'mboxrd'"

#. type: Plain text
#: en/pretty-formats.txt:91
#, priority:260
msgid "Like 'email', but lines in the commit message starting with \"From \" (preceded by zero or more \">\") are quoted with \">\" so they aren't confused as starting a new commit."
msgstr "和 \"email \"一样，但提交信息中以 \"From \"开头的行（前面有零个或多个\">\"）用\">\"引出，这样就不会被混淆为开始了一个新的提交。"

#. type: Plain text
#: en/pretty-formats.txt:93
#, ignore-same, priority:260
msgid "'raw'"
msgstr "'raw'"

#. type: Plain text
#: en/pretty-formats.txt:103
#, placeholders:'--abbrev':'--no-abbrev':'--raw`':'`--no-abbrev`', priority:260
msgid "The 'raw' format shows the entire commit exactly as stored in the commit object. Notably, the hashes are displayed in full, regardless of whether --abbrev or --no-abbrev are used, and 'parents' information show the true parent commits, without taking grafts or history simplification into account. Note that this format affects the way commits are displayed, but not the way the diff is shown e.g. with `git log --raw`. To get full object names in a raw diff format, use `--no-abbrev`."
msgstr "原始 \"格式显示的是整个提交对象中存储的内容。 值得注意的是，无论是否使用了 --abbrev 或 --no-abbrev，哈希值都会被完整地显示出来，而'parent'信息会显示真正的父级提交，不会考虑移花接木或历史简化。注意，这种格式会影响提交的显示方式，但不会影响diff的显示方式，比如用`git log --raw`来显示。要获得原始差异格式的完整对象名称，请使用`--no-abbrev`。"

#. type: Plain text
#: en/pretty-formats.txt:105
#, priority:260
msgid "'format:<format-string>'"
msgstr "'format:<格式字符串>'"

#. type: Plain text
#: en/pretty-formats.txt:110
#, priority:260
msgid "The 'format:<format-string>' format allows you to specify which information you want to show. It works a little bit like printf format, with the notable exception that you get a newline with '%n' instead of '\\n'."
msgstr "'format:<格式字符串' 格式允许你指定要显示的信息。它的工作原理有点像 printf 格式，但有一个明显的例外，那就是换行符是 '%n' 而不是 '\\n'。"

#. type: Plain text
#: en/pretty-formats.txt:113
#, priority:260
msgid "E.g, 'format:\"The author of %h was %an, %ar%nThe title was >>%s<<%n\"' would show something like this:"
msgstr "例如，'format: \"The author of %h was %an, %ar%nThe title was >>%s<<%n\"' 会显示这样的内容："

#. type: delimited block -
#: en/pretty-formats.txt:117
#, no-wrap, priority:260
msgid ""
"The author of fe6e0ee was Junio C Hamano, 23 hours ago\n"
"The title was >>t4119: test autocomputing -p<n> for traditional diff input.<<\n"
msgstr ""
"fe6e0ee的作者是Junio C Hamano, 23小时前\n"
"标题是 >>t4119: 测试传统diff输入的自动计算-p<n>。\n"

#. type: Plain text
#: en/pretty-formats.txt:121
#, priority:260
msgid "The placeholders are:"
msgstr "占位符是："

#. type: Plain text
#: en/pretty-formats.txt:123
#, priority:260
msgid "Placeholders that expand to a single literal character:"
msgstr "占位符，可扩展为一个字面字符："

#. type: Labeled list
#: en/pretty-formats.txt:123
#, ignore-same, no-wrap, priority:260
msgid "'%n'"
msgstr "'%n'"

#. type: Plain text
#: en/pretty-formats.txt:124
#, priority:260
msgid "newline"
msgstr "换行"

#. type: Plain text
#: en/pretty-formats.txt:125
#, priority:260
msgid "a raw '%'"
msgstr "一个原始的'%'"

#. type: Labeled list
#: en/pretty-formats.txt:125
#, no-wrap, priority:260
msgid "'%x00'"
msgstr "'%x00'"

#. type: Plain text
#: en/pretty-formats.txt:128
#, priority:260
msgid "'%x' followed by two hexadecimal digits is replaced with a byte with the hexadecimal digits' value (we will call this \"literal formatting code\" in the rest of this document)."
msgstr "'%x' 后跟两个十六进制数字，会被一个包含十六进制数字值的字节替换（在本文档的其余部分，我们称之为 “字面格式化代码”）。"

#. type: Plain text
#: en/pretty-formats.txt:130
#, priority:260
msgid "Placeholders that affect formatting of later placeholders:"
msgstr "影响后面占位符的格式化的占位符："

#. type: Labeled list
#: en/pretty-formats.txt:130
#, ignore-same, no-wrap, priority:260
msgid "'%Cred'"
msgstr "'%Cred'"

#. type: Plain text
#: en/pretty-formats.txt:131
#, priority:260
msgid "switch color to red"
msgstr "切换颜色为红色"

#. type: Labeled list
#: en/pretty-formats.txt:131
#, ignore-same, no-wrap, priority:260
msgid "'%Cgreen'"
msgstr "'%Cgreen'"

#. type: Plain text
#: en/pretty-formats.txt:132
#, priority:260
msgid "switch color to green"
msgstr "切换颜色为绿色"

#. type: Labeled list
#: en/pretty-formats.txt:132
#, ignore-same, no-wrap, priority:260
msgid "'%Cblue'"
msgstr "'%Cblue'"

#. type: Plain text
#: en/pretty-formats.txt:133
#, priority:260
msgid "switch color to blue"
msgstr "将颜色改为蓝色"

#. type: Labeled list
#: en/pretty-formats.txt:133
#, ignore-same, no-wrap, priority:260
msgid "'%Creset'"
msgstr "'%Creset'"

#. type: Plain text
#: en/pretty-formats.txt:134
#, priority:260
msgid "reset color"
msgstr "重置颜色"

#. type: Labeled list
#: en/pretty-formats.txt:134
#, ignore-ellipsis, no-wrap, priority:260
msgid "'%C(...)'"
msgstr "'%C(...)'"

#. type: Plain text
#: en/pretty-formats.txt:148
#, ignore-ellipsis, placeholders:'linkgit:git-config[1]':'color.diff':'color.ui':'`--color`':'`--color=always`', priority:260
msgid "color specification, as described under Values in the \"CONFIGURATION FILE\" section of linkgit:git-config[1]. By default, colors are shown only when enabled for log output (by `color.diff`, `color.ui`, or `--color`, and respecting the `auto` settings of the former if we are going to a terminal). `%C(auto,...)` is accepted as a historical synonym for the default (e.g., `%C(auto,red)`). Specifying `%C(always,...)` will show the colors even when color is not otherwise enabled (though consider just using `--color=always` to enable color for the whole output, including this format and anything else git might color). `auto` alone (i.e. `%C(auto)`) will turn on auto coloring on the next placeholders until the color is switched again."
msgstr "颜色规范，如linkgit:git-config[1]的 \"配置文件 \"部分中的数值描述。 默认情况下，只有在启用日志输出时才会显示颜色（通过 `color.diff`, `color.ui`, 或 `--color`, 如果我们要去终端，要尊重前者的`auto`设置）。`%C(auto,...)`被接受为默认的历史同义词（例如，`%C(auto,red)`）。指定`%C(always,...)`将显示颜色，即使没有启用颜色（尽管考虑使用`--color=always`来启用整个输出的颜色，包括这个格式和其他任何git可能的颜色）。 `auto`单独使用（即`%C(auto)`）将在下一个占位符上开启自动着色，直到再次切换颜色。"

#. type: Labeled list
#: en/pretty-formats.txt:148
#, ignore-same, no-wrap, priority:260
msgid "'%m'"
msgstr "'%m'"

#. type: Plain text
#: en/pretty-formats.txt:149
#, priority:260
msgid "left (`<`), right (`>`) or boundary (`-`) mark"
msgstr "左（`<`）、右（`>`）或边界（`-`）标记"

#. type: Labeled list
#: en/pretty-formats.txt:149
#, no-wrap, priority:260
msgid "'%w([<w>[,<i1>[,<i2>]]])'"
msgstr "'%w([<w>[,<i1>[,<i2>]]])'"

#. type: Plain text
#: en/pretty-formats.txt:151
#, placeholders:'linkgit:git-shortlog[1]', priority:260
msgid "switch line wrapping, like the -w option of linkgit:git-shortlog[1]."
msgstr "开关包行，就像 linkgit:git-shortlog[1] 的 -w 选项。"

#. type: Labeled list
#: en/pretty-formats.txt:151
#, no-wrap, priority:260
msgid "'%<( <N> [,trunc|ltrunc|mtrunc])'"
msgstr "'%<(<N>[,trunc|ltrunc|mtrunc])'"

#. type: Plain text
#: en/pretty-formats.txt:167
#, priority:260
msgid "make the next placeholder take at least N column widths, padding spaces on the right if necessary. Optionally truncate (with ellipsis '..') at the left (ltrunc) `..ft`, the middle (mtrunc) `mi..le`, or the end (trunc) `rig..`, if the output is longer than N columns. Note 1: that truncating only works correctly with N >= 2. Note 2: spaces around the N and M (see below) values are optional. Note 3: Emojis and other wide characters will take two display columns, which may over-run column boundaries. Note 4: decomposed character combining marks may be misplaced at padding boundaries."
msgstr "使下一个占位符至少占用 N 列宽，必要时在右侧填充空格。 如果输出超过 N 列，可选择在左侧（ltrunc）`..ft`、中间（mtrunc）`mi..le` 或末尾（trunc）`rig..` 截断（用省略号 '..' ）。 注意 1：截断只在 N >= 2 时有效。 注 2：N 和 M（见下文）值周围的空格为可选项。 注 3：表情符号和其他宽字符将占用两个显示列，可能会超出列边界。 注 4：分解字符组合标记可能会在填充边界处错位。"

#. type: Labeled list
#: en/pretty-formats.txt:167
#, no-wrap, priority:260
msgid "'%<|( <M> )'"
msgstr "'%<|(<M>)'"

#. type: Plain text
#: en/pretty-formats.txt:171
#, priority:260
msgid "make the next placeholder take at least until Mth display column, padding spaces on the right if necessary. Use negative M values for column positions measured from the right hand edge of the terminal window."
msgstr "使下一个占位符至少显示到第 M 列，必要时在右侧填充空格。 从终端窗口右侧边缘测量的列位置使用负 M 值。"

#. type: Labeled list
#: en/pretty-formats.txt:171
#, no-wrap, priority:260
msgid "'%>( <N> )', '%>|( <M> )'"
msgstr "'%>(<N>)', '%>|(<M>)'"

#. type: Plain text
#: en/pretty-formats.txt:173
#, priority:260
msgid "similar to '%<( <N> )', '%<|( <M> )' respectively, but padding spaces on the left"
msgstr "分别类似于 '%<( <N> )' 、'%<|( <M> )'，但在左侧填充空格"

#. type: Labeled list
#: en/pretty-formats.txt:173
#, no-wrap, priority:260
msgid "'%>>( <N> )', '%>>|( <M> )'"
msgstr "'%>>(<N>)', '%>>|(<M>)'"

#. type: Plain text
#: en/pretty-formats.txt:178
#, priority:260
msgid "similar to '%>( <N> )', '%>|( <M> )' respectively, except that if the next placeholder takes more spaces than given and there are spaces on its left, use those spaces"
msgstr "分别类似于'%>(<N>)'、'%>|(<M>)'，只是如果下一个占位符占用的空间比给定的多，并且其左侧有空格，则使用这些空格"

#. type: Labeled list
#: en/pretty-formats.txt:178
#, no-wrap, priority:260
msgid "'%><( <N> )', '%><|( <M> )'"
msgstr "'%><(<N>)', '%><|(<M>)'"

#. type: Plain text
#: en/pretty-formats.txt:181
#, priority:260
msgid "similar to '%<( <N> )', '%<|( <M> )' respectively, but padding both sides (i.e. the text is centered)"
msgstr "分别类似于'%<( <N> )' 和 '%<|( <M> )'，但两边都有填充（即文本居中）"

#. type: Plain text
#: en/pretty-formats.txt:183
#, priority:260
msgid "Placeholders that expand to information extracted from the commit:"
msgstr "占位符，扩展到从提交中提取的信息："

#. type: Labeled list
#: en/pretty-formats.txt:183
#, ignore-same, no-wrap, priority:260
msgid "'%H'"
msgstr "'%H'"

#. type: Plain text
#: en/pretty-formats.txt:184
#, priority:260
msgid "commit hash"
msgstr "提交的哈希值"

#. type: Labeled list
#: en/pretty-formats.txt:184
#, ignore-same, no-wrap, priority:260
msgid "'%h'"
msgstr "'%h'"

#. type: Plain text
#: en/pretty-formats.txt:185
#, priority:260
msgid "abbreviated commit hash"
msgstr "简称提交哈希"

#. type: Labeled list
#: en/pretty-formats.txt:185
#, ignore-same, no-wrap, priority:260
msgid "'%T'"
msgstr "'%T'"

#. type: Plain text
#: en/pretty-formats.txt:186
#, priority:260
msgid "tree hash"
msgstr "目录树哈希值"

#. type: Labeled list
#: en/pretty-formats.txt:186
#, ignore-same, no-wrap, priority:260
msgid "'%t'"
msgstr "'%t'"

#. type: Plain text
#: en/pretty-formats.txt:187
#, priority:260
msgid "abbreviated tree hash"
msgstr "简称树形哈希"

#. type: Labeled list
#: en/pretty-formats.txt:187
#, ignore-same, no-wrap, priority:260
msgid "'%P'"
msgstr "'%P'"

#. type: Plain text
#: en/pretty-formats.txt:188
#, priority:260
msgid "parent hashes"
msgstr "父类哈希值"

#. type: Labeled list
#: en/pretty-formats.txt:188
#, ignore-same, no-wrap, priority:260
msgid "'%p'"
msgstr "'%p'"

#. type: Plain text
#: en/pretty-formats.txt:189
#, priority:260
msgid "abbreviated parent hashes"
msgstr "缩写的父母哈希值"

#. type: Labeled list
#: en/pretty-formats.txt:189
#, ignore-same, no-wrap, priority:260
msgid "'%an'"
msgstr "'%an'"

#. type: Plain text
#: en/pretty-formats.txt:190
#, priority:260
msgid "author name"
msgstr "作者名"

#. type: Labeled list
#: en/pretty-formats.txt:190
#, ignore-same, no-wrap, priority:260
msgid "'%aN'"
msgstr "'%aN'"

#. type: Plain text
#: en/pretty-formats.txt:192
#, placeholders:'linkgit:git-shortlog[1]':'linkgit:git-blame[1]', priority:260
msgid "author name (respecting .mailmap, see linkgit:git-shortlog[1] or linkgit:git-blame[1])"
msgstr "作者名（关于 .mailmap，请参见 linkgit:git-shortlog[1] 或 linkgit:git-blame[1]"

#. type: Labeled list
#: en/pretty-formats.txt:192
#, ignore-same, no-wrap, priority:260
msgid "'%ae'"
msgstr "'%ae'"

#. type: Plain text
#: en/pretty-formats.txt:193
#, priority:260
msgid "author email"
msgstr "作者电子邮箱"

#. type: Labeled list
#: en/pretty-formats.txt:193
#, ignore-same, no-wrap, priority:260
msgid "'%aE'"
msgstr "'%aE'"

#. type: Plain text
#: en/pretty-formats.txt:195
#, placeholders:'linkgit:git-shortlog[1]':'linkgit:git-blame[1]', priority:260
msgid "author email (respecting .mailmap, see linkgit:git-shortlog[1] or linkgit:git-blame[1])"
msgstr "作者电子邮件（关于 .mailmap，请参见 linkgit:git-shortlog[1] 或 linkgit:git-blame[1]"

#. type: Labeled list
#: en/pretty-formats.txt:195
#, ignore-same, no-wrap, priority:260
msgid "'%al'"
msgstr "'%al'"

#. type: Plain text
#: en/pretty-formats.txt:196
#, priority:260
msgid "author email local-part (the part before the '@' sign)"
msgstr "作者电子邮件的本地部分（'@' 符号之前的部分）"

#. type: Labeled list
#: en/pretty-formats.txt:196
#, ignore-same, no-wrap, priority:260
msgid "'%aL'"
msgstr "'%aL'"

#. type: Plain text
#: en/pretty-formats.txt:198
#, placeholders:'linkgit:git-shortlog[1]':'linkgit:git-blame[1]', priority:260
msgid "author local-part (see '%al') respecting .mailmap, see linkgit:git-shortlog[1] or linkgit:git-blame[1])"
msgstr "尊重 .mailmap 作者的本地部分（参见 '%al' ），参见 linkgit:git-shortlog[1] 或 linkgit:git-blame[1])"

#. type: Labeled list
#: en/pretty-formats.txt:198
#, ignore-same, no-wrap, priority:260
msgid "'%ad'"
msgstr "'%ad'"

#. type: Plain text
#: en/pretty-formats.txt:199
#, placeholders:'--date=', priority:260
msgid "author date (format respects --date= option)"
msgstr "作者日期（格式尊重--date=选项"

#. type: Labeled list
#: en/pretty-formats.txt:199
#, ignore-same, no-wrap, priority:260
msgid "'%aD'"
msgstr "'%aD'"

#. type: Plain text
#: en/pretty-formats.txt:200
#, priority:260
msgid "author date, RFC2822 style"
msgstr "作者日期，RFC2822风格"

#. type: Labeled list
#: en/pretty-formats.txt:200
#, ignore-same, no-wrap, priority:260
msgid "'%ar'"
msgstr "'%ar'"

#. type: Plain text
#: en/pretty-formats.txt:201
#, priority:260
msgid "author date, relative"
msgstr "作者日期，相对"

#. type: Labeled list
#: en/pretty-formats.txt:201
#, ignore-same, no-wrap, priority:260
msgid "'%at'"
msgstr "'%at'"

#. type: Plain text
#: en/pretty-formats.txt:202
#, priority:260
msgid "author date, UNIX timestamp"
msgstr "作者日期，UNIX时间戳"

#. type: Labeled list
#: en/pretty-formats.txt:202
#, ignore-same, no-wrap, priority:260
msgid "'%ai'"
msgstr "'%ai'"

#. type: Plain text
#: en/pretty-formats.txt:203
#, priority:260
msgid "author date, ISO 8601-like format"
msgstr "作者日期，类似ISO 8601的格式"

#. type: Labeled list
#: en/pretty-formats.txt:203
#, ignore-same, no-wrap, priority:260
msgid "'%aI'"
msgstr "'%aI'"

#. type: Plain text
#: en/pretty-formats.txt:204
#, priority:260
msgid "author date, strict ISO 8601 format"
msgstr "作者日期，严格的ISO 8601格式"

#. type: Labeled list
#: en/pretty-formats.txt:204
#, ignore-same, no-wrap, priority:260
msgid "'%as'"
msgstr "'%as'"

#. type: Plain text
#: en/pretty-formats.txt:205
#, priority:260
msgid "author date, short format (`YYYY-MM-DD`)"
msgstr "作者日期，短格式（ `YYYY-MM-DD` ）"

#. type: Labeled list
#: en/pretty-formats.txt:205
#, ignore-same, no-wrap, priority:260
msgid "'%ah'"
msgstr "'%ah'"

# ERROR: linkgit:git-rev-list[1] not found in translation
#. type: Plain text
#: en/pretty-formats.txt:207
#, placeholders:'`--date=human`':'linkgit:git-rev-list[1]', priority:260
msgid "author date, human style (like the `--date=human` option of linkgit:git-rev-list[1])"
msgstr "作者日期，以易读形式呈现（就像 linkgit:git-rev-list[1] 的 `--date=human` 选项）"

#. type: Labeled list
#: en/pretty-formats.txt:207
#, ignore-same, no-wrap, priority:260
msgid "'%cn'"
msgstr "'%cn'"

#. type: Plain text
#: en/pretty-formats.txt:208
#, priority:260
msgid "committer name"
msgstr "提交者名称"

#. type: Labeled list
#: en/pretty-formats.txt:208
#, ignore-same, no-wrap, priority:260
msgid "'%cN'"
msgstr "'%cN'"

#. type: Plain text
#: en/pretty-formats.txt:210
#, placeholders:'linkgit:git-shortlog[1]':'linkgit:git-blame[1]', priority:260
msgid "committer name (respecting .mailmap, see linkgit:git-shortlog[1] or linkgit:git-blame[1])"
msgstr "提交者名称（尊重 .mailmap，参见 linkgit:git-shortlog[1] 或 linkgit:git-blame[1]"

#. type: Labeled list
#: en/pretty-formats.txt:210
#, ignore-same, no-wrap, priority:260
msgid "'%ce'"
msgstr "'%ce'"

#. type: Plain text
#: en/pretty-formats.txt:211
#, priority:260
msgid "committer email"
msgstr "提交者电子邮箱"

#. type: Labeled list
#: en/pretty-formats.txt:211
#, ignore-same, no-wrap, priority:260
msgid "'%cE'"
msgstr "'%cE'"

#. type: Plain text
#: en/pretty-formats.txt:213
#, placeholders:'linkgit:git-shortlog[1]':'linkgit:git-blame[1]', priority:260
msgid "committer email (respecting .mailmap, see linkgit:git-shortlog[1] or linkgit:git-blame[1])"
msgstr "提交者电子邮箱（尊重 .mailmap，参见 linkgit:git-shortlog[1] 或 linkgit:git-blame[1]"

#. type: Labeled list
#: en/pretty-formats.txt:213
#, ignore-same, no-wrap, priority:260
msgid "'%cl'"
msgstr "'%cl'"

#. type: Plain text
#: en/pretty-formats.txt:214
#, priority:260
msgid "committer email local-part (the part before the '@' sign)"
msgstr "提交者电子邮件的本地部分（'@' 符号之前的部分）"

#. type: Labeled list
#: en/pretty-formats.txt:214
#, ignore-same, no-wrap, priority:260
msgid "'%cL'"
msgstr "'%cL'"

#. type: Plain text
#: en/pretty-formats.txt:216
#, placeholders:'linkgit:git-shortlog[1]':'linkgit:git-blame[1]', priority:260
msgid "committer local-part (see '%cl') respecting .mailmap, see linkgit:git-shortlog[1] or linkgit:git-blame[1])"
msgstr "提交者本地部分（参见'%cl' ）尊重 .mailmap, 参见 linkgit:git-shortlog[1] 或 linkgit:git-blame[1])"

#. type: Labeled list
#: en/pretty-formats.txt:216
#, ignore-same, no-wrap, priority:260
msgid "'%cd'"
msgstr "'%cd'"

#. type: Plain text
#: en/pretty-formats.txt:217
#, placeholders:'--date=', priority:260
msgid "committer date (format respects --date= option)"
msgstr "承诺人日期（格式尊重--date=选项"

#. type: Labeled list
#: en/pretty-formats.txt:217
#, ignore-same, no-wrap, priority:260
msgid "'%cD'"
msgstr "'%cD'"

#. type: Plain text
#: en/pretty-formats.txt:218
#, priority:260
msgid "committer date, RFC2822 style"
msgstr "承诺人日期，RFC2822风格"

#. type: Labeled list
#: en/pretty-formats.txt:218
#, ignore-same, no-wrap, priority:260
msgid "'%cr'"
msgstr "'%cr'"

#. type: Plain text
#: en/pretty-formats.txt:219
#, priority:260
msgid "committer date, relative"
msgstr "承诺人日期，相对"

#. type: Labeled list
#: en/pretty-formats.txt:219
#, ignore-same, no-wrap, priority:260
msgid "'%ct'"
msgstr "'%ct'"

#. type: Plain text
#: en/pretty-formats.txt:220
#, priority:260
msgid "committer date, UNIX timestamp"
msgstr "提交者日期，UNIX时间戳"

#. type: Labeled list
#: en/pretty-formats.txt:220
#, ignore-same, no-wrap, priority:260
msgid "'%ci'"
msgstr "'%ci'"

#. type: Plain text
#: en/pretty-formats.txt:221
#, priority:260
msgid "committer date, ISO 8601-like format"
msgstr "承诺人日期，类似ISO 8601的格式"

#. type: Labeled list
#: en/pretty-formats.txt:221
#, ignore-same, no-wrap, priority:260
msgid "'%cI'"
msgstr "'%cI'"

#. type: Plain text
#: en/pretty-formats.txt:222
#, priority:260
msgid "committer date, strict ISO 8601 format"
msgstr "承诺人日期，严格的ISO 8601格式"

#. type: Labeled list
#: en/pretty-formats.txt:222
#, ignore-same, no-wrap, priority:260
msgid "'%cs'"
msgstr "'%cs'"

#. type: Plain text
#: en/pretty-formats.txt:223
#, priority:260
msgid "committer date, short format (`YYYY-MM-DD`)"
msgstr "承诺人日期，短格式（ `YYYY-MM-DD` ）"

#. type: Labeled list
#: en/pretty-formats.txt:223
#, ignore-same, no-wrap, priority:260
msgid "'%ch'"
msgstr "'%ch'"

#. type: Plain text
#: en/pretty-formats.txt:225
#, placeholders:'`--date=human`':'linkgit:git-rev-list[1]', priority:260
msgid "committer date, human style (like the `--date=human` option of linkgit:git-rev-list[1])"
msgstr "提交者的日期，人类风格（就像 linkgit:git-rev-list[1] 的 `--date=human` 选项）"

#. type: Labeled list
#: en/pretty-formats.txt:225
#, ignore-same, no-wrap, priority:260
msgid "'%d'"
msgstr "'%d'"

#. type: Plain text
#: en/pretty-formats.txt:226
#, placeholders:'--decorate':'linkgit:git-log[1]', priority:260
msgid "ref names, like the --decorate option of linkgit:git-log[1]"
msgstr "ref名称，就像linkgit:git-log[1]的--decorate选项。"

#. type: Labeled list
#: en/pretty-formats.txt:226
#, ignore-same, no-wrap, priority:260
msgid "'%D'"
msgstr "'%D'"

#. type: Plain text
#: en/pretty-formats.txt:227
#, priority:260
msgid "ref names without the \" (\", \")\" wrapping."
msgstr "没有\"（\"、\"）\"包装的参考文献名称。"

#. type: Labeled list
#: en/pretty-formats.txt:227
#, no-wrap, priority:260
msgid "'%(decorate[:<options>])'"
msgstr "'%(decorate[:<选项>])'"

#. type: Plain text
#: en/pretty-formats.txt:232
#, priority:260
msgid "ref names with custom decorations. The `decorate` string may be followed by a colon and zero or more comma-separated options. Option values may contain literal formatting codes. These must be used for commas (`%x2C`) and closing parentheses (`%x29`), due to their role in the option syntax."
msgstr "自定义装饰的引用名称。`decorate` 字符串后面可以是冒号和零个或多个以逗号分隔的选项。选项值可能包含字面格式化代码。由于逗号（`%x2C`）和结尾括号（`%x29`）在选项语法中的作用，因此必须使用这些代码。"

#. type: Plain text
#: en/pretty-formats.txt:234
#, placeholders:'{nbsp}', priority:260
msgid "'prefix=<value>': Shown before the list of ref names. Defaults to \"{nbsp}`(`\"."
msgstr "'prefix=<值>'： 显示在引用名称列表之前。 默认为 \"{nbsp}`(`\"。"

#. type: Plain text
#: en/pretty-formats.txt:235
#, priority:260
msgid "'suffix=<value>': Shown after the list of ref names. Defaults to \"`)`\"."
msgstr "'suffix=<值>'： 显示在引用名称列表之后。 默认为 \"`)`\"。"

#. type: Plain text
#: en/pretty-formats.txt:236
#, placeholders:'{nbsp}', priority:260
msgid "'separator=<value>': Shown between ref names. Defaults to \"`,`{nbsp}\"."
msgstr "'separator=<值>'： 显示在引用名称之间。 默认为 \"`,`{nbsp}\"。"

#. type: Plain text
#: en/pretty-formats.txt:237
#, placeholders:'HEAD', priority:260
msgid "'pointer=<value>': Shown between HEAD and the branch it points to, if any."
msgstr "'point=<值>'： 显示在 HEAD 和其指向的分支（如果有）之间。"

#. type: Plain text
#: en/pretty-formats.txt:238
#, placeholders:'{nbsp}':'{nbsp}', priority:260
msgid "Defaults to \"{nbsp}`->`{nbsp}\"."
msgstr "默认为 \"{nbsp}`->`{nbsp}\"。"

#. type: Plain text
#: en/pretty-formats.txt:239
#, placeholders:'{nbsp}', priority:260
msgid "'tag=<value>': Shown before tag names. Defaults to \"`tag:`{nbsp}\"."
msgstr "'tag=<值>'： 显示在标记名称之前。默认为 \"`tag:`{nbsp}\"。"

#. type: Plain text
#: en/pretty-formats.txt:243
#, priority:260
msgid "For example, to produce decorations with no wrapping or tag annotations, and spaces as separators:"
msgstr "例如，制作不带包装或标签注释的装饰，并用空格作为分隔符："

#. type: Plain text
#: en/pretty-formats.txt:245
#, priority:260
msgid "`%(decorate:prefix=,suffix=,tag=,separator= )`"
msgstr "`%(decorate:prefix=,suffix=,tag=,separator= )`"

#. type: Labeled list
#: en/pretty-formats.txt:246
#, no-wrap, priority:260
msgid "'%(describe[:<options>])'"
msgstr "'%(describe[:<选项>])'"

#. type: Plain text
#: en/pretty-formats.txt:251
#, placeholders:'linkgit:git-describe[1]', priority:260
msgid "human-readable name, like linkgit:git-describe[1]; empty string for undescribable commits. The `describe` string may be followed by a colon and zero or more comma-separated options. Descriptions can be inconsistent when tags are added or removed at the same time."
msgstr "人类可读的名字，像linkgit:git-describe[1]；空字符串表示不可描述的提交。 `describe`字符串后面可以有冒号和零个或多个逗号分隔的选项。 当标签同时被添加或删除时，描述可能不一致。"

#. type: Plain text
#: en/pretty-formats.txt:254
#, priority:260
msgid "'tags[=<bool-value>]': Instead of only considering annotated tags, consider lightweight tags as well."
msgstr "'tags[=<bool-value>]'：不仅考虑带注释的标签，还考虑轻量级标签。"

#. type: Plain text
#: en/pretty-formats.txt:258
#, priority:260
msgid "'abbrev=<number>': Instead of using the default number of hexadecimal digits (which will vary according to the number of objects in the repository with a default of 7) of the abbreviated object name, use <number> digits, or as many digits as needed to form a unique object name."
msgstr "'abbrev=<数量>'：不使用缩写对象名称的默认十六进制位数（根据仓库中对象的数量而变化，默认为 7 位），而是使用 <数量> 的位数，或根据需要的位数来组成唯一的对象名称。"

#. type: Plain text
#: en/pretty-formats.txt:260
#, priority:260
msgid "'match=<pattern>': Only consider tags matching the given `glob(7)` pattern, excluding the \"refs/tags/\" prefix."
msgstr "'match=<pattern>':只考虑与给定的`glob(7)`模式匹配的标签，不包括 \"refs/tags/\"前缀。"

#. type: Plain text
#: en/pretty-formats.txt:262
#, priority:260
msgid "'exclude=<pattern>': Do not consider tags matching the given `glob(7)` pattern, excluding the \"refs/tags/\" prefix."
msgstr "'exclude=<pattern>':不考虑匹配给定`glob(7)`模式的标签，排除 \"refs/tags/\"前缀。"

#. type: Plain text
#: en/pretty-formats.txt:265
#, placeholders:'--source`', priority:260
msgid "ref name given on the command line by which the commit was reached (like `git log --source`), only works with `git log`"
msgstr "在命令行中给出的提交名称（如 `git log --source`），只对 `git log` 起作用"

#. type: Labeled list
#: en/pretty-formats.txt:265
#, ignore-same, no-wrap, priority:260
msgid "'%e'"
msgstr "'%e'"

#. type: Plain text
#: en/pretty-formats.txt:266
#, priority:260
msgid "encoding"
msgstr "编码方式"

#. type: Plain text
#: en/pretty-formats.txt:267
#, priority:260
msgid "subject"
msgstr "主题"

#. type: Labeled list
#: en/pretty-formats.txt:267
#, ignore-same, no-wrap, priority:260
msgid "'%f'"
msgstr "'%f'"

#. type: Plain text
#: en/pretty-formats.txt:268
#, priority:260
msgid "sanitized subject line, suitable for a filename"
msgstr "经过消毒的主题行，适合于文件名"

#. type: Labeled list
#: en/pretty-formats.txt:268
#, ignore-same, no-wrap, priority:260
msgid "'%b'"
msgstr "'%b'"

#. type: Plain text
#: en/pretty-formats.txt:269
#, priority:260
msgid "body"
msgstr "正文"

#. type: Labeled list
#: en/pretty-formats.txt:269
#, ignore-same, no-wrap, priority:260
msgid "'%B'"
msgstr "'%B'"

#. type: Plain text
#: en/pretty-formats.txt:270
#, priority:260
msgid "raw body (unwrapped subject and body)"
msgstr "原始体（未包装的主题和体）"

#. type: Labeled list
#: en/pretty-formats.txt:271
#, ignore-same, no-wrap, priority:260
msgid "'%N'"
msgstr "'%N'"

#. type: Plain text
#: en/pretty-formats.txt:272
#, priority:260
msgid "commit notes"
msgstr "承诺说明"

#. type: Labeled list
#: en/pretty-formats.txt:273
#, ignore-same, no-wrap, priority:260
msgid "'%GG'"
msgstr "'%GG'"

#. type: Plain text
#: en/pretty-formats.txt:274
#, priority:260
msgid "raw verification message from GPG for a signed commit"
msgstr "来自GPG的签名提交的原始验证信息"

#. type: Labeled list
#: en/pretty-formats.txt:274
#, no-wrap, priority:260
msgid "'%G?'"
msgstr "'%G?'"

#. type: Plain text
#: en/pretty-formats.txt:282
#, priority:260
msgid "show \"G\" for a good (valid) signature, \"B\" for a bad signature, \"U\" for a good signature with unknown validity, \"X\" for a good signature that has expired, \"Y\" for a good signature made by an expired key, \"R\" for a good signature made by a revoked key, \"E\" if the signature cannot be checked (e.g. missing key) and \"N\" for no signature"
msgstr "显示 \"G\" 代表一个好的（有效的）签名，\"B\" 代表一个坏的签名，\"U\" 代表一个有效性未知的好的签名，\"X\" 代表一个已经过期的好的签名，\"Y\" 代表一个由过期的钥匙制作的好的签名，\"R\" 代表一个由撤销的 钥匙制作的好的签名，\"E\" 如果不能检查签名（如缺少钥匙），\"N\" 代表没有签名"

#. type: Labeled list
#: en/pretty-formats.txt:282
#, ignore-same, no-wrap, priority:260
msgid "'%GS'"
msgstr "'%GS'"

#. type: Plain text
#: en/pretty-formats.txt:283
#, priority:260
msgid "show the name of the signer for a signed commit"
msgstr "显示已签名的提交的签名者的名字"

#. type: Labeled list
#: en/pretty-formats.txt:283
#, ignore-same, no-wrap, priority:260
msgid "'%GK'"
msgstr "'%GK'"

#. type: Plain text
#: en/pretty-formats.txt:284
#, priority:260
msgid "show the key used to sign a signed commit"
msgstr "显示用于签署已签名的承诺的密钥"

#. type: Labeled list
#: en/pretty-formats.txt:284
#, ignore-same, no-wrap, priority:260
msgid "'%GF'"
msgstr "'%GF'"

#. type: Plain text
#: en/pretty-formats.txt:285
#, priority:260
msgid "show the fingerprint of the key used to sign a signed commit"
msgstr "显示用于签署已签名提交文件的密钥的指纹"

#. type: Labeled list
#: en/pretty-formats.txt:285
#, ignore-same, no-wrap, priority:260
msgid "'%GP'"
msgstr "'%GP'"

#. type: Plain text
#: en/pretty-formats.txt:287
#, priority:260
msgid "show the fingerprint of the primary key whose subkey was used to sign a signed commit"
msgstr "显示主键的指纹，该主键的子键被用来签署一个已签署的提交"

#. type: Labeled list
#: en/pretty-formats.txt:287
#, ignore-same, no-wrap, priority:260
msgid "'%GT'"
msgstr "'%GT'"

#. type: Plain text
#: en/pretty-formats.txt:288
#, priority:260
msgid "show the trust level for the key used to sign a signed commit"
msgstr "显示用于签署已签名的承诺的密钥的信任级别"

#. type: Labeled list
#: en/pretty-formats.txt:288
#, ignore-same, no-wrap, priority:260
msgid "'%gD'"
msgstr "'%gD'"

#. type: Plain text
#: en/pretty-formats.txt:293
#, placeholders:'{1}':'`-g`':'{0}', priority:260
msgid "reflog selector, e.g., `refs/stash@{1}` or `refs/stash@{2 minutes ago}`; the format follows the rules described for the `-g` option. The portion before the `@` is the refname as given on the command line (so `git log -g refs/heads/master` would yield `refs/heads/master@{0}`)."
msgstr "reflog选择器，例如，`refs/stash@{1}`或`refs/stash@{2分钟前}`；其格式遵循`-g`选项的规则。`@'前面的部分是命令行上给出的参考文献名称（所以`git log -g refs/heads/master`会产生`refs/heads/master@{0}`）。"

#. type: Labeled list
#: en/pretty-formats.txt:293
#, ignore-same, no-wrap, priority:260
msgid "'%gd'"
msgstr "'%gd'"

#. type: Plain text
#: en/pretty-formats.txt:296
#, priority:260
msgid "shortened reflog selector; same as `%gD`, but the refname portion is shortened for human readability (so `refs/heads/master` becomes just `master`)."
msgstr "简化的 reflog 选择器；与 `%gD` 相同，但 refname 部分被缩短以利于人类阅读（因此 `refs/heads/master` 变成了 `master`）。"

#. type: Labeled list
#: en/pretty-formats.txt:296
#, ignore-same, no-wrap, priority:260
msgid "'%gn'"
msgstr "'%gn'"

#. type: Plain text
#: en/pretty-formats.txt:297
#, priority:260
msgid "reflog identity name"
msgstr "记录身份名称"

#. type: Labeled list
#: en/pretty-formats.txt:297
#, ignore-same, no-wrap, priority:260
msgid "'%gN'"
msgstr "'%gN'"

#. type: Plain text
#: en/pretty-formats.txt:299
#, placeholders:'linkgit:git-shortlog[1]':'linkgit:git-blame[1]', priority:260
msgid "reflog identity name (respecting .mailmap, see linkgit:git-shortlog[1] or linkgit:git-blame[1])"
msgstr "引用日志身份名称（尊重 .mailmap，参见 linkgit:git-shortlog[1] 或 linkgit:git-blame[1]"

#. type: Labeled list
#: en/pretty-formats.txt:299
#, ignore-same, no-wrap, priority:260
msgid "'%ge'"
msgstr "'%ge'"

#. type: Plain text
#: en/pretty-formats.txt:300
#, priority:260
msgid "reflog identity email"
msgstr "重新记录身份邮件"

#. type: Labeled list
#: en/pretty-formats.txt:300
#, ignore-same, no-wrap, priority:260
msgid "'%gE'"
msgstr "'%gE'"

#. type: Plain text
#: en/pretty-formats.txt:302
#, placeholders:'linkgit:git-shortlog[1]':'linkgit:git-blame[1]', priority:260
msgid "reflog identity email (respecting .mailmap, see linkgit:git-shortlog[1] or linkgit:git-blame[1])"
msgstr "引用日志身份电子邮箱（尊重 .mailmap，参见 linkgit:git-shortlog[1] 或 linkgit:git-blame[1]"

#. type: Labeled list
#: en/pretty-formats.txt:302
#, ignore-same, no-wrap, priority:260
msgid "'%gs'"
msgstr "'%gs'"

#. type: Plain text
#: en/pretty-formats.txt:303
#, priority:260
msgid "reflog subject"
msgstr "记录主题"

#. type: Labeled list
#: en/pretty-formats.txt:303
#, no-wrap, priority:260
msgid "'%(trailers[:<options>])'"
msgstr "'%(trailers[:<选项>])'"

#. type: Plain text
#: en/pretty-formats.txt:308
#, placeholders:'linkgit:git-interpret-trailers[1]', priority:260
msgid "display the trailers of the body as interpreted by linkgit:git-interpret-trailers[1]. The `trailers` string may be followed by a colon and zero or more comma-separated options. If any option is provided multiple times, the last occurrence wins."
msgstr "显示由 linkgit:git-interpret-trailers[1] 解释的正文的为主。`trailers` 字符串后面可以有冒号和零个或多个逗号分隔的选项。 如果任何选项被多次提供，则最后出现的选项获胜。"

#. type: Plain text
#: en/pretty-formats.txt:317
#, priority:260
msgid "'key=<key>': only show trailers with specified <key>. Matching is done case-insensitively and trailing colon is optional. If option is given multiple times trailer lines matching any of the keys are shown. This option automatically enables the `only` option so that non-trailer lines in the trailer block are hidden. If that is not desired it can be disabled with `only=false`. E.g., `%(trailers:key=Reviewed-by)` shows trailer lines with key `Reviewed-by`."
msgstr "'key=<键>'：只显示具有指定密钥的为主。匹配是不分大小写的，后面的冒号是可选的。如果多次给出选项，则显示与任何键匹配的为主行。该选项自动启用 `only` 选项，使拖车块中的非尾注行被隐藏。如果不希望这样，可以用 `only=false` 禁用。 例如，`%(trailers:key=Reviewed-by)` 显示键为 `Reviewed-by` 的拖车行。"

#. type: Plain text
#: en/pretty-formats.txt:319
#, priority:260
msgid "'only[=<bool>]': select whether non-trailer lines from the trailer block should be included."
msgstr "'only[=<布尔值>]' ：选择是否应该包括来自尾注块的非尾注行。"

#. type: Plain text
#: en/pretty-formats.txt:327
#, priority:260
msgid "'separator=<sep>': specify a separator inserted between trailer lines. When this option is not given each trailer line is terminated with a line feed character. The string <sep> may contain the literal formatting codes described above. To use comma as separator one must use `%x2C` as it would otherwise be parsed as next option. E.g., `%(trailers:key=Ticket,separator=%x2C )` shows all trailer lines whose key is \"Ticket\" separated by a comma and a space."
msgstr "'separator=<切片>'：指定插入在尾注行之间的分隔符。如果不使用该选项，则每行以换行符结束。字符串 <切片> 可以包含上述字面格式化代码。要使用逗号作为分隔符，必须使用 `%x2C`，否则会被解析为下一个选项。例如，`%(trailer:key=Ticket,separator=%x2C )` 显示所有关键字为 \"Ticket\" 的尾注行，并用逗号和空格分隔。"

#. type: Plain text
#: en/pretty-formats.txt:330
#, placeholders:'`--unfold`', priority:260
msgid "'unfold[=<bool>]': make it behave as if interpret-trailer's `--unfold` option was given. E.g., `%(trailers:only,unfold=true)` unfolds and shows all trailer lines."
msgstr "'unfold[=<布尔值>]'：使它的行为就像 interpret-trailer 的 `--unfold` 选项被给出一样。例如，`%(trailers:only,unfold=true)`会展开并显示所有的尾注行。"

#. type: Plain text
#: en/pretty-formats.txt:331
#, priority:260
msgid "'keyonly[=<bool>]': only show the key part of the trailer."
msgstr "'keyonly[=<布尔值>]'：只显示尾注的关键部分。"

#. type: Plain text
#: en/pretty-formats.txt:332
#, priority:260
msgid "'valueonly[=<bool>]': only show the value part of the trailer."
msgstr "'valueonly[=<布尔值>]'：只显示尾注的值部分。"

#. type: Plain text
#: en/pretty-formats.txt:336
#, placeholders:'key_value_separator', priority:260
msgid "'key_value_separator=<sep>': specify a separator inserted between trailer lines. When this option is not given each trailer key-value pair is separated by \": \". Otherwise it shares the same semantics as 'separator=<sep>' above."
msgstr "'key_value_separator=<切片>'：指定在尾注行之间插入一个分隔符。当这个选项没有给出时，每个尾注的键值对都用 \": \" 分开。 否则，它的语义与上面的 'separator=<切片>' 相同。"

#. type: Plain text
#: en/pretty-formats.txt:343
#, placeholders:'`--decorate`', priority:260
msgid "Some placeholders may depend on other options given to the revision traversal engine. For example, the `%g*` reflog options will insert an empty string unless we are traversing reflog entries (e.g., by `git log -g`). The `%d` and `%D` placeholders will use the \"short\" decoration format if `--decorate` was not already provided on the command line."
msgstr "一些占位符可能取决于给修订版遍历引擎的其他选项。例如，`%g*` reflog选项将插入一个空字符串，除非我们正在遍历reflog条目（例如，通过`git log -g`）。`%d`和`%D`占位符将使用 \"短 \"装饰格式，如果`--decorate`没有在命令行上提供。"

#. type: Plain text
#: en/pretty-formats.txt:348
#, placeholders:'linkgit:git-config[1]', priority:260
msgid "The boolean options accept an optional value `[=<bool-value>]`. The values `true`, `false`, `on`, `off` etc. are all accepted. See the \"boolean\" sub-section in \"EXAMPLES\" in linkgit:git-config[1]. If a boolean option is given with no value, it's enabled."
msgstr "布尔选项接受一个可选的值`[=<布尔值>]`。`true`, `false`, `on`, `off`等值都可以接受。参见linkgit:git-config[1]中 “示例” 的 “布尔” 子章节。如果一个布尔选项没有给出值，它就被启用。"

#. type: Plain text
#: en/pretty-formats.txt:352
#, priority:260
msgid "If you add a `+` (plus sign) after '%' of a placeholder, a line-feed is inserted immediately before the expansion if and only if the placeholder expands to a non-empty string."
msgstr "如果你在占位符的'%'后面加了一个`+'（加号），当且仅当占位符扩展为一个非空字符串时，在扩展前会立即插入换行符。"

#. type: Plain text
#: en/pretty-formats.txt:356
#, priority:260
msgid "If you add a `-` (minus sign) after '%' of a placeholder, all consecutive line-feeds immediately preceding the expansion are deleted if and only if the placeholder expands to an empty string."
msgstr "如果你在占位符的'%'后面加了一个`-'（减号），如果且仅当占位符扩展为空字符串时，紧接着扩展前的所有连续换行将被删除。"

#. type: Plain text
#: en/pretty-formats.txt:360
#, priority:260
msgid "If you add a ` ` (space) after '%' of a placeholder, a space is inserted immediately before the expansion if and only if the placeholder expands to a non-empty string."
msgstr "如果你在占位符的'%'后面加了一个``（空格），当且仅当占位符扩展到一个非空字符串时，空格就会紧接着插入扩展。"

#. type: Plain text
#: en/pretty-formats.txt:362
#, priority:260
msgid "'tformat:'"
msgstr "'t格式:'"

#. type: Plain text
#: en/pretty-formats.txt:370
#, priority:260
msgid "The 'tformat:' format works exactly like 'format:', except that it provides \"terminator\" semantics instead of \"separator\" semantics. In other words, each commit has the message terminator character (usually a newline) appended, rather than a separator placed between entries. This means that the final entry of a single-line format will be properly terminated with a new line, just as the \"oneline\" format does. For example:"
msgstr "'tformat:' 格式的工作原理与 'format:' 完全一样，只是它提供了 “终止符” 语义，而不是 “分隔符” 语义。换句话说，每个提交都附加了信息结束符（通常是换行符），而不是在条目之间放置一个分隔符。 这意味着单行格式的最后一个条目将正确地以新行结束，就像 “单行” 格式那样。 比如说："

#. type: delimited block -
#: en/pretty-formats.txt:376
#, no-wrap, placeholders:'--pretty=format', priority:260
msgid ""
"$ git log -2 --pretty=format:%h 4da45bef \\\n"
"  | perl -pe '$_ .= \" -- NO NEWLINE\\n\" unless /\\n/'\n"
"4da45be\n"
"7134973 -- NO NEWLINE\n"
msgstr ""
"$ git log -2 --pretty=format:%h 4da45bef \\\n"
"  | perl -pe '$_ .= \" -- NO NEWLINE\\n\" unless /\\n/'\n"
"4da45be\n"
"7134973 -- NO NEWLINE\n"

#. type: delimited block -
#: en/pretty-formats.txt:381
#, no-wrap, placeholders:'--pretty=tformat', priority:260
msgid ""
"$ git log -2 --pretty=tformat:%h 4da45bef \\\n"
"  | perl -pe '$_ .= \" -- NO NEWLINE\\n\" unless /\\n/'\n"
"4da45be\n"
"7134973\n"
msgstr ""
"$ git log -2 --pretty=tformat:%h 4da45bef \\\n"
"  | perl -pe '$_ .= \" -- NO NEWLINE\\n\" unless /\\n/'\n"
"4da45be\n"
"7134973\n"

#. type: Plain text
#: en/pretty-formats.txt:386
#, priority:260
msgid "In addition, any unrecognized string that has a `%` in it is interpreted as if it has `tformat:` in front of it. For example, these two are equivalent:"
msgstr "此外，任何未被识别的字符串，如果其中有 `%` ，将被解释为前面有 `tformat:` 。 例如，这两个是等同的："

#. type: delimited block -
#: en/pretty-formats.txt:390
#, no-wrap, placeholders:'--pretty=tformat':'--pretty=', priority:260
msgid ""
"$ git log -2 --pretty=tformat:%h 4da45bef\n"
"$ git log -2 --pretty=%h 4da45bef\n"
msgstr ""
"$ git log -2 --pretty=tformat:%h 4da45bef\n"
"$ git log -2 --pretty=%h 4da45bef\n"

#. type: Labeled list
#: en/pretty-options.txt:1
#, no-wrap, placeholders:'--pretty', priority:260
msgid "--pretty[=<format>]"
msgstr "--pretty[=<格式>]"

#. type: Plain text
#: en/pretty-options.txt:10
#, placeholders:'--pretty=tformat', priority:260
msgid "Pretty-print the contents of the commit logs in a given format, where '<format>' can be one of 'oneline', 'short', 'medium', 'full', 'fuller', 'reference', 'email', 'raw', 'format:<string>' and 'tformat:<string>'. When '<format>' is none of the above, and has '%placeholder' in it, it acts as if '--pretty=tformat:<format>' were given."
msgstr "以指定的格式打印提交日志的内容，其中'<format>'可以是'oneline'、'short'、'medium'、'full'、'fuller'、'reference'、'email'、'raw'、'format:<string>'和'tformat:<string>'之一。 当'<format>'不是上述任何一种，并且其中有'%placeholder'时，它的作用就像给出'--pretty=tformat:<format>'一样。"

#. type: Plain text
#: en/pretty-options.txt:13
#, priority:260
msgid "See the \"PRETTY FORMATS\" section for some additional details for each format. When '=<format>' part is omitted, it defaults to 'medium'."
msgstr "参见 \"PRETTY FORMATS \"部分，了解每种格式的一些额外细节。 当'=<格式>'部分被省略时，它默认为'中等'。"

#. type: Plain text
#: en/pretty-options.txt:16
#, placeholders:'linkgit:git-config[1]', priority:260
msgid "Note: you can specify the default pretty format in the repository configuration (see linkgit:git-config[1])."
msgstr "注意：你可以在版本库配置中指定默认的漂亮格式（见linkgit:git-config[1]）。"

#. type: Labeled list
#: en/pretty-options.txt:17
#, ignore-same, no-wrap, priority:260
msgid "--abbrev-commit"
msgstr "--abbrev-commit"

#. type: Plain text
#: en/pretty-options.txt:22
#, placeholders:'--abbrev=', priority:260
msgid "Instead of showing the full 40-byte hexadecimal commit object name, show a prefix that names the object uniquely. \"--abbrev=<n>\" (which also modifies diff output, if it is displayed) option can be used to specify the minimum length of the prefix."
msgstr "不要显示完整的40字节的十六进制提交对象名称，而是显示一个前缀，以唯一的方式命名该对象。 \"--abbrev=<n>\"选项可以用来指定前缀的最小长度（如果显示的话，它也会修改diff输出）。"

#. type: Plain text
#: en/pretty-options.txt:25
#, placeholders:'--pretty=oneline', priority:260
msgid "This should make \"--pretty=oneline\" a whole lot more readable for people using 80-column terminals."
msgstr "这应该使\"--pretty=oneline \"对于使用80列终端的人来说更容易阅读。"

#. type: Labeled list
#: en/pretty-options.txt:26
#, ignore-same, no-wrap, priority:260
msgid "--no-abbrev-commit"
msgstr "--no-abbrev-commit"

#. type: Plain text
#: en/pretty-options.txt:30
#, placeholders:'`--abbrev-commit`':'--oneline':'log.abbrevCommit', priority:260
msgid "Show the full 40-byte hexadecimal commit object name. This negates `--abbrev-commit`, either explicit or implied by other options such as \"--oneline\". It also overrides the `log.abbrevCommit` variable."
msgstr "显示完整的40字节十六进制的提交对象名称。这否定了`--abbrev-commit`，无论是明确的还是由其他选项如\"--oneline \"暗示的。它还覆盖了`log.abbrevCommit`变量。"

#. type: Plain text
#: en/pretty-options.txt:34
#, placeholders:'--pretty=oneline':'--abbrev-commit', priority:260
msgid "This is a shorthand for \"--pretty=oneline --abbrev-commit\" used together."
msgstr "这是\"--pretty=oneline --abbrev-commit \"的简写，一起使用。"

#. type: Plain text
#: en/pretty-options.txt:46
#, priority:260
msgid "Commit objects record the character encoding used for the log message in their encoding header; this option can be used to tell the command to re-code the commit log message in the encoding preferred by the user. For non plumbing commands this defaults to UTF-8. Note that if an object claims to be encoded in `X` and we are outputting in `X`, we will output the object verbatim; this means that invalid sequences in the original commit may be copied to the output. Likewise, if iconv(3) fails to convert the commit, we will quietly output the original object verbatim."
msgstr "提交对象会在其编码头中记录日志信息使用的字符编码；该选项可用于告诉命令以用户偏好的编码重新编码提交日志信息。 对于非底层命令，默认编码为 UTF-8。需要注意的是，如果对象声称以 `X` 编码，而我们以 `X` 输出，我们将逐字输出该对象；这意味着原始提交中的无效序列可能会被复制到输出中。同样，如果 iconv(3) 无法转换提交，我们也会静静地逐字输出原始对象。"

#. type: Labeled list
#: en/pretty-options.txt:47
#, no-wrap, placeholders:'--expand-tabs=', priority:260
msgid "--expand-tabs=<n>"
msgstr "--expand-tabs=<n>"

#. type: Labeled list
#: en/pretty-options.txt:48
#, ignore-same, no-wrap, priority:260
msgid "--expand-tabs"
msgstr "--expand-tabs"

#. type: Labeled list
#: en/pretty-options.txt:49
#, ignore-same, no-wrap, priority:260
msgid "--no-expand-tabs"
msgstr "--no-expand-tabs"

#. type: Plain text
#: en/pretty-options.txt:56
#, placeholders:'`--expand-tabs`':'`--expand-tabs=8`':'`--no-expand-tabs`':'`--expand-tabs=0`', priority:260
msgid "Perform a tab expansion (replace each tab with enough spaces to fill to the next display column that is a multiple of '<n>') in the log message before showing it in the output. `--expand-tabs` is a short-hand for `--expand-tabs=8`, and `--no-expand-tabs` is a short-hand for `--expand-tabs=0`, which disables tab expansion."
msgstr "在输出中显示之前，在日志信息中进行标签扩展（用足够的空格替换每个标签，以填充到下一个显示列的 '<n>' 的倍数）。 `--expand-tabs` 是 `--expand-tabs=8` 的简写，`--no-expand-tabs` 是 `--expand-tabs=0` 的简写，它禁止标签扩展。"

#. type: Plain text
#: en/pretty-options.txt:60
#, priority:260
msgid "By default, tabs are expanded in pretty formats that indent the log message by 4 spaces (i.e. 'medium', which is the default, 'full', and 'fuller')."
msgstr "默认情况下，标签会以漂亮的格式展开，将日志信息缩进4个空格（即 \"中\"，这是默认的，\"全\"，和 \"更全\"）。"

#. type: Plain text
#: en/pretty-options.txt:68
#, placeholders:'linkgit:git-notes[1]':'`--pretty`':'`--format`':'`--oneline`', priority:260
msgid "Show the notes (see linkgit:git-notes[1]) that annotate the commit, when showing the commit log message. This is the default for `git log`, `git show` and `git whatchanged` commands when there is no `--pretty`, `--format`, or `--oneline` option given on the command line."
msgstr "在显示提交日志信息时，显示注释提交的说明（见linkgit:git-notes[1]）。 这是`git log`、`git show`和`git whatchanged`命令的默认设置，当命令行中没有给出`--pretty`、`--format`或`--oneline`选项时。"

#. type: Plain text
#: en/pretty-options.txt:72
#, placeholders:'core.notesRef':'notes.displayRef':'linkgit:git-config[1]', priority:260
msgid "By default, the notes shown are from the notes refs listed in the `core.notesRef` and `notes.displayRef` variables (or corresponding environment overrides). See linkgit:git-config[1] for more details."
msgstr "默认情况下，显示的注释来自于`core.notesRef`和`notes.displayRef`变量（或相应的环境覆盖）中列出的注释参考。更多细节见linkgit:git-config[1]。"

#. type: Plain text
#: en/pretty-options.txt:77
#, priority:260
msgid "With an optional '<ref>' argument, use the ref to find the notes to display. The ref can specify the full refname when it begins with `refs/notes/`; when it begins with `notes/`, `refs/` and otherwise `refs/notes/` is prefixed to form the full name of the ref."
msgstr "有了一个可选的 '<引用>' 参数，就可以使用引用来寻找要显示的笔记。 当引用以 `refs/notes/` 开头时，可以指定完整的引用名称；当它以 `notes/` 开头时， `refs/` ，否则 `refs/notes/` 前缀，形成引用的全名。"

#. type: Plain text
#: en/pretty-options.txt:82
#, placeholders:'--notes':'--notes=foo':'--notes=foo':'--notes', priority:260
msgid "Multiple --notes options can be combined to control which notes are being displayed. Examples: \"--notes=foo\" will show only notes from \"refs/notes/foo\"; \"--notes=foo --notes\" will show both notes from \"refs/notes/foo\" and from the default notes ref(s)."
msgstr "多个--音符选项可以组合起来，控制哪些音符被显示。例如。\"--notes=foo \"将只显示来自 \"refs/notes/foo \"的注释；\"--notes=foo --notes \"将同时显示来自 \"refs/notes/foo \"和默认注释的注释。"

#. type: Plain text
#: en/pretty-options.txt:89
#, placeholders:'`--notes`':'--notes':'--notes=foo':'--no-notes':'--notes=bar', priority:260
msgid "Do not show notes. This negates the above `--notes` option, by resetting the list of notes refs from which notes are shown. Options are parsed in the order given on the command line, so e.g. \"--notes --notes=foo --no-notes --notes=bar\" will only show notes from \"refs/notes/bar\"."
msgstr "不显示注释。这否定了上面的`--notes`选项，因为它重新设置了显示注释的注释列表。 选项按照命令行给出的顺序进行解析，因此，例如\"--notes --notes=foo --no-notes --notes=bar \"将只显示来自 \"refs/notes/bar \"的注释。"

#. type: Labeled list
#: en/pretty-options.txt:90
#, ignore-same, no-wrap, priority:260
msgid "--show-notes-by-default"
msgstr "--show-notes-by-default"

#. type: Plain text
#: en/pretty-options.txt:93
#, priority:260
msgid "Show the default notes unless options for displaying specific notes are given."
msgstr "显示默认备注，除非给出了显示特定备注的选项。"

#. type: Labeled list
#: en/pretty-options.txt:94
#, no-wrap, placeholders:'--show-notes', priority:260
msgid "--show-notes[=<ref>]"
msgstr "--show-notes[=<引用>]"

#. type: Labeled list
#: en/pretty-options.txt:95
#, ignore-same, no-wrap, priority:260
msgid "--[no-]standard-notes"
msgstr "--[no-]standard-notes"

#. type: Plain text
#: en/pretty-options.txt:98
#, placeholders:'--notes':'--no-notes', priority:260
msgid "These options are deprecated. Use the above --notes/--no-notes options instead."
msgstr "这些选项已被废弃。请使用上面的 --notes/--no-notes 选项来代替。"

#. type: Labeled list
#: en/pretty-options.txt:100
#, ignore-same, no-wrap, priority:260
msgid "--show-signature"
msgstr "--show-signature"

#. type: Plain text
#: en/pretty-options.txt:102
#, placeholders:'--verify`', priority:260
msgid "Check the validity of a signed commit object by passing the signature to `gpg --verify` and show the output."
msgstr "通过将签名传递给 `gpg --verify` 来检查已签名的提交对象的有效性，并显示输出。"

#. type: Plain text
#: en/pull-fetch-param.txt:6
#, placeholders:'<<URLS,':'<<REMOTES,', priority:220
msgid "The \"remote\" repository that is the source of a fetch or pull operation. This parameter can be either a URL (see the section <<URLS,GIT URLS>> below) or the name of a remote (see the section <<REMOTES,REMOTES>> below)."
msgstr "作为获取或拉动操作的来源的 \"remote\" 仓库。 这个参数可以是一个 URL（见下面 <<URLS,GIT URLS>> 一节），也可以是一个远程仓库的名称（见下面 <<REMOTES,远程>> 一节）。"

#. type: Labeled list
#: en/pull-fetch-param.txt:8
#, no-wrap, priority:220
msgid "<group>"
msgstr "<组>"

#. type: Plain text
#: en/pull-fetch-param.txt:12
#, placeholders:'linkgit:git-config[1]', priority:220
msgid "A name referring to a list of repositories as the value of remotes.<group> in the configuration file. (See linkgit:git-config[1])."
msgstr "指向仓库列表的名称，作为配置文件中 remotes.<组> 的值。 (参见 linkgit:git-config[1]）。"

#. type: Labeled list
#: en/pull-fetch-param.txt:14
#, no-wrap, priority:220
msgid "<refspec>"
msgstr "<引用规范>"

#. type: Plain text
#: en/pull-fetch-param.txt:18
#, priority:220
msgid "Specifies which refs to fetch and which local refs to update. When no <refspec>s appear on the command line, the refs to fetch are read from `remote.<repository>.fetch` variables instead"
msgstr "指定要获取哪些引用，以及要更新哪些本地引用。 当命令行上没有出现 <引用规范> 时，将从`remote.<仓库>.fetch` 变量中读取要获取的引用"

#. type: Plain text
#: en/pull-fetch-param.txt:20
#, no-wrap, placeholders:'<<CRTB,', priority:220
msgid "\t(see <<CRTB,CONFIGURED REMOTE-TRACKING BRANCHES>> below).\n"
msgstr "\t(参见下文 <<CRTB,配置的远程跟踪分支机构>> )。\n"

#. type: Plain text
#: en/pull-fetch-param.txt:24
#, no-wrap, placeholders:'linkgit:git-fetch[1]', priority:220
msgid ""
"\t(see the section \"CONFIGURED REMOTE-TRACKING BRANCHES\"\n"
"\tin linkgit:git-fetch[1]).\n"
msgstr ""
"\t(参见 linkgit:git-fetch[1] 中\n"
"\t “配置远程跟踪分支” 一节）。\n"

#. type: Plain text
#: en/pull-fetch-param.txt:32
#, priority:220
msgid "The format of a <refspec> parameter is an optional plus `+`, followed by the source <src>, followed by a colon `:`, followed by the destination ref <dst>. The colon can be omitted when <dst> is empty. <src> is typically a ref, but it can also be a fully spelled hex object name."
msgstr "<引用规范> 参数的格式是一个可选的加号 `+` ，后面是源 <src>，后面是冒号 `:`，后面是目标引用 <dst>。 当 <dst> 为空时，冒号可以被省略。 <src> 通常是一个引用，但它也可以是一个完全拼写的十六进制对象名称。"

#. type: Plain text
#: en/pull-fetch-param.txt:38
#, priority:220
msgid "A <refspec> may contain a `*` in its <src> to indicate a simple pattern match. Such a refspec functions like a glob that matches any ref with the same prefix. A pattern <refspec> must have a `*` in both the <src> and <dst>. It will map refs to the destination by replacing the `*` with the contents matched from the source."
msgstr "一个 <引用规范> 可以在其<src>中包含一个`*'来表示一个简单的模式匹配。这样的 refspec 的功能就像一个 glob，可以匹配任何具有相同前缀的 ref。匹配 <引用规范> 必须在 <src> 和 <dst> 中都有一个 `*`。它将通过把 `*` 替换成从源头匹配的内容来把引用映射到目的地。"

#. type: Plain text
#: en/pull-fetch-param.txt:48
#, priority:220
msgid "If a refspec is prefixed by `^`, it will be interpreted as a negative refspec. Rather than specifying which refs to fetch or which local refs to update, such a refspec will instead specify refs to exclude. A ref will be considered to match if it matches at least one positive refspec, and does not match any negative refspec. Negative refspecs can be useful to restrict the scope of a pattern refspec so that it will not include specific refs. Negative refspecs can themselves be pattern refspecs. However, they may only contain a <src> and do not specify a <dst>. Fully spelled out hex object names are also not supported."
msgstr "如果一个 引用规范的前缀是 `^`，它将被解释为一个负向引用规范。这样的引用规范不是指定要获取哪些引用或更新哪些本地引用，而是指定要排除的引用。如果一个引用至少与一个正向引用规范匹配，并且不与任何负向引用规范匹配，那么该引用将被视为匹配。负向引用规范可以用来限制引用规范匹配的范围，使其不包括特定的引用。 负向引用规范本身可以是模式引用规范。然而，它们可能只包含一个 <src>，而不指定一个 <dst>。完全拼出的十六进制对象名称也不被支持。"

#. type: Plain text
#: en/pull-fetch-param.txt:51
#, priority:220
msgid "`tag <tag>` means the same as `refs/tags/<tag>:refs/tags/<tag>`; it requests fetching everything up to the given tag."
msgstr "`tag <标签>`的意思与`refs/tags/<标签>:refs/tags/<标签>` 相同；它要求获取到给定标签的所有内容。"

#. type: Plain text
#: en/pull-fetch-param.txt:55
#, priority:220
msgid "The remote ref that matches <src> is fetched, and if <dst> is not an empty string, an attempt is made to update the local ref that matches it."
msgstr "获取与 <src> 相匹配的远程引用，如果 <dst> 不是一个空字符串，就会尝试更新与之相匹配的本地引用。"

#. type: Plain text
#: en/pull-fetch-param.txt:62
#, ignore-ellipsis, placeholders:'`--force`':'linkgit:git-push[1]', priority:220
msgid "Whether that update is allowed without `--force` depends on the ref namespace it's being fetched to, the type of object being fetched, and whether the update is considered to be a fast-forward. Generally, the same rules apply for fetching as when pushing, see the `<refspec>...` section of linkgit:git-push[1] for what those are. Exceptions to those rules particular to 'git fetch' are noted below."
msgstr "该更新是否允许不使用 `--force`，取决于它被获取的引用命名空间、被获取的对象的类型，以及该更新是否被认为是一个快速合并。一般来说，获取的规则与推送的规则相同，参见 linkgit:git-push[1] 的 `<引用规范>...' 部分。以下是 \"git fetch\" 特殊规则的例外情况。"

#. type: Plain text
#: en/pull-fetch-param.txt:70
#, placeholders:'linkgit:git-push[1]':'`--force`':'`--force`', priority:220
msgid "Until Git version 2.20, and unlike when pushing with linkgit:git-push[1], any updates to `refs/tags/*` would be accepted without `+` in the refspec (or `--force`). When fetching, we promiscuously considered all tag updates from a remote to be forced fetches. Since Git version 2.20, fetching to update `refs/tags/*` works the same way as when pushing. I.e. any updates will be rejected without `+` in the refspec (or `--force`)."
msgstr "在 Git 2.20 版本之前，与使用 linkgit:git-push[1] 推送时不同，任何对 `refs/tags/*` 的更新都会被接受，在引用规范中没有 `+`（或`--force`）。在获取的时候，我们把所有来自远程的标签更新都视为强制获取。 从 Git 2.20 版本开始，获取更新 `refs/tags/*` 的方式与推送时相同。也就是说，任何在引用规范中没有 `+` 的更新都会被拒绝（或`--force`）。"

#. type: Plain text
#: en/pull-fetch-param.txt:76
#, placeholders:'linkgit:git-push[1]':'`--force`', priority:220
msgid "Unlike when pushing with linkgit:git-push[1], any updates outside of `refs/{tags,heads}/*` will be accepted without `+` in the refspec (or `--force`), whether that's swapping e.g. a tree object for a blob, or a commit for another commit that doesn't have the previous commit as an ancestor etc."
msgstr "与使用 linkgit:git-push[1] 推送时不同，任何在 `refs/{tags,heads}/*` 之外的更新都会被接受，在引用规范中没有 `+`（或 `--force`），无论是将目录树对象换成二进制文件，还是将一个提交换成另一个没有前一个提交作为祖先的提交等等。"

#. type: Plain text
#: en/pull-fetch-param.txt:80
#, placeholders:'linkgit:git-push[1]', priority:220
msgid "Unlike when pushing with linkgit:git-push[1], there is no configuration which'll amend these rules, and nothing like a `pre-fetch` hook analogous to the `pre-receive` hook."
msgstr "与使用 linkgit:git-push[1] 推送时不同，没有任何配置可以修改这些规则，也没有类似于 `pre-receive` 的 `pre-fetch` 钩子。"

#. type: Plain text
#: en/pull-fetch-param.txt:87
#, placeholders:'linkgit:git-push[1]':'`--force`', priority:220
msgid "As with pushing with linkgit:git-push[1], all of the rules described above about what's not allowed as an update can be overridden by adding an optional leading `+` to a refspec (or using the `--force` command line option). The only exception to this is that no amount of forcing will make the `refs/heads/*` namespace accept a non-commit object."
msgstr "就像用 linkgit:git-push[1] 推送一样，上面描述的所有关于不允许更新的规则都可以通过在引用规范中添加一个可选的前导词 `+` 来覆盖（或者使用 `--force` 命令行选项）。唯一的例外是，无论如何强制都不能使 `refs/heads/*` 命名空间接受一个非提交对象。"

#. type: Plain text
#: en/pull-fetch-param.txt:99
#, priority:220
msgid "When the remote branch you want to fetch is known to be rewound and rebased regularly, it is expected that its new tip will not be a descendant of its previous tip (as stored in your remote-tracking branch the last time you fetched). You would want to use the `+` sign to indicate non-fast-forward updates will be needed for such branches. There is no way to determine or declare that a branch will be made available in a repository with this behavior; the pulling user simply must know this is the expected usage pattern for a branch."
msgstr "当你想获取的远程分支已知会被定期回溯和重定向时，预计它的新提示不会是其先前提示的后代（如你上次获取时存储在远程跟踪分支中的提示）。 你应该使用 `+` 号来表示对这类分支需要进行非快速合并式更新。 没有办法确定或声明一个分支将以这种行为在仓库中提供；拉取的用户只是必须知道这是一个分支的预期使用模式。"

#. type: Plain text
#: en/pull-fetch-param.txt:119
#, priority:220
msgid "There is a difference between listing multiple <refspec> directly on 'git pull' command line and having multiple `remote.<repository>.fetch` entries in your configuration for a <repository> and running a 'git pull' command without any explicit <refspec> parameters. <refspec>s listed explicitly on the command line are always merged into the current branch after fetching. In other words, if you list more than one remote ref, 'git pull' will create an Octopus merge. On the other hand, if you do not list any explicit <refspec> parameter on the command line, 'git pull' will fetch all the <refspec>s it finds in the `remote.<repository>.fetch` configuration and merge only the first <refspec> found into the current branch. This is because making an Octopus from remote refs is rarely done, while keeping track of multiple remote heads in one-go by fetching more than one is often useful."
msgstr "在 'git pull' 命令行上直接列出多个 <引用规范> 和在 <仓库> 的配置中拥有多个`remote.<仓库>.fetch` 条目以及在没有任何明确的 <引用规范> 参数的情况下运行 'git pull' 命令是有区别的。 在命令行上明确列出的 <引用规范> 在获取后总是被合并到当前分支。 换句话说，如果你列出一个以上的远程引用，'git pull' 将创建一个多路合并。 另一方面，如果你没有在命令行中列出任何明确的 <引用规范> 参数，'git pull' 将获取它在 `remote.<仓库>.fetch` 配置中发现的所有 <引用规范>，并且只将发现的第一个<引用规范> 合并到当前分支。 这是因为很少有人从远程引用中多路合并，而通过获取多个远程头来一次性跟踪多个远程头往往是有用的。"

# ERROR: --contains not found in translation
# ERROR: --no-contains not found in translation
# ERROR: --contains not found in translation
# ERROR: --no-contains not found in translation
#. type: Plain text
#: en/ref-reachability-filters.txt:4
#, placeholders:'`--contains`':'`--no-contains`':'`--contains`':'`--no-contains`', priority:260
msgid "When combining multiple `--contains` and `--no-contains` filters, only references that contain at least one of the `--contains` commits and contain none of the `--no-contains` commits are shown."
msgstr "当组合多个 `--contains` 和 `--no-contains` 过滤器时，只显示至少包含一个 `--contains` 的提交，并且不包含 `--no-contains` 的提交引用。"

# ERROR: --merged not found in translation
# ERROR: --no-merged not found in translation
# ERROR: --merged not found in translation
# ERROR: --no-merged not found in translation
#. type: Plain text
#: en/ref-reachability-filters.txt:7
#, placeholders:'`--merged`':'`--no-merged`':'`--merged`':'`--no-merged`', priority:260
msgid "When combining multiple `--merged` and `--no-merged` filters, only references that are reachable from at least one of the `--merged` commits and from none of the `--no-merged` commits are shown."
msgstr "当结合多个 `--merged` 和 `--no-merged` 过滤器时，只显示至少有一个 `--merged` 提交和没有 `--no-merged` 提交的引用。"

#. type: Labeled list
#: en/rerere-options.txt:1
#, ignore-same, no-wrap, priority:240
msgid "--rerere-autoupdate"
msgstr "--rerere-autoupdate"

#. type: Labeled list
#: en/rerere-options.txt:2
#, ignore-same, no-wrap, priority:240
msgid "--no-rerere-autoupdate"
msgstr "--no-rerere-autoupdate"

#. type: Plain text
#: en/rerere-options.txt:9
#, placeholders:'`--no-rerere-autoupdate`', priority:240
msgid "After the rerere mechanism reuses a recorded resolution on the current conflict to update the files in the working tree, allow it to also update the index with the result of resolution. `--no-rerere-autoupdate` is a good way to double-check what `rerere` did and catch potential mismerges, before committing the result to the index with a separate `git add`."
msgstr "在 rerere 机制重用当前冲突的记录解析来更新工作树中的文件后，允许它也用解析的结果来更新索引。 `--no-rerere-autoupdate`是一个很好的方法，在用单独的 `git add` 提交结果到索引之前，可以反复检查 `rerere` 所做的事情，并抓住潜在的错误合并。"

#. type: Title -
#: en/revisions.txt:2
#, no-wrap, priority:100
msgid "SPECIFYING REVISIONS"
msgstr "规定修订"

#. type: Plain text
#: en/revisions.txt:9
#, priority:100
msgid "A revision parameter '<rev>' typically, but not necessarily, names a commit object. It uses what is called an 'extended SHA-1' syntax. Here are various ways to spell object names. The ones listed near the end of this list name trees and blobs contained in a commit."
msgstr "修订参数 '<rev>' 通常（但不一定）命名一个提交对象。 它使用所谓的 ‘扩展 SHA-1’ 语法。 这里有多种对象名称的拼写方式。 本列表末尾列出的对象名称用于命名提交中包含的树和二进制对象。"

#. type: Plain text
#: en/revisions.txt:13
#, priority:100
msgid "This document shows the \"raw\" syntax as seen by git. The shell and other UIs might require additional quoting to protect special characters and to avoid word splitting."
msgstr "本文档显示的是 git 所看到的 “原始” 语法。shell 和其他用户界面可能需要额外的引号来保护特殊字符和避免分词。"

#. type: Labeled list
#: en/revisions.txt:14
#, no-wrap, priority:100
msgid "'<sha1>', e.g. 'dae86e1950b1277e545cee180551750029cfe735', 'dae86e'"
msgstr "'<sha1>', e.g. 'dae86e1950b1277e545cee180551750029cfe735', 'dae86e'"

#. type: Plain text
#: en/revisions.txt:20
#, priority:100
msgid "The full SHA-1 object name (40-byte hexadecimal string), or a leading substring that is unique within the repository. E.g. dae86e1950b1277e545cee180551750029cfe735 and dae86e both name the same commit object if there is no other object in your repository whose object name starts with dae86e."
msgstr "完整的 SHA-1 对象名称（40 字节十六进制字符串），或在仓库中唯一的前导子串。 例如，如果仓库中没有其他对象名称以 dae86e 开头的对象，则 dae86e1950b1277e545cee180551750029cfe735 和 dae86e 都是同一个提交对象的名称。"

#. type: Labeled list
#: en/revisions.txt:21
#, no-wrap, priority:100
msgid "'<describeOutput>', e.g. 'v1.7.4.2-679-g3bee7fb'"
msgstr "'<describeOutput（描述输出）>'，例如 'v1.7.4.2-679-g3bee7fb'"

#. type: Plain text
#: en/revisions.txt:25
#, priority:100
msgid "Output from `git describe`; i.e. a closest tag, optionally followed by a dash and a number of commits, followed by a dash, a 'g', and an abbreviated object name."
msgstr "来自 `git describe` 的输出；即一个最接近的标记，后面可选择一个破折号和提交次数，再后面是一个破折号、一个 'g' 和一个缩写的对象名称。"

#. type: Labeled list
#: en/revisions.txt:26
#, no-wrap, priority:100
msgid "'<refname>', e.g. 'master', 'heads/master', 'refs/heads/master'"
msgstr "'<引用名>'， 例如 'master', 'heads/master', 'refs/heads/master'"

#. type: Plain text
#: en/revisions.txt:33
#, priority:100
msgid "A symbolic ref name. E.g. 'master' typically means the commit object referenced by 'refs/heads/master'. If you happen to have both 'heads/master' and 'tags/master', you can explicitly say 'heads/master' to tell Git which one you mean. When ambiguous, a '<refname>' is disambiguated by taking the first match in the following rules:"
msgstr "符号引用名称。 例如，'master' 通常指 'refs/heads/master' 引用的提交对象。 如果你同时拥有 'heads/master' 和 'tags/master' ，你可以明确地说 'heads/master' 来告诉 Git 你指的是哪一个。 当 '<引用名>' 有歧义时，会根据以下规则取第一个匹配项来消除歧义："

#. type: Plain text
#: en/revisions.txt:38
#, placeholders:'$GIT_DIR':'HEAD':'FETCH_HEAD':'ORIG_HEAD':'MERGE_HEAD':'REBASE_HEAD':'REVERT_HEAD':'CHERRY_PICK_HEAD':'BISECT_HEAD':'AUTO_MERGE', priority:100
msgid "If '$GIT_DIR/<refname>' exists, that is what you mean (this is usually useful only for `HEAD`, `FETCH_HEAD`, `ORIG_HEAD`, `MERGE_HEAD`, `REBASE_HEAD`, `REVERT_HEAD`, `CHERRY_PICK_HEAD`, `BISECT_HEAD` and `AUTO_MERGE`);"
msgstr "如果'$GIT_DIR/<引用名>' 存在，这就是你的意思（这通常只对 `HEAD`、`FETCH_HEAD`、`ORIG_HEAD`、`MERGE_HEAD`、`REBASE_HEAD`、`REVERT_HEAD`、`CHERRY_PICK_HEAD`、`BISECT_HEAD` 和 `AUTO_MERGE` 有用）;"

#. type: Plain text
#: en/revisions.txt:40
#, priority:100
msgid "otherwise, 'refs/<refname>' if it exists;"
msgstr "否则，如果存在，则使用 'refs/<引用名>';"

#. type: Plain text
#: en/revisions.txt:42
#, priority:100
msgid "otherwise, 'refs/tags/<refname>' if it exists;"
msgstr "否则，如果存在 'refs/tags/<引用名>'，则使用 'refs/tags/<引用名>';"

#. type: Plain text
#: en/revisions.txt:44
#, priority:100
msgid "otherwise, 'refs/heads/<refname>' if it exists;"
msgstr "否则，如果存在 'refs/heads/<引用名>'，则使用 'refs/heads/<引用名>';"

#. type: Plain text
#: en/revisions.txt:46
#, priority:100
msgid "otherwise, 'refs/remotes/<refname>' if it exists;"
msgstr "否则，如果存在 'refs/remotes/<引用名>'，则使用 'refs/remotes/<引用名>';"

#. type: Plain text
#: en/revisions.txt:48
#, placeholders:'HEAD', priority:100
msgid "otherwise, 'refs/remotes/<refname>/HEAD' if it exists."
msgstr "否则，如果存在 'refs/remotes/<引用名>/HEAD'，则使用 'refs/remotes/<引用名>/HEAD'。"

#. type: Labeled list
#: en/revisions.txt:50
#, ignore-same, no-wrap, priority:100
msgid "`HEAD`"
msgstr "`HEAD`"

#. type: Plain text
#: en/revisions.txt:52
#, no-wrap, priority:100
msgid "names the commit on which you based the changes in the working tree.\n"
msgstr "命名工作区中的更改所基于的提交。\n"

#. type: Labeled list
#: en/revisions.txt:52
#, ignore-same, no-wrap, priority:100
msgid "`FETCH_HEAD`"
msgstr "`FETCH_HEAD`"

#. type: Plain text
#: en/revisions.txt:55
#, no-wrap, priority:100
msgid ""
"records the branch which you fetched from a remote repository with\n"
"your last `git fetch` invocation.\n"
msgstr ""
"记录您上次调用 `git fetch` 时\n"
"从远程仓库获取的分支。\n"

#. type: Labeled list
#: en/revisions.txt:55
#, ignore-same, no-wrap, priority:100
msgid "`ORIG_HEAD`"
msgstr "`ORIG_HEAD`"

#. type: Plain text
#: en/revisions.txt:60
#, no-wrap, placeholders:'HEAD':'HEAD', priority:100
msgid ""
"is created by commands that move your `HEAD` in a drastic way (`git\n"
"am`, `git merge`, `git rebase`, `git reset`), to record the position\n"
"of the `HEAD` before their operation, so that you can easily change\n"
"the tip of the branch back to the state before you ran them.\n"
msgstr ""
"命令（`git am`、`git merge`、`git rebase`、`git reset`）时创建的，\n"
"用于记录这些命令执行前`HEAD`的位置，\n"
"以便于将分支的顶端\n"
"改回执行这些命令前的状态。\n"

#. type: Labeled list
#: en/revisions.txt:60
#, ignore-same, no-wrap, priority:100
msgid "`MERGE_HEAD`"
msgstr "`MERGE_HEAD`"

#. type: Plain text
#: en/revisions.txt:63
#, no-wrap, priority:100
msgid ""
"records the commit(s) which you are merging into your branch when you\n"
"run `git merge`.\n"
msgstr ""
"记录您在运行 `git merge` 时\n"
"要合并到分支中的提交。\n"

#. type: Labeled list
#: en/revisions.txt:63
#, ignore-same, no-wrap, priority:100
msgid "`REBASE_HEAD`"
msgstr "`REBASE_HEAD`"

#. type: Plain text
#: en/revisions.txt:67
#, no-wrap, priority:100
msgid ""
"during a rebase, records the commit at which the operation is\n"
"currently stopped, either because of conflicts or an `edit` command in\n"
"an interactive rebase.\n"
msgstr ""
"会记录当前停止操作的提交，\n"
"原因可能是冲突或\n"
"交互式变基中的 `edit` 命令。\n"

#. type: Labeled list
#: en/revisions.txt:67
#, ignore-same, no-wrap, priority:100
msgid "`REVERT_HEAD`"
msgstr "`REVERT_HEAD`"

#. type: Plain text
#: en/revisions.txt:69
#, no-wrap, priority:100
msgid "records the commit which you are reverting when you run `git revert`.\n"
msgstr "记录您在运行 `git revert` 时要还原的提交。\n"

#. type: Labeled list
#: en/revisions.txt:69
#, ignore-same, no-wrap, priority:100
msgid "`CHERRY_PICK_HEAD`"
msgstr "`CHERRY_PICK_HEAD`"

#. type: Plain text
#: en/revisions.txt:72
#, no-wrap, priority:100
msgid ""
"records the commit which you are cherry-picking when you run `git\n"
"cherry-pick`.\n"
msgstr ""
"会记录您在运行 `git cherry-pick` 时\n"
"要 cherry-pick 的提交。\n"

#. type: Labeled list
#: en/revisions.txt:72
#, ignore-same, no-wrap, priority:100
msgid "`BISECT_HEAD`"
msgstr "`BISECT_HEAD`"

#. type: Plain text
#: en/revisions.txt:75
#, no-wrap, placeholders:'--no-checkout`', priority:100
msgid ""
"records the current commit to be tested when you run `git bisect\n"
"--no-checkout`.\n"
msgstr ""
"记录运行 `git bisect --no-checkout` 时\n"
"要测试的当前提交。\n"

#. type: Labeled list
#: en/revisions.txt:75
#, ignore-same, no-wrap, priority:100
msgid "`AUTO_MERGE`"
msgstr "`AUTO_MERGE`"

#. type: Plain text
#: en/revisions.txt:79
#, no-wrap, priority:100
msgid ""
"records a tree object corresponding to the state the\n"
"'ort' merge strategy wrote to the working tree when a merge operation\n"
"resulted in conflicts.\n"
msgstr ""
"当合并操作导致冲突时，\n"
"记录与 'ort' 合并策略写入工作树的状态\n"
"相对应的树对象。\n"

#. type: Plain text
#: en/revisions.txt:85
#, placeholders:'$GIT_DIR':'$GIT_DIR', priority:100
msgid "Note that any of the 'refs/*' cases above may come either from the `$GIT_DIR/refs` directory or from the `$GIT_DIR/packed-refs` file. While the ref name encoding is unspecified, UTF-8 is preferred as some output processing may assume ref names in UTF-8."
msgstr "请注意，上述任何 'refs/*' 都可能来自 `$GIT_DIR/refs` 目录或 `$GIT_DIR/packed-refs` 文件。 虽然引用名称编码未指定，但 UTF-8 是首选，因为某些输出处理可能会假定引用名称为 UTF-8 编码。"

#. type: Labeled list
#: en/revisions.txt:86
#, no-wrap, priority:100
msgid "'@'"
msgstr "'@'"

#. type: Plain text
#: en/revisions.txt:88
#, placeholders:'HEAD', priority:100
msgid "'@' alone is a shortcut for `HEAD`."
msgstr "'@' 本身就是 `HEAD` 的快捷方式。"

#. type: Labeled list
#: en/revisions.txt:89
#, no-wrap, placeholders:'HEAD', priority:100
msgid "'[<refname>]@{<date>}', e.g. 'master@\\{yesterday\\}', 'HEAD@{5 minutes ago}'"
msgstr "'[<引用名>]@{<日期>}', 例如： 'master@\\{yesterday\\}', 'HEAD@{5 minutes ago}'"

#. type: Plain text
#: en/revisions.txt:100
#, placeholders:'$GIT_DIR':'`--since`':'`--until`', priority:100
msgid "A ref followed by the suffix '@' with a date specification enclosed in a brace pair (e.g. '\\{yesterday\\}', '{1 month 2 weeks 3 days 1 hour 1 second ago}' or '{1979-02-26 18:30:00}') specifies the value of the ref at a prior point in time. This suffix may only be used immediately following a ref name and the ref must have an existing log ('$GIT_DIR/logs/<ref>'). Note that this looks up the state of your *local* ref at a given time; e.g., what was in your local 'master' branch last week. If you want to look at commits made during certain times, see `--since` and `--until`."
msgstr "在后缀为'@' 的引用后，用一对括号括起来的日期说明（例如 '\\{yesterday/}'、'{1 个月 2 周 3 天 1 小时 1 秒前}' 或 '{1979-02-26 18:30:00}'）指定了引用在之前某个时间点的值。 该后缀只能紧跟在引用名称之后使用，且引用必须有现存日志（'$GIT_DIR/logs/<ref>'）。需要注意的是，这个后缀查找的是*本地*引用在给定时间内的状态；例如，上周本地 'master' 分支中的情况。如果要查看特定时间内的提交，请参阅 `--since` 和 `--until`。"

#. type: Labeled list
#: en/revisions.txt:101
#, no-wrap, priority:100
msgid "'<refname>@{<n>}', e.g. 'master@\\{1\\}'"
msgstr "'<引用名>@{<n>}', e.g. 'master@\\{1\\}'"

#. type: Plain text
#: en/revisions.txt:109
#, placeholders:'$GIT_DIR', priority:100
msgid "A ref followed by the suffix '@' with an ordinal specification enclosed in a brace pair (e.g. '\\{1\\}', '\\{15\\}') specifies the n-th prior value of that ref. For example 'master@\\{1\\}' is the immediate prior value of 'master' while 'master@\\{5\\}' is the 5th prior value of 'master'. This suffix may only be used immediately following a ref name and the ref must have an existing log ('$GIT_DIR/logs/<refname>')."
msgstr "在后缀为 '@' 的引用后，用一对括号（如 '\\{1\\}'、'\\{15\\}'）括起来的序号说明指定了该引用的 n 次先验值。 例如，'master@\\{1\\}' 是 'master' 的直接先验值，而 'master@\\{5\\}' 是 'master' 的第 5 个先验值。该后缀只能紧跟在引用名称之后使用，并且引用必须有现存日志（'$GIT_DIR/logs/<引用名>'）。"

#. type: Labeled list
#: en/revisions.txt:110
#, no-wrap, priority:100
msgid "'@{<n>}', e.g. '@\\{1\\}'"
msgstr "'@{<n>}', e.g. '@\\{1\\}'"

#. type: Plain text
#: en/revisions.txt:114
#, priority:100
msgid "You can use the '@' construct with an empty ref part to get at a reflog entry of the current branch. For example, if you are on branch 'blabla' then '@\\{1\\}' means the same as 'blabla@\\{1\\}'."
msgstr "你可以使用带有空引用部分的\"@\"结构来获取当前分支的引用日志条目。例如，如果你在分支 'blabla' 上，那么 '@\\{1\\}' 与 'blabla@\\{1\\}' 的意思相同。"

#. type: Labeled list
#: en/revisions.txt:115
#, no-wrap, placeholders:'{-1}', priority:100
msgid "'@{-<n>}', e.g. '@{-1}'"
msgstr "'@{-<n>}', e.g. '@{-1}'"

#. type: Plain text
#: en/revisions.txt:118
#, priority:100
msgid "The construct '@{-<n>}' means the <n>th branch/commit checked out before the current one."
msgstr "结构体 '@{-<n>}' 表示在当前分支/提交之前签出的第 <n> 个分支/提交。"

#. type: Labeled list
#: en/revisions.txt:119
#, no-wrap, priority:100
msgid "'[<branchname>]@\\{upstream\\}', e.g. 'master@\\{upstream\\}', '@\\{u\\}'"
msgstr "'[<分支名>]@\\{upstream\\}', e.g. 'master@\\{upstream\\}', '@\\{u\\}'"

#. type: Plain text
#: en/revisions.txt:124
#, placeholders:'{u}', priority:100
msgid "A branch B may be set up to build on top of a branch X (configured with `branch.<name>.merge`) at a remote R (configured with `branch.<name>.remote`). B@{u} refers to the remote-tracking branch for the branch X taken from remote R, typically found at `refs/remotes/R/X`."
msgstr "分支 B 可以设置为在远程 R 的分支 X（使用 `branch.<名称>.merge` 配置）（使用 `branch.<名称>.remote`配置）之上构建。B@{u} 指的是远程 R 分支 X 的远程跟踪分支，通常位于 `refs/remotes/R/X`。"

#. type: Labeled list
#: en/revisions.txt:125
#, no-wrap, priority:100
msgid "'[<branchname>]@\\{push\\}', e.g. 'master@\\{push\\}', '@\\{push\\}'"
msgstr "'[<分支名>]@\\{push\\}', e.g. 'master@\\{push\\}', '@\\{push\\}'"

#. type: Plain text
#: en/revisions.txt:130
#, placeholders:'{push}':'HEAD', priority:100
msgid "The suffix '@\\{push}' reports the branch \"where we would push to\" if `git push` were run while `branchname` was checked out (or the current `HEAD` if no branchname is specified). Like for '@\\{upstream\\}', we report the remote-tracking branch that corresponds to that branch at the remote."
msgstr "后缀 '@\\{push}' 报告的是在 `branchname` 签出时运行 `git push` 时 “我们会推送到哪里” 的分支（如果没有指定分支名，则报告当前的 `HEAD`）。就像 '@\\{upstream\\}' 一样，我们会报告与该分支相对应的远程跟踪分支。"

#. type: Plain text
#: en/revisions.txt:132
#, priority:100
msgid "Here's an example to make it more clear:"
msgstr "这里有一个例子，可以更清楚地说明这一点:"

#. type: delimited block -
#: en/revisions.txt:137
#, no-wrap, placeholders:'push.default':'remote.pushdefault', priority:100
msgid ""
"$ git config push.default current\n"
"$ git config remote.pushdefault myfork\n"
"$ git switch -c mybranch origin/master\n"
msgstr ""
"$ git config push.default current\n"
"$ git config remote.pushdefault myfork\n"
"$ git switch -c mybranch origin/master\n"

#. type: delimited block -
#: en/revisions.txt:140
#, no-wrap, placeholders:'git rev-parse':'--symbolic-full-name':'{upstream}', priority:100
msgid ""
"$ git rev-parse --symbolic-full-name @{upstream}\n"
"refs/remotes/origin/master\n"
msgstr ""
"$ git rev-parse --symbolic-full-name @{upstream}\n"
"refs/remotes/origin/master\n"

#. type: delimited block -
#: en/revisions.txt:143
#, no-wrap, placeholders:'git rev-parse':'--symbolic-full-name':'{push}', priority:100
msgid ""
"$ git rev-parse --symbolic-full-name @{push}\n"
"refs/remotes/myfork/mybranch\n"
msgstr ""
"$ git rev-parse --symbolic-full-name @{push}\n"
"refs/remotes/myfork/mybranch\n"

#. type: Plain text
#: en/revisions.txt:148
#, placeholders:'{push}':'{upstream}', priority:100
msgid "Note in the example that we set up a triangular workflow, where we pull from one location and push to another. In a non-triangular workflow, '@\\{push}' is the same as '@\\{upstream}', and there is no need for it."
msgstr "请注意，我们在示例中设置了一个三角工作流，即从一个位置提取数据，然后推送到另一个位置。在非三角工作流中，'@\\{push}' 与 '@\\{upstream}' 相同，没有必要使用。"

#. type: Plain text
#: en/revisions.txt:151
#, priority:100
msgid "This suffix is also accepted when spelled in uppercase, and means the same thing no matter the case."
msgstr "这个后缀用大写字母拼写时也被接受，无论大小写，意思都一样。"

#. type: Labeled list
#: en/revisions.txt:152
#, no-wrap, placeholders:'{caret}':'HEAD':'{caret}':'{caret}', priority:100
msgid "'<rev>{caret}[<n>]', e.g. 'HEAD{caret}, v1.5.1{caret}0'"
msgstr "'<修订号>{caret}[<n>]'，例如 'HEAD{caret}, v1.5.1{caret}0'"

#. type: Plain text
#: en/revisions.txt:159
#, placeholders:'{caret}':'{caret}':'{caret}':'{caret}':'{caret}', priority:100
msgid "A suffix '{caret}' to a revision parameter means the first parent of that commit object. '{caret}<n>' means the <n>th parent (i.e. '<rev>{caret}' is equivalent to '<rev>{caret}1'). As a special rule, '<rev>{caret}0' means the commit itself and is used when '<rev>' is the object name of a tag object that refers to a commit object."
msgstr "修订参数的后缀 '{caret}' 表示该提交对象的第一个父对象。 '{caret}<n>'表示第 <n> 个父提交（即 '<rev>{caret}' 等同于 '<rev>{caret}1'）。 作为一条特殊规则，'<rev>{caret}0' 表示提交本身，在 '<rev>' 是指向提交对象的标记对象的对象名时使用。"

#. type: Labeled list
#: en/revisions.txt:160
#, no-wrap, placeholders:'{tilde}':'HEAD':'{tilde}':'{tilde}', priority:100
msgid "'<rev>{tilde}[<n>]', e.g. 'HEAD{tilde}, master{tilde}3'"
msgstr "'<修订>{tilde}[<n>]', e.g. 'HEAD{tilde}, master{tilde}3'"

#. type: Plain text
#: en/revisions.txt:169
#, placeholders:'{tilde}':'{tilde}':'{tilde}':'{caret}':'{caret}':'{caret}':'{caret}':'{caret}':'{caret}', priority:100
msgid "A suffix '{tilde}' to a revision parameter means the first parent of that commit object. A suffix '{tilde}<n>' to a revision parameter means the commit object that is the <n>th generation ancestor of the named commit object, following only the first parents. I.e. '<rev>{tilde}3' is equivalent to '<rev>{caret}{caret}{caret}' which is equivalent to '<rev>{caret}1{caret}1{caret}1'. See below for an illustration of the usage of this form."
msgstr "修订参数的后缀 '{tilde}' 表示该提交对象的第一代父对象。 修订参数的后缀 '{tilde}<n>' 表示该提交对象的 <n> 代祖先，仅次于第一代父对象。 例如，'<rev>{tilde}3' 等同于 '<rev>{caret}{caret}{caret}'，后者等同于 '<rev>{caret}1{caret}1{caret}1'。 请参阅下面的示例，了解这种形式的用法。"

#. type: Labeled list
#: en/revisions.txt:170
#, no-wrap, placeholders:'{caret}':'{caret}', priority:100
msgid "'<rev>{caret}{<type>}', e.g. 'v0.99.8{caret}\\{commit\\}'"
msgstr "'<修订>{caret}{<类型>}', e.g. 'v0.99.8{caret}\\{commit\\}'"

#. type: Plain text
#: en/revisions.txt:181
#, placeholders:'{caret}':'{caret}':'{caret}':'{caret}':'{caret}', priority:100
msgid "A suffix '{caret}' followed by an object type name enclosed in brace pair means dereference the object at '<rev>' recursively until an object of type '<type>' is found or the object cannot be dereferenced anymore (in which case, barf). For example, if '<rev>' is a commit-ish, '<rev>{caret}\\{commit\\}' describes the corresponding commit object. Similarly, if '<rev>' is a tree-ish, '<rev>{caret}\\{tree\\}' describes the corresponding tree object. '<rev>{caret}0' is a short-hand for '<rev>{caret}\\{commit\\}'."
msgstr "后缀 '{caret}' 后跟有一对括号的对象类型名称，表示在 '<修订>' 处递归引用该对象，直到找到 '<类型>' 类型的对象或该对象无法再被引用（在这种情况下，barf）。 例如，如果 '<修订>' 是一个提交对象，那么 '<修订>{caret}/{commit/}' 就描述了相应的提交对象。 同样，如果 '<修订>' 是一个树对象，那么 '<修订>{caret}/{tree/}' 就描述了相应的树对象。 '<修订>{caret}0' 是 '<rev>{caret}/{commit/}' 的简写。"

#. type: Plain text
#: en/revisions.txt:186
#, placeholders:'{caret}', priority:100
msgid "'<rev>{caret}\\{object\\}' can be used to make sure '<rev>' names an object that exists, without requiring '<rev>' to be a tag, and without dereferencing '<rev>'; because a tag is already an object, it does not have to be dereferenced even once to get to an object."
msgstr "'<修订>{caret}/{object/}' 可以用来确保 '<修订>' 命名了一个存在的对象，而不要求 '<修订>' 是一个标记，也不需要取消引用 '<修订>'；因为一个标记已经是一个对象，所以即使取消引用一次也不一定能找到一个对象。"

#. type: Plain text
#: en/revisions.txt:189
#, placeholders:'{caret}', priority:100
msgid "'<rev>{caret}\\{tag\\}' can be used to ensure that '<rev>' identifies an existing tag object."
msgstr "可以使用 '<修订>{caret}/{tag\\}' 来确保 '<修订>' 标识现有的标记对象。"

#. type: Labeled list
#: en/revisions.txt:190
#, no-wrap, placeholders:'{caret}':'{caret}', priority:100
msgid "'<rev>{caret}{}', e.g. 'v0.99.8{caret}{}'"
msgstr "'<rev>{caret}{}', e.g. 'v0.99.8{caret}{}'"

#. type: Plain text
#: en/revisions.txt:195
#, placeholders:'{caret}', priority:100
msgid "A suffix '{caret}' followed by an empty brace pair means the object could be a tag, and dereference the tag recursively until a non-tag object is found."
msgstr "后缀 '{caret}' 后跟一个空括号对，表示该对象可能是一个标记，并递归引用该标记，直到找到一个非标记对象。"

#. type: Labeled list
#: en/revisions.txt:196
#, no-wrap, placeholders:'{caret}':'HEAD', priority:100
msgid "'<rev>{caret}{/<text>}', e.g. 'HEAD^{/fix nasty bug}'"
msgstr "'<修订>{caret}{/<文本>}'，例如 'HEAD^{/fix nasty bug（修复讨厌的 BUG）}'"

#. type: Plain text
#: en/revisions.txt:202
#, placeholders:'{caret}':'{caret}', priority:100
msgid "A suffix '{caret}' to a revision parameter, followed by a brace pair that contains a text led by a slash, is the same as the ':/fix nasty bug' syntax below except that it returns the youngest matching commit which is reachable from the '<rev>' before '{caret}'."
msgstr "版本参数的后缀 '{caret}'，后面是包含以斜线为首的文本的括号对，与下面的 ':/fix nasty bug' 语法相同，但它返回的是 '{caret}' 之前的 '<修订>' 中最年轻的匹配提交。"

#. type: Labeled list
#: en/revisions.txt:203
#, no-wrap, priority:100
msgid "':/<text>', e.g. ':/fix nasty bug'"
msgstr "':/<文本>'，例如 ':/fix nasty bug'"

#. type: Plain text
#: en/revisions.txt:216
#, placeholders:'HEAD', priority:100
msgid "A colon, followed by a slash, followed by a text, names a commit whose commit message matches the specified regular expression. This name returns the youngest matching commit which is reachable from any ref, including HEAD. The regular expression can match any part of the commit message. To match messages starting with a string, one can use e.g. ':/^foo'. The special sequence ':/!' is reserved for modifiers to what is matched. ':/!-foo' performs a negative match, while ':/!!foo' matches a literal '!' character, followed by 'foo'. Any other sequence beginning with ':/!' is reserved for now. Depending on the given text, the shell's word splitting rules might require additional quoting."
msgstr "冒号后的斜线和文本，用于命名提交信息与指定正则表达式匹配的提交。 该名称会返回可从任何引用（包括 HEAD）到达的最年轻的匹配提交。 正则表达式可以匹配提交信息的任何部分。要匹配以字符串开头的提交信息，可以使用 ':/^foo'。特殊序列 ':/!' 用于修饰匹配内容。':/!-foo' 执行负匹配，而 ':/!!foo' 则匹配字面意义上的 '!' 字符，后接 'foo'。以 ':/!' 开头的其他序列暂时保留。 根据给定的文本，shell 的分词规则可能需要额外的引号。"

#. type: Labeled list
#: en/revisions.txt:217
#, no-wrap, placeholders:'HEAD', priority:100
msgid "'<rev>:<path>', e.g. 'HEAD:README', 'master:./README'"
msgstr "'<修订>:<路径>'，例如 'HEAD:README', 'master:./README'"

#. type: Plain text
#: en/revisions.txt:225
#, priority:100
msgid "A suffix ':' followed by a path names the blob or tree at the given path in the tree-ish object named by the part before the colon. A path starting with './' or '../' is relative to the current working directory. The given path will be converted to be relative to the working tree's root directory. This is most useful to address a blob or tree from a commit or tree that has the same tree structure as the working tree."
msgstr "后缀 ':' 和路径会在冒号前的树状对象中命名给定路径上的 blob 或树。 以'./' 或 '../' 开头的路径是相对于当前工作目录的。 给定路径将转换为相对于工作树根目录的路径。 这对于从与工作树具有相同树形结构的提交或树中查找 blob 或树最为有用。"

#. type: Labeled list
#: en/revisions.txt:226
#, no-wrap, priority:100
msgid "':[<n>:]<path>', e.g. ':0:README', ':README'"
msgstr "':[<n>:]<路径>', e.g. ':0:README', ':README'"

#. type: Plain text
#: en/revisions.txt:234
#, priority:100
msgid "A colon, optionally followed by a stage number (0 to 3) and a colon, followed by a path, names a blob object in the index at the given path. A missing stage number (and the colon that follows it) names a stage 0 entry. During a merge, stage 1 is the common ancestor, stage 2 is the target branch's version (typically the current branch), and stage 3 is the version from the branch which is being merged."
msgstr "一个冒号（可选）后面跟一个阶段编号（0 至 3）和一个冒号，冒号后面跟一个路径，用于命名索引中位于给定路径的 Blob 对象。如果缺少阶段号（以及后面的冒号），则命名为阶段 0 条目。在合并过程中，阶段 1 是共同祖先，阶段 2 是目标分支的版本（通常是当前分支），阶段 3 是被合并分支的版本。"

#. type: Plain text
#: en/revisions.txt:238
#, priority:100
msgid "Here is an illustration, by Jon Loeliger. Both commit nodes B and C are parents of commit node A. Parent commits are ordered left-to-right."
msgstr "下面是 Jon Loeliger 绘制的一幅插图。 提交节点 B 和 C 都是提交节点 A 的父节点。 父提交从左到右排序。"

#. type: delimited block .
#: en/revisions.txt:250
#, no-wrap, priority:100
msgid ""
"G   H   I   J\n"
" \\ /     \\ /\n"
"  D   E   F\n"
"   \\  |  / \\\n"
"    \\ | /   |\n"
"     \\|/    |\n"
"      B     C\n"
"       \\   /\n"
"        \\ /\n"
"         A\n"
msgstr ""
"G   H   I   J\n"
" \\ /     \\ /\n"
"  D   E   F\n"
"   \\  |  / \\\n"
"    \\ | /   |\n"
"     \\|/    |\n"
"      B     C\n"
"       \\   /\n"
"        \\ /\n"
"         A\n"

#. type: Plain text
#: en/revisions.txt:262
#, no-wrap, priority:100
msgid ""
"    A =      = A^0\n"
"    B = A^   = A^1     = A~1\n"
"    C =      = A^2\n"
"    D = A^^  = A^1^1   = A~2\n"
"    E = B^2  = A^^2\n"
"    F = B^3  = A^^3\n"
"    G = A^^^ = A^1^1^1 = A~3\n"
"    H = D^2  = B^^2    = A^^^2  = A~2^2\n"
"    I = F^   = B^3^    = A^^3^\n"
"    J = F^2  = B^3^2   = A^^3^2\n"
msgstr ""
"    A =      = A^0\n"
"    B = A^   = A^1     = A~1\n"
"    C =      = A^2\n"
"    D = A^^  = A^1^1   = A~2\n"
"    E = B^2  = A^^2\n"
"    F = B^3  = A^^3\n"
"    G = A^^^ = A^1^1^1 = A~3\n"
"    H = D^2  = B^^2    = A^^^2  = A~2^2\n"
"    I = F^   = B^3^    = A^^3^\n"
"    J = F^2  = B^3^2   = A^^3^2\n"

#. type: Plain text
#: en/revisions.txt:269
#, priority:100
msgid "History traversing commands such as `git log` operate on a set of commits, not just a single commit."
msgstr "历史记录遍历命令，如 `git log` 会对一组提交进行操作，而不仅仅是单个提交。"

#. type: Plain text
#: en/revisions.txt:274
#, priority:100
msgid "For these commands, specifying a single revision, using the notation described in the previous section, means the set of commits `reachable` from the given commit."
msgstr "对于这些命令，使用上一节中描述的符号指定一个修订版本，意味着从给定的提交开始 `可达到` 的一组提交。"

#. type: Plain text
#: en/revisions.txt:277
#, priority:100
msgid "Specifying several revisions means the set of commits reachable from any of the given commits."
msgstr "指定多个修订版本指的是可从任何给定的提交版本到达的提交版本集。"

#. type: Plain text
#: en/revisions.txt:280
#, priority:100
msgid "A commit's reachable set is the commit itself and the commits in its ancestry chain."
msgstr "提交的可达集合是指提交本身及其祖先链中的提交。"

#. type: Plain text
#: en/revisions.txt:283
#, priority:100
msgid "There are several notations to specify a set of connected commits (called a \"revision range\"), illustrated below."
msgstr "有几种符号可以指定一组相连的提交（称为 “修订范围”），如下图所示。"

#. type: Title ~
#: en/revisions.txt:286
#, no-wrap, priority:100
msgid "Commit Exclusions"
msgstr "排除提交"

#. type: Labeled list
#: en/revisions.txt:288
#, no-wrap, placeholders:'{caret}', priority:100
msgid "'{caret}<rev>' (caret) Notation"
msgstr "'{caret}<修订号>'（catet）表示"

#. type: Plain text
#: en/revisions.txt:293
#, placeholders:'{caret}':'{caret}', priority:100
msgid "To exclude commits reachable from a commit, a prefix '{caret}' notation is used. E.g. '{caret}r1 r2' means commits reachable from 'r2' but exclude the ones reachable from 'r1' (i.e. 'r1' and its ancestors)."
msgstr "要排除某个提交中可触及的提交，可使用前缀 '{caret}' 表示。 例如，'{caret}r1 r2' 表示可从 'r2' 到达的提交，但不包括可从 'r1' 到达的提交（即 'r1' 及其祖先）。"

#. type: Title ~
#: en/revisions.txt:295
#, no-wrap, priority:100
msgid "Dotted Range Notations"
msgstr "虚线范围符号"

#. type: Labeled list
#: en/revisions.txt:297
#, no-wrap, priority:100
msgid "The '..' (two-dot) Range Notation"
msgstr "'..'（双点）范围符号"

#. type: Plain text
#: en/revisions.txt:303
#, placeholders:'{caret}':'{caret}', priority:100
msgid "The '{caret}r1 r2' set operation appears so often that there is a shorthand for it. When you have two commits 'r1' and 'r2' (named according to the syntax explained in SPECIFYING REVISIONS above), you can ask for commits that are reachable from r2 excluding those that are reachable from r1 by '{caret}r1 r2' and it can be written as 'r1..r2'."
msgstr "由于 '{caret}r1 r2' 的设置操作经常出现，所以有了一种速记方法。 当你有两个提交 'r1' 和 'r2'（根据上文 “指定修订” 中解释的语法命名）时，你可以通过 '{caret}r1 r2' 请求从 r2 可以访问的提交，但不包括从 r1 可以访问的提交，可以写成 'r1...r2'。"

#. type: Labeled list
#: en/revisions.txt:304
#, ignore-ellipsis, no-wrap, priority:100
msgid "The '\\...' (three-dot) Symmetric Difference Notation"
msgstr "'\\...'（三点）对称差符号"

#. type: Plain text
#: en/revisions.txt:310
#, ignore-ellipsis, placeholders:'--not':'git merge-base':'--all', priority:100
msgid "A similar notation 'r1\\...r2' is called symmetric difference of 'r1' and 'r2' and is defined as 'r1 r2 --not $(git merge-base --all r1 r2)'. It is the set of commits that are reachable from either one of 'r1' (left side) or 'r2' (right side) but not from both."
msgstr "类似的符号 'r1\\...r2' 被称为 'r1' 和 'r2' 的对称差值，定义为 'r1 r2 --not $(git merge-base --all r1 r2)'。 它是可以从 'r1'（左侧）或 'r2'（右侧）之一到达，但不能同时从两处到达的提交的集合。"

#. type: Plain text
#: en/revisions.txt:317
#, placeholders:'HEAD':'HEAD':'HEAD':'HEAD':'HEAD':'HEAD', priority:100
msgid "In these two shorthand notations, you can omit one end and let it default to HEAD. For example, 'origin..' is a shorthand for 'origin..HEAD' and asks \"What did I do since I forked from the origin branch?\" Similarly, '..origin' is a shorthand for 'HEAD..origin' and asks \"What did the origin do since I forked from them?\" Note that '..' would mean 'HEAD..HEAD' which is an empty range that is both reachable and unreachable from HEAD."
msgstr "在这两种速记符号中，你可以省略一端，让它默认为 HEAD。 例如，'origin..' 是 'origin..HEAD' 的简写，问的是 “我从起源分支分叉后做了什么？” 同样，'..origin' 是 'HEAD..origin' 的简写，问的是 “我从起源分支分叉后做了什么？” 请注意，'..' 指的是 'HEAD..HEAD'，它是一个空范围，既可从 HEAD 访问，也不可从 HEAD 访问。"

#. type: Plain text
#: en/revisions.txt:324
#, placeholders:'git range-diff', priority:100
msgid "Commands that are specifically designed to take two distinct ranges (e.g. \"git range-diff R1 R2\" to compare two ranges) do exist, but they are exceptions. Unless otherwise noted, all \"git\" commands that operate on a set of commits work on a single revision range. In other words, writing two \"two-dot range notation\" next to each other, e.g."
msgstr "也有专门针对两个不同范围的命令（例如 \"git range-diff R1 R2\"，用于比较两个范围），但它们都是例外。 除非另有说明，否则所有对一组提交进行操作的 \"git\" 命令都是针对单一修订范围的。 换句话说，将两个 “双点范围符号” 写在一起，例如。"

#. type: Plain text
#: en/revisions.txt:326
#, no-wrap, priority:100
msgid "    $ git log A..B C..D\n"
msgstr "    $ git log A..B C..D\n"

#. type: Plain text
#: en/revisions.txt:331
#, priority:100
msgid "does *not* specify two revision ranges for most commands. Instead it will name a single connected set of commits, i.e. those that are reachable from either B or D but are reachable from neither A or C. In a linear history like this:"
msgstr "*不* 会为大多数命令指定两个修订范围。 取而代之的是，它将命名单个相连的提交集，即那些从 B 或 D 可以到达，但从 A 或 C 都不能到达的提交集："

#. type: Plain text
#: en/revisions.txt:333
#, no-wrap, placeholders:'---A---B---o---o---C---D', priority:100
msgid "    ---A---B---o---o---C---D\n"
msgstr "    ---A---B---o---o---C---D\n"

#. type: Plain text
#: en/revisions.txt:336
#, priority:100
msgid "because A and B are reachable from C, the revision range specified by these two dotted ranges is a single commit D."
msgstr "因为 A 和 B 可以从 C 处到达，所以这两个虚线范围指定的修订范围是单一的提交 D。"

#. type: Title ~
#: en/revisions.txt:339
#, no-wrap, placeholders:'{caret}', priority:100
msgid "Other <rev>{caret} Parent Shorthand Notations"
msgstr "其他 <修订号>{caret}父级速记符号"

#. type: Plain text
#: en/revisions.txt:342
#, priority:100
msgid "Three other shorthands exist, particularly useful for merge commits, for naming a set that is formed by a commit and its parent commits."
msgstr "还有其他三种简称，特别适用于合并提交，用于命名由提交及其父提交组成的集合。"

#. type: Plain text
#: en/revisions.txt:344
#, placeholders:'{caret}', priority:100
msgid "The 'r1{caret}@' notation means all parents of 'r1'."
msgstr "'r1{caret}@' 表示 'r1' 的所有父代。"

#. type: Plain text
#: en/revisions.txt:347
#, placeholders:'{caret}', priority:100
msgid "The 'r1{caret}!' notation includes commit 'r1' but excludes all of its parents. By itself, this notation denotes the single commit 'r1'."
msgstr "'r1{caret}!' 表示包含提交 'r1'，但不包括其所有父提交。 就其本身而言，该符号表示单个提交 'r1'。"

#. type: Plain text
#: en/revisions.txt:354
#, placeholders:'{caret}':'{caret}':'{caret}', priority:100
msgid "The '<rev>{caret}-[<n>]' notation includes '<rev>' but excludes the <n>th parent (i.e. a shorthand for '<rev>{caret}<n>..<rev>'), with '<n>' = 1 if not given. This is typically useful for merge commits where you can just pass '<commit>{caret}-' to get all the commits in the branch that was merged in merge commit '<commit>' (including '<commit>' itself)."
msgstr "'<修订号>{caret}-[<n>]' 符号包括 '<修订号>' ，但不包括第 <n> 次父提交（即 '<修订号>{caret}<n>..<修订号>' 的速记形式），如果没有给出，则 '<n>'= 1。这对合并提交非常有用，只需传递 '<提交号>{caret}-'，就能获得在合并提交 '<提交号>' 中被合并的分支的所有提交（包括 '<提交号>' 本身）。"

#. type: Plain text
#: en/revisions.txt:358
#, placeholders:'{caret}':'HEAD':'{caret}':'{caret}':'HEAD':'{caret}':'{caret}', priority:100
msgid "While '<rev>{caret}<n>' was about specifying a single commit parent, these three notations also consider its parents. For example you can say 'HEAD{caret}2{caret}@', however you cannot say 'HEAD{caret}@{caret}2'."
msgstr "虽然 '<修订号>{caret}<n>' 是指定单个提交的父提交，但这三种符号也会考虑其父提交。例如，你可以说 'HEAD{caret}2{caret}@'，但不能说 'HEAD{caret}@{caret}2'。"

#. type: Title -
#: en/revisions.txt:360
#, no-wrap, priority:100
msgid "Revision Range Summary"
msgstr "修订范围摘要"

#. type: Labeled list
#: en/revisions.txt:362
#, no-wrap, priority:100
msgid "'<rev>'"
msgstr "'<rev>'"

#. type: Plain text
#: en/revisions.txt:365
#, priority:100
msgid "Include commits that are reachable from <rev> (i.e. <rev> and its ancestors)."
msgstr "包括可从 <修订号> 到达的提交（即 <修订号> 及其祖先）。"

#. type: Labeled list
#: en/revisions.txt:366
#, no-wrap, placeholders:'{caret}', priority:100
msgid "'{caret}<rev>'"
msgstr "'{caret}<修订号>'"

#. type: Plain text
#: en/revisions.txt:369
#, priority:100
msgid "Exclude commits that are reachable from <rev> (i.e. <rev> and its ancestors)."
msgstr "排除可从 <修订号> 到达的提交（即 <修订号> 及其祖先）。"

#. type: Labeled list
#: en/revisions.txt:370
#, no-wrap, priority:100
msgid "'<rev1>..<rev2>'"
msgstr "'<rev1>..<rev2>'"

#. type: Plain text
#: en/revisions.txt:374
#, placeholders:'HEAD', priority:100
msgid "Include commits that are reachable from <rev2> but exclude those that are reachable from <rev1>. When either <rev1> or <rev2> is omitted, it defaults to `HEAD`."
msgstr "包括可从 <修订号2> 进入的提交，但不包括可从 <修订号1> 进入的提交。 如果省略 <修订号1> 或 <修订号2>，则默认为 `HEAD`。"

#. type: Labeled list
#: en/revisions.txt:375
#, ignore-ellipsis, no-wrap, priority:100
msgid "'<rev1>\\...<rev2>'"
msgstr "'<修订号1>\\...<修订号2>'"

#. type: Plain text
#: en/revisions.txt:379
#, placeholders:'HEAD', priority:100
msgid "Include commits that are reachable from either <rev1> or <rev2> but exclude those that are reachable from both. When either <rev1> or <rev2> is omitted, it defaults to `HEAD`."
msgstr "包括 <修订号1> 或 <修订号2> 均可访问的提交，但不包括 <修订号1> 和 <修订号2> 均可访问的提交。 省略 <修订号1> 或 <修订号2> 时，默认为 `HEAD`。"

#. type: Labeled list
#: en/revisions.txt:380
#, no-wrap, placeholders:'{caret}':'HEAD':'{caret}', priority:100
msgid "'<rev>{caret}@', e.g. 'HEAD{caret}@'"
msgstr "'<修订>{caret}@', e.g. 'HEAD{caret}@'"

#. type: Plain text
#: en/revisions.txt:384
#, placeholders:'{caret}', priority:100
msgid "A suffix '{caret}' followed by an at sign is the same as listing all parents of '<rev>' (meaning, include anything reachable from its parents, but not the commit itself)."
msgstr "后缀 '{caret}' 后跟一个 at(@) 符号，就等于列出了 '<修订号>' 的所有父提交（意思是，包括父提交中可触及的任何内容，但不包括提交本身）。"

#. type: Labeled list
#: en/revisions.txt:385
#, no-wrap, placeholders:'{caret}':'HEAD':'{caret}', priority:100
msgid "'<rev>{caret}!', e.g. 'HEAD{caret}!'"
msgstr "'<修订号>{caret}!'，例如 'HEAD{caret}!'"

#. type: Plain text
#: en/revisions.txt:389
#, placeholders:'{caret}':'{caret}', priority:100
msgid "A suffix '{caret}' followed by an exclamation mark is the same as giving commit '<rev>' and all its parents prefixed with '{caret}' to exclude them (and their ancestors)."
msgstr "带感叹号的后缀 '{caret}' 与提交 '<修订号>' 及其所有前缀为 '{caret}' 的父节点相同，都是为了排除它们（及其祖先）。"

#. type: Labeled list
#: en/revisions.txt:390
#, no-wrap, placeholders:'{caret}':'HEAD':'{caret}':'HEAD':'{caret}', priority:100
msgid "'<rev>{caret}-<n>', e.g. 'HEAD{caret}-, HEAD{caret}-2'"
msgstr "'<修订号>{caret}-<n>'，例如 'HEAD{caret}-, HEAD{caret}-2'"

#. type: Plain text
#: en/revisions.txt:393
#, placeholders:'{caret}', priority:100
msgid "Equivalent to '<rev>{caret}<n>..<rev>', with '<n>' = 1 if not given."
msgstr "等价于 '<修订号>{caret}<n>..<修订号>'，如果未给出，则 '<n>'= 1。"

#. type: Plain text
#: en/revisions.txt:397
#, priority:100
msgid "Here are a handful of examples using the Loeliger illustration above, with each step in the notation's expansion and selection carefully spelt out:"
msgstr "下面是一些使用上述 Loeliger 插图的示例，其中仔细说明了符号扩展和选择的每个步骤："

#. type: delimited block .
#: en/revisions.txt:421
#, ignore-ellipsis, no-wrap, priority:100
msgid ""
"   Args   Expanded arguments    Selected commits\n"
"   D                            G H D\n"
"   D F                          G H I J D F\n"
"   ^G D                         H D\n"
"   ^D B                         E I J F B\n"
"   ^D B C                       E I J F B C\n"
"   C                            I J F C\n"
"   B..C   = ^B C                C\n"
"   B...C  = B ^F C              G H D E B C\n"
"   B^-    = B^..B\n"
"\t  = ^B^1 B              E I J F B\n"
"   C^@    = C^1\n"
"\t  = F                   I J F\n"
"   B^@    = B^1 B^2 B^3\n"
"\t  = D E F               D G H E F I J\n"
"   C^!    = C ^C^@\n"
"\t  = C ^C^1\n"
"\t  = C ^F                C\n"
"   B^!    = B ^B^@\n"
"\t  = B ^B^1 ^B^2 ^B^3\n"
"\t  = B ^D ^E ^F          B\n"
"   F^! D  = F ^I ^J D           G H D F\n"
msgstr ""
"   参数   扩展参数    选定的提交\n"
"   D                            G H D\n"
"   D F                          G H I J D F\n"
"   ^G D                         H D\n"
"   ^D B                         E I J F B\n"
"   ^D B C                       E I J F B C\n"
"   C                            I J F C\n"
"   B..C   = ^B C                C\n"
"   B...C  = B ^F C              G H D E B C\n"
"   B^-    = B^..B\n"
"\t  = ^B^1 B              E I J F B\n"
"   C^@    = C^1\n"
"\t  = F                   I J F\n"
"   B^@    = B^1 B^2 B^3\n"
"\t  = D E F               D G H E F I J\n"
"   C^!    = C ^C^@\n"
"\t  = C ^C^1\n"
"\t  = C ^F                C\n"
"   B^!    = B ^B^@\n"
"\t  = B ^B^1 ^B^2 ^B^3\n"
"\t  = B ^D ^E ^F          B\n"
"   F^! D  = F ^I ^J D           G H D F\n"

#. type: Plain text
#: en/rev-list-description.txt:5
#, placeholders:'{caret}', priority:260
msgid "List commits that are reachable by following the `parent` links from the given commit(s), but exclude commits that are reachable from the one(s) given with a '{caret}' in front of them. The output is given in reverse chronological order by default."
msgstr "列出可以从给定的提交中通过 \"父 \"链接到达的提交，但不包括可以从前面有\"{caret}\"的提交中到达的提交。 默认情况下，输出结果是按时间顺序倒置的。"

#. type: Plain text
#: en/rev-list-description.txt:12
#, placeholders:'{caret}', priority:260
msgid "You can think of this as a set operation. Commits reachable from any of the commits given on the command line form a set, and then commits reachable from any of the ones given with '{caret}' in front are subtracted from that set. The remaining commits are what comes out in the command's output. Various other options and paths parameters can be used to further limit the result."
msgstr "你可以把它看成是一个集合操作。从命令行上给出的任何一个提交中可以到达的提交形成一个集合，然后从这个集合中减去任何一个前面带有'{caret}'的提交。 剩下的提交内容就是命令的输出结果。 其他各种选项和路径参数也可以用来进一步限制结果。"

#. type: Plain text
#: en/rev-list-description.txt:14
#, priority:260
msgid "Thus, the following command:"
msgstr "因此，可以执行以下命令："

#. type: delimited block -
#: en/rev-list-description.txt:18
#, no-wrap, placeholders:'git rev-list', priority:260
msgid "$ git rev-list foo bar ^baz\n"
msgstr "$ git rev-list foo bar ^baz\n"

#. type: delimited block -
#: en/rev-list-description.txt:23
#, no-wrap, priority:260
msgid "$ git log foo bar ^baz\n"
msgstr "$ git log foo bar ^baz\n"

#. type: Plain text
#: en/rev-list-description.txt:28
#, priority:260
msgid "means \"list all the commits which are reachable from 'foo' or 'bar', but not from 'baz'\"."
msgstr "意思是 \"列出所有可以从'foo'或'bar'，但不能从'baz'到达的提交\"。"

#. type: Plain text
#: en/rev-list-description.txt:32
#, priority:260
msgid "A special notation \"'<commit1>'..'<commit2>'\" can be used as a short-hand for \"^'<commit1>' '<commit2>'\". For example, either of the following may be used interchangeably:"
msgstr "一个特殊的符号 \"'<提交 1>'...'<提交 2>'\" 可以作为 \"^'<提交 1>' '<提交 2>'\" 的简称。例如，以下两种情况可以互换使用："

#. type: delimited block -
#: en/rev-list-description.txt:37
#, no-wrap, placeholders:'git rev-list':'HEAD':'git rev-list':'HEAD', priority:260
msgid ""
"$ git rev-list origin..HEAD\n"
"$ git rev-list HEAD ^origin\n"
msgstr ""
"$ git rev-list origin..HEAD\n"
"$ git rev-list HEAD ^origin\n"

#. type: delimited block -
#: en/rev-list-description.txt:43
#, no-wrap, placeholders:'HEAD':'HEAD', priority:260
msgid ""
"$ git log origin..HEAD\n"
"$ git log HEAD ^origin\n"
msgstr ""
"$ git log origin..HEAD\n"
"$ git log HEAD ^origin\n"

#. type: Plain text
#: en/rev-list-description.txt:49
#, ignore-ellipsis, priority:260
msgid "Another special notation is \"'<commit1>'...'<commit2>'\" which is useful for merges. The resulting set of commits is the symmetric difference between the two operands. The following two commands are equivalent:"
msgstr "另一个特殊的符号是 \"'<提交 1>'...'<提交 2>'\"，对合并很有用。 由此产生的提交集合是两个操作数之间的对称差。 以下两个命令是等价的："

#. type: delimited block -
#: en/rev-list-description.txt:54
#, ignore-ellipsis, no-wrap, placeholders:'git rev-list':'--not':'git merge-base':'--all':'git rev-list', priority:260
msgid ""
"$ git rev-list A B --not $(git merge-base --all A B)\n"
"$ git rev-list A...B\n"
msgstr ""
"$ git rev-list A B --not $(git merge-base --all A B)\n"
"$ git rev-list A...B\n"

#. type: delimited block -
#: en/rev-list-description.txt:60
#, ignore-ellipsis, no-wrap, placeholders:'--not':'git merge-base':'--all', priority:260
msgid ""
"$ git log A B --not $(git merge-base --all A B)\n"
"$ git log A...B\n"
msgstr ""
"$ git log A B --not $(git merge-base --all A B)\n"
"$ git log A...B\n"

#. type: Title ~
#: en/rev-list-options.txt:2
#, no-wrap, priority:260
msgid "Commit Limiting"
msgstr "承诺限制"

#. type: Plain text
#: en/rev-list-options.txt:7
#, priority:260
msgid "Besides specifying a range of commits that should be listed using the special notations explained in the description, additional commit limiting may be applied."
msgstr "除了使用描述中解释的特殊符号指定应列出的提交范围，还可以应用额外的提交限制。"

#. type: Plain text
#: en/rev-list-options.txt:12
#, placeholders:'`--since=':'`--grep=', priority:260
msgid "Using more options generally further limits the output (e.g. `--since=<date1>` limits to commits newer than `<date1>`, and using it with `--grep=<pattern>` further limits to commits whose log message has a line that matches `<pattern>`), unless otherwise noted."
msgstr "使用更多的选项通常会进一步限制输出（例如，`--since=<date1>`限制在比`<date1>`新的提交，与`--grep=<pattern>`一起使用会进一步限制在日志信息中有一行符合`<pattern>`的提交），除非另有说明。"

# ERROR: --reverse not found in translation
#. type: Plain text
#: en/rev-list-options.txt:15
#, placeholders:'`--reverse`', priority:260
msgid "Note that these are applied before commit ordering and formatting options, such as `--reverse`."
msgstr "请注意，这些都是在提交排序和格式化选项之前应用的，如 `--reverse`。"

#. type: Labeled list
#: en/rev-list-options.txt:17
#, no-wrap, priority:260
msgid "-n <number>"
msgstr "-n <数量>"

#. type: Labeled list
#: en/rev-list-options.txt:18
#, no-wrap, placeholders:'--max-count=', priority:260
msgid "--max-count=<number>"
msgstr "--max-count=<数量>"

#. type: Plain text
#: en/rev-list-options.txt:20
#, priority:260
msgid "Limit the number of commits to output."
msgstr "限制输出的提交数量。"

#. type: Labeled list
#: en/rev-list-options.txt:21
#, no-wrap, placeholders:'--skip=', priority:260
msgid "--skip=<number>"
msgstr "--skip=<数量>"

#. type: Plain text
#: en/rev-list-options.txt:23
#, priority:260
msgid "Skip 'number' commits before starting to show the commit output."
msgstr "在开始显示提交输出之前，跳过'数'的提交。"

#. type: Labeled list
#: en/rev-list-options.txt:24
#, no-wrap, placeholders:'--since=', priority:260
msgid "--since=<date>"
msgstr "--since=<日期>"

#. type: Labeled list
#: en/rev-list-options.txt:25
#, no-wrap, placeholders:'--after=', priority:260
msgid "--after=<date>"
msgstr "--after=<日期>"

#. type: Plain text
#: en/rev-list-options.txt:27
#, priority:260
msgid "Show commits more recent than a specific date."
msgstr "显示比某一特定日期更近的提交。"

# ERROR: --since-as-filter= not found in translation
#. type: Labeled list
#: en/rev-list-options.txt:28
#, no-wrap, placeholders:'--since-as-filter=', priority:260
msgid "--since-as-filter=<date>"
msgstr "--since-as-filter=<日期>"

#. type: Plain text
#: en/rev-list-options.txt:32
#, priority:260
msgid "Show all commits more recent than a specific date. This visits all commits in the range, rather than stopping at the first commit which is older than a specific date."
msgstr "显示所有比指定日期更近的提交。这将访问该范围内的所有提交，而不是停在第一个比指定日期更早的提交。"

#. type: Labeled list
#: en/rev-list-options.txt:33
#, no-wrap, placeholders:'--until=', priority:260
msgid "--until=<date>"
msgstr "--until=<日期>"

#. type: Labeled list
#: en/rev-list-options.txt:34
#, no-wrap, placeholders:'--before=', priority:260
msgid "--before=<date>"
msgstr "--before=<日期>"

#. type: Plain text
#: en/rev-list-options.txt:36
#, priority:260
msgid "Show commits older than a specific date."
msgstr "显示超过特定日期的提交。"

#. type: Labeled list
#: en/rev-list-options.txt:38
#, no-wrap, placeholders:'--max-age=', priority:260
msgid "--max-age=<timestamp>"
msgstr "--max-age=<时间戳>"

#. type: Labeled list
#: en/rev-list-options.txt:39
#, no-wrap, placeholders:'--min-age=', priority:260
msgid "--min-age=<timestamp>"
msgstr "--min-age=<时间戳>"

#. type: Plain text
#: en/rev-list-options.txt:41
#, priority:260
msgid "Limit the commits output to specified time range."
msgstr "将提交的结果限制在指定的时间范围内。"

#. type: Labeled list
#: en/rev-list-options.txt:43
#, no-wrap, placeholders:'--author=', priority:260
msgid "--author=<pattern>"
msgstr "--author=<模式>"

#. type: Labeled list
#: en/rev-list-options.txt:44
#, no-wrap, placeholders:'--committer=', priority:260
msgid "--committer=<pattern>"
msgstr "--committer=<模式>"

#. type: Plain text
#: en/rev-list-options.txt:50
#, placeholders:'`--author=':'`--committer=', priority:260
msgid "Limit the commits output to ones with author/committer header lines that match the specified pattern (regular expression). With more than one `--author=<pattern>`, commits whose author matches any of the given patterns are chosen (similarly for multiple `--committer=<pattern>`)."
msgstr "将提交文件的输出限制在作者/提交人标题行符合指定模式（正则表达式）的文件。 如果有多个`--author=<pattern>`，则会选择作者符合任何一个给定模式的提交（对于多个`--committer=<pattern>`也是如此）。"

#. type: Labeled list
#: en/rev-list-options.txt:51
#, no-wrap, placeholders:'--grep-reflog=', priority:260
msgid "--grep-reflog=<pattern>"
msgstr "--grep-reflog=<模式>"

#. type: Plain text
#: en/rev-list-options.txt:57
#, placeholders:'`--grep-reflog`':'`--walk-reflogs`', priority:260
msgid "Limit the commits output to ones with reflog entries that match the specified pattern (regular expression). With more than one `--grep-reflog`, commits whose reflog message matches any of the given patterns are chosen. It is an error to use this option unless `--walk-reflogs` is in use."
msgstr "将提交文件的输出限制在有符合指定模式（正则表达式）的reflog条目的提交文件。如果有多个 `--grep-reflog`，则会选择那些 reflog 信息符合任何指定模式的提交。 除非使用了`--walk-reflogs`，否则使用此选项是错误的。"

#. type: Labeled list
#: en/rev-list-options.txt:58
#, no-wrap, placeholders:'--grep=', priority:260
msgid "--grep=<pattern>"
msgstr "--grep=<模式>"

#. type: Plain text
#: en/rev-list-options.txt:64
#, placeholders:'`--grep=':'`--all-match`', priority:260
msgid "Limit the commits output to ones with a log message that matches the specified pattern (regular expression). With more than one `--grep=<pattern>`, commits whose message matches any of the given patterns are chosen (but see `--all-match`)."
msgstr "将提交结果限制在日志信息与指定模式（正则表达式）相匹配的提交。 如果有多个 `--grep=<模式>`，则会选择那些日志信息与任何指定模式相匹配的提交（但见 `--all-match`）。"

# ERROR: --notes not found in translation
#. type: Plain text
#: en/rev-list-options.txt:68
#, placeholders:'`--notes`', priority:260
msgid "When `--notes` is in effect, the message from the notes is matched as if it were part of the log message."
msgstr "当 `--notes` 生效时，笔记中的信息被匹配，就像它是日志信息的一部分。"

#. type: Plain text
#: en/rev-list-options.txt:73
#, placeholders:'`--grep`', priority:260
msgid "Limit the commits output to ones that match all given `--grep`, instead of ones that match at least one."
msgstr "将输出的提交限制在符合所有给定`--grep`的提交，而不是至少符合一个的提交。"

#. type: Labeled list
#: en/rev-list-options.txt:74
#, ignore-same, no-wrap, priority:260
msgid "--invert-grep"
msgstr "--invert-grep"

#. type: Plain text
#: en/rev-list-options.txt:77
#, placeholders:'`--grep=', priority:260
msgid "Limit the commits output to ones with a log message that do not match the pattern specified with `--grep=<pattern>`."
msgstr "限定输出的提交信息与 `--grep=<模式>`指定的模式不匹配。"

#. type: Labeled list
#: en/rev-list-options.txt:79
#, ignore-same, no-wrap, priority:260
msgid "--regexp-ignore-case"
msgstr "--regexp-ignore-case"

#. type: Plain text
#: en/rev-list-options.txt:82
#, priority:260
msgid "Match the regular expression limiting patterns without regard to letter case."
msgstr "匹配正则表达式的限制模式，不考虑字母大小写。"

#. type: Plain text
#: en/rev-list-options.txt:86
#, priority:260
msgid "Consider the limiting patterns to be basic regular expressions; this is the default."
msgstr "将限制性模式视为基本的正则表达式；这是默认的。"

#. type: Plain text
#: en/rev-list-options.txt:91
#, priority:260
msgid "Consider the limiting patterns to be extended regular expressions instead of the default basic regular expressions."
msgstr "将限制性模式视为扩展的正则表达式，而不是默认的基本正则表达式。"

#. type: Plain text
#: en/rev-list-options.txt:96
#, priority:260
msgid "Consider the limiting patterns to be fixed strings (don't interpret pattern as a regular expression)."
msgstr "将限制性模式视为固定字符串（不要将模式解释为正则表达式）。"

#. type: Plain text
#: en/rev-list-options.txt:101
#, priority:260
msgid "Consider the limiting patterns to be Perl-compatible regular expressions."
msgstr "将限制性模式视为与Perl兼容的正则表达式。"

#. type: Labeled list
#: en/rev-list-options.txt:106
#, ignore-same, no-wrap, priority:260
msgid "--remove-empty"
msgstr "--remove-empty"

#. type: Plain text
#: en/rev-list-options.txt:108
#, priority:260
msgid "Stop when a given path disappears from the tree."
msgstr "当一个给定的路径从树上消失时停止。"

#. type: Labeled list
#: en/rev-list-options.txt:109
#, ignore-same, no-wrap, priority:260
msgid "--merges"
msgstr "--merges"

#. type: Plain text
#: en/rev-list-options.txt:111
#, placeholders:'`--min-parents=2`', priority:260
msgid "Print only merge commits. This is exactly the same as `--min-parents=2`."
msgstr "只打印合并后的提交。这与`--min-parents=2`完全相同。"

#. type: Labeled list
#: en/rev-list-options.txt:112
#, ignore-same, no-wrap, priority:260
msgid "--no-merges"
msgstr "--no-merges"

#. type: Plain text
#: en/rev-list-options.txt:115
#, placeholders:'`--max-parents=1`', priority:260
msgid "Do not print commits with more than one parent. This is exactly the same as `--max-parents=1`."
msgstr "不打印有一个以上父级的提交。这与`--max-parents=1`完全相同。"

#. type: Labeled list
#: en/rev-list-options.txt:116
#, no-wrap, placeholders:'--min-parents=', priority:260
msgid "--min-parents=<number>"
msgstr "--min-parents=<数量>"

#. type: Labeled list
#: en/rev-list-options.txt:117
#, no-wrap, placeholders:'--max-parents=', priority:260
msgid "--max-parents=<number>"
msgstr "--max-parents=<数量>"

#. type: Labeled list
#: en/rev-list-options.txt:118
#, ignore-same, no-wrap, priority:260
msgid "--no-min-parents"
msgstr "--no-min-parents"

#. type: Labeled list
#: en/rev-list-options.txt:119
#, ignore-same, no-wrap, priority:260
msgid "--no-max-parents"
msgstr "--no-max-parents"

#. type: Plain text
#: en/rev-list-options.txt:124
#, placeholders:'`--max-parents=1`':'`--no-merges`':'`--min-parents=2`':'`--merges`':'`--max-parents=0`':'`--min-parents=3`', priority:260
msgid "Show only commits which have at least (or at most) that many parent commits. In particular, `--max-parents=1` is the same as `--no-merges`, `--min-parents=2` is the same as `--merges`. `--max-parents=0` gives all root commits and `--min-parents=3` all octopus merges."
msgstr "只显示至少（或最多）有那么多父提交的提交。特别是，`--max-parents=1`等同于`--no-merges`，`--min-parents=2`等同于`--merges`。 `--max-parents=0`给出所有根提交，`--min-parents=3`给出所有章鱼合并。"

# ERROR: --no-min-parents not found in translation
# ERROR: --no-max-parents not found in translation
# ERROR: --max-parents=-1 not found in translation
#. type: Plain text
#: en/rev-list-options.txt:128
#, placeholders:'`--no-min-parents`':'`--no-max-parents`':'`--min-parents=0`':'`--max-parents=-1`', priority:260
msgid "`--no-min-parents` and `--no-max-parents` reset these limits (to no limit) again. Equivalent forms are `--min-parents=0` (any commit has 0 or more parents) and `--max-parents=-1` (negative numbers denote no upper limit)."
msgstr "`--no-min-parents` 和 `--no-max-parents` 会再次重置这些限制（为无限制）。 等价形式是 `--min-parents=0`（任何提交都有 0 个或更多父代）和 `--max-parents=-1`（负数表示无上限）。"

#. type: Plain text
#: en/rev-list-options.txt:138
#, priority:260
msgid "When finding commits to include, follow only the first parent commit upon seeing a merge commit. This option can give a better overview when viewing the evolution of a particular topic branch, because merges into a topic branch tend to be only about adjusting to updated upstream from time to time, and this option allows you to ignore the individual commits brought in to your history by such a merge."
msgstr "查找要包含的提交时，在看到合并提交时只跟随第一个父提交。 在查看某个特性分支的演变时，该选项可以提供更好的概览，因为合并到特性分支往往只是为了不时地适应上游的更新，而该选项可以让你忽略由合并带来的历史中的单个提交。"

# ERROR: `--diff-merges=first-parent` not found in translation
#. type: Plain text
#: en/rev-list-options.txt:142
#, placeholders:'`--diff-merges=first-parent`', priority:260
msgid "This option also changes default diff format for merge commits to `first-parent`, see `--diff-merges=first-parent` for details."
msgstr "这个选项也改变了合并提交的默认差异格式为 `first-parent`，详见 `--diff-merges=first-parent`。"

#. type: Labeled list
#: en/rev-list-options.txt:144
#, ignore-same, no-wrap, priority:260
msgid "--exclude-first-parent-only"
msgstr "--exclude-first-parent-only"

#. type: Plain text
#: en/rev-list-options.txt:150
#, placeholders:'{caret}', priority:260
msgid "When finding commits to exclude (with a '{caret}'), follow only the first parent commit upon seeing a merge commit. This can be used to find the set of changes in a topic branch from the point where it diverged from the remote branch, given that arbitrary merges can be valid topic branch changes."
msgstr "在寻找要排除的提交（用'{caret}'）时，在看到合并提交时只跟随第一个父提交。 考虑到任意的合并都可以成为有效的主题分支变化，这可以用来查找主题分支中从它与远程分支的分歧点开始的变化集合。"

#. type: Plain text
#: en/rev-list-options.txt:158
#, placeholders:'{caret}':'`--not`':'--stdin', priority:260
msgid "Reverses the meaning of the '{caret}' prefix (or lack thereof) for all following revision specifiers, up to the next `--not`. When used on the command line before --stdin, the revisions passed through stdin will not be affected by it. Conversely, when passed via standard input, the revisions passed on the command line will not be affected by it."
msgstr "反转 '{caret}' 前缀（或无前缀）对后面所有版本说明符的意义，直到下一个 `--not`。 在 --stdin 之前的命令行中使用时，通过标准输入流传递的修订版本不会受其影响。反之，通过标准输入传递时，命令行上传递的修订版本也不会受其影响。"

#. type: Plain text
#: en/rev-list-options.txt:162
#, placeholders:'HEAD', priority:260
msgid "Pretend as if all the refs in `refs/`, along with `HEAD`, are listed on the command line as '<commit>'."
msgstr "假设`refs/`中的所有参考文献，连同`HEAD`一起，在命令行中被列为'<commit>'。"

#. type: Labeled list
#: en/rev-list-options.txt:163
#, no-wrap, placeholders:'--branches', priority:260
msgid "--branches[=<pattern>]"
msgstr "--branches[=<模式>]"

#. type: Plain text
#: en/rev-list-options.txt:168
#, placeholders:'{asterisk}':'{asterisk}', priority:260
msgid "Pretend as if all the refs in `refs/heads` are listed on the command line as '<commit>'. If '<pattern>' is given, limit branches to ones matching given shell glob. If pattern lacks '?', '{asterisk}', or '[', '/{asterisk}' at the end is implied."
msgstr "假设`refs/heads`中的所有 refs 在命令行中被列为 '<commit>'。如果给出了'<pattern>'，将分支限制在与给定的shell glob相匹配的分支。如果pattern缺少'?'、'{asterisk}'或'['，则末尾的'/{asterisk}'是暗示的。"

#. type: Labeled list
#: en/rev-list-options.txt:169
#, no-wrap, placeholders:'--tags', priority:260
msgid "--tags[=<pattern>]"
msgstr "--tags[=<模式>]"

#. type: Plain text
#: en/rev-list-options.txt:174
#, placeholders:'{asterisk}':'{asterisk}', priority:260
msgid "Pretend as if all the refs in `refs/tags` are listed on the command line as '<commit>'. If '<pattern>' is given, limit tags to ones matching given shell glob. If pattern lacks '?', '{asterisk}', or '[', '/{asterisk}' at the end is implied."
msgstr "假设`refs/tags`中的所有参考文献在命令行中被列为'<commit>'。如果给出了'<pattern>'，将标签限制在与给定的shell glob相匹配的标签。如果pattern缺少'?'、'{asterisk}'或'['，则暗示最后的'/{asterisk}'。"

#. type: Labeled list
#: en/rev-list-options.txt:175
#, no-wrap, placeholders:'--remotes', priority:260
msgid "--remotes[=<pattern>]"
msgstr "--remotes[=<模式>]"

#. type: Plain text
#: en/rev-list-options.txt:180
#, placeholders:'{asterisk}':'{asterisk}', priority:260
msgid "Pretend as if all the refs in `refs/remotes` are listed on the command line as '<commit>'. If '<pattern>' is given, limit remote-tracking branches to ones matching given shell glob. If pattern lacks '?', '{asterisk}', or '[', '/{asterisk}' at the end is implied."
msgstr "假设`refs/remotes`中的所有 refs 在命令行中被列为 '<commit>'。如果给出了'<pattern>'，将远程跟踪分支限制在与给定的shell glob相匹配的分支。 如果pattern缺少'?'、'{asterisk}'或'['，则末尾的'/{asterisk}'是暗示的。"

#. type: Labeled list
#: en/rev-list-options.txt:181
#, no-wrap, placeholders:'--glob=', priority:260
msgid "--glob=<glob-pattern>"
msgstr "--glob=<通配符模式>"

#. type: Plain text
#: en/rev-list-options.txt:186
#, placeholders:'{asterisk}':'{asterisk}', priority:260
msgid "Pretend as if all the refs matching shell glob '<glob-pattern>' are listed on the command line as '<commit>'. Leading 'refs/', is automatically prepended if missing. If pattern lacks '?', '{asterisk}', or '[', '/{asterisk}' at the end is implied."
msgstr "假设所有与shell glob '<glob-pattern>相匹配的refs在命令行中被列为'<commit>'。前面的'refs/'，如果缺少的话会自动预加。如果模式中缺少'?'、'{asterisk}'或'['，则在结尾处隐含'/{asterisk}'。"

#. type: Labeled list
#: en/rev-list-options.txt:210
#, ignore-same, no-wrap, priority:260
msgid "--reflog"
msgstr "--reflog"

#. type: Plain text
#: en/rev-list-options.txt:213
#, priority:260
msgid "Pretend as if all objects mentioned by reflogs are listed on the command line as `<commit>`."
msgstr "假设reflogs提到的所有对象都在命令行中被列为`<commit>`。"

#. type: Labeled list
#: en/rev-list-options.txt:214
#, ignore-same, no-wrap, priority:260
msgid "--alternate-refs"
msgstr "--alternate-refs"

#. type: Plain text
#: en/rev-list-options.txt:221
#, placeholders:'core.alternateRefsCommand':'linkgit:git-config[1]', priority:260
msgid "Pretend as if all objects mentioned as ref tips of alternate repositories were listed on the command line. An alternate repository is any repository whose object directory is specified in `objects/info/alternates`. The set of included objects may be modified by `core.alternateRefsCommand`, etc. See linkgit:git-config[1]."
msgstr "假设所有提到的作为备用仓库的参考提示的对象都列在命令行上。备用资源库是任何资源库，其对象目录在`objects/info/alternates`中指定。 包含的对象集可以通过`core.alternateRefsCommand`等修改。见linkgit:git-config[1]。"

#. type: Plain text
#: en/rev-list-options.txt:229
#, placeholders:'linkgit:git-worktree[1]':'`--all`':'`--reflog`':'`--indexed-objects`', priority:260
msgid "By default, all working trees will be examined by the following options when there are more than one (see linkgit:git-worktree[1]): `--all`, `--reflog` and `--indexed-objects`. This option forces them to examine the current working tree only."
msgstr "默认情况下，当有多个工作树时，所有工作树都会被以下选项检查（见linkgit:git-worktree[1]）：`--all`，`--reflog`和`--indexed-objects`。 这个选项强制它们只检查当前的工作树。"

#. type: Plain text
#: en/rev-list-options.txt:233
#, priority:260
msgid "Upon seeing an invalid object name in the input, pretend as if the bad input was not given."
msgstr "在看到输入中无效的对象名称时，假装没有给出坏的输入。"

#. type: Labeled list
#: en/rev-list-options.txt:235 en/rev-list-options.txt:792
#, ignore-same, no-wrap, priority:260
msgid "--bisect"
msgstr "--bisect"

#. type: Plain text
#: en/rev-list-options.txt:240
#, placeholders:'`--not`', priority:260
msgid "Pretend as if the bad bisection ref `refs/bisect/bad` was listed and as if it was followed by `--not` and the good bisection refs `refs/bisect/good-*` on the command line."
msgstr "假设坏的二分法参考文献`refs/bisect/bad`被列出，并且在命令行中假设它后面是`--not`和好的二分法参考文献`refs/bisect/good-*`。"

#. type: Plain text
#: en/rev-list-options.txt:250
#, placeholders:'`--all`':'`--glob=`':'`--not`', priority:260
msgid "In addition to getting arguments from the command line, read them from standard input as well. This accepts commits and pseudo-options like `--all` and `--glob=`. When a `--` separator is seen, the following input is treated as paths and used to limit the result. Flags like `--not` which are read via standard input are only respected for arguments passed in the same way and will not influence any subsequent command line arguments."
msgstr "除从命令行获取参数外，还可从标准输入读取参数。它接受提交和伪选项，如 `--all` 和 `--glob=`。当看到 `--` 分隔符时，下面的输入将被视为路径并用于限制结果。通过标准输入读取的 `--not` 等标志只适用于以相同方式传递的参数，不会影响后续的命令行参数。"

#. type: Plain text
#: en/rev-list-options.txt:258
#, priority:260
msgid "Don't print anything to standard output. This form is primarily meant to allow the caller to test the exit status to see if a range of objects is fully connected (or not). It is faster than redirecting stdout to `/dev/null` as the output does not have to be formatted."
msgstr "不要打印任何东西到标准输出。 这种形式主要是为了让调用者测试退出状态，看看一系列的对象是否完全连接（或没有）。 它比将stdout重定向到`/dev/null`要快，因为输出不需要被格式化。"

#. type: Labeled list
#: en/rev-list-options.txt:259
#, ignore-same, no-wrap, priority:260
msgid "--disk-usage"
msgstr "--disk-usage"

#. type: Labeled list
#: en/rev-list-options.txt:260
#, ignore-same, no-wrap, priority:260
msgid "--disk-usage=human"
msgstr "--disk-usage=human"

#. type: Plain text
#: en/rev-list-options.txt:270
#, placeholders:'git cat-file':'--batch-check=':'`--use-bitmap-index`':'linkgit:git-cat-file[1]', priority:260
msgid "Suppress normal output; instead, print the sum of the bytes used for on-disk storage by the selected commits or objects. This is equivalent to piping the output into `git cat-file --batch-check='%(objectsize:disk)'`, except that it runs much faster (especially with `--use-bitmap-index`). See the `CAVEATS` section in linkgit:git-cat-file[1] for the limitations of what \"on-disk storage\" means. With the optional value `human`, on-disk storage size is shown in human-readable string(e.g. 12.24 Kib, 3.50 Mib)."
msgstr "抑制正常输出；相反，打印所选提交或对象用于磁盘存储的字节数之和。这相当于用管道将输出写入 `git cat-file --batch-check='%(objectsize:disk)'` ，只是它的运行速度要快得多（尤其是在使用 `--use-bitmap-index` 时）。参见 linkgit:git-cat-file[1] 中的 `注意事项` 部分，了解 “磁盘存储” 的限制。 如果使用可选值 `human`，磁盘存储大小将以人类可读字符串显示（如 12.24 Kib、3.50 Mib）。"

#. type: Labeled list
#: en/rev-list-options.txt:272
#, ignore-same, no-wrap, priority:260
msgid "--cherry-mark"
msgstr "--cherry-mark"

#. type: Plain text
#: en/rev-list-options.txt:275
#, placeholders:'`--cherry-pick`', priority:260
msgid "Like `--cherry-pick` (see below) but mark equivalent commits with `=` rather than omitting them, and inequivalent ones with `+`."
msgstr "就像`--cherry-pick`（见下文），但用`=`标记同等的提交，而不是省略，用`+`标记不同等的提交。"

#. type: Labeled list
#: en/rev-list-options.txt:276
#, ignore-same, no-wrap, priority:260
msgid "--cherry-pick"
msgstr "--cherry-pick"

#. type: Plain text
#: en/rev-list-options.txt:280
#, priority:260
msgid "Omit any commit that introduces the same change as another commit on the ``other side'' when the set of commits are limited with symmetric difference."
msgstr "当提交的集合有对称差异时，省略任何与 \"另一边 \"的另一个提交相同的提交。"

# ERROR: --left-right not found in translation
# ERROR: --left-right not found in translation
#. type: Plain text
#: en/rev-list-options.txt:288
#, placeholders:'`--left-right`':'`--left-right`', priority:260
msgid "For example, if you have two branches, `A` and `B`, a usual way to list all commits on only one side of them is with `--left-right` (see the example below in the description of the `--left-right` option). However, it shows the commits that were cherry-picked from the other branch (for example, ``3rd on b'' may be cherry-picked from branch A). With this option, such pairs of commits are excluded from the output."
msgstr "例如，如果你有两个分支，`A` 和 `B`，通常的方法是用`--左--右`列出其中一边的所有提交（见下面关于`--left-right`选项的描述）。然而，它显示的是从另一个分支中偷梁换柱的提交（例如，''3rd on b'' 可能是从分支 A 中偷梁换柱的）。有了这个选项，这样的提交对将从输出中排除。"

# ERROR: --left-right not found in translation
#. type: Plain text
#: en/rev-list-options.txt:294
#, placeholders:'`--left-right`', priority:260
msgid "List only commits on the respective side of a symmetric difference, i.e. only those which would be marked `<` resp. `>` by `--left-right`."
msgstr "只列出对称性差异各自一侧的提交，即只列出那些通过 `--left-right` 标记的 `<` 或 `>`。"

#. type: Plain text
#: en/rev-list-options.txt:300
#, ignore-ellipsis, placeholders:'`--cherry-pick':'--right-only':'`--cherry-pick':'--right-only':'--no-merges`', priority:260
msgid "For example, `--cherry-pick --right-only A...B` omits those commits from `B` which are in `A` or are patch-equivalent to a commit in `A`. In other words, this lists the `+` commits from `git cherry A B`. More precisely, `--cherry-pick --right-only --no-merges` gives the exact list."
msgstr "例如，`--cherry-pick --right-only A...B`省略了`B`中那些在`A`中的提交或与`A`中的提交相等的补丁。换句话说，它列出了 \"git cherry A B \"的 \"+\"的提交。 更准确地说，`--cherry-pick --right-only --no-merges`可以得到准确的列表。"

#. type: Labeled list
#: en/rev-list-options.txt:301
#, ignore-same, no-wrap, priority:260
msgid "--cherry"
msgstr "--cherry"

#. type: Plain text
#: en/rev-list-options.txt:307
#, ignore-ellipsis, placeholders:'`--right-only':'--cherry-mark':'--no-merges`':'--cherry', priority:260
msgid "A synonym for `--right-only --cherry-mark --no-merges`; useful to limit the output to the commits on our side and mark those that have been applied to the other side of a forked history with `git log --cherry upstream...mybranch`, similar to `git cherry upstream mybranch`."
msgstr "`--right-only --cherry-mark --no-merges`的同义词；有助于将输出限制在我们这边的提交，并标记那些已经应用到分叉历史的另一边的提交，`git log --cherry upstream...mybranch`，类似于`git cherry upstream mybranch`。"

#. type: Labeled list
#: en/rev-list-options.txt:309
#, ignore-same, no-wrap, priority:260
msgid "--walk-reflogs"
msgstr "--walk-reflogs"

#. type: Plain text
#: en/rev-list-options.txt:315
#, ignore-ellipsis, placeholders:'{caret}', priority:260
msgid "Instead of walking the commit ancestry chain, walk reflog entries from the most recent one to older ones. When this option is used you cannot specify commits to exclude (that is, '{caret}commit', 'commit1..commit2', and 'commit1\\...commit2' notations cannot be used)."
msgstr "不走提交祖先链，而走从最近的提交到更早的提交的reflog条目。 使用这个选项时，你不能指定要排除的提交（也就是说，不能使用'{caret}commit'、'commit1...commit2'和'commit1/...commit2'的符号）。"

#. type: Plain text
#: en/rev-list-options.txt:322
#, placeholders:'`--pretty`':'{Nth}':'{timestamp}', priority:260
msgid "With `--pretty` format other than `oneline` and `reference` (for obvious reasons), this causes the output to have two extra lines of information taken from the reflog. The reflog designator in the output may be shown as `ref@{Nth}` (where `Nth` is the reverse-chronological index in the reflog) or as `ref@{timestamp}` (with the timestamp for that entry), depending on a few rules:"
msgstr "在 `--pretty` 格式下，除了 `oneline` 和 `reference` （由于明显的原因），这将导致输出有两行额外的信息来自引用日志。 输出中的引用日志代号可以显示为 `ref@{Nth}`（其中 `Nth` 是引用日志中的逆序索引）或 `ref@{timestamp}` （带有该条目的时间戳），取决于一些规则："

#. type: Plain text
#: en/rev-list-options.txt:326
#, placeholders:'{Nth}', priority:260
msgid "If the starting point is specified as `ref@{Nth}`, show the index format."
msgstr "如果起点被指定为`ref@{Nth}`，显示索引格式。"

#. type: Plain text
#: en/rev-list-options.txt:329
#, placeholders:'{now}', priority:260
msgid "If the starting point was specified as `ref@{now}`, show the timestamp format."
msgstr "如果起点被指定为`ref@{now}`，显示时间戳格式。"

#. type: Plain text
#: en/rev-list-options.txt:332
#, placeholders:'`--date`':'`--date`', priority:260
msgid "If neither was used, but `--date` was given on the command line, show the timestamp in the format requested by `--date`."
msgstr "如果两者都没有使用，但在命令行中给出了`--date`，则按照`--date`所要求的格式显示时间戳。"

#. type: Plain text
#: en/rev-list-options.txt:334
#, priority:260
msgid "Otherwise, show the index format."
msgstr "否则，显示索引格式。"

#. type: Plain text
#: en/rev-list-options.txt:340
#, placeholders:'`--pretty=oneline`':'`--reverse`':'linkgit:git-reflog[1]', priority:260
msgid "Under `--pretty=oneline`, the commit message is prefixed with this information on the same line. This option cannot be combined with `--reverse`. See also linkgit:git-reflog[1]."
msgstr "在`--pretty=oneline`下，提交信息的前缀是同一行中的这些信息。 这个选项不能与 `--reverse`结合使用。 参见 linkgit:git-reflog[1]。"

#. type: Plain text
#: en/rev-list-options.txt:342
#, placeholders:'`--pretty=reference`', priority:260
msgid "Under `--pretty=reference`, this information will not be shown at all."
msgstr "在`--pretty=reference`下，这些信息将完全不显示。"

#. type: Plain text
#: en/rev-list-options.txt:346
#, priority:260
msgid "After a failed merge, show refs that touch files having a conflict and don't exist on all heads to merge."
msgstr "在合并失败后，显示触及有冲突的文件且不存在于所有要合并的头的参考文件。"

#. type: Labeled list
#: en/rev-list-options.txt:347
#, ignore-same, no-wrap, priority:260
msgid "--boundary"
msgstr "--boundary"

#. type: Plain text
#: en/rev-list-options.txt:350
#, priority:260
msgid "Output excluded boundary commits. Boundary commits are prefixed with `-`."
msgstr "输出排除的边界提交。边界提交的前缀是\"-\"。"

#. type: Labeled list
#: en/rev-list-options.txt:352
#, ignore-same, no-wrap, priority:260
msgid "--use-bitmap-index"
msgstr "--use-bitmap-index"

# ERROR: --objects not found in translation
#. type: Plain text
#: en/rev-list-options.txt:357
#, placeholders:'`--objects`', priority:260
msgid "Try to speed up the traversal using the pack bitmap index (if one is available). Note that when traversing with `--objects`, trees and blobs will not have their associated path printed."
msgstr "尝试使用包位图索引（如果有的话）来加快遍历的速度。注意，当使用`--objects` 选项进行遍历时，目录树和 blobs 不会打印出它们的相关路径。"

#. type: Labeled list
#: en/rev-list-options.txt:358
#, no-wrap, placeholders:'--progress=', priority:260
msgid "--progress=<header>"
msgstr "--progress=<头信息>"

#. type: Plain text
#: en/rev-list-options.txt:361
#, priority:260
msgid "Show progress reports on stderr as objects are considered. The `<header>` text will be printed with each progress update."
msgstr "在考虑对象时在stderr上显示进度报告。`<标题>`文本将在每次进度更新时打印。"

#. type: Title ~
#: en/rev-list-options.txt:364
#, no-wrap, priority:260
msgid "History Simplification"
msgstr "简化历史"

#. type: Plain text
#: en/rev-list-options.txt:370
#, priority:260
msgid "Sometimes you are only interested in parts of the history, for example the commits modifying a particular <path>. But there are two parts of 'History Simplification', one part is selecting the commits and the other is how to do it, as there are various strategies to simplify the history."
msgstr "有时你只对历史的一部分感兴趣，例如修改某个<路径>的提交。但 \"历史简化 \"有两部分，一部分是选择提交，另一部分是如何做，因为有各种策略来简化历史。"

#. type: Plain text
#: en/rev-list-options.txt:372
#, priority:260
msgid "The following options select the commits to be shown:"
msgstr "以下选项选择要显示的提交："

#. type: Labeled list
#: en/rev-list-options.txt:373
#, no-wrap, priority:260
msgid "<paths>"
msgstr "<paths>"

#. type: Plain text
#: en/rev-list-options.txt:375
#, priority:260
msgid "Commits modifying the given <paths> are selected."
msgstr "修改给定<路径>的提交会被选中。"

#. type: Labeled list
#: en/rev-list-options.txt:376
#, ignore-same, no-wrap, priority:260
msgid "--simplify-by-decoration"
msgstr "--simplify-by-decoration"

#. type: Plain text
#: en/rev-list-options.txt:378
#, priority:260
msgid "Commits that are referred by some branch or tag are selected."
msgstr "被某个分支或标签引用的提交被选中。"

#. type: Plain text
#: en/rev-list-options.txt:380
#, priority:260
msgid "Note that extra commits can be shown to give a meaningful history."
msgstr "请注意，可以显示额外的提交，以提供一个有意义的历史。"

#. type: Plain text
#: en/rev-list-options.txt:382
#, priority:260
msgid "The following options affect the way the simplification is performed:"
msgstr "以下选项会影响简化的执行方式："

#. type: Labeled list
#: en/rev-list-options.txt:383 en/rev-list-options.txt:465
#, no-wrap, priority:260
msgid "Default mode"
msgstr "默认模式"

#. type: Plain text
#: en/rev-list-options.txt:388
#, priority:260
msgid "Simplifies the history to the simplest history explaining the final state of the tree. Simplest because it prunes some side branches if the end result is the same (i.e. merging branches with the same content)"
msgstr "将历史简化为解释树的最终状态的最简单的历史。最简单的原因是，如果最终结果相同，它会修剪一些侧枝（即合并具有相同内容的分支）"

#. type: Labeled list
#: en/rev-list-options.txt:389 en/rev-list-options.txt:743
#, ignore-same, no-wrap, priority:260
msgid "--show-pulls"
msgstr "--show-pulls"

#. type: Plain text
#: en/rev-list-options.txt:394
#, priority:260
msgid "Include all commits from the default mode, but also any merge commits that are not TREESAME to the first parent but are TREESAME to a later parent. This mode is helpful for showing the merge commits that \"first introduced\" a change to a branch."
msgstr "包括默认模式下的所有提交，但也包括任何与第一个父分支不相干但与后来的父分支相干的合并提交。这种模式有助于显示 \"首次引入 \"某个分支的合并提交。"

#. type: Labeled list
#: en/rev-list-options.txt:395
#, ignore-same, no-wrap, priority:260
msgid "--full-history"
msgstr "--full-history"

#. type: Plain text
#: en/rev-list-options.txt:397
#, priority:260
msgid "Same as the default mode, but does not prune some history."
msgstr "与默认模式相同，但不修剪一些历史记录。"

#. type: Labeled list
#: en/rev-list-options.txt:398 en/rev-list-options.txt:533
#, ignore-same, no-wrap, priority:260
msgid "--dense"
msgstr "--dense"

#. type: Plain text
#: en/rev-list-options.txt:401
#, priority:260
msgid "Only the selected commits are shown, plus some to have a meaningful history."
msgstr "只显示所选的提交，再加上一些才有意义的历史。"

#. type: Plain text
#: en/rev-list-options.txt:404
#, priority:260
msgid "All commits in the simplified history are shown."
msgstr "简化历史中的所有提交都会显示出来。"

#. type: Labeled list
#: en/rev-list-options.txt:405 en/rev-list-options.txt:544
#, ignore-same, no-wrap, priority:260
msgid "--simplify-merges"
msgstr "--simplify-merges"

#. type: Plain text
#: en/rev-list-options.txt:409
#, placeholders:'`--full-history`', priority:260
msgid "Additional option to `--full-history` to remove some needless merges from the resulting history, as there are no selected commits contributing to this merge."
msgstr "为`--full-history`增加了一个选项，可以从结果的历史中删除一些不必要的合并，因为没有选定的提交对这次合并有贡献。"

#. type: Labeled list
#: en/rev-list-options.txt:410 en/rev-list-options.txt:591
#, no-wrap, placeholders:'--ancestry-path', priority:260
msgid "--ancestry-path[=<commit>]"
msgstr "--ancestry-path[=<提交>]"

#. type: Plain text
#: en/rev-list-options.txt:418
#, placeholders:'{caret}', priority:260
msgid "When given a range of commits to display (e.g. 'commit1..commit2' or 'commit2 {caret}commit1'), only display commits in that range that are ancestors of <commit>, descendants of <commit>, or <commit> itself. If no commit is specified, use 'commit1' (the excluded part of the range) as <commit>. Can be passed multiple times; if so, a commit is included if it is any of the commits given or if it is an ancestor or descendant of one of them."
msgstr "如果给定了一个要显示的提交范围（例如 '提交1..提交2' 或 '提交2 {caret}-提交1' ），则只会显示该范围内属于 <提交> 的祖先、<提交> 的后代或 <提交> 本身的提交。 如果没有指定提交，则使用 '提交1'（范围中排除的部分）作为 <提交>。 可以多次传递；如果是这样，如果某个提交是所给定提交中的任何一个，或者是其中一个提交的祖先或后代，则该提交将被包括在内。"

#. type: Plain text
#: en/rev-list-options.txt:420
#, priority:260
msgid "A more detailed explanation follows."
msgstr "以下是更详细的解释。"

#. type: Plain text
#: en/rev-list-options.txt:424
#, priority:260
msgid "Suppose you specified `foo` as the <paths>. We shall call commits that modify `foo` !TREESAME, and the rest TREESAME. (In a diff filtered for `foo`, they look different and equal, respectively.)"
msgstr "假设你指定了 `foo` 作为 <路径>。 我们将把修改 `foo` 的提交称为 !TREESAME，其余的称为 TREESAME。 (在为 `foo` 过滤的差异中，它们看起来分别是不同的和相同的。）"

#. type: Plain text
#: en/rev-list-options.txt:428
#, priority:260
msgid "In the following, we will always refer to the same example history to illustrate the differences between simplification settings. We assume that you are filtering for a file `foo` in this commit graph:"
msgstr "在下文中，我们将始终引用同一个历史实例来说明简化设置之间的差异。 我们假设你在这个提交图中过滤的是一个文件 `foo`："

#. type: delimited block -
#: en/rev-list-options.txt:434
#, no-wrap, placeholders:'---M---N---O---P---Q':'`-------------', priority:260
msgid ""
"\t  .-A---M---N---O---P---Q\n"
"\t /     /   /   /   /   /\n"
"\tI     B   C   D   E   Y\n"
"\t \\   /   /   /   /   /\n"
"\t  `-------------'   X\n"
msgstr ""
"\t  .-A---M---N---O---P---Q\n"
"\t /     /   /   /   /   /\n"
"\tI     B   C   D   E   Y\n"
"\t \\   /   /   /   /   /\n"
"\t  `-------------'   X\n"

#. type: Plain text
#: en/rev-list-options.txt:437
#, placeholders:'---Q', priority:260
msgid "The horizontal line of history A---Q is taken to be the first parent of each merge. The commits are:"
msgstr "历史 A---Q 的横线被认为是每次合并的第一个父本。 这些提交是："

#. type: Plain text
#: en/rev-list-options.txt:441
#, priority:260
msgid "`I` is the initial commit, in which `foo` exists with contents ``asdf'', and a file `quux` exists with contents ``quux''. Initial commits are compared to an empty tree, so `I` is !TREESAME."
msgstr "`I`是初始提交，其中`foo`存在，内容是`asdf''，文件`quux`存在，内容是`quux''。初始提交与空树比较，所以`I`是！`TREESAME。"

#. type: Plain text
#: en/rev-list-options.txt:443
#, priority:260
msgid "In `A`, `foo` contains just ``foo''."
msgstr "在`A`中，`foo`只包含`foo''。"

#. type: Plain text
#: en/rev-list-options.txt:446
#, priority:260
msgid "`B` contains the same change as `A`. Its merge `M` is trivial and hence TREESAME to all parents."
msgstr "`B`包含与`A`相同的变化。 它的合并`M`是微不足道的，因此对所有父类来说是TREESAME。"

#. type: Plain text
#: en/rev-list-options.txt:449
#, priority:260
msgid "`C` does not change `foo`, but its merge `N` changes it to ``foobar'', so it is not TREESAME to any parent."
msgstr "`C`没有改变`foo`，但是它的合并`N`将其改为`foobar''，所以它与任何父类都不存在TREESAME。"

#. type: Plain text
#: en/rev-list-options.txt:452
#, priority:260
msgid "`D` sets `foo` to ``baz''. Its merge `O` combines the strings from `N` and `D` to ``foobarbaz''; i.e., it is not TREESAME to any parent."
msgstr "`D`将`foo`设置为`baz''。它的合并项`O`将`N`和`D`的字符串合并为`foobarbaz''；也就是说，它与任何父类都不是TREESAME。"

#. type: Plain text
#: en/rev-list-options.txt:455
#, priority:260
msgid "`E` changes `quux` to ``xyzzy'', and its merge `P` combines the strings to ``quux xyzzy''. `P` is TREESAME to `O`, but not to `E`."
msgstr "`E`将`quux`改为`xyzzy''，其合并的`P`将这些字符串合并为`quux xyzzy''。`P'与`O'的关系是TREESAME，但与`E'不是。"

#. type: Plain text
#: en/rev-list-options.txt:459
#, priority:260
msgid "`X` is an independent root commit that added a new file `side`, and `Y` modified it. `Y` is TREESAME to `X`. Its merge `Q` added `side` to `P`, and `Q` is TREESAME to `P`, but not to `Y`."
msgstr "`X`是一个独立的根提交，添加了一个新文件`side`，`Y`修改了它。`Y`与`X`同为TREESAME。它的合并文件`Q`在`P`上添加了`side`，`Q`与`P`是同源，但与`Y`不是同源。"

#. type: Plain text
#: en/rev-list-options.txt:464
#, placeholders:'`--full-history`':'`--parents`':'`--children`', priority:260
msgid "`rev-list` walks backwards through history, including or excluding commits based on whether `--full-history` and/or parent rewriting (via `--parents` or `--children`) are used. The following settings are available."
msgstr "`rev-list`在历史中倒退，根据是否使用`--full-history`和/或父代重写（通过`--parents`或`--children`），包括或排除提交。以下设置是可用的。"

#. type: Plain text
#: en/rev-list-options.txt:472
#, placeholders:'`--sparse`', priority:260
msgid "Commits are included if they are not TREESAME to any parent (though this can be changed, see `--sparse` below). If the commit was a merge, and it was TREESAME to one parent, follow only that parent. (Even if there are several TREESAME parents, follow only one of them.) Otherwise, follow all parents."
msgstr "如果提交的内容与任何父类不相干，则被包括在内（当然这一点可以改变，见下面的`--sparse`）。 如果该提交是一个合并，并且它与一个父类是同源的，则只跟随该父类。 (即使有几个TREESAME父类，也只跟随其中一个。) 否则，跟随所有父类。"

#. type: Plain text
#: en/rev-list-options.txt:474
#, priority:260
msgid "This results in:"
msgstr "这将实现："

#. type: delimited block -
#: en/rev-list-options.txt:479
#, no-wrap, placeholders:'---N---O':'---------', priority:260
msgid ""
"\t  .-A---N---O\n"
"\t /     /   /\n"
"\tI---------D\n"
msgstr ""
"\t  .-A---N---O\n"
"\t /     /   /\n"
"\tI---------D\n"

#. type: Plain text
#: en/rev-list-options.txt:485
#, priority:260
msgid "Note how the rule to only follow the TREESAME parent, if one is available, removed `B` from consideration entirely. `C` was considered via `N`, but is TREESAME. Root commits are compared to an empty tree, so `I` is !TREESAME."
msgstr "请注意，如果有TREESAME父类的话，只遵循TREESAME父类的规则，将`B'完全排除在考虑之外。 `C`是通过`N`考虑的，但也是TREESAME。 根提交是与空树比较的，所以`I`是!!TREESAME。"

# ERROR: --parents not found in translation
#. type: Plain text
#: en/rev-list-options.txt:489
#, placeholders:'`--parents`', priority:260
msgid "Parent/child relations are only visible with `--parents`, but that does not affect the commits selected in default mode, so we have shown the parent lines."
msgstr "父/子关系只有在使用 `--parents` 选项的情况下才能看到，但这并不影响在默认模式下选择的提交，所以我们显示了父行。"

#. type: Labeled list
#: en/rev-list-options.txt:490
#, no-wrap, placeholders:'--full-history', priority:260
msgid "--full-history without parent rewriting"
msgstr "--full-history 无父级重写的完整历史记录"

#. type: Plain text
#: en/rev-list-options.txt:496
#, priority:260
msgid "This mode differs from the default in one point: always follow all parents of a merge, even if it is TREESAME to one of them. Even if more than one side of the merge has commits that are included, this does not imply that the merge itself is! In the example, we get"
msgstr "这种模式与默认模式有一点不同：总是跟随一个合并的所有父本，即使它与其中一个父本是TREESAME。 即使合并的一方有多个提交被包括在内，这也不意味着合并本身也是如此在这个例子中，我们得到"

#. type: delimited block -
#: en/rev-list-options.txt:499
#, no-wrap, priority:260
msgid "\tI  A  B  N  D  O  P  Q\n"
msgstr "\tI  A  B  N  D  O  P  Q\n"

#. type: Plain text
#: en/rev-list-options.txt:504
#, priority:260
msgid "`M` was excluded because it is TREESAME to both parents. `E`, `C` and `B` were all walked, but only `B` was !TREESAME, so the others do not appear."
msgstr "`M` 被排除在外，因为它与父母都是TREESAME。 `E` 、`C` 和`B` 都走了，但只有`B` 是 !TREESAME，所以其他的都没有出现。"

#. type: Plain text
#: en/rev-list-options.txt:508
#, priority:260
msgid "Note that without parent rewriting, it is not really possible to talk about the parent/child relationships between the commits, so we show them disconnected."
msgstr "请注意，如果没有父子重写，其实是不可能谈论提交之间的父子关系的，所以我们显示它们是不相连的。"

#. type: Labeled list
#: en/rev-list-options.txt:509
#, no-wrap, placeholders:'--full-history', priority:260
msgid "--full-history with parent rewriting"
msgstr "--full-history 带父级重写功能的全历史记录"

#. type: Plain text
#: en/rev-list-options.txt:512
#, placeholders:'`--sparse`', priority:260
msgid "Ordinary commits are only included if they are !TREESAME (though this can be changed, see `--sparse` below)."
msgstr "普通的提交只有当它们是！TREESAME时才会被包括在内（尽管这一点可以改变，见下面的`--sparse`）。"

#. type: Plain text
#: en/rev-list-options.txt:516
#, priority:260
msgid "Merges are always included. However, their parent list is rewritten: Along each parent, prune away commits that are not included themselves. This results in"
msgstr "合并总是被包括在内。 然而，他们的父级列表会被重写。沿着每个父级，修剪掉那些不包括自己的提交。 这样做的结果是"

#. type: delimited block -
#: en/rev-list-options.txt:523
#, no-wrap, placeholders:'---M---N---O---P---Q':'`-------------', priority:260
msgid ""
"\t  .-A---M---N---O---P---Q\n"
"\t /     /   /   /   /\n"
"\tI     B   /   D   /\n"
"\t \\   /   /   /   /\n"
"\t  `-------------'\n"
msgstr ""
"\t  .-A---M---N---O---P---Q\n"
"\t /     /   /   /   /\n"
"\tI     B   /   D   /\n"
"\t \\   /   /   /   /\n"
"\t  `-------------'\n"

#. type: Plain text
#: en/rev-list-options.txt:529
#, placeholders:'`--full-history`', priority:260
msgid "Compare to `--full-history` without rewriting above. Note that `E` was pruned away because it is TREESAME, but the parent list of P was rewritten to contain `E`'s parent `I`. The same happened for `C` and `N`, and `X`, `Y` and `Q`."
msgstr "与上面的`--full-history`相比，没有重写。 请注意，`E`被修剪掉了，因为它是TREESAME，但是P的父列表被改写为包含`E`的父`I`。 同样的情况发生在`C`和`N`，以及`X`、`Y`和`Q`。"

#. type: Plain text
#: en/rev-list-options.txt:532
#, priority:260
msgid "In addition to the above settings, you can change whether TREESAME affects inclusion:"
msgstr "除了上述设置外，你还可以改变 TRESAME 是否会影响收录："

#. type: Plain text
#: en/rev-list-options.txt:536
#, priority:260
msgid "Commits that are walked are included if they are not TREESAME to any parent."
msgstr "如果不与任何父类有TREESAME关系，则包括走过的承诺。"

#. type: Plain text
#: en/rev-list-options.txt:539
#, priority:260
msgid "All commits that are walked are included."
msgstr "所有走过的提交都包括在内。"

#. type: Plain text
#: en/rev-list-options.txt:543
#, placeholders:'`--full-history`', priority:260
msgid "Note that without `--full-history`, this still simplifies merges: if one of the parents is TREESAME, we follow only that one, so the other sides of the merge are never walked."
msgstr "请注意，如果没有`--full-history`，这仍然可以简化合并：如果父代之一是TREESAME，我们只跟随这个父代，所以合并的其他方面永远不会被走。"

#. type: Plain text
#: en/rev-list-options.txt:547
#, placeholders:'`--full-history`', priority:260
msgid "First, build a history graph in the same way that `--full-history` with parent rewriting does (see above)."
msgstr "首先，按照`--full-history`与父级改写的相同方式建立一个历史图（见上文）。"

#. type: Plain text
#: en/rev-list-options.txt:550
#, priority:260
msgid "Then simplify each commit `C` to its replacement `C'` in the final history according to the following rules:"
msgstr "然后根据以下规则将每个提交的 `C` 简化为最终历史中的替换 `C`："

#. type: Plain text
#: en/rev-list-options.txt:553
#, priority:260
msgid "Set `C'` to `C`."
msgstr "将 \"C \"设为 \"C\"。"

#. type: Plain text
#: en/rev-list-options.txt:558
#, priority:260
msgid "Replace each parent `P` of `C'` with its simplification `P'`. In the process, drop parents that are ancestors of other parents or that are root commits TREESAME to an empty tree, and remove duplicates, but take care to never drop all parents that we are TREESAME to."
msgstr "将`C'`的每个父类`P'替换成其简化的`P'`。 在这个过程中，放弃那些是其他父类的祖先的父类，或者是根部提交TREESAME的空树，并删除重复的父类，但注意不要放弃所有我们是TREESAME的父类。"

#. type: Plain text
#: en/rev-list-options.txt:562
#, priority:260
msgid "If after this parent rewriting, `C'` is a root or merge commit (has zero or >1 parents), a boundary commit, or !TREESAME, it remains. Otherwise, it is replaced with its only parent."
msgstr "如果在这次父级改写之后，`C'`是一个根或合并提交（有0个或>1个父级），一个边界提交，或！TREESAME，那么它将被保留。 否则，它将被替换为其唯一的父类。"

#. type: Plain text
#: en/rev-list-options.txt:566
#, placeholders:'`--full-history`', priority:260
msgid "The effect of this is best shown by way of comparing to `--full-history` with parent rewriting. The example turns into:"
msgstr "通过与 `--full-history` 选项的父级改写进行比较，可以最好地显示其效果。 这个例子变成了："

#. type: delimited block -
#: en/rev-list-options.txt:573
#, no-wrap, placeholders:'---M---N---O':'`---------', priority:260
msgid ""
"\t  .-A---M---N---O\n"
"\t /     /       /\n"
"\tI     B       D\n"
"\t \\   /       /\n"
"\t  `---------'\n"
msgstr ""
"\t  .-A---M---N---O\n"
"\t /     /       /\n"
"\tI     B       D\n"
"\t \\   /       /\n"
"\t  `---------'\n"

#. type: Plain text
#: en/rev-list-options.txt:576
#, placeholders:'`--full-history`', priority:260
msgid "Note the major differences in `N`, `P`, and `Q` over `--full-history`:"
msgstr "注意 `N` 、`P` 和 `Q` 与 `--full-history` 的主要区别："

#. type: Plain text
#: en/rev-list-options.txt:580
#, priority:260
msgid "`N`'s parent list had `I` removed, because it is an ancestor of the other parent `M`. Still, `N` remained because it is !TREESAME."
msgstr "`N`的父列表中删除了`I`，因为它是另一个父`M`的一个祖先。 但是，`N`仍然存在，因为它是!TREESAME。"

#. type: Plain text
#: en/rev-list-options.txt:583
#, priority:260
msgid "`P`'s parent list similarly had `I` removed. `P` was then removed completely, because it had one parent and is TREESAME."
msgstr "`P`的父级列表也同样删除了`I`。 然后`P`被完全删除，因为它有一个父本，并且是TREESAME。"

#. type: Plain text
#: en/rev-list-options.txt:587
#, priority:260
msgid "`Q`'s parent list had `Y` simplified to `X`. `X` was then removed, because it was a TREESAME root. `Q` was then removed completely, because it had one parent and is TREESAME."
msgstr "`Q`的父列表中有`Y`简化为`X`。然后`X`被删除，因为它是一个TREESAME根。然后`Q`被完全删除，因为它有一个父级，是TREESAME。"

#. type: Plain text
#: en/rev-list-options.txt:590
#, priority:260
msgid "There is another simplification mode available:"
msgstr "还有一种简化模式可用："

#. type: Plain text
#: en/rev-list-options.txt:595
#, priority:260
msgid "Limit the displayed commits to those which are an ancestor of <commit>, or which are a descendant of <commit>, or are <commit> itself."
msgstr "将显示的提交限制在<提交>的祖先，或<提交>的后代，或<提交>本身。"

#. type: Plain text
#: en/rev-list-options.txt:597
#, priority:260
msgid "As an example use case, consider the following commit history:"
msgstr "作为一个用例，请考虑以下提交历史："

#. type: delimited block -
#: en/rev-list-options.txt:604
#, no-wrap, placeholders:'---E-------F':'---C---G---H---I---J':'-------':'---------------':'--M', priority:260
msgid ""
"\t    D---E-------F\n"
"\t   /     \\       \\\n"
"\t  B---C---G---H---I---J\n"
"\t /                     \\\n"
"\tA-------K---------------L--M\n"
msgstr ""
"\t    D---E-------F\n"
"\t   /     \\       \\\n"
"\t  B---C---G---H---I---J\n"
"\t /                     \\\n"
"\tA-------K---------------L--M\n"

#. type: Plain text
#: en/rev-list-options.txt:612
#, priority:260
msgid "A regular 'D..M' computes the set of commits that are ancestors of `M`, but excludes the ones that are ancestors of `D`. This is useful to see what happened to the history leading to `M` since `D`, in the sense that ``what does `M` have that did not exist in `D`''. The result in this example would be all the commits, except `A` and `B` (and `D` itself, of course)."
msgstr "有规律的 \"D...M \"会计算出作为`M`的祖先的提交集合，但不包括作为`D`的祖先的提交。这对了解`M'的历史在`D'之后发生了什么很有用，也就是说`M'有什么东西是`D'没有的'。这个例子中的结果是所有的提交，除了`A`和`B`（当然还有`D`本身）。"

#. type: Plain text
#: en/rev-list-options.txt:618
#, placeholders:'`--ancestry-path`', priority:260
msgid "When we want to find out what commits in `M` are contaminated with the bug introduced by `D` and need fixing, however, we might want to view only the subset of 'D..M' that are actually descendants of `D`, i.e. excluding `C` and `K`. This is exactly what the `--ancestry-path` option does. Applied to the 'D..M' range, it results in:"
msgstr "然而，当我们想找出`M'中哪些提交被`D'引入的错误所污染而需要修复时，我们可能只想查看'D...M'中实际上是`D'的后代的子集，即排除`C'和`K'。这正是`--ancestry-path`选项的作用。应用于'D...M'范围，它的结果是："

#. type: delimited block -
#: en/rev-list-options.txt:625
#, no-wrap, placeholders:'-------':'---H---I---J':'--M', priority:260
msgid ""
"\t\tE-------F\n"
"\t\t \\       \\\n"
"\t\t  G---H---I---J\n"
"\t\t\t       \\\n"
"\t\t\t\tL--M\n"
msgstr ""
"\t\tE-------F\n"
"\t\t \\       \\\n"
"\t\t  G---H---I---J\n"
"\t\t\t       \\\n"
"\t\t\t\tL--M\n"

#. type: Plain text
#: en/rev-list-options.txt:630
#, placeholders:'`--ancestry-path=D`':'`--ancestry-path`', priority:260
msgid "We can also use `--ancestry-path=D` instead of `--ancestry-path` which means the same thing when applied to the 'D..M' range but is just more explicit."
msgstr "我们也可以用`--ancestry-path=D`来代替`--ancestry-path`，这在应用于'D...M'范围时意思相同，只是更加明确。"

#. type: Plain text
#: en/rev-list-options.txt:635
#, placeholders:'`--ancestry-path=H', priority:260
msgid "If we instead are interested in a given topic within this range, and all commits affected by that topic, we may only want to view the subset of `D..M` which contain that topic in their ancestry path. So, using `--ancestry-path=H D..M` for example would result in:"
msgstr "如果我们感兴趣的是这个范围内的某个主题，以及受该主题影响的所有提交，我们可能只想查看祖先路径中包含该主题的`D...M`子集。 因此，以`--ancestry-path=H D...M`为例，会形成以下结果："

#. type: delimited block -
#: en/rev-list-options.txt:642
#, no-wrap, placeholders:'---H---I---J':'--M', priority:260
msgid ""
"\t\tE\n"
"\t\t \\\n"
"\t\t  G---H---I---J\n"
"\t\t\t       \\\n"
"\t\t\t\tL--M\n"
msgstr ""
"\t\tE\n"
"\t\t \\\n"
"\t\t  G---H---I---J\n"
"\t\t\t       \\\n"
"\t\t\t\tL--M\n"

#. type: Plain text
#: en/rev-list-options.txt:645
#, placeholders:'`--ancestry-path=K', priority:260
msgid "Whereas `--ancestry-path=K D..M` would result in"
msgstr "而`--ancestry-path=K D...M`会形成以下结果"

#. type: delimited block -
#: en/rev-list-options.txt:648
#, no-wrap, placeholders:'---------------':'--M', priority:260
msgid "\t\tK---------------L--M\n"
msgstr "\t\tK---------------L--M\n"

#. type: Plain text
#: en/rev-list-options.txt:652
#, placeholders:'`--show-pulls`', priority:260
msgid "Before discussing another option, `--show-pulls`, we need to create a new example history."
msgstr "在讨论另一个选项，`--show-pulls`之前，我们需要创建一个新的历史实例。"

#. type: Plain text
#: en/rev-list-options.txt:657
#, placeholders:'`--full-history`':'`--simplify-merges`', priority:260
msgid "A common problem users face when looking at simplified history is that a commit they know changed a file somehow does not appear in the file's simplified history. Let's demonstrate a new example and show how options such as `--full-history` and `--simplify-merges` works in that case:"
msgstr "用户在查看简化的提交历史时经常遇到的一个问题是，他们知道的对某个文件的修改提交并没有出现在该文件的简史中。让我们演示一个新的例子，并说明`--full-history`和`--simplify-merges`等选项在这种情况下是如何工作的："

#. type: delimited block -
#: en/rev-list-options.txt:665
#, no-wrap, placeholders:'---M-----C--N---O---P':'`---X--':'`---Y--', priority:260
msgid ""
"\t  .-A---M-----C--N---O---P\n"
"\t /     / \\  \\  \\/   /   /\n"
"\tI     B   \\  R-'`-Z'   /\n"
"\t \\   /     \\/         /\n"
"\t  \\ /      /\\        /\n"
"\t   `---X--'  `---Y--'\n"
msgstr ""
"\t  .-A---M-----C--N---O---P\n"
"\t /     / \\  \\  \\/   /   /\n"
"\tI     B   \\  R-'`-Z'   /\n"
"\t \\   /     \\/         /\n"
"\t  \\ /      /\\        /\n"
"\t   `---X--'  `---Y--'\n"

#. type: Plain text
#: en/rev-list-options.txt:678
#, priority:260
msgid "For this example, suppose `I` created `file.txt` which was modified by `A`, `B`, and `X` in different ways. The single-parent commits `C`, `Z`, and `Y` do not change `file.txt`. The merge commit `M` was created by resolving the merge conflict to include both changes from `A` and `B` and hence is not TREESAME to either. The merge commit `R`, however, was created by ignoring the contents of `file.txt` at `M` and taking only the contents of `file.txt` at `X`. Hence, `R` is TREESAME to `X` but not `M`. Finally, the natural merge resolution to create `N` is to take the contents of `file.txt` at `R`, so `N` is TREESAME to `R` but not `C`. The merge commits `O` and `P` are TREESAME to their first parents, but not to their second parents, `Z` and `Y` respectively."
msgstr "在这个例子中，假设`I`创建了`file.txt`，并被`A`、`B`和`X`以不同方式修改。单亲提交的`C`、`Z`和`Y`没有修改`file.txt`。合并提交 `M`是通过解决合并冲突而产生的，包括了 `A `和 `B `的修改，因此与其中任何一个都不是同源的。然而，合并提交`R`是通过忽略`M`处的`file.txt`的内容，而只采用`X`处的`file.txt`的内容而产生的。因此，`R`与`X`是同源的，但不是`M`。最后，创建`N'的自然合并决议是取`file.txt`在`R'的内容，所以`N'与`R`是同源的，但不是`C`。 合并提交的 `O` 和 `P` 与它们的第一代父母是同源的，但与它们的第二代父母 `Z` 和 `Y `则不是同源的。"

#. type: Plain text
#: en/rev-list-options.txt:682
#, priority:260
msgid "When using the default mode, `N` and `R` both have a TREESAME parent, so those edges are walked and the others are ignored. The resulting history graph is:"
msgstr "当使用默认模式时，`N'和`R`都有一个TREESAME父级，所以这些边被展示出来，其他边被忽略。由此产生的历史图是："

#. type: delimited block -
#: en/rev-list-options.txt:685
#, no-wrap, placeholders:'---X', priority:260
msgid "\tI---X\n"
msgstr "\tI---X\n"

#. type: Plain text
#: en/rev-list-options.txt:690
#, placeholders:'`--full-history`', priority:260
msgid "When using `--full-history`, Git walks every edge. This will discover the commits `A` and `B` and the merge `M`, but also will reveal the merge commits `O` and `P`. With parent rewriting, the resulting graph is:"
msgstr "当使用 `--full-history` 选项时，Git 会行走每条边。这将发现提交 `A` 和 `B` 以及合并 `M`，但也将揭示合并提交 `O` 和 `P` 。通过父级改写，得到的图是："

#. type: delimited block -
#: en/rev-list-options.txt:698
#, no-wrap, placeholders:'---M--------N---O---P':'`---X--':'`------', priority:260
msgid ""
"\t  .-A---M--------N---O---P\n"
"\t /     / \\  \\  \\/   /   /\n"
"\tI     B   \\  R-'`--'   /\n"
"\t \\   /     \\/         /\n"
"\t  \\ /      /\\        /\n"
"\t   `---X--'  `------'\n"
msgstr ""
"\t  .-A---M--------N---O---P\n"
"\t /     / \\  \\  \\/   /   /\n"
"\tI     B   \\  R-'`--'   /\n"
"\t \\   /     \\/         /\n"
"\t  \\ /      /\\        /\n"
"\t   `---X--'  `------'\n"

#. type: Plain text
#: en/rev-list-options.txt:706
#, placeholders:'`--full-history`', priority:260
msgid "Here, the merge commits `O` and `P` contribute extra noise, as they did not actually contribute a change to `file.txt`. They only merged a topic that was based on an older version of `file.txt`. This is a common issue in repositories using a workflow where many contributors work in parallel and merge their topic branches along a single trunk: many unrelated merges appear in the `--full-history` results."
msgstr "这里，合并提交 `O` 和 `P` 带来了额外的输出，因为它们实际上并没有对 `file.txt` 做出改变。他们只是合并了一个基于 `file.txt` 旧版本的主题。这是在使用工作流程的仓库中常见的问题，在工作流程中，许多贡献者并行工作，并沿着一个主干合并他们的主题分支：不相关的合并出现在 `--full-history` 选项结果中。"

# ERROR: --simplify-merges not found in translation
#. type: Plain text
#: en/rev-list-options.txt:713
#, placeholders:'`--simplify-merges`', priority:260
msgid "When using the `--simplify-merges` option, the commits `O` and `P` disappear from the results. This is because the rewritten second parents of `O` and `P` are reachable from their first parents. Those edges are removed and then the commits look like single-parent commits that are TREESAME to their parent. This also happens to the commit `N`, resulting in a history view as follows:"
msgstr "当使用`--simplify-merges`选项时，提交的 `O` 和 `P` 从结果中消失。这是因为 `O` 和 `P` 重写的第二父本可以从它们的第一父本到达。这些边被移除，然后这些提交看起来就像与它们的父类一样的单亲提交。这也发生在提交 `N` 上，导致历史视图如下："

#. type: delimited block -
#: en/rev-list-options.txt:721
#, no-wrap, placeholders:'---M--':'`---X--', priority:260
msgid ""
"\t  .-A---M--.\n"
"\t /     /    \\\n"
"\tI     B      R\n"
"\t \\   /      /\n"
"\t  \\ /      /\n"
"\t   `---X--'\n"
msgstr ""
"\t  .-A---M--.\n"
"\t /     /    \\\n"
"\tI     B      R\n"
"\t \\   /      /\n"
"\t  \\ /      /\n"
"\t   `---X--'\n"

#. type: Plain text
#: en/rev-list-options.txt:728
#, priority:260
msgid "In this view, we see all of the important single-parent changes from `A`, `B`, and `X`. We also see the carefully-resolved merge `M` and the not-so-carefully-resolved merge `R`. This is usually enough information to determine why the commits `A` and `B` \"disappeared\" from history in the default view. However, there are a few issues with this approach."
msgstr "在这个视图中，我们看到了所有来自`A`，`B`和`X`的重要单亲变化。我们还可以看到仔细解决的合并`M`和不那么仔细解决的合并`R`。这些信息通常足以确定为什么`A`和`B`的提交在默认视图中从历史中 \"消失 \"了。然而，这种方法也有一些问题。"

# ERROR: --simplify-merges not found in translation
#. type: Plain text
#: en/rev-list-options.txt:733
#, placeholders:'`--simplify-merges`', priority:260
msgid "The first issue is performance. Unlike any previous option, the `--simplify-merges` option requires walking the entire commit history before returning a single result. This can make the option difficult to use for very large repositories."
msgstr "第一个问题是性能。与之前的任何选项不同，`--simplify-merges` 选项需要在返回一个结果之前走完整个提交历史。这可能使该选项难以用于非常大的仓库。"

#. type: Plain text
#: en/rev-list-options.txt:742
#, priority:260
msgid "The second issue is one of auditing. When many contributors are working on the same repository, it is important which merge commits introduced a change into an important branch. The problematic merge `R` above is not likely to be the merge commit that was used to merge into an important branch. Instead, the merge `N` was used to merge `R` and `X` into the important branch. This commit may have information about why the change `X` came to override the changes from `A` and `B` in its commit message."
msgstr "第二个问题是审计的问题。当许多贡献者在同一个版本库中工作时，哪些合并提交将一个变化引入到一个重要的分支是很重要的。上面有问题的合并`R`不可能是用来合并到一个重要分支的合并提交。相反，`N'是用来将`R'和`X'合并到重要分支的。这个提交可能有关于为什么`X'会覆盖`A'和`B'的修改的信息，在其提交信息中。"

#. type: Plain text
#: en/rev-list-options.txt:747
#, priority:260
msgid "In addition to the commits shown in the default history, show each merge commit that is not TREESAME to its first parent but is TREESAME to a later parent."
msgstr "除了在默认历史中显示的提交之外，还要显示每一个与第一个父本不相同但与后来的父本相同的合并提交。"

#. type: Plain text
#: en/rev-list-options.txt:752
#, placeholders:'`--show-pulls`':'`--show-pulls`', priority:260
msgid "When a merge commit is included by `--show-pulls`, the merge is treated as if it \"pulled\" the change from another branch. When using `--show-pulls` on this example (and no other options) the resulting graph is:"
msgstr "当一个合并提交被 `--show-pulls` 选项包含时，该合并被视为从另一个分支 “拉取” 来的修改。在这个例子中使用 `--show-pulls` 选项时（没有其他选项），得到的图是："

#. type: delimited block -
#: en/rev-list-options.txt:755
#, no-wrap, placeholders:'---X---R---N', priority:260
msgid "\tI---X---R---N\n"
msgstr "\tI---X---R---N\n"

#. type: Plain text
#: en/rev-list-options.txt:761
#, priority:260
msgid "Here, the merge commits `R` and `N` are included because they pulled the commits `X` and `R` into the base branch, respectively. These merges are the reason the commits `A` and `B` do not appear in the default history."
msgstr "这里，合并后的提交`R`和`N`被包括在内，因为它们分别将提交`X`和`R`拉到了基础分支。这些合并是`A`和`B`的提交没有出现在默认历史中的原因。"

#. type: Plain text
#: en/rev-list-options.txt:764
#, placeholders:'`--show-pulls`':'`--simplify-merges`', priority:260
msgid "When `--show-pulls` is paired with `--simplify-merges`, the graph includes all of the necessary information:"
msgstr "当 `--show-pulls` 与 `--simplify-merges` 选项配对时，该图包括所有必要的信息："

#. type: delimited block -
#: en/rev-list-options.txt:772
#, no-wrap, placeholders:'---M--':'`---X--', priority:260
msgid ""
"\t  .-A---M--.   N\n"
"\t /     /    \\ /\n"
"\tI     B      R\n"
"\t \\   /      /\n"
"\t  \\ /      /\n"
"\t   `---X--'\n"
msgstr ""
"\t  .-A---M--.   N\n"
"\t /     /    \\ /\n"
"\tI     B      R\n"
"\t \\   /      /\n"
"\t  \\ /      /\n"
"\t   `---X--'\n"

#. type: Plain text
#: en/rev-list-options.txt:778
#, priority:260
msgid "Notice that since `M` is reachable from `R`, the edge from `N` to `M` was simplified away. However, `N` still appears in the history as an important commit because it \"pulled\" the change `R` into the main branch."
msgstr "请注意，由于`M`可以从`R`到达，从`N`到`M`的边被简化掉了。然而，`N`仍然作为一个重要的提交出现在历史中，因为它把`R`的修改 \"拉 \"进了主分支。"

# ERROR: --simplify-by-decoration not found in translation
#. type: Plain text
#: en/rev-list-options.txt:786
#, placeholders:'`--simplify-by-decoration`', priority:260
msgid "The `--simplify-by-decoration` option allows you to view only the big picture of the topology of the history, by omitting commits that are not referenced by tags. Commits are marked as !TREESAME (in other words, kept after history simplification rules described above) if (1) they are referenced by tags, or (2) they change the contents of the paths given on the command line. All other commits are marked as TREESAME (subject to be simplified away)."
msgstr "`--simplify-by-decoration` 选项允许你只查看历史拓扑的全貌，省略那些没有被标签引用的提交。 如果 (1) 提交被标签引用，或者 (2) 提交改变了命令行上给出的路径内容，则被标记为 TREESAME（换句话说，按照上述历史简化规则保留）。 所有其他的提交都被标记为 TREESAME（会被简化掉）。"

#. type: Title ~
#: en/rev-list-options.txt:790
#, no-wrap, priority:260
msgid "Bisection Helpers"
msgstr "剖腹产助手"

#. type: Plain text
#: en/rev-list-options.txt:799
#, priority:260
msgid "Limit output to the one commit object which is roughly halfway between included and excluded commits. Note that the bad bisection ref `refs/bisect/bad` is added to the included commits (if it exists) and the good bisection refs `refs/bisect/good-*` are added to the excluded commits (if they exist). Thus, supposing there are no refs in `refs/bisect/`, if"
msgstr "将输出限制在一个提交对象上，该对象大致在包含和排除的提交之间。请注意，坏的分界参考`refs/bisect/bad`会被添加到包含的提交中（如果它存在的话），好的分界参考`refs/bisect/good-*`会被添加到排除的提交中（如果它们存在的话）。因此，假设`refs/bisect/`中没有参考文献，如果"

#. type: delimited block -
#: en/rev-list-options.txt:802
#, no-wrap, placeholders:'git rev-list':'--bisect', priority:260
msgid "\t$ git rev-list --bisect foo ^bar ^baz\n"
msgstr "\t$ git rev-list --bisect foo ^bar ^baz\n"

#. type: Plain text
#: en/rev-list-options.txt:805
#, priority:260
msgid "outputs 'midpoint', the output of the two commands"
msgstr "输出 'midpoint'，即两个命令的输出"

#. type: delimited block -
#: en/rev-list-options.txt:809
#, no-wrap, placeholders:'git rev-list':'git rev-list', priority:260
msgid ""
"\t$ git rev-list foo ^midpoint\n"
"\t$ git rev-list midpoint ^bar ^baz\n"
msgstr ""
"\t$ git rev-list foo ^midpoint\n"
"\t$ git rev-list midpoint ^bar ^baz\n"

#. type: Plain text
#: en/rev-list-options.txt:815
#, priority:260
msgid "would be of roughly the same length. Finding the change which introduces a regression is thus reduced to a binary search: repeatedly generate and test new 'midpoint's until the commit chain is of length one."
msgstr "的长度大致相同。 因此，找到引入回归的变化就变成了一个二进制搜索：反复生成和测试新的 \"中点\"，直到提交链的长度为1。"

#. type: Labeled list
#: en/rev-list-options.txt:816
#, ignore-same, no-wrap, priority:260
msgid "--bisect-vars"
msgstr "--bisect-vars"

#. type: Plain text
#: en/rev-list-options.txt:827
#, placeholders:'`--bisect`':'bisect_rev':'bisect_rev':'bisect_nr':'bisect_rev':'bisect_good':'bisect_rev':'bisect_bad':'bisect_all', priority:260
msgid "This calculates the same as `--bisect`, except that refs in `refs/bisect/` are not used, and except that this outputs text ready to be eval'ed by the shell. These lines will assign the name of the midpoint revision to the variable `bisect_rev`, and the expected number of commits to be tested after `bisect_rev` is tested to `bisect_nr`, the expected number of commits to be tested if `bisect_rev` turns out to be good to `bisect_good`, the expected number of commits to be tested if `bisect_rev` turns out to be bad to `bisect_bad`, and the number of commits we are bisecting right now to `bisect_all`."
msgstr "这与`--bisect`的计算方法相同，只是不使用`refs/bisect/`中的参考文献，而且输出的文本可以被shell评估。这几行将把中点修订的名称分配给变量`bisect_rev`，并把`bisect_rev`测试后的预期提交数分配给`bisect_nr`。如果`bisect_rev'结果是好的，预计测试的提交数量为`bisect_good'，如果`bisect_rev'结果是坏的，预计测试的提交数量为`bisect_bad'，以及我们现在正在分叉的提交数量为`bisect_all'。"

#. type: Labeled list
#: en/rev-list-options.txt:828
#, ignore-same, no-wrap, priority:260
msgid "--bisect-all"
msgstr "--bisect-all"

#. type: Plain text
#: en/rev-list-options.txt:834
#, placeholders:'`--bisect`', priority:260
msgid "This outputs all the commit objects between the included and excluded commits, ordered by their distance to the included and excluded commits. Refs in `refs/bisect/` are not used. The farthest from them is displayed first. (This is the only one displayed by `--bisect`.)"
msgstr "这将输出包含的提交和排除的提交之间的所有提交对象，按照它们与包含的提交和排除的提交的距离排序。`refs/bisect/`中的引用不被使用。离它们最远的会先显示出来。这也是 `--bisect` 选项唯一显示的对象。）"

#. type: Plain text
#: en/rev-list-options.txt:838
#, priority:260
msgid "This is useful because it makes it easy to choose a good commit to test when you want to avoid to test some of them for some reason (they may not compile for example)."
msgstr "这很有用，因为当你因为某些原因想避免测试某些提交时（例如，它们可能无法编译），可以很容易地选择一个好的提交来测试。"

#. type: Plain text
#: en/rev-list-options.txt:842
#, placeholders:'`--bisect-vars`':'`--bisect-vars`', priority:260
msgid "This option can be used along with `--bisect-vars`, in this case, after all the sorted commit objects, there will be the same text as if `--bisect-vars` had been used alone."
msgstr "这个选项可以和`--bisect-vars`一起使用，在这种情况下，在所有排序的提交对象之后，会有和`--bisect-vars`单独使用一样的文本。"

#. type: Title ~
#: en/rev-list-options.txt:847
#, no-wrap, priority:260
msgid "Commit Ordering"
msgstr "承诺订购"

#. type: Plain text
#: en/rev-list-options.txt:850
#, priority:260
msgid "By default, the commits are shown in reverse chronological order."
msgstr "默认情况下，提交的内容是按时间顺序倒序显示的。"

#. type: Plain text
#: en/rev-list-options.txt:854
#, priority:260
msgid "Show no parents before all of its children are shown, but otherwise show commits in the commit timestamp order."
msgstr "在显示所有子代之前不显示父代，否则按提交时间戳顺序显示提交。"

#. type: Labeled list
#: en/rev-list-options.txt:855
#, ignore-same, no-wrap, priority:260
msgid "--author-date-order"
msgstr "--author-date-order"

#. type: Plain text
#: en/rev-list-options.txt:858
#, priority:260
msgid "Show no parents before all of its children are shown, but otherwise show commits in the author timestamp order."
msgstr "在显示所有子代之前不显示父代，否则按作者时间戳顺序显示提交。"

#. type: Plain text
#: en/rev-list-options.txt:863
#, priority:260
msgid "Show no parents before all of its children are shown, and avoid showing commits on multiple lines of history intermixed."
msgstr "在显示所有子代之前不显示父代，并避免显示多行历史交错的提交。"

#. type: Plain text
#: en/rev-list-options.txt:865
#, priority:260
msgid "For example, in a commit history like this:"
msgstr "例如，在这样的一个提交历史中："

#. type: delimited block -
#: en/rev-list-options.txt:871
#, no-wrap, placeholders:'---1----2----4----7':'----':'----':'----':'---', priority:260
msgid ""
"    ---1----2----4----7\n"
"\t\\\t       \\\n"
"\t 3----5----6----8---\n"
msgstr ""
"    ---1----2----4----7\n"
"\t\\\t       \\\n"
"\t 3----5----6----8---\n"

#. type: Plain text
#: en/rev-list-options.txt:877
#, placeholders:'git rev-list':'`--date-order`', priority:260
msgid "where the numbers denote the order of commit timestamps, `git rev-list` and friends with `--date-order` show the commits in the timestamp order: 8 7 6 5 4 3 2 1."
msgstr "其中数字表示提交时间戳的顺序，`git rev-list`和带有`--date-order`的朋友显示提交的时间戳顺序。8 7 6 5 4 3 2 1."

#. type: Plain text
#: en/rev-list-options.txt:882
#, placeholders:'`--topo-order`', priority:260
msgid "With `--topo-order`, they would show 8 6 5 3 7 4 2 1 (or 8 7 4 2 6 5 3 1); some older commits are shown before newer ones in order to avoid showing the commits from two parallel development track mixed together."
msgstr "如果使用`--topo-order`，它们会显示8 6 5 3 7 4 2 1（或8 7 4 2 6 5 3 1）；一些较早的提交会显示在较新的提交之前，以避免显示两个平行开发轨道的提交混在一起。"

#. type: Plain text
#: en/rev-list-options.txt:887
#, placeholders:'`--walk-reflogs`', priority:260
msgid "Output the commits chosen to be shown (see Commit Limiting section above) in reverse order. Cannot be combined with `--walk-reflogs`."
msgstr "以相反的顺序输出选择显示的提交（见上面的提交限制部分）。不能与`--walk-reflogs`结合使用。"

#. type: Title ~
#: en/rev-list-options.txt:891
#, no-wrap, priority:260
msgid "Object Traversal"
msgstr "对象遍历"

#. type: Plain text
#: en/rev-list-options.txt:894
#, priority:260
msgid "These options are mostly targeted for packing of Git repositories."
msgstr "这些选项主要是针对Git存储库的打包。"

#. type: Labeled list
#: en/rev-list-options.txt:896
#, ignore-same, no-wrap, priority:260
msgid "--objects"
msgstr "--objects"

# ERROR: --object-names not found in translation
#. type: Plain text
#: en/rev-list-options.txt:901
#, placeholders:'`--objects':'`--object-names`', priority:260
msgid "Print the object IDs of any object referenced by the listed commits. `--objects foo ^bar` thus means ``send me all object IDs which I need to download if I have the commit object _bar_ but not _foo_''. See also `--object-names` below."
msgstr "打印列出的提交对象所引用的任何对象的ID。 `--objects foo ^bar` 因此意味着 ''给我发送所有我需要下载的对象ID，如果我有提交对象_bar_但没有_foo_的话''。另请参阅下面的 `--object-names` 选项。"

#. type: Labeled list
#: en/rev-list-options.txt:902
#, ignore-same, no-wrap, priority:260
msgid "--in-commit-order"
msgstr "--in-commit-order"

#. type: Plain text
#: en/rev-list-options.txt:906
#, priority:260
msgid "Print tree and blob ids in order of the commits. The tree and blob ids are printed after they are first referenced by a commit."
msgstr "按照提交的顺序打印树和blob的id。树和blob的id会在它们第一次被提交者引用后打印。"

#. type: Labeled list
#: en/rev-list-options.txt:907
#, ignore-same, no-wrap, priority:260
msgid "--objects-edge"
msgstr "--objects-edge"

#. type: Plain text
#: en/rev-list-options.txt:913
#, placeholders:'`--objects`':'linkgit:git-pack-objects[1]', priority:260
msgid "Similar to `--objects`, but also print the IDs of excluded commits prefixed with a ``-'' character. This is used by linkgit:git-pack-objects[1] to build a ``thin'' pack, which records objects in deltified form based on objects contained in these excluded commits to reduce network traffic."
msgstr "类似于 `--objects`，但也会打印被排除的提交物的 ID，前缀为 `-''字符。 这被 linkgit:git-pack-objects[1] 用来建立一个 \"瘦身 \"包，它基于这些被排除的提交中包含的对象，以删除的形式记录对象，以减少网络流量。"

#. type: Labeled list
#: en/rev-list-options.txt:914
#, ignore-same, no-wrap, priority:260
msgid "--objects-edge-aggressive"
msgstr "--objects-edge-aggressive"

#. type: Plain text
#: en/rev-list-options.txt:918
#, placeholders:'`--objects-edge`':'`--objects-edge`', priority:260
msgid "Similar to `--objects-edge`, but it tries harder to find excluded commits at the cost of increased time. This is used instead of `--objects-edge` to build ``thin'' packs for shallow repositories."
msgstr "类似于 `--objects-edge`，但它更努力地寻找被排除的提交，代价是增加时间。 它被用来代替`--objects-edge`，为浅层仓库建立 \"薄 \"的包。"

#. type: Labeled list
#: en/rev-list-options.txt:919
#, ignore-same, no-wrap, priority:260
msgid "--indexed-objects"
msgstr "--indexed-objects"

#. type: Plain text
#: en/rev-list-options.txt:923
#, placeholders:'`--objects`', priority:260
msgid "Pretend as if all trees and blobs used by the index are listed on the command line. Note that you probably want to use `--objects`, too."
msgstr "假设索引使用的所有树和blobs都列在命令行中。 注意，你可能也想使用`--objects`。"

# ERROR: --objects not found in translation
# ERROR: `--objects` not found in translation
#. type: Plain text
#: en/rev-list-options.txt:927
#, placeholders:'`--objects`', priority:260
msgid "Only useful with `--objects`; print the object IDs that are not in packs."
msgstr "只对 `--objects` 有用；打印不在包中的对象 ID。"

#. type: Labeled list
#: en/rev-list-options.txt:928
#, ignore-same, no-wrap, priority:260
msgid "--object-names"
msgstr "--object-names"

#. type: Plain text
#: en/rev-list-options.txt:936
#, placeholders:'`--objects`', priority:260
msgid "Only useful with `--objects`; print the names of the object IDs that are found. This is the default behavior. Note that the \"name\" of each object is ambiguous, and mostly intended as a hint for packing objects. In particular: no distinction is made between the names of tags, trees, and blobs; path names may be modified to remove newlines; and if an object would appear multiple times with different names, only one name is shown."
msgstr "只对 `--objects` 有用；打印找到的对象ID的名称。这是默认的行为。注意，每个对象的 \"名字\" 是模糊的，主要是作为打包对象的提示。特别是：标签、树和二进制文件的名字不作区分；路径名称可以被修改以删除换行；如果一个对象会以不同的名字出现多次，则只显示一个名字。"

#. type: Labeled list
#: en/rev-list-options.txt:937
#, ignore-same, no-wrap, priority:260
msgid "--no-object-names"
msgstr "--no-object-names"

# ERROR: --objects not found in translation
#. type: Plain text
#: en/rev-list-options.txt:942
#, placeholders:'`--objects`':'`--object-names`':'linkgit:git-cat-file[1]', priority:260
msgid "Only useful with `--objects`; does not print the names of the object IDs that are found. This inverts `--object-names`. This flag allows the output to be more easily parsed by commands such as linkgit:git-cat-file[1]."
msgstr "只对 `--objects` 有用；不打印找到的对象 ID 的名称。这与 `--object-names` 相反。这个标志允许输出更容易被 linkgit:git-cat-file[1] 等命令解析。"

#. type: Plain text
#: en/rev-list-options.txt:947
#, placeholders:'`--objects', priority:260
msgid "Only useful with one of the `--objects*`; omits objects (usually blobs) from the list of printed objects. The '<filter-spec>' may be one of the following:"
msgstr "只对其中一个 `--objects*` 选项有用；从打印对象列表中省略对象（通常是 blobs）。 '<过滤规则>' 可以是下列之一："

#. type: Plain text
#: en/rev-list-options.txt:949
#, placeholders:'--filter=blob', priority:260
msgid "The form '--filter=blob:none' omits all blobs."
msgstr "'--filter=blob:none'的形式可以省略所有的blob。"

#. type: Plain text
#: en/rev-list-options.txt:954
#, placeholders:'--filter=blob', priority:260
msgid "The form '--filter=blob:limit=<n>[kmg]' omits blobs of size at least n bytes or units. n may be zero. The suffixes k, m, and g can be used to name units in KiB, MiB, or GiB. For example, 'blob:limit=1k' is the same as 'blob:limit=1024'."
msgstr "格式 '--filter=blob:limit=<n>[kmg]' 会忽略大小至少为 n 字节或单位的 blob。后缀 k、m 和 g 可用来命名 KiB、MiB 或 GiB 单位。例如，'blob:limit=1k' 与 'blob:limit=1024' 相同。"

#. type: Plain text
#: en/rev-list-options.txt:957
#, placeholders:'--filter=object', priority:260
msgid "The form '--filter=object:type=(tag|commit|tree|blob)' omits all objects which are not of the requested type."
msgstr "'--filter=object:type=(tag|commit|tree|blob)'的形式会省略所有不属于请求类型的对象。"

#. type: Plain text
#: en/rev-list-options.txt:962
#, placeholders:'--filter=sparse', priority:260
msgid "The form '--filter=sparse:oid=<blob-ish>' uses a sparse-checkout specification contained in the blob (or blob-expression) '<blob-ish>' to omit blobs that would not be required for a sparse checkout on the requested refs."
msgstr "表格 '--filter=sparse:oid=<blob-ish>' 使用 blob（或 blob 表达式）'<blob-ish>' 中包含的稀疏检出规范，以省略在请求的引用上进行稀疏检出时不需要的 blob。"

# ERROR: --stdin not found in translation
#. type: Plain text
#: en/rev-list-options.txt:972
#, placeholders:'--filter=tree':'--stdin', priority:260
msgid "The form '--filter=tree:<depth>' omits all blobs and trees whose depth from the root tree is >= <depth> (minimum depth if an object is located at multiple depths in the commits traversed). <depth>=0 will not include any trees or blobs unless included explicitly in the command-line (or standard input when --stdin is used). <depth>=1 will include only the tree and blobs which are referenced directly by a commit reachable from <commit> or an explicitly-given object. <depth>=2 is like <depth>=1 while also including trees and blobs one more level removed from an explicitly-given commit or tree."
msgstr "'--filter=tree:<深度>' 的形式省略了所有从根树开始深度 >=<深度>（如果一个对象在所穿越的提交中位于多个深度，则为最小深度）的blobs和目录树。<深度>=0 将不包括任何目录树或 blobs，除非在命令行中明确包括（或使用 --stdin 选项时的标准输入）。<深度>=1 将只包括由 <提交> 或明确指定的对象所能到达的提交直接引用的目录树和 blobs。<深度>=2 与 <深度>=1 类似，同时也包括从明确给出的提交或目录树中移出的多一级的目录树和 blobs。"

#. type: Plain text
#: en/rev-list-options.txt:976
#, placeholders:'--filter=sparse', priority:260
msgid "Note that the form '--filter=sparse:path=<path>' that wants to read from an arbitrary path on the filesystem has been dropped for security reasons."
msgstr "注意，出于安全原因，想要从文件系统上的任意路径读取的'--filter=sparse:path=<path>'形式已经被放弃了。"

# ERROR: --filter= not found in translation
#. type: Plain text
#: en/rev-list-options.txt:979
#, placeholders:'--filter=', priority:260
msgid "Multiple '--filter=' flags can be specified to combine filters. Only objects which are accepted by every filter are included."
msgstr "可以指定多个'--filter=' 标志来组合过滤器。只有那些被每个过滤器接受的对象才会被包括在内。"

#. type: Plain text
#: en/rev-list-options.txt:988
#, ignore-ellipsis, placeholders:'--filter=combine':'--filter':'{plus}':'{plus}', priority:260
msgid "The form '--filter=combine:<filter1>+<filter2>+...<filterN>' can also be used to combined several filters, but this is harder than just repeating the '--filter' flag and is usually not necessary. Filters are joined by '{plus}' and individual filters are %-encoded (i.e. URL-encoded). Besides the '{plus}' and '%' characters, the following characters are reserved and also must be encoded: `~!@#$^&*()[]{}\\;\",<>?`+&#39;&#96;+ as well as all characters with ASCII code &lt;= `0x20`, which includes space and newline."
msgstr "'--filter=combine:<filter1>+<filter2>+...<filterN>'的形式也可以用来组合几个过滤器，但这比重复'--filter'标志要难，通常没有必要。过滤器用'{plus}'连接，单个过滤器用%编码（即用URL编码）。 除了'{plus}'和'%'字符，以下字符是保留字符，也必须进行编码：`~！@#$^&*()[]{}/;\",<>?`+&#39;&#96;+以及所有ASCII代码为&lt;=`0x20`的字符，其中包括空格和换行。"

#. type: Plain text
#: en/rev-list-options.txt:992
#, priority:260
msgid "Other arbitrary characters can also be encoded. For instance, 'combine:tree:3+blob:none' and 'combine:tree%3A3+blob%3Anone' are equivalent."
msgstr "其他任意的字符也可以被编码。例如，'combined:tree:3+blob:none'和'combined:tree%3A3+blob%3Anone'是等同的。"

#. type: Plain text
#: en/rev-list-options.txt:995
#, placeholders:'`--filter=`', priority:260
msgid "Turn off any previous `--filter=` argument."
msgstr "关掉之前的任何`--filter=`参数。"

#. type: Labeled list
#: en/rev-list-options.txt:996
#, ignore-same, no-wrap, priority:260
msgid "--filter-provided-objects"
msgstr "--filter-provided-objects"

#. type: Plain text
#: en/rev-list-options.txt:1000
#, placeholders:'`--filter=`', priority:260
msgid "Filter the list of explicitly provided objects, which would otherwise always be printed even if they did not match any of the filters. Only useful with `--filter=`."
msgstr "过滤明确提供的对象的列表，否则，即使它们不符合任何过滤器，也会被打印出来。只对`--filter=`有用。"

#. type: Labeled list
#: en/rev-list-options.txt:1001
#, ignore-same, no-wrap, priority:260
msgid "--filter-print-omitted"
msgstr "--filter-print-omitted"

#. type: Plain text
#: en/rev-list-options.txt:1004
#, placeholders:'`--filter=`', priority:260
msgid "Only useful with `--filter=`; prints a list of the objects omitted by the filter. Object IDs are prefixed with a ``~'' character."
msgstr "只对`--filter=`有用；打印出被过滤器省略的对象的列表。 对象ID的前缀是``~''字符。"

#. type: Plain text
#: en/rev-list-options.txt:1011
#, placeholders:'--missing=error', priority:260
msgid "The form '--missing=error' requests that rev-list stop with an error if a missing object is encountered. This is the default action."
msgstr "形式'--missing=error'要求rev-list在遇到丢失的对象时以错误方式停止。 这是默认动作。"

#. type: Plain text
#: en/rev-list-options.txt:1015
#, placeholders:'--missing=allow-any', priority:260
msgid "The form '--missing=allow-any' will allow object traversal to continue if a missing object is encountered. Missing objects will silently be omitted from the results."
msgstr "'--missing=allow-any'的形式将允许在遇到缺失对象时继续进行对象遍历。 缺少的对象将被默默地从结果中省略掉。"

#. type: Plain text
#: en/rev-list-options.txt:1019
#, placeholders:'--missing=allow-promisor', priority:260
msgid "The form '--missing=allow-promisor' is like 'allow-any', but will only allow object traversal to continue for EXPECTED promisor missing objects. Unexpected missing objects will raise an error."
msgstr "'--missing=allow-promisor'的形式与'allow-any'相似，但只允许对预期的promisor缺失对象继续进行遍历。 意外的缺失对象将引发一个错误。"

#. type: Plain text
#: en/rev-list-options.txt:1022
#, placeholders:'--missing=print', priority:260
msgid "The form '--missing=print' is like 'allow-any', but will also print a list of the missing objects. Object IDs are prefixed with a ``?'' character."
msgstr "'--missing=print'的形式与'allow-any'相似，但也会打印出遗失对象的列表。 对象ID的前缀是\"？\"。"

#. type: Plain text
#: en/rev-list-options.txt:1029
#, placeholders:'`--missing=allow-promisor`', priority:260
msgid "(For internal use only.) Prefilter object traversal at promisor boundary. This is used with partial clone. This is stronger than `--missing=allow-promisor` because it limits the traversal, rather than just silencing errors about missing objects."
msgstr "仅供内部使用。）在希望者边界预过滤对象的遍历。 这是与部分克隆一起使用的。 这比`--missing=allow-promisor`更强，因为它限制了遍历，而不仅仅是消除了关于丢失对象的错误。"

#. type: Labeled list
#: en/rev-list-options.txt:1031
#, ignore-same, no-wrap, priority:260
msgid "--no-walk[=(sorted|unsorted)]"
msgstr "--no-walk[=(sorted|unsorted)]"

#. type: Plain text
#: en/rev-list-options.txt:1039
#, placeholders:'`--graph`', priority:260
msgid "Only show the given commits, but do not traverse their ancestors. This has no effect if a range is specified. If the argument `unsorted` is given, the commits are shown in the order they were given on the command line. Otherwise (if `sorted` or no argument was given), the commits are shown in reverse chronological order by commit time. Cannot be combined with `--graph`."
msgstr "只显示给定的提交，但不遍历其祖先。 如果指定了范围，这一点就没有影响。如果给了参数 `unsorted`，提交会按照命令行上的顺序显示。否则（如果 `sorted` 或者没有给出参数），提交将按照提交时间的倒序显示。 不能与 `--graph` 选项结合使用。"

#. type: Labeled list
#: en/rev-list-options.txt:1040
#, ignore-same, no-wrap, priority:260
msgid "--do-walk"
msgstr "--do-walk"

# ERROR: --no-walk not found in translation
#. type: Plain text
#: en/rev-list-options.txt:1042
#, placeholders:'`--no-walk`', priority:260
msgid "Overrides a previous `--no-walk`."
msgstr "覆盖之前的 `--no-walk` 。"

#. type: Title ~
#: en/rev-list-options.txt:1046
#, no-wrap, priority:260
msgid "Commit Formatting"
msgstr "承诺格式化"

#. type: Plain text
#: en/rev-list-options.txt:1052
#, placeholders:'linkgit:git-rev-list[1]':'linkgit:git-log[1]':'linkgit:git-show[1]':'linkgit:git-whatchanged[1]', priority:260
msgid "Using these options, linkgit:git-rev-list[1] will act similar to the more specialized family of commit log tools: linkgit:git-log[1], linkgit:git-show[1], and linkgit:git-whatchanged[1]"
msgstr "使用这些选项，linkgit:git-rev-list[1] 的作用类似于更专业的提交日志工具系列：linkgit:git-log[1]，linkgit:git-show[1]，和linkgit:git-whatchanged[1]"

#. type: Labeled list
#: en/rev-list-options.txt:1056
#, ignore-same, no-wrap, priority:260
msgid "--relative-date"
msgstr "--relative-date"

#. type: Plain text
#: en/rev-list-options.txt:1058
#, placeholders:'`--date=relative`', priority:260
msgid "Synonym for `--date=relative`."
msgstr "`--date=relative`的同义词。"

#. type: Plain text
#: en/rev-list-options.txt:1066
#, placeholders:'`--pretty`':'log.date':'`--date`', priority:260
msgid "Only takes effect for dates shown in human-readable format, such as when using `--pretty`. `log.date` config variable sets a default value for the log command's `--date` option. By default, dates are shown in the original time zone (either committer's or author's). If `-local` is appended to the format (e.g., `iso-local`), the user's local time zone is used instead."
msgstr "只对以人类可读格式显示的日期生效，例如使用`--pretty`时。`log.date`配置变量为日志命令的`--date`选项设置默认值。默认情况下，日期显示在原始时区（提交者或作者的时区）。如果`-local`被附加到格式中（例如，`iso-local`），就会使用用户的本地时区。"

#. type: Plain text
#: en/rev-list-options.txt:1071
#, placeholders:'`--date=relative`':'`--date=relative`', priority:260
msgid "`--date=relative` shows dates relative to the current time, e.g. ``2 hours ago''. The `-local` option has no effect for `--date=relative`."
msgstr "`--date=relative`显示相对于当前时间的日期，例如：`2小时前''。`--local`选项对`--date=relative`没有影响。"

#. type: Plain text
#: en/rev-list-options.txt:1073
#, placeholders:'`--date=local`':'`--date=default-local`', priority:260
msgid "`--date=local` is an alias for `--date=default-local`."
msgstr "`--date=local`是`--date=default-local`的一个别名。"

#. type: Plain text
#: en/rev-list-options.txt:1076
#, placeholders:'`--date=iso`':'`--date=iso8601`', priority:260
msgid "`--date=iso` (or `--date=iso8601`) shows timestamps in a ISO 8601-like format. The differences to the strict ISO 8601 format are:"
msgstr "`--date=iso`（或 `--date=iso8601` ）以类似 ISO 8601 的格式显示时间戳。 与严格的 ISO 8601 格式的区别是："

#. type: Plain text
#: en/rev-list-options.txt:1078
#, priority:260
msgid "a space instead of the `T` date/time delimiter"
msgstr "用空格代替`T`日期/时间分隔符"

#. type: Plain text
#: en/rev-list-options.txt:1079
#, priority:260
msgid "a space between time and time zone"
msgstr "时间和时区之间的空间"

#. type: Plain text
#: en/rev-list-options.txt:1080
#, priority:260
msgid "no colon between hours and minutes of the time zone"
msgstr "时区的小时和分钟之间没有冒号"

#. type: Plain text
#: en/rev-list-options.txt:1083
#, placeholders:'`--date=iso-strict`':'`--date=iso8601-strict`', priority:260
msgid "`--date=iso-strict` (or `--date=iso8601-strict`) shows timestamps in strict ISO 8601 format."
msgstr "`--date=iso-strict`（或`--date=iso8601-strict`）显示严格的ISO 8601格式的时间戳。"

#. type: Plain text
#: en/rev-list-options.txt:1086
#, placeholders:'`--date=rfc`':'`--date=rfc2822`', priority:260
msgid "`--date=rfc` (or `--date=rfc2822`) shows timestamps in RFC 2822 format, often found in email messages."
msgstr "`--date=rfc`（或`--date=rfc2822`）显示RFC 2822格式的时间戳，经常出现在电子邮件中。"

#. type: Plain text
#: en/rev-list-options.txt:1088
#, placeholders:'`--date=short`', priority:260
msgid "`--date=short` shows only the date, but not the time, in `YYYY-MM-DD` format."
msgstr "`--date=short`只显示日期，而不是时间，格式为`YYYY-MM-DD`。"

#. type: Plain text
#: en/rev-list-options.txt:1097
#, placeholders:'`--date=raw`', priority:260
msgid "`--date=raw` shows the date as seconds since the epoch (1970-01-01 00:00:00 UTC), followed by a space, and then the timezone as an offset from UTC (a `+` or `-` with four digits; the first two are hours, and the second two are minutes). I.e., as if the timestamp were formatted with `strftime(\"%s %z\")`). Note that the `-local` option does not affect the seconds-since-epoch value (which is always measured in UTC), but does switch the accompanying timezone value."
msgstr "`--date=raw`显示日期为自纪元以来的秒数（1970-01-01 00:00:00 UTC），后面是空格，然后是时区为UTC的偏移量（一个`+`或`-`的四位数字；前两位是小时，后两位是分钟）。也就是说，就像时间戳的格式为`strftime(\"%s %z\")`)。 请注意，`-local`选项不影响自始至终的秒数值（它总是以UTC为单位），但会切换伴随的时区值。"

#. type: Plain text
#: en/rev-list-options.txt:1104
#, placeholders:'`--date=human`', priority:260
msgid "`--date=human` shows the timezone if the timezone does not match the current time-zone, and doesn't print the whole date if that matches (ie skip printing year for dates that are \"this year\", but also skip the whole date itself if it's in the last few days and we can just say what weekday it was). For older dates the hour and minute is also omitted."
msgstr "`--date=human`如果时区与当前时区不匹配，则显示时区，如果匹配则不打印整个日期（即对于 \"今年 \"的日期，跳过打印年份，但如果是最近几天的日期，也跳过整个日期本身，我们可以只说是哪个工作日）。 对于较早的日期，小时和分钟也被省略了。"

#. type: Plain text
#: en/rev-list-options.txt:1108
#, placeholders:'`--date=unix`':'`--raw`', priority:260
msgid "`--date=unix` shows the date as a Unix epoch timestamp (seconds since 1970). As with `--raw`, this is always in UTC and therefore `-local` has no effect."
msgstr "`--date=unix`显示日期为Unix纪元时间戳（自1970年以来的秒数）。 与`--raw`一样，这总是以UTC为单位，因此`--local`没有影响。"

#. type: Plain text
#: en/rev-list-options.txt:1115
#, ignore-ellipsis, placeholders:'`--date=format':'`--date=format':'`--date=format-local', priority:260
msgid "`--date=format:...` feeds the format `...` to your system `strftime`, except for %s, %z, and %Z, which are handled internally. Use `--date=format:%c` to show the date in your system locale's preferred format. See the `strftime` manual for a complete list of format placeholders. When using `-local`, the correct syntax is `--date=format-local:...`."
msgstr "`--date=format:...` 将格式 `...` 输入到系统的 `strftime` 中，%z 和 %Z 除外，它们由内部处理。 使用 `--date=format:%c`，以系统语言首选的格式显示日期。 有关格式占位符的完整列表，请参阅 `strftime` 手册。使用 `-local` 时，正确的语法是 `--date=format-local:...`。"

#. type: Plain text
#: en/rev-list-options.txt:1121
#, placeholders:'`--date=default`', priority:260
msgid "`--date=default` is the default format, and is based on ctime(3) output. It shows a single line with three-letter day of the week, three-letter month, day-of-month, hour-minute-seconds in \"HH:MM:SS\" format, followed by 4-digit year, plus timezone information, unless the local time zone is used, e.g. `Thu Jan 1 00:00:00 1970 +0000`."
msgstr "`--date=default`是默认格式，基于ctime(3)输出。 它仅仅在一行中显示缩写的星期、缩写的月份、一月中的第几天、\"HH:MM:SS \"格式的小时-分钟-秒，然后是年份，除非使用本地时区，在末尾都会加上时区信息，例如`Thu Jan 1 00:00:00 1970 +0000`。"

#. type: Labeled list
#: en/rev-list-options.txt:1124
#, ignore-same, no-wrap, priority:260
msgid "--header"
msgstr "--header"

#. type: Plain text
#: en/rev-list-options.txt:1127
#, priority:260
msgid "Print the contents of the commit in raw-format; each record is separated with a NUL character."
msgstr "以原始格式打印提交的内容；每条记录用NUL字符分隔。"

#. type: Labeled list
#: en/rev-list-options.txt:1128
#, ignore-same, no-wrap, priority:260
msgid "--no-commit-header"
msgstr "--no-commit-header"

#. type: Plain text
#: en/rev-list-options.txt:1132
#, priority:260
msgid "Suppress the header line containing \"commit\" and the object ID printed before the specified format. This has no effect on the built-in formats; only custom formats are affected."
msgstr "抑制包含“提交”的标题行和在指定格式之前打印的对象 ID。这对内置格式没有影响；只有自定义格式会受到影响。"

#. type: Labeled list
#: en/rev-list-options.txt:1133
#, ignore-same, no-wrap, priority:260
msgid "--commit-header"
msgstr "--commit-header"

#. type: Plain text
#: en/rev-list-options.txt:1135
#, placeholders:'`--no-commit-header`', priority:260
msgid "Overrides a previous `--no-commit-header`."
msgstr "覆盖之前的 `--no-commit-header` 选项。"

#. type: Plain text
#: en/rev-list-options.txt:1140
#, ignore-ellipsis, priority:260
msgid "Print also the parents of the commit (in the form \"commit parent...\"). Also enables parent rewriting, see 'History Simplification' above."
msgstr "也可以打印提交的父类（以 \"提交父类... \"的形式）。 也可以启用父级改写，见上面的 \"历史简化\"。"

#. type: Labeled list
#: en/rev-list-options.txt:1141
#, ignore-same, no-wrap, priority:260
msgid "--children"
msgstr "--children"

#. type: Plain text
#: en/rev-list-options.txt:1144
#, ignore-ellipsis, priority:260
msgid "Print also the children of the commit (in the form \"commit child...\"). Also enables parent rewriting, see 'History Simplification' above."
msgstr "同时打印提交的子项（以 \"提交子项... \"的形式）。 也可以启用父级改写，见上面的 \"历史简化\"。"

#. type: Labeled list
#: en/rev-list-options.txt:1146
#, ignore-same, no-wrap, priority:260
msgid "--timestamp"
msgstr "--timestamp"

#. type: Plain text
#: en/rev-list-options.txt:1148
#, priority:260
msgid "Print the raw commit timestamp."
msgstr "打印原始提交时间戳。"

#. type: Labeled list
#: en/rev-list-options.txt:1150
#, ignore-same, no-wrap, priority:260
msgid "--left-right"
msgstr "--left-right"

# ERROR: --boundary not found in translation
#. type: Plain text
#: en/rev-list-options.txt:1155
#, placeholders:'`--boundary`', priority:260
msgid "Mark which side of a symmetric difference a commit is reachable from. Commits from the left side are prefixed with `<` and those from the right with `>`. If combined with `--boundary`, those commits are prefixed with `-`."
msgstr "标明提交可以从对称性差异的哪一边到达。 左边的提交以 `<` 为前缀，右边的则以 `>` 为前缀。 如果与 `--boundary` 结合，这些提交的前缀为 `-`。"

#. type: Plain text
#: en/rev-list-options.txt:1157
#, priority:260
msgid "For example, if you have this topology:"
msgstr "例如，如果你有这样的拓扑结构："

#. type: delimited block -
#: en/rev-list-options.txt:1164
#, no-wrap, placeholders:'y---b---b':'o---x---a---a', priority:260
msgid ""
"\t     y---b---b  branch B\n"
"\t    / \\ /\n"
"\t   /   .\n"
"\t  /   / \\\n"
"\t o---x---a---a  branch A\n"
msgstr ""
"\t     y---b---b  branch B\n"
"\t    / \\ /\n"
"\t   /   .\n"
"\t  /   / \\\n"
"\t o---x---a---a  branch A\n"

#. type: Plain text
#: en/rev-list-options.txt:1167
#, priority:260
msgid "you would get an output like this:"
msgstr "你会得到这样的输出："

#. type: delimited block -
#: en/rev-list-options.txt:1170
#, ignore-ellipsis, no-wrap, placeholders:'git rev-list':'--left-right':'--boundary':'--pretty=oneline', priority:260
msgid "\t$ git rev-list --left-right --boundary --pretty=oneline A...B\n"
msgstr "\t$ git rev-list --left-right --boundary --pretty=oneline A...B\n"

#. type: delimited block -
#: en/rev-list-options.txt:1177
#, ignore-ellipsis, no-wrap, priority:260
msgid ""
"\t>bbbbbbb... 3rd on b\n"
"\t>bbbbbbb... 2nd on b\n"
"\t<aaaaaaa... 3rd on a\n"
"\t<aaaaaaa... 2nd on a\n"
"\t-yyyyyyy... 1st on b\n"
"\t-xxxxxxx... 1st on a\n"
msgstr ""
"\t>bbbbbbb... 3rd on b\n"
"\t>bbbbbbb... 2nd on b\n"
"\t<aaaaaaa... 3rd on a\n"
"\t<aaaaaaa... 2nd on a\n"
"\t-yyyyyyy... 1st on b\n"
"\t-xxxxxxx... 1st on a\n"

#. type: Labeled list
#: en/rev-list-options.txt:1179
#, ignore-same, no-wrap, priority:260
msgid "--graph"
msgstr "--graph"

#. type: Plain text
#: en/rev-list-options.txt:1185
#, placeholders:'`--no-walk`', priority:260
msgid "Draw a text-based graphical representation of the commit history on the left hand side of the output. This may cause extra lines to be printed in between commits, in order for the graph history to be drawn properly. Cannot be combined with `--no-walk`."
msgstr "在输出的左手边绘制基于文本的提交历史图表。 这可能会导致在提交之间打印出额外的行，以便正确地绘制图形历史。 不能与`--no-walk`结合使用。"

#. type: Plain text
#: en/rev-list-options.txt:1187
#, priority:260
msgid "This enables parent rewriting, see 'History Simplification' above."
msgstr "这可以使父代改写，见上面的'历史简化'。"

#. type: Plain text
#: en/rev-list-options.txt:1190
#, placeholders:'`--topo-order`':'`--date-order`', priority:260
msgid "This implies the `--topo-order` option by default, but the `--date-order` option may also be specified."
msgstr "这意味着默认情况下是`--topo-order`选项，但也可以指定`--date-order`选项。"

#. type: Labeled list
#: en/rev-list-options.txt:1191
#, no-wrap, placeholders:'--show-linear-break', priority:260
msgid "--show-linear-break[=<barrier>]"
msgstr "--show-linear-break[=<阻隔>]"

#. type: Plain text
#: en/rev-list-options.txt:1197
#, placeholders:'--graph', priority:260
msgid "When --graph is not used, all history branches are flattened which can make it hard to see that the two consecutive commits do not belong to a linear branch. This option puts a barrier in between them in that case. If `<barrier>` is specified, it is the string that will be shown instead of the default one."
msgstr "如果不使用 --graph，所有的历史分支都会被压扁，这就很难看出两个连续的提交并不属于一个线性分支。在这种情况下，该选项会在它们之间设置一个障碍。如果指定了\"<barrier>\"，就会显示这个字符串，而不是默认的。"

# ERROR: --left-right not found in translation
# ERROR: --left-right not found in translation
#. type: Plain text
#: en/rev-list-options.txt:1207
#, placeholders:'`--left-right`':'`--cherry-mark`', priority:260
msgid "Print a number stating how many commits would have been listed, and suppress all other output. When used together with `--left-right`, instead print the counts for left and right commits, separated by a tab. When used together with `--cherry-mark`, omit patch equivalent commits from these counts and print the count for equivalent commits separated by a tab."
msgstr "打印一个数字，说明有多少提交会被列出，并抑制所有其他输出。 当与 `--left-right` 选项一起使用时，会打印左和右的提交计数，用制表符分开。当与 `--cherry-mark` 选项一起使用时，从这些计数中省略补丁等价提交，而打印等价提交的计数，用制表符分隔。"

#. type: Plain text
#: en/sequencer.txt:5
#, priority:100
msgid "Continue the operation in progress using the information in `.git/sequencer`. Can be used to continue after resolving conflicts in a failed cherry-pick or revert."
msgstr "使用`.git/sequencer`中的信息继续进行中的操作。 可以用来在解决拣选或还原失败的冲突后继续执行。"

#. type: Plain text
#: en/sequencer.txt:9
#, priority:100
msgid "Skip the current commit and continue with the rest of the sequence."
msgstr "跳过当前的提交，继续进行队列中其余的命令。"

#. type: Plain text
#: en/sequencer.txt:14
#, priority:100
msgid "Forget about the current operation in progress. Can be used to clear the sequencer state after a failed cherry-pick or revert."
msgstr "忽略当前正在进行的操作。 可以用来在拣选或还原失败之后清除序列器的状态。"

#. type: Plain text
#: en/sequencer.txt:16
#, priority:100
msgid "Cancel the operation and return to the pre-sequence state."
msgstr "取消操作并返回到预排序状态。"

#. type: Labeled list
#: en/signoff-option.txt:5
#, ignore-same, no-wrap, priority:280
msgid "--no-signoff"
msgstr "--no-signoff"

#. type: Plain text
#: en/signoff-option.txt:16
#, placeholders:'developercertificate.org', priority:280
msgid "Add a `Signed-off-by` trailer by the committer at the end of the commit log message. The meaning of a signoff depends on the project to which you're committing. For example, it may certify that the committer has the rights to submit the work under the project's license or agrees to some contributor representation, such as a Developer Certificate of Origin. (See https://developercertificate.org for the one used by the Linux kernel and Git projects.) Consult the documentation or leadership of the project to which you're contributing to understand how the signoffs are used in that project."
msgstr "在提交日志信息的末尾添加提交者的 \"Signed-off-by \"预告片。 签名的意义取决于你所提交的项目。 例如，它可以证明提交者有权利在项目许可下提交作品，或者同意一些贡献者的陈述，如开发者的原产地证书。 关于Linux内核和Git项目使用的证书，请参见http://developercertificate.org）。 请查阅你要贡献的项目的文档或领导层，以了解该项目如何使用签名。"

#. type: Plain text
#: en/signoff-option.txt:18
#, placeholders:'--no-signoff':'--signoff', priority:280
msgid "The --no-signoff option can be used to countermand an earlier --signoff option on the command line."
msgstr "--no-signoff选项可以用来反驳先前在命令行上的--signoff选项。"

#. type: Plain text
#: en/transfer-data-leaks.txt:11
#, priority:220
msgid "The fetch and push protocols are not designed to prevent one side from stealing data from the other repository that was not intended to be shared. If you have private data that you need to protect from a malicious peer, your best option is to store it in another repository. This applies to both clients and servers. In particular, namespaces on a server are not effective for read access control; you should only grant read access to a namespace to clients that you would trust with read access to the entire repository."
msgstr "获取和推送协议并不是为了防止一方从另一个版本库窃取不打算共享的数据。如果你有需要保护的私人数据不被恶意的同行窃取，你最好的选择是把它存储在另一个资源库中。这同时适用于客户端和服务器。特别是，服务器上的命名空间对于读取访问控制是无效的；你应该只将命名空间的读取访问权授予那些你信任的可以读取整个版本库的客户。"

#. type: Plain text
#: en/transfer-data-leaks.txt:13
#, priority:220
msgid "The known attack vectors are as follows:"
msgstr "已知的攻击媒介如下："

#. type: Plain text
#: en/transfer-data-leaks.txt:26
#, priority:220
msgid "The victim sends \"have\" lines advertising the IDs of objects it has that are not explicitly intended to be shared but can be used to optimize the transfer if the peer also has them. The attacker chooses an object ID X to steal and sends a ref to X, but isn't required to send the content of X because the victim already has it. Now the victim believes that the attacker has X, and it sends the content of X back to the attacker later. (This attack is most straightforward for a client to perform on a server, by creating a ref to X in the namespace the client has access to and then fetching it. The most likely way for a server to perform it on a client is to \"merge\" X into a public branch and hope that the user does additional work on this branch and pushes it back to the server without noticing the merge.)"
msgstr "受害者发送 \"have\" 行，宣传它所拥有的对象的 ID，这些对象并没有明确地打算被共享，但如果对等体也有这些对象，就可以用来优化传输。攻击者选择了一个对象 ID X 来窃取，并向 X 发送了一个引用，但不需要发送 X 的内容，因为受害者已经拥有它。现在，受害者认为攻击者拥有 X，它稍后将 X 的内容发回给攻击者。(这种攻击对于客户端来说在服务器上执行是最直接的，通过在客户端可以访问的命名空间中创建一个 X 的引用，然后获取它。服务器最可能在客户端执行的方式是将 X \"合并\" 到一个公共分支，并希望用户在这个分支上做额外的工作，然后在没有注意到合并的情况下将其推回给服务器。）"

#. type: Plain text
#: en/transfer-data-leaks.txt:30
#, priority:220
msgid "As in #1, the attacker chooses an object ID X to steal. The victim sends an object Y that the attacker already has, and the attacker falsely claims to have X and not Y, so the victim sends Y as a delta against X. The delta reveals regions of X that are similar to Y to the attacker."
msgstr "和 #1 一样，攻击者选择了一个对象 ID X 来偷窃。受害者发送了一个攻击者已经拥有的对象 Y，攻击者谎称拥有 X 而没有 Y，因此受害者发送 Y 作为对 X 的d elta，delta 向攻击者显示了 X 中与 Y 相似的区域。"

# ERROR: [[REMOTES]] not found in translation
#. type: Title -
#: en/urls-remotes.txt:4
#, no-wrap, placeholders:'[[REMOTES]]', priority:220
msgid "REMOTES[[REMOTES]]"
msgstr "REMOTES[[REMOTES]]"

#. type: Plain text
#: en/urls-remotes.txt:8
#, priority:220
msgid "The name of one of the following can be used instead of a URL as `<repository>` argument:"
msgstr "可以用下面的一个名称代替URL作为`<repository>`的参数："

#. type: Plain text
#: en/urls-remotes.txt:10
#, placeholders:'$GIT_DIR', priority:220
msgid "a remote in the Git configuration file: `$GIT_DIR/config`,"
msgstr "一个远端的配置文件在此仓库的git配置文件： `$GIT_DIR/config`、"

#. type: Plain text
#: en/urls-remotes.txt:11
#, placeholders:'$GIT_DIR', priority:220
msgid "a file in the `$GIT_DIR/remotes` directory, or"
msgstr "这个文件在`$GIT_DIR/remotes`目录下，或者"

#. type: Plain text
#: en/urls-remotes.txt:12
#, placeholders:'$GIT_DIR', priority:220
msgid "a file in the `$GIT_DIR/branches` directory."
msgstr "这个文件在`$GIT_DIR/branches`目录下。"

#. type: Plain text
#: en/urls-remotes.txt:15
#, priority:220
msgid "All of these also allow you to omit the refspec from the command line because they each contain a refspec which git will use by default."
msgstr "所有这些也允许你从命令行中省略refspec，因为它们都包含一个git默认使用的refspec。"

#. type: Title ~
#: en/urls-remotes.txt:17
#, no-wrap, priority:220
msgid "Named remote in configuration file"
msgstr "在配置文件中命名为 remote"

#. type: Plain text
#: en/urls-remotes.txt:26
#, placeholders:'linkgit:git-remote[1]':'linkgit:git-config[1]':'$GIT_DIR', priority:220
msgid "You can choose to provide the name of a remote which you had previously configured using linkgit:git-remote[1], linkgit:git-config[1] or even by a manual edit to the `$GIT_DIR/config` file. The URL of this remote will be used to access the repository. The refspec of this remote will be used by default when you do not provide a refspec on the command line. The entry in the config file would appear like this:"
msgstr "你可以选择提供你之前用 linkgit:git-remote[1]、linkgit:git-config[1] 或甚至通过手动编辑 `$GIT_DIR/config` 文件配置的远程名称。 这个远程的 URL 将被用来访问仓库。 当你没有在命令行上提供引用规范时，这个远程仓库的引用规范将被默认使用。 配置文件中的条目会像这样："

#. type: delimited block -
#: en/urls-remotes.txt:33
#, no-wrap, priority:220
msgid ""
"\t[remote \"<name>\"]\n"
"\t\turl = <URL>\n"
"\t\tpushurl = <pushurl>\n"
"\t\tpush = <refspec>\n"
"\t\tfetch = <refspec>\n"
msgstr ""
"\t[remote \"<名称>\"]\n"
"\t\turl = <地址>\n"
"\t\tpushurl = <推送地址>\n"
"\t\tpush = <引用规范>\n"
"\t\tfetch = <引用规范>\n"

#. type: Plain text
#: en/urls-remotes.txt:39
#, priority:220
msgid "The `<pushurl>` is used for pushes only. It is optional and defaults to `<URL>`. Pushing to a remote affects all defined pushurls or all defined urls if no pushurls are defined. Fetch, however, will only fetch from the first defined url if multiple urls are defined."
msgstr "`<推送地址>` 仅用于推送。它是可选的，默认为 `<URL>`。向远程推送会影响所有定义的推送urls，如果没有定义推送urls，则推送到所有定义的url。然而，如果定义了多个 URL，fetch 将只从第一个定义的 URL 获取。"

#. type: Title ~
#: en/urls-remotes.txt:41
#, no-wrap, placeholders:'$GIT_DIR', priority:220
msgid "Named file in `$GIT_DIR/remotes`"
msgstr "`$GIT_DIR/remotes` 中的命名文件"

#. type: Plain text
#: en/urls-remotes.txt:49
#, placeholders:'$GIT_DIR', priority:220
msgid "You can choose to provide the name of a file in `$GIT_DIR/remotes`. The URL in this file will be used to access the repository. The refspec in this file will be used as default when you do not provide a refspec on the command line. This file should have the following format:"
msgstr "你可以选择提供 `$GIT_DIR/remotes` 中的文件名。 这个文件中的 URL 将被用来访问仓库。 当你没有在命令行上提供引用规范时，该文件中的引用规范将被作为默认使用。 这个文件应该有以下格式："

#. type: delimited block -
#: en/urls-remotes.txt:54
#, no-wrap, priority:220
msgid ""
"\tURL: one of the above URL formats\n"
"\tPush: <refspec>\n"
"\tPull: <refspec>\n"
msgstr ""
"\tURL: one of the above URL format\n"
"\tPush: <引用规范>\n"
"\tPull: <引用规范>\n"

#. type: Plain text
#: en/urls-remotes.txt:61
#, priority:220
msgid "`Push:` lines are used by 'git push' and `Pull:` lines are used by 'git pull' and 'git fetch'. Multiple `Push:` and `Pull:` lines may be specified for additional branch mappings."
msgstr "`Push:` 行被 'git push' 使用，`Pull:` 行被 'git pull' 和 'git fetch' 使用。 可以为额外的分支映射指定多个 `Push:` 和 `Pull:` 行。"

#. type: Title ~
#: en/urls-remotes.txt:63
#, no-wrap, placeholders:'$GIT_DIR', priority:220
msgid "Named file in `$GIT_DIR/branches`"
msgstr "`$GIT_DIR/branches` 中的命名文件"

#. type: Plain text
#: en/urls-remotes.txt:69
#, placeholders:'$GIT_DIR', priority:220
msgid "You can choose to provide the name of a file in `$GIT_DIR/branches`. The URL in this file will be used to access the repository. This file should have the following format:"
msgstr "你可以选择提供 `$GIT_DIR/branches` 中的文件名。 这个文件中的 URL 将被用来访问仓库。 这个文件应该有以下格式："

#. type: delimited block -
#: en/urls-remotes.txt:73
#, no-wrap, priority:220
msgid "\t<URL>#<head>\n"
msgstr "\t<URL>#<head>\n"

#. type: Plain text
#: en/urls-remotes.txt:76
#, priority:220
msgid "`<URL>` is required; `#<head>` is optional."
msgstr "`<URL>` 是必须的；`#<head>` 是可选的。"

#. type: Plain text
#: en/urls-remotes.txt:81
#, placeholders:'$GIT_DIR', priority:220
msgid "Depending on the operation, git will use one of the following refspecs, if you don't provide one on the command line. `<branch>` is the name of this file in `$GIT_DIR/branches` and `<head>` defaults to `master`."
msgstr "根据不同的操作，如果你没有在命令行上提供一个引用规范，git 会使用以下其中一个。 `<分支>` 是该文件在 `$GIT_DIR/branches` 中的名称，`<头分支>` 默认为 `master`。"

#. type: Plain text
#: en/urls-remotes.txt:83
#, priority:220
msgid "git fetch uses:"
msgstr "git fetch 使用："

#. type: delimited block -
#: en/urls-remotes.txt:86
#, no-wrap, priority:220
msgid "\trefs/heads/<head>:refs/heads/<branch>\n"
msgstr "\trefs/heads/<头分支>:refs/heads/<分支>。\n"

#. type: Plain text
#: en/urls-remotes.txt:89
#, priority:220
msgid "git push uses:"
msgstr "git push 使用："

#. type: delimited block -
#: en/urls-remotes.txt:92
#, no-wrap, placeholders:'HEAD', priority:220
msgid "\tHEAD:refs/heads/<head>\n"
msgstr "\tHEAD:refs/heads/<头分支>。\n"

#. type: Title -
#: en/urls.txt:2
#, no-wrap, placeholders:'[[URLS]]', priority:300
msgid "GIT URLS[[URLS]]"
msgstr "GIT 地址[[URLS]]"

#. type: Plain text
#: en/urls.txt:8
#, priority:300
msgid "In general, URLs contain information about the transport protocol, the address of the remote server, and the path to the repository. Depending on the transport protocol, some of this information may be absent."
msgstr "通常，地址包含有关传输协议，远程服务器的地址以及仓库路径的信息。对于某些传输协议，一些信息可能会缺失。"

#. type: Plain text
#: en/urls.txt:12
#, priority:300
msgid "Git supports ssh, git, http, and https protocols (in addition, ftp and ftps can be used for fetching, but this is inefficient and deprecated; do not use them)."
msgstr "Git 支持 ssh，git，http 和 https 协议（此外，可以使用 ftp 和 ftps 进行抓取，但这效率低下且不建议使用；请勿使用）。"

#. type: Plain text
#: en/urls.txt:15
#, priority:300
msgid "The native transport (i.e. git:// URL) does no authentication and should be used with caution on unsecured networks."
msgstr "本地传输（即 git:// URL）不进行身份验证，在不安全的网络上应谨慎使用。"

#. type: Plain text
#: en/urls.txt:17
#, priority:300
msgid "The following syntaxes may be used with them:"
msgstr "以下是上述几个传输协议的格式："

#. type: Plain text
#: en/urls.txt:19
#, placeholders:'{startsb}':'{endsb}':'{startsb}':'{endsb}', priority:300
msgid "ssh://{startsb}user@{endsb}host.xz{startsb}:port{endsb}/path/to/repo.git/"
msgstr "ssh://{startsb}user@{endsb}host.xz{startsb}:port{endsb}/path/to/repo.git/"

#. type: Plain text
#: en/urls.txt:20
#, placeholders:'{startsb}':'{endsb}', priority:300
msgid "git://host.xz{startsb}:port{endsb}/path/to/repo.git/"
msgstr "git://host.xz{startsb}:port{endsb}/path/to/repo.git/"

#. type: Plain text
#: en/urls.txt:21
#, placeholders:'{startsb}':'{endsb}':'{startsb}':'{endsb}', priority:300
msgid "http{startsb}s{endsb}://host.xz{startsb}:port{endsb}/path/to/repo.git/"
msgstr "http{startsb}s{endsb}://host.xz{startsb}:port{endsb}/path/to/repo.git/"

#. type: Plain text
#: en/urls.txt:22
#, placeholders:'{startsb}':'{endsb}':'{startsb}':'{endsb}', priority:300
msgid "ftp{startsb}s{endsb}://host.xz{startsb}:port{endsb}/path/to/repo.git/"
msgstr "ftp{startsb}s{endsb}://host.xz{startsb}:port{endsb}/path/to/repo.git/"

#. type: Plain text
#: en/urls.txt:24
#, priority:300
msgid "An alternative scp-like syntax may also be used with the ssh protocol:"
msgstr "ssh 协议也可以使用类似 scp 的语法："

#. type: Plain text
#: en/urls.txt:26
#, placeholders:'{startsb}':'{endsb}', priority:300
msgid "{startsb}user@{endsb}host.xz:path/to/repo.git/"
msgstr "{startsb}user@{endsb}host.xz:path/to/repo.git/"

#. type: Plain text
#: en/urls.txt:32
#, priority:300
msgid "This syntax is only recognized if there are no slashes before the first colon. This helps differentiate a local path that contains a colon. For example the local path `foo:bar` could be specified as an absolute path or `./foo:bar` to avoid being misinterpreted as an ssh url."
msgstr "仅当第一个冒号之前没有斜杠时才能识别此语法。这有助于区分包含冒号的本地路径。例如，可以将本地路径 `foo:bar` 指定为绝对路径，或者将 `./foo:bar` 指定为绝对路径，以避免被误识别为 ssh url。"

#. type: Plain text
#: en/urls.txt:34
#, priority:300
msgid "The ssh and git protocols additionally support ~username expansion:"
msgstr "ssh 和 git 协议还支持 ~username 扩展："

#. type: Plain text
#: en/urls.txt:36
#, placeholders:'{startsb}':'{endsb}':'{startsb}':'{endsb}':'{startsb}':'{endsb}', priority:300
msgid "ssh://{startsb}user@{endsb}host.xz{startsb}:port{endsb}/~{startsb}user{endsb}/path/to/repo.git/"
msgstr "ssh://{startsb}user@{endsb}host.xz{startsb}:port{endsb}/~{startsb}user{endsb}/path/to/repo.git/"

#. type: Plain text
#: en/urls.txt:37
#, placeholders:'{startsb}':'{endsb}':'{startsb}':'{endsb}', priority:300
msgid "git://host.xz{startsb}:port{endsb}/~{startsb}user{endsb}/path/to/repo.git/"
msgstr "git://host.xz{startsb}:port{endsb}/~{startsb}user{endsb}/path/to/repo.git/"

#. type: Plain text
#: en/urls.txt:38
#, placeholders:'{startsb}':'{endsb}':'{startsb}':'{endsb}', priority:300
msgid "{startsb}user@{endsb}host.xz:/~{startsb}user{endsb}/path/to/repo.git/"
msgstr "{startsb}user@{endsb}host.xz:/~{startsb}user{endsb}/path/to/repo.git/"

#. type: Plain text
#: en/urls.txt:41
#, priority:300
msgid "For local repositories, also supported by Git natively, the following syntaxes may be used:"
msgstr "对于本地仓库（Git 本身也支持），可以使用以下语法："

#. type: Plain text
#: en/urls.txt:43
#, priority:300
msgid "/path/to/repo.git/"
msgstr "/path/to/repo.git/"

#. type: Plain text
#: en/urls.txt:44
#, priority:300
msgid "\\file:///path/to/repo.git/"
msgstr "\\file:///path/to/repo.git/"

#. type: Plain text
#: en/urls.txt:49
#, placeholders:'--local':'linkgit:git-clone[1]', priority:300
msgid "These two syntaxes are mostly equivalent, except when cloning, when the former implies --local option. See linkgit:git-clone[1] for details."
msgstr "这两种语法几乎是等效的，除了在克隆时，前者暗含 --local 选项。有关详细信息，请参阅 linkgit:git-clone[1]。"

#. type: Plain text
#: en/urls.txt:54
#, placeholders:'--local', priority:300
msgid "These two syntaxes are mostly equivalent, except the former implies --local option."
msgstr "这两种语法几乎是等效的，除了前者暗含 --local 选项。"

#. type: Plain text
#: en/urls.txt:58
#, placeholders:'linkgit:git-bundle[1]', priority:300
msgid "'git clone', 'git fetch' and 'git pull', but not 'git push', will also accept a suitable bundle file. See linkgit:git-bundle[1]."
msgstr "'git clone'、'git fetch' 和 'git pull'（但不包括 'git push'）也会接受合适的捆绑包文件。参见 linkgit:git-bundle[1]。"

#. type: Plain text
#: en/urls.txt:63
#, priority:300
msgid "When Git doesn't know how to handle a certain transport protocol, it attempts to use the 'remote-<transport>' remote helper, if one exists. To explicitly request a remote helper, the following syntax may be used:"
msgstr "当 Git 不知道如何处理某种传输协议时，它会尝试使用 'remote-<传输方式>' 远程帮助程序（如果存在）。要显式请求远程帮助程序，可以使用以下语法："

#. type: Plain text
#: en/urls.txt:65
#, priority:300
msgid "<transport>::<address>"
msgstr "<传送>::<地址>"

#. type: Plain text
#: en/urls.txt:69
#, placeholders:'linkgit:gitremote-helpers[7]', priority:300
msgid "where <address> may be a path, a server and path, or an arbitrary URL-like string recognized by the specific remote helper being invoked. See linkgit:gitremote-helpers[7] for details."
msgstr "其中，<地址> 可以是路径，服务器与路径，也可以是可被调用的特定远程帮助程序识别的类似于网页地址的任意字符串。有关详细信息，请参阅 linkgit:gitremote-helpers[7]。"

#. type: Plain text
#: en/urls.txt:74
#, priority:300
msgid "If there are a large number of similarly-named remote repositories and you want to use a different format for them (such that the URLs you use will be rewritten into URLs that work), you can create a configuration section of the form:"
msgstr "如果存在大量类似名称的远程仓库，并且您要为其使用不同的格式（这样，您使用的地址将被重写为有效的地址），则可以创建以下形式的配置："

#. type: delimited block -
#: en/urls.txt:78
#, no-wrap, priority:300
msgid ""
"\t[url \"<actual-url-base>\"]\n"
"\t\tinsteadOf = <other-url-base>\n"
msgstr ""
"\t[url \"<实际基础网址>\"]\n"
"\t\tinsteadOf = <其他基础网址>\n"

#. type: Plain text
#: en/urls.txt:81 en/urls.txt:100
#, priority:300
msgid "For example, with this:"
msgstr "例如，有如下："

#. type: delimited block -
#: en/urls.txt:86
#, no-wrap, priority:300
msgid ""
"\t[url \"git://git.host.xz/\"]\n"
"\t\tinsteadOf = host.xz:/path/to/\n"
"\t\tinsteadOf = work:\n"
msgstr ""
"\t[url \"git://git.host.xz/\"]\n"
"\t\tinsteadOf = host.xz:/path/to/\n"
"\t\tinsteadOf = work:\n"

#. type: Plain text
#: en/urls.txt:90
#, priority:300
msgid "a URL like \"work:repo.git\" or like \"host.xz:/path/to/repo.git\" will be rewritten in any context that takes a URL to be \"git://git.host.xz/repo.git\"."
msgstr "诸如 \"work:repo.git\" 或 \"host.xz:/path/to/repo.git\" 的地址会在任何类似于 \"git://git.host.xz/repo\" 地址的上下文中重写。"

#. type: Plain text
#: en/urls.txt:93
#, priority:300
msgid "If you want to rewrite URLs for push only, you can create a configuration section of the form:"
msgstr "如果要重写仅用于推送的地址，可以创建表单的配置部分："

#. type: delimited block -
#: en/urls.txt:97
#, no-wrap, priority:300
msgid ""
"\t[url \"<actual-url-base>\"]\n"
"\t\tpushInsteadOf = <other-url-base>\n"
msgstr ""
"\t[url \"<实际基础网址>\"]\n"
"\t\tpushInsteadOf = <其他基础网址>\n"

#. type: delimited block -
#: en/urls.txt:104
#, no-wrap, priority:300
msgid ""
"\t[url \"ssh://example.org/\"]\n"
"\t\tpushInsteadOf = git://example.org/\n"
msgstr ""
"\t[url \"ssh://example.org/\"]\n"
"\t\tpushInsteadOf = git://example.org/\n"

#. type: Plain text
#: en/urls.txt:108
#, priority:300
msgid "a URL like \"git://example.org/path/to/repo.git\" will be rewritten to \"ssh://example.org/path/to/repo.git\" for pushes, but pulls will still use the original URL."
msgstr "类似于 \"git://example.org/path/to/repo.git\" 的地址会被重写为 \"ssh://example.org/path/to/repo.git\"，用于推送。但拉取代码时仍然使用原始的地址。"

#. type: Title =
#: en/git-bisect-lk2009.txt:2
#, no-wrap, priority:100
msgid "Fighting regressions with git bisect"
msgstr "用Git二分查找解决回退问题"

#. type: Title -
#: en/git-bisect-lk2009.txt:8
#, no-wrap, priority:100
msgid "Abstract"
msgstr "摘要"

#. type: Plain text
#: en/git-bisect-lk2009.txt:17
#, priority:100
msgid "\"git bisect\" enables software users and developers to easily find the commit that introduced a regression. We show why it is important to have good tools to fight regressions. We describe how \"git bisect\" works from the outside and the algorithms it uses inside. Then we explain how to take advantage of \"git bisect\" to improve current practices. And we discuss how \"git bisect\" could improve in the future."
msgstr "\"Git二分查找\"使软件用户和开发者能够轻松找到引入回退的提交。我们展示了为什么拥有好的工具来解决回退是很重要的。我们描述了 \"Git二分查找 \"从外部如何工作，以及它在内部使用的算法。然后我们解释如何利用 \"Git二分查找\"来改进当前的体验。我们还讨论了 \"Git二分查找\"在未来可以如何改进。"

#. type: Title -
#: en/git-bisect-lk2009.txt:20
#, no-wrap, priority:100
msgid "Introduction to \"git bisect\""
msgstr "\"git bisect\" 简介"

#. type: Plain text
#: en/git-bisect-lk2009.txt:24
#, priority:100
msgid "Git is a Distributed Version Control system (DVCS) created by Linus Torvalds and maintained by Junio Hamano."
msgstr "Git是一个分布式版本控制系统（DVCS），由Linus Torvalds（一般指 林纳斯·本纳第克特·托瓦兹；Linux之父）创建，由Junio Hamano（ Junio C Hamano；滨野 纯）维护。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:30
#, priority:100
msgid "In Git like in many other Version Control Systems (VCS), the different states of the data that is managed by the system are called commits. And, as VCS are mostly used to manage software source code, sometimes \"interesting\" changes of behavior in the software are introduced in some commits."
msgstr "在Git中，像许多其他版本控制系统（VCS）一样，由系统管理的数据的不同状态被称为提交。而且，由于版本控制系统主要用于管理软件源代码，有时会在一些提交中引入软件中 \"有趣 \"的行为变化。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:37
#, priority:100
msgid "In fact people are specially interested in commits that introduce a \"bad\" behavior, called a bug or a regression. They are interested in these commits because a commit (hopefully) contains a very small set of source code changes. And it's much easier to understand and properly fix a problem when you only need to check a very small set of changes, than when you don't know where look in the first place."
msgstr "事实上，人们对那些引入 \"坏 \"行为的提交特别感兴趣，这些行为被称为错误或回归。他们之所以对这些提交感兴趣，是因为一个提交（希望）只包含一组非常小的源代码改动。当你只需要检查很小的改动时，理解和正确修复一个问题要比你不知道从哪里找问题容易得多。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:45
#, priority:100
msgid "So to help people find commits that introduce a \"bad\" behavior, the \"git bisect\" set of commands was invented. And it follows of course that in \"git bisect\" parlance, commits where the \"interesting behavior\" is present are called \"bad\" commits, while other commits are called \"good\" commits. And a commit that introduce the behavior we are interested in is called a \"first bad commit\". Note that there could be more than one \"first bad commit\" in the commit space we are searching."
msgstr "所以为了帮助人们找到引入 \"坏 \"行为的提交，发明了 \"Git二分查找\"命令集。当然，在 \"Git二分查找\"的说法中，存在 \"有趣行为 \"的提交被称为 \"坏 \"提交，而其他提交被称为 \"好 \"提交。而引入我们感兴趣的行为的提交被称为 \"第一个坏提交\"。请注意，在我们搜索的提交空间中，可能存在不止一个 \"第一个坏提交\"。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:48
#, priority:100
msgid "So \"git bisect\" is designed to help find a \"first bad commit\". And to be as efficient as possible, it tries to perform a binary search."
msgstr "因此，\"Git二分查找\"被设计用来帮助找到 \"第一个坏提交\"。为了尽可能的高效，它试图进行二分查找。"

#. type: Title -
#: en/git-bisect-lk2009.txt:51
#, no-wrap, priority:100
msgid "Fighting regressions overview"
msgstr "解决回退概述"

#. type: Title ~
#: en/git-bisect-lk2009.txt:54
#, no-wrap, priority:100
msgid "Regressions: a big problem"
msgstr "回退：一个大问题"

#. type: Plain text
#: en/git-bisect-lk2009.txt:58
#, priority:100
msgid "Regressions are a big problem in the software industry. But it's difficult to put some real numbers behind that claim."
msgstr "回退是软件行业的一个大问题。但是很难用数字来说明这个问题。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:61
#, placeholders:'<<1>>', priority:100
msgid "There are some numbers about bugs in general, like a NIST study in 2002 <<1>> that said:"
msgstr "有一些关于一般bug的数字，比如2002年NIST的一项研究<<1>>写道："

#. type: delimited block _
#: en/git-bisect-lk2009.txt:78
#, priority:100
msgid "Software bugs, or errors, are so prevalent and so detrimental that they cost the U.S. economy an estimated $59.5 billion annually, or about 0.6 percent of the gross domestic product, according to a newly released study commissioned by the Department of Commerce's National Institute of Standards and Technology (NIST). At the national level, over half of the costs are borne by software users and the remainder by software developers/vendors. The study also found that, although all errors cannot be removed, more than a third of these costs, or an estimated $22.2 billion, could be eliminated by an improved testing infrastructure that enables earlier and more effective identification and removal of software defects. These are the savings associated with finding an increased percentage (but not 100 percent) of errors closer to the development stages in which they are introduced. Currently, over half of all errors are not found until \"downstream\" in the development process or during post-sale software use."
msgstr "根据美国商务部国家标准与技术研究所（NIST）新近发布的一项研究，软件缺陷或错误是非常普遍且是灾难性的，以至于它们每年给美国经济造成约595亿美元的损失，或约占国内生产总值的0.6%。在全国范围内，超过一半的成本由软件用户承担，其余的由软件开发商/供应商承担。 该研究还发现，尽管所有的错误都无法消除，但通过改进测试基础架构，能够更早、更有效地识别和消除软件缺陷，可以消除这些成本的三分之一以上，即估计为222亿美元。这些都是在更接近错误发生的开发阶段发现更高比例（但不是100%）的错误所带来的节约。目前，超过一半的错误是在开发过程的 \"下游 \"或售后软件使用期间才被发现的。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:81
#, priority:100
msgid "And then:"
msgstr "然后："

#. type: delimited block _
#: en/git-bisect-lk2009.txt:87
#, priority:100
msgid "Software developers already spend approximately 80 percent of development costs on identifying and correcting defects, and yet few products of any type other than software are shipped with such high levels of errors."
msgstr "软件开发人员已经将大约80%的开发成本用于识别和纠正缺陷，然而，除了软件之外，很少有其他类型的产品在出厂时出现如此高的错误。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:90
#, priority:100
msgid "Eventually the conclusion started with:"
msgstr "最终结论是："

#. type: delimited block _
#: en/git-bisect-lk2009.txt:94
#, priority:100
msgid "The path to higher software quality is significantly improved software testing."
msgstr "改善软件测试是通往更高的软件质量的道路最为有效的方式。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:98
#, placeholders:'<<2>>', priority:100
msgid "There are other estimates saying that 80% of the cost related to software is about maintenance <<2>>."
msgstr "还有人估计说，与软件有关的成本中有80%是关于维护的<<2>>。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:100
#, placeholders:'<<3>>', priority:100
msgid "Though, according to Wikipedia <<3>>:"
msgstr "尽管，根据维基百科<<3>>的说法："

#. type: delimited block _
#: en/git-bisect-lk2009.txt:108
#, priority:100
msgid "A common perception of maintenance is that it is merely fixing bugs. However, studies and surveys over the years have indicated that the majority, over 80%, of the maintenance effort is used for non-corrective actions (Pigosky 1997). This perception is perpetuated by users submitting problem reports that in reality are functionality enhancements to the system."
msgstr "人们对维护工作的普遍看法是，它仅仅是在修复错误。然而，多年来的研究和调查表明，大部分（超过80%）的维护工作都是用于非纠正性的行动（Pigosky 1997）。用户提交的问题报告实际上是对系统功能的提升，这使得这种看法得以延续。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:113
#, priority:100
msgid "But we can guess that improving on existing software is very costly because you have to watch out for regressions. At least this would make the above studies consistent among themselves."
msgstr "但我们可以猜测，在现有软件上进行改进的代价是非常昂贵的，因为你必须注意功能退步的问题。至少这可以使上述研究之间保持一致。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:121
#, priority:100
msgid "Of course some kind of software is developed, then used during some time without being improved on much, and then finally thrown away. In this case, of course, regressions may not be a big problem. But on the other hand, there is a lot of big software that is continually developed and maintained during years or even tens of years by a lot of people. And as there are often many people who depend (sometimes critically) on such software, regressions are a really big problem."
msgstr "当然，有些软件被开发出来，然后在一段时间内使用中，没有得到很大的改进，最后被废弃。当然，在这种情况下，退步可能不是一个大问题。但另一方面，有很多大型软件是由很多人在几年甚至几十几年的时间里不断开发和维护的。由于经常有许多人依赖这种软件（有时是关键性的），所以回退是一个真正的大问题。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:128
#, priority:100
msgid "One such software is the Linux kernel. And if we look at the Linux kernel, we can see that a lot of time and effort is spent to fight regressions. The release cycle start with a 2 weeks long merge window. Then the first release candidate (rc) version is tagged. And after that about 7 or 8 more rc versions will appear with around one week between each of them, before the final release."
msgstr "Linux内核就是这样一个软件。如果我们看一下Linux内核，我们可以看到花了大量的时间和精力来对抗退步。发布周期从2周的合并窗口开始。然后，第一个候选版本（rc）被标记。在那之后，在最终发布之前，大约还有7到8个rc版本会出现，每个版本之间相隔一周左右。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:134
#, priority:100
msgid "The time between the first rc release and the final release is supposed to be used to test rc versions and fight bugs and especially regressions. And this time is more than 80% of the release cycle time. But this is not the end of the fight yet, as of course it continues after the release."
msgstr "从第一个rc版本到最终版本之间的时间应该是用来测试rc版本和解决bug，特别是回退问题。而这段时间占到了发布周期的80%以上。发布并不意味着战斗结束，因为bug在发布后还会继续出现。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:137
#, priority:100
msgid "And then this is what Ingo Molnar (a well known Linux kernel developer) says about his use of git bisect:"
msgstr "然后这是Ingo Molnar（一位知名的Linux内核开发者）对他正在使用的Git二分查找的评价："

#. type: delimited block _
#: en/git-bisect-lk2009.txt:143
#, priority:100
msgid "I most actively use it during the merge window (when a lot of trees get merged upstream and when the influx of bugs is the highest) - and yes, there have been cases that i used it multiple times a day. My average is roughly once a day."
msgstr "我在合并窗口期最积极地使用它（当大量的树被合并到上游时，也是bug涌入最多的时候），有一些情况下，我一天要多次使用。我的平均使用频率大约是每天一次。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:149
#, priority:100
msgid "So regressions are fought all the time by developers, and indeed it is well known that bugs should be fixed as soon as possible, so as soon as they are found. That's why it is interesting to have good tools for this purpose."
msgstr "因此，开发人员一直在与回退作斗争，事实上，众所周知，错误应该被尽快修复，所以一旦发现就应该尽快修复。这就是为什么有好的工具来达到这个目的是很有趣的。"

#. type: Title ~
#: en/git-bisect-lk2009.txt:151
#, no-wrap, priority:100
msgid "Other tools to fight regressions"
msgstr "解决回退的其他工具"

#. type: Plain text
#: en/git-bisect-lk2009.txt:156
#, priority:100
msgid "So what are the tools used to fight regressions? They are nearly the same as those used to fight regular bugs. The only specific tools are test suites and tools similar as \"git bisect\"."
msgstr "那么，用于解决回退的工具是什么呢？它们几乎与那些用来对付常规bug的工具相同。唯一特殊的工具是测试套件和类似于 \"Git二分查找\"的工具。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:162
#, priority:100
msgid "Test suites are very nice. But when they are used alone, they are supposed to be used so that all the tests are checked after each commit. This means that they are not very efficient, because many tests are run for no interesting result, and they suffer from combinatorial explosion."
msgstr "测试套件是非常好的。但当它们被单独使用时，它们应该被用来在每次提交后检查所有的测试。这意味着它们的效率并不高，因为许多测试的运行并没有意外的结果，而且它们会受到组合的影响。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:167
#, priority:100
msgid "In fact the problem is that big software often has many different configuration options and that each test case should pass for each configuration after each commit. So if you have for each release: N configurations, M commits and T test cases, you should perform:"
msgstr "事实上，问题在于大型软件通常有许多不同的配置选项，每次提交后，每个测试用例都应该通过每个配置。因此，如果你对每个版本有N个配置，M个提交，T个测试用例，你应该执行："

#. type: delimited block -
#: en/git-bisect-lk2009.txt:170
#, no-wrap, priority:100
msgid "N * M * T tests\n"
msgstr "N * M * T 个测试\n"

#. type: Plain text
#: en/git-bisect-lk2009.txt:173
#, priority:100
msgid "where N, M and T are all growing with the size your software."
msgstr "其中N、M和T都是随着你的软件大小而增长的。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:175
#, priority:100
msgid "So very soon it will not be possible to completely test everything."
msgstr "因此，很快就不可能对所有的东西进行测试。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:182
#, priority:100
msgid "And if some bugs slip through your test suite, then you can add a test to your test suite. But if you want to use your new improved test suite to find where the bug slipped in, then you will either have to emulate a bisection process or you will perhaps bluntly test each commit backward starting from the \"bad\" commit you have which may be very wasteful."
msgstr "而如果有些bug在你的测试套件中溜走了，那么你可以在你的测试套件中增加一个测试。但是，如果你想用你新改进的测试套件来找到bug溜进去的地方，那么你将不得不模仿一分为二的过程，或者你也许会直截了当地从你的 \"坏 \"提交开始向后测试每个提交，这可能是非常浪费的。"

#. type: Title -
#: en/git-bisect-lk2009.txt:184
#, no-wrap, priority:100
msgid "\"git bisect\" overview"
msgstr "\"git bisect\" 概览"

#. type: Title ~
#: en/git-bisect-lk2009.txt:187
#, no-wrap, priority:100
msgid "Starting a bisection"
msgstr "开始二分"

#. type: Plain text
#: en/git-bisect-lk2009.txt:194
#, priority:100
msgid "The first \"git bisect\" subcommand to use is \"git bisect start\" to start the search. Then bounds must be set to limit the commit space. This is done usually by giving one \"bad\" and at least one \"good\" commit. They can be passed in the initial call to \"git bisect start\" like this:"
msgstr "第一个要使用的 \"Git二分查找\"子命令是 \"git bisect start \"来开始搜索。然后必须设置边界来限制提交空间。这通常是通过给出一个 \"坏 \"和至少一个 \"好 \"的提交来实现的。它们可以像这样在初始调用 \"git bisect start \"时传递："

#. type: delimited block -
#: en/git-bisect-lk2009.txt:197
#, ignore-ellipsis, no-wrap, priority:100
msgid "$ git bisect start [BAD [GOOD...]]\n"
msgstr "$ git bisect start [BAD [GOOD...]]\n"

#. type: Plain text
#: en/git-bisect-lk2009.txt:200
#, priority:100
msgid "or they can be set using:"
msgstr "或者可以用以下方式设置："

#. type: delimited block -
#: en/git-bisect-lk2009.txt:203
#, no-wrap, priority:100
msgid "$ git bisect bad [COMMIT]\n"
msgstr "$ git bisect bad [COMMIT]\n"

#. type: Plain text
#: en/git-bisect-lk2009.txt:206
#, priority:100
msgid "and:"
msgstr "与："

#. type: delimited block -
#: en/git-bisect-lk2009.txt:209
#, ignore-ellipsis, no-wrap, priority:100
msgid "$ git bisect good [COMMIT...]\n"
msgstr "$ git bisect good [COMMIT...]\n"

#. type: Plain text
#: en/git-bisect-lk2009.txt:213
#, priority:100
msgid "where BAD, GOOD and COMMIT are all names that can be resolved to a commit."
msgstr "其中BAD、GOOD和COMMIT都可以解析为提交的名称。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:216
#, priority:100
msgid "Then \"git bisect\" will checkout a commit of its choosing and ask the user to test it, like this:"
msgstr "然后 \"git bisect \"会给出它所选择的一个提交，并要求用户测试它，就像这样："

#. type: delimited block -
#: en/git-bisect-lk2009.txt:221
#, no-wrap, placeholders:'max_low_pfn', priority:100
msgid ""
"$ git bisect start v2.6.27 v2.6.25\n"
"Bisecting: 10928 revisions left to test after this (roughly 14 steps)\n"
"[2ec65f8b89ea003c27ff7723525a2ee335a2b393] x86: clean up using max_low_pfn on 32-bit\n"
msgstr ""
"$ git bisect start v2.6.27 v2.6.25\n"
"Bisecting: 10928 revisions left to test after this (roughly 14 steps)\n"
"[2ec65f8b89ea003c27ff7723525a2ee335a2b393] x86: clean up using max_low_pfn on 32-bit\n"

#. type: Plain text
#: en/git-bisect-lk2009.txt:229
#, priority:100
msgid "Note that the example that we will use is really a toy example, we will be looking for the first commit that has a version like \"2.6.26-something\", that is the commit that has a \"SUBLEVEL = 26\" line in the top level Makefile. This is a toy example because there are better ways to find this commit with Git than using \"git bisect\" (for example \"git blame\" or \"git log -S<string>\")."
msgstr "请注意，我们将使用的例子实际上是一个小型例子，我们将寻找第一个版本为 \"2.6.26-something \"的提交，即在顶层 Makefile 中有 \"SUBLEVEL = 26 \"行的提交。这只是一个小型例子，因为除了使用 \"git bisect\"，还有更好的方法来找到这个提交（例如 \"git blame \"或 \"git log -S<string>\"）。"

#. type: Title ~
#: en/git-bisect-lk2009.txt:231
#, no-wrap, priority:100
msgid "Driving a bisection manually"
msgstr "手动驱动二分"

#. type: Plain text
#: en/git-bisect-lk2009.txt:236
#, priority:100
msgid "At this point there are basically 2 ways to drive the search. It can be driven manually by the user or it can be driven automatically by a script or a command."
msgstr "在这一点上，基本上有两种方式来驱动搜索。它可以由用户手动驱动，也可以由一个脚本或命令自动驱动。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:241
#, priority:100
msgid "If the user is driving it, then at each step of the search, the user will have to test the current commit and say if it is \"good\" or \"bad\" using the \"git bisect good\" or \"git bisect bad\" commands respectively that have been described above. For example:"
msgstr "如果由用户来驱动，那么在搜索的每一步，用户都必须测试当前的提交，并分别使用上文所述的 \"git bisect good \"或 \"git bisect bad \"命令说它是 \"好 \"还是 \"坏\"。比如："

#. type: delimited block -
#: en/git-bisect-lk2009.txt:246
#, no-wrap, placeholders:'f_count', priority:100
msgid ""
"$ git bisect bad\n"
"Bisecting: 5480 revisions left to test after this (roughly 13 steps)\n"
"[66c0b394f08fd89236515c1c84485ea712a157be] KVM: kill file->f_count abuse in kvm\n"
msgstr ""
"$ git bisect bad\n"
"Bisecting: 5480 revisions left to test after this (roughly 13 steps)\n"
"[66c0b394f08fd89236515c1c84485ea712a157be] KVM: kill file->f_count abuse in kvm\n"

#. type: Plain text
#: en/git-bisect-lk2009.txt:250
#, priority:100
msgid "And after a few more steps like that, \"git bisect\" will eventually find a first bad commit:"
msgstr "继续这样做，\"git bisect \"最终会找到第一个坏提交："

#. type: delimited block -
#: en/git-bisect-lk2009.txt:257
#, no-wrap, placeholders:'foundation.org', priority:100
msgid ""
"$ git bisect bad\n"
"2ddcca36c8bcfa251724fe342c8327451988be0d is the first bad commit\n"
"commit 2ddcca36c8bcfa251724fe342c8327451988be0d\n"
"Author: Linus Torvalds <torvalds@linux-foundation.org>\n"
"Date:   Sat May 3 11:59:44 2008 -0700\n"
msgstr ""
"$ git bisect bad\n"
"2ddcca36c8bcfa251724fe342c8327451988be0d is the first bad commit\n"
"commit 2ddcca36c8bcfa251724fe342c8327451988be0d\n"
"Author: Linus Torvalds <torvalds@linux-foundation.org>\n"
"Date:   Sat May 3 11:59:44 2008 -0700\n"

#. type: delimited block -
#: en/git-bisect-lk2009.txt:259 en/git-bisect-lk2009.txt:273 en/git-bisect-lk2009.txt:333
#, no-wrap, priority:100
msgid "    Linux 2.6.26-rc1\n"
msgstr "    Linux 2.6.26-rc1\n"

#. type: delimited block -
#: en/git-bisect-lk2009.txt:261
#, ignore-ellipsis, no-wrap, priority:100
msgid ":100644 100644 5cf82581... 4492984e... M      Makefile\n"
msgstr ":100644 100644 5cf82581... 4492984e... M      Makefile\n"

#. type: Plain text
#: en/git-bisect-lk2009.txt:265
#, priority:100
msgid "At this point we can see what the commit does, check it out (if it's not already checked out) or tinker with it, for example:"
msgstr "在这一点上，我们可以看到提交的内容，检查（如果它还没有被检查出来）或修补它，比如："

#. type: delimited block -
#: en/git-bisect-lk2009.txt:271
#, no-wrap, placeholders:'HEAD':'foundation.org', priority:100
msgid ""
"$ git show HEAD\n"
"commit 2ddcca36c8bcfa251724fe342c8327451988be0d\n"
"Author: Linus Torvalds <torvalds@linux-foundation.org>\n"
"Date:   Sat May 3 11:59:44 2008 -0700\n"
msgstr ""
"$ git show HEAD\n"
"commit 2ddcca36c8bcfa251724fe342c8327451988be0d\n"
"Author: Linus Torvalds <torvalds@linux-foundation.org>\n"
"Date:   Sat May 3 11:59:44 2008 -0700\n"

#. type: delimited block -
#: en/git-bisect-lk2009.txt:286
#, no-wrap, placeholders:'--git':'---', priority:100
msgid ""
"diff --git a/Makefile b/Makefile\n"
"index 5cf8258..4492984 100644\n"
"--- a/Makefile\n"
"+++ b/Makefile\n"
"@@ -1,7 +1,7 @@\n"
" VERSION = 2\n"
" PATCHLEVEL = 6\n"
"-SUBLEVEL = 25\n"
"-EXTRAVERSION =\n"
"+SUBLEVEL = 26\n"
"+EXTRAVERSION = -rc1\n"
" NAME = Funky Weasel is Jiggy wit it\n"
msgstr ""
"diff --git a/Makefile b/Makefile\n"
"index 5cf8258..4492984 100644\n"
"--- a/Makefile\n"
"+++ b/Makefile\n"
"@@ -1,7 +1,7 @@\n"
" VERSION = 2\n"
" PATCHLEVEL = 6\n"
"-SUBLEVEL = 25\n"
"-EXTRAVERSION =\n"
"+SUBLEVEL = 26\n"
"+EXTRAVERSION = -rc1\n"
" NAME = Funky Weasel is Jiggy wit it\n"

#. type: delimited block -
#: en/git-bisect-lk2009.txt:288
#, no-wrap, priority:100
msgid " # *DOCUMENTATION*\n"
msgstr " # *文档*\n"

#. type: Plain text
#: en/git-bisect-lk2009.txt:292
#, priority:100
msgid "And when we are finished we can use \"git bisect reset\" to go back to the branch we were in before we started bisecting:"
msgstr "当我们完成后，我们可以使用 \"git bisect reset \"回到我们开始二分前所在的分支："

#. type: delimited block -
#: en/git-bisect-lk2009.txt:298
#, ignore-ellipsis, no-wrap, placeholders:'HEAD', priority:100
msgid ""
"$ git bisect reset\n"
"Checking out files: 100% (21549/21549), done.\n"
"Previous HEAD position was 2ddcca3... Linux 2.6.26-rc1\n"
"Switched to branch 'master'\n"
msgstr ""
"$ git bisect reset\n"
"Checking out files: 100% (21549/21549), done.\n"
"Previous HEAD position was 2ddcca3... Linux 2.6.26-rc1\n"
"Switched to branch 'master'\n"

#. type: Title ~
#: en/git-bisect-lk2009.txt:301
#, no-wrap, priority:100
msgid "Driving a bisection automatically"
msgstr "自动驱动一个二分查找"

#. type: Plain text
#: en/git-bisect-lk2009.txt:307
#, priority:100
msgid "The other way to drive the bisection process is to tell \"git bisect\" to launch a script or command at each bisection step to know if the current commit is \"good\" or \"bad\". To do that, we use the \"git bisect run\" command. For example:"
msgstr "另一种驱动分界进程的方法是告诉 \"git bisect \"在每个分界步骤启动一个脚本或命令，以了解当前提交是 \"好 \"还是 \"坏\"。要做到这一点，我们使用 \"git bisect run \"命令。比如说："

#. type: delimited block -
#: en/git-bisect-lk2009.txt:331
#, ignore-ellipsis, no-wrap, placeholders:'max_low_pfn':'f_count':'foundation.org', priority:100
msgid ""
"$ git bisect start v2.6.27 v2.6.25\n"
"Bisecting: 10928 revisions left to test after this (roughly 14 steps)\n"
"[2ec65f8b89ea003c27ff7723525a2ee335a2b393] x86: clean up using max_low_pfn on 32-bit\n"
"$\n"
"$ git bisect run grep '^SUBLEVEL = 25' Makefile\n"
"running grep ^SUBLEVEL = 25 Makefile\n"
"Bisecting: 5480 revisions left to test after this (roughly 13 steps)\n"
"[66c0b394f08fd89236515c1c84485ea712a157be] KVM: kill file->f_count abuse in kvm\n"
"running grep ^SUBLEVEL = 25 Makefile\n"
"SUBLEVEL = 25\n"
"Bisecting: 2740 revisions left to test after this (roughly 12 steps)\n"
"[671294719628f1671faefd4882764886f8ad08cb] V4L/DVB(7879): Adding cx18 Support for mxl5005s\n"
"...\n"
"...\n"
"running grep ^SUBLEVEL = 25 Makefile\n"
"Bisecting: 0 revisions left to test after this (roughly 0 steps)\n"
"[2ddcca36c8bcfa251724fe342c8327451988be0d] Linux 2.6.26-rc1\n"
"running grep ^SUBLEVEL = 25 Makefile\n"
"2ddcca36c8bcfa251724fe342c8327451988be0d is the first bad commit\n"
"commit 2ddcca36c8bcfa251724fe342c8327451988be0d\n"
"Author: Linus Torvalds <torvalds@linux-foundation.org>\n"
"Date:   Sat May 3 11:59:44 2008 -0700\n"
msgstr ""
"$ git bisect start v2.6.27 v2.6.25\n"
"Bisecting: 10928 revisions left to test after this (roughly 14 steps)\n"
"[2ec65f8b89ea003c27ff7723525a2ee335a2b393] x86: clean up using max_low_pfn on 32-bit\n"
"$\n"
"$ git bisect run grep '^SUBLEVEL = 25' Makefile\n"
"running grep ^SUBLEVEL = 25 Makefile\n"
"Bisecting: 5480 revisions left to test after this (roughly 13 steps)\n"
"[66c0b394f08fd89236515c1c84485ea712a157be] KVM: kill file->f_count abuse in kvm\n"
"running grep ^SUBLEVEL = 25 Makefile\n"
"SUBLEVEL = 25\n"
"Bisecting: 2740 revisions left to test after this (roughly 12 steps)\n"
"[671294719628f1671faefd4882764886f8ad08cb] V4L/DVB(7879): Adding cx18 Support for mxl5005s\n"
"...\n"
"...\n"
"running grep ^SUBLEVEL = 25 Makefile\n"
"Bisecting: 0 revisions left to test after this (roughly 0 steps)\n"
"[2ddcca36c8bcfa251724fe342c8327451988be0d] Linux 2.6.26-rc1\n"
"running grep ^SUBLEVEL = 25 Makefile\n"
"2ddcca36c8bcfa251724fe342c8327451988be0d is the first bad commit\n"
"commit 2ddcca36c8bcfa251724fe342c8327451988be0d\n"
"Author: Linus Torvalds <torvalds@linux-foundation.org>\n"
"Date:   Sat May 3 11:59:44 2008 -0700\n"

#. type: delimited block -
#: en/git-bisect-lk2009.txt:336
#, ignore-ellipsis, no-wrap, priority:100
msgid ""
":100644 100644 5cf82581... 4492984e... M      Makefile\n"
"bisect run success\n"
msgstr ""
":100644 100644 5cf82581... 4492984e... M      Makefile\n"
"bisect run success\n"

#. type: Plain text
#: en/git-bisect-lk2009.txt:345
#, priority:100
msgid "In this example, we passed \"grep '^SUBLEVEL = 25' Makefile\" as parameter to \"git bisect run\". This means that at each step, the grep command we passed will be launched. And if it exits with code 0 (that means success) then git bisect will mark the current state as \"good\". If it exits with code 1 (or any code between 1 and 127 included, except the special code 125), then the current state will be marked as \"bad\"."
msgstr "在这个例子中，我们把 \"grep '^SUBLEVEL = 25' Makefile \"作为参数传给 \"git bisect run\"。这意味着在每个步骤中，我们传递的grep命令将被启动。如果它以代码0退出（这意味着成功），那么git bisect将把当前状态标记为 \"好\"。如果它以代码1退出（或者包括1到127之间的任何代码，除了特殊代码125），那么当前状态将被标记为 \"坏\"。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:350
#, priority:100
msgid "Exit code between 128 and 255 are special to \"git bisect run\". They make it stop immediately the bisection process. This is useful for example if the command passed takes too long to complete, because you can kill it with a signal and it will stop the bisection process."
msgstr "128和255之间的退出代码是 \"git bisect run \"的特殊代码。它们可以让它立即停止二分查找进程。例如，如果传递的命令需要很长时间才能完成，这很有用，因为你可以用一个信号杀掉该进程，它就会停止二分查找。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:353
#, priority:100
msgid "It can also be useful in scripts passed to \"git bisect run\" to \"exit 255\" if some very abnormal situation is detected."
msgstr "在传递给 \"git bisect run \"的脚本中，如果检测到一些极端不正常的情况，它也可以起到 \"exit 255 \"的作用。"

#. type: Title ~
#: en/git-bisect-lk2009.txt:355
#, no-wrap, priority:100
msgid "Avoiding untestable commits"
msgstr "避免不稳定的提交"

#. type: Plain text
#: en/git-bisect-lk2009.txt:362
#, priority:100
msgid "Sometimes it happens that the current state cannot be tested, for example if it does not compile because there was a bug preventing it at that time. This is what the special exit code 125 is for. It tells \"git bisect run\" that the current commit should be marked as untestable and that another one should be chosen and checked out."
msgstr "有时会发生当前状态无法测试的情况，例如，因为当时有一个错误阻止了它的编译。这就是特殊退出代码125的作用。它告诉 \"git bisect run\"，当前的提交应该被标记为不可测试，应该选择另一个提交并进行检查。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:366
#, priority:100
msgid "If the bisection process is driven manually, you can use \"git bisect skip\" to do the same thing. (In fact the special exit code 125 makes \"git bisect run\" use \"git bisect skip\" in the background.)"
msgstr "如果二分查找过程是手动驱动的，你可以使用 \"git bisect skip \"来做同样的事情。(事实上，特殊的退出代码125使 \"git bisect run\" 在后台使用 \"git bisect skip\"。）"

#. type: Plain text
#: en/git-bisect-lk2009.txt:371
#, priority:100
msgid "Or if you want more control, you can inspect the current state using for example \"git bisect visualize\". It will launch gitk (or \"git log\" if the `DISPLAY` environment variable is not set) to help you find a better bisection point."
msgstr "或者如果你想要更多的控制，你可以使用 \"git bisect visualize \"检查当前状态。它将启动gitk（如果没有设置`DISPLAY`环境变量，则启动 \"git log\"）来帮助你找到一个更好的分界点。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:376
#, priority:100
msgid "Either way, if you have a string of untestable commits, it might happen that the regression you are looking for has been introduced by one of these untestable commits. In this case it's not possible to tell for sure which commit introduced the regression."
msgstr "无论如何，如果你有一串不可测试的提交，你要找的回退可能是由其中一个不可测试的提交引入的。在这种情况下，我们不可能确定是哪个提交引入了回退。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:379
#, priority:100
msgid "So if you used \"git bisect skip\" (or the run script exited with special code 125) you could get a result like this:"
msgstr "因此，如果你使用 \"git bisect skip\"（或者运行脚本以特殊代码125退出），你可以得到这样的结果："

#. type: delimited block -
#: en/git-bisect-lk2009.txt:388
#, no-wrap, priority:100
msgid ""
"There are only 'skip'ped commits left to test.\n"
"The first bad commit could be any of:\n"
"15722f2fa328eaba97022898a305ffc8172db6b1\n"
"78e86cf3e850bd755bb71831f42e200626fbd1e0\n"
"e15b73ad3db9b48d7d1ade32f8cd23a751fe0ace\n"
"070eab2303024706f2924822bfec8b9847e4ac1b\n"
"We cannot bisect more!\n"
msgstr ""
"There are only 'skip'ped commits left to test.\n"
"The first bad commit could be any of:\n"
"15722f2fa328eaba97022898a305ffc8172db6b1\n"
"78e86cf3e850bd755bb71831f42e200626fbd1e0\n"
"e15b73ad3db9b48d7d1ade32f8cd23a751fe0ace\n"
"070eab2303024706f2924822bfec8b9847e4ac1b\n"
"We cannot bisect more!\n"

#. type: Title ~
#: en/git-bisect-lk2009.txt:391
#, no-wrap, priority:100
msgid "Saving a log and replaying it"
msgstr "保存日志并重新展示"

#. type: Plain text
#: en/git-bisect-lk2009.txt:395
#, priority:100
msgid "If you want to show other people your bisection process, you can get a log using for example:"
msgstr "如果你想向其他人展示你的查找过程，你可以用以下的示例得到一个日志："

#. type: delimited block -
#: en/git-bisect-lk2009.txt:398
#, no-wrap, placeholders:'bisect_log', priority:100
msgid "$ git bisect log > bisect_log.txt\n"
msgstr "$ git bisect log > bisect_log.txt\n"

#. type: Plain text
#: en/git-bisect-lk2009.txt:401
#, priority:100
msgid "And it is possible to replay it using:"
msgstr "而且可以重新展示："

#. type: delimited block -
#: en/git-bisect-lk2009.txt:404
#, no-wrap, placeholders:'bisect_log', priority:100
msgid "$ git bisect replay bisect_log.txt\n"
msgstr "$ git bisect replay bisect_log.txt\n"

#. type: Title -
#: en/git-bisect-lk2009.txt:408
#, no-wrap, priority:100
msgid "\"git bisect\" details"
msgstr "\"git bisect\" 详述"

#. type: Title ~
#: en/git-bisect-lk2009.txt:411
#, no-wrap, priority:100
msgid "Bisection algorithm"
msgstr "二分算法"

#. type: Plain text
#: en/git-bisect-lk2009.txt:417
#, priority:100
msgid "As the Git commits form a directed acyclic graph (DAG), finding the best bisection commit to test at each step is not so simple. Anyway Linus found and implemented a \"truly stupid\" algorithm, later improved by Junio Hamano, that works quite well."
msgstr "由于Git提交形成了一个有向无环图（DAG），在每一步找到最佳的分界提交来测试并不那么简单。不管怎样，Linus发现并实现了一种 \"非常傻瓜\"的算法，后来被Junio Hamano改进，效果相当好。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:420
#, priority:100
msgid "So the algorithm used by \"git bisect\" to find the best bisection commit when there are no skipped commits is the following:"
msgstr "因此，当没有跳过的提交时，\"git bisect \"用来寻找最佳分界提交的算法如下："

#. type: Plain text
#: en/git-bisect-lk2009.txt:422
#, priority:100
msgid "keep only the commits that:"
msgstr "只保留以下的提交："

#. type: Plain text
#: en/git-bisect-lk2009.txt:424
#, priority:100
msgid "are ancestor of the \"bad\" commit (including the \"bad\" commit itself),"
msgstr "是\"坏 \"提交的祖先（包括 \"坏 \"提交本身），"

#. type: Plain text
#: en/git-bisect-lk2009.txt:425
#, priority:100
msgid "are not ancestor of a \"good\" commit (excluding the \"good\" commits)."
msgstr "非\"好 \"提交的祖先（不包括 \"好 \"提交）。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:427
#, priority:100
msgid "This means that we get rid of the uninteresting commits in the DAG."
msgstr "这意味着我们摆脱了DAG中无趣的提交。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:429
#, priority:100
msgid "For example if we start with a graph like this:"
msgstr "例如，如果我们从一个这样的图开始："

#. type: delimited block -
#: en/git-bisect-lk2009.txt:438
#, no-wrap, placeholders:'---G-W---W', priority:100
msgid ""
"G-Y-G-W-W-W-X-X-X-X\n"
"\t   \\ /\n"
"\t    W-W-B\n"
"\t   /\n"
"Y---G-W---W\n"
" \\ /   \\\n"
"Y-Y     X-X-X-X\n"
msgstr ""
"G-Y-G-W-W-W-X-X-X-X\n"
"\t   \\ /\n"
"\t    W-W-B\n"
"\t   /\n"
"Y---G-W---W\n"
" \\ /   \\\n"
"Y-Y     X-X-X-X\n"

#. type: delimited block -
#: en/git-bisect-lk2009.txt:440
#, no-wrap, priority:100
msgid "-> time goes this way ->\n"
msgstr "-> 走这条路 ->\n"

#. type: Plain text
#: en/git-bisect-lk2009.txt:445
#, priority:100
msgid "where B is the \"bad\" commit, \"G\" are \"good\" commits and W, X, and Y are other commits, we will get the following graph after this first step:"
msgstr "其中B是 \"坏 \"的提交，\"G \"是 \"好 \"的提交，W、X、Y是其他的提交，经过这第一步，我们会得到以下的图："

#. type: delimited block -
#: en/git-bisect-lk2009.txt:452
#, no-wrap, placeholders:'---W', priority:100
msgid ""
"W-W-W\n"
"     \\\n"
"      W-W-B\n"
"     /\n"
"W---W\n"
msgstr ""
"W-W-W\n"
"     \\\n"
"      W-W-B\n"
"     /\n"
"W---W\n"

#. type: Plain text
#: en/git-bisect-lk2009.txt:457
#, priority:100
msgid "So only the W and B commits will be kept. Because commits X and Y will have been removed by rules a) and b) respectively, and because commits G are removed by rule b) too."
msgstr "所以只有W和B的提交会被保留。因为X和Y的提交将分别被规则a)和b)所删除，而且G的提交也被规则b)所删除。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:460
#, priority:100
msgid "Note for Git users, that it is equivalent as keeping only the commit given by:"
msgstr "请注意，对于Git用户来说，这相当于只保留了所给的这些提交："

#. type: delimited block -
#: en/git-bisect-lk2009.txt:463
#, ignore-ellipsis, no-wrap, placeholders:'git rev-list':'--not', priority:100
msgid "git rev-list BAD --not GOOD1 GOOD2...\n"
msgstr "git rev-list BAD --not GOOD1 GOOD2...\n"

#. type: Plain text
#: en/git-bisect-lk2009.txt:468
#, priority:100
msgid "Also note that we don't require the commits that are kept to be descendants of a \"good\" commit. So in the following example, commits W and Z will be kept:"
msgstr "另外请注意，我们并不要求被保留的提交必须是 \"好 \"提交的后代。所以在下面的例子中，W和Z的提交将被保留："

#. type: delimited block -
#: en/git-bisect-lk2009.txt:473
#, no-wrap, priority:100
msgid ""
"G-W-W-W-B\n"
"   /\n"
"Z-Z\n"
msgstr ""
"G-W-W-W-B\n"
"   /\n"
"Z-Z\n"

#. type: Plain text
#: en/git-bisect-lk2009.txt:477
#, priority:100
msgid "starting from the \"good\" ends of the graph, associate to each commit the number of ancestors it has plus one"
msgstr "从图中 \"好 \"的两端开始，将每个提交的祖先数量加上一个并与之相关联"

#. type: Plain text
#: en/git-bisect-lk2009.txt:480
#, priority:100
msgid "For example with the following graph where H is the \"bad\" commit and A and D are some parents of some \"good\" commits:"
msgstr "例如，下图中H是 \"坏 \"的提交，A和D是一些 \"好 \"的提交的父提交："

#. type: delimited block -
#: en/git-bisect-lk2009.txt:487
#, no-wrap, placeholders:'---E', priority:100
msgid ""
"A-B-C\n"
"     \\\n"
"      F-G-H\n"
"     /\n"
"D---E\n"
msgstr ""
"A-B-C\n"
"     \\\n"
"      F-G-H\n"
"     /\n"
"D---E\n"

#. type: Plain text
#: en/git-bisect-lk2009.txt:490
#, priority:100
msgid "this will give:"
msgstr "这将给出："

#. type: delimited block -
#: en/git-bisect-lk2009.txt:498
#, no-wrap, placeholders:'---E', priority:100
msgid ""
"1 2 3\n"
"A-B-C\n"
"     \\6 7 8\n"
"      F-G-H\n"
"1   2/\n"
"D---E\n"
msgstr ""
"1 2 3\n"
"A-B-C\n"
"     \\6 7 8\n"
"      F-G-H\n"
"1   2/\n"
"D---E\n"

#. type: Plain text
#: en/git-bisect-lk2009.txt:501
#, priority:100
msgid "associate to each commit: min(X, N - X)"
msgstr "关联到每个提交： min（X， N - X）"

#. type: Plain text
#: en/git-bisect-lk2009.txt:504
#, priority:100
msgid "where X is the value associated to the commit in step 2) and N is the total number of commits in the graph."
msgstr "其中X是与步骤2中的提交相关的数值，N是图中的提交总数。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:506
#, priority:100
msgid "In the above example we have N = 8, so this will give:"
msgstr "在上面的例子中，我们有N=8，所以这将得到："

#. type: delimited block -
#: en/git-bisect-lk2009.txt:514
#, no-wrap, placeholders:'---E', priority:100
msgid ""
"1 2 3\n"
"A-B-C\n"
"     \\2 1 0\n"
"      F-G-H\n"
"1   2/\n"
"D---E\n"
msgstr ""
"1 2 3\n"
"A-B-C\n"
"     \\2 1 0\n"
"      F-G-H\n"
"1   2/\n"
"D---E\n"

#. type: Plain text
#: en/git-bisect-lk2009.txt:518
#, priority:100
msgid "the best bisection point is the commit with the highest associated number"
msgstr "最佳分界点是具有最高关联数的提交"

#. type: Plain text
#: en/git-bisect-lk2009.txt:520
#, priority:100
msgid "So in the above example the best bisection point is commit C."
msgstr "所以在上面的例子中，最好的分界点是C。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:522
#, priority:100
msgid "note that some shortcuts are implemented to speed up the algorithm"
msgstr "请注意，这里实施了一些快捷方式以加速算法"

#. type: Plain text
#: en/git-bisect-lk2009.txt:528
#, priority:100
msgid "As we know N from the beginning, we know that min(X, N - X) can't be greater than N/2. So during steps 2) and 3), if we would associate N/2 to a commit, then we know this is the best bisection point. So in this case we can just stop processing any other commit and return the current commit."
msgstr "由于我们从一开始就知道N，所以知道min(X, N - X)不可能大于N/2。所以在步骤2）和3）中，如果我们将N/2与一个提交相关联，那么我们就知道这是一个最佳的分界点。所以在这种情况下，我们可以直接停止处理任何其他的提交，并返回当前的提交。"

#. type: Title ~
#: en/git-bisect-lk2009.txt:530
#, no-wrap, priority:100
msgid "Bisection algorithm debugging"
msgstr "二分法算法调试"

#. type: Plain text
#: en/git-bisect-lk2009.txt:534
#, placeholders:'git rev-list':'--bisect-all', priority:100
msgid "For any commit graph, you can see the number associated with each commit using \"git rev-list --bisect-all\"."
msgstr "对于任何提交图，你可以用 \"git rev-list --bisect-all \"查看与每个提交相关的数字。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:536
#, priority:100
msgid "For example, for the above graph, a command like:"
msgstr "例如，对于上面的图表，使用如下命令："

#. type: delimited block -
#: en/git-bisect-lk2009.txt:539
#, no-wrap, placeholders:'git rev-list':'--bisect-all':'--not', priority:100
msgid "$ git rev-list --bisect-all BAD --not GOOD1 GOOD2\n"
msgstr "$ git rev-list --bisect-all BAD --not GOOD1 GOOD2\n"

#. type: Plain text
#: en/git-bisect-lk2009.txt:542
#, priority:100
msgid "would output something like:"
msgstr "会输出类似的内容："

#. type: delimited block -
#: en/git-bisect-lk2009.txt:552
#, no-wrap, priority:100
msgid ""
"e15b73ad3db9b48d7d1ade32f8cd23a751fe0ace (dist=3)\n"
"15722f2fa328eaba97022898a305ffc8172db6b1 (dist=2)\n"
"78e86cf3e850bd755bb71831f42e200626fbd1e0 (dist=2)\n"
"a1939d9a142de972094af4dde9a544e577ddef0e (dist=2)\n"
"070eab2303024706f2924822bfec8b9847e4ac1b (dist=1)\n"
"a3864d4f32a3bf5ed177ddef598490a08760b70d (dist=1)\n"
"a41baa717dd74f1180abf55e9341bc7a0bb9d556 (dist=1)\n"
"9e622a6dad403b71c40979743bb9d5be17b16bd6 (dist=0)\n"
msgstr ""
"e15b73ad3db9b48d7d1ade32f8cd23a751fe0ace (dist=3)\n"
"15722f2fa328eaba97022898a305ffc8172db6b1 (dist=2)\n"
"78e86cf3e850bd755bb71831f42e200626fbd1e0 (dist=2)\n"
"a1939d9a142de972094af4dde9a544e577ddef0e (dist=2)\n"
"070eab2303024706f2924822bfec8b9847e4ac1b (dist=1)\n"
"a3864d4f32a3bf5ed177ddef598490a08760b70d (dist=1)\n"
"a41baa717dd74f1180abf55e9341bc7a0bb9d556 (dist=1)\n"
"9e622a6dad403b71c40979743bb9d5be17b16bd6 (dist=0)\n"

#. type: Title ~
#: en/git-bisect-lk2009.txt:555
#, no-wrap, priority:100
msgid "Bisection algorithm discussed"
msgstr "讨论二分算法"

#. type: Plain text
#: en/git-bisect-lk2009.txt:561
#, priority:100
msgid "First let's define \"best bisection point\". We will say that a commit X is a best bisection point or a best bisection commit if knowing its state (\"good\" or \"bad\") gives as much information as possible whether the state of the commit happens to be \"good\" or \"bad\"."
msgstr "首先让我们定义“最佳二分点”。如果知道一个提交的状态(“好”或“坏”)能尽可能多地提供提交状态是“好”还是“坏”的信息，我们就称它为最佳二分点或最佳二分提交。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:564
#, priority:100
msgid "This means that the best bisection commits are the commits where the following function is maximum:"
msgstr "这意味着最好的二分提交是以下函数最大的提交："

#. type: delimited block -
#: en/git-bisect-lk2009.txt:567
#, no-wrap, placeholders:'information_if_good':'information_if_bad', priority:100
msgid "f(X) = min(information_if_good(X), information_if_bad(X))\n"
msgstr "f(X) = min(information_if_good(X), information_if_bad(X))\n"

#. type: Plain text
#: en/git-bisect-lk2009.txt:571
#, placeholders:'information_if_good':'information_if_bad', priority:100
msgid "where information_if_good(X) is the information we get if X is good and information_if_bad(X) is the information we get if X is bad."
msgstr "其中information_if_good（X）是X好时我们获得的信息，information_if_bad（X）是X坏时我们得到的信息。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:580
#, priority:100
msgid "Now we will suppose that there is only one \"first bad commit\". This means that all its descendants are \"bad\" and all the other commits are \"good\". And we will suppose that all commits have an equal probability of being good or bad, or of being the first bad commit, so knowing the state of c commits gives always the same amount of information wherever these c commits are on the graph and whatever c is. (So we suppose that these commits being for example on a branch or near a good or a bad commit does not give more or less information)."
msgstr "现在我们假设只有一次“第一次错误提交”。这意味着它的所有后代都是“坏的”，而所有其他提交都是“好的”。我们假设所有的提交都有相同的概率是好的或坏的，或者是第一个错误的提交，所以知道c提交的状态给出的信息总是相同的无论这些c提交在图上的哪个位置，无论c是什么。(所以我们假设这些提交是在一个分支上，或者在一个好的或坏的提交附近，不会给出更多或更少的信息)。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:582
#, priority:100
msgid "Let's also suppose that we have a cleaned up graph like one after step"
msgstr "我们还假设我们有一个清理过的图表，例如一个步骤后"

#. type: Plain text
#: en/git-bisect-lk2009.txt:585
#, priority:100
msgid "in the bisection algorithm above. This means that we can measure the information we get in terms of number of commit we can remove from the graph.."
msgstr "在上面的二分算法中。这意味着我们可以根据可以从图中删除的提交数量来衡量我们获得的信息。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:587
#, priority:100
msgid "And let's take a commit X in the graph."
msgstr "让我们在图中提交一个 X。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:590
#, priority:100
msgid "If X is found to be \"good\", then we know that its ancestors are all \"good\", so we want to say that:"
msgstr "如果发现X是“好”的，那么我们知道它的祖先都是“好”的，所以我们想说："

#. type: delimited block -
#: en/git-bisect-lk2009.txt:593
#, no-wrap, placeholders:'information_if_good':'number_of_ancestors', priority:100
msgid "information_if_good(X) = number_of_ancestors(X)  (TRUE)\n"
msgstr "information_if_good（X） = number_of_ancestors（X） （TRUE）\n"

#. type: Plain text
#: en/git-bisect-lk2009.txt:597
#, priority:100
msgid "And this is true because at step 1) b) we remove the ancestors of the \"good\" commits."
msgstr "这是真的，因为在步骤 1） b） 我们删除了“好”提交的祖先。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:600
#, priority:100
msgid "If X is found to be \"bad\", then we know that its descendants are all \"bad\", so we want to say that:"
msgstr "如果发现 X 是“坏”的，那么我们知道它的后代都是“坏的”，所以我们想说："

#. type: delimited block -
#: en/git-bisect-lk2009.txt:603
#, no-wrap, placeholders:'information_if_bad':'number_of_descendants', priority:100
msgid "information_if_bad(X) = number_of_descendants(X)  (WRONG)\n"
msgstr "information_if_bad（X） = number_of_descendants（X） （WRONG）\n"

#. type: Plain text
#: en/git-bisect-lk2009.txt:612
#, priority:100
msgid "But this is wrong because at step 1) a) we keep only the ancestors of the bad commit. So we get more information when a commit is marked as \"bad\", because we also know that the ancestors of the previous \"bad\" commit that are not ancestors of the new \"bad\" commit are not the first bad commit. We don't know if they are good or bad, but we know that they are not the first bad commit because they are not ancestor of the new \"bad\" commit."
msgstr "但这是错误的，因为在步骤1）a）我们只保留错误承诺的祖先。因此，当提交被标记为“坏”时，我们会得到更多信息，因为我们也知道，不是新“坏”提交的祖先的上一个“坏”提交的祖先不是第一个错误提交。我们不知道它们是好是坏，但我们知道它们不是第一个错误提交，因为它们不是新“坏”提交的祖先。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:616
#, priority:100
msgid "So when a commit is marked as \"bad\" we know we can remove all the commits in the graph except those that are ancestors of the new \"bad\" commit. This means that:"
msgstr "因此，当一个提交被标记为“坏”时，我们知道我们可以删除图形中的所有提交，除了那些是新“坏”提交的祖先。这意味着："

#. type: delimited block -
#: en/git-bisect-lk2009.txt:619
#, no-wrap, placeholders:'information_if_bad':'number_of_ancestors', priority:100
msgid "information_if_bad(X) = N - number_of_ancestors(X)  (TRUE)\n"
msgstr "information_if_bad（X） = N - number_of_ancestors（X） （TRUE）\n"

#. type: Plain text
#: en/git-bisect-lk2009.txt:622
#, priority:100
msgid "where N is the number of commits in the (cleaned up) graph."
msgstr "其中 N 是（清理的）图中的提交数。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:625
#, priority:100
msgid "So in the end this means that to find the best bisection commits we should maximize the function:"
msgstr "所以最后这意味着要找到最好的二分提交，我们应该最大化函数："

#. type: delimited block -
#: en/git-bisect-lk2009.txt:628
#, no-wrap, placeholders:'number_of_ancestors':'number_of_ancestors', priority:100
msgid "f(X) = min(number_of_ancestors(X), N - number_of_ancestors(X))\n"
msgstr "f(X) = min(number_of_ancestors(X), N - number_of_ancestors(X))\n"

#. type: Plain text
#: en/git-bisect-lk2009.txt:632
#, placeholders:'number_of_ancestors', priority:100
msgid "And this is nice because at step 2) we compute number_of_ancestors(X) and so at step 3) we compute f(X)."
msgstr "这很好，因为在步骤2）我们计算number_of_ancestors(X)，所以在步骤3）我们计算f(X)。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:634
#, priority:100
msgid "Let's take the following graph as an example:"
msgstr "让我们以下图为例："

#. type: delimited block -
#: en/git-bisect-lk2009.txt:641
#, no-wrap, priority:100
msgid ""
"            G-H-I-J\n"
"           /       \\\n"
"A-B-C-D-E-F         O\n"
"           \\       /\n"
"            K-L-M-N\n"
msgstr ""
"            G-H-I-J\n"
"           /       \\\n"
"A-B-C-D-E-F         O\n"
"           \\       /\n"
"            K-L-M-N\n"

#. type: Plain text
#: en/git-bisect-lk2009.txt:644
#, priority:100
msgid "If we compute the following non optimal function on it:"
msgstr "如果我们在其上计算以下非最优函数："

#. type: delimited block -
#: en/git-bisect-lk2009.txt:647
#, no-wrap, placeholders:'number_of_ancestors':'number_of_descendants', priority:100
msgid "g(X) = min(number_of_ancestors(X), number_of_descendants(X))\n"
msgstr "g(X) = min(number_of_ancestors(X), number_of_descendants(X))\n"

#. type: Plain text
#: en/git-bisect-lk2009.txt:650
#, priority:100
msgid "we get:"
msgstr "我们得到："

#. type: delimited block -
#: en/git-bisect-lk2009.txt:659
#, no-wrap, priority:100
msgid ""
"            4 3 2 1\n"
"            G-H-I-J\n"
"1 2 3 4 5 6/       \\0\n"
"A-B-C-D-E-F         O\n"
"           \\       /\n"
"            K-L-M-N\n"
"            4 3 2 1\n"
msgstr ""
"            4 3 2 1\n"
"            G-H-I-J\n"
"1 2 3 4 5 6/       \\0\n"
"A-B-C-D-E-F         O\n"
"           \\       /\n"
"            K-L-M-N\n"
"            4 3 2 1\n"

#. type: Plain text
#: en/git-bisect-lk2009.txt:662
#, priority:100
msgid "but with the algorithm used by git bisect we get:"
msgstr "但是使用Git二分查找算法，我们得到："

#. type: delimited block -
#: en/git-bisect-lk2009.txt:671
#, no-wrap, priority:100
msgid ""
"            7 7 6 5\n"
"            G-H-I-J\n"
"1 2 3 4 5 6/       \\0\n"
"A-B-C-D-E-F         O\n"
"           \\       /\n"
"            K-L-M-N\n"
"            7 7 6 5\n"
msgstr ""
"            7 7 6 5\n"
"            G-H-I-J\n"
"1 2 3 4 5 6/       \\0\n"
"A-B-C-D-E-F         O\n"
"           \\       /\n"
"            K-L-M-N\n"
"            7 7 6 5\n"

#. type: Plain text
#: en/git-bisect-lk2009.txt:678
#, priority:100
msgid "So we chose G, H, K or L as the best bisection point, which is better than F. Because if for example L is bad, then we will know not only that L, M and N are bad but also that G, H, I and J are not the first bad commit (since we suppose that there is only one first bad commit and it must be an ancestor of L)."
msgstr "因此，我们选择G、H、K或L作为最佳平分点，这比F更好。因为，如果L是坏的，那么我们不仅知道L、M和N是坏的，而且还知道G、H、I和J不是第一个坏提交(因为我们假设只有一个第一个坏提交，而且它必须是L的祖先)。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:681
#, priority:100
msgid "So the current algorithm seems to be the best possible given what we initially supposed."
msgstr "因此，鉴于我们最初假设的算法，当前的算法似乎是最好的。"

#. type: Title ~
#: en/git-bisect-lk2009.txt:683
#, no-wrap, priority:100
msgid "Skip algorithm"
msgstr "跳过算法"

#. type: Plain text
#: en/git-bisect-lk2009.txt:688
#, priority:100
msgid "When some commits have been skipped (using \"git bisect skip\"), then the bisection algorithm is the same for step 1) to 3). But then we use roughly the following steps:"
msgstr "当跳过一些提交（使用“git bisect skip”）时，步骤 1 到 3 的二分算法是相同的）。但是，让我们来使用以下步骤："

#. type: Plain text
#: en/git-bisect-lk2009.txt:690
#, priority:100
msgid "sort the commit by decreasing associated value"
msgstr "通过减少关联值对提交进行排序"

#. type: Plain text
#: en/git-bisect-lk2009.txt:693
#, priority:100
msgid "if the first commit has not been skipped, we can return it and stop here"
msgstr "如果没有跳过第一次提交，我们可以返回它并在此处停止"

#. type: Plain text
#: en/git-bisect-lk2009.txt:695
#, priority:100
msgid "otherwise filter out all the skipped commits in the sorted list"
msgstr "否则过滤掉排序列表中所有跳过的提交"

#. type: Plain text
#: en/git-bisect-lk2009.txt:698
#, priority:100
msgid "use a pseudo random number generator (PRNG) to generate a random number between 0 and 1"
msgstr "使用伪随机数生成器 （PRNG） 生成介于 0 和 1 之间的随机数"

#. type: Plain text
#: en/git-bisect-lk2009.txt:701
#, priority:100
msgid "multiply this random number with its square root to bias it toward 0"
msgstr "将此随机数与其平方根相乘，使其偏向 0"

#. type: Plain text
#: en/git-bisect-lk2009.txt:704
#, priority:100
msgid "multiply the result by the number of commits in the filtered list to get an index into this list"
msgstr "将结果乘以过滤后的列表中的提交数量，得到该列表的索引"

#. type: Plain text
#: en/git-bisect-lk2009.txt:706
#, priority:100
msgid "return the commit at the computed index"
msgstr "返回计算出的索引处的提交"

#. type: Title ~
#: en/git-bisect-lk2009.txt:708
#, no-wrap, priority:100
msgid "Skip algorithm discussed"
msgstr "跳过算法讨论"

#. type: Plain text
#: en/git-bisect-lk2009.txt:715
#, priority:100
msgid "After step 7) (in the skip algorithm), we could check if the second commit has been skipped and return it if it is not the case. And in fact that was the algorithm we used from when \"git bisect skip\" was developed in Git version 1.5.4 (released on February 1st 2008) until Git version 1.6.4 (released July 29th 2009)."
msgstr "在步骤7）（跳过算法中）之后，我们可以检查第二次提交是否已经被跳过，如果不是这样，则返回它。事实上，这就是我们从Git 1.5.4版本（2008年2月1日发布）开发 \"git bisect skip \"时开始使用的算法，直到Git 1.6.4版本（2009年7月29日发布）。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:721
#, priority:100
msgid "But Ingo Molnar and H. Peter Anvin (another well known linux kernel developer) both complained that sometimes the best bisection points all happened to be in an area where all the commits are untestable. And in this case the user was asked to test many untestable commits, which could be very inefficient."
msgstr "但是Ingo Molnar和H. Peter Anvin（另一个著名的Linux内核开发者）都抱怨说，有时最好的分界点都碰巧在一个所有提交都无法测试的区域。而在这种情况下，用户被要求测试许多不可测试的提交，这可能是非常低效的。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:725
#, priority:100
msgid "Indeed untestable commits are often untestable because a breakage was introduced at one time, and that breakage was fixed only after many other commits were introduced."
msgstr "事实上，不可测试的提交往往是因为某次引入了一个破绽，而这个破绽是在引入了许多其他的提交之后才被修复的。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:729
#, priority:100
msgid "This breakage is of course most of the time unrelated to the breakage we are trying to locate in the commit graph. But it prevents us to know if the interesting \"bad behavior\" is present or not."
msgstr "当然，这种破坏在大多数时候与我们试图在提交图中定位的破坏无关。但它却让我们无法知道有趣的 \"坏行为 \"是否存在。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:733
#, priority:100
msgid "So it is a fact that commits near an untestable commit have a high probability of being untestable themselves. And the best bisection commits are often found together too (due to the bisection algorithm)."
msgstr "因此，在不可测试的提交附近的提交，其本身也有很大可能是不可测试的。而且，最好的分界线提交也经常被发现在一起（由于二分算法的原因）。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:736
#, priority:100
msgid "This is why it is a bad idea to just chose the next best unskipped bisection commit when the first one has been skipped."
msgstr "这就是为什么当第一个分界线被跳过时，直接选择下一个最好的未跳过的分界线提交是个坏主意。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:741
#, priority:100
msgid "We found that most commits on the graph may give quite a lot of information when they are tested. And the commits that will not on average give a lot of information are the one near the good and bad commits."
msgstr "我们发现，图中的大多数提交在被测试时可能会提供相当多的信息。而那些平均来说不会提供大量信息的提交是靠近好的和坏的提交。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:744
#, priority:100
msgid "So using a PRNG with a bias to favor commits away from the good and bad commits looked like a good choice."
msgstr "因此，使用一个有偏向性的PRNG来偏向于远离好的和坏的提交，看起来是一个不错的选择。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:751
#, priority:100
msgid "One obvious improvement to this algorithm would be to look for a commit that has an associated value near the one of the best bisection commit, and that is on another branch, before using the PRNG. Because if such a commit exists, then it is not very likely to be untestable too, so it will probably give more information than a nearly randomly chosen one."
msgstr "这个算法的一个明显的改进是，在使用PRNG之前，寻找一个与最佳分叉提交的值接近的提交，而且是在另一个分支上。因为如果这样的提交存在，那么它也不太可能是不可测试的，所以它可能会比几乎随机选择的提交提供更多信息。"

#. type: Title ~
#: en/git-bisect-lk2009.txt:753
#, no-wrap, priority:100
msgid "Checking merge bases"
msgstr "检查合并基础"

#. type: Plain text
#: en/git-bisect-lk2009.txt:757
#, priority:100
msgid "There is another tweak in the bisection algorithm that has not been described in the \"bisection algorithm\" above."
msgstr "分割算法中还有一个调整，在上面的 \"二分算法 \"中没有描述。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:761
#, priority:100
msgid "We supposed in the previous examples that the \"good\" commits were ancestors of the \"bad\" commit. But this is not a requirement of \"git bisect\"."
msgstr "在前面的例子中，我们认为 \"好 \"的提交是 \"坏 \"的提交的祖先。但这并不是 \"git bisect \"的要求。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:769
#, priority:100
msgid "Of course the \"bad\" commit cannot be an ancestor of a \"good\" commit, because the ancestors of the good commits are supposed to be \"good\". And all the \"good\" commits must be related to the bad commit. They cannot be on a branch that has no link with the branch of the \"bad\" commit. But it is possible for a good commit to be related to a bad commit and yet not be neither one of its ancestor nor one of its descendants."
msgstr "当然，\"坏 \"提交不可能是 \"好 \"提交的祖先，因为好提交的祖先应该是 \"好 \"的。而所有 \"好 \"的提交必须与坏的提交有关。 它们不可能在一个与 \"坏 \"提交的分支没有联系的分支上。但是，一个好的提交有可能与一个坏的提交有关系，但既不是它的祖先，也不是它的后代。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:772
#, priority:100
msgid "For example, there can be a \"main\" branch, and a \"dev\" branch that was forked of the main branch at a commit named \"D\" like this:"
msgstr "例如，可以有一个 \"main\"分支和一个 \"dev\"分支，后者是从main分支中提交名为 \"D\"的提交克隆出来的，如下所示："

#. type: delimited block -
#: en/git-bisect-lk2009.txt:777
#, no-wrap, placeholders:'--main':'--dev', priority:100
msgid ""
"A-B-C-D-E-F-G  <--main\n"
"       \\\n"
"        H-I-J  <--dev\n"
msgstr ""
"A-B-C-D-E-F-G  <--main\n"
"       \\\n"
"        H-I-J  <--dev\n"

#. type: Plain text
#: en/git-bisect-lk2009.txt:781
#, priority:100
msgid "The commit \"D\" is called a \"merge base\" for branch \"main\" and \"dev\" because it's the best common ancestor for these branches for a merge."
msgstr "提交 \"D \"被称为 \"main \"和 \"dev \"分支的 \"合并基础\"，因为它是这些分支可以进行合并的最佳共同祖先。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:785
#, priority:100
msgid "Now let's suppose that commit J is bad and commit G is good and that we apply the bisection algorithm like it has been previously described."
msgstr "现在我们假设提交J是坏的，提交G是好的，并且我们像之前描述的那样应用二分法。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:789
#, priority:100
msgid "As described in step 1) b) of the bisection algorithm, we remove all the ancestors of the good commits because they are supposed to be good too."
msgstr "正如一分为二算法的步骤1）b）所描述的那样，我们移除所有好提交的祖先，因为他们也应该是好的。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:791
#, priority:100
msgid "So we would be left with only:"
msgstr "因此，我们将只剩下："

#. type: delimited block -
#: en/git-bisect-lk2009.txt:794
#, no-wrap, priority:100
msgid "H-I-J\n"
msgstr "H-I-J\n"

#. type: Plain text
#: en/git-bisect-lk2009.txt:798
#, priority:100
msgid "But what happens if the first bad commit is \"B\" and if it has been fixed in the \"main\" branch by commit \"F\"?"
msgstr "但如果第一个坏的提交是 \"B\"，而在 \"main\"分支中已经被提交 \"F \"修复，会发生什么？"

#. type: Plain text
#: en/git-bisect-lk2009.txt:801
#, priority:100
msgid "The result of such a bisection would be that we would find that H is the first bad commit, when in fact it's B. So that would be wrong!"
msgstr "这样一分为二后，我们会发现H是第一个坏提交，但实际上第一个坏提交是B，所以这将造成错误的结果！"

#. type: Plain text
#: en/git-bisect-lk2009.txt:807
#, priority:100
msgid "And yes it can happen in practice that people working on one branch are not aware that people working on another branch fixed a bug! It could also happen that F fixed more than one bug or that it is a revert of some big development effort that was not ready to be released."
msgstr "在实践中可能会发生这样的情况：在一个分支上工作的人不知道在另一个分支上工作的人修复了一个bug！也可能发生的情况是，F修复了不止一个bug，或者是对一些尚未准备好发布的大型开发工作进行了恢复。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:813
#, priority:100
msgid "In fact development teams often maintain both a development branch and a maintenance branch, and it would be quite easy for them if \"git bisect\" just worked when they want to bisect a regression on the development branch that is not on the maintenance branch. They should be able to start bisecting using:"
msgstr "事实上，开发团队经常同时维护一个开发分支和一个维护分支，如果 \"git bisect \"只是在他们想对开发分支上的回归进行分流而不在维护分支上的时候发挥作用，那对他们来说会很容易。他们应该可以用以下方法开始二分："

#. type: delimited block -
#: en/git-bisect-lk2009.txt:816
#, no-wrap, priority:100
msgid "$ git bisect start dev main\n"
msgstr "$ git bisect start dev main\n"

#. type: Plain text
#: en/git-bisect-lk2009.txt:823
#, priority:100
msgid "To enable that additional nice feature, when a bisection is started and when some good commits are not ancestors of the bad commit, we first compute the merge bases between the bad and the good commits and we chose these merge bases as the first commits that will be checked out and tested."
msgstr "为了实现这个额外的功能，当一个分界开始，一些好的提交不是坏的提交的祖先时，我们首先计算坏的提交和好的提交之间的合并基数，我们选择这些合并基数作为第一个将被检查和测试的提交。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:826
#, priority:100
msgid "If it happens that one merge base is bad, then the bisection process is stopped with a message like:"
msgstr "如果有一个合并基数是坏的，那么二分过程就会停止，并发出类似的信息："

#. type: delimited block -
#: en/git-bisect-lk2009.txt:830
#, ignore-ellipsis, no-wrap, priority:100
msgid ""
"The merge base BBBBBB is bad.\n"
"This means the bug has been fixed between BBBBBB and [GGGGGG,...].\n"
msgstr ""
"合并基础BBBBB是坏的。\n"
"这意味着BBBBB和[GGGGG,...]之间的错误已经被修复。\n"

#. type: Plain text
#: en/git-bisect-lk2009.txt:834
#, ignore-ellipsis, priority:100
msgid "where BBBBBB is the sha1 hash of the bad merge base and [GGGGGG,...] is a comma separated list of the sha1 of the good commits."
msgstr "其中BBBBBB是坏合并基础的sha1哈希值，[GGGGG,...]是好提交的sha1的逗号分隔列表。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:838
#, priority:100
msgid "If some of the merge bases are skipped, then the bisection process continues, but the following message is printed for each skipped merge base:"
msgstr "如果一些合并基点被跳过，那么二分过程将继续进行，但对于每一个被跳过的合并基点都会打印出以下信息："

#. type: delimited block -
#: en/git-bisect-lk2009.txt:843
#, ignore-ellipsis, no-wrap, priority:100
msgid ""
"Warning: the merge base between BBBBBB and [GGGGGG,...] must be skipped.\n"
"So we cannot be sure the first bad commit is between MMMMMM and BBBBBB.\n"
"We continue anyway.\n"
msgstr ""
"警告：BBBBB和[GGGGG,...]之间的合并基数必须被跳过。\n"
"所以我们不能确定第一个坏提交是在MMMMMM和BBBBB之间。\n"
"我们会继续操作。\n"

#. type: Plain text
#: en/git-bisect-lk2009.txt:848
#, ignore-ellipsis, priority:100
msgid "where BBBBBB is the sha1 hash of the bad commit, MMMMMM is the sha1 hash of the merge base that is skipped and [GGGGGG,...] is a comma separated list of the sha1 of the good commits."
msgstr "其中BBBBB是坏提交的sha1哈希值，MMMMM是被跳过的合并基础的sha1哈希值，[GGGGG,...]是好提交的sha1的逗号分隔列表。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:851
#, priority:100
msgid "So if there is no bad merge base, the bisection process continues as usual after this step."
msgstr "因此，如果没有坏的合并基础，在这一步之后，二分过程照常进行。"

#. type: Title -
#: en/git-bisect-lk2009.txt:853
#, no-wrap, priority:100
msgid "Best bisecting practices"
msgstr "最佳的二分做法"

#. type: Title ~
#: en/git-bisect-lk2009.txt:856
#, no-wrap, priority:100
msgid "Using test suites and git bisect together"
msgstr "测试套件和git bisect一起使用"

#. type: Plain text
#: en/git-bisect-lk2009.txt:863
#, priority:100
msgid "If you both have a test suite and use git bisect, then it becomes less important to check that all tests pass after each commit. Though of course it is probably a good idea to have some checks to avoid breaking too many things because it could make bisecting other bugs more difficult."
msgstr "如果你有一个测试套件并使用git bisect，那么在每次提交后检查所有测试是否通过就变得不那么重要。当然，为了避免破坏太多的东西，有一些检查可能是个好的做法，因为这可能会使二分其他bug更加困难。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:868
#, priority:100
msgid "You can focus your efforts to check at a few points (for example rc and beta releases) that all the T test cases pass for all the N configurations. And when some tests don't pass you can use \"git bisect\" (or better \"git bisect run\"). So you should perform roughly:"
msgstr "你可以集中精力在几个点上检查（例如rc和beta版本），所有的T测试用例在所有的N个配置下都能通过。当一些测试没有通过时，你可以使用 \"git bisect\"（当然\"git bisect run\"更好）。所以你应该大致上执行："

#. type: delimited block -
#: en/git-bisect-lk2009.txt:871
#, no-wrap, priority:100
msgid "c * N * T + b * M * log2(M) tests\n"
msgstr "c * N * T + b * M * log2(M) tests\n"

#. type: Plain text
#: en/git-bisect-lk2009.txt:875
#, priority:100
msgid "where c is the number of rounds of test (so a small constant) and b is the ratio of bug per commit (hopefully a small constant too)."
msgstr "其中c是测试的轮数（所以是一个小常数），b是每次提交的bug比例（希望也是一个小常数）。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:878
#, priority:100
msgid "So of course it's much better as it's O(N * T) vs O(N * T * M) if you would test everything after each commit."
msgstr "所以，如果你在每次提交后都测试所有内容，O(N * T)当然比O(N * T * M)要好得多 。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:883
#, priority:100
msgid "This means that test suites are good to prevent some bugs from being committed and they are also quite good to tell you that you have some bugs. But they are not so good to tell you where some bugs have been introduced. To tell you that efficiently, git bisect is needed."
msgstr "这意味着测试套件对于防止一些bug被提交是很好的，它们对于告诉你有一些bug也是很好的。但它们并不能很好地告诉你一些错误是在哪里被引入的。所以需要git bisect告诉你这些信息。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:890
#, priority:100
msgid "The other nice thing with test suites, is that when you have one, you already know how to test for bad behavior. So you can use this knowledge to create a new test case for \"git bisect\" when it appears that there is a regression. So it will be easier to bisect the bug and fix it. And then you can add the test case you just created to your test suite."
msgstr "测试套件的另一个好处是，当你有一个测试套件时，你已经知道如何测试不良行为。因此，当出现类似问题时，你可以使用这些知识来创建一个新的 \"git bisect \"测试案例。这样就能更容易地将bug二分并修复它。然后你就可以把你刚创建的测试用例添加到你的测试套件中。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:893
#, priority:100
msgid "So if you know how to create test cases and how to bisect, you will be subject to a virtuous circle:"
msgstr "因此，如果你知道如何创建测试用例和二分，你就会受到良性循环的影响："

#. type: Plain text
#: en/git-bisect-lk2009.txt:895
#, priority:100
msgid "more tests => easier to create tests => easier to bisect => more tests"
msgstr "更多的测试 => 更容易创建测试 => 更容易二分 => 更多的测试"

#. type: Plain text
#: en/git-bisect-lk2009.txt:898
#, priority:100
msgid "So test suites and \"git bisect\" are complementary tools that are very powerful and efficient when used together."
msgstr "因此，测试套件和 \"git bisect \"是互补的工具，一起使用时非常强大和高效。"

#. type: Title ~
#: en/git-bisect-lk2009.txt:900
#, no-wrap, priority:100
msgid "Bisecting build failures"
msgstr "对构建失败的二分"

#. type: Plain text
#: en/git-bisect-lk2009.txt:904
#, priority:100
msgid "You can very easily automatically bisect broken builds using something like:"
msgstr "你可以非常容易地使用类似的东西来自动划分破碎的构建："

#. type: delimited block -
#: en/git-bisect-lk2009.txt:908
#, no-wrap, priority:100
msgid ""
"$ git bisect start BAD GOOD\n"
"$ git bisect run make\n"
msgstr ""
"$ git bisect start BAD GOOD\n"
"$ git bisect run make\n"

#. type: Title ~
#: en/git-bisect-lk2009.txt:911
#, no-wrap, priority:100
msgid "Passing sh -c \"some commands\" to \"git bisect run\""
msgstr "将sh -c \"一些命令 \"传递给 \"git bisect运行\""

#. type: delimited block -
#: en/git-bisect-lk2009.txt:917
#, no-wrap, placeholders:'my_app', priority:100
msgid "$ git bisect run sh -c \"make || exit 125; ./my_app | grep 'good output'\"\n"
msgstr "$ git bisect run sh -c \"make || exit 125; ./my_app | grep 'good output'\"\n"

#. type: Plain text
#: en/git-bisect-lk2009.txt:921
#, priority:100
msgid "On the other hand if you do this often, then it can be worth having scripts to avoid too much typing."
msgstr "另一方面，如果你经常这样做，那么就值得用脚本来避免过多的输入。"

#. type: Title ~
#: en/git-bisect-lk2009.txt:923
#, no-wrap, priority:100
msgid "Finding performance regressions"
msgstr "寻找性能回归"

#. type: Plain text
#: en/git-bisect-lk2009.txt:927
#, placeholders:'<<4>>', priority:100
msgid "Here is an example script that comes slightly modified from a real world script used by Junio Hamano <<4>>."
msgstr "这里有一个例子，它是由Junio Hamano使用真实案例的脚本稍加修改而成的<<4>>。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:930
#, priority:100
msgid "This script can be passed to \"git bisect run\" to find the commit that introduced a performance regression:"
msgstr "这个脚本可以传递给 \"git bisect run\"，以找到引入性能回归的提交："

#. type: delimited block -
#: en/git-bisect-lk2009.txt:936
#, no-wrap, placeholders:'my_app', priority:100
msgid ""
"# Build errors are not what I am interested in.\n"
"make my_app || exit 255\n"
msgstr ""
"# 我并不关心构建中的错误。\n"
"make my_app || exit 255\n"

#. type: delimited block -
#: en/git-bisect-lk2009.txt:939
#, ignore-ellipsis, no-wrap, priority:100
msgid ""
"# We are checking if it stops in a reasonable amount of time, so\n"
"# let it run in the background...\n"
msgstr ""
"# 我们要检查它是否在合理的时间内停止，所以\n"
"# 让它在后台运行...\n"

#. type: delimited block -
#: en/git-bisect-lk2009.txt:941
#, no-wrap, placeholders:'my_app', priority:100
msgid "./my_app >log 2>&1 &\n"
msgstr "./my_app >log 2>&1 &\n"

#. type: delimited block -
#: en/git-bisect-lk2009.txt:944
#, ignore-ellipsis, no-wrap, priority:100
msgid ""
"# ... and grab its process ID.\n"
"pid=$!\n"
msgstr ""
"# ... 并抓取其进程ID。\n"
"pid=$!\n"

#. type: delimited block -
#: en/git-bisect-lk2009.txt:947
#, ignore-ellipsis, no-wrap, placeholders:'$NORMAL_TIME', priority:100
msgid ""
"# ... and then wait for sufficiently long.\n"
"sleep $NORMAL_TIME\n"
msgstr ""
"# ... 然后等待足够长的时间。\n"
"sleep $NORMAL_TIME\n"

#. type: delimited block -
#: en/git-bisect-lk2009.txt:959
#, ignore-ellipsis, no-wrap, placeholders:'$pid':'$pid':'$pid':'$pid', priority:100
msgid ""
"# ... and then see if the process is still there.\n"
"if kill -0 $pid\n"
"then\n"
"\t# It is still running -- that is bad.\n"
"\tkill $pid; sleep 1; kill $pid;\n"
"\texit 1\n"
"else\n"
"\t# It has already finished (the $pid process was no more),\n"
"\t# and we are happy.\n"
"\texit 0\n"
"fi\n"
msgstr ""
"# ... 然后看看这个进程是否还在那里。\n"
"if kill -0 $pid\n"
"then\n"
"\t# 它仍然在运行 -- 有点失望。\n"
"\tkill $pid; sleep 1; kill $pid；\n"
"\texit 1\n"
"else\n"
"\t# 它已经结束了（$pid进程不再存在）,\n"
"\t# 皆大欢喜。\n"
"\texit 0\n"
"fi\n"

#. type: Title ~
#: en/git-bisect-lk2009.txt:962
#, no-wrap, priority:100
msgid "Following general best practices"
msgstr "遵循一般的最佳做法"

#. type: Plain text
#: en/git-bisect-lk2009.txt:967
#, priority:100
msgid "It is obviously a good idea not to have commits with changes that knowingly break things, even if some other commits later fix the breakage."
msgstr "显然，不要在提交时明知故犯是最好的，即使后来有其他的提交修复了错误。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:970
#, priority:100
msgid "It is also a good idea when using any VCS to have only one small logical change in each commit."
msgstr "在使用任何VCS时，最好是每次提交只有一个小的逻辑变化。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:975
#, priority:100
msgid "The smaller the changes in your commit, the most effective \"git bisect\" will be. And you will probably need \"git bisect\" less in the first place, as small changes are easier to review even if they are only reviewed by the committer."
msgstr "你的提交中的改动越小，\"git bisect \"就越有效。并且你可能一开始就不太需要 \"git bisect\"，因为即使只有提交者审查，小改动也更容易审查。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:978
#, priority:100
msgid "Another good idea is to have good commit messages. They can be very helpful to understand why some changes were made."
msgstr "另一个好的办法是要有一个明确的提交信息。它们对于理解为什么要做一些改动是非常有帮助的。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:980
#, priority:100
msgid "These general best practices are very helpful if you bisect often."
msgstr "如果你经常进行二分操作，一般这些最佳实践是非常有帮助的。"

#. type: Title ~
#: en/git-bisect-lk2009.txt:982
#, no-wrap, priority:100
msgid "Avoiding bug prone merges"
msgstr "避免容易出错的合并"

#. type: Plain text
#: en/git-bisect-lk2009.txt:988
#, priority:100
msgid "First merges by themselves can introduce some regressions even when the merge needs no source code conflict resolution. This is because a semantic change can happen in one branch while the other branch is not aware of it."
msgstr "即便合并不需要解决源代码冲突，但一次合并本身就会带来一些回归问题。这是因为语义变化可能发生在一个分支，而另一个分支并不知道该变化。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:991
#, priority:100
msgid "For example one branch can change the semantic of a function while the other branch add more calls to the same function."
msgstr "例如，一个分支可以改变一个函数的语义，而另一个分支则对同一个函数增加更多的调用。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:998
#, priority:100
msgid "This is made much worse if many files have to be fixed to resolve conflicts. That's why such merges are called \"evil merges\". They can make regressions very difficult to track down. It can even be misleading to know the first bad commit if it happens to be such a merge, because people might think that the bug comes from bad conflict resolution when it comes from a semantic change in one branch."
msgstr "如果为了解决冲突而不得不修复许多文件，情况就会变得更糟。这就是为什么这种合并被称为 \"邪恶合并\"。它们会使回归变得非常难以追踪。如果恰好合并了一个这样的坏提交，就很可能会产生误会，因为人们可能会认为这个错误来自于糟糕的冲突解决，但事实上它来自于一个分支的语义变化。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:1004
#, priority:100
msgid "Anyway \"git rebase\" can be used to linearize history. This can be used either to avoid merging in the first place. Or it can be used to bisect on a linear history instead of the non linear one, as this should give more information in case of a semantic change in one branch."
msgstr "无论如何，\"git rebase \"可以用来线性化历史。这也可以用来一开始就避免错误的合并。或者，它可以用来在线性历史上进行二分，而不是在非线性历史上进行二分，因为这在一个分支发生语义变化的情况下会提供更多信息。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:1007
#, priority:100
msgid "Merges can be also made simpler by using smaller branches or by using many topic branches instead of only long version related branches."
msgstr "通过使用较小的分支或使用许多主题分支而不是只使用一个非常长的分支，也可以使合并更简单。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:1010
#, priority:100
msgid "And testing can be done more often in special integration branches like linux-next for the linux kernel."
msgstr "而测试可以在特殊的集成分支中更频繁地进行，比如linux-next的linux内核。"

#. type: Title ~
#: en/git-bisect-lk2009.txt:1012
#, no-wrap, priority:100
msgid "Adapting your work-flow"
msgstr "调整你的工作流程"

#. type: Plain text
#: en/git-bisect-lk2009.txt:1015
#, priority:100
msgid "A special work-flow to process regressions can give great results."
msgstr "一个处理回归的特殊工作流程可以带来好的结果。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:1017
#, priority:100
msgid "Here is an example of a work-flow used by Andreas Ericsson:"
msgstr "比如，以下是Andreas Ericsson使用的一个工作流程："

#. type: Plain text
#: en/git-bisect-lk2009.txt:1019
#, priority:100
msgid "write, in the test suite, a test script that exposes the regression"
msgstr "在测试套件中，写一个测试脚本，暴露出回归的问题"

#. type: Plain text
#: en/git-bisect-lk2009.txt:1020
#, priority:100
msgid "use \"git bisect run\" to find the commit that introduced it"
msgstr "使用 \"git bisect run\" 查找引入它的提交"

#. type: Plain text
#: en/git-bisect-lk2009.txt:1021
#, priority:100
msgid "fix the bug that is often made obvious by the previous step"
msgstr "修复由上一步骤暴露出来的错误"

#. type: Plain text
#: en/git-bisect-lk2009.txt:1022
#, priority:100
msgid "commit both the fix and the test script (and if needed more tests)"
msgstr "提交修复和测试脚本（如果需要更多测试）"

#. type: Plain text
#: en/git-bisect-lk2009.txt:1024
#, placeholders:'<<5>>', priority:100
msgid "And here is what Andreas said about this work-flow <<5>>:"
msgstr "这里是Andreas对这个工作流程的评价<<5>>："

#. type: delimited block _
#: en/git-bisect-lk2009.txt:1034
#, priority:100
msgid "To give some hard figures, we used to have an average report-to-fix cycle of 142.6 hours (according to our somewhat weird bug-tracker which just measures wall-clock time). Since we moved to Git, we've lowered that to 16.2 hours. Primarily because we can stay on top of the bug fixing now, and because everyone's jockeying to get to fix bugs (we're quite proud of how lazy we are to let Git find the bugs for us). Each new release results in ~40% fewer bugs (almost certainly due to how we now feel about writing tests)."
msgstr "我们曾经有142.6小时的平均报告到修复周期（由我们只是测量时钟时间的错误跟踪器统计出）。自从我们转移到Git后，我们已经把这个时间降低到了16.2小时。主要是因为我们现在可以保持在最开始进行错误修复，也因为每个人都在争先恐后地修复错误（我们对自己懒得让Git为我们找到错误感到很自豪）。每个新的版本都会减少40%的bug（出于我们现在对编写测试的感觉，这个结果非常可信）。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:1039
#, priority:100
msgid "Clearly this work-flow uses the virtuous circle between test suites and \"git bisect\". In fact it makes it the standard procedure to deal with regression."
msgstr "显然，这个工作流程使用了测试套件和 \"git bisect \"之间的良性循环。事实上，也正是因此它才成为为处理回归的标准程序。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:1044
#, ignore-ellipsis, priority:100
msgid "In other messages Andreas says that they also use the \"best practices\" described above: small logical commits, topic branches, no evil merge,... These practices all improve the bisectability of the commit graph, by making it easier and more useful to bisect."
msgstr "在其他信息中，Andreas说他们也使用了上述的 \"最佳实践\"：小的逻辑提交，主题分支，没有邪恶的合并，......。这些做法都提高了提交图的可分性，使之更容易、更有用。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:1047
#, priority:100
msgid "So a good work-flow should be designed around the above points. That is making bisecting easier, more useful and standard."
msgstr "因此，一个好的工作流程应该围绕以上几点来设计。这就是让分界线变得更容易、更有用和更标准。"

#. type: Title ~
#: en/git-bisect-lk2009.txt:1049
#, no-wrap, priority:100
msgid "Involving QA people and if possible end users"
msgstr "让QA人员参与进来，如果可能的话，让终端用户参与进来"

#. type: Plain text
#: en/git-bisect-lk2009.txt:1055
#, priority:100
msgid "One nice about \"git bisect\" is that it is not only a developer tool. It can effectively be used by QA people or even end users (if they have access to the source code or if they can get access to all the builds)."
msgstr "关于 \"git bisect \"的一个好处是，它不仅仅是一个开发者工具。它可以有效地被QA人员甚至终端用户使用（如果他们能够访问源代码或者能够获得所有构建的权限）。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:1059
#, priority:100
msgid "There was a discussion at one point on the linux kernel mailing list of whether it was ok to always ask end user to bisect, and very good points were made to support the point of view that it is ok."
msgstr "在linux内核邮件列表中曾一度讨论过总是要求终端用户进行分割是否可行，并提出了非常好的观点来支持可以这样做的观点。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:1061
#, placeholders:'<<6>>', priority:100
msgid "For example David Miller wrote <<6>>:"
msgstr "例如，David Miller写道<<6>>："

#. type: delimited block _
#: en/git-bisect-lk2009.txt:1068
#, priority:100
msgid "What people don't get is that this is a situation where the \"end node principle\" applies. When you have limited resources (here: developers) you don't push the bulk of the burden upon them. Instead you push things out to the resource you have a lot of, the end nodes (here: users), so that the situation actually scales."
msgstr "人们不明白的是，这是一个适用 \"终端节点原则 \"的情况。当你拥有有限的资源时（这里是指开发人员），你不会把大部分的负担推给他们。相反，你要把事情推给你拥有的大量资源，即终端节点（这里：用户），这样情况才会有实际的扩展。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:1072
#, priority:100
msgid "This means that it is often \"cheaper\" if QA people or end users can do it."
msgstr "这意味着，如果QA人员或终端用户能够做到这一点，往往会 \"更便宜\"。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:1079
#, priority:100
msgid "What is interesting too is that end users that are reporting bugs (or QA people that reproduced a bug) have access to the environment where the bug happens. So they can often more easily reproduce a regression. And if they can bisect, then more information will be extracted from the environment where the bug happens, which means that it will be easier to understand and then fix the bug."
msgstr "有趣的是，报告错误的终端用户（或重现错误的QA人员）可以进入发生错误的环境。所以他们通常可以更容易地重现一个回归。如果他们能进行二分法，那么就可以从发生错误的环境中提取更多的信息，这意味着将更容易理解，然后修复错误。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:1083
#, priority:100
msgid "For open source projects it can be a good way to get more useful contributions from end users, and to introduce them to QA and development activities."
msgstr "对于开源项目来说，这可能是一个很好的方法，可以从终端用户那里获得更多有用的贡献，并将他们引入QA和开发活动。"

#. type: Title ~
#: en/git-bisect-lk2009.txt:1085
#, no-wrap, priority:100
msgid "Using complex scripts"
msgstr "使用复杂脚本"

#. type: Plain text
#: en/git-bisect-lk2009.txt:1089
#, priority:100
msgid "In some cases like for kernel development it can be worth developing complex scripts to be able to fully automate bisecting."
msgstr "在某些情况下，如内核开发，值得开发复杂的脚本，以便能够完全自动化地进行二分。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:1091
#, placeholders:'<<7>>', priority:100
msgid "Here is what Ingo Molnar says about that <<7>>:"
msgstr "以下是Ingo Molnar对此的评价<<7>>："

#. type: delimited block _
#: en/git-bisect-lk2009.txt:1101
#, placeholders:'git-bisect', priority:100
msgid "i have a fully automated bootup-hang bisection script. It is based on \"git-bisect run\". I run the script, it builds and boots kernels fully automatically, and when the bootup fails (the script notices that via the serial log, which it continuously watches - or via a timeout, if the system does not come up within 10 minutes it's a \"bad\" kernel), the script raises my attention via a beep and i power cycle the test box. (yeah, i should make use of a managed power outlet to 100% automate it)"
msgstr "我有一个完全自动化启动并挂起的二分脚本。它是基于 \"git-bisect run \"的。我运行这个脚本，它完全自动地构建和启动内核，当启动失败时（脚本通过连续观察的串行日志注意到这一点或者是通过超时判断，如果系统在10分钟内没有启动，就是一个 \"坏 \"内核），脚本通过嘟嘟声引起我的注意，我就给测试机断电。(的确，我应该使用一个可管理的电源插座来实现100%的自动化）"

#. type: Title ~
#: en/git-bisect-lk2009.txt:1104
#, no-wrap, priority:100
msgid "Combining test suites, git bisect and other systems together"
msgstr "将测试组件、git bisect 和其他系统组合在一起"

#. type: Plain text
#: en/git-bisect-lk2009.txt:1109
#, priority:100
msgid "We have seen that test suites and git bisect are very powerful when used together. It can be even more powerful if you can combine them with other systems."
msgstr "我们已经看到，测试套件和git bisect一起使用时已经非常强大了。如果你能把它们和其他系统结合起来，那将更加强大。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:1116
#, priority:100
msgid "For example some test suites could be run automatically at night with some unusual (or even random) configurations. And if a regression is found by a test suite, then \"git bisect\" can be automatically launched, and its result can be emailed to the author of the first bad commit found by \"git bisect\", and perhaps other people too. And a new entry in the bug tracking system could be automatically created too."
msgstr "例如，一些测试套件可以在晚上以一些不寻常（甚至是随机）的配置自动运行。如果测试套件发现了一个回归问题，那么 \"git bisect \"可以自动启动，其结果可以通过电子邮件发给 \"git bisect\"发现的第一个坏提交的作者，也许还有其他人。并且在错误跟踪系统中自动创建一个新条目。"

#. type: Title -
#: en/git-bisect-lk2009.txt:1119
#, no-wrap, priority:100
msgid "The future of bisecting"
msgstr "未来的二分算法"

#. type: Title ~
#: en/git-bisect-lk2009.txt:1122
#, no-wrap, priority:100
msgid "\"git replace\""
msgstr "\"git replace\""

#. type: Plain text
#: en/git-bisect-lk2009.txt:1128
#, priority:100
msgid "We saw earlier that \"git bisect skip\" is now using a PRNG to try to avoid areas in the commit graph where commits are untestable. The problem is that sometimes the first bad commit will be in an untestable area."
msgstr "之前，我们发现，\"git bisect skip\"目前使用PRNG来试图避免提交图中不可测试的区域。但问题是，有时第一个坏的提交恰恰在一个无法测试的区域。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:1134
#, priority:100
msgid "To simplify the discussion we will suppose that the untestable area is a simple string of commits and that it was created by a breakage introduced by one commit (let's call it BBC for bisect breaking commit) and later fixed by another one (let's call it BFC for bisect fixing commit)."
msgstr "为了简化这个话题，我们将假设不可测试区是一串简单的提交，它是由一个提交（我们称它为BBC，意为双断裂提交）引起的断裂，后来被另一个提交修复（我们称它为BFC，意为双断裂修复提交）。"

#. type: delimited block -
#: en/git-bisect-lk2009.txt:1139
#, ignore-ellipsis, no-wrap, priority:100
msgid "...-Y-BBC-X1-X2-X3-X4-X5-X6-BFC-Z-...\n"
msgstr "...-Y-BBC-X1-X2-X3-X4-X5-X6-BFC-Z-...\n"

#. type: Plain text
#: en/git-bisect-lk2009.txt:1143
#, priority:100
msgid "where we know that Y is good and BFC is bad, and where BBC and X1 to X6 are untestable."
msgstr "其中，我们知道Y是好的，BFC是坏的，而BBC和X1到X6不可测试。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:1150
#, priority:100
msgid "In this case if you are bisecting manually, what you can do is create a special branch that starts just before the BBC. The first commit in this branch should be the BBC with the BFC squashed into it. And the other commits in the branch should be the commits between BBC and BFC rebased on the first commit of the branch and then the commit after BFC also rebased on."
msgstr "在这种情况下，如果你是手动二分，你可以在BBC开始之前创建一个特殊的分支。这个分支的第一次提交应该是将 BFC 与BBC压缩到一起的。分支中的其他提交应该是在BBC和BFC之间的提交，以该分支的第一次提交为基础，然后再以BFC之后的提交为基础。"

#. type: delimited block -
#: en/git-bisect-lk2009.txt:1157
#, ignore-ellipsis, no-wrap, priority:100
msgid ""
"      (BBC+BFC)-X1'-X2'-X3'-X4'-X5'-X6'-Z'\n"
"     /\n"
"...-Y-BBC-X1-X2-X3-X4-X5-X6-BFC-Z-...\n"
msgstr ""
"      (BBC+BFC)-X1'-X2'-X3'-X4'-X5'-X6'-Z'\n"
"     /\n"
"...-Y-BBC-X1-X2-X3-X4-X5-X6-BFC-Z-...\n"

#. type: Plain text
#: en/git-bisect-lk2009.txt:1160
#, priority:100
msgid "where commits quoted with ' have been rebased."
msgstr "其中以引号 ' 括起来的的提交已被变基。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:1162
#, priority:100
msgid "You can easily create such a branch with Git using interactive rebase."
msgstr "你能够很轻松地用Git的交互式变基来创建这样的分支。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:1164
#, priority:100
msgid "For example using:"
msgstr "例如："

#. type: delimited block -
#: en/git-bisect-lk2009.txt:1167
#, no-wrap, priority:100
msgid "$ git rebase -i Y Z\n"
msgstr "$ git rebase -i Y Z\n"

#. type: Plain text
#: en/git-bisect-lk2009.txt:1170
#, priority:100
msgid "and then moving BFC after BBC and squashing it."
msgstr "然后BFC移动到BBC之后并压缩。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:1173
#, priority:100
msgid "After that you can start bisecting as usual in the new branch and you should eventually find the first bad commit."
msgstr "之后，你可以像往常一样在新的分支中开始二分，最终你应该能找到第一个坏的提交。"

#. type: delimited block -
#: en/git-bisect-lk2009.txt:1178
#, no-wrap, priority:100
msgid "$ git bisect start Z' Y\n"
msgstr "$ git bisect start Z' Y\n"

#. type: Plain text
#: en/git-bisect-lk2009.txt:1189
#, placeholders:'<<8>>', priority:100
msgid "If you are using \"git bisect run\", you can use the same manual fix up as above, and then start another \"git bisect run\" in the special branch. Or as the \"git bisect\" man page says, the script passed to \"git bisect run\" can apply a patch before it compiles and test the software <<8>>. The patch should turn a current untestable commits into a testable one. So the testing will result in \"good\" or \"bad\" and \"git bisect\" will be able to find the first bad commit. And the script should not forget to remove the patch once the testing is done before exiting from the script."
msgstr "如果你使用命令 \"git bisect run\"，你可以使用与上述相同的手段进行修复，然后在特殊分支中启动另一个 \"git bisect run\"。或者如 \"git bisect\"手册所说，作为\"git bisect run\"的脚本可以在编译和测试软件之前添加一个补丁<<8>>。这个补丁需要把当前不可测试的提交变成可测试的。这样，\"git bisect \"将能够找到第一个坏提交，所以测试的结果是 \"好 \"或 \"坏\"。但脚本应当在测试完成后退出脚本前删除补丁。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:1194
#, placeholders:'git cherry-pick':'--hard':'HEAD', priority:100
msgid "(Note that instead of a patch you can use \"git cherry-pick BFC\" to apply the fix, and in this case you should use \"git reset --hard HEAD^\" to revert the cherry-pick after testing and before returning from the script.)"
msgstr "(注意，你可以用 \"git cherry-pick BFC\"代替补丁来应用修复，在这种情况下，你应该用 \"git reset --hard HEAD^\"来在测试后和从脚本返回前恢复甄选（cherry-pick））"

#. type: Plain text
#: en/git-bisect-lk2009.txt:1202
#, priority:100
msgid "But the above ways to work around untestable areas are a little bit clunky. Using special branches is nice because these branches can be shared by developers like usual branches, but the risk is that people will get many such branches. And it disrupts the normal \"git bisect\" work-flow. So, if you want to use \"git bisect run\" completely automatically, you have to add special code in your script to restart bisection in the special branches."
msgstr "但上述绕过不可测试区域的方法有点笨拙。使用特殊分支是最好的，因为这些分支可以像普通分支一样被开发者共享，但风险是会创建很多这样的分支。并且它破坏了正常的 \"git bisect \"工作流程。因此，如果你想完全自动地使用 \"git bisect run\"，你必须在你的脚本中添加特殊的代码，以重新启动特殊分支的二分流程。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:1207
#, priority:100
msgid "Anyway one can notice in the above special branch example that the Z' and Z commits should point to the same source code state (the same \"tree\" in git parlance). That's because Z' result from applying the same changes as Z just in a slightly different order."
msgstr "总之，我们可以注意到，在上述特殊分支的例子中，Z'和Z的提交应该指向相同的源代码状态（用git术语说是相同的 \"树\"）。这是因为Z'的结果是应用了与Z相同的修改，只是顺序略有不同。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:1211
#, priority:100
msgid "So if we could just \"replace\" Z by Z' when we bisect, then we would not need to add anything to a script. It would just work for anyone in the project sharing the special branches and the replacements."
msgstr "因此，如果我们可以在二分时用Z'来 \"替换\"Z，那么我们就不需要在脚本中添加任何东西。它将对项目中任何共享特殊和替换分支的人起作用。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:1213
#, priority:100
msgid "With the example above that would give:"
msgstr "通过上面的例子，可以看出："

#. type: delimited block -
#: en/git-bisect-lk2009.txt:1218
#, ignore-ellipsis, no-wrap, priority:100
msgid ""
"      (BBC+BFC)-X1'-X2'-X3'-X4'-X5'-X6'-Z'-...\n"
"     /\n"
"...-Y-BBC-X1-X2-X3-X4-X5-X6-BFC-Z\n"
msgstr ""
"      (BBC+BFC)-X1'-X2'-X3'-X4'-X5'-X6'-Z'-...\n"
"     /\n"
"...-Y-BBC-X1-X2-X3-X4-X5-X6-BFC-Z\n"

#. type: Plain text
#: en/git-bisect-lk2009.txt:1225
#, priority:100
msgid "That's why the \"git replace\" command was created. Technically it stores replacements \"refs\" in the \"refs/replace/\" hierarchy. These \"refs\" are like branches (that are stored in \"refs/heads/\") or tags (that are stored in \"refs/tags\"), and that means that they can automatically be shared like branches or tags among developers."
msgstr "这就是\"git replace\"命令出现的原因。技术层面，它在 \"refs/replace/\"目录中存储替换的 \"refs\"。这些 \"ref \"就像分支（存储在 \"refs/heads/\"中）或标签（存储在 \"refs/tags \"中），所以它们可以像分支或标签一样自动地在开发者之间共享。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:1230
#, priority:100
msgid "\"git replace\" is a very powerful mechanism. It can be used to fix commits in already released history, for example to change the commit message or the author. And it can also be used instead of git \"grafts\" to link a repository with another old repository."
msgstr "\"git replace\"拥有非常强大的机制。它可以用来修复发布历史中的提交，例如改变提交的信息或作者。它也可以用来代替git \"grafts\"，将一个仓库与另一个旧仓库连接起来。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:1234
#, priority:100
msgid "In fact it's this last feature that \"sold\" it to the Git community, so it is now in the \"master\" branch of Git's Git repository and it should be released in Git 1.6.5 in October or November 2009."
msgstr "事实上，正是这最后一个功能把它\"卖\"给了Git社区，所以它目前在Git仓库的\"master\"分支中，应该是在2009年10月或11月的Git 1.6.5版本中发布的。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:1241
#, priority:100
msgid "One problem with \"git replace\" is that currently it stores all the replacements refs in \"refs/replace/\", but it would be perhaps better if the replacement refs that are useful only for bisecting would be in \"refs/replace/bisect/\". This way the replacement refs could be used only for bisecting, while other refs directly in \"refs/replace/\" would be used nearly all the time."
msgstr "\"git replace\"存在的一个问题是，目前它把所有替换的引用都存放在 \"refs/replace/\"中，但如果把只对二分有用的替换引用放在 \"refs/replace/bisect/\"中，也许会更好。这样一来，替换的引用就可以只用于二分，而直接存储在 \"refs/replace/\"中的其他引用则几乎一直在使用。"

#. type: Title ~
#: en/git-bisect-lk2009.txt:1243
#, no-wrap, priority:100
msgid "Bisecting sporadic bugs"
msgstr "查找零星的漏洞"

#. type: Plain text
#: en/git-bisect-lk2009.txt:1248
#, priority:100
msgid "Another possible improvement to \"git bisect\" would be to optionally add some redundancy to the tests performed so that it would be more reliable when tracking sporadic bugs."
msgstr "对 \"git bisect\"的另一个可能的改进是，在所进行的测试中选择性地增加一些冗余，这样在跟踪零星的bug时就会更可靠。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:1252
#, priority:100
msgid "This has been requested by some kernel developers because some bugs called sporadic bugs do not appear in all the kernel builds because they are very dependent on the compiler output."
msgstr "这是由一些内核开发者提出的要求，因为一些被称为零星漏洞的漏洞不会出现在所有的内核构建过程中，因为发现它们非常依赖于编译器输出。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:1261
#, priority:100
msgid "The idea is that every 3 test for example, \"git bisect\" could ask the user to test a commit that has already been found to be \"good\" or \"bad\" (because one of its descendants or one of its ancestors has been found to be \"good\" or \"bad\" respectively). If it happens that a commit has been previously incorrectly classified then the bisection can be aborted early, hopefully before too many mistakes have been made. Then the user will have to look at what happened and then restart the bisection using a fixed bisect log."
msgstr "我们的想法是，每3次测试，\"git bisect\"可以要求用户测试一个已经被标记为 \"好 \"或 \"坏 \"的提交（因为它的一个后代或一个祖先已经被视为 \"好 \"或 \"坏\"提交）。如果错误地分类了一个提交，那么可以在酿成大祸之前中止这个过程。接着，用户将不得不查看发生了什么，最后使用固定的日志重新启动二分操作。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:1265
#, placeholders:'<<9>>', priority:100
msgid "There is already a project called BBChop created by Ealdwulf Wuffinga on Github that does something like that using Bayesian Search Theory <<9>>:"
msgstr "目前，Github上已经有一个由Ealdwulf Wuffinga创建的名为BBChop的项目，其使用贝叶斯搜索理论做了类似的事情<<9>>："

#. type: delimited block _
#: en/git-bisect-lk2009.txt:1272
#, priority:100
msgid "BBChop is like 'git bisect' (or equivalent), but works when your bug is intermittent. That is, it works in the presence of false negatives (when a version happens to work this time even though it contains the bug). It assumes that there are no false positives (in principle, the same approach would work, but adding it may be non-trivial)."
msgstr "BBChop就像'git bisect'（或就是），但当存在间歇性漏洞的时候，它就会起作用。也就是说，它在存在假阴性的情况下也能工作（尽管这个版本包含了这个漏洞，但也可以运行）。它假定不存在假阳性（原则上，同样的方法也可以，但这可能不容易）。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:1276
#, priority:100
msgid "But BBChop is independent of any VCS and it would be easier for Git users to have something integrated in Git."
msgstr "但BBChop是独立于任何VCS的，并且对于Git用户来说，在Git中集成一些东西非常容易。"

#. type: Title -
#: en/git-bisect-lk2009.txt:1278
#, no-wrap, priority:100
msgid "Conclusion"
msgstr "结论"

#. type: Plain text
#: en/git-bisect-lk2009.txt:1285
#, priority:100
msgid "We have seen that regressions are an important problem, and that \"git bisect\" has nice features that complement very well practices and other tools, especially test suites, that are generally used to fight regressions. But it might be needed to change some work-flows and (bad) habits to get the most out of it."
msgstr "我们已经了解到，回归是一个重要的问题，\"git bisect\"有强大的功能，同时也可以很好地补充和应用到其他工具中，尤其是通常被用来解决回归问题测试套件。但也需要改变一些工作流程和改正坏习惯，以获得它的最大效益。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:1292
#, priority:100
msgid "Some improvements to the algorithms inside \"git bisect\" are possible and some new features could help in some cases, but overall \"git bisect\" works already very well, is used a lot, and is already very useful. To back up that last claim, let's give the final word to Ingo Molnar when he was asked by the author how much time does he think \"git bisect\" saves him when he uses it:"
msgstr "\"git bisect\"内部的算法可以进行改进，并且新的功能在特殊情况下也会有帮助，但总的来说，\"git bisect \"已经被大量使用并且非常优秀。Ingo Molnar的发言是最后一个说法的有力支撑，作者问他认为使用 \"git bisect\"能够节省他多少时间："

#. type: delimited block _
#: en/git-bisect-lk2009.txt:1295
#, priority:100
msgid "a _lot_."
msgstr "a _lot_."

#. type: delimited block _
#: en/git-bisect-lk2009.txt:1300
#, priority:100
msgid "About ten years ago did i do my first 'bisection' of a Linux patch queue. That was prior the Git (and even prior the BitKeeper) days. I literally days spent sorting out patches, creating what in essence were standalone commits that i guessed to be related to that bug."
msgstr "大约十年前，我第一次对Linux补丁队列进行了 \"二分算法\"。那是在Git（甚至在BitKeeper）出现之前。我真的花了好几天时间来整理补丁，创建了一些我猜测与该错误有关的独立提交。"

#. type: delimited block _
#: en/git-bisect-lk2009.txt:1303
#, priority:100
msgid "It was a tool of absolute last resort. I'd rather spend days looking at printk output than do a manual 'patch bisection'."
msgstr "这是一个万不得已的情况下使用的工具。我宁愿花几天时间看printk输出，也不愿意进行手动 的\"补丁分割\"。"

#. type: delimited block _
#: en/git-bisect-lk2009.txt:1308
#, priority:100
msgid "With Git bisect it's a breeze: in the best case i can get a ~15 step kernel bisection done in 20-30 minutes, in an automated way. Even with manual help or when bisecting multiple, overlapping bugs, it's rarely more than an hour."
msgstr "使用Git bisect很容易：在最好的情况下，我可以在20-30分钟内以自动化的方式完成约15个步骤的内核分割。即使需要人工帮助，或者在对多个重叠的bug进行分割时，也很少超过一个小时。"

#. type: delimited block _
#: en/git-bisect-lk2009.txt:1314
#, priority:100
msgid "In fact it's invaluable because there are bugs i would never even _try_ to debug if it wasn't for git bisect. In the past there were bug patterns that were immediately hopeless for me to debug - at best i could send the crash/bug signature to lkml and hope that someone else can think of something."
msgstr "事实上，它是非常有价值的，因为如果没有git bisect，有些漏洞我甚至不会尝试去调试。在过去，有些漏洞对我来说基本就没有希望进行调试——我最多只能把崩溃/漏洞签名发给lkml，希望别人能想到一些东西。"

#. type: delimited block _
#: en/git-bisect-lk2009.txt:1318
#, priority:100
msgid "And even if a bisection fails today it tells us something valuable about the bug: that it's non-deterministic - timing or kernel image layout dependent."
msgstr "即使是在运行失败的情况下，它也会告诉我们关于这个漏洞一些有价值的东西：它是非决定性的——与时间或内核图像布局有关。"

#. type: delimited block _
#: en/git-bisect-lk2009.txt:1321
#, priority:100
msgid "So git bisect is unconditional goodness - and feel free to quote that ;-)"
msgstr "因此，git bisect的善良不求回报——请随意引用这句话;-)"

#. type: Title -
#: en/git-bisect-lk2009.txt:1324
#, no-wrap, priority:100
msgid "Acknowledgments"
msgstr "致谢"

#. type: Plain text
#: en/git-bisect-lk2009.txt:1330
#, priority:100
msgid "Many thanks to Junio Hamano for his help in reviewing this paper, for reviewing the patches I sent to the Git mailing list, for discussing some ideas and helping me improve them, for improving \"git bisect\" a lot and for his awesome work in maintaining and developing Git."
msgstr "非常感谢Junio Hamano在审阅本文时提供的帮助，感谢他审阅我发给Git邮件列表的补丁，感谢他讨论一些想法并帮助我改进，感谢他对 \"git bisect\"的大量改进，感谢他在维护和开发Git方面的出色工作。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:1335
#, priority:100
msgid "Many thanks to Ingo Molnar for giving me very useful information that appears in this paper, for commenting on this paper, for his suggestions to improve \"git bisect\" and for evangelizing \"git bisect\" on the linux kernel mailing lists."
msgstr "非常感谢Ingo Molnar给本文提供非常有用的信息，感谢他对本文的评论，感谢他对 \"git bisect\"的改进建议，感谢他在linux内核邮件列表中对\"git bisect\"的宣传。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:1338
#, priority:100
msgid "Many thanks to Linus Torvalds for inventing, developing and evangelizing \"git bisect\", Git and Linux."
msgstr "非常感谢Linus Torvalds对 \"git bisect\"、Git和Linux的发明、开发和宣传。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:1343
#, priority:100
msgid "Many thanks to the many other great people who helped one way or another when I worked on Git, especially to Andreas Ericsson, Johannes Schindelin, H. Peter Anvin, Daniel Barkalow, Bill Lear, John Hawley, Shawn O. Pierce, Jeff King, Sam Vilain, Jon Seymour."
msgstr "非常感谢其他许多在我从事Git工作时以这种或那种方式提供帮助的伟大人物，特别是Andreas Ericsson, Johannes Schindelin, H. Peter Anvin, Daniel Barkalow, Bill Lear, John Hawley, Shawn O. Pierce, Jeff King, Sam Vilain, Jon Seymour。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:1346
#, priority:100
msgid "Many thanks to the Linux-Kongress program committee for choosing the author to given a talk and for publishing this paper."
msgstr "非常感谢Linux-Kongress计划委员会选择作者进行演讲并发表这篇论文。"

#. type: Title -
#: en/git-bisect-lk2009.txt:1348
#, no-wrap, priority:100
msgid "References"
msgstr "引用"

#. type: Plain text
#: en/git-bisect-lk2009.txt:1351
#, placeholders:'[[[1]]]':'https://web.archive.org/web/20091206032101/http://www.nist.gov/public_affairs/releases/n02-10.htm[':'https://www.nist.gov/system/files/documents/director/planning/report02-3.pdf[', priority:100
msgid "[[[1]]] https://web.archive.org/web/20091206032101/http://www.nist.gov/public_affairs/releases/n02-10.htm['Software Errors Cost U.S. Economy $59.5 Billion Annually'. Nist News Release.] See also https://www.nist.gov/system/files/documents/director/planning/report02-3.pdf['The Economic Impacts of Inadequate Infratructure for Software Testing'. Nist Planning Report 02-3], Executive Summary and Chapter 8."
msgstr "[[[1]]] https://web.archive.org/web/20091206032101/http://www.nist.gov/public_affairs/releases/n02-10.htm['Software Errors Cost U.S. Economy $59.5 Billion Annually'. Nist News Release.] 另见 https://www.nist.gov/system/files/documents/director/planning/report02-3.pdf['The Economic Impacts of Inadequate Infratructure for Software Testing'. Nist Planning Report 02-3], 内容摘要和第 8 章。"

# ERROR: introduction.html not found in translation
#. type: Plain text
#: en/git-bisect-lk2009.txt:1352
#, placeholders:'[[[2]]]':'https://www.oracle.com/java/technologies/javase/codeconventions-introduction.html[', priority:100
msgid "[[[2]]] https://www.oracle.com/java/technologies/javase/codeconventions-introduction.html['Code Conventions for the Java Programming Language: 1. Introduction'. Sun Microsystems.]"
msgstr "[[[2]]] https://www.oracle.com/java/technologies/javase/codeconventions-introduction.html['Code Conventions for the Java Programming Language: 1. Introduction'. Sun Microsystems.]"

#. type: Plain text
#: en/git-bisect-lk2009.txt:1353
#, placeholders:'[[[3]]]':'https://en.wikipedia.org/wiki/Software_maintenance[', priority:100
msgid "[[[3]]] https://en.wikipedia.org/wiki/Software_maintenance['Software maintenance'. Wikipedia.]"
msgstr "[[[3]]] https://en.wikipedia.org/wiki/Software_maintenance['Software maintenance'. Wikipedia.]"

#. type: Plain text
#: en/git-bisect-lk2009.txt:1354
#, placeholders:'[[[4]]]':'https://lore.kernel.org/git/7vps5xsbwp.fsf_-_@assigned-by-dhcp.cox.net/[', priority:100
msgid "[[[4]]] https://lore.kernel.org/git/7vps5xsbwp.fsf_-_@assigned-by-dhcp.cox.net/[Junio C Hamano. 'Automated bisect success story'.]"
msgstr "[[[4]]] https://lore.kernel.org/git/7vps5xsbwp.fsf_-_@assigned-by-dhcp.cox.net/[Junio C Hamano. 'Automated bisect success story'.]"

#. type: Plain text
#: en/git-bisect-lk2009.txt:1355
#, placeholders:'[[[5]]]':'https://lwn.net/Articles/317154/[':'LWN.net', priority:100
msgid "[[[5]]] https://lwn.net/Articles/317154/[Christian Couder. 'Fully automated bisecting with \"git bisect run\"'. LWN.net.]"
msgstr "[[[5]]] https://lwn.net/Articles/317154/[Christian Couder. 'Fully automated bisecting with \"git bisect run\"'. LWN.net.]"

#. type: Plain text
#: en/git-bisect-lk2009.txt:1356
#, placeholders:'[[[6]]]':'https://lwn.net/Articles/277872/[':'LWN.net', priority:100
msgid "[[[6]]] https://lwn.net/Articles/277872/[Jonathan Corbet. 'Bisection divides users and developers'. LWN.net.]"
msgstr "[[[6]]] https://lwn.net/Articles/277872/[Jonathan Corbet. 'Bisection divides users and developers'. LWN.net.]"

#. type: Plain text
#: en/git-bisect-lk2009.txt:1357
#, placeholders:'[[[7]]]':'https://lore.kernel.org/lkml/20071207113734.GA14598@elte.hu/[', priority:100
msgid "[[[7]]] https://lore.kernel.org/lkml/20071207113734.GA14598@elte.hu/[Ingo Molnar. 'Re: BUG 2.6.23-rc3 can't see sd partitions on Alpha'. Linux-kernel mailing list.]"
msgstr "[[[7]]] https://lore.kernel.org/lkml/20071207113734.GA14598@elte.hu/[Ingo Molnar. 'Re: BUG 2.6.23-rc3 can't see sd partitions on Alpha'. Linux-kernel mailing list.]"

#. type: Plain text
#: en/git-bisect-lk2009.txt:1358
#, placeholders:'[[[8]]]':'https://www.kernel.org/pub/software/scm/git/docs/git-bisect.html[':'git-list':'git-bisect', priority:100
msgid "[[[8]]] https://www.kernel.org/pub/software/scm/git/docs/git-bisect.html[Junio C Hamano and the git-list. 'git-bisect(1) Manual Page'. Linux Kernel Archives.]"
msgstr "[[[8]]] https://www.kernel.org/pub/software/scm/git/docs/git-bisect.html[Junio C Hamano and the git-list. 'git-bisect(1) Manual Page'. Linux Kernel Archives.]"

#. type: Plain text
#: en/git-bisect-lk2009.txt:1358
#, placeholders:'[[[9]]]':'https://github.com/Ealdwulf/bbchop[', priority:100
msgid "[[[9]]] https://github.com/Ealdwulf/bbchop[Ealdwulf. 'bbchop'. GitHub.]"
msgstr "[[[9]]] https://github.com/Ealdwulf/bbchop[Ealdwulf. 'bbchop'. GitHub.]"

#~ msgid "Ignore whitespace when comparing lines.  This ignores differences even if one line has whitespace where the other line has none."
#~ msgstr "比较行时忽略空格。即使一行有空格而另一行没有空格，也会忽略差异。"

#~ msgid "Fetch all remotes."
#~ msgstr "抓取所有远程。"

#~ msgid "The name of an existing branch to rename."
#~ msgstr "要重命名的现有分支的名称。"

#~ msgid "that is to say, the branch is not reset/created unless \"git checkout\" is successful."
#~ msgstr "也就是说，除非 \"git checkout \"执行成功，否则该分支不会被重置/创建。"

#~ msgid "A string that interpolates `%(fieldname)` from a ref being shown and the object it points at.  If `fieldname` is prefixed with an asterisk (`*`) and the ref points at a tag object, use the value for the field in the object which the tag object refers to (instead of the field in the tag object).  When unspecified, `<format>` defaults to `%(objectname) SPC %(objecttype) TAB %(refname)`.  It also interpolates `%%` to `%`, and `%xx` where `xx` are hex digits interpolates to character with hex code `xx`; for example `%00` interpolates to `\\0` (NUL), `%09` to `\\t` (TAB) and `%0a` to `\\n` (LF)."
#~ msgstr "一个字符串，用于从显示的引用及其指向的对象中插入 `%(字段名)`。 如果 `字段名` 前缀为星号 ( `*` )，且引用指向一个标记对象，则使用标记对象指向的对象中的字段值（而不是标记对象中的字段）。 未指定时，`<格式>` 默认为 `%(对象名) SPC %(对象名) TAB %(引用名)`。 它还会将 `%%` 内插为 `%`，将 `%xx` 内插为十六进制代码为 `xx` 的字符；例如，将 `%00` 内插为 `\\0` (NUL)，将 `%09` 内插为 `\\t` (TAB)，将 `%0a` 内插为 `\\n` (LF)。"

#~ msgid "Die, if the pack contains broken objects or links."
#~ msgstr "死亡，如果该包包含破碎的对象或链接。"

#, ignore-same, no-wrap
#~ msgid "--fsck-objects"
#~ msgstr "--fsck-objects"

#, placeholders:'`--format`':'--format'
#~ msgid "It is possible to print in a custom format by using the `--format` option, which is able to interpolate different fields using a `%(fieldname)` notation.  For example, if you only care about the \"objectname\" and \"path\" fields, you can execute with a specific \"--format\" like"
#~ msgstr "使用 `--format` 选项可以自定义打印格式，该选项可以使用 `%(字段名)` 符号对不同字段进行插值。 例如，如果只关心 “对象名” 和 “路径” 字段，可以使用特定的 \"--format\" 执行，如"

#, placeholders:'--continue`'
#~ msgid "The third syntax (\"`git merge --continue`\") can only be run after the merge has resulted in conflicts."
#~ msgstr "第三种语法（\"`git merge --continue`\"）只能在合并导致冲突后运行。"

#, ignore-ellipsis, placeholders:'`--fixup`':'`--fixup=amend':'`--fixup=reword':'`--squash`':'linkgit:git-commit[1]'
#~ msgid "When the commit log message begins with \"squash! ...\" or \"fixup! ...\" or \"amend! ...\", and there is already a commit in the todo list that matches the same `...`, automatically modify the todo list of `rebase -i`, so that the commit marked for squashing comes right after the commit to be modified, and change the action of the moved commit from `pick` to `squash` or `fixup` or `fixup -C` respectively. A commit matches the `...` if the commit subject matches, or if the `...` refers to the commit's hash. As a fall-back, partial matches of the commit subject work, too. The recommended way to create fixup/amend/squash commits is by using the `--fixup`, `--fixup=amend:` or `--fixup=reword:` and `--squash` options respectively of linkgit:git-commit[1]."
#~ msgstr "当提交日志信息以 \"squash！...\" 或 \"fixup！...\" 或 \"amend！......\"，并且待办事项列表中已经有一个与相同的 `...` 匹配的提交时，就会自动修改 `rebase -i` 的待办事项列表，使标记为压扁的提交紧跟在要修改的提交之后，并将移动提交的操作从 `pick` 分别改为 `squash` 或 `fixup` 或 `fixup -C`。如果提交主题匹配 `...`，或者 `...` 指的是提交的哈希值，则该提交匹配 `...`。作为后备，提交主题的部分匹配也会起作用。建议使用 linkgit:git-commit[1] 的 `--fixup`、`--fixup=amend:` 或 `--fixup=reword:`、`--squash` 选项来创建 fixup/amend/squash 提交。"

#, no-wrap
#~ msgid "mode         SP sha1          TAB path\n"
#~ msgstr "模式         SP sha1          TAB 路径\n"

#, fuzzy, no-wrap
#~ msgid "git file is."
#~ msgstr "git file is."

#, no-wrap
#~ msgid "keep file used as a lock to prevent the race with 'git repack'"
#~ msgstr "用一个锁来持有文件，以防止与 'git repack' 竞争"

#~ msgid "mentioned above."
#~ msgstr "上述提到的。"

#, fuzzy
#~ msgid "Generate patch (see section titled"
#~ msgstr "生成补丁（参阅生成补丁的相关章节）。"

#, fuzzy
#~ msgid "\"Generating patch text with -p\")."
#~ msgstr "使用选项 `-p` 生成补丁文本"

#, ignore-same, no-wrap
#~ msgid "--diff-merges=(off|none|on|first-parent|1|separate|m|combined|c|dense-combined|cc|remerge|r)"
#~ msgstr "--diff-merges=(off|none|on|first-parent|1|separate|m|combined|c|dense-combined|cc|remerge|r)"

#, ignore-same, no-wrap
#~ msgid "--diff-merges=(off|none)"
#~ msgstr "--diff-merges=(off|none)"

#, ignore-same, no-wrap
#~ msgid "--diff-merges=first-parent"
#~ msgstr "--diff-merges=first-parent"

#, ignore-same, no-wrap
#~ msgid "--diff-merges=1"
#~ msgstr "--diff-merges=1"

#~ msgid "This option makes merge commits show the full diff with respect to the first parent only."
#~ msgstr "此选项使合并提交只显示与第一个父提交之间的完整差异。"

#, ignore-same, no-wrap
#~ msgid "--diff-merges=separate"
#~ msgstr "--diff-merges=separate"

#, ignore-same, no-wrap
#~ msgid "--diff-merges=remerge"
#~ msgstr "--diff-merges=remerge"

#, ignore-same, no-wrap
#~ msgid "--diff-merges=r"
#~ msgstr "--diff-merges=r"

#, ignore-same, no-wrap
#~ msgid "--diff-merges=combined"
#~ msgstr "--diff-merges=combined"

#, ignore-same, no-wrap
#~ msgid "--diff-merges=c"
#~ msgstr "--diff-merges=c"

#, ignore-same, no-wrap
#~ msgid "--diff-merges=cc"
#~ msgstr "--diff-merges=cc"

#~ msgid "This means that the trimmed <token> and <value> will be separated by `': '` (one colon followed by one space). For convenience, the <token> can be a shortened string key (e.g., \"sign\") instead of the full string which should appear before the separator on the output (e.g., \"Signed-off-by\"). This can be configured using the 'trailer.<token>.key' configuration variable."
#~ msgstr "这意味着修剪后的 <token> 和 <value> 将用 `': '`（一个冒号后加一个空格）分隔。为方便起见，<token> 可以是缩短的字符串关键字（如 \"sign\"），而不是完整的字符串，完整的字符串应出现在输出分隔符之前（如 \"Signed-off-by\"）。这可以使用 'trailer.<token>.key ' 配置变量进行配置。"

#~ msgid "Remove any whitespace-continuation in trailers, so that each trailer appears on a line by itself with its full content."
#~ msgstr "移除尾注中的任何空格，以便每个尾注都能以其完整的内容出现在一行中。"

#, placeholders:'`--only-trailers':'--only-input':'--unfold`'
#~ msgid "A convenience alias for `--only-trailers --only-input --unfold`."
#~ msgstr "`--only-trailers --only-input --unfold` 的别名。"

#, no-wrap, placeholders:'HEAD'
#~ msgid ""
#~ "Submodules have more state and instead report\n"
#~ "\t\tM    the submodule has a different HEAD than\n"
#~ "\t\t     recorded in the index\n"
#~ "\t\tm    the submodule has modified content\n"
#~ "\t\t?    the submodule has untracked files\n"
#~ "since modified content or untracked files in a submodule cannot be added\n"
#~ "via `git add` in the superproject to prepare a commit.\n"
#~ msgstr ""
#~ "子模块有更多的状态，而是报告\n"
#~ "\t\tM的子模块有一个不同的HEAD比\n"
#~ "\t\t     记录在索引中\n"
#~ "\t\tm 该子模块有修改的内容\n"
#~ "\t\t该子模块有未跟踪的文件\n"
#~ "因为子模块中的修改内容或未跟踪的文件不能被添加到\n"
#~ "通过超级项目中的`git add`来准备提交。\n"

#, placeholders:'`--object-format=sha256`'
#~ msgid "THIS OPTION IS EXPERIMENTAL! SHA-256 support is experimental and still in an early stage.  A SHA-256 repository will in general not be able to share work with \"regular\" SHA-1 repositories.  It should be assumed that, e.g., Git internal file formats in relation to SHA-256 repositories may change in backwards-incompatible ways.  Only use `--object-format=sha256` for testing purposes."
#~ msgstr "此选项是实验性的！SHA-256 支持是实验性的，仍然处于早期阶段。一般来说，SHA-256 仓库不能与 \"常规\" SHA-1 仓库共同工作。应该假定，例如，与 SHA-256 仓库有关的 Git 内部文件格式可能会以向后不兼容的方式改变。仅在测试时使用 `--object-format=sha256` 选项。"

#~ msgid "print a byte from a hex code"
#~ msgstr "打印十六进制代码中的一个字节"

#, placeholders:'{caret}':'`--not`'
#~ msgid "Reverses the meaning of the '{caret}' prefix (or lack thereof)  for all following revision specifiers, up to the next `--not`."
#~ msgstr "颠倒\"{caret}\"前缀（或没有前缀）对所有后续修订指定符的意义，直到下一个`--not`。"

#, placeholders:'`--merge-base`'
#~ msgid "Just in case you are doing something exotic, it should be noted that all of the <commit> in the above description, except in the `--merge-base` case and in the last two forms that use `..` notations, can be any <tree>."
#~ msgstr "为了防止你做一些奇怪的事情，应该注意到，除了`--merge-base`的情况和最后两种使用`...`符号的形式，上述描述中的所有<commit>都可以是任何<tree>。"

#, placeholders:'`--trailer`'
#~ msgid "Otherwise, this command applies the arguments passed using the `--trailer` option, if any, to the commit message part of each input file. The result is emitted on the standard output."
#~ msgstr "否则，该命令将使用 `--trailer` 选项传递的参数（如果有的话）应用于每个输入文件的提交信息部分。其结果将在标准输出中发出。"

#, fuzzy, no-wrap
#~ msgid "message\n"
#~ msgstr "消息\n"

#, no-wrap, placeholders:'git ls-remote':'--tags'
#~ msgid ""
#~ "$ git ls-remote --tags .\n"
#~ "d6602ec5194c87b0fc87103ca4d67251c76f233a\trefs/tags/v0.99\n"
#~ "f25a265a342aed6041ab0cc484224d9ca54b6f41\trefs/tags/v0.99.1\n"
#~ "7ceca275d047c90c0c7d5afb13ab97efdf51bd6e\trefs/tags/v0.99.3\n"
#~ "c5db5456ae3b0873fc659c19fafdde22313cc441\trefs/tags/v0.99.2\n"
#~ "0918385dbd9656cab0d1d81ba7453d49bbc16250\trefs/tags/junio-gpg-pub\n"
#~ msgstr ""
#~ "$ git ls-remote --tags .\n"
#~ "d6602ec5194c87b0fc87103ca4d67251c76f233a\trefs/tags/v0.99\n"
#~ "f25a265a342aed6041ab0cc484224d9ca54b6f41\trefs/tags/v0.99.1\n"
#~ "7ceca275d047c90c0c7d5afb13ab97efdf51bd6e\trefs/tags/v0.99.3\n"
#~ "c5db5456ae3b0873fc659c19fafdde22313cc441\trefs/tags/v0.99.2\n"
#~ "0918385dbd9656cab0d1d81ba7453d49bbc16250\trefs/tags/junio-gpg-pub\n"

#, no-wrap, placeholders:'www.kernel.org':'git.git':'git ls-remote':'--tags'
#~ msgid ""
#~ "$ git remote add korg http://www.kernel.org/pub/scm/git/git.git\n"
#~ "$ git ls-remote --tags korg v\\*\n"
#~ "d6602ec5194c87b0fc87103ca4d67251c76f233a\trefs/tags/v0.99\n"
#~ "f25a265a342aed6041ab0cc484224d9ca54b6f41\trefs/tags/v0.99.1\n"
#~ "c5db5456ae3b0873fc659c19fafdde22313cc441\trefs/tags/v0.99.2\n"
#~ "7ceca275d047c90c0c7d5afb13ab97efdf51bd6e\trefs/tags/v0.99.3\n"
#~ msgstr ""
#~ "$ git remote add korg http://www.kernel.org/pub/scm/git/git.git\n"
#~ "$ git ls-remote --tags korg v\\*\n"
#~ "d6602ec5194c87b0fc87103ca4d67251c76f233a\trefs/tags/v0.99\n"
#~ "f25a265a342aed6041ab0cc484224d9ca54b6f41\trefs/tags/v0.99.1\n"
#~ "c5db5456ae3b0873fc659c19fafdde22313cc441\trefs/tags/v0.99.2\n"
#~ "7ceca275d047c90c0c7d5afb13ab97efdf51bd6e\trefs/tags/v0.99.3\n"

#, placeholders:'HEAD'
#~ msgid "Append to the notes of an existing object (defaults to HEAD).  Creates a new notes object if needed."
#~ msgstr "附加到一个现有对象的注释中（默认为HEAD）。 如果需要的话，会创建一个新的注释对象。"

#~ msgid "Take the given blob object (for example, another note) as the note message. (Use `git notes copy <object>` instead to copy notes between objects.)"
#~ msgstr "将给定的blob对象（例如，另一个笔记）作为笔记信息。(使用`git notes copy <object>`来代替在对象之间复制注释)。"

#~ msgid "The following 'update' procedures are only available via the `submodule.<name>.update` configuration variable:"
#~ msgstr "以下 'update' 程序仅通过 `submodule.<名称>.update` 配置变量可用："

#~ msgid "arbitrary shell command that takes a single argument (the sha1 of the commit recorded in the superproject) is executed. When `submodule.<name>.update` is set to '!command', the remainder after the exclamation mark is the custom command."
#~ msgstr "执行任意的 shell 命令，该命令需要一个参数（父项目中记录的提交的 sha1）。当 `submodule.<名称>.update` 被设置为 '!command' 时，惊叹号后的剩余部分就是自定义命令。"

#~ msgid "the submodule is not updated."
#~ msgstr "该子模块不被更新。"

#, ignore-same
#~ msgid "linkgit:git-apply[1]."
#~ msgstr "linkgit:git-apply[1]."

#, ignore-same
#~ msgid "bc"
#~ msgstr "bc"

#, ignore-same
#~ msgid "bc3"
#~ msgstr "bc3"

#, ignore-same
#~ msgid "bc4"
#~ msgstr "bc4"

#, ignore-same
#~ msgid "smerge"
#~ msgstr "smerge"

#, placeholders:'`--objects`'
#~ msgid "Only useful with `--objects`; print the names of the object IDs that are found. This is the default behavior."
#~ msgstr "只对`---对象`有用；打印找到的对象ID的名称。这是默认行为。"

#, fuzzy
#~ msgid "cached"
#~ msgstr "已缓存"

#, fuzzy
#~ msgid "skip-worktree"
#~ msgstr "跳过工作树"

#, fuzzy
#~ msgid "unmerged"
#~ msgstr "未合并"

#, fuzzy
#~ msgid "to be killed"
#~ msgstr "将被终止"

#, ignore-same
#~ msgid "--[no-]autosquash"
#~ msgstr "--[no-]autosquash"

#, no-wrap, placeholders:'--super-prefix='
#~ msgid "--super-prefix=<path>"
#~ msgstr "--super-prefix=<path>"

#~ msgid "Currently for internal use only.  Set a prefix which gives a path from above a repository down to its root.  One use is to give submodules context about the superproject that invoked it."
#~ msgstr "目前只供内部使用。 设置一个前缀，提供一个从仓库到其根目录的路径。 一个用途是给子模块提供关于调用它父模块的上下文。"

#, fuzzy
#~ msgid "Prints a Git logical variable."
#~ msgstr "Git"

#, placeholders:'`--date=default`':'`--date=rfc2822`'
#~ msgid "`--date=default` is the default format, and is similar to `--date=rfc2822`, with a few exceptions:"
#~ msgstr "`--date=default`是默认格式，与`--date=rfc2822`类似，但有一些例外。"

#~ msgid "there is no comma after the day-of-week"
#~ msgstr "在星期的后面没有逗号"

#~ msgid "the time zone is omitted when the local time zone is used"
#~ msgstr "使用本地时区时省略时区"

#, ignore-ellipsis, no-wrap
#~ msgid "'git mv' <options>... <args>...\n"
#~ msgstr "'git mv' <options>...<args>...\n"

#, fuzzy, no-wrap
#~ msgid "'git reflog' <subcommand> <options>\n"
#~ msgstr "'git reflog' <subcommand> <options>\n"

#, ignore-same, no-wrap
#~ msgid "apply.ignoreWhitespace"
#~ msgstr "apply.ignoreWhitespace"

#, ignore-same, no-wrap
#~ msgid "apply.whitespace"
#~ msgstr "apply.whitespace"

#, ignore-same, no-wrap
#~ msgid "diff.guitool"
#~ msgstr "diff.guitool"

#, ignore-same, no-wrap
#~ msgid "difftool.prompt"
#~ msgstr "difftool.prompt"

#, ignore-same, no-wrap
#~ msgid "difftool.trustExitCode"
#~ msgstr "difftool.trustExitCode"

#, fuzzy, no-wrap, placeholders:'grep.patternType'
#~ msgid "grep.patternType"
#~ msgstr "grep.patternType"

#, fuzzy, no-wrap, placeholders:'grep.extendedRegexp'
#~ msgid "grep.extendedRegexp"
#~ msgstr "grep.extendedRegexp"

#, fuzzy, no-wrap, placeholders:'grep.fullName'
#~ msgid "grep.fullName"
#~ msgstr "grep.fullName"

#, fuzzy, no-wrap, placeholders:'grep.fallbackToNoIndex'
#~ msgid "grep.fallbackToNoIndex"
#~ msgstr "grep.fallbackToNoIndex"

#, ignore-same, no-wrap
#~ msgid "log.date"
#~ msgstr "log.date"

#, placeholders:'`--date`'
#~ msgid "Default format for human-readable dates.  (Compare the `--date` option.)  Defaults to \"default\", which means to write dates like `Sat May 8 19:35:34 2010 -0500`."
#~ msgstr "人类可读日期的默认格式。 (比较`--date`选项。)默认为 \"default\"，即写成`Sat May 8 19:35:34 2010 -0500`这样的日期。"

#~ msgid "If the format is set to \"auto:foo\" and the pager is in use, format \"foo\" will be the used for the date format. Otherwise \"default\" will be used."
#~ msgstr "如果格式被设置为 \"auto:foo\"，并且正在使用呼叫器，那么格式 \"foo \"将被用于日期格式。否则将使用 \"默认\"。"

#, ignore-same, no-wrap
#~ msgid "log.follow"
#~ msgstr "log.follow"

#, placeholders:'`--follow`':'`--follow`'
#~ msgid "If `true`, `git log` will act as if the `--follow` option was used when a single <path> is given.  This has the same limitations as `--follow`, i.e. it cannot be used to follow multiple files and does not work well on non-linear history."
#~ msgstr "如果为`true`，`git log`将像使用`--follow`选项一样，当给出一个<路径>时。 这与`--follow`有相同的限制，即它不能用于跟踪多个文件，并且在非线性历史上不能很好地工作。"

#, ignore-same, no-wrap
#~ msgid "log.showRoot"
#~ msgstr "log.showRoot"

#~ msgid "If `false`, `git log` and related commands will not treat the initial commit as a big creation event.  Any root commits in `git log -p` output would be shown without a diff attached.  The default is `true`."
#~ msgstr "如果为`false`，`git log`和相关命令将不把初始提交作为一个大的创建事件。 `git log -p`输出中的任何根提交都会被显示出来，而不附加差异。 默认是`true`。"

#, ignore-same, no-wrap
#~ msgid "log.showSignature"
#~ msgstr "log.showSignature"

#, placeholders:'`--show-signature`'
#~ msgid "If `true`, `git log` and related commands will act as if the `--show-signature` option was passed to them."
#~ msgstr "如果 \"true\"，\"git log \"和相关命令将像\"--显示签名 \"选项一样行事。"

#, fuzzy, no-wrap
#~ msgid "mailmap.*"
#~ msgstr "邮件地图.*"

#, fuzzy, placeholders:'linkgit:git-shortlog[1]'
#~ msgid "See linkgit:git-shortlog[1]."
#~ msgstr "请查看 linkgit:git-shortlog[1]."

#, no-wrap, placeholders:'notes.displayRef'
#~ msgid "notes.displayRef"
#~ msgstr "笔记.displayRef"

#, placeholders:'core.notesRef':'GIT_NOTES_REF':'linkgit:git-notes[1]'
#~ msgid "Which refs, in addition to the default set by `core.notesRef` or `GIT_NOTES_REF`, to read notes from when showing commit messages with the `log` family of commands.  See linkgit:git-notes[1]."
#~ msgstr "除了由`core.notesRef`或`GIT_NOTES_REF`设置的默认值外，在用`log`系列命令显示提交信息时，还要从哪些参考文献中读取注释。 参见linkgit:git-notes[1]。"

#~ msgid "May be an unabbreviated ref name or a glob and may be specified multiple times.  A warning will be issued for refs that do not exist, but a glob that does not match any refs is silently ignored."
#~ msgstr "可以是一个非缩写的 ref 名称或一个 glob，并且可以多次指定。 对于不存在的参考文献将发出警告，但不匹配任何参考文献的glob将被沉默地忽略。"

#, placeholders:'`--no-notes`':'GIT_NOTES_DISPLAY_REF':'`--notes='
#~ msgid "This setting can be disabled by the `--no-notes` option, overridden by the `GIT_NOTES_DISPLAY_REF` environment variable, and overridden by the `--notes=<ref>` option."
#~ msgstr "这个设置可以由`--no-notes`选项禁用，由`GIT_NOTES_DISPLAY_REF`环境变量覆盖，并由`--notes=<ref>`选项覆盖。"

#, no-wrap, placeholders:'notes.mergeStrategy'
#~ msgid "notes.mergeStrategy"
#~ msgstr "笔记.合并策略"

#, placeholders:'cat_sort_uniq'
#~ msgid "Which merge strategy to choose by default when resolving notes conflicts.  Must be one of `manual`, `ours`, `theirs`, `union`, or `cat_sort_uniq`.  Defaults to `manual`.  See \"NOTES MERGE STRATEGIES\" section above for more information on each strategy."
#~ msgstr "在解决笔记冲突时，默认选择哪种合并策略。 必须是`manual`, `ours`, `theirs`, `union`, 或 `cat_sort_uniq`之一。 默认为 \"手动\"。 关于每种策略的更多信息，请看上面的 \"Notes MERGE STRATEGIES \"部分。"

#, placeholders:'`--strategy`'
#~ msgid "This setting can be overridden by passing the `--strategy` option."
#~ msgstr "这个设置可以通过传递`--策略`选项来覆盖。"

#, no-wrap
#~ msgid "notes.<name>.mergeStrategy"
#~ msgstr "笔记.<名称>.合并策略"

#, placeholders:'notes.mergeStrategy'
#~ msgid "Which merge strategy to choose when doing a notes merge into refs/notes/<name>.  This overrides the more general \"notes.mergeStrategy\".  See the \"NOTES MERGE STRATEGIES\" section above for more information on each available strategy."
#~ msgstr "当进行笔记合并到 refs/notes/<name>时，选择哪种合并策略。 这覆盖了更一般的 \"notes.mergeStrategy\"。 关于每个可用策略的更多信息，请参见上面的 \"笔记合并策略 \"部分。"

#, placeholders:'core.notesRef':'GIT_NOTES_REF':'GIT_NOTES_DISPLAY_REF':'linkgit:git-log[1]'
#~ msgid "Which ref (or refs, if a glob or specified more than once), in addition to the default set by `core.notesRef` or `GIT_NOTES_REF`, to read notes from when showing commit messages with the 'git log' family of commands.  This setting can be overridden on the command line or by the `GIT_NOTES_DISPLAY_REF` environment variable.  See linkgit:git-log[1]."
#~ msgstr "除了`core.notesRef`或`GIT_NOTES_REF`设置的默认值外，在用'git log'系列命令显示提交信息时，还要从哪个参考文献（或参考文献，如果一个glob或指定多个）中读取。 这个设置可以在命令行或`GIT_NOTES_DISPLAY_REF`环境变量中被覆盖。 参见 linkgit:git-log[1]。"

#, no-wrap, placeholders:'notes.rewrite'
#~ msgid "notes.rewrite.<command>"
#~ msgstr "笔记.重写.<命令>"

#, placeholders:'notes.rewriteRef'
#~ msgid "When rewriting commits with <command> (currently `amend` or `rebase`), if this variable is `false`, git will not copy notes from the original to the rewritten commit.  Defaults to `true`.  See also \"`notes.rewriteRef`\" below."
#~ msgstr "当用<command>重写提交时（目前是`amend`或`rebase`），如果这个变量是`false`，git将不会从原始提交中复制注释到重写的提交中。 默认为`true`。 参见下面的\"`notes.rewriteRef`\"。"

#, placeholders:'GIT_NOTES_REWRITE_REF'
#~ msgid "This setting can be overridden by the `GIT_NOTES_REWRITE_REF` environment variable."
#~ msgstr "这个设置可以被`GIT_NOTES_REWRITE_REF`环境变量所覆盖。"

#, no-wrap, placeholders:'notes.rewriteMode'
#~ msgid "notes.rewriteMode"
#~ msgstr "笔记.重写模式"

#, placeholders:'cat_sort_uniq'
#~ msgid "When copying notes during a rewrite, what to do if the target commit already has a note.  Must be one of `overwrite`, `concatenate`, `cat_sort_uniq`, or `ignore`.  Defaults to `concatenate`."
#~ msgstr "在重写过程中复制注释时，如果目标提交已经有一个注释，该如何处理。 必须是`overwrite`, `concatenate`, `cat_sort_uniq`, 或 `ignore`之一。 默认为 \"concatenate\"。"

#, placeholders:'GIT_NOTES_REWRITE_MODE'
#~ msgid "This setting can be overridden with the `GIT_NOTES_REWRITE_MODE` environment variable."
#~ msgstr "这个设置可以用`GIT_NOTES_REWRITE_MODE`环境变量覆盖。"

#, no-wrap, placeholders:'notes.rewriteRef'
#~ msgid "notes.rewriteRef"
#~ msgstr "笔记.重写参考"

#~ msgid "When copying notes during a rewrite, specifies the (fully qualified) ref whose notes should be copied.  May be a glob, in which case notes in all matching refs will be copied.  You may also specify this configuration several times."
#~ msgstr "当在重写过程中复制注释时，指定应该被复制的（完全合格的）注释。 可以是一个glob，在这种情况下，所有匹配的参考文献中的注释都会被复制。 你也可以多次指定这个配置。"

#~ msgid "Does not have a default value; you must configure this variable to enable note rewriting."
#~ msgstr "没有默认值；你必须配置这个变量以启用注释重写。"

#, placeholders:'GIT_NOTES_REWRITE_REF'
#~ msgid "Can be overridden with the `GIT_NOTES_REWRITE_REF` environment variable."
#~ msgstr "可以用`GIT_NOTES_REWRITE_REF`环境变量覆盖。"

#, ignore-same, no-wrap
#~ msgid "sendemail.aliasesFile"
#~ msgstr "sendemail.aliasesFile"

#, ignore-same, no-wrap
#~ msgid "sendemail.aliasFileType"
#~ msgstr "sendemail.aliasFileType"

#, fuzzy, no-wrap
#~ msgid "sendmail"
#~ msgstr "sendmail"

#, ignore-same, no-wrap
#~ msgid "sendemail.multiEdit"
#~ msgstr "sendemail.multiEdit"

#, ignore-same, no-wrap
#~ msgid "sendemail.confirm"
#~ msgstr "sendemail.confirm"

#~ msgid "Limit the displayed commits to those directly on the ancestry chain between the ``from'' and ``to'' commits in the given commit range. I.e. only display commits that are ancestor of the ``to'' commit and descendants of the ``from'' commit."
#~ msgstr "将显示的提交限制在给定提交范围内 \"from \"和 \"to \"提交之间的直接祖先链上。也就是说，只显示 \"to \"提交的祖先和 \"from \"提交的后代的提交。"

#, fuzzy, placeholders:'`--track=direct`':'branch.autoSetupMerge':'`--no-track`'
#~ msgid "`--track=direct` is the default when the start point is a remote-tracking branch.  Set the branch.autoSetupMerge configuration variable to `false` if you want `git switch`, `git checkout` and `git branch` to always behave as if `--no-track` were given. Set it to `always` if you want this behavior when the start-point is either a local or remote-tracking branch. Set it to `inherit` if you want to copy the tracking configuration from the branch point."
#~ msgstr "当起点是一个远程跟踪的分支时，这种行为是默认的。 如果你想让 \"git switch\"、\"git checkout \"和 \"git branch \"总是表现得像\"--no-track \"一样，就把 branch.autoSetupMerge 配置变量设为 \"false\"。如果你想在起始点是本地或远程跟踪的分支时有这种行为，则将其设置为`always`。"

#, fuzzy, no-wrap
#~ msgid "        <mode> SP <type> SP <object> TAB <file>\n"
#~ msgstr "        <mode> SP <type> SP <object> TAB <file>\n"

#, fuzzy, no-wrap
#~ msgid "        <mode> SP <type> SP <object> SP <object size> TAB <file>\n"
#~ msgstr "        <mode> SP <type> SP <object> SP <object size> TAB <file>\n"

#, ignore-same, no-wrap
#~ msgid "--no-quiet"
#~ msgstr "--no-quiet"

#, placeholders:'reset.quiet':'`--quiet`':'`--no-quiet`'
#~ msgid "Be quiet, only report errors. The default behavior is set by the `reset.quiet` config option. `--quiet` and `--no-quiet` will override the default behavior."
#~ msgstr "保持安静，只报告错误。默认行为是由`reset.quiet`配置选项设置的。`--quiet`和`--no-quiet`将覆盖默认行为。"

#, ignore-same, no-wrap
#~ msgid "--track"
#~ msgstr "--track"

#, fuzzy, no-wrap, placeholders:'--orphan':'new_branch'
#~ msgid "--orphan <new_branch>"
#~ msgstr "--orphan <new_branch>"

#, placeholders:'linkgit:githooks[5]'
#~ msgid "This option bypasses the pre-commit and commit-msg hooks.  See also linkgit:githooks[5]."
#~ msgstr "这个选项绕过了pre-commit和commit-msg钩子。 参见 linkgit:githooks[5]。"

#, ignore-same, no-wrap
#~ msgid "--shared[=(false|true|umask|group|all|world|everybody|0xxx)]"
#~ msgstr "--shared[=(false|true|umask|group|all|world|everybody|0xxx)]"

#, fuzzy, no-wrap
#~ msgid "'0xxx'"
#~ msgstr "'0xxx'"

#, fuzzy, no-wrap
#~ msgid "<url>"
#~ msgstr "<url>"

#, ignore-same, no-wrap
#~ msgid "--unsorted-input"
#~ msgstr "--unsorted-input"

#, ignore-same, no-wrap
#~ msgid "-9"
#~ msgstr "-9"

#, fuzzy
#~ msgid "The 'git bundle' command packages objects and references in an archive at the originating machine, which can then be imported into another repository using 'git fetch', 'git pull', or 'git clone', after moving the archive by some means (e.g., by sneakernet)."
#~ msgstr "The 'git bundle' command packages objects and references in an archive at the originating machine, which can then be imported into another repository using 'git fetch', 'git pull', or 'git clone', after moving the archive by some means (e.g., by sneakernet)."

#, fuzzy, no-wrap, placeholders:'--nl='
#~ msgid "--nl=<N>"
#~ msgstr "--nl=<N>"

#, fuzzy, no-wrap, placeholders:'--exclude-per-directory='
#~ msgid "--exclude-per-directory=<gitignore>"
#~ msgstr "--exclude-per-directory=<gitignore>"

#, ignore-same, no-wrap
#~ msgid "--preserve-merges"
#~ msgstr "--preserve-merges"

#, fuzzy, placeholders:'`--rebase-merges`'
#~ msgid "[DEPRECATED: use `--rebase-merges` instead] Recreate merge commits instead of flattening the history by replaying commits a merge commit introduces. Merge conflict resolutions or manual amendments to merge commits are not preserved."
#~ msgstr "[DEPRECATED: use `--rebase-merges` instead] Recreate merge commits instead of flattening the history by replaying commits a merge commit introduces. Merge conflict resolutions or manual amendments to merge commits are not preserved."

#, fuzzy, placeholders:'--preserve-merges':'--rebase-merges'
#~ msgid "--preserve-merges and --rebase-merges"
#~ msgstr "--preserve-merges and --rebase-merges"

#, fuzzy, placeholders:'--preserve-merges':'--empty='
#~ msgid "--preserve-merges and --empty="
#~ msgstr "--preserve-merges and --empty="

#, fuzzy, placeholders:'--preserve-merges':'--ignore-whitespace'
#~ msgid "--preserve-merges and --ignore-whitespace"
#~ msgstr "--preserve-merges and --ignore-whitespace"

#, fuzzy, placeholders:'--preserve-merges':'--committer-date-is-author-date'
#~ msgid "--preserve-merges and --committer-date-is-author-date"
#~ msgstr "--preserve-merges and --committer-date-is-author-date"

#, fuzzy, placeholders:'--preserve-merges':'--ignore-date'
#~ msgid "--preserve-merges and --ignore-date"
#~ msgstr "--preserve-merges and --ignore-date"

#, fuzzy, no-wrap, placeholders:'---':'---':'---':'---'
#~ msgid "1 --- 2 --- 3 --- 4 --- 5\n"
#~ msgstr "1 --- 2 --- 3 --- 4 --- 5\n"

#, fuzzy, no-wrap, placeholders:'---':'---':'---':'---'
#~ msgid "1 --- 2 --- 4 --- 3 --- 5\n"
#~ msgstr "1 --- 2 --- 4 --- 3 --- 5\n"

#~ msgid "'C' = copied"
#~ msgstr "'C'=复制的"

#, fuzzy, no-wrap, placeholders:'--preserve-merges'
#~ msgid "--preserve-merges (DEPRECATED)"
#~ msgstr "--preserve-merges (DEPRECATED)"

#, ignore-same, no-wrap
#~ msgid "--advertise-refs"
#~ msgstr "--advertise-refs"

#, placeholders:'`-M`':'`-C`'
#~ msgid "The `-M` and `-C` options require O(n^2) processing time where n is the number of potential rename/copy targets.  This option prevents rename/copy detection from running if the number of rename/copy targets exceeds the specified number."
#~ msgstr "`-M` 和 `-C` 选项需要 O(n^2) 的处理时间，其中 n 是潜在的重命名/复制目标数量。如果重命名/复制目标的数量超过了指定的数量，该选项可防止重命名/复制检测运行。"

#, ignore-ellipsis, no-wrap
#~ msgid "'git diff' [<options>] <commit> [--] [<path>...]"
#~ msgstr "'git diff' [<options>] <commit> [--] [<path>...] 。"

#, fuzzy, no-wrap, placeholders:'--no-diff-merges'
#~ msgid "--no-diff-merges:"
#~ msgstr "--no-diff-merges"

#, fuzzy, no-wrap
#~ msgid "-m:"
#~ msgstr "-m"

#, fuzzy, no-wrap
#~ msgid "-c:"
#~ msgstr "-c"

#, fuzzy, no-wrap, placeholders:'--cc'
#~ msgid "--cc:"
#~ msgstr "--cc"

#, fuzzy
#~ msgid "Show only names of changed files."
#~ msgstr "仅显示已更改文件的名称。"

#, fuzzy, no-wrap
#~ msgid "show [<diff-options>] [<stash>]"
#~ msgstr "'git show' [<options>] [<object>...]\n"

#, ignore-same, no-wrap
#~ msgid "linkgit:git-parse-remote[1]"
#~ msgstr "linkgit:git-parse-remote[1]"

#, ignore-same
#~ msgid "git-parse-remote(1)"
#~ msgstr "git-parse-remote(1)"

#, fuzzy, placeholders:'git-parse-remote'
#~ msgid "git-parse-remote - Routines to help parsing remote repository access parameters"
#~ msgstr "git-parse-remote - Routines to help parsing remote repository access parameters"

#, fuzzy, placeholders:'--exec-path':'git-parse-remote'
#~ msgid "'. \"$(git --exec-path)/git-parse-remote\"'\n"
#~ msgstr "'. \"$(git --exec-path)/git-parse-remote\"'\n"

#, fuzzy
#~ msgid ""
#~ "Context\n"
#~ "~~~~~~~\n"
#~ msgstr "上下文"

#, fuzzy
#~ msgid "NOTES\n"
#~ msgstr "注释"

#, fuzzy
#~ msgid "contents of <old|new>,\n"
#~ msgstr "--contents <file>"

#, ignore-same
#~ msgid "linkgit:git-shortlog[1]."
#~ msgstr "linkgit:git-shortlog[1]."

#, fuzzy
#~ msgid "similar to '%>(<N>)', '%>|(<N>)'"
#~ msgstr "'%>(<N>)', '%>|(<N>)'"

#, fuzzy
#~ msgid "similar to '%<(<N>)', '%<|(<N>)'"
#~ msgstr "'%><(<N>)', '%><|(<N>)'"

#, fuzzy, placeholders:'linkgit:git-blame[1]'
#~ msgid "or linkgit:git-blame[1])"
#~ msgstr "linkgit:git-blame[1]"

#, fuzzy
#~ msgid "to sign a signed commit"
#~ msgstr "--origin <commit>"

#, fuzzy, placeholders:'git show-index'
#~ msgid "'git show-index'\n"
#~ msgstr "git-show-index(1)"

#, ignore-same
#~ msgid "`GIT_REDACT_COOKIES`"
#~ msgstr "`GIT_REDACT_COOKIES`"

#, fuzzy, placeholders:'linkgit:git-commit-tree[1]'
#~ msgid "see linkgit:git-commit-tree[1]"
#~ msgstr "linkgit:git-commit-tree[1]"
