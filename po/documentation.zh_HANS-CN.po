# Simplified Chinese translations for Git Manual Pages.
# Copyright (C) 2019 Free Software Foundation, Inc.
# This file is distributed under the same license as the Git package.
# Matthias Aßhauer <mha1993@live.de>, 2019.
msgid ""
msgstr ""
"Project-Id-Version: git documentation\n"
"Report-Msgid-Bugs-To: jn.avila@free.fr\n"
"POT-Creation-Date: 2023-08-05 19:25+0200\n"
"PO-Revision-Date: 2023-08-03 19:53+0000\n"
"Last-Translator: 秃头灯笼鱼 <ttdlyu@163.com>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_HANS-CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Weblate 5.0-dev\n"

#. type: Labeled list
#: en/blame-options.txt:1 en/diff-options.txt:772 en/git-instaweb.txt:45 en/git-mailinfo.txt:49 en/git-mailsplit.txt:35 en/git-repack.txt:146 en/git-status.txt:31
#, ignore-same, no-wrap, priority:280
msgid "-b"
msgstr "-b"

#. type: Plain text
#: en/blame-options.txt:4
#, priority:100
msgid "Show blank SHA-1 for boundary commits.  This can also be controlled via the `blame.blankBoundary` config option."
msgstr "为边界提交显示空白的 SHA-1。  这也可以通过 `blame.blankBoundary` 配置选项来控制。"

#. type: Labeled list
#: en/blame-options.txt:5 en/git-diff-tree.txt:42 en/git-format-patch.txt:395 en/git-fsck.txt:38 en/git-rebase.txt:583
#, ignore-same, no-wrap, priority:100
msgid "--root"
msgstr "--root"

#. type: Plain text
#: en/blame-options.txt:8
#, priority:100
msgid "Do not treat root commits as boundaries.  This can also be controlled via the `blame.showRoot` config option."
msgstr "不把根提交当作边界。  这也可以通过 `blame.showRoot` 配置选项来控制。"

#. type: Labeled list
#: en/blame-options.txt:9
#, ignore-same, no-wrap, priority:100
msgid "--show-stats"
msgstr "--show-stats"

#. type: Plain text
#: en/blame-options.txt:11
#, priority:100
msgid "Include additional statistics at the end of blame output."
msgstr "在历史追溯输出的结尾处包括额外的统计数据。"

#. type: Labeled list
#: en/blame-options.txt:12
#, no-wrap, priority:100
msgid "-L <start>,<end>"
msgstr "-L <start>,<end>"

#. type: Labeled list
#: en/blame-options.txt:13
#, no-wrap, priority:100
msgid "-L :<funcname>"
msgstr "-L :<funcname>"

#. type: Plain text
#: en/blame-options.txt:17
#, priority:100
msgid "Annotate only the line range given by '<start>,<end>', or by the function name regex '<funcname>'.  May be specified multiple times. Overlapping ranges are allowed."
msgstr "仅注释由'<start>，<end>'或功能名称正则表达式'<funcname>'给出的行范围。 可以指定多次。 允许重叠范围。"

#. type: Plain text
#: en/blame-options.txt:20
#, priority:100
msgid "'<start>' and '<end>' are optional. `-L <start>` or `-L <start>,` spans from '<start>' to end of file. `-L ,<end>` spans from start of file to '<end>'."
msgstr "'<start>' 和 '<end>' 是可选的 `-L <start>` 或 `-L <start>,` 范围从 '<start>' 到文件末尾。 `-L ,<end>` 从文件开始到 '<end>'."

#. type: Labeled list
#: en/blame-options.txt:23 en/git-archive.txt:45 en/git-branch.txt:181 en/git-checkout.txt:203 en/git-clone.txt:45 en/git-config.txt:181 en/git-grep.txt:156 en/git-instaweb.txt:23 en/git-ls-tree.txt:51 en/git-repack.txt:83 en/git-svn.txt:244 en/git-tag.txt:99 en/git-var.txt:21
#, ignore-same, no-wrap, priority:300
msgid "-l"
msgstr "-l"

#. type: Plain text
#: en/blame-options.txt:25
#, priority:100
msgid "Show long rev (Default: off)."
msgstr "显示长转（默认值：关闭）。"

#. type: Labeled list
#: en/blame-options.txt:26 en/diff-options.txt:156 en/fetch-options.txt:194 en/git-branch.txt:217 en/git-cat-file.txt:42 en/git-checkout.txt:160 en/git-diff-tree.txt:39 en/git-ls-files.txt:140 en/git-ls-remote.txt:26 en/git-ls-tree.txt:47 en/git-svn.txt:312 en/git-switch.txt:153
#, ignore-same, no-wrap, priority:280
msgid "-t"
msgstr "-t"

#. type: Plain text
#: en/blame-options.txt:28
#, priority:100
msgid "Show raw timestamp (Default: off)."
msgstr "显示原始时间戳（默认值：关闭）。"

#. type: Labeled list
#: en/blame-options.txt:29
#, fuzzy, no-wrap, priority:100
msgid "-S <revs-file>"
msgstr "-S <revs-file>"

#. type: Plain text
#: en/blame-options.txt:31
#, priority:100
msgid "Use revisions from revs-file instead of calling linkgit:git-rev-list[1]."
msgstr "使用revs-file中的修订，而不是调用 linkgit:git-rev-list[1]。"

#. type: Labeled list
#: en/blame-options.txt:32
#, no-wrap, priority:100
msgid "--reverse <rev>..<rev>"
msgstr "--reverse <rev>..<rev>"

#. type: Plain text
#: en/blame-options.txt:39
#, priority:100
msgid "Walk history forward instead of backward. Instead of showing the revision in which a line appeared, this shows the last revision in which a line has existed. This requires a range of revision like START..END where the path to blame exists in START.  `git blame --reverse START` is taken as `git blame --reverse START..HEAD` for convenience."
msgstr "向前调用历史记录，而不向后调用历史记录。 与其显示行所在的修订，不显示行所在的最后一个修订。 这就需要进行一系列修订，例如START..END，其中的归咎路径在START中。 为方便起见，将git blame --reverse START。当作git blame --reverse START..HEAD。"

#. type: Labeled list
#: en/blame-options.txt:40 en/git-bisect.txt:368 en/git-describe.txt:122 en/rev-list-options.txt:129
#, ignore-same, no-wrap, priority:260
msgid "--first-parent"
msgstr "--first-parent"

#. type: Plain text
#: en/blame-options.txt:45
#, priority:100
msgid "Follow only the first parent commit upon seeing a merge commit. This option can be used to determine when a line was introduced to a particular integration branch, rather than when it was introduced to the history overall."
msgstr "在看到合并提交时只关注第一个父提交。这个选项可以用来确定某一行何时被引入某个特定的集成分支，而不是何时被引入整个历史中。"

#. type: Labeled list
#: en/blame-options.txt:46 en/diff-options.txt:16 en/diff-options.txt:22 en/fetch-options.txt:135 en/git-add.txt:96 en/git-cat-file.txt:57 en/git-checkout.txt:273 en/git-commit.txt:73 en/git-cvsexportcommit.txt:41 en/git-grep.txt:209 en/git-instaweb.txt:41 en/git-merge-file.txt:63 en/git-request-pull.txt:29 en/git-restore.txt:48 en/git-stash.txt:196 en/git-svn.txt:535 en/git-svn.txt:679 en/git.txt:128
#, ignore-same, no-wrap, priority:300
msgid "-p"
msgstr "-p"

#. type: Labeled list
#: en/blame-options.txt:47 en/fetch-options.txt:81 en/git-commit.txt:149 en/git-push.txt:177 en/git-worktree.txt:239
#, ignore-same, no-wrap, priority:280
msgid "--porcelain"
msgstr "--porcelain"

#. type: Plain text
#: en/blame-options.txt:49
#, fuzzy, priority:100
msgid "Show in a format designed for machine consumption."
msgstr "以专为机器消费而设计的格式展示。"

#. type: Labeled list
#: en/blame-options.txt:50
#, ignore-same, no-wrap, priority:100
msgid "--line-porcelain"
msgstr "--line-porcelain"

#. type: Plain text
#: en/blame-options.txt:54
#, priority:100
msgid "Show the porcelain format, but output commit information for each line, not just the first time a commit is referenced.  Implies --porcelain."
msgstr "显示上层命令格式，但输出每一行的提交信息，而不仅仅是第一次引用提交时的信息。 意味着 --porcelain。"

#. type: Labeled list
#: en/blame-options.txt:55 en/git-pack-objects.txt:178 en/git-svn.txt:373
#, ignore-same, no-wrap, priority:100
msgid "--incremental"
msgstr "--incremental"

#. type: Plain text
#: en/blame-options.txt:58
#, fuzzy, priority:100
msgid "Show the result incrementally in a format designed for machine consumption."
msgstr "以一种为机器消费设计的格式逐步显示结果。"

#. type: Labeled list
#: en/blame-options.txt:59 en/git-mailinfo.txt:64 en/pretty-options.txt:35
#, fuzzy, no-wrap, priority:260
msgid "--encoding=<encoding>"
msgstr "--encoding=<encoding>"

#. type: Plain text
#: en/blame-options.txt:65
#, priority:100
msgid "Specifies the encoding used to output author names and commit summaries. Setting it to `none` makes blame output unconverted data. For more information see the discussion about encoding in the linkgit:git-log[1] manual page."
msgstr "指定用于输出作者姓名和提交摘要的编码。设置为 `none` 会使历史追溯输出未转换的数据。更多信息见 linkgit:git-log[1] 手册页中关于编码的讨论。"

#. type: Labeled list
#: en/blame-options.txt:66
#, fuzzy, no-wrap, priority:100
msgid "--contents <file>"
msgstr "--contents <file>"

#. type: Plain text
#: en/blame-options.txt:70
#, priority:100
msgid "Annotate using the contents from the named file, starting from <rev> if it is specified, and HEAD otherwise. You may specify '-' to make the command read from the standard input for the file contents."
msgstr "使用指定文件中的内容进行注释，如果指定了 <rev>，则从 <rev> 开始，否则从 HEAD 开始。你可以指定 '-' 来使命令从标准输入中读取文件内容。"

#. type: Labeled list
#: en/blame-options.txt:71
#, no-wrap, priority:100
msgid "--date <format>"
msgstr "--date <格式>"

#. type: Plain text
#: en/blame-options.txt:77
#, priority:100
msgid "Specifies the format used to output dates. If --date is not provided, the value of the blame.date config variable is used. If the blame.date config variable is also not set, the iso format is used. For supported values, see the discussion of the --date option at linkgit:git-log[1]."
msgstr "指定用于输出日期的格式。如果没有提供 --date，则使用 blame.date 配置变量的值。如果 blame.date 配置变量也没有设置，则使用 iso 格式。关于支持的值，请参见 linkgit:git-log[1] 中关于 --date 选项的讨论。"

#. type: Labeled list
#: en/blame-options.txt:78 en/git-fsck.txt:100
#, ignore-same, no-wrap, priority:100
msgid "--[no-]progress"
msgstr "--[no-]progress"

#. type: Plain text
#: en/blame-options.txt:84
#, priority:100
msgid "Progress status is reported on the standard error stream by default when it is attached to a terminal. This flag enables progress reporting even if not attached to a terminal. Can't use `--progress` together with `--porcelain` or `--incremental`."
msgstr "当它连接到一个终端时，默认情况下进度状态会在标准错误流中报告。这个标志可以使进度报告即使没有连接到终端。`--porcelain`或`--incremental` 不能与 `--progress` 一起使用。"

#. type: Labeled list
#: en/blame-options.txt:85
#, fuzzy, no-wrap, priority:100
msgid "-M[<num>]"
msgstr "-M[<num>]"

#. type: Plain text
#: en/blame-options.txt:95
#, priority:100
msgid "Detect moved or copied lines within a file. When a commit moves or copies a block of lines (e.g. the original file has A and then B, and the commit changes it to B and then A), the traditional 'blame' algorithm notices only half of the movement and typically blames the lines that were moved up (i.e. B) to the parent and assigns blame to the lines that were moved down (i.e. A) to the child commit.  With this option, both groups of lines are blamed on the parent by running extra passes of inspection."
msgstr "检测文件中移动或复制的行。当一次提交移动或复制一个行块时（例如，原始文件有 A，然后是 B，而提交将其改为 B，然后是 A），传统的 'blame' 算法只注意到一半的移动，通常将向上移动的行（即 B ）归咎于父代，而将向下移动的行（即 A ）归咎于子代提交。 有了这个选项，通过运行额外的检查，两组行都会被归咎于父代。"

#. type: Plain text
#: en/blame-options.txt:100
#, priority:100
msgid "<num> is optional but it is the lower bound on the number of alphanumeric characters that Git must detect as moving/copying within a file for it to associate those lines with the parent commit. The default value is 20."
msgstr "<num> 是可选的，但它是 Git 必须检测到的在文件中移动或复制的字母数字字符的数量的下限，以便它将这些行与父提交相关联。默认值是20。"

#. type: Labeled list
#: en/blame-options.txt:101
#, fuzzy, no-wrap, priority:100
msgid "-C[<num>]"
msgstr "-C[<num>]"

#. type: Plain text
#: en/blame-options.txt:110
#, priority:100
msgid "In addition to `-M`, detect lines moved or copied from other files that were modified in the same commit.  This is useful when you reorganize your program and move code around across files.  When this option is given twice, the command additionally looks for copies from other files in the commit that creates the file. When this option is given three times, the command additionally looks for copies from other files in any commit."
msgstr "除了`-M`之外，还可以检测在同一提交中被修改的其他文件中移动或复制的行。 这在你重新组织程序并在不同文件间移动代码时很有用。 当这个选项被赋予两次时，命令会在创建文件的提交中额外寻找其他文件的拷贝。当这个选项出现三次时，命令会在任何一次提交中额外寻找其他文件的副本。"

#. type: Plain text
#: en/blame-options.txt:117
#, priority:100
msgid "<num> is optional but it is the lower bound on the number of alphanumeric characters that Git must detect as moving/copying between files for it to associate those lines with the parent commit. And the default value is 40. If there are more than one `-C` options given, the <num> argument of the last `-C` will take effect."
msgstr "<num>是 可选的，但它是 Git 必须检测到的在文件之间移动或复制的字母数字字符的数量的下限，以便它将这些行与父提交关联起来。而默认值是 40。如果有一个以上的 `-C ` 选项，只有最后一个 `-C `的 <num> 参数起作用。"

#. type: Labeled list
#: en/blame-options.txt:118
#, fuzzy, no-wrap, priority:100
msgid "--ignore-rev <rev>"
msgstr "--ignore-rev <rev>"

#. type: Plain text
#: en/blame-options.txt:129
#, priority:100
msgid "Ignore changes made by the revision when assigning blame, as if the change never happened.  Lines that were changed or added by an ignored commit will be blamed on the previous commit that changed that line or nearby lines.  This option may be specified multiple times to ignore more than one revision.  If the `blame.markIgnoredLines` config option is set, then lines that were changed by an ignored commit and attributed to another commit will be marked with a `?` in the blame output.  If the `blame.markUnblamableLines` config option is set, then those lines touched by an ignored commit that we could not attribute to another revision are marked with a '*'."
msgstr "在分配责任时忽略修订版所做的修改，就像该修改从未发生过一样。 被忽略的提交所改变或增加的行将被归咎于改变该行或附近行的前一个提交。 这个选项可以多次指定，以忽略一个以上的修订。 如果设置了 `blame.markIgnoredLines` 配置选项，那么被忽略的提交所改变的行将被归咎于另一个提交，在归咎输出中会标上`?` 如果设置了 `blame.markUnblamableLines` 配置选项，那么那些被忽略的提交所触及的、我们无法归因于另一个修订版的行将被标记为 '*'。"

#. type: Labeled list
#: en/blame-options.txt:130
#, no-wrap, priority:100
msgid "--ignore-revs-file <file>"
msgstr "--ignore-revs-file <文件>"

#. type: Plain text
#: en/blame-options.txt:136
#, priority:100
msgid "Ignore revisions listed in `file`, which must be in the same format as an `fsck.skipList`.  This option may be repeated, and these files will be processed after any files specified with the `blame.ignoreRevsFile` config option.  An empty file name, `\"\"`, will clear the list of revs from previously processed files."
msgstr "忽略 `file` 中列出的修订，其格式必须与 `fsck.skipList` 相同。 这个选项可以重复使用，这些文件将在任何用 `blame.ignoreRevsFile` 配置选项指定的文件之后被处理。 一个空的文件名，`\"\"`，将清除以前处理的文件的 Revs 列表。"

#. type: Labeled list
#: en/blame-options.txt:137
#, ignore-same, no-wrap, priority:100
msgid "--color-lines"
msgstr "--color-lines"

#. type: Plain text
#: en/blame-options.txt:142
#, priority:100
msgid "Color line annotations in the default format differently if they come from the same commit as the preceding line. This makes it easier to distinguish code blocks introduced by different commits. The color defaults to cyan and can be adjusted using the `color.blame.repeatedLines` config option."
msgstr "在默认格式下，如果行注释与前一行来自同一提交，则颜色不同。这可以让我们更容易区分不同提交的代码块。颜色默认为青色，可以使用 `color. blame.repeatedLines` 配置选项进行调整。"

#. type: Labeled list
#: en/blame-options.txt:143
#, ignore-same, no-wrap, priority:100
msgid "--color-by-age"
msgstr "--color-by-age"

#. type: Plain text
#: en/blame-options.txt:147
#, priority:100
msgid "Color line annotations depending on the age of the line in the default format.  The `color.blame.highlightRecent` config option controls what color is used for each range of age."
msgstr "根据默认格式的行的阶段，给行的注释着色。 `color.blue.highlightRecent` 配置选项控制每个阶段范围使用什么颜色。"

#. type: Labeled list
#: en/blame-options.txt:148 en/git-archimport.txt:71 en/git-cvsimport.txt:184 en/git-cvsserver.txt:60 en/git-grep.txt:114 en/git-ls-remote.txt:24 en/git.txt:49
#, ignore-same, no-wrap, priority:100
msgid "-h"
msgstr "-h"

#. type: Plain text
#: en/blame-options.txt:149
#, priority:100
msgid "Show help message."
msgstr "显示帮助信息。"

#. type: Plain text
#: en/cmds-ancillaryinterrogators.txt:1 en/git-blame.txt:254
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-annotate[1]"
msgstr "linkgit:git-annotate[1]"

#. type: Plain text
#: en/cmds-ancillaryinterrogators.txt:3
#, priority:100
msgid "Annotate file lines with commit information."
msgstr "用提交信息来注释文件行。"

#. type: Plain text
#: en/cmds-ancillaryinterrogators.txt:4 en/git-annotate.txt:30
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-blame[1]"
msgstr "linkgit:git-blame[1]"

#. type: Plain text
#: en/cmds-ancillaryinterrogators.txt:6
#, priority:100
msgid "Show what revision and author last modified each line of a file."
msgstr "显示文件的每一行最后修改的版本和作者。"

#. type: Labeled list
#: en/cmds-ancillaryinterrogators.txt:7
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-bugreport[1]"
msgstr "linkgit:git-bugreport[1]"

#. type: Plain text
#: en/cmds-ancillaryinterrogators.txt:9
#, priority:100
msgid "Collect information for user to file a bug report."
msgstr "收集信息，以便用户提交错误报告。"

#. type: Labeled list
#: en/cmds-ancillaryinterrogators.txt:10
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-count-objects[1]"
msgstr "linkgit:git-count-objects[1]"

#. type: Plain text
#: en/cmds-ancillaryinterrogators.txt:12
#, priority:100
msgid "Count unpacked number of objects and their disk consumption."
msgstr "计数对象的解包数量和它们的磁盘消耗。"

#. type: Labeled list
#: en/cmds-ancillaryinterrogators.txt:13
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-diagnose[1]"
msgstr "linkgit:git-diagnose[1]"

#. type: Plain text
#: en/cmds-ancillaryinterrogators.txt:15
#, priority:100
msgid "Generate a zip archive of diagnostic information."
msgstr "生成一个诊断信息的压缩文件。"

#. type: Labeled list
#: en/cmds-ancillaryinterrogators.txt:16
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-difftool[1]"
msgstr "linkgit:git-difftool[1]"

#. type: Plain text
#: en/cmds-ancillaryinterrogators.txt:18
#, priority:100
msgid "Show changes using common diff tools."
msgstr "使用常见的差异工具显示变化。"

#. type: Labeled list
#: en/cmds-ancillaryinterrogators.txt:19
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-fsck[1]"
msgstr "linkgit:git-fsck[1]"

#. type: Plain text
#: en/cmds-ancillaryinterrogators.txt:21 en/git-fsck.txt:20
#, priority:100
msgid "Verifies the connectivity and validity of the objects in the database."
msgstr "验证数据库中的对象的连接性和有效性。"

#. type: Labeled list
#: en/cmds-ancillaryinterrogators.txt:22
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-help[1]"
msgstr "linkgit:git-help[1]"

#. type: Plain text
#: en/cmds-ancillaryinterrogators.txt:24
#, priority:100
msgid "Display help information about Git."
msgstr "显示有关Git的帮助信息。"

#. type: Labeled list
#: en/cmds-ancillaryinterrogators.txt:25
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-instaweb[1]"
msgstr "linkgit:git-instaweb[1]"

#. type: Plain text
#: en/cmds-ancillaryinterrogators.txt:27
#, priority:100
msgid "Instantly browse your working repository in gitweb."
msgstr "在gitweb中浏览您的工作存储库。"

#. type: Labeled list
#: en/cmds-ancillaryinterrogators.txt:28
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-merge-tree[1]"
msgstr "linkgit:git-merge-tree[1]"

#. type: Plain text
#: en/cmds-ancillaryinterrogators.txt:30
#, fuzzy, priority:100
msgid "Perform merge without touching index or working tree."
msgstr "git-merge-tree - Show three-way merge without touching index"

#. type: Labeled list
#: en/cmds-ancillaryinterrogators.txt:31
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-rerere[1]"
msgstr "linkgit:git-rerere[1]"

#. type: Plain text
#: en/cmds-ancillaryinterrogators.txt:33
#, priority:100
msgid "Reuse recorded resolution of conflicted merges."
msgstr "重新使用记录的冲突合并的解决方案。"

#. type: Labeled list
#: en/cmds-ancillaryinterrogators.txt:34
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-show-branch[1]"
msgstr "linkgit:git-show-branch[1]"

#. type: Plain text
#: en/cmds-ancillaryinterrogators.txt:36
#, priority:100
msgid "Show branches and their commits."
msgstr "显示分支和它们的提交。"

#. type: Labeled list
#: en/cmds-ancillaryinterrogators.txt:37
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-verify-commit[1]"
msgstr "linkgit:git-verify-commit[1]"

#. type: Plain text
#: en/cmds-ancillaryinterrogators.txt:39
#, priority:100
msgid "Check the GPG signature of commits."
msgstr "检查提交的GPG签名。"

#. type: Labeled list
#: en/cmds-ancillaryinterrogators.txt:40
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-verify-tag[1]"
msgstr "linkgit:git-verify-tag[1]"

#. type: Plain text
#: en/cmds-ancillaryinterrogators.txt:42
#, priority:100
msgid "Check the GPG signature of tags."
msgstr "检查tag的GPG签名。"

#. type: Labeled list
#: en/cmds-ancillaryinterrogators.txt:43
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-version[1]"
msgstr "linkgit:git-version[1]"

#. type: Plain text
#: en/cmds-ancillaryinterrogators.txt:45
#, fuzzy, priority:100
#| msgid "Display help information about Git."
msgid "Display version information about Git."
msgstr "显示有关Git的帮助信息。"

#. type: Labeled list
#: en/cmds-ancillaryinterrogators.txt:46
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-whatchanged[1]"
msgstr "linkgit:git-whatchanged[1]"

#. type: Plain text
#: en/cmds-ancillaryinterrogators.txt:48
#, priority:100
msgid "Show logs with difference each commit introduces."
msgstr "显示每次提交带来的差异的日志。"

#. type: Plain text
#: en/cmds-ancillaryinterrogators.txt:49 en/git-instaweb.txt:91
#, ignore-same, no-wrap, priority:100
msgid "linkgit:gitweb[1]"
msgstr "linkgit:gitweb[1]"

#. type: Plain text
#: en/cmds-ancillaryinterrogators.txt:51
#, fuzzy, priority:100
msgid "Git web interface (web frontend to Git repositories)."
msgstr "Git web interface (web frontend to Git repositories)."

#. type: Labeled list
#: en/cmds-ancillarymanipulators.txt:1 en/git-difftool.txt:135
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-config[1]"
msgstr "linkgit:git-config[1]"

#. type: Plain text
#: en/cmds-ancillarymanipulators.txt:3
#, priority:100
msgid "Get and set repository or global options."
msgstr "获取和设置存储库或全局选项。"

#. type: Plain text
#: en/cmds-ancillarymanipulators.txt:4 en/git-fast-import.txt:1577
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-fast-export[1]"
msgstr "linkgit:git-fast-export[1]"

#. type: Plain text
#: en/cmds-ancillarymanipulators.txt:6
#, priority:100
msgid "Git data exporter."
msgstr "Git 数据导出器。"

#. type: Plain text
#: en/cmds-ancillarymanipulators.txt:7 en/git-fast-export.txt:281
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-fast-import[1]"
msgstr "linkgit:git-fast-import[1]"

#. type: Plain text
#: en/cmds-ancillarymanipulators.txt:9
#, priority:100
msgid "Backend for fast Git data importers."
msgstr "快速 Git 数据导入器的后端。"

#. type: Labeled list
#: en/cmds-ancillarymanipulators.txt:10
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-filter-branch[1]"
msgstr "linkgit:git-filter-branch[1]"

#. type: Plain text
#: en/cmds-ancillarymanipulators.txt:12
#, priority:100
msgid "Rewrite branches."
msgstr "重写分支。"

#. type: Labeled list
#: en/cmds-ancillarymanipulators.txt:13 en/git-difftool.txt:132
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-mergetool[1]"
msgstr "linkgit:git-mergetool[1]"

#. type: Plain text
#: en/cmds-ancillarymanipulators.txt:15
#, priority:100
msgid "Run merge conflict resolution tools to resolve merge conflicts."
msgstr "运行合并冲突解决工具来解决合并冲突。"

#. type: Labeled list
#: en/cmds-ancillarymanipulators.txt:16
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-pack-refs[1]"
msgstr "linkgit:git-pack-refs[1]"

#. type: Plain text
#: en/cmds-ancillarymanipulators.txt:18
#, priority:100
msgid "Pack heads and tags for efficient repository access."
msgstr "包装头和标签用于有效的仓库访问。"

#. type: Labeled list
#: en/cmds-ancillarymanipulators.txt:19
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-prune[1]"
msgstr "linkgit:git-prune[1]"

#. type: Plain text
#: en/cmds-ancillarymanipulators.txt:21
#, priority:100
msgid "Prune all unreachable objects from the object database."
msgstr "从对象数据库中修剪所有不可达的对象。"

#. type: Labeled list
#: en/cmds-ancillarymanipulators.txt:22
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-reflog[1]"
msgstr "linkgit:git-reflog[1]"

#. type: Plain text
#: en/cmds-ancillarymanipulators.txt:24
#, priority:100
msgid "Manage reflog information."
msgstr "管理reflog信息。"

#. type: Labeled list
#: en/cmds-ancillarymanipulators.txt:25
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-remote[1]"
msgstr "linkgit:git-remote[1]"

#. type: Plain text
#: en/cmds-ancillarymanipulators.txt:27
#, priority:100
msgid "Manage set of tracked repositories."
msgstr "管理一组被跟踪的仓库。"

#. type: Labeled list
#: en/cmds-ancillarymanipulators.txt:28
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-repack[1]"
msgstr "linkgit:git-repack[1]"

#. type: Plain text
#: en/cmds-ancillarymanipulators.txt:30
#, priority:100
msgid "Pack unpacked objects in a repository."
msgstr "在存储库中打包未打包的对象。"

#. type: Labeled list
#: en/cmds-ancillarymanipulators.txt:31
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-replace[1]"
msgstr "linkgit:git-replace[1]"

#. type: Plain text
#: en/cmds-ancillarymanipulators.txt:33
#, priority:100
msgid "Create, list, delete refs to replace objects."
msgstr "创建、列出、删除替换对象的引用。"

#. type: Labeled list
#: en/cmds-foreignscminterface.txt:1
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-archimport[1]"
msgstr "linkgit:git-archimport[1]"

#. type: Plain text
#: en/cmds-foreignscminterface.txt:3
#, priority:100
msgid "Import a GNU Arch repository into Git."
msgstr "导入一个GNU Arch仓库到Git。"

#. type: Labeled list
#: en/cmds-foreignscminterface.txt:4
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-cvsexportcommit[1]"
msgstr "linkgit:git-cvsexportcommit[1]"

#. type: Plain text
#: en/cmds-foreignscminterface.txt:6
#, priority:100
msgid "Export a single commit to a CVS checkout."
msgstr "导出单次commit到CVS checkout。"

#. type: Labeled list
#: en/cmds-foreignscminterface.txt:7
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-cvsimport[1]"
msgstr "linkgit:git-cvsimport[1]"

#. type: Plain text
#: en/cmds-foreignscminterface.txt:9
#, priority:100
msgid "Salvage your data out of another SCM people love to hate."
msgstr "把你的数据从另一个人们爱恨交加的 SCM 中解救出来。"

#. type: Labeled list
#: en/cmds-foreignscminterface.txt:10
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-cvsserver[1]"
msgstr "linkgit:git-cvsserver[1]"

#. type: Plain text
#: en/cmds-foreignscminterface.txt:12
#, priority:100
msgid "A CVS server emulator for Git."
msgstr "用于Git的CVS服务器模拟器。"

#. type: Labeled list
#: en/cmds-foreignscminterface.txt:13
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-imap-send[1]"
msgstr "linkgit:git-imap-send[1]"

#. type: Plain text
#: en/cmds-foreignscminterface.txt:15
#, fuzzy, priority:100
msgid "Send a collection of patches from stdin to an IMAP folder."
msgstr "IMAP"

#. type: Labeled list
#: en/cmds-foreignscminterface.txt:16
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-p4[1]"
msgstr "linkgit:git-p4[1]"

#. type: Plain text
#: en/cmds-foreignscminterface.txt:18
#, priority:100
msgid "Import from and submit to Perforce repositories."
msgstr "从 Perforce 存储库导入和提交。"

#. type: Labeled list
#: en/cmds-foreignscminterface.txt:19
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-quiltimport[1]"
msgstr "linkgit:git-quiltimport[1]"

#. type: Plain text
#: en/cmds-foreignscminterface.txt:21
#, priority:100
msgid "Applies a quilt patchset onto the current branch."
msgstr "将 quilt 补丁集应用到当前分支"

#. type: Labeled list
#: en/cmds-foreignscminterface.txt:22
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-request-pull[1]"
msgstr "linkgit:git-request-pull[1]"

#. type: Plain text
#: en/cmds-foreignscminterface.txt:24
#, priority:100
msgid "Generates a summary of pending changes."
msgstr "生成一个悬而未决的更改摘要。"

#. type: Labeled list
#: en/cmds-foreignscminterface.txt:25
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-send-email[1]"
msgstr "linkgit:git-send-email[1]"

#. type: Plain text
#: en/cmds-foreignscminterface.txt:27
#, priority:100
msgid "Send a collection of patches as emails."
msgstr "以电子邮件的形式发送补丁集合。"

#. type: Labeled list
#: en/cmds-foreignscminterface.txt:28
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-svn[1]"
msgstr "linkgit:git-svn[1]"

#. type: Plain text
#: en/cmds-foreignscminterface.txt:30
#, fuzzy, priority:100
msgid "Bidirectional operation between a Subversion repository and Git."
msgstr "Bidirectional operation between a Subversion repository and Git."

#. type: Labeled list
#: en/cmds-guide.txt:1
#, ignore-same, no-wrap, priority:100
msgid "linkgit:gitcore-tutorial[7]"
msgstr "linkgit:gitcore-tutorial[7]"

#. type: Plain text
#: en/cmds-guide.txt:3
#, priority:100
msgid "A Git core tutorial for developers."
msgstr "面向开发者的 Git 核心教程。"

#. type: Labeled list
#: en/cmds-guide.txt:4
#, ignore-same, no-wrap, priority:100
msgid "linkgit:gitcredentials[7]"
msgstr "linkgit:gitcredentials[7]"

#. type: Plain text
#: en/cmds-guide.txt:6
#, priority:100
msgid "Providing usernames and passwords to Git."
msgstr "向 Git 提供用户名和密码。"

#. type: Labeled list
#: en/cmds-guide.txt:7
#, ignore-same, no-wrap, priority:100
msgid "linkgit:gitcvs-migration[7]"
msgstr "linkgit:gitcvs-migration[7]"

#. type: Plain text
#: en/cmds-guide.txt:9
#, priority:100
msgid "Git for CVS users."
msgstr "为 CVS 用户提供的 Git。"

#. type: Labeled list
#: en/cmds-guide.txt:10
#, ignore-same, no-wrap, priority:100
msgid "linkgit:gitdiffcore[7]"
msgstr "linkgit:gitdiffcore[7]"

#. type: Plain text
#: en/cmds-guide.txt:12
#, priority:100
msgid "Tweaking diff output."
msgstr "调整差异输出。"

#. type: Labeled list
#: en/cmds-guide.txt:13
#, ignore-same, no-wrap, priority:100
msgid "linkgit:giteveryday[7]"
msgstr "linkgit:giteveryday[7]"

#. type: Plain text
#: en/cmds-guide.txt:15
#, priority:100
msgid "A useful minimum set of commands for Everyday Git."
msgstr "一套有用的最小化 Git 命令集。"

#. type: Labeled list
#: en/cmds-guide.txt:16
#, ignore-same, no-wrap, priority:100
msgid "linkgit:gitfaq[7]"
msgstr "linkgit:gitfaq[7]"

#. type: Plain text
#: en/cmds-guide.txt:18
#, priority:100
msgid "Frequently asked questions about using Git."
msgstr "关于使用 Git 的常见问题。"

#. type: Labeled list
#: en/cmds-guide.txt:19
#, ignore-same, no-wrap, priority:100
msgid "linkgit:gitglossary[7]"
msgstr "linkgit:gitglossary[7]"

#. type: Plain text
#: en/cmds-guide.txt:21
#, fuzzy, priority:100
msgid "A Git Glossary."
msgstr "gitglossary - A Git Glossary"

#. type: Plain text
#: en/cmds-guide.txt:22 en/git-upload-pack.txt:61
#, ignore-same, no-wrap, priority:100
msgid "linkgit:gitnamespaces[7]"
msgstr "linkgit:gitnamespaces[7]"

#. type: Plain text
#: en/cmds-guide.txt:24
#, fuzzy, priority:100
msgid "Git namespaces."
msgstr "空白字符"

#. type: Plain text
#: en/cmds-guide.txt:25 en/git-remote-ext.txt:122 en/git-remote-fd.txt:56
#, ignore-same, no-wrap, priority:100
msgid "linkgit:gitremote-helpers[7]"
msgstr "linkgit:gitremote-helpers[7]"

#. type: Plain text
#: en/cmds-guide.txt:27
#, priority:100
msgid "Helper programs to interact with remote repositories."
msgstr "与远程仓库互动的辅助程序。"

#. type: Labeled list
#: en/cmds-guide.txt:28
#, ignore-same, no-wrap, priority:100
msgid "linkgit:gitsubmodules[7]"
msgstr "linkgit:gitsubmodules[7]"

#. type: Plain text
#: en/cmds-guide.txt:30
#, priority:100
msgid "Mounting one repository inside another."
msgstr "将一个存储库挂载在另一个存储库内。"

#. type: Labeled list
#: en/cmds-guide.txt:31
#, ignore-same, no-wrap, priority:100
msgid "linkgit:gittutorial[7]"
msgstr "linkgit:gittutorial[7]"

#. type: Plain text
#: en/cmds-guide.txt:33
#, priority:100
msgid "A tutorial introduction to Git."
msgstr "Git入门教程。"

#. type: Labeled list
#: en/cmds-guide.txt:34
#, ignore-same, no-wrap, priority:100
msgid "linkgit:gittutorial-2[7]"
msgstr "linkgit:gittutorial-2[7]"

#. type: Plain text
#: en/cmds-guide.txt:36
#, priority:100
msgid "A tutorial introduction to Git: part two."
msgstr "Git 的教程介绍：第二部分。"

#. type: Labeled list
#: en/cmds-guide.txt:37
#, ignore-same, no-wrap, priority:100
msgid "linkgit:gitworkflows[7]"
msgstr "linkgit:gitworkflows[7]"

#. type: Plain text
#: en/cmds-guide.txt:39
#, priority:100
msgid "An overview of recommended workflows with Git."
msgstr "推荐使用 Git 的工作流程概述。"

#. type: Plain text
#: en/cmds-mainporcelain.txt:1 en/git-rm.txt:201
#, ignore-same, no-wrap, priority:280
msgid "linkgit:git-add[1]"
msgstr "linkgit:git-add[1]"

#. type: Plain text
#: en/cmds-mainporcelain.txt:3
#, fuzzy, priority:100
msgid "Add file contents to the index."
msgstr "Add file contents to the index."

#. type: Labeled list
#: en/cmds-mainporcelain.txt:4
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-am[1]"
msgstr "linkgit:git-am[1]"

#. type: Plain text
#: en/cmds-mainporcelain.txt:6
#, priority:100
msgid "Apply a series of patches from a mailbox."
msgstr "从一个邮箱中应用一系列的补丁。"

#. type: Labeled list
#: en/cmds-mainporcelain.txt:7
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-archive[1]"
msgstr "linkgit:git-archive[1]"

#. type: Plain text
#: en/cmds-mainporcelain.txt:9
#, priority:100
msgid "Create an archive of files from a named tree."
msgstr "从一个命名的目录中创建一个文件档案。"

#. type: Labeled list
#: en/cmds-mainporcelain.txt:10
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-bisect[1]"
msgstr "linkgit:git-bisect[1]"

#. type: Plain text
#: en/cmds-mainporcelain.txt:12
#, priority:100
msgid "Use binary search to find the commit that introduced a bug."
msgstr "使用二进制搜索查找引入错误的提交。"

#. type: Labeled list
#: en/cmds-mainporcelain.txt:13
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-branch[1]"
msgstr "linkgit:git-branch[1]"

#. type: Plain text
#: en/cmds-mainporcelain.txt:15
#, priority:100
msgid "List, create, or delete branches."
msgstr "列出、创建或删除分支。"

#. type: Labeled list
#: en/cmds-mainporcelain.txt:16
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-bundle[1]"
msgstr "linkgit:git-bundle[1]"

#. type: Plain text
#: en/cmds-mainporcelain.txt:18
#, priority:100
msgid "Move objects and refs by archive."
msgstr "通过存档移动对象和引用。"

#. type: Labeled list
#: en/cmds-mainporcelain.txt:19
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-checkout[1]"
msgstr "linkgit:git-checkout[1]"

#. type: Plain text
#: en/cmds-mainporcelain.txt:21
#, priority:100
msgid "Switch branches or restore working tree files."
msgstr "切换分支或恢复工作区文件。"

#. type: Plain text
#: en/cmds-mainporcelain.txt:22 en/git-revert.txt:155
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-cherry-pick[1]"
msgstr "linkgit:git-cherry-pick[1]"

#. type: Plain text
#: en/cmds-mainporcelain.txt:24
#, priority:100
msgid "Apply the changes introduced by some existing commits."
msgstr "应用一些现有的提交所带来的变化。"

#. type: Labeled list
#: en/cmds-mainporcelain.txt:25
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-citool[1]"
msgstr "linkgit:git-citool[1]"

#. type: Plain text
#: en/cmds-mainporcelain.txt:27
#, fuzzy, priority:100
msgid "Graphical alternative to git-commit."
msgstr "Graphical alternative to git-commit."

#. type: Labeled list
#: en/cmds-mainporcelain.txt:28
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-clean[1]"
msgstr "linkgit:git-clean[1]"

#. type: Plain text
#: en/cmds-mainporcelain.txt:30
#, priority:100
msgid "Remove untracked files from the working tree."
msgstr "从工作区上删除未跟踪的文件。"

#. type: Labeled list
#: en/cmds-mainporcelain.txt:31
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-clone[1]"
msgstr "linkgit:git-clone[1]"

#. type: Plain text
#: en/cmds-mainporcelain.txt:33
#, fuzzy, priority:100
msgid "Clone a repository into a new directory."
msgstr "Clone a repository into a new directory."

#. type: Labeled list
#: en/cmds-mainporcelain.txt:34
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-commit[1]"
msgstr "linkgit:git-commit[1]"

#. type: Plain text
#: en/cmds-mainporcelain.txt:36
#, priority:100
msgid "Record changes to the repository."
msgstr "记录对仓库的更改。"

#. type: Labeled list
#: en/cmds-mainporcelain.txt:37
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-describe[1]"
msgstr "linkgit:git-describe[1]"

#. type: Plain text
#: en/cmds-mainporcelain.txt:39
#, priority:100
msgid "Give an object a human readable name based on an available ref."
msgstr "根据一个可用的引用，给一个对象易于理解的名字。"

#. type: Labeled list
#: en/cmds-mainporcelain.txt:40 en/git-difftool.txt:129
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-diff[1]"
msgstr "linkgit:git-diff[1]"

#. type: Plain text
#: en/cmds-mainporcelain.txt:42
#, priority:100
msgid "Show changes between commits, commit and working tree, etc."
msgstr "显示提交之间的变化，提交和工作区，等。"

#. type: Plain text
#: en/cmds-mainporcelain.txt:43 en/git-fetch-pack.txt:133
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-fetch[1]"
msgstr "linkgit:git-fetch[1]"

#. type: Plain text
#: en/cmds-mainporcelain.txt:45
#, priority:100
msgid "Download objects and refs from another repository."
msgstr "从另一个仓库下载对象和引用。"

#. type: Labeled list
#: en/cmds-mainporcelain.txt:46
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-format-patch[1]"
msgstr "linkgit:git-format-patch[1]"

#. type: Plain text
#: en/cmds-mainporcelain.txt:48
#, priority:100
msgid "Prepare patches for e-mail submission."
msgstr "为提交电子邮件准备补丁。"

#. type: Labeled list
#: en/cmds-mainporcelain.txt:49
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-gc[1]"
msgstr "linkgit:git-gc[1]"

#. type: Plain text
#: en/cmds-mainporcelain.txt:51
#, priority:100
msgid "Cleanup unnecessary files and optimize the local repository."
msgstr "清理不必要的文件，优化本地仓库。"

#. type: Labeled list
#: en/cmds-mainporcelain.txt:52
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-grep[1]"
msgstr "linkgit:git-grep[1]"

#. type: Plain text
#: en/cmds-mainporcelain.txt:54
#, priority:100
msgid "Print lines matching a pattern."
msgstr "打印符合模式的行。"

#. type: Labeled list
#: en/cmds-mainporcelain.txt:55
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-gui[1]"
msgstr "linkgit:git-gui[1]"

#. type: Plain text
#: en/cmds-mainporcelain.txt:57
#, priority:100
msgid "A portable graphical interface to Git."
msgstr "Git的可移植图形界面。"

#. type: Labeled list
#: en/cmds-mainporcelain.txt:58
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-init[1]"
msgstr "linkgit:git-init[1]"

#. type: Plain text
#: en/cmds-mainporcelain.txt:60
#, fuzzy, priority:100
msgid "Create an empty Git repository or reinitialize an existing one."
msgstr "Create an empty Git repository or reinitialize an existing one."

#. type: Plain text
#: en/cmds-mainporcelain.txt:61 en/git-range-diff.txt:294
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-log[1]"
msgstr "linkgit:git-log[1]"

#. type: Plain text
#: en/cmds-mainporcelain.txt:63
#, priority:100
msgid "Show commit logs."
msgstr "展示提交日志。"

#. type: Labeled list
#: en/cmds-mainporcelain.txt:64
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-maintenance[1]"
msgstr "linkgit:git-maintenance[1]"

#. type: Plain text
#: en/cmds-mainporcelain.txt:66
#, priority:100
msgid "Run tasks to optimize Git repository data."
msgstr "运行任务来优化Git存储库的数据。"

#. type: Plain text
#: en/cmds-mainporcelain.txt:67 en/git-fmt-merge-msg.txt:79
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-merge[1]"
msgstr "linkgit:git-merge[1]"

#. type: Plain text
#: en/cmds-mainporcelain.txt:69
#, priority:100
msgid "Join two or more development histories together."
msgstr "将两个或更多的开发历史连接在一起。"

#. type: Labeled list
#: en/cmds-mainporcelain.txt:70
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-mv[1]"
msgstr "linkgit:git-mv[1]"

#. type: Plain text
#: en/cmds-mainporcelain.txt:72
#, priority:100
msgid "Move or rename a file, a directory, or a symlink."
msgstr "移动或重命名一个文件、一个目录或一个符号链接。"

#. type: Labeled list
#: en/cmds-mainporcelain.txt:73
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-notes[1]"
msgstr "linkgit:git-notes[1]"

#. type: Plain text
#: en/cmds-mainporcelain.txt:75
#, priority:100
msgid "Add or inspect object notes."
msgstr "添加或检查对象注释。"

#. type: Plain text
#: en/cmds-mainporcelain.txt:76 en/git-fetch.txt:314
#, ignore-same, no-wrap, priority:220
msgid "linkgit:git-pull[1]"
msgstr "linkgit:git-pull[1]"

#. type: Plain text
#: en/cmds-mainporcelain.txt:78
#, priority:100
msgid "Fetch from and integrate with another repository or a local branch."
msgstr "从另一个仓库或本地分支获取并整合。"

#. type: Labeled list
#: en/cmds-mainporcelain.txt:79
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-push[1]"
msgstr "linkgit:git-push[1]"

#. type: Plain text
#: en/cmds-mainporcelain.txt:81
#, priority:100
msgid "Update remote refs along with associated objects."
msgstr "更新远程仓库引用和相关对象。"

#. type: Labeled list
#: en/cmds-mainporcelain.txt:82
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-range-diff[1]"
msgstr "linkgit:git-range-diff[1]"

#. type: Plain text
#: en/cmds-mainporcelain.txt:84
#, priority:100
msgid "Compare two commit ranges (e.g. two versions of a branch)."
msgstr "比较两个提交范围（例如一个分支的两个版本）。"

#. type: Plain text
#: en/cmds-mainporcelain.txt:85 en/git-svn.txt:1171
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-rebase[1]"
msgstr "linkgit:git-rebase[1]"

#. type: Plain text
#: en/cmds-mainporcelain.txt:87
#, priority:100
msgid "Reapply commits on top of another base tip."
msgstr "在另一个基础提示的基础上重新提交。"

#. type: Labeled list
#: en/cmds-mainporcelain.txt:88
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-reset[1]"
msgstr "linkgit:git-reset[1]"

#. type: Plain text
#: en/cmds-mainporcelain.txt:90
#, priority:100
msgid "Reset current HEAD to the specified state."
msgstr "重置当前HEAD到指定状态。"

#. type: Labeled list
#: en/cmds-mainporcelain.txt:91
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-restore[1]"
msgstr "linkgit:git-restore[1]"

#. type: Plain text
#: en/cmds-mainporcelain.txt:93
#, priority:100
msgid "Restore working tree files."
msgstr "恢复工作区文件。"

#. type: Plain text
#: en/cmds-mainporcelain.txt:94 en/git-cherry-pick.txt:240
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-revert[1]"
msgstr "linkgit:git-revert[1]"

#. type: Plain text
#: en/cmds-mainporcelain.txt:96
#, priority:100
msgid "Revert some existing commits."
msgstr "还原一些现有的提交。"

#. type: Labeled list
#: en/cmds-mainporcelain.txt:97
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-rm[1]"
msgstr "linkgit:git-rm[1]"

#. type: Plain text
#: en/cmds-mainporcelain.txt:99
#, priority:100
msgid "Remove files from the working tree and from the index."
msgstr "从工作区和索引中删除文件。"

#. type: Labeled list
#: en/cmds-mainporcelain.txt:100
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-shortlog[1]"
msgstr "linkgit:git-shortlog[1]"

#. type: Plain text
#: en/cmds-mainporcelain.txt:102
#, fuzzy, priority:100
msgid "Summarize 'git log' output."
msgstr "Summarize 'git log' output."

#. type: Labeled list
#: en/cmds-mainporcelain.txt:103
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-show[1]"
msgstr "linkgit:git-show[1]"

#. type: Plain text
#: en/cmds-mainporcelain.txt:105
#, priority:100
msgid "Show various types of objects."
msgstr "展示各种类型的对象。"

#. type: Labeled list
#: en/cmds-mainporcelain.txt:106
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-sparse-checkout[1]"
msgstr "linkgit:git-sparse-checkout[1]"

#. type: Plain text
#: en/cmds-mainporcelain.txt:108
#, priority:100
msgid "Reduce your working tree to a subset of tracked files."
msgstr "将你的工作区减少到一个被跟踪的文件子集。"

#. type: Labeled list
#: en/cmds-mainporcelain.txt:109
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-stash[1]"
msgstr "linkgit:git-stash[1]"

#. type: Plain text
#: en/cmds-mainporcelain.txt:111
#, priority:100
msgid "Stash the changes in a dirty working directory away."
msgstr "把这些变化贮藏在一个脏工作目录中。"

#. type: Labeled list
#: en/cmds-mainporcelain.txt:112
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-status[1]"
msgstr "linkgit:git-status[1]"

#. type: Plain text
#: en/cmds-mainporcelain.txt:114
#, priority:100
msgid "Show the working tree status."
msgstr "显示工作区状态。"

#. type: Labeled list
#: en/cmds-mainporcelain.txt:115
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-submodule[1]"
msgstr "linkgit:git-submodule[1]"

#. type: Plain text
#: en/cmds-mainporcelain.txt:117
#, priority:100
msgid "Initialize, update or inspect submodules."
msgstr "初始化、更新或检查子模块。"

#. type: Labeled list
#: en/cmds-mainporcelain.txt:118
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-switch[1]"
msgstr "linkgit:git-switch[1]"

#. type: Plain text
#: en/cmds-mainporcelain.txt:120
#, priority:100
msgid "Switch branches."
msgstr "切换分支。"

#. type: Labeled list
#: en/cmds-mainporcelain.txt:121
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-tag[1]"
msgstr "linkgit:git-tag[1]"

#. type: Plain text
#: en/cmds-mainporcelain.txt:123
#, fuzzy, priority:100
msgid "Create, list, delete or verify a tag object signed with GPG."
msgstr "创建、列出、删除或校验以 GPG 签名的标签对象。"

#. type: Labeled list
#: en/cmds-mainporcelain.txt:124
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-worktree[1]"
msgstr "linkgit:git-worktree[1]"

#. type: Plain text
#: en/cmds-mainporcelain.txt:126
#, priority:100
msgid "Manage multiple working trees."
msgstr "管理多个工作区。"

#. type: Labeled list
#: en/cmds-mainporcelain.txt:127 en/git-gui.txt:104
#, ignore-same, no-wrap, priority:100
msgid "linkgit:gitk[1]"
msgstr "linkgit:gitk[1]"

#. type: Plain text
#: en/cmds-mainporcelain.txt:129
#, priority:100
msgid "The Git repository browser."
msgstr "Git 仓库浏览器。"

#. type: Labeled list
#: en/cmds-mainporcelain.txt:130
#, fuzzy, no-wrap, priority:100
#| msgid "linkgit:git-clean[1]"
msgid "linkgit:scalar[1]"
msgstr "linkgit:git-clean[1]"

#. type: Plain text
#: en/cmds-mainporcelain.txt:132
#, fuzzy, priority:100
#| msgid "These options are mostly targeted for packing of Git repositories."
msgid "A tool for managing large Git repositories."
msgstr "这些选项主要是针对Git存储库的打包。"

#. type: Labeled list
#: en/cmds-plumbinginterrogators.txt:1
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-cat-file[1]"
msgstr "linkgit:git-cat-file[1]"

#. type: Plain text
#: en/cmds-plumbinginterrogators.txt:3
#, priority:100
msgid "Provide content or type and size information for repository objects."
msgstr "为仓库对象提供内容或类型和大小信息。"

#. type: Labeled list
#: en/cmds-plumbinginterrogators.txt:4
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-cherry[1]"
msgstr "linkgit:git-cherry[1]"

#. type: Plain text
#: en/cmds-plumbinginterrogators.txt:6
#, priority:100
msgid "Find commits yet to be applied to upstream."
msgstr "查找尚未应用于上游仓库的提交。"

#. type: Labeled list
#: en/cmds-plumbinginterrogators.txt:7
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-diff-files[1]"
msgstr "linkgit:git-diff-files[1]"

#. type: Plain text
#: en/cmds-plumbinginterrogators.txt:9
#, priority:100
msgid "Compares files in the working tree and the index."
msgstr "比较工作区和索引中的文件。"

#. type: Labeled list
#: en/cmds-plumbinginterrogators.txt:10
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-diff-index[1]"
msgstr "linkgit:git-diff-index[1]"

#. type: Plain text
#: en/cmds-plumbinginterrogators.txt:12
#, priority:100
msgid "Compare a tree to the working tree or index."
msgstr "将目录树与工作目录或索引进行比较。"

#. type: Labeled list
#: en/cmds-plumbinginterrogators.txt:13
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-diff-tree[1]"
msgstr "linkgit:git-diff-tree[1]"

#. type: Plain text
#: en/cmds-plumbinginterrogators.txt:15
#, fuzzy, priority:100
msgid "Compares the content and mode of blobs found via two tree objects."
msgstr "比较两个树对象中发现的 blob 的内容和模式。"

#. type: Labeled list
#: en/cmds-plumbinginterrogators.txt:16
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-for-each-ref[1]"
msgstr "linkgit:git-for-each-ref[1]"

#. type: Plain text
#: en/cmds-plumbinginterrogators.txt:18
#, fuzzy, priority:100
msgid "Output information on each ref."
msgstr "输出每个参考的信息。"

#. type: Labeled list
#: en/cmds-plumbinginterrogators.txt:19
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-for-each-repo[1]"
msgstr "linkgit:git-for-each-repo[1]"

#. type: Plain text
#: en/cmds-plumbinginterrogators.txt:21
#, priority:100
msgid "Run a Git command on a list of repositories."
msgstr "在一个仓库列表上运行一个 Git 命令。"

#. type: Labeled list
#: en/cmds-plumbinginterrogators.txt:22
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-get-tar-commit-id[1]"
msgstr "linkgit:git-get-tar-commit-id[1]"

#. type: Plain text
#: en/cmds-plumbinginterrogators.txt:24
#, priority:100
msgid "Extract commit ID from an archive created using git-archive."
msgstr "从使用git archive创建的存档中提取commit ID。"

#. type: Labeled list
#: en/cmds-plumbinginterrogators.txt:25
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-ls-files[1]"
msgstr "linkgit:git-ls-files[1]"

#. type: Plain text
#: en/cmds-plumbinginterrogators.txt:27
#, priority:100
msgid "Show information about files in the index and the working tree."
msgstr "显示索引和工作区中的文件信息。"

#. type: Labeled list
#: en/cmds-plumbinginterrogators.txt:28
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-ls-remote[1]"
msgstr "linkgit:git-ls-remote[1]"

#. type: Plain text
#: en/cmds-plumbinginterrogators.txt:30
#, priority:100
msgid "List references in a remote repository."
msgstr "列出远程仓库中的引用。"

#. type: Labeled list
#: en/cmds-plumbinginterrogators.txt:31
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-ls-tree[1]"
msgstr "linkgit:git-ls-tree[1]"

#. type: Plain text
#: en/cmds-plumbinginterrogators.txt:33
#, priority:100
msgid "List the contents of a tree object."
msgstr "列出一个树对象的内容。"

#. type: Labeled list
#: en/cmds-plumbinginterrogators.txt:34
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-merge-base[1]"
msgstr "linkgit:git-merge-base[1]"

#. type: Plain text
#: en/cmds-plumbinginterrogators.txt:36
#, priority:100
msgid "Find as good common ancestors as possible for a merge."
msgstr "尽可能找到好的共同祖先进行合并。"

#. type: Labeled list
#: en/cmds-plumbinginterrogators.txt:37
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-name-rev[1]"
msgstr "linkgit:git-name-rev[1]"

#. type: Plain text
# 查找给定版本的符号名称
#: en/cmds-plumbinginterrogators.txt:39
#, priority:100
msgid "Find symbolic names for given revs."
msgstr "为给定的 revs 寻找符号名称。"

#. type: Labeled list
#: en/cmds-plumbinginterrogators.txt:40
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-pack-redundant[1]"
msgstr "linkgit:git-pack-redundant[1]"

#. type: Plain text
#: en/cmds-plumbinginterrogators.txt:42
#, priority:100
msgid "Find redundant pack files."
msgstr "寻找多余的包文件。"

#. type: Labeled list
#: en/cmds-plumbinginterrogators.txt:43
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-rev-list[1]"
msgstr "linkgit:git-rev-list[1]"

#. type: Plain text
#: en/cmds-plumbinginterrogators.txt:45
#, priority:100
msgid "Lists commit objects in reverse chronological order."
msgstr "按时间顺序倒序列出提交对象。"

#. type: Labeled list
#: en/cmds-plumbinginterrogators.txt:46
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-rev-parse[1]"
msgstr "linkgit:git-rev-parse[1]"

#. type: Plain text
#: en/cmds-plumbinginterrogators.txt:48
#, priority:100
msgid "Pick out and massage parameters."
msgstr "挑选并按摩参数。"

#. type: Labeled list
#: en/cmds-plumbinginterrogators.txt:49
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-show-index[1]"
msgstr "linkgit:git-show-index[1]"

#. type: Plain text
#: en/cmds-plumbinginterrogators.txt:51
#, priority:100
msgid "Show packed archive index."
msgstr "显示打包的档案索引。"

#. type: Plain text
#: en/cmds-plumbinginterrogators.txt:52 en/git-for-each-ref.txt:494
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-show-ref[1]"
msgstr "linkgit:git-show-ref[1]"

#. type: Plain text
#: en/cmds-plumbinginterrogators.txt:54
#, priority:100
msgid "List references in a local repository."
msgstr "列出本地仓库中的引用。"

#. type: Labeled list
#: en/cmds-plumbinginterrogators.txt:55
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-unpack-file[1]"
msgstr "linkgit:git-unpack-file[1]"

#. type: Plain text
#: en/cmds-plumbinginterrogators.txt:57
#, priority:100
msgid "Creates a temporary file with a blob's contents."
msgstr "创建包含blob内容的临时文件。"

#. type: Labeled list
#: en/cmds-plumbinginterrogators.txt:58
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-var[1]"
msgstr "linkgit:git-var[1]"

#. type: Plain text
#: en/cmds-plumbinginterrogators.txt:60
#, fuzzy, priority:100
msgid "Show a Git logical variable."
msgstr "Git"

#. type: Labeled list
#: en/cmds-plumbinginterrogators.txt:61
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-verify-pack[1]"
msgstr "linkgit:git-verify-pack[1]"

#. type: Plain text
#: en/cmds-plumbinginterrogators.txt:63
#, fuzzy, priority:100
msgid "Validate packed Git archive files."
msgstr "Git"

#. type: Labeled list
#: en/cmds-plumbingmanipulators.txt:1
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-apply[1]"
msgstr "linkgit:git-apply[1]"

#. type: Plain text
#: en/cmds-plumbingmanipulators.txt:3
#, fuzzy, priority:100
msgid "Apply a patch to files and/or to the index."
msgstr "/"

#. type: Labeled list
#: en/cmds-plumbingmanipulators.txt:4
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-checkout-index[1]"
msgstr "linkgit:git-checkout-index[1]"

#. type: Plain text
#: en/cmds-plumbingmanipulators.txt:6
#, priority:100
msgid "Copy files from the index to the working tree."
msgstr "从索引中复制文件到工作目录。"

#. type: Labeled list
#: en/cmds-plumbingmanipulators.txt:7
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-commit-graph[1]"
msgstr "linkgit:git-commit-graph[1]"

#. type: Plain text
#: en/cmds-plumbingmanipulators.txt:9
#, priority:100
msgid "Write and verify Git commit-graph files."
msgstr "编写并验证Git commit-graph文件。"

#. type: Labeled list
#: en/cmds-plumbingmanipulators.txt:10
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-commit-tree[1]"
msgstr "linkgit:git-commit-tree[1]"

#. type: Plain text
#: en/cmds-plumbingmanipulators.txt:12
#, priority:100
msgid "Create a new commit object."
msgstr "创建一个新的提交对象。"

#. type: Labeled list
#: en/cmds-plumbingmanipulators.txt:13
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-hash-object[1]"
msgstr "linkgit:git-hash-object[1]"

#. type: Plain text
#: en/cmds-plumbingmanipulators.txt:15
#, fuzzy, priority:100
msgid "Compute object ID and optionally creates a blob from a file."
msgstr "计算对象 ID，根据文件创建 blob（可选）。"

#. type: Labeled list
#: en/cmds-plumbingmanipulators.txt:16
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-index-pack[1]"
msgstr "linkgit:git-index-pack[1]"

#. type: Plain text
#: en/cmds-plumbingmanipulators.txt:18
#, priority:100
msgid "Build pack index file for an existing packed archive."
msgstr "为现有的打包档案建立打包索引文件。"

#. type: Labeled list
#: en/cmds-plumbingmanipulators.txt:19
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-merge-file[1]"
msgstr "linkgit:git-merge-file[1]"

#. type: Plain text
#: en/cmds-plumbingmanipulators.txt:21
#, priority:100
msgid "Run a three-way file merge."
msgstr "运行一个三向文件合并。"

#. type: Labeled list
#: en/cmds-plumbingmanipulators.txt:22
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-merge-index[1]"
msgstr "linkgit:git-merge-index[1]"

#. type: Plain text
#: en/cmds-plumbingmanipulators.txt:24
#, priority:100
msgid "Run a merge for files needing merging."
msgstr "为需要合并的文件运行合并程序。"

#. type: Labeled list
#: en/cmds-plumbingmanipulators.txt:25
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-mktag[1]"
msgstr "linkgit:git-mktag[1]"

#. type: Plain text
#: en/cmds-plumbingmanipulators.txt:27
#, priority:100
msgid "Creates a tag object with extra validation."
msgstr "创建一个具有额外验证功能的标签对象。"

#. type: Labeled list
#: en/cmds-plumbingmanipulators.txt:28
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-mktree[1]"
msgstr "linkgit:git-mktree[1]"

#. type: Plain text
#: en/cmds-plumbingmanipulators.txt:30
#, fuzzy, priority:100
msgid "Build a tree-object from ls-tree formatted text."
msgstr "根据 ls-树格式的文本构建树 (tree) 对象。"

#. type: Labeled list
#: en/cmds-plumbingmanipulators.txt:31
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-multi-pack-index[1]"
msgstr "linkgit:git-multi-pack-index[1]"

#. type: Plain text
#: en/cmds-plumbingmanipulators.txt:33
#, priority:100
msgid "Write and verify multi-pack-indexes."
msgstr "编写和验证多包索引。"

#. type: Labeled list
#: en/cmds-plumbingmanipulators.txt:34
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-pack-objects[1]"
msgstr "linkgit:git-pack-objects[1]"

#. type: Plain text
#: en/cmds-plumbingmanipulators.txt:36
#, priority:100
msgid "Create a packed archive of objects."
msgstr "创建一个打包的对象档案。"

#. type: Labeled list
#: en/cmds-plumbingmanipulators.txt:37
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-prune-packed[1]"
msgstr "linkgit:git-prune-packed[1]"

#. type: Plain text
#: en/cmds-plumbingmanipulators.txt:39
#, priority:100
msgid "Remove extra objects that are already in pack files."
msgstr "删除已经存在于包文件中的额外对象。"

#. type: Labeled list
#: en/cmds-plumbingmanipulators.txt:40
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-read-tree[1]"
msgstr "linkgit:git-read-tree[1]"

#. type: Plain text
#: en/cmds-plumbingmanipulators.txt:42
#, priority:100
msgid "Reads tree information into the index."
msgstr "将目录树的信息读入索引。"

#. type: Labeled list
#: en/cmds-plumbingmanipulators.txt:43
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-symbolic-ref[1]"
msgstr "linkgit:git-symbolic-ref[1]"

#. type: Plain text
#: en/cmds-plumbingmanipulators.txt:45
#, priority:100
msgid "Read, modify and delete symbolic refs."
msgstr "读取、修改和删除符号引用。"

#. type: Labeled list
#: en/cmds-plumbingmanipulators.txt:46
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-unpack-objects[1]"
msgstr "linkgit:git-unpack-objects[1]"

#. type: Plain text
#: en/cmds-plumbingmanipulators.txt:48
#, priority:100
msgid "Unpack objects from a packed archive."
msgstr "从打包的档案中解压对象。"

#. type: Labeled list
#: en/cmds-plumbingmanipulators.txt:49
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-update-index[1]"
msgstr "linkgit:git-update-index[1]"

#. type: Plain text
#: en/cmds-plumbingmanipulators.txt:51
#, priority:100
msgid "Register file contents in the working tree to the index."
msgstr "将工作区中的文件内容登记到索引中。"

#. type: Labeled list
#: en/cmds-plumbingmanipulators.txt:52
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-update-ref[1]"
msgstr "linkgit:git-update-ref[1]"

#. type: Plain text
#: en/cmds-plumbingmanipulators.txt:54
#, priority:100
msgid "Update the object name stored in a ref safely."
msgstr "安全地更新存储在引用中的对象名称。"

#. type: Labeled list
#: en/cmds-plumbingmanipulators.txt:55
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-write-tree[1]"
msgstr "linkgit:git-write-tree[1]"

#. type: Plain text
#: en/cmds-plumbingmanipulators.txt:57
#, priority:100
msgid "Create a tree object from the current index."
msgstr "从当前索引创建一个树形对象。"

#. type: Labeled list
#: en/cmds-purehelpers.txt:1
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-check-attr[1]"
msgstr "linkgit:git-check-attr[1]"

#. type: Plain text
#: en/cmds-purehelpers.txt:3
#, priority:100
msgid "Display gitattributes information."
msgstr "显示属性信息。"

#. type: Labeled list
#: en/cmds-purehelpers.txt:4
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-check-ignore[1]"
msgstr "linkgit:git-check-ignore[1]"

#. type: Plain text
#: en/cmds-purehelpers.txt:6
#, priority:100
msgid "Debug gitignore / exclude files."
msgstr "调试gitignore/排除文件。"

#. type: Labeled list
#: en/cmds-purehelpers.txt:7
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-check-mailmap[1]"
msgstr "linkgit:git-check-mailmap[1]"

#. type: Plain text
#: en/cmds-purehelpers.txt:9
#, priority:100
msgid "Show canonical names and email addresses of contacts."
msgstr "显示联系人的规范名称和电子邮件地址。"

#. type: Labeled list
#: en/cmds-purehelpers.txt:10
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-check-ref-format[1]"
msgstr "linkgit:git-check-ref-format[1]"

#. type: Plain text
#: en/cmds-purehelpers.txt:12
#, priority:100
msgid "Ensures that a reference name is well formed."
msgstr "确保一个引用名称是否规范。"

#. type: Labeled list
#: en/cmds-purehelpers.txt:13
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-column[1]"
msgstr "linkgit:git-column[1]"

#. type: Plain text
#: en/cmds-purehelpers.txt:15
#, priority:100
msgid "Display data in columns."
msgstr "以列显示数据。"

#. type: Labeled list
#: en/cmds-purehelpers.txt:16
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-credential[1]"
msgstr "linkgit:git-credential[1]"

#. type: Plain text
#: en/cmds-purehelpers.txt:18
#, priority:100
msgid "Retrieve and store user credentials."
msgstr "检索和存储用户凭证。"

#. type: Labeled list
#: en/cmds-purehelpers.txt:19
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-credential-cache[1]"
msgstr "linkgit:git-credential-cache[1]"

#. type: Plain text
#: en/cmds-purehelpers.txt:21
#, priority:100
msgid "Helper to temporarily store passwords in memory."
msgstr "用于在内存中临时存储密码的助手。"

#. type: Labeled list
#: en/cmds-purehelpers.txt:22
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-credential-store[1]"
msgstr "linkgit:git-credential-store[1]"

#. type: Plain text
#: en/cmds-purehelpers.txt:24
#, priority:100
msgid "Helper to store credentials on disk."
msgstr "帮助在磁盘上存储凭证。"

#. type: Labeled list
#: en/cmds-purehelpers.txt:25
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-fmt-merge-msg[1]"
msgstr "linkgit:git-fmt-merge-msg[1]"

#. type: Plain text
#: en/cmds-purehelpers.txt:27
#, priority:100
msgid "Produce a merge commit message."
msgstr "产生一个合并提交信息。"

#. type: Labeled list
#: en/cmds-purehelpers.txt:28
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-hook[1]"
msgstr "linkgit:git-hook[1]"

#. type: Plain text
#: en/cmds-purehelpers.txt:30
#, priority:100
msgid "Run git hooks."
msgstr "运行 git hooks。"

#. type: Labeled list
#: en/cmds-purehelpers.txt:31
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-interpret-trailers[1]"
msgstr "linkgit:git-interpret-trailers[1]"

#. type: Plain text
#: en/cmds-purehelpers.txt:33
#, priority:100
msgid "Add or parse structured information in commit messages."
msgstr "在提交信息中添加或解析结构化信息。"

#. type: Labeled list
#: en/cmds-purehelpers.txt:34
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-mailinfo[1]"
msgstr "linkgit:git-mailinfo[1]"

#. type: Plain text
#: en/cmds-purehelpers.txt:36
#, priority:100
msgid "Extracts patch and authorship from a single e-mail message."
msgstr "从单一的电子邮件中提取补丁和作者。"

#. type: Labeled list
#: en/cmds-purehelpers.txt:37
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-mailsplit[1]"
msgstr "linkgit:git-mailsplit[1]"

#. type: Plain text
#: en/cmds-purehelpers.txt:39
#, priority:100
msgid "Simple UNIX mbox splitter program."
msgstr "简单的 UNIX mbox 拆分器程序。"

#. type: Labeled list
#: en/cmds-purehelpers.txt:40
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-merge-one-file[1]"
msgstr "linkgit:git-merge-one-file[1]"

#. type: Plain text
#: en/cmds-purehelpers.txt:42
#, priority:100
msgid "The standard helper program to use with git-merge-index."
msgstr "与git-merge-index一起使用的标准帮助程序。"

#. type: Plain text
#: en/cmds-purehelpers.txt:43 en/git-cherry.txt:142
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-patch-id[1]"
msgstr "linkgit:git-patch-id[1]"

#. type: Plain text
#: en/cmds-purehelpers.txt:45
#, priority:100
msgid "Compute unique ID for a patch."
msgstr "为补丁计算唯一的主键ID。"

#. type: Labeled list
#: en/cmds-purehelpers.txt:46
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-sh-i18n[1]"
msgstr "linkgit:git-sh-i18n[1]"

#. type: Plain text
#: en/cmds-purehelpers.txt:48
#, priority:100
msgid "Git's i18n setup code for shell scripts."
msgstr "Git的i18n(国际化)安装代码- shell脚本."

#. type: Labeled list
#: en/cmds-purehelpers.txt:49
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-sh-setup[1]"
msgstr "linkgit:git-sh-setup[1]"

#. type: Plain text
#: en/cmds-purehelpers.txt:51
#, priority:100
msgid "Common Git shell script setup code."
msgstr "通用Git shell脚本安装代码。"

#. type: Labeled list
#: en/cmds-purehelpers.txt:52
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-stripspace[1]"
msgstr "linkgit:git-stripspace[1]"

#. type: Plain text
#: en/cmds-purehelpers.txt:54
#, priority:100
msgid "Remove unnecessary whitespace."
msgstr "删除不必要的空白。"

#. type: Labeled list
#: en/cmds-synchelpers.txt:1
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-http-fetch[1]"
msgstr "linkgit:git-http-fetch[1]"

#. type: Plain text
#: en/cmds-synchelpers.txt:3
#, priority:100
msgid "Download from a remote Git repository via HTTP."
msgstr "通过HTTP从远程Git存储库下载。"

#. type: Labeled list
#: en/cmds-synchelpers.txt:4
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-http-push[1]"
msgstr "linkgit:git-http-push[1]"

#. type: Plain text
#: en/cmds-synchelpers.txt:6
#, priority:100
msgid "Push objects over HTTP/DAV to another repository."
msgstr "通过HTTP/DAV将对象推送到另一个存储库。"

#. type: Labeled list
#: en/cmds-synchelpers.txt:7
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-receive-pack[1]"
msgstr "linkgit:git-receive-pack[1]"

#. type: Plain text
#: en/cmds-synchelpers.txt:9
#, priority:100
msgid "Receive what is pushed into the repository."
msgstr "接收推送到仓库的内容。"

#. type: Labeled list
#: en/cmds-synchelpers.txt:10
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-shell[1]"
msgstr "linkgit:git-shell[1]"

#. type: Plain text
#: en/cmds-synchelpers.txt:12
#, priority:100
msgid "Restricted login shell for Git-only SSH access."
msgstr "Git-only SSH 通道使用的限制登录脚本。"

#. type: Labeled list
#: en/cmds-synchelpers.txt:13
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-upload-archive[1]"
msgstr "linkgit:git-upload-archive[1]"

#. type: Plain text
#: en/cmds-synchelpers.txt:15
#, priority:100
msgid "Send archive back to git-archive."
msgstr "将归档文件发送回git-archive。"

#. type: Labeled list
#: en/cmds-synchelpers.txt:16
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-upload-pack[1]"
msgstr "linkgit:git-upload-pack[1]"

#. type: Plain text
#: en/cmds-synchelpers.txt:18
#, priority:100
msgid "Send objects packed back to git-fetch-pack."
msgstr "将打包的对象发送回git-fetch-pack。"

#. type: Labeled list
#: en/cmds-synchingrepositories.txt:1
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-daemon[1]"
msgstr "linkgit:git-daemon[1]"

#. type: Plain text
#: en/cmds-synchingrepositories.txt:3
#, priority:100
msgid "A really simple server for Git repositories."
msgstr "一个非常简单的Git存储库服务器。"

#. type: Labeled list
#: en/cmds-synchingrepositories.txt:4
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-fetch-pack[1]"
msgstr "linkgit:git-fetch-pack[1]"

#. type: Plain text
#: en/cmds-synchingrepositories.txt:6
#, priority:100
msgid "Receive missing objects from another repository."
msgstr "从另一个仓库接收丢失的对象。"

#. type: Labeled list
#: en/cmds-synchingrepositories.txt:7
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-http-backend[1]"
msgstr "linkgit:git-http-backend[1]"

#. type: Plain text
#: en/cmds-synchingrepositories.txt:9
#, fuzzy, priority:100
msgid "Server side implementation of Git over HTTP."
msgstr "Server side implementation of Git over HTTP."

#. type: Labeled list
#: en/cmds-synchingrepositories.txt:10
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-send-pack[1]"
msgstr "linkgit:git-send-pack[1]"

#. type: Plain text
#: en/cmds-synchingrepositories.txt:12
#, priority:100
msgid "Push objects over Git protocol to another repository."
msgstr "通过Git协议将对象推送到另一个存储库。"

#. type: Labeled list
#: en/cmds-synchingrepositories.txt:13
#, ignore-same, no-wrap, priority:100
msgid "linkgit:git-update-server-info[1]"
msgstr "linkgit:git-update-server-info[1]"

#. type: Plain text
#: en/cmds-synchingrepositories.txt:15
#, priority:100
msgid "Update auxiliary info file to help dumb servers."
msgstr "更新辅助信息文件以帮助哑服务器。"

#. type: Title -
#: en/config.txt:2 en/git-worktree.txt:308
#, fuzzy, no-wrap, priority:240
msgid "CONFIGURATION FILE"
msgstr "配置文件"

#. type: Plain text
#: en/config.txt:12
#, priority:100
msgid "The Git configuration file contains a number of variables that affect the Git commands' behavior. The files `.git/config` and optionally `config.worktree` (see the \"CONFIGURATION FILE\" section of linkgit:git-worktree[1]) in each repository are used to store the configuration for that repository, and `$HOME/.gitconfig` is used to store a per-user configuration as fallback values for the `.git/config` file. The file `/etc/gitconfig` can be used to store a system-wide default configuration."
msgstr "Git 配置文件包含了一些影响 Git 命令行为的变量。每个仓库中的文件 `.git/config` 和可选的 `config.worktree`（见linkgit:git-worktree[1]的 “配置文件” 部分）用于存储该仓库的配置，`$HOME/.gitconfig` 用于存储每个用户的配置，作为 `.git/config` 文件的后退值。文件 `/etc/gitconfig` 可以用来存储全系统的默认配置。"

#. type: Plain text
#: en/config.txt:21
#, priority:100
msgid "The configuration variables are used by both the Git plumbing and the porcelains. The variables are divided into sections, wherein the fully qualified variable name of the variable itself is the last dot-separated segment and the section name is everything before the last dot. The variable names are case-insensitive, allow only alphanumeric characters and `-`, and must start with an alphabetic character.  Some variables may appear multiple times; we say then that the variable is multivalued."
msgstr "配置变量同时被 Git 底层和上层命令使用。变量被分为几个部分，其中变量本身的完全合格的变量名是最后一个点分隔的部分，而部分名称是最后一个点之前的所有内容。变量名称不区分大小写，只允许使用字母数字字符和 `-`，并且必须以字母字符开头。  有些变量可能会出现多次；那么我们就说这个变量是多值的。"

#. type: Title ~
#: en/config.txt:23
#, fuzzy, no-wrap, priority:100
msgid "Syntax"
msgstr "语法"

#. type: Plain text
#: en/config.txt:28
#, priority:100
msgid "The syntax is fairly flexible and permissive; whitespaces are mostly ignored.  The '#' and ';' characters begin comments to the end of line, blank lines are ignored."
msgstr "语法是相当灵活和宽松的；空白处大多被忽略。  '#' 和 ';' 字符开始注释到行末，空行被忽略。"

#. type: Plain text
#: en/config.txt:35
#, priority:100
msgid "The file consists of sections and variables.  A section begins with the name of the section in square brackets and continues until the next section begins.  Section names are case-insensitive.  Only alphanumeric characters, `-` and `.` are allowed in section names.  Each variable must belong to some section, which means that there must be a section header before the first setting of a variable."
msgstr "该文件由章节和变量组成。  一个章节以方括号中的章节名称开始，一直到下一个章节开始。  节的名称是不区分大小写的。  在章节名称中只允许使用字母数字字符、`-` 和 `.`。  每个变量都必须属于某个部分，这意味着在第一次设置变量之前必须有一个部分标题。"

#. type: Plain text
#: en/config.txt:39
#, priority:100
msgid "Sections can be further divided into subsections.  To begin a subsection put its name in double quotes, separated by space from the section name, in the section header, like in the example below:"
msgstr "节可以进一步划分为子节。  要开始一个分节，请将其名称放在双引号中，与节的名称用空格隔开，放在节的标题中，如下面的例子："

#. type: delimited block -
#: en/config.txt:42
#, fuzzy, no-wrap, priority:100
msgid "\t[section \"subsection\"]\n"
msgstr "\t[section \"subsection\"]\n"

#. type: Plain text
#: en/config.txt:53
#, priority:100
msgid "Subsection names are case sensitive and can contain any characters except newline and the null byte. Doublequote `\"` and backslash can be included by escaping them as `\\\"` and `\\\\`, respectively. Backslashes preceding other characters are dropped when reading; for example, `\\t` is read as `t` and `\\0` is read as `0`. Section headers cannot span multiple lines.  Variables may belong directly to a section or to a given subsection. You can have `[section]` if you have `[section \"subsection\"]`, but you don't need to."
msgstr "分节名称是区分大小写的，可以包含任何字符，除了换行和空字节。双引号 `\"` 和反斜杠可以分别通过转义为 `\\\"`和 `\\\\` 来包含。读取时，其他字符前面的反斜杠将被删除；例如，`\\t` 被读作 `t`，`\\0` 被读作 `0`。章节标题不能跨越多行。  变量可以直接属于某一节或某一小节。如果你有 `[section \"subsection\"]`，你可以有 `[section]`，但你不需要这样。"

#. type: Plain text
#: en/config.txt:58
#, priority:100
msgid "There is also a deprecated `[section.subsection]` syntax. With this syntax, the subsection name is converted to lower-case and is also compared case sensitively. These subsection names follow the same restrictions as section names."
msgstr "还有一种废弃的 `[section.subsection]` 语法。在这种语法中，分节名称被转换为小写字母，并且也会敏感地比较大小写。这些分节名称遵循与章节名称相同的限制。"

#. type: Plain text
#: en/config.txt:65
#, priority:100
msgid "All the other lines (and the remainder of the line after the section header) are recognized as setting variables, in the form 'name = value' (or just 'name', which is a short-hand to say that the variable is the boolean \"true\").  The variable names are case-insensitive, allow only alphanumeric characters and `-`, and must start with an alphabetic character."
msgstr "所有其他行（以及部分标题之后的剩余行）都被认为是设置变量，形式为 'name = value'（或者只是 'name'，这是一个简写，表示变量是布尔值 \"true\"）。  变量名称不区分大小写，只允许使用字母数字字符和 `-`，并且必须以字母字符开头。"

#. type: Plain text
#: en/config.txt:73
#, priority:100
msgid "A line that defines a value can be continued to the next line by ending it with a `\\`; the backslash and the end-of-line are stripped.  Leading whitespaces after 'name =', the remainder of the line after the first comment character '#' or ';', and trailing whitespaces of the line are discarded unless they are enclosed in double quotes.  Internal whitespaces within the value are retained verbatim."
msgstr "定义一个值的行可以通过以 `\\` 结束来延续到下一行；反斜杠和行尾被剥离。  在 'name =' 之后的前导空白，在第一个注释字符 '#' 或 ';' 之后的剩余行，以及该行的尾部空白都会被丢弃，除非它们被包含在双引号中。  值中的内部空白将被逐字保留。"

#. type: Plain text
#: en/config.txt:76
#, priority:100
msgid "Inside double quotes, double quote `\"` and backslash `\\` characters must be escaped: use `\\\"` for `\"` and `\\\\` for `\\`."
msgstr "在双引号内，双引号 `\"` 和反斜杠 `\\` 字符必须被转义：用 `\\\"` 表示 `\"`，用 `\\\\` 表示 `\\`。"

#. type: Plain text
#: en/config.txt:81
#, priority:100
msgid "The following escape sequences (beside `\\\"` and `\\\\`) are recognized: `\\n` for newline character (NL), `\\t` for horizontal tabulation (HT, TAB)  and `\\b` for backspace (BS).  Other char escape sequences (including octal escape sequences) are invalid."
msgstr "以下转义序列（除了 `\\\"` 和 `\\\\`）可以被识别：`\\n` 表示换行符（NL），`\\t` 表示水平制表（HT，TAB），`\\b` 表示退格（BS）。  其他字符转义序列（包括八进制转义序列）是无效的。"

#. type: Title ~
#: en/config.txt:84
#, fuzzy, no-wrap, priority:100
msgid "Includes"
msgstr "包括"

#. type: Plain text
#: en/config.txt:91
#, priority:100
msgid "The `include` and `includeIf` sections allow you to include config directives from another source. These sections behave identically to each other with the exception that `includeIf` sections may be ignored if their condition does not evaluate to true; see \"Conditional includes\" below."
msgstr "`include` 和 `includeIf` 部分允许你从另一个来源包含配置指令。这些部分的行为与其他部分相同，但如果 `includeIf` 部分的条件没有评估为真，则可以忽略；见下面的 “有条件的包含”。"

#. type: Plain text
#: en/config.txt:96
#, priority:100
msgid "You can include a config file from another by setting the special `include.path` (or `includeIf.*.path`) variable to the name of the file to be included. The variable takes a pathname as its value, and is subject to tilde expansion. These variables can be given multiple times."
msgstr "你可以通过设置特殊的 `include.path`（或 `includeIf.*.path` ）变量来包含另一个配置文件，即要包含的文件名。该变量将路径名作为其值，并接受 tilde 扩展。这些变量可以被多次赋予。"

#. type: Plain text
#: en/config.txt:102
#, priority:100
msgid "The contents of the included file are inserted immediately, as if they had been found at the location of the include directive. If the value of the variable is a relative path, the path is considered to be relative to the configuration file in which the include directive was found.  See below for examples."
msgstr "被包含的文件的内容会被立即插入，就像它们是在 include 指令的位置被发现的一样。如果该变量的值是一个相对路径，则该路径被认为是相对于发现 include 指令的配置文件。  请看下面的例子。"

#. type: Title ~
#: en/config.txt:104
#, no-wrap, priority:100
msgid "Conditional includes"
msgstr "有条件的包括"

#. type: Plain text
#: en/config.txt:109
#, priority:100
msgid "You can include a config file from another conditionally by setting a `includeIf.<condition>.path` variable to the name of the file to be included."
msgstr "你可以通过设置 `includeIf.<条件>.path` 变量来有条件地包含另一个配置文件，即要包含的文件名称。"

#. type: Plain text
#: en/config.txt:113
#, priority:100
msgid "The condition starts with a keyword followed by a colon and some data whose format and meaning depends on the keyword. Supported keywords are:"
msgstr "条件以一个关键词开始，后面是冒号和一些数据，其格式和含义取决于关键词。支持的关键词有："

#. type: Labeled list
#: en/config.txt:114
#, ignore-same, no-wrap, priority:100
msgid "`gitdir`"
msgstr "`gitdir`"

#. type: Plain text
#: en/config.txt:119
#, priority:100
msgid "The data that follows the keyword `gitdir:` is used as a glob pattern. If the location of the .git directory matches the pattern, the include condition is met."
msgstr "关键字 `gitdir:` 后面的数据被用作匹配模式。如果. git 目录的位置与该模式相匹配，则满足包含条件。"

#. type: Plain text
#: en/config.txt:124
#, fuzzy, priority:100
msgid "The .git location may be auto-discovered, or come from `$GIT_DIR` environment variable. If the repository is auto discovered via a .git file (e.g. from submodules, or a linked worktree), the .git location would be the final location where the .git directory is, not where the"
msgstr "The .git location may be auto-discovered, or come from `$GIT_DIR` environment variable. If the repository is auto discovered via a .git file (e.g. from submodules, or a linked worktree), the .git location would be the final location where the .git directory is, not where the"

#. type: Block title
#: en/config.txt:124
#, fuzzy, no-wrap, priority:100
msgid "git file is."
msgstr "git file is."

#. type: Plain text
#: en/config.txt:129
#, priority:100
msgid "The pattern can contain standard globbing wildcards and two additional ones, `**/` and `/**`, that can match multiple path components. Please refer to linkgit:gitignore[5] for details. For convenience:"
msgstr "该模式可以包含标准的通配符和两个额外的通配符，`**/` 和 `/**`，可以匹配多个路径组件。详情请参考 linkgit:gitignore[5]。为了方便起见："

#. type: Plain text
#: en/config.txt:132
#, priority:100
msgid "If the pattern starts with `~/`, `~` will be substituted with the content of the environment variable `HOME`."
msgstr "如果该模式以 `~/` 开头，`~` 将被替换为环境变量 `HOME` 的内容。"

#. type: Plain text
#: en/config.txt:135
#, priority:100
msgid "If the pattern starts with `./`, it is replaced with the directory containing the current config file."
msgstr "如果模式以 `./` 开头，它将被替换为包含当前配置文件的目录。"

#. type: Plain text
#: en/config.txt:139
#, priority:100
msgid "If the pattern does not start with either `~/`, `./` or `/`, `**/` will be automatically prepended. For example, the pattern `foo/bar` becomes `**/foo/bar` and would match `/any/path/to/foo/bar`."
msgstr "如果模式不以 `~/` 、`./` 或 `/` 开头，`**/` 将被自动添加。例如，模式 `foo/bar` 变成 `**/foo/bar`，将匹配 `/any/path/to/foo/bar`。"

#. type: Plain text
#: en/config.txt:143
#, priority:100
msgid "If the pattern ends with `/`, `**` will be automatically added. For example, the pattern `foo/` becomes `foo/**`. In other words, it matches \"foo\" and everything inside, recursively."
msgstr "如果模式以 `/` 结尾，`**` 将被自动添加。例如，模式 `foo/` 变成 `foo/**`。换句话说，它匹配 \"foo\" 和里面的所有内容，是递归的。"

#. type: Labeled list
#: en/config.txt:144
#, fuzzy, no-wrap, priority:100
msgid "`gitdir/i`"
msgstr "`gitdir/i`"

#. type: Plain text
#: en/config.txt:147
#, priority:100
msgid "This is the same as `gitdir` except that matching is done case-insensitively (e.g. on case-insensitive file systems)"
msgstr "这与 `gitdir` 相同，只是匹配时不区分大小写（例如，在不区分大小写的文件系统上）"

#. type: Labeled list
#: en/config.txt:148
#, ignore-same, no-wrap, priority:100
msgid "`onbranch`"
msgstr "`onbranch`"

#. type: Plain text
#: en/config.txt:155
#, priority:100
msgid "The data that follows the keyword `onbranch:` is taken to be a pattern with standard globbing wildcards and two additional ones, `**/` and `/**`, that can match multiple path components.  If we are in a worktree where the name of the branch that is currently checked out matches the pattern, the include condition is met."
msgstr "关键词 `onbranch: ` 后面的数据被认为是一个带有标准通配符和两个额外的通配符的模式，`**/` 和 `/**`，可以匹配多个路径组件。  如果我们在一个工作树中，当前签出的分支的名称与该模式相匹配，则满足包含条件。"

#. type: Plain text
#: en/config.txt:161
#, priority:100
msgid "If the pattern ends with `/`, `**` will be automatically added. For example, the pattern `foo/` becomes `foo/**`. In other words, it matches all branches that begin with `foo/`. This is useful if your branches are organized hierarchically and you would like to apply a configuration to all the branches in that hierarchy."
msgstr "如果模式以 `/` 结尾，`**` 将被自动添加。例如，模式 `foo/` 变成 `foo/**`。换句话说，它匹配所有以 \"foo/\" 开头的分支。如果你的分支是分层组织的，而你想将一个配置应用于该层级中的所有分支，这就很有用了。"

#. type: Labeled list
#: en/config.txt:162
#, no-wrap, priority:100
msgid "`hasconfig:remote.*.url:`"
msgstr "`hasconfig:remote.*.url:`"

#. type: Plain text
#: en/config.txt:170
#, priority:100
msgid "The data that follows this keyword is taken to be a pattern with standard globbing wildcards and two additional ones, `**/` and `/**`, that can match multiple components. The first time this keyword is seen, the rest of the config files will be scanned for remote URLs (without applying any values). If there exists at least one remote URL that matches this pattern, the include condition is met."
msgstr "这个关键词后面的数据被认为是一个带有标准的通配符和两个额外的通配符的模式，`**/` 和 `/**`，可以匹配多个组件。第一次看到这个关键词时，其余的配置文件将被扫描以寻找远程 URL（不应用任何值）。如果存在至少一个匹配该模式的远程 URL，则满足包含条件。"

#. type: Plain text
#: en/config.txt:173
#, priority:100
msgid "Files included by this option (directly or indirectly) are not allowed to contain remote URLs."
msgstr "由该选项包含的文件（直接或间接）不允许包含远程 URLs。"

#. type: Plain text
#: en/config.txt:184
#, priority:100
msgid "Note that unlike other includeIf conditions, resolving this condition relies on information that is not yet known at the point of reading the condition. A typical use case is this option being present as a system-level or global-level config, and the remote URL being in a local-level config; hence the need to scan ahead when resolving this condition. In order to avoid the chicken-and-egg problem in which potentially-included files can affect whether such files are potentially included, Git breaks the cycle by prohibiting these files from affecting the resolution of these conditions (thus, prohibiting them from declaring remote URLs)."
msgstr "请注意，与其他 includeIf 条件不同，解决这个条件依赖于读取条件时还不知道的信息。一个典型的用例是这个选项作为系统级或全局级的配置出现，而远程 URL 在本地级配置中；因此在解决这个条件时需要提前扫描。为了避免鸡生蛋蛋生鸡的问题，即潜在包含的文件会影响这些文件是否被潜在包含，Git 通过禁止这些文件影响这些条件的解决来打破这个循环（因此，禁止它们声明远程 URLs）。"

#. type: Plain text
#: en/config.txt:188
#, fuzzy, priority:100
#| msgid "As for the naming of this keyword, it is for forwards compatibiliy with a naming scheme that supports more variable-based include conditions, but currently Git only supports the exact keyword described above."
msgid "As for the naming of this keyword, it is for forwards compatibility with a naming scheme that supports more variable-based include conditions, but currently Git only supports the exact keyword described above."
msgstr "至于这个关键字的命名，是为了与支持更多基于变量的包含条件的命名方案相兼容，但目前 Git 只支持上述的确切关键字。"

#. type: Plain text
#: en/config.txt:190
#, priority:100
msgid "A few more notes on matching via `gitdir` and `gitdir/i`:"
msgstr "关于通过 `gitdir` 和 `gitdir/i` 进行匹配的一些补充说明："

#. type: Plain text
#: en/config.txt:192
#, priority:100
msgid "Symlinks in `$GIT_DIR` are not resolved before matching."
msgstr "`$GIT_DIR` 中的符号链接在匹配前没有被解决。"

#. type: Plain text
#: en/config.txt:197
#, priority:100
msgid "Both the symlink & realpath versions of paths will be matched outside of `$GIT_DIR`. E.g. if ~/git is a symlink to /mnt/storage/git, both `gitdir:~/git` and `gitdir:/mnt/storage/git` will match."
msgstr "在 `$GIT_DIR` 之外，符号链接和实际路径版本的路径都将被匹配。例如，如果 ~/git 是 /mnt/storage/git 的符号链接，`gitdir:~/git` 和 `gitdir:/mnt/storage/git` 都会匹配。"

#. type: Plain text
#: en/config.txt:202
#, priority:100
msgid "This was not the case in the initial release of this feature in v2.13.0, which only matched the realpath version. Configuration that wants to be compatible with the initial release of this feature needs to either specify only the realpath version, or both versions."
msgstr "在 v2.13.0 版本中，这个功能的初始版本不是这样的，它只匹配 realpath 版本。想要与这个功能的初始版本兼容的配置，要么只指定 realpath 版本，要么就指定两个版本。"

#. type: Plain text
#: en/config.txt:205
#, priority:100
msgid "Note that \"../\" is not special and will match literally, which is unlikely what you want."
msgstr "请注意，\"../\" 不是特殊的，将按字面意思匹配，这不太可能是你想要的。"

#. type: Title ~
#: en/config.txt:207 en/git-rev-parse.txt:393 en/git-rev-parse.txt:449
#, fuzzy, no-wrap, priority:100
msgid "Example"
msgstr "示例"

#. type: delimited block -
#: en/config.txt:214
#, no-wrap, priority:100
msgid ""
"# Core variables\n"
"[core]\n"
"\t; Don't trust file modes\n"
"\tfilemode = false\n"
msgstr ""
"# 核心变量\n"
"[core]\n"
"\t; 不信任文件模式\n"
"\tfilemode = false\n"

#. type: delimited block -
#: en/config.txt:219
#, no-wrap, priority:100
msgid ""
"# Our diff algorithm\n"
"[diff]\n"
"\texternal = /usr/local/bin/diff-wrapper\n"
"\trenames = true\n"
msgstr ""
"# 我们的差异算法\n"
"[diff]\n"
"\texternal = /usr/local/bin/diff-wrapper\n"
"\trenames = true\n"

#. type: delimited block -
#: en/config.txt:223
#, fuzzy, no-wrap, priority:100
msgid ""
"[branch \"devel\"]\n"
"\tremote = origin\n"
"\tmerge = refs/heads/devel\n"
msgstr ""
"[branch \"devel\"]\n"
"\tremote = origin\n"
"\tmerge = refs/heads/devel\n"

#. type: delimited block -
#: en/config.txt:228
#, no-wrap, priority:100
msgid ""
"# Proxy settings\n"
"[core]\n"
"\tgitProxy=\"ssh\" for \"kernel.org\"\n"
"\tgitProxy=default-proxy ; for the rest\n"
msgstr ""
"# 代理设置\n"
"[core]\n"
"\tgitProxy=\"ssh\" for \"kernel.org\"\n"
"\tgitProxy=default-proxy ; 其余为\n"

#. type: delimited block -
#: en/config.txt:233
#, fuzzy, no-wrap, priority:100
msgid ""
"[include]\n"
"\tpath = /path/to/foo.inc ; include by absolute path\n"
"\tpath = foo.inc ; find \"foo.inc\" relative to the current file\n"
"\tpath = ~/foo.inc ; find \"foo.inc\" in your `$HOME` directory\n"
msgstr ""
"[include]\n"
"\tpath = /path/to/foo.inc ; include by absolute path\n"
"\tpath = foo.inc ; find \"foo.inc\" relative to the current file\n"
"\tpath = ~/foo.inc ; find \"foo.inc\" in your `$HOME` directory\n"

#. type: delimited block -
#: en/config.txt:237
#, no-wrap, priority:100
msgid ""
"; include if $GIT_DIR is /path/to/foo/.git\n"
"[includeIf \"gitdir:/path/to/foo/.git\"]\n"
"\tpath = /path/to/foo.inc\n"
msgstr ""
";如果 $GIT_DIR 是 /path/to/foo/.git 就包含\n"
"[includeIf \"gitdir:/path/to/foo/.git\"]\n"
"\tpath = /path/to/foo.inc\n"

#. type: delimited block -
#: en/config.txt:241
#, fuzzy, no-wrap, priority:100
msgid ""
"; include for all repositories inside /path/to/group\n"
"[includeIf \"gitdir:/path/to/group/\"]\n"
"\tpath = /path/to/foo.inc\n"
msgstr ""
";包括 /path/to/group 内的所有仓库\n"
"[包括如果 \"gitdir:/path/to/group/\"]\n"
"\t路径 = /path/to/foo.inc\n"

#. type: delimited block -
#: en/config.txt:245
#, no-wrap, priority:100
msgid ""
"; include for all repositories inside $HOME/to/group\n"
"[includeIf \"gitdir:~/to/group/\"]\n"
"\tpath = /path/to/foo.inc\n"
msgstr ""
"; 包括 $HOME/to/group 内的所有仓库\n"
"[includeIf \"gitdir:~/to/group/\"]\n"
"\tpath = /path/to/foo.inc\n"

#. type: delimited block -
#: en/config.txt:251
#, no-wrap, priority:100
msgid ""
"; relative paths are always relative to the including\n"
"; file (if the condition is true); their location is not\n"
"; affected by the condition\n"
"[includeIf \"gitdir:/path/to/group/\"]\n"
"\tpath = foo.inc\n"
msgstr ""
"; 相对路径总是相对于包括\n"
"; 文件（如果条件为真）；其位置不受\n"
"; 的位置不受条件的影响。\n"
"[includeIf \"gitdir:/path/to/group/\"]\n"
"\tpath = foo.inc\n"

#. type: delimited block -
#: en/config.txt:256
#, no-wrap, priority:100
msgid ""
"; include only if we are in a worktree where foo-branch is\n"
"; currently checked out\n"
"[includeIf \"onbranch:foo-branch\"]\n"
"\tpath = foo.inc\n"
msgstr ""
"; 只有工作区当前检出了 foo-branch \n"
"; 才包括\n"
"[includeIf \"onbranch:foo-branch\"] 。\n"
"\t路径 = foo.inc\n"

#. type: delimited block -
#: en/config.txt:264
#, no-wrap, priority:100
msgid ""
"; include only if a remote with the given URL exists (note\n"
"; that such a URL may be provided later in a file or in a\n"
"; file read after this file is read, as seen in this example)\n"
"[includeIf \"hasconfig:remote.*.url:https://example.com/**\"]\n"
"\tpath = foo.inc\n"
"[remote \"origin\"]\n"
"\turl = https://example.com/git\n"
msgstr ""
"; 只有在给定 URL 的远程仓库存在的情况下才包括（注意\n"
"; 这样的URL可能在以后的文件中提供，或者在这个文件被读取后的一个\n"
"; 文件中提供，正如在这个例子中看到的那样)\n"
"[includeIf \"hasconfig:remote.*.url:https://example.com/*\" ]\n"
"\t路径 = foo.inc\n"
"[remote \"origin\"]\n"
"\turl = https://example.com/git\n"

#. type: Title ~
#: en/config.txt:267
#, fuzzy, no-wrap, priority:100
msgid "Values"
msgstr "值"

#. type: Plain text
#: en/config.txt:272
#, priority:100
msgid "Values of many variables are treated as a simple string, but there are variables that take values of specific types and there are rules as to how to spell them."
msgstr "许多变量的值都被当作一个简单的字符串，但有些变量取的是特定类型的值，对于如何拼写它们有一些规则。"

#. type: Labeled list
#: en/config.txt:273
#, fuzzy, no-wrap, priority:100
msgid "boolean"
msgstr "布尔"

#. type: Plain text
#: en/config.txt:278
#, priority:100
msgid "When a variable is said to take a boolean value, many synonyms are accepted for 'true' and 'false'; these are all case-insensitive."
msgstr "当一个变量被称为采取布尔值时，许多同义词被接受为 'true' 和 'false' ；这些都是不分大小写的。"

#. type: Labeled list
#: en/config.txt:279
#, fuzzy, no-wrap, priority:100
msgid "true"
msgstr "真"

#. type: Plain text
#: en/config.txt:282
#, priority:100
msgid "Boolean true literals are `yes`, `on`, `true`, and `1`.  Also, a variable defined without `= <value>` is taken as true."
msgstr "布尔真值是 `yes`、`on`、`true`和 `1`。 此外，一个没有 `= <值>` 的变量被认为是真。"

#. type: Labeled list
#: en/config.txt:283
#, fuzzy, no-wrap, priority:100
msgid "false"
msgstr "错误"

#. type: Plain text
#: en/config.txt:285
#, priority:100
msgid "Boolean false literals are `no`, `off`, `false`, `0` and the empty string."
msgstr "布尔假值是 `no`、`off`、`false`、`0` 和空字符串。"

#. type: Plain text
#: en/config.txt:289
#, priority:100
msgid "When converting a value to its canonical form using the `--type=bool` type specifier, 'git config' will ensure that the output is \"true\" or \"false\" (spelled in lowercase)."
msgstr "当使用 `--type=bool` 类型指定符将一个值转换为其规范形式时，'git config' 将确保输出为 \"true\" 或 \"false\"（用小写字母拼写）。"

#. type: Labeled list
#: en/config.txt:290
#, fuzzy, no-wrap, priority:100
msgid "integer"
msgstr "整数"

#. type: Plain text
#: en/config.txt:294
#, ignore-ellipsis, priority:100
msgid "The value for many variables that specify various sizes can be suffixed with `k`, `M`,... to mean \"scale the number by 1024\", \"by 1024x1024\", etc."
msgstr "许多指定各种尺寸的变量的值可以以 `k`、`M`...为后缀，表示 “以1024为比例的数字”、“以1024x1024为比例”，等等。"

#. type: Labeled list
#: en/config.txt:295 en/diff-options.txt:443 en/git-for-each-ref.txt:190
#, ignore-same, no-wrap, priority:280
msgid "color"
msgstr "color"

#. type: Plain text
#: en/config.txt:299
#, priority:100
msgid "The value for a variable that takes a color is a list of colors (at most two, one for foreground and one for background)  and attributes (as many as you want), separated by spaces."
msgstr "接受颜色的变量的值是一个颜色（最多两个，一个用于前景，一个用于背景）和属性（你想要多少就有多少）的列表，用空格分隔。"

#. type: Plain text
#: en/config.txt:305
#, priority:100
msgid "The basic colors accepted are `normal`, `black`, `red`, `green`, `yellow`, `blue`, `magenta`, `cyan`, `white` and `default`.  The first color given is the foreground; the second is the background.  All the basic colors except `normal` and `default` have a bright variant that can be specified by prefixing the color with `bright`, like `brightred`."
msgstr "接受的基本颜色是 `normal`、`black`、`red`、`green`、`yellow`、`blue`、`magenta`、`cyan`、`white` 和 `default`。 给出的第一种颜色是前景；第二种是背景。 除了`normal'和`default'之外，所有的基本颜色都有一个明亮的变体，可以通过在颜色前面加上`bright'来指定，比如`brightred'。"

#. type: Plain text
#: en/config.txt:309
#, priority:100
msgid "The color `normal` makes no change to the color. It is the same as an empty string, but can be used as the foreground color when specifying a background color alone (for example, \"normal red\")."
msgstr "颜色`normal`不会使颜色发生变化。它与空字符串相同，但在单独指定背景颜色时可以作为前景颜色（例如，\"normal red\"）。"

#. type: Plain text
#: en/config.txt:313
#, priority:100
msgid "The color `default` explicitly resets the color to the terminal default, for example to specify a cleared background. Although it varies between terminals, this is usually not the same as setting to \"white black\"."
msgstr "颜色`default` 明确地将颜色重置为终端的默认值，例如，指定一个清除的背景。虽然不同的终端有差异，但这通常与设置为 \"white black\" 不一样。"

#. type: Plain text
#: en/config.txt:318
#, priority:100
msgid "Colors may also be given as numbers between 0 and 255; these use ANSI 256-color mode (but note that not all terminals may support this).  If your terminal supports it, you may also specify 24-bit RGB values as hex, like `#ff0ab3`."
msgstr "颜色也可以用 0 到 255 之间的数字来表示；这些颜色使用 ANSI 256 色模式（但注意不是所有的终端都支持这个）。 如果你的终端支持，你也可以指定 24 位 RGB 值为十六进制，如 `#ff0ab3`。"

#. type: Plain text
#: en/config.txt:325
#, priority:100
msgid "The accepted attributes are `bold`, `dim`, `ul`, `blink`, `reverse`, `italic`, and `strike` (for crossed-out or \"strikethrough\" letters).  The position of any attributes with respect to the colors (before, after, or in between), doesn't matter. Specific attributes may be turned off by prefixing them with `no` or `no-` (e.g., `noreverse`, `no-ul`, etc)."
msgstr "可接受的属性是 `bold`、`dim`、`ul`、`blink`、`reverse`、`italic` 和 `strike`（用于划掉的字母或 “删除线”）。 任何属性相对于颜色的位置（在前，在后，或在中间）并不重要。特定的属性可以通过在它们前面加上 `no` 或 `no-` 来关闭（例如，`noreverse`，`no-ul`，等等）。"

#. type: Plain text
#: en/config.txt:330
#, priority:100
msgid "The pseudo-attribute `reset` resets all colors and attributes before applying the specified coloring. For example, `reset green` will result in a green foreground and default background without any active attributes."
msgstr "伪属性 `reset` 在应用指定的着色之前重置所有颜色和属性。例如，`reset green` 将导致一个绿色的前景和默认的背景，没有任何激活的属性。"

#. type: Plain text
#: en/config.txt:333
#, priority:100
msgid "An empty color string produces no color effect at all. This can be used to avoid coloring specific elements without disabling color entirely."
msgstr "一个空的颜色字符串根本不会产生任何颜色效果。这可以用来避免给特定的元素上色而不完全禁用颜色。"

#. type: Plain text
#: en/config.txt:342
#, priority:100
msgid "For git's pre-defined color slots, the attributes are meant to be reset at the beginning of each item in the colored output. So setting `color.decorate.branch` to `black` will paint that branch name in a plain `black`, even if the previous thing on the same output line (e.g.  opening parenthesis before the list of branch names in `log --decorate` output) is set to be painted with `bold` or some other attribute.  However, custom log formats may do more complicated and layered coloring, and the negated forms may be useful there."
msgstr "对于 git 的预定义颜色槽，属性是为了在彩色输出的每一项开始时被重置。所以将 `color.decorate.branch` 设置为 `black` 会将该分支名称涂成普通的 `black`，即使同一输出行中的前一个东西（例如`log -decorate`输出中的分支名称列表前的括号）被设置为 `bold` 或其他属性。 然而，自定义的日志格式可能会做更复杂和分层的着色，而否定的形式在那里可能很有用。"

#. type: Labeled list
#: en/config.txt:343
#, fuzzy, no-wrap, priority:100
msgid "pathname"
msgstr "pathname"

#. type: Plain text
#: en/config.txt:349
#, priority:100
msgid "A variable that takes a pathname value can be given a string that begins with \"`~/`\" or \"`~user/`\", and the usual tilde expansion happens to such a string: `~/` is expanded to the value of `$HOME`, and `~user/` to the specified user's home directory."
msgstr "一个获取路径名值的变量可以被赋予一个以 \"`~/`\" 或 \"`~user/`\" 开头的字符串，通常的 tilde 扩展会发生在这样一个字符串上： `~/` 被扩展为 `$HOME` 的值，而 `~user/` 被扩展为指定用户的主目录。"

#. type: Plain text
#: en/config.txt:358
#, priority:100
msgid "If a path starts with `%(prefix)/`, the remainder is interpreted as a path relative to Git's \"runtime prefix\", i.e. relative to the location where Git itself was installed. For example, `%(prefix)/bin/` refers to the directory in which the Git executable itself lives. If Git was compiled without runtime prefix support, the compiled-in prefix will be substituted instead. In the unlikely event that a literal path needs to be specified that should _not_ be expanded, it needs to be prefixed by `./`, like so: `./%(prefix)/bin`."
msgstr "如果一个路径以 `%(prefix)/` 开头，其余部分将被解释为相对于 Gi t的 \"运行时前缀\" 的路径，即相对于 Git 本身安装的位置。例如，`%(prefix)/bin/` 指的是 Git 可执行文件本身所在的目录。如果 Git 在编译时不支持运行时前缀，那么编译时的前缀将被替代。在不太可能的情况下，如果需要指定一个不应该被扩展的字面路径，需要以 `./` 为前缀，就像这样： `./%（前缀）/bin`。"

#. type: Title ~
#: en/config.txt:361
#, fuzzy, no-wrap, priority:100
msgid "Variables"
msgstr "变量"

#. type: Plain text
#: en/config.txt:366
#, priority:100
msgid "Note that this list is non-comprehensive and not necessarily complete.  For command-specific variables, you will find a more detailed description in the appropriate manual page."
msgstr "请注意，这个列表并不全面，也不一定完整。 对于特定命令的变量，你会在相应的手册页中找到更详细的描述。"

#. type: Plain text
#: en/config.txt:371
#, priority:100
msgid "Other git-related tools may and do use their own variables.  When inventing new variables for use in your own tool, make sure their names do not conflict with those that are used by Git itself and other popular tools, and describe them in your documentation."
msgstr "其他与 git 相关的工具可能也确实使用了他们自己的变量。 当发明新的变量用于自己的工具时，要确保它们的名字不与 Git 本身和其他流行的工具所使用的名字冲突，并在你的文档中描述它们。"

#. type: Labeled list
#: en/config/merge.txt:1
#, ignore-same, no-wrap, priority:240
msgid "merge.conflictStyle"
msgstr "merge.conflictStyle"

#. type: Plain text
#: en/config/merge.txt:15
#, fuzzy, priority:240
#| msgid "Specify the style in which conflicted hunks are written out to working tree files upon merge.  The default is \"merge\", which shows a `<<<<<<<` conflict marker, changes made by one side, a `=======` marker, changes made by the other side, and then a `>>>>>>>` marker.  An alternate style, \"diff3\", adds a `|||||||` marker and the original text before the `=======` marker."
msgid "Specify the style in which conflicted hunks are written out to working tree files upon merge.  The default is \"merge\", which shows a `<<<<<<<` conflict marker, changes made by one side, a `=======` marker, changes made by the other side, and then a `>>>>>>>` marker.  An alternate style, \"diff3\", adds a `|||||||` marker and the original text before the `=======` marker.  The \"merge\" style tends to produce smaller conflict regions than diff3, both because of the exclusion of the original text, and because when a subset of lines match on the two sides they are just pulled out of the conflict region.  Another alternate style, \"zdiff3\", is similar to diff3 but removes matching lines on the two sides from the conflict region when those matching lines appear near either the beginning or end of a conflict region."
msgstr "指定在合并时将冲突块写入工作树文件的样式。  默认是 \"merge\"，显示一个`<<<<<<<`冲突标记，一方的修改，一个`=======`标记，另一方的修改，然后是`>>>>>>>`标记。  另一种样式，\"diff3\"，增加了一个`|||||||`标记，并在`=======`标记前增加了原始文本。"

#. type: Labeled list
#: en/config/merge.txt:16
#, ignore-same, no-wrap, priority:240
msgid "merge.defaultToUpstream"
msgstr "merge.defaultToUpstream"

#. type: Plain text
#: en/config/merge.txt:25
#, fuzzy, priority:240
#| msgid "If merge is called without any commit argument, merge the upstream branches configured for the current branch by using their last observed values stored in their remote-tracking branches.  The values of the `branch.<current branch>.merge` that name the branches at the remote named by `branch.<current branch>.remote` are consulted, and then they are mapped via `remote.<remote>.fetch` to their corresponding remote-tracking branches, and the tips of these tracking branches are merged."
msgid "If merge is called without any commit argument, merge the upstream branches configured for the current branch by using their last observed values stored in their remote-tracking branches.  The values of the `branch.<current branch>.merge` that name the branches at the remote named by `branch.<current branch>.remote` are consulted, and then they are mapped via `remote.<remote>.fetch` to their corresponding remote-tracking branches, and the tips of these tracking branches are merged. Defaults to true."
msgstr "如果调用 merge 时没有任何提交参数，则通过使用存储在其远程跟踪分支中的最后观察值来合并为当前分支配置的上游分支。  `branch.<current branch>.merge`的值会被查阅，这些值命名了由`branch.<current branch>.remote`命名的远程分支，然后通过`remote.<remote>.fetch`将它们映射到相应的远程跟踪分支，并合并这些跟踪分支的提示。"

#. type: Labeled list
#: en/config/merge.txt:26
#, ignore-same, no-wrap, priority:240
msgid "merge.ff"
msgstr "merge.ff"

#. type: Plain text
#: en/config/merge.txt:35
#, priority:240
msgid "By default, Git does not create an extra merge commit when merging a commit that is a descendant of the current commit. Instead, the tip of the current branch is fast-forwarded. When set to `false`, this variable tells Git to create an extra merge commit in such a case (equivalent to giving the `--no-ff` option from the command line). When set to `only`, only such fast-forward merges are allowed (equivalent to giving the `--ff-only` option from the command line)."
msgstr "默认情况下，当合并当前提交的后裔提交时，Git 不会创建一个额外的合并提交。相反，当前分支的顶端会被快进。当设置为 \"false \"时，这个变量告诉Git在这种情况下创建一个额外的合并提交（相当于在命令行中给出 \"no-ff \"选项）。当设置为`only`时，只允许这种快进合并（相当于从命令行给出`--ff-only`选项）。"

#. type: Labeled list
#: en/config/merge.txt:36
#, ignore-same, no-wrap, priority:240
msgid "merge.verifySignatures"
msgstr "merge.verifySignatures"

#. type: Plain text
#: en/config/merge.txt:39
#, priority:240
msgid "If true, this is equivalent to the --verify-signatures command line option. See linkgit:git-merge[1] for details."
msgstr "如果为真，这等同于 --verify-signatures 命令行选项。详见 linkgit:git-merge[1]。"

#. type: Labeled list
#: en/config/merge.txt:42
#, ignore-same, no-wrap, priority:240
msgid "merge.renameLimit"
msgstr "merge.renameLimit"

#. type: Plain text
#: en/config/merge.txt:49
#, fuzzy, priority:240
#| msgid "The number of files to consider when performing rename detection during a merge; if not specified, defaults to the value of diff.renameLimit. This setting has no effect if rename detection is turned off."
msgid "The number of files to consider in the exhaustive portion of rename detection during a merge.  If not specified, defaults to the value of diff.renameLimit.  If neither merge.renameLimit nor diff.renameLimit are specified, currently defaults to 7000.  This setting has no effect if rename detection is turned off."
msgstr "在合并过程中执行重名检测时要考虑的文件数量；如果没有指定，默认为diff.renameLimit的值。如果重名检测被关闭，这个设置就没有作用。"

#. type: Labeled list
#: en/config/merge.txt:50
#, ignore-same, no-wrap, priority:240
msgid "merge.renames"
msgstr "merge.renames"

#. type: Plain text
#: en/config/merge.txt:54
#, priority:240
msgid "Whether Git detects renames.  If set to \"false\", rename detection is disabled. If set to \"true\", basic rename detection is enabled.  Defaults to the value of diff.renames."
msgstr "Git是否会检测重名。  如果设置为 \"false\"，重名检测被禁用。如果设置为 \"true\"，则启用基本重名检测。  默认为 diff.renames 的值。"

#. type: Labeled list
#: en/config/merge.txt:55
#, ignore-same, no-wrap, priority:240
msgid "merge.directoryRenames"
msgstr "merge.directoryRenames"

#. type: Plain text
#: en/config/merge.txt:67
#, priority:240
msgid "Whether Git detects directory renames, affecting what happens at merge time to new files added to a directory on one side of history when that directory was renamed on the other side of history.  If merge.directoryRenames is set to \"false\", directory rename detection is disabled, meaning that such new files will be left behind in the old directory.  If set to \"true\", directory rename detection is enabled, meaning that such new files will be moved into the new directory.  If set to \"conflict\", a conflict will be reported for such paths.  If merge.renames is false, merge.directoryRenames is ignored and treated as false.  Defaults to \"conflict\"."
msgstr "Git是否检测目录重名，影响在合并时对历史一侧的目录被重命名时加入的新文件的处理。  如果merge.directoryRenames设置为 \"false\"，目录重名检测将被禁用，这意味着这些新文件将被遗留在旧目录中。  如果设置为 \"true\"，目录重名检测被启用，意味着这样的新文件将被移到新目录中。  如果设置为 \"冲突\"，将报告此类路径的冲突。  如果merge.renames为false，merge.directoryRenames将被忽略并被视为false。  默认为 \"冲突\"。"

#. type: Labeled list
#: en/config/merge.txt:68
#, ignore-same, no-wrap, priority:240
msgid "merge.renormalize"
msgstr "merge.renormalize"

#. type: Plain text
#: en/config/merge.txt:77
#, priority:240
msgid "Tell Git that canonical representation of files in the repository has changed over time (e.g. earlier commits record text files with CRLF line endings, but recent ones use LF line endings).  In such a repository, Git can convert the data recorded in commits to a canonical form before performing a merge to reduce unnecessary conflicts.  For more information, see section \"Merging branches with differing checkin/checkout attributes\" in linkgit:gitattributes[5]."
msgstr "告诉 Git 仓库中文件的正则表示法随着时间的推移而改变（例如，早期的提交记录文本文件使用 CRLF 行结尾，但最近的提交使用 LF 行结尾）。  在这样的仓库中，Git 可以在执行合并之前将提交的数据转换为规范的形式，以减少不必要的冲突。  更多信息，请参阅 linkgit:gitattributes[5] 中的 \"合并具有不同签入/签出属性的分支 \"一节。"

#. type: Labeled list
#: en/config/merge.txt:78
#, ignore-same, no-wrap, priority:240
msgid "merge.stat"
msgstr "merge.stat"

#. type: Plain text
#: en/config/merge.txt:81
#, priority:240
msgid "Whether to print the diffstat between ORIG_HEAD and the merge result at the end of the merge.  True by default."
msgstr "是否在合并结束后打印ORIG_HEAD和合并结果之间的差异统计表。  默认为 \"真\"。"

#. type: Labeled list
#: en/config/merge.txt:82
#, ignore-same, no-wrap, priority:240
msgid "merge.autoStash"
msgstr "merge.autoStash"

#. type: Plain text
#: en/config/merge.txt:91
#, priority:240
msgid "When set to true, automatically create a temporary stash entry before the operation begins, and apply it after the operation ends.  This means that you can run merge on a dirty worktree.  However, use with care: the final stash application after a successful merge might result in non-trivial conflicts.  This option can be overridden by the `--no-autostash` and `--autostash` options of linkgit:git-merge[1].  Defaults to false."
msgstr "当设置为 \"true \"时，在操作开始前自动创建一个临时的储藏库条目，并在操作结束后应用它。  这意味着你可以在一个肮脏的工作树上运行merge。  然而，要小心使用：在成功的合并之后，最后的储藏库应用可能会导致非实质性的冲突。  这个选项可以被 linkgit:git-merge[1] 的 `--no-autostash` 和 `--autostash` 选项覆盖。  默认为false。"

#. type: Labeled list
#: en/config/merge.txt:92
#, ignore-same, no-wrap, priority:240
msgid "merge.tool"
msgstr "merge.tool"

#. type: Plain text
#: en/config/merge.txt:97
#, priority:240
msgid "Controls which merge tool is used by linkgit:git-mergetool[1].  The list below shows the valid built-in values.  Any other value is treated as a custom merge tool and requires that a corresponding mergetool.<tool>.cmd variable is defined."
msgstr "控制linkgit:git-mergetool[1]使用哪个合并工具。  下面的列表显示了有效的内置值。  任何其他值都被视为自定义的合并工具，需要定义一个相应的mergetool.<tool>.cmd变量。"

#. type: Labeled list
#: en/config/merge.txt:98
#, ignore-same, no-wrap, priority:240
msgid "merge.guitool"
msgstr "merge.guitool"

#. type: Plain text
#: en/config/merge.txt:103
#, priority:240
msgid "Controls which merge tool is used by linkgit:git-mergetool[1] when the -g/--gui flag is specified. The list below shows the valid built-in values.  Any other value is treated as a custom merge tool and requires that a corresponding mergetool.<guitool>.cmd variable is defined."
msgstr "控制linkgit:git-mergetool[1]在指定-g/-gui标志时使用的合并工具。下面的列表显示了有效的内置值。  任何其他值都被视为自定义的合并工具，需要定义一个相应的mergetool.<guitool>.cmd变量。"

#. type: Labeled list
#: en/config/merge.txt:106
#, ignore-same, no-wrap, priority:240
msgid "merge.verbosity"
msgstr "merge.verbosity"

#. type: Plain text
#: en/config/merge.txt:113
#, priority:240
msgid "Controls the amount of output shown by the recursive merge strategy.  Level 0 outputs nothing except a final error message if conflicts were detected. Level 1 outputs only conflicts, 2 outputs conflicts and file changes.  Level 5 and above outputs debugging information.  The default is level 2.  Can be overridden by the `GIT_MERGE_VERBOSITY` environment variable."
msgstr "控制递归合并策略所显示的输出量。  0级除了在检测到冲突时有一个最终的错误信息外，什么都不输出。1级只输出冲突，2级输出冲突和文件变化。  5级及以上输出调试信息。  默认是第2级。  可以通过`GIT_MERGE_VERBOSITY`环境变量覆盖。"

#. type: Labeled list
#: en/config/merge.txt:114
#, no-wrap, priority:240
msgid "merge.<driver>.name"
msgstr "合并.<driver>.name"

#. type: Plain text
#: en/config/merge.txt:117
#, priority:240
msgid "Defines a human-readable name for a custom low-level merge driver.  See linkgit:gitattributes[5] for details."
msgstr "为自定义的低级合并驱动定义了一个人类可读的名字。  详情见 linkgit:gitattributes[5]。"

#. type: Labeled list
#: en/config/merge.txt:118
#, no-wrap, priority:240
msgid "merge.<driver>.driver"
msgstr "merge.<driver>.driver"

#. type: Plain text
#: en/config/merge.txt:121
#, priority:240
msgid "Defines the command that implements a custom low-level merge driver.  See linkgit:gitattributes[5] for details."
msgstr "定义实现自定义低级合并驱动程序的命令。详见链接git:gitattributes[5]。"

#. type: Labeled list
#: en/config/merge.txt:122
#, fuzzy, no-wrap, priority:240
msgid "merge.<driver>.recursive"
msgstr "merge.<driver>.recursive"

#. type: Plain text
#: en/config/merge.txt:125
#, priority:240
msgid "Names a low-level merge driver to be used when performing an internal merge between common ancestors.  See linkgit:gitattributes[5] for details."
msgstr "在执行共同祖先之间的内部合并时，命名一个低级别的合并驱动。  详情见 linkgit:gitattributes[5]。"

#. type: Labeled list
#: en/config/fmt-merge-msg.txt:1
#, ignore-same, no-wrap, priority:240
msgid "merge.branchdesc"
msgstr "merge.branchdesc"

#. type: Plain text
#: en/config/fmt-merge-msg.txt:5
#, fuzzy, priority:240
msgid "In addition to branch names, populate the log message with the branch description text associated with them.  Defaults to false."
msgstr "除了分支名称之外，还使用与其关联的分支描述文本填充日志消息。默认为 false。"

#. type: Labeled list
#: en/config/fmt-merge-msg.txt:6
#, ignore-same, no-wrap, priority:240
msgid "merge.log"
msgstr "merge.log"

#. type: Plain text
#: en/config/fmt-merge-msg.txt:11
#, fuzzy, priority:240
msgid "In addition to branch names, populate the log message with at most the specified number of one-line descriptions from the actual commits that are being merged.  Defaults to false, and true is a synonym for 20."
msgstr "除了分支名称外，在日志信息中最多加入指定数量的被合并的实际提交的单行描述。  默认为false，true是20的同义词。"

#. type: Labeled list
#: en/config/fmt-merge-msg.txt:12
#, ignore-same, no-wrap, priority:240
msgid "merge.suppressDest"
msgstr "merge.suppressDest"

#. type: Plain text
#: en/config/fmt-merge-msg.txt:18
#, fuzzy, priority:240
msgid "By adding a glob that matches the names of integration branches to this multi-valued configuration variable, the default merge message computed for merges into these integration branches will omit \"into <branch name>\" from its title."
msgstr "通过向这个多值配置变量添加一个匹配集成分支名称的 glob，为合并到这些集成分支计算的默认合并消息将在其标题中省略“into <branch name>”。"

#. type: Plain text
#: en/config/fmt-merge-msg.txt:22
#, priority:240
msgid "An element with an empty value can be used to clear the list of globs accumulated from previous configuration entries.  When there is no `merge.suppressDest` variable defined, the default value of `master` is used for backward compatibility."
msgstr "一个空值的元素可以用来清除以前配置项积累的globs列表。  当没有定义`merge.suppressDest`变量时，为了向后兼容，会使用默认值`master`。"

#. type: Title -
#: en/date-formats.txt:2
#, fuzzy, no-wrap, priority:280
msgid "DATE FORMATS"
msgstr "日期格式"

#. type: Plain text
#: en/date-formats.txt:6
#, fuzzy, priority:280
msgid "The `GIT_AUTHOR_DATE` and `GIT_COMMITTER_DATE` environment variables support the following date formats:"
msgstr "`GIT_AUTHOR_DATE`, `GIT_COMMITTER_DATE` 环境变量"

#. type: Labeled list
#: en/date-formats.txt:7
#, fuzzy, no-wrap, priority:280
msgid "Git internal format"
msgstr "Git 内部格式"

#. type: Plain text
#: en/date-formats.txt:12
#, fuzzy, priority:280
msgid "It is `<unix-timestamp> <time-zone-offset>`, where `<unix-timestamp>` is the number of seconds since the UNIX epoch.  `<time-zone-offset>` is a positive or negative offset from UTC.  For example CET (which is 1 hour ahead of UTC) is `+0100`."
msgstr "`<unix  时间戳> <时区偏移量>`，其中 `<unix 时间戳>` 是自 UNIX epoch 以来的秒数。 `<时区偏移量>` 是相对于 UTC 的正或负偏移量。例如，CET（比 UTC 提前1小时）为 `+0100`。"

#. type: Labeled list
#: en/date-formats.txt:13
#, fuzzy, no-wrap, priority:280
msgid "RFC 2822"
msgstr "RFC 2822"

#. type: Plain text
#: en/date-formats.txt:16
#, fuzzy, priority:280
msgid "The standard email format as described by RFC 2822, for example `Thu, 07 Apr 2005 22:13:13 +0200`."
msgstr "由 RFC 2822 描述的标准电子邮件格式，例如 `Thu, 07 Apr 2005 22:13:13 +0200`。"

#. type: Labeled list
#: en/date-formats.txt:17
#, fuzzy, no-wrap, priority:280
msgid "ISO 8601"
msgstr "ISO 8601"

#. type: Plain text
#: en/date-formats.txt:23
#, fuzzy, priority:280
#| msgid "Time and date specified by the ISO 8601 standard, for example `2005-04-07T22:13:13`. The parser accepts a space instead of the `T` character as well."
msgid "Time and date specified by the ISO 8601 standard, for example `2005-04-07T22:13:13`. The parser accepts a space instead of the `T` character as well. Fractional parts of a second will be ignored, for example `2005-04-07T22:13:13.019` will be treated as `2005-04-07T22:13:13`."
msgstr "ISO 8601 标准规定的时间和日期，例如 `2005-04-07T22:13:13`。解析器也接受将 `T` 替换为空格。"

#. type: Plain text
#: en/date-formats.txt:26
#, fuzzy, priority:280
msgid "In addition, the date part is accepted in the following formats: `YYYY.MM.DD`, `MM/DD/YYYY` and `DD.MM.YYYY`."
msgstr "此外，日期部分还接受以下格式：`YYYY.MM.DD`，`MM/DD/YYYY` 和 `DD.MM.YYYY`。"

#. type: Plain text
#: en/date-formats.txt:31
#, priority:280
msgid "In addition to recognizing all date formats above, the `--date` option will also try to make sense of other, more human-centric date formats, such as relative dates like \"yesterday\" or \"last Friday at noon\"."
msgstr "除了识别上述所有日期格式外，`--date` 选项还将尝试理解其它非标准化的日期格式，如 \"昨天\" 或 \"上周五中午\" 等相对日期。"

#. type: Title -
#: en/diff-format.txt:2
#, fuzzy, no-wrap, priority:280
msgid "Raw output format"
msgstr "原始输出格式"

#. type: Plain text
#: en/diff-format.txt:6
#, fuzzy, priority:280
msgid "The raw output format from \"git-diff-index\", \"git-diff-tree\", \"git-diff-files\" and \"git diff --raw\" are very similar."
msgstr "\"git-diff-index\"，\"git-diff-tree\"，\"git-diff-files\" 和 \"git diff --raw\" 的原始输出格式非常相似。"

#. type: Plain text
#: en/diff-format.txt:9
#, fuzzy, priority:280
msgid "These commands all compare two sets of things; what is compared differs:"
msgstr "这些命令都比较两组事物。但比较的内容有所不同："

#. type: Labeled list
#: en/diff-format.txt:10
#, no-wrap, priority:280
msgid "git-diff-index <tree-ish>"
msgstr "git-diff-index <tree-ish>"

#. type: Plain text
#: en/diff-format.txt:12
#, fuzzy, priority:280
msgid "compares the <tree-ish> and the files on the filesystem."
msgstr "比较 <文件树> 和文件系统上的文件。"

#. type: Labeled list
#: en/diff-format.txt:13
#, no-wrap, priority:280
msgid "git-diff-index --cached <tree-ish>"
msgstr "git-diff-index --cached <tree-ish>"

#. type: Plain text
#: en/diff-format.txt:15
#, fuzzy, priority:280
msgid "compares the <tree-ish> and the index."
msgstr "比较 <文件树> 和索引。"

#. type: Labeled list
#: en/diff-format.txt:16
#, ignore-ellipsis, no-wrap, priority:280
msgid "git-diff-tree [-r] <tree-ish-1> <tree-ish-2> [<pattern>...]"
msgstr "git-diff-tree [-r] <tree-ish-1> <tree-ish-2> [<pattern>...]"

#. type: Plain text
#: en/diff-format.txt:18
#, fuzzy, priority:280
msgid "compares the trees named by the two arguments."
msgstr "比较由两个参数传递的文件树。"

#. type: Labeled list
#: en/diff-format.txt:19
#, ignore-ellipsis, no-wrap, priority:280
msgid "git-diff-files [<pattern>...]"
msgstr "git-diff-files [<pattern>...]"

#. type: Plain text
#: en/diff-format.txt:21
#, fuzzy, priority:280
msgid "compares the index and the files on the filesystem."
msgstr "比较索引和文件系统上的文件。"

#. type: Plain text
#: en/diff-format.txt:25
#, fuzzy, priority:280
msgid "The \"git-diff-tree\" command begins its output by printing the hash of what is being compared. After that, all the commands print one output line per changed file."
msgstr "\"git-diff-tree\" 命令在最开始输出被比较对象的哈希值。之后，所有命令都会为每个更改的文件打印一个输出行。"

#. type: Plain text
#: en/diff-format.txt:27
#, fuzzy, priority:280
msgid "An output line is formatted this way:"
msgstr "输出行的格式如下："

#. type: delimited block -
#: en/diff-format.txt:35
#, fuzzy, no-wrap, priority:280
msgid ""
"in-place edit  :100644 100644 bcd1234 0123456 M file0\n"
"copy-edit      :100644 100644 abcd123 1234567 C68 file1 file2\n"
"rename-edit    :100644 100644 abcd123 1234567 R86 file1 file3\n"
"create         :000000 100644 0000000 1234567 A file4\n"
"delete         :100644 000000 1234567 0000000 D file5\n"
"unmerged       :000000 000000 0000000 0000000 U file6\n"
msgstr ""
"in-place edit  :100644 100644 bcd1234 0123456 M file0\n"
"copy-edit      :100644 100644 abcd123 1234567 C68 file1 file2\n"
"rename-edit    :100644 100644 abcd123 1234567 R86 file1 file3\n"
"create         :000000 100644 0000000 1234567 A file4\n"
"delete         :100644 000000 1234567 0000000 D file5\n"
"unmerged       :000000 000000 0000000 0000000 U file6\n"

#. type: Plain text
#: en/diff-format.txt:38
#, fuzzy, priority:280
msgid "That is, from the left to the right:"
msgstr "含义如下，从左到右依次："

#. type: Plain text
#: en/diff-format.txt:40
#, fuzzy, priority:280
msgid "a colon."
msgstr "冒号。"

#. type: Plain text
#: en/diff-format.txt:41
#, fuzzy, priority:280
msgid "mode for \"src\"; 000000 if creation or unmerged."
msgstr "\"src\"（源文件）的模式；如果是新建或是未合并的，则为 000000。"

#. type: Plain text
#: en/diff-format.txt:42 en/diff-format.txt:44 en/diff-format.txt:46 en/diff-format.txt:48
#, fuzzy, priority:280
msgid "a space."
msgstr "空格。"

#. type: Plain text
#: en/diff-format.txt:43
#, fuzzy, priority:280
msgid "mode for \"dst\"; 000000 if deletion or unmerged."
msgstr "\"dst\"(目标文件）的模式；如果被删除或未合并则为 000000。"

#. type: Plain text
#: en/diff-format.txt:45
#, fuzzy, priority:280
msgid "sha1 for \"src\"; 0\\{40\\} if creation or unmerged."
msgstr "\"src\"（源文件）的 sha1 值；如果为新建或未合并则为 0\\{40\\}。"

#. type: Plain text
#: en/diff-format.txt:47
#, fuzzy, priority:280
msgid "sha1 for \"dst\"; 0\\{40\\} if deletion, unmerged or \"work tree out of sync with the index\"."
msgstr "\"dst\"（目标文件）的 sha1 值；如果为新建、未合并或 \"参见工作树\"，则为 0\\{40\\}。"

#. type: Plain text
#: en/diff-format.txt:49
#, fuzzy, priority:280
msgid "status, followed by optional \"score\" number."
msgstr "状态，在可选值 \"score\" 之后。"

#. type: Plain text
#: en/diff-format.txt:50
#, fuzzy, priority:280
msgid "a tab or a NUL when `-z` option is used."
msgstr "当使用 `-z` 选项时为制表符或 NUL。"

#. type: Plain text
#: en/diff-format.txt:51
#, fuzzy, priority:280
msgid "path for \"src\""
msgstr "\"src\" 的路径"

#. type: Plain text
#: en/diff-format.txt:52
#, fuzzy, priority:280
msgid "a tab or a NUL when `-z` option is used; only exists for C or R."
msgstr "使用 `-z` 选项时为制表符或 NUL；仅当状态为 C 或 R 时存在。"

#. type: Plain text
#: en/diff-format.txt:53
#, fuzzy, priority:280
msgid "path for \"dst\"; only exists for C or R."
msgstr "\"dst\" 的路径；仅当状态为 C 或 R 时存在。"

#. type: Plain text
#: en/diff-format.txt:54
#, fuzzy, priority:280
msgid "an LF or a NUL when `-z` option is used, to terminate the record."
msgstr "当使用 `-z` 选项时为 LF 或 NUL，用于终止记录。"

#. type: Plain text
#: en/diff-format.txt:56
#, fuzzy, priority:280
msgid "Possible status letters are:"
msgstr "可能的状态字母为："

#. type: Plain text
#: en/diff-format.txt:58
#, fuzzy, priority:280
msgid "A: addition of a file"
msgstr "A：文件新增部分"

#. type: Plain text
#: en/diff-format.txt:59
#, fuzzy, priority:280
msgid "C: copy of a file into a new one"
msgstr "C：复制到一个新文件"

#. type: Plain text
#: en/diff-format.txt:60
#, fuzzy, priority:280
msgid "D: deletion of a file"
msgstr "D：文件删除部分"

#. type: Plain text
#: en/diff-format.txt:61
#, fuzzy, priority:280
msgid "M: modification of the contents or mode of a file"
msgstr "M：文件内容或文件模式修改"

#. type: Plain text
#: en/diff-format.txt:62
#, fuzzy, priority:280
msgid "R: renaming of a file"
msgstr "R：文件重命名"

#. type: Plain text
#: en/diff-format.txt:63
#, fuzzy, priority:280
msgid "T: change in the type of the file (regular file, symbolic link or submodule)"
msgstr "T：文件类型改变"

#. type: Plain text
#: en/diff-format.txt:65
#, fuzzy, priority:280
msgid "U: file is unmerged (you must complete the merge before it can be committed)"
msgstr "U：文件未合并（你必须在提交之前完成合并）"

#. type: Plain text
#: en/diff-format.txt:66
#, fuzzy, priority:280
msgid "X: \"unknown\" change type (most probably a bug, please report it)"
msgstr "X：\"unknown\"（未知）更改类型（可能为错误，请报告）"

#. type: Plain text
#: en/diff-format.txt:71
#, fuzzy, priority:280
msgid "Status letters C and R are always followed by a score (denoting the percentage of similarity between the source and target of the move or copy).  Status letter M may be followed by a score (denoting the percentage of dissimilarity) for file rewrites."
msgstr "状态字母 C 和 R 后面总是一个分数（表示移动或复制的源与目标之间的相似性百分比）。状态字母M后面可能有文件重写的分数（表示相异百分比）。"

#. type: Plain text
#: en/diff-format.txt:74
#, fuzzy, priority:280
msgid "The sha1 for \"dst\" is shown as all 0's if a file on the filesystem is out of sync with the index."
msgstr "如果文件是文件系统上的新文件，并且与索引不同步，则 <sha1> 将显示为全0。"

#. type: Labeled list
#: en/diff-format.txt:76 en/git-svn.txt:499 en/git-svn.txt:539
#, fuzzy, no-wrap, priority:280
msgid "Example:"
msgstr "例如："

#. type: delimited block -
#: en/diff-format.txt:79
#, fuzzy, no-wrap, priority:280
msgid ":100644 100644 5be4a4a 0000000 M file.c\n"
msgstr ":100644 100644 5be4a4a 0000000 M file.c\n"

#. type: Plain text
#: en/diff-format.txt:85 en/git-ls-files.txt:255 en/git-ls-tree.txt:134
#, fuzzy, priority:280
msgid "Without the `-z` option, pathnames with \"unusual\" characters are quoted as explained for the configuration variable `core.quotePath` (see linkgit:git-config[1]).  Using `-z` the filename is output verbatim and the line is terminated by a NUL byte."
msgstr "如果没有 `-z` 选项，带 \"不常见\" 字符的路径名会被加上引号，正如配置变量 \"core.quotePath\" 所解释的那样（参见 linkgit:git-config[1]）。  使用 `-z` 选项，文件名将被逐字输出，并以 NUL 字节结束。"

#. type: Title -
#: en/diff-format.txt:87
#, fuzzy, no-wrap, priority:280
msgid "diff format for merges"
msgstr "合并的差异格式"

#. type: Plain text
#: en/diff-format.txt:93
#, fuzzy, priority:280
msgid "\"git-diff-tree\", \"git-diff-files\" and \"git-diff --raw\" can take `-c` or `--cc` option to generate diff output also for merge commits.  The output differs from the format described above in the following way:"
msgstr "\"git-diff-tree\"、\"git-diff-files\" 和 \"git-diff --raw\" 可以使用 `-c` 或 `--cc` 选项来生成差异输出，也可以用于合并提交。其输出与上面描述的格式有以下不同："

#. type: Plain text
#: en/diff-format.txt:95
#, fuzzy, priority:280
msgid "there is a colon for each parent"
msgstr "每个父提交都有一个冒号"

#. type: Plain text
#: en/diff-format.txt:96
#, fuzzy, priority:280
msgid "there are more \"src\" modes and \"src\" sha1"
msgstr "有更多的 \"src\" 文件模式和 \"src\" sha1"

#. type: Plain text
#: en/diff-format.txt:97
#, fuzzy, priority:280
msgid "status is concatenated status characters for each parent"
msgstr "状态是每个父提交的状态字符的合并"

#. type: Plain text
#: en/diff-format.txt:98
#, fuzzy, priority:280
msgid "no optional \"score\" number"
msgstr "无可选的分数（\"score\"）数字"

#. type: Plain text
#: en/diff-format.txt:99
#, fuzzy, priority:280
msgid "tab-separated pathname(s) of the file"
msgstr "以制表符分隔的文件路径名"

#. type: Plain text
#: en/diff-format.txt:104
#, fuzzy, priority:280
msgid "For `-c` and `--cc`, only the destination or final path is shown even if the file was renamed on any side of history.  With `--combined-all-paths`, the name of the path in each parent is shown followed by the name of the path in the merge commit."
msgstr "对于 `-c` 和 `--cc` 选项，即使文件在历史中的任何一边被重命名，也只显示目标路径或最终路径。使用 `--combined-all-paths` 选项，则每个父提交中的路径名称会在合并提交中的路径名称后面显示。"

#. type: Plain text
#: en/diff-format.txt:106
#, fuzzy, priority:280
msgid "Examples for `-c` and `--cc` without `--combined-all-paths`:"
msgstr "以下为带 `-c` 和 `--cc` 选项且不带 `--combined-all-paths` 选项的示例："

#. type: delimited block -
#: en/diff-format.txt:110
#, fuzzy, no-wrap, priority:280
msgid ""
"::100644 100644 100644 fabadb8 cc95eb0 4866510 MM\tdesc.c\n"
"::100755 100755 100755 52b7a2d 6d1ac04 d2ac7d7 RM\tbar.sh\n"
"::100644 100644 100644 e07d6c5 9042e82 ee91881 RR\tphooey.c\n"
msgstr ""
"::100644 100644 100644 fabadb8 cc95eb0 4866510 MM\tdesc.c\n"
"::100755 100755 100755 52b7a2d 6d1ac04 d2ac7d7 RM\tbar.sh\n"
"::100644 100644 100644 e07d6c5 9042e82 ee91881 RR\tphooey.c\n"

#. type: Plain text
#: en/diff-format.txt:113
#, fuzzy, priority:280
msgid "Examples when `--combined-all-paths` added to either `-c` or `--cc`:"
msgstr "以下为使用 `--combined-all-paths` 选项且使用 `-c` 或 `--cc` 选项的示例:"

#. type: delimited block -
#: en/diff-format.txt:118
#, fuzzy, no-wrap, priority:280
msgid ""
"::100644 100644 100644 fabadb8 cc95eb0 4866510 MM\tdesc.c\tdesc.c\tdesc.c\n"
"::100755 100755 100755 52b7a2d 6d1ac04 d2ac7d7 RM\tfoo.sh\tbar.sh\tbar.sh\n"
"::100644 100644 100644 e07d6c5 9042e82 ee91881 RR\tfooey.c\tfuey.c\tphooey.c\n"
msgstr ""
"::100644 100644 100644 fabadb8 cc95eb0 4866510 MM\tdesc.c\tdesc.c\tdesc.c\n"
"::100755 100755 100755 52b7a2d 6d1ac04 d2ac7d7 RM\tfoo.sh\tbar.sh\tbar.sh\n"
"::100644 100644 100644 e07d6c5 9042e82 ee91881 RR\tfooey.c\tfuey.c\tphooey.c\n"

#. type: Plain text
#: en/diff-format.txt:122
#, fuzzy, priority:280
msgid "Note that 'combined diff' lists only files which were modified from all parents."
msgstr "请注意 'combined diff' 只列出了从所有父提交中修改过的文件。"

#. type: Title -
#: en/diff-format.txt:128
#, fuzzy, no-wrap, priority:280
msgid "other diff formats"
msgstr "其他差异格式"

#. type: Plain text
#: en/diff-format.txt:134
#, fuzzy, priority:280
msgid "The `--summary` option describes newly added, deleted, renamed and copied files.  The `--stat` option adds diffstat(1) graph to the output.  These options can be combined with other options, such as `-p`, and are meant for human consumption."
msgstr "`--summary` 选项描述新添加、删除、重命名和复制的文件。`--stat` 选项将 diffstat(1) 图添加到输出中。这些选项可以与其他选项组合在一起，如 `-p` 选项可以提高可读性。"

#. type: Plain text
#: en/diff-format.txt:139
#, fuzzy, priority:280
msgid "When showing a change that involves a rename or a copy, `--stat` output formats the pathnames compactly by combining common prefix and suffix of the pathnames.  For example, a change that moves `arch/i386/Makefile` to `arch/x86/Makefile` while modifying 4 lines will be shown like this:"
msgstr "当显示一个涉及到重命名或复制的更改时，`--stat` 输出会将路径名的前缀和后缀结合在一起，会以较紧凑的方式显示。例如，将 \"arch/i386/Makefile\" 移动到 \"arch/x86/Makefile\"，同时修改了4行，就会显示出这样的变化："

#. type: delimited block -
#: en/diff-format.txt:142
#, fuzzy, no-wrap, priority:280
msgid "arch/{i386 => x86}/Makefile    |   4 +--\n"
msgstr "arch/{i386 => x86}/Makefile    |   4 +--\n"

#. type: Plain text
#: en/diff-format.txt:147
#, fuzzy, priority:280
msgid "The `--numstat` option gives the diffstat(1) information but is designed for easier machine consumption.  An entry in `--numstat` output looks like this:"
msgstr "`--numstat` 选项提供了 diffstat(1) 的信息，但其是为了方便程序使用而设计的。`--numstat` 输出中的一个条目如下："

#. type: delimited block -
#: en/diff-format.txt:151
#, fuzzy, no-wrap, priority:280
msgid ""
"1\t2\tREADME\n"
"3\t1\tarch/{i386 => x86}/Makefile\n"
msgstr ""
"1\t2\tREADME\n"
"3\t1\tarch/{i386 => x86}/Makefile\n"

#. type: Plain text
#: en/diff-format.txt:154
#, fuzzy, priority:280
msgid "That is, from left to right:"
msgstr "从左至右依次是："

#. type: Plain text
#: en/diff-format.txt:156 en/diff-format.txt:172
#, fuzzy, priority:280
msgid "the number of added lines;"
msgstr "添加的行数；"

#. type: Plain text
#: en/diff-format.txt:157 en/diff-format.txt:159 en/diff-format.txt:173 en/diff-format.txt:175
#, fuzzy, priority:280
msgid "a tab;"
msgstr "制表符；"

#. type: Plain text
#: en/diff-format.txt:158 en/diff-format.txt:174
#, priority:280
msgid "the number of deleted lines;"
msgstr "已删除行数;"

#. type: Plain text
#: en/diff-format.txt:160
#, fuzzy, priority:280
msgid "pathname (possibly with rename/copy information);"
msgstr "路径名（可能有重命名/复制信息）；"

#. type: Plain text
#: en/diff-format.txt:161
#, fuzzy, priority:280
msgid "a newline."
msgstr "换行符。"

#. type: Plain text
#: en/diff-format.txt:163
#, fuzzy, priority:280
msgid "When `-z` output option is in effect, the output is formatted this way:"
msgstr "当 `-z` 输出选项生效时，输出的格式如下："

#. type: delimited block -
#: en/diff-format.txt:167
#, fuzzy, no-wrap, priority:280
msgid ""
"1\t2\tREADME NUL\n"
"3\t1\tNUL arch/i386/Makefile NUL arch/x86/Makefile NUL\n"
msgstr ""
"1\t2\tREADME NUL\n"
"3\t1\tNUL arch/i386/Makefile NUL arch/x86/Makefile NUL\n"

#. type: Plain text
#: en/diff-format.txt:170
#, fuzzy, priority:280
msgid "That is:"
msgstr "依次是："

#. type: Plain text
#: en/diff-format.txt:176 en/diff-format.txt:178
#, fuzzy, priority:280
msgid "a NUL (only exists if renamed/copied);"
msgstr "NUL（仅在重命名/复制时存在）；"

#. type: Plain text
#: en/diff-format.txt:177
#, fuzzy, priority:280
msgid "pathname in preimage;"
msgstr "完整路径名；"

#. type: Plain text
#: en/diff-format.txt:179
#, fuzzy, priority:280
msgid "pathname in postimage (only exists if renamed/copied);"
msgstr "完整路径名（仅在重命名/复制时存在）；"

#. type: Plain text
#: en/diff-format.txt:180
#, priority:280
msgid "a NUL."
msgstr "a NUL."

#. type: Plain text
#: en/diff-format.txt:185
#, fuzzy, priority:280
msgid "The extra `NUL` before the preimage path in renamed case is to allow scripts that read the output to tell if the current record being read is a single-path record or a rename/copy record without reading ahead.  After reading added and deleted lines, reading up to `NUL` would yield the pathname, but if that is `NUL`, the record will show two paths."
msgstr "在重命名的情况下，完整路径前多出的 `NUL` 为了让读取输出的脚本能够判断，当前被读取的记录是单路径记录还是重命名/复制记录，而不需要提前读取。在读完增删行数后，读至 `NUL` 会得到路径名，但如果先读到 `NUL`，记录将显示两个路径。"

#. type: Title -
#: en/diff-generate-patch.txt:3
#, no-wrap, priority:280
msgid "Generating patch text with -p"
msgstr "使用选项 `-p` 生成补丁文本"

#. type: Plain text
#: en/diff-generate-patch.txt:16
#, fuzzy, priority:280
#| msgid "Running linkgit:git-diff[1], linkgit:git-log[1], linkgit:git-show[1], linkgit:git-diff-index[1], linkgit:git-diff-tree[1], or linkgit:git-diff-files[1] with the `-p` option produces patch text.  You can customize the creation of patch text via the `GIT_EXTERNAL_DIFF` and the `GIT_DIFF_OPTS` environment variables (see linkgit:git[1])."
msgid "Running linkgit:git-diff[1], linkgit:git-log[1], linkgit:git-show[1], linkgit:git-diff-index[1], linkgit:git-diff-tree[1], or linkgit:git-diff-files[1] with the `-p` option produces patch text.  You can customize the creation of patch text via the `GIT_EXTERNAL_DIFF` and the `GIT_DIFF_OPTS` environment variables (see linkgit:git[1]), and the `diff` attribute (see linkgit:gitattributes[5])."
msgstr "运行 linkgit:git-diff[1], linkgit:git-log[1], linkgit:git-show[1], linkgit:git-diff-index[1], linkgit:git-diff-tree[1], 或 linkgit:git-diff-files[1] 时带有 `-p` 选项会生成补丁文本。你可以通过 `GIT_EXTERNAL_DIFF` 和 `GIT_DIFF_OPTS` 环境变量来定制补丁文本创建（参见 linkgit:git[1]）。"

#. type: Plain text
#: en/diff-generate-patch.txt:19
#, priority:280
msgid "What the -p option produces is slightly different from the traditional diff format:"
msgstr "-p 选项产生的内容与传统的差异格式略有不同："

#. type: Plain text
#: en/diff-generate-patch.txt:21
#, priority:280
msgid "It is preceded with a \"git diff\" header that looks like this:"
msgstr "它前面有一个 `git diff` 头，如下所示："

#. type: Plain text
#: en/diff-generate-patch.txt:23
#, no-wrap, priority:280
msgid "diff --git a/file1 b/file2\n"
msgstr "diff --git a/file1 b/file2\n"

#. type: Plain text
#: en/diff-generate-patch.txt:27
#, priority:280
msgid "The `a/` and `b/` filenames are the same unless rename/copy is involved.  Especially, even for a creation or a deletion, `/dev/null` is _not_ used in place of the `a/` or `b/` filenames."
msgstr "`a/` 和 `b/` 的文件名相同，除非涉及到重命名/复制。特别地，即使是创建或删除，也 _不_ 使用 `/dev/null` 来代替 `a/` 或 `b/` 文件名。"

#. type: Plain text
#: en/diff-generate-patch.txt:31
#, priority:280
msgid "When rename/copy is involved, `file1` and `file2` show the name of the source file of the rename/copy and the name of the file that rename/copy produces, respectively."
msgstr "当涉及到重命名/复制时，`file1` 和 `file2` 分别显示重命名/复制的源文件的名称和重命名/复制产生的文件的名称。"

#. type: Plain text
#: en/diff-generate-patch.txt:33
#, priority:280
msgid "It is followed by one or more extended header lines:"
msgstr "它的后面是一个或多个扩展头信息行："

#. type: Plain text
#: en/diff-generate-patch.txt:45
#, no-wrap, priority:280
msgid ""
"old mode <mode>\n"
"new mode <mode>\n"
"deleted file mode <mode>\n"
"new file mode <mode>\n"
"copy from <path>\n"
"copy to <path>\n"
"rename from <path>\n"
"rename to <path>\n"
"similarity index <number>\n"
"dissimilarity index <number>\n"
"index <hash>..<hash> <mode>\n"
msgstr ""
"old mode <模式>\n"
"new mode <模式>\n"
"deleted file mode <模式>\n"
"new file mode <模式>\n"
"copy from <路径>\n"
"copy to <路径>\n"
"rename from <路径>\n"
"rename to <路径>\n"
"similarity index <数字>\n"
"dissimilarity index <数字>\n"
"index <哈希>..<哈希> <模式>\n"

#. type: Plain text
#: en/diff-generate-patch.txt:48
#, priority:280
msgid "File modes are printed as 6-digit octal numbers including the file type and file permission bits."
msgstr "文件模式被打印为6位八进制数字，包括文件类型和文件权限位。"

#. type: Plain text
#: en/diff-generate-patch.txt:50
#, priority:280
msgid "Path names in extended headers do not include the `a/` and `b/` prefixes."
msgstr "扩展头信息中的路径名称不包括 `a/` 和 `b/` 前缀。"

#. type: Plain text
#: en/diff-generate-patch.txt:57
#, priority:280
msgid "The similarity index is the percentage of unchanged lines, and the dissimilarity index is the percentage of changed lines.  It is a rounded down integer, followed by a percent sign.  The similarity index value of 100% is thus reserved for two equal files, while 100% dissimilarity means that no line from the old file made it into the new one."
msgstr "相似性指数是未改变的行占比，而不相似性指数是改变的行占比。它是四舍五入的整数，后有百分号。因此，100%的相似度指数指为两个文件相等，而 100% 的不相似度意味着入新文件中没有旧文件中的行。"

#. type: Plain text
#: en/diff-generate-patch.txt:61
#, priority:280
msgid "The index line includes the blob object names before and after the change.  The <mode> is included if the file mode does not change; otherwise, separate lines indicate the old and the new mode."
msgstr "索引行包括改变前和改变后的 blob 对象名称。如果文件模式没有变化，则包含 <模式>；否则，分别显示新旧模式。"

#. type: Plain text
#: en/diff-generate-patch.txt:65
#, priority:280
msgid "Pathnames with \"unusual\" characters are quoted as explained for the configuration variable `core.quotePath` (see linkgit:git-config[1])."
msgstr "含有 \"不常见\" 字符的路径名会被引用，这一点在配置变量` core.quotePath` 中有所解释（见 linkgit:git-config[1]）。"

#. type: Plain text
#: en/diff-generate-patch.txt:70
#, priority:280
msgid "All the `file1` files in the output refer to files before the commit, and all the `file2` files refer to files after the commit.  It is incorrect to apply each change to each file sequentially.  For example, this patch will swap a and b:"
msgstr "输出中所有的 `file1` 文件都是指提交前的文件，而所有的 `file2` 文件都是指提交后的文件。按顺序对每个文件进行修改是不正确的。例如，这个补丁将交换文件 a 和 b："

#. type: Plain text
#: en/diff-generate-patch.txt:77
#, no-wrap, priority:280
msgid ""
"diff --git a/a b/b\n"
"rename from a\n"
"rename to b\n"
"diff --git a/b b/a\n"
"rename from b\n"
"rename to a\n"
msgstr ""
"diff --git a/a b/b\n"
"rename from a\n"
"rename to b\n"
"diff --git a/b b/a\n"
"rename from b\n"
"rename to a\n"

#. type: Plain text
#: en/diff-generate-patch.txt:82
#, priority:280
msgid "Hunk headers mention the name of the function to which the hunk applies.  See \"Defining a custom hunk-header\" in linkgit:gitattributes[5] for details of how to tailor to this to specific languages."
msgstr "块头提到了块头所适用的函数的名称。  参见 linkgit:gitattributes[5] 中的 \"定义自定义 hunk-header\"，以了解如何针对特定语言进行定制。"

#. type: Title -
#: en/diff-generate-patch.txt:85
#, no-wrap, priority:280
msgid "Combined diff format"
msgstr "合并的差异格式"

#. type: Plain text
#: en/diff-generate-patch.txt:93
#, priority:280
msgid "Any diff-generating command can take the `-c` or `--cc` option to produce a 'combined diff' when showing a merge. This is the default format when showing merges with linkgit:git-diff[1] or linkgit:git-show[1]. Note also that you can give suitable `--diff-merges` option to any of these commands to force generation of diffs in specific format."
msgstr "任何生成差异的命令都可以使用 `-c` 或 `-cc` 选项，在显示合并时产生一个 \"合并差异\"。当用 linkgit:git-diff[1] 或 linkgit:git-show[1] 显示合并时，这默认格式。还需要注意的是，你可以给这些命令适当的 `--diff-merges` 选项来强制生成特定格式的差异。"

#. type: Plain text
#: en/diff-generate-patch.txt:95
#, priority:280
msgid "A \"combined diff\" format looks like this:"
msgstr "\"合并的差异\" 的格式如下："

#. type: delimited block -
#: en/diff-generate-patch.txt:104
#, no-wrap, priority:280
msgid ""
"diff --combined describe.c\n"
"index fabadb8,cc95eb0..4866510\n"
"--- a/describe.c\n"
"+++ b/describe.c\n"
"@@@ -98,20 -98,12 +98,20 @@@\n"
"\treturn (a_date > b_date) ? -1 : (a_date == b_date) ? 0 : 1;\n"
"  }\n"
msgstr ""
"diff --combined describe.c\n"
"index fabadb8,cc95eb0..4866510\n"
"--- a/describe.c\n"
"+++ b/describe.c\n"
"@@@ -98,20 -98,12 +98,20 @@@\n"
"\treturn (a_date > b_date) ? -1 : (a_date == b_date) ? 0 : 1;\n"
"  }\n"

#. type: delimited block -
#: en/diff-generate-patch.txt:114
#, no-wrap, priority:280
msgid ""
"- static void describe(char *arg)\n"
" -static void describe(struct commit *cmit, int last_one)\n"
"++static void describe(char *arg, int last_one)\n"
"  {\n"
" +\tunsigned char sha1[20];\n"
" +\tstruct commit *cmit;\n"
"\tstruct commit_list *list;\n"
"\tstatic int initialized = 0;\n"
"\tstruct commit_name *n;\n"
msgstr ""
"- static void describe(char *arg)\n"
" -static void describe(struct commit *cmit, int last_one)\n"
"++static void describe(char *arg, int last_one)\n"
"  {\n"
" +\tunsigned char sha1[20];\n"
" +\tstruct commit *cmit;\n"
"\tstruct commit_list *list;\n"
"\tstatic int initialized = 0;\n"
"\tstruct commit_name *n;\n"

#. type: delimited block -
#: en/diff-generate-patch.txt:124
#, no-wrap, priority:280
msgid ""
" +\tif (get_sha1(arg, sha1) < 0)\n"
" +\t\tusage(describe_usage);\n"
" +\tcmit = lookup_commit_reference(sha1);\n"
" +\tif (!cmit)\n"
" +\t\tusage(describe_usage);\n"
" +\n"
"\tif (!initialized) {\n"
"\t\tinitialized = 1;\n"
"\t\tfor_each_ref(get_name);\n"
msgstr ""
" +\tif (get_sha1(arg, sha1) < 0)\n"
" +\t\tusage(describe_usage);\n"
" +\tcmit = lookup_commit_reference(sha1);\n"
" +\tif (!cmit)\n"
" +\t\tusage(describe_usage);\n"
" +\n"
"\tif (!initialized) {\n"
"\t\tinitialized = 1;\n"
"\t\tfor_each_ref(get_name);\n"

#. type: Plain text
#: en/diff-generate-patch.txt:128
#, priority:280
msgid "It is preceded with a \"git diff\" header, that looks like this (when the `-c` option is used):"
msgstr "它前面有 \"git diff\" 头，如下（当使用 `c` 选项时）："

#. type: Plain text
#: en/diff-generate-patch.txt:130
#, no-wrap, priority:280
msgid "diff --combined file\n"
msgstr "diff --combined file\n"

#. type: Plain text
#: en/diff-generate-patch.txt:132
#, priority:280
msgid "or like this (when the `--cc` option is used):"
msgstr "或如下（当使用 `--cc` 选项时）："

#. type: Plain text
#: en/diff-generate-patch.txt:134
#, no-wrap, priority:280
msgid "       diff --cc file\n"
msgstr "       diff --cc file\n"

#. type: Plain text
#: en/diff-generate-patch.txt:137
#, priority:280
msgid "It is followed by one or more extended header lines (this example shows a merge with two parents):"
msgstr "它的后面是一个或多个扩展头信息行（本例显示的是与两个父提交的合并）："

#. type: Plain text
#: en/diff-generate-patch.txt:142
#, no-wrap, priority:280
msgid ""
"index <hash>,<hash>..<hash>\n"
"mode <mode>,<mode>..<mode>\n"
"new file mode <mode>\n"
"deleted file mode <mode>,<mode>\n"
msgstr ""
"index <哈希>,<哈希>..<哈希>\n"
"mode <模式>,<模式>..<模式>\n"
"new file mode <模式>\n"
"deleted file mode <模式>,<模式>\n"

#. type: Plain text
#: en/diff-generate-patch.txt:148
#, fuzzy, priority:280
msgid "The `mode <mode>,<mode>..<mode>` line appears only if at least one of the <mode> is different from the rest. Extended headers with information about detected contents movement (renames and copying detection) are designed to work with diff of two <tree-ish> and are not used by combined diff format."
msgstr "`mode<mode>，<mode>..<mode>` 行仅在 <mode> 中至少有一个与其余的不同时才会出现。包含有关检测到的内容移动的信息 (重命名和复制检测) 的扩展标头设计为使用两个 <tree-ish> 的 diff，不能用于组合的 diff 格式。"

#. type: Plain text
#: en/diff-generate-patch.txt:150
#, priority:280
msgid "It is followed by two-line from-file/to-file header"
msgstr "它的后面是两行源文件/目标文件的头信息"

#. type: Plain text
#: en/diff-generate-patch.txt:152 en/diff-generate-patch.txt:163 en/diff-generate-patch.txt:164 en/diff-generate-patch.txt:165
#, priority:280
msgid "a/file"
msgstr "a/file"

#. type: Plain text
#: en/diff-generate-patch.txt:153 en/diff-generate-patch.txt:166
#, priority:280
msgid "b/file"
msgstr "b/file"

#. type: Plain text
#: en/diff-generate-patch.txt:157
#, priority:280
msgid "Similar to two-line header for traditional 'unified' diff format, `/dev/null` is used to signal created or deleted files."
msgstr "类似于传统的 \"统一\" 差异格式的双行头，`/dev/null` 用来表示创建或删除的文件。"

#. type: Plain text
#: en/diff-generate-patch.txt:161
#, priority:280
msgid "However, if the --combined-all-paths option is provided, instead of a two-line from-file/to-file you get a N+1 line from-file/to-file header, where N is the number of parents in the merge commit"
msgstr "但是，如果提供了 --combined-all-paths 选项，你就会得到一个 N+1 行的源文件/目标文件头，其中 N 是合并提交中的父提交数量"

#. type: Plain text
#: en/diff-generate-patch.txt:170
#, priority:280
msgid "This extended format can be useful if rename or copy detection is active, to allow you to see the original name of the file in different parents."
msgstr "如果重命名或复制检测处于活动状态，这种扩展格式可能很有用，可以让你在不同的父提交中看到文件的原始名称。"

#. type: Plain text
#: en/diff-generate-patch.txt:176
#, priority:280
msgid "Chunk header format is modified to prevent people from accidentally feeding it to `patch -p1`. Combined diff format was created for review of merge commit changes, and was not meant to be applied. The change is similar to the change in the extended 'index' header:"
msgstr "修改了文件块头信息的格式，以防止不小心将其送入 `patch -p1`。合并的差异格式是为审查合并提交的修改而创建的，并不是为了应用。这个变化类似于扩展的 \"索引\" 头信息的变化："

#. type: Plain text
#: en/diff-generate-patch.txt:178
#, no-wrap, priority:280
msgid "@@@ <from-file-range> <from-file-range> <to-file-range> @@@\n"
msgstr "@@@ <from-file-range> <from-file-range> <to-file-range> @@@\n"

#. type: Plain text
#: en/diff-generate-patch.txt:181
#, priority:280
msgid "There are (number of parents + 1) `@` characters in the chunk header for combined diff format."
msgstr "块中有（父提交数量+1）`@` 字符，用于合并的差异格式。"

#. type: Plain text
#: en/diff-generate-patch.txt:190
#, ignore-ellipsis, priority:280
msgid "Unlike the traditional 'unified' diff format, which shows two files A and B with a single column that has `-` (minus -- appears in A but removed in B), `+` (plus -- missing in A but added to B), or `\" \"` (space -- unchanged) prefix, this format compares two or more files file1, file2,... with one file X, and shows how X differs from each of fileN.  One column for each of fileN is prepended to the output line to note how X's line is different from it."
msgstr "与传统的 \"统一\" 差异格式不同，这种格式显示两个文件 A 和 B 的列，其中有 `-`（减号 -- 在 A 中出现，但在 B 中删除），`+`（加号 -- 在 A 中缺少，但在 B 中增加），或 `\" \"`（空格 -- 不变）前缀，这种格式比较两个或多个文件与一个文件 X，并显示 X 与其中每个文件的差异。文件中的每一个都有一列被前置在输出行中，以指出 X 的行与它的不同之处。"

#. type: Plain text
#: en/diff-generate-patch.txt:196
#, priority:280
msgid "A `-` character in the column N means that the line appears in fileN but it does not appear in the result.  A `+` character in the column N means that the line appears in the result, and fileN does not have that line (in other words, the line was added, from the point of view of that parent)."
msgstr "第 N 列中的 `-` 字符意味着该行出现在文件 N 中，但它没有出现在结果文件中。第 N 列中的 `+` 字符意味着该行出现在结果文件中，而文件 N 中没有该行（换句话说，从该父提交的角度来看，该行是被添加的）。"

#. type: Plain text
#: en/diff-generate-patch.txt:202
#, priority:280
msgid "In the above example output, the function signature was changed from both files (hence two `-` removals from both file1 and file2, plus `++` to mean one line that was added does not appear in either file1 or file2).  Also eight other lines are the same from file1 but do not appear in file2 (hence prefixed with `+`)."
msgstr "在上面的输出示例中，两个文件中的函数签名都被改变了（因此从文件 1 和文件 2 中都有表示删除的 `-`，而 `++` 表示被添加的一行没有出现在文件 1 或文件 2 中）。另外还有 8 行与文件 1 中的相同，但没有出现在文件 2 中（因此前缀为 `+`）。"

#. type: Plain text
#: en/diff-generate-patch.txt:208
#, priority:280
msgid "When shown by `git diff-tree -c`, it compares the parents of a merge commit with the merge result (i.e. file1..fileN are the parents).  When shown by `git diff-files -c`, it compares the two unresolved merge parents with the working tree file (i.e. file1 is stage 2 aka \"our version\", file2 is stage 3 aka \"their version\")."
msgstr "当用 `git diff-tree -c` 显示时，它将合并提交的父提交文件与合并结果进行比较（即文件 1 ... 文件 N 是父提交文件）。当用 `git diff-files -c` 显示时，它将两个未解决的合并父提交文件与工作树文件进行比较（即文件 1 是阶段 2 ，又称 \"我们的版本\"，文件 2 是阶段 3，又称 \"他们的版本\"）。"

#. type: Labeled list
#: en/diff-options.txt:17 en/git-rebase.txt:420 en/merge-options.txt:109
#, ignore-same, no-wrap, priority:280
msgid "--no-stat"
msgstr "--no-stat"

#. type: Plain text
#: en/diff-options.txt:19
#, priority:280
msgid "Generate plain patches without any diffstats."
msgstr "生成没有任何差异状态(diffstats)的普通补丁。"

#. type: Labeled list
#: en/diff-options.txt:23 en/fetch-options.txt:264 en/git-add.txt:119 en/git-am.txt:92 en/git-checkout-index.txt:26 en/git-cvsexportcommit.txt:64 en/git-cvsimport.txt:98 en/git-ls-files.txt:80 en/git-mailinfo.txt:54 en/git-push.txt:373 en/git-read-tree.txt:45 en/git-stash.txt:166
#, ignore-same, no-wrap, priority:300
msgid "-u"
msgstr "-u"

#. type: Labeled list
#: en/diff-options.txt:24 en/git-add.txt:97 en/git-checkout.txt:274 en/git-commit.txt:74 en/git-restore.txt:49 en/git-stash.txt:197
#, ignore-same, no-wrap, priority:300
msgid "--patch"
msgstr "--patch"

#. type: Plain text
#: en/diff-options.txt:26
#, fuzzy, priority:280
msgid "Generate patch (see section titled"
msgstr "生成补丁（参阅生成补丁的相关章节）。"

#. type: Plain text
#: en/diff-options.txt:28
#, priority:280
msgid "<<generate_patch_text_with_p, \"Generating patch text with -p\">>)."
msgstr "使用选项 `-p` 生成补丁文本。"

#. type: Plain text
#: en/diff-options.txt:31
#, fuzzy, priority:280
#| msgid "Generating patch text with -p"
msgid "\"Generating patch text with -p\")."
msgstr "使用选项 `-p` 生成补丁文本"

#. type: Plain text
#: en/diff-options.txt:34 en/diff-options.txt:139
#, fuzzy, no-wrap, priority:280
msgid "\tThis is the default.\n"
msgstr "\t这是默认设置。\n"

#. type: Labeled list
#: en/diff-options.txt:36 en/git-am.txt:38 en/git-blame.txt:75 en/git-cat-file.txt:46 en/git-cherry-pick.txt:105 en/git-clone.txt:76 en/git-diff-tree.txt:77 en/git-format-patch.txt:138 en/git-ls-files.txt:68 en/git-revert.txt:100 en/git-shortlog.txt:34 en/git-show-ref.txt:53 en/git-status.txt:27 en/git-stripspace.txt:38 en/git-svn.txt:46 en/git-tag.txt:64 en/git-verify-pack.txt:31 en/signoff-option.txt:2
#, ignore-same, no-wrap, priority:300
msgid "-s"
msgstr "-s"

#. type: Labeled list
#: en/diff-options.txt:37
#, ignore-same, no-wrap, priority:280
msgid "--no-patch"
msgstr "--no-patch"

#. type: Plain text
#: en/diff-options.txt:42
#, fuzzy, priority:280
msgid "Suppress all output from the diff machinery.  Useful for commands like `git show` that show the patch by default to squelch their output, or to cancel the effect of options like `--patch`, `--stat` earlier on the command line in an alias."
msgstr "不输出差异（diff）。对于显示修补程序的 `git show` 等命令是默认选项，也用于取消选项 `--patch` 的效果。"

#. type: Labeled list
#: en/diff-options.txt:46
#, fuzzy, no-wrap, priority:280
#| msgid "--diff-merges=(off|none|first-parent|1|separate|m|combined|c|dense-combined|cc)"
msgid "--diff-merges=(off|none|on|first-parent|1|separate|m|combined|c|dense-combined|cc|remerge|r)"
msgstr "--diff-merges=(off|none|first-parent|1|separate|m|combined|c|dense-combined|cc)"

#. type: Labeled list
#: en/diff-options.txt:47 en/diff-options.txt:53
#, ignore-same, no-wrap, priority:280
msgid "--no-diff-merges"
msgstr "--no-diff-merges"

#. type: Plain text
#: en/diff-options.txt:51
#, priority:280
msgid "Specify diff format to be used for merge commits. Default is {diff-merges-default} unless `--first-parent` is in use, in which case `first-parent` is the default."
msgstr "指定合并提交时使用的差异格式。默认为 {diff-merges-default}，但当使用 `--first-parent` 选项时，默认为 `first-parent`。"

#. type: Labeled list
#: en/diff-options.txt:52
#, fuzzy, no-wrap, priority:280
#| msgid "diffmerge"
msgid "--diff-merges=(off|none)"
msgstr "diffmerge"

#. type: Plain text
#: en/diff-options.txt:56
#, priority:280
msgid "Disable output of diffs for merge commits. Useful to override implied value."
msgstr "禁用合并提交时的差异输出。对覆盖隐含值很有用。"

#. type: Labeled list
#: en/diff-options.txt:57
#, fuzzy, no-wrap, priority:280
#| msgid "diffmerge"
msgid "--diff-merges=on"
msgstr "diffmerge"

#. type: Labeled list
#: en/diff-options.txt:58
#, fuzzy, no-wrap, priority:280
#| msgid "diffmerge"
msgid "--diff-merges=m"
msgstr "diffmerge"

#. type: Labeled list
#: en/diff-options.txt:59 en/git-am.txt:77 en/git-branch.txt:131 en/git-checkout.txt:246 en/git-cvsexportcommit.txt:60 en/git-cvsimport.txt:118 en/git-diff-index.txt:37 en/git-diff-tree.txt:71 en/git-help.txt:96 en/git-instaweb.txt:36 en/git-ls-files.txt:48 en/git-mailinfo.txt:71 en/git-read-tree.txt:33 en/git-rebase.txt:363 en/git-repack.txt:216 en/git-restore.txt:86 en/git-svn.txt:308 en/git-svn.txt:675 en/git-switch.txt:121 en/git-symbolic-ref.txt:58
#, ignore-same, no-wrap, priority:280
msgid "-m"
msgstr "-m"

#. type: Plain text
#: en/diff-options.txt:65
#, fuzzy, priority:280
#| msgid "This option makes diff output for merge commits to be shown in the default format. `-m` will produce the output only if `-p` is given as well. The default format could be changed using `log.diffMerges` configuration parameter, which default value is `separate`."
msgid "This option makes diff output for merge commits to be shown in the default format. `-m` will produce the output only if `-p` is given as well. The default format could be changed using `log.diffMerges` configuration parameter, which default value is `separate`."
msgstr "该选项使合并提交的差异输出以默认格式显示。`-m`只有在`-p`的情况下才会产生输出。默认格式可以通过`log.diffMerges`配置参数改变，默认值为`separate`。"

#. type: Labeled list
#: en/diff-options.txt:66
#, fuzzy, no-wrap, priority:280
#| msgid "--first-parent"
msgid "--diff-merges=first-parent"
msgstr "--first-parent"

#. type: Labeled list
#: en/diff-options.txt:67
#, fuzzy, no-wrap, priority:280
#| msgid "diffmerge"
msgid "--diff-merges=1"
msgstr "diffmerge"

#. type: Plain text
#: en/diff-options.txt:70
#, priority:280
msgid "This option makes merge commits show the full diff with respect to the first parent only."
msgstr "此选项使合并提交只显示与第一个父提交之间的完整差异。"

#. type: Labeled list
#: en/diff-options.txt:71
#, fuzzy, no-wrap, priority:280
#| msgid "diffmerge"
msgid "--diff-merges=separate"
msgstr "diffmerge"

#. type: Plain text
#: en/diff-options.txt:75
#, fuzzy, priority:280
#| msgid "This makes merge commits show the full diff with respect to each of the parents. Separate log entry and diff is generated for each parent. `-m` doesn't produce any output without `-p`."
msgid "This makes merge commits show the full diff with respect to each of the parents. Separate log entry and diff is generated for each parent."
msgstr "这使得合并提交显示了每个父提交之间的完整差异。每个父提交都会产生单独的日志项和差异。`-m` 选项在没有 `-p` 选项时不会产生任何输出。"

#. type: Labeled list
#: en/diff-options.txt:76
#, fuzzy, no-wrap, priority:280
#| msgid "diffmerge"
msgid "--diff-merges=remerge"
msgstr "diffmerge"

#. type: Labeled list
#: en/diff-options.txt:77
#, fuzzy, no-wrap, priority:280
#| msgid "diffmerge"
msgid "--diff-merges=r"
msgstr "diffmerge"

#. type: Labeled list
#: en/diff-options.txt:78
#, ignore-same, no-wrap, priority:280
msgid "--remerge-diff"
msgstr "--remerge-diff"

#. type: Plain text
#: en/diff-options.txt:83
#, priority:280
msgid "With this option, two-parent merge commits are remerged to create a temporary tree object -- potentially containing files with conflict markers and such.  A diff is then shown between that temporary tree and the actual merge commit."
msgstr "With this option, two-parent merge commits are remerged to create a temporary tree object -- potentially containing files with conflict markers and such.  A diff is then shown between that temporary tree and the actual merge commit."

#. type: Plain text
#: en/diff-options.txt:87
#, priority:280
msgid "The output emitted when this option is used is subject to change, and so is its interaction with other options (unless explicitly documented)."
msgstr "使用该选项时发出的输出是可以改变的，它与其他选项的互动也是可以改变的（除非有明确的记录）。"

#. type: Labeled list
#: en/diff-options.txt:88
#, fuzzy, no-wrap, priority:280
#| msgid "diffmerge"
msgid "--diff-merges=combined"
msgstr "diffmerge"

#. type: Labeled list
#: en/diff-options.txt:89
#, fuzzy, no-wrap, priority:280
#| msgid "diffmerge"
msgid "--diff-merges=c"
msgstr "diffmerge"

#. type: Labeled list
#: en/diff-options.txt:90 en/git-am.txt:57 en/git-blame.txt:53 en/git-branch.txt:138 en/git-cvsexportcommit.txt:37 en/git-diff-files.txt:37 en/git-diff-tree.txt:93 en/git-grep.txt:188 en/git-help.txt:65 en/git-ls-files.txt:38 en/git-shortlog.txt:87 en/git-stripspace.txt:42
#, ignore-same, no-wrap, priority:280
msgid "-c"
msgstr "-c"

#. type: Plain text
#: en/diff-options.txt:97
#, priority:280
msgid "With this option, diff output for a merge commit shows the differences from each of the parents to the merge result simultaneously instead of showing pairwise diff between a parent and the result one at a time. Furthermore, it lists only files which were modified from all parents. `-c` implies `-p`."
msgstr "使用此选项，合并提交的差异输出将同时显示每个父提交与合并结果的差异，而不是一次显示一个父提交与结果之间的成对差异 。此外，它只列出所有父提交中修改的文件。`-c` 选项暗含 `-p` 选项。"

#. type: Labeled list
#: en/diff-options.txt:98
#, fuzzy, no-wrap, priority:280
#| msgid "diffmerge"
msgid "--diff-merges=dense-combined"
msgstr "diffmerge"

#. type: Labeled list
#: en/diff-options.txt:99
#, fuzzy, no-wrap, priority:280
#| msgid "diffmerge"
msgid "--diff-merges=cc"
msgstr "diffmerge"

#. type: Labeled list
#: en/diff-options.txt:100 en/git-diff-files.txt:38 en/git-diff-tree.txt:103
#, ignore-same, no-wrap, priority:280
msgid "--cc"
msgstr "--cc"

#. type: Plain text
#: en/diff-options.txt:106
#, fuzzy, priority:280
msgid "With this option the output produced by `--diff-merges=combined` is further compressed by omitting uninteresting hunks whose contents in the parents have only two variants and the merge result picks one of them without modification.  `--cc` implies `-p`."
msgstr "使用该选项，通过省略不感兴趣的块，进一步压缩 `--diff-merges=combined` 产生的输出，这类块在父提交中的内容只有两个变体，并且合并结果选择了其中一个而没有修改。 `--cc` 选项暗含 `-p`。"

#. type: Labeled list
#: en/diff-options.txt:107 en/git-diff-tree.txt:113
#, ignore-same, no-wrap, priority:280
msgid "--combined-all-paths"
msgstr "--combined-all-paths"

#. type: Plain text
#: en/diff-options.txt:113
#, fuzzy, priority:280
msgid "This flag causes combined diffs (used for merge commits) to list the name of the file from all parents.  It thus only has effect when `--diff-merges=[dense-]combined` is in use, and is likely only useful if filename changes are detected (i.e.  when either rename or copy detection have been requested)."
msgstr "这个标志会使合并后的差异文件（用于合并提交）列出所有父提交的名称。，因此它只在使用 `--diff-merges=[dense-]combined` 时有效。其可能在检测到文件名变化时有用（例如，当要求检测重命名或复制时）。"

#. type: Labeled list
#: en/diff-options.txt:115
#, fuzzy, no-wrap, priority:280
msgid "-U<n>"
msgstr "-U<n>"

#. type: Labeled list
#: en/diff-options.txt:116
#, fuzzy, no-wrap, priority:280
msgid "--unified=<n>"
msgstr "--unified=<n>"

#. type: Plain text
#: en/diff-options.txt:119
#, fuzzy, priority:280
msgid "Generate diffs with <n> lines of context instead of the usual three."
msgstr "生成带有 <n> 行上下文的差异，而不是通常的 3 行。暗含 `--patch` 选项。"

#. type: Plain text
#: en/diff-options.txt:121 en/diff-options.txt:529
#, fuzzy, no-wrap, priority:280
msgid "\tImplies `--patch`.\n"
msgstr "\t暗含 `-p`。\n"

#. type: Labeled list
#: en/diff-options.txt:123 en/git-archive.txt:59
#, fuzzy, no-wrap, priority:280
msgid "--output=<file>"
msgstr "--output=<文件>"

#. type: Plain text
#: en/diff-options.txt:125
#, fuzzy, priority:280
msgid "Output to a specific file instead of stdout."
msgstr "输出到一个特定的文件，而不是标准输出。"

#. type: Labeled list
#: en/diff-options.txt:126
#, fuzzy, no-wrap, priority:280
msgid "--output-indicator-new=<char>"
msgstr "--output-indicator-new=<字符>"

#. type: Labeled list
#: en/diff-options.txt:127
#, fuzzy, no-wrap, priority:280
msgid "--output-indicator-old=<char>"
msgstr "--output-indicator-old=<字符>"

#. type: Labeled list
#: en/diff-options.txt:128
#, fuzzy, no-wrap, priority:280
msgid "--output-indicator-context=<char>"
msgstr "--output-indicator-context=<字符>"

#. type: Plain text
#: en/diff-options.txt:132
#, fuzzy, priority:280
msgid "Specify the character used to indicate new, old or context lines in the generated patch. Normally they are '+', '-' and ' ' respectively."
msgstr "指定在生成的补丁中用来表示新、旧或上下文行的字符。通常它们分别是 '+'、'-' 和 ' '（空格）。"

#. type: Labeled list
#: en/diff-options.txt:134 en/git-replace.txt:78 en/git-verify-commit.txt:19 en/git-verify-tag.txt:19
#, ignore-same, no-wrap, priority:280
msgid "--raw"
msgstr "--raw"

#. type: Plain text
#: en/diff-options.txt:137
#, fuzzy, no-wrap, priority:280
msgid "\tGenerate the diff in raw format.\n"
msgstr "\t生成原始格式的差异。\n"

#. type: Plain text
#: en/diff-options.txt:147
#, fuzzy, no-wrap, priority:280
msgid ""
"\tFor each commit, show a summary of changes using the raw diff\n"
"\tformat. See the \"RAW OUTPUT FORMAT\" section of\n"
"\tlinkgit:git-diff[1]. This is different from showing the log\n"
"\titself in raw format, which you can achieve with\n"
"\t`--format=raw`.\n"
msgstr ""
"\t对于每一个提交，使用原始的差异格式\n"
"\t请参见 linkgit:git-diff[1] 中\n"
"\t\"原始输出格式\" 一节 。\n"
"\t这与显示日志中的本身的原始格式不同\n"
"\t你可以用 `--format=raw` 来实现。\n"

#. type: Labeled list
#: en/diff-options.txt:151
#, ignore-same, no-wrap, priority:280
msgid "--patch-with-raw"
msgstr "--patch-with-raw"

#. type: Plain text
#: en/diff-options.txt:153
#, fuzzy, priority:280
msgid "Synonym for `-p --raw`."
msgstr "`-p-raw` 的同义词。"

#. type: Plain text
#: en/diff-options.txt:158
#, fuzzy, priority:280
msgid "Show the tree objects in the diff output."
msgstr "在差异输出中显示树对象。"

#. type: Labeled list
#: en/diff-options.txt:160
#, ignore-same, no-wrap, priority:280
msgid "--indent-heuristic"
msgstr "--indent-heuristic"

#. type: Plain text
#: en/diff-options.txt:163
#, fuzzy, priority:280
msgid "Enable the heuristic that shifts diff hunk boundaries to make patches easier to read. This is the default."
msgstr "启用启发式的缩进区块的方法，使得补丁更易读。这是默认选项。"

#. type: Labeled list
#: en/diff-options.txt:164
#, ignore-same, no-wrap, priority:280
msgid "--no-indent-heuristic"
msgstr "--no-indent-heuristic"

#. type: Plain text
#: en/diff-options.txt:166
#, fuzzy, priority:280
msgid "Disable the indent heuristic."
msgstr "禁用启发式缩进。"

#. type: Labeled list
#: en/diff-options.txt:167
#, ignore-same, no-wrap, priority:280
msgid "--minimal"
msgstr "--minimal"

#. type: Plain text
#: en/diff-options.txt:170 en/diff-options.txt:196
#, fuzzy, priority:280
msgid "Spend extra time to make sure the smallest possible diff is produced."
msgstr "花费额外的时间以确保生成尽可能小的差异。"

#. type: Labeled list
#: en/diff-options.txt:171
#, ignore-same, no-wrap, priority:280
msgid "--patience"
msgstr "--patience"

#. type: Plain text
#: en/diff-options.txt:173
#, fuzzy, priority:280
msgid "Generate a diff using the \"patience diff\" algorithm."
msgstr "使用 \"patience diff\" 算法生成差异。"

#. type: Labeled list
#: en/diff-options.txt:174
#, ignore-same, no-wrap, priority:280
msgid "--histogram"
msgstr "--histogram"

#. type: Plain text
#: en/diff-options.txt:176
#, fuzzy, priority:280
msgid "Generate a diff using the \"histogram diff\" algorithm."
msgstr "使用 \"histogram diff\" 算法生成差异。"

#. type: Labeled list
#: en/diff-options.txt:177
#, fuzzy, no-wrap, priority:280
msgid "--anchored=<text>"
msgstr "--anchored=<文本>"

#. type: Plain text
#: en/diff-options.txt:179
#, fuzzy, priority:280
msgid "Generate a diff using the \"anchored diff\" algorithm."
msgstr "使用 \"anchored diff\" 算法生成差异。"

#. type: Plain text
#: en/diff-options.txt:181
#, fuzzy, priority:280
msgid "This option may be specified more than once."
msgstr "这个选项可以被指定多次。"

#. type: Plain text
#: en/diff-options.txt:186
#, fuzzy, priority:280
msgid "If a line exists in both the source and destination, exists only once, and starts with this text, this algorithm attempts to prevent it from appearing as a deletion or addition in the output. It uses the \"patience diff\" algorithm internally."
msgstr "如果某一个行同时存在于来源和目标中，各只出现一次，以这个文本开头，这个算法试图防止它在输出中以删除或添加的形式出现。它在内部使用了 \"patience diff\" 算法。"

#. type: Labeled list
#: en/diff-options.txt:187
#, fuzzy, no-wrap, priority:280
msgid "--diff-algorithm={patience|minimal|histogram|myers}"
msgstr "diff-algorithm=[patience|minimal|histogram|myers]"

#. type: Plain text
#: en/diff-options.txt:189
#, fuzzy, priority:280
msgid "Choose a diff algorithm. The variants are as follows:"
msgstr "选择差异算法。有如下可选项："

#. type: Labeled list
#: en/diff-options.txt:191
#, ignore-same, no-wrap, priority:280
msgid "`default`, `myers`"
msgstr "`default`, `myers`"

#. type: Plain text
#: en/diff-options.txt:193
#, fuzzy, priority:280
msgid "The basic greedy diff algorithm. Currently, this is the default."
msgstr "基本的贪婪差异算法。当前是默认设置。"

#. type: Labeled list
#: en/diff-options.txt:193
#, ignore-same, no-wrap, priority:280
msgid "`minimal`"
msgstr "`minimal`"

#. type: Labeled list
#: en/diff-options.txt:196
#, ignore-same, no-wrap, priority:280
msgid "`patience`"
msgstr "`patience`"

#. type: Plain text
#: en/diff-options.txt:198
#, fuzzy, priority:280
msgid "Use \"patience diff\" algorithm when generating patches."
msgstr "使用 \"patience diff\" 算法时产生的补丁。"

#. type: Labeled list
#: en/diff-options.txt:198
#, ignore-same, no-wrap, priority:280
msgid "`histogram`"
msgstr "`histogram`"

#. type: Plain text
#: en/diff-options.txt:201
#, fuzzy, priority:280
msgid "This algorithm extends the patience algorithm to \"support low-occurrence common elements\"."
msgstr "该算法将耐心算法扩展为“支持低发生率的常见元素”。"

#. type: Plain text
#: en/diff-options.txt:206
#, fuzzy, priority:280
msgid "For instance, if you configured the `diff.algorithm` variable to a non-default value and want to use the default one, then you have to use `--diff-algorithm=default` option."
msgstr "例如，如果你将 `diff.algorithm` 变量配置为非默认值，但希望使用默认值，那么你必须使用 `--diff-algorithm=default` 选项。"

#. type: Labeled list
#: en/diff-options.txt:207
#, no-wrap, priority:280
msgid "--stat[=<width>[,<name-width>[,<count>]]]"
msgstr "--stat[=<宽度>[,<名称宽度>[,<数值>]]]"

#. type: Plain text
#: en/diff-options.txt:221
#, fuzzy, ignore-ellipsis, priority:280
msgid "Generate a diffstat. By default, as much space as necessary will be used for the filename part, and the rest for the graph part. Maximum width defaults to terminal width, or 80 columns if not connected to a terminal, and can be overridden by `<width>`. The width of the filename part can be limited by giving another width `<name-width>` after a comma. The width of the graph part can be limited by using `--stat-graph-width=<width>` (affects all commands generating a stat graph) or by setting `diff.statGraphWidth=<width>` (does not affect `git format-patch`).  By giving a third parameter `<count>`, you can limit the output to the first `<count>` lines, followed by `...` if there are more."
msgstr "生成一个差异状态。默认情况下，文件名部分将尽可能多地使用空间，其余的空间用于图形部分。最大宽度默认为终端宽度，如果没有连接到终端，最大宽度为80列。可以用 `<宽度>` 覆盖。文件名部分的宽度可以通过在逗号后加一个参数 `<名称宽度>` 来限制。图形部分的宽度可以通过使用 `--stat-graph-width=<宽度>` 来限制（影响所有生成状态图的命令），或者通过设置 `diff.statGraphWidth=<宽度>`（不影响 `git format-patch`）。通过给第三个参数 `<数量>`，你可以把输出限制在第一个`<count>` 行。如果有更多的行，后面是 `...`。"

#. type: Plain text
#: en/diff-options.txt:224
#, fuzzy, priority:280
msgid "These parameters can also be set individually with `--stat-width=<width>`, `--stat-name-width=<name-width>` and `--stat-count=<count>`."
msgstr "这些参数也可以用 `--stat-width=<宽度>`，`--stat-name-width=<名称宽度>` 和 `--stat-count=<数量>` 单独设置。"

#. type: Labeled list
#: en/diff-options.txt:225
#, ignore-same, no-wrap, priority:280
msgid "--compact-summary"
msgstr "--compact-summary"

#. type: Plain text
#: en/diff-options.txt:232
#, fuzzy, priority:280
msgid "Output a condensed summary of extended header information such as file creations or deletions (\"new\" or \"gone\", optionally \"+l\" if it's a symlink) and mode changes (\"+x\" or \"-x\" for adding or removing executable bit respectively) in diffstat. The information is put between the filename part and the graph part. Implies `--stat`."
msgstr "在差异状态中输出扩展头信息的压缩摘要，如文件的创建或删除（\"new \" 或 \"good\"。如果是符号链接，则为 \"+l\"）和模式变化（\"+x\" 或 \"-x\" 分别用于添加或删除可执行位）。这些信息被放在文件名部分和图形部分之间。暗含 `--stat` 选项。"

#. type: Labeled list
#: en/diff-options.txt:233 en/git-apply.txt:45
#, ignore-same, no-wrap, priority:280
msgid "--numstat"
msgstr "--numstat"

#. type: Plain text
#: en/diff-options.txt:239
#, fuzzy, priority:280
msgid "Similar to `--stat`, but shows number of added and deleted lines in decimal notation and pathname without abbreviation, to make it more machine friendly.  For binary files, outputs two `-` instead of saying `0 0`."
msgstr "类似于 `--stat`，但是使用小数点和不含缩写的路径名显示添加和删除的行数，使其对程序更友好。对于二进制文件，输出两个 `-`，而不是 `0 0`。"

#. type: Labeled list
#: en/diff-options.txt:240
#, ignore-same, no-wrap, priority:280
msgid "--shortstat"
msgstr "--shortstat"

#. type: Plain text
#: en/diff-options.txt:244
#, fuzzy, priority:280
msgid "Output only the last line of the `--stat` format containing total number of modified files, as well as number of added and deleted lines."
msgstr "只输出使用 `--stat` 选项输出的最后一行，包含修改的文件总数，添加和删除的行数。"

#. type: Labeled list
#: en/diff-options.txt:245
#, fuzzy, ignore-ellipsis, no-wrap, priority:280
msgid "-X[<param1,param2,...>]"
msgstr "-X[<参数1,参数2,...>]"

#. type: Labeled list
#: en/diff-options.txt:246
#, fuzzy, ignore-ellipsis, no-wrap, priority:280
msgid "--dirstat[=<param1,param2,...>]"
msgstr "--dirstat[=<参数1,参数2,...>]"

#. type: Plain text
#: en/diff-options.txt:253
#, fuzzy, priority:280
msgid "Output the distribution of relative amount of changes for each sub-directory. The behavior of `--dirstat` can be customized by passing it a comma separated list of parameters.  The defaults are controlled by the `diff.dirstat` configuration variable (see linkgit:git-config[1]).  The following parameters are available:"
msgstr "输出每个子目录的相对变化量的分布。`--dirstat` 的行为可以通过传递一个以逗号分隔的参数列表来自定义。默认值由`diff.dirstat` 配置变量控制 (参见 linkgit:git-config[1])。以下是可用的参数："

#. type: Labeled list
#: en/diff-options.txt:255
#, ignore-same, no-wrap, priority:280
msgid "`changes`"
msgstr "`changes`"

#. type: Plain text
#: en/diff-options.txt:261
#, fuzzy, priority:280
msgid "Compute the dirstat numbers by counting the lines that have been removed from the source, or added to the destination. This ignores the amount of pure code movements within a file.  In other words, rearranging lines in a file is not counted as much as other changes.  This is the default behavior when no parameter is given."
msgstr "通过计算从源文件中删除的行数或添加到目标文件中的行数来计算分布状态的数字。这忽略了文件内的代码移动行为。也就是说，在文件中重新排列的行不会像其他变化一样被计算在内。这是在没有给出参数时的默认行为。"

#. type: Labeled list
#: en/diff-options.txt:261
#, ignore-same, no-wrap, priority:280
msgid "`lines`"
msgstr "`lines`"

#. type: Plain text
#: en/diff-options.txt:269
#, fuzzy, priority:280
msgid "Compute the dirstat numbers by doing the regular line-based diff analysis, and summing the removed/added line counts. (For binary files, count 64-byte chunks instead, since binary files have no natural concept of lines). This is a more expensive `--dirstat` behavior than the `changes` behavior, but it does count rearranged lines within a file as much as other changes. The resulting output is consistent with what you get from the other `--*stat` options."
msgstr "通过做常规基于行的差异分析，计算分布状态的数字，并将删除/添加的行数相加。(对于二进制文件，用64字节的块来计算，因为二进制文件没有行的概念)。在使用 `--dirstat` 时这个选项的行为开销比 `changes` 更大，但会对文件中重新排列的行进行计数。其得到的输出结果与其他的 `--*stat` 选项一致。"

#. type: Labeled list
#: en/diff-options.txt:269
#, ignore-same, no-wrap, priority:280
msgid "`files`"
msgstr "`files`"

#. type: Plain text
#: en/diff-options.txt:274
#, fuzzy, priority:280
msgid "Compute the dirstat numbers by counting the number of files changed.  Each changed file counts equally in the dirstat analysis. This is the computationally cheapest `--dirstat` behavior, since it does not have to look at the file contents at all."
msgstr "通过计算被改变的文件数量来计算分布状态的数字。在分布状态分析中，每一个被改变的文件都会被平等地计算。这是计算上开销最小的 `--dirstat` 行为，因为它无需查看文件内容。"

#. type: Labeled list
#: en/diff-options.txt:274
#, ignore-same, no-wrap, priority:280
msgid "`cumulative`"
msgstr "`cumulative`"

#. type: Plain text
#: en/diff-options.txt:279
#, fuzzy, priority:280
msgid "Count changes in a child directory for the parent directory as well.  Note that when using `cumulative`, the sum of the percentages reported may exceed 100%. The default (non-cumulative) behavior can be specified with the `noncumulative` parameter."
msgstr "子目录中的变化计算到父目录中。 注意，当使用 `cumulative` 选项时，报告的百分比之和可能超过100%。默认的（非累积）行为可以用 `noncumulative` 参数指定。"

#. type: Labeled list
#: en/diff-options.txt:279 en/git-cherry.txt:39
#, no-wrap, priority:280
msgid "<limit>"
msgstr "<limit>"

#. type: Plain text
#: en/diff-options.txt:283
#, fuzzy, priority:280
msgid "An integer parameter specifies a cut-off percent (3% by default).  Directories contributing less than this percentage of the changes are not shown in the output."
msgstr "一个整数参数，其指定一个截止百分比（默认为3%）。贡献值小于这个百分比的目录不显示在输出中。"

#. type: Plain text
#: en/diff-options.txt:289
#, fuzzy, priority:280
msgid "Example: The following will count changed files, while ignoring directories with less than 10% of the total amount of changed files, and accumulating child directory counts in the parent directories: `--dirstat=files,10,cumulative`."
msgstr "例如：下面的参数会统计更改的文件，同时忽略占更改文件总数10%以下的目录，并累积父目录中的子目录计数：`--dirstat=files,10,cumulative`。"

#. type: Labeled list
#: en/diff-options.txt:290
#, ignore-same, no-wrap, priority:280
msgid "--cumulative"
msgstr "--cumulative"

#. type: Plain text
#: en/diff-options.txt:292
#, priority:280
msgid "Synonym for --dirstat=cumulative"
msgstr "--dirstat=cumulative 同义"

#. type: Labeled list
#: en/diff-options.txt:293
#, fuzzy, ignore-ellipsis, no-wrap, priority:280
msgid "--dirstat-by-file[=<param1,param2>...]"
msgstr "--dirstat-byfile[=<参数1,参数2>...]"

#. type: Plain text
#: en/diff-options.txt:295
#, fuzzy, ignore-ellipsis, priority:280
msgid "Synonym for --dirstat=files,param1,param2..."
msgstr "--dirstat=files,param1,param2... 的同义词。"

#. type: Labeled list
#: en/diff-options.txt:296 en/git-apply.txt:52 en/git-shortlog.txt:35 en/merge-options.txt:168
#, ignore-same, no-wrap, priority:280
msgid "--summary"
msgstr "--summary"

#. type: Plain text
#: en/diff-options.txt:299
#, fuzzy, priority:280
msgid "Output a condensed summary of extended header information such as creations, renames and mode changes."
msgstr "输出扩展头信息，如创建、重命名和模式变化等，的压缩摘要。"

#. type: Labeled list
#: en/diff-options.txt:301
#, ignore-same, no-wrap, priority:280
msgid "--patch-with-stat"
msgstr "--patch-with-stat"

#. type: Plain text
#: en/diff-options.txt:303
#, priority:280
msgid "Synonym for `-p --stat`."
msgstr "同义词 '-p --stat'。"

#. type: Labeled list
#: en/diff-options.txt:307 en/git-apply.txt:116 en/git-cat-file.txt:251 en/git-check-attr.txt:34 en/git-check-ignore.txt:47 en/git-checkout-index.txt:73 en/git-commit.txt:158 en/git-config.txt:229 en/git-grep.txt:176 en/git-ls-files.txt:99 en/git-ls-tree.txt:55 en/git-merge-tree.txt:43 en/git-mktree.txt:23 en/git-status.txt:126 en/git-update-index.txt:173 en/git-worktree.txt:245
#, ignore-same, no-wrap, priority:280
msgid "-z"
msgstr "-z"

#. type: Plain text
#: en/diff-options.txt:310
#, fuzzy, no-wrap, priority:280
msgid "\tSeparate the commits with NULs instead of with new newlines.\n"
msgstr "\t用 NUL 而不是用换行来分隔提交。\n"

#. type: Plain text
#: en/diff-options.txt:313
#, fuzzy, priority:280
msgid "Also, when `--raw` or `--numstat` has been given, do not munge pathnames and use NULs as output field terminators."
msgstr "另外，当给出 `--raw` 或 `--numstat` 时，不合并路径名，并使用 NUL 作为输出字段终止符。"

#. type: Plain text
#: en/diff-options.txt:317
#, fuzzy, no-wrap, priority:280
msgid ""
"\tWhen `--raw`, `--numstat`, `--name-only` or `--name-status` has been\n"
"\tgiven, do not munge pathnames and use NULs as output field terminators.\n"
msgstr ""
"\t另外，当给出 `--raw` 或 `--numstat` 时，\n"
"\t不合并路径名，并使用 NUL 作为输出字段终止符。\n"

#. type: Plain text
#: en/diff-options.txt:322 en/git-apply.txt:123
#, fuzzy, priority:280
msgid "Without this option, pathnames with \"unusual\" characters are quoted as explained for the configuration variable `core.quotePath` (see linkgit:git-config[1])."
msgstr "如果没有这个选项，带 \"不常见\" 字符的路径名会被引用，正如配置变量 `core.quotePath` 所解释的那样（参见 linkgit:git-config[1]）。"

#. type: Labeled list
#: en/diff-options.txt:323 en/git-config.txt:238 en/git-grep.txt:158 en/git-ls-tree.txt:59 en/git-merge-tree.txt:49 en/git-name-rev.txt:74
#, ignore-same, no-wrap, priority:280
msgid "--name-only"
msgstr "--name-only"

#. type: Plain text
#: en/diff-options.txt:327
#, priority:280
msgid "Show only names of changed files. The file names are often encoded in UTF-8.  For more information see the discussion about encoding in the linkgit:git-log[1] manual page."
msgstr "只显示更改过的文件的名称。文件名通常以 UTF-8 编码。  更多信息见 linkgit:git-log[1] 手册页中关于编码的讨论。"

#. type: Labeled list
#: en/diff-options.txt:328 en/git-ls-tree.txt:60
#, ignore-same, no-wrap, priority:280
msgid "--name-status"
msgstr "--name-status"

#. type: Plain text
#: en/diff-options.txt:332
#, fuzzy, priority:280
msgid "Show only names and status of changed files. See the description of the `--diff-filter` option on what the status letters mean.  Just like `--name-only` the file names are often encoded in UTF-8."
msgstr "仅显示已更改文件的名称和状态。有关状态字母的含义，请参阅 `--diff-filter` 选项的说明。"

#. type: Labeled list
#: en/diff-options.txt:333
#, fuzzy, no-wrap, priority:280
msgid "--submodule[=<format>]"
msgstr "--submodule[=<格式>]"

#. type: Plain text
#: en/diff-options.txt:344
#, fuzzy, priority:280
msgid "Specify how differences in submodules are shown.  When specifying `--submodule=short` the 'short' format is used.  This format just shows the names of the commits at the beginning and end of the range.  When `--submodule` or `--submodule=log` is specified, the 'log' format is used.  This format lists the commits in the range like linkgit:git-submodule[1] `summary` does.  When `--submodule=diff` is specified, the 'diff' format is used.  This format shows an inline diff of the changes in the submodule contents between the commit range.  Defaults to `diff.submodule` or the 'short' format if the config option is unset."
msgstr "指定子模块中的差异如何显示。当指定 `--submodule=short` 选项时，会使用 'short' 格式。这种格式只显示范围的开头和结尾处的提交名称。当指定了 `--submodule=short` 或  `--submodule=log` 时，会使用 'log' 格式。这种格式会像 linkgit:git-submodule[1]  `summary` 那样，列出该范围内的提交。当指定了 `--submodule=diff` 时，会使用 'diff' 格式。这个格式显示的是子模块内在提交范围之间的变化差异。默认为 `diff.submodule`，如果配置选项未设置， 则为 `short` 格式。"

#. type: Labeled list
#: en/diff-options.txt:345 en/git-branch.txt:145 en/git-for-each-ref.txt:66 en/git-grep.txt:193 en/git-show-branch.txt:118 en/git-tag.txt:125
#, no-wrap, priority:280
msgid "--color[=<when>]"
msgstr "--color[=<when>]"

#. type: Plain text
#: en/diff-options.txt:349
#, fuzzy, priority:280
msgid "Show colored diff.  `--color` (i.e. without '=<when>') is the same as `--color=always`.  '<when>' can be one of `always`, `never`, or `auto`."
msgstr "显示有颜色的差异。`--color`（即不含 '=<何时>'）与 `--color=always` 相同。'<何时>' 可以是 `always`、`never` 或 `auto`。"

#. type: Plain text
#: en/diff-options.txt:352
#, fuzzy, no-wrap, priority:280
msgid ""
"\tIt can be changed by the `color.ui` and `color.diff`\n"
"\tconfiguration settings.\n"
msgstr ""
"\t它可以通过 `color.ui` 和 `color.diff` 来改变\n"
"\t配置设置。\n"

#. type: Labeled list
#: en/diff-options.txt:354 en/git-branch.txt:150 en/git-grep.txt:197 en/git-show-branch.txt:123
#, ignore-same, no-wrap, priority:280
msgid "--no-color"
msgstr "--no-color"

#. type: Plain text
#: en/diff-options.txt:356
#, fuzzy, priority:280
msgid "Turn off colored diff."
msgstr "关掉带彩色显示的差异。"

#. type: Plain text
#: en/diff-options.txt:358
#, fuzzy, no-wrap, priority:280
msgid "\tThis can be used to override configuration settings.\n"
msgstr "\t这可以用来覆盖配置设置。\n"

#. type: Plain text
#: en/diff-options.txt:360
#, fuzzy, no-wrap, priority:280
msgid "\tIt is the same as `--color=never`.\n"
msgstr "\t这和 `--color=never` 相同。\n"

#. type: Labeled list
#: en/diff-options.txt:361
#, no-wrap, priority:280
msgid "--color-moved[=<mode>]"
msgstr "--color-moved[=<模式>]"

#. type: Plain text
#: en/diff-options.txt:363
#, fuzzy, priority:280
msgid "Moved lines of code are colored differently."
msgstr "移动的代码行的颜色不同。"

#. type: Plain text
#: en/diff-options.txt:365
#, fuzzy, no-wrap, priority:280
msgid "\tIt can be changed by the `diff.colorMoved` configuration setting.\n"
msgstr "\t它可以通过 `diff.colorMoved` 配置设置来改变。\n"

#. type: Plain text
#: en/diff-options.txt:369
#, fuzzy, no-wrap, priority:280
msgid ""
"\tThe <mode> defaults to 'no' if the option is not given\n"
"\tand to 'zebra' if the option with no mode is given.\n"
"\tThe mode must be one of:\n"
msgstr ""
"\t如果没有给出该选项，<模式> 默认为 'no'\n"
"\t如果没有给定模式选项，则为 'zebra'。\n"
"\t该模式必须以下其中之一：\n"

#. type: Labeled list
#: en/diff-options.txt:371 en/diff-options.txt:413
#, ignore-same, no-wrap, priority:280
msgid "no"
msgstr "no"

#. type: Plain text
#: en/diff-options.txt:373
#, fuzzy, priority:280
msgid "Moved lines are not highlighted."
msgstr "被移动的行不突出显示。"

#. type: Labeled list
#: en/diff-options.txt:373 en/git-commit.txt:252
#, ignore-same, no-wrap, priority:280
msgid "default"
msgstr "default"

#. type: Plain text
#: en/diff-options.txt:376
#, fuzzy, priority:280
msgid "Is a synonym for `zebra`. This may change to a more sensible mode in the future."
msgstr "是 `zebra` 的同义词。今后可能会改成更合理的模式。"

#. type: Labeled list
#: en/diff-options.txt:376 en/diff-options.txt:445
#, ignore-same, no-wrap, priority:280
msgid "plain"
msgstr "plain"

#. type: Plain text
#: en/diff-options.txt:383
#, fuzzy, priority:280
msgid "Any line that is added in one location and was removed in another location will be colored with 'color.diff.newMoved'.  Similarly 'color.diff.oldMoved' will be used for removed lines that are added somewhere else in the diff. This mode picks up any moved line, but it is not very useful in a review to determine if a block of code was moved without permutation."
msgstr "任何在某个位置被添加，且在另一个位置被删除的行，都会被用 'color.diff.newMoved' 着色。同样的，在差异中在某处删除且在其它地方添加的行会使用 'color.diff.oldMoved' 着色。这种模式可以读取任何被移动的行，但在代码审查中，它不能确定一个代码块是否未经排列而进行了移动。"

#. type: Labeled list
#: en/diff-options.txt:383
#, ignore-same, no-wrap, priority:280
msgid "blocks"
msgstr "blocks"

#. type: Plain text
#: en/diff-options.txt:388
#, fuzzy, priority:280
msgid "Blocks of moved text of at least 20 alphanumeric characters are detected greedily. The detected blocks are painted using either the 'color.diff.{old,new}Moved' color.  Adjacent blocks cannot be told apart."
msgstr "使用贪心方法检测含至少20个字母数字字符的移动文本块。检测到的区块使用 'color.diff.{old,new}Moved' 的颜色。相邻的区块不能被区分开。"

#. type: Labeled list
#: en/diff-options.txt:388
#, ignore-same, no-wrap, priority:280
msgid "zebra"
msgstr "zebra"

#. type: Plain text
#: en/diff-options.txt:393
#, fuzzy, priority:280
msgid "Blocks of moved text are detected as in 'blocks' mode. The blocks are painted using either the 'color.diff.{old,new}Moved' color or 'color.diff.{old,new}MovedAlternative'. The change between the two colors indicates that a new block was detected."
msgstr "在“块”模式下检测到移动的文本块。块使用 'color.diff.{old,new}Moved' 颜色或 'color.diff.{old,new}MovedAlternative' 颜色。这两种颜色之间的变化表示检测到了新的块。"

#. type: Labeled list
#: en/diff-options.txt:393
#, ignore-same, no-wrap, priority:280
msgid "dimmed-zebra"
msgstr "dimmed-zebra"

#. type: Plain text
#: en/diff-options.txt:398
#, fuzzy, priority:280
msgid "Similar to 'zebra', but additional dimming of uninteresting parts of moved code is performed. The bordering lines of two adjacent blocks are considered interesting, the rest is uninteresting.  `dimmed_zebra` is a deprecated synonym."
msgstr "类似于  'zebra' 模式，但对=使移动的代码中不关注的部分变暗。相邻两个区块的边界线被认为是重要，其余的部分是无关紧要的。`dimmed_zebra` 是一个被废弃的同义词。"

#. type: Labeled list
#: en/diff-options.txt:400
#, ignore-same, no-wrap, priority:280
msgid "--no-color-moved"
msgstr "--no-color-moved"

#. type: Plain text
#: en/diff-options.txt:403
#, fuzzy, priority:280
msgid "Turn off move detection. This can be used to override configuration settings. It is the same as `--color-moved=no`."
msgstr "关闭移动检测。这可以用来覆盖配置设置。它与 `--color-moved=no` 相同。"

#. type: Labeled list
#: en/diff-options.txt:404
#, no-wrap, priority:280
msgid "--color-moved-ws=<modes>"
msgstr "--color-moved-ws=<模式>"

#. type: Plain text
#: en/diff-options.txt:407
#, fuzzy, priority:280
msgid "This configures how whitespace is ignored when performing the move detection for `--color-moved`."
msgstr "这将配置在执行 `--color-moved` 的移动检测时如何忽略空格。"

#. type: Plain text
#: en/diff-options.txt:409
#, fuzzy, no-wrap, priority:280
msgid "\tIt can be set by the `diff.colorMovedWS` configuration setting.\n"
msgstr "\t可以通过 `diff.colorMovedWS` 来设置。\n"

#. type: Plain text
#: en/diff-options.txt:411
#, fuzzy, no-wrap, priority:280
msgid "\tThese modes can be given as a comma separated list:\n"
msgstr "\t这些模式可以通过以逗号分隔的列表给出：\n"

#. type: Plain text
#: en/diff-options.txt:415
#, fuzzy, priority:280
msgid "Do not ignore whitespace when performing move detection."
msgstr "执行移动检测时不忽略空格。"

#. type: Labeled list
#: en/diff-options.txt:415 en/merge-strategies.txt:43
#, ignore-same, no-wrap, priority:280
msgid "ignore-space-at-eol"
msgstr "ignore-space-at-eol"

#. type: Plain text
#: en/diff-options.txt:417 en/diff-options.txt:771
#, fuzzy, priority:280
msgid "Ignore changes in whitespace at EOL."
msgstr "忽略行尾空格的变化。"

#. type: Labeled list
#: en/diff-options.txt:417 en/merge-strategies.txt:41
#, ignore-same, no-wrap, priority:280
msgid "ignore-space-change"
msgstr "ignore-space-change"

#. type: Plain text
#: en/diff-options.txt:421 en/diff-options.txt:777
#, fuzzy, priority:280
msgid "Ignore changes in amount of whitespace.  This ignores whitespace at line end, and considers all other sequences of one or more whitespace characters to be equivalent."
msgstr "忽略空格数量的变化。这会忽略行尾的空格，并认为包含一个或多个空格字符的其他序列都是等同的。"

#. type: Labeled list
#: en/diff-options.txt:421 en/merge-strategies.txt:42
#, ignore-same, no-wrap, priority:280
msgid "ignore-all-space"
msgstr "ignore-all-space"

#. type: Plain text
#: en/diff-options.txt:424
#, fuzzy, priority:280
msgid "Ignore whitespace when comparing lines. This ignores differences even if one line has whitespace where the other line has none."
msgstr "比较行时忽略空格。即使一行有空格而另一行没有空格，也会忽略差异。"

#. type: Labeled list
#: en/diff-options.txt:424
#, ignore-same, no-wrap, priority:280
msgid "allow-indentation-change"
msgstr "allow-indentation-change"

#. type: Plain text
#: en/diff-options.txt:429
#, fuzzy, priority:280
msgid "Initially ignore any whitespace in the move detection, then group the moved code blocks only into a block if the change in whitespace is the same per line. This is incompatible with the other modes."
msgstr "在最初移动检测中忽略的任何空格，然后只在每行的空格变化相同的情况下，将移动的代码块归为一个块。这与其他模式是不兼容的。"

#. type: Labeled list
#: en/diff-options.txt:431
#, ignore-same, no-wrap, priority:280
msgid "--no-color-moved-ws"
msgstr "--no-color-moved-ws"

#. type: Plain text
#: en/diff-options.txt:435
#, fuzzy, priority:280
msgid "Do not ignore whitespace when performing move detection. This can be used to override configuration settings. It is the same as `--color-moved-ws=no`."
msgstr "执行移动检测时，不忽略空格。这可以用来覆盖配置。它与 `--color-moved-ws=no` 相同。"

#. type: Labeled list
#: en/diff-options.txt:436
#, fuzzy, no-wrap, priority:280
msgid "--word-diff[=<mode>]"
msgstr "--word-diff[=<模式>]"

#. type: Plain text
#: en/diff-options.txt:441
#, fuzzy, priority:280
msgid "Show a word diff, using the <mode> to delimit changed words.  By default, words are delimited by whitespace; see `--word-diff-regex` below.  The <mode> defaults to 'plain', and must be one of:"
msgstr "显示词的差异，用 <模式> 来分隔已更改的词。默认情况下，单词是以空格分隔；请参考 `--word-diff-regex`。<模式> 默认为 `plain`，并且必须是以下其中之一："

#. type: Plain text
#: en/diff-options.txt:445
#, fuzzy, priority:280
msgid "Highlight changed words using only colors.  Implies `--color`."
msgstr "只用颜色突出显示已更改的单词。暗含 `--color` 选项。"

#. type: Plain text
#: en/diff-options.txt:449
#, fuzzy, priority:280
msgid "Show words as `[-removed-]` and `{+added+}`.  Makes no attempts to escape the delimiters if they appear in the input, so the output may be ambiguous."
msgstr "显示更改的词为 `[-removed-]` 和 `{+added+}`。如果在输入中出现定界符，则不尝试转义，所以输出可能是多义的。"

#. type: Labeled list
#: en/diff-options.txt:449
#, ignore-same, no-wrap, priority:280
msgid "porcelain"
msgstr "porcelain"

#. type: Plain text
#: en/diff-options.txt:456
#, fuzzy, priority:280
msgid "Use a special line-based format intended for script consumption.  Added/removed/unchanged runs are printed in the usual unified diff format, starting with a `+`/`-`/` ` character at the beginning of the line and extending to the end of the line.  Newlines in the input are represented by a tilde `~` on a line of its own."
msgstr "使用一种特殊的、基于行的格式，供脚本使用。添加/删除/未更改的运行数据以通常的统一的差异格式输出，行的开头以 `+`/`-`/` ` 字符开始，一直到行的结尾。输入中的新行用单行上的 `~`表示。"

#. type: Labeled list
#: en/diff-options.txt:456 en/git-daemon.txt:131 en/git-submodule.txt:178
#, ignore-same, no-wrap, priority:280
msgid "none"
msgstr "none"

#. type: Plain text
#: en/diff-options.txt:458
#, fuzzy, priority:280
msgid "Disable word diff again."
msgstr "再次禁用单词差异模式。"

#. type: Plain text
#: en/diff-options.txt:462
#, fuzzy, priority:280
msgid "Note that despite the name of the first mode, color is used to highlight the changed parts in all modes if enabled."
msgstr "请注意，无论第一个模式的名称是什么，如果启用该选项，将在所有模式中使用颜色，以高亮显示更改的部分。"

#. type: Labeled list
#: en/diff-options.txt:463
#, fuzzy, no-wrap, priority:280
msgid "--word-diff-regex=<regex>"
msgstr "--word-diff-regex=<正则表达式>"

#. type: Plain text
#: en/diff-options.txt:467
#, fuzzy, priority:280
msgid "Use <regex> to decide what a word is, instead of considering runs of non-whitespace to be a word.  Also implies `--word-diff` unless it was already enabled."
msgstr "使用 <正则表达式> 来确定单词的格式，而不是将一串非空白行视为单词。除非已启用，否则还暗含 `--word-diff` 选项。"

#. type: Plain text
#: en/diff-options.txt:475
#, fuzzy, priority:280
msgid "Every non-overlapping match of the <regex> is considered a word.  Anything between these matches is considered whitespace and ignored(!) for the purposes of finding differences.  You may want to append `|[^[:space:]]` to your regular expression to make sure that it matches all non-whitespace characters.  A match that contains a newline is silently truncated(!) at the newline."
msgstr "<正则表达式> 匹配的的每一个非重叠的匹配都被视为一个单词。在这些匹配项之间的任何内容都被认为是空白，并且在查找差异时被忽略(!)。您可能需要在您的正则表达式中附加 `|[^[:space:]]`，以确保它匹配所有非空格字符。包含换行的匹配会在换行处被截断(!)。"

#. type: Plain text
#: en/diff-options.txt:478
#, fuzzy, priority:280
msgid "For example, `--word-diff-regex=.` will treat each character as a word and, correspondingly, show differences character by character."
msgstr "例如，`--word-diff-regex=.` 将把每个字符当作一个单词，并相应地逐个字符显示差异。"

#. type: Plain text
#: en/diff-options.txt:483
#, fuzzy, priority:280
msgid "The regex can also be set via a diff driver or configuration option, see linkgit:gitattributes[5] or linkgit:git-config[1].  Giving it explicitly overrides any diff driver or configuration setting.  Diff drivers override configuration settings."
msgstr "正则表达式也可以通过差异程序或配置选项来设置，参见 linkgit:gitattributes[5] 或 linkgit:git-config[1]。显式指明会覆盖任何程序或配置。差异程序会覆盖配置。"

#. type: Labeled list
#: en/diff-options.txt:484
#, no-wrap, priority:280
msgid "--color-words[=<regex>]"
msgstr "--color-words[=<正则表达式>]"

#. type: Plain text
#: en/diff-options.txt:487
#, fuzzy, priority:280
msgid "Equivalent to `--word-diff=color` plus (if a regex was specified) `--word-diff-regex=<regex>`."
msgstr "与 `--word-diff=color` 和（如果指明了正则表达式）`--word-diff-regex=<正则表达式>` 两个选项含义相同。"

#. type: Labeled list
#: en/diff-options.txt:489 en/git-status.txt:143
#, ignore-same, no-wrap, priority:280
msgid "--no-renames"
msgstr "--no-renames"

#. type: Plain text
#: en/diff-options.txt:492
#, fuzzy, priority:280
msgid "Turn off rename detection, even when the configuration file gives the default to do so."
msgstr "关闭重命名检测，即使配置文件给出的默认是这样做。"

#. type: Labeled list
#: en/diff-options.txt:493
#, ignore-same, no-wrap, priority:280
msgid "--[no-]rename-empty"
msgstr "--[no-]rename-empty"

#. type: Plain text
#: en/diff-options.txt:495
#, fuzzy, priority:280
msgid "Whether to use empty blobs as rename source."
msgstr "是否使用空的数据对象作为重命名源。"

#. type: Labeled list
#: en/diff-options.txt:497 en/git-apply.txt:58
#, ignore-same, no-wrap, priority:280
msgid "--check"
msgstr "--check"

#. type: Plain text
#: en/diff-options.txt:506
#, fuzzy, priority:280
msgid "Warn if changes introduce conflict markers or whitespace errors.  What are considered whitespace errors is controlled by `core.whitespace` configuration.  By default, trailing whitespaces (including lines that consist solely of whitespaces) and a space character that is immediately followed by a tab character inside the initial indent of the line are considered whitespace errors.  Exits with non-zero status if problems are found. Not compatible with --exit-code."
msgstr "如果更改引入冲突标记或空格错误，则发出警告。哪些被认为是空格错误是由 `core.whitespace` 配置控制的。默认情况下，行尾部的空格字符（包括仅由空格字符组成的行）和紧跟在行初缩进内 tab 字符后的空格字符，都被认为是空格字符错误。如果发现问题，则以非零状态退出。与 --exit-code 选项不兼容。"

#. type: Labeled list
#: en/diff-options.txt:507
#, fuzzy, no-wrap, priority:280
msgid "--ws-error-highlight=<kind>"
msgstr "--ws-error-highlight=<种类>"

#. type: Plain text
#: en/diff-options.txt:516
#, fuzzy, priority:280
msgid "Highlight whitespace errors in the `context`, `old` or `new` lines of the diff.  Multiple values are separated by comma, `none` resets previous values, `default` reset the list to `new` and `all` is a shorthand for `old,new,context`.  When this option is not given, and the configuration variable `diff.wsErrorHighlight` is not set, only whitespace errors in `new` lines are highlighted. The whitespace errors are colored with `color.diff.whitespace`."
msgstr "突出显示差异中 `context`（上下文）、`old`（旧）或 `new`（新）行中的空格错误。多个值用逗号隔开，`none` 选项会重置以前的值，`default` 重置列表为 ·new`，`all` 是 `old,new,context` 的简写。当没有给定这个选项，并且配置变量 `diff.wsErrorHighlight``没有设置时，只有 `new` 行中的空格错误会被高亮显示。空格错误会用 `color.diff.whitespace` 配置进行着色。"

#. type: Labeled list
#: en/diff-options.txt:519
#, ignore-same, no-wrap, priority:280
msgid "--full-index"
msgstr "--full-index"

#. type: Plain text
#: en/diff-options.txt:523
#, fuzzy, priority:280
msgid "Instead of the first handful of characters, show the full pre- and post-image blob object names on the \"index\" line when generating patch format output."
msgstr "在生成补丁格式输出时，在 `index`（索引）行上显示完整的图像前和图像后数据对象名称，而不仅是前几个字符。"

#. type: Labeled list
#: en/diff-options.txt:524 en/git-apply.txt:161
#, ignore-same, no-wrap, priority:280
msgid "--binary"
msgstr "--binary"

#. type: Plain text
#: en/diff-options.txt:527
#, fuzzy, priority:280
msgid "In addition to `--full-index`, output a binary diff that can be applied with `git-apply`."
msgstr "除了 `--full-index`输出的差异之外，输出二进制的差异。其可以用 `git-apply` 命令来应用。暗含 `--patch` 选项。"

#. type: Labeled list
#: en/diff-options.txt:531 en/git-ls-files.txt:184 en/git-ls-tree.txt:72 en/git-show-ref.txt:65
#, fuzzy, no-wrap, priority:280
msgid "--abbrev[=<n>]"
msgstr "--abbrev[=<n>]"

#. type: Plain text
#: en/diff-options.txt:540
#, fuzzy, priority:280
#| msgid "Instead of showing the full 40-byte hexadecimal object name in diff-raw format output and diff-tree header lines, show only a partial prefix.  This is independent of the `--full-index` option above, which controls the diff-patch output format.  Non default number of digits can be specified with `--abbrev=<n>`."
msgid "Instead of showing the full 40-byte hexadecimal object name in diff-raw format output and diff-tree header lines, show the shortest prefix that is at least '<n>' hexdigits long that uniquely refers the object.  In diff-patch output format, `--full-index` takes higher precedence, i.e. if `--full-index` is specified, full blob names will be shown regardless of `--abbrev`.  Non default number of digits can be specified with `--abbrev=<n>`."
msgstr "在 diff-raw（原始差异）格式输出和 diff-tree（树状差异）头行中，不显示完整的 40 字节十六进制对象名称，而只显示部分前缀。这与上面的 `--full-index` 选项无关，后者控制了 diff-patch（差异补丁）的输出格式。非默认的位数可以用 `--abbrev=<n>` 指定。"

#. type: Labeled list
#: en/diff-options.txt:541
#, fuzzy, no-wrap, priority:280
msgid "-B[<n>][/<m>]"
msgstr "-B[<n>][/<m>]"

#. type: Labeled list
#: en/diff-options.txt:542
#, fuzzy, no-wrap, priority:280
msgid "--break-rewrites[=[<n>][/<m>]]"
msgstr "--break-rewrites[=[<n>][/<m>]]"

#. type: Plain text
#: en/diff-options.txt:545
#, fuzzy, priority:280
msgid "Break complete rewrite changes into pairs of delete and create. This serves two purposes:"
msgstr "将完整的重写更改切分成删除和创建对（pair）。这有两个目的："

#. type: Plain text
#: en/diff-options.txt:555
#, fuzzy, priority:280
msgid "It affects the way a change that amounts to a total rewrite of a file not as a series of deletion and insertion mixed together with a very few lines that happen to match textually as the context, but as a single deletion of everything old followed by a single insertion of everything new, and the number `m` controls this aspect of the -B option (defaults to 60%). `-B/70%` specifies that less than 30% of the original should remain in the result for Git to consider it a total rewrite (i.e. otherwise the resulting patch will be a series of deletion and insertion mixed together with context lines)."
msgstr "它会影响决定更改形式的阈值，当单个文件内修改总量达到一定值时，会认为该文件进行了完全重写，而不是将一系列删除和插入操作视为修改。如果视为多个删除和插入修改，修改中的行可能会碰巧在文本上与原文一致，从而被当作上下文。选项中的数字 `m` 控制 -B 选项的这一方面（默认为 60％）。`-B/70％` 表示，如果在结果中保留的原始内容少于原始内容的30％，则 Git 认为它是完全重写的（否则，生成的补丁将是一系列删除和插入，并与上下文行混合在一起）。"

#. type: Plain text
#: en/diff-options.txt:563
#, fuzzy, priority:280
msgid "When used with -M, a totally-rewritten file is also considered as the source of a rename (usually -M only considers a file that disappeared as the source of a rename), and the number `n` controls this aspect of the -B option (defaults to 50%). `-B20%` specifies that a change with addition and deletion compared to 20% or more of the file's size are eligible for being picked up as a possible source of a rename to another file."
msgstr "使用 -M 选项时，一个完全改写的文件也被认为是重命名文件的来源（通常 -M 只考查一个消失文件作为重命名的来源)。选项中的数量 `n` 控制 -B 选项的这一方面（默认为 50％)。`-B20%` 表明，当插入与删除比 20％ 的文件大小更多，该文件可作为重命名到另一文件的可能来源。"

#. type: Labeled list
#: en/diff-options.txt:564
#, fuzzy, no-wrap, priority:280
msgid "-M[<n>]"
msgstr "-M[<n>]"

#. type: Labeled list
#: en/diff-options.txt:565 en/git-status.txt:147
#, fuzzy, no-wrap, priority:280
msgid "--find-renames[=<n>]"
msgstr "--find-renames[=<n>]"

#. type: Plain text
#: en/diff-options.txt:568
#, fuzzy, no-wrap, priority:280
msgid "\tDetect renames.\n"
msgstr "\t重命名检测。\n"

#. type: Plain text
#: en/diff-options.txt:573
#, fuzzy, no-wrap, priority:280
msgid ""
"\tIf generating diffs, detect and report renames for each commit.\n"
"\tFor following files across renames while traversing history, see\n"
"\t`--follow`.\n"
msgstr ""
"\t如果制成差异，检测并报告每个提交中的重命名。\n"
"\t对于每个在遍历历史时重命名的文件，参见\n"
"\t`--follow`。\n"

#. type: Plain text
#: en/diff-options.txt:583
#, no-wrap, priority:280
msgid ""
"\tIf `n` is specified, it is a threshold on the similarity\n"
"\tindex (i.e. amount of addition/deletions compared to the\n"
"\tfile's size). For example, `-M90%` means Git should consider a\n"
"\tdelete/add pair to be a rename if more than 90% of the file\n"
"\thasn't changed.  Without a `%` sign, the number is to be read as\n"
"\ta fraction, with a decimal point before it.  I.e., `-M5` becomes\n"
"\t0.5, and is thus the same as `-M50%`.  Similarly, `-M05` is\n"
"\tthe same as `-M5%`.  To limit detection to exact renames, use\n"
"\t`-M100%`.  The default similarity index is 50%.\n"
msgstr ""
"\t如果指定了 `n`，则其为相似度指数阈值（即相比于文件大小的增/删量）。\n"
"\t例如，`-M90％` 表示如果文件90％以上的内容没有更改，则 Git 应将删除/添加对视为重命名。\n"
"\t如果没有 `％` 符号，则该数字应作为小数读取，并在其前面加上小数点。\n"
" \t即 `-M5` 变为 0.5，因此与 `-M50％` 相同。 同样，`-M05` 与 `-M5％` 相同。\n"
" \t要将检测限制为精确的重命名，请使用 `-M100％`。 默认相似度指数为50％。\n"

#. type: Labeled list
#: en/diff-options.txt:584
#, fuzzy, no-wrap, priority:280
msgid "-C[<n>]"
msgstr "-C[<n>]"

#. type: Labeled list
#: en/diff-options.txt:585
#, fuzzy, no-wrap, priority:280
msgid "--find-copies[=<n>]"
msgstr "--find-copies[=<n>]"

#. type: Plain text
#: en/diff-options.txt:588
#, fuzzy, priority:280
msgid "Detect copies as well as renames.  See also `--find-copies-harder`.  If `n` is specified, it has the same meaning as for `-M<n>`."
msgstr "检测复制与重命名。参见 `--find-copies-harder`。如果指定了 `n`，则其与 `-M<n>` 含义相同。"

#. type: Labeled list
#: en/diff-options.txt:589 en/git-svn.txt:626
#, ignore-same, no-wrap, priority:280
msgid "--find-copies-harder"
msgstr "--find-copies-harder"

#. type: Plain text
#: en/diff-options.txt:597
#, fuzzy, priority:280
msgid "For performance reasons, by default, `-C` option finds copies only if the original file of the copy was modified in the same changeset.  This flag makes the command inspect unmodified files as candidates for the source of copy.  This is a very expensive operation for large projects, so use it with caution.  Giving more than one `-C` option has the same effect."
msgstr "出于性能考虑，默认情况下，`-C` 选项只在复制的原始文件在相同的变更集中被修改时才会查找复制。这个标志使命令检查未修改的文件作为复制源的候选文件。 对于大型项目来说，这是一个非常耗时的操作，所以要谨慎使用。 给出一个以上的 `-C` 选项有同样的效果。"

#. type: Labeled list
#: en/diff-options.txt:598 en/git-branch.txt:104 en/git-http-push.txt:45
#, no-wrap, priority:280
msgid "-D"
msgstr "-D"

#. type: Labeled list
#: en/diff-options.txt:599
#, ignore-same, no-wrap, priority:280
msgid "--irreversible-delete"
msgstr "--irreversible-delete"

#. type: Plain text
#: en/diff-options.txt:607
#, priority:280
msgid "Omit the preimage for deletes, i.e. print only the header but not the diff between the preimage and `/dev/null`. The resulting patch is not meant to be applied with `patch` or `git apply`; this is solely for people who want to just concentrate on reviewing the text after the change. In addition, the output obviously lacks enough information to apply such a patch in reverse, even manually, hence the name of the option."
msgstr "删除时省略原内容，即只打印头信息，而不打原内容和 `/dev/null` 之间的差异。所产生的补丁并不是要用于 `patch` 或 `git apply`；这只是为了让人们只专注于审查修改后的文本。此外，输出结果显然缺乏足够的信息来反转，或手动应用这样一个补丁，因此这个选项的名称如此。"

#. type: Plain text
#: en/diff-options.txt:610
#, priority:280
msgid "When used together with `-B`, omit also the preimage in the deletion part of a delete/create pair."
msgstr "当与 `-B` 一起使用时，也省略删除/创建对中删除部分的原内容。"

#. type: Labeled list
#: en/diff-options.txt:611 en/git-svn.txt:625
#, no-wrap, priority:280
msgid "-l<num>"
msgstr "-l<数量>"

#. type: Plain text
#: en/diff-options.txt:623
#, fuzzy, priority:280
msgid "The `-M` and `-C` options involve some preliminary steps that can detect subsets of renames/copies cheaply, followed by an exhaustive fallback portion that compares all remaining unpaired destinations to all relevant sources.  (For renames, only remaining unpaired sources are relevant; for copies, all original sources are relevant.)  For N sources and destinations, this exhaustive check is O(N^2).  This option prevents the exhaustive portion of rename/copy detection from running if the number of source/destination files involved exceeds the specified number.  Defaults to diff.renameLimit.  Note that a value of 0 is treated as unlimited."
msgstr "`-M` 和 `-C` 选项涉及一些初步步骤，可以廉价地检测重命名/副本的子集，然后是详尽的后备部分，将所有剩余的未配对目的地与所有相关源进行比较。 （对于重命名，只有剩余的未配对源是相关的；对于副本，所有原始源都是相关的。）对于 N 个源和目的地，这个详尽的检查是 O(N^2)。如果涉及的源/目标文件数量超过指定数量，则此选项可防止重命名/复制检测的详尽部分运行。默认为 diff.renameLimit。请注意，值 0 被视为无限制。"

#. type: Labeled list
#: en/diff-options.txt:625
#, ignore-ellipsis, no-wrap, priority:280
msgid "--diff-filter=[(A|C|D|M|R|T|U|X|B)...[*]]"
msgstr "--diff-filter=[(A|C|D|M|R|T|U|X|B)...[*]]"

#. type: Plain text
#: en/diff-options.txt:636
#, ignore-ellipsis, priority:280
msgid "Select only files that are Added (`A`), Copied (`C`), Deleted (`D`), Modified (`M`), Renamed (`R`), have their type (i.e. regular file, symlink, submodule, ...) changed (`T`), are Unmerged (`U`), are Unknown (`X`), or have had their pairing Broken (`B`).  Any combination of the filter characters (including none) can be used.  When `*` (All-or-none) is added to the combination, all paths are selected if there is any file that matches other criteria in the comparison; if there is no file that matches other criteria, nothing is selected."
msgstr "只选择添加（`A`）、复制（`C`）、删除（`D`）、修改（`M`）、重命名（`R`）、类型（即常规文件、符号链接、子模块......）改变（`T`）、未合并（`U`）、未知（`X`）或配对被破坏（`B`）的文件。可以使用过滤字符的任何组合（包括空）。当组合中加入 `*`（全部或空）时，如果在比较中有任何文件与其他条件匹配，则选择所有路径；如果没有符合其他条件的文件，则不会选择任何内容。"

#. type: Plain text
#: en/diff-options.txt:639
#, priority:280
msgid "Also, these upper-case letters can be downcased to exclude.  E.g.  `--diff-filter=ad` excludes added and deleted paths."
msgstr "另外，这些大写字母也可以通过使用小写排除。例如：`--diff-filter=ad` 排除添加和删除的路径。"

#. type: Plain text
#: en/diff-options.txt:642
#, fuzzy, priority:280
#| msgid "Note that not all diffs can feature all types. For instance, diffs from the index to the working tree can never have Added entries (because the set of paths included in the diff is limited by what is in the index).  Similarly, copied and renamed entries cannot appear if detection for those types is disabled."
msgid "Note that not all diffs can feature all types. For instance, copied and renamed entries cannot appear if detection for those types is disabled."
msgstr "请注意，并不是所有的差异都能包含所有类型。例如，从索引到工作树的差异永远不会有添加（Added）条目（因为差异中包含的路径集受索引中的内容的限制）。同样，如果禁止检测复制和重命名的条目，这些类型也不会出现。"

#. type: Labeled list
#: en/diff-options.txt:643
#, no-wrap, priority:280
msgid "-S<string>"
msgstr "-S<string>"

#. type: Plain text
#: en/diff-options.txt:647
#, priority:280
msgid "Look for differences that change the number of occurrences of the specified string (i.e. addition/deletion) in a file.  Intended for the scripter's use."
msgstr "寻找改变文件中指定字符串出现次数的差异（即增加/删除）。供脚本编写者使用。"

#. type: Plain text
#: en/diff-options.txt:653
#, fuzzy, priority:280
msgid "It is useful when you're looking for an exact block of code (like a struct), and want to know the history of that block since it first came into being: use the feature iteratively to feed the interesting block in the preimage back into `-S`, and keep going until you get the very first version of the block."
msgstr "当您正在寻找确切的代码块（如结构体），并且想知道该块自首次出现以来的历史记录时，这将非常有用：通过 `-S` 选项迭代，将原文件中的感兴趣的块显示出，并继续进行，直到获得该块的第一个版本。"

#. type: Plain text
#: en/diff-options.txt:655
#, priority:280
msgid "Binary files are searched as well."
msgstr "二进制文件也会被搜索到。"

#. type: Labeled list
#: en/diff-options.txt:656
#, no-wrap, priority:280
msgid "-G<regex>"
msgstr "-G<正则表达式>"

#. type: Plain text
#: en/diff-options.txt:659
#, priority:280
msgid "Look for differences whose patch text contains added/removed lines that match <regex>."
msgstr "查找其补丁文本包含与 <正则表达式> 匹配的添加/删除行的差异。"

#. type: Plain text
#: en/diff-options.txt:663
#, priority:280
msgid "To illustrate the difference between `-S<regex> --pickaxe-regex` and `-G<regex>`, consider a commit with the following diff in the same file:"
msgstr "为了说明 `-S<正则表达式> --pickaxe-regex` 和 `-G<正则表达式>` 之间的区别，假设某次提交在同一文件中有以下差异："

#. type: delimited block -
#: en/diff-options.txt:668
#, ignore-ellipsis, no-wrap, priority:280
msgid ""
"+    return frotz(nitfol, two->ptr, 1, 0);\n"
"...\n"
"-    hit = frotz(nitfol, mf2.ptr, 1, 0);\n"
msgstr ""
"+    return frotz(nitfol, two->ptr, 1, 0);\n"
"...\n"
"-    hit = frotz(nitfol, mf2.ptr, 1, 0);\n"

#. type: Plain text
#: en/diff-options.txt:673
#, priority:280
msgid "While `git log -G\"frotz\\(nitfol\"` will show this commit, `git log -S\"frotz\\(nitfol\" --pickaxe-regex` will not (because the number of occurrences of that string did not change)."
msgstr "`git log -G \"frotz\\(nitfol\"` 会显示这次提交，但 `git log -S \"frotz\\(nitfol\" --pickaxe-regex` 不会显示（因为该字符串的出现次数没有改变）。"

#. type: Plain text
#: en/diff-options.txt:676
#, fuzzy, priority:280
msgid "Unless `--text` is supplied patches of binary files without a textconv filter will be ignored."
msgstr "除非提供 `--text`，否则没有 textconv 过滤器的二进制文件补丁将被忽略。"

#. type: Plain text
#: en/diff-options.txt:679
#, priority:280
msgid "See the 'pickaxe' entry in linkgit:gitdiffcore[7] for more information."
msgstr "更多信息请参见 linkgit:gitdiffcore[7] 中的 'pickaxe' 条目。"

#. type: Labeled list
#: en/diff-options.txt:680
#, no-wrap, priority:280
msgid "--find-object=<object-id>"
msgstr "--find-object=<对象ID>"

#. type: Plain text
#: en/diff-options.txt:685
#, priority:280
msgid "Look for differences that change the number of occurrences of the specified object. Similar to `-S`, just the argument is different in that it doesn't search for a specific string but for a specific object id."
msgstr "查找指定对象出现次数的差异。与 `-S` 类似，只是参数不同：它不搜索特定的字符串，而是搜索特定的对象 id。"

#. type: Plain text
#: en/diff-options.txt:688
#, priority:280
msgid "The object can be a blob or a submodule commit. It implies the `-t` option in `git-log` to also find trees."
msgstr "该对象可以是一个 blob 或一个子模块提交。它意味着 `git-log` 中的 `-t` 选项也能找到工作树。"

#. type: Labeled list
#: en/diff-options.txt:689
#, ignore-same, no-wrap, priority:280
msgid "--pickaxe-all"
msgstr "--pickaxe-all"

#. type: Plain text
#: en/diff-options.txt:693
#, priority:280
msgid "When `-S` or `-G` finds a change, show all the changes in that changeset, not just the files that contain the change in <string>."
msgstr "当使用 `-S` 或 `-G` 选项找到一个更改时，显示该更改集中的所有更改，而不仅仅是显示包含 <string> 更改的文件。"

#. type: Labeled list
#: en/diff-options.txt:694
#, ignore-same, no-wrap, priority:280
msgid "--pickaxe-regex"
msgstr "--pickaxe-regex"

#. type: Plain text
#: en/diff-options.txt:697
#, priority:280
msgid "Treat the <string> given to `-S` as an extended POSIX regular expression to match."
msgstr "将 `-S` 选项的 <string> 参数当作扩展的 POSIX 正则表达式来匹配。"

#. type: Labeled list
#: en/diff-options.txt:700 en/git-mergetool.txt:96
#, no-wrap, priority:280
msgid "-O<orderfile>"
msgstr "-O<顺序控制文件>"

#. type: Plain text
#: en/diff-options.txt:705
#, priority:280
msgid "Control the order in which files appear in the output.  This overrides the `diff.orderFile` configuration variable (see linkgit:git-config[1]).  To cancel `diff.orderFile`, use `-O/dev/null`."
msgstr "控制文件在输出中出现的顺序。这将覆盖 `diff.orderFile` 配置变量（参见 linkgit:git-config[1]）。要取消 `diff.orderFile`，请使用 `-O/dev/null`。"

#. type: Plain text
#: en/diff-options.txt:717
#, priority:280
msgid "The output order is determined by the order of glob patterns in <orderfile>.  All files with pathnames that match the first pattern are output first, all files with pathnames that match the second pattern (but not the first) are output next, and so on.  All files with pathnames that do not match any pattern are output last, as if there was an implicit match-all pattern at the end of the file.  If multiple pathnames have the same rank (they match the same pattern but no earlier patterns), their output order relative to each other is the normal order."
msgstr "输出顺序由 <顺序控制文件> 中的 glob 模式的顺序决定。所有路径名与第一个模式匹配的文件首先输出，路径名与第二个模式匹配（但不与第一个模式匹配）的文件其次输出，以此类推。所有路径名与任何模式匹配的文件会最后输出，就像在文件末尾有一个隐含的全部匹配模式。如果多个路径名具有相同的等级（它们匹配相同的模式，但没有匹配先前的模式），它们相对于彼此的输出顺序是正常的。"

#. type: Plain text
#: en/diff-options.txt:719
#, priority:280
msgid "<orderfile> is parsed as follows:"
msgstr "<顺序控制文件> 格式如下："

#. type: Plain text
#: en/diff-options.txt:723
#, priority:280
msgid "Blank lines are ignored, so they can be used as separators for readability."
msgstr "空白行会被忽略，因此可以用它们作为分隔符，以保证可读性。"

#. type: Plain text
#: en/diff-options.txt:727
#, priority:280
msgid "Lines starting with a hash (\"`#`\") are ignored, so they can be used for comments.  Add a backslash (\"`\\`\") to the beginning of the pattern if it starts with a hash."
msgstr "以井号（\"`#`\"）开头的行会被忽略，所以它们可以用来做注释。如果模式以井号开头，则需要在模式的开头加上反斜杠（\"`\\`\"）。"

#. type: Plain text
#: en/diff-options.txt:729
#, priority:280
msgid "Each other line contains a single pattern."
msgstr "每一行都包含一个模式。"

#. type: Plain text
#: en/diff-options.txt:736
#, priority:280
msgid "Patterns have the same syntax and semantics as patterns used for fnmatch(3) without the FNM_PATHNAME flag, except a pathname also matches a pattern if removing any number of the final pathname components matches the pattern.  For example, the pattern \"`foo*bar`\" matches \"`fooasdfbar`\" and \"`foo/bar/baz/asdf`\" but not \"`foobarx`\"."
msgstr "模式的语法和语义与 fnmatch(3) 中使用的相同，不包括 FNM_PATHNAME 标志，但在删除路径名中结尾任意几个成分后匹配的情况下例外。例如，模式 \"`foo*bar`\" 匹配 \"`fooasdfbar`\" 和 \"`foo/bar/baz/asdf`\"，但不匹配 \"`foobarx`\"。"

#. type: Labeled list
#: en/diff-options.txt:737 en/git-difftool.txt:41
#, fuzzy, no-wrap, priority:280
msgid "--skip-to=<file>"
msgstr "--output=<文件>"

#. type: Labeled list
#: en/diff-options.txt:738 en/git-difftool.txt:37
#, fuzzy, no-wrap, priority:280
msgid "--rotate-to=<file>"
msgstr "--template=<file>"

#. type: Plain text
#: en/diff-options.txt:744
#, priority:280
msgid "Discard the files before the named <file> from the output (i.e. 'skip to'), or move them to the end of the output (i.e. 'rotate to').  These were invented primarily for use of the `git difftool` command, and may not be very useful otherwise."
msgstr "从输出中丢弃命名为 <文件> 之前的文件（即 '跳过'），或将它们移到输出的末尾（即 '旋转'）。这些选项主要是为了使用 `git difftool` 命令而添加的，在其他情况下可能不是很有用。"

#. type: Labeled list
#: en/diff-options.txt:746 en/git-apply.txt:105 en/git-cvsimport.txt:168
#, no-wrap, priority:280
msgid "-R"
msgstr "-R"

#. type: Plain text
#: en/diff-options.txt:749
#, priority:280
msgid "Swap two inputs; that is, show differences from index or on-disk file to tree contents."
msgstr "交换两个输入；即显示从索引或磁盘文件到目录树内容的差异。"

#. type: Labeled list
#: en/diff-options.txt:751
#, no-wrap, priority:280
msgid "--relative[=<path>]"
msgstr "--relative[=<路径>]"

#. type: Labeled list
#: en/diff-options.txt:752
#, ignore-same, no-wrap, priority:280
msgid "--no-relative"
msgstr "--no-relative"

#. type: Plain text
#: en/diff-options.txt:761
#, priority:280
msgid "When run from a subdirectory of the project, it can be told to exclude changes outside the directory and show pathnames relative to it with this option.  When you are not in a subdirectory (e.g. in a bare repository), you can name which subdirectory to make the output relative to by giving a <path> as an argument.  `--no-relative` can be used to countermand both `diff.relative` config option and previous `--relative`."
msgstr "当从项目的子目录中运行时，可以排除目录外的变化，并通过这个选项显示相对于它的路径名。当你不在子目录中时（例如在纯仓库中），你可以通过 <路径> 参数来指明要使输出相对于哪个子目录。`--no-relative` 可以用来取消 `diff.relative`配置选项和之前的 `--relative` 选项。"

#. type: Labeled list
#: en/diff-options.txt:762 en/fetch-options.txt:4 en/git-archimport.txt:99 en/git-branch.txt:176 en/git-checkout-index.txt:39 en/git-commit.txt:67 en/git-cvsexportcommit.txt:45 en/git-cvsimport.txt:135 en/git-grep.txt:71 en/git-help.txt:49 en/git-merge-base.txt:71 en/git-merge-index.txt:26 en/git-repack.txt:31 en/git-show-branch.txt:47 en/git-stash.txt:159 en/git-tag.txt:60
#, ignore-same, no-wrap, priority:280
msgid "-a"
msgstr "-a"

#. type: Labeled list
#: en/diff-options.txt:763 en/git-grep.txt:72
#, ignore-same, no-wrap, priority:280
msgid "--text"
msgstr "--text"

#. type: Plain text
#: en/diff-options.txt:765
#, priority:280
msgid "Treat all files as text."
msgstr "将一切输入文件视为文本。"

#. type: Labeled list
#: en/diff-options.txt:766
#, ignore-same, no-wrap, priority:280
msgid "--ignore-cr-at-eol"
msgstr "--ignore-cr-at-eol"

#. type: Plain text
#: en/diff-options.txt:768
#, priority:280
msgid "Ignore carriage-return at the end of line when doing a comparison."
msgstr "在进行比较时，忽略行末的回车。"

#. type: Labeled list
#: en/diff-options.txt:769
#, ignore-same, no-wrap, priority:280
msgid "--ignore-space-at-eol"
msgstr "--ignore-space-at-eol"

#. type: Labeled list
#: en/diff-options.txt:773 en/git-am.txt:119 en/git-apply.txt:183
#, ignore-same, no-wrap, priority:280
msgid "--ignore-space-change"
msgstr "--ignore-space-change"

#. type: Labeled list
#: en/diff-options.txt:778 en/git-blame.txt:84 en/git-cvsexportcommit.txt:71 en/git-grep.txt:104 en/git-hash-object.txt:31 en/git-help.txt:106
#, ignore-same, no-wrap, priority:280
msgid "-w"
msgstr "-w"

#. type: Labeled list
#: en/diff-options.txt:779
#, ignore-same, no-wrap, priority:280
msgid "--ignore-all-space"
msgstr "--ignore-all-space"

#. type: Plain text
#: en/diff-options.txt:783
#, priority:280
msgid "Ignore whitespace when comparing lines.  This ignores differences even if one line has whitespace where the other line has none."
msgstr "比较行时忽略空格。即使一行有空格而另一行没有空格，也会忽略差异。"

#. type: Labeled list
#: en/diff-options.txt:784
#, ignore-same, no-wrap, priority:280
msgid "--ignore-blank-lines"
msgstr "--ignore-blank-lines"

#. type: Plain text
#: en/diff-options.txt:786
#, priority:280
msgid "Ignore changes whose lines are all blank."
msgstr "忽略空白行的变化。"

#. type: Labeled list
#: en/diff-options.txt:787
#, fuzzy, no-wrap, priority:280
msgid "-I<regex>"
msgstr "-G<regex>"

#. type: Labeled list
#: en/diff-options.txt:788
#, fuzzy, no-wrap, priority:280
msgid "--ignore-matching-lines=<regex>"
msgstr "--ignore-paths=<regex>"

#. type: Plain text
#: en/diff-options.txt:791
#, fuzzy, priority:280
msgid "Ignore changes whose all lines match <regex>.  This option may be specified more than once."
msgstr "这个选项可以被指定多次。"

#. type: Labeled list
#: en/diff-options.txt:792
#, fuzzy, no-wrap, priority:280
msgid "--inter-hunk-context=<lines>"
msgstr "--inter-hunk-context=<lines>"

#. type: Plain text
#: en/diff-options.txt:797
#, priority:280
msgid "Show the context between diff hunks, up to the specified number of lines, thereby fusing hunks that are close to each other.  Defaults to `diff.interHunkContext` or 0 if the config option is unset."
msgstr "显示块差异之间的上下文，最多显示指定的行数，从而合并彼此接近的块。 默认认为 `diff.interHunkContext`，如果配置选项未设置，则默认为0。"

#. type: Labeled list
#: en/diff-options.txt:798 en/git-cvsexportcommit.txt:77 en/git-grep.txt:233 en/git-restore.txt:58
#, fuzzy, no-wrap, priority:280
msgid "-W"
msgstr "-W"

#. type: Labeled list
#: en/diff-options.txt:799 en/git-grep.txt:234
#, ignore-same, no-wrap, priority:280
msgid "--function-context"
msgstr "--function-context"

#. type: Plain text
#: en/diff-options.txt:804
#, priority:280
msgid "Show whole function as context lines for each change.  The function names are determined in the same way as `git diff` works out patch hunk headers (see 'Defining a custom hunk-header' in linkgit:gitattributes[5])."
msgstr "在每个修改中的上下文行显示整个函数。函数名称的确定方式与 `git diff` 计算补丁头的方式相同（参见 linkgit:gitattributes[5] 中的 '自定义区块头' ）。"

#. type: Labeled list
#: en/diff-options.txt:807 en/git-ls-remote.txt:48
#, ignore-same, no-wrap, priority:280
msgid "--exit-code"
msgstr "--exit-code"

#. type: Plain text
#: en/diff-options.txt:811
#, priority:280
msgid "Make the program exit with codes similar to diff(1).  That is, it exits with 1 if there were differences and 0 means no differences."
msgstr "让程序以类似 diff(1) 的代码退出。也就是说，如果有差异则返回1，否则返回0。"

#. type: Labeled list
#: en/diff-options.txt:812 en/fetch-options.txt:282 en/git-am.txt:89 en/git-apply.txt:232 en/git-branch.txt:203 en/git-bundle.txt:127 en/git-checkout-index.txt:32 en/git-checkout.txt:108 en/git-clean.txt:54 en/git-clone.txt:130 en/git-commit.txt:370 en/git-fast-import.txt:42 en/git-fetch-pack.txt:49 en/git-format-patch.txt:375 en/git-gc.txt:73 en/git-grep.txt:295 en/git-imap-send.txt:37 en/git-init.txt:44 en/git-ls-remote.txt:39 en/git-notes.txt:232 en/git-prune-packed.txt:37 en/git-pull.txt:81 en/git-push.txt:387 en/git-read-tree.txt:118 en/git-rebase.txt:408 en/git-repack.txt:96 en/git-reset.txt:108 en/git-restore.txt:67 en/git-rev-parse.txt:118 en/git-rm.txt:82 en/git-send-email.txt:442 en/git-show-ref.txt:71 en/git-stash.txt:239 en/git-submodule.txt:277 en/git-svn.txt:671 en/git-switch.txt:143 en/git-symbolic-ref.txt:40 en/git-worktree.txt:252 en/merge-options.txt:175 en/rev-list-options.txt:246
#, ignore-same, no-wrap, priority:300
msgid "--quiet"
msgstr "--quiet"

#. type: Plain text
#: en/diff-options.txt:814
#, priority:280
msgid "Disable all output of the program. Implies `--exit-code`."
msgstr "禁用程序的所有输出。暗含 `--exit-code`。"

#. type: Labeled list
#: en/diff-options.txt:817
#, ignore-same, no-wrap, priority:280
msgid "--ext-diff"
msgstr "--ext-diff"

#. type: Plain text
#: en/diff-options.txt:821
#, fuzzy, priority:280
msgid "Allow an external diff helper to be executed. If you set an external diff driver with linkgit:gitattributes[5], you need to use this option with linkgit:git-log[1] and friends."
msgstr "允许执行外部差异器。如果你用 linkgit:gitattributes[5] 设置了一个外部差异驱动程序，你需要在 linkgit:git-log[1] 和相关命令中使用这个选项。"

#. type: Labeled list
#: en/diff-options.txt:822
#, ignore-same, no-wrap, priority:280
msgid "--no-ext-diff"
msgstr "--no-ext-diff"

#. type: Plain text
#: en/diff-options.txt:824
#, priority:280
msgid "Disallow external diff drivers."
msgstr "禁止使用外部差异器。"

#. type: Labeled list
#: en/diff-options.txt:825 en/git-cat-file.txt:74 en/git-grep.txt:75
#, ignore-same, no-wrap, priority:280
msgid "--textconv"
msgstr "--textconv"

#. type: Labeled list
#: en/diff-options.txt:826 en/git-grep.txt:78
#, ignore-same, no-wrap, priority:280
msgid "--no-textconv"
msgstr "--no-textconv"

#. type: Plain text
#: en/diff-options.txt:835
#, priority:280
msgid "Allow (or disallow) external text conversion filters to be run when comparing binary files. See linkgit:gitattributes[5] for details. Because textconv filters are typically a one-way conversion, the resulting diff is suitable for human consumption, but cannot be applied. For this reason, textconv filters are enabled by default only for linkgit:git-diff[1] and linkgit:git-log[1], but not for linkgit:git-format-patch[1] or diff plumbing commands."
msgstr "允许（或不允许）在比较二进制文件时运行外部文本转换过滤器。详情请参见 linkgit:gitattributes[5] 。由于文本转换过滤器通常是单向转换，因此产生的差异适合人类用户使用，但不能应用（apply）。因此默认情况下，只有 linkgit:git-diff[1] 和 linkgit:git-log[1] 启用文本转换过滤器，而 linkgit:git-format-patch[1] 或 diff plumbing 命令则不启用。"

#. type: Labeled list
#: en/diff-options.txt:836 en/git-status.txt:87
#, no-wrap, priority:280
msgid "--ignore-submodules[=<when>]"
msgstr "--ignore-submodules[=<when>]"

#. type: Plain text
#: en/diff-options.txt:848
#, priority:280
msgid "Ignore changes to submodules in the diff generation. <when> can be either \"none\", \"untracked\", \"dirty\" or \"all\", which is the default.  Using \"none\" will consider the submodule modified when it either contains untracked or modified files or its HEAD differs from the commit recorded in the superproject and can be used to override any settings of the 'ignore' option in linkgit:git-config[1] or linkgit:gitmodules[5]. When \"untracked\" is used submodules are not considered dirty when they only contain untracked content (but they are still scanned for modified content). Using \"dirty\" ignores all changes to the work tree of submodules, only changes to the commits stored in the superproject are shown (this was the behavior until 1.7.0). Using \"all\" hides all changes to submodules."
msgstr "在生成差异时忽略子模块的修改。<when> 可以是 \"none\"、\"untracked\"、\"dirty \" 或 \"all\"，\"all\" 是默认选项。使用 \"none\" 会在子模块包含未跟踪或修改的文件，或者它的HEAD 与上级项目中记录的提交不同时，认为它被修改了，并且可以用来覆盖 linkgit:git-config[1] 或 linkgit:gitmodules[5] 中 '忽略' 选项的设置。当使用 \"untracked\" 时，当子模块只包含未跟踪的内容时，它们不会被认为是有改动的（但它们仍然会被扫描是否有被修改的内容）。使用 \"dirty\" 会忽略所有对子模块工作树的修改，只有存储在上级项目中的提交的修改才会被显示出来（这是在1.7.0之前的行为）。使用 \"all\" 会隐藏所有对子模块的修改。"

#. type: Labeled list
#: en/diff-options.txt:849
#, no-wrap, priority:280
msgid "--src-prefix=<prefix>"
msgstr "--src-prefix=<prefix>"

#. type: Plain text
#: en/diff-options.txt:851
#, priority:280
msgid "Show the given source prefix instead of \"a/\"."
msgstr "显示给定的源前缀而不是 \"a/\"。"

#. type: Labeled list
#: en/diff-options.txt:852
#, no-wrap, priority:280
msgid "--dst-prefix=<prefix>"
msgstr "--dst-prefix=<prefix>"

#. type: Plain text
#: en/diff-options.txt:854
#, priority:280
msgid "Show the given destination prefix instead of \"b/\"."
msgstr "显示给定的目标前缀，而不是“b/”。"

#. type: Labeled list
#: en/diff-options.txt:855
#, ignore-same, no-wrap, priority:280
msgid "--no-prefix"
msgstr "--no-prefix"

#. type: Plain text
#: en/diff-options.txt:857
#, priority:280
msgid "Do not show any source or destination prefix."
msgstr "不显示任何源或目的前缀。"

#. type: Labeled list
#: en/diff-options.txt:858
#, ignore-same, no-wrap, priority:280
msgid "--default-prefix"
msgstr "--default-prefix"

#. type: Plain text
#: en/diff-options.txt:862
#, priority:280
msgid "Use the default source and destination prefixes (\"a/\" and \"b/\").  This is usually the default already, but may be used to override config such as `diff.noprefix`."
msgstr "使用默认的源和目标前缀（\"a/\"和 \"b/\"）。  这通常已经是默认的，但可以用来覆盖配置，如 `diff.noprefix`。"

#. type: Labeled list
#: en/diff-options.txt:863
#, no-wrap, priority:280
msgid "--line-prefix=<prefix>"
msgstr "--line-prefix=<prefix>"

#. type: Plain text
#: en/diff-options.txt:865
#, priority:280
msgid "Prepend an additional prefix to every line of output."
msgstr "在每一行输出前加上一个额外的前缀。"

#. type: Labeled list
#: en/diff-options.txt:866
#, ignore-same, no-wrap, priority:280
msgid "--ita-invisible-in-index"
msgstr "--ita-invisible-in-index"

#. type: Plain text
#: en/diff-options.txt:873
#, priority:280
msgid "By default entries added by \"git add -N\" appear as an existing empty file in \"git diff\" and a new file in \"git diff --cached\".  This option makes the entry appear as a new file in \"git diff\" and non-existent in \"git diff --cached\". This option could be reverted with `--ita-visible-in-index`. Both options are experimental and could be removed in future."
msgstr "默认情况下，通过 \"git add -N\" 添加的条目在 \"git diff\" 中显示为现有的空文件，在 \"git diff --cached\" 中显示为新文件。这个选项使得条目在 \"git diff\" 中显示为一个新文件，而在 \"git diff --cached\" 中显示为不存在的文件。这个选项可以用 `--ita-visible-in-index` 来还原。这两个选项都是试验性的，将来可能会被删除。"

#. type: Plain text
#: en/diff-options.txt:875
#, priority:280
msgid "For more detailed explanation on these common options, see also linkgit:gitdiffcore[7]."
msgstr "关于这些常用选项的更多解释，请参见 linkgit:gitdiffcore[7]。"

#. type: Labeled list
#: en/fetch-options.txt:1 en/git-add.txt:131 en/git-branch.txt:177 en/git-checkout-index.txt:40 en/git-commit.txt:68 en/git-describe.txt:50 en/git-fetch-pack.txt:35 en/git-help.txt:50 en/git-http-push.txt:25 en/git-merge-base.txt:72 en/git-name-rev.txt:42 en/git-pack-objects.txt:78 en/git-pack-redundant.txt:46 en/git-pack-refs.txt:48 en/git-push.txt:149 en/git-reflog.txt:69 en/git-rev-parse.txt:165 en/git-send-pack.txt:38 en/git-show-branch.txt:48 en/git-stash.txt:160 en/git-submodule.txt:287 en/rev-list-options.txt:155
#, ignore-same, no-wrap, priority:300
msgid "--all"
msgstr "--all"

#. type: Plain text
#: en/fetch-options.txt:3
#, priority:220
msgid "Fetch all remotes."
msgstr "抓取所有远程。"

#. type: Labeled list
#: en/fetch-options.txt:5
#, ignore-same, no-wrap, priority:220
msgid "--append"
msgstr "--append"

#. type: Plain text
#: en/fetch-options.txt:9
#, priority:220
msgid "Append ref names and object names of fetched refs to the existing contents of `.git/FETCH_HEAD`.  Without this option old data in `.git/FETCH_HEAD` will be overwritten."
msgstr "在 `.git/FETCH_HEAD` 的现有内容中添加获取的引用名称和对象名称。  如果没有这个选项，`.git/FETCH_HEAD` 中的旧数据将被覆盖。"

#. type: Labeled list
#: en/fetch-options.txt:10 en/git-send-pack.txt:69
#, ignore-same, no-wrap, priority:220
msgid "--atomic"
msgstr "--atomic"

#. type: Plain text
#: en/fetch-options.txt:13
#, priority:220
msgid "Use an atomic transaction to update local refs. Either all refs are updated, or on error, no refs are updated."
msgstr "使用一个原子事务来更新本地索引。要么所有的引用都被更新，要么在出错时，没有引用被更新。"

#. type: Labeled list
#: en/fetch-options.txt:14
#, fuzzy, no-wrap, priority:220
msgid "--depth=<depth>"
msgstr "--depth=<深度>"

#. type: Plain text
#: en/fetch-options.txt:20
#, priority:220
msgid "Limit fetching to the specified number of commits from the tip of each remote branch history. If fetching to a 'shallow' repository created by `git clone` with `--depth=<depth>` option (see linkgit:git-clone[1]), deepen or shorten the history to the specified number of commits. Tags for the deepened commits are not fetched."
msgstr "限制从每个远程分支历史的顶端获取指定数量的提交。如果获取的是由 `git clone` 创建的 '浅层' 仓库，并使用 `--depth=<depth>` 选项（见 linkgit:git-clone[1]），则加深或缩短历史，达到指定数量的提交。深化后的提交的标签不会被获取。"

#. type: Labeled list
#: en/fetch-options.txt:21
#, no-wrap, priority:220
msgid "--deepen=<depth>"
msgstr "--deepen=<深度>"

#. type: Plain text
#: en/fetch-options.txt:25
#, priority:220
msgid "Similar to --depth, except it specifies the number of commits from the current shallow boundary instead of from the tip of each remote branch history."
msgstr "与--depth类似，只是它指定了从当前浅层边界开始的提交数量，而不是从每个远程分支历史的顶端开始。"

#. type: Labeled list
#: en/fetch-options.txt:26 en/git-clone.txt:252 en/git-fetch-pack.txt:90
#, no-wrap, priority:300
msgid "--shallow-since=<date>"
msgstr "--shallow-since=<日期>"

#. type: Plain text
#: en/fetch-options.txt:29 en/git-fetch-pack.txt:93
#, priority:220
msgid "Deepen or shorten the history of a shallow repository to include all reachable commits after <date>."
msgstr "加深或缩短浅层仓库的历史，包括<日期>之后所有可触及的提交。"

#. type: Labeled list
#: en/fetch-options.txt:30 en/git-clone.txt:255 en/git-fetch-pack.txt:94
#, no-wrap, priority:300
msgid "--shallow-exclude=<revision>"
msgstr "--shallow-exclude=<修订版本>"

#. type: Plain text
#: en/fetch-options.txt:34 en/git-fetch-pack.txt:98
#, priority:220
msgid "Deepen or shorten the history of a shallow repository to exclude commits reachable from a specified remote branch or tag.  This option can be specified multiple times."
msgstr "深化或缩短浅层版本库的历史，以排除从指定的远程分支或标记中可以到达的提交。  这个选项可以指定多次。"

#. type: Labeled list
#: en/fetch-options.txt:35
#, ignore-same, no-wrap, priority:220
msgid "--unshallow"
msgstr "--unshallow"

#. type: Plain text
#: en/fetch-options.txt:39
#, priority:220
msgid "If the source repository is complete, convert a shallow repository to a complete one, removing all the limitations imposed by shallow repositories."
msgstr "如果源仓库是完整的，将浅层资源库转换为完整的仓库，消除浅层仓库带来的所有限制。"

#. type: Plain text
#: en/fetch-options.txt:42
#, priority:220
msgid "If the source repository is shallow, fetch as much as possible so that the current repository has the same history as the source repository."
msgstr "如果源仓库是浅层的，尽可能多的获取，使当前仓库的历史与源仓库相同。"

#. type: Labeled list
#: en/fetch-options.txt:43
#, ignore-same, no-wrap, priority:220
msgid "--update-shallow"
msgstr "--update-shallow"

#. type: Plain text
#: en/fetch-options.txt:48
#, priority:220
msgid "By default when fetching from a shallow repository, `git fetch` refuses refs that require updating .git/shallow. This option updates .git/shallow and accept such refs."
msgstr "默认情况下，当从浅层仓库获取时，`git fetch` 会拒绝需要更新 .git/shallow 的引用。这个选项更新了 .git/shallow 并接受这样的引用。"

#. type: Labeled list
#: en/fetch-options.txt:49
#, fuzzy, no-wrap, priority:220
msgid "--negotiation-tip=<commit|glob>"
msgstr "--negotiation-tip=<commit|glob>"

#. type: Plain text
#: en/fetch-options.txt:57
#, priority:220
msgid "By default, Git will report, to the server, commits reachable from all local refs to find common commits in an attempt to reduce the size of the to-be-received packfile. If specified, Git will only report commits reachable from the given tips.  This is useful to speed up fetches when the user knows which local ref is likely to have commits in common with the upstream ref being fetched."
msgstr "默认情况下，Git 会向服务器报告从所有本地引用中可触及的提交，以寻找共同的提交，试图减少待接收的打包文件的大小。如果指定的话，Git将只报告从给定提示中的可达提交。  当用户知道哪个本地引用可能与被获取的上游引用有共同的提交时，这会加快抓取文件的速度。"

#. type: Plain text
#: en/fetch-options.txt:60
#, priority:220
msgid "This option may be specified more than once; if so, Git will report commits reachable from any of the given commits."
msgstr "这个选项可以指定多次；如果是这样，Git将报告从任何一个给定的提交中可达提交。"

#. type: Plain text
#: en/fetch-options.txt:64
#, priority:220
msgid "The argument to this option may be a glob on ref names, a ref, or the (possibly abbreviated) SHA-1 of a commit. Specifying a glob is equivalent to specifying this option multiple times, one for each matching ref name."
msgstr "这个选项的参数可以是一个引用名称的通配符，一个引用，或者一个提交的SHA-1（可能是缩写的）。指定一个通配符相当于多次指定这个选项，为每个匹配的引用名称指定该选项。"

#. type: Plain text
#: en/fetch-options.txt:68
#, priority:220
msgid "See also the `fetch.negotiationAlgorithm` and `push.negotiate` configuration variables documented in linkgit:git-config[1], and the `--negotiate-only` option below."
msgstr "参见 linkgit:git-config[1] 中记录的 `fetch.negotiAlgorithm` 和 `push.negoti` 配置变量，以及下面的 `--negotiate-only` 选项。"

#. type: Labeled list
#: en/fetch-options.txt:69
#, ignore-same, no-wrap, priority:220
msgid "--negotiate-only"
msgstr "--negotiate-only"

#. type: Plain text
#: en/fetch-options.txt:73
#, priority:220
msgid "Do not fetch anything from the server, and instead print the ancestors of the provided `--negotiation-tip=*` arguments, which we have in common with the server."
msgstr "不从服务器获取任何东西，而是打印所提供的 `--negotiation-tip=*` 参数与服务器上的共同祖先。"

#. type: Plain text
#: en/fetch-options.txt:77
#, priority:220
msgid "This is incompatible with `--recurse-submodules=[yes|on-demand]`.  Internally this is used to implement the `push.negotiate` option, see linkgit:git-config[1]."
msgstr "这与 `--recurse-submodules=[yes|on-demand]` 不兼容。  在内部，这被用来实现 `push.negotiate` 选项，见linkgit:git-config[1]。"

#. type: Labeled list
#: en/fetch-options.txt:78 en/git-add.txt:70 en/git-clean.txt:50 en/git-commit.txt:373 en/git-http-push.txt:37 en/git-mv.txt:40 en/git-notes.txt:204 en/git-p4.txt:332 en/git-prune-packed.txt:32 en/git-prune.txt:37 en/git-push.txt:174 en/git-quiltimport.txt:35 en/git-read-tree.txt:59 en/git-reflog.txt:117 en/git-rm.txt:53 en/git-send-email.txt:433 en/git-send-pack.txt:52 en/git-svn.txt:687 en/git-worktree.txt:231
#, ignore-same, no-wrap, priority:300
msgid "--dry-run"
msgstr "--dry-run"

#. type: Plain text
#: en/fetch-options.txt:80
#, priority:220
msgid "Show what would be done, without making any changes."
msgstr "显示会做什么，而不做任何改变。"

#. type: Plain text
#: en/fetch-options.txt:84
#, priority:220
msgid "Print the output to standard output in an easy-to-parse format for scripts. See section OUTPUT in linkgit:git-fetch[1] for details."
msgstr "将输出结果以易于解析的格式打印到标准输出，供脚本使用。详情见 linkgit:git-fetch[1] 中的输出部分。"

#. type: Plain text
#: en/fetch-options.txt:87
#, priority:220
msgid "This is incompatible with `--recurse-submodules=[yes|on-demand]` and takes precedence over the `fetch.output` config option."
msgstr "这与 `--recurse-submodules=[yes|on-demand]` 选项不兼容，并且优先于 `fetch.output` 配置选项。"

#. type: Labeled list
#: en/fetch-options.txt:89
#, ignore-same, no-wrap, priority:220
msgid "--[no-]write-fetch-head"
msgstr "--[no-]write-fetch-head"

#. type: Plain text
#: en/fetch-options.txt:95
#, priority:220
msgid "Write the list of remote refs fetched in the `FETCH_HEAD` file directly under `$GIT_DIR`.  This is the default.  Passing `--no-write-fetch-head` from the command line tells Git not to write the file.  Under `--dry-run` option, the file is never written."
msgstr "直接在`$GIT_DIR`下的`FETCH_HEAD`文件中写入获取的远程引用列表。  这是默认的。  从命令行传递`--no-write-fetch-head`，告诉Git不要写入该文件。  在`--dry-run`选项下，该文件永远不会被写入。"

#. type: Labeled list
#: en/fetch-options.txt:97 en/git-add.txt:78 en/git-archimport.txt:81 en/git-blame.txt:65 en/git-branch.txt:117 en/git-checkout-index.txt:35 en/git-checkout.txt:118 en/git-clean.txt:36 en/git-cvsexportcommit.txt:54 en/git-filter-branch.txt:208 en/git-ls-files.txt:169 en/git-mv.txt:31 en/git-notes.txt:133 en/git-push.txt:333 en/git-rebase.txt:440 en/git-repack.txt:87 en/git-replace.txt:60 en/git-rm.txt:48 en/git-submodule.txt:300 en/git-switch.txt:110 en/git-tag.txt:79 en/git-update-server-info.txt:24 en/git-worktree.txt:172
#, ignore-same, no-wrap, priority:300
msgid "-f"
msgstr "-f"

#. type: Labeled list
#: en/fetch-options.txt:98 en/git-add.txt:79 en/git-branch.txt:118 en/git-checkout-index.txt:36 en/git-checkout.txt:119 en/git-clean.txt:37 en/git-fast-import.txt:37 en/git-filter-branch.txt:209 en/git-gc.txt:76 en/git-http-push.txt:30 en/git-mv.txt:32 en/git-notes.txt:134 en/git-push.txt:334 en/git-replace.txt:61 en/git-rm.txt:49 en/git-send-email.txt:462 en/git-send-pack.txt:55 en/git-submodule.txt:301 en/git-switch.txt:111 en/git-tag.txt:80 en/git-update-server-info.txt:25 en/git-worktree.txt:173
#, ignore-same, no-wrap, priority:300
msgid "--force"
msgstr "--force"

#. type: Plain text
#: en/fetch-options.txt:101
#, priority:220
msgid "When 'git fetch' is used with `<src>:<dst>` refspec it may refuse to update the local branch as discussed"
msgstr "正如讨论的那样，当 'git fetch' 与 `<src>:<dst>` 引用规范一起使用时，它可能会拒绝更新本地分支"

#. type: Plain text
#: en/fetch-options.txt:104
#, no-wrap, priority:220
msgid ""
"\tin the `<refspec>` part of the linkgit:git-fetch[1]\n"
"\tdocumentation.\n"
msgstr ""
"\t在linkgit:git-fetch[1]的`<引用规范>`部分。\n"
"\t文档中。\n"

#. type: Plain text
#: en/fetch-options.txt:107
#, no-wrap, priority:220
msgid "\tin the `<refspec>` part below.\n"
msgstr "\t在下面的 `<引用规范>` 部分。\n"

#. type: Plain text
#: en/fetch-options.txt:109
#, no-wrap, priority:220
msgid "\tThis option overrides that check.\n"
msgstr "\t这个选项覆盖了这个检查。\n"

#. type: Labeled list
#: en/fetch-options.txt:110 en/git-am.txt:44 en/git-cvsexportcommit.txt:67 en/git-cvsimport.txt:93 en/git-fetch-pack.txt:53 en/git-format-patch.txt:133 en/git-ls-files.txt:86 en/git-mailinfo.txt:29 en/git-mv.txt:34 en/git-repack.txt:177 en/git-stash.txt:189
#, ignore-same, no-wrap, priority:280
msgid "-k"
msgstr "-k"

#. type: Labeled list
#: en/fetch-options.txt:111 en/git-am.txt:45 en/git-fetch-pack.txt:54 en/git-index-pack.txt:62 en/git-reset.txt:87
#, ignore-same, no-wrap, priority:280
msgid "--keep"
msgstr "--keep"

#. type: Plain text
#: en/fetch-options.txt:113
#, priority:220
msgid "Keep downloaded pack."
msgstr "保存下载的包。"

#. type: Labeled list
#: en/fetch-options.txt:115
#, ignore-same, no-wrap, priority:220
msgid "--multiple"
msgstr "--multiple"

#. type: Plain text
#: en/fetch-options.txt:118
#, priority:220
msgid "Allow several <repository> and <group> arguments to be specified. No <refspec>s may be specified."
msgstr "允许指定几个 <仓库> 和 <group> 参数。不可以指定 <引用规范>。"

#. type: Labeled list
#: en/fetch-options.txt:119
#, ignore-same, no-wrap, priority:220
msgid "--[no-]auto-maintenance"
msgstr "--[no-]auto-maintenance"

#. type: Labeled list
#: en/fetch-options.txt:120
#, ignore-same, no-wrap, priority:220
msgid "--[no-]auto-gc"
msgstr "--[no-]auto-gc"

#. type: Plain text
#: en/fetch-options.txt:124
#, priority:220
msgid "Run `git maintenance run --auto` at the end to perform automatic repository maintenance if needed. (`--[no-]auto-gc` is a synonym.)  This is enabled by default."
msgstr "在最后运行 `git maintenance run --auto`，以在需要时执行自动仓库维护。（与 \"--[no-]auto-gc\" 选项效果一样。）这个功能默认启用。"

#. type: Labeled list
#: en/fetch-options.txt:125
#, ignore-same, no-wrap, priority:220
msgid "--[no-]write-commit-graph"
msgstr "--[no-]write-commit-graph"

#. type: Plain text
#: en/fetch-options.txt:128
#, priority:220
msgid "Write a commit-graph after fetching. This overrides the config setting `fetch.writeCommitGraph`."
msgstr "在获取后写一个提交图。这会覆盖 `fetch.writeCommitGraph` 配置选项。"

#. type: Labeled list
#: en/fetch-options.txt:130
#, ignore-same, no-wrap, priority:220
msgid "--prefetch"
msgstr "--prefetch"

#. type: Plain text
#: en/fetch-options.txt:134
#, fuzzy, priority:220
msgid "Modify the configured refspec to place all refs into the `refs/prefetch/` namespace. See the `prefetch` task in linkgit:git-maintenance[1]."
msgstr "修改配置的引用规范，将所有引用放到 `refs/prefetch/` 命名空间中。参见 linkgit:git-maintenance[1] 中的 `prefetch` 任务。"

#. type: Labeled list
#: en/fetch-options.txt:136 en/git-push.txt:154
#, ignore-same, no-wrap, priority:220
msgid "--prune"
msgstr "--prune"

#. type: Plain text
#: en/fetch-options.txt:146
#, priority:220
msgid "Before fetching, remove any remote-tracking references that no longer exist on the remote.  Tags are not subject to pruning if they are fetched only because of the default tag auto-following or due to a --tags option.  However, if tags are fetched due to an explicit refspec (either on the command line or in the remote configuration, for example if the remote was cloned with the --mirror option), then they are also subject to pruning. Supplying `--prune-tags` is a shorthand for providing the tag refspec."
msgstr "在获取之前，删除任何不再存在于远程的远程跟踪引用。  如果只是因为默认的标签自动跟踪或者因为 --tags 选项而获取标签，则不需要剪枝。  然而，如果标签是由于明确的引用规范（无论是在命令行还是在远程配置中，例如，如果远程是用 --mirror 选项克隆的）而被获取的，那么它们也会被剪除。提供 `--prune-tags` 是提供标签引用规范的速记方法。"

#. type: Plain text
#: en/fetch-options.txt:149 en/fetch-options.txt:160
#, priority:220
msgid "See the PRUNING section below for more details."
msgstr "更多细节见下面的 剪枝 部分。"

#. type: Labeled list
#: en/fetch-options.txt:150 en/git-cvsexportcommit.txt:57 en/git-grep.txt:135 en/git.txt:135 en/rev-list-options.txt:97
#, fuzzy, no-wrap, priority:260
msgid "-P"
msgstr "-P"

#. type: Labeled list
#: en/fetch-options.txt:151
#, ignore-same, no-wrap, priority:220
msgid "--prune-tags"
msgstr "--prune-tags"

#. type: Plain text
#: en/fetch-options.txt:158
#, priority:220
msgid "Before fetching, remove any local tags that no longer exist on the remote if `--prune` is enabled. This option should be used more carefully, unlike `--prune` it will remove any local references (local tags) that have been created. This option is a shorthand for providing the explicit tag refspec along with `--prune`, see the discussion about that in its documentation."
msgstr "在获取之前，如果 `--prune` 被启用，则删除任何不再存在于远程的本地标签。这个选项应该更谨慎使用，与`--prune`不同，它将删除任何已经创建的本地引用（本地标签）。这个选项是与`--prune`一起提供明确的标签引用规范的速记形式，见其文档中关于这个的讨论。"

#. type: Labeled list
#: en/fetch-options.txt:164 en/git-add.txt:69 en/git-am.txt:143 en/git-blame.txt:71 en/git-checkout-index.txt:45 en/git-cherry-pick.txt:92 en/git-clean.txt:49 en/git-clone.txt:153 en/git-commit.txt:214 en/git-format-patch.txt:118 en/git-grep.txt:148 en/git-mailinfo.txt:68 en/git-mv.txt:39 en/git-notes.txt:203 en/git-p4.txt:331 en/git-prune-packed.txt:31 en/git-prune.txt:36 en/git-push.txt:173 en/git-quiltimport.txt:34 en/git-read-tree.txt:58 en/git-rebase.txt:419 en/git-reflog.txt:116 en/git-repack.txt:100 en/git-revert.txt:77 en/git-rm.txt:52 en/git-shortlog.txt:29 en/git-submodule.txt:323 en/git-svn.txt:686 en/git-unpack-objects.txt:30 en/git-worktree.txt:230 en/merge-options.txt:108
#, ignore-same, no-wrap, priority:300
msgid "-n"
msgstr "-n"

#. type: Labeled list
#: en/fetch-options.txt:166 en/git-clone.txt:270
#, ignore-same, no-wrap, priority:300
msgid "--no-tags"
msgstr "--no-tags"

#. type: Plain text
#: en/fetch-options.txt:172
#, priority:220
msgid "By default, tags that point at objects that are downloaded from the remote repository are fetched and stored locally.  This option disables this automatic tag following. The default behavior for a remote may be specified with the remote.<name>.tagOpt setting. See linkgit:git-config[1]."
msgstr "默认情况下，指向从远程仓库下载的对象的标签会被获取并存储到本地。  这个选项禁用了这种自动标记跟踪。远程的默认行为可以通过 remote.<远程名称>.tagOpt 设置来指定。参见 linkgit:git-config[1]。"

#. type: Labeled list
#: en/fetch-options.txt:174 en/git-fetch-pack.txt:104
#, ignore-same, no-wrap, priority:220
msgid "--refetch"
msgstr "--refetch"

#. type: Plain text
#: en/fetch-options.txt:181
#, priority:220
msgid "Instead of negotiating with the server to avoid transferring commits and associated objects that are already present locally, this option fetches all objects as a fresh clone would. Use this to reapply a partial clone filter from configuration or using `--filter=` when the filter definition has changed. Automatic post-fetch maintenance will perform object database pack consolidation to remove any duplicate objects."
msgstr "这个选项不是与服务器协商以避免传输本地已经存在的提交和相关对象，而是像一个新的克隆那样获取所有对象。当过滤器定义发生变化时，使用此选项重新应用配置中的部分克隆过滤器或使用 `--filter=`。自动获取后的维护将执行对象数据库包的整合，以删除任何重复的对象。"

#. type: Labeled list
#: en/fetch-options.txt:183
#, fuzzy, no-wrap, priority:220
msgid "--refmap=<refspec>"
msgstr "--refmap=<refspec>"

#. type: Plain text
#: en/fetch-options.txt:193
#, priority:220
msgid "When fetching refs listed on the command line, use the specified refspec (can be given more than once) to map the refs to remote-tracking branches, instead of the values of `remote.*.fetch` configuration variables for the remote repository.  Providing an empty `<refspec>` to the `--refmap` option causes Git to ignore the configured refspecs and rely entirely on the refspecs supplied as command-line arguments. See section on \"Configured Remote-tracking Branches\" for details."
msgstr "当获取命令行上列出的引用时，使用指定的引用规范（可以是多个）来映射引用到远程跟踪分支，而不是远程仓库的 `remote.*.fetch` 配置变量的值。  为 `--refmap` 选项提供一个空的 `<引用规范>` 会导致Git忽略配置的引用规范，而完全依赖作为命令行参数提供的引用规范。详见 \"配置的远程跟踪分支\" 一节。"

#. type: Labeled list
#: en/fetch-options.txt:195 en/git-describe.txt:55 en/git-fsck.txt:41 en/git-ls-remote.txt:27 en/git-name-rev.txt:24 en/git-push.txt:187 en/git-show-ref.txt:41
#, ignore-same, no-wrap, priority:260
msgid "--tags"
msgstr "--tags"

#. type: Plain text
#: en/fetch-options.txt:202
#, priority:220
msgid "Fetch all tags from the remote (i.e., fetch remote tags `refs/tags/*` into local tags with the same name), in addition to whatever else would otherwise be fetched.  Using this option alone does not subject tags to pruning, even if --prune is used (though tags may be pruned anyway if they are also the destination of an explicit refspec; see `--prune`)."
msgstr "从远程获取所有标签（即，将远程标签 `refs/tags/*` 获取为同名的本地标签），除此之外，还可以获取其他东西。  单独使用这个选项，即使使用了 --prune，也不会对标签进行修剪（尽管标签是一个明确了无论如何也要删除的引用规范目标，见 `--prune` 选项）。"

#. type: Labeled list
#: en/fetch-options.txt:204
#, fuzzy, no-wrap, priority:220
msgid "--recurse-submodules[=yes|on-demand|no]"
msgstr "--recurse-submodules[=yes|on-demand|no]"

#. type: Plain text
#: en/fetch-options.txt:214
#, priority:220
msgid "This option controls if and under what conditions new commits of submodules should be fetched too. When recursing through submodules, `git fetch` always attempts to fetch \"changed\" submodules, that is, a submodule that has commits that are referenced by a newly fetched superproject commit but are missing in the local submodule clone. A changed submodule can be fetched as long as it is present locally e.g.  in `$GIT_DIR/modules/` (see linkgit:gitsubmodules[7]); if the upstream adds a new submodule, that submodule cannot be fetched until it is cloned e.g. by `git submodule update`."
msgstr "这个选项控制是否以及在什么条件下，子模块的新提交也应该被获取。当遍历子模块时，`git fetch` 总是试图获取 \"改变的\" 子模块，也就是说，一个子模块的提交被新获取的父项目提交所引用，但在本地的子模块克隆中却没有。一个改变了的子模块可以被获取，只要它在本地存在，例如在`$GIT_DIR/modules/`（见linkgit:gitsubmodules[7]）；如果上游添加了一个新的子模块，该子模块不能被获取，直到它被克隆，例如通过`git submodule update`。"

#. type: Plain text
#: en/fetch-options.txt:219
#, priority:220
msgid "When set to 'on-demand', only changed submodules are fetched. When set to 'yes', all populated submodules are fetched and submodules that are both unpopulated and changed are fetched. When set to 'no', submodules are never fetched."
msgstr "当设置为 'on-demand' 时，只取回已改变的子模块。当设置为 'yes' 时，所有已填充的子模块都被获取，同时未填充和已改变的子模块也被获取。当设置为 'no' 时，子模块永远不会被获取。"

#. type: Plain text
#: en/fetch-options.txt:223
#, priority:220
msgid "When unspecified, this uses the value of `fetch.recurseSubmodules` if it is set (see linkgit:git-config[1]), defaulting to 'on-demand' if unset.  When this option is used without any value, it defaults to 'yes'."
msgstr "当未指定时，如果设置了 `fetch.recurseSubmodules`，则使用该值（见linkgit:git-config[1]），如果未设置则默认为 'on-demand'。  当这个选项被使用而没有任何值时，它默认为 'yes'。"

#. type: Labeled list
#: en/fetch-options.txt:225
#, ignore-same, no-wrap, priority:220
msgid "-j"
msgstr "-j"

#. type: Labeled list
#: en/fetch-options.txt:226
#, fuzzy, no-wrap, priority:220
msgid "--jobs=<n>"
msgstr "--jobs=<n>"

#. type: Plain text
#: en/fetch-options.txt:228
#, priority:220
msgid "Number of parallel children to be used for all forms of fetching."
msgstr "用于所有形式的获取的并行子进程的数量。"

#. type: Plain text
#: en/fetch-options.txt:233
#, priority:220
msgid "If the `--multiple` option was specified, the different remotes will be fetched in parallel. If multiple submodules are fetched, they will be fetched in parallel. To control them independently, use the config settings `fetch.parallel` and `submodule.fetchJobs` (see linkgit:git-config[1])."
msgstr "如果指定了 `--multiple` 选项，不同的远程将被并行获取。如果多个子模块被取走，它们将并行获取。要独立控制它们，使用配置 `fetch.parallel` 和 `submodule.fetchJobs`（见linkgit:git-config[1]）。"

#. type: Plain text
#: en/fetch-options.txt:236
#, priority:220
msgid "Typically, parallel recursive and multi-remote fetches will be faster. By default fetches are performed sequentially, not in parallel."
msgstr "通常情况下，并行的递归和多远程的提取会更快。默认情况下，检索是按顺序进行的，而不是并行的。"

#. type: Labeled list
#: en/fetch-options.txt:238 en/git-checkout.txt:300 en/git-push.txt:402 en/git-restore.txt:111 en/git-switch.txt:184
#, ignore-same, no-wrap, priority:280
msgid "--no-recurse-submodules"
msgstr "--no-recurse-submodules"

#. type: Plain text
#: en/fetch-options.txt:241
#, priority:220
msgid "Disable recursive fetching of submodules (this has the same effect as using the `--recurse-submodules=no` option)."
msgstr "禁用子模块的递归获取（这与使用 `--recurse-submodules=no` 选项的效果相同）。"

#. type: Labeled list
#: en/fetch-options.txt:243 en/git-branch.txt:267 en/git-push.txt:374
#, ignore-same, no-wrap, priority:260
msgid "--set-upstream"
msgstr "--set-upstream"

#. type: Plain text
#: en/fetch-options.txt:249
#, priority:220
msgid "If the remote is fetched successfully, add upstream (tracking) reference, used by argument-less linkgit:git-pull[1] and other commands. For more information, see `branch.<name>.merge` and `branch.<name>.remote` in linkgit:git-config[1]."
msgstr "如果远程被成功获取，添加上游（跟踪）引用，由无参数的 linkgit:git-pull[1] 和其他命令使用。更多信息，见 linkgit:git-config[1] 中的 `branch.<名称>.merge` 和 `branch.<名称>.remote`。"

#. type: Labeled list
#: en/fetch-options.txt:251
#, fuzzy, no-wrap, priority:220
msgid "--submodule-prefix=<path>"
msgstr "--submodule-prefix=<path>"

#. type: Plain text
#: en/fetch-options.txt:255
#, priority:220
msgid "Prepend <path> to paths printed in informative messages such as \"Fetching submodule foo\".  This option is used internally when recursing over submodules."
msgstr "将 <路径> 添加到信息性消息中打印的路径，例如“获取子模块 foo”。递归子模块时在内部使用此选项。"

#. type: Labeled list
#: en/fetch-options.txt:256
#, fuzzy, no-wrap, priority:220
msgid "--recurse-submodules-default=[yes|on-demand]"
msgstr "--recurse-submodules-default=[yes|on-demand]"

#. type: Plain text
#: en/fetch-options.txt:263
#, priority:220
msgid "This option is used internally to temporarily provide a non-negative default value for the --recurse-submodules option.  All other methods of configuring fetch's submodule recursion (such as settings in linkgit:gitmodules[5] and linkgit:git-config[1]) override this option, as does specifying --[no-]recurse-submodules directly."
msgstr "这个选项在内部被用来为 --recurse-submodules 选项暂时提供一个非负的默认值。  所有其他配置获取子模块递归的方法（比如 linkgit:gitmodules[5] 和 linkgit:git-config[1] 中的设置）都覆盖这个选项，直接指定 --[no-]recurse-submodules 也是如此。"

#. type: Labeled list
#: en/fetch-options.txt:265
#, ignore-same, no-wrap, priority:220
msgid "--update-head-ok"
msgstr "--update-head-ok"

#. type: Plain text
#: en/fetch-options.txt:272
#, priority:220
msgid "By default 'git fetch' refuses to update the head which corresponds to the current branch.  This flag disables the check.  This is purely for the internal use for 'git pull' to communicate with 'git fetch', and unless you are implementing your own Porcelain you are not supposed to use it."
msgstr "默认情况下，\"git fetch\" 拒绝更新与当前分支相对应的头部。  这个标志禁用了这种检查。  这纯粹是为了让 'git pull' 与 'git fetch' 沟通的内部使用，除非你正在实现你自己的上层命令，否则你不应该使用它。"

#. type: Labeled list
#: en/fetch-options.txt:274 en/git-clone.txt:219
#, no-wrap, priority:300
msgid "--upload-pack <upload-pack>"
msgstr "--upload-pack <upload-pack>"

#. type: Plain text
#: en/fetch-options.txt:279
#, priority:220
msgid "When given, and the repository to fetch from is handled by 'git fetch-pack', `--exec=<upload-pack>` is passed to the command to specify non-default path for the command run on the other end."
msgstr "当给出时，并且要获取的仓库是由 'git fetch-pack' 处理的，`--exec=<upload-pack>` 被传递到命令中，为另一端运行的命令指定非默认路径。"

#. type: Labeled list
#: en/fetch-options.txt:281 en/git-am.txt:88 en/git-apply.txt:231 en/git-branch.txt:202 en/git-bundle.txt:126 en/git-checkout-index.txt:31 en/git-checkout.txt:107 en/git-clean.txt:53 en/git-clone.txt:129 en/git-commit.txt:369 en/git-diff-files.txt:44 en/git-fetch-pack.txt:48 en/git-format-patch.txt:374 en/git-grep.txt:294 en/git-imap-send.txt:36 en/git-init.txt:43 en/git-ls-remote.txt:38 en/git-merge-file.txt:67 en/git-merge-index.txt:35 en/git-notes.txt:231 en/git-pack-objects.txt:213 en/git-prune-packed.txt:36 en/git-pull.txt:80 en/git-push.txt:386 en/git-read-tree.txt:117 en/git-rebase.txt:407 en/git-repack.txt:95 en/git-reset.txt:107 en/git-restore.txt:66 en/git-rev-parse.txt:117 en/git-rm.txt:81 en/git-show-ref.txt:70 en/git-stash.txt:238 en/git-submodule.txt:276 en/git-svn.txt:670 en/git-switch.txt:142 en/git-symbolic-ref.txt:39 en/git-unpack-objects.txt:34 en/git-update-index.txt:58 en/git-worktree.txt:251 en/merge-options.txt:174
#, ignore-same, no-wrap, priority:300
msgid "-q"
msgstr "-q"

#. type: Plain text
#: en/fetch-options.txt:286
#, priority:220
msgid "Pass --quiet to git-fetch-pack and silence any other internally used git commands. Progress is not reported to the standard error stream."
msgstr "将 --quiet 传递给 git-fetch-pack，并使任何其他内部使用的 git 命令保持沉默。进度不会报告给标准错误流。"

#. type: Labeled list
#: en/fetch-options.txt:287 en/git-add.txt:74 en/git-apply.txt:225 en/git-archimport.txt:74 en/git-archive.txt:49 en/git-branch.txt:191 en/git-cherry.txt:29 en/git-clone.txt:134 en/git-commit.txt:354 en/git-count-objects.txt:21 en/git-cvsexportcommit.txt:82 en/git-cvsimport.txt:52 en/git-diff-tree.txt:83 en/git-fetch-pack.txt:115 en/git-grep.txt:110 en/git-http-fetch.txt:30 en/git-imap-send.txt:32 en/git-index-pack.txt:28 en/git-ls-files.txt:164 en/git-mv.txt:43 en/git-notes.txt:235 en/git-p4.txt:208 en/git-prune.txt:41 en/git-pull.txt:86 en/git-push.txt:392 en/git-read-tree.txt:63 en/git-rebase.txt:411 en/git-remote.txt:35 en/git-status.txt:50 en/git-svn.txt:366 en/git-tag.txt:87 en/git.txt:41 en/git-verify-commit.txt:23 en/git-verify-pack.txt:26 en/git-verify-tag.txt:23 en/git-worktree.txt:255 en/merge-options.txt:178
#, ignore-same, no-wrap, priority:300
msgid "-v"
msgstr "-v"

#. type: Labeled list
#: en/fetch-options.txt:288 en/git-add.txt:75 en/git-apply.txt:226 en/git-archive.txt:50 en/git-branch.txt:193 en/git-clone.txt:135 en/git-commit.txt:355 en/git-count-objects.txt:22 en/git-daemon.txt:148 en/git-fsck.txt:85 en/git-help.txt:61 en/git-http-push.txt:40 en/git-imap-send.txt:33 en/git-mv.txt:44 en/git-notes.txt:236 en/git-p4.txt:209 en/git-pack-redundant.txt:53 en/git-prune.txt:42 en/git-pull.txt:87 en/git-push.txt:393 en/git-rebase.txt:412 en/git-reflog.txt:121 en/git-remote.txt:36 en/git-send-pack.txt:62 en/git-status.txt:51 en/git-svn.txt:367 en/git-update-index.txt:158 en/git-verify-commit.txt:24 en/git-verify-pack.txt:27 en/git-verify-tag.txt:24 en/git-worktree.txt:256 en/merge-options.txt:179
#, ignore-same, no-wrap, priority:300
msgid "--verbose"
msgstr "--verbose"

#. type: Plain text
#: en/fetch-options.txt:290 en/git-add.txt:77 en/git-imap-send.txt:35 en/merge-options.txt:181
#, priority:300
msgid "Be verbose."
msgstr "详细日志。"

#. type: Labeled list
#: en/fetch-options.txt:292 en/git-bundle.txt:114 en/git-checkout.txt:111 en/git-clone.txt:139 en/git-format-patch.txt:402 en/git-pack-objects.txt:191 en/git-prune.txt:45 en/git-push.txt:396 en/git-restore.txt:70 en/git-submodule.txt:280 en/git-switch.txt:146 en/merge-options.txt:182
#, ignore-same, no-wrap, priority:300
msgid "--progress"
msgstr "--progress"

#. type: Plain text
#: en/fetch-options.txt:297 en/git-bundle.txt:119 en/git-pack-objects.txt:196 en/git-push.txt:401
#, priority:220
msgid "Progress status is reported on the standard error stream by default when it is attached to a terminal, unless -q is specified. This flag forces progress status even if the standard error stream is not directed to a terminal."
msgstr "当标准错误流连接到终端时，除非指定了 -q，否则默认情况下会在标准错误流上报告进展状态。即使标准错误流没有指向终端，这个标志也会强制显示进度状态。"

#. type: Labeled list
#: en/fetch-options.txt:298 en/git-ls-remote.txt:75 en/git-push.txt:216
#, no-wrap, priority:220
msgid "-o <option>"
msgstr "-o <选项>"

#. type: Labeled list
#: en/fetch-options.txt:299 en/git-clone.txt:145 en/git-ls-remote.txt:76
#, no-wrap, priority:300
msgid "--server-option=<option>"
msgstr "--server-option=<选项>"

#. type: Plain text
#: en/fetch-options.txt:306 en/git-clone.txt:152
#, priority:300
msgid "Transmit the given string to the server when communicating using protocol version 2.  The given string must not contain a NUL or LF character.  The server's handling of server options, including unknown ones, is server-specific.  When multiple `--server-option=<option>` are given, they are all sent to the other side in the order listed on the command line."
msgstr "使用协议版本2进行通信时，将给定的字符串传输到服务器。给定的字符串不得包含NUL或LF字符。服务器对服务器选项（包括未知选项）的处理是取决于服务器。当给出多个`--server-option = <option>`时，它们都按照命令行中列出的顺序发送到另一端。"

#. type: Labeled list
#: en/fetch-options.txt:307
#, ignore-same, no-wrap, priority:220
msgid "--show-forced-updates"
msgstr "--show-forced-updates"

#. type: Plain text
#: en/fetch-options.txt:312
#, priority:220
msgid "By default, git checks if a branch is force-updated during fetch. This can be disabled through fetch.showForcedUpdates, but the --show-forced-updates option guarantees this check occurs.  See linkgit:git-config[1]."
msgstr "默认情况下，git 在获取过程中会检查一个分支是否被强制更新了。这可以通过 fetch.showForcedUpdates 禁用，但 --show-forced-updates 选项保证了这种检查的发生。  参见 linkgit:git-config[1]。"

#. type: Labeled list
#: en/fetch-options.txt:313
#, ignore-same, no-wrap, priority:220
msgid "--no-show-forced-updates"
msgstr "--no-show-forced-updates"

#. type: Plain text
#: en/fetch-options.txt:319
#, priority:220
msgid "By default, git checks if a branch is force-updated during fetch. Pass --no-show-forced-updates or set fetch.showForcedUpdates to false to skip this check for performance reasons. If used during 'git-pull' the --ff-only option will still check for forced updates before attempting a fast-forward update. See linkgit:git-config[1]."
msgstr "默认情况下，git 会在获取过程中检查一个分支是否被强制更新了。通过 --no-show-forced-updates 或将 fetch.showForcedUpdates 设置为 false 来跳过这个检查，以保证性能。如果在 'git-pull' 中使用 --ff-only 选项，在尝试快速更新前仍会检查强制更新。见 linkgit:git-config[1]。"

#. type: Labeled list
#: en/fetch-options.txt:320 en/git-push.txt:427
#, ignore-same, no-wrap, priority:220
msgid "-4"
msgstr "-4"

#. type: Labeled list
#: en/fetch-options.txt:321 en/git-push.txt:428
#, ignore-same, no-wrap, priority:220
msgid "--ipv4"
msgstr "--ipv4"

#. type: Plain text
#: en/fetch-options.txt:323 en/git-push.txt:430
#, priority:220
msgid "Use IPv4 addresses only, ignoring IPv6 addresses."
msgstr "仅使用 IPv4 地址，忽略 IPv6 地址。"

#. type: Labeled list
#: en/fetch-options.txt:324 en/git-push.txt:431
#, ignore-same, no-wrap, priority:220
msgid "-6"
msgstr "-6"

#. type: Labeled list
#: en/fetch-options.txt:325 en/git-push.txt:432
#, ignore-same, no-wrap, priority:220
msgid "--ipv6"
msgstr "--ipv6"

#. type: Plain text
#: en/fetch-options.txt:326 en/git-push.txt:434
#, priority:220
msgid "Use IPv6 addresses only, ignoring IPv4 addresses."
msgstr "仅使用 IPv6 地址，忽略 IPv4 地址。"

#. type: Title =
#: en/git-add.txt:2
#, ignore-same, no-wrap, priority:300
msgid "git-add(1)"
msgstr "git-add(1)"

#. type: Title -
#: en/git-add.txt:5 en/git-am.txt:5 en/git-annotate.txt:5 en/git-apply.txt:5 en/git-archimport.txt:5 en/git-archive.txt:5 en/git-bisect.txt:5 en/git-blame.txt:5 en/git-branch.txt:5 en/git-bugreport.txt:5 en/git-bundle.txt:5 en/git-cat-file.txt:5 en/git-check-attr.txt:5 en/git-check-ignore.txt:5 en/git-check-mailmap.txt:5 en/git-checkout-index.txt:5 en/git-checkout.txt:5 en/git-check-ref-format.txt:5 en/git-cherry-pick.txt:5 en/git-cherry.txt:5 en/git-citool.txt:5 en/git-clean.txt:5 en/git-clone.txt:5 en/git-column.txt:5 en/git-commit-tree.txt:5 en/git-commit.txt:5 en/git-config.txt:5 en/git-count-objects.txt:5 en/git-credential-cache--daemon.txt:5 en/git-credential-cache.txt:5 en/git-credential-store.txt:5 en/git-credential.txt:5 en/git-cvsexportcommit.txt:5 en/git-cvsimport.txt:5 en/git-cvsserver.txt:5 en/git-daemon.txt:5 en/git-describe.txt:5 en/git-diff-files.txt:5 en/git-diff-index.txt:5 en/git-difftool.txt:5 en/git-diff-tree.txt:5 en/git-diff.txt:5 en/git-fast-export.txt:5 en/git-fast-import.txt:5 en/git-fetch-pack.txt:5 en/git-fetch.txt:5 en/git-filter-branch.txt:5 en/git-fmt-merge-msg.txt:5 en/git-for-each-ref.txt:5 en/git-format-patch.txt:5 en/git-fsck-objects.txt:5 en/git-fsck.txt:5 en/git-gc.txt:5 en/git-get-tar-commit-id.txt:5 en/git-grep.txt:5 en/git-gui.txt:5 en/git-hash-object.txt:5 en/git-help.txt:5 en/git-http-backend.txt:5 en/git-http-fetch.txt:5 en/git-http-push.txt:5 en/git-imap-send.txt:5 en/git-index-pack.txt:5 en/git-init-db.txt:5 en/git-init.txt:5 en/git-instaweb.txt:5 en/git-interpret-trailers.txt:5 en/git-log.txt:5 en/git-ls-files.txt:5 en/git-ls-remote.txt:5 en/git-ls-tree.txt:5 en/git-mailinfo.txt:5 en/git-mailsplit.txt:5 en/git-merge-base.txt:5 en/git-merge-file.txt:5 en/git-merge-index.txt:5 en/git-merge-one-file.txt:5 en/git-mergetool--lib.txt:5 en/git-mergetool.txt:5 en/git-merge-tree.txt:5 en/git-merge.txt:5 en/git-mktag.txt:5 en/git-mktree.txt:5 en/git-mv.txt:5 en/git-name-rev.txt:5 en/git-notes.txt:5 en/git-p4.txt:5 en/git-pack-objects.txt:5 en/git-pack-redundant.txt:5 en/git-pack-refs.txt:5 en/git-patch-id.txt:5 en/git-prune-packed.txt:5 en/git-prune.txt:5 en/git-pull.txt:5 en/git-push.txt:5 en/git-quiltimport.txt:5 en/git-range-diff.txt:5 en/git-read-tree.txt:5 en/git-rebase.txt:5 en/git-receive-pack.txt:5 en/git-reflog.txt:5 en/git-remote-ext.txt:5 en/git-remote-fd.txt:5 en/git-remote.txt:5 en/git-repack.txt:5 en/git-replace.txt:5 en/git-request-pull.txt:5 en/git-rerere.txt:5 en/git-reset.txt:5 en/git-restore.txt:5 en/git-revert.txt:5 en/git-rev-list.txt:5 en/git-rev-parse.txt:5 en/git-rm.txt:5 en/git-send-email.txt:5 en/git-send-pack.txt:5 en/git-shell.txt:5 en/git-sh-i18n--envsubst.txt:5 en/git-sh-i18n.txt:5 en/git-shortlog.txt:5 en/git-show-branch.txt:5 en/git-show-index.txt:5 en/git-show-ref.txt:5 en/git-show.txt:5 en/git-sh-setup.txt:5 en/git-stage.txt:5 en/git-stash.txt:5 en/git-status.txt:5 en/git-stripspace.txt:5 en/git-submodule.txt:5 en/git-svn.txt:5 en/git-switch.txt:5 en/git-symbolic-ref.txt:5 en/git-tag.txt:5 en/git.txt:5 en/git-unpack-file.txt:5 en/git-unpack-objects.txt:5 en/git-update-index.txt:5 en/git-update-ref.txt:5 en/git-update-server-info.txt:5 en/git-upload-archive.txt:5 en/git-upload-pack.txt:5 en/git-var.txt:5 en/git-verify-commit.txt:5 en/git-verify-pack.txt:5 en/git-verify-tag.txt:5 en/git-web--browse.txt:5 en/git-whatchanged.txt:5 en/git-worktree.txt:5 en/git-write-tree.txt:5 en/gitglossary.txt:5
#, no-wrap, priority:310
msgid "NAME"
msgstr "名称"

#. type: Plain text
#: en/git-add.txt:7
#, priority:300
msgid "git-add - Add file contents to the index"
msgstr "git-add - 添加文件内容到索引"

#. type: Title -
#: en/git-add.txt:9 en/git-am.txt:10 en/git-annotate.txt:9 en/git-apply.txt:10 en/git-archimport.txt:10 en/git-archive.txt:10 en/git-bisect.txt:10 en/git-blame.txt:9 en/git-branch.txt:9 en/git-bugreport.txt:9 en/git-bundle.txt:10 en/git-cat-file.txt:10 en/git-check-attr.txt:10 en/git-check-ignore.txt:10 en/git-check-mailmap.txt:10 en/git-checkout-index.txt:10 en/git-checkout.txt:9 en/git-check-ref-format.txt:9 en/git-cherry-pick.txt:9 en/git-cherry.txt:9 en/git-citool.txt:9 en/git-clean.txt:9 en/git-clone.txt:10 en/git-column.txt:9 en/git-commit-tree.txt:10 en/git-commit.txt:9 en/git-config.txt:10 en/git-count-objects.txt:9 en/git-credential-cache--daemon.txt:9 en/git-credential-cache.txt:9 en/git-credential-store.txt:9 en/git-credential.txt:9 en/git-cvsexportcommit.txt:10 en/git-cvsimport.txt:10 en/git-cvsserver.txt:9 en/git-daemon.txt:9 en/git-describe.txt:9 en/git-diff-files.txt:10 en/git-diff-index.txt:10 en/git-difftool.txt:9 en/git-diff-tree.txt:10 en/git-diff.txt:10 en/git-fast-export.txt:10 en/git-fast-import.txt:10 en/git-fetch-pack.txt:10 en/git-fetch.txt:10 en/git-filter-branch.txt:9 en/git-fmt-merge-msg.txt:10 en/git-for-each-ref.txt:9 en/git-format-patch.txt:10 en/git-fsck-objects.txt:10 en/git-fsck.txt:10 en/git-gc.txt:10 en/git-get-tar-commit-id.txt:10 en/git-grep.txt:10 en/git-gui.txt:9 en/git-hash-object.txt:10 en/git-help.txt:9 en/git-http-backend.txt:9 en/git-http-fetch.txt:10 en/git-http-push.txt:10 en/git-imap-send.txt:10 en/git-index-pack.txt:10 en/git-init-db.txt:10 en/git-init.txt:10 en/git-instaweb.txt:9 en/git-interpret-trailers.txt:9 en/git-log.txt:10 en/git-ls-files.txt:10 en/git-ls-remote.txt:10 en/git-ls-tree.txt:10 en/git-mailinfo.txt:10 en/git-mailsplit.txt:9 en/git-merge-base.txt:10 en/git-merge-file.txt:10 en/git-merge-index.txt:10 en/git-merge-one-file.txt:10 en/git-mergetool--lib.txt:9 en/git-mergetool.txt:9 en/git-merge-tree.txt:10 en/git-merge.txt:10 en/git-mktag.txt:10 en/git-mktree.txt:10 en/git-mv.txt:10 en/git-name-rev.txt:10 en/git-notes.txt:9 en/git-p4.txt:10 en/git-pack-objects.txt:10 en/git-pack-redundant.txt:10 en/git-pack-refs.txt:9 en/git-patch-id.txt:9 en/git-prune-packed.txt:10 en/git-prune.txt:10 en/git-pull.txt:10 en/git-push.txt:10 en/git-quiltimport.txt:10 en/git-range-diff.txt:9 en/git-read-tree.txt:10 en/git-rebase.txt:9 en/git-receive-pack.txt:10 en/git-reflog.txt:10 en/git-remote-ext.txt:9 en/git-remote-fd.txt:9 en/git-remote.txt:10 en/git-repack.txt:10 en/git-replace.txt:9 en/git-request-pull.txt:9 en/git-rerere.txt:9 en/git-reset.txt:9 en/git-restore.txt:9 en/git-revert.txt:9 en/git-rev-list.txt:10 en/git-rev-parse.txt:10 en/git-rm.txt:9 en/git-send-email.txt:10 en/git-send-pack.txt:10 en/git-shell.txt:10 en/git-sh-i18n--envsubst.txt:9 en/git-sh-i18n.txt:9 en/git-shortlog.txt:9 en/git-show-branch.txt:9 en/git-show-index.txt:10 en/git-show-ref.txt:9 en/git-show.txt:10 en/git-sh-setup.txt:9 en/git-stage.txt:10 en/git-stash.txt:9 en/git-status.txt:10 en/git-stripspace.txt:10 en/git-submodule.txt:10 en/git-svn.txt:9 en/git-switch.txt:9 en/git-symbolic-ref.txt:9 en/git-tag.txt:10 en/git.txt:10 en/git-unpack-file.txt:11 en/git-unpack-objects.txt:10 en/git-update-index.txt:10 en/git-update-ref.txt:9 en/git-update-server-info.txt:10 en/git-upload-archive.txt:10 en/git-upload-pack.txt:10 en/git-var.txt:10 en/git-verify-commit.txt:9 en/git-verify-pack.txt:10 en/git-verify-tag.txt:9 en/git-web--browse.txt:9 en/git-whatchanged.txt:10 en/git-worktree.txt:10 en/git-write-tree.txt:10 en/gitglossary.txt:9
#, no-wrap, priority:310
msgid "SYNOPSIS"
msgstr "概述"

#. type: Plain text
#: en/git-add.txt:16
#, ignore-ellipsis, no-wrap, priority:300
msgid ""
"'git add' [--verbose | -v] [--dry-run | -n] [--force | -f] [--interactive | -i] [--patch | -p]\n"
"\t  [--edit | -e] [--[no-]all | --[no-]ignore-removal | [--update | -u]] [--sparse]\n"
"\t  [--intent-to-add | -N] [--refresh] [--ignore-errors] [--ignore-missing] [--renormalize]\n"
"\t  [--chmod=(+|-)x] [--pathspec-from-file=<file> [--pathspec-file-nul]]\n"
"\t  [--] [<pathspec>...]\n"
msgstr ""
"'git add' [--verbose | -v] [--dry-run | -n] [--force | -f] [--interactive | -i] [--patch | -p]\n"
"\t  [--edit | -e] [--[no-]all | --[no-]ignore-removal | [--update | -u]] [--sparse]\n"
"\t  [--intent-to-add | -N] [--refresh] [--ignore-errors] [--ignore-missing] [--renormalize]\n"
"\t  [--chmod=(+|-)x] [--pathspec-from-file=<file> [--pathspec-file-nul]]\n"
"\t  [--] [<pathspec>...]\n"

#. type: Title -
#: en/git-add.txt:18 en/git-am.txt:24 en/git-annotate.txt:14 en/git-apply.txt:22 en/git-archimport.txt:16 en/git-archive.txt:18 en/git-bisect.txt:15 en/git-blame.txt:18 en/git-branch.txt:29 en/git-bugreport.txt:15 en/git-bundle.txt:19 en/git-cat-file.txt:22 en/git-check-attr.txt:16 en/git-check-ignore.txt:16 en/git-check-mailmap.txt:16 en/git-checkout-index.txt:20 en/git-checkout.txt:20 en/git-check-ref-format.txt:17 en/git-cherry-pick.txt:16 en/git-cherry.txt:14 en/git-citool.txt:14 en/git-clean.txt:14 en/git-clone.txt:23 en/git-column.txt:15 en/git-commit-tree.txt:18 en/git-commit.txt:21 en/git-config.txt:29 en/git-count-objects.txt:14 en/git-credential-cache--daemon.txt:14 en/git-credential-cache.txt:15 en/git-credential-store.txt:15 en/git-credential.txt:15 en/git-cvsexportcommit.txt:17 en/git-cvsimport.txt:20 en/git-cvsserver.txt:28 en/git-daemon.txt:27 en/git-describe.txt:16 en/git-diff-files.txt:15 en/git-diff-index.txt:15 en/git-difftool.txt:14 en/git-diff-tree.txt:17 en/git-diff.txt:20 en/git-fast-export.txt:15 en/git-fast-import.txt:15 en/git-fetch-pack.txt:18 en/git-fetch.txt:19 en/git-filter-branch.txt:33 en/git-fmt-merge-msg.txt:16 en/git-for-each-ref.txt:20 en/git-format-patch.txt:37 en/git-fsck-objects.txt:15 en/git-fsck.txt:18 en/git-gc.txt:15 en/git-get-tar-commit-id.txt:16 en/git-grep.txt:35 en/git-gui.txt:14 en/git-hash-object.txt:17 en/git-help.txt:19 en/git-http-backend.txt:14 en/git-http-fetch.txt:15 en/git-http-push.txt:15 en/git-imap-send.txt:16 en/git-index-pack.txt:18 en/git-init-db.txt:16 en/git-init.txt:19 en/git-instaweb.txt:16 en/git-interpret-trailers.txt:16 en/git-log.txt:15 en/git-ls-files.txt:27 en/git-ls-remote.txt:17 en/git-ls-tree.txt:17 en/git-mailinfo.txt:18 en/git-mailsplit.txt:15 en/git-merge-base.txt:19 en/git-merge-file.txt:18 en/git-merge-index.txt:15 en/git-merge-one-file.txt:15 en/git-mergetool--lib.txt:14 en/git-mergetool.txt:14 en/git-merge-tree.txt:17 en/git-merge.txt:20 en/git-mktag.txt:15 en/git-mktree.txt:15 en/git-mv.txt:15 en/git-name-rev.txt:16 en/git-notes.txt:26 en/git-p4.txt:19 en/git-pack-objects.txt:22 en/git-pack-redundant.txt:29 en/git-pack-refs.txt:14 en/git-patch-id.txt:14 en/git-prune-packed.txt:16 en/git-prune.txt:15 en/git-pull.txt:16 en/git-push.txt:20 en/git-quiltimport.txt:17 en/git-range-diff.txt:18 en/git-read-tree.txt:18 en/git-rebase.txt:18 en/git-receive-pack.txt:15 en/git-reflog.txt:21 en/git-remote-ext.txt:14 en/git-remote-fd.txt:13 en/git-remote.txt:27 en/git-repack.txt:15 en/git-replace.txt:19 en/git-request-pull.txt:14 en/git-rerere.txt:14 en/git-reset.txt:17 en/git-restore.txt:16 en/git-revert.txt:15 en/git-rev-list.txt:15 en/git-rev-parse.txt:15 en/git-rm.txt:16 en/git-send-email.txt:18 en/git-send-pack.txt:19 en/git-shell.txt:17 en/git-sh-i18n--envsubst.txt:19 en/git-sh-i18n.txt:14 en/git-shortlog.txt:15 en/git-show-branch.txt:19 en/git-show-index.txt:16 en/git-show-ref.txt:17 en/git-show.txt:15 en/git-sh-setup.txt:14 en/git-stage.txt:16 en/git-stash.txt:28 en/git-status.txt:15 en/git-stripspace.txt:16 en/git-submodule.txt:27 en/git-svn.txt:14 en/git-switch.txt:17 en/git-symbolic-ref.txt:16 en/git-tag.txt:22 en/git.txt:19 en/git-unpack-file.txt:16 en/git-unpack-objects.txt:16 en/git-update-index.txt:32 en/git-update-ref.txt:14 en/git-update-server-info.txt:15 en/git-upload-archive.txt:15 en/git-upload-pack.txt:16 en/git-var.txt:15 en/git-verify-commit.txt:14 en/git-verify-pack.txt:16 en/git-verify-tag.txt:14 en/git-web--browse.txt:14 en/git-whatchanged.txt:15 en/git-worktree.txt:23 en/git-write-tree.txt:15 en/gitglossary.txt:13
#, no-wrap, priority:310
msgid "DESCRIPTION"
msgstr "描述"

#. type: Plain text
#: en/git-add.txt:25
#, priority:300
msgid "This command updates the index using the current content found in the working tree, to prepare the content staged for the next commit.  It typically adds the current content of existing paths as a whole, but with some options it can also be used to add content with only part of the changes made to the working tree files applied, or remove paths that do not exist in the working tree anymore."
msgstr "该命令使用工作区的内容来更新索引，为下一次提交准备暂存的内容。通常情况下会添加当前目录的所有内容到索引，但是通过某些选项，它也可以用于仅添加对工作树文件所做的部分更改，或删除工作树中不存在的路径。"

#. type: Plain text
#: en/git-add.txt:31
#, priority:300
msgid "The \"index\" holds a snapshot of the content of the working tree, and it is this snapshot that is taken as the contents of the next commit.  Thus after making any changes to the working tree, and before running the commit command, you must use the `add` command to add any new or modified files to the index."
msgstr "索引区中储存着一份工作区的快照，在下次提交时这份快照会被保存到 Git 仓库中。因此在工作区做过修改后以及在运行下一次提交命令前，你必须通过 `add` 命令来添加新创建的文件或者保存新的改动到索引中。"

#. type: Plain text
#: en/git-add.txt:36
#, priority:300
msgid "This command can be performed multiple times before a commit.  It only adds the content of the specified file(s) at the time the add command is run; if you want subsequent changes included in the next commit, then you must run `git add` again to add the new content to the index."
msgstr "提交前可以多次执行此命令。它仅在运行add命令时添加指定文件的内容；如果要在下一次提交中包含后续更改，则必须再次运行`git add`将新内容添加到索引中。"

#. type: Plain text
#: en/git-add.txt:39
#, priority:300
msgid "The `git status` command can be used to obtain a summary of which files have changes that are staged for the next commit."
msgstr "`git status` 命令可用于获取摘要，说明哪些变化的文件已暂存，准备下一次提交。"

#. type: Plain text
#: en/git-add.txt:46
#, priority:300
msgid "The `git add` command will not add ignored files by default.  If any ignored files were explicitly specified on the command line, `git add` will fail with a list of ignored files.  Ignored files reached by directory recursion or filename globbing performed by Git (quote your globs before the shell) will be silently ignored.  The 'git add' command can be used to add ignored files with the `-f` (force) option."
msgstr "`git add` 命令默认不会添加被忽略的文件。如果在命令行上明确指定了任何被忽略的文件，则`git add`会失败，并显示被忽略文件的列表。由目录递归或Git执行的文件名通配符（在shell之前引用的通配符）所涉及的忽略文件将被静默忽略。 'git add' 命令可用于通过 -f 选项（force）强制添加忽略的文件。"

#. type: Plain text
#: en/git-add.txt:49
#, priority:300
msgid "Please see linkgit:git-commit[1] for alternative ways to add content to a commit."
msgstr "请参阅 linkgit:git-commit[1] 了解将内容添加到提交的其他替代方法。"

#. type: Title -
#: en/git-add.txt:52 en/git-am.txt:32 en/git-annotate.txt:24 en/git-apply.txt:36 en/git-archimport.txt:69 en/git-archive.txt:34 en/git-bisect.txt:356 en/git-blame.txt:50 en/git-branch.txt:97 en/git-bugreport.txt:45 en/git-bundle.txt:63 en/git-cat-file.txt:36 en/git-check-attr.txt:21 en/git-check-ignore.txt:27 en/git-check-mailmap.txt:25 en/git-checkout-index.txt:25 en/git-checkout.txt:106 en/git-check-ref-format.txt:100 en/git-cherry-pick.txt:42 en/git-cherry.txt:28 en/git-clean.txt:27 en/git-clone.txt:44 en/git-column.txt:22 en/git-commit-tree.txt:46 en/git-commit.txt:66 en/git-config.txt:79 en/git-count-objects.txt:20 en/git-credential-cache.txt:30 en/git-credential-store.txt:30 en/git-cvsexportcommit.txt:35 en/git-cvsimport.txt:51 en/git-cvsserver.txt:40 en/git-daemon.txt:48 en/git-describe.txt:36 en/git-diff-files.txt:22 en/git-diff-index.txt:23 en/git-difftool.txt:21 en/git-diff-tree.txt:26 en/git-diff.txt:124 en/git-fast-export.txt:25 en/git-fast-import.txt:35 en/git-fetch-pack.txt:34 en/git-fetch.txt:46 en/git-filter-branch.txt:96 en/git-fmt-merge-msg.txt:25 en/git-for-each-ref.txt:30 en/git-format-patch.txt:106 en/git-fsck.txt:22 en/git-gc.txt:35 en/git-grep.txt:43 en/git-hash-object.txt:25 en/git-help.txt:48 en/git-http-fetch.txt:23 en/git-http-push.txt:24 en/git-imap-send.txt:30 en/git-index-pack.txt:27 en/git-init.txt:41 en/git-instaweb.txt:21 en/git-interpret-trailers.txt:98 en/git-log.txt:28 en/git-ls-files.txt:37 en/git-ls-remote.txt:23 en/git-ls-tree.txt:37 en/git-mailinfo.txt:28 en/git-mailsplit.txt:23 en/git-merge-base.txt:70 en/git-merge-file.txt:53 en/git-merge-index.txt:22 en/git-mergetool.txt:26 en/git-merge-tree.txt:41 en/git-merge.txt:65 en/git-mktag.txt:41 en/git-mktree.txt:22 en/git-mv.txt:30 en/git-name-rev.txt:22 en/git-notes.txt:132 en/git-p4.txt:199 en/git-pack-objects.txt:51 en/git-pack-redundant.txt:43 en/git-pack-refs.txt:46 en/git-patch-id.txt:31 en/git-prune-packed.txt:30 en/git-prune.txt:34 en/git-pull.txt:78 en/git-quiltimport.txt:32 en/git-range-diff.txt:49 en/git-read-tree.txt:32 en/git-rebase.txt:245 en/git-receive-pack.txt:40 en/git-reflog.txt:58 en/git-remote.txt:33 en/git-repack.txt:29 en/git-replace.txt:59 en/git-request-pull.txt:28 en/git-reset.txt:105 en/git-restore.txt:34 en/git-revert.txt:35 en/git-rev-list.txt:27 en/git-rev-parse.txt:26 en/git-rm.txt:32 en/git-send-email.txt:45 en/git-send-pack.txt:28 en/git-shortlog.txt:27 en/git-show-branch.txt:32 en/git-show-index.txt:40 en/git-show-ref.txt:34 en/git-show.txt:36 en/git-stash.txt:158 en/git-status.txt:25 en/git-stripspace.txt:37 en/git-submodule.txt:275 en/git-svn.txt:575 en/git-switch.txt:35 en/git-symbolic-ref.txt:33 en/git-tag.txt:59 en/git.txt:40 en/git-unpack-file.txt:22 en/git-unpack-objects.txt:29 en/git-update-index.txt:43 en/git-update-server-info.txt:23 en/git-upload-archive.txt:56 en/git-upload-pack.txt:26 en/git-var.txt:20 en/git-verify-commit.txt:18 en/git-verify-pack.txt:22 en/git-verify-tag.txt:18 en/git-web--browse.txt:43 en/git-worktree.txt:170 en/git-write-tree.txt:29
#, no-wrap, priority:300
msgid "OPTIONS"
msgstr "选项"

#. type: Labeled list
#: en/git-add.txt:53 en/git-checkout.txt:367 en/git-commit.txt:401 en/git-grep.txt:307 en/git-reset.txt:131 en/git-restore.txt:144 en/git-rm.txt:33 en/git-stash.txt:250 en/git-status.txt:152
#, ignore-ellipsis, no-wrap, priority:300
msgid "<pathspec>..."
msgstr "<pathspec>..."

#. type: Plain text
#: en/git-add.txt:65
#, priority:300
msgid "Files to add content from.  Fileglobs (e.g. `*.c`) can be given to add all matching files.  Also a leading directory name (e.g. `dir` to add `dir/file1` and `dir/file2`) can be given to update the index to match the current state of the directory as a whole (e.g.  specifying `dir` will record not just a file `dir/file1` modified in the working tree, a file `dir/file2` added to the working tree, but also a file `dir/file3` removed from the working tree). Note that older versions of Git used to ignore removed files; use `--no-all` option if you want to add modified or new files but ignore removed ones."
msgstr "要从中添加内容的文件。可以使用文件通配符（例如 `*.c`）来添加所有匹配的文件。此外，还可以提供一个前导目录名（例如，指定 `dir` 以添加 `dir/file1` 和 `dir/file2`）来更新索引，使其与整个目录的当前状态相匹配（例如，指定 `dir` 不仅会记录在工作树中修改的文件 `dir/file1`，还会记录在工作树中添加的文件 `dir/file2`，还有从工作树中删除的文件 `dir/file3`）。请注意，旧版本的 Git 会忽略已删除的文件；如果要添加已修改的文件或新文件，但忽略已删除的文件，请使用 `--no all` 选项。"

#. type: Plain text
#: en/git-add.txt:68 en/git-grep.txt:313
#, priority:300
msgid "For more details about the <pathspec> syntax, see the 'pathspec' entry in linkgit:gitglossary[7]."
msgstr "有关 <指定路径> 格式的更多细节，请参考 linkgit:gitglossary[7]。"

#. type: Plain text
#: en/git-add.txt:73
#, priority:300
msgid "Don't actually add the file(s), just show if they exist and/or will be ignored."
msgstr "实际上不添加文件，仅展示文件是否存在或是否忽略。"

#. type: Plain text
#: en/git-add.txt:81
#, priority:300
msgid "Allow adding otherwise ignored files."
msgstr "允许添加已被忽略的文件。"

#. type: Labeled list
#: en/git-add.txt:82 en/git-clone.txt:174 en/git-ls-files.txt:213 en/git-rm.txt:75 en/git-show-branch.txt:67 en/rev-list-options.txt:396 en/rev-list-options.txt:531
#, ignore-same, no-wrap, priority:300
msgid "--sparse"
msgstr "--sparse"

#. type: Plain text
#: en/git-add.txt:88
#, priority:300
msgid "Allow updating index entries outside of the sparse-checkout cone.  Normally, `git add` refuses to update index entries whose paths do not fit within the sparse-checkout cone, since those files might be removed from the working tree without warning. See linkgit:git-sparse-checkout[1] for more details."
msgstr "允许更新稀疏检出 cone 之外的索引条目。  通常，`git add` 拒绝更新其路径不适合稀疏检出 cone 的索引条目，因为这些文件可能会在没有警告的情况下从工作区中删除。有关更多详细信息，请参阅链接 git:git-sparse-checkout[1]。"

#. type: Labeled list
#: en/git-add.txt:89 en/git-am.txt:139 en/git-branch.txt:155 en/git-clean.txt:44 en/git-commit.txt:301 en/git-cvsimport.txt:88 en/git-grep.txt:82 en/git-help.txt:91 en/git-ls-files.txt:57 en/git-read-tree.txt:49 en/git-rebase.txt:518 en/git-repack.txt:184 en/git-tag.txt:130 en/rev-list-options.txt:78
#, ignore-same, no-wrap, priority:300
msgid "-i"
msgstr "-i"

#. type: Labeled list
#: en/git-add.txt:90 en/git-am.txt:140 en/git-clean.txt:45 en/git-rebase.txt:519 en/git-rebase.txt:659 en/git-svn.txt:297
#, ignore-same, no-wrap, priority:300
msgid "--interactive"
msgstr "--interactive"

#. type: Plain text
#: en/git-add.txt:95
#, fuzzy, priority:300
msgid "Add modified contents in the working tree interactively to the index. Optional path arguments may be supplied to limit operation to a subset of the working tree. See ``Interactive mode'' for details."
msgstr "以交互方式将工作树中的修改内容添加到索引。可以提供可选的路径参数，以将操作限制为工作树的子集。有关详细信息，请参见``交互模式''。"

#. type: Plain text
#: en/git-add.txt:102
#, fuzzy, priority:300
msgid "Interactively choose hunks of patch between the index and the work tree and add them to the index. This gives the user a chance to review the difference before adding modified contents to the index."
msgstr "交互地在索引和工作树之间选择补丁块并将它们添加到索引中。这让用户有机会在将修改后的内容添加到索引之前查看差异。"

#. type: Plain text
#: en/git-add.txt:106
#, fuzzy, priority:300
msgid "This effectively runs `add --interactive`, but bypasses the initial command menu and directly jumps to the `patch` subcommand.  See ``Interactive mode'' for details."
msgstr "参见这可以有效地运行 `add --interactive`，但是会绕过初始命令菜单，而直接跳转到 `patch` 子命令。有关详细信息，请参见``交互模式''。"

#. type: Labeled list
#: en/git-add.txt:107 en/git-blame.txt:78 en/git-cat-file.txt:52 en/git-cherry-pick.txt:53 en/git-commit.txt:260 en/git-config.txt:275 en/git-grep.txt:274 en/git-revert.txt:44 en/git-shortlog.txt:38 en/git-svn.txt:614 en/git-tag.txt:181 en/merge-options.txt:19
#, ignore-same, no-wrap, priority:300
msgid "-e"
msgstr "-e"

#. type: Labeled list
#: en/git-add.txt:108 en/git-cherry-pick.txt:54 en/git-commit.txt:261 en/git-config.txt:276 en/git-revert.txt:45 en/git-svn.txt:615 en/git-tag.txt:182 en/merge-options.txt:18
#, ignore-same, no-wrap, priority:300
msgid "--edit"
msgstr "--edit"

#. type: Plain text
#: en/git-add.txt:112
#, fuzzy, priority:300
msgid "Open the diff vs. the index in an editor and let the user edit it.  After the editor was closed, adjust the hunk headers and apply the patch to the index."
msgstr "在编辑器中打开与索引的差异，使用户进行编辑。关闭编辑器后，调整块补丁头并将其应用于索引。"

#. type: Plain text
#: en/git-add.txt:118
#, fuzzy, priority:300
msgid "The intent of this option is to pick and choose lines of the patch to apply, or even to modify the contents of lines to be staged. This can be quicker and more flexible than using the interactive hunk selector.  However, it is easy to confuse oneself and create a patch that does not apply to the index. See EDITING PATCHES below."
msgstr "此选项的目的是选择并选择要应用的补丁的行，甚至修改要暂存的行的内容。与使用交互式补丁块选择器相比，其更快，更灵活。但是，很容易混淆自己并创建不应用于索引的补丁。请参阅下面的编辑补丁。"

#. type: Labeled list
#: en/git-add.txt:120
#, ignore-same, no-wrap, priority:300
msgid "--update"
msgstr "--update"

#. type: Plain text
#: en/git-add.txt:124
#, fuzzy, priority:300
msgid "Update the index just where it already has an entry matching <pathspec>.  This removes as well as modifies index entries to match the working tree, but adds no new files."
msgstr "在索引已经有与 <指定路径> 匹配项的地方更新索引。这会删除和修改索引项以匹配工作树，但不添加新文件。"

#. type: Plain text
#: en/git-add.txt:129
#, fuzzy, priority:300
msgid "If no <pathspec> is given when `-u` option is used, all tracked files in the entire working tree are updated (old versions of Git used to limit the update to the current directory and its subdirectories)."
msgstr "如果在使用 `-u` 选项时没有 <指定路径>，则整个工作树中的所有跟踪文件都将更新（旧版本 Git 会限制更新当前目录及其子目录）。"

#. type: Labeled list
#: en/git-add.txt:130 en/git-repack.txt:49 en/git-svn.txt:418
#, no-wrap, priority:300
msgid "-A"
msgstr "-A"

#. type: Labeled list
#: en/git-add.txt:132
#, ignore-same, no-wrap, priority:300
msgid "--no-ignore-removal"
msgstr "--no-ignore-removal"

#. type: Plain text
#: en/git-add.txt:137
#, fuzzy, priority:300
msgid "Update the index not only where the working tree has a file matching <pathspec> but also where the index already has an entry. This adds, modifies, and removes index entries to match the working tree."
msgstr "不仅在工作树中有与 <指定路径 >匹配的文件的地方更新索引，而且在索引中已经有一个项的地方更新索引。这将添加、修改和删除与工作树匹配的索引项。"

#. type: Plain text
#: en/git-add.txt:142
#, fuzzy, priority:300
msgid "If no <pathspec> is given when `-A` option is used, all files in the entire working tree are updated (old versions of Git used to limit the update to the current directory and its subdirectories)."
msgstr "如果在使用 `-A` 选项时没有 <指定路径>，则整个工作树中的所有文件都将更新（旧版本的 Git 会限制当前目录及其子目录的更新）。"

#. type: Labeled list
#: en/git-add.txt:143
#, ignore-same, no-wrap, priority:300
msgid "--no-all"
msgstr "--no-all"

#. type: Labeled list
#: en/git-add.txt:144
#, ignore-same, no-wrap, priority:300
msgid "--ignore-removal"
msgstr "--ignore-removal"

#. type: Plain text
#: en/git-add.txt:149
#, fuzzy, priority:300
msgid "Update the index by adding new files that are unknown to the index and files modified in the working tree, but ignore files that have been removed from the working tree.  This option is a no-op when no <pathspec> is used."
msgstr "通过添加索引未知的新文件和在工作树中修改的文件以更新索引，但忽略已从工作树中删除的文件。当不使用 <指定路径> 时，此选项是必须的。"

#. type: Plain text
#: en/git-add.txt:153
#, fuzzy, ignore-ellipsis, priority:300
msgid "This option is primarily to help users who are used to older versions of Git, whose \"git add <pathspec>...\" was a synonym for \"git add --no-all <pathspec>...\", i.e. ignored removed files."
msgstr "此选项主要用于帮助那些习惯于较旧版本 Git 的用户。旧版本中的 \"Git add<指定路径>...\" 是 \"Git add--no all<指定路径>...\" 的同义词，即忽略已删除的文件。"

#. type: Labeled list
#: en/git-add.txt:154 en/git-format-patch.txt:122 en/git-submodule.txt:362
#, no-wrap, priority:300
msgid "-N"
msgstr "-N"

#. type: Labeled list
#: en/git-add.txt:155 en/git-apply.txt:77
#, ignore-same, no-wrap, priority:300
msgid "--intent-to-add"
msgstr "--intent-to-add"

#. type: Plain text
#: en/git-add.txt:161
#, fuzzy, priority:300
msgid "Record only the fact that the path will be added later. An entry for the path is placed in the index with no content. This is useful for, among other things, showing the unstaged content of such files with `git diff` and committing them with `git commit -a`."
msgstr "只记录稍后将添加路径的事实。路径的项会被放置在索引中，但不包括改动的内容。这对于使用 `git diff` 显示文件的未暂存内容以及使 `git commit -a` 提交这些文件非常有用。"

#. type: Labeled list
#: en/git-add.txt:162 en/git-reset.txt:111 en/git-update-index.txt:54
#, ignore-same, no-wrap, priority:300
msgid "--refresh"
msgstr "--refresh"

#. type: Plain text
#: en/git-add.txt:165
#, fuzzy, priority:300
msgid "Don't add the file(s), but only refresh their stat()  information in the index."
msgstr "不添加文件，只刷新索引中的 stat() 信息。"

#. type: Labeled list
#: en/git-add.txt:166
#, ignore-same, no-wrap, priority:300
msgid "--ignore-errors"
msgstr "--ignore-errors"

#. type: Plain text
#: en/git-add.txt:172
#, fuzzy, priority:300
msgid "If some files could not be added because of errors indexing them, do not abort the operation, but continue adding the others. The command shall still exit with non-zero status.  The configuration variable `add.ignoreErrors` can be set to true to make this the default behaviour."
msgstr "如果由于索引错误而无法添加某些文件，请不要中止操作，而是继续添加其他文件。命令仍应以非零状态退出。可以将配置变量`add.ignoreErrors`设置为true，使其成为默认行为。"

#. type: Labeled list
#: en/git-add.txt:173 en/git-notes.txt:194 en/git-update-index.txt:72 en/rev-list-options.txt:226
#, ignore-same, no-wrap, priority:300
msgid "--ignore-missing"
msgstr "--ignore-missing"

#. type: Plain text
#: en/git-add.txt:178
#, priority:300
msgid "This option can only be used together with --dry-run. By using this option the user can check if any of the given files would be ignored, no matter if they are already present in the work tree or not."
msgstr "此选项只能与--dry-run一起使用。通过使用此选项，用户可以检查是否会忽略任何给定的文件，无论它们是否已存在于工作树中。"

#. type: Labeled list
#: en/git-add.txt:179
#, ignore-same, no-wrap, priority:300
msgid "--no-warn-embedded-repo"
msgstr "--no-warn-embedded-repo"

#. type: Plain text
#: en/git-add.txt:185
#, priority:300
msgid "By default, `git add` will warn when adding an embedded repository to the index without using `git submodule add` to create an entry in `.gitmodules`. This option will suppress the warning (e.g., if you are manually performing operations on submodules)."
msgstr "默认情况下， `git add` 将在向索引添加嵌入式存储库时发出警告，而不使用 `git submodule add` 在 `.gitmodules` 中创建条目。此选项将抑制警告（例如，如果手动对子模块执行操作）。"

#. type: Labeled list
#: en/git-add.txt:186
#, ignore-same, no-wrap, priority:300
msgid "--renormalize"
msgstr "--renormalize"

#. type: Plain text
#: en/git-add.txt:194
#, fuzzy, priority:300
#| msgid "Apply the \"clean\" process freshly to all tracked files to forcibly add them again to the index.  This is useful after changing `core.autocrlf` configuration or the `text` attribute in order to correct files added with wrong CRLF/LF line endings.  This option implies `-u`."
msgid "Apply the \"clean\" process freshly to all tracked files to forcibly add them again to the index.  This is useful after changing `core.autocrlf` configuration or the `text` attribute in order to correct files added with wrong CRLF/LF line endings.  This option implies `-u`. Lone CR characters are untouched, thus while a CRLF cleans to LF, a CRCRLF sequence is only partially cleaned to CRLF."
msgstr "对所有跟踪的文件应用`clean`过程，将它们再次强制添加到索引中。这在更改`core.autocrlf`配置或`text`属性以更正添加了错误CRLF/LF行结尾的文件后非常有用。此选项隐含`-u`选项。"

#. type: Labeled list
#: en/git-add.txt:195 en/git-update-index.txt:85
#, no-wrap, priority:300
msgid "--chmod=(+|-)x"
msgstr "--chmod=(+|-)x"

#. type: Plain text
#: en/git-add.txt:199
#, fuzzy, priority:300
msgid "Override the executable bit of the added files.  The executable bit is only changed in the index, the files on disk are left unchanged."
msgstr "重写添加文件的可执行位。可执行位仅在索引中更改，磁盘上的文件保持不变。"

#. type: Labeled list
#: en/git-add.txt:200 en/git-checkout.txt:317 en/git-commit.txt:322 en/git-reset.txt:115 en/git-restore.txt:128 en/git-rm.txt:86 en/git-stash.txt:221
#, no-wrap, priority:300
msgid "--pathspec-from-file=<file>"
msgstr "--pathspec-from-file=<file>"

#. type: Plain text
#: en/git-add.txt:207 en/git-checkout.txt:324 en/git-commit.txt:329 en/git-reset.txt:122 en/git-restore.txt:135 en/git-rm.txt:93 en/git-stash.txt:230
#, priority:300
msgid "Pathspec is passed in `<file>` instead of commandline args. If `<file>` is exactly `-` then standard input is used. Pathspec elements are separated by LF or CR/LF. Pathspec elements can be quoted as explained for the configuration variable `core.quotePath` (see linkgit:git-config[1]). See also `--pathspec-file-nul` and global `--literal-pathspecs`."
msgstr "Pathspec在 `<file>` 中传递，而不是在命令行参数中传递。如果 `<file>` 正好是 `-`，则使用标准输入。Pathspec 元素由 LF 或 CR/LF 分隔。可以引用配置变量 `core.quotePath` 的 Pathspec 元素（请参见 linkgit:git-config[1]）。另请参见 `--pathspec-file-nul `和全局 `--literal-pathspecs`。"

#. type: Labeled list
#: en/git-add.txt:208 en/git-checkout.txt:325 en/git-commit.txt:330 en/git-reset.txt:123 en/git-restore.txt:136 en/git-rm.txt:94 en/git-stash.txt:231
#, ignore-same, no-wrap, priority:300
msgid "--pathspec-file-nul"
msgstr "--pathspec-file-nul"

#. type: Plain text
#: en/git-add.txt:212 en/git-checkout.txt:329 en/git-commit.txt:334 en/git-reset.txt:127 en/git-restore.txt:140 en/git-rm.txt:98 en/git-stash.txt:237
#, fuzzy, priority:300
msgid "Only meaningful with `--pathspec-from-file`. Pathspec elements are separated with NUL character and all other characters are taken literally (including newlines and quotes)."
msgstr "只有在使用 `--pathspec-from-file` 时才有意义。指定路径元素用 NUL 字符分隔，所有其他字符都按字面意思（包括换行符和引号）表示。"

#. type: Labeled list
#: en/git-add.txt:213 en/git-check-attr.txt:44 en/git-checkout-index.txt:77 en/git-checkout.txt:364 en/git-commit.txt:398 en/git-grep.txt:303 en/git-ls-files.txt:225 en/git-merge-index.txt:23 en/git-prune.txt:51 en/git-reset.txt:128 en/git-restore.txt:141 en/git-rm.txt:62 en/git-stash.txt:245 en/git-update-index.txt:226 en/git-verify-pack.txt:36
#, no-wrap, priority:300
msgid "\\--"
msgstr "\\--"

#. type: Plain text
#: en/git-add.txt:217 en/git-rm.txt:66
#, fuzzy, priority:300
msgid "This option can be used to separate command-line options from the list of files, (useful when filenames might be mistaken for command-line options)."
msgstr "此选项可用于分离命令行选项和文件列表（当文件名可能被误认为命令行选项时非常有用）。"

#. type: Title -
#: en/git-add.txt:220 en/git-archive.txt:187 en/git-bisect.txt:380 en/git-branch.txt:352 en/git-bundle.txt:217 en/git-check-attr.txt:76 en/git-checkout-index.txt:149 en/git-checkout.txt:517 en/git-check-ref-format.txt:123 en/git-cherry-pick.txt:166 en/git-cherry.txt:43 en/git-clone.txt:342 en/git-column.txt:50 en/git-commit.txt:410 en/git-config.txt:435 en/git-credential-cache.txt:58 en/git-credential-store.txt:71 en/git-cvsexportcommit.txt:91 en/git-daemon.txt:259 en/git-describe.txt:128 en/git-diff.txt:151 en/git-fast-export.txt:167 en/git-fetch.txt:255 en/git-filter-branch.txt:247 en/git-fmt-merge-msg.txt:65 en/git-for-each-ref.txt:371 en/git-format-patch.txt:713 en/git-grep.txt:315 en/git-http-backend.txt:69 en/git-imap-send.txt:62 en/git-init.txt:157 en/git-interpret-trailers.txt:294 en/git-log.txt:136 en/git-ls-remote.txt:114 en/git-merge-file.txt:84 en/git-merge.txt:357 en/git-name-rev.txt:88 en/git-notes.txt:303 en/git-p4.txt:33 en/git-prune.txt:60 en/git-pull.txt:202 en/git-push.txt:599 en/git-range-diff.txt:135 en/git-remote-ext.txt:77 en/git-remote-fd.txt:37 en/git-remote.txt:220 en/git-request-pull.txt:50 en/git-reset.txt:137 en/git-restore.txt:150 en/git-revert.txt:131 en/git-rev-list.txt:35 en/git-rev-parse.txt:464 en/git-rm.txt:175 en/git-send-email.txt:484 en/git-shell.txt:66 en/git-show-branch.txt:177 en/git-show-ref.txt:136 en/git-show.txt:61 en/git-stash.txt:286 en/git-stripspace.txt:49 en/git-switch.txt:193 en/git-update-index.txt:360 en/git-var.txt:28 en/git-worktree.txt:493
#, no-wrap, priority:300
msgid "EXAMPLES"
msgstr "实例"

#. type: Plain text
#: en/git-add.txt:224
#, fuzzy, priority:300
msgid "Adds content from all `*.txt` files under `Documentation` directory and its subdirectories:"
msgstr "添加 `Documentation` 目录及其子目录下所有 `*.txt` 文件的内容："

#. type: delimited block -
#: en/git-add.txt:227
#, no-wrap, priority:300
msgid "$ git add Documentation/\\*.txt\n"
msgstr "$ git add Documentation/\\*.txt\n"

#. type: Plain text
#: en/git-add.txt:232
#, priority:300
msgid "Note that the asterisk `*` is quoted from the shell in this example; this lets the command include the files from subdirectories of `Documentation/` directory."
msgstr "注意，在本例中，星号 `*` 是从 shell 中引入的；这使得该命令可以包含 `Documentation/` 的子目录中的文件。"

#. type: Plain text
#: en/git-add.txt:234
#, fuzzy, priority:300
msgid "Considers adding content from all git-*.sh scripts:"
msgstr "从所有 git-*.sh 脚本中添加内容："

#. type: delimited block -
#: en/git-add.txt:237
#, no-wrap, priority:300
msgid "$ git add git-*.sh\n"
msgstr "$ git add git-*.sh\n"

#. type: Plain text
#: en/git-add.txt:242
#, fuzzy, priority:300
msgid "Because this example lets the shell expand the asterisk (i.e. you are listing the files explicitly), it does not consider `subdir/git-foo.sh`."
msgstr "因为这个示例允许 shell 扩展星号（即显式列出文件），所以它不包含 `subdir/git-foo.sh`。"

#. type: Title -
#: en/git-add.txt:244 en/git-rebase.txt:828
#, no-wrap, priority:300
msgid "INTERACTIVE MODE"
msgstr "交互模式"

#. type: Plain text
#: en/git-add.txt:248
#, fuzzy, priority:300
msgid "When the command enters the interactive mode, it shows the output of the 'status' subcommand, and then goes into its interactive command loop."
msgstr "当命令进入交互模式时，它将显示 `status` 子命令的输出，然后进入其交互命令循环。"

#. type: Plain text
#: en/git-add.txt:253 en/git-clean.txt:85
#, fuzzy, priority:300
msgid "The command loop shows the list of subcommands available, and gives a prompt \"What now> \".  In general, when the prompt ends with a single '>', you can pick only one of the choices given and type return, like this:"
msgstr "命令循环显示可用的子命令列表，并提示 `What now>`。通常，当提示以单个 `>` 结尾时，您只能选择给定的一个选项并键入回车，如下所示："

#. type: delimited block -
#: en/git-add.txt:259
#, fuzzy, no-wrap, priority:300
msgid ""
"    *** Commands ***\n"
"      1: status       2: update       3: revert       4: add untracked\n"
"      5: patch        6: diff         7: quit         8: help\n"
"    What now> 1\n"
msgstr ""
"    *** Commands ***\n"
"      1: status       2: update       3: revert       4: add untracked\n"
"      5: patch        6: diff         7: quit         8: help\n"
"    What now> 1\n"

#. type: Plain text
#: en/git-add.txt:263
#, fuzzy, priority:300
msgid "You also could say `s` or `sta` or `status` above as long as the choice is unique."
msgstr "你也可以输入 `s`、`sta` 或 `status`，只要候选项是唯一的。"

#. type: Plain text
#: en/git-add.txt:265
#, fuzzy, priority:300
msgid "The main command loop has 6 subcommands (plus help and quit)."
msgstr "主命令循环有6个子命令（包括帮助和退出）。"

#. type: Labeled list
#: en/git-add.txt:266
#, no-wrap, priority:300
msgid "status"
msgstr "状态"

#. type: Plain text
#: en/git-add.txt:273
#, fuzzy, priority:300
msgid "This shows the change between HEAD and index (i.e. what will be committed if you say `git commit`), and between index and working tree files (i.e. what you could stage further before `git commit` using `git add`) for each path.  A sample output looks like this:"
msgstr "这将显示每个路径下 HEAD 和索引之间的更改（即，如果输入 `git commit`，将提交什么），以及索引和工作树文件之间的更改（即，在输入 `git commit` 之前，执行 `git add` 可以进一步暂存什么）。示例输出如下："

#. type: delimited block -
#: en/git-add.txt:278
#, fuzzy, no-wrap, priority:300
msgid ""
"              staged     unstaged path\n"
"     1:       binary      nothing foo.png\n"
"     2:     +403/-35        +1/-1 add-interactive.c\n"
msgstr ""
"              staged     unstaged path\n"
"     1:       binary      nothing foo.png\n"
"     2:     +403/-35        +1/-1 git-add--interactive.perl\n"

#. type: Plain text
#: en/git-add.txt:289
#, fuzzy, priority:300
msgid "It shows that foo.png has differences from HEAD (but that is binary so line count cannot be shown) and there is no difference between indexed copy and the working tree version (if the working tree version were also different, 'binary' would have been shown in place of 'nothing').  The other file, add-interactive.c, has 403 lines added and 35 lines deleted if you commit what is in the index, but working tree file has further modifications (one addition and one deletion)."
msgstr "它表明foo.png与HEAD有区别（但其是二进制的，因此无法显示行数），索引副本和工作树版本之间没有区别（如果工作树版本也不同，`nothing`的位置上会显示`binary`）。另一个文件git add-{litdd}interactive.perl添加了403行，如果提交索引中的内容，则删除了35行，但工作树文件有额外修改（一次添加一次删除）。"

#. type: Labeled list
#: en/git-add.txt:290 en/git-update-ref.txt:102
#, ignore-same, no-wrap, priority:300
msgid "update"
msgstr "update"

#. type: Plain text
#: en/git-add.txt:299
#, fuzzy, priority:300
msgid "This shows the status information and issues an \"Update>>\" prompt.  When the prompt ends with double '>>', you can make more than one selection, concatenated with whitespace or comma.  Also you can say ranges.  E.g. \"2-5 7,9\" to choose 2,3,4,5,7,9 from the list.  If the second number in a range is omitted, all remaining patches are taken.  E.g. \"7-\" to choose 7,8,9 from the list.  You can say '*' to choose everything."
msgstr "这将显示状态信息并发出“更新>>”提示。当提示以“>>”结尾时，可以进行多个选择，并用空格或逗号连接。你也可以输入范围。例如：“2-5 7,9”将从列表中选择2、3、4、5、7、9。如果省略一个范围中的第二个数字，则将获取所有剩余的补丁。例如：“7-”从列表中选择7、8、9。你可以输入“*”来选择全部补丁。"

#. type: Plain text
#: en/git-add.txt:302
#, fuzzy, priority:300
msgid "What you chose are then highlighted with '*', like this:"
msgstr "您选择的内容会用“*”突出显示，如下所示："

#. type: delimited block -
#: en/git-add.txt:307
#, fuzzy, no-wrap, priority:300
msgid ""
"           staged     unstaged path\n"
"  1:       binary      nothing foo.png\n"
"* 2:     +403/-35        +1/-1 add-interactive.c\n"
msgstr ""
"           staged     unstaged path\n"
"  1:       binary      nothing foo.png\n"
"* 2:     +403/-35        +1/-1 git-add--interactive.perl\n"

#. type: Plain text
#: en/git-add.txt:311
#, fuzzy, priority:300
msgid "To remove selection, prefix the input with `-` like this:"
msgstr "要删除选定内容，请在输入前加上`-`，如下所示："

#. type: delimited block -
#: en/git-add.txt:314
#, fuzzy, no-wrap, priority:300
msgid "Update>> -2\n"
msgstr "Update>> -2\n"

#. type: Plain text
#: en/git-add.txt:318
#, fuzzy, priority:300
msgid "After making the selection, answer with an empty line to stage the contents of working tree files for selected paths in the index."
msgstr "进行选择后，输入空行，以便为索引中选定的路径暂存工作树文件的内容。"

#. type: Labeled list
#: en/git-add.txt:319
#, no-wrap, priority:300
msgid "revert"
msgstr "还原"

#. type: Plain text
#: en/git-add.txt:324
#, fuzzy, priority:300
msgid "This has a very similar UI to 'update', and the staged information for selected paths are reverted to that of the HEAD version.  Reverting new paths makes them untracked."
msgstr "它有一个与 'update' 非常相似的交互过程，所选路径的暂存信息将还原为 HEAD 版本。还原新路径将使它们不被追踪。"

#. type: Labeled list
#: en/git-add.txt:325
#, no-wrap, priority:300
msgid "add untracked"
msgstr "添加未跟踪文件"

#. type: Plain text
#: en/git-add.txt:329
#, fuzzy, priority:300
msgid "This has a very similar UI to 'update' and 'revert', and lets you add untracked paths to the index."
msgstr "它有一个与 'update' 和 'revert' 非常相似的交互过程，允许您向索引添加未跟踪的路径。"

#. type: Labeled list
#: en/git-add.txt:330
#, no-wrap, priority:300
msgid "patch"
msgstr "补丁"

#. type: Plain text
#: en/git-add.txt:337
#, fuzzy, priority:300
msgid "This lets you choose one path out of a 'status' like selection.  After choosing the path, it presents the diff between the index and the working tree file and asks you if you want to stage the change of each hunk.  You can select one of the following options and type return:"
msgstr "这允许您从类似 \"status\" 命令的选择中选择一条路径。在选择路径之后，它将显示索引和工作树文件之间的差异，并询问您是否要暂存每个块的更改。您可以选择以下选项之一并输入回车："

#. type: Plain text
#: en/git-add.txt:352
#, fuzzy, no-wrap, priority:300
msgid ""
"y - stage this hunk\n"
"n - do not stage this hunk\n"
"q - quit; do not stage this hunk or any of the remaining ones\n"
"a - stage this hunk and all later hunks in the file\n"
"d - do not stage this hunk or any of the later hunks in the file\n"
"g - select a hunk to go to\n"
"/ - search for a hunk matching the given regex\n"
"j - leave this hunk undecided, see next undecided hunk\n"
"J - leave this hunk undecided, see next hunk\n"
"k - leave this hunk undecided, see previous undecided hunk\n"
"K - leave this hunk undecided, see previous hunk\n"
"s - split the current hunk into smaller hunks\n"
"e - manually edit the current hunk\n"
"? - print help\n"
msgstr ""
"y - 暂存此区块\n"
"n - 不暂存此区块\n"
"q - 退出；不暂存包括此块在内的剩余的区块\n"
"a - 暂存此块与此文件后面所有的区块\n"
"d - 不暂存此块与此文件后面所有的 区块\n"
"g - 选择并跳转至一个区块\n"
"/ - 搜索与给定正则表达示匹配的区块\n"
"j - 暂不决定，转至下一个未决定的区块\n"
"J - 暂不决定，转至下一个区块\n"
"k - 暂不决定，转至上一个未决定的区块\n"
"K - 暂不决定，转至上一个区块\n"
"s - 将当前的区块分割成多个较小的区块\n"
"e - 手动编辑当前的区块\n"
"? - 输出帮助\n"

#. type: Plain text
#: en/git-add.txt:355
#, fuzzy, priority:300
msgid "After deciding the fate for all hunks, if there is any hunk that was chosen, the index is updated with the selected hunks."
msgstr "在决定了所有块的操作后，如果有选择的区块，则会使用其来更新索引。"

#. type: Plain text
#: en/git-add.txt:358
#, fuzzy, priority:300
msgid "You can omit having to type return here, by setting the configuration variable `interactive.singleKey` to `true`."
msgstr "通过将配置变量 `interactive.singleKey` 设置为 `true`，在此处可以不必键入回车。"

#. type: Labeled list
#: en/git-add.txt:359
#, ignore-same, no-wrap, priority:300
msgid "diff"
msgstr "diff"

#. type: Plain text
#: en/git-add.txt:363
#, fuzzy, priority:300
msgid "This lets you review what will be committed (i.e. between HEAD and index)."
msgstr "这使您可以查看要提交的内容（即，在HEAD和索引之间）。"

#. type: Title -
#: en/git-add.txt:366
#, no-wrap, priority:300
msgid "EDITING PATCHES"
msgstr "编辑补丁"

#. type: Plain text
#: en/git-add.txt:376
#, fuzzy, priority:300
msgid "Invoking `git add -e` or selecting `e` from the interactive hunk selector will open a patch in your editor; after the editor exits, the result is applied to the index. You are free to make arbitrary changes to the patch, but note that some changes may have confusing results, or even result in a patch that cannot be applied.  If you want to abort the operation entirely (i.e., stage nothing new in the index), simply delete all lines of the patch. The list below describes some common things you may see in a patch, and which editing operations make sense on them."
msgstr "调用`git add -e`或从交互式块选择器中选择`e`命令，将在编辑器中打开一个补丁。编辑器退出后，结果将应用于索引。您可以随意对补丁进行任何更改，但是请注意，某些更改可能会导致混乱，甚至导致补丁无法使用。如果您想完全中止该操作（即不在索引中更新内容），只需删除补丁中的所有行。下面的列表描述了您可能会在补丁中看到的一些常见内容，以及对其进行哪些编辑操作才有意义。"

#. type: Labeled list
#: en/git-add.txt:378
#, no-wrap, priority:300
msgid "added content"
msgstr "添加的内容"

#. type: Plain text
#: en/git-add.txt:382
#, fuzzy, priority:300
msgid "Added content is represented by lines beginning with \"{plus}\". You can prevent staging any addition lines by deleting them."
msgstr "添加的内容以“ {plus}”开头的行表示。您可以删除它们以防止暂存。"

#. type: Labeled list
#: en/git-add.txt:383
#, no-wrap, priority:300
msgid "removed content"
msgstr "删除的内容"

#. type: Plain text
#: en/git-add.txt:387
#, fuzzy, priority:300
msgid "Removed content is represented by lines beginning with \"-\". You can prevent staging their removal by converting the \"-\" to a \" \" (space)."
msgstr "删除的内容以“-”开头的行表示。您可以通过将“-”转换为“ ”（空格）来防止将其删除。"

#. type: Labeled list
# 译者：末尾两个字节可能被删减，如果翻译为中文标点会出现半个汉字
#: en/git-add.txt:388
#, no-wrap, priority:300
msgid "modified content"
msgstr "修改的内容"

#. type: Plain text
#: en/git-add.txt:395
#, fuzzy, priority:300
msgid "Modified content is represented by \"-\" lines (removing the old content)  followed by \"{plus}\" lines (adding the replacement content). You can prevent staging the modification by converting \"-\" lines to \" \", and removing \"{plus}\" lines. Beware that modifying only half of the pair is likely to introduce confusing changes to the index."
msgstr "修改后的内容由“-”行（删除旧内容）和“{plus}”行（添加替换内容）表示。通过将“-”行转换为“ ”，并删除“{plus}”行，可以防止临时进行修改。请注意，只修改其中一个可能会给索引带来混乱的更改。"

#. type: Plain text
#: en/git-add.txt:403
#, fuzzy, priority:300
msgid "There are also more complex operations that can be performed. But beware that because the patch is applied only to the index and not the working tree, the working tree will appear to \"undo\" the change in the index.  For example, introducing a new line into the index that is in neither the HEAD nor the working tree will stage the new line for commit, but the line will appear to be reverted in the working tree."
msgstr "还可以执行更复杂的操作。但是请注意，由于补丁仅应用于索引而不是工作树，因此工作树似乎会“撤消”索引中的更改。例如，在索引中添加一行，而该行不在 HEAD 或工作树。此时会暂存其以进行提交，但是该行似乎在会在工作树中进行还原。"

#. type: Plain text
#: en/git-add.txt:405
#, fuzzy, priority:300
msgid "Avoid using these constructs, or do so with extreme caution."
msgstr "避免使用这些构造，除非格外小心。"

#. type: Labeled list
#: en/git-add.txt:407
#, fuzzy, no-wrap, priority:300
msgid "removing untouched content"
msgstr "删除未改动的内容"

#. type: Plain text
#: en/git-add.txt:413
#, fuzzy, priority:300
msgid "Content which does not differ between the index and working tree may be shown on context lines, beginning with a \" \" (space).  You can stage context lines for removal by converting the space to a \"-\". The resulting working tree file will appear to re-add the content."
msgstr "索引和工作树之间没有区别的内容可能会显示在上下文行中，以“ ”（空格）开头。您可以通过将空格转换为“-”来暂存要删除的上下文行。生成的工作树文件将重新添加内容。"

#. type: Labeled list
#: en/git-add.txt:414
#, no-wrap, priority:300
msgid "modifying existing content"
msgstr "修改现有的内容"

#. type: Plain text
#: en/git-add.txt:421
#, fuzzy, priority:300
msgid "One can also modify context lines by staging them for removal (by converting \" \" to \"-\") and adding a \"{plus}\" line with the new content.  Similarly, one can modify \"{plus}\" lines for existing additions or modifications. In all cases, the new modification will appear reverted in the working tree."
msgstr "也可以通过暂存上下文行（通过将“ ”转换为“-”）以进行删除来修改上下文行，并在其中添加新内容的“{plus}”行。类似地，可以修改“{plus}”行以进行现有内容的添加或修改。在所有情况下，新的修改都将在工作树中还原。"

#. type: Labeled list
#: en/git-add.txt:422
#, no-wrap, priority:300
msgid "new content"
msgstr "新的内容"

#. type: Plain text
#: en/git-add.txt:427
#, fuzzy, priority:300
msgid "You may also add new content that does not exist in the patch; simply add new lines, each starting with \"{plus}\". The addition will appear reverted in the working tree."
msgstr "您还可以添加补丁中不存在的新内容。只需添加新行，每行以“{plus}”开头。添加的内容将还原到工作树中。"

#. type: Plain text
#: en/git-add.txt:431
#, fuzzy, priority:300
msgid "There are also several operations which should be avoided entirely, as they will make the patch impossible to apply:"
msgstr "还有一些操作应完全避免，因为它们会使补丁无法应用："

#. type: Plain text
#: en/git-add.txt:433
#, fuzzy, priority:300
msgid "adding context (\" \") or removal (\"-\") lines"
msgstr "添加上下文（“ ”）行或添加删除（“-”）行"

#. type: Plain text
#: en/git-add.txt:434
#, fuzzy, priority:300
msgid "deleting context or removal lines"
msgstr "删除上下文行或删除标记为删除的行"

#. type: Plain text
#: en/git-add.txt:435
#, fuzzy, priority:300
msgid "modifying the contents of context or removal lines"
msgstr "修改上下文或删除行的内容"

#. type: Title -
#: en/git-add.txt:437 en/git-am.txt:270 en/git-apply.txt:264 en/git-archive.txt:137 en/git-blame.txt:245 en/git-branch.txt:342 en/git-check-mailmap.txt:40 en/git-checkout.txt:608 en/git-clean.txt:137 en/git-clone.txt:379 en/git-column.txt:78 en/git-config.txt:291 en/git-cvsexportcommit.txt:86 en/git-difftool.txt:119 en/git-diff.txt:224 en/git-fast-import.txt:1568 en/git-fetch.txt:298 en/git-fmt-merge-msg.txt:57 en/git-format-patch.txt:406 en/git-fsck.txt:108 en/git-gc.txt:113 en/git-grep.txt:344 en/git-imap-send.txt:52 en/git-init.txt:173 en/git-instaweb.txt:70 en/git-log.txt:198 en/git-mailinfo.txt:119 en/git-mergetool.txt:104 en/git-merge.txt:391 en/git-notes.txt:337 en/git-pack-objects.txt:445 en/git-push.txt:701 en/git-range-diff.txt:128 en/git-rebase.txt:1279 en/git-repack.txt:222 en/git-revert.txt:146 en/git-send-email.txt:477 en/git-show-branch.txt:203 en/git-stash.txt:389 en/git-status.txt:425 en/git-svn.txt:1064 en/git-switch.txt:269 en/git-tag.txt:219 en/git-update-index.txt:555
#, no-wrap, priority:300
msgid "CONFIGURATION"
msgstr "配置"

#. type: Title -
#: en/git-add.txt:444 en/git-am.txt:277 en/git-annotate.txt:28 en/git-apply.txt:286 en/git-archive.txt:236 en/git-bisect.txt:504 en/git-blame.txt:252 en/git-branch.txt:420 en/git-check-attr.txt:120 en/git-check-ignore.txt:119 en/git-checkout.txt:615 en/git-cherry-pick.txt:238 en/git-cherry.txt:140 en/git-clean.txt:144 en/git-commit-tree.txt:95 en/git-commit.txt:581 en/git-difftool.txt:128 en/git-diff.txt:231 en/git-fast-export.txt:279 en/git-fast-import.txt:1575 en/git-fetch-pack.txt:131 en/git-fetch.txt:312 en/git-fmt-merge-msg.txt:77 en/git-for-each-ref.txt:492 en/git-format-patch.txt:766 en/git-gc.txt:160 en/git-gui.txt:103 en/git-imap-send.txt:141 en/git-instaweb.txt:89 en/git-interpret-trailers.txt:485 en/git-ls-files.txt:326 en/git-ls-remote.txt:147 en/git-merge.txt:403 en/git-pack-objects.txt:455 en/git-pack-redundant.txt:57 en/git-prune-packed.txt:41 en/git-prune.txt:81 en/git-pull.txt:249 en/git-range-diff.txt:292 en/git-read-tree.txt:431 en/git-receive-pack.txt:256 en/git-remote-ext.txt:120 en/git-remote-fd.txt:54 en/git-remote.txt:262 en/git-repack.txt:242 en/git-replace.txt:149 en/git-restore.txt:212 en/git-revert.txt:153 en/git-rm.txt:199 en/git-send-email.txt:522 en/git-shell.txt:99 en/git-show-ref.txt:190 en/git-stash.txt:397 en/git-status.txt:521 en/git-submodule.txt:462 en/git-svn.txt:1169 en/git-switch.txt:276 en/git-tag.txt:400 en/git.txt:1084 en/git-update-index.txt:599 en/git-upload-pack.txt:59 en/git-var.txt:98 en/gitglossary.txt:18
#, no-wrap, priority:310
msgid "SEE ALSO"
msgstr "参见"

#. type: Plain text
#: en/git-add.txt:451
#, ignore-same, priority:300
msgid "linkgit:git-status[1] linkgit:git-rm[1] linkgit:git-reset[1] linkgit:git-mv[1] linkgit:git-commit[1] linkgit:git-update-index[1]"
msgstr "linkgit:git-status[1] linkgit:git-rm[1] linkgit:git-reset[1] linkgit:git-mv[1] linkgit:git-commit[1] linkgit:git-update-index[1]"

#. type: Title -
#: en/git-add.txt:453 en/git-am.txt:282 en/git-annotate.txt:32 en/git-apply.txt:290 en/git-archimport.txt:112 en/git-archive.txt:240 en/git-bisect.txt:509 en/git-blame.txt:256 en/git-branch.txt:428 en/git-bugreport.txt:71 en/git-bundle.txt:330 en/git-cat-file.txt:413 en/git-check-attr.txt:124 en/git-check-ignore.txt:125 en/git-check-mailmap.txt:53 en/git-checkout-index.txt:182 en/git-checkout.txt:620 en/git-check-ref-format.txt:139 en/git-cherry-pick.txt:242 en/git-cherry.txt:144 en/git-citool.txt:24 en/git-clean.txt:148 en/git-clone.txt:389 en/git-column.txt:85 en/git-commit-tree.txt:100 en/git-commit.txt:589 en/git-config.txt:591 en/git-count-objects.txt:53 en/git-credential-cache--daemon.txt:29 en/git-credential-cache.txt:82 en/git-credential-store.txt:109 en/git-credential.txt:195 en/git-cvsexportcommit.txt:117 en/git-cvsimport.txt:227 en/git-cvsserver.txt:432 en/git-daemon.txt:340 en/git-describe.txt:210 en/git-diff-files.txt:51 en/git-diff-index.txt:126 en/git-difftool.txt:139 en/git-diff-tree.txt:130 en/git-diff.txt:241 en/git-fast-export.txt:283 en/git-fast-import.txt:1579 en/git-fetch-pack.txt:135 en/git-fetch.txt:316 en/git-filter-branch.txt:702 en/git-fmt-merge-msg.txt:81 en/git-for-each-ref.txt:496 en/git-format-patch.txt:770 en/git-fsck-objects.txt:21 en/git-fsck.txt:180 en/git-gc.txt:167 en/git-get-tar-commit-id.txt:29 en/git-grep.txt:351 en/git-gui.txt:120 en/git-hash-object.txt:64 en/git-help.txt:230 en/git-http-backend.txt:300 en/git-http-fetch.txt:61 en/git-http-push.txt:95 en/git-imap-send.txt:145 en/git-index-pack.txt:144 en/git-init-db.txt:22 en/git-init.txt:180 en/git-instaweb.txt:93 en/git-interpret-trailers.txt:489 en/git-log.txt:219 en/git-ls-files.txt:330 en/git-ls-remote.txt:151 en/git-ls-tree.txt:164 en/git-mailinfo.txt:126 en/git-mailsplit.txt:56 en/git-merge-base.txt:246 en/git-merge-file.txt:97 en/git-merge-index.txt:82 en/git-merge-one-file.txt:20 en/git-mergetool--lib.txt:52 en/git-mergetool.txt:129 en/git-merge-tree.txt:315 en/git-merge.txt:412 en/git-mktag.txt:65 en/git-mktree.txt:39 en/git-mv.txt:68 en/git-name-rev.txt:111 en/git-notes.txt:382 en/git-p4.txt:802 en/git-pack-objects.txt:461 en/git-pack-redundant.txt:63 en/git-pack-refs.txt:95 en/git-patch-id.txt:68 en/git-prune-packed.txt:46 en/git-prune.txt:88 en/git-pull.txt:253 en/git-push.txt:708 en/git-quiltimport.txt:63 en/git-range-diff.txt:296 en/git-read-tree.txt:436 en/git-rebase.txt:1287 en/git-receive-pack.txt:260 en/git-reflog.txt:134 en/git-remote-ext.txt:124 en/git-remote-fd.txt:58 en/git-remote.txt:268 en/git-repack.txt:247 en/git-replace.txt:160 en/git-request-pull.txt:78 en/git-rerere.txt:221 en/git-reset.txt:505 en/git-restore.txt:217 en/git-revert.txt:157 en/git-rev-list.txt:128 en/git-rev-parse.txt:489 en/git-rm.txt:203 en/git-send-email.txt:526 en/git-send-pack.txt:156 en/git-shell.txt:105 en/git-sh-i18n--envsubst.txt:35 en/git-sh-i18n.txt:42 en/git-shortlog.txt:129 en/git-show-branch.txt:210 en/git-show-index.txt:51 en/git-show-ref.txt:197 en/git-show.txt:89 en/git-sh-setup.txt:94 en/git-stage.txt:22 en/git-stash.txt:405 en/git-status.txt:525 en/git-stripspace.txt:93 en/git-submodule.txt:466 en/git-svn.txt:1173 en/git-switch.txt:281 en/git-symbolic-ref.txt:77 en/git-tag.txt:405 en/git.txt:1092 en/git-unpack-file.txt:27 en/git-unpack-objects.txt:51 en/git-update-index.txt:605 en/git-update-ref.txt:179 en/git-update-server-info.txt:40 en/git-upload-archive.txt:61 en/git-upload-pack.txt:63 en/git-var.txt:104 en/git-verify-commit.txt:31 en/git-verify-pack.txt:52 en/git-verify-tag.txt:31 en/git-web--browse.txt:123 en/git-whatchanged.txt:42 en/git-worktree.txt:519 en/git-write-tree.txt:41 en/gitglossary.txt:26
#, no-wrap, priority:310
msgid "GIT"
msgstr "GIT"

#. type: Plain text
#: en/git-add.txt:454 en/git-am.txt:283 en/git-annotate.txt:33 en/git-apply.txt:291 en/git-archimport.txt:113 en/git-archive.txt:241 en/git-bisect.txt:510 en/git-blame.txt:257 en/git-branch.txt:429 en/git-bugreport.txt:72 en/git-bundle.txt:331 en/git-cat-file.txt:414 en/git-check-attr.txt:125 en/git-check-ignore.txt:126 en/git-check-mailmap.txt:54 en/git-checkout-index.txt:183 en/git-checkout.txt:621 en/git-check-ref-format.txt:140 en/git-cherry-pick.txt:243 en/git-cherry.txt:145 en/git-citool.txt:25 en/git-clean.txt:149 en/git-clone.txt:390 en/git-column.txt:86 en/git-commit-tree.txt:101 en/git-commit.txt:590 en/git-config.txt:592 en/git-count-objects.txt:54 en/git-credential-cache--daemon.txt:30 en/git-credential-cache.txt:83 en/git-credential-store.txt:110 en/git-credential.txt:196 en/git-cvsexportcommit.txt:118 en/git-cvsimport.txt:228 en/git-cvsserver.txt:433 en/git-daemon.txt:341 en/git-describe.txt:211 en/git-diff-files.txt:52 en/git-diff-index.txt:127 en/git-difftool.txt:140 en/git-diff-tree.txt:131 en/git-diff.txt:242 en/git-fast-export.txt:284 en/git-fast-import.txt:1580 en/git-fetch-pack.txt:136 en/git-fetch.txt:317 en/git-filter-branch.txt:703 en/git-fmt-merge-msg.txt:82 en/git-for-each-ref.txt:497 en/git-format-patch.txt:771 en/git-fsck-objects.txt:22 en/git-fsck.txt:181 en/git-gc.txt:168 en/git-get-tar-commit-id.txt:30 en/git-grep.txt:352 en/git-gui.txt:121 en/git-hash-object.txt:65 en/git-help.txt:231 en/git-http-backend.txt:301 en/git-http-fetch.txt:62 en/git-http-push.txt:96 en/git-imap-send.txt:146 en/git-index-pack.txt:145 en/git-init-db.txt:23 en/git-init.txt:181 en/git-instaweb.txt:94 en/git-interpret-trailers.txt:490 en/git-log.txt:220 en/git-ls-files.txt:331 en/git-ls-remote.txt:152 en/git-ls-tree.txt:165 en/git-mailinfo.txt:127 en/git-mailsplit.txt:57 en/git-merge-base.txt:247 en/git-merge-file.txt:98 en/git-merge-index.txt:83 en/git-merge-one-file.txt:21 en/git-mergetool--lib.txt:53 en/git-mergetool.txt:130 en/git-merge-tree.txt:316 en/git-merge.txt:413 en/git-mktag.txt:66 en/git-mktree.txt:40 en/git-mv.txt:69 en/git-name-rev.txt:112 en/git-notes.txt:383 en/git-p4.txt:803 en/git-pack-objects.txt:462 en/git-pack-redundant.txt:64 en/git-pack-refs.txt:96 en/git-patch-id.txt:69 en/git-prune-packed.txt:47 en/git-prune.txt:89 en/git-pull.txt:254 en/git-push.txt:709 en/git-quiltimport.txt:64 en/git-range-diff.txt:297 en/git-read-tree.txt:437 en/git-rebase.txt:1288 en/git-receive-pack.txt:261 en/git-reflog.txt:135 en/git-remote-ext.txt:125 en/git-remote-fd.txt:59 en/git-remote.txt:269 en/git-repack.txt:248 en/git-replace.txt:161 en/git-request-pull.txt:79 en/git-rerere.txt:222 en/git-reset.txt:506 en/git-restore.txt:218 en/git-revert.txt:158 en/git-rev-list.txt:129 en/git-rev-parse.txt:490 en/git-rm.txt:204 en/git-send-email.txt:527 en/git-send-pack.txt:157 en/git-shell.txt:106 en/git-sh-i18n--envsubst.txt:36 en/git-sh-i18n.txt:43 en/git-shortlog.txt:130 en/git-show-branch.txt:211 en/git-show-index.txt:52 en/git-show-ref.txt:198 en/git-show.txt:90 en/git-sh-setup.txt:95 en/git-stage.txt:23 en/git-stash.txt:406 en/git-status.txt:526 en/git-stripspace.txt:94 en/git-submodule.txt:467 en/git-svn.txt:1174 en/git-switch.txt:282 en/git-symbolic-ref.txt:78 en/git-tag.txt:406 en/git.txt:1093 en/git-unpack-file.txt:28 en/git-unpack-objects.txt:52 en/git-update-index.txt:606 en/git-update-ref.txt:180 en/git-update-server-info.txt:41 en/git-upload-archive.txt:62 en/git-upload-pack.txt:64 en/git-var.txt:105 en/git-verify-commit.txt:32 en/git-verify-pack.txt:53 en/git-verify-tag.txt:32 en/git-web--browse.txt:124 en/git-whatchanged.txt:43 en/git-worktree.txt:520 en/git-write-tree.txt:42 en/gitglossary.txt:27
#, priority:310
msgid "Part of the linkgit:git[1] suite"
msgstr "属于 linkgit:git[1] 文档"

#. type: Title =
#: en/git-am.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-am(1)"
msgstr "git-am(1)"

#. type: Plain text
#: en/git-am.txt:7
#, fuzzy, priority:100
msgid "git-am - Apply a series of patches from a mailbox"
msgstr "git-am - Apply a series of patches from a mailbox"

#. type: Plain text
#: en/git-am.txt:22
#, fuzzy, ignore-ellipsis, no-wrap, priority:100
msgid ""
"'git am' [--signoff] [--keep] [--[no-]keep-cr] [--[no-]utf8] [--no-verify]\n"
"\t [--[no-]3way] [--interactive] [--committer-date-is-author-date]\n"
"\t [--ignore-date] [--ignore-space-change | --ignore-whitespace]\n"
"\t [--whitespace=<option>] [-C<n>] [-p<n>] [--directory=<dir>]\n"
"\t [--exclude=<path>] [--include=<path>] [--reject] [-q | --quiet]\n"
"\t [--[no-]scissors] [-S[<keyid>]] [--patch-format=<format>]\n"
"\t [--quoted-cr=<action>]\n"
"\t [--empty=(stop|drop|keep)]\n"
"\t [(<mbox> | <Maildir>)...]\n"
"'git am' (--continue | --skip | --abort | --quit | --show-current-patch[=(diff|raw)] | --allow-empty)\n"
msgstr ""
"'git am' [--signoff] [--keep] [--[no-]keep-cr] [--[no-]utf8] [--no-verify]\n"
"\t [--[no-]3way] [--interactive] [--committer-date-is-author-date]\n"
"\t [--ignore-date] [--ignore-space-change | --ignore-whitespace]\n"
"\t [--whitespace=<选项>] [-C<n>] [-p<n>] [--directory=<dir>]\n"
"\t [--exclude=<路径>] [--include=<路径>] [--reject] [-q | --quiet]\n"
"\t [--[no-]scissors] [-S[<keyid>]] [--patch-format=<format>]\n"
"\t [--quoted-cr=<action>]\n"
"\t [--empty=(stop|drop|keep)]\n"
"\t [(<mbox> | <Maildir>)...]\n"
"'git am' (--continue | --skip | --abort | --quit | --show-current-patch[=(diff|raw)] | --allow-empty)\n"

#. type: Plain text
#: en/git-am.txt:30
#, priority:100
msgid "Splits mail messages in a mailbox into commit log message, authorship information and patches, and applies them to the current branch. You could think of it as a reverse operation of linkgit:git-format-patch[1] run on a branch with a straight history without merges."
msgstr "将邮箱中的邮件信息拆分为提交日志信息、作者信息和补丁，并将其应用到当前分支。你可以把它看作是 linkgit:git-format-patch[1] 的反向操作，在一个没有合并历史的分支上运行。"

#. type: Labeled list
#: en/git-am.txt:33
#, fuzzy, ignore-ellipsis, no-wrap, priority:100
msgid "(<mbox>|<Maildir>)..."
msgstr "(<mbox>|<Maildir>)..."

#. type: Plain text
#: en/git-am.txt:37
#, priority:100
msgid "The list of mailbox files to read patches from. If you do not supply this argument, the command reads from the standard input.  If you supply directories, they will be treated as Maildirs."
msgstr "要读取补丁的邮箱文件的列表。如果你不提供这个参数，命令将从标准输入中读取。 如果你提供目录，它们将被视为邮箱目录。"

#. type: Labeled list
#: en/git-am.txt:39 en/git-cherry-pick.txt:106 en/git-format-patch.txt:139 en/git-rebase.txt:511 en/git-revert.txt:101 en/signoff-option.txt:4
#, ignore-same, no-wrap, priority:280
msgid "--signoff"
msgstr "--signoff"

#. type: Plain text
#: en/git-am.txt:43 en/git-format-patch.txt:143
#, priority:100
msgid "Add a `Signed-off-by` trailer to the commit message, using the committer identity of yourself.  See the signoff option in linkgit:git-commit[1] for more information."
msgstr "在提交信息中加入 `Signed-off-by` 的尾注，使用自己的提交者身份。 更多信息见 linkgit:git-commit[1] 中的 signoff 选项。"

#. type: Plain text
#: en/git-am.txt:47
#, priority:100
msgid "Pass `-k` flag to 'git mailinfo' (see linkgit:git-mailinfo[1])."
msgstr "传递`-k` 标志给 'git mailinfo'（见linkgit:git-mailinfo[1]）。"

#. type: Labeled list
#: en/git-am.txt:48 en/git-quiltimport.txt:59
#, ignore-same, no-wrap, priority:100
msgid "--keep-non-patch"
msgstr "--keep-non-patch"

#. type: Plain text
#: en/git-am.txt:50 en/git-quiltimport.txt:61
#, priority:100
msgid "Pass `-b` flag to 'git mailinfo' (see linkgit:git-mailinfo[1])."
msgstr "将 `-b` 标志传递给 'git mailinfo'（见linkgit:git-mailinfo[1]）。"

#. type: Labeled list
#: en/git-am.txt:51
#, ignore-same, no-wrap, priority:100
msgid "--[no-]keep-cr"
msgstr "--[no-]keep-cr"

#. type: Plain text
#: en/git-am.txt:56
#, priority:100
msgid "With `--keep-cr`, call 'git mailsplit' (see linkgit:git-mailsplit[1])  with the same option, to prevent it from stripping CR at the end of lines. `am.keepcr` configuration variable can be used to specify the default behaviour.  `--no-keep-cr` is useful to override `am.keepcr`."
msgstr "使用 `--keep-cr`，调用 'git mailsplit'（见linkgit:git-mailsplit[1]），并使用相同的选项，以防止它在行末剥离 CR。`am.keepcr` 配置变量可以用来指定默认行为。 `--no-keep-cr` 可以用来覆盖 `am.keepcr`。"

#. type: Labeled list
#: en/git-am.txt:58 en/git-mailinfo.txt:76
#, ignore-same, no-wrap, priority:100
msgid "--scissors"
msgstr "--scissors"

#. type: Plain text
#: en/git-am.txt:62
#, priority:100
msgid "Remove everything in body before a scissors line (see linkgit:git-mailinfo[1]). Can be activated by default using the `mailinfo.scissors` configuration variable."
msgstr "移除正文中剪切行之前的所有内容（见linkgit:git-mailinfo[1]）。可以使用 `mailinfo.scissors` 配置变量来默认激活。"

#. type: Labeled list
#: en/git-am.txt:63 en/git-mailinfo.txt:91
#, ignore-same, no-wrap, priority:100
msgid "--no-scissors"
msgstr "--no-scissors"

#. type: Plain text
#: en/git-am.txt:65
#, priority:100
msgid "Ignore scissors lines (see linkgit:git-mailinfo[1])."
msgstr "忽略剪切线（见linkgit:git-mailinfo[1]）。"

#. type: Labeled list
#: en/git-am.txt:66 en/git-mailinfo.txt:94
#, fuzzy, no-wrap, priority:100
msgid "--quoted-cr=<action>"
msgstr "--whitespace=<action>"

#. type: Plain text
#: en/git-am.txt:68
#, priority:100
msgid "This flag will be passed down to 'git mailinfo' (see linkgit:git-mailinfo[1])."
msgstr "这个标志将被传递给 'git mailinfo'（见 linkgit:git-mailinfo[1]）。"

#. type: Labeled list
#: en/git-am.txt:69
#, fuzzy, no-wrap, priority:100
msgid "--empty=(stop|drop|keep)"
msgstr "--empty={drop,keep,ask}"

#. type: Plain text
#: en/git-am.txt:76
#, priority:100
msgid "By default, or when the option is set to 'stop', the command errors out on an input e-mail message lacking a patch and stops into the middle of the current am session. When this option is set to 'drop', skip such an e-mail message instead.  When this option is set to 'keep', create an empty commit, recording the contents of the e-mail message as its log."
msgstr "默认情况下，或者当该选项被设置为 'stop' 时，该命令在输入缺乏补丁的电子邮件时出错，并停止到当前 am 会话的中间。当这个选项被设置为 'drop' 时，跳过这样的电子邮件信息。 当这个选项被设置为 'keep' 时，会创建一个空的提交，将电子邮件的内容记录为日志。"

#. type: Labeled list
#: en/git-am.txt:78 en/git-mailinfo.txt:72
#, ignore-same, no-wrap, priority:100
msgid "--message-id"
msgstr "--message-id"

#. type: Plain text
#: en/git-am.txt:83
#, priority:100
msgid "Pass the `-m` flag to 'git mailinfo' (see linkgit:git-mailinfo[1]), so that the Message-ID header is added to the commit message.  The `am.messageid` configuration variable can be used to specify the default behaviour."
msgstr "传递 `-m` 标志给 'git mailinfo'（见 linkgit:git-mailinfo[1]），这样 Message-ID 头会被添加到提交信息中。 `am.messageid` 配置变量可以用来指定默认行为。"

#. type: Labeled list
#: en/git-am.txt:84
#, ignore-same, no-wrap, priority:100
msgid "--no-message-id"
msgstr "--no-message-id"

#. type: Plain text
#: en/git-am.txt:87
#, priority:100
msgid "Do not add the Message-ID header to the commit message.  `no-message-id` is useful to override `am.messageid`."
msgstr "不要在提交信息中添加 Message-ID 头。  `no-message-id` 对于覆盖 `am.messageid` 很有用。"

#. type: Plain text
#: en/git-am.txt:91
#, priority:100
msgid "Be quiet. Only print error messages."
msgstr "保持安静。只打印错误信息。"

#. type: Labeled list
#: en/git-am.txt:93
#, ignore-same, no-wrap, priority:100
msgid "--utf8"
msgstr "--utf8"

#. type: Plain text
#: en/git-am.txt:99
#, priority:100
msgid "Pass `-u` flag to 'git mailinfo' (see linkgit:git-mailinfo[1]).  The proposed commit log message taken from the e-mail is re-coded into UTF-8 encoding (configuration variable `i18n.commitEncoding` can be used to specify project's preferred encoding if it is not UTF-8)."
msgstr "传递 `-u` 标志给 'git mailinfo'（见linkgit:git-mailinfo[1]）。 建议从邮件中提取的提交日志信息被重新编码为 UTF-8 编码（配置变量 `i18n.commitEncoding` 可以用来指定项目的首选编码，如果它不是 UTF-8）。"

#. type: Plain text
#: en/git-am.txt:102
#, no-wrap, priority:100
msgid ""
"This was optional in prior versions of git, but now it is the\n"
"default.   You can use `--no-utf8` to override this.\n"
msgstr ""
"这在以前的 git 版本中是可选的，但现在它是\n"
"默认的。  你可以使用 `--no-utf8` 来覆盖它。\n"

#. type: Labeled list
#: en/git-am.txt:103
#, ignore-same, no-wrap, priority:100
msgid "--no-utf8"
msgstr "--no-utf8"

#. type: Plain text
#: en/git-am.txt:106
#, priority:100
msgid "Pass `-n` flag to 'git mailinfo' (see linkgit:git-mailinfo[1])."
msgstr "传递 `-n` 标志给 'git mailinfo'（见linkgit:git-mailinfo[1]）。"

#. type: Labeled list
#: en/git-am.txt:107 en/git-apply.txt:85
#, ignore-same, no-wrap, priority:100
msgid "-3"
msgstr "-3"

#. type: Labeled list
#: en/git-am.txt:108 en/git-apply.txt:86
#, ignore-same, no-wrap, priority:100
msgid "--3way"
msgstr "--3way"

#. type: Labeled list
#: en/git-am.txt:109
#, ignore-same, no-wrap, priority:100
msgid "--no-3way"
msgstr "--no-3way"

#. type: Plain text
#: en/git-am.txt:116
#, priority:100
msgid "When the patch does not apply cleanly, fall back on 3-way merge if the patch records the identity of blobs it is supposed to apply to and we have those blobs available locally. `--no-3way` can be used to override am.threeWay configuration variable. For more information, see am.threeWay in linkgit:git-config[1]."
msgstr "当补丁不能干净地应用时，如果补丁记录了它应该应用到的二进制文件的身份，并且我们有这些二进制文件可以在本地使用，那么就退回到三路合并。`--no-3way` 可以用来覆盖 am.threeWay 配置变量。更多信息，见 linkgit:git-config[1] 中的 am.threeWay。"

#. type: Labeled list
#: en/git-am.txt:120 en/git-apply.txt:184 en/git-rebase.txt:473
#, ignore-same, no-wrap, priority:100
msgid "--ignore-whitespace"
msgstr "--ignore-whitespace"

#. type: Labeled list
#: en/git-am.txt:121 en/git-rebase.txt:491
#, fuzzy, no-wrap, priority:100
msgid "--whitespace=<option>"
msgstr "--whitespace=<option>"

#. type: Labeled list
#: en/git-am.txt:122 en/git-apply.txt:130 en/git-rebase.txt:430
#, fuzzy, no-wrap, priority:100
msgid "-C<n>"
msgstr "-C<n>"

#. type: Labeled list
#: en/git-am.txt:123 en/git-apply.txt:124
#, fuzzy, no-wrap, priority:100
msgid "-p<n>"
msgstr "-p<n>"

#. type: Labeled list
#: en/git-am.txt:124
#, fuzzy, no-wrap, priority:100
msgid "--directory=<dir>"
msgstr "--directory=<dir>"

#. type: Labeled list
#: en/git-am.txt:125
#, no-wrap, priority:100
msgid "--exclude=<path>"
msgstr "--exclude=<路径>"

#. type: Labeled list
#: en/git-am.txt:126
#, fuzzy, no-wrap, priority:100
msgid "--include=<path>"
msgstr "--include=<path>"

#. type: Labeled list
#: en/git-am.txt:127 en/git-apply.txt:109
#, ignore-same, no-wrap, priority:100
msgid "--reject"
msgstr "--reject"

#. type: Plain text
#: en/git-am.txt:131
#, priority:100
msgid "These flags are passed to the 'git apply' (see linkgit:git-apply[1])  program that applies the patch."
msgstr "这些标志会传递给应用补丁的 \"git apply\"（见 linkgit:git-apply[1]）程序。"

#. type: Labeled list
#: en/git-am.txt:132
#, ignore-same, no-wrap, priority:100
msgid "--patch-format"
msgstr "--patch-format"

#. type: Plain text
#: en/git-am.txt:138
#, priority:100
msgid "By default the command will try to detect the patch format automatically. This option allows the user to bypass the automatic detection and specify the patch format that the patch(es) should be interpreted as. Valid formats are mbox, mboxrd, stgit, stgit-series and hg."
msgstr "默认情况下，该命令将尝试自动检测补丁格式。这个选项允许用户绕过自动检测，并指定补丁的格式，以便将其解释为补丁。有效的格式是 mbox、mboxrd、stgit、stgit-series 和 hg。"

#. type: Plain text
#: en/git-am.txt:142
#, priority:100
msgid "Run interactively."
msgstr "交互式运行。"

#. type: Labeled list
#: en/git-am.txt:144 en/git-rebase.txt:423
#, ignore-same, no-wrap, priority:100
msgid "--no-verify"
msgstr "--no-verify"

#. type: Plain text
#: en/git-am.txt:148
#, fuzzy, priority:100
#| msgid "By default, the pre-commit and commit-msg hooks are run.  When any of `--no-verify` or `-n` is given, these are bypassed.  See also linkgit:githooks[5]."
msgid "By default, the pre-applypatch and applypatch-msg hooks are run.  When any of `--no-verify` or `-n` is given, these are bypassed.  See also linkgit:githooks[5]."
msgstr "默认情况下，会运行 pre-commit 和 commit-msg 钩子。当给出任何 `--no-verify` 或 `-n` 时，这些都会被绕过。参见链接git:githooks[5]。"

#. type: Labeled list
#: en/git-am.txt:149 en/git-rebase.txt:498
#, ignore-same, no-wrap, priority:100
msgid "--committer-date-is-author-date"
msgstr "--committer-date-is-author-date"

#. type: Plain text
#: en/git-am.txt:155
#, priority:100
msgid "By default the command records the date from the e-mail message as the commit author date, and uses the time of commit creation as the committer date. This allows the user to lie about the committer date by using the same value as the author date."
msgstr "默认情况下，该命令将电子邮件中的日期作为提交者日期，并使用提交者的创建时间作为提交者日期。这使得用户可以通过使用与作者日期相同的值来谎报提交者日期。"

#. type: Labeled list
#: en/git-am.txt:156 en/git-rebase.txt:503
#, ignore-same, no-wrap, priority:100
msgid "--ignore-date"
msgstr "--ignore-date"

#. type: Plain text
#: en/git-am.txt:162
#, priority:100
msgid "By default the command records the date from the e-mail message as the commit author date, and uses the time of commit creation as the committer date. This allows the user to lie about the author date by using the same value as the committer date."
msgstr "默认情况下，该命令将电子邮件中的日期作为提交者日期，并使用提交者的创建时间作为提交者日期。这使得用户可以通过使用与提交者日期相同的值来谎报作者日期。"

#. type: Labeled list
#: en/git-am.txt:163 en/git-rebase.txt:220 en/sequencer.txt:6
#, ignore-same, no-wrap, priority:100
msgid "--skip"
msgstr "--skip"

#. type: Plain text
#: en/git-am.txt:166
#, priority:100
msgid "Skip the current patch.  This is only meaningful when restarting an aborted patch."
msgstr "跳过当前的补丁。 这只有在重新启动一个中止的补丁时才有意义。"

#. type: Labeled list
#: en/git-am.txt:167 en/git-cherry-pick.txt:110 en/git-commit-tree.txt:62 en/git-commit.txt:389 en/git-rebase.txt:398 en/git-revert.txt:91 en/merge-options.txt:84
#, no-wrap, priority:280
msgid "-S[<keyid>]"
msgstr "-S[<keyid>]"

#. type: Labeled list
#: en/git-am.txt:168 en/git-cherry-pick.txt:111 en/git-commit-tree.txt:63 en/git-commit.txt:390 en/git-rebase.txt:399 en/git-revert.txt:92 en/merge-options.txt:85
#, no-wrap, priority:280
msgid "--gpg-sign[=<keyid>]"
msgstr "--gpg-sign[=<keyid>]"

#. type: Labeled list
#: en/git-am.txt:169 en/git-cherry-pick.txt:112 en/git-commit-tree.txt:64 en/git-commit.txt:391 en/git-rebase.txt:400 en/git-revert.txt:93 en/merge-options.txt:86
#, ignore-same, no-wrap, priority:280
msgid "--no-gpg-sign"
msgstr "--no-gpg-sign"

#. type: Plain text
#: en/git-am.txt:175 en/git-cherry-pick.txt:118 en/git-commit.txt:397 en/git-rebase.txt:406 en/git-revert.txt:99
#, priority:280
msgid "GPG-sign commits. The `keyid` argument is optional and defaults to the committer identity; if specified, it must be stuck to the option without a space. `--no-gpg-sign` is useful to countermand both `commit.gpgSign` configuration variable, and earlier `--gpg-sign`."
msgstr "GPG 签名提交。`keyid` 参数是可选的，默认为提交者身份；如果指定了，则必须与选项相连，不加空格。`--no-gpg-sign` 用于还原 `commit.gpgSign` 配置变量和先前的 `--gpg-sign`。"

#. type: Labeled list
#: en/git-am.txt:176 en/git-merge.txt:122 en/git-rebase.txt:217 en/sequencer.txt:1
#, ignore-same, no-wrap, priority:240
msgid "--continue"
msgstr "--continue"

#. type: Labeled list
#: en/git-am.txt:177 en/git-branch.txt:171 en/git-cherry-pick.txt:79 en/git-diff-tree.txt:36 en/git-grep.txt:97 en/git-ls-tree.txt:44 en/git-pull.txt:107 en/git-rebase.txt:530 en/git-rm.txt:58 en/git-show-branch.txt:43 en/git-unpack-objects.txt:38
#, ignore-same, no-wrap, priority:280
msgid "-r"
msgstr "-r"

#. type: Labeled list
#: en/git-am.txt:178
#, ignore-same, no-wrap, priority:100
msgid "--resolved"
msgstr "--resolved"

#. type: Plain text
#: en/git-am.txt:185
#, priority:100
msgid "After a patch failure (e.g. attempting to apply conflicting patch), the user has applied it by hand and the index file stores the result of the application.  Make a commit using the authorship and commit log extracted from the e-mail message and the current index file, and continue."
msgstr "补丁失败后（如试图应用冲突的补丁），用户已经手工应用，索引文件存储了应用的结果。 使用从电子邮件中提取的作者和提交日志以及当前的索引文件进行提交，然后继续运行。"

#. type: Labeled list
#: en/git-am.txt:186
#, fuzzy, no-wrap, priority:100
msgid "--resolvemsg=<msg>"
msgstr "--resolvemsg=<msg>"

#. type: Plain text
#: en/git-am.txt:192
#, priority:100
msgid "When a patch failure occurs, <msg> will be printed to the screen before exiting.  This overrides the standard message informing you to use `--continue` or `--skip` to handle the failure.  This is solely for internal use between 'git rebase' and 'git am'."
msgstr "当发生补丁失败时，<信息> 将在退出前被打印到屏幕上。 这将覆盖标准信息，通知你使用 `--continue` 或 `--skip` 来处理失败。 这只是为了在 'git rebase' 和 'git am' 之间的内部使用。"

#. type: Labeled list
#: en/git-am.txt:193 en/git-merge.txt:101 en/git-notes.txt:226 en/git-rebase.txt:223 en/sequencer.txt:15
#, ignore-same, no-wrap, priority:280
msgid "--abort"
msgstr "--abort"

#. type: Plain text
#: en/git-am.txt:197
#, priority:100
msgid "Restore the original branch and abort the patching operation.  Revert contents of files involved in the am operation to their pre-am state."
msgstr "恢复原来的分支，放弃打补丁的操作。 将 am 操作中涉及的文件内容恢复到 am 前的状态。"

#. type: Labeled list
#: en/git-am.txt:198 en/git-merge.txt:117 en/git-rebase.txt:230 en/sequencer.txt:10
#, ignore-same, no-wrap, priority:240
msgid "--quit"
msgstr "--quit"

#. type: Plain text
#: en/git-am.txt:201
#, priority:100
msgid "Abort the patching operation but keep HEAD and the index untouched."
msgstr "中止打补丁的操作，但保留 HEAD 和索引不被接触。"

#. type: Labeled list
#: en/git-am.txt:202
#, fuzzy, no-wrap, priority:100
#| msgid "--show-current-patch"
msgid "--show-current-patch[=(diff|raw)]"
msgstr "--show-current-patch[=(diff|raw)]"

#. type: Plain text
#: en/git-am.txt:207
#, priority:100
msgid "Show the message at which `git am` has stopped due to conflicts.  If `raw` is specified, show the raw contents of the e-mail message; if `diff`, show the diff portion only.  Defaults to `raw`."
msgstr "显示`git am` 因冲突而停止的消息。 如果指定了 `raw`，显示电子邮件的原始内容；如果是 `diff`，只显示差异部分。 默认为 `raw`。"

#. type: Labeled list
#: en/git-am.txt:208 en/git-apply.txt:259 en/git-cherry-pick.txt:124 en/git-commit.txt:220 en/git-notes.txt:170
#, ignore-same, no-wrap, priority:280
msgid "--allow-empty"
msgstr "--allow-empty"

#. type: Plain text
#: en/git-am.txt:212
#, priority:100
msgid "After a patch failure on an input e-mail message lacking a patch, create an empty commit with the contents of the e-mail message as its log message."
msgstr "在对缺乏补丁的输入邮件信息进行补丁失败后，创建一个空的提交，将邮件信息的内容作为其日志信息。"

#. type: Title -
#: en/git-am.txt:214 en/git-commit.txt:541 en/git-format-patch.txt:430 en/git-fsck.txt:115 en/git-log.txt:193 en/git-merge-base.txt:76 en/git-notes.txt:243 en/git-remote.txt:202 en/git-rerere.txt:77 en/git-reset.txt:381 en/git-show.txt:84 en/git-stash.txt:268 en/git-tag.txt:235
#, no-wrap, priority:280
msgid "DISCUSSION"
msgstr "讨论"

#. type: Plain text
#: en/git-am.txt:222
#, priority:100
msgid "The commit author name is taken from the \"From: \" line of the message, and commit author date is taken from the \"Date: \" line of the message.  The \"Subject: \" line is used as the title of the commit, after stripping common prefix \"[PATCH <anything>]\".  The \"Subject: \" line is supposed to concisely describe what the commit is about in one line of text."
msgstr "提交者的名字取自信息的 \"From:\" 行，而提交者的日期则取自信息的 \"Date:\" 行。 \"Subject:\" 行是提交的标题，在去掉普通前缀 \"[PATCH <任何东西>]\" 之后。 \"Sbuject: \" 是为了用一行文字简洁地描述提交的内容。"

#. type: Plain text
#: en/git-am.txt:225
#, priority:100
msgid "\"From: \", \"Date: \", and \"Subject: \" lines starting the body override the respective commit author name and title values taken from the headers."
msgstr "\"From: \"、\"Date: \" 和 \"Subject: \" 行开始的正文覆盖了从标题中获取的各自的提交者名称和标题值。"

#. type: Plain text
#: en/git-am.txt:230
#, priority:100
msgid "The commit message is formed by the title taken from the \"Subject: \", a blank line and the body of the message up to where the patch begins.  Excess whitespace at the end of each line is automatically stripped."
msgstr "提交信息由 \"Subject: \" 中的标题、一个空行和直到补丁开始的信息正文组成。  每行末尾多余的空格会被自动删除。"

#. type: Plain text
#: en/git-am.txt:233
#, priority:100
msgid "The patch is expected to be inline, directly following the message.  Any line that is of the form:"
msgstr "补丁应该是内联的，直接跟在信息后面。 任何形式的行："

#. type: Plain text
#: en/git-am.txt:235
#, priority:100
msgid "three-dashes and end-of-line, or"
msgstr "三个破折号和行末，或"

#. type: Plain text
#: en/git-am.txt:236
#, priority:100
msgid "a line that begins with \"diff -\", or"
msgstr "以 \"diff - \" 开头的一行，或"

#. type: Plain text
#: en/git-am.txt:237
#, priority:100
msgid "a line that begins with \"Index: \""
msgstr "以 \"index: \" 开头的一行"

#. type: Plain text
#: en/git-am.txt:240
#, priority:100
msgid "is taken as the beginning of a patch, and the commit log message is terminated before the first occurrence of such a line."
msgstr "被认为是一个补丁的开始，提交日志信息在第一次出现这样的行之前就结束了。"

#. type: Plain text
#: en/git-am.txt:244
#, priority:100
msgid "When initially invoking `git am`, you give it the names of the mailboxes to process.  Upon seeing the first patch that does not apply, it aborts in the middle.  You can recover from this in one of two ways:"
msgstr "当最初调用 `git am` 时，你给了它要处理的邮箱的名字。 当看到第一个不适用的补丁时，它就会在中间中止。 你可以通过以下两种方式之一恢复："

#. type: Plain text
#: en/git-am.txt:247
#, priority:100
msgid "skip the current patch by re-running the command with the `--skip` option."
msgstr "通过重新运行带有 `--skip` 选项的命令，跳过当前补丁。"

#. type: Plain text
#: en/git-am.txt:251
#, priority:100
msgid "hand resolve the conflict in the working directory, and update the index file to bring it into a state that the patch should have produced.  Then run the command with the `--continue` option."
msgstr "手解决工作目录中的冲突，并更新索引文件，使其进入补丁应该产生的状态。 然后用 `--continue` 选项运行该命令。"

#. type: Plain text
#: en/git-am.txt:256
#, priority:100
msgid "The command refuses to process new mailboxes until the current operation is finished, so if you decide to start over from scratch, run `git am --abort` before running the command with mailbox names."
msgstr "在当前操作完成之前，该命令拒绝处理新的邮箱，所以如果你决定从头开始，在运行带有邮箱名称的命令之前，运行 `git am --abort`。"

#. type: Plain text
#: en/git-am.txt:262
#, priority:100
msgid "Before any patches are applied, ORIG_HEAD is set to the tip of the current branch.  This is useful if you have problems with multiple commits, like running 'git am' on the wrong branch or an error in the commits that is more easily fixed by changing the mailbox (e.g.  errors in the \"From:\" lines)."
msgstr "在应用任何补丁之前，ORIG_HEAD 被设置为当前分支的顶端。 如果你在多个提交中遇到问题，比如在错误的分支上运行 'git am'，或者提交中的错误更容易通过改变邮箱来解决（比如 \"From: \" 行中的错误），这就很有用了。"

#. type: Title -
#: en/git-am.txt:264 en/git-commit.txt:565 en/git-gc.txt:153
#, fuzzy, no-wrap, priority:280
msgid "HOOKS"
msgstr "钩子"

#. type: Plain text
#: en/git-am.txt:268
#, priority:100
msgid "This command can run `applypatch-msg`, `pre-applypatch`, and `post-applypatch` hooks.  See linkgit:githooks[5] for more information."
msgstr "这个命令可以运行 `applypatch-msg`, `pre-applypatch`, 和 `post-applypatch` 钩子。 更多信息见 linkgit:githooks[5]。"

#. type: Plain text
#: en/git-am.txt:280
#, ignore-same, priority:100
msgid "linkgit:git-apply[1], linkgit:git-format-patch[1]."
msgstr "linkgit:git-apply[1], linkgit:git-format-patch[1]."

#. type: Title =
#: en/git-annotate.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-annotate(1)"
msgstr "git-annotate(1)"

#. type: Plain text
#: en/git-annotate.txt:7
#, fuzzy, priority:100
msgid "git-annotate - Annotate file lines with commit information"
msgstr "git-annotate - Annotate file lines with commit information"

#. type: Plain text
#: en/git-annotate.txt:12
#, fuzzy, no-wrap, priority:100
msgid "'git annotate' [<options>] [<rev-opts>] [<rev>] [--] <file>\n"
msgstr "'git annotate' [<options>] <file> [<revision>]\n"

#. type: Plain text
#: en/git-annotate.txt:17
#, priority:100
msgid "Annotates each line in the given file with information from the commit which introduced the line. Optionally annotates from a given revision."
msgstr "用引入该行的提交信息来注释给定文件中的每一行。也可以选择从给定的修订版中进行注释。"

#. type: Plain text
#: en/git-annotate.txt:22
#, priority:100
msgid "The only difference between this command and linkgit:git-blame[1] is that they use slightly different output formats, and this command exists only for backward compatibility to support existing scripts, and provide a more familiar command name for people coming from other SCM systems."
msgstr "这个命令和 linkgit:git-blame[1] 的唯一区别是，它们使用的输出格式略有不同，这个命令的存在只是为了向后兼容，以支持现有的脚本，并为来自其他 SCM 系统的人提供一个更熟悉的命令名称。"

#. type: Title =
#: en/git-apply.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-apply(1)"
msgstr "git-apply(1)"

#. type: Plain text
#: en/git-apply.txt:7
#, fuzzy, priority:100
msgid "git-apply - Apply a patch to files and/or to the index"
msgstr "/"

#. type: Plain text
#: en/git-apply.txt:20
#, fuzzy, ignore-ellipsis, no-wrap, priority:100
msgid ""
"'git apply' [--stat] [--numstat] [--summary] [--check] [--index | --intent-to-add] [--3way]\n"
"\t  [--apply] [--no-add] [--build-fake-ancestor=<file>] [-R | --reverse]\n"
"\t  [--allow-binary-replacement | --binary] [--reject] [-z]\n"
"\t  [-p<n>] [-C<n>] [--inaccurate-eof] [--recount] [--cached]\n"
"\t  [--ignore-space-change | --ignore-whitespace]\n"
"\t  [--whitespace=(nowarn|warn|fix|error|error-all)]\n"
"\t  [--exclude=<path>] [--include=<path>] [--directory=<root>]\n"
"\t  [--verbose | --quiet] [--unsafe-paths] [--allow-empty] [<patch>...]\n"
msgstr ""
"'git apply' [--stat] [--numstat] [--summary] [--check] [--index | --intent-to-add] [--3way]\n"
"\t  [--apply] [--no-add] [--build-fake-ancestor=<file>] [-R | --reverse]\n"
"\t  [--allow-binary-replacement | --binary] [--reject] [-z]\n"
"\t  [-p<n>] [-C<n>] [--inaccurate-eof] [--recount] [--cached]\n"
"\t  [--ignore-space-change | --ignore-whitespace]\n"
"\t  [--whitespace=(nowarn|warn|fix|error|error-all)]\n"
"\t  [--exclude=<路径>] [--include=<路径>] [--directory=<根目录>]\n"
"\t  [--verbose | --quiet] [--unsafe-paths] [--allow-empty] [<patch>...]\n"

#. type: Plain text
#: en/git-apply.txt:30
#, priority:100
msgid "Reads the supplied diff output (i.e. \"a patch\") and applies it to files.  When running from a subdirectory in a repository, patched paths outside the directory are ignored.  With the `--index` option the patch is also applied to the index, and with the `--cached` option the patch is only applied to the index.  Without these options, the command applies the patch only to files, and does not require them to be in a Git repository."
msgstr "读取提供的差异输出（即 \"一个补丁\" ）并将其应用于文件。 当从版本库中的子目录运行时，目录外的补丁路径会被忽略。 使用 `--index `选项，补丁也会应用到索引中，使用 `--cached` 选项，补丁只应用到索引中。 如果没有这些选项，该命令只对文件打补丁，而不要求它们在 Git 仓库中。"

#. type: Plain text
#: en/git-apply.txt:34
#, priority:100
msgid "This command applies the patch but does not create a commit.  Use linkgit:git-am[1] to create commits from patches generated by linkgit:git-format-patch[1] and/or received by email."
msgstr "该命令会应用补丁，但不会创建提交。 使用 linkgit:git-am[1] 从 linkgit:git-format-patch[1] 生成的和/或通过电子邮件收到的补丁创建提交。"

#. type: Labeled list
#: en/git-apply.txt:37
#, fuzzy, ignore-ellipsis, no-wrap, priority:100
msgid "<patch>..."
msgstr "<patch>..."

#. type: Plain text
#: en/git-apply.txt:40
#, priority:100
msgid "The files to read the patch from.  '-' can be used to read from the standard input."
msgstr "要读取补丁的文件。 '-' 可以用来从标准输入中读取。"

#. type: Labeled list
#: en/git-apply.txt:41 en/git-rebase.txt:415 en/merge-options.txt:107
#, ignore-same, no-wrap, priority:240
msgid "--stat"
msgstr "--stat"

#. type: Plain text
#: en/git-apply.txt:44
#, priority:100
msgid "Instead of applying the patch, output diffstat for the input.  Turns off \"apply\"."
msgstr "不应用补丁，而是输出输入的差异状态。 关掉 \"apply\"。"

#. type: Plain text
#: en/git-apply.txt:51
#, priority:100
msgid "Similar to `--stat`, but shows the number of added and deleted lines in decimal notation and the pathname without abbreviation, to make it more machine friendly.  For binary files, outputs two `-` instead of saying `0 0`.  Turns off \"apply\"."
msgstr "类似于 `--stat`，但是用十进制符号显示增加和删除的行数，路径名不加缩写，使其对机器更友好。 对于二进制文件，输出两个`-` 而不是 `0 0`。 关闭 \"apply\"。"

#. type: Plain text
#: en/git-apply.txt:57
#, priority:100
msgid "Instead of applying the patch, output a condensed summary of information obtained from git diff extended headers, such as creations, renames and mode changes.  Turns off \"apply\"."
msgstr "不应用补丁，而是输出从 git dif f扩展头文件中获得的信息的浓缩摘要，如创建、重命名和模式变化。 关闭 \"apply\"。"

#. type: Plain text
#: en/git-apply.txt:62
#, priority:100
msgid "Instead of applying the patch, see if the patch is applicable to the current working tree and/or the index file and detects errors.  Turns off \"apply\"."
msgstr "看看该补丁是否适用于当前工作树和/或索引文件，并检测到错误，而不是应用该补丁。 关闭 \"apply\"。"

#. type: Labeled list
#: en/git-apply.txt:63 en/git-checkout-index.txt:27 en/git-stash.txt:181
#, ignore-same, no-wrap, priority:240
msgid "--index"
msgstr "--index"

#. type: Plain text
#: en/git-apply.txt:71
#, priority:100
msgid "Apply the patch to both the index and the working tree (or merely check that it would apply cleanly to both if `--check` is in effect). Note that `--index` expects index entries and working tree copies for relevant paths to be identical (their contents and metadata such as file mode must match), and will raise an error if they are not, even if the patch would apply cleanly to both the index and the working tree in isolation."
msgstr "在索引和工作目录上都打上补丁（如果 `--check`生 效，则只需检查它是否能干净地应用于两者）。注意，`--index` 希望相关路径的索引条目和工作区副本是相同的（它们的内容和元数据，如文件模式必须匹配），如果它们不相同，将引发一个错误，即使该补丁可以干净地应用于索引和工作区。"

#. type: Labeled list
#: en/git-apply.txt:72 en/git-check-attr.txt:27 en/git-diff-index.txt:29 en/git-grep.txt:44 en/git-ls-files.txt:39 en/git-rm.txt:67 en/git-submodule.txt:313
#, ignore-same, no-wrap, priority:280
msgid "--cached"
msgstr "--cached"

#. type: Plain text
#: en/git-apply.txt:76
#, priority:100
msgid "Apply the patch to just the index, without touching the working tree. If `--check` is in effect, merely check that it would apply cleanly to the index entry."
msgstr "将补丁只应用于索引，而不触及工作目录。如果 `--check` 是有效的，只需检查它是否能干净地应用于索引条目。"

#. type: Plain text
#: en/git-apply.txt:84
#, priority:100
msgid "When applying the patch only to the working tree, mark new files to be added to the index later (see `--intent-to-add` option in linkgit:git-add[1]). This option is ignored unless running in a Git repository and `--index` is not specified.  Note that `--index` could be implied by other options such as `--cached` or `--3way`."
msgstr "当只在工作树上应用补丁时，标记新的文件，以便以后添加到索引中（见 linkgit:git-add[1] 中的 `--intent-to-add` 选项）。除非在 Git 仓库中运行且没有指定 `--index`，否则该选项将被忽略。 请注意，`--index` 可能是由其他选项暗示的，如 `--cached` 或 `--3way`。"

#. type: Plain text
#: en/git-apply.txt:94
#, priority:100
msgid "Attempt 3-way merge if the patch records the identity of blobs it is supposed to apply to and we have those blobs available locally, possibly leaving the conflict markers in the files in the working tree for the user to resolve.  This option implies the `--index` option unless the `--cached` option is used, and is incompatible with the `--reject` option.  When used with the `--cached` option, any conflicts are left at higher stages in the cache."
msgstr "如果补丁记录了它应该应用到的二进制文件的身份，并且我们有这些二进制文件在本地可用，则尝试三方合并，可能会在工作树中的文件中留下冲突标记，由用户解决。  这个选项意味着 `--index` 选项，除非使用 `--cached` 选项，并且与 `--reject` 选项不兼容。  当与 `--cached` 选项一起使用时，任何冲突都被留在缓存的较高阶段。"

#. type: Labeled list
#: en/git-apply.txt:95
#, fuzzy, no-wrap, priority:100
msgid "--build-fake-ancestor=<file>"
msgstr "--build-fake-ancestor=<file>"

#. type: Plain text
#: en/git-apply.txt:101
#, priority:100
msgid "Newer 'git diff' output has embedded 'index information' for each blob to help identify the original version that the patch applies to.  When this flag is given, and if the original versions of the blobs are available locally, builds a temporary index containing those blobs."
msgstr "较新的 \"git diff\" 输出为每个 blob 嵌入了 \"索引信息\"，以帮助识别补丁所适用的原始版本。 当给出这个标志时，如果 blob 的原始版本在本地可用，则建立一个包含这些 blob 的临时索引。"

#. type: Plain text
#: en/git-apply.txt:104
#, priority:100
msgid "When a pure mode change is encountered (which has no index information), the information is read from the current index instead."
msgstr "当遇到一个纯粹的模式变化（没有索引信息）时，将从当前索引中读取信息。"

#. type: Labeled list
#: en/git-apply.txt:106 en/rev-list-options.txt:877
#, ignore-same, no-wrap, priority:260
msgid "--reverse"
msgstr "--reverse"

#. type: Plain text
#: en/git-apply.txt:108
#, priority:100
msgid "Apply the patch in reverse."
msgstr "反过来应用补丁。"

#. type: Plain text
#: en/git-apply.txt:115
#, priority:100
msgid "For atomicity, 'git apply' by default fails the whole patch and does not touch the working tree when some of the hunks do not apply.  This option makes it apply the parts of the patch that are applicable, and leave the rejected hunks in corresponding *.rej files."
msgstr "为了保证原子性，'git apply' 默认情况下会使整个补丁失效，并且在某些目标不适用的情况下不会接触工作区。 这个选项让它应用补丁中适用的部分，并将被拒绝的目标留在相应的 *.rej 文件中。"

#. type: Plain text
#: en/git-apply.txt:119
#, priority:100
msgid "When `--numstat` has been given, do not munge pathnames, but use a NUL-terminated machine-readable format."
msgstr "当 `--numstat` 被给出时，不对路径名进行编码，而是使用以 NUL 结尾的机器可读格式。"

#. type: Plain text
#: en/git-apply.txt:129
#, fuzzy, priority:100
msgid "Remove <n> leading path components (separated by slashes) from traditional diff paths. E.g., with `-p2`, a patch against `a/dir/file` will be applied directly to `file`. The default is 1."
msgstr "移除传统 diff 路径中的 <n> 前导路径成分（用斜线分隔）。例如，使用 `-p2`，针对 `a/dir/file` 的补丁将直接应用于 `file`。默认为 1。"

#. type: Plain text
#: en/git-apply.txt:135
#, priority:100
msgid "Ensure at least <n> lines of surrounding context match before and after each change.  When fewer lines of surrounding context exist they all must match.  By default no context is ever ignored."
msgstr "确保每次更改前后至少有 <n> 行的周围环境相匹配。 当周围环境的行数较少时，它们必须全部匹配。 在默认情况下，没有任何上下文被忽略。"

#. type: Labeled list
#: en/git-apply.txt:136
#, ignore-same, no-wrap, priority:100
msgid "--unidiff-zero"
msgstr "--unidiff-zero"

#. type: Plain text
#: en/git-apply.txt:142
#, priority:100
msgid "By default, 'git apply' expects that the patch being applied is a unified diff with at least one line of context.  This provides good safety measures, but breaks down when applying a diff generated with `--unified=0`. To bypass these checks use `--unidiff-zero`."
msgstr "默认情况下，'git apply' 希望被应用的补丁是一个至少有一行上下文的统一差异。 这提供了很好的安全措施，但在应用以 `--unified=0` 生成的差异时，会出现问题。要绕过这些检查，请使用 `--unidiff-zero`。"

#. type: Plain text
#: en/git-apply.txt:145
#, priority:100
msgid "Note, for the reasons stated above usage of context-free patches is discouraged."
msgstr "注意，由于上述原因，不鼓励使用无语境补丁。"

#. type: Plain text
#: en/git-apply.txt:146 en/git-rebase.txt:285 en/git-rebase.txt:648
#, ignore-same, no-wrap, priority:100
msgid "--apply"
msgstr "--apply"

#. type: Plain text
#: en/git-apply.txt:152
#, priority:100
msgid "If you use any of the options marked \"Turns off 'apply'\" above, 'git apply' reads and outputs the requested information without actually applying the patch.  Give this flag after those flags to also apply the patch."
msgstr "如果您使用了上面标有 \"关闭 'apply' \" 的任何选项，'git apply' 会读取并输出所需的信息，而不会实际应用补丁。 在这些标志之后给出这个标志，也可以应用该补丁。"

#. type: Labeled list
#: en/git-apply.txt:153
#, ignore-same, no-wrap, priority:100
msgid "--no-add"
msgstr "--no-add"

#. type: Plain text
#: en/git-apply.txt:159
#, priority:100
msgid "When applying a patch, ignore additions made by the patch.  This can be used to extract the common part between two files by first running 'diff' on them and applying the result with this option, which would apply the deletion part but not the addition part."
msgstr "当应用一个补丁时，忽略该补丁所做的添加内容。 这可以用来提取两个文件之间的共同部分，首先对它们运行 'diff'，然后用这个选项应用结果，这将应用删除的部分，但不应用增加的部分。"

#. type: Labeled list
#: en/git-apply.txt:160
#, ignore-same, no-wrap, priority:100
msgid "--allow-binary-replacement"
msgstr "--allow-binary-replacement"

#. type: Plain text
#: en/git-apply.txt:166
#, priority:100
msgid "Historically we did not allow binary patch applied without an explicit permission from the user, and this flag was the way to do so.  Currently we always allow binary patch application, so this is a no-op."
msgstr "历史上，我们不允许在没有用户明确许可的情况下应用二进制补丁，而这个标志是这样做的。 目前，我们总是允许应用二进制补丁，所以这是一个无用功。"

#. type: Labeled list
#: en/git-apply.txt:167
#, fuzzy, no-wrap, priority:100
msgid "--exclude=<path-pattern>"
msgstr "--exclude=<path-pattern>"

#. type: Plain text
#: en/git-apply.txt:171
#, priority:100
msgid "Don't apply changes to files matching the given path pattern. This can be useful when importing patchsets, where you want to exclude certain files or directories."
msgstr "不要对符合给定路径模式的文件进行修改。这在导入补丁集时，你想把某些文件或目录排除在外的情况下很有用。"

#. type: Labeled list
#: en/git-apply.txt:172
#, fuzzy, no-wrap, priority:100
msgid "--include=<path-pattern>"
msgstr "--include=<path-pattern>"

#. type: Plain text
#: en/git-apply.txt:176
#, priority:100
msgid "Apply changes to files matching the given path pattern. This can be useful when importing patchsets, where you want to include certain files or directories."
msgstr "将修改应用于与给定路径模式相匹配的文件。这在导入补丁集时，你想包括某些文件或目录的情况下很有用。"

#. type: Plain text
#: en/git-apply.txt:182
#, priority:100
msgid "When `--exclude` and `--include` patterns are used, they are examined in the order they appear on the command line, and the first match determines if a patch to each path is used.  A patch to a path that does not match any include/exclude pattern is used by default if there is no include pattern on the command line, and ignored if there is any include pattern."
msgstr "当使用 `--exclude` 和 `-include` 模式时，会按照它们在命令行中出现的顺序进行检查，第一个匹配项决定是否使用每个路径的补丁。 如果命令行上没有include模式，则默认使用不匹配任何 include/exclude 模式的路径的补丁，如果有任何 include 模式，则忽略。"

#. type: Plain text
#: en/git-apply.txt:190
#, priority:100
msgid "When applying a patch, ignore changes in whitespace in context lines if necessary.  Context lines will preserve their whitespace, and they will not undergo whitespace fixing regardless of the value of the `--whitespace` option. New lines will still be fixed, though."
msgstr "当应用一个补丁时，如果有必要，请忽略上下文行中的空白变化。 上下文行将保留其空白，无论 `--whitespace` 选项的值是多少，它们都不会进行空白修正。不过，新的行仍然会被修复。"

#. type: Labeled list
#: en/git-apply.txt:191
#, fuzzy, no-wrap, priority:100
msgid "--whitespace=<action>"
msgstr "--whitespace=<action>"

#. type: Plain text
#: en/git-apply.txt:199
#, priority:100
msgid "When applying a patch, detect a new or modified line that has whitespace errors.  What are considered whitespace errors is controlled by `core.whitespace` configuration.  By default, trailing whitespaces (including lines that solely consist of whitespaces) and a space character that is immediately followed by a tab character inside the initial indent of the line are considered whitespace errors."
msgstr "当应用一个补丁时，检测一个新的或修改过的行有空格错误。 什么是空格错误是由 `core.whitespace` 配置控制的。 默认情况下，尾部的空白（包括仅由空白组成的行）和紧跟在行的初始缩进内的 Tab 字符的空白字符被认为是空白错误。"

#. type: Plain text
#: en/git-apply.txt:203
#, priority:100
msgid "By default, the command outputs warning messages but applies the patch.  When `git-apply` is used for statistics and not applying a patch, it defaults to `nowarn`."
msgstr "默认情况下，该命令输出警告信息，但会应用补丁。 当 `git-apply` 被用于统计而不应用补丁时，它默认为 `nowarn`。"

#. type: Plain text
#: en/git-apply.txt:206
#, fuzzy, priority:100
msgid "You can use different `<action>` values to control this behavior:"
msgstr "你可以使用不同的 `<action>` 值来控制这种行为："

#. type: Plain text
#: en/git-apply.txt:208
#, priority:100
msgid "`nowarn` turns off the trailing whitespace warning."
msgstr "`nowarn` 关闭尾部空白警告。"

#. type: Plain text
#: en/git-apply.txt:210
#, priority:100
msgid "`warn` outputs warnings for a few such errors, but applies the patch as-is (default)."
msgstr "`warn` 对少数此类错误输出警告，但按原样应用补丁（默认）。"

#. type: Plain text
#: en/git-apply.txt:214
#, priority:100
msgid "`fix` outputs warnings for a few such errors, and applies the patch after fixing them (`strip` is a synonym -- the tool used to consider only trailing whitespace characters as errors, and the fix involved 'stripping' them, but modern Gits do more)."
msgstr "`fix` 对一些这样的错误输出警告，并在修复后应用补丁（`strip` 是一个同义词--该工具过去只考虑尾部空白字符的错误，修复涉及 'stripping' 等，但现代 Gits 做得更多）。"

#. type: Plain text
#: en/git-apply.txt:216
#, priority:100
msgid "`error` outputs warnings for a few such errors, and refuses to apply the patch."
msgstr "`error` 对几个这样的错误输出警告，并拒绝应用补丁。"

#. type: Plain text
#: en/git-apply.txt:217
#, priority:100
msgid "`error-all` is similar to `error` but shows all errors."
msgstr "`error-all` 与 `error` 类似，但显示所有错误。"

#. type: Labeled list
#: en/git-apply.txt:218
#, ignore-same, no-wrap, priority:100
msgid "--inaccurate-eof"
msgstr "--inaccurate-eof"

#. type: Plain text
#: en/git-apply.txt:224
#, priority:100
msgid "Under certain circumstances, some versions of 'diff' do not correctly detect a missing new-line at the end of the file. As a result, patches created by such 'diff' programs do not record incomplete lines correctly. This option adds support for applying such patches by working around this bug."
msgstr "在某些情况下，某些版本的 'diff ' 不能正确检测到文件末尾缺少的换行。因此，由这类 'diff' 程序创建的补丁不能正确记录不完整的行。这个选项通过解决这个错误来增加对应用这种补丁的支持。"

#. type: Plain text
#: en/git-apply.txt:230
#, priority:100
msgid "Report progress to stderr. By default, only a message about the current patch being applied will be printed. This option will cause additional information to be reported."
msgstr "向标准错误流报告进度。默认情况下，只有关于当前正在应用的补丁的信息会被打印出来。这个选项将导致报告额外的信息。"

#. type: Plain text
#: en/git-apply.txt:235
#, priority:100
msgid "Suppress stderr output. Messages about patch status and progress will not be printed."
msgstr "抑制标准错误流输出。关于补丁状态和进度的信息将不被打印。"

#. type: Labeled list
#: en/git-apply.txt:236
#, ignore-same, no-wrap, priority:100
msgid "--recount"
msgstr "--recount"

#. type: Plain text
#: en/git-apply.txt:240
#, priority:100
msgid "Do not trust the line counts in the hunk headers, but infer them by inspecting the patch (e.g. after editing the patch without adjusting the hunk headers appropriately)."
msgstr "不信任组头中的行数，而是通过检查补丁来推断（例如，在编辑补丁后没有适当调整组头）。"

#. type: Labeled list
#: en/git-apply.txt:241
#, fuzzy, no-wrap, priority:100
msgid "--directory=<root>"
msgstr "--directory=<root>"

#. type: Plain text
#: en/git-apply.txt:244
#, priority:100
msgid "Prepend <root> to all filenames.  If a \"-p\" argument was also passed, it is applied before prepending the new root."
msgstr "将 <根目录> 预置到所有文件名中。 如果还传递了 \"-p \" 参数，则在预置新根目录之前应用。"

#. type: Plain text
#: en/git-apply.txt:248
#, priority:100
msgid "For example, a patch that talks about updating `a/git-gui.sh` to `b/git-gui.sh` can be applied to the file in the working tree `modules/git-gui/git-gui.sh` by running `git apply --directory=modules/git-gui`."
msgstr "例如，一个关于将 `a/git-gui.sh` 更新为 `b/git-gui.sh` 的补丁可以通过运行 `git apply --directory=modules/git-gui` 来应用于工作区 `modules/git-gui/git-gui.sh` 中的文件。"

#. type: Labeled list
#: en/git-apply.txt:249
#, ignore-same, no-wrap, priority:100
msgid "--unsafe-paths"
msgstr "--unsafe-paths"

#. type: Plain text
#: en/git-apply.txt:254
#, priority:100
msgid "By default, a patch that affects outside the working area (either a Git controlled working tree, or the current working directory when \"git apply\" is used as a replacement of GNU patch) is rejected as a mistake (or a mischief)."
msgstr "默认情况下，影响到工作区域之外（无论是 Git 控制的工作区，还是用 \"git apply\" 替代 GNU patch 时的当前工作目录）的补丁会被当作错误（或恶作剧）而拒绝。"

#. type: Plain text
#: en/git-apply.txt:258
#, priority:100
msgid "When `git apply` is used as a \"better GNU patch\", the user can pass the `--unsafe-paths` option to override this safety check.  This option has no effect when `--index` or `--cached` is in use."
msgstr "当 `git apply` 被用作 \"更好的 GNU 补丁\" 时，用户可以通过 `--unsafe-paths` 选项来覆盖这个安全检查。 当使用 `--index` 或 `--cached` 时，该选项没有作用。"

#. type: Plain text
#: en/git-apply.txt:262
#, priority:100
msgid "Don't return error for patches containing no diff. This includes empty patches and patches with commit text only."
msgstr "对于不包含差异的补丁，不返回错误。这包括空补丁和只有提交文本的补丁。"

#. type: Title -
#: en/git-apply.txt:271 en/git-mv.txt:48 en/git-rm.txt:153
#, no-wrap, priority:280
msgid "SUBMODULES"
msgstr "子模块"

#. type: Plain text
#: en/git-apply.txt:274
#, priority:100
msgid "If the patch contains any changes to submodules then 'git apply' treats these changes as follows."
msgstr "如果该补丁包含对子模块的任何修改，那么 'git apply' 会对这些修改进行如下处理。"

#. type: Plain text
#: en/git-apply.txt:280
#, priority:100
msgid "If `--index` is specified (explicitly or implicitly), then the submodule commits must match the index exactly for the patch to apply.  If any of the submodules are checked-out, then these check-outs are completely ignored, i.e., they are not required to be up to date or clean and they are not updated."
msgstr "如果 `--index` 被指定（显式或隐式），那么子模块的提交必须与索引完全匹配，补丁才能应用。 如果任何一个子模块被检出，那么这些检出的模块将被完全忽略，也就是说，它们不需要是最新的或干净的，它们也不会被更新。"

#. type: Plain text
#: en/git-apply.txt:284
#, priority:100
msgid "If `--index` is not specified, then the submodule commits in the patch are ignored and only the absence or presence of the corresponding subdirectory is checked and (if possible) updated."
msgstr "如果没有指定 `--index`，那么补丁中的子模块提交将被忽略，只检查相应的子目录是否存在，并（如果可能）更新。"

#. type: Plain text
#: en/git-apply.txt:288
#, ignore-same, priority:100
msgid "linkgit:git-am[1]."
msgstr "linkgit:git-am[1]."

#. type: Title =
#: en/git-archimport.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-archimport(1)"
msgstr "git-archimport(1)"

#. type: Plain text
#: en/git-archimport.txt:7
#, priority:100
msgid "git-archimport - Import a GNU Arch repository into Git"
msgstr "git-archimport - 将 GNU Arch 仓库导入 Git 中"

#. type: Plain text
#: en/git-archimport.txt:14
#, ignore-ellipsis, no-wrap, priority:100
msgid ""
"'git archimport' [-h] [-v] [-o] [-a] [-f] [-T] [-D <depth>] [-t <tempdir>]\n"
"\t       <archive>/<branch>[:<git-branch>]...\n"
msgstr ""
"'git archimport' [-h] [-v] [-o] [-a] [-f] [-T] [-D <深度>] [-t <缓存目录>]\n"
"\t       <归档>/<分支>[:<git 分支>]...\n"

#. type: Plain text
#: en/git-archimport.txt:23
#, priority:100
msgid "Imports a project from one or more GNU Arch repositories.  It will follow branches and repositories within the namespaces defined by the <archive>/<branch> parameters supplied. If it cannot find the remote branch a merge comes from it will just import it as a regular commit. If it can find it, it will mark it as a merge whenever possible (see discussion below)."
msgstr "从一个或多个 GNU Arch 仓库导入一个项目。 它将在所提供的 <归档>/<分支> 参数所定义的命名空间内跟踪分支和仓库。如果它找不到合并后的远程分支，就会把它作为一个普通的提交导入。如果它能找到它，它会尽可能地将其标记为合并（见下面的讨论）。"

#. type: Plain text
#: en/git-archimport.txt:27
#, priority:100
msgid "The script expects you to provide the key roots where it can start the import from an 'initial import' or 'tag' type of Arch commit. It will follow and import new branches within the provided roots."
msgstr "该脚本希望你提供关键的根目录，它可以从 'initial' 或 'tag' 类型的 Arch 提交开始导入。它将跟踪并导入所提供的根目录下的新分支。"

#. type: Plain text
#: en/git-archimport.txt:32
#, priority:100
msgid "It expects to be dealing with one project only. If it sees branches that have different roots, it will refuse to run. In that case, edit your <archive>/<branch> parameters to define clearly the scope of the import."
msgstr "它希望只处理一个项目。如果它看到有不同根目录的分支，它将拒绝运行。在这种情况下，编辑你的 <归档>/<分支> 参数，以明确定义导入的范围。"

#. type: Plain text
#: en/git-archimport.txt:37
#, priority:100
msgid "'git archimport' uses `tla` extensively in the background to access the Arch repository.  Make sure you have a recent version of `tla` available in the path. `tla` must know about the repositories you pass to 'git archimport'."
msgstr "'git archimport' 在后台广泛使用 `tla` 来访问Arch仓库。 确保你的路径中有一个最新版本的 `tla`。`tla` 必须知道你传递给 'git archimport' 的仓库。"

#. type: Plain text
#: en/git-archimport.txt:42
#, fuzzy, priority:100
msgid "For the initial import, 'git archimport' expects to find itself in an empty directory. To follow the development of a project that uses Arch, rerun 'git archimport' with the same parameters as the initial import to perform incremental imports."
msgstr "对于初始导入，'git archimport' 希望能在一个空目录中找到自己。要跟踪一个使用 Arch 的项目的发展，重新运行 'git archimport'，参数与初始导入相同，以执行增量导入。"

#. type: Plain text
#: en/git-archimport.txt:49
#, priority:100
msgid "While 'git archimport' will try to create sensible branch names for the archives that it imports, it is also possible to specify Git branch names manually.  To do so, write a Git branch name after each <archive>/<branch> parameter, separated by a colon.  This way, you can shorten the Arch branch names and convert Arch jargon to Git jargon, for example mapping a \"PROJECT{litdd}devo{litdd}VERSION\" branch to \"master\"."
msgstr "虽然 'git archimport' 会尝试为它导入的档案创建合理的分支名，但也可以手动指定 Git 分支名。 要做到这一点，在每个 <归档>/<分支> 参数后面写一个 Git 分支名，用冒号隔开。 这样，你可以缩短 Arch 分支的名称，并将 Arch 的行话转换成 Git 的行话，例如将 \"PROJECT{litdd}devo{litdd}VERSION\" 分支映射为 \"master\"。"

#. type: Plain text
#: en/git-archimport.txt:54
#, priority:100
msgid "Associating multiple Arch branches to one Git branch is possible; the result will make the most sense only if no commits are made to the first branch, after the second branch is created.  Still, this is useful to convert Arch repositories that had been rotated periodically."
msgstr "将多个 Arch 分支关联到一个 Git 分支是可能的；只有在创建第二个分支后没有向第一个分支提交的情况下，其结果才是最合理的。 不过，这对于转换定期轮换的 Arch 仓库还是很有用的。"

#. type: Title -
#: en/git-archimport.txt:57
#, fuzzy, no-wrap, priority:100
msgid "MERGES"
msgstr "MERGES"

#. type: Plain text
#: en/git-archimport.txt:63
#, priority:100
msgid "Patch merge data from Arch is used to mark merges in Git as well. Git does not care much about tracking patches, and only considers a merge when a branch incorporates all the commits since the point they forked. The end result is that Git will have a good idea of how far branches have diverged. So the import process does lose some patch-trading metadata."
msgstr "Arch 的补丁合并数据在 Git 中也被用来标记合并。Git 并不关心对补丁的追踪，只有当一个分支包含了自分叉点以来的所有提交时，才会考虑合并。最终的结果是，Git 会很好地了解分支的分歧程度。所以导入过程确实会丢失一些补丁交易的元数据。"

#. type: Plain text
#: en/git-archimport.txt:67
#, priority:100
msgid "Fortunately, when you try and merge branches imported from Arch, Git will find a good merge base, and it has a good chance of identifying patches that have been traded out-of-sequence between the branches."
msgstr "幸运的是，当你尝试合并从 Arch 导入的分支时，Git 会找到一个好的合并基础，而且它有很大的机会识别出在分支之间被交易的不符合顺序的补丁。"

#. type: Plain text
#: en/git-archimport.txt:73
#, priority:100
msgid "Display usage."
msgstr "显示用途。"

#. type: Plain text
#: en/git-archimport.txt:76
#, fuzzy, priority:100
msgid "Verbose output."
msgstr "粗略的输出。"

#. type: Labeled list
#: en/git-archimport.txt:77
#, fuzzy, no-wrap, priority:100
msgid "-T"
msgstr "-T"

#. type: Plain text
#: en/git-archimport.txt:80
#, priority:100
msgid "Many tags. Will create a tag for every commit, reflecting the commit name in the Arch repository."
msgstr "多标签。将为每个提交创建一个标签，反映 Arch 库中的提交名称。"

#. type: Plain text
#: en/git-archimport.txt:85
#, priority:100
msgid "Use the fast patchset import strategy.  This can be significantly faster for large trees, but cannot handle directory renames or permissions changes.  The default strategy is slow and safe."
msgstr "使用快速补丁集导入策略。 这对大目录树来说可以明显加快，但不能处理目录重名或权限变化。 默认策略是缓慢而安全的。"

#. type: Labeled list
#: en/git-archimport.txt:86 en/git-commit.txt:308 en/git-grep.txt:183 en/git-ls-files.txt:53 en/git-merge-index.txt:29
#, ignore-same, no-wrap, priority:280
msgid "-o"
msgstr "-o"

#. type: Plain text
#: en/git-archimport.txt:93
#, priority:100
msgid "Use this for compatibility with old-style branch names used by earlier versions of 'git archimport'.  Old-style branch names were category{litdd}branch, whereas new-style branch names are archive,category{litdd}branch{litdd}version.  In both cases, names given on the command-line will override the automatically-generated ones."
msgstr "为了与早期版本的 'git archimport' 所使用的旧式分支名兼容，使用这个名字。 旧式的分支名是 category{litdd}branch，而新式的分支名是 archive,category{litdd}branch{litdd}version。 在这两种情况下，在命令行中给出的名字将覆盖自动生成的名字。"

#. type: Labeled list
#: en/git-archimport.txt:94
#, fuzzy, no-wrap, priority:100
msgid "-D <depth>"
msgstr "-D <depth>"

#. type: Plain text
#: en/git-archimport.txt:98
#, priority:100
msgid "Follow merge ancestry and attempt to import trees that have been merged from.  Specify a depth greater than 1 if patch logs have been pruned."
msgstr "遵循合并的祖先，并尝试导入已经合并的目录树。 如果补丁日志已经被修剪，则指定一个大于 1 的深度。"

#. type: Plain text
#: en/git-archimport.txt:102
#, priority:100
msgid "Attempt to auto-register archives at `http://mirrors.sourcecontrol.net` This is particularly useful with the -D option."
msgstr "尝试在 `http://mirrors.sourcecontrol.net` 上自动注册档案，这在 -D 选项下特别有用。"

#. type: Labeled list
#: en/git-archimport.txt:103
#, no-wrap, priority:100
msgid "-t <tmpdir>"
msgstr "-t <缓存目录>"

#. type: Plain text
#: en/git-archimport.txt:105
#, priority:100
msgid "Override the default tempdir."
msgstr "重写默认缓存目录。"

#. type: Labeled list
#: en/git-archimport.txt:107
#, fuzzy, no-wrap, priority:100
msgid "<archive>/<branch>"
msgstr "--branch <branch>"

#. type: Plain text
#: en/git-archimport.txt:109
#, priority:100
msgid "<archive>/<branch> identifier in a format that `tla log` understands."
msgstr "<归档>/<分支> 标识符的格式是 `tla log` 能理解的。"

#. type: Title =
#: en/git-archive.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-archive(1)"
msgstr "git-archive(1)"

#. type: Plain text
#: en/git-archive.txt:7
#, priority:100
msgid "git-archive - Create an archive of files from a named tree"
msgstr "git-archive - 从命名的目录树中创建一个归档文件"

#. type: Plain text
#: en/git-archive.txt:16
#, fuzzy, ignore-ellipsis, no-wrap, priority:100
msgid ""
"'git archive' [--format=<fmt>] [--list] [--prefix=<prefix>/] [<extra>]\n"
"\t      [-o <file> | --output=<file>] [--worktree-attributes]\n"
"\t      [--remote=<repo> [--exec=<git-upload-archive>]] <tree-ish>\n"
"\t      [<path>...]\n"
msgstr ""
"'git archive' [--format=<fmt>] [--list] [--prefix=<前缀>/] [<extra>]\n"
"\t      [-o <文件> | --output=<文件>] [--worktree-attributes]\n"
"\t      [--remote=<仓库> [--exec=<git-upload-archive>]] <树状对象>\n"
"\t      [<路径>...]\n"

#. type: Plain text
#: en/git-archive.txt:23
#, priority:100
msgid "Creates an archive of the specified format containing the tree structure for the named tree, and writes it out to the standard output.  If <prefix> is specified it is prepended to the filenames in the archive."
msgstr "创建一个指定格式的档案，包含命名的目录树的结构，并将其写入标准输出。 如果 <前缀> 被指定，它将被预置在归档文件的文件名上。"

#. type: Plain text
#: en/git-archive.txt:32
#, priority:100
msgid "'git archive' behaves differently when given a tree ID versus when given a commit ID or tag ID.  In the first case the current time is used as the modification time of each file in the archive.  In the latter case the commit time as recorded in the referenced commit object is used instead.  Additionally the commit ID is stored in a global extended pax header if the tar format is used; it can be extracted using 'git get-tar-commit-id'. In ZIP files it is stored as a file comment."
msgstr "'git archive' 在给定树的 ID 和给定提交的 ID 或标签的 ID 时表现不同。 在前一种情况下，当前时间被用作档案中每个文件的修改时间。 在后一种情况下，则使用参考的提交对象中记录的提交时间。 此外，如果使用 tar 格式，提交 ID 会被存储在一个全局扩展的 pax 头中；可以用 'git get-tar-commit-id' 来提取它。在 ZIP 文件中，它被存储为一个文件注释。"

#. type: Labeled list
#: en/git-archive.txt:36
#, fuzzy, no-wrap, priority:100
msgid "--format=<fmt>"
msgstr "--format=<fmt>"

#. type: Plain text
#: en/git-archive.txt:44
#, priority:100
msgid "Format of the resulting archive. Possible values are `tar`, `zip`, `tar.gz`, `tgz`, and any format defined using the configuration option `tar.<format>.command`. If `--format` is not given, and the output file is specified, the format is inferred from the filename if possible (e.g. writing to `foo.zip` makes the output to be in the `zip` format). Otherwise the output format is `tar`."
msgstr "归档文件的格式。可能的值是 `tar`, `zip`, `tar.gz`, `tgz`, 以及使用配置选项 `tar.<格式>.command` 定义的任何格式。如果没有给出 `--format`，并且指定了输出文件，如果可能的话，将从文件名中推断出格式（例如，写入`foo.zip` 会使输出为`zip`格式）。否则，输出格式为`tar`。"

#. type: Labeled list
#: en/git-archive.txt:46 en/git-branch.txt:182 en/git-config.txt:182 en/git-show-branch.txt:79 en/git-tag.txt:100
#, ignore-same, no-wrap, priority:260
msgid "--list"
msgstr "--list"

#. type: Plain text
#: en/git-archive.txt:48
#, priority:100
msgid "Show all available formats."
msgstr "显示所有可用的格式。"

#. type: Plain text
#: en/git-archive.txt:52
#, priority:100
msgid "Report progress to stderr."
msgstr "向标准错误流报告进度。"

#. type: Labeled list
#: en/git-archive.txt:53 en/git-write-tree.txt:35
#, fuzzy, no-wrap, priority:100
msgid "--prefix=<prefix>/"
msgstr "--prefix=<prefix>/"

#. type: Plain text
#: en/git-archive.txt:57
#, priority:100
msgid "Prepend <prefix>/ to paths in the archive.  Can be repeated; its rightmost value is used for all tracked files.  See below which value gets used by `--add-file` and `--add-virtual-file`."
msgstr "将 <前缀>/ 预置到存档中的路径。 可以重复使用；其最右边的值用于所有跟踪的文件。 请看下面的 `--add-file` 和 `--add-virtual-file` 所使用的值。"

#. type: Labeled list
#: en/git-archive.txt:58
#, fuzzy, no-wrap, priority:100
msgid "-o <file>"
msgstr "-o <file>"

#. type: Plain text
#: en/git-archive.txt:61
#, priority:100
msgid "Write the archive to <file> instead of stdout."
msgstr "将存档写入 <文件> 而不是标准输出流。"

#. type: Labeled list
#: en/git-archive.txt:62
#, fuzzy, no-wrap, priority:100
#| msgid "--pathspec-from-file=<file>"
msgid "--add-file=<file>"
msgstr "--add-file=<file>"

#. type: Plain text
#: en/git-archive.txt:67
#, priority:100
msgid "Add a non-tracked file to the archive.  Can be repeated to add multiple files.  The path of the file in the archive is built by concatenating the value of the last `--prefix` option (if any)  before this `--add-file` and the basename of <file>."
msgstr "添加一个非跟踪的文件到存档。 可以重复添加多个文件。 归档文件的路径是由这个 `--add-file` 之前的最后一个 `--prefix` 选项（如果有的话）的值和 <文件> 的基本名称连接而成的。"

#. type: Labeled list
#: en/git-archive.txt:68
#, no-wrap, priority:100
msgid "--add-virtual-file=<path>:<content>"
msgstr "--add-virtual-file=<路径>:<内容>"

#. type: Plain text
#: en/git-archive.txt:73
#, priority:100
msgid "Add the specified contents to the archive.  Can be repeated to add multiple files.  The path of the file in the archive is built by concatenating the value of the last `--prefix` option (if any)  before this `--add-virtual-file` and `<path>`."
msgstr "将指定的内容添加到档案中。 可以重复添加多个文件。 归档文件的路径是由这个 `--add-virtual-file` 之前的最后一个 `--prefix` 选项（如果有的话）和 `<路径>` 相连而成的。"

#. type: Plain text
#: en/git-archive.txt:80
#, priority:100
msgid "The `<path>` argument can start and end with a literal double-quote character; the contained file name is interpreted as a C-style string, i.e. the backslash is interpreted as escape character. The path must be quoted if it contains a colon, to avoid the colon from being misinterpreted as the separator between the path and the contents, or if the path begins or ends with a double-quote character."
msgstr "`<路径>` 参数可以以字面的双引号字符开始和结束；包含的文件名被解释为 C 风格的字符串，即反斜杠被解释为转义字符。如果路径包含一个冒号，则必须加引号，以避免冒号被误解为路径和内容之间的分隔符，或者如果路径以双引号字符开始或结束。"

#. type: Plain text
#: en/git-archive.txt:84
#, priority:100
msgid "The file mode is limited to a regular file, and the option may be subject to platform-dependent command-line limits. For non-trivial cases, write an untracked file and use `--add-file` instead."
msgstr "文件模式被限制为普通文件，该选项可能会受到依赖平台的命令行的限制。对于非复杂的情况，写一个非跟踪的文件并使用 `--add-file` 代替。"

#. type: Labeled list
#: en/git-archive.txt:85
#, ignore-same, no-wrap, priority:100
msgid "--worktree-attributes"
msgstr "--worktree-attributes"

#. type: Plain text
#: en/git-archive.txt:88
#, priority:100
msgid "Look for attributes in .gitattributes files in the working tree as well (see <<ATTRIBUTES>>)."
msgstr "也可以在工作区中的 .gitattributes 文件中寻找属性（见 <<ATTRIBUTES>>）。"

#. type: Labeled list
#: en/git-archive.txt:89
#, fuzzy, no-wrap, priority:100
msgid "--mtime=<time>"
msgstr "--expire <time>"

#. type: Plain text
#: en/git-archive.txt:93
#, priority:100
msgid "Set modification time of archive entries.  Without this option the committer time is used if `<tree-ish>` is a commit or tag, and the current time if it is a tree."
msgstr "设置存档条目的修改时间。 如果没有这个选项，如果 `<树状对象>` 是一个提交或标签，则使用提交者的时间，如果是一个树，则使用当前时间。"

#. type: Labeled list
#: en/git-archive.txt:94
#, fuzzy, no-wrap, priority:100
msgid "<extra>"
msgstr "<extra>"

#. type: Plain text
#: en/git-archive.txt:97
#, priority:100
msgid "This can be any options that the archiver backend understands.  See next section."
msgstr "这可以是存档器后端能理解的任何选项。 见下一节。"

#. type: Labeled list
#: en/git-archive.txt:98
#, fuzzy, no-wrap, priority:100
msgid "--remote=<repo>"
msgstr "--remote=<repo>"

#. type: Plain text
#: en/git-archive.txt:104
#, priority:100
msgid "Instead of making a tar archive from the local repository, retrieve a tar archive from a remote repository. Note that the remote repository may place restrictions on which sha1 expressions may be allowed in `<tree-ish>`. See linkgit:git-upload-archive[1] for details."
msgstr "与其从本地版本库制作一个 tar 归档，不如从远程版本库检索一个 tar 归档。注意，远程仓库可能会对 `<树状对象>` 中允许的 sha1 表达式进行限制。详情见 linkgit:git-upload-archive[1]。"

#. type: Labeled list
#: en/git-archive.txt:105
#, ignore-same, no-wrap, priority:100
msgid "--exec=<git-upload-archive>"
msgstr "--exec=<git-upload-archive>"

#. type: Plain text
#: en/git-archive.txt:108
#, priority:100
msgid "Used with --remote to specify the path to the 'git-upload-archive' on the remote side."
msgstr "与 --remote 一起使用，指定远程端的 \"git-upload-archive\" 的路径。"

#. type: Labeled list
#: en/git-archive.txt:109 en/git-checkout.txt:356 en/git-diff-index.txt:26 en/git-diff-tree.txt:29 en/git-ls-tree.txt:38 en/git.txt:402
#, no-wrap, priority:240
msgid "<tree-ish>"
msgstr "<tree-ish>"

#. type: Plain text
#: en/git-archive.txt:111
#, priority:100
msgid "The tree or commit to produce an archive for."
msgstr "要制作存档的树目录或提交。"

#. type: Labeled list
#: en/git-archive.txt:112
#, fuzzy, no-wrap, priority:100
msgid "<path>"
msgstr "<path>"

#. type: Plain text
#: en/git-archive.txt:116
#, priority:100
msgid "Without an optional path parameter, all files and subdirectories of the current working directory are included in the archive.  If one or more paths are specified, only these are included."
msgstr "如果没有可选的路径参数，当前工作目录下的所有文件和子目录都会包括在存档中。  如果指定了一个或多个路径，则只包括这些路径。"

#. type: Title -
#: en/git-archive.txt:118
#, no-wrap, priority:100
msgid "BACKEND EXTRA OPTIONS"
msgstr "后台额外选项"

#. type: Title ~
#: en/git-archive.txt:121
#, fuzzy, no-wrap, priority:100
msgid "zip"
msgstr "郵遞區號"

#. type: Labeled list
#: en/git-archive.txt:122
#, no-wrap, priority:100
msgid "-<digit>"
msgstr "-<数字 0-9>"

#. type: Plain text
#: en/git-archive.txt:127
#, priority:100
msgid "Specify compression level.  Larger values allow the command to spend more time to compress to smaller size.  Supported values are from `-0` (store-only) to `-9` (best ratio).  Default is `-6` if not given."
msgstr "指定压缩级别。 较大的值允许命令花费更多的时间来压缩到较小的尺寸。 支持的值从 `-0`（只存储）到 `-9`（最佳比例）。 如果没有给出，默认为 `-6'。"

#. type: Title ~
#: en/git-archive.txt:129
#, fuzzy, no-wrap, priority:100
msgid "tar"
msgstr "起点"

#. type: Labeled list
#: en/git-archive.txt:130 en/rev-list-options.txt:16
#, no-wrap, priority:260
msgid "-<number>"
msgstr "-<数>"

#. type: Plain text
#: en/git-archive.txt:135
#, priority:100
msgid "Specify compression level. The value will be passed to the compression command configured in `tar.<format>.command`. See manual page of the configured command for the list of supported levels and the default level if this option isn't specified."
msgstr "指定压缩级别。该值将被传递给 `tar.<格式>.command` 中配置的压缩命令。如果没有指定这个选项，请参阅配置的命令的手册页，了解支持的级别和默认级别。"

#. type: Labeled list
#: en/git-archive.txt:139
#, fuzzy, no-wrap, priority:100
msgid "tar.umask"
msgstr "tar.umask"

#. type: Plain text
#: en/git-archive.txt:146
#, priority:100
msgid "This variable can be used to restrict the permission bits of tar archive entries.  The default is 0002, which turns off the world write bit.  The special value \"user\" indicates that the archiving user's umask will be used instead.  See umask(2) for details.  If `--remote` is used then only the configuration of the remote repository takes effect."
msgstr "这个变量可以用来限制 tar 存档条目的权限位。 默认值是 0002，它关闭了世界写入位。 特殊值 \"user\" 表示将使用归档用户的 umask 来代替。 详情见 umask(2)。 如果使用 `--remote`，那么只有远程仓库的配置才会生效。"

#. type: Labeled list
#: en/git-archive.txt:147
#, no-wrap, priority:100
msgid "tar.<format>.command"
msgstr "tar.<格式>.command"

#. type: Plain text
#: en/git-archive.txt:154
#, priority:100
msgid "This variable specifies a shell command through which the tar output generated by `git archive` should be piped. The command is executed using the shell with the generated tar file on its standard input, and should produce the final output on its standard output. Any compression-level options will be passed to the command (e.g., `-9`)."
msgstr "这个变量指定了一个 shel l命令，由 `git archive` 产生的 tar 输出应该通过管道。该命令使用 shell 执行，在其标准输入中生成 tar 文件，并应在其标准输出中产生最终输出。任何压缩级别的选项将被传递给该命令（例如，`-9'）。"

#. type: Plain text
#: en/git-archive.txt:158
#, priority:100
msgid "The `tar.gz` and `tgz` formats are defined automatically and use the magic command `git archive gzip` by default, which invokes an internal implementation of gzip."
msgstr "`tar.gz` 和 `tgz` 格式是自动定义的，默认使用神奇的命令 `git archive gzip`，它调用了 gzip 的内部实现。"

#. type: Labeled list
#: en/git-archive.txt:159
#, fuzzy, no-wrap, priority:100
msgid "tar.<format>.remote"
msgstr "tar.<format>.remote"

#. type: Plain text
#: en/git-archive.txt:164
#, priority:100
msgid "If true, enable the format for use by remote clients via linkgit:git-upload-archive[1]. Defaults to false for user-defined formats, but true for the `tar.gz` and `tgz` formats."
msgstr "如果为真，则通过 linkgit:git-upload-archive[1] 启用该格式供远程客户端使用。对于用户定义的格式，默认为 false，但对于 `tar.gz` 和 `tgz` 格式为 true。"

#. type: Title -
#: en/git-archive.txt:167
#, fuzzy, no-wrap, priority:100
msgid "ATTRIBUTES"
msgstr "属性"

#. type: Labeled list
#: en/git-archive.txt:169
#, no-wrap, priority:100
msgid "export-ignore"
msgstr "export-ignore"

#. type: Plain text
#: en/git-archive.txt:172
#, priority:100
msgid "Files and directories with the attribute export-ignore won't be added to archive files.  See linkgit:gitattributes[5] for details."
msgstr "带有 export-ignore 属性的文件和目录不会被添加到存档文件中。 详情见 linkgit:gitattributes[5]。"

#. type: Labeled list
#: en/git-archive.txt:173
#, no-wrap, priority:100
msgid "export-subst"
msgstr "export-subst"

#. type: Plain text
#: en/git-archive.txt:177
#, priority:100
msgid "If the attribute export-subst is set for a file then Git will expand several placeholders when adding this file to an archive.  See linkgit:gitattributes[5] for details."
msgstr "如果为一个文件设置了 export-subst 属性，那么当把这个文件添加到存档时，Git 会展开几个占位符。 详情见 linkgit:gitattributes[5]。"

#. type: Plain text
#: en/git-archive.txt:185
#, priority:100
msgid "Note that attributes are by default taken from the `.gitattributes` files in the tree that is being archived.  If you want to tweak the way the output is generated after the fact (e.g. you committed without adding an appropriate export-ignore in its `.gitattributes`), adjust the checked out `.gitattributes` file as necessary and use `--worktree-attributes` option.  Alternatively you can keep necessary attributes that should apply while archiving any tree in your `$GIT_DIR/info/attributes` file."
msgstr "注意，默认情况下，属性来自被归档的树中的 `.gitattributes` 文件。 如果你想在事后调整输出的方式（例如，你提交时没有在其 `.gitattributes` 中添加适当的 export-ignore ），请根据需要调整检查出来的 `.gitattributes` 文件并使用 `--worktreeattributes` 选项。 另外，你也可以在你的 `$GIT_DIR/info/attributes` 文件中保留归档任何树时应该适用的必要属性。"

#. type: Labeled list
#: en/git-archive.txt:188
#, no-wrap, priority:100
msgid "`git archive --format=tar --prefix=junk/ HEAD | (cd /var/tmp/ && tar xf -)`"
msgstr "`git archive --format=tar --prefix=junk/ HEAD | (cd /var/tmp/ && tar xf -)`"

#. type: Plain text
#: en/git-archive.txt:193
#, priority:100
msgid "Create a tar archive that contains the contents of the latest commit on the current branch, and extract it in the `/var/tmp/junk` directory."
msgstr "创建一个包含当前分支上最新提交内容的 tar 归档文件，并将其解压到 `/var/tmp/junk` 目录中。"

#. type: Labeled list
#: en/git-archive.txt:194
#, no-wrap, priority:100
msgid "`git archive --format=tar --prefix=git-1.4.0/ v1.4.0 | gzip >git-1.4.0.tar.gz`"
msgstr "`git archive --format=tar --prefix=git-1.4.0/ v1.4.0 | gzip >git-1.4.0.tar.gz`"

#. type: Plain text
#: en/git-archive.txt:197
#, priority:100
msgid "Create a compressed tarball for v1.4.0 release."
msgstr "为 v1.4.0 版本创建一个压缩的压缩包。"

#. type: Labeled list
#: en/git-archive.txt:198
#, no-wrap, priority:100
msgid "`git archive --format=tar.gz --prefix=git-1.4.0/ v1.4.0 >git-1.4.0.tar.gz`"
msgstr "`git archive --format=tar.gz --prefix=git-1.4.0/ v1.4.0 >git-1.4.0.tar.gz`"

#. type: Plain text
#: en/git-archive.txt:201
#, priority:100
msgid "Same as above, but using the builtin tar.gz handling."
msgstr "和上面一样，但使用内置的 tar.gz 处理。"

#. type: Labeled list
#: en/git-archive.txt:202
#, no-wrap, priority:100
msgid "`git archive --prefix=git-1.4.0/ -o git-1.4.0.tar.gz v1.4.0`"
msgstr "`git archive --prefix=git-1.4.0/ -o git-1.4.0.tar.gz v1.4.0`"

#. type: Plain text
#: en/git-archive.txt:205
#, priority:100
msgid "Same as above, but the format is inferred from the output file."
msgstr "与上述相同，但格式是从输出文件中推断出来的。"

#. type: Labeled list
#: en/git-archive.txt:206
#, fuzzy, no-wrap, priority:100
msgid "`git archive --format=tar --prefix=git-1.4.0/ v1.4.0^{tree} | gzip >git-1.4.0.tar.gz`"
msgstr "`git archive --format=tar --prefix=git-1.4.0/ v1.4.0^{tree} | gzip >git-1.4.0.tar.gz`"

#. type: Plain text
#: en/git-archive.txt:210
#, priority:100
msgid "Create a compressed tarball for v1.4.0 release, but without a global extended pax header."
msgstr "为 v1.4.0 版本创建一个压缩的 tarball，但没有全局扩展的 pax 头。"

#. type: Labeled list
#: en/git-archive.txt:211
#, fuzzy, no-wrap, priority:100
msgid "`git archive --format=zip --prefix=git-docs/ HEAD:Documentation/ > git-1.4.0-docs.zip`"
msgstr "`git archive --format=zip --prefix=git-docs/ HEAD:Documentation/ > git-1.4.0-docs.zip`"

#. type: Plain text
#: en/git-archive.txt:215
#, priority:100
msgid "Put everything in the current head's Documentation/ directory into 'git-1.4.0-docs.zip', with the prefix 'git-docs/'."
msgstr "将当前头文件或目录下的所有内容放入 'git-1.4.0-docs.zip'，前缀为 'git-docs/'。"

#. type: Labeled list
#: en/git-archive.txt:216
#, no-wrap, priority:100
msgid "`git archive -o latest.zip HEAD`"
msgstr "`git archive -o latest.zip HEAD`"

#. type: Plain text
#: en/git-archive.txt:221
#, priority:100
msgid "Create a Zip archive that contains the contents of the latest commit on the current branch. Note that the output format is inferred by the extension of the output file."
msgstr "创建一个包含当前分支上最新提交内容的 Zip 档案。注意，输出格式是由输出文件的扩展名推断出来的。"

#. type: Labeled list
#: en/git-archive.txt:222
#, no-wrap, priority:100
msgid "`git archive -o latest.tar --prefix=build/ --add-file=configure --prefix= HEAD`"
msgstr "`git archive -o latest.tar --prefix=build/ --add-file=configure --prefix= HEAD`"

#. type: Plain text
#: en/git-archive.txt:227
#, priority:100
msgid "Creates a tar archive that contains the contents of the latest commit on the current branch with no prefix and the untracked file 'configure' with the prefix 'build/'."
msgstr "创建一个 tar 归档文件，其中包含当前分支上的最新提交内容，无前缀，以及无跟踪的文件 'configure'，前缀为 'build/'。"

#. type: Labeled list
#: en/git-archive.txt:228
#, fuzzy, no-wrap, priority:100
msgid "`git config tar.tar.xz.command \"xz -c\"`"
msgstr "`git config tar.tar.xz.command \"xz -c\"`"

#. type: Plain text
#: en/git-archive.txt:233
#, priority:100
msgid "Configure a \"tar.xz\" format for making LZMA-compressed tarfiles.  You can use it specifying `--format=tar.xz`, or by creating an output file like `-o foo.tar.xz`."
msgstr "配置一个 \"tar.xz\" 格式来制作 LZMA 压缩的 tarf 文件。 你可以指定 `--format=tar.xz` 来使用它，或者通过创建一个像 `-o foo.tar.xz` 这样的输出文件。"

#. type: Plain text
#: en/git-archive.txt:238
#, ignore-same, priority:100
msgid "linkgit:gitattributes[5]"
msgstr "linkgit:gitattributes[5]"

#. type: Title =
#: en/git-bisect.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-bisect(1)"
msgstr "git-bisect(1)"

#. type: Plain text
#: en/git-bisect.txt:7
#, priority:100
msgid "git-bisect - Use binary search to find the commit that introduced a bug"
msgstr "git-bisect - 使用二进制搜索查找引入错误的提交。"

#. type: Plain text
#: en/git-bisect.txt:13
#, fuzzy, no-wrap, priority:100
msgid "'git bisect' <subcommand> <options>\n"
msgstr "'git bisect' <subcommand> <options>\n"

#. type: Plain text
#: en/git-bisect.txt:18 en/git-reflog.txt:34
#, priority:100
msgid "The command takes various subcommands, and different options depending on the subcommand:"
msgstr "该命令采取不同的子命令，并根据子命令有不同的选项："

#. type: Plain text
#: en/git-bisect.txt:31
#, fuzzy, ignore-ellipsis, no-wrap, priority:100
msgid ""
" git bisect start [--term-{new,bad}=<term> --term-{old,good}=<term>]\n"
"\t\t  [--no-checkout] [--first-parent] [<bad> [<good>...]] [--] [<paths>...]\n"
" git bisect (bad|new|<term-new>) [<rev>]\n"
" git bisect (good|old|<term-old>) [<rev>...]\n"
" git bisect terms [--term-good | --term-bad]\n"
" git bisect skip [(<rev>|<range>)...]\n"
" git bisect reset [<commit>]\n"
" git bisect (visualize|view)\n"
" git bisect replay <logfile>\n"
" git bisect log\n"
" git bisect run <cmd>...\n"
" git bisect help\n"
msgstr ""
" git bisect start [--term-{new,bad}=<term> --term-{old,good}=<term>]\n"
"\t\t  [--no-checkout] [--first-parent] [<bad> [<good>...]] [--] [<paths>...]\n"
" git bisect (bad|new|<term-new>) [<rev>]\n"
" git bisect (good|old|<term-old>) [<rev>...]\n"
" git bisect terms [--term-good | --term-bad]\n"
" git bisect skip [(<rev>|<range>)...]\n"
" git bisect reset [<commit>]\n"
" git bisect (visualize|view)\n"
" git bisect replay <logfile>\n"
" git bisect log\n"
" git bisect run <cmd>...\n"
" git bisect help\n"

#. type: Plain text
#: en/git-bisect.txt:40
#, priority:100
msgid "This command uses a binary search algorithm to find which commit in your project's history introduced a bug. You use it by first telling it a \"bad\" commit that is known to contain the bug, and a \"good\" commit that is known to be before the bug was introduced. Then `git bisect` picks a commit between those two endpoints and asks you whether the selected commit is \"good\" or \"bad\". It continues narrowing down the range until it finds the exact commit that introduced the change."
msgstr "这个命令使用二分搜索算法来查找项目历史中哪个提交引入了一个错误。使用该命令时，首先告诉它一个已知包含错误的 \"坏\" 提交，以及一个已知在错误出现之前的 \"好\" 提交。然后 `git bisect` 在这两个端点之间挑选一个提交，并询问你所选的提交是 \"好\" 还是 \"坏\"。它继续缩小范围，直到找到引入该修改的确切提交。"

#. type: Plain text
#: en/git-bisect.txt:47
#, priority:100
msgid "In fact, `git bisect` can be used to find the commit that changed *any* property of your project; e.g., the commit that fixed a bug, or the commit that caused a benchmark's performance to improve. To support this more general usage, the terms \"old\" and \"new\" can be used in place of \"good\" and \"bad\", or you can choose your own terms. See section \"Alternate terms\" below for more information."
msgstr "事实上，`git bisect` 可以用来查找改变项目 *任何* 属性的提交；例如，修复了一个 bug 的提交，或者使一个基准的性能得到改善的提交。为了支持这种更普遍的用法，可以用 \"old\" 和 \"new\" 来代替 \"good\" 和 \"bad\"，或者您可以选择自己的术语。更多信息见下文 \"替代术语 \"一节。"

#. type: Title ~
#: en/git-bisect.txt:49
#, no-wrap, priority:100
msgid "Basic bisect commands: start, bad, good"
msgstr "基本的二分命令：start, bad, good"

#. type: Plain text
#: en/git-bisect.txt:54
#, priority:100
msgid "As an example, suppose you are trying to find the commit that broke a feature that was known to work in version `v2.6.13-rc2` of your project. You start a bisect session as follows:"
msgstr "举个例子，假设你想找到破坏了一个已知在你的项目的 `v2.6.13-rc2` 版本中工作的特性的提交。你启动了一个 bisect 会话，如下所示："

#. type: delimited block -
#: en/git-bisect.txt:59
#, fuzzy, no-wrap, priority:100
msgid ""
"$ git bisect start\n"
"$ git bisect bad                 # Current version is bad\n"
"$ git bisect good v2.6.13-rc2    # v2.6.13-rc2 is known to be good\n"
msgstr ""
"$ git bisect start\n"
"$ git bisect bad                 # Current version is bad\n"
"$ git bisect good v2.6.13-rc2    # v2.6.13-rc2 is known to be good\n"

#. type: Plain text
#: en/git-bisect.txt:64
#, priority:100
msgid "Once you have specified at least one bad and one good commit, `git bisect` selects a commit in the middle of that range of history, checks it out, and outputs something similar to the following:"
msgstr "一旦你指定了至少一个坏的和一个好的提交，`git bisect` 就会在这个历史范围的中间选择一个提交，检查它，并输出类似于以下的内容："

#. type: delimited block -
#: en/git-bisect.txt:67
#, no-wrap, priority:100
msgid "Bisecting: 675 revisions left to test after this (roughly 10 steps)\n"
msgstr "Bisecting: 675 revisions left to test after this (roughly 10 steps) | 在这之后，还有675次修订需要测试（大约10步）\n"

#. type: Plain text
#: en/git-bisect.txt:71
#, priority:100
msgid "You should now compile the checked-out version and test it. If that version works correctly, type"
msgstr "你现在应该编译检出的版本并进行测试。如果该版本工作正常，请输入"

#. type: delimited block -
#: en/git-bisect.txt:74
#, no-wrap, priority:100
msgid "$ git bisect good\n"
msgstr "$ git bisect good\n"

#. type: Plain text
#: en/git-bisect.txt:77
#, priority:100
msgid "If that version is broken, type"
msgstr "如果该版本被破坏，请输入"

#. type: delimited block -
#: en/git-bisect.txt:80
#, fuzzy, no-wrap, priority:100
msgid "$ git bisect bad\n"
msgstr "$ git bisect bad\n"

#. type: Plain text
#: en/git-bisect.txt:83
#, priority:100
msgid "Then `git bisect` will respond with something like"
msgstr "然后，`git bisect`会做出如下反应"

#. type: delimited block -
#: en/git-bisect.txt:86
#, no-wrap, priority:100
msgid "Bisecting: 337 revisions left to test after this (roughly 9 steps)\n"
msgstr "Bisecting: 337 revisions left to test after this (roughly 9 steps) | 在这之后还有337个修订要测试（大约9个步骤）。\n"

#. type: Plain text
#: en/git-bisect.txt:91
#, priority:100
msgid "Keep repeating the process: compile the tree, test it, and depending on whether it is good or bad run `git bisect good` or `git bisect bad` to ask for the next commit that needs testing."
msgstr "不断重复这个过程：编译树，测试它，根据它是好是坏，运行 `git bisect good` 或 `git bisect bad` 来要求下一个需要测试的提交。"

#. type: Plain text
#: en/git-bisect.txt:95
#, priority:100
msgid "Eventually there will be no more revisions left to inspect, and the command will print out a description of the first bad commit. The reference `refs/bisect/bad` will be left pointing at that commit."
msgstr "最终，将没有更多的修订可以检查，该命令将打印出第一个坏提交的描述。引用 `refs/bisect/bad` 将被留在该提交处。"

#. type: Title ~
#: en/git-bisect.txt:98
#, no-wrap, priority:100
msgid "Bisect reset"
msgstr "重置二分查找"

#. type: Plain text
#: en/git-bisect.txt:102
#, priority:100
msgid "After a bisect session, to clean up the bisection state and return to the original HEAD, issue the following command:"
msgstr "在一个二分查找会话之后，要清理二分查找状态并返回到原来的 HEAD，请发出以下命令："

#. type: delimited block -
#: en/git-bisect.txt:105
#, fuzzy, no-wrap, priority:100
msgid "$ git bisect reset\n"
msgstr "$ git bisect reset\n"

#. type: Plain text
#: en/git-bisect.txt:110
#, priority:100
msgid "By default, this will return your tree to the commit that was checked out before `git bisect start`.  (A new `git bisect start` will also do that, as it cleans up the old bisection state.)"
msgstr "默认情况下，这将使你的树返回到 `git bisect start` 之前检查出来的提交。 (新的 `git bisect start` 也会这样做，因为它清理了旧的分界状态）"

#. type: Plain text
#: en/git-bisect.txt:113
#, priority:100
msgid "With an optional argument, you can return to a different commit instead:"
msgstr "通过一个可选参数，你可以返回到一个不同的提交，而不是："

#. type: delimited block -
#: en/git-bisect.txt:116
#, fuzzy, no-wrap, priority:100
msgid "$ git bisect reset <commit>\n"
msgstr "$ git bisect reset <commit>\n"

#. type: Plain text
#: en/git-bisect.txt:121
#, priority:100
msgid "For example, `git bisect reset bisect/bad` will check out the first bad revision, while `git bisect reset HEAD` will leave you on the current bisection commit and avoid switching commits at all."
msgstr "例如，`git bisect reset bisect/bad` 会检查出第一个坏的修订，而 `git bisect reset HEAD` 会让你停留在当前的分界提交上，完全避免切换提交。"

#. type: Title ~
#: en/git-bisect.txt:124
#, no-wrap, priority:100
msgid "Alternate terms"
msgstr "替代条款"

#. type: Plain text
#: en/git-bisect.txt:132
#, priority:100
msgid "Sometimes you are not looking for the commit that introduced a breakage, but rather for a commit that caused a change between some other \"old\" state and \"new\" state. For example, you might be looking for the commit that introduced a particular fix. Or you might be looking for the first commit in which the source-code filenames were finally all converted to your company's naming standard. Or whatever."
msgstr "有时，您要找的不是引入断裂的提交，而是在其他 \"旧\" 状态和 \"新\" 状态之间引起变化的提交。例如，你可能要找的是引入某项修复的提交。或者你想找的是第一次提交，在这次提交中，源代码文件名最终都被转换为你公司的命名标准。或者其他什么。"

#. type: Plain text
#: en/git-bisect.txt:138
#, priority:100
msgid "In such cases it can be very confusing to use the terms \"good\" and \"bad\" to refer to \"the state before the change\" and \"the state after the change\". So instead, you can use the terms \"old\" and \"new\", respectively, in place of \"good\" and \"bad\". (But note that you cannot mix \"good\" and \"bad\" with \"old\" and \"new\" in a single session.)"
msgstr "在这种情况下，用 \"好\" 和 \"坏\" 来指代 \"变化前的状态\" 和 \"变化后的状态\" 会非常混乱。因此，你可以用 \"旧 \"和 \"新\" 来代替 \"好\" 和 \"坏\"。(但要注意，你不能在一个会话中把 \"好\"和 \"坏\" 与 \"旧\"和 \"新\" 混在一起）。"

#. type: Plain text
#: en/git-bisect.txt:145
#, priority:100
msgid "In this more general usage, you provide `git bisect` with a \"new\" commit that has some property and an \"old\" commit that doesn't have that property. Each time `git bisect` checks out a commit, you test if that commit has the property. If it does, mark the commit as \"new\"; otherwise, mark it as \"old\". When the bisection is done, `git bisect` will report which commit introduced the property."
msgstr "在这种更普遍的用法中，你向 `git bisect` 提供了一个具有某种属性的 \"新\" 提交和一个不具有该属性的 \"旧\" 提交。每次 `git bisect` 检查一个提交时，都要测试该提交是否具有该属性。如果有，则将该提交标记为 \"新\"；否则，标记为 \"旧\"。分割完成后，`git bisect` 会报告哪个提交引入了该属性。"

#. type: Plain text
#: en/git-bisect.txt:149
#, priority:100
msgid "To use \"old\" and \"new\" instead of \"good\" and bad, you must run `git bisect start` without commits as argument and then run the following commands to add the commits:"
msgstr "要使用 \"旧\" 和 \"新\"，而不是 \"好\" 和 \"坏\"，你必须运行 `git bisect start`，而不以提交为参数，然后运行以下命令来添加提交："

#. type: delimited block -
#: en/git-bisect.txt:152
#, fuzzy, no-wrap, priority:100
msgid "git bisect old [<rev>]\n"
msgstr "git bisect old [<rev>]\n"

#. type: Plain text
#: en/git-bisect.txt:155
#, priority:100
msgid "to indicate that a commit was before the sought change, or"
msgstr "表明提交时间在所寻求的变更之前，或"

#. type: delimited block -
#: en/git-bisect.txt:158
#, fuzzy, ignore-ellipsis, no-wrap, priority:100
msgid "git bisect new [<rev>...]\n"
msgstr "git bisect new [<rev>...]\n"

#. type: Plain text
#: en/git-bisect.txt:161
#, priority:100
msgid "to indicate that it was after."
msgstr "以表明它是在之后。"

#. type: Plain text
#: en/git-bisect.txt:163
#, priority:100
msgid "To get a reminder of the currently used terms, use"
msgstr "要获得当前使用的术语的提醒，请使用"

#. type: delimited block -
#: en/git-bisect.txt:166
#, no-wrap, priority:100
msgid "git bisect terms\n"
msgstr "git bisect terms\n"

#. type: Plain text
#: en/git-bisect.txt:170
#, priority:100
msgid "You can get just the old (respectively new) term with `git bisect terms --term-old` or `git bisect terms --term-good`."
msgstr "你可以用 `git bisect terms --term-old` 或 `git bisect terms --term-good` 只得到旧的（分别是新的）术语。"

#. type: Plain text
#: en/git-bisect.txt:175
#, fuzzy, ignore-ellipsis, priority:100
msgid "If you would like to use your own terms instead of \"bad\"/\"good\" or \"new\"/\"old\", you can choose any names you like (except existing bisect subcommands like `reset`, `start`, ...) by starting the bisection using"
msgstr "如果你想使用你自己的术语，而不是 \"坏\" / \"好 \" 或 \"新\" / \"旧\"，你可以选择任何你喜欢的名字（除了现有的 bisect 子命令如 `reset`，`start`，......），通过使用以下命令启动 bisection"

#. type: delimited block -
#: en/git-bisect.txt:178
#, no-wrap, priority:100
msgid "git bisect start --term-old <term-old> --term-new <term-new>\n"
msgstr "git bisect start --term-old <term-old> --term-new <term-new>\n"

#. type: Plain text
#: en/git-bisect.txt:182
#, priority:100
msgid "For example, if you are looking for a commit that introduced a performance regression, you might use"
msgstr "例如，如果你要找一个引入性能回归的提交，你可以用"

#. type: delimited block -
#: en/git-bisect.txt:185
#, no-wrap, priority:100
msgid "git bisect start --term-old fast --term-new slow\n"
msgstr "git bisect start --term-old fast --term-new slow\n"

#. type: Plain text
#: en/git-bisect.txt:188
#, priority:100
msgid "Or if you are looking for the commit that fixed a bug, you might use"
msgstr "或者，如果你要找的是修复了某个错误的提交，你可以使用"

#. type: delimited block -
#: en/git-bisect.txt:191
#, no-wrap, priority:100
msgid "git bisect start --term-new fixed --term-old broken\n"
msgstr "git bisect start --term-new fixed --term-old broken\n"

#. type: Plain text
#: en/git-bisect.txt:195
#, priority:100
msgid "Then, use `git bisect <term-old>` and `git bisect <term-new>` instead of `git bisect good` and `git bisect bad` to mark commits."
msgstr "然后，用`git bisect <term-old>` 和 `git bisect <term-new>` 代替 `git bisect good` 和`git bisect bad` 来标记提交。"

#. type: Title ~
#: en/git-bisect.txt:197
#, no-wrap, priority:100
msgid "Bisect visualize/view"
msgstr "视觉化/视图的二分查找"

#. type: Plain text
#: en/git-bisect.txt:202
#, priority:100
msgid "To see the currently remaining suspects in 'gitk', issue the following command during the bisection process (the subcommand `view` can be used as an alternative to `visualize`):"
msgstr "要查看 'gitk' 中当前剩余的嫌疑人，在二分查找过程中发出以下命令（子命令`view`可以用来替代`visualize`）："

#. type: delimited block -
#: en/git-bisect.txt:205
#, fuzzy, no-wrap, priority:100
msgid "$ git bisect visualize\n"
msgstr "$ git bisect visualize\n"

#. type: Plain text
#: en/git-bisect.txt:210
#, priority:100
msgid "If the `DISPLAY` environment variable is not set, 'git log' is used instead.  You can also give command-line options such as `-p` and `--stat`."
msgstr "如果没有设置 `DISPLAY` 环境变量，则使用 'git log' 代替。 你也可以给出命令行选项，如 `-p` 和 `-stat`。"

#. type: delimited block -
#: en/git-bisect.txt:213
#, fuzzy, no-wrap, priority:100
msgid "$ git bisect visualize --stat\n"
msgstr "$ git bisect visualize --stat\n"

#. type: Title ~
#: en/git-bisect.txt:216
#, no-wrap, priority:100
msgid "Bisect log and bisect replay"
msgstr "二分查找日志和重放二分查找"

#. type: Plain text
#: en/git-bisect.txt:220
#, priority:100
msgid "After having marked revisions as good or bad, issue the following command to show what has been done so far:"
msgstr "在将修订标记为好的或坏的之后，发出以下命令来显示到目前为止所做的事情："

#. type: delimited block -
#: en/git-bisect.txt:223
#, fuzzy, no-wrap, priority:100
msgid "$ git bisect log\n"
msgstr "$ git bisect log\n"

#. type: Plain text
#: en/git-bisect.txt:229
#, priority:100
msgid "If you discover that you made a mistake in specifying the status of a revision, you can save the output of this command to a file, edit it to remove the incorrect entries, and then issue the following commands to return to a corrected state:"
msgstr "如果你发现你在指定修订版的状态时犯了错误，你可以把这个命令的输出保存到一个文件中，编辑它以删除不正确的条目，然后发出下面的命令来返回到一个正确的状态："

#. type: delimited block -
#: en/git-bisect.txt:233
#, fuzzy, no-wrap, priority:100
msgid ""
"$ git bisect reset\n"
"$ git bisect replay that-file\n"
msgstr ""
"$ git bisect reset\n"
"$ git bisect replay that-file\n"

#. type: Title ~
#: en/git-bisect.txt:236
#, no-wrap, priority:100
msgid "Avoiding testing a commit"
msgstr "避免测试一个提交"

#. type: Plain text
#: en/git-bisect.txt:243
#, priority:100
msgid "If, in the middle of a bisect session, you know that the suggested revision is not a good one to test (e.g. it fails to build and you know that the failure does not have anything to do with the bug you are chasing), you can manually select a nearby commit and test that one instead."
msgstr "如果在二分查找会话中，你知道建议的修订版不是一个好的测试对象（例如，它不能构建，而你知道这个失败与你正在追寻的错误无关），你可以手动选择一个附近的提交，并测试该提交。"

#. type: Plain text
#: en/git-bisect.txt:245 en/git-name-rev.txt:53 en/git-tag.txt:377 en/git-bisect-lk2009.txt:914 en/git-bisect-lk2009.txt:1136 en/git-bisect-lk2009.txt:1152 en/git-bisect-lk2009.txt:1175
#, fuzzy, priority:240
msgid "For example:"
msgstr "例如："

#. type: delimited block -
#: en/git-bisect.txt:252
#, fuzzy, no-wrap, priority:100
msgid ""
"$ git bisect good/bad\t\t\t# previous round was good or bad.\n"
"Bisecting: 337 revisions left to test after this (roughly 9 steps)\n"
"$ git bisect visualize\t\t\t# oops, that is uninteresting.\n"
"$ git reset --hard HEAD~3\t\t# try 3 revisions before what\n"
"\t\t\t\t\t# was suggested\n"
msgstr ""
"$ git bisect good/bad\t\t\t# previous round was good or bad.\n"
"Bisecting: 337 revisions left to test after this (roughly 9 steps)\n"
"$ git bisect visualize\t\t\t# oops, that is uninteresting.\n"
"$ git reset --hard HEAD~3\t\t# try 3 revisions before what\n"
"\t\t\t\t\t# was suggested\n"

#. type: Plain text
#: en/git-bisect.txt:256
#, priority:100
msgid "Then compile and test the chosen revision, and afterwards mark the revision as good or bad in the usual manner."
msgstr "然后编译和测试所选择的修订版，之后以通常的方式将修订版标记为好或坏。"

#. type: Title ~
#: en/git-bisect.txt:258
#, no-wrap, priority:100
msgid "Bisect skip"
msgstr "跳过二分查找"

#. type: Plain text
#: en/git-bisect.txt:262
#, priority:100
msgid "Instead of choosing a nearby commit by yourself, you can ask Git to do it for you by issuing the command:"
msgstr "与其自己选择附近的提交，你可以通过发布命令让 Git 为你做这件事："

#. type: delimited block -
#: en/git-bisect.txt:265
#, no-wrap, priority:100
msgid "$ git bisect skip                 # Current version cannot be tested\n"
msgstr "$ git bisect skip                                # 当前版本不能被测试\n"

#. type: Plain text
#: en/git-bisect.txt:270
#, priority:100
msgid "However, if you skip a commit adjacent to the one you are looking for, Git will be unable to tell exactly which of those commits was the first bad one."
msgstr "然而，如果你跳过了与你要找的提交相邻的提交，Git 将无法准确判断出哪个提交是第一个坏提交。"

#. type: Plain text
#: en/git-bisect.txt:273
#, priority:100
msgid "You can also skip a range of commits, instead of just one commit, using range notation. For example:"
msgstr "您也可以使用范围符号跳过一系列的提交，而不仅仅是一个提交。比如说："

#. type: delimited block -
#: en/git-bisect.txt:276
#, fuzzy, no-wrap, priority:100
msgid "$ git bisect skip v2.5..v2.6\n"
msgstr "$ git bisect skip v2.5..v2.6\n"

#. type: Plain text
#: en/git-bisect.txt:280
#, priority:100
msgid "This tells the bisect process that no commit after `v2.5`, up to and including `v2.6`, should be tested."
msgstr "这告诉二分查找进程，`v2.5` 之后的提交，包括 `v2.6`，都不应该被测试。"

#. type: Plain text
#: en/git-bisect.txt:283
#, priority:100
msgid "Note that if you also want to skip the first commit of the range you would issue the command:"
msgstr "请注意，如果你也想跳过范围内的第一个提交，你会发出这个命令："

#. type: delimited block -
#: en/git-bisect.txt:286
#, fuzzy, no-wrap, priority:100
msgid "$ git bisect skip v2.5 v2.5..v2.6\n"
msgstr "$ git bisect skip v2.5 v2.5..v2.6\n"

#. type: Plain text
#: en/git-bisect.txt:290
#, priority:100
msgid "This tells the bisect process that the commits between `v2.5` and `v2.6` (inclusive) should be skipped."
msgstr "这告诉二分查找进程，应该跳过 `v2.5` 和 `v2.6`（包括）之间的提交。"

#. type: Title ~
#: en/git-bisect.txt:293
#, no-wrap, priority:100
msgid "Cutting down bisection by giving more parameters to bisect start"
msgstr "通过提供更多的参数来削减二分查找的起点"

#. type: Plain text
#: en/git-bisect.txt:298
#, priority:100
msgid "You can further cut down the number of trials, if you know what part of the tree is involved in the problem you are tracking down, by specifying path parameters when issuing the `bisect start` command:"
msgstr "如果你知道你要追踪的问题涉及到树的哪一部分，你可以通过在发出 `bisect start` 命令时指定路径参数来进一步减少试验的数量："

#. type: delimited block -
#: en/git-bisect.txt:301
#, no-wrap, priority:100
msgid "$ git bisect start -- arch/i386 include/asm-i386\n"
msgstr "$ git bisect start -- arch/i386 include/asm-i386\n"

#. type: Plain text
#: en/git-bisect.txt:306
#, priority:100
msgid "If you know beforehand more than one good commit, you can narrow the bisect space down by specifying all of the good commits immediately after the bad commit when issuing the `bisect start` command:"
msgstr "如果你事先知道有一个以上的好的提交，你可以在发出 `bisect start ` 命令时，指定坏的提交之后的所有好的提交，从而缩小二分查找的空间："

#. type: delimited block -
#: en/git-bisect.txt:311
#, fuzzy, no-wrap, priority:100
msgid ""
"$ git bisect start v2.6.20-rc6 v2.6.20-rc4 v2.6.20-rc1 --\n"
"                   # v2.6.20-rc6 is bad\n"
"                   # v2.6.20-rc4 and v2.6.20-rc1 are good\n"
msgstr ""
"$ git bisect start v2.6.20-rc6 v2.6.20-rc4 v2.6.20-rc1 --\n"
"                   # v2.6.20-rc6 is bad\n"
"                   # v2.6.20-rc4 and v2.6.20-rc1 are good\n"

#. type: Title ~
#: en/git-bisect.txt:314
#, no-wrap, priority:100
msgid "Bisect run"
msgstr "运行二分查找"

#. type: Plain text
#: en/git-bisect.txt:318
#, priority:100
msgid "If you have a script that can tell if the current source code is good or bad, you can bisect by issuing the command:"
msgstr "如果你有一个脚本，可以知道当前的源代码是好是坏，你可以通过发出命令来进行二分查找："

#. type: delimited block -
#: en/git-bisect.txt:321
#, fuzzy, no-wrap, priority:100
msgid "$ git bisect run my_script arguments\n"
msgstr "$ git bisect run my_script arguments\n"

#. type: Plain text
#: en/git-bisect.txt:327
#, priority:100
msgid "Note that the script (`my_script` in the above example) should exit with code 0 if the current source code is good/old, and exit with a code between 1 and 127 (inclusive), except 125, if the current source code is bad/new."
msgstr "注意，如果当前的源代码是好的或是旧的，脚本（上面例子中的 `my_script`）应该以代码 0 退出，如果当前的源代码是坏的或是新的，则以代码 1到 127（包括）之间退出，但 125 除外。"

#. type: Plain text
#: en/git-bisect.txt:331
#, priority:100
msgid "Any other exit code will abort the bisect process. It should be noted that a program that terminates via `exit(-1)` leaves $? = 255, (see the exit(3) manual page), as the value is chopped with `& 0377`."
msgstr "任何其他的退出代码都会中止二分查找进程。应该注意的是，通过 `exit(-1)` 终止的程序会留下 $? = 255，（见 exit(3) 手册页），因为这个值是用 `& 0377` 砍掉的。"

#. type: Plain text
#: en/git-bisect.txt:340
#, priority:100
msgid "The special exit code 125 should be used when the current source code cannot be tested. If the script exits with this code, the current revision will be skipped (see `git bisect skip` above). 125 was chosen as the highest sensible value to use for this purpose, because 126 and 127 are used by POSIX shells to signal specific error status (127 is for command not found, 126 is for command found but not executable--these details do not matter, as they are normal errors in the script, as far as `bisect run` is concerned)."
msgstr "当当前的源代码不能被测试时，应该使用特殊的退出代码 125。如果脚本以这个代码退出，当前的修订版将被跳过（见上面的 `git bisect skip`）。125 被选为用于此目的的最高合理值，因为 126 和 127 被 POSIX shells 用来表示特定的错误状态（127 表示未找到命令，126 表示找到命令但不可执行——这些细节并不重要，因为就 `bisect run` 而言，它们是脚本中的正常错误）。"

#. type: Plain text
#: en/git-bisect.txt:346
#, priority:100
msgid "You may often find that during a bisect session you want to have temporary modifications (e.g. s/#define DEBUG 0/#define DEBUG 1/ in a header file, or \"revision that does not have this commit needs this patch applied to work around another problem this bisection is not interested in\") applied to the revision being tested."
msgstr "你可能经常发现，在一个二分查找会话中，你想让临时的修改（例如，头文件中的 /#define DEBUG 0/#define DEBUG 1/，或者 “没有这个提交的版本需要应用这个补丁来解决这个查找不感兴趣的另一个问题”）应用到正在测试的版本中。"

#. type: Plain text
#: en/git-bisect.txt:354
#, priority:100
msgid "To cope with such a situation, after the inner 'git bisect' finds the next revision to test, the script can apply the patch before compiling, run the real test, and afterwards decide if the revision (possibly with the needed patch) passed the test and then rewind the tree to the pristine state.  Finally the script should exit with the status of the real test to let the `git bisect run` command loop determine the eventual outcome of the bisect session."
msgstr "为了应对这种情况，在内部的 'git bisect' 找到要测试的下一个修订版后，脚本可以在编译前应用补丁，运行真正的测试，之后决定该修订版（可能有需要的补丁）是否通过测试，然后将树倒回原始状态。 最后，脚本应该以真实测试的状态退出，让 `git bisect run` 命令循环决定二分查找会话的最终结果。"

#. type: Labeled list
#: en/git-bisect.txt:357 en/git-clone.txt:154
#, ignore-same, no-wrap, priority:300
msgid "--no-checkout"
msgstr "--no-checkout"

#. type: Plain text
#: en/git-bisect.txt:362
#, priority:100
msgid "Do not checkout the new working tree at each iteration of the bisection process. Instead just update a special reference named `BISECT_HEAD` to make it point to the commit that should be tested."
msgstr "在二分查找过程的每个迭代中，不要检出新的工作区。相反，只需更新一个名为 `BISECT_HEAD` 的特殊引用，使其指向应被测试的提交。"

#. type: Plain text
#: en/git-bisect.txt:365
#, priority:100
msgid "This option may be useful when the test you would perform in each step does not require a checked out tree."
msgstr "当你在每个步骤中执行的测试不需要检查出来的目录树时，这个选项可能很有用。"

#. type: Plain text
#: en/git-bisect.txt:367
#, priority:100
msgid "If the repository is bare, `--no-checkout` is assumed."
msgstr "如果版本库是裸仓库，则假定 `--no-checkout`。"

#. type: Plain text
#: en/git-bisect.txt:371
#, priority:100
msgid "Follow only the first parent commit upon seeing a merge commit."
msgstr "在看到合并提交时，只跟随第一个父提交。"

#. type: Plain text
#: en/git-bisect.txt:375
#, priority:100
msgid "In detecting regressions introduced through the merging of a branch, the merge commit will be identified as introduction of the bug and its ancestors will be ignored."
msgstr "在检测通过合并分支引入的回归时，合并后的提交将被识别为引入了该错误，其祖先将被忽略。"

#. type: Plain text
#: en/git-bisect.txt:378
#, priority:100
msgid "This option is particularly useful in avoiding false positives when a merged branch contained broken or non-buildable commits, but the merge itself was OK."
msgstr "这个选项在避免假阳性方面特别有用，当一个合并的分支包含有破损或不可构建的提交，但合并本身是正常的。"

#. type: Plain text
#: en/git-bisect.txt:383
#, priority:100
msgid "Automatically bisect a broken build between v1.2 and HEAD:"
msgstr "自动将 V1.2 和 HEAD 之间的破损构建二分查找："

#. type: delimited block -
#: en/git-bisect.txt:388
#, fuzzy, no-wrap, priority:100
msgid ""
"$ git bisect start HEAD v1.2 --      # HEAD is bad, v1.2 is good\n"
"$ git bisect run make                # \"make\" builds the app\n"
"$ git bisect reset                   # quit the bisect session\n"
msgstr ""
"$ git bisect start HEAD v1.2 --      # HEAD is bad, v1.2 is good\n"
"$ git bisect run make                # \"make\" builds the app\n"
"$ git bisect reset                   # quit the bisect session\n"

#. type: Plain text
#: en/git-bisect.txt:391
#, priority:100
msgid "Automatically bisect a test failure between origin and HEAD:"
msgstr "在起源和HEAD之间自动二分查找失败测试："

#. type: delimited block -
#: en/git-bisect.txt:396
#, fuzzy, no-wrap, priority:100
msgid ""
"$ git bisect start HEAD origin --    # HEAD is bad, origin is good\n"
"$ git bisect run make test           # \"make test\" builds and tests\n"
"$ git bisect reset                   # quit the bisect session\n"
msgstr ""
"$ git bisect start HEAD origin --    # HEAD is bad, origin is good\n"
"$ git bisect run make test           # \"make test\" builds and tests\n"
"$ git bisect reset                   # quit the bisect session\n"

#. type: Plain text
#: en/git-bisect.txt:399 en/git-bisect.txt:453
#, priority:100
msgid "Automatically bisect a broken test case:"
msgstr "自动二分查找错误的的测试用例："

#. type: delimited block -
#: en/git-bisect.txt:408
#, no-wrap, priority:100
msgid ""
"$ cat ~/test.sh\n"
"#!/bin/sh\n"
"make || exit 125                     # this skips broken builds\n"
"~/check_test_case.sh                 # does the test case pass?\n"
"$ git bisect start HEAD HEAD~10 --   # culprit is among the last 10\n"
"$ git bisect run ~/test.sh\n"
"$ git bisect reset                   # quit the bisect session\n"
msgstr ""
"$ cat ~/test.sh\n"
"#!/bin/sh\n"
"make || exit 125                     # 跳过了错误构建\n"
"~/check_test_case.sh                 # 测试案例是否通过？\n"
"$ git bisect start HEAD HEAD~10 --   # 罪魁祸首就在最后10个中\n"
"$ git bisect run ~/test.sh\n"
"$ git bisect reset                   # 退出二分查找会话\n"

#. type: Plain text
#: en/git-bisect.txt:414
#, priority:100
msgid "Here we use a `test.sh` custom script. In this script, if `make` fails, we skip the current commit.  `check_test_case.sh` should `exit 0` if the test case passes, and `exit 1` otherwise."
msgstr "这里我们使用一个 `test.sh `自定义脚本。在这个脚本中，如果 `make` 失败，我们就跳过当前的提交。 `check_test_case.sh` 如果测试用例通过，应该 `exit 0`，否则 `exit 1`。"

#. type: Plain text
#: en/git-bisect.txt:418
#, priority:100
msgid "It is safer if both `test.sh` and `check_test_case.sh` are outside the repository to prevent interactions between the bisect, make and test processes and the scripts."
msgstr "如果 `test.sh` 和 `check_test_case.sh `都在仓库之外，以防止 bisect、make 和 test 进程与脚本之间的相互作用，这样会更安全。"

#. type: Plain text
#: en/git-bisect.txt:420
#, priority:100
msgid "Automatically bisect with temporary modifications (hot-fix):"
msgstr "用临时修改的方式自动二分查找（热修复）："

#. type: delimited block -
#: en/git-bisect.txt:424
#, fuzzy, no-wrap, priority:100
msgid ""
"$ cat ~/test.sh\n"
"#!/bin/sh\n"
msgstr ""
"$ cat ~/test.sh\n"
"#!/bin/sh\n"

#. type: delimited block -
#: en/git-bisect.txt:437
#, no-wrap, priority:100
msgid ""
"# tweak the working tree by merging the hot-fix branch\n"
"# and then attempt a build\n"
"if\tgit merge --no-commit --no-ff hot-fix &&\n"
"\tmake\n"
"then\n"
"\t# run project specific test and report its status\n"
"\t~/check_test_case.sh\n"
"\tstatus=$?\n"
"else\n"
"\t# tell the caller this is untestable\n"
"\tstatus=125\n"
"fi\n"
msgstr ""
"# 通过合并热修复来调整工作区\n"
"# 然后尝试构建\n"
"if\tgit merge --no-commit --no-ff hot-fix &&\n"
"\tmake\n"
"then\n"
"\t# 运行项目特定的测试并报告其状态\n"
"\t~/check_test_case.sh\n"
"\tstatus=$?\n"
"else\n"
"\t# 告知发起进程这是不可测试的\n"
"\tstatus=125\n"
"fi\n"

#. type: delimited block -
#: en/git-bisect.txt:440
#, no-wrap, priority:100
msgid ""
"# undo the tweak to allow clean flipping to the next commit\n"
"git reset --hard\n"
msgstr ""
"# 撤销调整，以便干净利落地翻转到下一次提交\n"
"git reset --hard\n"

#. type: delimited block -
#: en/git-bisect.txt:443
#, no-wrap, priority:100
msgid ""
"# return control\n"
"exit $status\n"
msgstr ""
"# 交回控制权\n"
"exit $status\n"

#. type: Plain text
#: en/git-bisect.txt:451
#, priority:100
msgid "This applies modifications from a hot-fix branch before each test run, e.g. in case your build or test environment changed so that older revisions may need a fix which newer ones have already. (Make sure the hot-fix branch is based off a commit which is contained in all revisions which you are bisecting, so that the merge does not pull in too much, or use `git cherry-pick` instead of `git merge`.)"
msgstr "这是在每次测试前应用热修复分支的修改，例如，如果你的构建或测试环境发生变化，老版本可能需要一个新版本的修复。(确保热修复分支是基于一个包含在所有修订版中的提交，这样合并时就不会拉入太多，或者使用 `git cherry-pick` 代替 `git merge`。)"

#. type: delimited block -
#: en/git-bisect.txt:458
#, fuzzy, no-wrap, priority:100
msgid ""
"$ git bisect start HEAD HEAD~10 --   # culprit is among the last 10\n"
"$ git bisect run sh -c \"make || exit 125; ~/check_test_case.sh\"\n"
"$ git bisect reset                   # quit the bisect session\n"
msgstr ""
"$ git bisect start HEAD HEAD~10 --   # culprit is among the last 10\n"
"$ git bisect run sh -c \"make || exit 125; ~/check_test_case.sh\"\n"
"$ git bisect reset                   # quit the bisect session\n"

#. type: Plain text
#: en/git-bisect.txt:462
#, priority:100
msgid "This shows that you can do without a run script if you write the test on a single line."
msgstr "这表明，如果你把测试写在一行上，你可以不使用运行脚本。"

#. type: Plain text
#: en/git-bisect.txt:464
#, priority:100
msgid "Locate a good region of the object graph in a damaged repository"
msgstr "在受损的存储库中找到对象图的一个良好区域"

#. type: delimited block -
#: en/git-bisect.txt:474
#, ignore-ellipsis, no-wrap, priority:100
msgid ""
"$ git bisect start HEAD <known-good-commit> [ <boundary-commit> ... ] --no-checkout\n"
"$ git bisect run sh -c '\n"
"\tGOOD=$(git for-each-ref \"--format=%(objectname)\" refs/bisect/good-*) &&\n"
"\tgit rev-list --objects BISECT_HEAD --not $GOOD >tmp.$$ &&\n"
"\tgit pack-objects --stdout >/dev/null <tmp.$$\n"
"\trc=$?\n"
"\trm -f tmp.$$\n"
"\ttest $rc = 0'\n"
msgstr ""
"$ git bisect start HEAD <known-good-commit> [ <boundary-commit> ... ] --no-checkout\n"
"$ git bisect run sh -c '\n"
"\tGOOD=$(git for-each-ref \"--format=%(objectname)\" refs/bisect/good-*) &&\n"
"\tgit rev-list --objects BISECT_HEAD --not $GOOD >tmp.$$ &&\n"
"\tgit pack-objects --stdout >/dev/null <tmp.$$\n"
"\trc=$?\n"
"\trm -f tmp.$$\n"
"\ttest $rc = 0'\n"

#. type: delimited block -
#: en/git-bisect.txt:476
#, fuzzy, no-wrap, priority:100
msgid "$ git bisect reset                   # quit the bisect session\n"
msgstr "$ git bisect reset                   # quit the bisect session\n"

#. type: Plain text
#: en/git-bisect.txt:481
#, priority:100
msgid "In this case, when 'git bisect run' finishes, bisect/bad will refer to a commit that has at least one parent whose reachable graph is fully traversable in the sense required by 'git pack objects'."
msgstr "在这种情况下，当 'git bisect run' 完成时，bisect/bad 将指的是至少有一个父级的提交，其可达图在 'git pack objects' 的意义上是完全可穿越的。"

#. type: Plain text
#: en/git-bisect.txt:483
#, priority:100
msgid "Look for a fix instead of a regression in the code"
msgstr "在代码中寻找修复而不是回归的方法"

#. type: delimited block -
#: en/git-bisect.txt:488
#, fuzzy, no-wrap, priority:100
msgid ""
"$ git bisect start\n"
"$ git bisect new HEAD    # current commit is marked as new\n"
"$ git bisect old HEAD~10 # the tenth commit from now is marked as old\n"
msgstr ""
"$ git bisect start\n"
"$ git bisect new HEAD    # current commit is marked as new\n"
"$ git bisect old HEAD~10 # the tenth commit from now is marked as old\n"

#. type: Plain text
#: en/git-bisect.txt:491
#, priority:100
msgid "or:"
msgstr "或："

#. type: delimited block -
#: en/git-bisect.txt:495
#, fuzzy, no-wrap, priority:100
msgid ""
"$ git bisect start --term-old broken --term-new fixed\n"
"$ git bisect fixed\n"
"$ git bisect broken HEAD~10\n"
msgstr ""
"$ git bisect start --term-old broken --term-new fixed\n"
"$ git bisect fixed\n"
"$ git bisect broken HEAD~10\n"

#. type: Title ~
#: en/git-bisect.txt:498
#, no-wrap, priority:100
msgid "Getting help"
msgstr "获得帮助"

#. type: Plain text
#: en/git-bisect.txt:502
#, priority:100
msgid "Use `git bisect` to get a short usage description, and `git bisect help` or `git bisect -h` to get a long usage description."
msgstr "使用 `git bisect` 获得简短的使用说明，使用 `git bisect help` 或 `git bisect -h` 获得长的使用说明。"

#. type: Plain text
#: en/git-bisect.txt:507
#, priority:100
msgid "link:git-bisect-lk2009.html[Fighting regressions with git bisect], linkgit:git-blame[1]."
msgstr "link:git-bisect-lk2009.html [用 git bisect 对抗回归]，linkgit:git-blame[1]。"

#. type: Title =
#: en/git-blame.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-blame(1)"
msgstr "git-blame(1)"

#. type: Plain text
#: en/git-blame.txt:7
#, fuzzy, priority:100
msgid "git-blame - Show what revision and author last modified each line of a file"
msgstr "git-blame - Show what revision and author last modified each line of a file"

#. type: Plain text
#: en/git-blame.txt:16
#, fuzzy, no-wrap, priority:100
msgid ""
"'git blame' [-c] [-b] [-l] [--root] [-t] [-f] [-n] [-s] [-e] [-p] [-w] [--incremental]\n"
"\t    [-L <range>] [-S <revs-file>] [-M] [-C] [-C] [-C] [--since=<date>]\n"
"\t    [--ignore-rev <rev>] [--ignore-revs-file <file>]\n"
"\t    [--color-lines] [--color-by-age] [--progress] [--abbrev=<n>]\n"
"\t    [ --contents <file> ] [<rev> | --reverse <rev>..<rev>] [--] <file>\n"
msgstr ""
"'git blame' [-c] [-b] [-l] [--root] [-t] [-f] [-n] [-s] [-e] [-p] [-w] [--incremental]\n"
"\t    [-L <范围i>] [-S <revs-file>] [-M] [-C] [-C] [-C] [--since=<日期>]\n"
"\t    [--ignore-rev <rev>] [--ignore-revs-file <文件>]\n"
"\t    [--color-lines] [--color-by-age] [--progress] [--abbrev=<n>]\n"
"\t    [ --contents <文件> ] [<rev> | --reverse <rev>..<rev>] [--] <文件>\n"

#. type: Plain text
#: en/git-blame.txt:22
#, priority:100
msgid "Annotates each line in the given file with information from the revision which last modified the line. Optionally, start annotating from the given revision."
msgstr "用最后一次修改该行的修订版的信息来注释给定文件中的每一行。可以选择从给定的修订版开始做注释。"

#. type: Plain text
#: en/git-blame.txt:25
#, priority:100
msgid "When specified one or more times, `-L` restricts annotation to the requested lines."
msgstr "当指定一次或多次时，`-L` 将注释限制在要求的行中。"

#. type: Plain text
#: en/git-blame.txt:31
#, priority:100
msgid "The origin of lines is automatically followed across whole-file renames (currently there is no option to turn the rename-following off). To follow lines moved from one file to another, or to follow lines that were copied and pasted from another file, etc., see the `-C` and `-M` options."
msgstr "在整个文件的重命名过程中，行的起源被自动跟踪（目前没有选项可以关闭重命名跟踪）。要跟踪从一个文件移到另一个文件的行，或者跟踪从另一个文件复制和粘贴的行，等等，请参见 `-C` 和 `-M` 选项。"

#. type: Plain text
#: en/git-blame.txt:35
#, priority:100
msgid "The report does not tell you anything about lines which have been deleted or replaced; you need to use a tool such as 'git diff' or the \"pickaxe\" interface briefly mentioned in the following paragraph."
msgstr "报告不会告诉你任何关于被删除或替换的行的信息；你需要使用一个工具，如 'git diff' 或下段中简要提到的 'pickaxe' 接口。"

#. type: Plain text
#: en/git-blame.txt:42
#, priority:100
msgid "Apart from supporting file annotation, Git also supports searching the development history for when a code snippet occurred in a change. This makes it possible to track when a code snippet was added to a file, moved or copied between files, and eventually deleted or replaced. It works by searching for a text string in the diff. A small example of the pickaxe interface that searches for `blame_usage`:"
msgstr "除了支持文件注释外，Git 还支持在开发历史中搜索代码片段何时发生变化。这使得追踪一个代码片段何时被添加到一个文件，在文件之间移动或复制，以及最终被删除或替换成为可能。它的工作原理是在差异中搜索一个文本字符串。一个搜索 `blame_usage` 的 pickaxe 界面的小例子："

#. type: delimited block -
#: en/git-blame.txt:47
#, fuzzy, no-wrap, priority:100
msgid ""
"$ git log --pretty=oneline -S'blame_usage'\n"
"5040f17eba15504bad66b14a645bddd9b015ebb7 blame -S <ancestry-file>\n"
"ea4c7f9bf69e781dd0cd88d2bccb2bf5cc15c9a7 git-blame: Make the output\n"
msgstr ""
"$ git log --pretty=oneline -S'blame_usage'\n"
"5040f17eba15504bad66b14a645bddd9b015ebb7 blame -S <ancestry-file>\n"
"ea4c7f9bf69e781dd0cd88d2bccb2bf5cc15c9a7 git-blame: Make the output\n"

#. type: Plain text
#: en/git-blame.txt:55
#, fuzzy, priority:100
msgid "Use the same output mode as linkgit:git-annotate[1] (Default: off)."
msgstr "git-annotate"

#. type: Labeled list
#: en/git-blame.txt:56
#, ignore-same, no-wrap, priority:100
msgid "--score-debug"
msgstr "--score-debug"

#. type: Plain text
#: en/git-blame.txt:64
#, priority:100
msgid "Include debugging information related to the movement of lines between files (see `-C`) and lines moved within a file (see `-M`).  The first number listed is the score.  This is the number of alphanumeric characters detected as having been moved between or within files.  This must be above a certain threshold for 'git blame' to consider those lines of code to have been moved."
msgstr "包括与文件之间行的移动（见 `-C`）和文件内行的移动（见 `-M`）有关的调试信息。 列出的第一个数字是分数。 这是检测到的在文件间或文件内移动的字母数字字符的数量。 这个数字必须超过一定的阈值，'git blame' 才会认为这些代码行被移动了。"

#. type: Labeled list
#: en/git-blame.txt:66
#, ignore-same, no-wrap, priority:100
msgid "--show-name"
msgstr "--show-name"

#. type: Plain text
#: en/git-blame.txt:70
#, priority:100
msgid "Show the filename in the original commit.  By default the filename is shown if there is any line that came from a file with a different name, due to rename detection."
msgstr "显示原始提交中的文件名。 默认情况下，如果有任何一行来自不同名字的文件，由于重名检测，文件名会显示出来。"

#. type: Labeled list
#: en/git-blame.txt:72
#, ignore-same, no-wrap, priority:100
msgid "--show-number"
msgstr "--show-number"

#. type: Plain text
#: en/git-blame.txt:74
#, priority:100
msgid "Show the line number in the original commit (Default: off)."
msgstr "显示原始提交中的行号（默认：off）。"

#. type: Plain text
#: en/git-blame.txt:77
#, priority:100
msgid "Suppress the author name and timestamp from the output."
msgstr "抑制输出中的作者姓名和时间戳。"

#. type: Labeled list
#: en/git-blame.txt:79
#, ignore-same, no-wrap, priority:100
msgid "--show-email"
msgstr "--show-email"

#. type: Plain text
#: en/git-blame.txt:83
#, priority:100
msgid "Show the author email instead of author name (Default: off).  This can also be controlled via the `blame.showEmail` config option."
msgstr "显示作者的电子邮件而不是作者的名字（默认：off）。 这也可以通过 `blame.showEmail` 配置选项来控制。"

#. type: Plain text
#: en/git-blame.txt:87
#, priority:100
msgid "Ignore whitespace when comparing the parent's version and the child's to find where the lines came from."
msgstr "在比较父本和子本的版本时，忽略空白，以找到行的来源。"

#. type: Labeled list
#: en/git-blame.txt:88 en/git-branch.txt:207 en/git-describe.txt:65
#, fuzzy, no-wrap, priority:260
msgid "--abbrev=<n>"
msgstr "--abbrev=<n>"

#. type: Plain text
#: en/git-blame.txt:94
#, priority:100
msgid "Instead of using the default 7+1 hexadecimal digits as the abbreviated object name, use <m>+1 digits, where <m> is at least <n> but ensures the commit object names are unique.  Note that 1 column is used for a caret to mark the boundary commit."
msgstr "不要使用默认的7+1个十六进制数字作为对象的缩写，而是使用 <m>+1 个数字，其中 <m> 至少是 <n>，但确保提交对象的名称是唯一的。 请注意，有1列是用来标记边界提交的关健词。"

#. type: Title -
#: en/git-blame.txt:97
#, fuzzy, no-wrap, priority:100
msgid "THE DEFAULT FORMAT"
msgstr "日期格式"

#. type: Plain text
#: en/git-blame.txt:101
#, priority:100
msgid "When neither `--porcelain` nor `--incremental` option is specified, `git blame` will output annotation for each line with:"
msgstr "当既没有指定`--porcelain` 也没有指定`--incremental` 选项时，`git blame` 将为每一行输出注释："

#. type: Plain text
#: en/git-blame.txt:103
#, priority:100
msgid "abbreviated object name for the commit the line came from;"
msgstr "该行来自的提交的缩写对象名称；"

#. type: Plain text
#: en/git-blame.txt:105
#, priority:100
msgid "author ident (by default author name and date, unless `-s` or `-e` is specified); and"
msgstr "作者身份（默认为作者姓名和日期，除非指定`s`或`e`）；以及"

#. type: Plain text
#: en/git-blame.txt:106
#, fuzzy, priority:100
#| msgid "--line-number"
msgid "line number"
msgstr "--line-number"

#. type: Plain text
#: en/git-blame.txt:108
#, priority:100
msgid "before the line contents."
msgstr "在该行内容之前。"

#. type: Title -
#: en/git-blame.txt:110
#, no-wrap, priority:100
msgid "THE PORCELAIN FORMAT"
msgstr "上层命令格式"

#. type: Plain text
#: en/git-blame.txt:114
#, priority:100
msgid "In this format, each line is output after a header; the header at the minimum has the first line which has:"
msgstr "在这种格式中，每一行都是在页眉之后输出的；页眉至少有第一行，它有："

#. type: Plain text
#: en/git-blame.txt:116
#, priority:100
msgid "40-byte SHA-1 of the commit the line is attributed to;"
msgstr "该行所归属的提交的 40 字节 SHA-1；"

#. type: Plain text
#: en/git-blame.txt:117
#, priority:100
msgid "the line number of the line in the original file;"
msgstr "原始文件中该行的行号；"

#. type: Plain text
#: en/git-blame.txt:118
#, priority:100
msgid "the line number of the line in the final file;"
msgstr "最后文件中该行的行号；"

#. type: Plain text
#: en/git-blame.txt:121
#, priority:100
msgid "on a line that starts a group of lines from a different commit than the previous one, the number of lines in this group.  On subsequent lines this field is absent."
msgstr "在开始一组与前一次不同的提交的行上，该组的行数。 在随后的行中，这个字段是不存在的。"

#. type: Plain text
#: en/git-blame.txt:124
#, priority:100
msgid "This header line is followed by the following information at least once for each commit:"
msgstr "这个标题行后面是以下信息，每次提交至少有一次："

#. type: Plain text
#: en/git-blame.txt:128
#, priority:100
msgid "the author name (\"author\"), email (\"author-mail\"), time (\"author-time\"), and time zone (\"author-tz\"); similarly for committer."
msgstr "作者姓名（\"author\"）、电子邮件（\"author-mail\"）、时间（\"author-time\"）和时区（\"author-tz\"）；对提交者也是如此。"

#. type: Plain text
#: en/git-blame.txt:129
#, priority:100
msgid "the filename in the commit that the line is attributed to."
msgstr "该行归属的提交中的文件名。"

#. type: Plain text
#: en/git-blame.txt:130
#, priority:100
msgid "the first line of the commit log message (\"summary\")."
msgstr "提交日志信息的第一行（\"摘要\"）。"

#. type: Plain text
#: en/git-blame.txt:134
#, priority:100
msgid "The contents of the actual line is output after the above header, prefixed by a TAB. This is to allow adding more header elements later."
msgstr "实际行的内容会在上述标题之后输出，前缀为 TAB。这是为了允许以后添加更多的标题元素。"

#. type: Plain text
#: en/git-blame.txt:142
#, priority:100
msgid "The porcelain format generally suppresses commit information that has already been seen. For example, two lines that are blamed to the same commit will both be shown, but the details for that commit will be shown only once. This is more efficient, but may require more state be kept by the reader. The `--line-porcelain` option can be used to output full commit information for each line, allowing simpler (but less efficient)  usage like:"
msgstr "上层命令格式通常会抑制已经看过的提交信息。例如，两行归咎于同一个提交的内容都会被显示出来，但该提交的细节只会被显示一次。这样做更有效率，但可能需要读者保存更多的状态："

#. type: Plain text
#: en/git-blame.txt:147
#, no-wrap, priority:100
msgid ""
"\t# count the number of lines attributed to each author\n"
"\tgit blame --line-porcelain file |\n"
"\tsed -n 's/^author //p' |\n"
"\tsort | uniq -c | sort -rn\n"
msgstr ""
"\t# count the number of lines attributed to each author\n"
"\tgit blame --line-porcelain file |\n"
"\tsed -n 's/^author //p' |\n"
"\tsort | uniq -c | sort -rn\n"

#. type: Title -
#: en/git-blame.txt:150 en/revisions.txt:265
#, no-wrap, priority:100
msgid "SPECIFYING RANGES"
msgstr "指定范围"

#. type: Plain text
#: en/git-blame.txt:156
#, priority:100
msgid "Unlike 'git blame' and 'git annotate' in older versions of git, the extent of the annotation can be limited to both line ranges and revision ranges. The `-L` option, which limits annotation to a range of lines, may be specified multiple times."
msgstr "与旧版本的 \"git blame\" 和 \"git annotate\" 不同，注释的范围可以限制在行的范围和修订范围。`-L` 选项将注释限制在一个行的范围内，可以多次指定。"

#. type: Plain text
#: en/git-blame.txt:161
#, priority:100
msgid "When you are interested in finding the origin for lines 40-60 for file `foo`, you can use the `-L` option like so (they mean the same thing -- both ask for 21 lines starting at line 40):"
msgstr "当你对查找文件 `foo` 的第 40-60 行的原点感兴趣时，你可以像这样使用 `-L` 选项（它们的意思是一样的--都要求从第 40 行开始的 21 行）："

#. type: Plain text
#: en/git-blame.txt:164
#, fuzzy, no-wrap, priority:100
msgid ""
"\tgit blame -L 40,60 foo\n"
"\tgit blame -L 40,+21 foo\n"
msgstr ""
"\tgit blame -L 40,60 foo\n"
"\tgit blame -L 40,+21 foo\n"

#. type: Plain text
#: en/git-blame.txt:166
#, priority:100
msgid "Also you can use a regular expression to specify the line range:"
msgstr "你也可以使用正则表达式来指定行的范围："

#. type: Plain text
#: en/git-blame.txt:168
#, fuzzy, no-wrap, priority:100
msgid "\tgit blame -L '/^sub hello {/,/^}$/' foo\n"
msgstr "\tgit blame -L '/^sub hello {/,/^}$/' foo\n"

#. type: Plain text
#: en/git-blame.txt:170
#, priority:100
msgid "which limits the annotation to the body of the `hello` subroutine."
msgstr "它将注释限制在 `hello` 子程序的主体中。"

#. type: Plain text
#: en/git-blame.txt:174
#, priority:100
msgid "When you are not interested in changes older than version v2.6.18, or changes older than 3 weeks, you can use revision range specifiers similar to 'git rev-list':"
msgstr "当你对超过 v2.6.18 版本的修改不感兴趣，或者超过 3 周的修改不感兴趣时，你可以使用类似于 `git rev-list` 的修订范围指定器："

#. type: Plain text
#: en/git-blame.txt:177
#, fuzzy, no-wrap, priority:100
msgid ""
"\tgit blame v2.6.18.. -- foo\n"
"\tgit blame --since=3.weeks -- foo\n"
msgstr ""
"\tgit blame v2.6.18.. -- foo\n"
"\tgit blame --since=3.weeks -- foo\n"

#. type: Plain text
#: en/git-blame.txt:183
#, priority:100
msgid "When revision range specifiers are used to limit the annotation, lines that have not changed since the range boundary (either the commit v2.6.18 or the most recent commit that is more than 3 weeks old in the above example) are blamed for that range boundary commit."
msgstr "当修订范围指定符被用来限制注释时，自范围边界（在上面的例子中，提交 v2.6.18 或超过 3 周的最新提交）以来没有改变的行被指责为该范围边界提交。"

#. type: Plain text
#: en/git-blame.txt:189
#, priority:100
msgid "A particularly useful way is to see if an added file has lines created by copy-and-paste from existing files.  Sometimes this indicates that the developer was being sloppy and did not refactor the code properly.  You can first find the commit that introduced the file with:"
msgstr "一个特别有用的方法是看一个新增的文件是否有从现有文件中复制和粘贴的行。 有时，这表明开发人员很马虎，没有正确地重构代码。 你可以首先找到引入该文件的提交："

#. type: Plain text
#: en/git-blame.txt:191
#, no-wrap, priority:100
msgid "\tgit log --diff-filter=A --pretty=short -- foo\n"
msgstr "\tgit log --diff-filter=A --pretty=short -- foo\n"

#. type: Plain text
#: en/git-blame.txt:194
#, priority:100
msgid "and then annotate the change between the commit and its parents, using `commit^!` notation:"
msgstr "然后用 'commit^!' 符号来注释该提交和其父辈之间的变化："

#. type: Plain text
#: en/git-blame.txt:196
#, no-wrap, priority:100
msgid "\tgit blame -C -C -f $commit^! -- foo\n"
msgstr "\tgit blame -C -C -f $commit^! -- foo\n"

#. type: Title -
#: en/git-blame.txt:199
#, no-wrap, priority:100
msgid "INCREMENTAL OUTPUT"
msgstr "增量输出"

#. type: Plain text
#: en/git-blame.txt:206
#, priority:100
msgid "When called with `--incremental` option, the command outputs the result as it is built.  The output generally will talk about lines touched by more recent commits first (i.e. the lines will be annotated out of order) and is meant to be used by interactive viewers."
msgstr "当调用 `--incremental` 选项时，该命令在构建过程中输出结果。 一般来说，输出结果会先谈及最近提交的行（也就是说，这些行会被不按顺序的注释），并且是为了给交互式浏览者使用。"

#. type: Plain text
#: en/git-blame.txt:210
#, priority:100
msgid "The output format is similar to the Porcelain format, but it does not contain the actual lines from the file that is being annotated."
msgstr "输出格式类似于上层命令格式，但它不包含被注释的文件的实际行数。"

#. type: Plain text
#: en/git-blame.txt:212
#, priority:100
msgid "Each blame entry always starts with a line of:"
msgstr "每个历史追溯条目总是以一行字开始："

#. type: Plain text
#: en/git-blame.txt:214
#, fuzzy, no-wrap, priority:100
msgid "<40-byte hex sha1> <sourceline> <resultline> <num_lines>\n"
msgstr "<40-byte hex sha1> <sourceline> <resultline> <num_lines>\n"

#. type: Plain text
#: en/git-blame.txt:216
#, priority:100
msgid "Line numbers count from 1."
msgstr "行数从 1 开始计算。"

#. type: Plain text
#: en/git-blame.txt:221
#, priority:100
msgid "The first time that a commit shows up in the stream, it has various other information about it printed out with a one-word tag at the beginning of each line describing the extra commit information (author, email, committer, dates, summary, etc.)."
msgstr "当一个提交首次出现在数据流中时，它的各种其他信息会被打印出来，每一行的开头都有一个单字标签，描述额外的提交信息（作者、电子邮件、提交者、日期、摘要等）。"

#. type: Plain text
#: en/git-blame.txt:224
#, priority:100
msgid "Unlike the Porcelain format, the filename information is always given and terminates the entry:"
msgstr "与上层命令格式不同，文件名信息总是给定的，并终止条目："

#. type: Plain text
#: en/git-blame.txt:226
#, no-wrap, priority:100
msgid "\"filename\" <whitespace-quoted-filename-goes-here>\n"
msgstr "\"filename\" <whitespace-quoted-filename-goes-here>\n"

#. type: Plain text
#: en/git-blame.txt:229
#, priority:100
msgid "and thus it is really quite easy to parse for some line- and word-oriented parser (which should be quite natural for most scripting languages)."
msgstr "因此，对于一些面向行和字的解析器来说，它确实很容易解析（这对于大多数脚本语言来说应该是很自然的）。"

#. type: Plain text
#: en/git-blame.txt:237
#, priority:100
msgid "For people who do parsing: to make it more robust, just ignore any lines between the first and last one (\"<sha1>\" and \"filename\" lines)  where you do not recognize the tag words (or care about that particular one) at the beginning of the \"extended information\" lines. That way, if there is ever added information (like the commit encoding or extended commit commentary), a blame viewer will not care."
msgstr "对于做解析的人来说：为了使它更健壮，只要忽略第一和最后一个（\"<sha1>\" 和 \"filename\" 行）之间的任何行，在 \"扩展信息\" 行的开头，你不认识标签词（或关心那个特定的）。这样一来，如果有一天增加了信息（比如提交编码或扩展的提交注释），历史追溯查看者就不会在意。"

#. type: Title -
#: en/git-blame.txt:240 en/git-check-mailmap.txt:47 en/git-shortlog.txt:120
#, no-wrap, priority:260
msgid "MAPPING AUTHORS"
msgstr "制图作者"

#. type: Plain text
#: en/git-blame.txt:243 en/git-check-mailmap.txt:50 en/git-shortlog.txt:123
#, fuzzy, priority:260
msgid "See linkgit:gitmailmap[5]."
msgstr "linkgit:git-add[1]"

#. type: Title =
#: en/git-branch.txt:2
#, ignore-same, no-wrap, priority:260
msgid "git-branch(1)"
msgstr "git-branch(1)"

#. type: Plain text
#: en/git-branch.txt:7
#, priority:260
msgid "git-branch - List, create, or delete branches"
msgstr "git-branch - 列出、创建或删除分支"

#. type: Plain text
#: en/git-branch.txt:27
#, ignore-ellipsis, no-wrap, priority:260
msgid ""
"'git branch' [--color[=<when>] | --no-color] [--show-current]\n"
"\t[-v [--abbrev=<n> | --no-abbrev]]\n"
"\t[--column[=<options>] | --no-column] [--sort=<key>]\n"
"\t[--merged [<commit>]] [--no-merged [<commit>]]\n"
"\t[--contains [<commit>]] [--no-contains [<commit>]]\n"
"\t[--points-at <object>] [--format=<format>]\n"
"\t[(-r | --remotes) | (-a | --all)]\n"
"\t[--list] [<pattern>...]\n"
"'git branch' [--track[=(direct|inherit)] | --no-track] [-f]\n"
"\t[--recurse-submodules] <branchname> [<start-point>]\n"
"'git branch' (--set-upstream-to=<upstream> | -u <upstream>) [<branchname>]\n"
"'git branch' --unset-upstream [<branchname>]\n"
"'git branch' (-m | -M) [<oldbranch>] <newbranch>\n"
"'git branch' (-c | -C) [<oldbranch>] <newbranch>\n"
"'git branch' (-d | -D) [-r] <branchname>...\n"
"'git branch' --edit-description [<branchname>]\n"
msgstr ""
"'git branch' [--color[=<when>] | --no-color] [--show-current]\n"
"\t[-v [--abbrev=<n> | --no-abbrev]]\n"
"\t[--column[=<options>] | --no-column] [--sort=<key>]\n"
"\t[--merged [<commit>]] [--no-merged [<commit>]]\n"
"\t[--contains [<commit>]] [--no-contains [<commit>]]\n"
"\t[--points-at <object>] [--format=<format>]\n"
"\t[(-r | --remotes) | (-a | --all)]\n"
"\t[--list] [<pattern>...]\n"
"'git branch' [--track[=(direct|inherit)] | --no-track] [-f]\n"
"\t[--recurse-submodules] <分支名> [<起始点>]\n"
"'git branch' (--set-upstream-to=<上游> | -u <上游>) [<分支名>]\n"
"'git branch' --unset-upstream [<分支名>]\n"
"'git branch' (-m | -M) [<旧分支>] <新分支>\n"
"'git branch' (-c | -C) [<旧分支>] <新分支>\n"
"'git branch' (-d | -D) [-r] <分支名>...\n"
"'git branch' --edit-description [<分支名>]\n"

#. type: Plain text
#: en/git-branch.txt:37
#, priority:260
msgid "If `--list` is given, or if there are no non-option arguments, existing branches are listed; the current branch will be highlighted in green and marked with an asterisk.  Any branches checked out in linked worktrees will be highlighted in cyan and marked with a plus sign. Option `-r` causes the remote-tracking branches to be listed, and option `-a` shows both local and remote branches."
msgstr "如果给了`--list`，或者没有非选项参数，现有的分支将被列出；当前的分支将以绿色突出显示，并标有星号。  在链接的工作树中检查出来的任何分支将以青色突出显示，并标有加号。选项`-r`导致远程跟踪的分支被列出，选项`-a`显示本地和远程分支。"

#. type: Plain text
#: en/git-branch.txt:42
#, priority:260
msgid "If a `<pattern>` is given, it is used as a shell wildcard to restrict the output to matching branches. If multiple patterns are given, a branch is shown if it matches any of the patterns."
msgstr "如果给出了`<pattern>`，它被用作shell通配符，将输出限制在匹配的分支上。如果给出多个模式，如果一个分支与任何模式相匹配，就会显示出来。"

#. type: Plain text
#: en/git-branch.txt:46
#, priority:260
msgid "Note that when providing a `<pattern>`, you must use `--list`; otherwise the command may be interpreted as branch creation."
msgstr "注意，当提供\"<pattern>\"时，必须使用\"--list\"；否则命令可能被解释为创建分支。"

#. type: Plain text
#: en/git-branch.txt:55
#, priority:260
msgid "With `--contains`, shows only the branches that contain the named commit (in other words, the branches whose tip commits are descendants of the named commit), `--no-contains` inverts it. With `--merged`, only branches merged into the named commit (i.e. the branches whose tip commits are reachable from the named commit) will be listed.  With `--no-merged` only branches not merged into the named commit will be listed.  If the <commit> argument is missing it defaults to `HEAD` (i.e. the tip of the current branch)."
msgstr "使用 `--contains` 时，只显示包含指定提交的分支（换句话说，尖端提交是指定提交的后裔的分支），`--no-contains` 会反过来。如果使用 `--merged`，则只列出被合并到指定提交的分支（即其顶端提交可以从指定提交处到达的分支）。  如果使用\"--no-merged\"，则只列出未被合并到指定提交的分支。  如果缺少<commit>参数，则默认为`HEAD`（即当前分支的顶端）。"

#. type: Plain text
#: en/git-branch.txt:62
#, ignore-ellipsis, priority:260
msgid "The command's second form creates a new branch head named <branchname> which points to the current `HEAD`, or <start-point> if given. As a special case, for <start-point>, you may use `\"A...B\"` as a shortcut for the merge base of `A` and `B` if there is exactly one merge base. You can leave out at most one of `A` and `B`, in which case it defaults to `HEAD`."
msgstr "该命令的第二种形式是创建一个名为<branchname>的新分支头，该分支头指向当前的`HEAD`，如果给定的话，则指向<start-point>。作为一种特殊情况，对于<start-point>，你可以使用`\"A...B \"作为`A`和`B`的合并基础的快捷方式，如果正好有一个合并基础。你最多可以省略`A`和`B`中的一个，在这种情况下，它默认为`HEAD`。"

#. type: Plain text
#: en/git-branch.txt:66
#, priority:260
msgid "Note that this will create the new branch, but it will not switch the working tree to it; use \"git switch <newbranch>\" to switch to the new branch."
msgstr "注意，这将创建新的分支，但不会将工作树切换到它；使用 \"git switch <newbranch>\"来切换到新的分支。"

#. type: Plain text
#: en/git-branch.txt:74
#, priority:260
msgid "When a local branch is started off a remote-tracking branch, Git sets up the branch (specifically the `branch.<name>.remote` and `branch.<name>.merge` configuration entries) so that 'git pull' will appropriately merge from the remote-tracking branch. This behavior may be changed via the global `branch.autoSetupMerge` configuration flag. That setting can be overridden by using the `--track` and `--no-track` options, and changed later using `git branch --set-upstream-to`."
msgstr "当一个本地分支从远程跟踪的分支开始时，Git 会设置该分支（特别是 `branch.<name>.remote` 和 `branch.<name>.merge` 配置项），以便 \"git pull \"能适当地从远程跟踪的分支合并。这种行为可以通过全局的 `branch.autoSetupMerge` 配置标志来改变。该设置可以通过使用`--track`和`--no-track`选项来覆盖，并在之后使用`git branch --set-upstream-to`来改变。"

#. type: Plain text
#: en/git-branch.txt:80
#, priority:260
msgid "With a `-m` or `-M` option, <oldbranch> will be renamed to <newbranch>.  If <oldbranch> had a corresponding reflog, it is renamed to match <newbranch>, and a reflog entry is created to remember the branch renaming. If <newbranch> exists, -M must be used to force the rename to happen."
msgstr "使用`-m`或`-M`选项，<oldbranch>将被重命名为<newbranch>。  如果 <oldbranch> 有相应的 reflog，它将被重命名以匹配 <newbranch>，并创建一个 reflog 条目以记住分支重命名。如果 <newbranch> 存在，必须使用 -M 来强制重命名。"

#. type: Plain text
#: en/git-branch.txt:84
#, priority:260
msgid "The `-c` and `-C` options have the exact same semantics as `-m` and `-M`, except instead of the branch being renamed, it will be copied to a new name, along with its config and reflog."
msgstr "`-c`和`-C`选项的语义与`-m`和`-M`完全相同，只不过不是对分支进行重命名，而是将其连同其配置和日志一起复制到一个新的名称。"

#. type: Plain text
#: en/git-branch.txt:88
#, priority:260
msgid "With a `-d` or `-D` option, `<branchname>` will be deleted.  You may specify more than one branch for deletion.  If the branch currently has a reflog then the reflog will also be deleted."
msgstr "使用`-d`或`-D`选项，`<branchname>`将被删除。  你可以指定一个以上的分支进行删除。  如果该分支目前有一个reflog，那么reflog也将被删除。"

#. type: Plain text
#: en/git-branch.txt:94
#, priority:260
msgid "Use `-r` together with `-d` to delete remote-tracking branches. Note, that it only makes sense to delete remote-tracking branches if they no longer exist in the remote repository or if 'git fetch' was configured not to fetch them again. See also the 'prune' subcommand of linkgit:git-remote[1] for a way to clean up all obsolete remote-tracking branches."
msgstr "使用 `-r` 和 `-d` 来删除远程跟踪的分支。注意，只有当远程分支不再存在于远程仓库或 \"git fetch \"被配置为不再获取它们时，删除远程跟踪分支才有意义。参见 linkgit:git-remote[1] 的 \"prune \"子命令，它可以清理所有过时的远程跟踪分支。"

#. type: Labeled list
#: en/git-branch.txt:98 en/git-checkout.txt:207 en/git-clean.txt:28 en/git-cvsexportcommit.txt:49 en/git-difftool.txt:22 en/git-http-push.txt:44 en/git-instaweb.txt:27 en/git-ls-files.txt:44 en/git-ls-tree.txt:41 en/git-push.txt:182 en/git-repack.txt:60 en/git-replace.txt:65 en/git-show-ref.txt:47 en/git-switch.txt:81 en/git-symbolic-ref.txt:35 en/git-tag.txt:83 en/git-worktree.txt:198
#, ignore-same, no-wrap, priority:260
msgid "-d"
msgstr "-d"

#. type: Labeled list
#: en/git-branch.txt:99 en/git-push.txt:183 en/git-replace.txt:66 en/git-symbolic-ref.txt:36 en/git-tag.txt:84
#, ignore-same, no-wrap, priority:260
msgid "--delete"
msgstr "--delete"

#. type: Plain text
#: en/git-branch.txt:103
#, priority:260
msgid "Delete a branch. The branch must be fully merged in its upstream branch, or in `HEAD` if no upstream was set with `--track` or `--set-upstream-to`."
msgstr "删除一个分支。该分支必须完全合并在其上游分支中，如果没有用`--track`或`--set-upstream-to`设置的上游分支，则必须在`HEAD`中。"

#. type: Plain text
#: en/git-branch.txt:106
#, priority:260
msgid "Shortcut for `--delete --force`."
msgstr "`--delete --force`的快捷方式。"

#. type: Labeled list
#: en/git-branch.txt:107 en/git-tag.txt:194
#, ignore-same, no-wrap, priority:260
msgid "--create-reflog"
msgstr "--create-reflog"

#. type: Plain text
#: en/git-branch.txt:116
#, priority:260
msgid "Create the branch's reflog.  This activates recording of all changes made to the branch ref, enabling use of date based sha1 expressions such as \"<branchname>@\\{yesterday}\".  Note that in non-bare repositories, reflogs are usually enabled by default by the `core.logAllRefUpdates` config option.  The negated form `--no-create-reflog` only overrides an earlier `--create-reflog`, but currently does not negate the setting of `core.logAllRefUpdates`."
msgstr "创建该分支的 reflog。  这将激活对该分支参考文献所做的所有修改的记录，使其能够使用基于日期的sha1表达式，如\"<branchname>@{yesterday}\"。  请注意，在非空白仓库中， reflogs通常由`core.logAllRefUpdates`配置选项默认启用。  否定的形式`--no-create-reflog`只覆盖先前的`--create-reflog`，但目前并不否定`core.logAllRefUpdates`的设置。"

#. type: Plain text
#: en/git-branch.txt:126
#, fuzzy, priority:260
#| msgid "Reset <branchname> to <startpoint>, even if <branchname> exists already. Without `-f`, 'git branch' refuses to change an existing branch.  In combination with `-d` (or `--delete`), allow deleting the branch irrespective of its merged status. In combination with `-m` (or `--move`), allow renaming the branch even if the new branch name already exists, the same applies for `-c` (or `--copy`)."
msgid "Reset <branchname> to <start-point>, even if <branchname> exists already. Without `-f`, 'git branch' refuses to change an existing branch.  In combination with `-d` (or `--delete`), allow deleting the branch irrespective of its merged status, or whether it even points to a valid commit. In combination with `-m` (or `--move`), allow renaming the branch even if the new branch name already exists, the same applies for `-c` (or `--copy`)."
msgstr "将 <branchname> 重置为 <startpoint>，即使 <branchname> 已经存在。如果没有 `-f`，'git branch'拒绝改变现有的分支。  与 `-d` (或 `--delete`) 结合，允许删除该分支，而不管其合并状态如何。与`-m`（或`--move`）结合，允许重命名分支，即使新的分支名称已经存在，同样适用于`-c`（或`--copy`）。"

#. type: Plain text
#: en/git-branch.txt:130
#, priority:260
msgid "Note that 'git branch -f <branchname> [<start-point>]', even with '-f', refuses to change an existing branch `<branchname>` that is checked out in another worktree linked to the same repository."
msgstr "请注意，\"git branch -f <branchname> [<start-point>]\"命令，即使添加\"-f\"选项，该命令也会拒绝改变一个在链接到同一仓库的另一个工作树中被检查出来的现有分支`<branchname>`。"

#. type: Labeled list
#: en/git-branch.txt:132
#, ignore-same, no-wrap, priority:260
msgid "--move"
msgstr "--move"

#. type: Plain text
#: en/git-branch.txt:134
#, fuzzy, priority:260
#| msgid "Move/rename a branch and the corresponding reflog."
msgid "Move/rename a branch, together with its config and reflog."
msgstr "移动/重命名一个分支和相应的重新记录。"

#. type: Labeled list
#: en/git-branch.txt:135 en/git-fast-export.txt:53 en/git-p4.txt:317
#, fuzzy, no-wrap, priority:260
msgid "-M"
msgstr "-M"

#. type: Plain text
#: en/git-branch.txt:137
#, priority:260
msgid "Shortcut for `--move --force`."
msgstr "`--move --force`的快捷方式。"

#. type: Labeled list
#: en/git-branch.txt:139
#, ignore-same, no-wrap, priority:260
msgid "--copy"
msgstr "--copy"

#. type: Plain text
#: en/git-branch.txt:141
#, fuzzy, priority:260
#| msgid "Copy a branch and the corresponding reflog."
msgid "Copy a branch, together with its config and reflog."
msgstr "复制一个分支和相应的reflog。"

#. type: Plain text
#: en/git-branch.txt:142 en/git-fast-export.txt:54 en/git-rebase.txt:650
#, fuzzy, no-wrap, priority:260
msgid "-C"
msgstr "-C"

#. type: Plain text
#: en/git-branch.txt:144
#, priority:260
msgid "Shortcut for `--copy --force`."
msgstr "`--copy --force`的快捷方式。"

#. type: Plain text
#: en/git-branch.txt:149
#, priority:260
msgid "Color branches to highlight current, local, and remote-tracking branches.  The value must be always (the default), never, or auto."
msgstr "给分支着色，以突出当前、本地和远程跟踪的分支。  该值必须是始终（默认）、从不或自动。"

#. type: Plain text
#: en/git-branch.txt:154
#, priority:260
msgid "Turn off branch colors, even when the configuration file gives the default to color output.  Same as `--color=never`."
msgstr "关闭分支的颜色，即使在配置文件中默认为彩色输出。  与`--color=never`相同。"

#. type: Labeled list
#: en/git-branch.txt:156 en/git-for-each-ref.txt:99 en/git-grep.txt:83 en/git-tag.txt:131
#, ignore-same, no-wrap, priority:260
msgid "--ignore-case"
msgstr "--ignore-case"

#. type: Plain text
#: en/git-branch.txt:158
#, priority:260
msgid "Sorting and filtering branches are case insensitive."
msgstr "排序和过滤分支是不分大小写的。"

#. type: Labeled list
#: en/git-branch.txt:159 en/git-for-each-ref.txt:102 en/git-tag.txt:134
#, ignore-same, no-wrap, priority:260
msgid "--omit-empty"
msgstr "--omit-empty"

#. type: Plain text
#: en/git-branch.txt:162 en/git-for-each-ref.txt:105 en/git-tag.txt:137
#, priority:260
msgid "Do not print a newline after formatted refs where the format expands to the empty string."
msgstr "在格式化的引用后不打印换行，因为格式化的引用会扩展为空字符串。"

#. type: Labeled list
#: en/git-branch.txt:163 en/git-status.txt:130 en/git-tag.txt:138
#, no-wrap, priority:280
msgid "--column[=<options>]"
msgstr "--column[=<选项>]"

#. type: Labeled list
#: en/git-branch.txt:164 en/git-status.txt:131 en/git-tag.txt:139
#, ignore-same, no-wrap, priority:280
msgid "--no-column"
msgstr "--no-column"

#. type: Plain text
#: en/git-branch.txt:168
#, priority:260
msgid "Display branch listing in columns. See configuration variable `column.branch` for option syntax. `--column` and `--no-column` without options are equivalent to 'always' and 'never' respectively."
msgstr "在列中显示分支列表。选项语法见配置变量`column.branch`。`--column`和`--no-column`没有选项，分别相当于'always'和'never'。"

#. type: Plain text
#: en/git-branch.txt:170
#, priority:260
msgid "This option is only applicable in non-verbose mode."
msgstr "这个选项只适用于非粗话模式。"

#. type: Labeled list
#: en/git-branch.txt:172 en/git-show-branch.txt:44
#, ignore-same, no-wrap, priority:260
msgid "--remotes"
msgstr "--remotes"

#. type: Plain text
#: en/git-branch.txt:175
#, priority:260
msgid "List or delete (if used with -d) the remote-tracking branches.  Combine with `--list` to match the optional pattern(s)."
msgstr "列出或删除（如果与-d一起使用）远程跟踪的分支。  与`--list`结合使用，以匹配可选的模式（s）。"

#. type: Plain text
#: en/git-branch.txt:180
#, priority:260
msgid "List both remote-tracking branches and local branches.  Combine with `--list` to match optional pattern(s)."
msgstr "列出远程跟踪的分支和本地分支。  与`--list`组合，以匹配可选的模式。"

#. type: Plain text
#: en/git-branch.txt:186
#, ignore-ellipsis, priority:260
msgid "List branches.  With optional `<pattern>...`, e.g. `git branch --list 'maint-*'`, list only the branches that match the pattern(s)."
msgstr "列出分支。  使用可选的\"<pattern>...\"，例如 \"git branch --list 'maint-*'\"，只列出符合该模式的分支。"

#. type: Labeled list
#: en/git-branch.txt:187
#, ignore-same, no-wrap, priority:260
msgid "--show-current"
msgstr "--show-current"

#. type: Plain text
#: en/git-branch.txt:190
#, priority:260
msgid "Print the name of the current branch. In detached HEAD state, nothing is printed."
msgstr "打印当前分支的名称。在分离的HEAD状态下，不打印任何东西。"

#. type: Labeled list
#: en/git-branch.txt:192
#, ignore-same, no-wrap, priority:260
msgid "-vv"
msgstr "-vv"

#. type: Plain text
#: en/git-branch.txt:201
#, priority:260
msgid "When in list mode, show sha1 and commit subject line for each head, along with relationship to upstream branch (if any). If given twice, print the path of the linked worktree (if any) and the name of the upstream branch, as well (see also `git remote show <remote>`).  Note that the current worktree's HEAD will not have its path printed (it will always be your current directory)."
msgstr "当在列表模式下，显示每个头的sha1和提交主题行，以及与上游分支的关系（如果有的话）。如果给了两次，也会打印链接的工作树的路径（如果有的话）和上游分支的名称（也见 `git remote show <remote>`）。  请注意，当前工作树的HEAD不会打印其路径（它总是你的当前目录）。"

#. type: Plain text
#: en/git-branch.txt:206
#, priority:260
msgid "Be more quiet when creating or deleting a branch, suppressing non-error messages."
msgstr "在创建或删除一个分支时更加安静，抑制非错误信息。"

#. type: Plain text
#: en/git-branch.txt:213
#, priority:260
msgid "In the verbose listing that show the commit object name, show the shortest prefix that is at least '<n>' hexdigits long that uniquely refers the object.  The default value is 7 and can be overridden by the `core.abbrev` config option."
msgstr "在显示提交对象名称的冗长列表中，显示至少有'<n>'个六位数的最短前缀，以唯一地指代该对象。  默认值是7，可以通过`core.abbrev`配置选项覆盖。"

#. type: Labeled list
#: en/git-branch.txt:214
#, ignore-same, no-wrap, priority:260
msgid "--no-abbrev"
msgstr "--no-abbrev"

#. type: Plain text
#: en/git-branch.txt:216
#, priority:260
msgid "Display the full sha1s in the output listing rather than abbreviating them."
msgstr "在输出列表中显示完整的sha1，而不是缩写它们。"

#. type: Labeled list
#: en/git-branch.txt:218 en/git-checkout.txt:161
#, fuzzy, no-wrap, priority:260
msgid "--track[=(direct|inherit)]"
msgstr "--track [inherit|direct]"

#. type: Plain text
#: en/git-branch.txt:226
#, fuzzy, priority:260
#| msgid "When creating a new branch, set up `branch.<name>.remote` and `branch.<name>.merge` configuration entries to mark the start-point branch as \"upstream\" from the new branch. This configuration will tell git to show the relationship between the two branches in `git status` and `git branch -v`. Furthermore, it directs `git pull` without arguments to pull from the upstream when the new branch is checked out."
msgid "When creating a new branch, set up `branch.<name>.remote` and `branch.<name>.merge` configuration entries to set \"upstream\" tracking configuration for the new branch. This configuration will tell git to show the relationship between the two branches in `git status` and `git branch -v`. Furthermore, it directs `git pull` without arguments to pull from the upstream when the new branch is checked out."
msgstr "在创建新分支时，设置`branch.<name>.remote`和`branch.<name>.merge`配置项，将起始点分支标记为新分支的 \"上游\"。这个配置将告诉git在`git status`和`git branch -v`中显示这两个分支之间的关系。此外，它还指示`git pull`在新分支被检出时，不带参数地从上游提取。"

#. type: Plain text
#: en/git-branch.txt:231
#, fuzzy, priority:260
msgid "The exact upstream branch is chosen depending on the optional argument: `-t`, `--track`, or `--track=direct` means to use the start-point branch itself as the upstream; `--track=inherit` means to copy the upstream configuration of the start-point branch."
msgstr "根据可选参数选择确切的上游分支： `--track` 或 `--track direct` 表示将起点分支本身用作上游； `--track inherit` 表示复制起点分支的上游配置。"

#. type: Plain text
#: en/git-branch.txt:235
#, priority:260
msgid "The branch.autoSetupMerge configuration variable specifies how `git switch`, `git checkout` and `git branch` should behave when neither `--track` nor `--no-track` are specified:"
msgstr "branch.autoSetupMerge配置变量指定了当既不指定`--track`也不指定`--no-track`时，`git switch`、`git checkout`和`git branch`应如何运行："

#. type: Plain text
#: en/git-branch.txt:243
#, priority:260
msgid "The default option, `true`, behaves as though `--track=direct` were given whenever the start-point is a remote-tracking branch.  `false` behaves as if `--no-track` were given. `always` behaves as though `--track=direct` were given. `inherit` behaves as though `--track=inherit` were given. `simple` behaves as though `--track=direct` were given only when the start-point is a remote-tracking branch and the new branch has the same name as the remote branch."
msgstr "默认选项 \"true\"，在起点是远程跟踪分支的情况下，就像给了 \"track=direct\"。  `false`的行为就像给了`--no-track`一样。`always`的行为就像给了`--track=direct`一样。继承(inherit)的行为就像给了`--track=inherit'一样。`simple`的行为就像给了`--track=direct`一样，只有当起点是远程跟踪的分支，并且新的分支与远程分支有相同的名字时，才会有这种行为。"

#. type: Plain text
#: en/git-branch.txt:246
#, fuzzy, priority:260
msgid "See linkgit:git-pull[1] and linkgit:git-config[1] for additional discussion on how the `branch.<name>.remote` and `branch.<name>.merge` options are used."
msgstr "有关如何使用 `branch.<name>.remote` 和 `branch.<name>.merge` 选项的更多讨论，请参见 linkgit:git-pull[1] 和 linkgit:git-config[1]。"

#. type: Labeled list
#: en/git-branch.txt:247 en/git-checkout.txt:175 en/git-switch.txt:169
#, ignore-same, no-wrap, priority:260
msgid "--no-track"
msgstr "--no-track"

#. type: Plain text
#: en/git-branch.txt:250
#, fuzzy, priority:260
#| msgid "Do not set up \"upstream\" configuration, even if the branch.autoSetupMerge configuration variable is true."
msgid "Do not set up \"upstream\" configuration, even if the branch.autoSetupMerge configuration variable is set."
msgstr "不要设置 \"上游 \"配置，即使 branch.autoSetupMerge 配置变量为 true。"

#. type: Labeled list
#: en/git-branch.txt:251 en/git-checkout.txt:299 en/git-grep.txt:64 en/git-ls-files.txt:180 en/git-restore.txt:110 en/git-switch.txt:183
#, ignore-same, no-wrap, priority:280
msgid "--recurse-submodules"
msgstr "--recurse-submodules"

#. type: Plain text
#: en/git-branch.txt:257
#, priority:260
msgid "THIS OPTION IS EXPERIMENTAL! Causes the current command to recurse into submodules if `submodule.propagateBranches` is enabled. See `submodule.propagateBranches` in linkgit:git-config[1]. Currently, only branch creation is supported."
msgstr "这个选项是实验性的！！！如果 `submodule.propagateBranches` 被启用，会导致当前命令递归到子模块。参见 linkgit:git-config[1] 中的 `submodule.propagateBranches`。目前，只支持创建分支。"

#. type: Plain text
#: en/git-branch.txt:266
#, priority:260
msgid "When used in branch creation, a new branch <branchname> will be created in the superproject and all of the submodules in the superproject's <start-point>. In submodules, the branch will point to the submodule commit in the superproject's <start-point> but the branch's tracking information will be set up based on the submodule's branches and remotes e.g. `git branch --recurse-submodules topic origin/main` will create the submodule branch \"topic\" that points to the submodule commit in the superproject's \"origin/main\", but tracks the submodule's \"origin/main\"."
msgstr "当在分支创建中使用时，一个新的分支<branchname>将在父项目和父项目的<start-point>中的所有子模块中创建。在子模块中，该分支将指向超级项目的<start-point>中的子模块提交，但该分支的跟踪信息将根据子模块的分支和远程来设置，例如`git branch --recurse-submodules topic origin/main`将创建一个子模块分支 \"topic\"，指向父项目的 \"origin/main \"中的子模块提交，但跟踪子模块的 \"origin/main\"。"

#. type: Plain text
#: en/git-branch.txt:270
#, priority:260
msgid "As this option had confusing syntax, it is no longer supported.  Please use `--track` or `--set-upstream-to` instead."
msgstr "由于这个选项的语法混乱，不再支持。  请使用`--track`或`--set-upstream-to`代替。"

#. type: Labeled list
#: en/git-branch.txt:271
#, no-wrap, priority:260
msgid "-u <upstream>"
msgstr "-u <上行>"

#. type: Labeled list
#: en/git-branch.txt:272
#, fuzzy, no-wrap, priority:260
msgid "--set-upstream-to=<upstream>"
msgstr "--set-upstream-to=<upstream>"

#. type: Plain text
#: en/git-branch.txt:276
#, priority:260
msgid "Set up <branchname>'s tracking information so <upstream> is considered <branchname>'s upstream branch. If no <branchname> is specified, then it defaults to the current branch."
msgstr "设置<branchname>的跟踪信息，使<upstream>被视为<branchname>的上游分支。如果没有指定<branchname>，则默认为当前分支。"

#. type: Labeled list
#: en/git-branch.txt:277
#, ignore-same, no-wrap, priority:260
msgid "--unset-upstream"
msgstr "--unset-upstream"

#. type: Plain text
#: en/git-branch.txt:280
#, priority:260
msgid "Remove the upstream information for <branchname>. If no branch is specified it defaults to the current branch."
msgstr "删除<branchname>的上游信息。如果没有指定分支，则默认为当前分支。"

#. type: Labeled list
#: en/git-branch.txt:281
#, ignore-same, no-wrap, priority:260
msgid "--edit-description"
msgstr "--edit-description"

#. type: Plain text
#: en/git-branch.txt:286
#, priority:260
msgid "Open an editor and edit the text to explain what the branch is for, to be used by various other commands (e.g. `format-patch`, `request-pull`, and `merge` (if enabled)). Multi-line explanations may be used."
msgstr "打开一个编辑器，编辑文本，解释该分支的用途，以便被其他各种命令（如`format-patch`、`request-pull`和`merge`（如果启用））使用。可以使用多行解释。"

#. type: Labeled list
#: en/git-branch.txt:287 en/git-tag.txt:146
#, fuzzy, no-wrap, priority:260
msgid "--contains [<commit>]"
msgstr "--contains [<commit>]"

#. type: Plain text
#: en/git-branch.txt:290
#, priority:260
msgid "Only list branches which contain the specified commit (HEAD if not specified). Implies `--list`."
msgstr "只列出包含指定提交的分支（如果没有指定则为HEAD）。意味着 `--list`。"

#. type: Labeled list
#: en/git-branch.txt:291 en/git-tag.txt:150
#, fuzzy, no-wrap, priority:260
msgid "--no-contains [<commit>]"
msgstr "--no-contains [<commit>]"

#. type: Plain text
#: en/git-branch.txt:294
#, priority:260
msgid "Only list branches which don't contain the specified commit (HEAD if not specified). Implies `--list`."
msgstr "只列出不包含指定提交的分支（如果不指定则为HEAD）。意味着 `--list`。"

#. type: Labeled list
#: en/git-branch.txt:295 en/git-tag.txt:154
#, fuzzy, no-wrap, priority:260
msgid "--merged [<commit>]"
msgstr "--merged [<commit>]"

#. type: Plain text
#: en/git-branch.txt:298
#, priority:260
msgid "Only list branches whose tips are reachable from the specified commit (HEAD if not specified). Implies `--list`."
msgstr "只列出从指定的提交（如果没有指定，则为HEAD）可以到达的分支的提示。意味着 `--list`。"

#. type: Labeled list
#: en/git-branch.txt:299 en/git-tag.txt:158
#, fuzzy, no-wrap, priority:260
msgid "--no-merged [<commit>]"
msgstr "--no-merged [<commit>]"

#. type: Plain text
#: en/git-branch.txt:302
#, priority:260
msgid "Only list branches whose tips are not reachable from the specified commit (HEAD if not specified). Implies `--list`."
msgstr "只列出从指定的提交（如果没有指定，则为HEAD）中无法到达的分支。意味着 `--list`。"

#. type: Labeled list
#: en/git-branch.txt:303
#, no-wrap, priority:260
msgid "<branchname>"
msgstr "<branchname>"

#. type: Plain text
#: en/git-branch.txt:308
#, priority:260
msgid "The name of the branch to create or delete.  The new branch name must pass all checks defined by linkgit:git-check-ref-format[1].  Some of these checks may restrict the characters allowed in a branch name."
msgstr "要创建或删除的分支的名称。  新的分支名必须通过 linkgit:git-check-ref-format[1] 定义的所有检查。  其中一些检查可能会限制分支名称中允许的字符。"

#. type: Labeled list
#: en/git-branch.txt:309 en/git-checkout.txt:348 en/git-switch.txt:42
#, no-wrap, priority:260
msgid "<start-point>"
msgstr "<起始点"

#. type: Plain text
#: en/git-branch.txt:313
#, priority:260
msgid "The new branch head will point to this commit.  It may be given as a branch name, a commit-id, or a tag.  If this option is omitted, the current HEAD will be used instead."
msgstr "新的分支头将指向这个提交。  它可以是一个分支名，一个提交号，或者一个标签。  如果省略此选项，将使用当前的HEAD来代替。"

#. type: Labeled list
#: en/git-branch.txt:314
#, fuzzy, no-wrap, priority:260
msgid "<oldbranch>"
msgstr "<oldbranch>"

#. type: Plain text
#: en/git-branch.txt:316
#, priority:260
msgid "The name of an existing branch to rename."
msgstr "要重命名的现有分支的名称。"

#. type: Labeled list
#: en/git-branch.txt:317
#, fuzzy, no-wrap, priority:260
msgid "<newbranch>"
msgstr "<newbranch>"

#. type: Plain text
#: en/git-branch.txt:320
#, priority:260
msgid "The new name for an existing branch. The same restrictions as for <branchname> apply."
msgstr "现有分支的新名称。与<branchname>的限制相同。"

#. type: Labeled list
#: en/git-branch.txt:321 en/git-for-each-ref.txt:46 en/git-ls-remote.txt:65 en/git-tag.txt:112
#, no-wrap, priority:260
msgid "--sort=<key>"
msgstr "--排序=<键>"

#. type: Plain text
#: en/git-branch.txt:331
#, ignore-ellipsis, priority:260
msgid "Sort based on the key given. Prefix `-` to sort in descending order of the value. You may use the --sort=<key> option multiple times, in which case the last key becomes the primary key. The keys supported are the same as those in `git for-each-ref`. Sort order defaults to the value configured for the `branch.sort` variable if exists, or to sorting based on the full refname (including `refs/...` prefix). This lists detached HEAD (if present) first, then local branches and finally remote-tracking branches. See linkgit:git-config[1]."
msgstr "根据给定的键进行排序。前缀\"-\"表示按照数值的降序排序。你可以多次使用--sort=<key>选项，在这种情况下，最后一个键成为主键。支持的键与`git for-each-ref`中的键相同。排序顺序默认为`branch.sort`变量的配置值（如果存在），或者基于完整的 refname（包括 `refs/...` 前缀）进行排序。这将首先列出分离的 HEAD（如果存在），然后是本地分支，最后是远程跟踪分支。参见 linkgit:git-config[1]。"

#. type: Labeled list
#: en/git-branch.txt:333 en/git-tag.txt:162
#, fuzzy, no-wrap, priority:260
msgid "--points-at <object>"
msgstr "--points-at <object>"

#. type: Plain text
#: en/git-branch.txt:335
#, priority:260
msgid "Only list branches of the given object."
msgstr "只列出给定对象的分支。"

#. type: Labeled list
#: en/git-branch.txt:336
#, fuzzy, no-wrap, priority:260
msgid "--format <format>"
msgstr "--format <format>"

#. type: Plain text
#: en/git-branch.txt:340
#, priority:260
msgid "A string that interpolates `%(fieldname)` from a branch ref being shown and the object it points at.  The format is the same as that of linkgit:git-for-each-ref[1]."
msgstr "一个字符串，从正在显示的分支参考文献和它所指向的对象中插值`%(fieldname)'。  其格式与linkgit:git-for-each-ref[1]的格式相同。"

#. type: Plain text
#: en/git-branch.txt:346
#, priority:260
msgid "`pager.branch` is only respected when listing branches, i.e., when `--list` is used or implied. The default is to use a pager.  See linkgit:git-config[1]."
msgstr "`pager.branch`只在列出分支时被尊重，即使用或暗示使用`--list`时。默认情况是使用 pager。  参见 linkgit:git-config[1]。"

#. type: Labeled list
#: en/git-branch.txt:354
#, no-wrap, priority:260
msgid "Start development from a known tag"
msgstr "从一个已知的标签开始开发"

#. type: delimited block -
#: en/git-branch.txt:361
#, ignore-ellipsis, no-wrap, priority:260
msgid ""
"$ git clone git://git.kernel.org/pub/scm/.../linux-2.6 my2.6\n"
"$ cd my2.6\n"
"$ git branch my2.6.14 v2.6.14   <1>\n"
"$ git switch my2.6.14\n"
msgstr ""
"$ git clone git://git.kernel.org/pub/scm/.../linux-2.6 my2.6\n"
"$ cd my2.6\n"
"$ git branch my2.6.14 v2.6.14 <1>.\n"
"$ git switch my2.6.14\n"

#. type: Plain text
#: en/git-branch.txt:365
#, priority:260
msgid "This step and the next one could be combined into a single step with \"checkout -b my2.6.14 v2.6.14\"."
msgstr "这一步和下一步可以用 \"checkout -b my2.6.14 v2.6.14 \"合并为一个步骤。"

#. type: Labeled list
#: en/git-branch.txt:366
#, no-wrap, priority:260
msgid "Delete an unneeded branch"
msgstr "删除一个不需要的分支"

#. type: delimited block -
#: en/git-branch.txt:373
#, fuzzy, ignore-ellipsis, no-wrap, priority:260
msgid ""
"$ git clone git://git.kernel.org/.../git.git my.git\n"
"$ cd my.git\n"
"$ git branch -d -r origin/todo origin/html origin/man   <1>\n"
"$ git branch -D test                                    <2>\n"
msgstr ""
"$ git clone git://git.kernel.org/.../git.git my.git\n"
"$ cd my.git\n"
"$ git branch -d -r origin/todo origin/html origin/man   <1>\n"
"$ git branch -D test                                    <2>\n"

#. type: Plain text
#: en/git-branch.txt:378
#, priority:260
msgid "Delete the remote-tracking branches \"todo\", \"html\" and \"man\". The next 'fetch' or 'pull' will create them again unless you configure them not to.  See linkgit:git-fetch[1]."
msgstr "删除远程跟踪的分支 \"todo\"、\"html \"和 \"man\"。下一次的 \"fetch \"或 \"pull \"会再次创建它们，除非你配置它们不这样做。  参见 linkgit:git-fetch[1]。"

#. type: Plain text
#: en/git-branch.txt:380
#, priority:260
msgid "Delete the \"test\" branch even if the \"master\" branch (or whichever branch is currently checked out) does not have all commits from the test branch."
msgstr "删除 \"测试 \"分支，即使 \"主 \"分支（或当前签出的任何一个分支）没有测试分支的所有提交。"

#. type: Labeled list
#: en/git-branch.txt:381
#, no-wrap, priority:260
msgid "Listing branches from a specific remote"
msgstr "从一个特定的远端列出分支"

#. type: delimited block -
#: en/git-branch.txt:386
#, fuzzy, no-wrap, priority:260
msgid ""
"$ git branch -r -l '<remote>/<pattern>'                 <1>\n"
"$ git for-each-ref 'refs/remotes/<remote>/<pattern>'    <2>\n"
msgstr ""
"$ git branch -r -l '<remote>/<pattern>'                 <1>\n"
"$ git for-each-ref 'refs/remotes/<remote>/<pattern>'    <2>\n"

#. type: Plain text
#: en/git-branch.txt:390
#, priority:260
msgid "Using `-a` would conflate <remote> with any local branches you happen to have been prefixed with the same <remote> pattern."
msgstr "使用`-a`会将<remote>与任何你碰巧以相同的<remote>模式为前缀的本地分支混淆。"

#. type: Plain text
#: en/git-branch.txt:391
#, priority:260
msgid "`for-each-ref` can take a wide range of options. See linkgit:git-for-each-ref[1]"
msgstr "`for-each-ref`可以接受一系列的选项。参见 linkgit:git-for-each-ref[1] 。"

#. type: Plain text
#: en/git-branch.txt:393
#, priority:260
msgid "Patterns will normally need quoting."
msgstr "图案通常需要引证。"

#. type: Title -
#: en/git-branch.txt:395 en/git-for-each-ref.txt:487 en/git-gc.txt:120 en/git-index-pack.txt:134 en/git-prune.txt:71 en/git-rebase.txt:814 en/git-symbolic-ref.txt:63 en/git-tag.txt:395 en/git-update-index.txt:583
#, fuzzy, no-wrap, priority:260
msgid "NOTES"
msgstr "注释"

#. type: Plain text
#: en/git-branch.txt:400
#, priority:260
msgid "If you are creating a branch that you want to switch to immediately, it is easier to use the \"git switch\" command with its `-c` option to do the same thing with a single command."
msgstr "如果你正在创建一个你想立即切换到的分支，使用 \"git switch \"命令及其`-c`选项，用一条命令做同样的事情，会更容易。"

#. type: Plain text
#: en/git-branch.txt:403
#, priority:260
msgid "The options `--contains`, `--no-contains`, `--merged` and `--no-merged` serve four related but different purposes:"
msgstr "选项`--包含`、`--不包含`、`--合并`和`--不合并`有四个相关但不同的目的。"

#. type: Plain text
#: en/git-branch.txt:407
#, priority:260
msgid "`--contains <commit>` is used to find all branches which will need special attention if <commit> were to be rebased or amended, since those branches contain the specified <commit>."
msgstr "`--contains <commit>`用于查找所有在<commit>被重新编译或修改时需要特别关注的分支，因为这些分支包含指定的<commit>。"

#. type: Plain text
#: en/git-branch.txt:410
#, priority:260
msgid "`--no-contains <commit>` is the inverse of that, i.e. branches that don't contain the specified <commit>."
msgstr "`--no-contains <commit>`是其反义词，即不包含指定<commit>的分支。"

#. type: Plain text
#: en/git-branch.txt:413
#, priority:260
msgid "`--merged` is used to find all branches which can be safely deleted, since those branches are fully contained by HEAD."
msgstr "`--merged`用于查找所有可以安全删除的分支，因为这些分支被HEAD完全包含。"

#. type: Plain text
#: en/git-branch.txt:416
#, priority:260
msgid "`--no-merged` is used to find branches which are candidates for merging into HEAD, since those branches are not fully contained by HEAD."
msgstr "`--no-merged`是用来寻找可以合并到HEAD的候选分支，因为这些分支没有被HEAD完全包含。"

#. type: Plain text
#: en/git-branch.txt:426
#, priority:260
msgid "linkgit:git-check-ref-format[1], linkgit:git-fetch[1], linkgit:git-remote[1], link:user-manual.html#what-is-a-branch[``Understanding history: What is a branch?''] in the Git User's Manual."
msgstr "linkgit:git-check-ref-format[1], linkgit:git-fetch[1], linkgit:git-remote[1], link:user-manual.html#what-is-a-branch[``了解历史：什么是分支？'] 在 Git User's Manual。"

#. type: Title =
#: en/git-bugreport.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-bugreport(1)"
msgstr "git-bugreport(1)"

#. type: Plain text
#: en/git-bugreport.txt:7
#, priority:100
msgid "git-bugreport - Collect information for user to file a bug report"
msgstr "git-bugreport - 收集用户提交错误报告的信息"

#. type: Plain text
#: en/git-bugreport.txt:13
#, no-wrap, priority:100
msgid ""
"'git bugreport' [(-o | --output-directory) <path>] [(-s | --suffix) <format>]\n"
"\t\t[--diagnose[=<mode>]]\n"
msgstr ""
"'git bugreport' [(-o | --output-directory) <path>] [(-s | --suffix) <格式>]\n"
"\t\t[--diagnose[=<模式>]]\n"

#. type: Plain text
#: en/git-bugreport.txt:20
#, priority:100
msgid "Captures information about the user's machine, Git client, and repository state, as well as a form requesting information about the behavior the user observed, into a single text file which the user can then share, for example to the Git mailing list, in order to report an observed bug."
msgstr "捕获关于用户的机器、Git 客户端和仓库状态的信息，以及要求提供用户观察到的行为信息的表格，并将其放入一个文本文件中，然后用户可以分享该文件，例如分享到 Git 邮件列表，以便报告观察到的错误。"

#. type: Plain text
#: en/git-bugreport.txt:22
#, priority:100
msgid "The following information is requested from the user:"
msgstr "要求用户提供以下信息："

#. type: Plain text
#: en/git-bugreport.txt:24
#, priority:100
msgid "Reproduction steps"
msgstr "再生产步骤"

#. type: Plain text
#: en/git-bugreport.txt:25
#, priority:100
msgid "Expected behavior"
msgstr "预期的行为"

#. type: Plain text
#: en/git-bugreport.txt:26
#, priority:100
msgid "Actual behavior"
msgstr "实际行为"

#. type: Plain text
#: en/git-bugreport.txt:28
#, priority:100
msgid "The following information is captured automatically:"
msgstr "以下信息是自动采集的："

#. type: Plain text
#: en/git-bugreport.txt:30
#, priority:100
msgid "'git version --build-options'"
msgstr "'git version --build-options'"

#. type: Plain text
#: en/git-bugreport.txt:31
#, priority:100
msgid "uname sysname, release, version, and machine strings"
msgstr "uname sysname, release, version, and machine strings"

#. type: Plain text
#: en/git-bugreport.txt:32
#, priority:100
msgid "Compiler-specific info string"
msgstr "编译器特定信息字符串"

#. type: Plain text
#: en/git-bugreport.txt:33
#, priority:100
msgid "A list of enabled hooks"
msgstr "启用的钩子的列表"

#. type: Plain text
#: en/git-bugreport.txt:34
#, fuzzy, priority:100
msgid "$SHELL"
msgstr "$SHELL"

#. type: Plain text
#: en/git-bugreport.txt:38
#, priority:100
msgid "Additional information may be gathered into a separate zip archive using the `--diagnose` option, and can be attached alongside the bugreport document to provide additional context to readers."
msgstr "额外的信息可以使用 `--diagnose` 选项收集到一个单独的压缩文件中，并可以与 bugreport 文件一起附上，为读者提供额外的上下文。"

#. type: Plain text
#: en/git-bugreport.txt:43
#, priority:100
msgid "This tool is invoked via the typical Git setup process, which means that in some cases, it might not be able to launch - for example, if a relevant config file is unreadable. In this kind of scenario, it may be helpful to manually gather the kind of information listed above when manually asking for help."
msgstr "这个工具是通过典型的 Git 设置过程调用的，这意味着在某些情况下，它可能无法启动——例如，如果相关的配置文件无法读取。在这种情况下，在手动请求帮助时，手动收集上面列出的那种信息可能会有帮助。"

#. type: Labeled list
#: en/git-bugreport.txt:46
#, fuzzy, no-wrap, priority:100
#| msgid "-o <name>"
msgid "-o <path>"
msgstr "-o <路径>"

#. type: Labeled list
#: en/git-bugreport.txt:47
#, fuzzy, no-wrap, priority:100
#| msgid "--no-empty-directory"
msgid "--output-directory <path>"
msgstr "--output-directory <path>"

#. type: Plain text
#: en/git-bugreport.txt:50
#, priority:100
msgid "Place the resulting bug report file in `<path>` instead of the current directory."
msgstr "将产生的错误报告文件放在 `<路径>` 而不是当前目录中。"

#. type: Labeled list
#: en/git-bugreport.txt:51
#, fuzzy, no-wrap, priority:100
msgid "-s <format>"
msgstr "-s <format>"

#. type: Labeled list
#: en/git-bugreport.txt:52
#, fuzzy, no-wrap, priority:100
#| msgid "--git-format"
msgid "--suffix <format>"
msgstr "--suffix <format>"

#. type: Plain text
#: en/git-bugreport.txt:56
#, priority:100
msgid "Specify an alternate suffix for the bugreport name, to create a file named 'git-bugreport-<formatted suffix>'. This should take the form of a strftime(3) format string; the current local time will be used."
msgstr "为 bugreport 名称指定一个备用后缀，以创建一个名为 \"git-bugreport-<格式化后缀>\"的文件。这应该采取 strftime(3) 格式字符串的形式；将使用当前的本地时间。"

#. type: Labeled list
#: en/git-bugreport.txt:57
#, ignore-same, no-wrap, priority:100
msgid "--no-diagnose"
msgstr "--no-diagnose"

#. type: Labeled list
#: en/git-bugreport.txt:58
#, fuzzy, no-wrap, priority:100
msgid "--diagnose[=<mode>]"
msgstr "--ignored[=<mode>]"

#. type: Plain text
#: en/git-bugreport.txt:63
#, priority:100
msgid "Create a zip archive of supplemental information about the user's machine, Git client, and repository state. The archive is written to the same output directory as the bug report and is named 'git-diagnostics-<formatted suffix>'."
msgstr "创建一个包含用户机器、Git 客户端和仓库状态等补充信息的 zip 档案。该归档文件与错误报告写入同一输出目录，并命名为 'git-diagnostics-<格式化后缀>'。"

#. type: Plain text
#: en/git-bugreport.txt:69
#, priority:100
msgid "Without `mode` specified, the diagnostic archive will contain the default set of statistics reported by `git diagnose`. An optional `mode` value may be specified to change which information is included in the archive. See linkgit:git-diagnose[1] for the list of valid values for `mode` and details about their usage."
msgstr "如果没有指定`mode'，诊断档案将包含 `git diagnose` 报告的默认统计信息。可以指定一个可选的 `mode` 值来改变存档中包含的信息。参见 linkgit:git-diagnose[1]，了解 `mode` 的有效值列表及其使用细节。"

#. type: Title =
#: en/git-bundle.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-bundle(1)"
msgstr "git-bundle(1)"

#. type: Plain text
#: en/git-bundle.txt:7
#, fuzzy, priority:100
msgid "git-bundle - Move objects and refs by archive"
msgstr "git-bundle - Move objects and refs by archive"

#. type: Plain text
#: en/git-bundle.txt:17
#, ignore-ellipsis, no-wrap, priority:100
msgid ""
"'git bundle' create [-q | --quiet | --progress]\n"
"\t\t    [--version=<version>] <file> <git-rev-list-args>\n"
"'git bundle' verify [-q | --quiet] <file>\n"
"'git bundle' list-heads <file> [<refname>...]\n"
"'git bundle' unbundle [--progress] <file> [<refname>...]\n"
msgstr ""
"'git bundle' create [-q | --quiet | --progress]\n"
"\t\t    [--version=<版本>] <文件> <git-rev-list-args>\n"
"'git bundle' verify [-q | --quiet] <文件>\n"
"'git bundle' list-heads <文件> [<引用名>...]\n"
"'git bundle' unbundle [--progress] <文件> [<引用名>...]\n"

#. type: Plain text
#: en/git-bundle.txt:24
#, priority:100
msgid "Create, unpack, and manipulate \"bundle\" files. Bundles are used for the \"offline\" transfer of Git objects without an active \"server\" sitting on the other side of the network connection."
msgstr "创建、解包和操作 “打包” 文件。捆绑文件用于 Git 对象的 “离线” 传输，而不需要在网络连接的另一端有一个活跃的 “服务器”。"

#. type: Plain text
#: en/git-bundle.txt:28
#, priority:100
msgid "They can be used to create both incremental and full backups of a repository, and to relay the state of the references in one repository to another."
msgstr "它们可以用来创建仓库的增量和完全备份，并将一个仓库中的引用状态传递给另一个版本库。"

#. type: Plain text
#: en/git-bundle.txt:36
#, priority:100
msgid "Git commands that fetch or otherwise \"read\" via protocols such as `ssh://` and `https://` can also operate on bundle files. It is possible linkgit:git-clone[1] a new repository from a bundle, to use linkgit:git-fetch[1] to fetch from one, and to list the references contained within it with linkgit:git-ls-remote[1]. There's no corresponding \"write\" support, i.e.a 'git push' into a bundle is not supported."
msgstr "通过 `ssh://` 和 `https://` 等协议获取或以其他方式 “读取” 的 Git 命令也可以对打包文件进行操作。它可以通过 linkgit:git-clone[1] 从打包中建立新的仓库，用 linkgit:git-fetch[1] 从其中获取，并通过 linkgit:git-ls-remote[1] 列出其中的引用。没有相应的 \"写\" 支持，也就是说，不支持 'git push' 捆绑包。"

#. type: Plain text
#: en/git-bundle.txt:38
#, priority:100
msgid "See the \"EXAMPLES\" section below for examples of how to use bundles."
msgstr "关于如何使用捆绑包的例子，见下面的 “实例” 部分。"

#. type: Title -
#: en/git-bundle.txt:40
#, fuzzy, no-wrap, priority:100
msgid "BUNDLE FORMAT"
msgstr "日期格式"

#. type: Plain text
#: en/git-bundle.txt:44
#, priority:100
msgid "Bundles are `.pack` files (see linkgit:git-pack-objects[1]) with a header indicating what references are contained within the bundle."
msgstr "捆绑包是 `.pack` 文件（见 linkgit:git-pack-objects[1]），有一个标头说明捆绑包中包含哪些引用。"

#. type: Plain text
#: en/git-bundle.txt:48
#, priority:100
msgid "Like the packed archive format itself bundles can either be self-contained, or be created using exclusions.  See the \"OBJECT PREREQUISITES\" section below."
msgstr "就像打包的归档格式本身一样，捆绑包既可以是独立的，也可以使用排除法创建。 参见下面的 \"目标前提\" 部分。"

#. type: Plain text
#: en/git-bundle.txt:52
#, priority:100
msgid "Bundles created using revision exclusions are \"thin packs\" created using the `--thin` option to linkgit:git-pack-objects[1], and unbundled using the `--fix-thin` option to linkgit:git-index-pack[1]."
msgstr "使用修订版排除法创建的捆绑包是使用 linkgit:git-pack-objects[1] 的 `--thin` 选项创建的 “轻量包”，并使用 linkgit:git-index-pack[1] 的 `--fix-thin` 选项解除捆绑。"

#. type: Plain text
#: en/git-bundle.txt:58
#, priority:100
msgid "There is no option to create a \"thick pack\" when using revision exclusions, and users should not be concerned about the difference. By using \"thin packs\", bundles created using exclusions are smaller in size. That they're \"thin\" under the hood is merely noted here as a curiosity, and as a reference to other documentation."
msgstr "在使用修订排除法时，没有创建 “复杂包” 的选项，用户不应该担心这种差异。通过使用 “轻量包”，使用排除法创建的捆绑文件尺寸较小。它们在引擎盖下是 “薄” 的，在此只是作为一种好奇，并作为其他文档的参考。"

#. type: Plain text
#: en/git-bundle.txt:61
#, priority:100
msgid "See linkgit:gitformat-bundle[5] for more details and the discussion of \"thin pack\" in linkgit:gitformat-pack[5] for further details."
msgstr "更多细节见 linkgit:gitformat-bundle[5] ，以及 linkgit:gitformat-pack[5] 中关于 “轻量包” 的讨论。"

#. type: Labeled list
#: en/git-bundle.txt:65
#, fuzzy, no-wrap, priority:100
msgid "create [options] <file> <git-rev-list-args>"
msgstr "create [options] <文件> <git-rev-list-args>"

#. type: Plain text
#: en/git-bundle.txt:70
#, priority:100
msgid "Used to create a bundle named 'file'.  This requires the '<git-rev-list-args>' arguments to define the bundle contents.  'options' contains the options specific to the 'git bundle create' subcommand. If 'file' is `-`, the bundle is written to stdout."
msgstr "用来创建一个名为 '<文件>' 的捆绑包。 这需要 '<git-rev-list-args>' 参数来定义包的内容。 '选项' 包含 'git bundle create' 子命令的特定选项。如果 'file' 是 '-'，捆绑内容将被写入标准输出流。"

#. type: Labeled list
#: en/git-bundle.txt:71
#, no-wrap, priority:100
msgid "verify <file>"
msgstr "verify <文件>"

#. type: Plain text
#: en/git-bundle.txt:82
#, priority:100
msgid "Used to check that a bundle file is valid and will apply cleanly to the current repository.  This includes checks on the bundle format itself as well as checking that the prerequisite commits exist and are fully linked in the current repository.  Then, 'git bundle' prints a list of missing commits, if any.  Finally, information about additional capabilities, such as \"object filter\", is printed. See \"Capabilities\" in linkgit:gitformat-bundle[5] for more information. The exit code is zero for success, but will be nonzero if the bundle file is invalid. If 'file' is `-`, the bundle is read from stdin."
msgstr "用于检查捆绑包文件是否有效，是否能干净地应用到当前仓库。 这包括对捆绑包格式本身的检查，以及检查前提提交是否存在，并在当前版本库中被完全链接。 然后，'git bundle' 会打印出一个缺失提交的列表，如果有的话。 最后，打印出关于额外能力的信息，比如 “对象过滤器”。更多信息见 linkgit:gitformat-bundle[5] 中的 “能力”。成功时退出代码为零，但如果捆绑包文件无效，退出代码将为非零。如果 'file' 是 `-`，则从标准输入流读取捆绑包文件。"

#. type: Labeled list
#: en/git-bundle.txt:83
#, no-wrap, priority:100
msgid "list-heads <file>"
msgstr "list-heads <文件>"

#. type: Plain text
#: en/git-bundle.txt:87
#, priority:100
msgid "Lists the references defined in the bundle.  If followed by a list of references, only references matching those given are printed out. If 'file' is `-`, the bundle is read from stdin."
msgstr "列出捆绑中定义的引用。 如果后面是引用列表，则只打印出与之匹配的引用。如果 'file' 是 `-`，则从标准输入流中读取捆绑包文件。"

#. type: Labeled list
#: en/git-bundle.txt:88
#, no-wrap, priority:100
msgid "unbundle <file>"
msgstr "unbundle <文件>"

#. type: Plain text
#: en/git-bundle.txt:95
#, priority:100
msgid "Passes the objects in the bundle to 'git index-pack' for storage in the repository, then prints the names of all defined references. If a list of references is given, only references matching those in the list are printed. This command is really plumbing, intended to be called only by 'git fetch'.  If 'file' is `-`, the bundle is read from stdin."
msgstr "将捆绑包中的对象传递给 'git index-pack' 以存储在仓库中，然后打印出所有定义的引用的名称。如果给了一个引用列表，则只打印列表中匹配的引用。这个命令是真正的管道，只打算由 'git fetch' 调用。 如果 'file' 是 `-`，则从标准输入流读取捆绑包文件。"

#. type: Labeled list
#: en/git-bundle.txt:96
#, fuzzy, no-wrap, priority:100
msgid "<git-rev-list-args>"
msgstr "<git-rev-list-args>"

#. type: Plain text
#: en/git-bundle.txt:105
#, priority:100
msgid "A list of arguments, acceptable to 'git rev-parse' and 'git rev-list' (and containing a named ref, see SPECIFYING REFERENCES below), that specifies the specific objects and references to transport.  For example, `master~10..master` causes the current master reference to be packaged along with all objects added since its 10th ancestor commit.  There is no explicit limit to the number of references and objects that may be packaged."
msgstr "一个参数列表，可以被 'git rev-parse' 和 'git rev-list' 接受（并包含一个命名的引用，见下面的 指定引用），它指定了要传送的特定对象和引用。 例如，`master~10...master` 会导致当前的主引用与自其第 10 次祖先提交后添加的所有对象一起被打包。 对于可以打包的引用和对象的数量没有明确的限制。"

#. type: Labeled list
#: en/git-bundle.txt:107
#, ignore-ellipsis, no-wrap, priority:100
msgid "[<refname>...]"
msgstr "[<引用名>...]"

#. type: Plain text
#: en/git-bundle.txt:113
#, priority:100
msgid "A list of references used to limit the references reported as available. This is principally of use to 'git fetch', which expects to receive only those references asked for and not necessarily everything in the pack (in this case, 'git bundle' acts like 'git fetch-pack')."
msgstr "用于限制报告的可用引用的列表。这主要是对 'git fetch' 有用，它希望只收到那些要求的引用，而不一定是包中的所有内容（在这种情况下， 'git bundle' 就像 'git fetch-pack'）。"

#. type: Labeled list
#: en/git-bundle.txt:120
#, fuzzy, no-wrap, priority:100
#| msgid "--server-option=<option>"
msgid "--version=<version>"
msgstr "--version=<version>"

#. type: Plain text
#: en/git-bundle.txt:125
#, priority:100
msgid "Specify the bundle version.  Version 2 is the older format and can only be used with SHA-1 repositories; the newer version 3 contains capabilities that permit extensions. The default is the oldest supported format, based on the hash algorithm in use."
msgstr "指定捆绑包的版本。 版本 2 是较老的格式，只能用于 SHA-1 仓库；较新的版本 3 包含允许扩展的功能。默认是最古老的支持格式，基于使用中的哈希算法。"

#. type: Plain text
#: en/git-bundle.txt:130 en/git-pack-objects.txt:216
#, priority:100
msgid "This flag makes the command not to report its progress on the standard error stream."
msgstr "这个标志使命令不在标准错误流中报告其进度。"

#. type: Title -
#: en/git-bundle.txt:132
#, no-wrap, priority:100
msgid "SPECIFYING REFERENCES"
msgstr "指定引用"

#. type: Plain text
#: en/git-bundle.txt:136
#, priority:100
msgid "Revisions must be accompanied by reference names to be packaged in a bundle."
msgstr "修订必须附有引用名称，才能打包成捆绑包。"

#. type: Plain text
#: en/git-bundle.txt:140
#, priority:100
msgid "More than one reference may be packaged, and more than one set of prerequisite objects can be specified.  The objects packaged are those not contained in the union of the prerequisites."
msgstr "可以打包一个以上的引用，也可以指定一组以上的先决条件对象。 被打包的对象是那些不包含在先决条件组合中的对象。"

#. type: Plain text
#: en/git-bundle.txt:145
#, priority:100
msgid "The 'git bundle create' command resolves the reference names for you using the same rules as `git rev-parse --abbrev-ref=loose`. Each prerequisite can be specified explicitly (e.g. `^master~10`), or implicitly (e.g. `master~10..master`, `--since=10.days.ago master`)."
msgstr "'git bundle create' 命令使用与 `git rev-parse --abbrev-ref=loose' 相同的规则为您解析引用名称。每个先决条件都可以明确指定（例如`^master~10`），或者隐含地指定（例如 `master~10...master`，`--since=10.day.after master`）。"

#. type: Plain text
#: en/git-bundle.txt:148
#, priority:100
msgid "All of these simple cases are OK (assuming we have a \"master\" and \"next\" branch):"
msgstr "所有这些简单的情况都没有问题（假设我们有一个 \"master\" 和 \"next\" 分支）："

#. type: delimited block -
#: en/git-bundle.txt:154
#, no-wrap, priority:100
msgid ""
"$ git bundle create master.bundle master\n"
"$ echo master | git bundle create master.bundle --stdin\n"
"$ git bundle create master-and-next.bundle master next\n"
"$ (echo master; echo next) | git bundle create master-and-next.bundle --stdin\n"
msgstr ""
"$ git bundle create master.bundle master\n"
"$ echo master | git bundle create master.bundle --stdin\n"
"$ git bundle create master-and-next.bundle master next\n"
"$ (echo master; echo next) | git bundle create master-and-next.bundle --stdin\n"

#. type: Plain text
#: en/git-bundle.txt:157
#, priority:100
msgid "And so are these (and the same but omitted `--stdin` examples):"
msgstr "这些也是如此（还有相同的但省略了 `--stdin` 的例子）："

#. type: delimited block -
#: en/git-bundle.txt:161
#, no-wrap, priority:100
msgid ""
"$ git bundle create recent-master.bundle master~10..master\n"
"$ git bundle create recent-updates.bundle master~10..master next~5..next\n"
msgstr ""
"$ git bundle create recent-master.bundle master~10..master\n"
"$ git bundle create recent-updates.bundle master~10..master next~5..next\n"

#. type: Plain text
#: en/git-bundle.txt:165
#, priority:100
msgid "A revision name or a range whose right-hand-side cannot be resolved to a reference is not accepted:"
msgstr "不接受修订名称或其右侧不能被解析为引用的范围："

#. type: delimited block -
#: en/git-bundle.txt:171
#, no-wrap, priority:100
msgid ""
"$ git bundle create HEAD.bundle $(git rev-parse HEAD)\n"
"fatal: Refusing to create empty bundle.\n"
"$ git bundle create master-yesterday.bundle master~10..master~5\n"
"fatal: Refusing to create empty bundle.\n"
msgstr ""
"$ git bundle create HEAD.bundle $(git rev-parse HEAD)\n"
"fatal: Refusing to create empty bundle.\n"
"$ git bundle create master-yesterday.bundle master~10..master~5\n"
"fatal: Refusing to create empty bundle.\n"

#. type: Title -
#: en/git-bundle.txt:174
#, fuzzy, no-wrap, priority:100
msgid "OBJECT PREREQUISITES"
msgstr "对象的先决条件"

#. type: Plain text
#: en/git-bundle.txt:180
#, priority:100
msgid "When creating bundles it is possible to create a self-contained bundle that can be unbundled in a repository with no common history, as well as providing negative revisions to exclude objects needed in the earlier parts of the history."
msgstr "在创建捆绑包时，可以创建一个独立的捆绑包，可以在没有共同历史的版本库中解绑，也可以提供负修订，以排除历史早期部分所需的对象。"

#. type: Plain text
#: en/git-bundle.txt:185
#, priority:100
msgid "Feeding a revision such as `new` to `git bundle create` will create a bundle file that contains all the objects reachable from the revision `new`. That bundle can be unbundled in any repository to obtain a full history that leads to the revision `new`:"
msgstr "向 `git bundle create` 输入诸如`new'这样的修订版将创建一个捆绑包文件，其中包含所有从 `new` 修订版可以到达的对象。捆绑文件可以在任何版本库中解绑，以获得通往 `new` 版本的完整历史："

#. type: delimited block -
#: en/git-bundle.txt:188
#, fuzzy, no-wrap, priority:100
msgid "$ git bundle create full.bundle new\n"
msgstr "$ git bundle create mybundle -10 master\n"

#. type: Plain text
#: en/git-bundle.txt:193
#, priority:100
msgid "A revision range such as `old..new` will produce a bundle file that will require the revision `old` (and any objects reachable from it)  to exist for the bundle to be \"unbundle\"-able:"
msgstr "向`git bundle create` 输入诸如 `new` 这样的修订版将创建一个捆绑包文件，其中包含所有从 `new` 修订版可以到达的对象。捆绑包文件可以在任何仓库中解绑，以获得通往 `new` 版本的完整历史："

#. type: delimited block -
#: en/git-bundle.txt:196
#, fuzzy, no-wrap, priority:100
msgid "$ git bundle create full.bundle old..new\n"
msgstr "$ git bundle create mybundle v1.0.0..master\n"

#. type: Plain text
#: en/git-bundle.txt:201
#, priority:100
msgid "A self-contained bundle without any prerequisites can be extracted into anywhere, even into an empty repository, or be cloned from (i.e., `new`, but not `old..new`)."
msgstr "一个没有任何先决条件的独立软件包可以被提取到任何地方，甚至可以提取到一个空的仓库中，或者被克隆出来（即 `new`，但不是 `old..new`）。"

#. type: Plain text
#: en/git-bundle.txt:205
#, priority:100
msgid "It is okay to err on the side of caution, causing the bundle file to contain objects already in the destination, as these are ignored when unpacking at the destination."
msgstr "谨慎行事是可以的，使捆绑文件包含已经在目的地的对象，因为在目的地解包时这些对象会被忽略。"

#. type: Plain text
#: en/git-bundle.txt:211
#, priority:100
msgid "If you want to match `git clone --mirror`, which would include your refs such as `refs/remotes/*`, use `--all`.  If you want to provide the same set of refs that a clone directly from the source repository would get, use `--branches --tags` for the `<git-rev-list-args>`."
msgstr "如果你想匹配 `git clone --mirror`，这将包括你的 refs 如 `refs/remotes/*`，使用 `--all`。 如果你想提供与直接从源码库克隆得到的相同的引用，使用 `--branches --tags` 作为 `<git-rev-list-args>`。"

#. type: Plain text
#: en/git-bundle.txt:215
#, priority:100
msgid "The 'git bundle verify' command can be used to check whether your recipient repository has the required prerequisite commits for a bundle."
msgstr "'git bundle verify' 命令可以用来检查你的接收库是否有一个捆绑包所需的先决条件提交。"

#. type: Plain text
#: en/git-bundle.txt:224
#, priority:100
msgid "Assume you want to transfer the history from a repository R1 on machine A to another repository R2 on machine B.  For whatever reason, direct connection between A and B is not allowed, but we can move data from A to B via some mechanism (CD, email, etc.).  We want to update R2 with development made on the branch master in R1."
msgstr "假设你想把 A 机器上的版本库 R1 的历史记录转移到 B 机器上的另一个版本库 R2。由于某种原因，A 和 B 之间不允许直接连接，但我们可以通过某种机制（CD、电子邮件等）把数据从 A 转移到 B。 我们想用 R1 中的分支 master 上的开发来更新 R2。"

#. type: Plain text
#: en/git-bundle.txt:229
#, priority:100
msgid "To bootstrap the process, you can first create a bundle that does not have any prerequisites. You can use a tag to remember up to what commit you last processed, in order to make it easy to later update the other repository with an incremental bundle:"
msgstr "为了启动这个过程，你可以先创建一个没有任何先决条件的捆绑包。你可以使用一个标签来记住你最后处理的提交，以方便以后用增量的捆绑包来更新其他仓库："

#. type: delimited block -
#: en/git-bundle.txt:234
#, no-wrap, priority:100
msgid ""
"machineA$ cd R1\n"
"machineA$ git bundle create file.bundle master\n"
"machineA$ git tag -f lastR2bundle master\n"
msgstr ""
"machineA$ cd R1\n"
"machineA$ git bundle create file.bundle master\n"
"machineA$ git tag -f lastR2bundle master\n"

#. type: Plain text
#: en/git-bundle.txt:239
#, priority:100
msgid "Then you transfer file.bundle to the target machine B. Because this bundle does not require any existing object to be extracted, you can create a new repository on machine B by cloning from it:"
msgstr "然后你把 file.bundle 传输到目标机器 B。因为这个捆绑包不需要提取任何现有的对象，你可以通过克隆它在机器 B 上创建一个新的仓库："

#. type: delimited block -
#: en/git-bundle.txt:242
#, no-wrap, priority:100
msgid "machineB$ git clone -b master /home/me/tmp/file.bundle R2\n"
msgstr "机器 B $ git clone -b master /home/me/tmp/file.bundle R2\n"

#. type: Plain text
#: en/git-bundle.txt:247
#, priority:100
msgid "This will define a remote called \"origin\" in the resulting repository that lets you fetch and pull from the bundle. The $GIT_DIR/config file in R2 will have an entry like this:"
msgstr "这将在生成的版本库中定义一个名为 \"origin\" 的远程，让你从捆绑包中获取和拉取。R2 中的 $GIT_DIR/config 文件将有一个这样的条目："

#. type: delimited block -
#: en/git-bundle.txt:252
#, fuzzy, no-wrap, priority:100
msgid ""
"[remote \"origin\"]\n"
"    url = /home/me/tmp/file.bundle\n"
"    fetch = refs/heads/*:refs/remotes/origin/*\n"
msgstr ""
"[remote \"origin\"]\n"
"    url = /home/me/tmp/file.bundle\n"
"    fetch = refs/heads/*:refs/remotes/origin/*\n"

#. type: Plain text
#: en/git-bundle.txt:257
#, priority:100
msgid "To update the resulting mine.git repository, you can fetch or pull after replacing the bundle stored at /home/me/tmp/file.bundle with incremental updates."
msgstr "要更新产生的 mine.git 仓库，你可以在用增量更新替换存储在 /home/me/tmp/file.bundle 的捆绑包后取用或拉取。"

#. type: Plain text
#: en/git-bundle.txt:260
#, priority:100
msgid "After working some more in the original repository, you can create an incremental bundle to update the other repository:"
msgstr "在原始仓库中再工作一段时间后，你可以创建一个增量包来更新另一个版本库："

#. type: delimited block -
#: en/git-bundle.txt:265
#, no-wrap, priority:100
msgid ""
"machineA$ cd R1\n"
"machineA$ git bundle create file.bundle lastR2bundle..master\n"
"machineA$ git tag -f lastR2bundle master\n"
msgstr ""
"机器 A $ cd R1\n"
"机器 A $ git bundle create file.bundle lastR2bundle..master\n"
"机器 A $ git tag -f lastR2bundle master\n"

#. type: Plain text
#: en/git-bundle.txt:269
#, priority:100
msgid "You then transfer the bundle to the other machine to replace /home/me/tmp/file.bundle, and pull from it."
msgstr "然后你把捆绑包转移到另一台机器上，以取代 /home/me/tmp/file.bundle，并从其中提取。"

#. type: delimited block -
#: en/git-bundle.txt:273
#, no-wrap, priority:100
msgid ""
"machineB$ cd R2\n"
"machineB$ git pull\n"
msgstr ""
"机器 B $ cd R2\n"
"机器 B $ git pull\n"

#. type: Plain text
#: en/git-bundle.txt:281
#, priority:100
msgid "If you know up to what commit the intended recipient repository should have the necessary objects, you can use that knowledge to specify the prerequisites, giving a cut-off point to limit the revisions and objects that go in the resulting bundle. The previous example used the lastR2bundle tag for this purpose, but you can use any other options that you would give to the linkgit:git-log[1] command. Here are more examples:"
msgstr "如果你知道预期的接收库应该在哪次提交中拥有必要的对象，你可以用这些知识来指定先决条件，给出一个截止点来限制产生的捆绑包中的修订和对象。前面的例子为此使用了 lastR2bundle 标签，但你也可以使用任何其他选项，就像你给 linkgit:git-log[1] 命令的那样。这里有更多的例子："

#. type: Plain text
#: en/git-bundle.txt:283
#, priority:100
msgid "You can use a tag that is present in both:"
msgstr "你可以使用一个在两者中都存在的标签："

#. type: delimited block -
#: en/git-bundle.txt:286
#, fuzzy, no-wrap, priority:100
msgid "$ git bundle create mybundle v1.0.0..master\n"
msgstr "$ git bundle create mybundle v1.0.0..master\n"

#. type: Plain text
#: en/git-bundle.txt:289
#, priority:100
msgid "You can use a prerequisite based on time:"
msgstr "你可以使用基于时间的先决条件："

#. type: delimited block -
#: en/git-bundle.txt:292
#, fuzzy, no-wrap, priority:100
msgid "$ git bundle create mybundle --since=10.days master\n"
msgstr "$ git bundle create mybundle --since=10.days master\n"

#. type: Plain text
#: en/git-bundle.txt:295
#, priority:100
msgid "You can use the number of commits:"
msgstr "你可以使用提交的数量："

#. type: delimited block -
#: en/git-bundle.txt:298
#, fuzzy, no-wrap, priority:100
msgid "$ git bundle create mybundle -10 master\n"
msgstr "$ git bundle create mybundle -10 master\n"

#. type: Plain text
#: en/git-bundle.txt:302
#, priority:100
msgid "You can run `git-bundle verify` to see if you can extract from a bundle that was created with a prerequisite:"
msgstr "你可以运行 `git-bundle verify` 来看看你是否可以从一个用先决条件创建的包中提取："

#. type: delimited block -
#: en/git-bundle.txt:305
#, fuzzy, no-wrap, priority:100
msgid "$ git bundle verify mybundle\n"
msgstr "$ git bundle verify mybundle\n"

#. type: Plain text
#: en/git-bundle.txt:309
#, priority:100
msgid "This will list what commits you must have in order to extract from the bundle and will error out if you do not have them."
msgstr "这将列出你必须有哪些提交才能从捆绑包中提取，如果你没有这些提交就会出错。"

#. type: Plain text
#: en/git-bundle.txt:313
#, priority:100
msgid "A bundle from a recipient repository's point of view is just like a regular repository which it fetches or pulls from. You can, for example, map references when fetching:"
msgstr "从接收者仓库的角度来看，一个捆绑包就像一个普通的仓库，它从那里获取或拉取。例如，你可以在获取的时候映射引用："

#. type: delimited block -
#: en/git-bundle.txt:316
#, fuzzy, no-wrap, priority:100
msgid "$ git fetch mybundle master:localRef\n"
msgstr "$ git fetch mybundle master:localRef\n"

#. type: Plain text
#: en/git-bundle.txt:319
#, priority:100
msgid "You can also see what references it offers:"
msgstr "你也可以看看它提供哪些引用："

#. type: delimited block -
#: en/git-bundle.txt:322
#, fuzzy, no-wrap, priority:100
msgid "$ git ls-remote mybundle\n"
msgstr "$ git ls-remote mybundle\n"

#. type: Title -
#: en/git-bundle.txt:325
#, fuzzy, no-wrap, priority:100
msgid "FILE FORMAT"
msgstr "日期格式"

#. type: Plain text
#: en/git-bundle.txt:328
#, fuzzy, priority:100
msgid "See linkgit:gitformat-bundle[5]."
msgstr "linkgit:git-add[1]"

#. type: Title =
#: en/git-cat-file.txt:2
#, ignore-same, no-wrap, priority:80
msgid "git-cat-file(1)"
msgstr "git-cat-file(1)"

#. type: Plain text
#: en/git-cat-file.txt:7
#, fuzzy, priority:80
msgid "git-cat-file - Provide content or type and size information for repository objects"
msgstr "git-cat-file - Provide content or type and size information for repository objects"

#. type: Plain text
#: en/git-cat-file.txt:20
#, no-wrap, priority:80
msgid ""
"'git cat-file' <type> <object>\n"
"'git cat-file' (-e | -p) <object>\n"
"'git cat-file' (-t | -s) [--allow-unknown-type] <object>\n"
"'git cat-file' (--batch | --batch-check | --batch-command) [--batch-all-objects]\n"
"\t     [--buffer] [--follow-symlinks] [--unordered]\n"
"\t     [--textconv | --filters] [-Z]\n"
"'git cat-file' (--textconv | --filters)\n"
"\t     [<rev>:<path|tree-ish> | --path=<path|tree-ish> <rev>]\n"
msgstr ""

#. type: Plain text
#: en/git-cat-file.txt:27
#, priority:80
msgid "In its first form, the command provides the content or the type of an object in the repository. The type is required unless `-t` or `-p` is used to find the object type, or `-s` is used to find the object size, or `--textconv` or `--filters` is used (which imply type \"blob\")."
msgstr ""

#. type: Plain text
#: en/git-cat-file.txt:34
#, priority:80
msgid "In the second form, a list of objects (separated by linefeeds) is provided on stdin, and the SHA-1, type, and size of each object is printed on stdout. The output format can be overridden using the optional `<format>` argument. If either `--textconv` or `--filters` was specified, the input is expected to list the object names followed by the path name, separated by a single whitespace, so that the appropriate drivers can be determined."
msgstr ""

#. type: Labeled list
#: en/git-cat-file.txt:37 en/git-fsck.txt:23 en/git-tag.txt:214 en/git.txt:390
#, no-wrap, priority:240
msgid "<object>"
msgstr "<对象>"

#. type: Plain text
#: en/git-cat-file.txt:41
#, priority:80
msgid "The name of the object to show.  For a more complete list of ways to spell object names, see the \"SPECIFYING REVISIONS\" section in linkgit:gitrevisions[7]."
msgstr ""

#. type: Plain text
#: en/git-cat-file.txt:45
#, priority:80
msgid "Instead of the content, show the object type identified by `<object>`."
msgstr ""

#. type: Plain text
#: en/git-cat-file.txt:51
#, priority:80
msgid "Instead of the content, show the object size identified by `<object>`. If used with `--use-mailmap` option, will show the size of updated object after replacing idents using the mailmap mechanism."
msgstr ""

#. type: Plain text
#: en/git-cat-file.txt:56
#, priority:80
msgid "Exit with zero status if `<object>` exists and is a valid object. If `<object>` is of an invalid format exit with non-zero and emits an error on stderr."
msgstr ""

#. type: Plain text
#: en/git-cat-file.txt:59
#, priority:80
msgid "Pretty-print the contents of `<object>` based on its type."
msgstr ""

#. type: Labeled list
#: en/git-cat-file.txt:60 en/git.txt:414
#, no-wrap, priority:100
msgid "<type>"
msgstr "<类型>"

#. type: Plain text
#: en/git-cat-file.txt:67
#, priority:80
msgid "Typically this matches the real type of `<object>` but asking for a type that can trivially be dereferenced from the given `<object>` is also permitted.  An example is to ask for a \"tree\" with `<object>` being a commit object that contains it, or to ask for a \"blob\" with `<object>` being a tag object that points at it."
msgstr ""

#. type: Labeled list
#: en/git-cat-file.txt:68 en/git-log.txt:70
#, ignore-same, no-wrap, priority:260
msgid "--[no-]mailmap"
msgstr "--[no-]mailmap"

#. type: Labeled list
#: en/git-cat-file.txt:69 en/git-log.txt:71
#, ignore-same, no-wrap, priority:260
msgid "--[no-]use-mailmap"
msgstr "--[no-]use-mailmap"

#. type: Plain text
#: en/git-cat-file.txt:73
#, fuzzy, priority:80
#| msgid "Use mailmap file to map author and committer names and email addresses to canonical real names and email addresses. See linkgit:git-shortlog[1]."
msgid "Use mailmap file to map author, committer and tagger names and email addresses to canonical real names and email addresses.  See linkgit:git-shortlog[1]."
msgstr "使用 mailmap 文件将作者和提交者的名字和电子邮件地址映射为规范的真实姓名和电子邮件地址。参见 linkgit:git-shortlog[1]。"

#. type: Plain text
#: en/git-cat-file.txt:79
#, priority:80
msgid "Show the content as transformed by a textconv filter. In this case, `<object>` has to be of the form `<tree-ish>:<path>`, or `:<path>` in order to apply the filter to the content recorded in the index at `<path>`."
msgstr ""

#. type: Labeled list
#: en/git-cat-file.txt:80
#, ignore-same, no-wrap, priority:80
msgid "--filters"
msgstr "--filters"

#. type: Plain text
#: en/git-cat-file.txt:85
#, priority:80
msgid "Show the content as converted by the filters configured in the current working tree for the given `<path>` (i.e. smudge filters, end-of-line conversion, etc). In this case, `<object>` has to be of the form `<tree-ish>:<path>`, or `:<path>`."
msgstr ""

#. type: Labeled list
#: en/git-cat-file.txt:86
#, fuzzy, no-wrap, priority:80
msgid "--path=<path>"
msgstr "--path=<path>"

#. type: Plain text
#: en/git-cat-file.txt:90
#, priority:80
msgid "For use with `--textconv` or `--filters`, to allow specifying an object name and a path separately, e.g. when it is difficult to figure out the revision from which the blob came."
msgstr ""

#. type: Labeled list
#: en/git-cat-file.txt:91 en/git-mktree.txt:32
#, ignore-same, no-wrap, priority:100
msgid "--batch"
msgstr "--batch"

#. type: Labeled list
#: en/git-cat-file.txt:92
#, fuzzy, no-wrap, priority:80
msgid "--batch=<format>"
msgstr "--batch=<format>"

#. type: Plain text
#: en/git-cat-file.txt:96
#, priority:80
msgid "Print object information and contents for each object provided on stdin. May not be combined with any other options or arguments except `--textconv`, `--filters`, or `--use-mailmap`."
msgstr ""

#. type: Plain text
#: en/git-cat-file.txt:101 en/git-cat-file.txt:135
#, priority:80
msgid "When used with `--textconv` or `--filters`, the input lines must specify the path, separated by whitespace. See the section `BATCH OUTPUT` below for details."
msgstr ""

#. type: Plain text
#: en/git-cat-file.txt:107
#, priority:80
msgid "When used with `--use-mailmap`, for commit and tag objects, the contents part of the output shows the identities replaced using the mailmap mechanism, while the information part of the output shows the size of the object as if it actually recorded the replacement identities."
msgstr ""

#. type: Labeled list
#: en/git-cat-file.txt:109
#, ignore-same, no-wrap, priority:80
msgid "--batch-check"
msgstr "--batch-check"

#. type: Labeled list
#: en/git-cat-file.txt:110
#, no-wrap, priority:80
msgid "--batch-check=<format>"
msgstr ""

#. type: Plain text
#: en/git-cat-file.txt:114
#, priority:80
msgid "Print object information for each object provided on stdin. May not be combined with any other options or arguments except `--textconv`, `--filters` or `--use-mailmap`."
msgstr ""

#. type: Plain text
#: en/git-cat-file.txt:117
#, priority:80
msgid "When used with `--textconv` or `--filters`, the input lines must"
msgstr ""

#. type: Plain text
#: en/git-cat-file.txt:119
#, no-wrap, priority:80
msgid ""
"specify the path, separated by whitespace. See the section\n"
"`BATCH OUTPUT` below for details.\n"
msgstr ""

#. type: Plain text
#: en/git-cat-file.txt:123
#, priority:80
msgid "When used with `--use-mailmap`, for commit and tag objects, the printed object information shows the size of the object as if the identities recorded in it were replaced by the mailmap mechanism."
msgstr ""

#. type: Labeled list
#: en/git-cat-file.txt:125
#, ignore-same, no-wrap, priority:80
msgid "--batch-command"
msgstr "--batch-command"

#. type: Labeled list
#: en/git-cat-file.txt:126
#, fuzzy, no-wrap, priority:80
msgid "--batch-command=<format>"
msgstr "--batch=<format>"

#. type: Plain text
#: en/git-cat-file.txt:130
#, priority:80
msgid "Enter a command mode that reads commands and arguments from stdin. May only be combined with `--buffer`, `--textconv`, `--use-mailmap` or `--filters`."
msgstr ""

#. type: Plain text
#: en/git-cat-file.txt:141
#, priority:80
msgid "When used with `--use-mailmap`, for commit and tag objects, the `contents` command shows the identities replaced using the mailmap mechanism, while the `info` command shows the size of the object as if it actually recorded the replacement identities."
msgstr ""

#. type: Plain text
#: en/git-cat-file.txt:144
#, fuzzy, priority:80
msgid "`--batch-command` recognizes the following commands:"
msgstr "支持以下日期格式："

#. type: Labeled list
#: en/git-cat-file.txt:146
#, fuzzy, no-wrap, priority:80
msgid "contents <object>"
msgstr "--contains[=<object>]"

#. type: Plain text
#: en/git-cat-file.txt:149
#, priority:80
msgid "Print object contents for object reference `<object>`. This corresponds to the output of `--batch`."
msgstr ""

#. type: Labeled list
#: en/git-cat-file.txt:150
#, fuzzy, no-wrap, priority:80
#| msgid "-C <object>"
msgid "info <object>"
msgstr "-C <对象>"

#. type: Plain text
#: en/git-cat-file.txt:153
#, priority:80
msgid "Print object info for object reference `<object>`. This corresponds to the output of `--batch-check`."
msgstr ""

#. type: Labeled list
#: en/git-cat-file.txt:154
#, no-wrap, priority:80
msgid "flush"
msgstr ""

#. type: Plain text
#: en/git-cat-file.txt:159
#, priority:80
msgid "Used with `--buffer` to execute all preceding commands that were issued since the beginning or since the last flush was issued. When `--buffer` is used, no output will come until a `flush` is issued. When `--buffer` is not used, commands are flushed each time without issuing `flush`."
msgstr ""

#. type: Labeled list
#: en/git-cat-file.txt:162
#, ignore-same, no-wrap, priority:80
msgid "--batch-all-objects"
msgstr "--batch-all-objects"

#. type: Plain text
#: en/git-cat-file.txt:170
#, priority:80
msgid "Instead of reading a list of objects on stdin, perform the requested batch operation on all objects in the repository and any alternate object stores (not just reachable objects).  Requires `--batch` or `--batch-check` be specified. By default, the objects are visited in order sorted by their hashes; see also `--unordered` below. Objects are presented as-is, without respecting the \"replace\" mechanism of linkgit:git-replace[1]."
msgstr ""

#. type: Labeled list
#: en/git-cat-file.txt:171
#, ignore-same, no-wrap, priority:80
msgid "--buffer"
msgstr "--buffer"

#. type: Plain text
#: en/git-cat-file.txt:177
#, priority:80
msgid "Normally batch output is flushed after each object is output, so that a process can interactively read and write from `cat-file`. With this option, the output uses normal stdio buffering; this is much more efficient when invoking `--batch-check` or `--batch-command` on a large number of objects."
msgstr ""

#. type: Labeled list
#: en/git-cat-file.txt:178
#, ignore-same, no-wrap, priority:80
msgid "--unordered"
msgstr "--unordered"

#. type: Plain text
#: en/git-cat-file.txt:187
#, priority:80
msgid "When `--batch-all-objects` is in use, visit objects in an order which may be more efficient for accessing the object contents than hash order. The exact details of the order are unspecified, but if you do not require a specific order, this should generally result in faster output, especially with `--batch`.  Note that `cat-file` will still show each object only once, even if it is stored multiple times in the repository."
msgstr ""

#. type: Labeled list
#: en/git-cat-file.txt:188
#, ignore-same, no-wrap, priority:80
msgid "--allow-unknown-type"
msgstr "--allow-unknown-type"

#. type: Plain text
#: en/git-cat-file.txt:190
#, priority:80
msgid "Allow `-s` or `-t` to query broken/corrupt objects of unknown type."
msgstr ""

#. type: Labeled list
#: en/git-cat-file.txt:191
#, ignore-same, no-wrap, priority:80
msgid "--follow-symlinks"
msgstr "--follow-symlinks"

#. type: Plain text
#: en/git-cat-file.txt:200
#, priority:80
msgid "With `--batch` or `--batch-check`, follow symlinks inside the repository when requesting objects with extended SHA-1 expressions of the form tree-ish:path-in-tree.  Instead of providing output about the link itself, provide output about the linked-to object.  If a symlink points outside the tree-ish (e.g. a link to `/foo` or a root-level link to `../foo`), the portion of the link which is outside the tree will be printed."
msgstr ""

#. type: Plain text
#: en/git-cat-file.txt:204
#, priority:80
msgid "This option does not (currently) work correctly when an object in the index is specified (e.g. `:link` instead of `HEAD:link`) rather than one in the tree."
msgstr ""

#. type: Plain text
#: en/git-cat-file.txt:207
#, priority:80
msgid "This option cannot (currently) be used unless `--batch` or `--batch-check` is used."
msgstr ""

#. type: Plain text
#: en/git-cat-file.txt:209
#, priority:80
msgid "For example, consider a git repository containing:"
msgstr ""

#. type: Plain text
#: en/git-cat-file.txt:216
#, no-wrap, priority:80
msgid ""
"\tf: a file containing \"hello\\n\"\n"
"\tlink: a symlink to f\n"
"\tdir/link: a symlink to ../f\n"
"\tplink: a symlink to ../f\n"
"\talink: a symlink to /etc/passwd\n"
msgstr ""

#. type: Plain text
#: en/git-cat-file.txt:219
#, priority:80
msgid "For a regular file `f`, `echo HEAD:f | git cat-file --batch` would print"
msgstr ""

#. type: Plain text
#: en/git-cat-file.txt:222
#, no-wrap, priority:80
msgid "\tce013625030ba8dba906f756967f9e9ca394464a blob 6\n"
msgstr ""

#. type: Plain text
#: en/git-cat-file.txt:227
#, priority:80
msgid "And `echo HEAD:link | git cat-file --batch --follow-symlinks` would print the same thing, as would `HEAD:dir/link`, as they both point at `HEAD:f`."
msgstr ""

#. type: Plain text
#: en/git-cat-file.txt:230
#, priority:80
msgid "Without `--follow-symlinks`, these would print data about the symlink itself.  In the case of `HEAD:link`, you would see"
msgstr ""

#. type: Plain text
#: en/git-cat-file.txt:233
#, no-wrap, priority:80
msgid "\t4d1ae35ba2c8ec712fa2a379db44ad639ca277bd blob 1\n"
msgstr ""

#. type: Plain text
#: en/git-cat-file.txt:237
#, priority:80
msgid "Both `plink` and `alink` point outside the tree, so they would respectively print:"
msgstr ""

#. type: Plain text
#: en/git-cat-file.txt:241
#, no-wrap, priority:80
msgid ""
"\tsymlink 4\n"
"\t../f\n"
msgstr ""

#. type: Plain text
#: en/git-cat-file.txt:244
#, no-wrap, priority:80
msgid ""
"\tsymlink 11\n"
"\t/etc/passwd\n"
msgstr ""

#. type: Labeled list
#: en/git-cat-file.txt:246
#, fuzzy, no-wrap, priority:80
msgid "-Z"
msgstr "-"

#. type: Plain text
#: en/git-cat-file.txt:250
#, priority:80
msgid "Only meaningful with `--batch`, `--batch-check`, or `--batch-command`; input and output is NUL-delimited instead of newline-delimited."
msgstr ""

#. type: Plain text
#: en/git-cat-file.txt:256
#, priority:80
msgid "Only meaningful with `--batch`, `--batch-check`, or `--batch-command`; input is NUL-delimited instead of newline-delimited. This option is deprecated in favor of `-Z` as the output can otherwise be ambiguous."
msgstr ""

#. type: Title -
#: en/git-cat-file.txt:259 en/git-check-attr.txt:53 en/git-check-ignore.txt:66 en/git-check-mailmap.txt:32 en/git-cvsimport.txt:188 en/git-fetch.txt:194 en/git-ls-files.txt:233 en/git-ls-remote.txt:100 en/git-merge-tree.txt:74 en/git-push.txt:438 en/git-show-branch.txt:133 en/git-show-ref.txt:97 en/git-status.txt:156 en/git-update-server-info.txt:29
#, no-wrap, priority:280
msgid "OUTPUT"
msgstr "输出"

#. type: Plain text
#: en/git-cat-file.txt:261
#, priority:80
msgid "If `-t` is specified, one of the `<type>`."
msgstr ""

#. type: Plain text
#: en/git-cat-file.txt:263
#, priority:80
msgid "If `-s` is specified, the size of the `<object>` in bytes."
msgstr ""

#. type: Plain text
#: en/git-cat-file.txt:265
#, priority:80
msgid "If `-e` is specified, no output, unless the `<object>` is malformed."
msgstr ""

#. type: Plain text
#: en/git-cat-file.txt:267
#, priority:80
msgid "If `-p` is specified, the contents of `<object>` are pretty-printed."
msgstr ""

#. type: Plain text
#: en/git-cat-file.txt:270
#, priority:80
msgid "If `<type>` is specified, the raw (though uncompressed) contents of the `<object>` will be returned."
msgstr ""

#. type: Title -
#: en/git-cat-file.txt:272
#, no-wrap, priority:80
msgid "BATCH OUTPUT"
msgstr ""

#. type: Plain text
#: en/git-cat-file.txt:278
#, priority:80
msgid "If `--batch` or `--batch-check` is given, `cat-file` will read objects from stdin, one per line, and print information about them. By default, the whole line is considered as an object, as if it were fed to linkgit:git-rev-parse[1]."
msgstr ""

#. type: Plain text
#: en/git-cat-file.txt:285
#, priority:80
msgid "When `--batch-command` is given, `cat-file` will read commands from stdin, one per line, and print information based on the command given. With `--batch-command`, the `info` command followed by an object will print information about the object the same way `--batch-check` would, and the `contents` command followed by an object prints contents in the same way `--batch` would."
msgstr ""

#. type: Plain text
#: en/git-cat-file.txt:290
#, priority:80
msgid "You can specify the information shown for each object by using a custom `<format>`. The `<format>` is copied literally to stdout for each object, with placeholders of the form `%(atom)` expanded, followed by a newline. The available atoms are:"
msgstr ""

#. type: Labeled list
#: en/git-cat-file.txt:291
#, ignore-same, no-wrap, priority:80
msgid "`objectname`"
msgstr "`objectname`"

#. type: Plain text
#: en/git-cat-file.txt:293
#, priority:80
msgid "The full hex representation of the object name."
msgstr ""

#. type: Labeled list
#: en/git-cat-file.txt:294
#, ignore-same, no-wrap, priority:80
msgid "`objecttype`"
msgstr "`objecttype`"

#. type: Plain text
#: en/git-cat-file.txt:296
#, priority:80
msgid "The type of the object (the same as `cat-file -t` reports)."
msgstr ""

#. type: Labeled list
#: en/git-cat-file.txt:297
#, ignore-same, no-wrap, priority:80
msgid "`objectsize`"
msgstr "`objectsize`"

#. type: Plain text
#: en/git-cat-file.txt:300
#, priority:80
msgid "The size, in bytes, of the object (the same as `cat-file -s` reports)."
msgstr ""

#. type: Labeled list
#: en/git-cat-file.txt:301
#, no-wrap, priority:80
msgid "`objectsize:disk`"
msgstr ""

#. type: Plain text
#: en/git-cat-file.txt:304
#, priority:80
msgid "The size, in bytes, that the object takes up on disk. See the note about on-disk sizes in the `CAVEATS` section below."
msgstr ""

#. type: Labeled list
#: en/git-cat-file.txt:305
#, ignore-same, no-wrap, priority:80
msgid "`deltabase`"
msgstr "`deltabase`"

#. type: Plain text
#: en/git-cat-file.txt:310
#, priority:80
msgid "If the object is stored as a delta on-disk, this expands to the full hex representation of the delta base object name.  Otherwise, expands to the null OID (all zeroes). See `CAVEATS` below."
msgstr ""

#. type: Labeled list
#: en/git-cat-file.txt:311
#, ignore-same, no-wrap, priority:80
msgid "`rest`"
msgstr "`rest`"

#. type: Plain text
#: en/git-cat-file.txt:317
#, priority:80
msgid "If this atom is used in the output string, input lines are split at the first whitespace boundary. All characters before that whitespace are considered to be the object name; characters after that first run of whitespace (i.e., the \"rest\" of the line) are output in place of the `%(rest)` atom."
msgstr ""

#. type: Plain text
#: en/git-cat-file.txt:320
#, priority:80
msgid "If no format is specified, the default format is `%(objectname)  %(objecttype) %(objectsize)`."
msgstr ""

#. type: Plain text
#: en/git-cat-file.txt:324
#, priority:80
msgid "If `--batch` is specified, or if `--batch-command` is used with the `contents` command, the object information is followed by the object contents (consisting of `%(objectsize)` bytes), followed by a newline."
msgstr ""

#. type: Plain text
#: en/git-cat-file.txt:326
#, priority:80
msgid "For example, `--batch` without a custom format would produce:"
msgstr ""

#. type: delimited block -
#: en/git-cat-file.txt:330
#, no-wrap, priority:80
msgid ""
"<oid> SP <type> SP <size> LF\n"
"<contents> LF\n"
msgstr ""

#. type: Plain text
#: en/git-cat-file.txt:333
#, priority:80
msgid "Whereas `--batch-check='%(objectname) %(objecttype)'` would produce:"
msgstr ""

#. type: delimited block -
#: en/git-cat-file.txt:336
#, no-wrap, priority:80
msgid "<oid> SP <type> LF\n"
msgstr ""

#. type: Plain text
#: en/git-cat-file.txt:340
#, priority:80
msgid "If a name is specified on stdin that cannot be resolved to an object in the repository, then `cat-file` will ignore any custom format and print:"
msgstr ""

#. type: delimited block -
#: en/git-cat-file.txt:343 en/git-cat-file.txt:369
#, no-wrap, priority:80
msgid "<object> SP missing LF\n"
msgstr ""

#. type: Plain text
#: en/git-cat-file.txt:346
#, priority:80
msgid "If a name is specified that might refer to more than one object (an ambiguous short sha), then `cat-file` will ignore any custom format and print:"
msgstr ""

#. type: delimited block -
#: en/git-cat-file.txt:349
#, fuzzy, no-wrap, priority:80
msgid "<object> SP ambiguous LF\n"
msgstr "<object> SP ambiguous LF\n"

#. type: Plain text
#: en/git-cat-file.txt:354
#, priority:80
msgid "If `--follow-symlinks` is used, and a symlink in the repository points outside the repository, then `cat-file` will ignore any custom format and print:"
msgstr ""

#. type: delimited block -
#: en/git-cat-file.txt:358
#, no-wrap, priority:80
msgid ""
"symlink SP <size> LF\n"
"<symlink> LF\n"
msgstr ""

#. type: Plain text
#: en/git-cat-file.txt:363
#, priority:80
msgid "The symlink will either be absolute (beginning with a `/`), or relative to the tree root.  For instance, if dir/link points to `../../foo`, then `<symlink>` will be `../foo`.  `<size>` is the size of the symlink in bytes."
msgstr ""

#. type: Plain text
#: en/git-cat-file.txt:366
#, priority:80
msgid "If `--follow-symlinks` is used, the following error messages will be displayed:"
msgstr ""

#. type: Plain text
#: en/git-cat-file.txt:371
#, priority:80
msgid "is printed when the initial symlink requested does not exist."
msgstr ""

#. type: delimited block -
#: en/git-cat-file.txt:375
#, no-wrap, priority:80
msgid ""
"dangling SP <size> LF\n"
"<object> LF\n"
msgstr ""

#. type: Plain text
#: en/git-cat-file.txt:378
#, priority:80
msgid "is printed when the initial symlink exists, but something that it (transitive-of) points to does not."
msgstr ""

#. type: delimited block -
#: en/git-cat-file.txt:382
#, no-wrap, priority:80
msgid ""
"loop SP <size> LF\n"
"<object> LF\n"
msgstr ""

#. type: Plain text
#: en/git-cat-file.txt:385
#, priority:80
msgid "is printed for symlink loops (or any symlinks that require more than 40 link resolutions to resolve)."
msgstr ""

#. type: delimited block -
#: en/git-cat-file.txt:389
#, no-wrap, priority:80
msgid ""
"notdir SP <size> LF\n"
"<object> LF\n"
msgstr ""

#. type: Plain text
#: en/git-cat-file.txt:392
#, priority:80
msgid "is printed when, during symlink resolution, a file is used as a directory name."
msgstr ""

#. type: Plain text
#: en/git-cat-file.txt:397
#, priority:80
msgid "Alternatively, when `-Z` is passed, the line feeds in any of the above examples are replaced with NUL terminators. This ensures that output will be parsable if the output itself would contain a linefeed and is thus recommended for scripting purposes."
msgstr ""

#. type: Title -
#: en/git-cat-file.txt:399 en/git-for-each-ref.txt:473 en/git-format-patch.txt:758 en/git-svn.txt:998
#, no-wrap, priority:100
msgid "CAVEATS"
msgstr "注意事项"

#. type: Plain text
#: en/git-cat-file.txt:407 en/git-for-each-ref.txt:481
#, priority:80
msgid "Note that the sizes of objects on disk are reported accurately, but care should be taken in drawing conclusions about which refs or objects are responsible for disk usage. The size of a packed non-delta object may be much larger than the size of objects which delta against it, but the choice of which object is the base and which is the delta is arbitrary and is subject to change during a repack."
msgstr ""

#. type: Plain text
#: en/git-cat-file.txt:411 en/git-for-each-ref.txt:485
#, priority:80
msgid "Note also that multiple copies of an object may be present in the object database; in this case, it is undefined which copy's size or delta base will be reported."
msgstr ""

#. type: Title =
#: en/git-check-attr.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-check-attr(1)"
msgstr "git-check-attr(1)"

#. type: Plain text
#: en/git-check-attr.txt:7
#, priority:100
msgid "git-check-attr - Display gitattributes information"
msgstr "git-check-attr - 显示 gitattributes 信息"

#. type: Plain text
#: en/git-check-attr.txt:14
#, ignore-ellipsis, no-wrap, priority:100
msgid ""
"'git check-attr' [--source <tree-ish>] [-a | --all | <attr>...] [--] <pathname>...\n"
"'git check-attr' --stdin [-z] [--source <tree-ish>] [-a | --all | <attr>...]\n"
msgstr ""
"'git check-attr' [--source <树状对象>] [-a | --all | <属性>...] [--] <路径名>...\n"
"'git check-attr' --stdin [-z] [--source <树状对象>] [-a | --all | <属性>...]\n"

#. type: Plain text
#: en/git-check-attr.txt:19
#, priority:100
msgid "For every pathname, this command will list if each attribute is 'unspecified', 'set', or 'unset' as a gitattribute on that pathname."
msgstr "对于每个路径名，该命令将列出每个属性是否为 “未指定”、“已设置” 或 “未设置”，作为该路径名的 gitattribute。"

#. type: Labeled list
#: en/git-check-attr.txt:22
#, fuzzy, no-wrap, priority:100
msgid "-a, --all"
msgstr "-a, --all"

#. type: Plain text
#: en/git-check-attr.txt:26
#, priority:100
msgid "List all attributes that are associated with the specified paths.  If this option is used, then 'unspecified' attributes will not be included in the output."
msgstr "列出与指定路径相关的所有属性。 如果使用这个选项，那么 “未指定的” 属性将不包括在输出中。"

#. type: Plain text
#: en/git-check-attr.txt:29
#, priority:100
msgid "Consider `.gitattributes` in the index only, ignoring the working tree."
msgstr "只考虑索引中的 `.gitattributes`，忽略工作区。"

#. type: Labeled list
#: en/git-check-attr.txt:30 en/git-check-ignore.txt:43 en/git-check-mailmap.txt:26 en/git-checkout-index.txt:68 en/git-diff-tree.txt:51 en/git-fetch-pack.txt:38 en/git-fetch.txt:51 en/git-for-each-ref.txt:37 en/git-hash-object.txt:34 en/git-http-fetch.txt:37 en/git-index-pack.txt:46 en/git-notes.txt:198 en/git-send-pack.txt:42 en/git-svn.txt:595 en/git-update-index.txt:153 en/rev-list-options.txt:238
#, ignore-same, no-wrap, priority:280
msgid "--stdin"
msgstr "--stdin"

#. type: Plain text
#: en/git-check-attr.txt:33 en/git-check-ignore.txt:46
#, priority:100
msgid "Read pathnames from the standard input, one per line, instead of from the command-line."
msgstr "从标准输入中读取路径名，每行一个，而不是从命令行读取。"

#. type: Plain text
#: en/git-check-attr.txt:38
#, priority:100
msgid "The output format is modified to be machine-parsable.  If `--stdin` is also given, input paths are separated with a NUL character instead of a linefeed character."
msgstr "输出格式被修改为机器可解析的。 如果同时给出 `--stdin`，输入路径将用 NUL 字符而不是换行符来分隔。"

#. type: Labeled list
#: en/git-check-attr.txt:39
#, fuzzy, no-wrap, priority:100
#| msgid "--source=<tree>"
msgid "--source=<tree-ish>"
msgstr "--source=<tree>（来源）。"

#. type: Plain text
#: en/git-check-attr.txt:43
#, fuzzy, priority:100
#| msgid "Restore the working tree files with the content from the given tree. It is common to specify the source tree by naming a commit, branch or tag associated with it."
msgid "Check attributes against the specified tree-ish. It is common to specify the source tree by naming a commit, branch or tag associated with it."
msgstr "用给定树的内容恢复工作树的文件。通常是通过命名与之相关的提交、分支或标签来指定源树。"

#. type: Plain text
#: en/git-check-attr.txt:47
#, priority:100
msgid "Interpret all preceding arguments as attributes and all following arguments as path names."
msgstr "将前面的所有参数解释为属性，后面的所有参数解释为路径名称。"

#. type: Plain text
#: en/git-check-attr.txt:51
#, priority:100
msgid "If none of `--stdin`, `--all`, or `--` is used, the first argument will be treated as an attribute and the rest of the arguments as pathnames."
msgstr "如果没有使用 `--stdin`、`--all` 或 `--`，第一个参数将被视为一个属性，其余的参数将被视为路径名。"

#. type: Plain text
#: en/git-check-attr.txt:57
#, priority:100
msgid "The output is of the form: <path> COLON SP <attribute> COLON SP <info> LF"
msgstr "输出的形式是： <路径> COLON SP <属性> COLON SP <信息> LF"

#. type: Plain text
#: en/git-check-attr.txt:60
#, priority:100
msgid "unless `-z` is in effect, in which case NUL is used as delimiter: <path> NUL <attribute> NUL <info> NUL"
msgstr "除非 `-z` 生效，在这种情况下，使用 NUL 作为分隔符： <路径> NUL <属性> NUL <信息> NUL"

#. type: Plain text
#: en/git-check-attr.txt:64
#, priority:100
msgid "<path> is the path of a file being queried, <attribute> is an attribute being queried and <info> can be either:"
msgstr "<路径> 是被查询的文件的路径，<属性> 是被查询的属性，<信息> 可以是任何一种："

#. type: Labeled list
#: en/git-check-attr.txt:65
#, ignore-same, no-wrap, priority:100
msgid "'unspecified'"
msgstr "'unspecified'"

#. type: Plain text
#: en/git-check-attr.txt:66
#, priority:100
msgid "when the attribute is not defined for the path."
msgstr "当该属性未被定义为路径时。"

#. type: Labeled list
#: en/git-check-attr.txt:66
#, ignore-same, no-wrap, priority:100
msgid "'unset'"
msgstr "'unset'"

#. type: Plain text
#: en/git-check-attr.txt:67
#, priority:100
msgid "when the attribute is defined as false."
msgstr "当该属性被定义为 false 时。"

#. type: Labeled list
#: en/git-check-attr.txt:67
#, ignore-same, no-wrap, priority:100
msgid "'set'"
msgstr "'set'"

#. type: Plain text
#: en/git-check-attr.txt:68
#, priority:100
msgid "when the attribute is defined as true."
msgstr "当该属性被定义为真时。"

#. type: Labeled list
#: en/git-check-attr.txt:68
#, no-wrap, priority:100
msgid "<value>"
msgstr "<值>"

#. type: Plain text
#: en/git-check-attr.txt:69
#, priority:100
msgid "when a value has been assigned to the attribute."
msgstr "当一个值被分配给该属性时。"

#. type: Plain text
#: en/git-check-attr.txt:74 en/git-check-ignore.txt:105
#, priority:100
msgid "Buffering happens as documented under the `GIT_FLUSH` option in linkgit:git[1].  The caller is responsible for avoiding deadlocks caused by overfilling an input buffer or reading from an empty output buffer."
msgstr "缓冲发生在 linkgit:git[1] 中的 `GIT_FLUSH` 选项下的记录。 调用者负责避免因过度填充输入缓冲区或从空的输出缓冲区读取而造成的死锁。"

#. type: Plain text
#: en/git-check-attr.txt:79
#, priority:100
msgid "In the examples, the following '.gitattributes' file is used:"
msgstr "在例子中，使用了以下 '.gitattributes' 文件："

#. type: delimited block -
#: en/git-check-attr.txt:83
#, fuzzy, no-wrap, priority:100
msgid ""
"*.java diff=java -crlf myAttr\n"
"NoMyAttr.java !myAttr\n"
"README caveat=unspecified\n"
msgstr ""
"*.java diff=java -crlf myAttr\n"
"NoMyAttr.java !myAttr\n"
"README caveat=unspecified\n"

#. type: Plain text
#: en/git-check-attr.txt:86
#, priority:100
msgid "Listing a single attribute:"
msgstr "列出一个单一属性："

#. type: delimited block -
#: en/git-check-attr.txt:89
#, fuzzy, no-wrap, priority:100
msgid ""
"$ git check-attr diff org/example/MyClass.java\n"
"org/example/MyClass.java: diff: java\n"
msgstr ""
"$ git check-attr diff org/example/MyClass.java\n"
"org/example/MyClass.java: diff: java\n"

#. type: Plain text
#: en/git-check-attr.txt:92
#, priority:100
msgid "Listing multiple attributes for a file:"
msgstr "列出一个文件的多个属性："

#. type: delimited block -
#: en/git-check-attr.txt:97
#, fuzzy, no-wrap, priority:100
msgid ""
"$ git check-attr crlf diff myAttr -- org/example/MyClass.java\n"
"org/example/MyClass.java: crlf: unset\n"
"org/example/MyClass.java: diff: java\n"
"org/example/MyClass.java: myAttr: set\n"
msgstr ""
"$ git check-attr crlf diff myAttr -- org/example/MyClass.java\n"
"org/example/MyClass.java: crlf: unset\n"
"org/example/MyClass.java: diff: java\n"
"org/example/MyClass.java: myAttr: set\n"

#. type: Plain text
#: en/git-check-attr.txt:100
#, priority:100
msgid "Listing all attributes for a file:"
msgstr "列出一个文件的所有属性："

#. type: delimited block -
#: en/git-check-attr.txt:104
#, fuzzy, no-wrap, priority:100
msgid ""
"$ git check-attr --all -- org/example/MyClass.java\n"
"org/example/MyClass.java: diff: java\n"
"org/example/MyClass.java: myAttr: set\n"
msgstr ""
"$ git check-attr --all -- org/example/MyClass.java\n"
"org/example/MyClass.java: diff: java\n"
"org/example/MyClass.java: myAttr: set\n"

#. type: Plain text
#: en/git-check-attr.txt:107
#, priority:100
msgid "Listing an attribute for multiple files:"
msgstr "为多个文件列出一个属性："

#. type: delimited block -
#: en/git-check-attr.txt:111
#, fuzzy, no-wrap, priority:100
msgid ""
"$ git check-attr myAttr -- org/example/MyClass.java org/example/NoMyAttr.java\n"
"org/example/MyClass.java: myAttr: set\n"
"org/example/NoMyAttr.java: myAttr: unspecified\n"
msgstr ""
"$ git check-attr myAttr -- org/example/MyClass.java org/example/NoMyAttr.java\n"
"org/example/MyClass.java: myAttr: set\n"
"org/example/NoMyAttr.java: myAttr: unspecified\n"

#. type: Plain text
#: en/git-check-attr.txt:114
#, priority:100
msgid "Not all values are equally unambiguous:"
msgstr "并非所有的价值观都是同样明确的："

#. type: delimited block -
#: en/git-check-attr.txt:117
#, fuzzy, no-wrap, priority:100
msgid ""
"$ git check-attr caveat README\n"
"README: caveat: unspecified\n"
msgstr ""
"$ git check-attr caveat README\n"
"README: caveat: unspecified\n"

#. type: Plain text
#: en/git-check-attr.txt:122
#, ignore-same, priority:100
msgid "linkgit:gitattributes[5]."
msgstr "linkgit:gitattributes[5]."

#. type: Title =
#: en/git-check-ignore.txt:2
#, ignore-same, no-wrap, priority:80
msgid "git-check-ignore(1)"
msgstr "git-check-ignore(1)"

#. type: Plain text
#: en/git-check-ignore.txt:7
#, priority:80
msgid "git-check-ignore - Debug gitignore / exclude files"
msgstr ""

#. type: Plain text
#: en/git-check-ignore.txt:14
#, ignore-ellipsis, no-wrap, priority:80
msgid ""
"'git check-ignore' [<options>] <pathname>...\n"
"'git check-ignore' [<options>] --stdin\n"
msgstr ""

#. type: Plain text
#: en/git-check-ignore.txt:22
#, priority:80
msgid "For each pathname given via the command-line or from a file via `--stdin`, check whether the file is excluded by .gitignore (or other input files to the exclude mechanism) and output the path if it is excluded."
msgstr ""

#. type: Plain text
#: en/git-check-ignore.txt:25
#, priority:80
msgid "By default, tracked files are not shown at all since they are not subject to exclude rules; but see `--no-index'."
msgstr ""

#. type: Labeled list
#: en/git-check-ignore.txt:28
#, fuzzy, no-wrap, priority:80
msgid "-q, --quiet"
msgstr "-q, --quiet"

#. type: Plain text
#: en/git-check-ignore.txt:31
#, priority:80
msgid "Don't output anything, just set exit status.  This is only valid with a single pathname."
msgstr ""

#. type: Labeled list
#: en/git-check-ignore.txt:32
#, fuzzy, no-wrap, priority:80
msgid "-v, --verbose"
msgstr "-v, --verbose"

#. type: Plain text
#: en/git-check-ignore.txt:39
#, priority:80
msgid "Instead of printing the paths that are excluded, for each path that matches an exclude pattern, print the exclude pattern together with the path.  (Matching an exclude pattern usually means the path is excluded, but if the pattern begins with \"`!`\" then it is a negated pattern and matching it means the path is NOT excluded.)"
msgstr ""

#. type: Plain text
#: en/git-check-ignore.txt:42
#, priority:80
msgid "For precedence rules within and between exclude sources, see linkgit:gitignore[5]."
msgstr ""

#. type: Plain text
#: en/git-check-ignore.txt:51
#, priority:80
msgid "The output format is modified to be machine-parsable (see below).  If `--stdin` is also given, input paths are separated with a NUL character instead of a linefeed character."
msgstr ""

#. type: Labeled list
#: en/git-check-ignore.txt:52
#, no-wrap, priority:80
msgid "-n, --non-matching"
msgstr ""

#. type: Plain text
#: en/git-check-ignore.txt:57
#, priority:80
msgid "Show given paths which don't match any pattern.\t This only makes sense when `--verbose` is enabled, otherwise it would not be possible to distinguish between paths which match a pattern and those which don't."
msgstr ""

#. type: Labeled list
#: en/git-check-ignore.txt:58 en/git-grep.txt:48
#, ignore-same, no-wrap, priority:100
msgid "--no-index"
msgstr "--no-index"

#. type: Plain text
#: en/git-check-ignore.txt:64
#, priority:80
msgid "Don't look in the index when undertaking the checks. This can be used to debug why a path became tracked by e.g. `git add .` and was not ignored by the rules as expected by the user or when developing patterns including negation to match a path previously added with `git add -f`."
msgstr ""

#. type: Plain text
#: en/git-check-ignore.txt:72
#, priority:80
msgid "By default, any of the given pathnames which match an ignore pattern will be output, one per line.  If no pattern matches a given path, nothing will be output for that path; this means that path will not be ignored."
msgstr ""

#. type: Plain text
#: en/git-check-ignore.txt:74
#, priority:80
msgid "If `--verbose` is specified, the output is a series of lines of the form:"
msgstr ""

#. type: Plain text
#: en/git-check-ignore.txt:76
#, priority:80
msgid "<source> <COLON> <linenum> <COLON> <pattern> <HT> <pathname>"
msgstr ""

#. type: Plain text
#: en/git-check-ignore.txt:84
#, priority:80
msgid "<pathname> is the path of a file being queried, <pattern> is the matching pattern, <source> is the pattern's source file, and <linenum> is the line number of the pattern within that source.  If the pattern contained a \"`!`\" prefix or \"`/`\" suffix, it will be preserved in the output.  <source> will be an absolute path when referring to the file configured by `core.excludesFile`, or relative to the repository root when referring to `.git/info/exclude` or a per-directory exclude file."
msgstr ""

#. type: Plain text
#: en/git-check-ignore.txt:88
#, priority:80
msgid "If `-z` is specified, the pathnames in the output are delimited by the null character; if `--verbose` is also specified then null characters are also used instead of colons and hard tabs:"
msgstr ""

#. type: Plain text
#: en/git-check-ignore.txt:90
#, priority:80
msgid "<source> <NULL> <linenum> <NULL> <pattern> <NULL> <pathname> <NULL>"
msgstr ""

#. type: Plain text
#: en/git-check-ignore.txt:100
#, priority:80
msgid "If `-n` or `--non-matching` are specified, non-matching pathnames will also be output, in which case all fields in each output record except for <pathname> will be empty.  This can be useful when running non-interactively, so that files can be incrementally streamed to STDIN of a long-running check-ignore process, and for each of these files, STDOUT will indicate whether that file matched a pattern or not.  (Without this option, it would be impossible to tell whether the absence of output for a given file meant that it didn't match any pattern, or that the output hadn't been generated yet.)"
msgstr ""

#. type: Title -
#: en/git-check-ignore.txt:107 en/git-filter-branch.txt:239 en/git-merge-tree.txt:187 en/git-remote.txt:209
#, no-wrap, priority:220
msgid "EXIT STATUS"
msgstr "退出状态码"

#. type: Labeled list
#: en/git-check-ignore.txt:109
#, fuzzy, no-wrap, priority:80
msgid "0"
msgstr "0"

#. type: Plain text
#: en/git-check-ignore.txt:111
#, priority:80
msgid "One or more of the provided paths is ignored."
msgstr ""

#. type: Labeled list
#: en/git-check-ignore.txt:112
#, fuzzy, no-wrap, priority:80
msgid "1"
msgstr "1"

#. type: Plain text
#: en/git-check-ignore.txt:114
#, priority:80
msgid "None of the provided paths are ignored."
msgstr ""

#. type: Labeled list
#: en/git-check-ignore.txt:115
#, fuzzy, no-wrap, priority:80
msgid "128"
msgstr "128"

#. type: Plain text
#: en/git-check-ignore.txt:117
#, priority:80
msgid "A fatal error was encountered."
msgstr ""

#. type: Plain text
#: en/git-check-ignore.txt:123
#, ignore-same, priority:80
msgid "linkgit:gitignore[5] linkgit:git-config[1] linkgit:git-ls-files[1]"
msgstr "linkgit:gitignore[5] linkgit:git-config[1] linkgit:git-ls-files[1]"

#. type: Title =
#: en/git-check-mailmap.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-check-mailmap(1)"
msgstr "git-check-mailmap(1)"

#. type: Plain text
#: en/git-check-mailmap.txt:7
#, priority:100
msgid "git-check-mailmap - Show canonical names and email addresses of contacts"
msgstr "git-check-mailmap - 显示联系人的规范名称和电子邮件地址"

#. type: Plain text
#: en/git-check-mailmap.txt:13
#, fuzzy, ignore-ellipsis, no-wrap, priority:100
msgid "'git check-mailmap' [<options>] <contact>...\n"
msgstr "'git check-mailmap' [<options>] <contact>...\n"

#. type: Plain text
#: en/git-check-mailmap.txt:22
#, priority:100
msgid "For each ``Name $$<user@host>$$'' or ``$$<user@host>$$'' from the command-line or standard input (when using `--stdin`), look up the person's canonical name and email address (see \"Mapping Authors\" below). If found, print them; otherwise print the input as-is."
msgstr "对于每一个来自命令行或标准输入（当使用 `--stdin` 时）的 ``Name $$<user@host>$$\" 或 ``$$<user@host>$$'，查找该人的规范名称和电子邮件地址（见下面的 “映射作者”）。如果找到了，就打印出来；否则就按原样打印输入。"

#. type: Plain text
#: en/git-check-mailmap.txt:29
#, priority:100
msgid "Read contacts, one per line, from the standard input after exhausting contacts provided on the command-line."
msgstr "在用完命令行上提供的联系人后，从标准输入中读取联系人，每行一个。"

#. type: Plain text
#: en/git-check-mailmap.txt:37
#, priority:100
msgid "For each contact, a single line is output, terminated by a newline.  If the name is provided or known to the 'mailmap', ``Name $$<user@host>$$'' is printed; otherwise only ``$$<user@host>$$'' is printed."
msgstr "对于每个联系人，都会输出一行，以换行结束。 如果名字被提供或被 'mailmap' 知道，``Name $$<user@host>$$'' 被打印；否则只有 ``$$<user@host>$$'' 被打印。"

#. type: Plain text
#: en/git-check-mailmap.txt:44
#, priority:100
msgid "See `mailmap.file` and `mailmap.blob` in linkgit:git-config[1] for how to specify a custom `.mailmap` target file or object."
msgstr "参见 linkgit:git-config[1] 中的 `mailmap.file` 和 `mailmap.blob`，了解如何指定一个自定义的 `.mailmap` 目标文件或对象。"

#. type: Title =
#: en/git-checkout-index.txt:2
#, ignore-same, no-wrap, priority:80
msgid "git-checkout-index(1)"
msgstr "git-checkout-index(1)"

#. type: Plain text
#: en/git-checkout-index.txt:7
#, fuzzy, priority:80
msgid "git-checkout-index - Copy files from the index to the working tree"
msgstr "git-checkout-index - Copy files from the index to the working tree"

#. type: Plain text
#: en/git-checkout-index.txt:18
#, ignore-ellipsis, no-wrap, priority:80
msgid ""
"'git checkout-index' [-u] [-q] [-a] [-f] [-n] [--prefix=<string>]\n"
"\t\t   [--stage=<number>|all]\n"
"\t\t   [--temp]\n"
"\t\t   [--ignore-skip-worktree-bits]\n"
"\t\t   [-z] [--stdin]\n"
"\t\t   [--] [<file>...]\n"
msgstr ""

#. type: Plain text
#: en/git-checkout-index.txt:23
#, priority:80
msgid "Will copy all files listed from the index to the working directory (not overwriting existing files)."
msgstr ""

#. type: Plain text
#: en/git-checkout-index.txt:30
#, priority:80
msgid "update stat information for the checked out entries in the index file."
msgstr ""

#. type: Plain text
#: en/git-checkout-index.txt:34
#, priority:80
msgid "be quiet if files exist or are not in the index"
msgstr ""

#. type: Plain text
#: en/git-checkout-index.txt:38
#, priority:80
msgid "forces overwrite of existing files"
msgstr ""

#. type: Plain text
#: en/git-checkout-index.txt:44
#, priority:80
msgid "checks out all files in the index except for those with the skip-worktree bit set (see `--ignore-skip-worktree-bits`).  Cannot be used together with explicit filenames."
msgstr ""

#. type: Labeled list
#: en/git-checkout-index.txt:46
#, ignore-same, no-wrap, priority:80
msgid "--no-create"
msgstr "--no-create"

#. type: Plain text
#: en/git-checkout-index.txt:49
#, priority:80
msgid "Don't checkout new files, only refresh files already checked out."
msgstr ""

#. type: Labeled list
#: en/git-checkout-index.txt:50
#, no-wrap, priority:80
msgid "--prefix=<string>"
msgstr ""

#. type: Plain text
#: en/git-checkout-index.txt:53
#, priority:80
msgid "When creating files, prepend <string> (usually a directory including a trailing /)"
msgstr ""

#. type: Labeled list
#: en/git-checkout-index.txt:54
#, fuzzy, no-wrap, priority:80
msgid "--stage=<number>|all"
msgstr "--stage=<number>|all"

#. type: Plain text
#: en/git-checkout-index.txt:58
#, priority:80
msgid "Instead of checking out unmerged entries, copy out the files from named stage.  <number> must be between 1 and 3.  Note: --stage=all automatically implies --temp."
msgstr ""

#. type: Labeled list
#: en/git-checkout-index.txt:59
#, ignore-same, no-wrap, priority:80
msgid "--temp"
msgstr "--temp"

#. type: Plain text
#: en/git-checkout-index.txt:63
#, priority:80
msgid "Instead of copying the files to the working directory write the content to temporary files.  The temporary name associations will be written to stdout."
msgstr ""

#. type: Labeled list
#: en/git-checkout-index.txt:64 en/git-checkout.txt:240 en/git-restore.txt:103
#, ignore-same, no-wrap, priority:280
msgid "--ignore-skip-worktree-bits"
msgstr "--ignore-skip-worktree-bits"

#. type: Plain text
#: en/git-checkout-index.txt:67
#, priority:80
msgid "Check out all files, including those with the skip-worktree bit set."
msgstr ""

#. type: Plain text
#: en/git-checkout-index.txt:72 en/git-update-index.txt:157
#, priority:80
msgid "Instead of taking list of paths from the command line, read list of paths from the standard input.  Paths are separated by LF (i.e. one path per line) by default."
msgstr ""

#. type: Plain text
#: en/git-checkout-index.txt:76
#, priority:80
msgid "Only meaningful with `--stdin`; paths are separated with NUL character instead of LF."
msgstr ""

#. type: Plain text
#: en/git-checkout-index.txt:79 en/git-checkout.txt:366 en/git-commit.txt:400 en/git-ls-files.txt:227 en/git-merge-index.txt:25 en/git-prune.txt:53 en/git-reset.txt:130 en/git-restore.txt:143 en/git-update-index.txt:228 en/git-verify-pack.txt:38
#, priority:280
msgid "Do not interpret any more arguments as options."
msgstr "不将之后的参数解释为选项。"

#. type: Plain text
#: en/git-checkout-index.txt:81
#, priority:80
msgid "The order of the flags used to matter, but not anymore."
msgstr ""

#. type: Plain text
#: en/git-checkout-index.txt:85
#, priority:80
msgid "Just doing `git checkout-index` does nothing. You probably meant `git checkout-index -a`. And if you want to force it, you want `git checkout-index -f -a`."
msgstr ""

#. type: Plain text
#: en/git-checkout-index.txt:89
#, priority:80
msgid "Intuitiveness is not the goal here. Repeatability is. The reason for the \"no arguments means no work\" behavior is that from scripts you are supposed to be able to do:"
msgstr ""

#. type: delimited block -
#: en/git-checkout-index.txt:92
#, fuzzy, no-wrap, priority:80
msgid "$ find . -name '*.h' -print0 | xargs -0 git checkout-index -f --\n"
msgstr "$ find . -name '*.h' -print0 | xargs -0 git checkout-index -f --\n"

#. type: Plain text
#: en/git-checkout-index.txt:98
#, priority:80
msgid "which will force all existing `*.h` files to be replaced with their cached copies. If an empty command line implied \"all\", then this would force-refresh everything in the index, which was not the point.  But since 'git checkout-index' accepts --stdin it would be faster to use:"
msgstr ""

#. type: delimited block -
#: en/git-checkout-index.txt:101
#, fuzzy, no-wrap, priority:80
msgid "$ find . -name '*.h' -print0 | git checkout-index -f -z --stdin\n"
msgstr "$ find . -name '*.h' -print0 | git checkout-index -f -z --stdin\n"

#. type: Plain text
#: en/git-checkout-index.txt:106
#, priority:80
msgid "The `--` is just a good idea when you know the rest will be filenames; it will prevent problems with a filename of, for example, `-a`.  Using `--` is probably a good policy in scripts."
msgstr ""

#. type: Title -
#: en/git-checkout-index.txt:109
#, no-wrap, priority:80
msgid "Using --temp or --stage=all"
msgstr ""

#. type: Plain text
#: en/git-checkout-index.txt:116
#, priority:80
msgid "When `--temp` is used (or implied by `--stage=all`)  'git checkout-index' will create a temporary file for each index entry being checked out.  The index will not be updated with stat information.  These options can be useful if the caller needs all stages of all unmerged entries so that the unmerged files can be processed by an external merge tool."
msgstr ""

#. type: Plain text
#: en/git-checkout-index.txt:120
#, priority:80
msgid "A listing will be written to stdout providing the association of temporary file names to tracked path names.  The listing format has two variations:"
msgstr ""

#. type: Plain text
#: en/git-checkout-index.txt:122
#, priority:80
msgid "tempname TAB path RS"
msgstr ""

#. type: Plain text
#: en/git-checkout-index.txt:127
#, priority:80
msgid "The first format is what gets used when `--stage` is omitted or is not `--stage=all`. The field tempname is the temporary file name holding the file content and path is the tracked path name in the index.  Only the requested entries are output."
msgstr ""

#. type: Plain text
#: en/git-checkout-index.txt:129
#, priority:80
msgid "stage1temp SP stage2temp SP stage3tmp TAB path RS"
msgstr ""

#. type: Plain text
#: en/git-checkout-index.txt:135
#, priority:80
msgid "The second format is what gets used when `--stage=all`.  The three stage temporary fields (stage1temp, stage2temp, stage3temp) list the name of the temporary file if there is a stage entry in the index or `.` if there is no stage entry.  Paths which only have a stage 0 entry will always be omitted from the output."
msgstr ""

#. type: Plain text
#: en/git-checkout-index.txt:142
#, priority:80
msgid "In both formats RS (the record separator) is newline by default but will be the null byte if -z was passed on the command line.  The temporary file names are always safe strings; they will never contain directory separators or whitespace characters.  The path field is always relative to the current directory and the temporary file names are always relative to the top level directory."
msgstr ""

#. type: Plain text
#: en/git-checkout-index.txt:146
#, priority:80
msgid "If the object being copied out to a temporary file is a symbolic link the content of the link will be written to a normal file.  It is up to the end-user or the Porcelain to make use of this information."
msgstr ""

#. type: Labeled list
#: en/git-checkout-index.txt:150
#, no-wrap, priority:80
msgid "To update and refresh only the files already checked out"
msgstr ""

#. type: delimited block -
#: en/git-checkout-index.txt:154 en/git-update-index.txt:365
#, fuzzy, no-wrap, priority:80
msgid "$ git checkout-index -n -f -a && git update-index --ignore-missing --refresh\n"
msgstr "$ git checkout-index -n -f -a && git update-index --ignore-missing --refresh\n"

#. type: Labeled list
#: en/git-checkout-index.txt:156
#, no-wrap, priority:80
msgid "Using 'git checkout-index' to \"export an entire tree\""
msgstr ""

#. type: Plain text
#: en/git-checkout-index.txt:160
#, priority:80
msgid "The prefix ability basically makes it trivial to use 'git checkout-index' as an \"export as tree\" function.  Just read the desired tree into the index, and do:"
msgstr ""

#. type: delimited block -
#: en/git-checkout-index.txt:163
#, fuzzy, no-wrap, priority:80
msgid "$ git checkout-index --prefix=git-export-dir/ -a\n"
msgstr "$ git checkout-index --prefix=git-export-dir/ -a\n"

#. type: Plain text
#: en/git-checkout-index.txt:167
#, priority:80
msgid "`git checkout-index` will \"export\" the index into the specified directory."
msgstr ""

#. type: Plain text
#: en/git-checkout-index.txt:171
#, priority:80
msgid "The final \"/\" is important. The exported name is literally just prefixed with the specified string.  Contrast this with the following example."
msgstr ""

#. type: Labeled list
#: en/git-checkout-index.txt:172
#, no-wrap, priority:80
msgid "Export files with a prefix"
msgstr ""

#. type: delimited block -
#: en/git-checkout-index.txt:176
#, fuzzy, no-wrap, priority:80
msgid "$ git checkout-index --prefix=.merged- Makefile\n"
msgstr "$ git checkout-index --prefix=.merged- Makefile\n"

#. type: Plain text
#: en/git-checkout-index.txt:180
#, priority:80
msgid "This will check out the currently cached copy of `Makefile` into the file `.merged-Makefile`."
msgstr ""

#. type: Title =
#: en/git-checkout.txt:2
#, ignore-same, no-wrap, priority:240
msgid "git-checkout(1)"
msgstr "git-checkout(1)"

#. type: Plain text
#: en/git-checkout.txt:7
#, fuzzy, priority:240
msgid "git-checkout - Switch branches or restore working tree files"
msgstr "git-checkout - Switch branches or restore working tree files"

#. type: Plain text
#: en/git-checkout.txt:18
#, ignore-ellipsis, no-wrap, priority:240
msgid ""
"'git checkout' [-q] [-f] [-m] [<branch>]\n"
"'git checkout' [-q] [-f] [-m] --detach [<branch>]\n"
"'git checkout' [-q] [-f] [-m] [--detach] <commit>\n"
"'git checkout' [-q] [-f] [-m] [[-b|-B|--orphan] <new-branch>] [<start-point>]\n"
"'git checkout' [-f|--ours|--theirs|-m|--conflict=<style>] [<tree-ish>] [--] <pathspec>...\n"
"'git checkout' [-f|--ours|--theirs|-m|--conflict=<style>] [<tree-ish>] --pathspec-from-file=<file> [--pathspec-file-nul]\n"
"'git checkout' (-p|--patch) [<tree-ish>] [--] [<pathspec>...]\n"
msgstr ""
"'git checkout' [-q] [-f] [-m] [<分支>]\n"
"'git checkout' [-q] [-f] [-m] --detach [<分支>]\n"
"'git checkout' [-q] [-f] [-m] [--detach] <提交>\n"
"'git checkout' [-q] [-f] [-m] [[-b|-B|--orphan] <新分支>] [<起点>]\n"
"'git checkout' [-f|--ours|--theirs|-m|--conflict=<样式>] [<树状对象>] [--] <修饰符>...\n"
"'git checkout' [-f|--ours|--theirs|-m|--conflict=<样式>] [<树状对象>] --pathspec-from-file=<文件> [--pathspec-file-nul]\n"
"'git checkout' (-p|--patch) [<树状对象>] [--] [<修饰符>...]\n"

#. type: Plain text
#: en/git-checkout.txt:25
#, priority:240
msgid "Updates files in the working tree to match the version in the index or the specified tree.  If no pathspec was given, 'git checkout' will also update `HEAD` to set the specified branch as the current branch."
msgstr "更新工作区中的文件，使其与索引或指定的树中的版本一致。  如果没有给出pathspec，'git checkout'也将更新`HEAD`，将指定的分支设为当前分支。"

#. type: Labeled list
#: en/git-checkout.txt:26
#, no-wrap, priority:240
msgid "'git checkout' [<branch>]"
msgstr "'git checkout' [<分支>]"

#. type: Plain text
#: en/git-checkout.txt:32
#, priority:240
msgid "To prepare for working on `<branch>`, switch to it by updating the index and the files in the working tree, and by pointing `HEAD` at the branch. Local modifications to the files in the working tree are kept, so that they can be committed to the `<branch>`."
msgstr "要准备在`<分支>`上工作，需要更新索引和工作区中的文件，以及将`HEAD`指向该分支来切换到该分支。对工作区中文件的本地修改会被保留，以便修改可以被提交到`<分支>`。"

#. type: Plain text
#: en/git-checkout.txt:36
#, priority:240
msgid "If `<branch>` is not found but there does exist a tracking branch in exactly one remote (call it `<remote>`) with a matching name and `--no-guess` is not specified, treat as equivalent to"
msgstr "如果没有找到该`<分支>`，但正好一个远程（称其为`<远程仓库>`）中确实存在一个名称相匹配的已跟踪分支，并且没有指定`--no-guess`，则视为等同于"

#. type: delimited block -
#: en/git-checkout.txt:39 en/git-checkout.txt:187
#, fuzzy, no-wrap, priority:240
msgid "$ git checkout -b <branch> --track <remote>/<branch>\n"
msgstr "$ git checkout -b <branch> --track <remote>/<branch>\n"

#. type: Plain text
#: en/git-checkout.txt:45
#, fuzzy, priority:240
msgid "You could omit `<branch>`, in which case the command degenerates to \"check out the current branch\", which is a glorified no-op with rather expensive side-effects to show only the tracking information, if exists, for the current branch."
msgstr "你可以省略`<分支>`，在这种情况下，该命令会退化为 \"检查出当前分支\"，这是一个美化的无操作，具有非常大的副作用，如果存在当前分支的话，只显示当前分支的跟踪信息。"

#. type: Labeled list
#: en/git-checkout.txt:46
#, fuzzy, no-wrap, priority:240
msgid "'git checkout' -b|-B <new-branch> [<start-point>]"
msgstr "'git checkout' -b|-B <new_branch> [<start point>]"

#. type: Plain text
#: en/git-checkout.txt:54
#, priority:240
msgid "Specifying `-b` causes a new branch to be created as if linkgit:git-branch[1] were called and then checked out.  In this case you can use the `--track` or `--no-track` options, which will be passed to 'git branch'.  As a convenience, `--track` without `-b` implies branch creation; see the description of `--track` below."
msgstr "指定 `-b` 会导致一个新的分支被创建，就像调用 linkgit:git-branch[1] 然后签出一样。  在这种情况下，你可以使用 `--track` 或 `--no-track` 选项，它们将被传递给 'git branch'。  为方便起见，`--track`不加`-b`意味着创建分支；见下文对`--track`的描述。"

#. type: Plain text
#: en/git-checkout.txt:57
#, priority:240
msgid "If `-B` is given, `<new-branch>` is created if it doesn't exist; otherwise, it is reset. This is the transactional equivalent of"
msgstr "如果给定了`-B'，如果不存在`<新分支>`，就会创建；否则，就会重置。这在事务上等同于"

#. type: delimited block -
#: en/git-checkout.txt:61
#, fuzzy, no-wrap, priority:240
msgid ""
"$ git branch -f <branch> [<start-point>]\n"
"$ git checkout <branch>\n"
msgstr ""
"$ git branch -f <branch> [<start point>]\n"
"$ git checkout <branch>\n"

#. type: Plain text
#: en/git-checkout.txt:65
#, priority:240
msgid "that is to say, the branch is not reset/created unless \"git checkout\" is successful."
msgstr "也就是说，除非 \"git checkout \"执行成功，否则该分支不会被重置/创建。"

#. type: Labeled list
#: en/git-checkout.txt:66
#, no-wrap, priority:240
msgid "'git checkout' --detach [<branch>]"
msgstr "'git checkout' --detach [<分支>]"

#. type: Labeled list
#: en/git-checkout.txt:67
#, no-wrap, priority:240
msgid "'git checkout' [--detach] <commit>"
msgstr "'git checkout' [--detach] <提交>"

#. type: Plain text
#: en/git-checkout.txt:75
#, priority:240
msgid "Prepare to work on top of `<commit>`, by detaching `HEAD` at it (see \"DETACHED HEAD\" section), and updating the index and the files in the working tree.  Local modifications to the files in the working tree are kept, so that the resulting working tree will be the state recorded in the commit plus the local modifications."
msgstr "准备在 `<提交>` 上工作，通过分离 `HEAD` 来实现（参见 \"DETACHED HEAD\" 部分），并更新工作区中的索引和文件。  对工作区中的文件的本地修改会被保留，所以最终的工作区将是提交时记录的状态加上本地的修改。"

#. type: Plain text
#: en/git-checkout.txt:79
#, priority:240
msgid "When the `<commit>` argument is a branch name, the `--detach` option can be used to detach `HEAD` at the tip of the branch (`git checkout <branch>` would check out that branch without detaching `HEAD`)."
msgstr "当`<提交>`参数是一个分支名称时，`--detach`选项可以用来分离分支顶端的`HEAD`（`git checkout <分支>`会签出该分支而不分离`HEAD`）。"

#. type: Plain text
#: en/git-checkout.txt:81
#, priority:240
msgid "Omitting `<branch>` detaches `HEAD` at the tip of the current branch."
msgstr "省略`<分支>`会在当前分支的顶端分离`HEAD`。"

#. type: Labeled list
#: en/git-checkout.txt:82
#, fuzzy, ignore-ellipsis, no-wrap, priority:240
msgid "'git checkout' [-f|--ours|--theirs|-m|--conflict=<style>] [<tree-ish>] [--] <pathspec>..."
msgstr "'git checkout' [-f|--ours|--theirs|-m|--conflict=<style>] [<tree-ish>] [--] <pathspec>..."

#. type: Labeled list
#: en/git-checkout.txt:83
#, no-wrap, priority:240
msgid "'git checkout' [-f|--ours|--theirs|-m|--conflict=<style>] [<tree-ish>] --pathspec-from-file=<file> [--pathspec-file-nul]"
msgstr "'git checkout' [-f|--our|--theirs|-m|--conflict=<样式>] [<树状对象>] --pathspec-from-file=<文件> [--pathspec-file-nul]"

#. type: Plain text
#: en/git-checkout.txt:90
#, priority:240
msgid "Overwrite the contents of the files that match the pathspec.  When the `<tree-ish>` (most often a commit) is not given, overwrite working tree with the contents in the index.  When the `<tree-ish>` is given, overwrite both the index and the working tree with the contents at the `<tree-ish>`."
msgstr "覆盖符合路径对范文件的内容。  当没有给出`<树状对象>`（最常见的是提交），用索引中的内容覆盖工作区。  当`<树状对象>`被给出时，用`<树状对象>`处的内容覆盖索引和工作区。"

#. type: Plain text
#: en/git-checkout.txt:98
#, priority:240
msgid "The index may contain unmerged entries because of a previous failed merge.  By default, if you try to check out such an entry from the index, the checkout operation will fail and nothing will be checked out.  Using `-f` will ignore these unmerged entries.  The contents from a specific side of the merge can be checked out of the index by using `--ours` or `--theirs`.  With `-m`, changes made to the working tree file can be discarded to re-create the original conflicted merge result."
msgstr "索引可能包含因之前合并失败导致的未合并条目。  默认情况下，如果你试图从索引中签出这样的条目，签出操作将失败，没有任何东西被签出。  使用`-f`将忽略这些未合并的条目。  通过使用`--ours\"或`--theirs\"选项，可以从索引中检出合并的特定一方的内容。  使用`-m`，对工作区文件的修改可以被丢弃，以重新创建原冲突合并的结果。"

#. type: Labeled list
#: en/git-checkout.txt:99
#, ignore-ellipsis, no-wrap, priority:240
msgid "'git checkout' (-p|--patch) [<tree-ish>] [--] [<pathspec>...]"
msgstr "'git checkout' (-p|--patch) [<树状对象>] [--] [<路径规范>...]"

#. type: Plain text
#: en/git-checkout.txt:104
#, priority:240
msgid "This is similar to the previous mode, but lets you use the interactive interface to show the \"diff\" output and choose which hunks to use in the result.  See below for the description of `--patch` option."
msgstr "这与前面的模式类似，但让你使用交互式界面来显示 \"diff \"输出，并选择在结果中使用哪些代码块。  关于`--patch`选项的描述，见下文。"

#. type: Plain text
#: en/git-checkout.txt:110 en/git-read-tree.txt:120 en/git-stash.txt:244 en/git-switch.txt:145
#, priority:240
msgid "Quiet, suppress feedback messages."
msgstr "静默，压制反馈信息。"

#. type: Labeled list
#: en/git-checkout.txt:112 en/git-fetch-pack.txt:108 en/git-restore.txt:71 en/git-switch.txt:147 en/merge-options.txt:183
#, ignore-same, no-wrap, priority:280
msgid "--no-progress"
msgstr "--no-progress"

#. type: Plain text
#: en/git-checkout.txt:117 en/git-restore.txt:76 en/git-switch.txt:152
#, priority:280
msgid "Progress status is reported on the standard error stream by default when it is attached to a terminal, unless `--quiet` is specified. This flag enables progress reporting even if not attached to a terminal, regardless of `--quiet`."
msgstr "当它附加到终端时，除非指定 `--quiet`，否则默认情况下会在标准错误流中报告进度状态。这个标志可以启用进度报告，即使没有附在到终端，而不管 `--quiet`。"

#. type: Plain text
#: en/git-checkout.txt:124
#, priority:240
msgid "When switching branches, proceed even if the index or the working tree differs from `HEAD`, and even if there are untracked files in the way.  This is used to throw away local changes and any untracked files or directories that are in the way."
msgstr "当切换分支时，即使索引或工作区与`HEAD`不同，即使有未追踪的文件挡住去路，也要继续。  这是用来丢弃本地修改和任何碍事的未追踪文件或目录的。"

#. type: Plain text
#: en/git-checkout.txt:127
#, priority:240
msgid "When checking out paths from the index, do not fail upon unmerged entries; instead, unmerged entries are ignored."
msgstr "当从索引中检查出路径时，不将未合并条目视为失败；相反，忽略未合并条目。"

#. type: Labeled list
#: en/git-checkout.txt:128 en/git-merge-file.txt:76 en/git-restore.txt:77
#, ignore-same, no-wrap, priority:280
msgid "--ours"
msgstr "--ours"

#. type: Labeled list
#: en/git-checkout.txt:129 en/git-merge-file.txt:77 en/git-restore.txt:78
#, ignore-same, no-wrap, priority:280
msgid "--theirs"
msgstr "--theirs"

#. type: Plain text
#: en/git-checkout.txt:132
#, priority:240
msgid "When checking out paths from the index, check out stage #2 ('ours') or #3 ('theirs') for unmerged paths."
msgstr "当从索引中检查出路径时，要检查第二阶段（'ours'）或第三阶段（'theirs'）的未合并路径。"

#. type: Plain text
#: en/git-checkout.txt:137
#, priority:240
msgid "Note that during `git rebase` and `git pull --rebase`, 'ours' and 'theirs' may appear swapped; `--ours` gives the version from the branch the changes are rebased onto, while `--theirs` gives the version from the branch that holds your work that is being rebased."
msgstr "注意在 \"git rebase \"和 \"git pull --rebase \"过程中，\"ours\"和 \"theirs\"可能会互换；\"--ours \"给出了分支变基后的版本，而\"--theirs\"则给出你即将变基的分支版本。"

#. type: Plain text
#: en/git-checkout.txt:147
#, priority:240
msgid "This is because `rebase` is used in a workflow that treats the history at the remote as the shared canonical one, and treats the work done on the branch you are rebasing as the third-party work to be integrated, and you are temporarily assuming the role of the keeper of the canonical history during the rebase.  As the keeper of the canonical history, you need to view the history from the remote as `ours` (i.e. \"our shared canonical history\"), while what you did on your side branch as `theirs` (i.e. \"one contributor's work on top of it\")."
msgstr "这是因为 \"rebase\"在工作流程中使用，它将远程的历史视为共享的规范历史，并将在你重命名的分支上所做的工作视为需要整合的第三方工作，而你在重命名过程中暂时承担了规范历史守护者的角色。 作为规范历史的守护者，你需要将远程的历史视为 \"ours\"（即 \"我们共享的规范历史\"），而将你在侧边分支上的工作视为 \"their\"（即 \"一个贡献者在上面所作的工作\"）。"

#. type: Labeled list
#: en/git-checkout.txt:148 en/git-worktree.txt:189
#, fuzzy, no-wrap, priority:240
msgid "-b <new-branch>"
msgstr "-b <new-branch>"

#. type: Plain text
#: en/git-checkout.txt:152
#, priority:240
msgid "Create a new branch named `<new-branch>`, start it at `<start-point>`, and check the resulting branch out; see linkgit:git-branch[1] for details."
msgstr "创建一个名为\"<新分支>\"的新分支，从\"<起点>\"开始，并检出产生的分支；详情见 linkgit:git-branch[1]。"

#. type: Labeled list
#: en/git-checkout.txt:153 en/git-worktree.txt:190
#, no-wrap, priority:240
msgid "-B <new-branch>"
msgstr "-B <新分支>"

#. type: Plain text
#: en/git-checkout.txt:159
#, priority:240
msgid "Creates the branch `<new-branch>`, start it at `<start-point>`; if it already exists, then reset it to `<start-point>`. And then check the resulting branch out.  This is equivalent to running \"git branch\" with \"-f\" followed by \"git checkout\" of that branch; see linkgit:git-branch[1] for details."
msgstr "从`<起点>`开始，创建分支`<新分支>`；如果分支已经存在，则重置为`<起点>`。然后检出生成的分支。这相当于用 \"-f\"选项 运行 \"git branch\" ，然后用 \"git checkout\" 检出该分支；详见 linkgit:git-branch[1]。"

#. type: Plain text
#: en/git-checkout.txt:164
#, priority:240
msgid "When creating a new branch, set up \"upstream\" configuration. See \"--track\" in linkgit:git-branch[1] for details."
msgstr "创建新分支时，要设置 \"上游\"配置。详情见 linkgit:git-branch[1] 中的 \"--track\"。"

#. type: Plain text
#: en/git-checkout.txt:174
#, priority:240
msgid "If no `-b` option is given, the name of the new branch will be derived from the remote-tracking branch, by looking at the local part of the refspec configured for the corresponding remote, and then stripping the initial part up to the \"*\".  This would tell us to use `hack` as the local branch when branching off of `origin/hack` (or `remotes/origin/hack`, or even `refs/remotes/origin/hack`).  If the given name has no slash, or the above guessing results in an empty name, the guessing is aborted.  You can explicitly give a name with `-b` in such a case."
msgstr "如果没有给出`-b`选项，新分支的名称将从远程跟踪分支中推导出来，方法是查看为相应的远程配置引用规范的本地部分，然后剥离初始部分，直至 \"*\"。由上述可得出，在从`origin/hack`（或`remotes/origin/hack`，甚至`refs/remotes/origin/hack`）分支时，将使用`hack`作为本地分支。如果给定的名字没有斜线，或者上述推测的结果是一个空名，则会终止推测。在这种情况下，你可以用`-b`明确地给出一个名字。"

#. type: Plain text
#: en/git-checkout.txt:178 en/git-switch.txt:172
#, priority:240
msgid "Do not set up \"upstream\" configuration, even if the `branch.autoSetupMerge` configuration variable is true."
msgstr "不设置 \"上游 \"配置，即使`branch.autoSetupMerge`配置变量为true。"

#. type: Labeled list
#: en/git-checkout.txt:179 en/git-switch.txt:87
#, ignore-same, no-wrap, priority:240
msgid "--guess"
msgstr "--guess"

#. type: Labeled list
#: en/git-checkout.txt:180 en/git-switch.txt:88
#, ignore-same, no-wrap, priority:240
msgid "--no-guess"
msgstr "--no-guess"

#. type: Plain text
#: en/git-checkout.txt:184 en/git-switch.txt:92
#, priority:240
msgid "If `<branch>` is not found but there does exist a tracking branch in exactly one remote (call it `<remote>`) with a matching name, treat as equivalent to"
msgstr "如果没有找到`<分支>`，但确实有一个远程分支（称为`<远程分支>`）的跟踪分支存在，且名称匹配，则视为等同于"

#. type: Plain text
#: en/git-checkout.txt:197 en/git-switch.txt:104
#, priority:240
msgid "If the branch exists in multiple remotes and one of them is named by the `checkout.defaultRemote` configuration variable, we'll use that one for the purposes of disambiguation, even if the `<branch>` isn't unique across all remotes. Set it to e.g. `checkout.defaultRemote=origin` to always checkout remote branches from there if `<branch>` is ambiguous but exists on the 'origin' remote. See also `checkout.defaultRemote` in linkgit:git-config[1]."
msgstr "如果该分支存在于多个远程，并且其中一个是由`checkout.defaultRemote`配置变量命名的，为了消除歧义，我们将使用该变量，即使`<分支>`在所有远程中并不唯一。将其设置为例如 `checkout.defaultRemote=origin`，以便在`<分支>`不明确但存在于'origin'远程时，总是从那里签出远程分支。参见 linkgit:git-config[1] 中的 `checkout.defaultRemote`。"

#. type: Plain text
#: en/git-checkout.txt:199 en/git-switch.txt:106
#, priority:240
msgid "`--guess` is the default behavior. Use `--no-guess` to disable it."
msgstr "`--guess`是默认行为。使用`--no-guess`来禁用它。"

#. type: Plain text
#: en/git-checkout.txt:202 en/git-switch.txt:109
#, priority:240
msgid "The default behavior can be set via the `checkout.guess` configuration variable."
msgstr "默认行为可以通过`checkout.guess`配置变量设置。"

#. type: Plain text
#: en/git-checkout.txt:206
#, priority:240
msgid "Create the new branch's reflog; see linkgit:git-branch[1] for details."
msgstr "创建新分支的引用日志；详见 linkgit:git-branch[1]。"

#. type: Labeled list
#: en/git-checkout.txt:208 en/git-daemon.txt:156 en/git-switch.txt:82 en/git-worktree.txt:199
#, ignore-same, no-wrap, priority:240
msgid "--detach"
msgstr "--detach"

#. type: Plain text
#: en/git-checkout.txt:214
#, priority:240
msgid "Rather than checking out a branch to work on it, check out a commit for inspection and discardable experiments.  This is the default behavior of `git checkout <commit>` when `<commit>` is not a branch name.  See the \"DETACHED HEAD\" section below for details."
msgstr "与其签出一个分支来工作，不如签出一个提交来进行检查和可放弃的实验。当`<提交>`不是一个分支名时， 这是`git checkout <提交>`的默认行为，。 详见下面的 \"游离状态（DETACHED HEAD）\"部分。"

#. type: Labeled list
#: en/git-checkout.txt:215 en/git-switch.txt:173
#, fuzzy, no-wrap, priority:240
msgid "--orphan <new-branch>"
msgstr "--orphan <new-branch>"

#. type: Plain text
#: en/git-checkout.txt:221
#, priority:240
msgid "Create a new 'orphan' branch, named `<new-branch>`, started from `<start-point>` and switch to it.  The first commit made on this new branch will have no parents and it will be the root of a new history totally disconnected from all the other branches and commits."
msgstr "从\"<起点>\"开始，创建一个新的 \"孤儿\"分支，命名为\"<新分支>\"，并切换到该分支。 在这个新分支上的第一次提交将没有父分支，它将是一个新的历史起点，与所有其他的分支和提交完全断开。"

#. type: Plain text
#: en/git-checkout.txt:226
#, priority:240
msgid "The index and the working tree are adjusted as if you had previously run `git checkout <start-point>`.  This allows you to start a new history that records a set of paths similar to `<start-point>` by easily running `git commit -a` to make the root commit."
msgstr "索引和工作区的调整就像你之前运行`git checkout <起点>`一样。 这允许你轻松地通过运行`git commit -a`来启动一个新的历史，记录一组类似于`<新起点>`的路径，进行根提交。"

#. type: Plain text
#: en/git-checkout.txt:232
#, priority:240
msgid "This can be useful when you want to publish the tree from a commit without exposing its full history. You might want to do this to publish an open source branch of a project whose current tree is \"clean\", but whose full history contains proprietary or otherwise encumbered bits of code."
msgstr "当你想发布一个提交树而不暴露其完整的历史时，这就很有用。你可能想这样做来发布一个项目的开源分支，这个分支的当前树是 \"干净的\"，但其完整的历史包含了专有的或其他一些代码。"

#. type: Plain text
#: en/git-checkout.txt:239
#, priority:240
msgid "If you want to start a disconnected history that records a set of paths that is totally different from the one of `<start-point>`, then you should clear the index and the working tree right after creating the orphan branch by running `git rm -rf .` from the top level of the working tree.  Afterwards you will be ready to prepare your new files, repopulating the working tree, by copying them from elsewhere, extracting a tarball, etc."
msgstr "如果你想启动一个断开的历史，记录一组完全不同于`<起点>`的路径，那么你应该在创建孤儿分支后立即清除索引和工作区，从工作区的顶层运行`git rm -rf .`。 之后你就可以准备你的新文件了，重新填充工作区，办法是从其他地方复制它们，提取一个包，等等。"

#. type: Plain text
#: en/git-checkout.txt:245
#, priority:240
msgid "In sparse checkout mode, `git checkout -- <paths>` would update only entries matched by `<paths>` and sparse patterns in `$GIT_DIR/info/sparse-checkout`. This option ignores the sparse patterns and adds back any files in `<paths>`."
msgstr "在稀疏签出模式下，`git checkout -- <路径>`将只更新由`<路径>`和`$GIT_DIR/info/sparse-checkout`中的稀疏模式匹配的条目。这个选项忽略了稀疏模式，并添加回`<路径>`中的任何文件。"

#. type: Labeled list
#: en/git-checkout.txt:247 en/git-rebase.txt:364 en/git-rebase.txt:654 en/git-reset.txt:76 en/git-restore.txt:87 en/git-submodule.txt:376 en/git-svn.txt:676 en/git-switch.txt:122 en/rev-list-options.txt:337
#, ignore-same, no-wrap, priority:280
msgid "--merge"
msgstr "--merge"

#. type: Plain text
#: en/git-checkout.txt:256
#, priority:240
msgid "When switching branches, if you have local modifications to one or more files that are different between the current branch and the branch to which you are switching, the command refuses to switch branches in order to preserve your modifications in context.  However, with this option, a three-way merge between the current branch, your working tree contents, and the new branch is done, and you will be on the new branch."
msgstr "在切换分支时，如果你对一个或多个文件的本地修改在当前分支和你要切换的分支之间是不同的，命令会拒绝切换分支，以保留你的修改内容。 然而，使用这个选项后，就会在当前分支、你的工作区内容和新的分支之间进行三方合并，之后，你会处于新分支。"

#. type: Plain text
#: en/git-checkout.txt:261 en/git-switch.txt:135
#, priority:240
msgid "When a merge conflict happens, the index entries for conflicting paths are left unmerged, and you need to resolve the conflicts and mark the resolved paths with `git add` (or `git rm` if the merge should result in deletion of the path)."
msgstr "当合并冲突发生时，冲突路径的索引条目会被留下，你需要解决冲突，并用`git add`标记已解决的路径（如果合并应导致删除路径，则用`git rm`）。"

#. type: Plain text
#: en/git-checkout.txt:264
#, priority:240
msgid "When checking out paths from the index, this option lets you recreate the conflicted merge in the specified paths."
msgstr "当从索引中检查出路径时，这个选项让你在指定的路径中重新创建冲突的合并。"

#. type: Plain text
#: en/git-checkout.txt:266
#, priority:240
msgid "When switching branches with `--merge`, staged changes may be lost."
msgstr "当用`--merge`切换分支时，可能会丢失阶段性修改。"

#. type: Labeled list
#: en/git-checkout.txt:267 en/git-restore.txt:91 en/git-switch.txt:136
#, no-wrap, priority:280
msgid "--conflict=<style>"
msgstr "--conflict=<style>"

#. type: Plain text
#: en/git-checkout.txt:272 en/git-restore.txt:96 en/git-switch.txt:141
#, fuzzy, priority:280
#| msgid "The same as `--merge` option above, but changes the way the conflicting hunks are presented, overriding the `merge.conflictStyle` configuration variable.  Possible values are \"merge\" (default) and \"diff3\" (in addition to what is shown by \"merge\" style, shows the original contents)."
msgid "The same as `--merge` option above, but changes the way the conflicting hunks are presented, overriding the `merge.conflictStyle` configuration variable.  Possible values are \"merge\" (default), \"diff3\", and \"zdiff3\"."
msgstr "与上面的 `--merge` 选项相同，但改变了冲突块的显示方式，覆盖 `merge.conflictStyle` 配置变量。可能的值是 \"merge\"（默认）和 \"diff3\"（除了 \"merge\" 样式显示的内容外，还显示原始内容）。"

#. type: Plain text
#: en/git-checkout.txt:279
#, priority:240
msgid "Interactively select hunks in the difference between the `<tree-ish>` (or the index, if unspecified) and the working tree.  The chosen hunks are then applied in reverse to the working tree (and if a `<tree-ish>` was specified, the index)."
msgstr "在`<树状对象>`（或索引，如果没有指定）和工作区之间的差异中，交互式地选择目标。 选择的目标会被反向应用到工作区上（如果指定了`<树状对象>`，则是索引）。"

#. type: Plain text
#: en/git-checkout.txt:283
#, priority:240
msgid "This means that you can use `git checkout -p` to selectively discard edits from your current working tree. See the ``Interactive Mode'' section of linkgit:git-add[1] to learn how to operate the `--patch` mode."
msgstr "这意味着你可以使用 `git checkout -p` 来有选择地丢弃当前工作区上的编辑内容。参见 linkgit:git-add[1] 的 \"互动模式''部分，了解`--patch`模式如何操作。"

#. type: Plain text
#: en/git-checkout.txt:286
#, priority:240
msgid "Note that this option uses the no overlay mode by default (see also `--overlay`), and currently doesn't support overlay mode."
msgstr "注意，这个选项默认使用无覆盖模式（另见`--overlay`），目前不支持覆盖模式。"

#. type: Labeled list
#: en/git-checkout.txt:287 en/git-switch.txt:177
#, ignore-same, no-wrap, priority:240
msgid "--ignore-other-worktrees"
msgstr "--ignore-other-worktrees"

#. type: Plain text
#: en/git-checkout.txt:292
#, priority:240
msgid "`git checkout` refuses when the wanted ref is already checked out by another worktree. This option makes it check the ref out anyway. In other words, the ref can be held by more than one worktree."
msgstr "`git checkout`在想要的引用已经被另一个工作区签出时拒绝。这个选项让它无论如何都要签出这个引用。换句话说，这个引用可能被多个工作区持有。"

#. type: Labeled list
#: en/git-checkout.txt:293 en/git-merge.txt:96
#, ignore-same, no-wrap, priority:240
msgid "--overwrite-ignore"
msgstr "--overwrite-ignore"

#. type: Labeled list
#: en/git-checkout.txt:294 en/git-merge.txt:97
#, ignore-same, no-wrap, priority:240
msgid "--no-overwrite-ignore"
msgstr "--no-overwrite-ignore"

#. type: Plain text
#: en/git-checkout.txt:298
#, priority:240
msgid "Silently overwrite ignored files when switching branches. This is the default behavior. Use `--no-overwrite-ignore` to abort the operation when the new branch contains ignored files."
msgstr "在切换分支时静默地覆盖被忽略的文件。这是默认行为。使用 `--no-overwrite-ignore` 可以在新的分支包含被忽略的文件时中止操作。"

#. type: Plain text
#: en/git-checkout.txt:308
#, priority:240
msgid "Using `--recurse-submodules` will update the content of all active submodules according to the commit recorded in the superproject. If local modifications in a submodule would be overwritten the checkout will fail unless `-f` is used. If nothing (or `--no-recurse-submodules`)  is used, submodules working trees will not be updated.  Just like linkgit:git-submodule[1], this will detach `HEAD` of the submodule."
msgstr "使用`--recurse-submodules`将根据父项目的提交记录更新所有活动的子模块的内容。如果子模块中的本地修改会被覆盖，除非使用`-f`，则会签出将失败。如果什么都不使用（或`--no-recurse-submodules`），子模块的工作区将不会被更新。  就像linkgit:git-submodule[1]，这将分离子模块的`HEAD`。"

#. type: Labeled list
#: en/git-checkout.txt:309 en/git-restore.txt:121
#, ignore-same, no-wrap, priority:280
msgid "--overlay"
msgstr "--overlay"

#. type: Labeled list
#: en/git-checkout.txt:310 en/git-restore.txt:122
#, ignore-same, no-wrap, priority:280
msgid "--no-overlay"
msgstr "--no-overlay"

#. type: Plain text
#: en/git-checkout.txt:316
#, priority:240
msgid "In the default overlay mode, `git checkout` never removes files from the index or the working tree.  When specifying `--no-overlay`, files that appear in the index and working tree, but not in `<tree-ish>` are removed, to make them match `<tree-ish>` exactly."
msgstr "在默认的覆盖模式下，`git checkout`不会从索引或工作区中删除文件。  当指定`--no-overlay`时，出现在索引和工作区中，但不在`<树状对象>`中的文件会被删除，以使它们与`<树状对象>`完全匹配。"

#. type: Labeled list
#: en/git-checkout.txt:330 en/git-rebase.txt:282 en/git-switch.txt:36
#, fuzzy, no-wrap, priority:240
msgid "<branch>"
msgstr "<branch>"

#. type: Plain text
#: en/git-checkout.txt:336
#, priority:240
msgid "Branch to checkout; if it refers to a branch (i.e., a name that, when prepended with \"refs/heads/\", is a valid ref), then that branch is checked out. Otherwise, if it refers to a valid commit, your `HEAD` becomes \"detached\" and you are no longer on any branch (see below for details)."
msgstr "签出的分支；如果它指的是一个分支（即一个名字，在前面加上 \"refs/heads/\"时，是一个有效的 引用），那么这个分支就被签出。否则，如果它指的是一个有效的提交，你的`HEAD`就会\"分离\"，此时，你就不再在任何一个分支上了（详见下文）。"

#. type: Plain text
#: en/git-checkout.txt:340
#, priority:240
msgid "You can use the `@{-N}` syntax to refer to the N-th last branch/commit checked out using \"git checkout\" operation. You may also specify `-` which is synonymous to `@{-1}`."
msgstr "你可以使用`@{-N}`语法来指代使用 \"git checkout \"操作检查出来的第N个最后的分支或是提交。你也可以指定`-`，它与`@{-1}`同义。"

#. type: Plain text
#: en/git-checkout.txt:344 en/git-switch.txt:58
#, ignore-ellipsis, priority:240
msgid "As a special case, you may use `A...B` as a shortcut for the merge base of `A` and `B` if there is exactly one merge base. You can leave out at most one of `A` and `B`, in which case it defaults to `HEAD`."
msgstr "作为一种特殊情况，如果正好有一个合并基础，你可以使用`A...B`作为`A`和`B`的合并基础的快捷方式。你最多可以省略在`A`和`B`中默认为`HEAD`的一个分支。"

#. type: Labeled list
#: en/git-checkout.txt:345 en/git-switch.txt:39
#, no-wrap, priority:240
msgid "<new-branch>"
msgstr "<新分支>"

#. type: Plain text
#: en/git-checkout.txt:347 en/git-switch.txt:41
#, priority:240
msgid "Name for the new branch."
msgstr "新分支的名称。"

#. type: Plain text
#: en/git-checkout.txt:351
#, priority:240
msgid "The name of a commit at which to start the new branch; see linkgit:git-branch[1] for details. Defaults to `HEAD`."
msgstr "启动新分支的提交名称；详见 linkgit:git-branch[1]。默认为 `HEAD`。"

#. type: Plain text
#: en/git-checkout.txt:355 en/git-checkout.txt:363 en/git-restore.txt:47
#, ignore-ellipsis, priority:280
msgid "As a special case, you may use `\"A...B\"` as a shortcut for the merge base of `A` and `B` if there is exactly one merge base. You can leave out at most one of `A` and `B`, in which case it defaults to `HEAD`."
msgstr "作为一种特殊情况，如果正好有一个合并基数，你可以使用`\"A...B \"作为`A`和`B`的合并基数的快捷方式。你最多可以漏掉`A`和`B`中的一个，在这种情况下，它默认为`HEAD`。"

#. type: Plain text
#: en/git-checkout.txt:359
#, priority:240
msgid "Tree to checkout from (when paths are given). If not specified, the index will be used."
msgstr "签出的树（当路径给定时）。如果没有指定，将使用索引。"

#. type: Plain text
#: en/git-checkout.txt:369 en/git-reset.txt:133 en/git-restore.txt:146
#, priority:280
msgid "Limits the paths affected by the operation."
msgstr "限制受操作影响的路径。"

#. type: Plain text
#: en/git-checkout.txt:371 en/git-commit.txt:408 en/git-reset.txt:135 en/git-restore.txt:148 en/git-rm.txt:47 en/git-stash.txt:259
#, priority:280
msgid "For more details, see the 'pathspec' entry in linkgit:gitglossary[7]."
msgstr "更多细节请参见 linkgit:gitglossary[7] 中的 '路径规范' 条目。"

#. type: Title -
#: en/git-checkout.txt:373
#, no-wrap, priority:240
msgid "DETACHED HEAD"
msgstr "游离状态（DETACHED HEAD）"

#. type: Plain text
#: en/git-checkout.txt:377
#, priority:240
msgid "`HEAD` normally refers to a named branch (e.g. `master`). Meanwhile, each branch refers to a specific commit. Let's look at a repo with three commits, one of them tagged, and with branch `master` checked out:"
msgstr "`HEAD`通常指的是一个分支的引用（例如`master`）。同时，每个分支指的是一个特定的提交。让我们看看一个有三个提交的仓库，其中一个被标记了，并且分支`master`被检出："

#. type: delimited block -
#: en/git-checkout.txt:386
#, no-wrap, priority:240
msgid ""
"           HEAD (refers to branch 'master')\n"
"            |\n"
"            v\n"
"a---b---c  branch 'master' (refers to commit 'c')\n"
"    ^\n"
"    |\n"
"  tag 'v2.0' (refers to commit 'b')\n"
msgstr ""
"           HEAD（'master'分支的引用）\n"
"            |\n"
"            v\n"
"a---b---c  branch 'master'（'c' 提交的引用）\n"
"    ^\n"
"    |\n"
"  tag 'v2.0' （'b' 提交的引用）\n"

#. type: Plain text
#: en/git-checkout.txt:393
#, priority:240
msgid "When a commit is created in this state, the branch is updated to refer to the new commit. Specifically, 'git commit' creates a new commit `d`, whose parent is commit `c`, and then updates branch `master` to refer to new commit `d`. `HEAD` still refers to branch `master` and so indirectly now refers to commit `d`:"
msgstr "当在这种状态下创建一个提交时，分支会被更新以引用新的提交。具体来说，'git commit'创建了一个新的提交`d`，其父级是提交`c`，然后更新分支`master`以引用新的提交`d`。`HEAD'仍指向`master'，所以现在间接地指向提交`d`："

#. type: delimited block -
#: en/git-checkout.txt:396 en/git-checkout.txt:431 en/git-checkout.txt:448
#, fuzzy, no-wrap, priority:240
msgid "$ edit; git add; git commit\n"
msgstr "$ edit; git add; git commit\n"

#. type: delimited block -
#: en/git-checkout.txt:404
#, no-wrap, priority:240
msgid ""
"               HEAD (refers to branch 'master')\n"
"                |\n"
"                v\n"
"a---b---c---d  branch 'master' (refers to commit 'd')\n"
"    ^\n"
"    |\n"
"  tag 'v2.0' (refers to commit 'b')\n"
msgstr ""
"               HEAD （指向'master'分支）\n"
"                |\n"
"                v\n"
"a---b---c---d  分支'master' （指向提交'd'）\n"
"    ^\n"
"    |\n"
"  tag 'v2.0' (指向提交'b')\n"

#. type: Plain text
#: en/git-checkout.txt:410
#, priority:240
msgid "It is sometimes useful to be able to checkout a commit that is not at the tip of any named branch, or even to create a new commit that is not referenced by a named branch. Let's look at what happens when we checkout commit `b` (here we show two ways this may be done):"
msgstr "有时能够签出一个不在任何命名分支顶端的提交，甚至创建一个不被命名分支引用的新提交，是很有用的。让我们来看看当我们签出提交 `b`时会发生什么（这里我们展示了两种方法）："

#. type: delimited block -
#: en/git-checkout.txt:414
#, fuzzy, no-wrap, priority:240
msgid ""
"$ git checkout v2.0  # or\n"
"$ git checkout master^^\n"
msgstr ""
"$ git checkout v2.0  # or\n"
"$ git checkout master^^\n"

#. type: delimited block -
#: en/git-checkout.txt:422
#, no-wrap, priority:240
msgid ""
"   HEAD (refers to commit 'b')\n"
"    |\n"
"    v\n"
"a---b---c---d  branch 'master' (refers to commit 'd')\n"
"    ^\n"
"    |\n"
"  tag 'v2.0' (refers to commit 'b')\n"
msgstr ""
"   HEAD （指向提交'b'）\n"
"    |\n"
"    v\n"
"a---b---c---d  分支'master'（指向提交'd'）\n"
"    ^\n"
"    |\n"
"  tag 'v2.0' (指向提交'b')\n"

#. type: Plain text
#: en/git-checkout.txt:428
#, priority:240
msgid "Notice that regardless of which checkout command we use, `HEAD` now refers directly to commit `b`. This is known as being in detached `HEAD` state.  It means simply that `HEAD` refers to a specific commit, as opposed to referring to a named branch. Let's see what happens when we create a commit:"
msgstr "请注意，无论我们使用哪条结账命令，`HEAD`现在都直接指向提交`b`。这就是所谓的分离的`HEAD'状态。  这意味着，`HEAD`指向一个特定的提交，而不是指向一个命名的分支。让我们看看创建提交时发生了什么："

#. type: delimited block -
#: en/git-checkout.txt:441
#, no-wrap, priority:240
msgid ""
"     HEAD (refers to commit 'e')\n"
"      |\n"
"      v\n"
"      e\n"
"     /\n"
"a---b---c---d  branch 'master' (refers to commit 'd')\n"
"    ^\n"
"    |\n"
"  tag 'v2.0' (refers to commit 'b')\n"
msgstr ""
"     HEAD （指向提交'e'）\n"
"      |\n"
"      v\n"
"      e\n"
"     /\n"
"a---b---c---d  branch 'master' （指向提交'd'）\n"
"    ^\n"
"    |\n"
"  tag 'v2.0' （指向提交'b'）\n"

#. type: Plain text
#: en/git-checkout.txt:445
#, priority:240
msgid "There is now a new commit `e`, but it is referenced only by `HEAD`. We can of course add yet another commit in this state:"
msgstr "现在有一个新的提交`e`，但它只被`HEAD`所引用。当然，我们可以在这个状态下再增加一个提交："

#. type: delimited block -
#: en/git-checkout.txt:458
#, no-wrap, priority:240
msgid ""
"\t HEAD (refers to commit 'f')\n"
"\t  |\n"
"\t  v\n"
"      e---f\n"
"     /\n"
"a---b---c---d  branch 'master' (refers to commit 'd')\n"
"    ^\n"
"    |\n"
"  tag 'v2.0' (refers to commit 'b')\n"
msgstr ""
"\t HEAD（指向提交'f'）。\n"
"\t  |\n"
"\t  v\n"
"      e--f\n"
"     /\n"
"a--b--c--d 分支\"master\"（指向提交'd'）。\n"
"    ^\n"
"    |\n"
"  tag 'v2.0'（指向提交'b'）。\n"

#. type: Plain text
#: en/git-checkout.txt:462
#, priority:240
msgid "In fact, we can perform all the normal Git operations. But, let's look at what happens when we then checkout `master`:"
msgstr "事实上，我们可以执行所有正常的 Git 操作。但是，让我们看看当我们签出`master`时会发生什么："

#. type: delimited block -
#: en/git-checkout.txt:465
#, fuzzy, no-wrap, priority:240
msgid "$ git checkout master\n"
msgstr "$ git checkout master\n"

#. type: delimited block -
#: en/git-checkout.txt:473
#, no-wrap, priority:240
msgid ""
"               HEAD (refers to branch 'master')\n"
"      e---f     |\n"
"     /          v\n"
"a---b---c---d  branch 'master' (refers to commit 'd')\n"
"    ^\n"
"    |\n"
"  tag 'v2.0' (refers to commit 'b')\n"
msgstr ""
"               HEAD（指向分支 'master'）\n"
"      e---f     |\n"
"     /          v\n"
"a---b---c---d  branch 'master' （指向提交 'd'）\n"
"    ^\n"
"    |\n"
"  tag 'v2.0' (指向提交 'b')\n"

#. type: Plain text
#: en/git-checkout.txt:480
#, priority:240
msgid "It is important to realize that at this point nothing refers to commit `f`. Eventually commit `f` (and by extension commit `e`) will be deleted by the routine Git garbage collection process, unless we create a reference before that happens. If we have not yet moved away from commit `f`, any of these will create a reference to it:"
msgstr "重要的是要意识到，在这一点上，没有任何引用是指向提交`f`的。最终，提交 `f`（以及提交 `e`）会被 Git 的例行垃圾回收程序删除，除非我们在这之前创建一个引用。如果我们还没有离开提交 `f`，以下任何一个操作都会创建一个对它的引用："

#. type: delimited block -
#: en/git-checkout.txt:485
#, fuzzy, no-wrap, priority:240
msgid ""
"$ git checkout -b foo  # or \"git switch -c foo\"  <1>\n"
"$ git branch foo                                 <2>\n"
"$ git tag foo                                    <3>\n"
msgstr ""
"$ git checkout -b foo   <1>\n"
"$ git branch foo        <2>\n"
"$ git tag foo           <3>\n"

#. type: Plain text
#: en/git-checkout.txt:489
#, priority:240
msgid "creates a new branch `foo`, which refers to commit `f`, and then updates `HEAD` to refer to branch `foo`. In other words, we'll no longer be in detached `HEAD` state after this command."
msgstr "创建一个新的分支`foo`，指向提交`f`，然后更新`HEAD`，指向分支`foo`。换句话说，这条命令之后，我们将不再处于分离的`HEAD`状态。"

#. type: Plain text
#: en/git-checkout.txt:491
#, priority:240
msgid "similarly creates a new branch `foo`, which refers to commit `f`, but leaves `HEAD` detached."
msgstr "类似的，创建一个新的分支`foo`，它指向提交`f`，但将`HEAD`分离出来。"

#. type: Plain text
#: en/git-checkout.txt:493
#, priority:240
msgid "creates a new tag `foo`, which refers to commit `f`, leaving `HEAD` detached."
msgstr "创建一个新的标签`foo`，指向提交`f`，让`HEAD`处于分离状态。"

#. type: Plain text
#: en/git-checkout.txt:498
#, priority:240
msgid "If we have moved away from commit `f`, then we must first recover its object name (typically by using git reflog), and then we can create a reference to it. For example, to see the last two commits to which `HEAD` referred, we can use either of these commands:"
msgstr "如果我们已经离开了`f'的提交，那么我们必须首先恢复它的对象名称（通常使用git reflog），然后我们可以创建一个对它的引用。例如，要查看`HEAD`指向的最后两个提交，我们可以使用以下任一命令："

#. type: delimited block -
#: en/git-checkout.txt:502
#, fuzzy, no-wrap, priority:240
msgid ""
"$ git reflog -2 HEAD # or\n"
"$ git log -g -2 HEAD\n"
msgstr ""
"$ git reflog -2 HEAD # or\n"
"$ git log -g -2 HEAD\n"

#. type: Title -
#: en/git-checkout.txt:505
#, fuzzy, no-wrap, priority:240
msgid "ARGUMENT DISAMBIGUATION"
msgstr "论点消歧"

#. type: Plain text
#: en/git-checkout.txt:515
#, priority:240
msgid "When there is only one argument given and it is not `--` (e.g. `git checkout abc`), and when the argument is both a valid `<tree-ish>` (e.g. a branch `abc` exists) and a valid `<pathspec>` (e.g. a file or a directory whose name is \"abc\" exists), Git would usually ask you to disambiguate.  Because checking out a branch is so common an operation, however, `git checkout abc` takes \"abc\" as a `<tree-ish>` in such a situation.  Use `git checkout -- <pathspec>` if you want to checkout these paths out of the index."
msgstr "当只有一个参数且不是`--`时（例如`git checkout abc`），当参数既是有效的`<树状对象>`（例如分支`abc`存在）又是有效的`<路径规范>`（例如文件或目录的名称为 \"abc \"存在），Git通常会要求你进行区分。  因为签出分支是很常见的操作，`git checkout abc`在这种情况下把 \"abc \"作为`<树状对象>`。  如果你想从索引中签出这些路径，请使用`git checkout --<路径规范>`。"

#. type: Title ===
#: en/git-checkout.txt:519
#, no-wrap, priority:240
msgid "1. Paths"
msgstr "1.路径"

#. type: Plain text
#: en/git-checkout.txt:524
#, priority:240
msgid "The following sequence checks out the `master` branch, reverts the `Makefile` to two revisions back, deletes `hello.c` by mistake, and gets it back from the index."
msgstr "下面的序列检查了 \"master \"分支，将 \"Makefile \"恢复到两个修订版，错误地删除了 \"hello.c\"，并从索引中取回它。"

#. type: delimited block -
#: en/git-checkout.txt:530
#, fuzzy, no-wrap, priority:240
msgid ""
"$ git checkout master             <1>\n"
"$ git checkout master~2 Makefile  <2>\n"
"$ rm -f hello.c\n"
"$ git checkout hello.c            <3>\n"
msgstr ""
"$ git checkout master             <1>\n"
"$ git checkout master~2 Makefile  <2>\n"
"$ rm -f hello.c\n"
"$ git checkout hello.c            <3>\n"

#. type: Plain text
#: en/git-checkout.txt:532
#, priority:240
msgid "switch branch"
msgstr "选择分支"

#. type: Plain text
#: en/git-checkout.txt:533 en/git-restore.txt:164
#, priority:280
msgid "take a file out of another commit"
msgstr "将一个文件从另一个提交中取出"

#. type: Plain text
#: en/git-checkout.txt:534
#, priority:240
msgid "restore `hello.c` from the index"
msgstr "从索引中恢复`hello.c`"

#. type: Plain text
#: en/git-checkout.txt:537
#, priority:240
msgid "If you want to check out _all_ C source files out of the index, you can say"
msgstr "如果你想从索引中检出_所有_的C源文件，你可以这样"

#. type: delimited block -
#: en/git-checkout.txt:540
#, fuzzy, no-wrap, priority:240
msgid "$ git checkout -- '*.c'\n"
msgstr "$ git checkout -- '*.c'\n"

#. type: Plain text
#: en/git-checkout.txt:546
#, priority:240
msgid "Note the quotes around `*.c`.  The file `hello.c` will also be checked out, even though it is no longer in the working tree, because the file globbing is used to match entries in the index (not in the working tree by the shell)."
msgstr "注意 `*.c `周围的引号。  文件`hello.c`也将被检出，尽管它已经不在工作树中了，因为文件通配符被用来匹配索引中的条目（不是工作区中的shell）。"

#. type: Plain text
#: en/git-checkout.txt:550
#, priority:240
msgid "If you have an unfortunate branch that is named `hello.c`, this step would be confused as an instruction to switch to that branch.  You should instead write:"
msgstr "如果不幸你有一个分支被命名为 \"hello.c\"，这一步会误认为切换到该分支的指令。  你应该这样写："

#. type: delimited block -
#: en/git-checkout.txt:553
#, fuzzy, no-wrap, priority:240
msgid "$ git checkout -- hello.c\n"
msgstr "$ git checkout -- hello.c\n"

#. type: Title ===
#: en/git-checkout.txt:555
#, fuzzy, no-wrap, priority:240
#| msgid "merge"
msgid "2. Merge"
msgstr "merge"

#. type: Plain text
#: en/git-checkout.txt:559 en/git-switch.txt:203
#, priority:240
msgid "After working in the wrong branch, switching to the correct branch would be done using:"
msgstr "在错误的分支工作后，切换到正确的分支将使用："

#. type: delimited block -
#: en/git-checkout.txt:562
#, fuzzy, no-wrap, priority:240
msgid "$ git checkout mytopic\n"
msgstr "$ git checkout mytopic\n"

#. type: Plain text
#: en/git-checkout.txt:567
#, priority:240
msgid "However, your \"wrong\" branch and correct `mytopic` branch may differ in files that you have modified locally, in which case the above checkout would fail like this:"
msgstr "然而，你的 \"错误\"分支和正确的`mytopic`分支可能在你本地修改的文件中存在差异，在这种情况下，上述检出会失败，像这样："

#. type: delimited block -
#: en/git-checkout.txt:571
#, fuzzy, no-wrap, priority:240
msgid ""
"$ git checkout mytopic\n"
"error: You have local changes to 'frotz'; not switching branches.\n"
msgstr ""
"$ git checkout mytopic\n"
"error: You have local changes to 'frotz'; not switching branches.\n"

#. type: Plain text
#: en/git-checkout.txt:575 en/git-switch.txt:219
#, priority:240
msgid "You can give the `-m` flag to the command, which would try a three-way merge:"
msgstr "你可以给命令加上 `-m`标志，这样就可以尝试三方合并了："

#. type: delimited block -
#: en/git-checkout.txt:579
#, fuzzy, no-wrap, priority:240
msgid ""
"$ git checkout -m mytopic\n"
"Auto-merging frotz\n"
msgstr ""
"$ git checkout -m mytopic\n"
"Auto-merging frotz\n"

#. type: Plain text
#: en/git-checkout.txt:584 en/git-switch.txt:228
#, priority:240
msgid "After this three-way merge, the local modifications are _not_ registered in your index file, so `git diff` would show you what changes you made since the tip of the new branch."
msgstr "在这个三方合并之后，本地的修改并「没有」登记在你的索引文件中，所以`git diff`会显示你在新分支的提示下做了哪些修改。"

#. type: Title ===
#: en/git-checkout.txt:585
#, fuzzy, no-wrap, priority:240
#| msgid "merge.conflictStyle"
msgid "3. Merge conflict"
msgstr "merge.conflictStyle"

#. type: Plain text
#: en/git-checkout.txt:589
#, priority:240
msgid "When a merge conflict happens during switching branches with the `-m` option, you would see something like this:"
msgstr "当使用`-m`选项切换分支时发生合并冲突，你会看到类似这样的情况："

#. type: delimited block -
#: en/git-checkout.txt:595
#, fuzzy, no-wrap, priority:240
msgid ""
"$ git checkout -m mytopic\n"
"Auto-merging frotz\n"
"ERROR: Merge conflict in frotz\n"
"fatal: merge program failed\n"
msgstr ""
"$ git checkout -m mytopic\n"
"Auto-merging frotz\n"
"ERROR: Merge conflict in frotz\n"
"fatal: merge program failed\n"

#. type: Plain text
#: en/git-checkout.txt:601
#, priority:240
msgid "At this point, `git diff` shows the changes cleanly merged as in the previous example, as well as the changes in the conflicted files.  Edit and resolve the conflict and mark it resolved with `git add` as usual:"
msgstr "在这一点上，`git diff`显示了与前面的例子一样干净地合并的修改，以及冲突文件中的修改。  编辑并解决冲突，让后像往常一样用`git add`标记已解决："

#. type: delimited block -
#: en/git-checkout.txt:605
#, fuzzy, no-wrap, priority:240
msgid ""
"$ edit frotz\n"
"$ git add frotz\n"
msgstr ""
"$ edit frotz\n"
"$ git add frotz\n"

#. type: Plain text
#: en/git-checkout.txt:618
#, ignore-same, priority:240
msgid "linkgit:git-switch[1], linkgit:git-restore[1]"
msgstr "linkgit:git-switch[1], linkgit:git-restore[1]"

#. type: Title =
#: en/git-check-ref-format.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-check-ref-format(1)"
msgstr "git-check-ref-format(1)"

#. type: Plain text
#: en/git-check-ref-format.txt:7
#, priority:100
msgid "git-check-ref-format - Ensures that a reference name is well formed"
msgstr "git-check-ref-format - 确保引用名称的格式正确"

#. type: Plain text
#: en/git-check-ref-format.txt:15
#, no-wrap, priority:100
msgid ""
"'git check-ref-format' [--normalize]\n"
"       [--[no-]allow-onelevel] [--refspec-pattern]\n"
"       <refname>\n"
"'git check-ref-format' --branch <branchname-shorthand>\n"
msgstr ""
"'git check-ref-format' [--normalize]\n"
"       [--[no-]allow-onelevel] [--refspec-pattern]\n"
"       <引用名>\n"
"'git check-ref-format' --branch <branchname-shorthand>\n"

#. type: Plain text
#: en/git-check-ref-format.txt:20
#, priority:100
msgid "Checks if a given 'refname' is acceptable, and exits with a non-zero status if it is not."
msgstr "检查给定的 ‘引用名’ 是否可接受，如果不可接受，则以非零状态退出。"

#. type: Plain text
#: en/git-check-ref-format.txt:27
#, priority:100
msgid "A reference is used in Git to specify branches and tags.  A branch head is stored in the `refs/heads` hierarchy, while a tag is stored in the `refs/tags` hierarchy of the ref namespace (typically in `$GIT_DIR/refs/heads` and `$GIT_DIR/refs/tags` directories or, as entries in file `$GIT_DIR/packed-refs` if refs are packed by `git gc`)."
msgstr "在 Git 中，引用被用来指定分支和标签。 分支头存储在 `refs/heads` 层次结构中，而标签存储在引用命名空间的 `refs/tags` 层次结构中（通常在 `$GIT_DIR/refs/heads` 和 `$GIT_DIR/refs/tags` 目录中，或者，如果引用是由 `git gc` 打包的，则作为文件 `$GIT_DIR/packed-refs` 的条目）。"

#. type: Plain text
#: en/git-check-ref-format.txt:29
#, priority:100
msgid "Git imposes the following rules on how references are named:"
msgstr "Git 对引用的命名方式有以下规则："

#. type: Plain text
#: en/git-check-ref-format.txt:33
#, priority:100
msgid "They can include slash `/` for hierarchical (directory)  grouping, but no slash-separated component can begin with a dot `.` or end with the sequence `.lock`."
msgstr "它们可以包括斜线`/`，用于分层（目录）分组，但任何斜线分隔的组件都不能以点`.`开头或以序列`.lock`结尾。"

#. type: Plain text
#: en/git-check-ref-format.txt:38
#, priority:100
msgid "They must contain at least one `/`. This enforces the presence of a category like `heads/`, `tags/` etc. but the actual names are not restricted.  If the `--allow-onelevel` option is used, this rule is waived."
msgstr "它们可以包括斜线 `/`，用于分层（目录）分组，但任何斜线分隔的组件都不能以点 `.` 开头或以序列 `.lock` 结尾。"

#. type: Plain text
#: en/git-check-ref-format.txt:40
#, priority:100
msgid "They cannot have two consecutive dots `..` anywhere."
msgstr "他们不能在任何地方有两个连续的点 `..`。"

#. type: Plain text
#: en/git-check-ref-format.txt:44
#, priority:100
msgid "They cannot have ASCII control characters (i.e. bytes whose values are lower than \\040, or \\177 `DEL`), space, tilde `~`, caret `^`, or colon `:` anywhere."
msgstr "它们不能有 ASCII 控制字符（即数值低于 \\040，或 177 `DEL` 的字节）、空格、斜体字 `~`、省略号 `^`，或冒号 `:` 的任何一个。"

#. type: Plain text
#: en/git-check-ref-format.txt:48
#, priority:100
msgid "They cannot have question-mark `?`, asterisk `*`, or open bracket `[` anywhere.  See the `--refspec-pattern` option below for an exception to this rule."
msgstr "它们不能有问号 `?`，星号 `*`，或大括号 `[`的地方。 参见下面的 `--refspec-pattern` 选项，以了解这一规则的例外情况。"

#. type: Plain text
#: en/git-check-ref-format.txt:52
#, priority:100
msgid "They cannot begin or end with a slash `/` or contain multiple consecutive slashes (see the `--normalize` option below for an exception to this rule)"
msgstr "它们不能以斜线 `/` 开头或结尾，也不能包含多个连续的斜线（参见下面的 `--normalize` 选项，该规则的一个例外）"

#. type: Plain text
#: en/git-check-ref-format.txt:54
#, priority:100
msgid "They cannot end with a dot `.`."
msgstr "它们不能以点 `.` 结尾。"

#. type: Plain text
#: en/git-check-ref-format.txt:56
#, priority:100
msgid "They cannot contain a sequence `@{`."
msgstr "它们不能包含一个序列 `@{`。"

#. type: Plain text
#: en/git-check-ref-format.txt:58
#, priority:100
msgid "They cannot be the single character `@`."
msgstr "它们不能是单个字符 `@`。"

#. type: Plain text
#: en/git-check-ref-format.txt:60
#, priority:100
msgid "They cannot contain a `\\`."
msgstr "它们不能包含一个 `\\`。"

#. type: Plain text
#: en/git-check-ref-format.txt:65
#, priority:100
msgid "These rules make it easy for shell script based tools to parse reference names, pathname expansion by the shell when a reference name is used unquoted (by mistake), and also avoid ambiguities in certain reference name expressions (see linkgit:gitrevisions[7]):"
msgstr "这些规则使基于 shell 脚本的工具很容易解析引用名，当引用名未加引号（错误地）使用时由 shell 进行路径名扩展，同时也避免了某些引用名表达的歧义（见 linkgit:gitrevisions[7]）："

#. type: Plain text
#: en/git-check-ref-format.txt:69
#, priority:100
msgid "A double-dot `..` is often used as in `ref1..ref2`, and in some contexts this notation means `^ref1 ref2` (i.e. not in `ref1` and in `ref2`)."
msgstr "双点 `..` 经常被用作 `ref1..ref2`，在某些情况下，这个符号意味着 `^ref1 ref2`（即不在 `ref1` 和 `ref2` 中）。"

#. type: Plain text
#: en/git-check-ref-format.txt:72
#, priority:100
msgid "A tilde `~` and caret `^` are used to introduce the postfix 'nth parent' and 'peel onion' operation."
msgstr "省略号 `~` 和 `^` 符号用于介绍后缀 ‘第 n 个父亲’ 和 ‘剥洋葱’ 操作。"

#. type: Plain text
#: en/git-check-ref-format.txt:77
#, priority:100
msgid "A colon `:` is used as in `srcref:dstref` to mean \"use srcref\\'s value and store it in dstref\" in fetch and push operations.  It may also be used to select a specific object such as with 'git cat-file': \"git cat-file blob v1.3.3:refs.c\"."
msgstr "冒号 `:` 在获取和推送操作中被用于 `srcref:dstref`，表示 `使用 srcref（源引用）的值并将其存储在 dstref（目标引用）中。 它也可以用来选择一个特定的对象，如 'git cat-file': \"git cat-file blob v1.3.3:refs.c\"。"

#. type: Plain text
#: en/git-check-ref-format.txt:79
#, priority:100
msgid "at-open-brace `@{` is used as a notation to access a reflog entry."
msgstr "`@{` 被用来作为访问一个引用日志条目的符号。"

#. type: Plain text
#: en/git-check-ref-format.txt:98
#, priority:100
msgid "With the `--branch` option, the command takes a name and checks if it can be used as a valid branch name (e.g. when creating a new branch). But be cautious when using the previous checkout syntax that may refer to a detached HEAD state.  The rule `git check-ref-format --branch $name` implements may be stricter than what `git check-ref-format refs/heads/$name` says (e.g. a dash may appear at the beginning of a ref component, but it is explicitly forbidden at the beginning of a branch name).  When run with `--branch` option in a repository, the input is first expanded for the ``previous checkout syntax'' `@{-n}`.  For example, `@{-1}` is a way to refer the last thing that was checked out using \"git switch\" or \"git checkout\" operation.  This option should be used by porcelains to accept this syntax anywhere a branch name is expected, so they can act as if you typed the branch name. As an exception note that, the ``previous checkout operation'' might result in a commit object name when the N-th last thing checked out was not a branch."
msgstr "使用 `--branch` 选项，该命令接收一个名字，并检查它是否可以作为一个有效的分支名称（例如在创建新的分支时）。但在使用之前的检查语法时要谨慎，因为它可能指的是一个分离的 HEAD 状态。 `git check-ref-format --branch $name` 实现的规则可能比` git check-ref-format refs/heads/$name` 说的更严格（例如，破折号可以出现在引用组件的开头，但在分支名的开头是明确禁止的）。 当在仓库中使用 `--branch` 选项运行时，输入的内容首先被扩展为 ``以前的检出语法\" `@{-n}`。 例如，`@{-1}` 是指使用 \"git switch\" 或 \"git checkout\" 操作签出的最后一件东西。 这个选项应该被上层命令用来在任何需要分支名的地方接受这个语法，这样他们就可以像你输入分支名一样行事。作为一个例外，请注意，当最后签出的第 N 个东西不是一个分支时，\"以前的签出操作\" 可能会导致一个提交对象的名字。"

#. type: Labeled list
#: en/git-check-ref-format.txt:101
#, ignore-same, no-wrap, priority:100
msgid "--[no-]allow-onelevel"
msgstr "--[no-]allow-onelevel"

#. type: Plain text
#: en/git-check-ref-format.txt:105
#, priority:100
msgid "Controls whether one-level refnames are accepted (i.e., refnames that do not contain multiple `/`-separated components).  The default is `--no-allow-onelevel`."
msgstr "控制是否接受单级参考名称（即不包含多个 `/` 分隔的参考名称）。 默认值是 `--no-allow-onelevel`。"

#. type: Labeled list
#: en/git-check-ref-format.txt:106
#, ignore-same, no-wrap, priority:100
msgid "--refspec-pattern"
msgstr "--refspec-pattern"

#. type: Plain text
#: en/git-check-ref-format.txt:112
#, priority:100
msgid "Interpret <refname> as a reference name pattern for a refspec (as used with remote repositories).  If this option is enabled, <refname> is allowed to contain a single `*` in the refspec (e.g., `foo/bar*/baz` or `foo/bar*baz/` but not `foo/bar*/baz*`)."
msgstr "将 <引用名> 解释为引用规范的参考名称模式（如用于远程仓库）。 如果这个选项被启用，<引用名> 允许在引用规范中包含一个 `*`（例如， `foo/bar*/baz` 或 `foo/bar*baz/`，但不允许 `foo/bar*/baz*`）。"

#. type: Labeled list
#: en/git-check-ref-format.txt:113
#, ignore-same, no-wrap, priority:100
msgid "--normalize"
msgstr "--normalize"

#. type: Plain text
#: en/git-check-ref-format.txt:120
#, priority:100
msgid "Normalize 'refname' by removing any leading slash (`/`)  characters and collapsing runs of adjacent slashes between name components into a single slash.  If the normalized refname is valid then print it to standard output and exit with a status of 0, otherwise exit with a non-zero status.  (`--print` is a deprecated way to spell `--normalize`.)"
msgstr "将 ‘引用名’ 规范化，去掉任何前导斜线（`/`）字符，并将名称成分之间的相邻斜线折叠成一个斜线。 如果规范化后的引用名有效，则将其打印到标准输出，并以 0 的状态退出，否则以非零状态退出。 (`--print` 是 `--normalize` 的一种废弃的拼写方式。)"

#. type: Plain text
#: en/git-check-ref-format.txt:126
#, priority:100
msgid "Print the name of the previous thing checked out:"
msgstr "打印前一个检出的东西的名称："

#. type: delimited block -
#: en/git-check-ref-format.txt:129
#, fuzzy, no-wrap, priority:100
msgid "$ git check-ref-format --branch @{-1}\n"
msgstr "$ git check-ref-format --branch @{-1}\n"

#. type: Plain text
#: en/git-check-ref-format.txt:132
#, priority:100
msgid "Determine the reference name to use for a new branch:"
msgstr "确定新分支要使用的引用名称："

#. type: delimited block -
#: en/git-check-ref-format.txt:136
#, fuzzy, no-wrap, priority:100
msgid ""
"$ ref=$(git check-ref-format --normalize \"refs/heads/$newbranch\")||\n"
"{ echo \"we do not like '$newbranch' as a branch name.\" >&2 ; exit 1 ; }\n"
msgstr ""
"$ ref=$(git check-ref-format --normalize \"refs/heads/$newbranch\")||\n"
"{ echo \"we do not like '$newbranch' as a branch name.\" >&2 ; exit 1 ; }\n"

#. type: Title =
#: en/git-cherry-pick.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-cherry-pick(1)"
msgstr "git-cherry-pick(1)"

#. type: Plain text
#: en/git-cherry-pick.txt:7
#, fuzzy, priority:100
msgid "git-cherry-pick - Apply the changes introduced by some existing commits"
msgstr "git-cherry-pick - Apply the changes introduced by some existing commits"

#. type: Plain text
#: en/git-cherry-pick.txt:14
#, fuzzy, ignore-ellipsis, no-wrap, priority:100
msgid ""
"'git cherry-pick' [--edit] [-n] [-m <parent-number>] [-s] [-x] [--ff]\n"
"\t\t  [-S[<keyid>]] <commit>...\n"
"'git cherry-pick' (--continue | --skip | --abort | --quit)\n"
msgstr ""
"'git cherry-pick' [--edit] [-n] [-m parent-number] [-s] [-x] [--ff]\n"
"\t\t  [-S[<keyid>]] <commit>...\n"
"'git cherry-pick' (--continue | --skip | --abort | --quit)\n"

#. type: Plain text
#: en/git-cherry-pick.txt:21
#, priority:100
msgid "Given one or more existing commits, apply the change each one introduces, recording a new commit for each.  This requires your working tree to be clean (no modifications from the HEAD commit)."
msgstr "给出一个或多个现有的提交，应用每个提交所带来的变化，为每个提交记录一个新的提交。 这需要您的工作区是干净的（没有对 HEAD 提交的修改）。"

#. type: Plain text
#: en/git-cherry-pick.txt:24
#, priority:100
msgid "When it is not obvious how to apply a change, the following happens:"
msgstr "当如何应用一个变化不明显时，会发生以下情况："

#. type: Plain text
#: en/git-cherry-pick.txt:27
#, priority:100
msgid "The current branch and `HEAD` pointer stay at the last commit successfully made."
msgstr "当前的分支和 `HEAD` 指针保持在最后一次成功提交的位置。"

#. type: Plain text
#: en/git-cherry-pick.txt:29
#, priority:100
msgid "The `CHERRY_PICK_HEAD` ref is set to point at the commit that introduced the change that is difficult to apply."
msgstr "`CHERRY_PICK_HEAD` 引用被设置为指向引入难以应用的修改的提交。"

#. type: Plain text
#: en/git-cherry-pick.txt:31
#, priority:100
msgid "Paths in which the change applied cleanly are updated both in the index file and in your working tree."
msgstr "在索引文件和你的工作区中，更改应用得很干净的路径都被更新。"

#. type: Plain text
#: en/git-cherry-pick.txt:36
#, fuzzy, priority:100
msgid "For conflicting paths, the index file records up to three versions, as described in the \"TRUE MERGE\" section of linkgit:git-merge[1].  The working tree files will include a description of the conflict bracketed by the usual conflict markers `<<<<<<<` and `>>>>>>>`."
msgstr "对于冲突的路径，索引文件最多记录三个版本，如 linkgit:git-merge[1] 的 \"TRUE MERGE \"部分所述。 工作区文件将包括对冲突的描述，括号里是通常的冲突标记 `<<<<<<<` 和 `>>>>>>>`。"

#. type: Plain text
#: en/git-cherry-pick.txt:37
#, priority:100
msgid "No other modifications are made."
msgstr "不做其他修改。"

#. type: Plain text
#: en/git-cherry-pick.txt:40
#, priority:100
msgid "See linkgit:git-merge[1] for some hints on resolving such conflicts."
msgstr "参见 linkgit:git-merge[1] 以了解一些解决此类冲突的提示。"

#. type: Labeled list
#: en/git-cherry-pick.txt:43 en/git-merge.txt:127 en/git-revert.txt:36 en/git-verify-commit.txt:27
#, fuzzy, ignore-ellipsis, no-wrap, priority:240
msgid "<commit>..."
msgstr "<commit>..."

#. type: Plain text
#: en/git-cherry-pick.txt:52
#, ignore-ellipsis, priority:100
msgid "Commits to cherry-pick.  For a more complete list of ways to spell commits, see linkgit:gitrevisions[7].  Sets of commits can be passed but no traversal is done by default, as if the `--no-walk` option was specified, see linkgit:git-rev-list[1]. Note that specifying a range will feed all <commit>... arguments to a single revision walk (see a later example that uses 'maint master..next')."
msgstr "拣选（cherry-pick）的提交。 更完整的拼写提交的方法列表，见 linkgit:gitrevisions[7]。 可以传递提交集，但默认不做遍历，就像指定了 `--no-walk` 选项一样，见 linkgit:git-rev-list[1]。注意，指定一个范围会把所有 <提交>... 参数送入一个单一的修订版（见后面的例子，使用 'maint master...next'）。"

#. type: Plain text
#: en/git-cherry-pick.txt:57
#, priority:100
msgid "With this option, 'git cherry-pick' will let you edit the commit message prior to committing."
msgstr "有了这个选项，'git cherry-pick' 会让你在提交前编辑提交信息。"

#. type: Labeled list
#: en/git-cherry-pick.txt:58 en/git-commit.txt:232 en/git-revert.txt:70 en/git-tag.txt:187 en/merge-options.txt:38
#, no-wrap, priority:280
msgid "--cleanup=<mode>"
msgstr "--cleanup=<模式>"

#. type: Plain text
#: en/git-cherry-pick.txt:64 en/git-revert.txt:76
#, priority:100
msgid "This option determines how the commit message will be cleaned up before being passed on to the commit machinery. See linkgit:git-commit[1] for more details. In particular, if the '<mode>' is given a value of `scissors`, scissors will be appended to `MERGE_MSG` before being passed on in the case of a conflict."
msgstr "这个选项决定了提交信息在传递给提交机制之前将如何进行清理。更多细节见 linkgit:git-commit[1]。特别是，如果 '<模式>' 的值为 `scissors`，那么在发生冲突时，`scissors` 将被附加到 `MERGE_MSG` 上。"

#. type: Labeled list
#: en/git-cherry-pick.txt:65 en/git-clean.txt:63
#, ignore-same, no-wrap, priority:100
msgid "-x"
msgstr "-x"

#. type: Plain text
#: en/git-cherry-pick.txt:78
#, ignore-ellipsis, priority:100
msgid "When recording the commit, append a line that says \"(cherry picked from commit ...)\" to the original commit message in order to indicate which commit this change was cherry-picked from.  This is done only for cherry picks without conflicts.  Do not use this option if you are cherry-picking from your private branch because the information is useless to the recipient.  If on the other hand you are cherry-picking between two publicly visible branches (e.g. backporting a fix to a maintenance branch for an older release from a development branch), adding this information can be useful."
msgstr "在记录提交时，在原始提交信息中添加一行 \"(cherry picked from commit ...)\"，以表明这个改动是从哪个提交中拣选的。 这只适用于没有冲突的拣选。 如果你是从自己的私有分支中偷梁换柱，请不要使用这个选项，因为这个信息对接收者来说是无用的。 另一方面，如果您是在两个公开可见的分支之间进行拣选（例如，从开发分支向维护分支回传一个旧版本的修正），添加这一信息会很有用。"

#. type: Plain text
#: en/git-cherry-pick.txt:83
#, priority:100
msgid "It used to be that the command defaulted to do `-x` described above, and `-r` was to disable it.  Now the default is not to do `-x` so this option is a no-op."
msgstr "过去，该命令默认为做上述的 `-x`，`-r` 是禁用它。 现在默认是不做 `-x` ，所以这个选项是一个无用的选项。"

#. type: Labeled list
#: en/git-cherry-pick.txt:84
#, fuzzy, no-wrap, priority:100
msgid "-m <parent-number>"
msgstr "--mainline parent-number"

#. type: Labeled list
#: en/git-cherry-pick.txt:85
#, fuzzy, no-wrap, priority:100
msgid "--mainline <parent-number>"
msgstr "--mainline parent-number"

#. type: Plain text
#: en/git-cherry-pick.txt:91
#, priority:100
msgid "Usually you cannot cherry-pick a merge because you do not know which side of the merge should be considered the mainline.  This option specifies the parent number (starting from 1) of the mainline and allows cherry-pick to replay the change relative to the specified parent."
msgstr "通常你不能对一个合并进行拣选，因为你不知道合并的哪一边应该被视为主线。 这个选项指定了主线的父号（从 1 开始），允许拣选相对于指定的父号重放修改。"

#. type: Labeled list
#: en/git-cherry-pick.txt:93 en/git-revert.txt:78 en/merge-options.txt:2
#, ignore-same, no-wrap, priority:240
msgid "--no-commit"
msgstr "--no-commit"

#. type: Plain text
#: en/git-cherry-pick.txt:101
#, priority:100
msgid "Usually the command automatically creates a sequence of commits.  This flag applies the changes necessary to cherry-pick each named commit to your working tree and the index, without making any commit.  In addition, when this option is used, your index does not have to match the HEAD commit.  The cherry-pick is done against the beginning state of your index."
msgstr "通常该命令会自动创建一连串的提交。 这个标志会对您的工作树和索引进行必要的修改，以摘取每个命名的提交，而不做任何提交。 此外，使用这个选项时，您的索引不需要与 HEAD 提交相匹配。 挑拣是针对你的索引的起始状态进行的。"

#. type: Plain text
#: en/git-cherry-pick.txt:104
#, priority:100
msgid "This is useful when cherry-picking more than one commits' effect to your index in a row."
msgstr "这在连续摘取多个提交的效果给你的索引时很有用。"

#. type: Plain text
#: en/git-cherry-pick.txt:109 en/git-revert.txt:104
#, priority:100
msgid "Add a `Signed-off-by` trailer at the end of the commit message.  See the signoff option in linkgit:git-commit[1] for more information."
msgstr "在提交信息的末尾添加一个 `Signed-off-by` 的尾注。 更多信息见 linkgit:git-commit[1] 中的 signoff 选项。"

#. type: Labeled list
#: en/git-cherry-pick.txt:119 en/merge-options.txt:46 en/merge-options.txt:61
#, ignore-same, no-wrap, priority:240
msgid "--ff"
msgstr "--ff"

#. type: Plain text
#: en/git-cherry-pick.txt:123
#, priority:100
msgid "If the current HEAD is the same as the parent of the cherry-pick'ed commit, then a fast forward to this commit will be performed."
msgstr "如果当前的 HEAD 与拣选的提交的父本相同，那么将执行快速合并到这个提交。"

#. type: Plain text
#: en/git-cherry-pick.txt:136
#, priority:100
msgid "By default, cherry-picking an empty commit will fail, indicating that an explicit invocation of `git commit --allow-empty` is required. This option overrides that behavior, allowing empty commits to be preserved automatically in a cherry-pick. Note that when \"--ff\" is in effect, empty commits that meet the \"fast-forward\" requirement will be kept even without this option.  Note also, that use of this option only keeps commits that were initially empty (i.e. the commit recorded the same tree as its parent).  Commits which are made empty due to a previous commit are dropped.  To force the inclusion of those commits use `--keep-redundant-commits`."
msgstr "默认情况下，对空提交的偷取会失败，表明需要明确调用 `git commit --allow-empty`。这个选项覆盖了这一行为，允许在偷取时自动保留空的提交。注意，当 \"--ff\" 生效时，即使没有这个选项，符合 “快速合并” 要求的空提交也会被保留。 还要注意的是，使用这个选项只保留最初为空的提交（即提交与它的父级记录在同一目录苏上）。 由于之前的提交而导致的空的提交会被放弃。 如果要强制包含这些提交，请使用 `--keep-redundant-commits`。"

#. type: Labeled list
#: en/git-cherry-pick.txt:137 en/git-commit.txt:226 en/git-rebase.txt:355
#, ignore-same, no-wrap, priority:280
msgid "--allow-empty-message"
msgstr "--allow-empty-message"

#. type: Plain text
#: en/git-cherry-pick.txt:141
#, priority:100
msgid "By default, cherry-picking a commit with an empty message will fail.  This option overrides that behavior, allowing commits with empty messages to be cherry picked."
msgstr "默认情况下，对空信息的提交进行拣选会失败。 这个选项覆盖了这一行为，允许对空信息的提交进行拣选。"

#. type: Labeled list
#: en/git-cherry-pick.txt:142
#, ignore-same, no-wrap, priority:100
msgid "--keep-redundant-commits"
msgstr "--keep-redundant-commits"

#. type: Plain text
#: en/git-cherry-pick.txt:148
#, priority:100
msgid "If a commit being cherry picked duplicates a commit already in the current history, it will become empty.  By default these redundant commits cause `cherry-pick` to stop so the user can examine the commit. This option overrides that behavior and creates an empty commit object.  Implies `--allow-empty`."
msgstr "如果被摘取的提交与当前历史中已有的提交重复，它将变成空的。 默认情况下，这些多余的提交会导致 `cherry-pick` 停止，以便用户能够检查提交。这个选项覆盖了这一行为，并创建一个空的提交对象。暗含 `--allow-empty`。"

#. type: Labeled list
#: en/git-cherry-pick.txt:149 en/git-notes.txt:209 en/git-rebase.txt:376 en/git-revert.txt:105 en/git-svn.txt:678 en/merge-options.txt:144
#, no-wrap, priority:280
msgid "--strategy=<strategy>"
msgstr "--strategy=<strategy>"

#. type: Plain text
#: en/git-cherry-pick.txt:153 en/git-revert.txt:109
#, priority:100
msgid "Use the given merge strategy.  Should only be used once.  See the MERGE STRATEGIES section in linkgit:git-merge[1] for details."
msgstr "使用给定的合并策略。 应该只使用一次。 详见 linkgit:git-merge[1] 中的合并策略部分。"

#. type: Labeled list
#: en/git-cherry-pick.txt:154 en/git-revert.txt:110
#, fuzzy, no-wrap, priority:100
msgid "-X<option>"
msgstr "-X<option>"

#. type: Labeled list
#: en/git-cherry-pick.txt:155 en/git-revert.txt:111 en/merge-options.txt:152
#, fuzzy, no-wrap, priority:240
msgid "--strategy-option=<option>"
msgstr "--strategy-option=<option>"

#. type: Plain text
#: en/git-cherry-pick.txt:158 en/git-revert.txt:114
#, priority:100
msgid "Pass the merge strategy-specific option through to the merge strategy.  See linkgit:git-merge[1] for details."
msgstr "将合并策略特有的选项传递给合并策略。 详见 linkgit:git-merge[1]。"

#. type: Title -
#: en/git-cherry-pick.txt:162 en/git-revert.txt:127
#, no-wrap, priority:100
msgid "SEQUENCER SUBCOMMANDS"
msgstr "序列器子命令"

#. type: Labeled list
#: en/git-cherry-pick.txt:167
#, fuzzy, no-wrap, priority:100
msgid "`git cherry-pick master`"
msgstr "`git cherry-pick master`"

#. type: Plain text
#: en/git-cherry-pick.txt:171
#, priority:100
msgid "Apply the change introduced by the commit at the tip of the master branch and create a new commit with this change."
msgstr "应用主分支顶端的提交所引入的修改，并以这个修改创建一个新的提交。"

#. type: Labeled list
#: en/git-cherry-pick.txt:172
#, no-wrap, priority:100
msgid "`git cherry-pick ..master`"
msgstr "`git cherry-pick ..master`"

#. type: Labeled list
#: en/git-cherry-pick.txt:173
#, fuzzy, no-wrap, priority:100
msgid "`git cherry-pick ^HEAD master`"
msgstr "`git cherry-pick ^HEAD master`"

#. type: Plain text
#: en/git-cherry-pick.txt:177
#, priority:100
msgid "Apply the changes introduced by all commits that are ancestors of master but not of HEAD to produce new commits."
msgstr "应用所有属于 master 但不属于 HEAD 的祖先的提交所带来的变化，产生新的提交。"

#. type: Labeled list
#: en/git-cherry-pick.txt:178
#, no-wrap, priority:100
msgid "`git cherry-pick maint next ^master`"
msgstr "`git cherry-pick maint next ^master`"

#. type: Labeled list
#: en/git-cherry-pick.txt:179
#, no-wrap, priority:100
msgid "`git cherry-pick maint master..next`"
msgstr "`git cherry-pick maint master..next`"

#. type: Plain text
#: en/git-cherry-pick.txt:186
#, priority:100
msgid "Apply the changes introduced by all commits that are ancestors of maint or next, but not master or any of its ancestors.  Note that the latter does not mean `maint` and everything between `master` and `next`; specifically, `maint` will not be used if it is included in `master`."
msgstr "应用所有属于 maint 或 next 的祖先的提交所带来的变化，但不包括 master 或其任何祖先。 注意，后者不是指 `maint` 和 `master` 与 `next` 之间的一切；具体来说，如果 `maint` 包含在 `master` 中，则不会被使用。"

#. type: Labeled list
#: en/git-cherry-pick.txt:187
#, fuzzy, no-wrap, priority:100
msgid "`git cherry-pick master~4 master~2`"
msgstr "`git cherry-pick master~4 master~2`"

#. type: Plain text
#: en/git-cherry-pick.txt:192
#, priority:100
msgid "Apply the changes introduced by the fifth and third last commits pointed to by master and create 2 new commits with these changes."
msgstr "应用 master 指向的第五次和最后第三次提交所带来的变化，并根据这些变化创建两个新的提交。"

#. type: Labeled list
#: en/git-cherry-pick.txt:193
#, fuzzy, no-wrap, priority:100
msgid "`git cherry-pick -n master~1 next`"
msgstr "`git cherry-pick -n master~1 next`"

#. type: Plain text
#: en/git-cherry-pick.txt:199
#, priority:100
msgid "Apply to the working tree and the index the changes introduced by the second last commit pointed to by master and by the last commit pointed to by next, but do not create any commit with these changes."
msgstr "在工作区和索引中应用 master 指向的倒数第二个提交和 next 指向的最后一个提交所带来的变化，但不要用这些变化创建任何提交。"

#. type: Labeled list
#: en/git-cherry-pick.txt:200
#, fuzzy, no-wrap, priority:100
msgid "`git cherry-pick --ff ..next`"
msgstr "`git cherry-pick --ff ..next`"

#. type: Plain text
#: en/git-cherry-pick.txt:207
#, priority:100
msgid "If history is linear and HEAD is an ancestor of next, update the working tree and advance the HEAD pointer to match next.  Otherwise, apply the changes introduced by those commits that are in next but not HEAD to the current branch, creating a new commit for each new change."
msgstr "如果历史是线性的，并且 HEAD 是 next 的祖先，则更新工作区并将 HEAD 指针向前推进以匹配 next。 否则，将那些在 next 但不在 HEAD 中的提交所带来的变化应用到当前分支，为每个新变化创建一个新的提交。"

#. type: Labeled list
#: en/git-cherry-pick.txt:208
#, fuzzy, no-wrap, priority:100
msgid "`git rev-list --reverse master -- README | git cherry-pick -n --stdin`"
msgstr "`git rev-list --reverse master -- README | git cherry-pick -n --stdin`"

#. type: Plain text
#: en/git-cherry-pick.txt:214
#, priority:100
msgid "Apply the changes introduced by all commits on the master branch that touched README to the working tree and index, so the result can be inspected and made into a single new commit if suitable."
msgstr "将主干分支上所有触及 README 的提交所带来的变化应用到工作区和索引中，这样就可以检查结果，并在合适的时候做成一个新的提交。"

#. type: Plain text
#: en/git-cherry-pick.txt:218
#, priority:100
msgid "The following sequence attempts to backport a patch, bails out because the code the patch applies to has changed too much, and then tries again, this time exercising more care about matching up context lines."
msgstr "下面的序列试图回传一个补丁，因为补丁所适用的代码变化太大，所以放弃了，然后再试一次，这次对上下文行的匹配更加谨慎。"

#. type: delimited block -
#: en/git-cherry-pick.txt:224
#, fuzzy, no-wrap, priority:100
msgid ""
"$ git cherry-pick topic^             <1>\n"
"$ git diff                           <2>\n"
"$ git cherry-pick --abort            <3>\n"
"$ git cherry-pick -Xpatience topic^  <4>\n"
msgstr ""
"$ git cherry-pick topic^             <1>\n"
"$ git diff                           <2>\n"
"$ git reset --merge ORIG_HEAD        <3>\n"
"$ git cherry-pick -Xpatience topic^  <4>\n"

#. type: Plain text
#: en/git-cherry-pick.txt:229
#, priority:100
msgid "apply the change that would be shown by `git show topic^`.  In this example, the patch does not apply cleanly, so information about the conflict is written to the index and working tree and no new commit results."
msgstr "应用将由 `git show topic^` 显示的变化。 在这个例子中，补丁没有干净地应用，所以冲突的信息被写入索引和工作树，没有新的提交结果。"

#. type: Plain text
#: en/git-cherry-pick.txt:230
#, priority:100
msgid "summarize changes to be reconciled"
msgstr "总结需要调节的变化"

#. type: Plain text
#: en/git-cherry-pick.txt:233
#, priority:100
msgid "cancel the cherry-pick.  In other words, return to the pre-cherry-pick state, preserving any local modifications you had in the working tree."
msgstr "取消 cherry-pick。 换句话说，返回到 cherry-pick 前的状态，保留你在工作区上的任何本地修改。"

#. type: Plain text
#: en/git-cherry-pick.txt:236
#, priority:100
msgid "try to apply the change introduced by `topic^` again, spending extra time to avoid mistakes based on incorrectly matching context lines."
msgstr "尝试再次应用由 `topic^` 引入的修改，花费额外的时间来避免基于不正确匹配的上下文行的错误。"

#. type: Title =
#: en/git-cherry.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-cherry(1)"
msgstr "git-cherry(1)"

#. type: Plain text
#: en/git-cherry.txt:7
#, priority:100
msgid "git-cherry - Find commits yet to be applied to upstream"
msgstr "git-cherry - 查找尚未应用于上游的提交内容"

#. type: Plain text
#: en/git-cherry.txt:12
#, fuzzy, no-wrap, priority:100
msgid "'git cherry' [-v] [<upstream> [<head> [<limit>]]]\n"
msgstr "'git cherry' [-v] [<upstream> [<head> [<limit>]]]\n"

#. type: Plain text
#: en/git-cherry.txt:17
#, priority:100
msgid "Determine whether there are commits in `<head>..<upstream>` that are equivalent to those in the range `<limit>..<head>`."
msgstr "确定 `<head>...<upstream>` 中是否有与 `<limit>...<head>` 范围内的提交相等。"

#. type: Plain text
#: en/git-cherry.txt:22
#, priority:100
msgid "The equivalence test is based on the diff, after removing whitespace and line numbers.  git-cherry therefore detects when commits have been \"copied\" by means of linkgit:git-cherry-pick[1], linkgit:git-am[1] or linkgit:git-rebase[1]."
msgstr "因此，git-cherry 通过 linkgit:git-cherry-pick[1]、linkgit:git-am[1] 或 linkgit:git-rebase[1] 来检测提交是否被 “复制” 了。"

#. type: Plain text
#: en/git-cherry.txt:26
#, priority:100
msgid "Outputs the SHA1 of every commit in `<limit>..<head>`, prefixed with `-` for commits that have an equivalent in <upstream>, and `+` for commits that do not."
msgstr "输出 `<limit>...<head>` 中每个提交的 SHA1，对于在 <upstream> 中有对应的提交，以 `-` 为前缀，对于没有对应的提交，以 `+` 为前缀。"

#. type: Plain text
#: en/git-cherry.txt:31
#, priority:100
msgid "Show the commit subjects next to the SHA1s."
msgstr "在 SHA1 旁边显示提交主题。"

#. type: Labeled list
#: en/git-cherry.txt:32 en/git-rebase.txt:277
#, fuzzy, no-wrap, priority:100
msgid "<upstream>"
msgstr "<upstream>"

#. type: Plain text
#: en/git-cherry.txt:35
#, priority:100
msgid "Upstream branch to search for equivalent commits.  Defaults to the upstream branch of HEAD."
msgstr "在 SHA1 旁边显示提交主题。"

#. type: Labeled list
#: en/git-cherry.txt:36 en/git.txt:434
#, fuzzy, no-wrap, priority:100
msgid "<head>"
msgstr "<head>"

#. type: Plain text
#: en/git-cherry.txt:38
#, priority:100
msgid "Working branch; defaults to HEAD."
msgstr "工作分支；默认为 HEAD。"

#. type: Plain text
#: en/git-cherry.txt:41
#, priority:100
msgid "Do not report commits up to (and including) limit."
msgstr "不报告达到（和包括）极限的提交。"

#. type: Title ~
#: en/git-cherry.txt:46
#, no-wrap, priority:100
msgid "Patch workflows"
msgstr "补丁工作流程"

#. type: Plain text
#: en/git-cherry.txt:52
#, priority:100
msgid "git-cherry is frequently used in patch-based workflows (see linkgit:gitworkflows[7]) to determine if a series of patches has been applied by the upstream maintainer.  In such a workflow you might create and send a topic branch like this:"
msgstr "git-cherry 常用于基于补丁的工作流程（见 linkgit:gitworkflows[7]），以确定一系列补丁是否已被上游维护者应用。 在这样的工作流程中，你可能会创建并发送一个类似这样的主题分支："

#. type: delimited block -
#: en/git-cherry.txt:58
#, fuzzy, ignore-ellipsis, no-wrap, priority:100
msgid ""
"$ git checkout -b topic origin/master\n"
"# work and create some commits\n"
"$ git format-patch origin/master\n"
"$ git send-email ... 00*\n"
msgstr ""
"$ git checkout -b topic origin/master\n"
"# work and create some commits\n"
"$ git format-patch origin/master\n"
"$ git send-email ... 00*\n"

#. type: Plain text
#: en/git-cherry.txt:62
#, priority:100
msgid "Later, you can see whether your changes have been applied by saying (still on `topic`):"
msgstr "后来，你可以通过说（仍然是在 `topic`上）看到你的修改是否被应用："

#. type: delimited block -
#: en/git-cherry.txt:66
#, fuzzy, no-wrap, priority:100
msgid ""
"$ git fetch  # update your notion of origin/master\n"
"$ git cherry -v\n"
msgstr ""
"$ git fetch  # update your notion of origin/master\n"
"$ git cherry -v\n"

#. type: Title ~
#: en/git-cherry.txt:69
#, fuzzy, no-wrap, priority:100
msgid "Concrete example"
msgstr "Concrete example"

#. type: Plain text
#: en/git-cherry.txt:73
#, priority:100
msgid "In a situation where topic consisted of three commits, and the maintainer applied two of them, the situation might look like:"
msgstr "如果话题由三个提交组成，而维护者应用了其中的两个提交，情况可能是这样的："

#. type: delimited block -
#: en/git-cherry.txt:86
#, ignore-ellipsis, no-wrap, priority:100
msgid ""
"$ git log --graph --oneline --decorate --boundary origin/master...topic\n"
"* 7654321 (origin/master) upstream tip commit\n"
"[... snip some other commits ...]\n"
"* cccc111 cherry-pick of C\n"
"* aaaa111 cherry-pick of A\n"
"[... snip a lot more that has happened ...]\n"
"| * cccc000 (topic) commit C\n"
"| * bbbb000 commit B\n"
"| * aaaa000 commit A\n"
"|/\n"
"o 1234567 branch point\n"
msgstr ""
"$ git log --graph --oneline --decorate --boundary origin/master...topic\n"
"* 7654321 (origin/master) upstream tip commit\n"
"[... snip some other commits ...]\n"
"* cccc111 cherry-pick of C\n"
"* aaaa111 cherry-pick of A\n"
"[... snip a lot more that has happened ...]\n"
"| * cccc000 (topic) commit C\n"
"| * bbbb000 commit B\n"
"| * aaaa000 commit A\n"
"|/\n"
"o 1234567 branch point\n"

#. type: Plain text
#: en/git-cherry.txt:90
#, priority:100
msgid "In such cases, git-cherry shows a concise summary of what has yet to be applied:"
msgstr "在这种情况下，git-cherry 会显示一个简明的摘要，说明还有哪些地方需要应用："

#. type: delimited block -
#: en/git-cherry.txt:96
#, fuzzy, ignore-ellipsis, no-wrap, priority:100
msgid ""
"$ git cherry origin/master topic\n"
"- cccc000... commit C\n"
"+ bbbb000... commit B\n"
"- aaaa000... commit A\n"
msgstr ""
"$ git cherry origin/master topic\n"
"- cccc000... commit C\n"
"+ bbbb000... commit B\n"
"- aaaa000... commit A\n"

#. type: Plain text
#: en/git-cherry.txt:102
#, priority:100
msgid "Here, we see that the commits A and C (marked with `-`) can be dropped from your `topic` branch when you rebase it on top of `origin/master`, while the commit B (marked with `+`) still needs to be kept so that it will be sent to be applied to `origin/master`."
msgstr "在这里，我们看到，当你在 `origin/master` 之上重新建立分支时，可以从 `topic` 分支中删除 A 和 C（标有 `-`），而 B（标有 `+`）仍然需要保留，这样它就会被发送到 `origin/master `上应用。"

#. type: Title ~
#: en/git-cherry.txt:105
#, no-wrap, priority:100
msgid "Using a limit"
msgstr "使用一个限制"

#. type: Plain text
#: en/git-cherry.txt:110
#, priority:100
msgid "The optional <limit> is useful in cases where your topic is based on other work that is not in upstream.  Expanding on the previous example, this might look like:"
msgstr "可选的 <限制> 在你的主题是基于其他不在上游的工作的情况下很有用。 在前面的例子基础上扩展，这可能看起来像："

#. type: delimited block -
#: en/git-cherry.txt:126
#, ignore-ellipsis, no-wrap, priority:100
msgid ""
"$ git log --graph --oneline --decorate --boundary origin/master...topic\n"
"* 7654321 (origin/master) upstream tip commit\n"
"[... snip some other commits ...]\n"
"* cccc111 cherry-pick of C\n"
"* aaaa111 cherry-pick of A\n"
"[... snip a lot more that has happened ...]\n"
"| * cccc000 (topic) commit C\n"
"| * bbbb000 commit B\n"
"| * aaaa000 commit A\n"
"| * 0000fff (base) unpublished stuff F\n"
"[... snip ...]\n"
"| * 0000aaa unpublished stuff A\n"
"|/\n"
"o 1234567 merge-base between upstream and topic\n"
msgstr ""
"$ git log --graph --oneline --decorate --boundary origin/master...topic\n"
"* 7654321 (origin/master) upstream tip commit\n"
"[... snip some other commits ...]\n"
"* cccc111 cherry-pick of C\n"
"* aaaa111 cherry-pick of A\n"
"[... snip a lot more that has happened ...]\n"
"| * cccc000 (topic) commit C\n"
"| * bbbb000 commit B\n"
"| * aaaa000 commit A\n"
"| * 0000fff (base) unpublished stuff F\n"
"[... snip ...]\n"
"| * 0000aaa unpublished stuff A\n"
"|/\n"
"o 1234567 merge-base between upstream and topic\n"

#. type: Plain text
#: en/git-cherry.txt:130
#, priority:100
msgid "By specifying `base` as the limit, you can avoid listing commits between `base` and `topic`:"
msgstr "通过指定 `base` 作为限制，你可以避免列出 `base` 和 `topic` 之间的提交："

#. type: delimited block -
#: en/git-cherry.txt:136
#, fuzzy, ignore-ellipsis, no-wrap, priority:100
msgid ""
"$ git cherry origin/master topic base\n"
"- cccc000... commit C\n"
"+ bbbb000... commit B\n"
"- aaaa000... commit A\n"
msgstr ""
"$ git cherry origin/master topic base\n"
"- cccc000... commit C\n"
"+ bbbb000... commit B\n"
"- aaaa000... commit A\n"

#. type: Title =
#: en/git-citool.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-citool(1)"
msgstr "git-citool(1)"

#. type: Plain text
#: en/git-citool.txt:7
#, priority:100
msgid "git-citool - Graphical alternative to git-commit"
msgstr "git-citool —— 替代 git-commit 的图形化工具"

#. type: Plain text
#: en/git-citool.txt:12
#, fuzzy, no-wrap, priority:100
msgid "'git citool'\n"
msgstr "'git citool'\n"

#. type: Plain text
#: en/git-citool.txt:19
#, priority:100
msgid "A Tcl/Tk based graphical interface to review modified files, stage them into the index, enter a commit message and record the new commit onto the current branch.  This interface is an alternative to the less interactive 'git commit' program."
msgstr "一个基于 Tcl/Tk 的图形界面，用于查看修改过的文件，将其放入索引，输入提交信息，并将新的提交记录到当前分支。 这个界面是对互动性较差的 'git commit' 程序的一种替代。"

#. type: Plain text
#: en/git-citool.txt:22
#, fuzzy, priority:100
msgid "'git citool' is actually a standard alias for `git gui citool`.  See linkgit:git-gui[1] for more details."
msgstr "'git citool' is actually a standard alias for `git gui citool`.  See linkgit:git-gui[1] for more details."

#. type: Title =
#: en/git-clean.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-clean(1)"
msgstr "git-clean(1)"

#. type: Plain text
#: en/git-clean.txt:7
#, fuzzy, priority:100
msgid "git-clean - Remove untracked files from the working tree"
msgstr "git-clean - Remove untracked files from the working tree"

#. type: Plain text
#: en/git-clean.txt:12
#, fuzzy, ignore-ellipsis, no-wrap, priority:100
msgid "'git clean' [-d] [-f] [-i] [-n] [-q] [-e <pattern>] [-x | -X] [--] [<pathspec>...]\n"
msgstr "'git clean' [-d] [-f] [-i] [-n] [-q] [-e <pattern>] [-x | -X] [--] <path>...\n"

#. type: Plain text
#: en/git-clean.txt:18
#, priority:100
msgid "Cleans the working tree by recursively removing files that are not under version control, starting from the current directory."
msgstr "从当前目录开始，通过递归删除不在版本控制之下的文件来清理工作区。"

#. type: Plain text
#: en/git-clean.txt:22
#, priority:100
msgid "Normally, only files unknown to Git are removed, but if the `-x` option is specified, ignored files are also removed. This can, for example, be useful to remove all build products."
msgstr "通常情况下，只有 Git 未知的文件会被删除，但如果指定了 `-x` 选项，被忽略的文件也会被删除。例如，这对删除所有构建产品很有用。"

#. type: Plain text
#: en/git-clean.txt:25
#, ignore-ellipsis, priority:100
msgid "If any optional `<pathspec>...` arguments are given, only those paths that match the pathspec are affected."
msgstr "如果给出任何可选的`<路径规范>...`参数，只有那些与路径规范相匹配的路径会受到影响。"

#. type: Plain text
#: en/git-clean.txt:35
#, priority:100
msgid "Normally, when no <pathspec> is specified, git clean will not recurse into untracked directories to avoid removing too much.  Specify -d to have it recurse into such directories as well.  If a <pathspec> is specified, -d is irrelevant; all untracked files matching the specified paths (with exceptions for nested git directories mentioned under `--force`) will be removed."
msgstr "通常，当没有指定 <路径规范> 时，git clean 不会递归到未追踪的目录，以避免删除太多。 指定 -d 可以让它也递归到这些目录。 如果指定了<路径规范>，-d 就不重要了；所有符合指定路径的未追踪文件（`--force` 下提到的嵌套的 git 目录除外）将被删除。"

#. type: Plain text
#: en/git-clean.txt:43
#, priority:100
msgid "If the Git configuration variable clean.requireForce is not set to false, 'git clean' will refuse to delete files or directories unless given -f or -i.  Git will refuse to modify untracked nested git repositories (directories with a .git subdirectory)  unless a second -f is given."
msgstr "如果 Git 配置变量 clean.requireForce 没有设置为 false，'git clean' 将拒绝删除文件或目录，除非给出 -f 或 -i。 除非给出第二个 -f，否则 Git 将拒绝修改未跟踪的嵌套 git 仓库（有.git子目录的目录）。"

#. type: Plain text
#: en/git-clean.txt:48
#, priority:100
msgid "Show what would be done and clean files interactively. See ``Interactive mode'' for details."
msgstr "显示会做什么，并以交互方式清理文件。详见 “交互模式”。"

#. type: Plain text
#: en/git-clean.txt:52
#, priority:100
msgid "Don't actually remove anything, just show what would be done."
msgstr "实际上不要删除任何东西，只是显示会做什么。"

#. type: Plain text
#: en/git-clean.txt:57
#, priority:100
msgid "Be quiet, only report errors, but not the files that are successfully removed."
msgstr "要安静，只报告错误，但不报告成功删除的文件。"

#. type: Labeled list
#: en/git-clean.txt:58
#, fuzzy, no-wrap, priority:100
msgid "-e <pattern>"
msgstr "-e <pattern>"

#. type: Labeled list
#: en/git-clean.txt:59 en/git-for-each-ref.txt:106 en/git-ls-files.txt:111 en/git-name-rev.txt:33
#, fuzzy, no-wrap, priority:100
msgid "--exclude=<pattern>"
msgstr "--exclude=<pattern>"

#. type: Plain text
#: en/git-clean.txt:62
#, priority:100
msgid "Use the given exclude pattern in addition to the standard ignore rules (see linkgit:gitignore[5])."
msgstr "在标准的忽略规则之外，使用给定的排除模式（见 linkgit:gitignore[5]）。"

#. type: Plain text
#: en/git-clean.txt:70
#, priority:100
msgid "Don't use the standard ignore rules (see linkgit:gitignore[5]), but still use the ignore rules given with `-e` options from the command line.  This allows removing all untracked files, including build products.  This can be used (possibly in conjunction with 'git restore' or 'git reset') to create a pristine working directory to test a clean build."
msgstr "不要使用标准的忽略规则（见linkgit:gitignore[5]），但仍然使用命令行中用 `-e` 选项给出的忽略规则。 这允许删除所有未跟踪的文件，包括构建产品。 这可以用来（可能与 'git restore' 或 'git reset' 一起使用）创建一个原始的工作目录来测试一个干净的构建。"

#. type: Labeled list
#: en/git-clean.txt:71
#, fuzzy, no-wrap, priority:100
msgid "-X"
msgstr "-X"

#. type: Plain text
#: en/git-clean.txt:74
#, priority:100
msgid "Remove only files ignored by Git.  This may be useful to rebuild everything from scratch, but keep manually created files."
msgstr "只删除被 Git 忽略的文件。 这对于从头开始重建一切，但保留手动创建的文件可能很有用。"

#. type: Title -
#: en/git-clean.txt:76
#, no-wrap, priority:100
msgid "Interactive mode"
msgstr "交互模式"

#. type: Plain text
#: en/git-clean.txt:80
#, priority:100
msgid "When the command enters the interactive mode, it shows the files and directories to be cleaned, and goes into its interactive command loop."
msgstr "当命令进入交互式模式时，它会显示要清理的文件和目录，并进入其交互式命令循环。"

#. type: delimited block -
#: en/git-clean.txt:91
#, no-wrap, priority:100
msgid ""
"    *** Commands ***\n"
"\t1: clean                2: filter by pattern    3: select by numbers\n"
"\t4: ask each             5: quit                 6: help\n"
"    What now> 1\n"
msgstr ""
"    *** Commands ***\n"
"\t1: clean                2: filter by pattern    3: select by numbers\n"
"\t4: ask each             5: quit                 6: help\n"
"    What now> 1\n"

#. type: Plain text
#: en/git-clean.txt:94
#, priority:100
msgid "You also could say `c` or `clean` above as long as the choice is unique."
msgstr "你也可以在上面输入 `c` 或 `clean`，只要选择是唯一的。"

#. type: Plain text
#: en/git-clean.txt:96
#, priority:100
msgid "The main command loop has 6 subcommands."
msgstr "主命令循环有 6 个子命令。"

#. type: Labeled list
#: en/git-clean.txt:97
#, fuzzy, no-wrap, priority:100
msgid "clean"
msgstr "清理"

#. type: Plain text
#: en/git-clean.txt:100
#, priority:100
msgid "Start cleaning files and directories, and then quit."
msgstr "开始清理文件和目录，然后退出。"

#. type: Labeled list
#: en/git-clean.txt:101
#, no-wrap, priority:100
msgid "filter by pattern"
msgstr "按模式过滤"

#. type: Plain text
#: en/git-clean.txt:109
#, priority:100
msgid "This shows the files and directories to be deleted and issues an \"Input ignore patterns>>\" prompt. You can input space-separated patterns to exclude files and directories from deletion.  E.g. \"*.c *.h\" will excludes files end with \".c\" and \".h\" from deletion. When you are satisfied with the filtered result, press ENTER (empty) back to the main menu."
msgstr "这将显示要删除的文件和目录，并发出 \"Input ignore patterns>>（输入忽略模式）\" 提示。你可以输入以空格分隔的模式来排除文件和目录的删除。 例如，\"*.c *.h \" 将排除以 \".c \" 和 \".h\" 结尾的文件不被删除。当你对过滤后的结果满意时，按回车（空）键回到主菜单。"

#. type: Labeled list
#: en/git-clean.txt:110
#, no-wrap, priority:100
msgid "select by numbers"
msgstr "按数字选择"

#. type: Plain text
#: en/git-clean.txt:121
#, priority:100
msgid "This shows the files and directories to be deleted and issues an \"Select items to delete>>\" prompt. When the prompt ends with double '>>' like this, you can make more than one selection, concatenated with whitespace or comma.  Also you can say ranges.  E.g. \"2-5 7,9\" to choose 2,3,4,5,7,9 from the list.  If the second number in a range is omitted, all remaining items are selected.  E.g. \"7-\" to choose 7,8,9 from the list.  You can say '*' to choose everything.  Also when you are satisfied with the filtered result, press ENTER (empty) back to the main menu."
msgstr "这显示了要删除的文件和目录，并发出 \"Select items to delete>>（选择要删除的项目）\"提示。当提示像这样以双 '>>' 结束时，你可以做一个以上的选择，用空格或逗号连接起来。 你也可以说范围。 例如，\"2-5 7,9\" 可以从列表中选择 2,3,4,5,7,9。 如果一个范围内的第二个数字被省略了，所有剩下的项目都会被选中。 例如：\"7-\" 从列表中选择 7、8、9。 你可以输入 '*' 来选择所有项目。 另外，当你对过滤后的结果满意时，按回车（空）键回到主菜单。"

#. type: Labeled list
#: en/git-clean.txt:122
#, no-wrap, priority:100
msgid "ask each"
msgstr "逐一询问"

#. type: Plain text
#: en/git-clean.txt:127
#, priority:100
msgid "This will start to clean, and you must confirm one by one in order to delete items. Please note that this action is not as efficient as the above two actions."
msgstr "这将开始进行清理，你必须逐一确认，以便删除项目。请注意，这个动作没有上述两个动作那么有效。"

#. type: Labeled list
#: en/git-clean.txt:128
#, fuzzy, no-wrap, priority:100
msgid "quit"
msgstr "&退出"

#. type: Plain text
#: en/git-clean.txt:131
#, priority:100
msgid "This lets you quit without do cleaning."
msgstr "这让你不用做清理就可以退出。"

#. type: Labeled list
#: en/git-clean.txt:132
#, fuzzy, no-wrap, priority:100
msgid "help"
msgstr "帮助"

#. type: Plain text
#: en/git-clean.txt:135
#, priority:100
msgid "Show brief usage of interactive git-clean."
msgstr "显示交互式 git-clean 的简要用法。"

#. type: Plain text
#: en/git-clean.txt:146 en/git-status.txt:523
#, ignore-same, priority:280
msgid "linkgit:gitignore[5]"
msgstr "linkgit:gitignore[5]"

#. type: Title =
#: en/git-clone.txt:2
#, ignore-same, no-wrap, priority:300
msgid "git-clone(1)"
msgstr "git-clone(1)"

#. type: Plain text
#: en/git-clone.txt:7
#, priority:300
msgid "git-clone - Clone a repository into a new directory"
msgstr "git-clone - 克隆一个仓库到新目录"

#. type: Plain text
#: en/git-clone.txt:21
#, fuzzy, no-wrap, priority:300
#| msgid ""
#| "'git clone' [--template=<template_directory>]\n"
#| "\t  [-l] [-s] [--no-hardlinks] [-q] [-n] [--bare] [--mirror]\n"
#| "\t  [-o <name>] [-b <name>] [-u <upload-pack>] [--reference <repository>]\n"
#| "\t  [--dissociate] [--separate-git-dir <git dir>]\n"
#| "\t  [--depth <depth>] [--[no-]single-branch] [--no-tags]\n"
#| "\t  [--recurse-submodules[=<pathspec>]] [--[no-]shallow-submodules]\n"
#| "\t  [--[no-]remote-submodules] [--jobs <n>] [--sparse] [--] <repository>\n"
#| "\t  [<directory>]\n"
msgid ""
"'git clone' [--template=<template-directory>]\n"
"\t  [-l] [-s] [--no-hardlinks] [-q] [-n] [--bare] [--mirror]\n"
"\t  [-o <name>] [-b <name>] [-u <upload-pack>] [--reference <repository>]\n"
"\t  [--dissociate] [--separate-git-dir <git-dir>]\n"
"\t  [--depth <depth>] [--[no-]single-branch] [--no-tags]\n"
"\t  [--recurse-submodules[=<pathspec>]] [--[no-]shallow-submodules]\n"
"\t  [--[no-]remote-submodules] [--jobs <n>] [--sparse] [--[no-]reject-shallow]\n"
"\t  [--filter=<filter> [--also-filter-submodules]] [--] <repository>\n"
"\t  [<directory>]\n"
msgstr ""
"'git clone' [--template=<template_directory>]\n"
"\t  [-l] [-s] [--no-hardlinks] [-q] [-n] [--bare] [--mirror]\n"
"\t  [-o <name>] [-b <name>] [-u <upload-pack>] [--reference <repository>]\n"
"\t  [--dissociate] [--separate-git-dir <git dir>]\n"
"\t  [--depth <depth>] [--[no-]single-branch] [--no-tags]\n"
"\t  [--recurse-submodules[=<pathspec>]] [--[no-]shallow-submodules]\n"
"\t  [--[no-]remote-submodules] [--jobs <n>] [--sparse]\n"
"\t  [--filter=<filter>] [--] <repository>\n"
"\t  [<directory>]\n"

#. type: Plain text
#: en/git-clone.txt:30
#, fuzzy, priority:300
msgid "Clones a repository into a newly created directory, creates remote-tracking branches for each branch in the cloned repository (visible using `git branch --remotes`), and creates and checks out an initial branch that is forked from the cloned repository's currently active branch."
msgstr "将存储库克隆到新创建的目录中，为克隆存储库中的每个分支创建远程跟踪分支（使用`git branch --remotes`可见），并创建、签出从克隆存储库当前活动的分支派生的初始分支。"

#. type: Plain text
#: en/git-clone.txt:36
#, fuzzy, priority:300
msgid "After the clone, a plain `git fetch` without arguments will update all the remote-tracking branches, and a `git pull` without arguments will in addition merge the remote master branch into the current master branch, if any (this is untrue when \"--single-branch\" is given; see below)."
msgstr "克隆后，执行不带参数的`git fetch`命令将更新所有远程跟踪的分支，执行不带参数的`git pull`命令将另把远程master分支合并到当前master分支（如果存在）（如果附加“--single-branch”参数，则情况不同；请参阅下文）。"

#. type: Plain text
#: en/git-clone.txt:41
#, fuzzy, priority:300
msgid "This default configuration is achieved by creating references to the remote branch heads under `refs/remotes/origin` and by initializing `remote.origin.url` and `remote.origin.fetch` configuration variables."
msgstr "通过在 `refs / remotes / origin` 下创建对远程分支头的引用，并通过初始化 `remote.origin.url` 和 `remote.origin.fetch` 配置变量来创建此默认配置。"

#. type: Labeled list
#: en/git-clone.txt:46 en/git-config.txt:134 en/git-instaweb.txt:24 en/git-pack-objects.txt:182 en/git-svn.txt:245
#, ignore-same, no-wrap, priority:300
msgid "--local"
msgstr "--local"

#. type: Plain text
#: en/git-clone.txt:53
#, fuzzy, priority:300
msgid "When the repository to clone from is on a local machine, this flag bypasses the normal \"Git aware\" transport mechanism and clones the repository by making a copy of HEAD and everything under objects and refs directories.  The files under `.git/objects/` directory are hardlinked to save space when possible."
msgstr "当要从中进行克隆的存储库位于本地计算机上时，此标志会绕过常规的“Git感知”传输机制，并通过为 HEAD 以及对象和引用目录内的所有内容创建副本以克隆存储库。尽可能将 `.git / objects /` 目录下的文件进行硬链接以节省空间。"

#. type: Plain text
#: en/git-clone.txt:60
#, fuzzy, priority:300
msgid "If the repository is specified as a local path (e.g., `/path/to/repo`), this is the default, and --local is essentially a no-op.  If the repository is specified as a URL, then this flag is ignored (and we never use the local optimizations).  Specifying `--no-local` will override the default when `/path/to/repo` is given, using the regular Git transport instead."
msgstr "如果将存储库指定为本地路径（例如，`/path/to/repo`），--local 参数实质上是不起作用的。如果将存储库指定为 URL，则忽略此标志（不使用本地优化）。指定 `--no-local` 将在给定 `/path/to/repo` 时覆盖默认值，而使用常规 Git 传输方式。"

#. type: Plain text
#: en/git-clone.txt:65
#, priority:300
msgid "If the repository's `$GIT_DIR/objects` has symbolic links or is a symbolic link, the clone will fail. This is a security measure to prevent the unintentional copying of files by dereferencing the symbolic links."
msgstr "如果仓库的 `$GIT_DIR/objects` 有符号链接或者它就是符号链接，克隆将会失败。这是一项安全措施，以防止通过解读符号链接意外地复制文件。"

#. type: Plain text
#: en/git-clone.txt:69
#, no-wrap, priority:300
msgid ""
"*NOTE*: this operation can race with concurrent modification to the\n"
"source repository, similar to running `cp -r src dst` while modifying\n"
"`src`.\n"
msgstr "*注意*：该操作可能与并发的源仓库修改产生产竞争，类似于在运行 `cp -r src dst` 时同时修改 `src`。\n"

#. type: Labeled list
#: en/git-clone.txt:70
#, ignore-same, no-wrap, priority:300
msgid "--no-hardlinks"
msgstr "--no-hardlinks"

#. type: Plain text
#: en/git-clone.txt:75
#, priority:300
msgid "Force the cloning process from a repository on a local filesystem to copy the files under the `.git/objects` directory instead of using hardlinks. This may be desirable if you are trying to make a back-up of your repository."
msgstr "从本地文件系统上的存储库进行克隆时，强制复制 `.git / objects` 目录下的文件，而不使用硬链接。如果您要备份存储库，则可能需要这样做。"

#. type: Labeled list
#: en/git-clone.txt:77
#, ignore-same, no-wrap, priority:300
msgid "--shared"
msgstr "--shared"

#. type: Plain text
#: en/git-clone.txt:83
#, priority:300
msgid "When the repository to clone is on the local machine, instead of using hard links, automatically setup `.git/objects/info/alternates` to share the objects with the source repository.  The resulting repository starts out without any object of its own."
msgstr "当要克隆的存储库位于本地计算机上时，不使用硬链接，而是自动设置 `.git/objects/info/alternates` 与源存储库共享对象。生成的存储库开始时没有其自己的任何对象。"

#. type: Plain text
#: en/git-clone.txt:93
#, fuzzy, no-wrap, priority:300
msgid ""
"*NOTE*: this is a possibly dangerous operation; do *not* use\n"
"it unless you understand what it does. If you clone your\n"
"repository using this option and then delete branches (or use any\n"
"other Git command that makes any existing commit unreferenced) in the\n"
"source repository, some objects may become unreferenced (or dangling).\n"
"These objects may be removed by normal Git operations (such as `git commit`)\n"
"which automatically call `git maintenance run --auto`. (See\n"
"linkgit:git-maintenance[1].) If these objects are removed and were referenced\n"
"by the cloned repository, then the cloned repository will become corrupt.\n"
msgstr ""
"*注意*：这可能是危险的操作；*不要*使用除非您了解它的功能。\n"
"如果您克隆您的存储库时使用此选项，\n"
"然后在源存储库中删除分支\n"
"（或使用任何其他使现有提交解除引用的 Git 命令），\n"
"某些对象可能会变得未引用（或悬空）。\n"
"这些对象可能被常规的 Git 操作（例如 `git commit`）删除。\n"
"它会自动调用 `git maintenance run --auto`。（请参阅linkgit:git-maintenance[1]。）\n"
"如果这些对象已删除并被克隆的存储库引用，\n"
"那么克隆的存储库将损坏。\n"

#. type: Plain text
#: en/git-clone.txt:99
#, fuzzy, priority:300
msgid "Note that running `git repack` without the `--local` option in a repository cloned with `--shared` will copy objects from the source repository into a pack in the cloned repository, removing the disk space savings of `clone --shared`.  It is safe, however, to run `git gc`, which uses the `--local` option by default."
msgstr "请注意，在使用 `--shared` 选项克隆的存储库中运行不带 `--local` 选项的 `git repack` 命令会将源存储库中的对象复制到克隆存储库中的包中，从而消除使用 `clone --shared` 节省的磁盘空间。不过，运行 `git-gc` 是安全的，它默认使用 `--local` 选项。"

#. type: Plain text
#: en/git-clone.txt:103
#, fuzzy, priority:300
msgid "If you want to break the dependency of a repository cloned with `--shared` on its source repository, you can simply run `git repack -a` to copy all objects from the source repository into a pack in the cloned repository."
msgstr "如果要断开用 `--shared` 克隆的存储库对其源存储库的依赖关系，只需运行 `git repack -a` 即可将源存储库中的所有对象复制到克隆存储库中的一个包中。"

#. type: Labeled list
#: en/git-clone.txt:104
#, fuzzy, no-wrap, priority:300
msgid "--reference[-if-able] <repository>"
msgstr "--reference[-if-able] <repository>"

#. type: Plain text
#: en/git-clone.txt:114
#, fuzzy, priority:300
msgid "If the reference repository is on the local machine, automatically setup `.git/objects/info/alternates` to obtain objects from the reference repository.  Using an already existing repository as an alternate will require fewer objects to be copied from the repository being cloned, reducing network and local storage costs.  When using the `--reference-if-able`, a non existing directory is skipped with a warning instead of aborting the clone."
msgstr "如果参考存储库位于本地计算机上，则自动设置 `.git / objects / info / alternates` 以从参考存储库获取对象。使用现有的存储库作为备用存储库，则将需要从要克隆的存储库中复制较少的对象，从而降低了网络和本地存储成本。当使用 `--reference-if-able` 时，不存在的目录会被警告跳过，而不是中止克隆。"

#. type: Plain text
#: en/git-clone.txt:117
#, fuzzy, no-wrap, priority:300
msgid ""
"*NOTE*: see the NOTE for the `--shared` option, and also the\n"
"`--dissociate` option.\n"
msgstr ""
"*注意*：请参阅`--shared`选项的注释，以及\n"
"`--dissociate`选项。\n"

#. type: Labeled list
#: en/git-clone.txt:118 en/git-submodule.txt:414
#, ignore-same, no-wrap, priority:300
msgid "--dissociate"
msgstr "--dissociate"

#. type: Plain text
#: en/git-clone.txt:128
#, fuzzy, priority:300
msgid "Borrow the objects from reference repositories specified with the `--reference` options only to reduce network transfer, and stop borrowing from them after a clone is made by making necessary local copies of borrowed objects.  This option can also be used when cloning locally from a repository that already borrows objects from another repository--the new repository will borrow objects from the same repository, and this option can be used to stop the borrowing."
msgstr "从用 `--reference` 选项指定的参考存储库中借用对象仅是为了减少网络传输，并在克隆后通过制作借用对象的必要本地副本来停止从对象借用。当从已经从另一个存储库借用对象的存储库进行本地克隆时，也可以使用此选项：新存储库将从同一个存储库借用对象，并且该选项可用于停止借用。"

#. type: Plain text
#: en/git-clone.txt:133
#, fuzzy, priority:300
msgid "Operate quietly.  Progress is not reported to the standard error stream."
msgstr "静默操作。进度不会报告给标准错误流。"

#. type: Plain text
#: en/git-clone.txt:138
#, fuzzy, priority:300
msgid "Run verbosely. Does not affect the reporting of progress status to the standard error stream."
msgstr "冗余运行。不影响向标准错误流报告进度状态。"

#. type: Plain text
#: en/git-clone.txt:144
#, fuzzy, priority:300
msgid "Progress status is reported on the standard error stream by default when it is attached to a terminal, unless `--quiet` is specified. This flag forces progress status even if the standard error stream is not directed to a terminal."
msgstr "默认情况下，附加到终端时，会将进度状态报告给标准错误流，除非指定了 `--quiet` 选项。即使标准错误流未定向到终端，该标志也会强制显示进度状态。"

#. type: Plain text
#: en/git-clone.txt:156
#, fuzzy, priority:300
msgid "No checkout of HEAD is performed after the clone is complete."
msgstr "克隆完成后，不执行HEAD检出操作。"

#. type: Labeled list
#: en/git-clone.txt:157
#, ignore-same, no-wrap, priority:300
msgid "--[no-]reject-shallow"
msgstr "--[no-]reject-shallow"

#. type: Plain text
#: en/git-clone.txt:161
#, priority:300
msgid "Fail if the source repository is a shallow repository.  The 'clone.rejectShallow' configuration variable can be used to specify the default."
msgstr "如果源版本库是一个浅层版本库，则失败。  clone.rejectShallow \"配置变量可以用来指定默认值。"

#. type: Labeled list
#: en/git-clone.txt:162 en/git-init.txt:48 en/git-p4.txt:305 en/git.txt:171
#, ignore-same, no-wrap, priority:300
msgid "--bare"
msgstr "--bare"

#. type: Plain text
#: en/git-clone.txt:173
#, fuzzy, priority:300
msgid "Make a 'bare' Git repository.  That is, instead of creating `<directory>` and placing the administrative files in `<directory>/.git`, make the `<directory>` itself the `$GIT_DIR`. This obviously implies the `--no-checkout` because there is nowhere to check out the working tree.  Also the branch heads at the remote are copied directly to corresponding local branch heads, without mapping them to `refs/remotes/origin/`.  When this option is used, neither remote-tracking branches nor the related configuration variables are created."
msgstr "创建一个“纯”Git存储库。也就是说，不要创建 `<directory>` 并将管理文件放在 `<directory>/.git`，而是将 `<directory>` 本身设为`$GIT_DIR`。这显然暗含着 `--no-checkout` 选项，因为没有地方可以检出工作树。此外，远程的分支头直接复制到相应的本地分支头，而不将它们映射到 `refs/remotes/origin/`。使用此选项时，不会创建远程跟踪分支或相关配置变量。"

#. type: Plain text
#: en/git-clone.txt:179
#, fuzzy, priority:300
msgid "Employ a sparse-checkout, with only files in the toplevel directory initially being present.  The linkgit:git-sparse-checkout[1] command can be used to grow the working directory as needed."
msgstr "初始化稀疏检出文件，以便工作目录仅从存储库根目录中的文件开始。可以修改稀疏签出文件以根据需要扩展工作目录。"

#. type: Labeled list
#: en/git-clone.txt:180 en/git-pack-objects.txt:300 en/rev-list-options.txt:937
#, no-wrap, priority:300
msgid "--filter=<filter-spec>"
msgstr "--filter=<过滤器定义>"

#. type: Plain text
#: en/git-clone.txt:189
#, fuzzy, priority:300
msgid "Use the partial clone feature and request that the server sends a subset of reachable objects according to a given object filter.  When using `--filter`, the supplied `<filter-spec>` is used for the partial clone filter. For example, `--filter=blob:none` will filter out all blobs (file contents) until needed by Git. Also, `--filter=blob:limit=<size>` will filter out all blobs of size at least `<size>`. For more details on filter specifications, see the `--filter` option in linkgit:git-rev-list[1]."
msgstr "使用部分克隆功能，要求服务器根据给定的对象过滤器发送一个可到达的对象的子集。当使用 `--filter` 选项时，提供的 `<filter-spec>` 将被用于部分克隆过滤器。例如，`--filter=blob:none` 将过滤掉所有的数据对象（文件内容），直到 Git 需要相应的数据。另外，`--filter=blob:limit=<size>` 将过滤掉所有文件大小至少为 `<size>` 的数据对象。关于过滤器定义的更多细节，请参阅 linkgit:git-rev-list[1] 中的 `--filter` 选项。"

#. type: Labeled list
#: en/git-clone.txt:190
#, ignore-same, no-wrap, priority:300
msgid "--also-filter-submodules"
msgstr "--also-filter-submodules"

#. type: Plain text
#: en/git-clone.txt:194
#, priority:300
msgid "Also apply the partial clone filter to any submodules in the repository.  Requires `--filter` and `--recurse-submodules`. This can be turned on by default by setting the `clone.filterSubmodules` config option."
msgstr "同时对版本库中的任何子模块应用部分克隆过滤器。  需要`--fliter`和`--recurse-submodules`。这可以通过设置 `clone.filterSubmodules` 配置项来默认开启。"

#. type: Labeled list
#: en/git-clone.txt:195 en/git-push.txt:162
#, ignore-same, no-wrap, priority:300
msgid "--mirror"
msgstr "--mirror"

#. type: Plain text
#: en/git-clone.txt:202
#, priority:300
msgid "Set up a mirror of the source repository.  This implies `--bare`.  Compared to `--bare`, `--mirror` not only maps local branches of the source to local branches of the target, it maps all refs (including remote-tracking branches, notes etc.) and sets up a refspec configuration such that all these refs are overwritten by a `git remote update` in the target repository."
msgstr "建立源存储库的镜像。这默认包含 `--bare` 选项。与 `--bare` 相比，`--mirror` 不仅将源的本地分支映射到目标的本地分支，还映射所有引用（包括远程跟踪分支，注释等）并设置了引用规范，因而在目标存储库中执行 `git remote update` 时，所有这些引用都会被覆盖。"

#. type: Labeled list
#: en/git-clone.txt:203
#, no-wrap, priority:300
msgid "-o <name>"
msgstr "-o <名称>"

#. type: Labeled list
#: en/git-clone.txt:204
#, no-wrap, priority:300
msgid "--origin <name>"
msgstr "--origin <名称>"

#. type: Plain text
#: en/git-clone.txt:208
#, priority:300
msgid "Instead of using the remote name `origin` to keep track of the upstream repository, use `<name>`.  Overrides `clone.defaultRemoteName` from the config."
msgstr "不使用远程名称`origin`来跟踪远程仓库，而使用`<name>`值。  这会覆盖配置中`clone.defaultRemoteName`的设置。"

#. type: Labeled list
#: en/git-clone.txt:209
#, no-wrap, priority:300
msgid "-b <name>"
msgstr "-b <名称>"

#. type: Labeled list
#: en/git-clone.txt:210
#, fuzzy, no-wrap, priority:300
msgid "--branch <name>"
msgstr "--branch <name>"

#. type: Plain text
#: en/git-clone.txt:217
#, fuzzy, priority:300
msgid "Instead of pointing the newly created HEAD to the branch pointed to by the cloned repository's HEAD, point to `<name>` branch instead. In a non-bare repository, this is the branch that will be checked out.  `--branch` can also take tags and detaches the HEAD at that commit in the resulting repository."
msgstr "不将新创建的 HEAD 指向克隆存储库的 HEAD 所指向的分支，而是指向`<名称>`分支。在非裸仓库中，这是将被检出的分支。 `--branch` 也可以使用标签并在生成的存储库中的提交时分离 HEAD。"

#. type: Labeled list
#: en/git-clone.txt:218
#, fuzzy, no-wrap, priority:300
msgid "-u <upload-pack>"
msgstr "-u <上传包>"

#. type: Plain text
#: en/git-clone.txt:223
#, fuzzy, priority:300
msgid "When given, and the repository to clone from is accessed via ssh, this specifies a non-default path for the command run on the other end."
msgstr "如果指定了要克隆的存储库，且可以通过 ssh 访问该存储库，这将为另一端运行的命令指定非默认路径。"

#. type: Labeled list
#: en/git-clone.txt:224 en/git-init.txt:60 en/git-svn.txt:578
#, fuzzy, no-wrap, priority:300
msgid "--template=<template-directory>"
msgstr "--template = <模板目录>"

#. type: Plain text
#: en/git-clone.txt:227
#, fuzzy, priority:300
msgid "Specify the directory from which templates will be used; (See the \"TEMPLATE DIRECTORY\" section of linkgit:git-init[1].)"
msgstr "指定将使用模板的目录；（请参阅 linkgit:git-init[1] 的“模板目录”部分。）"

#. type: Labeled list
#: en/git-clone.txt:228
#, fuzzy, no-wrap, priority:300
msgid "-c <key>=<value>"
msgstr "-c <key>=<value>"

#. type: Labeled list
#: en/git-clone.txt:229
#, fuzzy, no-wrap, priority:300
msgid "--config <key>=<value>"
msgstr "--config <key>=<value>"

#. type: Plain text
#: en/git-clone.txt:238
#, fuzzy, priority:300
msgid "Set a configuration variable in the newly-created repository; this takes effect immediately after the repository is initialized, but before the remote history is fetched or any files checked out.  The key is in the same format as expected by linkgit:git-config[1] (e.g., `core.eol=true`). If multiple values are given for the same key, each value will be written to the config file. This makes it safe, for example, to add additional fetch refspecs to the origin remote."
msgstr "在新创建的存储库中设置配置变量；这将在初始化存储库之后、获取远程历史记录或签出任何文件之前立即生效。密钥的格式与 linkgit:git-config[1] 期望的格式相同（例如，`core.eol = true`）。如果为同一键指定了多个值，则每个值都将写入配置文件。例如，这可以安全地将其他抓取 refspec 添加到源远端。"

#. type: Plain text
#: en/git-clone.txt:244
#, fuzzy, priority:300
msgid "Due to limitations of the current implementation, some configuration variables do not take effect until after the initial fetch and checkout.  Configuration variables known to not take effect are: `remote.<name>.mirror` and `remote.<name>.tagOpt`.  Use the corresponding `--mirror` and `--no-tags` options instead."
msgstr "由于当前实现方式的限制，某些配置变量要等到初始获取和签出后才能生效。已知不会生效的配置变量有：`remote.<s名称> .mirror` 和`remote.<名称> .tagOpt`。如要修改，应改用相应的 `--mirror` 和 `--no-tags` 选项。"

#. type: Labeled list
#: en/git-clone.txt:245
#, fuzzy, no-wrap, priority:300
msgid "--depth <depth>"
msgstr "--depth <深度>"

#. type: Plain text
#: en/git-clone.txt:251
#, fuzzy, priority:300
msgid "Create a 'shallow' clone with a history truncated to the specified number of commits. Implies `--single-branch` unless `--no-single-branch` is given to fetch the histories near the tips of all branches. If you want to clone submodules shallowly, also pass `--shallow-submodules`."
msgstr "创建一个历史记录被截断为指定提交次数的“浅”克隆。暗含 `--single-branch` 选项，除非给出 `--no-single-branch` 来获取所有分支顶端附近的历史记录。如果要浅层克隆子模块，还可以使用 `--shallow-submodules` 选项。"

#. type: Plain text
#: en/git-clone.txt:254
#, fuzzy, priority:300
msgid "Create a shallow clone with a history after the specified time."
msgstr "创建浅克隆，只包含指定的时间之后的历史记录。"

#. type: Plain text
#: en/git-clone.txt:259
#, fuzzy, priority:300
msgid "Create a shallow clone with a history, excluding commits reachable from a specified remote branch or tag.  This option can be specified multiple times."
msgstr "创建一个有历史的浅克隆，不包含可以被指定远程分支或标签访问的提交。本选项可以使用多次。"

#. type: Labeled list
#: en/git-clone.txt:260 en/git-submodule.txt:444
#, ignore-same, no-wrap, priority:300
msgid "--[no-]single-branch"
msgstr "--[no-]single-branch"

#. type: Plain text
#: en/git-clone.txt:269
#, fuzzy, priority:300
msgid "Clone only the history leading to the tip of a single branch, either specified by the `--branch` option or the primary branch remote's `HEAD` points at.  Further fetches into the resulting repository will only update the remote-tracking branch for the branch this option was used for the initial cloning.  If the HEAD at the remote did not point at any branch when `--single-branch` clone was made, no remote-tracking branch is created."
msgstr "仅克隆直到单一分支末尾的历史，该分支被 `--branch` 选项或主分支远程 `HEAD` 指定。被创建仓库之后的抓取将只更新在克隆时被指定的远程跟踪分支。如果在 `--single-branch` 克隆时，远程 HEAD 未指向任何分支，则不会创建远程跟踪分支。"

#. type: Plain text
#: en/git-clone.txt:276
#, priority:300
msgid "Don't clone any tags, and set `remote.<remote>.tagOpt=--no-tags` in the config, ensuring that future `git pull` and `git fetch` operations won't follow any tags. Subsequent explicit tag fetches will still work, (see linkgit:git-fetch[1])."
msgstr "不克隆任何标签，并在配置中设置 `remote.<remote>.tagOpt=--no-tags` ，确保将来的`git pull`和`git fetch`操作不会跟随任何标签。随后的显式标签抓取仍将起作用（参阅 linkgit:git-fetch[1]）。"

#. type: Plain text
#: en/git-clone.txt:281
#, fuzzy, priority:300
msgid "Can be used in conjunction with `--single-branch` to clone and maintain a branch with no references other than a single cloned branch. This is useful e.g. to maintain minimal clones of the default branch of some repository for search indexing."
msgstr "可以与 `--single-branch` 结合使用，以克隆和维护除单个克隆分支外没有其他引用的分支。这在例如维护某些仓库的默认分支的最小克隆以进行搜索索引时有用。"

#. type: Labeled list
#: en/git-clone.txt:282
#, fuzzy, no-wrap, priority:300
#| msgid "--recurse-submodules[=<pathspec]"
msgid "--recurse-submodules[=<pathspec>]"
msgstr "--recurse-submodules[=<路径规范]"

#. type: Plain text
#: en/git-clone.txt:290
#, fuzzy, priority:300
msgid "After the clone is created, initialize and clone submodules within based on the provided pathspec.  If no pathspec is provided, all submodules are initialized and cloned.  This option can be given multiple times for pathspecs consisting of multiple entries.  The resulting clone has `submodule.active` set to the provided pathspec, or \".\" (meaning all submodules) if no pathspec is provided."
msgstr "创建克隆后，根据提供的路径规范初始化并克隆其中的子模块。如果未提供路径规范，则将初始化并克隆所有子模块。对于由多个条目组成的路径规范，可以多次赋予此选项。生成的克隆将把 `submodule.active` 设为提供的路径规范。如果未提供路径规范，生成的克隆将把 `submodule.active` 设为 \".\" （表示所有子模块）。"

#. type: Plain text
#: en/git-clone.txt:297
#, fuzzy, priority:300
msgid "Submodules are initialized and cloned using their default settings. This is equivalent to running `git submodule update --init --recursive <pathspec>` immediately after the clone is finished. This option is ignored if the cloned repository does not have a worktree/checkout (i.e. if any of `--no-checkout`/`-n`, `--bare`, or `--mirror` is given)"
msgstr "子模块使用其默认设置进行初始化和克隆。这等效于克隆完成后立即运行 `git submodule update --init --recursive <路径规范>`。如果克隆的仓库没有工作区/检出（即给出了 `--no-checkout`/`-n`，`--bare` 或 `--mirror`中的任何一个选项），则忽略此选项。"

#. type: Labeled list
#: en/git-clone.txt:298
#, ignore-same, no-wrap, priority:300
msgid "--[no-]shallow-submodules"
msgstr "--[no-]shallow-submodules"

#. type: Plain text
#: en/git-clone.txt:300
#, fuzzy, priority:300
msgid "All submodules which are cloned will be shallow with a depth of 1."
msgstr "所有克隆的子模块都将是浅克隆，深度为1。"

#. type: Labeled list
#: en/git-clone.txt:301
#, ignore-same, no-wrap, priority:300
msgid "--[no-]remote-submodules"
msgstr "--[no-]remote-submodules"

#. type: Plain text
#: en/git-clone.txt:306
#, fuzzy, priority:300
msgid "All submodules which are cloned will use the status of the submodule's remote-tracking branch to update the submodule, rather than the superproject's recorded SHA-1. Equivalent to passing `--remote` to `git submodule update`."
msgstr "克隆的所有子模块将使用子模块的远程跟踪分支的状态来更新子模块，而不是超级项目的已记录SHA-1。等同于将`--remote` 传递给 `git submodule update`。"

#. type: Labeled list
#: en/git-clone.txt:307 en/git-init.txt:65
#, fuzzy, no-wrap, priority:300
msgid "--separate-git-dir=<git-dir>"
msgstr "--separate-git-dir=<git目录>"

#. type: Plain text
#: en/git-clone.txt:313
#, fuzzy, priority:300
msgid "Instead of placing the cloned repository where it is supposed to be, place the cloned repository at the specified directory, then make a filesystem-agnostic Git symbolic link to there.  The result is Git repository can be separated from working tree."
msgstr "不将克隆的存储库放置在原处，而是将克隆的存储库放置在指定的目录中，然后在此处建立与文件系统无关的Git符号链接。这可以将Git仓库与工作区分离。"

#. type: Labeled list
#: en/git-clone.txt:314 en/git-submodule.txt:438
#, fuzzy, no-wrap, priority:300
msgid "-j <n>"
msgstr "-j <n>"

#. type: Labeled list
#: en/git-clone.txt:315 en/git-submodule.txt:439
#, fuzzy, no-wrap, priority:300
msgid "--jobs <n>"
msgstr "--jobs <n>"

#. type: Plain text
#: en/git-clone.txt:318
#, fuzzy, priority:300
msgid "The number of submodules fetched at the same time.  Defaults to the `submodule.fetchJobs` option."
msgstr "同时抓取的子模块数。默认为 `submodule.fetchJobs` 选项。"

#. type: Labeled list
#: en/git-clone.txt:319 en/git-fetch-pack.txt:118 en/git-ls-remote.txt:83 en/git-push.txt:50 en/git-upload-archive.txt:57 en/pull-fetch-param.txt:1
#, fuzzy, no-wrap, priority:300
msgid "<repository>"
msgstr "<repository>"

#. type: Plain text
#: en/git-clone.txt:323
#, fuzzy, priority:300
msgid "The (possibly remote) repository to clone from.  See the <<URLS,GIT URLS>> section below for more information on specifying repositories."
msgstr "要克隆的（可能是远程的）仓库。有关指定仓库的更多信息，参阅下面的 <<URLS,GIT URLS>> 部分。"

#. type: Labeled list
#: en/git-clone.txt:324 en/git-cvsserver.txt:65 en/git-daemon.txt:220 en/git-send-pack.txt:96 en/git-upload-pack.txt:47
#, fuzzy, no-wrap, priority:300
msgid "<directory>"
msgstr "<directory>"

#. type: Plain text
#: en/git-clone.txt:330
#, fuzzy, priority:300
msgid "The name of a new directory to clone into.  The \"humanish\" part of the source repository is used if no directory is explicitly given (`repo` for `/path/to/repo.git` and `foo` for `host.xz:foo/.git`).  Cloning into an existing directory is only allowed if the directory is empty."
msgstr "要克隆到的新目录的名称。如果未明确指定目录，则使用源仓库中的“人性化”部分（对于 `/path/to/repo.git` 而言，为 `repo`；对于 `host.xz:foo/.git` 而言，为 `foo`）。仅当目录为空时才允许克隆到现有目录。"

#. type: Labeled list
#: en/git-clone.txt:331
#, no-wrap, priority:300
msgid "--bundle-uri=<uri>"
msgstr "--bundle-uri=<uri>"

#. type: Plain text
#: en/git-clone.txt:337
#, priority:300
msgid "Before fetching from the remote, fetch a bundle from the given `<uri>` and unbundle the data into the local repository. The refs in the bundle will be stored under the hidden `refs/bundle/*` namespace. This option is incompatible with `--depth`, `--shallow-since`, and `--shallow-exclude`."
msgstr "在从远程获取之前，从给定的`<uri>`中获取一个捆绑包，并将数据解绑到本地资源库中。捆绑包中的引用将被存储在隐藏的 `refs/bundle/*` 命名空间下。该选项不与`--depth`、`--shallow--scince`、`--shallow--exclude`兼容。"

#. type: Plain text
#: en/git-clone.txt:345
#, fuzzy, priority:300
msgid "Clone from upstream:"
msgstr "从上游克隆："

#. type: delimited block -
#: en/git-clone.txt:350
#, fuzzy, ignore-ellipsis, no-wrap, priority:300
msgid ""
"$ git clone git://git.kernel.org/pub/scm/.../linux.git my-linux\n"
"$ cd my-linux\n"
"$ make\n"
msgstr ""
"$ git clone git://git.kernel.org/pub/scm/.../linux.git my-linux\n"
"$ cd my-linux\n"
"$ make\n"

#. type: Plain text
#: en/git-clone.txt:354
#, fuzzy, priority:300
msgid "Make a local clone that borrows from the current directory, without checking things out:"
msgstr "制作一个从当前目录借用的本地克隆，而无需进行检出："

#. type: delimited block -
#: en/git-clone.txt:359
#, fuzzy, no-wrap, priority:300
msgid ""
"$ git clone -l -s -n . ../copy\n"
"$ cd ../copy\n"
"$ git show-branch\n"
msgstr ""
"$ git clone -l -s -n . ../copy\n"
"$ cd ../copy\n"
"$ git show-branch\n"

#. type: Plain text
#: en/git-clone.txt:363
#, fuzzy, priority:300
msgid "Clone from upstream while borrowing from an existing local directory:"
msgstr "从上游克隆时借用本地目录："

#. type: delimited block -
#: en/git-clone.txt:369
#, fuzzy, ignore-ellipsis, no-wrap, priority:300
msgid ""
"$ git clone --reference /git/linux.git \\\n"
"\tgit://git.kernel.org/pub/scm/.../linux.git \\\n"
"\tmy-linux\n"
"$ cd my-linux\n"
msgstr ""
"$ git clone --reference /git/linux.git \\\n"
"\tgit://git.kernel.org/pub/scm/.../linux.git \\\n"
"\tmy-linux\n"
"$ cd my-linux\n"

#. type: Plain text
#: en/git-clone.txt:373
#, fuzzy, priority:300
msgid "Create a bare repository to publish your changes to the public:"
msgstr "创建一个裸仓库，以将您的更改发布给公众："

#. type: delimited block -
#: en/git-clone.txt:376
#, fuzzy, no-wrap, priority:300
msgid "$ git clone --bare -l /home/proj/.git /pub/scm/proj.git\n"
msgstr "$ git clone --bare -l /home/proj/.git /pub/scm/proj.git\n"

#. type: Title =
#: en/git-column.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-column(1)"
msgstr "git-column(1)"

#. type: Plain text
#: en/git-column.txt:7
#, priority:100
msgid "git-column - Display data in columns"
msgstr "git-column - 以列展示数据"

#. type: Plain text
#: en/git-column.txt:13
#, no-wrap, priority:100
msgid ""
"'git column' [--command=<name>] [--[raw-]mode=<mode>] [--width=<width>]\n"
"\t     [--indent=<string>] [--nl=<string>] [--padding=<n>]\n"
msgstr ""
"'git column' [--command=<名称>] [--[raw-]mode=<模式>] [--width=<宽度>]\n"
"\t     [--indent=<字符串>] [--nl=<字符串>] [--padding=<n>]\n"

#. type: Plain text
#: en/git-column.txt:20
#, priority:100
msgid "This command formats the lines of its standard input into a table with multiple columns. Each input line occupies one cell of the table. It is used internally by other git commands to format output into columns."
msgstr "该命令将其标准输入的行格式化为一个多列表格。每个输入行占据表格的一个单元。它被其他Git命令内部使用，以将输出信息格式化为列。"

#. type: Labeled list
#: en/git-column.txt:23
#, no-wrap, priority:100
msgid "--command=<name>"
msgstr "--command=<名称>"

#. type: Plain text
#: en/git-column.txt:26
#, priority:100
msgid "Look up layout mode using configuration variable column.<name> and column.ui."
msgstr "使用配置变量column.<名称>和column.ui查询布局模式。"

#. type: Labeled list
#: en/git-column.txt:27
#, no-wrap, priority:100
msgid "--mode=<mode>"
msgstr "--mode=<模式>"

#. type: Plain text
#: en/git-column.txt:30
#, priority:100
msgid "Specify layout mode. See configuration variable column.ui for option syntax in linkgit:git-config[1]."
msgstr "指定布局模式。选项的语法见 linkgit:git-config[1] 中column.ui变量的配置。"

#. type: Labeled list
#: en/git-column.txt:31
#, fuzzy, no-wrap, priority:100
msgid "--raw-mode=<n>"
msgstr "--raw-mode=<n>"

#. type: Plain text
#: en/git-column.txt:34
#, priority:100
msgid "Same as --mode but take mode encoded as a number. This is mainly used by other commands that have already parsed layout mode."
msgstr "与--模式选项相同，但该选项将模式编码为一个数字。这主要是被其他已经解析了布局模式的命令使用。"

#. type: Labeled list
#: en/git-column.txt:35
#, no-wrap, priority:100
msgid "--width=<width>"
msgstr "--width=<宽度>"

#. type: Plain text
#: en/git-column.txt:38
#, priority:100
msgid "Specify the terminal width. By default 'git column' will detect the terminal width, or fall back to 80 if it is unable to do so."
msgstr "指定终端的宽度。默认情况下，'git column'会检测终端宽度，如果无法检测，则会将其宽度设置为80。"

#. type: Labeled list
#: en/git-column.txt:39
#, no-wrap, priority:100
msgid "--indent=<string>"
msgstr "--indent=<字符串>"

#. type: Plain text
#: en/git-column.txt:41
#, priority:100
msgid "String to be printed at the beginning of each line."
msgstr "设置要在每一行的开头打印的字符串。"

#. type: Labeled list
#: en/git-column.txt:42
#, no-wrap, priority:100
msgid "--nl=<string>"
msgstr "--indent=<字符串>"

#. type: Plain text
#: en/git-column.txt:45
#, priority:100
msgid "String to be printed at the end of each line, including newline character."
msgstr "在每一行的末尾要打印的字符串，包括换行符。"

#. type: Labeled list
#: en/git-column.txt:46
#, fuzzy, no-wrap, priority:100
msgid "--padding=<N>"
msgstr "--padding=<N>"

#. type: Plain text
#: en/git-column.txt:48
#, priority:100
msgid "The number of spaces between columns. One space by default."
msgstr "列之间的空格数，默认为一个空格。"

#. type: Plain text
#: en/git-column.txt:53
#, priority:100
msgid "Format data by columns:"
msgstr "按列格式化数据："

#. type: delimited block -
#: en/git-column.txt:58
#, fuzzy, no-wrap, priority:100
msgid ""
"$ seq 1 24 | git column --mode=column --padding=5\n"
"1      4      7      10     13     16     19     22\n"
"2      5      8      11     14     17     20     23\n"
"3      6      9      12     15     18     21     24\n"
msgstr ""
"$ seq 1 24 | git column --mode=column --padding=5\n"
"1      4      7      10     13     16     19     22\n"
"2      5      8      11     14     17     20     23\n"
"3      6      9      12     15     18     21     24\n"

#. type: Plain text
#: en/git-column.txt:61
#, priority:100
msgid "Format data by rows:"
msgstr "按行格式化数据："

#. type: delimited block -
#: en/git-column.txt:66
#, fuzzy, no-wrap, priority:100
msgid ""
"$ seq 1 21 | git column --mode=row --padding=5\n"
"1      2      3      4      5      6      7\n"
"8      9      10     11     12     13     14\n"
"15     16     17     18     19     20     21\n"
msgstr ""
"$ seq 1 21 | git column --mode=row --padding=5\n"
"1      2      3      4      5      6      7\n"
"8      9      10     11     12     13     14\n"
"15     16     17     18     19     20     21\n"

#. type: Plain text
#: en/git-column.txt:69
#, priority:100
msgid "List some tags in a table with unequal column widths:"
msgstr "在一个列宽不等的表格中列出一些标签："

#. type: delimited block -
#: en/git-column.txt:75
#, fuzzy, no-wrap, priority:100
msgid ""
"$ git tag --list 'v2.4.*' --column=row,dense\n"
"v2.4.0  v2.4.0-rc0  v2.4.0-rc1  v2.4.0-rc2  v2.4.0-rc3\n"
"v2.4.1  v2.4.10     v2.4.11     v2.4.12     v2.4.2\n"
"v2.4.3  v2.4.4      v2.4.5      v2.4.6      v2.4.7\n"
"v2.4.8  v2.4.9\n"
msgstr ""
"$ git tag --list 'v2.4.*' --column=row,dense\n"
"v2.4.0  v2.4.0-rc0  v2.4.0-rc1  v2.4.0-rc2  v2.4.0-rc3\n"
"v2.4.1  v2.4.10     v2.4.11     v2.4.12     v2.4.2\n"
"v2.4.3  v2.4.4      v2.4.5      v2.4.6      v2.4.7\n"
"v2.4.8  v2.4.9\n"

#. type: Title =
#: en/git-commit-tree.txt:2
#, ignore-same, no-wrap, priority:80
msgid "git-commit-tree(1)"
msgstr "git-commit-tree(1)"

#. type: Plain text
#: en/git-commit-tree.txt:7
#, fuzzy, priority:80
msgid "git-commit-tree - Create a new commit object"
msgstr "git-commit-tree - Create a new commit object"

#. type: Plain text
#: en/git-commit-tree.txt:15
#, ignore-ellipsis, no-wrap, priority:80
msgid ""
"'git commit-tree' <tree> [(-p <parent>)...]\n"
"'git commit-tree' [(-p <parent>)...] [-S[<keyid>]] [(-m <message>)...]\n"
"\t\t  [(-F <file>)...] <tree>\n"
msgstr ""

#. type: Plain text
#: en/git-commit-tree.txt:21
#, priority:80
msgid "This is usually not what an end user wants to run directly.  See linkgit:git-commit[1] instead."
msgstr ""

#. type: Plain text
#: en/git-commit-tree.txt:25
#, priority:80
msgid "Creates a new commit object based on the provided tree object and emits the new commit object id on stdout. The log message is read from the standard input, unless `-m` or `-F` options are given."
msgstr ""

#. type: Plain text
#: en/git-commit-tree.txt:29
#, priority:80
msgid "The `-m` and `-F` options can be given any number of times, in any order. The commit log message will be composed in the order in which the options are given."
msgstr ""

#. type: Plain text
#: en/git-commit-tree.txt:34
#, priority:80
msgid "A commit object may have any number of parents. With exactly one parent, it is an ordinary commit. Having more than one parent makes the commit a merge between several lines of history. Initial (root)  commits have no parents."
msgstr ""

#. type: Plain text
#: en/git-commit-tree.txt:38
#, priority:80
msgid "While a tree represents a particular directory state of a working directory, a commit represents that state in \"time\", and explains how to get there."
msgstr ""

#. type: Plain text
#: en/git-commit-tree.txt:44
#, priority:80
msgid "Normally a commit would identify a new \"HEAD\" state, and while Git doesn't care where you save the note about that state, in practice we tend to just write the result to the file that is pointed at by `.git/HEAD`, so that we can always see what the last committed state was."
msgstr ""

#. type: Labeled list
#: en/git-commit-tree.txt:47 en/git.txt:396
#, fuzzy, no-wrap, priority:100
msgid "<tree>"
msgstr "<tree>"

#. type: Plain text
#: en/git-commit-tree.txt:49
#, priority:80
msgid "An existing tree object."
msgstr ""

#. type: Labeled list
#: en/git-commit-tree.txt:50
#, fuzzy, no-wrap, priority:80
msgid "-p <parent>"
msgstr "-p <parent>"

#. type: Plain text
#: en/git-commit-tree.txt:52
#, priority:80
msgid "Each `-p` indicates the id of a parent commit object."
msgstr ""

#. type: Labeled list
#: en/git-commit-tree.txt:53 en/git-fmt-merge-msg.txt:42
#, no-wrap, priority:100
msgid "-m <message>"
msgstr "-m <信息>"

#. type: Plain text
#: en/git-commit-tree.txt:56
#, priority:80
msgid "A paragraph in the commit log message. This can be given more than once and each <message> becomes its own paragraph."
msgstr ""

#. type: Labeled list
#: en/git-commit-tree.txt:57 en/git-commit.txt:167 en/git-fmt-merge-msg.txt:51 en/git-merge.txt:86 en/git-notes.txt:147 en/git-tag.txt:174
#, no-wrap, priority:280
msgid "-F <file>"
msgstr "-F <文件>"

#. type: Plain text
#: en/git-commit-tree.txt:61
#, priority:80
msgid "Read the commit log message from the given file. Use `-` to read from the standard input. This can be given more than once and the content of each file becomes its own paragraph."
msgstr ""

#. type: Plain text
#: en/git-commit-tree.txt:69
#, priority:80
msgid "GPG-sign commits. The `keyid` argument is optional and defaults to the committer identity; if specified, it must be stuck to the option without a space. `--no-gpg-sign` is useful to countermand a `--gpg-sign` option given earlier on the command line."
msgstr ""

#. type: Title -
#: en/git-commit-tree.txt:71
#, no-wrap, priority:80
msgid "Commit Information"
msgstr ""

#. type: Plain text
#: en/git-commit-tree.txt:74
#, priority:80
msgid "A commit encapsulates:"
msgstr ""

#. type: Plain text
#: en/git-commit-tree.txt:76
#, priority:80
msgid "all parent object ids"
msgstr ""

#. type: Plain text
#: en/git-commit-tree.txt:77
#, priority:80
msgid "author name, email and date"
msgstr ""

#. type: Plain text
#: en/git-commit-tree.txt:78
#, priority:80
msgid "committer name and email and the commit time."
msgstr ""

#. type: Plain text
#: en/git-commit-tree.txt:82
#, priority:80
msgid "A commit comment is read from stdin. If a changelog entry is not provided via \"<\" redirection, 'git commit-tree' will just wait for one to be entered and terminated with ^D."
msgstr ""

#. type: Title -
#: en/git-commit-tree.txt:86
#, fuzzy, no-wrap, priority:80
msgid "Discussion"
msgstr "讨论"

#. type: Title -
#: en/git-commit-tree.txt:91 en/git-commit.txt:571 en/git-config.txt:298 en/git-credential-store.txt:45 en/git-show-ref.txt:186 en/git-submodule.txt:454 en/git-svn.txt:1137 en/git-tag.txt:385
#, no-wrap, priority:280
msgid "FILES"
msgstr "文件"

#. type: Plain text
#: en/git-commit-tree.txt:93
#, fuzzy, priority:80
msgid "/etc/mailname"
msgstr "/etc/mailname"

#. type: Plain text
#: en/git-commit-tree.txt:98
#, ignore-same, priority:80
msgid "linkgit:git-write-tree[1] linkgit:git-commit[1]"
msgstr "linkgit:git-write-tree[1] linkgit:git-commit[1]"

#. type: Title =
#: en/git-commit.txt:2
#, ignore-same, no-wrap, priority:280
msgid "git-commit(1)"
msgstr "git-commit(1)"

#. type: Plain text
#: en/git-commit.txt:7
#, priority:280
msgid "git-commit - Record changes to the repository"
msgstr "git-commit - 记录仓库的修改"

#. type: Plain text
#: en/git-commit.txt:19
#, ignore-ellipsis, no-wrap, priority:280
msgid ""
"'git commit' [-a | --interactive | --patch] [-s] [-v] [-u<mode>] [--amend]\n"
"\t   [--dry-run] [(-c | -C | --squash) <commit> | --fixup [(amend|reword):]<commit>)]\n"
"\t   [-F <file> | -m <msg>] [--reset-author] [--allow-empty]\n"
"\t   [--allow-empty-message] [--no-verify] [-e] [--author=<author>]\n"
"\t   [--date=<date>] [--cleanup=<mode>] [--[no-]status]\n"
"\t   [-i | -o] [--pathspec-from-file=<file> [--pathspec-file-nul]]\n"
"\t   [(--trailer <token>[(=|:)<value>])...] [-S[<keyid>]]\n"
"\t   [--] [<pathspec>...]\n"
msgstr ""
"'git commit' [-a | --interactive | --patch] [-s] [-v] [-u<模式>] [--amend]\n"
"\t   [--dry-run] [(-c | -C | --squash) <提交> | --fixup [(amend|reword):]<提交>)]\n"
"\t   [-F <文件> | -m <消息>] [--reset-author] [--allow-empty]\n"
"\t   [--allow-empty-message] [--no-verify] [-e] [--author=<提交人>]\n"
"\t   [--date=<日期>] [--cleanup=<模式>] [--[no-]status]\n"
"\t   [-i | -o] [--pathspec-from-file=<文件> [--pathspec-file-nul]]\n"
"\t   [(--trailer <token>[(=|:)<value>])...] [-S[<keyid>]]\n"
"\t   [--] [<路径>...]\n"

#. type: Plain text
#: en/git-commit.txt:28
#, priority:280
msgid "Create a new commit containing the current contents of the index and the given log message describing the changes. The new commit is a direct child of HEAD, usually the tip of the current branch, and the branch is updated to point to it (unless no branch is associated with the working tree, in which case HEAD is \"detached\" as described in linkgit:git-checkout[1])."
msgstr "创建一个新的提交，包含索引的当前内容和描述变化的给定日志信息。新的提交是 HEAD 的直接子节点，通常是当前分支的顶端，分支会被更新以指向它（除非工作树上没有分支，在这种情况下 HEAD 会被 \"分离\"，如 linkgit:git-checkout[1] 所述）。"

#. type: Plain text
#: en/git-commit.txt:30
#, priority:280
msgid "The content to be committed can be specified in several ways:"
msgstr "可以用几种方式指定要提交的内容："

#. type: Plain text
#: en/git-commit.txt:34
#, priority:280
msgid "by using linkgit:git-add[1] to incrementally \"add\" changes to the index before using the 'commit' command (Note: even modified files must be \"added\");"
msgstr "通过使用linkgit:git-add[1]，在使用'commit'命令之前，逐步将修改内容 \"添加\"到索引中（注意:即使是修改过的文件也必须被 \"添加\" ）；"

#. type: Plain text
#: en/git-commit.txt:37
#, priority:280
msgid "by using linkgit:git-rm[1] to remove files from the working tree and the index, again before using the 'commit' command;"
msgstr "通过使用 linkgit:git-rm[1] ，在再次使用“提交”命令之前从工作树和索引中删除文件；"

#. type: Plain text
#: en/git-commit.txt:43
#, priority:280
msgid "by listing files as arguments to the 'commit' command (without --interactive or --patch switch), in which case the commit will ignore changes staged in the index, and instead record the current content of the listed files (which must already be known to Git);"
msgstr "通过将文件列为“commit”命令的参数(不带--interactive或--patch switch)，在这种情况下，提交将忽略索引中的更改，而是记录所列文件的当前内容(Git必须已经知道);"

#. type: Plain text
#: en/git-commit.txt:49
#, priority:280
msgid "by using the -a switch with the 'commit' command to automatically \"add\" changes from all known files (i.e. all files that are already listed in the index) and to automatically \"rm\" files in the index that have been removed from the working tree, and then perform the actual commit;"
msgstr "通过在'commit'命令中使用-a开关，自动 \"添加 \"所有已知文件的修改（即所有已经列在索引中的文件），并自动 \"清除 \"索引中已经从工作树中删除的文件，然后执行实际的提交；"

#. type: Plain text
#: en/git-commit.txt:55
#, priority:280
msgid "by using the --interactive or --patch switches with the 'commit' command to decide one by one which files or hunks should be part of the commit in addition to contents in the index, before finalizing the operation. See the ``Interactive Mode'' section of linkgit:git-add[1] to learn how to operate these modes."
msgstr "通过在'commit'命令中使用 --interactive 或 --patch 开关，在最终完成操作之前，逐一决定哪些文件或块应该成为提交的一部分，而不是索引中的内容。参见 linkgit:git-add[1] 的 ``交互式模式'一节，了解如何操作这些模式。"

#. type: Plain text
#: en/git-commit.txt:59
#, priority:280
msgid "The `--dry-run` option can be used to obtain a summary of what is included by any of the above for the next commit by giving the same set of parameters (options and paths)."
msgstr "`--dry-run`选项可以用来获得上述任何一个选项为下一次提交所包含的内容的摘要，只要给出相同的参数（选项和路径）即可。"

#. type: Plain text
#: en/git-commit.txt:62
#, priority:280
msgid "If you make a commit and then find a mistake immediately after that, you can recover from it with 'git reset'."
msgstr "如果你做了一个提交，然后紧接着发现了一个错误，你可以用'git reset'来恢复它。"

#. type: Plain text
#: en/git-commit.txt:72
#, priority:280
msgid "Tell the command to automatically stage files that have been modified and deleted, but new files you have not told Git about are not affected."
msgstr "告诉命令自动阶段化已经被修改和删除的文件，但你没有告诉 Git 的新文件不受影响。"

#. type: Plain text
#: en/git-commit.txt:78
#, fuzzy, priority:280
#| msgid "Use the interactive patch selection interface to chose which changes to commit. See linkgit:git-add[1] for details."
msgid "Use the interactive patch selection interface to choose which changes to commit. See linkgit:git-add[1] for details."
msgstr "使用交互式补丁选择界面来选择要提交的修改。详情见 linkgit:git-add[1]。"

#. type: Labeled list
#: en/git-commit.txt:79
#, no-wrap, priority:280
msgid "-C <commit>"
msgstr "-C <提交>"

#. type: Labeled list
#: en/git-commit.txt:80
#, no-wrap, priority:280
msgid "--reuse-message=<commit>"
msgstr "--reuse-message=<提交>"

#. type: Plain text
#: en/git-commit.txt:84
#, priority:280
msgid "Take an existing commit object, and reuse the log message and the authorship information (including the timestamp)  when creating the commit."
msgstr "取一个现有的提交对象，并在创建提交时重新使用日志信息和作者信息（包括时间戳）。"

#. type: Labeled list
#: en/git-commit.txt:85
#, no-wrap, priority:280
msgid "-c <commit>"
msgstr "-c <commit>"

#. type: Labeled list
#: en/git-commit.txt:86
#, no-wrap, priority:280
msgid "--reedit-message=<commit>"
msgstr "--reedit-message=<commit>"

#. type: Plain text
#: en/git-commit.txt:89
#, priority:280
msgid "Like '-C', but with `-c` the editor is invoked, so that the user can further edit the commit message."
msgstr "和'-C'一样，但用`-c'会调用编辑器，这样用户可以进一步编辑提交信息。"

#. type: Labeled list
#: en/git-commit.txt:90
#, fuzzy, no-wrap, priority:280
msgid "--fixup=[(amend|reword):]<commit>"
msgstr "--fixup=<commit>"

#. type: Plain text
#: en/git-commit.txt:100
#, priority:280
msgid "Create a new commit which \"fixes up\" `<commit>` when applied with `git rebase --autosquash`. Plain `--fixup=<commit>` creates a \"fixup!\" commit which changes the content of `<commit>` but leaves its log message untouched. `--fixup=amend:<commit>` is similar but creates an \"amend!\" commit which also replaces the log message of `<commit>` with the log message of the \"amend!\" commit.  `--fixup=reword:<commit>` creates an \"amend!\" commit which replaces the log message of `<commit>` with its own log message but makes no changes to the content of `<commit>`."
msgstr "创建一个新的提交，在使用 `git rebase --autosquash` 时，\"修复\"`<commit>`。普通的`--fixup=<commit>`会创建一个 \"fixup!\"的提交，改变`<commit>`的内容，但不改变其日志信息。`--fixup=amend:<commit>`类似，但会创建一个 \"修正！\"的提交，同时用 \"修正！\"的提交的日志信息替换`<commit>`的日志信息。  `--fixup=reword:<commit>`创建一个 \"修正！\"提交，用自己的日志信息替换`<commit>`的日志信息，但不对`<commit>`的内容做任何修改。"

#. type: Plain text
#: en/git-commit.txt:108
#, priority:280
msgid "The commit created by plain `--fixup=<commit>` has a subject composed of \"fixup!\" followed by the subject line from <commit>, and is recognized specially by `git rebase --autosquash`. The `-m` option may be used to supplement the log message of the created commit, but the additional commentary will be thrown away once the \"fixup!\" commit is squashed into `<commit>` by `git rebase --autosquash`."
msgstr "由普通的`--fixup=<commit>`创建的提交，其主题由 \"fixup!\"和<commit>的主题行组成，并被`git rebase --autosquash`特别识别。`-m`选项可以用来补充创建提交的日志信息，但一旦 \"fixup!\"提交被`git rebase --autosquash`压入`<commit>`，额外的注释就会被扔掉。"

#. type: Plain text
#: en/git-commit.txt:118
#, priority:280
msgid "The commit created by `--fixup=amend:<commit>` is similar but its subject is instead prefixed with \"amend!\". The log message of <commit> is copied into the log message of the \"amend!\" commit and opened in an editor so it can be refined. When `git rebase --autosquash` squashes the \"amend!\" commit into `<commit>`, the log message of `<commit>` is replaced by the refined log message from the \"amend!\" commit. It is an error for the \"amend!\" commit's log message to be empty unless `--allow-empty-message` is specified."
msgstr "由`--fixup=amend:<commit>`创建的提交与此类似，但其主题前缀为 \"amend!\"。<commit>的日志信息会被复制到 \"amend!\"提交的日志信息中，并在编辑器中打开，以便对其进行修改。当`git rebase --autosquash`将 \"amend!\"提交压入`<commit>`时，`<commit>`的日志信息会被 \"amend!\"提交的精炼日志信息所取代。如果 \"修正！\"提交的日志信息为空，则是一个错误，除非指定`--allow-empty-message`。"

#. type: Plain text
#: en/git-commit.txt:124
#, priority:280
msgid "`--fixup=reword:<commit>` is shorthand for `--fixup=amend:<commit> --only`. It creates an \"amend!\" commit with only a log message (ignoring any changes staged in the index). When squashed by `git rebase --autosquash`, it replaces the log message of `<commit>` without making any other changes."
msgstr "`--fixup=reword:<commit>`是`--fixup=amend:<commit>--only`的简写。它创建一个只有日志信息的 \"修正！\"提交（忽略索引中的任何修改）。当被`git rebase --autosquash`压制时，它会替换`<commit>`的日志信息而不做任何其他改动。"

#. type: Plain text
#: en/git-commit.txt:128
#, priority:280
msgid "Neither \"fixup!\" nor \"amend!\" commits change authorship of `<commit>` when applied by `git rebase --autosquash`.  See linkgit:git-rebase[1] for details."
msgstr "当被 `git rebase --autosquash` 应用时，\"fixup!\"和 \"amend!\"提交都不会改变 `<commit>` 的作者身份。  详情见 linkgit:git-rebase[1]。"

#. type: Labeled list
#: en/git-commit.txt:129
#, no-wrap, priority:280
msgid "--squash=<commit>"
msgstr "--squash=<提交>"

#. type: Plain text
#: en/git-commit.txt:135
#, priority:280
msgid "Construct a commit message for use with `rebase --autosquash`.  The commit message subject line is taken from the specified commit with a prefix of \"squash! \".  Can be used with additional commit message options (`-m`/`-c`/`-C`/`-F`). See linkgit:git-rebase[1] for details."
msgstr "构建一条提交信息，供`rebase --autosquash`使用。  提交信息的主题行取自指定的提交，前缀为 \"squash!\".  可以和其他提交信息选项（`-m`/`-c`/`-C`/`-F`）一起使用。详情见 linkgit:git-rebase[1]。"

#. type: Labeled list
#: en/git-commit.txt:136
#, ignore-same, no-wrap, priority:280
msgid "--reset-author"
msgstr "--reset-author"

#. type: Plain text
#: en/git-commit.txt:141
#, priority:280
msgid "When used with -C/-c/--amend options, or when committing after a conflicting cherry-pick, declare that the authorship of the resulting commit now belongs to the committer. This also renews the author timestamp."
msgstr "当与-C/-c/--amend选项一起使用时，或者当在一个冲突的cherry-pick之后提交时，声明所产生的提交的作者身份现在属于提交者。这也是对作者时间戳的更新。"

#. type: Labeled list
#: en/git-commit.txt:142 en/git-status.txt:28 en/git-symbolic-ref.txt:45
#, ignore-same, no-wrap, priority:280
msgid "--short"
msgstr "--short"

#. type: Plain text
#: en/git-commit.txt:145
#, priority:280
msgid "When doing a dry-run, give the output in the short-format. See linkgit:git-status[1] for details. Implies `--dry-run`."
msgstr "当做干运行的时候，以简短的形式给出输出。详见 linkgit:git-status[1]。意味着 `--干运行`。"

#. type: Labeled list
#: en/git-commit.txt:146 en/git-status.txt:32
#, ignore-same, no-wrap, priority:280
msgid "--branch"
msgstr "--branch"

#. type: Plain text
#: en/git-commit.txt:148 en/git-status.txt:34
#, priority:280
msgid "Show the branch and tracking info even in short-format."
msgstr "即使在短文中也要显示分支和跟踪信息。"

#. type: Plain text
#: en/git-commit.txt:153
#, priority:280
msgid "When doing a dry-run, give the output in a porcelain-ready format. See linkgit:git-status[1] for details. Implies `--dry-run`."
msgstr "在做干运行的时候，要把输出结果以可瓷器的格式给出。详见 linkgit:git-status[1]。意味着 `--干运行`。"

#. type: Labeled list
#: en/git-commit.txt:154 en/git-describe.txt:88 en/git-ls-tree.txt:52 en/git-status.txt:47
#, ignore-same, no-wrap, priority:280
msgid "--long"
msgstr "--long"

#. type: Plain text
#: en/git-commit.txt:157
#, priority:280
msgid "When doing a dry-run, give the output in the long-format.  Implies `--dry-run`."
msgstr "当做干运行时，以长格式给出输出。  意味着\"--干运行\"。"

#. type: Labeled list
#: en/git-commit.txt:159 en/git-config.txt:230 en/git-grep.txt:177
#, ignore-same, no-wrap, priority:280
msgid "--null"
msgstr "--null"

#. type: Plain text
#: en/git-commit.txt:166
#, priority:280
msgid "When showing `short` or `porcelain` status output, print the filename verbatim and terminate the entries with NUL, instead of LF.  If no format is given, implies the `--porcelain` output format.  Without the `-z` option, filenames with \"unusual\" characters are quoted as explained for the configuration variable `core.quotePath` (see linkgit:git-config[1])."
msgstr "当显示 \"short \"或 \"porcelain \"状态输出时，逐字打印文件名，用NUL而不是LF来结束条目。  如果没有给出格式，就意味着是`--porcelain`输出格式。  如果没有`-z`选项，带有 \"不寻常 \"字符的文件名将被引用，正如对配置变量`core.quotePath`的解释（见linkgit:git-config[1]）。"

#. type: Labeled list
#: en/git-commit.txt:168 en/git-merge.txt:87 en/git-notes.txt:148 en/git-tag.txt:175
#, no-wrap, priority:280
msgid "--file=<file>"
msgstr "--file=<文件>"

#. type: Plain text
#: en/git-commit.txt:171
#, priority:280
msgid "Take the commit message from the given file.  Use '-' to read the message from the standard input."
msgstr "从给定文件中获取提交信息。  使用'-'可以从标准输入中读取信息。"

#. type: Labeled list
#: en/git-commit.txt:172
#, no-wrap, priority:280
msgid "--author=<author>"
msgstr "--author=<提交人>"

#. type: Plain text
#: en/git-commit.txt:178
#, priority:280
msgid "Override the commit author. Specify an explicit author using the standard `A U Thor <author@example.com>` format. Otherwise <author> is assumed to be a pattern and is used to search for an existing commit by that author (i.e. rev-list --all -i --author=<author>); the commit author is then copied from the first such commit found."
msgstr "覆盖提交者。使用标准的`A U Thor <author@example.com>`格式指定一个明确的作者。否则，<author>将被假定为一个模式，用于搜索该作者的现有提交（即 rev-list --all -i --author=<author>）；然后从找到的第一个此类提交中复制提交作者。"

#. type: Labeled list
#: en/git-commit.txt:179
#, no-wrap, priority:280
msgid "--date=<date>"
msgstr "--date=<日期>"

#. type: Plain text
#: en/git-commit.txt:181
#, priority:280
msgid "Override the author date used in the commit."
msgstr "覆盖提交中使用的作者日期。"

#. type: Labeled list
#: en/git-commit.txt:182 en/git-merge.txt:70 en/git-notes.txt:138 en/git-svn.txt:468 en/git-tag.txt:166
#, no-wrap, priority:280
msgid "-m <msg>"
msgstr "-m <消息>"

#. type: Labeled list
#: en/git-commit.txt:183 en/git-notes.txt:139 en/git-svn.txt:469 en/git-tag.txt:167
#, no-wrap, priority:280
msgid "--message=<msg>"
msgstr "--message=<msg>"

#. type: Plain text
#: en/git-commit.txt:187
#, priority:280
msgid "Use the given <msg> as the commit message.  If multiple `-m` options are given, their values are concatenated as separate paragraphs."
msgstr "使用给定的<msg>作为提交信息。  如果给定了多个`-m`选项，它们的值会作为单独的段落串联起来。"

#. type: Plain text
#: en/git-commit.txt:189
#, priority:280
msgid "The `-m` option is mutually exclusive with `-c`, `-C`, and `-F`."
msgstr "m \"选项与 \"c\"、\"C \"和 \"F \"相互排斥。"

#. type: Labeled list
#: en/git-commit.txt:190
#, no-wrap, priority:280
msgid "-t <file>"
msgstr "-t <文件>"

#. type: Labeled list
#: en/git-commit.txt:191
#, no-wrap, priority:280
msgid "--template=<file>"
msgstr "--template=<文件>"

#. type: Plain text
#: en/git-commit.txt:200
#, priority:280
msgid "When editing the commit message, start the editor with the contents in the given file.  The `commit.template` configuration variable is often used to give this option implicitly to the command.  This mechanism can be used by projects that want to guide participants with some hints on what to write in the message in what order.  If the user exits the editor without editing the message, the commit is aborted.  This has no effect when a message is given by other means, e.g. with the `-m` or `-F` options."
msgstr "编辑提交信息时，以给定文件中的内容启动编辑器。  `commit.template`配置变量经常被用来给命令隐含这个选项。  这个机制可以被那些希望通过一些提示来指导参与者在消息中以何种顺序书写的项目所使用。  如果用户在没有编辑消息的情况下退出编辑器，提交将被中止。  当用其他方式给出消息时，例如用`-m`或`-F`选项时，这没有影响。"

#. type: Labeled list
#: en/git-commit.txt:203 en/git-interpret-trailers.txt:107
#, no-wrap, priority:280
msgid "--trailer <token>[(=|:)<value>]"
msgstr "--trailer <令牌>[(=|:)<值>]"

#. type: Plain text
#: en/git-commit.txt:213
#, priority:280
msgid "Specify a (<token>, <value>) pair that should be applied as a trailer. (e.g. `git commit --trailer \"Signed-off-by:C O Mitter \\ <committer@example.com>\" --trailer \"Helped-by:C O Mitter \\ <committer@example.com>\"` will add the \"Signed-off-by\" trailer and the \"Helped-by\" trailer to the commit message.)  The `trailer.*` configuration variables (linkgit:git-interpret-trailers[1]) can be used to define if a duplicated trailer is omitted, where in the run of trailers each trailer would appear, and other details."
msgstr "指定一个（<token>, <value>）对，应该作为拖车应用。(例如，`git commit --trailer \"Signed-off-by:C O Mitter / <committer@example.com>\" --trailer \"Helped-by:C O Mitter / <committer@example.com>\"`将在提交信息中加入 \"Signed-off-by \"预告片和 \"Helped-by \"预告片。)  `trailer.*`配置变量（linkgit:git-interpret-trailers[1]）可以用来定义是否省略重复的拖车，每个拖车会出现在拖车运行的哪个位置，以及其他细节。"

#. type: Labeled list
#: en/git-commit.txt:215 en/git-push.txt:422 en/merge-options.txt:135
#, ignore-same, no-wrap, priority:280
msgid "--[no-]verify"
msgstr "--[no-]verify"

#. type: Plain text
#: en/git-commit.txt:219
#, priority:280
msgid "By default, the pre-commit and commit-msg hooks are run.  When any of `--no-verify` or `-n` is given, these are bypassed.  See also linkgit:githooks[5]."
msgstr "默认情况下，会运行 pre-commit 和 commit-msg 钩子。当给出任何 `--no-verify` 或 `-n` 时，这些都会被绕过。参见链接git:githooks[5]。"

#. type: Plain text
#: en/git-commit.txt:225
#, priority:280
msgid "Usually recording a commit that has the exact same tree as its sole parent commit is a mistake, and the command prevents you from making such a commit.  This option bypasses the safety, and is primarily for use by foreign SCM interface scripts."
msgstr "通常情况下，记录一个与唯一的父级提交的树完全相同的提交是一个错误，该命令会阻止你做出这样的提交。  这个选项绕过了安全问题，主要供国外SCM接口脚本使用。"

#. type: Plain text
#: en/git-commit.txt:231
#, priority:280
msgid "Like --allow-empty this command is primarily for use by foreign SCM interface scripts. It allows you to create a commit with an empty commit message without using plumbing commands like linkgit:git-commit-tree[1]."
msgstr "和 --allow-empty 一样，这条命令主要是给国外的 SCM 接口脚本使用的。它允许你在不使用linkgit:git-commit-tree[1]等管道命令的情况下创建一个带有空提交信息的提交。"

#. type: Plain text
#: en/git-commit.txt:236
#, priority:280
msgid "This option determines how the supplied commit message should be cleaned up before committing.  The '<mode>' can be `strip`, `whitespace`, `verbatim`, `scissors` or `default`."
msgstr "这个选项决定了在提交前如何清理所提供的提交信息。  <mode>可以是`strip`、`whitespace`、`verbatim`、`scissors`或`default`。"

#. type: Labeled list
#: en/git-commit.txt:238
#, no-wrap, priority:280
msgid "strip"
msgstr "剥离"

#. type: Plain text
#: en/git-commit.txt:241
#, priority:280
msgid "Strip leading and trailing empty lines, trailing whitespace, commentary and collapse consecutive empty lines."
msgstr "剥离前面和后面的空行、后面的空白、注释和折叠的连续空行。"

#. type: Labeled list
#: en/git-commit.txt:241
#, no-wrap, priority:280
msgid "whitespace"
msgstr "空白字符"

#. type: Plain text
#: en/git-commit.txt:243
#, priority:280
msgid "Same as `strip` except #commentary is not removed."
msgstr "与 \"strip \"相同，只是#commentary不被删除。"

#. type: Labeled list
#: en/git-commit.txt:243
#, no-wrap, priority:280
msgid "verbatim"
msgstr "逐字逐句"

#. type: Plain text
#: en/git-commit.txt:245
#, priority:280
msgid "Do not change the message at all."
msgstr "完全不要改变信息。"

#. type: Labeled list
#: en/git-commit.txt:245
#, fuzzy, no-wrap, priority:280
msgid "scissors"
msgstr "剪刀"

#. type: Plain text
#: en/git-commit.txt:249
#, priority:280
msgid "Same as `whitespace` except that everything from (and including)  the line found below is truncated, if the message is to be edited.  \"`#`\" can be customized with core.commentChar."
msgstr "与 \"whitespace \"相同，但如果要编辑信息，从下面一行开始（包括）的所有内容都被截断。  \"`#`\"可以用core.commentChar自定义。"

#. type: Plain text
#: en/git-commit.txt:251
#, fuzzy, no-wrap, priority:280
msgid "# ------------------------ >8 ------------------------\n"
msgstr "# ------------------------ >8 ------------------------\n"

#. type: Plain text
#: en/git-commit.txt:255
#, priority:280
msgid "Same as `strip` if the message is to be edited.  Otherwise `whitespace`."
msgstr "如果要编辑信息，与`strip`相同。  否则就是`whitespace'。"

#. type: Plain text
#: en/git-commit.txt:259
#, priority:280
msgid "The default can be changed by the `commit.cleanup` configuration variable (see linkgit:git-config[1])."
msgstr "默认值可以通过 `commit.cleanup` 配置变量来改变（见linkgit:git-config[1]）。"

#. type: Plain text
#: en/git-commit.txt:266
#, priority:280
msgid "The message taken from file with `-F`, command line with `-m`, and from commit object with `-C` are usually used as the commit log message unmodified. This option lets you further edit the message taken from these sources."
msgstr "用`-F`从文件中获取的信息，用`-m`从命令行中获取的信息，以及用`-C`从提交对象中获取的信息，通常都是未经修改的提交日志信息。这个选项可以让你进一步编辑从这些来源获取的信息。"

#. type: Labeled list
#: en/git-commit.txt:267 en/git-revert.txt:66 en/merge-options.txt:20
#, ignore-same, no-wrap, priority:280
msgid "--no-edit"
msgstr "--no-edit"

#. type: Plain text
#: en/git-commit.txt:271
#, priority:280
msgid "Use the selected commit message without launching an editor.  For example, `git commit --amend --no-edit` amends a commit without changing its commit message."
msgstr "使用选定的提交信息而不启动编辑器。  例如，`git commit --amend --no-edit`修改一个提交，但不改变其提交信息。"

#. type: Labeled list
#: en/git-commit.txt:272
#, ignore-same, no-wrap, priority:280
msgid "--amend"
msgstr "--amend"

#. type: Plain text
#: en/git-commit.txt:282
#, priority:280
msgid "Replace the tip of the current branch by creating a new commit. The recorded tree is prepared as usual (including the effect of the `-i` and `-o` options and explicit pathspec), and the message from the original commit is used as the starting point, instead of an empty message, when no other message is specified from the command line via options such as `-m`, `-F`, `-c`, etc.  The new commit has the same parents and author as the current one (the `--reset-author` option can countermand this)."
msgstr "通过创建一个新的提交来替换当前分支的顶端。记录的树像往常一样准备（包括`-i`和`-o`选项和显式pathspec的效果），当命令行没有通过`-m`、`-F`、`-c`等选项指定其他信息时，原始提交的信息会被用作起点，而不是空信息。  新的提交与当前的提交具有相同的父辈和作者（`--reset-author`选项可以反驳）。"

#. type: Plain text
#: en/git-commit.txt:285
#, fuzzy, priority:280
msgid "It is a rough equivalent for:"
msgstr "它大致相当于："

#. type: delimited block -
#: en/git-commit.txt:289
#, ignore-ellipsis, no-wrap, priority:280
msgid ""
"\t$ git reset --soft HEAD^\n"
"\t$ ... do something else to come up with the right tree ...\n"
"\t$ git commit -c ORIG_HEAD\n"
msgstr ""
"\t$ git reset --soft HEAD^\n"
"\t$ ... do something else to come up with the right tree ...\n"
"\t$ git commit -c ORIG_HEAD\n"

#. type: Plain text
#: en/git-commit.txt:292
#, priority:280
msgid "but can be used to amend a merge commit."
msgstr "但可以用来修改合并提交。"

#. type: Plain text
#: en/git-commit.txt:297
#, priority:280
msgid "You should understand the implications of rewriting history if you amend a commit that has already been published.  (See the \"RECOVERING FROM UPSTREAM REBASE\" section in linkgit:git-rebase[1].)"
msgstr "如果你修改了一个已经发布的提交，你应该明白重写历史的意义。  参见 linkgit:git-rebase[1]中的 \"RECOVERING FROM UPSTREAM REBASE\" 部分）。"

#. type: Labeled list
#: en/git-commit.txt:298
#, ignore-same, no-wrap, priority:280
msgid "--no-post-rewrite"
msgstr "--no-post-rewrite"

#. type: Plain text
#: en/git-commit.txt:300
#, priority:280
msgid "Bypass the post-rewrite hook."
msgstr "绕过post-rewrite钩子。"

#. type: Labeled list
#: en/git-commit.txt:302
#, ignore-same, no-wrap, priority:280
msgid "--include"
msgstr "--include"

#. type: Plain text
#: en/git-commit.txt:307
#, priority:280
msgid "Before making a commit out of staged contents so far, stage the contents of paths given on the command line as well.  This is usually not what you want unless you are concluding a conflicted merge."
msgstr "在对迄今为止的暂存内容进行提交之前，对命令行上给出的路径内容也进行暂存。  这通常不是你想要的，除非你正在结束一个冲突的合并。"

#. type: Labeled list
#: en/git-commit.txt:309
#, ignore-same, no-wrap, priority:280
msgid "--only"
msgstr "--only"

#. type: Plain text
#: en/git-commit.txt:321
#, priority:280
msgid "Make a commit by taking the updated working tree contents of the paths specified on the command line, disregarding any contents that have been staged for other paths. This is the default mode of operation of 'git commit' if any paths are given on the command line, in which case this option can be omitted.  If this option is specified together with `--amend`, then no paths need to be specified, which can be used to amend the last commit without committing changes that have already been staged. If used together with `--allow-empty` paths are also not required, and an empty commit will be created."
msgstr "在提交时，只取命令行上指定的工作树的最新内容，而不考虑其他路径上的缓存内容。这是'git commit'的默认操作模式，如果在命令行中给出了任何路径，在这种情况下可以省略该选项。  如果该选项与`--amend`一起指定，则不需要指定路径，可以用来修改最后的提交，而不提交已经被暂存的修改。如果和`--allow-empty`一起使用，也不需要指定路径，将创建一个空的提交。"

#. type: Labeled list
#: en/git-commit.txt:335 en/git-status.txt:58
#, no-wrap, priority:280
msgid "-u[<mode>]"
msgstr "-u[<模式>]"

#. type: Labeled list
#: en/git-commit.txt:336 en/git-status.txt:59
#, no-wrap, priority:280
msgid "--untracked-files[=<mode>]"
msgstr "--untracked-files[=<模式>]"

#. type: Plain text
#: en/git-commit.txt:338 en/git-status.txt:61
#, priority:280
msgid "Show untracked files."
msgstr "显示未追踪文件。"

#. type: Plain text
#: en/git-commit.txt:343
#, priority:280
msgid "The mode parameter is optional (defaults to 'all'), and is used to specify the handling of untracked files; when -u is not used, the default is 'normal', i.e. show untracked files and directories."
msgstr "模式参数是可选的（默认为 \"所有\"），用于指定对未追踪文件的处理；当没有使用-u时，默认为 \"正常\"，即显示未追踪的文件和目录。"

#. type: Plain text
#: en/git-commit.txt:345 en/git-status.txt:68 en/git-status.txt:110
#, priority:280
msgid "The possible options are:"
msgstr "可选项："

#. type: Plain text
#: en/git-commit.txt:347
#, no-wrap, priority:280
msgid "'no'     - Show no untracked files\n"
msgstr "'no' - 不显示未被追踪的文件\n"

#. type: Plain text
#: en/git-commit.txt:348
#, no-wrap, priority:280
msgid "'normal' - Shows untracked files and directories\n"
msgstr "'normal' - 显示未被追踪的文件和目录\n"

#. type: Plain text
#: en/git-commit.txt:349 en/git-status.txt:72
#, no-wrap, priority:280
msgid "'all'    - Also shows individual files in untracked directories.\n"
msgstr "'all' - 也显示未被追踪的目录中的单个文件。\n"

#. type: Plain text
#: en/git-commit.txt:352 en/git-status.txt:85
#, priority:280
msgid "The default can be changed using the status.showUntrackedFiles configuration variable documented in linkgit:git-config[1]."
msgstr "默认值可以用linkgit:git-config[1]中记载的 status.showUntrackedFiles 配置变量来改变。"

#. type: Plain text
#: en/git-commit.txt:364
#, priority:280
msgid "Show unified diff between the HEAD commit and what would be committed at the bottom of the commit message template to help the user describe the commit by reminding what changes the commit has.  Note that this diff output doesn't have its lines prefixed with '#'. This diff will not be a part of the commit message. See the `commit.verbose` configuration variable in linkgit:git-config[1]."
msgstr "在提交信息模板的底部显示HEAD提交和将要提交的内容之间的统一差异，通过提醒提交有哪些变化来帮助用户描述提交。  请注意，这个差异输出的行数不会以'#'为前缀。这个差异不会成为提交信息的一部分。参见 linkgit:git-config[1] 中的 `commit.verbose` 配置变量。"

#. type: Plain text
#: en/git-commit.txt:368
#, priority:280
msgid "If specified twice, show in addition the unified diff between what would be committed and the worktree files, i.e. the unstaged changes to tracked files."
msgstr "如果指定了两次，则另外显示将被提交的文件和工作树文件之间的统一差异，即对已跟踪文件的非阶段性修改。"

#. type: Plain text
#: en/git-commit.txt:372
#, priority:280
msgid "Suppress commit summary message."
msgstr "抑制提交摘要信息。"

#. type: Plain text
#: en/git-commit.txt:377
#, priority:280
msgid "Do not create a commit, but show a list of paths that are to be committed, paths with local changes that will be left uncommitted and paths that are untracked."
msgstr "不创建提交，但显示要提交的路径列表，有局部改动的路径将不提交，以及未跟踪的路径。"

#. type: Labeled list
#: en/git-commit.txt:378
#, ignore-same, no-wrap, priority:280
msgid "--status"
msgstr "--status"

#. type: Plain text
#: en/git-commit.txt:383
#, priority:280
msgid "Include the output of linkgit:git-status[1] in the commit message template when using an editor to prepare the commit message.  Defaults to on, but can be used to override configuration variable commit.status."
msgstr "在使用编辑器准备提交信息时，在提交信息模板中包含linkgit:git-status[1]的输出。  默认为开，但可以用来覆盖配置变量commit.status。"

#. type: Labeled list
#: en/git-commit.txt:384
#, ignore-same, no-wrap, priority:280
msgid "--no-status"
msgstr "--no-status"

#. type: Plain text
#: en/git-commit.txt:388
#, priority:280
msgid "Do not include the output of linkgit:git-status[1] in the commit message template when using an editor to prepare the default commit message."
msgstr "当使用编辑器准备默认的提交信息时，不要将 linkgit:git-status[1] 的输出包含在提交信息模板中。"

#. type: Plain text
#: en/git-commit.txt:406
#, priority:280
msgid "When pathspec is given on the command line, commit the contents of the files that match the pathspec without recording the changes already added to the index. The contents of these files are also staged for the next commit on top of what have been staged before."
msgstr "当命令行中给出pathspec时，提交符合pathspec的文件内容，而不记录已经添加到索引中的修改。这些文件的内容也会在下一次提交时在之前的文件基础上被暂存。"

#. type: Plain text
#: en/git-commit.txt:422
#, fuzzy, priority:280
msgid "When recording your own work, the contents of modified files in your working tree are temporarily stored to a staging area called the \"index\" with 'git add'.  A file can be reverted back, only in the index but not in the working tree, to that of the last commit with `git restore --staged <file>`, which effectively reverts 'git add' and prevents the changes to this file from participating in the next commit.  After building the state to be committed incrementally with these commands, `git commit` (without any pathname parameter) is used to record what has been staged so far.  This is the most basic form of the command.  An example:"
msgstr "在记录自己的工作时，工作树中修改过的文件的内容会通过'git add'暂时存储到一个叫做 \"index \"的暂存区域。  一个文件可以用`git restore --staged <file>`恢复到上次提交时的状态，只是在索引中，而不是在工作树中，这实际上是恢复了'git add'，并阻止这个文件的修改参与下一次提交。  在用这些命令建立了要增量提交的状态后，`git commit`（没有任何路径名参数）被用来记录到目前为止已经分阶段提交的内容。  这是该命令最基本的形式。例如："

#. type: delimited block -
#: en/git-commit.txt:428
#, no-wrap, priority:280
msgid ""
"$ edit hello.c\n"
"$ git rm goodbye.c\n"
"$ git add hello.c\n"
"$ git commit\n"
msgstr ""
"$ edit hello.c\n"
"$ git rm goodbye.c\n"
"$ git add hello.c\n"
"$ git commit\n"

#. type: Plain text
#: en/git-commit.txt:436
#, priority:280
msgid "Instead of staging files after each individual change, you can tell `git commit` to notice the changes to the files whose contents are tracked in your working tree and do corresponding `git add` and `git rm` for you.  That is, this example does the same as the earlier example if there is no other change in your working tree:"
msgstr "你可以告诉`git commit`注意到工作树中内容被跟踪的文件的变化，并为你做相应的`git add`和`git rm`，而不是在每个单独的变化后暂存文件。  也就是说，如果你的工作树中没有其他变化，这个例子的做法与前面的例子相同。"

#. type: delimited block -
#: en/git-commit.txt:441
#, no-wrap, priority:280
msgid ""
"$ edit hello.c\n"
"$ rm goodbye.c\n"
"$ git commit -a\n"
msgstr ""
"$ edit hello.c\n"
"$ rm goodbye.c\n"
"$ git commit -a\n"

#. type: Plain text
#: en/git-commit.txt:446
#, priority:280
msgid "The command `git commit -a` first looks at your working tree, notices that you have modified hello.c and removed goodbye.c, and performs necessary `git add` and `git rm` for you."
msgstr "命令`git commit -a`首先查看你的工作树，注意到你修改了hello.c并删除了goodbye.c，并为你执行必要的`git add`和`git rm`。"

#. type: Plain text
#: en/git-commit.txt:451
#, priority:280
msgid "After staging changes to many files, you can alter the order the changes are recorded in, by giving pathnames to `git commit`.  When pathnames are given, the command makes a commit that only records the changes made to the named paths:"
msgstr "在对许多文件进行分期修改后，你可以通过给`git commit`提供路径名来改变修改的顺序。  给出路径名后，该命令就会进行提交，只记录对指定路径的修改。"

#. type: delimited block -
#: en/git-commit.txt:457
#, fuzzy, no-wrap, priority:280
msgid ""
"$ edit hello.c hello.h\n"
"$ git add hello.c hello.h\n"
"$ edit Makefile\n"
"$ git commit Makefile\n"
msgstr ""
"$ edit hello.c hello.h\n"
"$ git add hello.c hello.h\n"
"$ edit Makefile\n"
"$ git commit Makefile\n"

#. type: Plain text
#: en/git-commit.txt:464
#, priority:280
msgid "This makes a commit that records the modification to `Makefile`.  The changes staged for `hello.c` and `hello.h` are not included in the resulting commit.  However, their changes are not lost -- they are still staged and merely held back.  After the above sequence, if you do:"
msgstr "这将产生一个提交，记录对`Makefile`的修改。  为`hello.c`和`hello.h`所做的修改不包括在这次提交中。  然而，它们的修改并没有丢失 -- 它们仍然被暂存，只是被保留了下来。  在上述顺序之后，如果你做"

#. type: delimited block -
#: en/git-commit.txt:467 en/git-commit.txt:493
#, fuzzy, no-wrap, priority:280
msgid "$ git commit\n"
msgstr "$ git commit\n"

#. type: Plain text
#: en/git-commit.txt:471
#, priority:280
msgid "this second commit would record the changes to `hello.c` and `hello.h` as expected."
msgstr "第二次提交会记录下对`hello.c`和`hello.h`的修改，正如预期的那样。"

#. type: Plain text
#: en/git-commit.txt:479
#, priority:280
msgid "After a merge (initiated by 'git merge' or 'git pull') stops because of conflicts, cleanly merged paths are already staged to be committed for you, and paths that conflicted are left in unmerged state.  You would have to first check which paths are conflicting with 'git status' and after fixing them manually in your working tree, you would stage the result as usual with 'git add':"
msgstr "在一次合并（由'git merge'或'git pull'发起）因冲突而停止后，干净的合并路径已经被分阶段提交给你了，而发生冲突的路径则被留在未合并状态。  你必须先用'git status'检查哪些路径有冲突，然后在工作树上手动修复它们，再像往常一样用'git add'将结果分阶段。"

#. type: delimited block -
#: en/git-commit.txt:485
#, fuzzy, no-wrap, priority:280
msgid ""
"$ git status | grep unmerged\n"
"unmerged: hello.c\n"
"$ edit hello.c\n"
"$ git add hello.c\n"
msgstr ""
"$ git status | grep unmerged\n"
"unmerged: hello.c\n"
"$ edit hello.c\n"
"$ git add hello.c\n"

#. type: Plain text
#: en/git-commit.txt:490
#, priority:280
msgid "After resolving conflicts and staging the result, `git ls-files -u` would stop mentioning the conflicted path.  When you are done, run `git commit` to finally record the merge:"
msgstr "在解决冲突并将结果归档后，`git ls-files -u`将不再提及冲突的路径。  完成后，运行`git commit`来最终记录合并的结果。"

#. type: Plain text
#: en/git-commit.txt:501
#, priority:280
msgid "As with the case to record your own changes, you can use `-a` option to save typing.  One difference is that during a merge resolution, you cannot use `git commit` with pathnames to alter the order the changes are committed, because the merge should be recorded as a single commit.  In fact, the command refuses to run when given pathnames (but see `-i` option)."
msgstr "和记录自己的修改的情况一样，你可以使用`-a`选项来节省打字。  有一点不同的是，在解决合并的过程中，你不能使用`git commit`和路径名来改变修改的提交顺序，因为合并应该被记录为一次提交。  事实上，该命令在给定路径名时拒绝运行（但见`-i`选项）。"

#. type: Title -
#: en/git-commit.txt:503
#, no-wrap, priority:280
msgid "COMMIT INFORMATION"
msgstr "承诺信息"

#. type: Plain text
#: en/git-commit.txt:507
#, priority:280
msgid "Author and committer information is taken from the following environment variables, if set:"
msgstr "作者和提交者的信息取自以下环境变量，如果设置了的话。"

#. type: Plain text
#: en/git-commit.txt:514
#, fuzzy, no-wrap, priority:280
msgid ""
"\tGIT_AUTHOR_NAME\n"
"\tGIT_AUTHOR_EMAIL\n"
"\tGIT_AUTHOR_DATE\n"
"\tGIT_COMMITTER_NAME\n"
"\tGIT_COMMITTER_EMAIL\n"
"\tGIT_COMMITTER_DATE\n"
msgstr ""
"\tGIT_AUTHOR_NAME\n"
"\tGIT_AUTHOR_EMAIL\n"
"\tGIT_AUTHOR_DATE\n"
"\tGIT_COMMITTER_NAME\n"
"\tGIT_COMMITTER_EMAIL\n"
"\tGIT_COMMITTER_DATE\n"

#. type: Plain text
#: en/git-commit.txt:516
#, priority:280
msgid "(nb \"<\", \">\" and \"\\n\"s are stripped)"
msgstr "（注意\"<\"、\">\" 和 \"\\n\" 被剥离）"

#. type: Plain text
#: en/git-commit.txt:522
#, priority:280
msgid "The author and committer names are by convention some form of a personal name (that is, the name by which other humans refer to you), although Git does not enforce or require any particular form. Arbitrary Unicode may be used, subject to the constraints listed above. This name has no effect on authentication; for that, see the `credential.username` variable in linkgit:git-config[1]."
msgstr "作者和提交者的名字按惯例是某种形式的人名（也就是其他人称呼你的名字），尽管Git并不强制或要求任何特定的形式。可以使用任意的Unicode，但要遵守上述的限制。这个名字对认证没有影响；关于这一点，请看linkgit:git-config[1]中的`credential.username`变量。"

#. type: Plain text
#: en/git-commit.txt:529
#, priority:280
msgid "In case (some of) these environment variables are not set, the information is taken from the configuration items `user.name` and `user.email`, or, if not present, the environment variable EMAIL, or, if that is not set, system user name and the hostname used for outgoing mail (taken from `/etc/mailname` and falling back to the fully qualified hostname when that file does not exist)."
msgstr "如果这些环境变量（其中一些）没有设置，信息来自配置项`user.name`和`user.email`，或者，如果不存在，环境变量EMAIL，或者，如果没有设置，系统用户名和用于发送邮件的主机名（取自`/etc/mailname`，如果该文件不存在，则返回到完全合格的主机名）。"

#. type: Plain text
#: en/git-commit.txt:533
#, priority:280
msgid "The `author.name` and `committer.name` and their corresponding email options override `user.name` and `user.email` if set and are overridden themselves by the environment variables."
msgstr "如果设置了`author.name`和`committer.name`及其相应的email选项，将覆盖`user.name`和`user.email`，并由环境变量自行覆盖。"

#. type: Plain text
#: en/git-commit.txt:536
#, priority:280
msgid "The typical usage is to set just the `user.name` and `user.email` variables; the other options are provided for more complex use cases."
msgstr "典型的用法是只设置 \"user.name \"和 \"user.email \"变量；其他选项是为更复杂的使用情况提供的。"

#. type: Plain text
#: en/git-commit.txt:550
#, priority:280
msgid "Though not required, it's a good idea to begin the commit message with a single short (less than 50 character) line summarizing the change, followed by a blank line and then a more thorough description.  The text up to the first blank line in a commit message is treated as the commit title, and that title is used throughout Git.  For example, linkgit:git-format-patch[1] turns a commit into email, and it uses the title on the Subject line and the rest of the commit in the body."
msgstr "虽然不是必须的，但在提交信息的开头用一行简短（少于50个字符）的文字来概括修改内容是个好主意，接下来是空白行，然后是更详尽的描述。  提交信息中第一个空行之前的文字被视为提交标题，并且该标题在整个 Git 中使用。  例如，linkgit:git-format-patch[1] 把提交变成了电子邮件，它在主题行使用标题，在正文中使用提交的其他内容。"

#. type: Title -
#: en/git-commit.txt:554
#, no-wrap, priority:280
msgid "ENVIRONMENT AND CONFIGURATION VARIABLES"
msgstr "环境和配置变量"

#. type: Plain text
#: en/git-commit.txt:559
#, priority:280
msgid "The editor used to edit the commit log message will be chosen from the `GIT_EDITOR` environment variable, the core.editor configuration variable, the `VISUAL` environment variable, or the `EDITOR` environment variable (in that order).  See linkgit:git-var[1] for details."
msgstr "用于编辑提交日志信息的编辑器将从`GIT_EDITOR`环境变量、core.editor配置变量、`VISUAL`环境变量或`EDITOR`环境变量中选择（按顺序）。  详情见linkgit:git-var[1]。"

#. type: Plain text
#: en/git-commit.txt:569
#, priority:280
msgid "This command can run `commit-msg`, `prepare-commit-msg`, `pre-commit`, `post-commit` and `post-rewrite` hooks.  See linkgit:githooks[5] for more information."
msgstr "这个命令可以运行`commit-msg`、`prepare-commit-msg`、`pre-commit`、`post-commit`和`post-rewrite`钩子。  更多信息见linkgit:githooks[5]。"

#. type: Labeled list
#: en/git-commit.txt:573
#, no-wrap, priority:280
msgid "`$GIT_DIR/COMMIT_EDITMSG`"
msgstr "`$git_dir/commit_editmsg`。"

#. type: Plain text
#: en/git-commit.txt:579
#, priority:280
msgid "This file contains the commit message of a commit in progress.  If `git commit` exits due to an error before creating a commit, any commit message that has been provided by the user (e.g., in an editor session) will be available in this file, but will be overwritten by the next invocation of `git commit`."
msgstr "该文件包含正在进行的提交的提交信息。  如果`git commit`在创建提交前因错误而退出，任何由用户提供的提交信息（例如在编辑器会话中）都会在此文件中出现，但会被下次调用`git commit`时覆盖。"

#. type: Plain text
#: en/git-commit.txt:587
#, ignore-same, priority:280
msgid "linkgit:git-add[1], linkgit:git-rm[1], linkgit:git-mv[1], linkgit:git-merge[1], linkgit:git-commit-tree[1]"
msgstr "linkgit:git-add[1], linkgit:git-rm[1], linkgit:git-mv[1], linkgit:git-merge[1], linkgit:git-commit-tree[1]"

#. type: Title =
#: en/git-config.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-config(1)"
msgstr "git-config(1)"

#. type: Plain text
#: en/git-config.txt:7
#, priority:100
msgid "git-config - Get and set repository or global options"
msgstr "git-config - 获取和设置仓库或全局选项"

#. type: Plain text
#: en/git-config.txt:27
#, no-wrap, priority:100
msgid ""
"'git config' [<file-option>] [--type=<type>] [--fixed-value] [--show-origin] [--show-scope] [-z|--null] <name> [<value> [<value-pattern>]]\n"
"'git config' [<file-option>] [--type=<type>] --add <name> <value>\n"
"'git config' [<file-option>] [--type=<type>] [--fixed-value] --replace-all <name> <value> [<value-pattern>]\n"
"'git config' [<file-option>] [--type=<type>] [--show-origin] [--show-scope] [-z|--null] [--fixed-value] --get <name> [<value-pattern>]\n"
"'git config' [<file-option>] [--type=<type>] [--show-origin] [--show-scope] [-z|--null] [--fixed-value] --get-all <name> [<value-pattern>]\n"
"'git config' [<file-option>] [--type=<type>] [--show-origin] [--show-scope] [-z|--null] [--fixed-value] [--name-only] --get-regexp <name-regex> [<value-pattern>]\n"
"'git config' [<file-option>] [--type=<type>] [-z|--null] --get-urlmatch <name> <URL>\n"
"'git config' [<file-option>] [--fixed-value] --unset <name> [<value-pattern>]\n"
"'git config' [<file-option>] [--fixed-value] --unset-all <name> [<value-pattern>]\n"
"'git config' [<file-option>] --rename-section <old-name> <new-name>\n"
"'git config' [<file-option>] --remove-section <name>\n"
"'git config' [<file-option>] [--show-origin] [--show-scope] [-z|--null] [--name-only] -l | --list\n"
"'git config' [<file-option>] --get-color <name> [<default>]\n"
"'git config' [<file-option>] --get-colorbool <name> [<stdout-is-tty>]\n"
"'git config' [<file-option>] -e | --edit\n"
msgstr ""
"'git config' [<file-option>] [--type=<type>] [--fixed-value] [--show-origin] [--show-scope] [-z|--null] <name> [<value> [<value-pattern>]]\n"
"'git config' [<file-option>] [--type=<type>] --add <name> <value>\n"
"'git config' [<file-option>] [--type=<type>] [--fixed-value] --replace-all <name> <value> [<value-pattern>]\n"
"'git config' [<file-option>] [--type=<type>] [--show-origin] [--show-scope] [-z|--null] [--fixed-value] --get <name> [<value-pattern>]\n"
"'git config' [<file-option>] [--type=<type>] [--show-origin] [--show-scope] [-z|--null] [--fixed-value] --get-all <name> [<value-pattern>]\n"
"'git config' [<file-option>] [--type=<type>] [--show-origin] [--show-scope] [-z|--null] [--fixed-value] [--name-only] --get-regexp <name-regex> [<value-pattern>]\n"
"'git config' [<file-option>] [--type=<type>] [-z|--null] --get-urlmatch <name> <URL>\n"
"'git config' [<file-option>] [--fixed-value] --unset <name> [<value-pattern>]\n"
"'git config' [<file-option>] [--fixed-value] --unset-all <name> [<value-pattern>]\n"
"'git config' [<file-option>] --rename-section <old-name> <new-name>\n"
"'git config' [<file-option>] --remove-section <name>\n"
"'git config' [<file-option>] [--show-origin] [--show-scope] [-z|--null] [--name-only] -l | --list\n"
"'git config' [<file-option>] --get-color <name> [<default>]\n"
"'git config' [<file-option>] --get-colorbool <name> [<stdout-is-tty>]\n"
"'git config' [<file-option>] -e | --edit\n"

#. type: Plain text
#: en/git-config.txt:33
#, priority:100
msgid "You can query/set/replace/unset options with this command. The name is actually the section and the key separated by a dot, and the value will be escaped."
msgstr "你可以用这个命令查询/设置/替换/取消选项。名称(name)实际上是用点隔开的节和键，值(value)会被转义。"

#. type: Plain text
#: en/git-config.txt:43
#, priority:100
msgid "Multiple lines can be added to an option by using the `--add` option.  If you want to update or unset an option which can occur on multiple lines, a `value-pattern` (which is an extended regular expression, unless the `--fixed-value` option is given) needs to be given.  Only the existing values that match the pattern are updated or unset.  If you want to handle the lines that do *not* match the pattern, just prepend a single exclamation mark in front (see also <<EXAMPLES>>), but note that this only works when the `--fixed-value` option is not in use."
msgstr "通过使用`--add`选项，可以为一个选项添加多行。  如果你想更新或取消一个可以出现在多行的选项，需要给出一个`value-pattern`（这是一个扩展的正则表达式，除非给出`--fixed-value`选项）。  只有符合该模式的现有值被更新或取消设置。  如果你想处理不符合模式的行，只需在前面加上一个感叹号（参见<<例子>>），但注意这只在没有使用`--fixed-value`选项时有效。"

#. type: Plain text
#: en/git-config.txt:48
#, priority:100
msgid "The `--type=<type>` option instructs 'git config' to ensure that incoming and outgoing values are canonicalize-able under the given <type>.  If no `--type=<type>` is given, no canonicalization will be performed. Callers may unset an existing `--type` specifier with `--no-type`."
msgstr "`--type=<类型>`选项指示'git config'确保传入和传出的值在给定的<类型>下是可以被规范化的。  如果没有给定`--type=<类型>`，将不执行规范化。调用者可以用`--no-type`取消现有的`--type`指定器。"

#. type: Plain text
#: en/git-config.txt:54
#, priority:100
msgid "When reading, the values are read from the system, global and repository local configuration files by default, and options `--system`, `--global`, `--local`, `--worktree` and `--file <filename>` can be used to tell the command to read from only that location (see <<FILES>>)."
msgstr "读取配置时，默认从系统、全局和资源库的本地配置文件中读取数值，选项`--系统(system)`、`--全局(global)`、`--(local)`、`--工作区(worktree)`和`--文件(file)<文件名>`可以用来告诉命令只从选定的位置读取（见<<文件>>）。"

#. type: Plain text
#: en/git-config.txt:60
#, priority:100
msgid "When writing, the new value is written to the repository local configuration file by default, and options `--system`, `--global`, `--worktree`, `--file <filename>` can be used to tell the command to write to that location (you can say `--local` but that is the default)."
msgstr "写入时，新值默认写入版本库的本地配置文件，选项`--system(系统)`、`--global(全局)`、`--worktree(工作区)`、`--file(文件) <filename>`可以用来告诉命令写到那个位置（你可以给出`--local(本地)`选项，但是默认选项就是本地(local)）。"

#. type: Plain text
#: en/git-config.txt:63
#, priority:100
msgid "This command will fail with non-zero status upon error.  Some exit codes are:"
msgstr "该命令出错时将以非零状态失败。  以下是一些退出代码："

#. type: Plain text
#: en/git-config.txt:65
#, priority:100
msgid "The section or key is invalid (ret=1),"
msgstr "该节或键无效（退出代码为1），"

#. type: Plain text
#: en/git-config.txt:66
#, priority:100
msgid "no section or name was provided (ret=2),"
msgstr "没有提供节或键（退出值为2），"

#. type: Plain text
#: en/git-config.txt:67
#, priority:100
msgid "the config file is invalid (ret=3),"
msgstr "配置文件无效（退出代码为3），"

#. type: Plain text
#: en/git-config.txt:68
#, priority:100
msgid "the config file cannot be written (ret=4),"
msgstr "配置文件无法写入（退出代码为4），"

#. type: Plain text
#: en/git-config.txt:69
#, priority:100
msgid "you try to unset an option which does not exist (ret=5),"
msgstr "你试图取消一个不存在的选项（退出代码为5），"

#. type: Plain text
#: en/git-config.txt:70
#, priority:100
msgid "you try to unset/set an option for which multiple lines match (ret=5), or"
msgstr "你试图取消/设置一个多行匹配的选项（退出代码为5），或"

#. type: Plain text
#: en/git-config.txt:71
#, priority:100
msgid "you try to use an invalid regexp (ret=6)."
msgstr "试图使用一个无效的正则表达式（退出代码为6）。"

#. type: Plain text
#: en/git-config.txt:73
#, priority:100
msgid "On success, the command returns the exit code 0."
msgstr "执行成功时，该命令返回退出代码0。"

#. type: Plain text
#: en/git-config.txt:76
#, priority:100
msgid "A list of all available configuration variables can be obtained using the `git help --config` command."
msgstr "所有可用配置变量的列表可以通过`git help --config`命令获取。"

#. type: Labeled list
#: en/git-config.txt:81
#, ignore-same, no-wrap, priority:100
msgid "--replace-all"
msgstr "--replace-all"

#. type: Plain text
#: en/git-config.txt:84
#, priority:100
msgid "Default behavior is to replace at most one line. This replaces all lines matching the key (and optionally the `value-pattern`)."
msgstr "默认行为是最多替换一行。这将会替换所有与键（以及可选的`value-pattern`）匹配的行。"

#. type: Labeled list
#: en/git-config.txt:85 en/git-update-index.txt:44
#, ignore-same, no-wrap, priority:100
msgid "--add"
msgstr "--add"

#. type: Plain text
#: en/git-config.txt:89
#, priority:100
msgid "Adds a new line to the option without altering any existing values.  This is the same as providing '^$' as the `value-pattern` in `--replace-all`."
msgstr "不改变任何现有的值的情况下，在选项中增加一个新的行。  这与在`--replace-all`中提供'^$'作为`value-pattern` 是一样的。"

#. type: Labeled list
#: en/git-config.txt:90
#, ignore-same, no-wrap, priority:100
msgid "--get"
msgstr "--get"

#. type: Plain text
#: en/git-config.txt:94
#, priority:100
msgid "Get the value for a given key (optionally filtered by a regex matching the value). Returns error code 1 if the key was not found and the last value if multiple key values were found."
msgstr "获取一个给定的键的值（可选择通过与该值相匹配的正则表达式进行过滤）。如果没有找到键值，返回错误代码1；如果找到多个键值，则返回最后一个值。"

#. type: Labeled list
#: en/git-config.txt:95
#, ignore-same, no-wrap, priority:100
msgid "--get-all"
msgstr "--get-all"

#. type: Plain text
#: en/git-config.txt:97
#, priority:100
msgid "Like get, but returns all values for a multi-valued key."
msgstr "和--get一样，但是返回一个多值键的所有值。"

#. type: Labeled list
#: en/git-config.txt:98
#, ignore-same, no-wrap, priority:100
msgid "--get-regexp"
msgstr "--get-regexp"

#. type: Plain text
#: en/git-config.txt:104
#, priority:100
msgid "Like --get-all, but interprets the name as a regular expression and writes out the key names.  Regular expression matching is currently case-sensitive and done against a canonicalized version of the key in which section and variable names are lowercased, but subsection names are not."
msgstr "像 --get-all 一样，但是用正则表达式作为，并写出键名。  正则表达式匹配目前是区分大小写的，并且是针对一个规范化的键的版本进行的，其中节(section)和变量名称是小写的，但子节名称不是小写的。"

#. type: Labeled list
#: en/git-config.txt:105
#, no-wrap, priority:100
msgid "--get-urlmatch <name> <URL>"
msgstr "--get-urlmatch <名称> <URL>"

#. type: Plain text
#: en/git-config.txt:112
#, priority:100
msgid "When given a two-part name section.key, the value for section.<URL>.key whose <URL> part matches the best to the given URL is returned (if no such key exists, the value for section.key is used as a fallback).  When given just the section as name, do so for all the keys in the section and list them.  Returns error code 1 if no value is found."
msgstr "当给定一个由两部分组成的名称section.key时，返回section.<URL>.key的值，其<URL>部分是给定的最相匹配的URL（如果没有这样的键存在，section.key的值将作为备用值）。  当只给出section的名称时，对section中的所有key进行处理，并将其列出。  如果没有找到值，返回错误代码1（section: 节，key:键；在配置文件中是这样的[section]  key=value）。"

#. type: Labeled list
#: en/git-config.txt:113
#, ignore-same, no-wrap, priority:100
msgid "--global"
msgstr "--global"

#. type: Plain text
#: en/git-config.txt:118
#, priority:100
msgid "For writing options: write to global `~/.gitconfig` file rather than the repository `.git/config`, write to `$XDG_CONFIG_HOME/git/config` file if this file exists and the `~/.gitconfig` file doesn't."
msgstr "对于写入选项：写入全局的`~/.gitconfig`文件而不是仓库的`.git/config`文件，如果该文件存在而`~/.gitconfig`文件不存在，则写入`$XDG_CONFIG_HOME/git/config`文件。"

#. type: Plain text
#: en/git-config.txt:121
#, priority:100
msgid "For reading options: read only from global `~/.gitconfig` and from `$XDG_CONFIG_HOME/git/config` rather than from all available files."
msgstr "对于读取选项：只从全局的`~/.gitconfig`和`$XDG_CONFIG_HOME/git/config`中读取，而不是从所有可用文件中读取。"

#. type: Plain text
#: en/git-config.txt:123 en/git-config.txt:133 en/git-config.txt:142 en/git-config.txt:161 en/git-config.txt:409
#, priority:100
msgid "See also <<FILES>>."
msgstr "另请参见<<文件>>。"

#. type: Labeled list
#: en/git-config.txt:124
#, ignore-same, no-wrap, priority:100
msgid "--system"
msgstr "--system"

#. type: Plain text
#: en/git-config.txt:128
#, priority:100
msgid "For writing options: write to system-wide `$(prefix)/etc/gitconfig` rather than the repository `.git/config`."
msgstr "对于写选项：写到系统范围内的`$(prefix)/etc/gitconfig`文件中，而不是仓库中的`.git/config`文件。"

#. type: Plain text
#: en/git-config.txt:131
#, priority:100
msgid "For reading options: read only from system-wide `$(prefix)/etc/gitconfig` rather than from all available files."
msgstr "对于读取选项：只从系统范围内的`$(prefix)/etc/gitconfig`读取，而不是从所有可用文件中读取。"

#. type: Plain text
#: en/git-config.txt:137
#, priority:100
msgid "For writing options: write to the repository `.git/config` file.  This is the default behavior."
msgstr "对于写选项：写到版本库的`.git/config`文件中。  这是默认行为。"

#. type: Plain text
#: en/git-config.txt:140
#, priority:100
msgid "For reading options: read only from the repository `.git/config` rather than from all available files."
msgstr "对于读取选项：只从存储库`.git/config`中读取，而不是从所有可用文件中读取。"

#. type: Labeled list
#: en/git-config.txt:143 en/git-restore.txt:59
#, ignore-same, no-wrap, priority:280
msgid "--worktree"
msgstr "--worktree"

#. type: Plain text
#: en/git-config.txt:151
#, priority:100
msgid "Similar to `--local` except that `$GIT_DIR/config.worktree` is read from or written to if `extensions.worktreeConfig` is enabled. If not it's the same as `--local`. Note that `$GIT_DIR` is equal to `$GIT_COMMON_DIR` for the main working tree, but is of the form `$GIT_DIR/worktrees/<id>/` for other working trees. See linkgit:git-worktree[1] to learn how to enable `extensions.worktreeConfig`."
msgstr "与`--local`类似，只是如果启用了`extensions.worktreeConfig`，则从`$GIT_DIR/config.worktree`读取或写入。如果没有，则与`--local`相同。注意，对于主工作区，`$GIT_DIR`等于`$GIT_COMMON_DIR`，但对于其他工作区，它的形式是`$GIT_DIR/worktrees/<id>/`。了解如何启用 `extensions.worktreeConfig`，参见 linkgit:git-worktree[1] 。"

#. type: Labeled list
#: en/git-config.txt:152
#, no-wrap, priority:100
msgid "-f <config-file>"
msgstr "-f <配置文件>"

#. type: Labeled list
#: en/git-config.txt:153
#, no-wrap, priority:100
msgid "--file <config-file>"
msgstr "--file <配置文件>"

#. type: Plain text
#: en/git-config.txt:156
#, priority:100
msgid "For writing options: write to the specified file rather than the repository `.git/config`."
msgstr "对于写入选项：写到指定的文件，而不是仓库`.git/config`。"

#. type: Plain text
#: en/git-config.txt:159
#, priority:100
msgid "For reading options: read only from the specified file rather than from all available files."
msgstr "对于读取选项：只从指定的文件而不是从所有可用的文件中读取。"

#. type: Labeled list
#: en/git-config.txt:162
#, no-wrap, priority:100
msgid "--blob <blob>"
msgstr "--blob <二进制对象>"

#. type: Plain text
#: en/git-config.txt:168
#, priority:100
msgid "Similar to `--file` but use the given blob instead of a file. E.g.  you can use 'master:.gitmodules' to read values from the file '.gitmodules' in the master branch. See \"SPECIFYING REVISIONS\" section in linkgit:gitrevisions[7] for a more complete list of ways to spell blob names."
msgstr "类似于`--file`，但使用指定的二进制对象而不是文件。例如，你可以使用'master:.gitmodules'来读取主分支中'.gitmodules'文件中的值。参见 linkgit:gitrevisions[7] 中的 \"指定的修正\"部分，以获得更完整的二进制对象名称拼写方式。"

#. type: Labeled list
#: en/git-config.txt:169
#, ignore-same, no-wrap, priority:100
msgid "--remove-section"
msgstr "--remove-section"

#. type: Plain text
#: en/git-config.txt:171
#, priority:100
msgid "Remove the given section from the configuration file."
msgstr "从配置文件中删除了该节。"

#. type: Labeled list
#: en/git-config.txt:172
#, ignore-same, no-wrap, priority:100
msgid "--rename-section"
msgstr "--rename-section"

#. type: Plain text
#: en/git-config.txt:174
#, priority:100
msgid "Rename the given section to a new name."
msgstr "将给定的节重命名为一个新的名称。"

#. type: Labeled list
#: en/git-config.txt:175
#, ignore-same, no-wrap, priority:100
msgid "--unset"
msgstr "--unset"

#. type: Plain text
#: en/git-config.txt:177
#, priority:100
msgid "Remove the line matching the key from config file."
msgstr "从配置文件中删除与该键匹配的行。"

#. type: Labeled list
#: en/git-config.txt:178
#, ignore-same, no-wrap, priority:100
msgid "--unset-all"
msgstr "--unset-all"

#. type: Plain text
#: en/git-config.txt:180
#, priority:100
msgid "Remove all lines matching the key from config file."
msgstr "从配置文件中删除所有匹配该键的行。"

#. type: Plain text
#: en/git-config.txt:184
#, priority:100
msgid "List all variables set in config file, along with their values."
msgstr "列出配置文件中设置的所有变量，以及它们的值。"

#. type: Labeled list
#: en/git-config.txt:185
#, ignore-same, no-wrap, priority:100
msgid "--fixed-value"
msgstr "--fixed-value"

#. type: Plain text
#: en/git-config.txt:190
#, priority:100
msgid "When used with the `value-pattern` argument, treat `value-pattern` as an exact string instead of a regular expression. This will restrict the name/value pairs that are matched to only those where the value is exactly equal to the `value-pattern`."
msgstr "当与`value-pattern`参数一起使用时，将`value-pattern`视为精确的字符串，而不是正则表达式。这将使得被匹配的名称/值对，只有那些值与`value-pattern'完全相等的名称/值对。"

#. type: Labeled list
#: en/git-config.txt:191
#, no-wrap, priority:100
msgid "--type <type>"
msgstr "--type <类型>"

#. type: Plain text
#: en/git-config.txt:195
#, priority:100
msgid "'git config' will ensure that any input or output is valid under the given type constraint(s), and will canonicalize outgoing values in `<type>`'s canonical form."
msgstr "'git config' 将确保任何输入或输出在给定的类型约束下是有效的，并将以 `<类型>` 的规范形式将输出的值规范化。"

#. type: Plain text
#: en/git-config.txt:197
#, priority:100
msgid "Valid `<type>`'s include:"
msgstr "有效的 `<类型>` 包括："

#. type: Plain text
#: en/git-config.txt:199
#, priority:100
msgid "'bool': canonicalize values as either \"true\" or \"false\"."
msgstr "'bool'：将数值规范化为 \"true\" 或 \"false\"。"

#. type: Plain text
#: en/git-config.txt:202
#, priority:100
msgid "'int': canonicalize values as simple decimal numbers. An optional suffix of 'k', 'm', or 'g' will cause the value to be multiplied by 1024, 1048576, or 1073741824 upon input."
msgstr "'int'：将数值规范化为简单的十进制数字。可选的后缀 'k'、'm' 或 'g'将导致输入的值被乘以 1024、1048576 或 1073741824。"

#. type: Plain text
#: en/git-config.txt:204
#, priority:100
msgid "'bool-or-int': canonicalize according to either 'bool' or 'int', as described above."
msgstr "'bool-or-int'：如上所述，根据 'bool '或 'int' 进行规范化。"

#. type: Plain text
#: en/git-config.txt:208
#, fuzzy, priority:100
msgid "'path': canonicalize by adding a leading `~` to the value of `$HOME` and `~user` to the home directory for the specified user. This specifier has no effect when setting the value (but you can use `git config section.variable ~/` from the command line to let your shell do the expansion.)"
msgstr "'path': canonicalize by adding a leading `~` to the value of `$HOME` and `~user` to the home directory for the specified user. This specifier has no effect when setting the value (but you can use `git config section.variable ~/` from the command line to let your shell do the expansion.)"

#. type: Plain text
#: en/git-config.txt:210
#, priority:100
msgid "'expiry-date': canonicalize by converting from a fixed or relative date-string to a timestamp. This specifier has no effect when setting the value."
msgstr "'expiry-date'：通过将固定或相对日期字符串转换为时间戳进行规范化。这个指定符在设置值时没有影响。"

#. type: Plain text
#: en/git-config.txt:214
#, priority:100
msgid "'color': When getting a value, canonicalize by converting to an ANSI color escape sequence. When setting a value, a sanity-check is performed to ensure that the given value is canonicalize-able as an ANSI color, but it is written as-is."
msgstr "'color'： 当获得一个值时，通过转换为 ANSI 颜色转义序列进行规范化。当设置一个值时，会进行理智检查，以确保给定的值可以被规范化为 ANSI 颜色，但它会按原样写入。"

#. type: Labeled list
#: en/git-config.txt:216
#, ignore-same, no-wrap, priority:100
msgid "--bool"
msgstr "--bool"

#. type: Labeled list
#: en/git-config.txt:217
#, ignore-same, no-wrap, priority:100
msgid "--int"
msgstr "--int"

#. type: Labeled list
#: en/git-config.txt:218
#, ignore-same, no-wrap, priority:100
msgid "--bool-or-int"
msgstr "--bool-or-int"

#. type: Labeled list
#: en/git-config.txt:219 en/git-hash-object.txt:41
#, ignore-same, no-wrap, priority:100
msgid "--path"
msgstr "--path"

#. type: Labeled list
#: en/git-config.txt:220
#, ignore-same, no-wrap, priority:100
msgid "--expiry-date"
msgstr "--expiry-date"

#. type: Plain text
#: en/git-config.txt:223
#, priority:100
msgid "Historical options for selecting a type specifier. Prefer instead `--type` (see above)."
msgstr "选择类型指定器的历史选项。更倾向于选择 `--type`（见上文）。"

#. type: Labeled list
#: en/git-config.txt:224
#, ignore-same, no-wrap, priority:100
msgid "--no-type"
msgstr "--no-type"

#. type: Plain text
#: en/git-config.txt:228
#, priority:100
msgid "Un-sets the previously set type specifier (if one was previously set). This option requests that 'git config' not canonicalize the retrieved variable.  `--no-type` has no effect without `--type=<type>` or `--<type>`."
msgstr "取消先前设置的类型指定器（如果先前有的话）。这个选项要求 'git config' 不对检索的变量进行规范化处理。 `--no-type` 在没有 `--type=<类型>` 或 `--<类型>` 的情况下没有作用。"

#. type: Plain text
#: en/git-config.txt:237
#, priority:100
msgid "For all options that output values and/or keys, always end values with the null character (instead of a newline). Use newline instead as a delimiter between key and value. This allows for secure parsing of the output without getting confused e.g. by values that contain line breaks."
msgstr "对于所有输出值和/或键的选项，总是用空字符（而不是换行）结束值。使用换行符作为键和值之间的分隔符。这样可以安全地解析输出，而不会被包含换行的值所混淆。"

#. type: Plain text
#: en/git-config.txt:241
#, priority:100
msgid "Output only the names of config variables for `--list` or `--get-regexp`."
msgstr "只输出 `--list` 或 `--get-regexp` 的配置变量的名称。"

#. type: Labeled list
#: en/git-config.txt:242
#, ignore-same, no-wrap, priority:100
msgid "--show-origin"
msgstr "--show-origin"

#. type: Plain text
#: en/git-config.txt:247
#, priority:100
msgid "Augment the output of all queried config options with the origin type (file, standard input, blob, command line) and the actual origin (config file path, ref, or blob id if applicable)."
msgstr "用来源类型（文件、标准输入、blob、命令行）和实际来源（配置文件路径、引用或 blob id（如适用））对所有查询到的配置选项的输出进行扩充。"

#. type: Labeled list
#: en/git-config.txt:248
#, ignore-same, no-wrap, priority:100
msgid "--show-scope"
msgstr "--show-scope"

#. type: Plain text
#: en/git-config.txt:252
#, priority:100
msgid "Similar to `--show-origin` in that it augments the output of all queried config options with the scope of that value (worktree, local, global, system, command)."
msgstr "类似于 `--show-origin`，它用该值的范围（工作树、本地、全局、系统、命令）来增加所有查询的配置选项的输出。"

#. type: Labeled list
#: en/git-config.txt:253
#, fuzzy, no-wrap, priority:100
msgid "--get-colorbool <name> [<stdout-is-tty>]"
msgstr "--get-colorbool name [stdout-is-tty]"

#. type: Plain text
#: en/git-config.txt:263
#, priority:100
msgid "Find the color setting for `<name>` (e.g. `color.diff`) and output \"true\" or \"false\".  `<stdout-is-tty>` should be either \"true\" or \"false\", and is taken into account when configuration says \"auto\".  If `<stdout-is-tty>` is missing, then checks the standard output of the command itself, and exits with status 0 if color is to be used, or exits with status 1 otherwise.  When the color setting for `name` is undefined, the command uses `color.ui` as fallback."
msgstr "找到 `<名称>` 的颜色设置（例如 `color.diff`），并输出 \"true\" 或 \"false\"。 `<stdout-is-tty>` 应该是 \"true\" 或 \"false\"，当配置为 \"auto\" 时将被考虑。 如果 `<stdout-is-tty>` 缺失，则检查命令本身的标准输出，如果要使用颜色则以状态 0 退出，否则以状态 1 退出。 当 `name` 的颜色设置未被定义时，该命令使用 `color.ui` 作为回退。"

#. type: Labeled list
#: en/git-config.txt:264
#, fuzzy, no-wrap, priority:100
msgid "--get-color <name> [<default>]"
msgstr "--get-color name [default]"

#. type: Plain text
#: en/git-config.txt:270
#, priority:100
msgid "Find the color configured for `name` (e.g. `color.diff.new`) and output it as the ANSI color escape sequence to the standard output.  The optional `default` parameter is used instead, if there is no color configured for `name`."
msgstr "找到为 `name` 配置的颜色（例如：`color.diff.new`），并将其作为 ANSI 颜色转义序列输出到标准输出。 如果没有为 `name` 配置的颜色，则使用可选的 `default` 参数来代替。"

#. type: Plain text
#: en/git-config.txt:274
#, priority:100
msgid "`--type=color [--default=<default>]` is preferred over `--get-color` (but note that `--get-color` will omit the trailing newline printed by `--type=color`)."
msgstr "`--type=color [--default=<默认>]` 比 `--get-color` 更受欢迎（但注意 `--get-color` 会省略 `--type=color` 打印的尾部换行）。"

#. type: Plain text
#: en/git-config.txt:279
#, priority:100
msgid "Opens an editor to modify the specified config file; either `--system`, `--global`, or repository (default)."
msgstr "打开一个编辑器来修改指定的配置文件；可以是 `--system`，`--global`，也可以是仓库（默认）。"

#. type: Labeled list
#: en/git-config.txt:280
#, ignore-same, no-wrap, priority:100
msgid "--[no-]includes"
msgstr "--[no-]includes"

#. type: Plain text
#: en/git-config.txt:285
#, priority:100
msgid "Respect `include.*` directives in config files when looking up values. Defaults to `off` when a specific file is given (e.g., using `--file`, `--global`, etc) and `on` when searching all config files."
msgstr "在查找数值时尊重配置文件中的 `include.*` 指令。当给出一个特定的文件时，默认为 `off`（例如，使用 `--file`、`--global` 等），当搜索所有配置文件时，默认为 `on`。"

#. type: Labeled list
#: en/git-config.txt:286
#, no-wrap, priority:100
msgid "--default <value>"
msgstr "--default <值>"

#. type: Plain text
#: en/git-config.txt:289
#, priority:100
msgid "When using `--get`, and the requested variable is not found, behave as if <value> were the value assigned to the that variable."
msgstr "当使用 `--get` 时，如果没有找到所要求的变量，则表现为 <值> 是分配给该变量的值。"

#. type: Plain text
#: en/git-config.txt:295
#, priority:100
msgid "`pager.config` is only respected when listing configuration, i.e., when using `--list` or any of the `--get-*` which may return multiple results.  The default is to use a pager."
msgstr "`pager.config` 只在列出配置时被尊重，即在使用 `--list` 或任何可能返回多个结果的 `--get-*` 时。 默认情况下是使用 pager。"

#. type: Plain text
#: en/git-config.txt:302
#, priority:100
msgid "By default, 'git config' will read configuration options from multiple files:"
msgstr "默认情况下，'git config' 会从多个文件中读取配置选项："

#. type: Plain text
#: en/git-config.txt:303 en/git-config.txt:353
#, fuzzy, no-wrap, priority:100
msgid "$(prefix)/etc/gitconfig"
msgstr "$(prefix)/etc/gitconfig"

#. type: Plain text
#: en/git-config.txt:305
#, priority:100
msgid "System-wide configuration file."
msgstr "全系统的配置文件。"

#. type: Plain text
#: en/git-config.txt:306 en/git-config.txt:356
#, fuzzy, no-wrap, priority:100
msgid "$XDG_CONFIG_HOME/git/config"
msgstr "$XDG_CONFIG_HOME/git/config"

#. type: Plain text
#: en/git-config.txt:307 en/git-config.txt:358
#, fuzzy, no-wrap, priority:100
msgid "~/.gitconfig"
msgstr "~/.gitconfig"

#. type: Plain text
#: en/git-config.txt:311
#, priority:100
msgid "User-specific configuration files. When the XDG_CONFIG_HOME environment variable is not set or empty, $HOME/.config/ is used as $XDG_CONFIG_HOME."
msgstr "用户特定的配置文件。当 XDG_CONFIG_HOME 环境变量没有设置或为空时，$HOME/.config/ 被用作 $XDG_CONFIG_HOME。"

#. type: Plain text
#: en/git-config.txt:314
#, priority:100
msgid "These are also called \"global\" configuration files. If both files exist, both files are read in the order given above."
msgstr "这些文件也被称为 “全局” 配置文件。如果这两个文件都存在，就按照上面的顺序读取这两个文件。"

#. type: Plain text
#: en/git-config.txt:315 en/git-config.txt:361
#, no-wrap, priority:100
msgid "$GIT_DIR/config"
msgstr "$GIT_DIR/config"

#. type: Plain text
#: en/git-config.txt:317
#, priority:100
msgid "Repository specific configuration file."
msgstr "仓库特定的配置文件。"

#. type: Plain text
#: en/git-config.txt:318 en/git-config.txt:364
#, fuzzy, no-wrap, priority:100
msgid "$GIT_DIR/config.worktree"
msgstr "$GIT_DIR/config.worktree"

#. type: Plain text
#: en/git-config.txt:321
#, priority:100
msgid "This is optional and is only searched when `extensions.worktreeConfig` is present in $GIT_DIR/config."
msgstr "这是可选的，只有当 $GIT_DIR/config 中存在 `extensions.worktreeConfig` 时才会被搜索到。"

#. type: Plain text
#: en/git-config.txt:324
#, priority:100
msgid "You may also provide additional configuration parameters when running any git command by using the `-c` option. See linkgit:git[1] for details."
msgstr "你也可以在运行任何 git 命令时通过使用 `-c` 选项提供额外的配置参数。详情见 linkgit:git[1]。"

#. type: Plain text
#: en/git-config.txt:330
#, priority:100
msgid "Options will be read from all of these files that are available. If the global or the system-wide configuration files are missing or unreadable they will be ignored. If the repository configuration file is missing or unreadable, 'git config' will exit with a non-zero error code. An error message is produced if the file is unreadable, but not if it is missing."
msgstr "选项将从所有这些可用的文件中读取。如果全局或全系统的配置文件丢失或不可读，它们将被忽略。如果版本库的配置文件丢失或不可读，'git config' 将以非零的错误代码退出。如果文件不可读，会产生一个错误信息，但如果文件丢失，则不会产生错误信息。"

#. type: Plain text
#: en/git-config.txt:334
#, priority:100
msgid "The files are read in the order given above, with last value found taking precedence over values read earlier.  When multiple values are taken then all values of a key from all files will be used."
msgstr "文件是按照上述顺序读取的，最后发现的值优先于之前读取的值。 当有多个值时，将使用所有文件中某个键的所有值。"

#. type: Plain text
#: en/git-config.txt:338
#, priority:100
msgid "By default, options are only written to the repository specific configuration file. Note that this also affects options like `--replace-all` and `--unset`. *'git config' will only ever change one file at a time*."
msgstr "默认情况下，选项只被写入版本库特定的配置文件中。请注意，这也会影响到 `--replace-all` 和 `--unset` 等选项。*'git config' 一次只能改变一个文件*。"

#. type: Plain text
#: en/git-config.txt:343
#, priority:100
msgid "You can limit which configuration sources are read from or written to by specifying the path of a file with the `--file` option, or by specifying a configuration scope with `--system`, `--global`, `--local`, or `--worktree`.  For more, see <<OPTIONS>> above."
msgstr "你可以通过使用 `--file` 选项指定文件路径，或者使用 `--system`、`--global`、`--local` 或 `--worktree` 指定配置范围，来限制从哪些配置源读取或写入。 更多内容请参见上面的 <<OPTIONS>>。"

#. type: Title -
#: en/git-config.txt:346
#, no-wrap, priority:100
msgid "SCOPES"
msgstr "范围"

#. type: Plain text
#: en/git-config.txt:350
#, priority:100
msgid "Each configuration source falls within a configuration scope. The scopes are:"
msgstr "每个配置源都属于一个配置范围。这些范围包括："

#. type: Labeled list
#: en/git-config.txt:351
#, fuzzy, no-wrap, priority:100
#| msgid "--system"
msgid "system"
msgstr "--system"

#. type: Labeled list
#: en/git-config.txt:354
#, fuzzy, no-wrap, priority:100
#| msgid "--global"
msgid "global"
msgstr "--global"

#. type: Labeled list
#: en/git-config.txt:359
#, fuzzy, no-wrap, priority:100
#| msgid "--local"
msgid "local"
msgstr "--local"

#. type: Labeled list
#: en/git-config.txt:362
#, no-wrap, priority:100
msgid "worktree"
msgstr "工作区"

#. type: Labeled list
#: en/git-config.txt:365
#, fuzzy, no-wrap, priority:100
msgid "command"
msgstr "命令"

#. type: Plain text
#: en/git-config.txt:368
#, priority:100
msgid "GIT_CONFIG_{COUNT,KEY,VALUE} environment variables (see <<ENVIRONMENT>> below)"
msgstr "GIT_CONFIG_{COUNT,KEY,VALUE} 环境变量（见下文 <<ENVIRONMENT>>）"

#. type: Plain text
#: en/git-config.txt:370
#, fuzzy, priority:100
msgid "the `-c` option"
msgstr "和 `--date` 选项"

#. type: Plain text
#: en/git-config.txt:373
#, priority:100
msgid "With the exception of 'command', each scope corresponds to a command line option: `--system`, `--global`, `--local`, `--worktree`."
msgstr "除了 'command' 之外，每个范围都对应于一个命令行选项：`--system`、`--global`、`--local`、`--worktree`。"

#. type: Plain text
#: en/git-config.txt:378
#, priority:100
msgid "When reading options, specifying a scope will only read options from the files within that scope. When writing options, specifying a scope will write to the files within that scope (instead of the repository specific configuration file). See <<OPTIONS>> above for a complete description."
msgstr "当读取选项时，指定一个范围将只从该范围内的文件读取选项。当写选项时，指定一个范围将写到该范围内的文件（而不是仓库的特定配置文件）。参见上面的<<OPTIONS >>以获得完整的描述。"

#. type: Plain text
#: en/git-config.txt:382
#, priority:100
msgid "Most configuration options are respected regardless of the scope it is defined in, but some options are only respected in certain scopes. See the respective option's documentation for the full details."
msgstr "大多数配置选项无论在哪个作用域中定义都会被尊重，但有些选项只在某些作用域中被尊重。完整的细节请参见相应选项的文档。"

#. type: Title ~
#: en/git-config.txt:384
#, fuzzy, no-wrap, priority:100
msgid "Protected configuration"
msgstr "配置"

#. type: Plain text
#: en/git-config.txt:389
#, priority:100
msgid "Protected configuration refers to the 'system', 'global', and 'command' scopes.  For security reasons, certain options are only respected when they are specified in protected configuration, and ignored otherwise."
msgstr "受保护的配置指的是 'system'、'global' 和 'command' 范围。 出于安全考虑，某些选项只有在受保护的配置中指定时才会被尊重，否则会被忽略。"

#. type: Plain text
#: en/git-config.txt:394
#, priority:100
msgid "Git treats these scopes as if they are controlled by the user or a trusted administrator. This is because an attacker who controls these scopes can do substantial harm without using Git, so it is assumed that the user's environment protects these scopes against attackers."
msgstr "Git 将这些作用域视为由用户或可信的管理员控制。这是因为控制这些作用域的攻击者可以在不使用 Git 的情况下造成实质性的伤害，所以假定用户的环境会保护这些作用域免受攻击。"

#. type: Title -
#: en/git-config.txt:397 en/git-cvsserver.txt:308 en/git-daemon.txt:333 en/git-http-backend.txt:257 en/git-notes.txt:351 en/git-upload-pack.txt:51
#, no-wrap, priority:280
msgid "ENVIRONMENT"
msgstr "环境变量"

#. type: Labeled list
#: en/git-config.txt:399 en/git-var.txt:86
#, ignore-same, no-wrap, priority:100
msgid "GIT_CONFIG_GLOBAL"
msgstr "GIT_CONFIG_GLOBAL"

#. type: Labeled list
#: en/git-config.txt:400 en/git-var.txt:83
#, ignore-same, no-wrap, priority:100
msgid "GIT_CONFIG_SYSTEM"
msgstr "GIT_CONFIG_SYSTEM"

#. type: Plain text
#: en/git-config.txt:403
#, priority:100
msgid "Take the configuration from the given files instead from global or system-level configuration. See linkgit:git[1] for details."
msgstr "从给定的文件中获取配置，而不是从全局或系统级配置中获取。详情见 linkgit:git[1]。"

#. type: Labeled list
#: en/git-config.txt:404
#, ignore-same, no-wrap, priority:100
msgid "GIT_CONFIG_NOSYSTEM"
msgstr "GIT_CONFIG_NOSYSTEM"

#. type: Plain text
#: en/git-config.txt:407
#, priority:100
msgid "Whether to skip reading settings from the system-wide $(prefix)/etc/gitconfig file. See linkgit:git[1] for details."
msgstr "是否跳过从全系统 $(prefix)/etc/gitconfig 文件中读取设置。详见 linkgit:git[1]。"

#. type: Labeled list
#: en/git-config.txt:410
#, ignore-same, no-wrap, priority:100
msgid "GIT_CONFIG_COUNT"
msgstr "GIT_CONFIG_COUNT"

#. type: Labeled list
#: en/git-config.txt:411
#, fuzzy, no-wrap, priority:100
#| msgid "GIT_CONFIG"
msgid "GIT_CONFIG_KEY_<n>"
msgstr "GIT_CONFIG"

#. type: Labeled list
#: en/git-config.txt:412
#, fuzzy, no-wrap, priority:100
#| msgid "GIT_CONFIG"
msgid "GIT_CONFIG_VALUE_<n>"
msgstr "GIT_CONFIG"

#. type: Plain text
#: en/git-config.txt:421
#, priority:100
msgid "If GIT_CONFIG_COUNT is set to a positive number, all environment pairs GIT_CONFIG_KEY_<n> and GIT_CONFIG_VALUE_<n> up to that number will be added to the process's runtime configuration. The config pairs are zero-indexed. Any missing key or value is treated as an error. An empty GIT_CONFIG_COUNT is treated the same as GIT_CONFIG_COUNT=0, namely no pairs are processed. These environment variables will override values in configuration files, but will be overridden by any explicit options passed via `git -c`."
msgstr "如果 GIT_CONFIG_COUNT 被设置为一个正数，所有环境对 GIT_CONFIG_KEY_<n> 和 GIT_CONFIG_VALUE_<n> 到这个数字都将被添加到进程的运行时配置中。配置对是零索引的。任何缺失的键或值都被视为一个错误。空的 GIT_CONFIG_COUNT 与 GIT_CONFIG_COUNT=0 的处理方式相同，即不处理配置对。这些环境变量将覆盖配置文件中的值，但会被通过 `git -c` 传递的任何明确选项所覆盖。"

#. type: Plain text
#: en/git-config.txt:425
#, priority:100
msgid "This is useful for cases where you want to spawn multiple git commands with a common configuration but cannot depend on a configuration file, for example when writing scripts."
msgstr "这在你想用一个共同的配置催生多个 git 命令，但又不能依赖一个配置文件的情况下很有用，例如在编写脚本时。"

#. type: Labeled list
#: en/git-config.txt:426
#, ignore-same, no-wrap, priority:100
msgid "GIT_CONFIG"
msgstr "GIT_CONFIG"

#. type: Plain text
#: en/git-config.txt:432
#, priority:100
msgid "If no `--file` option is provided to `git config`, use the file given by `GIT_CONFIG` as if it were provided via `--file`. This variable has no effect on other Git commands, and is mostly for historical compatibility; there is generally no reason to use it instead of the `--file` option."
msgstr "如果 `git config` 没有提供 `--file` 选项，则使用 `GIT_CONFIG` 提供的文件，就像通过 `--file` 提供的一样。这个变量对其他 Git 命令没有影响，主要是为了历史兼容性；通常没有理由用它来代替 `--file` 选项。"

#. type: Plain text
#: en/git-config.txt:438
#, priority:100
msgid "Given a .git/config like this:"
msgstr "给出一个这样的 .git/config："

#. type: delimited block -
#: en/git-config.txt:445
#, no-wrap, priority:100
msgid ""
"#\n"
"# This is the config file, and\n"
"# a '#' or ';' character indicates\n"
"# a comment\n"
"#\n"
msgstr ""
"#\n"
"# 这就是配置文件，并且\n"
"# 一个'#'或';'字符表示\n"
"# 一个注释\n"
"#\n"

#. type: delimited block -
#: en/git-config.txt:450 en/git.txt:375
#, no-wrap, priority:100
msgid ""
"; core variables\n"
"[core]\n"
"\t; Don't trust file modes\n"
"\tfilemode = false\n"
msgstr ""
"; 核心变量\n"
"[core]\n"
"\t; 不信任文件模式\n"
"\tfilemode = false\n"

#. type: delimited block -
#: en/git-config.txt:455
#, no-wrap, priority:100
msgid ""
"; Our diff algorithm\n"
"[diff]\n"
"\texternal = /usr/local/bin/diff-wrapper\n"
"\trenames = true\n"
msgstr ""
"; 我们的差异算法\n"
"[diff]\n"
"\texternal = /usr/local/bin/diff-wrapper\n"
"\trename = true\n"

#. type: delimited block -
#: en/git-config.txt:460
#, no-wrap, priority:100
msgid ""
"; Proxy settings\n"
"[core]\n"
"\tgitproxy=proxy-command for kernel.org\n"
"\tgitproxy=default-proxy ; for all the rest\n"
msgstr ""
"; 代理设置\n"
"[core]\n"
"\tgitproxy=proxy-command for kernel.org\n"
"\tgitproxy=default-proxy ; 适用于其他所有网站\n"

#. type: delimited block -
#: en/git-config.txt:467
#, no-wrap, priority:100
msgid ""
"; HTTP\n"
"[http]\n"
"\tsslVerify\n"
"[http \"https://weak.example.com\"]\n"
"\tsslVerify = false\n"
"\tcookieFile = /tmp/cookie.txt\n"
msgstr ""
"; HTTP\n"
"[http]\n"
"\tsslVerify\n"
"[http \"https://weak.example.com\"]\n"
"\tsslVerify = false\n"
"\tcookiFile= /tmp/cookie.txt\n"

#. type: Plain text
#: en/git-config.txt:470
#, priority:100
msgid "you can set the filemode to true with"
msgstr "你可以用以下方法将文件模式设置为真"

#. type: delimited block -
#: en/git-config.txt:473
#, fuzzy, no-wrap, priority:100
msgid "% git config core.filemode true\n"
msgstr "% git config core.filemode true\n"

#. type: Plain text
#: en/git-config.txt:478
#, priority:100
msgid "The hypothetical proxy command entries actually have a postfix to discern what URL they apply to. Here is how to change the entry for kernel.org to \"ssh\"."
msgstr "假设的代理命令条目实际上有一个后缀来辨别它们适用于什么URL。下面是如何将 kernel.org 的条目改为 \"ssh\"。"

#. type: delimited block -
#: en/git-config.txt:481
#, fuzzy, no-wrap, priority:100
msgid "% git config core.gitproxy '\"ssh\" for kernel.org' 'for kernel.org$'\n"
msgstr "% git config core.gitproxy '\"ssh\" for kernel.org' 'for kernel.org$'\n"

#. type: Plain text
#: en/git-config.txt:484
#, priority:100
msgid "This makes sure that only the key/value pair for kernel.org is replaced."
msgstr "这确保了只有 kernel.org 的键/值对被替换。"

#. type: Plain text
#: en/git-config.txt:486
#, priority:100
msgid "To delete the entry for renames, do"
msgstr "要删除重名的条目，请执行"

#. type: delimited block -
#: en/git-config.txt:489
#, fuzzy, no-wrap, priority:100
msgid "% git config --unset diff.renames\n"
msgstr "% git config --unset diff.renames\n"

#. type: Plain text
#: en/git-config.txt:493
#, priority:100
msgid "If you want to delete an entry for a multivar (like core.gitproxy above), you have to provide a regex matching the value of exactly one line."
msgstr "如果你想删除一个多变量的条目（如上面的 core.gitproxy），你必须提供一个与恰好一行的值相匹配的正则表达式。"

#. type: Plain text
#: en/git-config.txt:495
#, priority:100
msgid "To query the value for a given key, do"
msgstr "要查询一个给定键的值，请做"

#. type: delimited block -
#: en/git-config.txt:498
#, fuzzy, no-wrap, priority:100
msgid "% git config --get core.filemode\n"
msgstr "% git config --get core.filemode\n"

#. type: Plain text
#: en/git-config.txt:501 en/git-merge-index.txt:66
#, fuzzy, priority:100
msgid "or"
msgstr "或"

#. type: delimited block -
#: en/git-config.txt:504
#, fuzzy, no-wrap, priority:100
msgid "% git config core.filemode\n"
msgstr "% git config core.filemode\n"

#. type: Plain text
#: en/git-config.txt:507
#, priority:100
msgid "or, to query a multivar:"
msgstr "或者，要查询一个多变量："

#. type: delimited block -
#: en/git-config.txt:510
#, fuzzy, no-wrap, priority:100
msgid "% git config --get core.gitproxy \"for kernel.org$\"\n"
msgstr "% git config --get core.gitproxy \"for kernel.org$\"\n"

#. type: Plain text
#: en/git-config.txt:513
#, priority:100
msgid "If you want to know all the values for a multivar, do:"
msgstr "如果你想知道一个多变量的所有值，请做："

#. type: delimited block -
#: en/git-config.txt:516
#, fuzzy, no-wrap, priority:100
msgid "% git config --get-all core.gitproxy\n"
msgstr "% git config --get-all core.gitproxy\n"

#. type: Plain text
#: en/git-config.txt:520
#, priority:100
msgid "If you like to live dangerously, you can replace *all* core.gitproxy by a new one with"
msgstr "如果你喜欢危险的生活，你可以用一个新的核心.gitproxy来取代 *所有* 的核心 .gitproxy，用的是"

#. type: delimited block -
#: en/git-config.txt:523
#, fuzzy, no-wrap, priority:100
msgid "% git config --replace-all core.gitproxy ssh\n"
msgstr "% git config --replace-all core.gitproxy ssh\n"

#. type: Plain text
#: en/git-config.txt:527
#, ignore-ellipsis, priority:100
msgid "However, if you really only want to replace the line for the default proxy, i.e. the one without a \"for ...\" postfix, do something like this:"
msgstr "然而，如果你真的只想替换默认代理，即没有 \"for ...\" 后缀的那一行，可以这样做："

#. type: delimited block -
#: en/git-config.txt:530
#, fuzzy, no-wrap, priority:100
msgid "% git config core.gitproxy ssh '! for '\n"
msgstr "% git config core.gitproxy ssh '! for '\n"

#. type: Plain text
#: en/git-config.txt:533
#, priority:100
msgid "To actually match only values with an exclamation mark, you have to"
msgstr "为了真正地只匹配带有感叹号的值，你必须"

#. type: delimited block -
#: en/git-config.txt:536
#, fuzzy, no-wrap, priority:100
msgid "% git config section.key value '[!]'\n"
msgstr "% git config section.key value '[!]'\n"

#. type: Plain text
#: en/git-config.txt:539
#, priority:100
msgid "To add a new proxy, without altering any of the existing ones, use"
msgstr "要添加一个新的代理，而不改变任何现有的代理，使用"

#. type: delimited block -
#: en/git-config.txt:542
#, fuzzy, no-wrap, priority:100
msgid "% git config --add core.gitproxy '\"proxy-command\" for example.com'\n"
msgstr "% git config --add core.gitproxy '\"proxy-command\" for example.com'\n"

#. type: Plain text
#: en/git-config.txt:546
#, priority:100
msgid "An example to use customized color from the configuration in your script:"
msgstr "一个例子是在你的脚本中使用配置的自定义颜色："

#. type: delimited block -
#: en/git-config.txt:552
#, fuzzy, no-wrap, priority:100
msgid ""
"#!/bin/sh\n"
"WS=$(git config --get-color color.diff.whitespace \"blue reverse\")\n"
"RESET=$(git config --get-color \"\" \"reset\")\n"
"echo \"${WS}your whitespace color or blue reverse${RESET}\"\n"
msgstr ""
"#!/bin/sh\n"
"WS=$(git config --get-color color.diff.whitespace \"blue reverse\")\n"
"RESET=$(git config --get-color \"\" \"reset\")\n"
"echo \"${WS}your whitespace color or blue reverse${RESET}\"\n"

#. type: Plain text
#: en/git-config.txt:556
#, priority:100
msgid "For URLs in `https://weak.example.com`, `http.sslVerify` is set to false, while it is set to `true` for all others:"
msgstr "对于 `https://weak.example.com` 中的 URL，`http.sslVerify` 被设置为 false，而对于所有其他的 URL，它被设置为 `true`："

#. type: delimited block -
#: en/git-config.txt:565
#, no-wrap, priority:100
msgid ""
"% git config --type=bool --get-urlmatch http.sslverify https://good.example.com\n"
"true\n"
"% git config --type=bool --get-urlmatch http.sslverify https://weak.example.com\n"
"false\n"
"% git config --get-urlmatch http https://weak.example.com\n"
"http.cookieFile /tmp/cookie.txt\n"
"http.sslverify false\n"
msgstr ""
"% git config --type=bool --get-urlmatch http.sslverify https://good.example.com\n"
"true\n"
"% git config --type=bool --get-urlmatch http.sslverify https://weak.example.com\n"
"false\n"
"% git config --get-urlmatch http https://weak.example.com\n"
"http.cookieFile /tmp/cookie.txt\n"
"http.sslverify false\n"

#. type: Title -
#: en/git-config.txt:570 en/git-describe.txt:202 en/git-fetch.txt:305 en/git-mv.txt:56 en/git-pack-refs.txt:87 en/git-pull.txt:240 en/git-replace.txt:139 en/git-rm.txt:190 en/git-svn.txt:1150 en/git-worktree.txt:513
#, no-wrap, priority:280
msgid "BUGS"
msgstr "漏洞"

#. type: Plain text
#: en/git-config.txt:575
#, priority:100
msgid "When using the deprecated `[section.subsection]` syntax, changing a value will result in adding a multi-line key instead of a change, if the subsection is given with at least one uppercase character. For example when the config looks like"
msgstr "当使用废弃的 `[section.subsection]` 语法时，如果 subsection 至少有一个大写字母，改变一个值将导致添加一个多行键而不是改变。例如，当配置看起来像"

#. type: delimited block -
#: en/git-config.txt:579
#, fuzzy, no-wrap, priority:100
msgid ""
"  [section.subsection]\n"
"    key = value1\n"
msgstr ""
"  [section.subsection]\n"
"    key = value1\n"

#. type: Plain text
#: en/git-config.txt:582
#, priority:100
msgid "and running `git config section.Subsection.key value2` will result in"
msgstr "并运行 `git config section.Subsection.key value2` 将导致"

#. type: delimited block -
#: en/git-config.txt:587
#, no-wrap, priority:100
msgid ""
"  [section.subsection]\n"
"    key = value1\n"
"    key = value2\n"
msgstr ""
"  [section.subsection]\n"
"    key = value1\n"
"    key = value2\n"

#. type: Title =
#: en/git-count-objects.txt:2
#, ignore-same, no-wrap, priority:80
msgid "git-count-objects(1)"
msgstr "git-count-objects(1)"

#. type: Plain text
#: en/git-count-objects.txt:7
#, priority:80
msgid "git-count-objects - Count unpacked number of objects and their disk consumption"
msgstr ""

#. type: Plain text
#: en/git-count-objects.txt:12
#, fuzzy, no-wrap, priority:80
msgid "'git count-objects' [-v] [-H | --human-readable]\n"
msgstr "'git count-objects' [-v] [-H | --human-readable]\n"

#. type: Plain text
#: en/git-count-objects.txt:17
#, priority:80
msgid "This counts the number of unpacked object files and disk space consumed by them, to help you decide when it is a good time to repack."
msgstr ""

#. type: Plain text
#: en/git-count-objects.txt:24
#, priority:80
msgid "Report in more detail:"
msgstr ""

#. type: Plain text
#: en/git-count-objects.txt:26
#, priority:80
msgid "count: the number of loose objects"
msgstr ""

#. type: Plain text
#: en/git-count-objects.txt:28
#, priority:80
msgid "size: disk space consumed by loose objects, in KiB (unless -H is specified)"
msgstr ""

#. type: Plain text
#: en/git-count-objects.txt:30
#, priority:80
msgid "in-pack: the number of in-pack objects"
msgstr ""

#. type: Plain text
#: en/git-count-objects.txt:32
#, priority:80
msgid "size-pack: disk space consumed by the packs, in KiB (unless -H is specified)"
msgstr ""

#. type: Plain text
#: en/git-count-objects.txt:35
#, priority:80
msgid "prune-packable: the number of loose objects that are also present in the packs. These objects could be pruned using `git prune-packed`."
msgstr ""

#. type: Plain text
#: en/git-count-objects.txt:38
#, priority:80
msgid "garbage: the number of files in object database that are neither valid loose objects nor valid packs"
msgstr ""

#. type: Plain text
#: en/git-count-objects.txt:41
#, priority:80
msgid "size-garbage: disk space consumed by garbage files, in KiB (unless -H is specified)"
msgstr ""

#. type: Plain text
#: en/git-count-objects.txt:46
#, priority:80
msgid "alternate: absolute path of alternate object databases; may appear multiple times, one line per path. Note that if the path contains non-printable characters, it may be surrounded by double-quotes and contain C-style backslashed escape sequences."
msgstr ""

#. type: Labeled list
#: en/git-count-objects.txt:47 en/git-cvsserver.txt:61 en/git-grep.txt:115
#, fuzzy, no-wrap, priority:100
msgid "-H"
msgstr "-H"

#. type: Labeled list
#: en/git-count-objects.txt:48
#, ignore-same, no-wrap, priority:80
msgid "--human-readable"
msgstr "--human-readable"

#. type: Plain text
#: en/git-count-objects.txt:51
#, priority:80
msgid "Print sizes in human readable format"
msgstr "以人类可读的格式打印对象大小"

#. type: Title =
#: en/git-credential-cache--daemon.txt:2
#, fuzzy, no-wrap, priority:90
#| msgid "git-credential-cache--daemon(1)"
msgid "git-credential-cache{litdd}daemon(1)"
msgstr "git-credential-cache--daemon(1)"

#. type: Plain text
#: en/git-credential-cache--daemon.txt:7
#, priority:90
msgid "git-credential-cache--daemon - Temporarily store user credentials in memory"
msgstr ""

#. type: Plain text
#: en/git-credential-cache--daemon.txt:12
#, fuzzy, no-wrap, priority:90
#| msgid "git-credential-cache--daemon(1)"
msgid "'git credential-cache{litdd}daemon' [--debug] <socket-path>\n"
msgstr "'git credential-cache{litdd}daemon' [--debug] <socket-path>\n"

#. type: Plain text
#: en/git-credential-cache--daemon.txt:18
#, priority:90
msgid "You probably don't want to invoke this command yourself; it is started automatically when you use linkgit:git-credential-cache[1]."
msgstr ""

#. type: Plain text
#: en/git-credential-cache--daemon.txt:23
#, priority:90
msgid "This command listens on the Unix domain socket specified by `<socket-path>` for `git-credential-cache` clients. Clients may store and retrieve credentials. Each credential is held for a timeout specified by the client; once no credentials are held, the daemon exits."
msgstr ""

#. type: Plain text
#: en/git-credential-cache--daemon.txt:27
#, priority:90
msgid "If the `--debug` option is specified, the daemon does not close its stderr stream, and may output extra diagnostics to it even after it has begun listening for clients."
msgstr ""

#. type: Title =
#: en/git-credential-cache.txt:2
#, ignore-same, no-wrap, priority:90
msgid "git-credential-cache(1)"
msgstr "git-credential-cache(1)"

#. type: Plain text
#: en/git-credential-cache.txt:7
#, fuzzy, priority:90
msgid "git-credential-cache - Helper to temporarily store passwords in memory"
msgstr "git-credential-cache - Helper to temporarily store passwords in memory"

#. type: delimited block -
#: en/git-credential-cache.txt:12
#, no-wrap, priority:90
msgid "git config credential.helper 'cache [<options>]'\n"
msgstr ""

#. type: Plain text
#: en/git-credential-cache.txt:24
#, priority:90
msgid "This command caches credentials for use by future Git programs.  The stored credentials are kept in memory of the cache-daemon process (instead of written to a file) and are forgotten after a configurable timeout. Credentials are forgotten sooner if the cache-daemon dies, for example if the system restarts. The cache is accessible over a Unix domain socket, restricted to the current user by filesystem permissions."
msgstr ""

#. type: Plain text
#: en/git-credential-cache.txt:28
#, priority:90
msgid "You probably don't want to invoke this command directly; it is meant to be used as a credential helper by other parts of Git. See linkgit:gitcredentials[7] or `EXAMPLES` below."
msgstr ""

#. type: Labeled list
#: en/git-credential-cache.txt:32
#, fuzzy, no-wrap, priority:90
msgid "--timeout <seconds>"
msgstr "--timeout <seconds>"

#. type: Plain text
#: en/git-credential-cache.txt:35
#, priority:90
msgid "Number of seconds to cache credentials (default: 900)."
msgstr ""

#. type: Labeled list
#: en/git-credential-cache.txt:36
#, no-wrap, priority:90
msgid "--socket <path>"
msgstr ""

#. type: Plain text
#: en/git-credential-cache.txt:46
#, priority:90
msgid "Use `<path>` to contact a running cache daemon (or start a new cache daemon if one is not started).  Defaults to `$XDG_CACHE_HOME/git/credential/socket` unless `~/.git-credential-cache/` exists in which case `~/.git-credential-cache/socket` is used instead.  If your home directory is on a network-mounted filesystem, you may need to change this to a local filesystem. You must specify an absolute path."
msgstr ""

#. type: Title -
#: en/git-credential-cache.txt:48
#, no-wrap, priority:90
msgid "CONTROLLING THE DAEMON"
msgstr ""

#. type: Plain text
#: en/git-credential-cache.txt:52
#, priority:90
msgid "If you would like the daemon to exit early, forgetting all cached credentials before their timeout, you can issue an `exit` action:"
msgstr ""

#. type: delimited block -
#: en/git-credential-cache.txt:55
#, no-wrap, priority:90
msgid "git credential-cache exit\n"
msgstr ""

#. type: Plain text
#: en/git-credential-cache.txt:62 en/git-credential-store.txt:75
#, priority:100
msgid "The point of this helper is to reduce the number of times you must type your username or password. For example:"
msgstr "这个助手的意义在于减少你必须输入用户名或密码的次数。比如说："

#. type: delimited block -
#: en/git-credential-cache.txt:68
#, no-wrap, priority:90
msgid ""
"$ git config credential.helper cache\n"
"$ git push http://example.com/repo.git\n"
"Username: <type your username>\n"
"Password: <type your password>\n"
msgstr ""

#. type: delimited block -
#: en/git-credential-cache.txt:72
#, fuzzy, no-wrap, priority:90
msgid ""
"[work for 5 more minutes]\n"
"$ git push http://example.com/repo.git\n"
"[your credentials are used automatically]\n"
msgstr ""
"[work for 5 more minutes]\n"
"$ git push http://example.com/repo.git\n"
"[your credentials are used automatically]\n"

#. type: Plain text
#: en/git-credential-cache.txt:76
#, priority:90
msgid "You can provide options via the credential.helper configuration variable (this example increases the cache time to 1 hour):"
msgstr ""

#. type: delimited block -
#: en/git-credential-cache.txt:79
#, fuzzy, no-wrap, priority:90
msgid "$ git config credential.helper 'cache --timeout=3600'\n"
msgstr "$ git config credential.helper 'cache --timeout=300'\n"

#. type: Title =
#: en/git-credential-store.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-credential-store(1)"
msgstr "git-credential-store(1)"

#. type: Plain text
#: en/git-credential-store.txt:7
#, fuzzy, priority:100
msgid "git-credential-store - Helper to store credentials on disk"
msgstr "git-credential-store - Helper to store credentials on disk"

#. type: delimited block -
#: en/git-credential-store.txt:12
#, no-wrap, priority:100
msgid "git config credential.helper 'store [<options>]'\n"
msgstr "git config credential.helper 'store [<选项>]'\n"

#. type: Plain text
#: en/git-credential-store.txt:21
#, priority:100
msgid "Using this helper will store your passwords unencrypted on disk, protected only by filesystem permissions. If this is not an acceptable security tradeoff, try linkgit:git-credential-cache[1], or find a helper that integrates with secure storage provided by your operating system."
msgstr "使用这个助手会将你的密码未加密地存储在磁盘上，只受文件系统权限的保护。如果这不是一个可接受的安全权衡，请尝试 linkgit:git-credential-cache[1]，或者找一个能与你的操作系统提供的安全存储整合的助手。"

#. type: Plain text
#: en/git-credential-store.txt:24
#, priority:100
msgid "This command stores credentials indefinitely on disk for use by future Git programs."
msgstr "该命令在磁盘上无限期地存储凭证，供未来的 Git 程序使用。"

#. type: Plain text
#: en/git-credential-store.txt:28
#, priority:100
msgid "You probably don't want to invoke this command directly; it is meant to be used as a credential helper by other parts of git. See linkgit:gitcredentials[7] or `EXAMPLES` below."
msgstr "你可能不想直接调用这个命令；它是作为 git 其他部分的凭证助手来使用的。参见 linkgit:gitcredentials[7] 或下面的 `EXAMPLES`。"

#. type: Labeled list
#: en/git-credential-store.txt:32
#, no-wrap, priority:100
msgid "--file=<path>"
msgstr "--file=<路径>"

#. type: Plain text
#: en/git-credential-store.txt:42
#, priority:100
msgid "Use `<path>` to lookup and store credentials. The file will have its filesystem permissions set to prevent other users on the system from reading it, but will not be encrypted or otherwise protected. If not specified, credentials will be searched for from `~/.git-credentials` and `$XDG_CONFIG_HOME/git/credentials`, and credentials will be written to `~/.git-credentials` if it exists, or `$XDG_CONFIG_HOME/git/credentials` if it exists and the former does not. See also <<FILES>>."
msgstr "使用 `<路径>` 来查询和存储证书。该文件将设置其文件系统权限，以防止系统中的其他用户读取它，但不会被加密或其他保护。如果没有指定，将从 `~/.git-credentials` 和 `$XDG_CONFIG_HOME/git/credentials` 中搜索证书，如果证书存在，将被写入 `~/.git-credentials`，如果证书存在而前者不存在，则写入 `$XDG_CONFIG_HOME/git/credentials`。参见 <<FILES>>。"

#. type: Plain text
#: en/git-credential-store.txt:49
#, priority:100
msgid "If not set explicitly with `--file`, there are two files where git-credential-store will search for credentials in order of precedence:"
msgstr "如果没有用 `--file` 明确设置，有两个文件，git-credential-store 将按照优先顺序搜索证书："

#. type: Labeled list
#: en/git-credential-store.txt:50
#, fuzzy, no-wrap, priority:100
msgid "~/.git-credentials"
msgstr "~/.git-credentials"

#. type: Plain text
#: en/git-credential-store.txt:52
#, priority:100
msgid "User-specific credentials file."
msgstr "用户特定的凭证文件。"

#. type: Labeled list
#: en/git-credential-store.txt:53
#, no-wrap, priority:100
msgid "$XDG_CONFIG_HOME/git/credentials"
msgstr "$XDG_CONFIG_HOME/git/credentials"

#. type: Plain text
#: en/git-credential-store.txt:59
#, priority:100
msgid "Second user-specific credentials file. If '$XDG_CONFIG_HOME' is not set or empty, `$HOME/.config/git/credentials` will be used. Any credentials stored in this file will not be used if `~/.git-credentials` has a matching credential as well. It is a good idea not to create this file if you sometimes use older versions of Git that do not support it."
msgstr "第二个用户专用的证书文件。如果 '$XDG_CONFIG_HOME' 没有设置或为空，`$HOME/.config/git/credentials` 将被使用。如果 `~/.git-credentials` 也有匹配的凭证，那么存储在该文件中的任何凭证将不会被使用。如果你有时使用不支持该文件的旧版本的 Git，那么不创建该文件是个好主意。"

#. type: Plain text
#: en/git-credential-store.txt:63
#, priority:100
msgid "For credential lookups, the files are read in the order given above, with the first matching credential found taking precedence over credentials found in files further down the list."
msgstr "对于凭证查询，文件按上述顺序读取，发现的第一个匹配凭证优先于在列表后面的文件中发现的凭证。"

#. type: Plain text
#: en/git-credential-store.txt:67
#, priority:100
msgid "Credential storage will by default write to the first existing file in the list. If none of these files exist, `~/.git-credentials` will be created and written to."
msgstr "凭证存储将默认写到列表中的第一个现有文件。如果这些文件都不存在，`~/.git-credentials` 将被创建并写入。"

#. type: Plain text
#: en/git-credential-store.txt:69
#, priority:100
msgid "When erasing credentials, matching credentials will be erased from all files."
msgstr "擦除证书时，匹配的证书将从所有文件中擦除。"

#. type: delimited block -
#: en/git-credential-store.txt:81
#, fuzzy, no-wrap, priority:100
msgid ""
"$ git config credential.helper store\n"
"$ git push http://example.com/repo.git\n"
"Username: <type your username>\n"
"Password: <type your password>\n"
msgstr ""
"$ git config credential.helper store\n"
"$ git push http://example.com/repo.git\n"
"Username: <type your username>\n"
"Password: <type your password>\n"

#. type: delimited block -
#: en/git-credential-store.txt:85
#, fuzzy, no-wrap, priority:100
msgid ""
"[several days later]\n"
"$ git push http://example.com/repo.git\n"
"[your credentials are used automatically]\n"
msgstr ""
"[several days later]\n"
"$ git push http://example.com/repo.git\n"
"[your credentials are used automatically]\n"

#. type: Title -
#: en/git-credential-store.txt:88
#, no-wrap, priority:100
msgid "STORAGE FORMAT"
msgstr "存储格式"

#. type: Plain text
#: en/git-credential-store.txt:92
#, priority:100
msgid "The `.git-credentials` file is stored in plaintext. Each credential is stored on its own line as a URL like:"
msgstr "`.git-credentials` 文件是以明文存储的。每个凭证都以 URL 的形式存储在自己的一行中，比如："

#. type: delimited block -
#: en/git-credential-store.txt:95
#, fuzzy, no-wrap, priority:100
msgid "https://user:pass@example.com\n"
msgstr "https://user:pass@example.com\n"

#. type: Plain text
#: en/git-credential-store.txt:100
#, priority:100
msgid "No other kinds of lines (e.g. empty lines or comment lines) are allowed in the file, even though some may be silently ignored. Do not view or edit the file with editors."
msgstr "文件中不允许有其他类型的行（如空行或注释行），尽管有些行可能被默默地忽略了。不要用编辑器查看或编辑该文件。"

#. type: Plain text
#: en/git-credential-store.txt:107
#, priority:100
msgid "When Git needs authentication for a particular URL context, credential-store will consider that context a pattern to match against each entry in the credentials file.  If the protocol, hostname, and username (if we already have one) match, then the password is returned to Git. See the discussion of configuration in linkgit:gitcredentials[7] for more information."
msgstr "当 Git 需要对某个特定的 URL 上下文进行认证时，credential-store 会将该上下文视为一种模式，与凭证文件中的每个条目进行匹配。 如果协议、主机名和用户名（如果我们已经有了）相匹配，那么密码就会返回给 Git。更多信息见 linkgit:gitcredentials[7] 中关于配置的讨论。"

#. type: Title =
#: en/git-credential.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-credential(1)"
msgstr "git-credential(1)"

#. type: Plain text
#: en/git-credential.txt:7
#, priority:100
msgid "git-credential - Retrieve and store user credentials"
msgstr "git-credential - 检索和存储用户证书"

#. type: delimited block -
#: en/git-credential.txt:12
#, no-wrap, priority:100
msgid "'git credential' (fill|approve|reject)\n"
msgstr "'git credential' (fill|approve|reject)\n"

#. type: Plain text
#: en/git-credential.txt:24
#, priority:100
msgid "Git has an internal interface for storing and retrieving credentials from system-specific helpers, as well as prompting the user for usernames and passwords. The git-credential command exposes this interface to scripts which may want to retrieve, store, or prompt for credentials in the same manner as Git. The design of this scriptable interface models the internal C API; see credential.h for more background on the concepts."
msgstr "Git 有一个内部接口，用于存储和检索来自系统特定帮助器的凭证，以及提示用户输入用户名和密码。git-credential 命令将这个接口暴露给脚本，这些脚本可能希望以与 Git 相同的方式检索、存储或提示凭证。这个脚本接口的设计仿照了内部的 C 语言应用程序接口；更多概念的背景见 credential.h。"

#. type: Plain text
#: en/git-credential.txt:28
#, fuzzy, priority:100
msgid "git-credential takes an \"action\" option on the command-line (one of `fill`, `approve`, or `reject`) and reads a credential description on stdin (see <<IOFMT,INPUT/OUTPUT FORMAT>>)."
msgstr "git-credential takes an \"action\" option on the command-line (one of `fill`, `approve`, or `reject`) and reads a credential description on stdin (see <<IOFMT,INPUT/OUTPUT FORMAT>>)."

#. type: Plain text
#: en/git-credential.txt:35
#, priority:100
msgid "If the action is `fill`, git-credential will attempt to add \"username\" and \"password\" attributes to the description by reading config files, by contacting any configured credential helpers, or by prompting the user. The username and password attributes of the credential description are then printed to stdout together with the attributes already provided."
msgstr "如果动作是 `fill`，git-credential 将尝试通过读取配置文件、联系任何已配置的凭证助手或提示用户来向描述中添加 “用户名” 和 “密码” 属性。然后，凭证描述中的用户名和密码属性会和已经提供的属性一起打印到标准输出流。"

#. type: Plain text
#: en/git-credential.txt:39
#, priority:100
msgid "If the action is `approve`, git-credential will send the description to any configured credential helpers, which may store the credential for later use."
msgstr "如果动作是 `approve`，git-credential 将把描述发送给任何配置的凭证助手，它们可以存储凭证供以后使用。"

#. type: Plain text
#: en/git-credential.txt:43
#, fuzzy, priority:100
#| msgid "If the action is `reject`, git-credential will send the description to any configured credential helpers, which may erase any stored credential matching the description."
msgid "If the action is `reject`, git-credential will send the description to any configured credential helpers, which may erase any stored credentials matching the description."
msgstr "如果动作是 `reject`，git-credential 将把描述发送到任何配置的凭证助手，这可能会删除任何与描述相匹配的存储凭证。"

#. type: Plain text
#: en/git-credential.txt:45
#, priority:100
msgid "If the action is `approve` or `reject`, no output should be emitted."
msgstr "如果动作是 `approve` 或 `reject`，就不应该有输出。"

#. type: Title -
#: en/git-credential.txt:47
#, no-wrap, priority:100
msgid "TYPICAL USE OF GIT CREDENTIAL"
msgstr "git 凭证的典型用途"

#. type: Plain text
#: en/git-credential.txt:51
#, priority:100
msgid "An application using git-credential will typically use `git credential` following these steps:"
msgstr "使用 git-credential 的应用程序通常会按照以下步骤使用 `git credential`："

#. type: Plain text
#: en/git-credential.txt:53
#, priority:100
msgid "Generate a credential description based on the context."
msgstr "根据上下文生成一个凭证描述。"

#. type: Plain text
#: en/git-credential.txt:59
#, priority:100
msgid "For example, if we want a password for `https://example.com/foo.git`, we might generate the following credential description (don't forget the blank line at the end; it tells `git credential` that the application finished feeding all the information it has):"
msgstr "例如，如果我们想要一个 `https://example.com/foo.git` 的密码，我们可能会生成下面的凭证描述（别忘了最后的空行；它告诉 `git credential`，应用程序已经完成了所有信息的输入）："

#. type: Plain text
#: en/git-credential.txt:63
#, no-wrap, priority:100
msgid ""
"\t protocol=https\n"
"\t host=example.com\n"
"\t path=foo.git\n"
msgstr ""
"\t protocol=https\n"
"\t host=example.com\n"
"\t path=foo.git\n"

#. type: Plain text
#: en/git-credential.txt:69
#, priority:100
msgid "Ask git-credential to give us a username and password for this description. This is done by running `git credential fill`, feeding the description from step (1) to its standard input. The complete credential description (including the credential per se, i.e. the login and password) will be produced on standard output, like:"
msgstr "要求 git-credential 为这个描述提供一个用户名和密码。这可以通过运行 `git credential fill` 来实现，将步骤（1）中的描述输入到其标准输入中。完整的凭证描述（包括凭证本身，即登录名和密码）将在标准输出中产生，比如："

#. type: Plain text
#: en/git-credential.txt:74
#, no-wrap, priority:100
msgid ""
"protocol=https\n"
"host=example.com\n"
"username=bob\n"
"password=secr3t\n"
msgstr ""
"protocol=https\n"
"host=example.com\n"
"username=bob\n"
"password=secr3t\n"

#. type: Plain text
#: en/git-credential.txt:79
#, priority:100
msgid "In most cases, this means the attributes given in the input will be repeated in the output, but Git may also modify the credential description, for example by removing the `path` attribute when the protocol is HTTP(s) and `credential.useHttpPath` is false."
msgstr "在大多数情况下，这意味着输入中给出的属性将在输出中重复出现，但Git也可以修改凭证描述，例如，当协议是HTTP(s)且 `credential.useHttpPath` 为假时，删除 `path` 属性。"

#. type: Plain text
#: en/git-credential.txt:85
#, priority:100
msgid "If the `git credential` knew about the password, this step may not have involved the user actually typing this password (the user may have typed a password to unlock the keychain instead, or no user interaction was done if the keychain was already unlocked) before it returned `password=secr3t`."
msgstr "如果`git credential` 知道密码，在返回 `password=secr3t` 之前，这一步可能不涉及用户实际输入这个密码（用户可能输入了一个密码来代替解锁钥匙串，或者如果钥匙串已经被解锁，则没有进行用户交互）。"

#. type: Plain text
#: en/git-credential.txt:88
#, priority:100
msgid "Use the credential (e.g., access the URL with the username and password from step (2)), and see if it's accepted."
msgstr "使用该证书（例如，用步骤（2）中的用户名和密码访问 URL），看看是否被接受。"

#. type: Plain text
#: en/git-credential.txt:98
#, priority:100
msgid "Report on the success or failure of the password. If the credential allowed the operation to complete successfully, then it can be marked with an \"approve\" action to tell `git credential` to reuse it in its next invocation. If the credential was rejected during the operation, use the \"reject\" action so that `git credential` will ask for a new password in its next invocation. In either case, `git credential` should be fed with the credential description obtained from step (2) (which also contain the ones provided in step (1))."
msgstr "报告密码的成功或失败。如果凭证允许操作成功完成，那么可以用 \"approve\" 动作标记，告诉 `git credential` 在下一次调用中重新使用它。如果操作过程中证书被拒绝，使用 \"reject\" 动作，这样 `git credential` 将在下一次调用中要求一个新的密码。在这两种情况下，`git credential` 应该被输入从步骤 (2) 中获得的凭证描述（其中也包含步骤(1)中提供的描述）。"

#. type: Title -
#: en/git-credential.txt:101
#, no-wrap, priority:100
msgid "INPUT/OUTPUT FORMAT"
msgstr "输入/输出格式"

#. type: Plain text
#: en/git-credential.txt:108
#, priority:100
msgid "`git credential` reads and/or writes (depending on the action used)  credential information in its standard input/output. This information can correspond either to keys for which `git credential` will obtain the login information (e.g. host, protocol, path), or to the actual credential data to be obtained (username/password)."
msgstr "`git credential` 在其标准输入/输出中读取和/或写入（取决于使用的操作）凭证信息。这些信息可以对应于 `git credential` 将获得登录信息的键（如主机、协议、路径），或者对应于要获得的实际凭证数据（用户名/密码）。"

#. type: Plain text
#: en/git-credential.txt:112
#, priority:100
msgid "The credential is split into a set of named attributes, with one attribute per line. Each attribute is specified by a key-value pair, separated by an `=` (equals) sign, followed by a newline."
msgstr "凭证被分割成一组命名的属性，每行一个属性。每个属性由一个键值对指定，用一个 `=`（等号）分隔，后面是换行。"

#. type: Plain text
#: en/git-credential.txt:115
#, priority:100
msgid "The key may contain any bytes except `=`, newline, or NUL. The value may contain any bytes except newline or NUL."
msgstr "键可以包含任何字节，除了 `=`、换行或 NUL。值可以包含除换行或 NUL 之外的任何字节。"

#. type: Plain text
#: en/git-credential.txt:121
#, priority:100
msgid "Attributes with keys that end with C-style array brackets `[]` can have multiple values. Each instance of a multi-valued attribute forms an ordered list of values - the order of the repeated attributes defines the order of the values. An empty multi-valued attribute (`key[]=\\n`)  acts to clear any previous entries and reset the list."
msgstr "键值以 C 型数组括号 `[]` 结尾的属性可以有多个值。一个多值属性的每个实例形成一个有序的值列表--重复属性的顺序决定了值的顺序。一个空的多值属性（`key[]=\\n`）的作用是清除之前的任何条目并重置列表。"

#. type: Plain text
#: en/git-credential.txt:125
#, priority:100
msgid "In all cases, all bytes are treated as-is (i.e., there is no quoting, and one cannot transmit a value with newline or NUL in it). The list of attributes is terminated by a blank line or end-of-file."
msgstr "在所有情况下，所有字节都按原样处理（即没有引号，也不能传输带有换行或NUL的值）。属性列表以空行或文件结束来结束。"

#. type: Plain text
#: en/git-credential.txt:127
#, fuzzy, priority:100
#| msgid "support the following date formats:"
msgid "Git understands the following attributes:"
msgstr "支持以下日期格式："

#. type: Labeled list
#: en/git-credential.txt:128
#, ignore-same, no-wrap, priority:100
msgid "`protocol`"
msgstr "`protocol`"

#. type: Plain text
#: en/git-credential.txt:132
#, priority:100
msgid "The protocol over which the credential will be used (e.g., `https`)."
msgstr "将使用证书的协议（例如，`https`）。"

#. type: Labeled list
#: en/git-credential.txt:133
#, ignore-same, no-wrap, priority:100
msgid "`host`"
msgstr "`host`"

#. type: Plain text
#: en/git-credential.txt:137
#, priority:100
msgid "The remote hostname for a network credential.  This includes the port number if one was specified (e.g., \"example.com:8088\")."
msgstr "网络凭证的远程主机名。 如果指定了端口号，这包括端口号（例如，\"example.com:8088\"）。"

#. type: Labeled list
#: en/git-credential.txt:138
#, ignore-same, no-wrap, priority:100
msgid "`path`"
msgstr "`path`"

#. type: Plain text
#: en/git-credential.txt:143
#, priority:100
msgid "The path with which the credential will be used. E.g., for accessing a remote https repository, this will be the repository's path on the server."
msgstr "证书将被使用的路径。例如，对于访问远程 https 版本库，这将是服务器上版本库的路径。"

#. type: Labeled list
#: en/git-credential.txt:144
#, ignore-same, no-wrap, priority:100
msgid "`username`"
msgstr "`username`"

#. type: Plain text
#: en/git-credential.txt:148
#, priority:100
msgid "The credential's username, if we already have one (e.g., from a URL, the configuration, the user, or from a previously run helper)."
msgstr "证书的用户名，如果我们已经有了一个（例如，从URL、配置、用户，或从先前运行的帮助器）。"

#. type: Labeled list
#: en/git-credential.txt:149
#, ignore-same, no-wrap, priority:100
msgid "`password`"
msgstr "`password`"

#. type: Plain text
#: en/git-credential.txt:152
#, priority:100
msgid "The credential's password, if we are asking it to be stored."
msgstr "凭证的密码，如果我们要求它被存储。"

#. type: Labeled list
#: en/git-credential.txt:153
#, ignore-same, no-wrap, priority:100
msgid "`password_expiry_utc`"
msgstr "`password_expiry_utc`"

#. type: Plain text
#: en/git-credential.txt:158
#, priority:100
msgid "Generated passwords such as an OAuth access token may have an expiry date.  When reading credentials from helpers, `git credential fill` ignores expired passwords. Represented as Unix time UTC, seconds since 1970."
msgstr "生成的密码，如 OAuth 访问令牌，可能有一个过期日期。 当从助手那里读取凭证时，`git credential fill` 会忽略过期的密码。表示为 Unix 时间 UTC，自 1970 年以来的秒数。"

#. type: Labeled list
#: en/git-credential.txt:159
#, ignore-same, no-wrap, priority:100
msgid "`oauth_refresh_token`"
msgstr "`oauth_refresh_token`"

#. type: Plain text
#: en/git-credential.txt:164
#, priority:100
msgid "An OAuth refresh token may accompany a password that is an OAuth access token. Helpers must treat this attribute as confidential like the password attribute. Git itself has no special behaviour for this attribute."
msgstr "一个 OAuth 刷新令牌可以伴随着一个 OAuth 访问令牌的密码。帮助者必须像密码属性一样，将此属性视为机密。Git 本身对这个属性没有特殊行为。"

#. type: Labeled list
#: en/git-credential.txt:165
#, ignore-same, no-wrap, priority:100
msgid "`url`"
msgstr "`url`"

#. type: Plain text
#: en/git-credential.txt:172
#, priority:100
msgid "When this special attribute is read by `git credential`, the value is parsed as a URL and treated as if its constituent parts were read (e.g., `url=https://example.com` would behave as if `protocol=https` and `host=example.com` had been provided). This can help callers avoid parsing URLs themselves."
msgstr "当这个特殊属性被 `git credential` 读取时，该值被解析为一个 URL，并被当作其组成部分来处理（例如，`url=_00` 的行为就如同提供了 `protocol=https` 和 `host=example.com`）。这可以帮助调用者避免自己解析 URL。"

#. type: Plain text
#: en/git-credential.txt:177
#, priority:100
msgid "Note that specifying a protocol is mandatory and if the URL doesn't specify a hostname (e.g., \"cert:///path/to/file\") the credential will contain a hostname attribute whose value is an empty string."
msgstr "请注意，指定协议是强制性的，如果 URL 没有指定主机名（例如，\"cert:///path/to/file\"），证书将包含一个主机名属性，其值是一个空字符串。"

#. type: Plain text
#: en/git-credential.txt:180
#, priority:100
msgid "Components which are missing from the URL (e.g., there is no username in the example above) will be left unset."
msgstr "URL 中缺少的组件（例如，上面的例子中没有用户名）将不被设置。"

#. type: Labeled list
#: en/git-credential.txt:181
#, fuzzy, no-wrap, priority:100
#| msgid "`author`"
msgid "`wwwauth[]`"
msgstr "`author`"

#. type: Plain text
#: en/git-credential.txt:186
#, priority:100
msgid "When an HTTP response is received by Git that includes one or more 'WWW-Authenticate' authentication headers, these will be passed by Git to credential helpers."
msgstr "当 Git 收到包含一个或多个 \"WWW-Authenticate\" 认证头的 HTTP 响应时，这些头将被 Git 传递给证书助手。"

#. type: Plain text
#: en/git-credential.txt:191
#, priority:100
msgid "Each 'WWW-Authenticate' header value is passed as a multi-valued attribute 'wwwauth[]', where the order of the attributes is the same as they appear in the HTTP response. This attribute is 'one-way' from Git to pass additional information to credential helpers."
msgstr "每个 'WWW-Authenticate' 头的值都以多值属性 'wwwauth[]' 的形式传递，其中属性的顺序与它们在 HTTP 响应中出现的一样。这个属性是 Git 的 'one-way' 属性，用于传递额外的信息给证书助手。"

#. type: Plain text
#: en/git-credential.txt:193
#, priority:100
msgid "Unrecognised attributes are silently discarded."
msgstr "未识别的属性会被默默地丢弃。"

#. type: Title =
#: en/git-cvsexportcommit.txt:2
#, ignore-same, no-wrap, priority:90
msgid "git-cvsexportcommit(1)"
msgstr "git-cvsexportcommit(1)"

#. type: Plain text
#: en/git-cvsexportcommit.txt:7
#, priority:90
msgid "git-cvsexportcommit - Export a single commit to a CVS checkout"
msgstr ""

#. type: Plain text
#: en/git-cvsexportcommit.txt:14
#, no-wrap, priority:90
msgid ""
"'git cvsexportcommit' [-h] [-u] [-v] [-c] [-P] [-p] [-a] [-d <cvsroot>]\n"
"\t[-w <cvs-workdir>] [-W] [-f] [-m <msgprefix>] [<parent-commit>] <commit-id>\n"
msgstr ""

#. type: Plain text
#: en/git-cvsexportcommit.txt:20
#, priority:90
msgid "Exports a commit from Git to a CVS checkout, making it easier to merge patches from a Git repository into a CVS repository."
msgstr ""

#. type: Plain text
#: en/git-cvsexportcommit.txt:24
#, priority:90
msgid "Specify the name of a CVS checkout using the -w switch or execute it from the root of the CVS working copy. In the latter case GIT_DIR must be defined. See examples below."
msgstr ""

#. type: Plain text
#: en/git-cvsexportcommit.txt:28
#, priority:90
msgid "It does its best to do the safe thing, it will check that the files are unchanged and up to date in the CVS checkout, and it will not autocommit by default."
msgstr ""

#. type: Plain text
#: en/git-cvsexportcommit.txt:30
#, priority:90
msgid "Supports file additions, removals, and commits that affect binary files."
msgstr ""

#. type: Plain text
#: en/git-cvsexportcommit.txt:33
#, priority:90
msgid "If the commit is a merge commit, you must tell 'git cvsexportcommit' what parent the changeset should be done against."
msgstr ""

#. type: Plain text
#: en/git-cvsexportcommit.txt:40
#, priority:90
msgid "Commit automatically if the patch applied cleanly. It will not commit if any hunks fail to apply or there were other problems."
msgstr ""

#. type: Plain text
#: en/git-cvsexportcommit.txt:44
#, priority:90
msgid "Be pedantic (paranoid) when applying patches. Invokes patch with --fuzz=0"
msgstr ""

#. type: Plain text
#: en/git-cvsexportcommit.txt:48
#, priority:90
msgid "Add authorship information. Adds Author line, and Committer (if different from Author) to the message."
msgstr ""

#. type: Plain text
#: en/git-cvsexportcommit.txt:53
#, priority:90
msgid "Set an alternative CVSROOT to use.  This corresponds to the CVS -d parameter.  Usually users will not want to set this, except if using CVS in an asymmetric fashion."
msgstr ""

#. type: Plain text
#: en/git-cvsexportcommit.txt:56
#, priority:90
msgid "Force the merge even if the files are not up to date."
msgstr ""

#. type: Plain text
#: en/git-cvsexportcommit.txt:59
#, priority:90
msgid "Force the parent commit, even if it is not a direct parent."
msgstr ""

#. type: Plain text
#: en/git-cvsexportcommit.txt:63
#, priority:90
msgid "Prepend the commit message with the provided prefix.  Useful for patch series and the like."
msgstr ""

#. type: Plain text
#: en/git-cvsexportcommit.txt:66
#, priority:90
msgid "Update affected files from CVS repository before attempting export."
msgstr ""

#. type: Plain text
#: en/git-cvsexportcommit.txt:70
#, priority:90
msgid "Reverse CVS keyword expansion (e.g. $Revision: 1.2.3.4$ becomes $Revision$) in working CVS checkout before applying patch."
msgstr ""

#. type: Plain text
#: en/git-cvsexportcommit.txt:76
#, priority:90
msgid "Specify the location of the CVS checkout to use for the export. This option does not require GIT_DIR to be set before execution if the current directory is within a Git repository.  The default is the value of 'cvsexportcommit.cvsdir'."
msgstr ""

#. type: Plain text
#: en/git-cvsexportcommit.txt:81
#, priority:90
msgid "Tell cvsexportcommit that the current working directory is not only a Git checkout, but also the CVS checkout.  Therefore, Git will reset the working directory to the parent commit before proceeding."
msgstr ""

#. type: Plain text
#: en/git-cvsexportcommit.txt:84
#, fuzzy, priority:90
msgid "Verbose."
msgstr "Verbose."

#. type: Labeled list
#: en/git-cvsexportcommit.txt:87
#, no-wrap, priority:90
msgid "cvsexportcommit.cvsdir"
msgstr ""

#. type: Plain text
#: en/git-cvsexportcommit.txt:89
#, priority:90
msgid "The default location of the CVS checkout to use for the export."
msgstr ""

#. type: Labeled list
#: en/git-cvsexportcommit.txt:93
#, fuzzy, no-wrap, priority:90
msgid "Merge one patch into CVS"
msgstr "将一个修补程序合并到 CVS 中"

#. type: delimited block -
#: en/git-cvsexportcommit.txt:100
#, fuzzy, no-wrap, priority:90
msgid ""
"$ export GIT_DIR=~/project/.git\n"
"$ cd ~/project_cvs_checkout\n"
"$ git cvsexportcommit -v <commit-sha1>\n"
"$ cvs commit -F .msg <files>\n"
msgstr ""
"$ export GIT_DIR=~/project/.git\n"
"$ cd ~/project_cvs_checkout\n"
"$ git cvsexportcommit -v <commit-sha1>\n"
"$ cvs commit -F .msg <files>\n"

#. type: Labeled list
#: en/git-cvsexportcommit.txt:102
#, no-wrap, priority:90
msgid "Merge one patch into CVS (-c and -w options). The working directory is within the Git Repo"
msgstr ""

#. type: delimited block -
#: en/git-cvsexportcommit.txt:106
#, fuzzy, no-wrap, priority:90
msgid "\t$ git cvsexportcommit -v -c -w ~/project_cvs_checkout <commit-sha1>\n"
msgstr "\t$ git cvsexportcommit -v -c -w ~/project_cvs_checkout <commit-sha1>\n"

#. type: Labeled list
#: en/git-cvsexportcommit.txt:108
#, no-wrap, priority:90
msgid "Merge pending patches into CVS automatically -- only if you really know what you are doing"
msgstr ""

#. type: delimited block -
#: en/git-cvsexportcommit.txt:114
#, fuzzy, no-wrap, priority:90
msgid ""
"$ export GIT_DIR=~/project/.git\n"
"$ cd ~/project_cvs_checkout\n"
"$ git cherry cvshead myhead | sed -n 's/^+ //p' | xargs -l1 git cvsexportcommit -c -p -v\n"
msgstr ""
"$ export GIT_DIR=~/project/.git\n"
"$ cd ~/project_cvs_checkout\n"
"$ git cherry cvshead myhead | sed -n 's/^+ //p' | xargs -l1 git cvsexportcommit -c -p -v\n"

#. type: Title =
#: en/git-cvsimport.txt:2
#, ignore-same, no-wrap, priority:90
msgid "git-cvsimport(1)"
msgstr "git-cvsimport(1)"

#. type: Plain text
#: en/git-cvsimport.txt:7
#, priority:90
msgid "git-cvsimport - Salvage your data out of another SCM people love to hate"
msgstr ""

#. type: Plain text
#: en/git-cvsimport.txt:17
#, no-wrap, priority:90
msgid ""
"'git cvsimport' [-o <branch-for-HEAD>] [-h] [-v] [-d <CVSROOT>]\n"
"\t      [-A <author-conv-file>] [-p <options-for-cvsps>] [-P <file>]\n"
"\t      [-C <git-repository>] [-z <fuzz>] [-i] [-k] [-u] [-s <subst>]\n"
"\t      [-a] [-m] [-M <regex>] [-S <regex>] [-L <commit-limit>]\n"
"\t      [-r <remote>] [-R] [<CVS-module>]\n"
msgstr ""

#. type: Plain text
#: en/git-cvsimport.txt:26
#, no-wrap, priority:90
msgid ""
"*WARNING:* `git cvsimport` uses cvsps version 2, which is considered\n"
"deprecated; it does not work with cvsps version 3 and later.  If you are\n"
"performing a one-shot import of a CVS repository consider using\n"
"http://cvs2svn.tigris.org/cvs2git.html[cvs2git] or\n"
"http://www.catb.org/esr/cvs-fast-export/[cvs-fast-export].\n"
msgstr ""

#. type: Plain text
#: en/git-cvsimport.txt:29
#, priority:90
msgid "Imports a CVS repository into Git. It will either create a new repository, or incrementally import into an existing one."
msgstr ""

#. type: Plain text
#: en/git-cvsimport.txt:32
#, priority:90
msgid "Splitting the CVS log into patch sets is done by 'cvsps'.  At least version 2.1 is required."
msgstr ""

#. type: Plain text
#: en/git-cvsimport.txt:35
#, no-wrap, priority:90
msgid ""
"*WARNING:* for certain situations the import leads to incorrect results.\n"
"Please see the section <<issues,ISSUES>> for further reference.\n"
msgstr ""

#. type: Plain text
#: en/git-cvsimport.txt:42
#, priority:90
msgid "You should *never* do any work of your own on the branches that are created by 'git cvsimport'.  By default initial import will create and populate a \"master\" branch from the CVS repository's main branch which you're free to work with; after that, you need to 'git merge' incremental imports, or any CVS branches, yourself.  It is advisable to specify a named remote via -r to separate and protect the incoming branches."
msgstr ""

#. type: Plain text
#: en/git-cvsimport.txt:48
#, priority:90
msgid "If you intend to set up a shared public repository that all developers can read/write, or if you want to use linkgit:git-cvsserver[1], then you probably want to make a bare clone of the imported repository, and use the clone as the shared repository.  See linkgit:gitcvs-migration[7]."
msgstr ""

#. type: Plain text
#: en/git-cvsimport.txt:54
#, priority:90
msgid "Verbosity: let 'cvsimport' report what it is doing."
msgstr ""

#. type: Labeled list
#: en/git-cvsimport.txt:55
#, fuzzy, no-wrap, priority:90
msgid "-d <CVSROOT>"
msgstr "-d <CVSROOT>"

#. type: Plain text
#: en/git-cvsimport.txt:61
#, priority:90
msgid "The root of the CVS archive. May be local (a simple path) or remote; currently, only the :local:, :ext: and :pserver: access methods are supported. If not given, 'git cvsimport' will try to read it from `CVS/Root`. If no such file exists, it checks for the `CVSROOT` environment variable."
msgstr ""

#. type: Labeled list
#: en/git-cvsimport.txt:62
#, fuzzy, no-wrap, priority:90
msgid "<CVS-module>"
msgstr "<CVS_module>"

#. type: Plain text
#: en/git-cvsimport.txt:66
#, priority:90
msgid "The CVS module you want to import. Relative to <CVSROOT>.  If not given, 'git cvsimport' tries to read it from `CVS/Repository`."
msgstr ""

#. type: Labeled list
#: en/git-cvsimport.txt:67
#, fuzzy, no-wrap, priority:90
msgid "-C <target-dir>"
msgstr "-C <target-dir>"

#. type: Plain text
#: en/git-cvsimport.txt:70
#, fuzzy, priority:90
msgid "The Git repository to import to.  If the directory doesn't exist, it will be created.  Default is the current directory."
msgstr "Clone a repository into a new directory."

#. type: Labeled list
#: en/git-cvsimport.txt:71
#, fuzzy, no-wrap, priority:90
msgid "-r <remote>"
msgstr "-r <remote>"

#. type: Plain text
#: en/git-cvsimport.txt:75
#, priority:90
msgid "The Git remote to import this CVS repository into.  Moves all CVS branches into remotes/<remote>/<branch> akin to the way 'git clone' uses 'origin' by default."
msgstr ""

#. type: Labeled list
#: en/git-cvsimport.txt:76
#, fuzzy, no-wrap, priority:90
msgid "-o <branch-for-HEAD>"
msgstr "-o <branch-for-HEAD>"

#. type: Plain text
#: en/git-cvsimport.txt:84
#, priority:90
msgid "When no remote is specified (via -r) the `HEAD` branch from CVS is imported to the 'origin' branch within the Git repository, as `HEAD` already has a special meaning for Git.  When a remote is specified the `HEAD` branch is named remotes/<remote>/master mirroring 'git clone' behaviour.  Use this option if you want to import into a different branch."
msgstr ""

#. type: Plain text
#: en/git-cvsimport.txt:87
#, priority:90
msgid "Use '-o master' for continuing an import that was initially done by the old cvs2git tool."
msgstr ""

#. type: Plain text
#: en/git-cvsimport.txt:92
#, priority:90
msgid "Import-only: don't perform a checkout after importing.  This option ensures the working directory and index remain untouched and will not create them if they do not exist."
msgstr ""

#. type: Plain text
#: en/git-cvsimport.txt:97
#, priority:90
msgid "Kill keywords: will extract files with '-kk' from the CVS archive to avoid noisy changesets. Highly recommended, but off by default to preserve compatibility with early imported trees."
msgstr ""

#. type: Plain text
#: en/git-cvsimport.txt:100
#, priority:90
msgid "Convert underscores in tag and branch names to dots."
msgstr ""

#. type: Labeled list
#: en/git-cvsimport.txt:101
#, fuzzy, no-wrap, priority:90
msgid "-s <subst>"
msgstr "-s <subst>"

#. type: Plain text
#: en/git-cvsimport.txt:103
#, priority:90
msgid "Substitute the character \"/\" in branch names with <subst>"
msgstr ""

#. type: Labeled list
#: en/git-cvsimport.txt:104
#, fuzzy, no-wrap, priority:90
msgid "-p <options-for-cvsps>"
msgstr "-p <options-for-cvsps>"

#. type: Plain text
#: en/git-cvsimport.txt:107
#, priority:90
msgid "Additional options for cvsps.  The options `-u` and '-A' are implicit and should not be used here."
msgstr ""

#. type: Plain text
#: en/git-cvsimport.txt:109
#, priority:90
msgid "If you need to pass multiple options, separate them with a comma."
msgstr ""

#. type: Labeled list
#: en/git-cvsimport.txt:110
#, fuzzy, no-wrap, priority:90
msgid "-z <fuzz>"
msgstr "-z <fuzz>"

#. type: Plain text
#: en/git-cvsimport.txt:113
#, priority:90
msgid "Pass the timestamp fuzz factor to cvsps, in seconds. If unset, cvsps defaults to 300s."
msgstr ""

#. type: Labeled list
#: en/git-cvsimport.txt:114
#, no-wrap, priority:90
msgid "-P <cvsps-output-file>"
msgstr ""

#. type: Plain text
#: en/git-cvsimport.txt:117
#, priority:90
msgid "Instead of calling cvsps, read the provided cvsps output file. Useful for debugging or when cvsps is being handled outside cvsimport."
msgstr ""

#. type: Plain text
#: en/git-cvsimport.txt:122
#, priority:90
msgid "Attempt to detect merges based on the commit message. This option will enable default regexes that try to capture the source branch name from the commit message."
msgstr ""

#. type: Labeled list
#: en/git-cvsimport.txt:123
#, fuzzy, no-wrap, priority:90
msgid "-M <regex>"
msgstr "-M <regex>"

#. type: Plain text
#: en/git-cvsimport.txt:127
#, priority:90
msgid "Attempt to detect merges based on the commit message with a custom regex. It can be used with `-m` to enable the default regexes as well. You must escape forward slashes."
msgstr ""

#. type: Plain text
#: en/git-cvsimport.txt:129
#, priority:90
msgid "The regex must capture the source branch name in $1."
msgstr ""

#. type: Plain text
#: en/git-cvsimport.txt:131
#, priority:90
msgid "This option can be used several times to provide several detection regexes."
msgstr ""

#. type: Labeled list
#: en/git-cvsimport.txt:132
#, no-wrap, priority:90
msgid "-S <regex>"
msgstr ""

#. type: Plain text
#: en/git-cvsimport.txt:134
#, priority:90
msgid "Skip paths matching the regex."
msgstr ""

#. type: Plain text
#: en/git-cvsimport.txt:138
#, priority:90
msgid "Import all commits, including recent ones. cvsimport by default skips commits that have a timestamp less than 10 minutes ago."
msgstr ""

#. type: Labeled list
#: en/git-cvsimport.txt:139
#, fuzzy, no-wrap, priority:90
msgid "-L <limit>"
msgstr "-L <limit>"

#. type: Plain text
#: en/git-cvsimport.txt:142
#, priority:90
msgid "Limit the number of commits imported. Workaround for cases where cvsimport leaks memory."
msgstr ""

#. type: Labeled list
#: en/git-cvsimport.txt:143
#, no-wrap, priority:90
msgid "-A <author-conv-file>"
msgstr ""

#. type: Plain text
#: en/git-cvsimport.txt:148
#, priority:90
msgid "CVS by default uses the Unix username when writing its commit logs. Using this option and an author-conv-file maps the name recorded in CVS to author name, e-mail and optional time zone:"
msgstr ""

#. type: delimited block -
#: en/git-cvsimport.txt:152
#, no-wrap, priority:90
msgid ""
"\texon=Andreas Ericsson <ae@op5.se>\n"
"\tspawn=Simon Pawn <spawn@frog-pond.org> America/Chicago\n"
msgstr ""

#. type: Plain text
#: en/git-cvsimport.txt:159
#, fuzzy, priority:90
msgid "'git cvsimport' will make it appear as those authors had their GIT_AUTHOR_NAME and GIT_AUTHOR_EMAIL set properly all along.  If a time zone is specified, GIT_AUTHOR_DATE will have the corresponding offset applied."
msgstr "'git cvsimport' will make it appear as those authors had their GIT_AUTHOR_NAME and GIT_AUTHOR_EMAIL set properly all along.  If a time zone is specified, GIT_AUTHOR_DATE will have the corresponding offset applied."

#. type: Plain text
#: en/git-cvsimport.txt:163
#, priority:90
msgid "For convenience, this data is saved to `$GIT_DIR/cvs-authors` each time the '-A' option is provided and read from that same file each time 'git cvsimport' is run."
msgstr ""

#. type: Plain text
#: en/git-cvsimport.txt:167
#, priority:90
msgid "It is not recommended to use this feature if you intend to export changes back to CVS again later with 'git cvsexportcommit'."
msgstr ""

#. type: Plain text
#: en/git-cvsimport.txt:173
#, priority:90
msgid "Generate a `$GIT_DIR/cvs-revisions` file containing a mapping from CVS revision numbers to newly-created Git commit IDs.  The generated file will contain one line for each (filename, revision) pair imported; each line will look like"
msgstr ""

#. type: delimited block -
#: en/git-cvsimport.txt:176
#, fuzzy, no-wrap, priority:90
msgid "src/widget.c 1.1 1d862f173cdc7325b6fa6d2ae1cfd61fd1b512b7\n"
msgstr "src/widget.c 1.1 1d862f173cdc7325b6fa6d2ae1cfd61fd1b512b7\n"

#. type: Plain text
#: en/git-cvsimport.txt:180
#, priority:90
msgid "The revision data is appended to the file if it already exists, for use when doing incremental imports."
msgstr ""

#. type: Plain text
#: en/git-cvsimport.txt:183
#, priority:90
msgid "This option may be useful if you have CVS revision numbers stored in commit messages, bug-tracking systems, email archives, and the like."
msgstr ""

#. type: Plain text
#: en/git-cvsimport.txt:186
#, priority:90
msgid "Print a short usage message and exit."
msgstr ""

#. type: Plain text
#: en/git-cvsimport.txt:190
#, priority:90
msgid "If `-v` is specified, the script reports what it is doing."
msgstr ""

#. type: Plain text
#: en/git-cvsimport.txt:193
#, priority:90
msgid "Otherwise, success is indicated the Unix way, i.e. by simply exiting with a zero exit status."
msgstr ""

#. type: Title -
#: en/git-cvsimport.txt:196
#, no-wrap, priority:90
msgid "ISSUES"
msgstr ""

#. type: Plain text
#: en/git-cvsimport.txt:198
#, priority:90
msgid "Problems related to timestamps:"
msgstr ""

#. type: Plain text
#: en/git-cvsimport.txt:202
#, priority:90
msgid "If timestamps of commits in the CVS repository are not stable enough to be used for ordering commits changes may show up in the wrong order."
msgstr ""

#. type: Plain text
#: en/git-cvsimport.txt:204
#, priority:90
msgid "If any files were ever \"cvs import\"ed more than once (e.g., import of more than one vendor release) the HEAD contains the wrong content."
msgstr ""

#. type: Plain text
#: en/git-cvsimport.txt:207
#, priority:90
msgid "If the timestamp order of different files cross the revision order within the commit matching time window the order of commits may be wrong."
msgstr ""

#. type: Plain text
#: en/git-cvsimport.txt:209
#, priority:90
msgid "Problems related to branches:"
msgstr ""

#. type: Plain text
#: en/git-cvsimport.txt:211
#, priority:90
msgid "Branches on which no commits have been made are not imported."
msgstr ""

#. type: Plain text
#: en/git-cvsimport.txt:213
#, priority:90
msgid "All files from the branching point are added to a branch even if never added in CVS."
msgstr ""

#. type: Plain text
#: en/git-cvsimport.txt:216
#, priority:90
msgid "This applies to files added to the source branch *after* a daughter branch was created: if previously no commit was made on the daughter branch they will erroneously be added to the daughter branch in git."
msgstr ""

#. type: Plain text
#: en/git-cvsimport.txt:218
#, priority:90
msgid "Problems related to tags:"
msgstr ""

#. type: Plain text
#: en/git-cvsimport.txt:220
#, priority:90
msgid "Multiple tags on the same revision are not imported."
msgstr ""

#. type: Plain text
#: en/git-cvsimport.txt:223
#, priority:90
msgid "If you suspect that any of these issues may apply to the repository you want to import, consider using cvs2git:"
msgstr ""

#. type: Plain text
#: en/git-cvsimport.txt:225
#, priority:90
msgid "cvs2git (part of cvs2svn), `http://subversion.apache.org/`"
msgstr ""

#. type: Title =
#: en/git-cvsserver.txt:2
#, ignore-same, no-wrap, priority:90
msgid "git-cvsserver(1)"
msgstr "git-cvsserver(1)"

#. type: Plain text
#: en/git-cvsserver.txt:7
#, fuzzy, priority:90
msgid "git-cvsserver - A CVS server emulator for Git"
msgstr "git-cvsserver - A CVS server emulator for Git"

#. type: Plain text
#: en/git-cvsserver.txt:12
#, priority:90
msgid "SSH:"
msgstr "{BASH_GNLV3_AMP}"

#. type: Plain text
#: en/git-cvsserver.txt:16
#, no-wrap, priority:90
msgid ""
"export CVS_SERVER=\"git cvsserver\"\n"
"'cvs' -d :ext:user@server/path/repo.git co <HEAD_name>\n"
msgstr ""

#. type: Plain text
#: en/git-cvsserver.txt:18
#, fuzzy, priority:90
msgid "pserver (/etc/inetd.conf):"
msgstr "pserver (/etc/inetd.conf):"

#. type: Plain text
#: en/git-cvsserver.txt:21
#, no-wrap, priority:90
msgid "cvspserver stream tcp nowait nobody /usr/bin/git-cvsserver git-cvsserver pserver\n"
msgstr ""

#. type: Plain text
#: en/git-cvsserver.txt:23
#, fuzzy, priority:90
msgid "Usage:"
msgstr "用法："

#. type: Plain text
#: en/git-cvsserver.txt:26
#, ignore-ellipsis, no-wrap, priority:90
msgid "'git-cvsserver' [<options>] [pserver|server] [<directory> ...]\n"
msgstr ""

#. type: Plain text
#: en/git-cvsserver.txt:31
#, priority:90
msgid "This application is a CVS emulation layer for Git."
msgstr ""

#. type: Plain text
#: en/git-cvsserver.txt:35
#, priority:90
msgid "It is highly functional. However, not all methods are implemented, and for those methods that are implemented, not all switches are implemented."
msgstr ""

#. type: Plain text
#: en/git-cvsserver.txt:38
#, priority:90
msgid "Testing has been done using both the CLI CVS client, and the Eclipse CVS plugin. Most functionality works fine with both of these clients."
msgstr ""

#. type: Plain text
#: en/git-cvsserver.txt:45
#, priority:90
msgid "All these options obviously only make sense if enforced by the server side.  They have been implemented to resemble the linkgit:git-daemon[1] options as closely as possible."
msgstr ""

#. type: Labeled list
#: en/git-cvsserver.txt:46
#, fuzzy, no-wrap, priority:90
msgid "--base-path <path>"
msgstr "--base-path <path>"

#. type: Plain text
#: en/git-cvsserver.txt:48
#, priority:90
msgid "Prepend 'path' to requested CVSROOT"
msgstr ""

#. type: Labeled list
#: en/git-cvsserver.txt:49 en/git-daemon.txt:49
#, ignore-same, no-wrap, priority:100
msgid "--strict-paths"
msgstr "--strict-paths"

#. type: Plain text
#: en/git-cvsserver.txt:51
#, priority:90
msgid "Don't allow recursing into subdirectories"
msgstr ""

#. type: Labeled list
#: en/git-cvsserver.txt:52 en/git-daemon.txt:78
#, ignore-same, no-wrap, priority:100
msgid "--export-all"
msgstr "--export-all"

#. type: Plain text
#: en/git-cvsserver.txt:55
#, priority:90
msgid "Don't check for `gitcvs.enabled` in config. You also have to specify a list of allowed directories (see below) if you want to use this option."
msgstr ""

#. type: Labeled list
#: en/git-cvsserver.txt:56
#, fuzzy, no-wrap, priority:90
msgid "-V"
msgstr "-V"

#. type: Labeled list
#: en/git-cvsserver.txt:57 en/git.txt:42
#, ignore-same, no-wrap, priority:100
msgid "--version"
msgstr "--version"

#. type: Plain text
#: en/git-cvsserver.txt:59
#, fuzzy, priority:90
msgid "Print version information and exit"
msgstr "打印版本信息并退出"

#. type: Labeled list
#: en/git-cvsserver.txt:62 en/git.txt:50
#, ignore-same, no-wrap, priority:100
msgid "--help"
msgstr "--help"

#. type: Plain text
#: en/git-cvsserver.txt:64
#, priority:90
msgid "Print usage information and exit"
msgstr ""

#. type: Plain text
#: en/git-cvsserver.txt:70
#, priority:90
msgid "The remaining arguments provide a list of directories. If no directories are given, then all are allowed. Repositories within these directories still require the `gitcvs.enabled` config option, unless `--export-all` is specified."
msgstr ""

#. type: Title -
#: en/git-cvsserver.txt:72 en/git-fast-export.txt:272
#, no-wrap, priority:90
msgid "LIMITATIONS"
msgstr ""

#. type: Plain text
#: en/git-cvsserver.txt:75
#, priority:90
msgid "CVS clients cannot tag, branch or perform Git merges."
msgstr ""

#. type: Plain text
#: en/git-cvsserver.txt:79
#, fuzzy, priority:90
msgid "'git-cvsserver' maps Git branches to CVS modules. This is very different from what most CVS users would expect since in CVS modules usually represent one or more directories."
msgstr "'git-cvsserver' maps Git branches to CVS modules. This is very different from what most CVS users would expect since in CVS modules usually represent one or more directories."

#. type: Title -
#: en/git-cvsserver.txt:81
#, fuzzy, no-wrap, priority:90
msgid "INSTALLATION"
msgstr "安装"

#. type: Plain text
#: en/git-cvsserver.txt:85
#, priority:90
msgid "If you are going to offer CVS access via pserver, add a line in /etc/inetd.conf like"
msgstr ""

#. type: delimited block -
#: en/git-cvsserver.txt:89
#, no-wrap, priority:90
msgid "   cvspserver stream tcp nowait nobody git-cvsserver pserver\n"
msgstr ""

#. type: Plain text
#: en/git-cvsserver.txt:95
#, priority:90
msgid "Note: Some inetd servers let you specify the name of the executable independently of the value of argv[0] (i.e. the name the program assumes it was executed with). In this case the correct line in /etc/inetd.conf looks like"
msgstr ""

#. type: delimited block -
#: en/git-cvsserver.txt:98
#, no-wrap, priority:90
msgid "   cvspserver stream tcp nowait nobody /usr/bin/git-cvsserver git-cvsserver pserver\n"
msgstr ""

#. type: Plain text
#: en/git-cvsserver.txt:105
#, priority:90
msgid "Only anonymous access is provided by pserver by default. To commit you will have to create pserver accounts, simply add a gitcvs.authdb setting in the config file of the repositories you want the cvsserver to allow writes to, for example:"
msgstr ""

#. type: delimited block -
#: en/git-cvsserver.txt:110
#, fuzzy, no-wrap, priority:90
msgid ""
"   [gitcvs]\n"
"\tauthdb = /etc/cvsserver/passwd\n"
msgstr ""
"   [gitcvs]\n"
"\tauthdb = /etc/cvsserver/passwd\n"

#. type: Plain text
#: en/git-cvsserver.txt:114
#, priority:90
msgid "The format of these files is username followed by the encrypted password, for example:"
msgstr ""

#. type: delimited block -
#: en/git-cvsserver.txt:119
#, no-wrap, priority:90
msgid ""
"   myuser:sqkNi8zPf01HI\n"
"   myuser:$1$9K7FzU28$VfF6EoPYCJEYcVQwATgOP/\n"
"   myuser:$5$.NqmNH1vwfzGpV8B$znZIcumu1tNLATgV2l6e1/mY8RzhUDHMOaVOeL1cxV3\n"
msgstr ""

#. type: Plain text
#: en/git-cvsserver.txt:122
#, priority:90
msgid "You can use the 'htpasswd' facility that comes with Apache to make these files, but only with the -d option (or -B if your system supports it)."
msgstr ""

#. type: Plain text
#: en/git-cvsserver.txt:126
#, priority:90
msgid "Preferably use the system specific utility that manages password hash creation in your platform (e.g. mkpasswd in Linux, encrypt in OpenBSD or pwhash in NetBSD) and paste it in the right location."
msgstr ""

#. type: Plain text
#: en/git-cvsserver.txt:128
#, priority:90
msgid "Then provide your password via the pserver method, for example:"
msgstr ""

#. type: delimited block -
#: en/git-cvsserver.txt:130
#, no-wrap, priority:90
msgid "   cvs -d:pserver:someuser:somepassword@server:/path/repo.git co <HEAD_name>\n"
msgstr ""

#. type: Plain text
#: en/git-cvsserver.txt:134
#, priority:90
msgid "No special setup is needed for SSH access, other than having Git tools in the PATH. If you have clients that do not accept the CVS_SERVER environment variable, you can rename 'git-cvsserver' to `cvs`."
msgstr ""

#. type: Plain text
#: en/git-cvsserver.txt:137
#, priority:90
msgid "Note: Newer CVS versions (>= 1.12.11) also support specifying CVS_SERVER directly in CVSROOT like"
msgstr ""

#. type: delimited block -
#: en/git-cvsserver.txt:140
#, no-wrap, priority:90
msgid "   cvs -d \":ext;CVS_SERVER=git cvsserver:user@server/path/repo.git\" co <HEAD_name>\n"
msgstr ""

#. type: Plain text
#: en/git-cvsserver.txt:146
#, priority:90
msgid "This has the advantage that it will be saved in your 'CVS/Root' files and you don't need to worry about always setting the correct environment variable.  SSH users restricted to 'git-shell' don't need to override the default with CVS_SERVER (and shouldn't) as 'git-shell' understands `cvs` to mean 'git-cvsserver' and pretends that the other end runs the real 'cvs' better."
msgstr ""

#. type: Plain text
#: en/git-cvsserver.txt:149
#, priority:90
msgid "For each repo that you want accessible from CVS you need to edit config in the repo and add the following section."
msgstr ""

#. type: delimited block -
#: en/git-cvsserver.txt:156
#, fuzzy, no-wrap, priority:90
msgid ""
"   [gitcvs]\n"
"        enabled=1\n"
"        # optional for debugging\n"
"\tlogFile=/path/to/logfile\n"
msgstr ""
"   [gitcvs]\n"
"        enabled=1\n"
"        # optional for debugging\n"
"\tlogFile=/path/to/logfile\n"

#. type: Plain text
#: en/git-cvsserver.txt:162
#, priority:90
msgid "Note: you need to ensure each user that is going to invoke 'git-cvsserver' has write access to the log file and to the database (see <<dbbackend,Database Backend>>. If you want to offer write access over SSH, the users of course also need write access to the Git repository itself."
msgstr ""

#. type: Plain text
#: en/git-cvsserver.txt:165
#, priority:90
msgid "You also need to ensure that each repository is \"bare\" (without a Git index file) for `cvs commit` to work. See linkgit:gitcvs-migration[7]."
msgstr ""

#. type: Plain text
#: en/git-cvsserver.txt:171
#, priority:90
msgid "All configuration variables can also be overridden for a specific method of access. Valid method names are \"ext\" (for SSH access) and \"pserver\". The following example configuration would disable pserver access while still allowing access over SSH."
msgstr ""

#. type: delimited block -
#: en/git-cvsserver.txt:174
#, fuzzy, no-wrap, priority:90
msgid ""
"   [gitcvs]\n"
"        enabled=0\n"
msgstr ""
"   [gitcvs]\n"
"        enabled=0\n"

#. type: delimited block -
#: en/git-cvsserver.txt:177
#, no-wrap, priority:90
msgid ""
"   [gitcvs \"ext\"]\n"
"        enabled=1\n"
msgstr ""

#. type: Plain text
#: en/git-cvsserver.txt:184
#, priority:90
msgid "If you didn't specify the CVSROOT/CVS_SERVER directly in the checkout command, automatically saving it in your 'CVS/Root' files, then you need to set them explicitly in your environment.  CVSROOT should be set as per normal, but the directory should point at the appropriate Git repo.  As above, for SSH clients _not_ restricted to 'git-shell', CVS_SERVER should be set to 'git-cvsserver'."
msgstr ""

#. type: delimited block -
#: en/git-cvsserver.txt:189
#, no-wrap, priority:90
msgid ""
"   export CVSROOT=:ext:user@server:/var/git/project.git\n"
"   export CVS_SERVER=\"git cvsserver\"\n"
msgstr ""

#. type: Plain text
#: en/git-cvsserver.txt:196
#, priority:90
msgid "For SSH clients that will make commits, make sure their server-side .ssh/environment files (or .bashrc, etc., according to their specific shell)  export appropriate values for GIT_AUTHOR_NAME, GIT_AUTHOR_EMAIL, GIT_COMMITTER_NAME, and GIT_COMMITTER_EMAIL.  For SSH clients whose login shell is bash, .bashrc may be a reasonable alternative."
msgstr ""

#. type: Plain text
#: en/git-cvsserver.txt:202
#, priority:90
msgid "Clients should now be able to check out the project. Use the CVS 'module' name to indicate what Git 'head' you want to check out.  This also sets the name of your newly checked-out directory, unless you tell it otherwise with `-d <dir_name>`.  For example, this checks out 'master' branch to the `project-master` directory:"
msgstr ""

#. type: delimited block -
#: en/git-cvsserver.txt:205
#, no-wrap, priority:90
msgid "   cvs co -d project-master master\n"
msgstr ""

#. type: Title -
#: en/git-cvsserver.txt:209
#, no-wrap, priority:90
msgid "DATABASE BACKEND"
msgstr ""

#. type: Plain text
#: en/git-cvsserver.txt:215
#, fuzzy, priority:90
msgid "'git-cvsserver' uses one database per Git head (i.e. CVS module) to store information about the repository to maintain consistent CVS revision numbers. The database needs to be updated (i.e. written to) after every commit."
msgstr "'git-cvsserver' uses one database per Git head (i.e. CVS module) to store information about the repository to maintain consistent CVS revision numbers. The database needs to be updated (i.e. written to) after every commit."

#. type: Plain text
#: en/git-cvsserver.txt:220
#, priority:90
msgid "If the commit is done directly by using `git` (as opposed to using 'git-cvsserver') the update will need to happen on the next repository access by 'git-cvsserver', independent of access method and requested operation."
msgstr ""

#. type: Plain text
#: en/git-cvsserver.txt:225
#, priority:90
msgid "That means that even if you offer only read access (e.g. by using the pserver method), 'git-cvsserver' should have write access to the database to work reliably (otherwise you need to make sure that the database is up to date any time 'git-cvsserver' is executed)."
msgstr ""

#. type: Plain text
#: en/git-cvsserver.txt:232
#, priority:90
msgid "By default it uses SQLite databases in the Git directory, named `gitcvs.<module_name>.sqlite`. Note that the SQLite backend creates temporary files in the same directory as the database file on write so it might not be enough to grant the users using 'git-cvsserver' write access to the database file without granting them write access to the directory, too."
msgstr ""

#. type: Plain text
#: en/git-cvsserver.txt:244
#, priority:90
msgid "The database cannot be reliably regenerated in a consistent form after the branch it is tracking has changed.  Example: For merged branches, 'git-cvsserver' only tracks one branch of development, and after a 'git merge' an incrementally updated database may track a different branch than a database regenerated from scratch, causing inconsistent CVS revision numbers. `git-cvsserver` has no way of knowing which branch it would have picked if it had been run incrementally pre-merge. So if you have to fully or partially (from old backup) regenerate the database, you should be suspicious of pre-existing CVS sandboxes."
msgstr ""

#. type: Plain text
#: en/git-cvsserver.txt:247
#, priority:90
msgid "You can configure the database backend with the following configuration variables:"
msgstr ""

#. type: Title ~
#: en/git-cvsserver.txt:249
#, no-wrap, priority:90
msgid "Configuring database backend"
msgstr ""

#. type: Plain text
#: en/git-cvsserver.txt:254
#, fuzzy, priority:90
msgid "'git-cvsserver' uses the Perl DBI module. Please also read its documentation if changing these variables, especially about `DBI->connect()`."
msgstr "'git-cvsserver' uses the Perl DBI module. Please also read its documentation if changing these variables, especially about `DBI->connect()`."

#. type: Labeled list
#: en/git-cvsserver.txt:255
#, fuzzy, no-wrap, priority:90
msgid "gitcvs.dbName"
msgstr "gitcvs.dbName"

#. type: Plain text
#: en/git-cvsserver.txt:261
#, priority:90
msgid "Database name. The exact meaning depends on the selected database driver, for SQLite this is a filename.  Supports variable substitution (see below). May not contain semicolons (`;`).  Default: '%Ggitcvs.%m.sqlite'"
msgstr ""

#. type: Labeled list
#: en/git-cvsserver.txt:262
#, fuzzy, no-wrap, priority:90
msgid "gitcvs.dbDriver"
msgstr "gitcvs.dbDriver"

#. type: Plain text
#: en/git-cvsserver.txt:270
#, priority:90
msgid "Used DBI driver. You can specify any available driver for this here, but it might not work. cvsserver is tested with 'DBD::SQLite', reported to work with 'DBD::Pg', and reported *not* to work with 'DBD::mysql'.  Please regard this as an experimental feature. May not contain colons (`:`).  Default: 'SQLite'"
msgstr ""

#. type: Labeled list
#: en/git-cvsserver.txt:271
#, fuzzy, no-wrap, priority:90
msgid "gitcvs.dbuser"
msgstr "gitcvs.dbuser"

#. type: Plain text
#: en/git-cvsserver.txt:275
#, priority:90
msgid "Database user. Only useful if setting `dbDriver`, since SQLite has no concept of database users. Supports variable substitution (see below)."
msgstr ""

#. type: Labeled list
#: en/git-cvsserver.txt:276
#, no-wrap, priority:90
msgid "gitcvs.dbPass"
msgstr ""

#. type: Plain text
#: en/git-cvsserver.txt:279
#, priority:90
msgid "Database password.  Only useful if setting `dbDriver`, since SQLite has no concept of database passwords."
msgstr ""

#. type: Labeled list
#: en/git-cvsserver.txt:280
#, fuzzy, no-wrap, priority:90
msgid "gitcvs.dbTableNamePrefix"
msgstr "gitcvs.dbTableNamePrefix"

#. type: Plain text
#: en/git-cvsserver.txt:284
#, priority:90
msgid "Database table name prefix.  Supports variable substitution (see below).  Any non-alphabetic characters will be replaced with underscores."
msgstr ""

#. type: Plain text
#: en/git-cvsserver.txt:286
#, priority:90
msgid "All variables can also be set per access method, see <<configaccessmethod,above>>."
msgstr ""

#. type: Title ^
#: en/git-cvsserver.txt:288
#, no-wrap, priority:90
msgid "Variable substitution"
msgstr ""

#. type: Plain text
#: en/git-cvsserver.txt:290
#, priority:90
msgid "In `dbDriver` and `dbUser` you can use the following variables:"
msgstr ""

#. type: Labeled list
#: en/git-cvsserver.txt:291
#, ignore-same, no-wrap, priority:90
msgid "%G"
msgstr "%G"

#. type: Plain text
#: en/git-cvsserver.txt:293
#, priority:90
msgid "Git directory name"
msgstr ""

#. type: Labeled list
#: en/git-cvsserver.txt:293
#, ignore-same, no-wrap, priority:90
msgid "%g"
msgstr "%g"

#. type: Plain text
#: en/git-cvsserver.txt:298
#, priority:90
msgid "Git directory name, where all characters except for alphanumeric ones, `.`, and `-` are replaced with `_` (this should make it easier to use the directory name in a filename if wanted)"
msgstr ""

#. type: Labeled list
#: en/git-cvsserver.txt:298
#, ignore-same, no-wrap, priority:90
msgid "%m"
msgstr "%m"

#. type: Plain text
#: en/git-cvsserver.txt:300
#, priority:90
msgid "CVS module/Git head name"
msgstr ""

#. type: Labeled list
#: en/git-cvsserver.txt:300
#, ignore-same, no-wrap, priority:90
msgid "%a"
msgstr "%a"

#. type: Plain text
#: en/git-cvsserver.txt:302
#, priority:90
msgid "access method (one of \"ext\" or \"pserver\")"
msgstr ""

#. type: Labeled list
#: en/git-cvsserver.txt:302
#, ignore-same, no-wrap, priority:90
msgid "%u"
msgstr "%u"

#. type: Plain text
#: en/git-cvsserver.txt:306
#, priority:90
msgid "Name of the user running 'git-cvsserver'.  If no name can be determined, the numeric uid is used."
msgstr ""

#. type: Plain text
#: en/git-cvsserver.txt:312
#, priority:90
msgid "These variables obviate the need for command-line options in some circumstances, allowing easier restricted usage through git-shell."
msgstr ""

#. type: Labeled list
#: en/git-cvsserver.txt:313
#, ignore-same, no-wrap, priority:90
msgid "GIT_CVSSERVER_BASE_PATH"
msgstr "GIT_CVSSERVER_BASE_PATH"

#. type: Plain text
#: en/git-cvsserver.txt:315
#, priority:90
msgid "This variable replaces the argument to --base-path."
msgstr ""

#. type: Labeled list
#: en/git-cvsserver.txt:316
#, ignore-same, no-wrap, priority:90
msgid "GIT_CVSSERVER_ROOT"
msgstr "GIT_CVSSERVER_ROOT"

#. type: Plain text
#: en/git-cvsserver.txt:320
#, ignore-ellipsis, priority:90
msgid "This variable specifies a single directory, replacing the `<directory>...` argument list. The repository still requires the `gitcvs.enabled` config option, unless `--export-all` is specified."
msgstr ""

#. type: Plain text
#: en/git-cvsserver.txt:323
#, priority:90
msgid "When these environment variables are set, the corresponding command-line arguments may not be used."
msgstr ""

#. type: Title -
#: en/git-cvsserver.txt:325
#, no-wrap, priority:90
msgid "ECLIPSE CVS CLIENT NOTES"
msgstr ""

#. type: Plain text
#: en/git-cvsserver.txt:328
#, priority:90
msgid "To get a checkout with the Eclipse CVS client:"
msgstr ""

#. type: Plain text
#: en/git-cvsserver.txt:330
#, priority:90
msgid "Select \"Create a new project -> From CVS checkout\""
msgstr ""

#. type: Plain text
#: en/git-cvsserver.txt:332
#, priority:90
msgid "Create a new location. See the notes below for details on how to choose the right protocol."
msgstr ""

#. type: Plain text
#: en/git-cvsserver.txt:335
#, priority:90
msgid "Browse the 'modules' available. It will give you a list of the heads in the repository. You will not be able to browse the tree from there. Only the heads."
msgstr ""

#. type: Plain text
#: en/git-cvsserver.txt:337
#, priority:90
msgid "Pick `HEAD` when it asks what branch/tag to check out. Untick the \"launch commit wizard\" to avoid committing the .project file."
msgstr ""

#. type: Plain text
#: en/git-cvsserver.txt:343
#, priority:90
msgid "Protocol notes: If you are using anonymous access via pserver, just select that.  Those using SSH access should choose the 'ext' protocol, and configure 'ext' access on the Preferences->Team->CVS->ExtConnection pane. Set CVS_SERVER to \"`git cvsserver`\". Note that password support is not good when using 'ext', you will definitely want to have SSH keys setup."
msgstr ""

#. type: Plain text
#: en/git-cvsserver.txt:348
#, priority:90
msgid "Alternatively, you can just use the non-standard extssh protocol that Eclipse offer. In that case CVS_SERVER is ignored, and you will have to replace the cvs utility on the server with 'git-cvsserver' or manipulate your `.bashrc` so that calling 'cvs' effectively calls 'git-cvsserver'."
msgstr ""

#. type: Title -
#: en/git-cvsserver.txt:350
#, no-wrap, priority:90
msgid "CLIENTS KNOWN TO WORK"
msgstr ""

#. type: Plain text
#: en/git-cvsserver.txt:353
#, priority:90
msgid "CVS 1.12.9 on Debian"
msgstr ""

#. type: Plain text
#: en/git-cvsserver.txt:354
#, priority:90
msgid "CVS 1.11.17 on MacOSX (from Fink package)"
msgstr ""

#. type: Plain text
#: en/git-cvsserver.txt:355
#, priority:90
msgid "Eclipse 3.0, 3.1.2 on MacOSX (see Eclipse CVS Client Notes)"
msgstr ""

#. type: Plain text
#: en/git-cvsserver.txt:356
#, priority:90
msgid "TortoiseCVS"
msgstr ""

#. type: Title -
#: en/git-cvsserver.txt:358
#, no-wrap, priority:90
msgid "OPERATIONS SUPPORTED"
msgstr ""

#. type: Plain text
#: en/git-cvsserver.txt:362
#, priority:90
msgid "All the operations required for normal use are supported, including checkout, diff, status, update, log, add, remove, commit."
msgstr ""

#. type: Plain text
#: en/git-cvsserver.txt:371
#, priority:90
msgid "Most CVS command arguments that read CVS tags or revision numbers (typically -r) work, and also support any git refspec (tag, branch, commit ID, etc).  However, CVS revision numbers for non-default branches are not well emulated, and cvs log does not show tags or branches at all.  (Non-main-branch CVS revision numbers superficially resemble CVS revision numbers, but they actually encode a git commit ID directly, rather than represent the number of revisions since the branch point.)"
msgstr ""

#. type: Plain text
#: en/git-cvsserver.txt:385
#, priority:90
msgid "Note that there are two ways to checkout a particular branch.  As described elsewhere on this page, the \"module\" parameter of cvs checkout is interpreted as a branch name, and it becomes the main branch.  It remains the main branch for a given sandbox even if you temporarily make another branch sticky with cvs update -r.  Alternatively, the -r argument can indicate some other branch to actually checkout, even though the module is still the \"main\" branch.  Tradeoffs (as currently implemented): Each new \"module\" creates a new database on disk with a history for the given module, and after the database is created, operations against that main branch are fast.  Or alternatively, -r doesn't take any extra disk space, but may be significantly slower for many operations, like cvs update."
msgstr ""

#. type: Plain text
#: en/git-cvsserver.txt:398
#, priority:90
msgid "If you want to refer to a git refspec that has characters that are not allowed by CVS, you have two options.  First, it may just work to supply the git refspec directly to the appropriate CVS -r argument; some CVS clients don't seem to do much sanity checking of the argument.  Second, if that fails, you can use a special character escape mechanism that only uses characters that are valid in CVS tags.  A sequence of 4 or 5 characters of the form (underscore (`\"_\"`), dash (`\"-\"`), one or two characters, and dash (`\"-\"`)) can encode various characters based on the one or two letters: `\"s\"` for slash (`\"/\"`), `\"p\"` for period (`\".\"`), `\"u\"` for underscore (`\"_\"`), or two hexadecimal digits for any byte value at all (typically an ASCII number, or perhaps a part of a UTF-8 encoded character)."
msgstr ""

#. type: Plain text
#: en/git-cvsserver.txt:401
#, priority:90
msgid "Legacy monitoring operations are not supported (edit, watch and related).  Exports and tagging (tags and branches) are not supported at this stage."
msgstr ""

#. type: Title ~
#: en/git-cvsserver.txt:403
#, no-wrap, priority:90
msgid "CRLF Line Ending Conversions"
msgstr ""

#. type: Plain text
#: en/git-cvsserver.txt:408
#, priority:90
msgid "By default the server leaves the `-k` mode blank for all files, which causes the CVS client to treat them as a text files, subject to end-of-line conversion on some platforms."
msgstr ""

#. type: Plain text
#: en/git-cvsserver.txt:413
#, priority:90
msgid "You can make the server use the end-of-line conversion attributes to set the `-k` modes for files by setting the `gitcvs.usecrlfattr` config variable.  See linkgit:gitattributes[5] for more information about end-of-line conversion."
msgstr ""

#. type: Plain text
#: en/git-cvsserver.txt:422
#, priority:90
msgid "Alternatively, if `gitcvs.usecrlfattr` config is not enabled or the attributes do not allow automatic detection for a filename, then the server uses the `gitcvs.allBinary` config for the default setting.  If `gitcvs.allBinary` is set, then file not otherwise specified will default to '-kb' mode. Otherwise the `-k` mode is left blank. But if `gitcvs.allBinary` is set to \"guess\", then the correct `-k` mode will be guessed based on the contents of the file."
msgstr ""

#. type: Plain text
#: en/git-cvsserver.txt:426
#, priority:90
msgid "For best consistency with 'cvs', it is probably best to override the defaults by setting `gitcvs.usecrlfattr` to true, and `gitcvs.allBinary` to \"guess\"."
msgstr ""

#. type: Title -
#: en/git-cvsserver.txt:428
#, no-wrap, priority:90
msgid "DEPENDENCIES"
msgstr ""

#. type: Plain text
#: en/git-cvsserver.txt:430
#, fuzzy, priority:90
msgid "'git-cvsserver' depends on DBD::SQLite."
msgstr "'git-cvsserver' depends on DBD::SQLite."

#. type: Title =
#: en/git-daemon.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-daemon(1)"
msgstr "git-daemon(1)"

#. type: Plain text
#: en/git-daemon.txt:7
#, priority:100
msgid "git-daemon - A really simple server for Git repositories"
msgstr "git-daemon - 一个非常简单的git存储库服务器。"

#. type: Plain text
#: en/git-daemon.txt:25
#, fuzzy, ignore-ellipsis, no-wrap, priority:100
msgid ""
"'git daemon' [--verbose] [--syslog] [--export-all]\n"
"\t     [--timeout=<n>] [--init-timeout=<n>] [--max-connections=<n>]\n"
"\t     [--strict-paths] [--base-path=<path>] [--base-path-relaxed]\n"
"\t     [--user-path | --user-path=<path>]\n"
"\t     [--interpolated-path=<pathtemplate>]\n"
"\t     [--reuseaddr] [--detach] [--pid-file=<file>]\n"
"\t     [--enable=<service>] [--disable=<service>]\n"
"\t     [--allow-override=<service>] [--forbid-override=<service>]\n"
"\t     [--access-hook=<path>] [--[no-]informative-errors]\n"
"\t     [--inetd |\n"
"\t      [--listen=<host_or_ipaddr>] [--port=<n>]\n"
"\t      [--user=<user> [--group=<group>]]]\n"
"\t     [--log-destination=(stderr|syslog|none)]\n"
"\t     [<directory>...]\n"
msgstr ""
"'git daemon' [--verbose] [--syslog] [--export-all]\n"
"\t     [--timeout=<n>] [--init-timeout=<n>] [--max-connections=<n>]\n"
"\t     [--strict-paths] [--base-path=<路径>] [--base-path-relaxed]\n"
"\t     [--user-path | --user-path=<路径>]\n"
"\t     [--interpolated-path=<路径模板>]\n"
"\t     [--reuseaddr] [--detach] [--pid-file=<文件>]\n"
"\t     [--enable=<服务>] [--disable=<服务>]\n"
"\t     [--allow-override=<服务>] [--forbid-override=<服务>]\n"
"\t     [--access-hook=<路径>] [--[no-]informative-errors]\n"
"\t     [--inetd |\n"
"\t      [--listen=<主机或 ip 地址>] [--port=<n>]\n"
"\t      [--user=<用户> [--group=<组>]]]\n"
"\t     [--log-destination=(stderr|syslog|none)]\n"
"\t     [<directory>...]\n"

#. type: Plain text
#: en/git-daemon.txt:31
#, priority:100
msgid "A really simple TCP Git daemon that normally listens on port \"DEFAULT_GIT_PORT\" aka 9418.  It waits for a connection asking for a service, and will serve that service if it is enabled."
msgstr "一个非常简单的 TCP Git 守护进程，通常在端口 \"DEFAULT_GIT_PORT\"（即 9418）上进行监听。 它等待一个要求提供服务的连接，如果该服务被启用，它将提供服务。"

#. type: Plain text
#: en/git-daemon.txt:37
#, priority:100
msgid "It verifies that the directory has the magic file \"git-daemon-export-ok\", and it will refuse to export any Git directory that hasn't explicitly been marked for export this way (unless the `--export-all` parameter is specified). If you pass some directory paths as 'git daemon' arguments, the offers are limited to repositories within those directories."
msgstr "它验证该目录是否有神奇的文件 \"git-daemon-export-ok\"，它将拒绝导出任何没有明确标记为这种方式导出的 Gi t目录（除非指定 `--export-all` 参数）。如果你把一些目录路径作为 \"git daemon\" 参数传递，那么提供的内容就会被限制在这些目录内的仓库。"

#. type: Plain text
#: en/git-daemon.txt:41
#, priority:100
msgid "By default, only `upload-pack` service is enabled, which serves 'git fetch-pack' and 'git ls-remote' clients, which are invoked from 'git fetch', 'git pull', and 'git clone'."
msgstr "默认情况下，只有 \"upload-pack \"服务被启用，它为 \"git fetch-pack\" 和 \"git ls-remote\" 客户端服务，这些客户端是由 \"git fetch\"、\"git pull\" 和 \"git clone \" 调用的。"

#. type: Plain text
#: en/git-daemon.txt:44
#, priority:100
msgid "This is ideally suited for read-only updates, i.e., pulling from Git repositories."
msgstr "这非常适合于只读更新，即从 Git 仓库拉取。"

#. type: Plain text
#: en/git-daemon.txt:46
#, priority:100
msgid "An `upload-archive` also exists to serve 'git archive'."
msgstr "还存在一个 `upload-archive`，为 'git archive' 服务。"

#. type: Plain text
#: en/git-daemon.txt:54
#, priority:100
msgid "Match paths exactly (i.e. don't allow \"/foo/repo\" when the real path is \"/foo/repo.git\" or \"/foo/repo/.git\") and don't do user-relative paths.  'git daemon' will refuse to start when this option is enabled and no directory arguments are provided."
msgstr "准确匹配路径（即不允许 \"/foo/repo\"，而真正的路径是 \"/foo/repo.git \" 或 \"/foo/repo/.git\"），不做与用户相关的路径。 当这个选项被启用并且没有提供目录参数时，\"git daemon\" 将拒绝启动。"

#. type: Labeled list
#: en/git-daemon.txt:55
#, fuzzy, no-wrap, priority:100
msgid "--base-path=<path>"
msgstr "--base-path=<path>"

#. type: Plain text
#: en/git-daemon.txt:61
#, priority:100
msgid "Remap all the path requests as relative to the given path.  This is sort of \"Git root\" - if you run 'git daemon' with '--base-path=/srv/git' on example.com, then if you later try to pull 'git://example.com/hello.git', 'git daemon' will interpret the path as `/srv/git/hello.git`."
msgstr "将所有的路径请求重新映射为相对于给定路径的请求。 这有点像 \"Git root\"--如果你在 example.com 上用 '-base-path=/srv/git' 运行 'git daemon'，那么如果你以后试图拉 'git://example.com/hello.git'，'git daemon' 将把路径解释为 `/srv/git/hello.git`。"

#. type: Labeled list
#: en/git-daemon.txt:62
#, ignore-same, no-wrap, priority:100
msgid "--base-path-relaxed"
msgstr "--base-path-relaxed"

#. type: Plain text
#: en/git-daemon.txt:67
#, priority:100
msgid "If --base-path is enabled and repo lookup fails, with this option 'git daemon' will attempt to lookup without prefixing the base path.  This is useful for switching to --base-path usage, while still allowing the old paths."
msgstr "如果启用了 --base-path，并且 repo 查找失败，使用这个选项，'git daemon' 将尝试在不加前缀的基础路径下进行查找。 这对于切换到 --base-path 的使用很有用，同时仍然允许使用旧的路径。"

#. type: Labeled list
#: en/git-daemon.txt:68
#, fuzzy, no-wrap, priority:100
msgid "--interpolated-path=<pathtemplate>"
msgstr "--interpolated-path=<pathtemplate>"

#. type: Plain text
#: en/git-daemon.txt:77
#, priority:100
msgid "To support virtual hosting, an interpolated path template can be used to dynamically construct alternate paths.  The template supports %H for the target hostname as supplied by the client but converted to all lowercase, %CH for the canonical hostname, %IP for the server's IP address, %P for the port number, and %D for the absolute path of the named repository.  After interpolation, the path is validated against the directory list."
msgstr "为了支持虚拟主机，可以使用插值路径模板来动态地构建备用路径。 该模板支持由客户提供的目标主机名的 %H，但转换为小写字母；支持规范主机名的 %CH；支持服务器 IP 地址的 %IP；支持端口号的 %P；支持命名仓库的绝对路径的 %D。 在插值之后，该路径将根据目录列表进行验证。"

#. type: Plain text
#: en/git-daemon.txt:82
#, priority:100
msgid "Allow pulling from all directories that look like Git repositories (have the 'objects' and 'refs' subdirectories), even if they do not have the 'git-daemon-export-ok' file."
msgstr "允许从所有看起来像 Git 仓库的目录（有 'objects' 和 'refs' 子目录）提取，即使它们没有 'git-daemon-export-ok' 文件。"

#. type: Labeled list
#: en/git-daemon.txt:83
#, ignore-same, no-wrap, priority:100
msgid "--inetd"
msgstr "--inetd"

#. type: Plain text
#: en/git-daemon.txt:88
#, priority:100
msgid "Have the server run as an inetd service. Implies --syslog (may be overridden with `--log-destination=`).  Incompatible with --detach, --port, --listen, --user and --group options."
msgstr "让服务器作为一个 inetd 服务运行。暗示 --syslog（可以用 `--log-destination=` 重写）。 与 --detach、--port、--listen、--user 和 --group 选项不兼容。"

#. type: Labeled list
#: en/git-daemon.txt:89
#, fuzzy, no-wrap, priority:100
msgid "--listen=<host_or_ipaddr>"
msgstr "--listen=<host_or_ipaddr>"

#. type: Plain text
#: en/git-daemon.txt:96
#, priority:100
msgid "Listen on a specific IP address or hostname.  IP addresses can be either an IPv4 address or an IPv6 address if supported.  If IPv6 is not supported, then --listen=hostname is also not supported and --listen must be given an IPv4 address.  Can be given more than once.  Incompatible with `--inetd` option."
msgstr "在一个特定的 IP 地址或主机名上收听。 IP 地址可以是一个 IPv4 地址，也可以是一个 IPv6 地址（如果支持）。 如果不支持 IPv6，那么 --listen=hostname也不被支持，--listen 必须给出一个 IPv4 地址。 可以多次给出。 与 `--inetd` 选项不兼容。"

#. type: Labeled list
#: en/git-daemon.txt:97
#, fuzzy, no-wrap, priority:100
msgid "--port=<n>"
msgstr "--port=<n>"

#. type: Plain text
#: en/git-daemon.txt:99
#, priority:100
msgid "Listen on an alternative port.  Incompatible with `--inetd` option."
msgstr "在另一个端口上监听。 与 `--inetd` 选项不兼容。"

#. type: Labeled list
#: en/git-daemon.txt:100
#, fuzzy, no-wrap, priority:100
msgid "--init-timeout=<n>"
msgstr "--init-timeout=<n>"

#. type: Plain text
#: en/git-daemon.txt:104
#, priority:100
msgid "Timeout (in seconds) between the moment the connection is established and the client request is received (typically a rather low value, since that should be basically immediate)."
msgstr "从建立连接到收到客户端请求之间的超时（以秒为单位）（通常是一个相当低的值，因为这基本上应该是即时的）。"

#. type: Labeled list
#: en/git-daemon.txt:105 en/git-upload-pack.txt:31
#, no-wrap, priority:100
msgid "--timeout=<n>"
msgstr "--timeout=<n>"

#. type: Plain text
#: en/git-daemon.txt:109
#, priority:100
msgid "Timeout (in seconds) for specific client sub-requests. This includes the time it takes for the server to process the sub-request and the time spent waiting for the next client's request."
msgstr "特定客户端子请求的超时（单位：秒）。这包括服务器处理子请求的时间和等待下一个客户端请求的时间。"

#. type: Labeled list
#: en/git-daemon.txt:110
#, no-wrap, priority:100
msgid "--max-connections=<n>"
msgstr "--max-connections=<n>"

#. type: Plain text
#: en/git-daemon.txt:113
#, priority:100
msgid "Maximum number of concurrent clients, defaults to 32.  Set it to zero for no limit."
msgstr "最大并发客户数，默认为 32。 设置为零表示没有限制。"

#. type: Labeled list
#: en/git-daemon.txt:114
#, ignore-same, no-wrap, priority:100
msgid "--syslog"
msgstr "--syslog"

#. type: Plain text
#: en/git-daemon.txt:116
#, priority:100
msgid "Short for `--log-destination=syslog`."
msgstr "是 `--log-destination=syslog` 的简称。"

#. type: Labeled list
#: en/git-daemon.txt:117
#, no-wrap, priority:100
msgid "--log-destination=<destination>"
msgstr "--log-destination=<目的>"

#. type: Plain text
#: en/git-daemon.txt:122
#, priority:100
msgid "Send log messages to the specified destination.  Note that this option does not imply --verbose, thus by default only error conditions will be logged.  The <destination> must be one of:"
msgstr "发送日志信息到指定的目的地。 注意，这个选项并不意味着 --verbose，因此默认情况下只有错误情况会被记录下来。 <目的> 必须是以下之一："

#. type: Labeled list
#: en/git-daemon.txt:124
#, fuzzy, no-wrap, priority:100
msgid "stderr"
msgstr "标准错误"

#. type: Plain text
#: en/git-daemon.txt:129
#, priority:100
msgid "Write to standard error.  Note that if `--detach` is specified, the process disconnects from the real standard error, making this destination effectively equivalent to `none`."
msgstr "写入标准错误。 注意，如果指定了 `--detach`，进程就会断开与真正的标准错误的连接，使得这个目的地实际上等同于 `none`。"

#. type: Labeled list
#: en/git-daemon.txt:129
#, fuzzy, no-wrap, priority:100
msgid "syslog"
msgstr "日志服务器"

#. type: Plain text
#: en/git-daemon.txt:131
#, priority:100
msgid "Write to syslog, using the `git-daemon` identifier."
msgstr "写入 syslog，使用 `git-daemon` 标识符。"

#. type: Plain text
#: en/git-daemon.txt:133
#, priority:100
msgid "Disable all logging."
msgstr "禁用所有日志记录。"

#. type: Plain text
#: en/git-daemon.txt:137
#, priority:100
msgid "The default destination is `syslog` if `--inetd` or `--detach` is specified, otherwise `stderr`."
msgstr "如果指定了 `--inetd` 或 `--detach`，默认的目标是 `syslog`，否则是 `stderr`。"

#. type: Labeled list
#: en/git-daemon.txt:138
#, ignore-same, no-wrap, priority:100
msgid "--user-path"
msgstr "--user-path"

#. type: Labeled list
#: en/git-daemon.txt:139
#, fuzzy, no-wrap, priority:100
msgid "--user-path=<path>"
msgstr "--user-path=<path>"

#. type: Plain text
#: en/git-daemon.txt:147
#, priority:100
msgid "Allow {tilde}user notation to be used in requests.  When specified with no parameter, requests to git://host/{tilde}alice/foo is taken as a request to access 'foo' repository in the home directory of user `alice`.  If `--user-path=path` is specified, the same request is taken as a request to access `path/foo` repository in the home directory of user `alice`."
msgstr "允许在请求中使用 {tilde} 用户符号。 当没有指定参数时，对 git://host/{tilde}alice/foo 的请求会被视为访问用户 `alice`的主目录下的 'foo' 仓库的请求。 如果指定了 `--user-path=path`，同样的请求将被视为访问用户 `alice` 的主目录下的 `path/foo`存储库。"

#. type: Plain text
#: en/git-daemon.txt:150
#, priority:100
msgid "Log details about the incoming connections and requested files."
msgstr "记录有关传入连接和请求文件的详细信息。"

#. type: Labeled list
#: en/git-daemon.txt:151
#, ignore-same, no-wrap, priority:100
msgid "--reuseaddr"
msgstr "--reuseaddr"

#. type: Plain text
#: en/git-daemon.txt:155
#, priority:100
msgid "Use SO_REUSEADDR when binding the listening socket.  This allows the server to restart without waiting for old connections to time out."
msgstr "在绑定监听套接字时使用 SO_REUSEADDR。 这允许服务器重新启动，而不必等待旧的连接超时。"

#. type: Plain text
#: en/git-daemon.txt:158
#, priority:100
msgid "Detach from the shell. Implies --syslog."
msgstr "从 shell 中分离出来。这意味着 --syslog。"

#. type: Labeled list
#: en/git-daemon.txt:159
#, fuzzy, no-wrap, priority:100
msgid "--pid-file=<file>"
msgstr "--pid-file=<file>"

#. type: Plain text
#: en/git-daemon.txt:162
#, priority:100
msgid "Save the process id in 'file'.  Ignored when the daemon is run under `--inetd`."
msgstr "在 'file' 中保存进程 ID。 当守护进程在 `--inetd` 下运行时被忽略。"

#. type: Labeled list
#: en/git-daemon.txt:163
#, fuzzy, no-wrap, priority:100
msgid "--user=<user>"
msgstr "--user=<user>"

#. type: Labeled list
#: en/git-daemon.txt:164
#, no-wrap, priority:100
msgid "--group=<group>"
msgstr "--group=<组>"

#. type: Plain text
#: en/git-daemon.txt:170
#, priority:100
msgid "Change daemon's uid and gid before entering the service loop.  When only `--user` is given without `--group`, the primary group ID for the user is used.  The values of the option are given to `getpwnam(3)` and `getgrnam(3)` and numeric IDs are not supported."
msgstr "在进入服务循环之前，改变 daemon 的 uid 和 gid。 当只给出 `--user` 而没有 `--group` 时，将使用用户的主要组 ID。 该选项的值是给 `getpwnam(3)` 和 `getgrnam(3)` 的，不支持数字 ID。"

#. type: Plain text
#: en/git-daemon.txt:174
#, priority:100
msgid "Giving these options is an error when used with `--inetd`; use the facility of inet daemon to achieve the same before spawning 'git daemon' if needed."
msgstr "当与 `--inetd` 一起使用时，给出这些选项是一个错误；如果需要，在催生 'git daemon' 之前，使用 inet daemon 的设施来实现同样的目的。"

#. type: Plain text
#: en/git-daemon.txt:181
#, priority:100
msgid "Like many programs that switch user id, the daemon does not reset environment variables such as `$HOME` when it runs git programs, e.g. `upload-pack` and `receive-pack`. When using this option, you may also want to set and export `HOME` to point at the home directory of `<user>` before starting the daemon, and make sure any Git configuration files in that directory are readable by `<user>`."
msgstr "像许多切换用户 ID 的程序一样，守护进程在运行 git 程序（如 `upload-pack` 和 `receive-pack`）时，不会重置 `$HOME` 之类的环境变量。当使用这个选项时，你可能还想在启动守护进程之前设置并导出 `HOME` 指向 `<user>` 的主目录，并确保该目录下的任何 Git 配置文件是 `<user>` 可以读取的。"

#. type: Labeled list
#: en/git-daemon.txt:182
#, no-wrap, priority:100
msgid "--enable=<service>"
msgstr "--enable=<服务>"

#. type: Labeled list
#: en/git-daemon.txt:183
#, no-wrap, priority:100
msgid "--disable=<service>"
msgstr "--disable=<服务>"

#. type: Plain text
#: en/git-daemon.txt:189
#, priority:100
msgid "Enable/disable the service site-wide per default.  Note that a service disabled site-wide can still be enabled per repository if it is marked overridable and the repository enables the service with a configuration item."
msgstr "在全站范围内默认启用/禁用该服务。 请注意，如果一个全站禁用的服务被标记为可重写，并且版本库用配置项启用了该服务，那么它仍然可以在每个版本库中启用。"

#. type: Labeled list
#: en/git-daemon.txt:190
#, fuzzy, no-wrap, priority:100
msgid "--allow-override=<service>"
msgstr "--allow-override=<service>"

#. type: Labeled list
#: en/git-daemon.txt:191
#, no-wrap, priority:100
msgid "--forbid-override=<service>"
msgstr "--forbid-override=<服务>"

#. type: Plain text
#: en/git-daemon.txt:195
#, priority:100
msgid "Allow/forbid overriding the site-wide default with per repository configuration.  By default, all the services may be overridden."
msgstr "允许/禁止用每个版本库的配置来覆盖全站的默认值。 默认情况下，所有的服务都可以被覆盖。"

#. type: Labeled list
#: en/git-daemon.txt:196
#, ignore-same, no-wrap, priority:100
msgid "--[no-]informative-errors"
msgstr "--[no-]informative-errors"

#. type: Plain text
#: en/git-daemon.txt:204
#, priority:100
msgid "When informative errors are turned on, git-daemon will report more verbose errors to the client, differentiating conditions like \"no such repository\" from \"repository not exported\". This is more convenient for clients, but may leak information about the existence of unexported repositories.  When informative errors are not enabled, all errors report \"access denied\" to the client. The default is --no-informative-errors."
msgstr "当信息性错误被打开时，git-daemon 会向客户端报告更多详细的错误，区分 \"没有这样的仓库\" 和 \"仓库没有被导出\" 这样的情况。这对客户端来说更方便，但可能会泄露未导出版本库的信息。 如果不启用信息性错误，所有错误都会向客户报告 \"拒绝访问\"。默认情况是 --no-informative-errors。"

#. type: Labeled list
#: en/git-daemon.txt:205
#, no-wrap, priority:100
msgid "--access-hook=<path>"
msgstr "--access-hook=<路径>"

#. type: Plain text
#: en/git-daemon.txt:215
#, priority:100
msgid "Every time a client connects, first run an external command specified by the <path> with service name (e.g. \"upload-pack\"), path to the repository, hostname (%H), canonical hostname (%CH), IP address (%IP), and TCP port (%P) as its command-line arguments. The external command can decide to decline the service by exiting with a non-zero status (or to allow it by exiting with a zero status).  It can also look at the $REMOTE_ADDR and `$REMOTE_PORT` environment variables to learn about the requestor when making this decision."
msgstr "每次客户端连接时，首先运行 <路径> 指定的外部命令，以服务名称（如 \"upload-pack\"）、仓库的路径、主机名（%H）、规范主机名（%CH）、IP 地址（%IP）和 TCP 端口（%P）作为其命令行参数。外部命令可以通过以非零状态退出来决定拒绝该服务（或通过以零状态退出来允许它）。 在做出这个决定时，它还可以查看 $REMOTE_ADDR 和 `$REMOTE_PORT` 环境变量来了解请求者的情况。"

#. type: Plain text
#: en/git-daemon.txt:219
#, priority:100
msgid "The external command can optionally write a single line to its standard output to be sent to the requestor as an error message when it declines the service."
msgstr "外部命令可以选择在其标准输出中写入一行，在拒绝服务时作为错误信息发送给请求者。"

#. type: Plain text
#: en/git-daemon.txt:226
#, priority:100
msgid "The remaining arguments provide a list of directories. If any directories are specified, then the `git-daemon` process will serve a requested directory only if it is contained in one of these directories. If `--strict-paths` is specified, then the requested directory must match one of these directories exactly."
msgstr "其余的参数提供了一个目录列表。如果指定了任何目录，那么 `git-daemon` 进程将只在所请求的目录包含在这些目录中时提供服务。如果指定了 `--strict-paths`，那么请求的目录必须与这些目录之一完全匹配。"

#. type: Title -
#: en/git-daemon.txt:228 en/git-http-backend.txt:35
#, fuzzy, no-wrap, priority:100
msgid "SERVICES"
msgstr "服务"

#. type: Plain text
#: en/git-daemon.txt:236
#, priority:100
msgid "These services can be globally enabled/disabled using the command-line options of this command.  If finer-grained control is desired (e.g. to allow 'git archive' to be run against only in a few selected repositories the daemon serves), the per-repository configuration file can be used to enable or disable them."
msgstr "这些服务可以通过该命令的命令行选项全局启用/禁用。 如果需要更精细的控制（例如，允许 'git archive' 只在守护进程所服务的几个选定的仓库中运行），可以使用每个仓库的配置文件来启用或禁用它们。"

#. type: Labeled list
#: en/git-daemon.txt:237
#, no-wrap, priority:100
msgid "upload-pack"
msgstr "upload-pack"

#. type: Plain text
#: en/git-daemon.txt:242
#, priority:100
msgid "This serves 'git fetch-pack' and 'git ls-remote' clients.  It is enabled by default, but a repository can disable it by setting `daemon.uploadpack` configuration item to `false`."
msgstr "它为 'git fetch-pack' 和 'git ls-remote' 客户端服务。 它默认是启用的，但仓库可以通过设置 `daemon.uploadpack` 配置项为 `false` 来禁用它。"

#. type: Labeled list
#: en/git-daemon.txt:243
#, fuzzy, no-wrap, priority:100
msgid "upload-archive"
msgstr "upload-archive"

#. type: Plain text
#: en/git-daemon.txt:247
#, priority:100
msgid "This serves 'git archive --remote'.  It is disabled by default, but a repository can enable it by setting `daemon.uploadarch` configuration item to `true`."
msgstr "这为 'git archive --remote' 服务。 它默认是禁用的，但版本库可以通过设置 `daemon.uploadarch` 配置项为 `true` 来启用它。"

#. type: Labeled list
#: en/git-daemon.txt:248
#, fuzzy, no-wrap, priority:100
msgid "receive-pack"
msgstr "receive-pack"

#. type: Plain text
#: en/git-daemon.txt:257
#, priority:100
msgid "This serves 'git send-pack' clients, allowing anonymous push.  It is disabled by default, as there is _no_ authentication in the protocol (in other words, anybody can push anything into the repository, including removal of refs).  This is solely meant for a closed LAN setting where everybody is friendly.  This service can be enabled by setting `daemon.receivepack` configuration item to `true`."
msgstr "它为 'git send-pack' 客户端服务，允许匿名推送。 它默认是禁用的，因为协议中没有认证（换句话说，任何人都可以推送任何东西到仓库，包括删除引用）。 这只适用于封闭的局域网环境，大家都很友好。 这个服务可以通过设置 `daemon.receivepack` 配置项为 `true` 来启用。"

#. type: Labeled list
#: en/git-daemon.txt:260
#, no-wrap, priority:100
msgid "We assume the following in /etc/services"
msgstr "我们在 /etc/services 中假设如下"

#. type: delimited block -
#: en/git-daemon.txt:265
#, fuzzy, no-wrap, priority:100
msgid ""
"$ grep 9418 /etc/services\n"
"git\t\t9418/tcp\t\t# Git Version Control System\n"
msgstr ""
"$ grep 9418 /etc/services\n"
"git\t\t9418/tcp\t\t# Git Version Control System\n"

#. type: Labeled list
#: en/git-daemon.txt:267
#, no-wrap, priority:100
msgid "'git daemon' as inetd server"
msgstr "'git daemon' 作为 inetd 服务器"

#. type: Plain text
#: en/git-daemon.txt:271
#, priority:100
msgid "To set up 'git daemon' as an inetd service that handles any repository within `/pub/foo` or `/pub/bar`, place an entry like the following into `/etc/inetd` all on one line:"
msgstr "要把 'git daemon' 设置为 inetd 服务，处理 `/pub/foo` 或 `/pub/bar` 内的任何仓库，在 `/etc/inetd` 中放入如下条目，全部放在一行："

#. type: delimited block -
#: en/git-daemon.txt:276
#, no-wrap, priority:100
msgid ""
"\tgit stream tcp nowait nobody  /usr/bin/git\n"
"\t\tgit daemon --inetd --verbose --export-all\n"
"\t\t/pub/foo /pub/bar\n"
msgstr ""
"\tgit stream tcp nowait nobody  /usr/bin/git\n"
"\t\tgit daemon --inetd --verbose --export-all\n"
"\t\t/pub/foo /pub/bar\n"

#. type: Labeled list
#: en/git-daemon.txt:279
#, no-wrap, priority:100
msgid "'git daemon' as inetd server for virtual hosts"
msgstr "作为虚拟主机的 inetd 服务器的 'git daemon'"

#. type: Plain text
#: en/git-daemon.txt:284
#, priority:100
msgid "To set up 'git daemon' as an inetd service that handles repositories for different virtual hosts, `www.example.com` and `www.example.org`, place an entry like the following into `/etc/inetd` all on one line:"
msgstr "要将 'git daemon' 设置为 inetd 服务，处理不同的虚拟主机 `www.example.com` 和 `www.example.org` 的仓库，在 `/etc/inetd` 中放置如下条目，全部在一行："

#. type: delimited block -
#: en/git-daemon.txt:292
#, no-wrap, priority:100
msgid ""
"\tgit stream tcp nowait nobody /usr/bin/git\n"
"\t\tgit daemon --inetd --verbose --export-all\n"
"\t\t--interpolated-path=/pub/%H%D\n"
"\t\t/pub/www.example.org/software\n"
"\t\t/pub/www.example.com/software\n"
"\t\t/software\n"
msgstr ""
"\tgit stream tcp nowait nobody /usr/bin/git\n"
"\t\tgit daemon --inetd --verbose --export-all\n"
"\t\t--interpolated-path=/pub/%H%D\n"
"\t\t/pub/www.example.org/software\n"
"\t\t/pub/www.example.com/software\n"
"\t\t/software\n"

#. type: Plain text
#: en/git-daemon.txt:300
#, priority:100
msgid "In this example, the root-level directory `/pub` will contain a subdirectory for each virtual host name supported.  Further, both hosts advertise repositories simply as `git://www.example.com/software/repo.git`.  For pre-1.4.0 clients, a symlink from `/software` into the appropriate default repository could be made as well."
msgstr "在这个例子中，根级目录 `/pub` 将包含一个子目录，用于支持每个虚拟主机名。 此外，两台主机都简单地以 `git://www.example.com/software/repo.git` 的方式宣传仓库。 对于 1.4.0 之前的客户端，也可以从 `/software` 建立一个符号链接到相应的默认仓库。"

#. type: Labeled list
#: en/git-daemon.txt:302
#, no-wrap, priority:100
msgid "'git daemon' as regular daemon for virtual hosts"
msgstr "'git daemon' 作为虚拟主机的常规守护程序"

#. type: Plain text
#: en/git-daemon.txt:306
#, priority:100
msgid "To set up 'git daemon' as a regular, non-inetd service that handles repositories for multiple virtual hosts based on their IP addresses, start the daemon like this:"
msgstr "要把 'git daemon' 设置成一个普通的、非 inetd 的服务，处理基于 IP 地址的多个虚拟主机的存储库，可以像这样启动 daemon："

#. type: delimited block -
#: en/git-daemon.txt:312
#, no-wrap, priority:100
msgid ""
"\tgit daemon --verbose --export-all\n"
"\t\t--interpolated-path=/pub/%IP/%D\n"
"\t\t/pub/192.168.1.200/software\n"
"\t\t/pub/10.10.220.23/software\n"
msgstr ""
"\tgit daemon --verbose --export-all\n"
"\t\t--interpolated-path=/pub/%IP/%D\n"
"\t\t/pub/192.168.1.200/software\n"
"\t\t/pub/10.10.220.23/software\n"

#. type: Plain text
#: en/git-daemon.txt:318
#, priority:100
msgid "In this example, the root-level directory `/pub` will contain a subdirectory for each virtual host IP address supported.  Repositories can still be accessed by hostname though, assuming they correspond to these IP addresses."
msgstr "在这个例子中，根级目录 `/pub` 将包含一个支持每个虚拟主机IP地址的子目录。 虽然仓库仍然可以通过主机名访问，但假设它们对应于这些 IP 地址。"

#. type: Labeled list
#: en/git-daemon.txt:319
#, no-wrap, priority:100
msgid "selectively enable/disable services per repository"
msgstr "选择性地启用/禁用每个仓库的服务"

#. type: Plain text
#: en/git-daemon.txt:324
#, priority:100
msgid "To enable 'git archive --remote' and disable 'git fetch' against a repository, have the following in the configuration file in the repository (that is the file 'config' next to `HEAD`, 'refs' and 'objects')."
msgstr "要启用 'git archive --remote' 并禁用 'git fetch'，在仓库的配置文件中要有以下内容（也就是在 `HEAD`、'refs' 和 'objects' 旁的 'config'文件）。"

#. type: delimited block -
#: en/git-daemon.txt:329
#, fuzzy, no-wrap, priority:100
msgid ""
"\t[daemon]\n"
"\t\tuploadpack = false\n"
"\t\tuploadarch = true\n"
msgstr ""
"\t[daemon]\n"
"\t\tuploadpack = false\n"
"\t\tuploadarch = true\n"

#. type: Plain text
#: en/git-daemon.txt:338
#, priority:100
msgid "'git daemon' will set REMOTE_ADDR to the IP address of the client that connected to it, if the IP address is available. REMOTE_ADDR will be available in the environment of hooks called when services are performed."
msgstr "'git daemon' 将把 REMOTE_ADDR 设置为连接到它的客户端的 IP 地址，如果该 IP 地址是可用的。REMOTE_ADDR 将在执行服务时调用的钩子环境中可用。"

#. type: Title =
#: en/git-describe.txt:2
#, ignore-same, no-wrap, priority:260
msgid "git-describe(1)"
msgstr "git-describe(1)"

#. type: Plain text
#: en/git-describe.txt:7
#, priority:260
msgid "git-describe - Give an object a human readable name based on an available ref"
msgstr "git-describe - 根据一个可用的参考文献，给一个对象起一个人类可读的名字。"

#. type: Plain text
#: en/git-describe.txt:14
#, ignore-ellipsis, no-wrap, priority:260
msgid ""
"'git describe' [--all] [--tags] [--contains] [--abbrev=<n>] [<commit-ish>...]\n"
"'git describe' [--all] [--tags] [--contains] [--abbrev=<n>] --dirty[=<mark>]\n"
"'git describe' <blob>\n"
msgstr ""
"'git describe' [--all] [--tags] [--contains] [--abbrev=<n>] [<commit-ish>...]\n"
"'git describe' [--all] [--tags] [--contains] [--abbrev=<n>] --dirty[=<mark>] 。\n"
"'git describe' <blob\n"

#. type: Plain text
#: en/git-describe.txt:24
#, priority:260
msgid "The command finds the most recent tag that is reachable from a commit.  If the tag points to the commit, then only the tag is shown.  Otherwise, it suffixes the tag name with the number of additional commits on top of the tagged object and the abbreviated object name of the most recent commit. The result is a \"human-readable\" object name which can also be used to identify the commit to other git commands."
msgstr "该命令找到可从提交中获取的最新标签。  如果标签指向该提交，则只显示该标签。  否则，它会在标签名后面加上附加提交的数量，以及最新提交的缩写对象名。其结果是一个 \"人类可读 \"的对象名称，也可用于识别其他git命令中的提交。"

#. type: Plain text
#: en/git-describe.txt:28
#, priority:260
msgid "By default (without --all or --tags) `git describe` only shows annotated tags.  For more information about creating annotated tags see the -a and -s options to linkgit:git-tag[1]."
msgstr "默认情况下（没有 --all 或 --tags）`git describe`只显示有注释的标签。  关于创建注释标签的更多信息，请参见linkgit:git-tag[1]的-a和-s选项。"

#. type: Plain text
#: en/git-describe.txt:34
#, priority:260
msgid "If the given object refers to a blob, it will be described as `<commit-ish>:<path>`, such that the blob can be found at `<path>` in the `<commit-ish>`, which itself describes the first commit in which this blob occurs in a reverse revision walk from HEAD."
msgstr "如果给定的对象指的是一个blob，它将被描述为`<commit-ish>:<path>`，这样就可以在`<commit-ish>`中的`<path>`找到这个blob，而这个blob本身就描述了从HEAD反向修订中出现的第一个提交。"

#. type: Labeled list
#: en/git-describe.txt:37
#, fuzzy, ignore-ellipsis, no-wrap, priority:260
msgid "<commit-ish>..."
msgstr "<commit-ish>..."

#. type: Plain text
#: en/git-describe.txt:39
#, priority:260
msgid "Commit-ish object names to describe.  Defaults to HEAD if omitted."
msgstr "要描述的类似于承诺的对象名称。  如果省略，则默认为HEAD。"

#. type: Labeled list
#: en/git-describe.txt:40
#, fuzzy, no-wrap, priority:260
msgid "--dirty[=<mark>]"
msgstr "--dirty[=<mark>]"

#. type: Labeled list
#: en/git-describe.txt:41
#, fuzzy, no-wrap, priority:260
msgid "--broken[=<mark>]"
msgstr "--broken[=<mark>]"

#. type: Plain text
#: en/git-describe.txt:49
#, priority:260
msgid "Describe the state of the working tree.  When the working tree matches HEAD, the output is the same as \"git describe HEAD\".  If the working tree has local modification \"-dirty\" is appended to it.  If a repository is corrupt and Git cannot determine if there is local modification, Git will error out, unless `--broken' is given, which appends the suffix \"-broken\" instead."
msgstr "描述工作树的状态。  当工作树与HEAD匹配时，其输出与 \"git describe HEAD \"相同。  如果工作树有本地修改，\"-dirty \"会被附加到它上面。  如果一个仓库被破坏了，而Git不能确定是否有本地修改，Git会出错，除非给了`--broken'，它将附加后缀\"-broken\"。"

#. type: Plain text
#: en/git-describe.txt:54
#, priority:260
msgid "Instead of using only the annotated tags, use any ref found in `refs/` namespace.  This option enables matching any known branch, remote-tracking branch, or lightweight tag."
msgstr "而不是只使用注释的标签，使用在`refs/`命名空间中发现的任何ref。  这个选项可以匹配任何已知的分支、远程跟踪分支或轻量级标签。"

#. type: Plain text
#: en/git-describe.txt:59
#, priority:260
msgid "Instead of using only the annotated tags, use any tag found in `refs/tags` namespace.  This option enables matching a lightweight (non-annotated) tag."
msgstr "而不是只使用注释过的标签，使用在`refs/tags`命名空间中发现的任何标签。  这个选项可以匹配轻量级（非注释的）标签。"

#. type: Labeled list
#: en/git-describe.txt:60
#, ignore-same, no-wrap, priority:260
msgid "--contains"
msgstr "--contains"

#. type: Plain text
#: en/git-describe.txt:64
#, priority:260
msgid "Instead of finding the tag that predates the commit, find the tag that comes after the commit, and thus contains it.  Automatically implies --tags."
msgstr "与其寻找提交前的标签，不如寻找提交后的标签，从而包含该标签。  自动暗示--标签。"

#. type: Plain text
#: en/git-describe.txt:71
#, priority:260
msgid "Instead of using the default number of hexadecimal digits (which will vary according to the number of objects in the repository with a default of 7) of the abbreviated object name, use <n> digits, or as many digits as needed to form a unique object name. An <n> of 0 will suppress long format, only showing the closest tag."
msgstr "不要使用缩写对象名称的默认十六进制数字（根据存储库中对象的数量而变化，默认为7），而是使用<n>数字，或根据需要使用任意多的数字来形成唯一的对象名称。<n>为0将抑制长格式，仅显示最近的标记。"

#. type: Labeled list
#: en/git-describe.txt:72
#, fuzzy, no-wrap, priority:260
msgid "--candidates=<n>"
msgstr "--candidates=<n>"

#. type: Plain text
#: en/git-describe.txt:78
#, priority:260
msgid "Instead of considering only the 10 most recent tags as candidates to describe the input commit-ish consider up to <n> candidates.  Increasing <n> above 10 will take slightly longer but may produce a more accurate result.  An <n> of 0 will cause only exact matches to be output."
msgstr "与其只考虑用最近的10个标签来描述输入的commit-ish，不如考虑最多<n>个候选人。  将<n>增加到10以上会花费更长的时间，但可能会产生一个更准确的结果。  <n>为0将导致只输出完全匹配的结果。"

#. type: Labeled list
#: en/git-describe.txt:79
#, ignore-same, no-wrap, priority:260
msgid "--exact-match"
msgstr "--exact-match"

#. type: Plain text
#: en/git-describe.txt:82
#, priority:260
msgid "Only output exact matches (a tag directly references the supplied commit).  This is a synonym for --candidates=0."
msgstr "只输出完全匹配的内容（一个标签直接引用所提供的提交）。  这是 --candidates=0 的同义词。"

#. type: Labeled list
#: en/git-describe.txt:83 en/git-ls-files.txt:190
#, ignore-same, no-wrap, priority:260
msgid "--debug"
msgstr "--debug"

#. type: Plain text
#: en/git-describe.txt:87
#, priority:260
msgid "Verbosely display information about the searching strategy being employed to standard error.  The tag name will still be printed to standard out."
msgstr "以粗略的方式向标准错误显示正在使用的搜索策略的信息。  标签名称仍将被打印到标准输出。"

#. type: Plain text
#: en/git-describe.txt:96
#, ignore-ellipsis, priority:260
msgid "Always output the long format (the tag, the number of commits and the abbreviated commit name) even when it matches a tag.  This is useful when you want to see parts of the commit object name in \"describe\" output, even when the commit in question happens to be a tagged version.  Instead of just emitting the tag name, it will describe such a commit as v1.2-0-gdeadbee (0th commit since tag v1.2 that points at object deadbee....)."
msgstr "总是输出长格式（标签、提交数量和提交名称的缩写），即使它与一个标签相匹配。  当你想在 \"describe \"输出中看到提交对象的部分名称时，这很有用，即使相关的提交恰好是一个有标签的版本。  它不会只发出标签名称，而是将这样的提交描述为v1.2-0-gdeadbee（标签v1.2后的第0次提交，指向对象deadbee....）。"

#. type: Labeled list
#: en/git-describe.txt:97
#, no-wrap, priority:260
msgid "--match <pattern>"
msgstr "--match <pattern>"

#. type: Plain text
#: en/git-describe.txt:106
#, priority:260
msgid "Only consider tags matching the given `glob(7)` pattern, excluding the \"refs/tags/\" prefix. If used with `--all`, it also considers local branches and remote-tracking references matching the pattern, excluding respectively \"refs/heads/\" and \"refs/remotes/\" prefix; references of other types are never considered. If given multiple times, a list of patterns will be accumulated, and tags matching any of the patterns will be considered.  Use `--no-match` to clear and reset the list of patterns."
msgstr "只考虑与给定的 `glob(7)` 模式匹配的标签，不包括 \"refs/tags/\" 前缀。如果和`--all`一起使用，它也会考虑匹配该模式的本地分支和远程跟踪引用，分别排除 \"refs/heads/\"和 \"refs/remotes/\"前缀；其他类型的引用永远不会被考虑。如果给出多次，将积累一个模式列表，匹配任何模式的标签都会被考虑。  使用`--no-match`来清除和重置模式列表。"

#. type: Labeled list
#: en/git-describe.txt:107 en/git-pack-refs.txt:72
#, no-wrap, priority:260
msgid "--exclude <pattern>"
msgstr "--排除<pattern>。"

#. type: Plain text
#: en/git-describe.txt:118
#, priority:260
msgid "Do not consider tags matching the given `glob(7)` pattern, excluding the \"refs/tags/\" prefix. If used with `--all`, it also does not consider local branches and remote-tracking references matching the pattern, excluding respectively \"refs/heads/\" and \"refs/remotes/\" prefix; references of other types are never considered. If given multiple times, a list of patterns will be accumulated and tags matching any of the patterns will be excluded. When combined with --match a tag will be considered when it matches at least one --match pattern and does not match any of the --exclude patterns. Use `--no-exclude` to clear and reset the list of patterns."
msgstr "不考虑与给定的 `glob(7)` 模式匹配的标签，排除 \"refs/tags/\"前缀。如果和`--all`一起使用，也不考虑匹配模式的本地分支和远程跟踪引用，分别排除 \"refs/heads/\"和 \"refs/remotes/\"前缀；其他类型的引用从不考虑。如果给定多次，将积累一个模式列表，匹配任何模式的标签将被排除。当与--match结合时，当一个标签至少匹配一个--match模式且不匹配任何--exclude模式时，将被考虑。使用`--no-exclude`来清除和重置模式列表。"

#. type: Labeled list
#: en/git-describe.txt:119 en/git-diff-tree.txt:120 en/git-format-patch.txt:194 en/git-name-rev.txt:84
#, ignore-same, no-wrap, priority:260
msgid "--always"
msgstr "--always"

#. type: Plain text
#: en/git-describe.txt:121 en/git-name-rev.txt:86
#, priority:260
msgid "Show uniquely abbreviated commit object as fallback."
msgstr "显示唯一缩写的提交对象作为后备。"

#. type: Plain text
#: en/git-describe.txt:126
#, priority:260
msgid "Follow only the first parent commit upon seeing a merge commit.  This is useful when you wish to not match tags on branches merged in the history of the target commit."
msgstr "在看到合并提交时，只跟随第一个父提交。  当你希望不匹配目标提交历史中合并的分支上的标签时，这很有用。"

#. type: Plain text
#: en/git-describe.txt:131
#, priority:260
msgid "With something like git.git current tree, I get:"
msgstr "用git.git当前树这样的东西，我得到了。"

#. type: Plain text
#: en/git-describe.txt:134
#, fuzzy, no-wrap, priority:260
msgid ""
"\t[torvalds@g5 git]$ git describe parent\n"
"\tv1.0.4-14-g2414721\n"
msgstr ""
"\t[torvalds@g5 git]$ git describe parent\n"
"\tv1.0.4-14-g2414721\n"

#. type: Plain text
#: en/git-describe.txt:140
#, priority:260
msgid "i.e. the current head of my \"parent\" branch is based on v1.0.4, but since it has a few commits on top of that, describe has added the number of additional commits (\"14\") and an abbreviated object name for the commit itself (\"2414721\")  at the end."
msgstr "也就是说，我的 \"父 \"分支的当前头部是基于v1.0.4的，但由于它在此基础上有一些提交，所以describe在最后添加了额外的提交数量（\"14\"）和提交本身的缩写对象名称（\"2414721\"）。"

#. type: Plain text
#: en/git-describe.txt:151
#, fuzzy, priority:260
#| msgid "The number of additional commits is the number of commits which would be displayed by \"git log v1.0.4..parent\".  The hash suffix is \"-g\" + unambiguous abbreviation for the tip commit of parent (which was `2414721b194453f058079d897d13c4e377f92dc6`).  The \"g\" prefix stands for \"git\" and is used to allow describing the version of a software depending on the SCM the software is managed with. This is useful in an environment where people may use different SCMs."
msgid "The number of additional commits is the number of commits which would be displayed by \"git log v1.0.4..parent\".  The hash suffix is \"-g\" + an unambiguous abbreviation for the tip commit of parent (which was `2414721b194453f058079d897d13c4e377f92dc6`). The length of the abbreviation scales as the repository grows, using the approximate number of objects in the repository and a bit of math around the birthday paradox, and defaults to a minimum of 7.  The \"g\" prefix stands for \"git\" and is used to allow describing the version of a software depending on the SCM the software is managed with. This is useful in an environment where people may use different SCMs."
msgstr "额外提交的数量是 \"git log v1.0.4...parent \"所能显示的提交的数量。  哈希后缀是\"-g \"+ parent的提示提交的明确缩写（即`2414721b194453f058079d897d13c4e377f92dc6`）。  前缀 \"g \"代表 \"git\"，用于描述软件的版本，取决于软件管理的SCM。这在人们可能使用不同SCM的环境中很有用。"

#. type: Plain text
#: en/git-describe.txt:153
#, priority:260
msgid "Doing a 'git describe' on a tag-name will just show the tag name:"
msgstr "对一个标签名做 \"git describe\"，只会显示标签名。"

#. type: Plain text
#: en/git-describe.txt:156
#, fuzzy, no-wrap, priority:260
msgid ""
"\t[torvalds@g5 git]$ git describe v1.0.4\n"
"\tv1.0.4\n"
msgstr ""
"\t[torvalds@g5 git]$ git describe v1.0.4\n"
"\tv1.0.4\n"

#. type: Plain text
#: en/git-describe.txt:159
#, priority:260
msgid "With --all, the command can use branch heads as references, so the output shows the reference path as well:"
msgstr "使用--all，命令可以使用分支头作为参考，所以输出也会显示参考路径。"

#. type: Plain text
#: en/git-describe.txt:162
#, fuzzy, no-wrap, priority:260
msgid ""
"\t[torvalds@g5 git]$ git describe --all --abbrev=4 v1.0.5^2\n"
"\ttags/v1.0.0-21-g975b\n"
msgstr ""
"\t[torvalds@g5 git]$ git describe --all --abbrev=4 v1.0.5^2\n"
"\ttags/v1.0.0-21-g975b\n"

#. type: Plain text
#: en/git-describe.txt:165
#, fuzzy, no-wrap, priority:260
msgid ""
"\t[torvalds@g5 git]$ git describe --all --abbrev=4 HEAD^\n"
"\theads/lt/describe-7-g975b\n"
msgstr ""
"\t[torvalds@g5 git]$ git describe --all --abbrev=4 HEAD^\n"
"\theads/lt/describe-7-g975b\n"

#. type: Plain text
#: en/git-describe.txt:168
#, priority:260
msgid "With --abbrev set to 0, the command can be used to find the closest tagname without any suffix:"
msgstr "在--abbrev设置为0的情况下，该命令可以用来寻找最接近的没有任何后缀的tagname。"

#. type: Plain text
#: en/git-describe.txt:171
#, fuzzy, no-wrap, priority:260
msgid ""
"\t[torvalds@g5 git]$ git describe --abbrev=0 v1.0.5^2\n"
"\ttags/v1.0.0\n"
msgstr ""
"\t[torvalds@g5 git]$ git describe --abbrev=0 v1.0.5^2\n"
"\ttags/v1.0.0\n"

#. type: Plain text
#: en/git-describe.txt:177
#, priority:260
msgid "Note that the suffix you get if you type these commands today may be longer than what Linus saw above when he ran these commands, as your Git repository may have new commits whose object names begin with 975b that did not exist back then, and \"-g975b\" suffix alone may not be sufficient to disambiguate these commits."
msgstr "请注意，如果你今天输入这些命令，得到的后缀可能比上面Linus运行这些命令时看到的要长，因为你的Git仓库可能有新的提交，其对象名称以975b开头，而这些提交在当时并不存在，仅靠\"-g975b \"后缀可能还不足以区分这些提交。"

#. type: Title -
#: en/git-describe.txt:180
#, no-wrap, priority:260
msgid "SEARCH STRATEGY"
msgstr "搜索策略"

#. type: Plain text
#: en/git-describe.txt:187
#, priority:260
msgid "For each commit-ish supplied, 'git describe' will first look for a tag which tags exactly that commit.  Annotated tags will always be preferred over lightweight tags, and tags with newer dates will always be preferred over tags with older dates.  If an exact match is found, its name will be output and searching will stop."
msgstr "对于提供的每个提交，'git describe'将首先寻找一个标签，该标签正是该提交的标签。  有注释的标签总是比轻量级的标签更受欢迎，日期较新的标签总是比日期较老的标签更受欢迎。  如果找到一个完全匹配的标签，它的名字就会被输出，搜索就会停止。"

#. type: Plain text
#: en/git-describe.txt:194
#, priority:260
msgid "If an exact match was not found, 'git describe' will walk back through the commit history to locate an ancestor commit which has been tagged.  The ancestor's tag will be output along with an abbreviation of the input commit-ish's SHA-1. If `--first-parent` was specified then the walk will only consider the first parent of each commit."
msgstr "如果没有找到完全匹配的，'git describe'会回溯提交历史，找到一个已经被标记的祖先提交。  该祖先的标签将与输入的提交的SHA-1的缩写一起被输出。如果指定了 `--first-parent`，那么回溯将只考虑每个提交的第一个父级。"

#. type: Plain text
#: en/git-describe.txt:200
#, priority:260
msgid "If multiple tags were found during the walk then the tag which has the fewest commits different from the input commit-ish will be selected and output.  Here fewest commits different is defined as the number of commits which would be shown by `git log tag..input` will be the smallest number of commits possible."
msgstr "如果在行走过程中发现了多个标签，那么将选择与输入的commit-ish相差最少的标签并输出。  这里，最小的提交差异被定义为 \"git log tag...input \"所显示的提交数量将是最小的提交数量。"

#. type: Plain text
#: en/git-describe.txt:208
#, fuzzy, priority:260
#| msgid "Tree objects as well as tag objects not pointing at commits, cannot be described.  When describing blobs, the lightweight tags pointing at blobs are ignored, but the blob is still described as <committ-ish>:<path> despite the lightweight tag being favorable."
msgid "Tree objects as well as tag objects not pointing at commits, cannot be described.  When describing blobs, the lightweight tags pointing at blobs are ignored, but the blob is still described as <commit-ish>:<path> despite the lightweight tag being favorable."
msgstr "树对象以及不指向提交的标签对象，不能被描述。  在描述blob时，指向blob的轻量级标签会被忽略，但尽管轻量级标签是有利的，blob仍然被描述为<committ-ish>:<path>。"

#. type: Title =
#: en/git-diff-files.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-diff-files(1)"
msgstr "git-diff-files(1)"

#. type: Plain text
#: en/git-diff-files.txt:7
#, priority:100
msgid "git-diff-files - Compares files in the working tree and the index"
msgstr "git-diff-files - 对比工作区和索引中的文件"

#. type: Plain text
#: en/git-diff-files.txt:13
#, fuzzy, ignore-ellipsis, no-wrap, priority:100
msgid "'git diff-files' [-q] [-0 | -1 | -2 | -3 | -c | --cc] [<common-diff-options>] [<path>...]\n"
msgstr "'git diff-files' [-q] [-0|-1|-2|-3|-c|--cc] [<common-diff-options>] [<path>...]\n"

#. type: Plain text
#: en/git-diff-files.txt:20
#, priority:100
msgid "Compares the files in the working tree and the index.  When paths are specified, compares only those named paths.  Otherwise all entries in the index are compared.  The output format is the same as for 'git diff-index' and 'git diff-tree'."
msgstr "比较工作区和索引中的文件。 当指定路径时，只比较那些命名的路径。 否则就比较索引中的所有条目。 输出格式与 'git diff-index' 和 'git diff-tree' 的相同。"

#. type: Labeled list
#: en/git-diff-files.txt:25 en/git-diff.txt:128
#, no-wrap, priority:280
msgid "-1 --base"
msgstr "-1 --基地"

#. type: Labeled list
#: en/git-diff-files.txt:26 en/git-diff.txt:129
#, fuzzy, no-wrap, priority:280
msgid "-2 --ours"
msgstr "-2 --ours"

#. type: Labeled list
#: en/git-diff-files.txt:27 en/git-diff.txt:130
#, fuzzy, no-wrap, priority:280
msgid "-3 --theirs"
msgstr "-3 --theirs"

#. type: Labeled list
#: en/git-diff-files.txt:28 en/git-diff.txt:137
#, ignore-same, no-wrap, priority:280
msgid "-0"
msgstr "-0"

#. type: Plain text
#: en/git-diff-files.txt:32
#, priority:100
msgid "Diff against the \"base\" version, \"our branch\" or \"their branch\" respectively.  With these options, diffs for merged entries are not shown."
msgstr "分别与 “基础” 版本、“我们的分支” 或 “他们的分支” 进行比较。 有了这些选项，合并后的条目的差异就不会显示。"

#. type: Plain text
#: en/git-diff-files.txt:36
#, priority:100
msgid "The default is to diff against our branch (-2) and the cleanly resolved paths.  The option -0 can be given to omit diff output for unmerged entries and just show \"Unmerged\"."
msgstr "默认是针对我们的分支 (-2) 和干净的解决路径进行差异比对。 可以给出选项 -0 来省略未合并的条目的差异输出，只显示 \"Unmerged\"。"

#. type: Plain text
#: en/git-diff-files.txt:43
#, priority:100
msgid "This compares stage 2 (our branch), stage 3 (their branch) and the working tree file and outputs a combined diff, similar to the way 'diff-tree' shows a merge commit with these flags."
msgstr "这将比较第二阶段（我们的分支）、第三阶段（他们的分支）和工作区文件，并输出一个综合的差异，类似于 'diff-tree' 显示带有这些标志的合并提交。"

#. type: Plain text
#: en/git-diff-files.txt:46
#, priority:100
msgid "Remain silent even on nonexistent files"
msgstr "即使对不存在的文件也保持沉默"

#. type: Title =
#: en/git-diff-index.txt:2
#, ignore-same, no-wrap, priority:80
msgid "git-diff-index(1)"
msgstr "git-diff-index(1)"

#. type: Plain text
#: en/git-diff-index.txt:7
#, priority:80
msgid "git-diff-index - Compare a tree to the working tree or index"
msgstr ""

#. type: Plain text
#: en/git-diff-index.txt:13
#, fuzzy, ignore-ellipsis, no-wrap, priority:80
msgid "'git diff-index' [-m] [--cached] [--merge-base] [<common-diff-options>] <tree-ish> [<path>...]\n"
msgstr "'git diff-index' [-m] [--cached] [--merge-base] [<common-diff-options>] <tree-ish> [<path>...]\n"

#. type: Plain text
#: en/git-diff-index.txt:21
#, priority:80
msgid "Compares the content and mode of the blobs found in a tree object with the corresponding tracked files in the working tree, or with the corresponding paths in the index.  When <path> arguments are present, compares only paths matching those patterns.  Otherwise all tracked files are compared."
msgstr ""

#. type: Plain text
#: en/git-diff-index.txt:28
#, priority:80
msgid "The id of a tree object to diff against."
msgstr ""

#. type: Plain text
#: en/git-diff-index.txt:31
#, priority:80
msgid "Do not consider the on-disk file at all."
msgstr ""

#. type: Labeled list
#: en/git-diff-index.txt:32 en/git-diff-tree.txt:46 en/git-show-branch.txt:82
#, ignore-same, no-wrap, priority:100
msgid "--merge-base"
msgstr "--merge-base"

#. type: Plain text
#: en/git-diff-index.txt:36
#, priority:80
msgid "Instead of comparing <tree-ish> directly, use the merge base between <tree-ish> and HEAD instead.  <tree-ish> must be a commit."
msgstr ""

#. type: Plain text
#: en/git-diff-index.txt:42
#, priority:80
msgid "By default, files recorded in the index but not checked out are reported as deleted.  This flag makes 'git diff-index' say that all non-checked-out files are up to date."
msgstr ""

#. type: Title -
#: en/git-diff-index.txt:46
#, no-wrap, priority:80
msgid "OPERATING MODES"
msgstr ""

#. type: Plain text
#: en/git-diff-index.txt:51
#, priority:80
msgid "You can choose whether you want to trust the index file entirely (using the `--cached` flag) or ask the diff logic to show any files that don't match the stat state as being \"tentatively changed\".  Both of these operations are very useful indeed."
msgstr ""

#. type: Title -
#: en/git-diff-index.txt:53
#, no-wrap, priority:80
msgid "CACHED MODE"
msgstr ""

#. type: Plain text
#: en/git-diff-index.txt:55
#, priority:80
msgid "If `--cached` is specified, it allows you to ask:"
msgstr ""

#. type: Plain text
#: en/git-diff-index.txt:58
#, no-wrap, priority:80
msgid ""
"\tshow me the differences between HEAD and the current index\n"
"\tcontents (the ones I'd write using 'git write-tree')\n"
msgstr ""

#. type: Plain text
#: en/git-diff-index.txt:63
#, priority:80
msgid "For example, let's say that you have worked on your working directory, updated some files in the index and are ready to commit. You want to see exactly *what* you are going to commit, without having to write a new tree object and compare it that way, and to do that, you just do"
msgstr ""

#. type: Plain text
#: en/git-diff-index.txt:65
#, no-wrap, priority:80
msgid "\tgit diff-index --cached HEAD\n"
msgstr ""

#. type: Plain text
#: en/git-diff-index.txt:70
#, priority:80
msgid "Example: let's say I had renamed `commit.c` to `git-commit.c`, and I had done an `update-index` to make that effective in the index file.  `git diff-files` wouldn't show anything at all, since the index file matches my working directory. But doing a 'git diff-index' does:"
msgstr ""

#. type: Plain text
#: en/git-diff-index.txt:74
#, fuzzy, no-wrap, priority:80
msgid ""
"  torvalds@ppc970:~/git> git diff-index --cached HEAD\n"
"  :100644 000000 4161aecc6700a2eb579e842af0b7f22b98443f74 0000000000000000000000000000000000000000 D\tcommit.c\n"
"  :000000 100644 0000000000000000000000000000000000000000 4161aecc6700a2eb579e842af0b7f22b98443f74 A\tgit-commit.c\n"
msgstr ""
"  torvalds@ppc970:~/git> git diff-index --cached HEAD\n"
"  -100644 blob    4161aecc6700a2eb579e842af0b7f22b98443f74        commit.c\n"
"  +100644 blob    4161aecc6700a2eb579e842af0b7f22b98443f74        git-commit.c\n"

#. type: Plain text
#: en/git-diff-index.txt:76
#, priority:80
msgid "You can see easily that the above is a rename."
msgstr ""

#. type: Plain text
#: en/git-diff-index.txt:80
#, priority:80
msgid "In fact, `git diff-index --cached` *should* always be entirely equivalent to actually doing a 'git write-tree' and comparing that. Except this one is much nicer for the case where you just want to check where you are."
msgstr ""

#. type: Plain text
#: en/git-diff-index.txt:84
#, priority:80
msgid "So doing a `git diff-index --cached` is basically very useful when you are asking yourself \"what have I already marked for being committed, and what's the difference to a previous tree\"."
msgstr ""

#. type: Title -
#: en/git-diff-index.txt:86
#, no-wrap, priority:80
msgid "NON-CACHED MODE"
msgstr ""

#. type: Plain text
#: en/git-diff-index.txt:91
#, priority:80
msgid "The \"non-cached\" mode takes a different approach, and is potentially the more useful of the two in that what it does can't be emulated with a 'git write-tree' + 'git diff-tree'. Thus that's the default mode.  The non-cached version asks the question:"
msgstr ""

#. type: Plain text
#: en/git-diff-index.txt:94
#, no-wrap, priority:80
msgid ""
"  show me the differences between HEAD and the currently checked out\n"
"  tree - index contents _and_ files that aren't up to date\n"
msgstr ""

#. type: Plain text
#: en/git-diff-index.txt:98
#, priority:80
msgid "which is obviously a very useful question too, since that tells you what you *could* commit. Again, the output matches the 'git diff-tree -r' output to a tee, but with a twist."
msgstr ""

#. type: Plain text
#: en/git-diff-index.txt:104
#, priority:80
msgid "The twist is that if some file doesn't match the index, we don't have a backing store thing for it, and we use the magic \"all-zero\" sha1 to show that. So let's say that you have edited `kernel/sched.c`, but have not actually done a 'git update-index' on it yet - there is no \"object\" associated with the new state, and you get:"
msgstr ""

#. type: Plain text
#: en/git-diff-index.txt:107
#, no-wrap, priority:80
msgid ""
"  torvalds@ppc970:~/v2.6/linux> git diff-index --abbrev HEAD\n"
"  :100644 100644 7476bb5ba 000000000 M\tkernel/sched.c\n"
msgstr ""

#. type: Plain text
#: en/git-diff-index.txt:112
#, priority:80
msgid "i.e., it shows that the tree has changed, and that `kernel/sched.c` is not up to date and may contain new stuff. The all-zero sha1 means that to get the real diff, you need to look at the object in the working directory directly rather than do an object-to-object diff."
msgstr ""

#. type: Plain text
#: en/git-diff-index.txt:118
#, priority:80
msgid "As with other commands of this type, 'git diff-index' does not actually look at the contents of the file at all. So maybe `kernel/sched.c` hasn't actually changed, and it's just that you touched it. In either case, it's a note that you need to 'git update-index' it to make the index be in sync."
msgstr ""

#. type: Plain text
#: en/git-diff-index.txt:124
#, priority:80
msgid "You can have a mixture of files show up as \"has been updated\" and \"is still dirty in the working directory\" together. You can always tell which file is in which state, since the \"has been updated\" ones show a valid sha1, and the \"not in sync with the index\" ones will always have the special all-zero sha1."
msgstr ""

#. type: Title =
#: en/git-difftool.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-difftool(1)"
msgstr "git-difftool(1)"

#. type: Plain text
#: en/git-difftool.txt:7
#, priority:100
msgid "git-difftool - Show changes using common diff tools"
msgstr "git-difftool - 使用常见的差异工具显示变化"

#. type: Plain text
#: en/git-difftool.txt:12
#, fuzzy, ignore-ellipsis, no-wrap, priority:100
msgid "'git difftool' [<options>] [<commit> [<commit>]] [--] [<path>...]\n"
msgstr "'git difftool' [<options>] [<commit> [<commit>]] [--] [<path>...]\n"

#. type: Plain text
#: en/git-difftool.txt:19
#, fuzzy, priority:100
msgid "'git difftool' is a Git command that allows you to compare and edit files between revisions using common diff tools.  'git difftool' is a frontend to 'git diff' and accepts the same options and arguments. See linkgit:git-diff[1]."
msgstr "'git difftool' is a Git command that allows you to compare and edit files between revisions using common diff tools.  'git difftool' is a frontend to 'git diff' and accepts the same options and arguments. See linkgit:git-diff[1]."

#. type: Labeled list
#: en/git-difftool.txt:23
#, ignore-same, no-wrap, priority:100
msgid "--dir-diff"
msgstr "--dir-diff"

#. type: Plain text
#: en/git-difftool.txt:27
#, priority:100
msgid "Copy the modified files to a temporary location and perform a directory diff on them. This mode never prompts before launching the diff tool."
msgstr "把修改过的文件复制到一个临时位置，然后对它们进行目录比较。这种模式在启动差异工具之前从不提示。"

#. type: Labeled list
#: en/git-difftool.txt:28 en/git-mergetool.txt:70
#, ignore-same, no-wrap, priority:240
msgid "-y"
msgstr "-y"

#. type: Labeled list
#: en/git-difftool.txt:29 en/git-mergetool.txt:71
#, ignore-same, no-wrap, priority:240
msgid "--no-prompt"
msgstr "--no-prompt"

#. type: Plain text
#: en/git-difftool.txt:31
#, priority:100
msgid "Do not prompt before launching a diff tool."
msgstr "在启动差异工具之前不要提示。"

#. type: Labeled list
#: en/git-difftool.txt:32 en/git-mergetool.txt:78
#, ignore-same, no-wrap, priority:240
msgid "--prompt"
msgstr "--prompt"

#. type: Plain text
#: en/git-difftool.txt:36
#, priority:100
msgid "Prompt before each invocation of the diff tool.  This is the default behaviour; the option is provided to override any configuration settings."
msgstr "在每次调用差异工具之前提示。 这是默认行为；提供该选项是为了覆盖任何配置设置。"

#. type: Plain text
#: en/git-difftool.txt:40
#, priority:100
msgid "Start showing the diff for the given path, the paths before it will move to end and output."
msgstr "开始显示给定路径的差异，在它之前的路径将移动到终点并输出。"

#. type: Plain text
#: en/git-difftool.txt:44
#, priority:100
msgid "Start showing the diff for the given path, skipping all the paths before it."
msgstr "开始显示给定路径的差异，跳过前面所有的路径。"

#. type: Labeled list
#: en/git-difftool.txt:45 en/git-mergetool.txt:27
#, fuzzy, no-wrap, priority:240
msgid "-t <tool>"
msgstr "-t <tool>"

#. type: Labeled list
#: en/git-difftool.txt:46 en/git-mergetool.txt:28
#, fuzzy, no-wrap, priority:240
msgid "--tool=<tool>"
msgstr "--tool=<tool>"

#. type: Plain text
#: en/git-difftool.txt:50
#, priority:100
msgid "Use the diff tool specified by <tool>.  Valid values include emerge, kompare, meld, and vimdiff. Run `git difftool --tool-help` for the list of valid <tool> settings."
msgstr "使用由 <工具> 指定的差异工具。 有效值包括 emerge, kompare, meld, 和 vimdiff。运行 `git difftool --tool-help` 以获得有效的 <工具> 设置列表。"

#. type: Plain text
#: en/git-difftool.txt:55
#, priority:100
msgid "If a diff tool is not specified, 'git difftool' will use the configuration variable `diff.tool`.  If the configuration variable `diff.tool` is not set, 'git difftool' will pick a suitable default."
msgstr "如果没有指定差异工具，'git difftool' 将使用配置变量 `diff.tool`。 如果配置变量 `diff.tool` 没有设置，'git difftool' 将选择一个合适的默认值。"

#. type: Plain text
#: en/git-difftool.txt:61
#, priority:100
msgid "You can explicitly provide a full path to the tool by setting the configuration variable `difftool.<tool>.path`. For example, you can configure the absolute path to kdiff3 by setting `difftool.kdiff3.path`. Otherwise, 'git difftool' assumes the tool is available in PATH."
msgstr "你可以通过设置配置变量 `difftool.<工具>.path` 来明确提供工具的完整路径。例如，你可以通过设置 `difftool.kdiff3.path` 来配置 kdiff3 的绝对路径。否则，'git difftool' 会假定该工具在 PATH 中可用。"

#. type: Plain text
#: en/git-difftool.txt:66
#, priority:100
msgid "Instead of running one of the known diff tools, 'git difftool' can be customized to run an alternative program by specifying the command line to invoke in a configuration variable `difftool.<tool>.cmd`."
msgstr "通过在配置变量 `difftool.<工具>.cmd` 中指定要调用的命令行，可以定制 'git difftool'，而不是运行一个已知的比较工具，以运行一个替代程序。"

#. type: Plain text
#: en/git-difftool.txt:76
#, priority:100
msgid "When 'git difftool' is invoked with this tool (either through the `-t` or `--tool` option or the `diff.tool` configuration variable)  the configured command line will be invoked with the following variables available: `$LOCAL` is set to the name of the temporary file containing the contents of the diff pre-image and `$REMOTE` is set to the name of the temporary file containing the contents of the diff post-image.  `$MERGED` is the name of the file which is being compared. `$BASE` is provided for compatibility with custom merge tool commands and has the same value as `$MERGED`."
msgstr "当 'git difftool' 与此工具一起调用时（通过 `-t` 或 `--tool` 选项或 `diff.tool` 配置变量），配置的命令行将被调用，以下变量可用： `$LOCAL` 被设置为包含差异比对前图像内容的临时文件名，`$REMOTE` 被设置为包含差异比对后图像内容的临时文件名。 `$MERGED` 是被比较的文件的名称。`$BASE` 是为了与自定义合并工具命令兼容而提供的，其值与 `$MERGED` 相同。"

#. type: Labeled list
#: en/git-difftool.txt:77 en/git-mergetool.txt:67
#, ignore-same, no-wrap, priority:240
msgid "--tool-help"
msgstr "--tool-help"

#. type: Plain text
#: en/git-difftool.txt:79
#, priority:100
msgid "Print a list of diff tools that may be used with `--tool`."
msgstr "列出可以和\"--tool\"命令一起使用的diff工具。"

#. type: Labeled list
#: en/git-difftool.txt:80
#, ignore-same, no-wrap, priority:100
msgid "--[no-]symlinks"
msgstr "--[no-]symlinks"

#. type: Plain text
#: en/git-difftool.txt:85
#, fuzzy, priority:100
msgid "'git difftool''s default behavior is create symlinks to the working tree when run in `--dir-diff` mode and the right-hand side of the comparison yields the same content as the file in the working tree."
msgstr "'git difftool''s default behavior is create symlinks to the working tree when run in `--dir-diff` mode and the right-hand side of the comparison yields the same content as the file in the working tree."

#. type: Plain text
#: en/git-difftool.txt:88
#, priority:100
msgid "Specifying `--no-symlinks` instructs 'git difftool' to create copies instead.  `--no-symlinks` is the default on Windows."
msgstr "指定 `---no-symlinks` 会指示 'git difftool' 创建副本。 `--no-symlinks` 是 Windows 上的默认值。"

#. type: Labeled list
#: en/git-difftool.txt:89
#, no-wrap, priority:100
msgid "-x <command>"
msgstr "-x <命令>"

#. type: Labeled list
#: en/git-difftool.txt:90
#, fuzzy, no-wrap, priority:100
msgid "--extcmd=<command>"
msgstr "--extcmd=<command>"

#. type: Plain text
#: en/git-difftool.txt:95
#, priority:100
msgid "Specify a custom command for viewing diffs.  'git-difftool' ignores the configured defaults and runs `$command $LOCAL $REMOTE` when this option is specified.  Additionally, `$BASE` is set in the environment."
msgstr "指定一个用于查看差异的自定义命令。 'git-difftool' 忽略了配置的默认值，当这个选项被指定时，运行`$command $LOCAL $REMOTE`。 此外，`$BASE`在环境中被设置。"

#. type: Labeled list
#: en/git-difftool.txt:96 en/git-help.txt:70 en/git-mergetool.txt:82 en/git-show-branch.txt:110 en/git-update-index.txt:127 en/rev-list-options.txt:302
#, ignore-same, no-wrap, priority:260
msgid "-g"
msgstr "-g"

#. type: Labeled list
#: en/git-difftool.txt:97
#, ignore-same, no-wrap, priority:100
msgid "--[no-]gui"
msgstr "--[no-]gui"

#. type: Plain text
#: en/git-difftool.txt:106
#, fuzzy, priority:100
#| msgid "When 'git-mergetool' is invoked with the `-g` or `--gui` option the default merge tool will be read from the configured `merge.guitool` variable instead of `merge.tool`. If `merge.guitool` is not set, we will fallback to the tool configured under `merge.tool`."
msgid "When 'git-difftool' is invoked with the `-g` or `--gui` option the default diff tool will be read from the configured `diff.guitool` variable instead of `diff.tool`. This may be selected automatically using the configuration variable `difftool.guiDefault`. The `--no-gui` option can be used to override these settings. If `diff.guitool` is not set, we will fallback in the order of `merge.guitool`, `diff.tool`, `merge.tool` until a tool is found."
msgstr "当'git-mergetool'以`-g`或`--gui`选项调用时，默认的合并工具将从配置的`merge.guitool`变量读取，而不是`merge.tool`。如果`merge.guitool`没有设置，git将会使用`merge.tool`配置的工具。"

#. type: Labeled list
#: en/git-difftool.txt:107
#, ignore-same, no-wrap, priority:100
msgid "--[no-]trust-exit-code"
msgstr "--[no-]trust-exit-code"

#. type: Plain text
#: en/git-difftool.txt:112
#, priority:100
msgid "'git-difftool' invokes a diff tool individually on each file.  Errors reported by the diff tool are ignored by default.  Use `--trust-exit-code` to make 'git-difftool' exit when an invoked diff tool returns a non-zero exit code."
msgstr "'git-difftool' 在每个文件上单独调用一个差异工具。 默认情况下，差异工具报告的错误会被忽略。 使用 `--trust-exit-code` 使 'git-difftool' 在被调用的差异工具返回非零的退出代码时退出。"

#. type: Plain text
#: en/git-difftool.txt:115
#, priority:100
msgid "'git-difftool' will forward the exit code of the invoked tool when `--trust-exit-code` is used."
msgstr "'git-difftool' 在使用 `--trust-exit-code` 时将转发被调用工具的退出代码。"

#. type: Plain text
#: en/git-difftool.txt:117
#, priority:100
msgid "See linkgit:git-diff[1] for the full list of supported options."
msgstr "关于支持的选项的完整列表，见 linkgit:git-diff[1]。"

#. type: Plain text
#: en/git-difftool.txt:122
#, priority:100
msgid "'git difftool' falls back to 'git mergetool' config variables when the difftool equivalents have not been defined."
msgstr "当差异工具等价物没有被定义时，'git difftool' 会返回到 'git mergetool' 配置变量。"

#. type: Plain text
#: en/git-difftool.txt:131
#, priority:100
msgid "Show changes between commits, commit and working tree, etc"
msgstr "显示提交之间的变化，提交和工作区，等等"

#. type: Plain text
#: en/git-difftool.txt:134
#, priority:100
msgid "Run merge conflict resolution tools to resolve merge conflicts"
msgstr "运行合并冲突解决工具来解决合并冲突"

#. type: Plain text
#: en/git-difftool.txt:137
#, priority:100
msgid "Get and set repository or global options"
msgstr "获取和设置仓库或全局选项"

#. type: Title =
#: en/git-diff-tree.txt:2
#, ignore-same, no-wrap, priority:80
msgid "git-diff-tree(1)"
msgstr "git-diff-tree(1)"

#. type: Plain text
#: en/git-diff-tree.txt:7
#, priority:80
msgid "git-diff-tree - Compares the content and mode of blobs found via two tree objects"
msgstr ""

#. type: Plain text
#: en/git-diff-tree.txt:15
#, ignore-ellipsis, no-wrap, priority:80
msgid ""
"'git diff-tree' [--stdin] [-m] [-s] [-v] [--no-commit-id] [--pretty]\n"
"\t      [-t] [-r] [-c | --cc] [--combined-all-paths] [--root] [--merge-base]\n"
"\t      [<common-diff-options>] <tree-ish> [<tree-ish>] [<path>...]\n"
msgstr ""

#. type: Plain text
#: en/git-diff-tree.txt:19
#, priority:80
msgid "Compares the content and mode of the blobs found via two tree objects."
msgstr ""

#. type: Plain text
#: en/git-diff-tree.txt:22
#, priority:80
msgid "If there is only one <tree-ish> given, the commit is compared with its parents (see --stdin below)."
msgstr ""

#. type: Plain text
#: en/git-diff-tree.txt:24
#, priority:80
msgid "Note that 'git diff-tree' can use the tree encapsulated in a commit object."
msgstr ""

#. type: Plain text
#: en/git-diff-tree.txt:31
#, priority:80
msgid "The id of a tree object."
msgstr ""

#. type: Labeled list
#: en/git-diff-tree.txt:32 en/git-diff.txt:142 en/git-submodule.txt:448
#, ignore-ellipsis, no-wrap, priority:280
msgid "<path>..."
msgstr "<路径>..."

#. type: Plain text
#: en/git-diff-tree.txt:35
#, priority:80
msgid "If provided, the results are limited to a subset of files matching one of the provided pathspecs."
msgstr ""

#. type: Plain text
#: en/git-diff-tree.txt:38
#, priority:80
msgid "recurse into sub-trees"
msgstr ""

#. type: Plain text
#: en/git-diff-tree.txt:41
#, priority:80
msgid "show tree entry itself as well as subtrees.  Implies -r."
msgstr ""

#. type: Plain text
#: en/git-diff-tree.txt:45
#, priority:80
msgid "When `--root` is specified the initial commit will be shown as a big creation event. This is equivalent to a diff against the NULL tree."
msgstr ""

#. type: Plain text
#: en/git-diff-tree.txt:50
#, priority:80
msgid "Instead of comparing the <tree-ish>s directly, use the merge base between the two <tree-ish>s as the \"before\" side.  There must be two <tree-ish>s given and they must both be commits."
msgstr ""

#. type: Plain text
#: en/git-diff-tree.txt:57
#, priority:80
msgid "When `--stdin` is specified, the command does not take <tree-ish> arguments from the command line.  Instead, it reads lines containing either two <tree>, one <commit>, or a list of <commit> from its standard input.  (Use a single space as separator.)"
msgstr ""

#. type: Plain text
#: en/git-diff-tree.txt:62
#, priority:80
msgid "When two trees are given, it compares the first tree with the second.  When a single commit is given, it compares the commit with its parents.  The remaining commits, when given, are used as if they are parents of the first commit."
msgstr ""

#. type: Plain text
#: en/git-diff-tree.txt:67
#, priority:80
msgid "When comparing two trees, the ID of both trees (separated by a space and terminated by a newline) is printed before the difference.  When comparing commits, the ID of the first (or only) commit, followed by a newline, is printed."
msgstr ""

#. type: Plain text
#: en/git-diff-tree.txt:70
#, priority:80
msgid "The following flags further affect the behavior when comparing commits (but not trees)."
msgstr ""

#. type: Plain text
#: en/git-diff-tree.txt:76
#, priority:80
msgid "By default, 'git diff-tree --stdin' does not show differences for merge commits.  With this flag, it shows differences to that commit from all of its parents. See also `-c`."
msgstr ""

#. type: Plain text
#: en/git-diff-tree.txt:82
#, priority:80
msgid "By default, 'git diff-tree --stdin' shows differences, either in machine-readable form (without `-p`) or in patch form (with `-p`).  This output can be suppressed.  It is only useful with `-v` flag."
msgstr ""

#. type: Plain text
#: en/git-diff-tree.txt:86
#, priority:80
msgid "This flag causes 'git diff-tree --stdin' to also show the commit message before the differences."
msgstr ""

#. type: Labeled list
#: en/git-diff-tree.txt:89
#, ignore-same, no-wrap, priority:80
msgid "--no-commit-id"
msgstr "--no-commit-id"

#. type: Plain text
#: en/git-diff-tree.txt:92
#, priority:80
msgid "'git diff-tree' outputs a line with the commit ID when applicable.  This flag suppressed the commit ID output."
msgstr ""

#. type: Plain text
#: en/git-diff-tree.txt:102
#, priority:80
msgid "This flag changes the way a merge commit is displayed (which means it is useful only when the command is given one <tree-ish>, or `--stdin`).  It shows the differences from each of the parents to the merge result simultaneously instead of showing pairwise diff between a parent and the result one at a time (which is what the `-m` option does).  Furthermore, it lists only files which were modified from all parents."
msgstr ""

#. type: Plain text
#: en/git-diff-tree.txt:112
#, priority:80
msgid "This flag changes the way a merge commit patch is displayed, in a similar way to the `-c` option. It implies the `-c` and `-p` options and further compresses the patch output by omitting uninteresting hunks whose the contents in the parents have only two variants and the merge result picks one of them without modification.  When all hunks are uninteresting, the commit itself and the commit log message is not shown, just like in any other \"empty diff\" case."
msgstr ""

#. type: Plain text
#: en/git-diff-tree.txt:119
#, priority:80
msgid "This flag causes combined diffs (used for merge commits) to list the name of the file from all parents.  It thus only has effect when -c or --cc are specified, and is likely only useful if filename changes are detected (i.e. when either rename or copy detection have been requested)."
msgstr ""

#. type: Plain text
#: en/git-diff-tree.txt:123
#, priority:80
msgid "Show the commit itself and the commit log message even if the diff itself is empty."
msgstr ""

#. type: Title =
#: en/git-diff.txt:2
#, ignore-same, no-wrap, priority:280
msgid "git-diff(1)"
msgstr "git-diff(1)"

#. type: Plain text
#: en/git-diff.txt:7
#, priority:280
msgid "git-diff - Show changes between commits, commit and working tree, etc"
msgstr "git-diff - 显示提交和工作区等变化"

#. type: Plain text
#: en/git-diff.txt:18
#, ignore-ellipsis, no-wrap, priority:280
msgid ""
"'git diff' [<options>] [<commit>] [--] [<path>...]\n"
"'git diff' [<options>] --cached [--merge-base] [<commit>] [--] [<path>...]\n"
"'git diff' [<options>] [--merge-base] <commit> [<commit>...] <commit> [--] [<path>...]\n"
"'git diff' [<options>] <commit>...<commit> [--] [<path>...]\n"
"'git diff' [<options>] <blob> <blob>\n"
"'git diff' [<options>] --no-index [--] <path> <path>\n"
msgstr ""
"'git diff' [<options>] [<commit>] [--] [<path>...]。\n"
"'git diff' [<options>] --cached [--merge-base] [<commit>] [--] [<path>...]。\n"
"'git diff' [<options>] [--merge-base] <commit> [<commit>...] <commit> [--] [<path>...]\n"
"'git diff' [<options>] <commit>...<commit> [--] [<path>...]。\n"
"'git diff' [<options>] <blob> <blob\n"
"'git diff' [<options>] --no-index [--] <path> <path>。\n"

#. type: Plain text
#: en/git-diff.txt:25
#, priority:280
msgid "Show changes between the working tree and the index or a tree, changes between the index and a tree, changes between two trees, changes resulting from a merge, changes between two blob objects, or changes between two files on disk."
msgstr "显示工作树和索引或树之间的变化，索引和树之间的变化，两个树之间的变化，合并产生的变化，两个blob对象之间的变化，或者磁盘上两个文件之间的变化。"

#. type: Labeled list
#: en/git-diff.txt:26
#, ignore-ellipsis, no-wrap, priority:280
msgid "'git diff' [<options>] [--] [<path>...]"
msgstr "'git diff' [<options>] [--] [<path>...] 。"

#. type: Plain text
#: en/git-diff.txt:33
#, priority:280
msgid "This form is to view the changes you made relative to the index (staging area for the next commit).  In other words, the differences are what you _could_ tell Git to further add to the index but you still haven't.  You can stage these changes by using linkgit:git-add[1]."
msgstr "这个表格是用来查看你相对于索引（下次提交的暂存区域）所做的修改。  换句话说，这些差异是你_可以告诉 Git 进一步添加到索引中，但你仍然没有。  你可以用linkgit:git-add[1]来对这些改动进行分期。"

#. type: Labeled list
#: en/git-diff.txt:34
#, no-wrap, priority:280
msgid "'git diff' [<options>] --no-index [--] <path> <path>"
msgstr "'git diff' [<options>] --no-index [--] <path> <path>"

#. type: Plain text
#: en/git-diff.txt:42
#, priority:280
msgid "This form is to compare the given two paths on the filesystem.  You can omit the `--no-index` option when running the command in a working tree controlled by Git and at least one of the paths points outside the working tree, or when running the command outside a working tree controlled by Git. This form implies `--exit-code`."
msgstr "这种形式是为了比较文件系统上给定的两个路径。  当在一个由Git控制的工作树中运行该命令，并且至少有一个路径指向工作树之外，或者在一个由Git控制的工作树之外运行该命令时，你可以省略`--no-index`选项。这种形式意味着`--exit-code`。"

#. type: Labeled list
#: en/git-diff.txt:43
#, fuzzy, ignore-ellipsis, no-wrap, priority:280
msgid "'git diff' [<options>] --cached [--merge-base] [<commit>] [--] [<path>...]"
msgstr "'git diff' [<options>] --cached [<commit>] [--] [<path>...]"

#. type: Plain text
#: en/git-diff.txt:52
#, priority:280
msgid "This form is to view the changes you staged for the next commit relative to the named <commit>.  Typically you would want comparison with the latest commit, so if you do not give <commit>, it defaults to HEAD.  If HEAD does not exist (e.g. unborn branches) and <commit> is not given, it shows all staged changes.  --staged is a synonym of --cached."
msgstr "这个表单是用来查看你为下一次提交所做的相对于<commit>的修改。  通常情况下，你希望与最新的提交进行比较，所以如果你没有给出 <commit>，它默认为 HEAD。  如果HEAD不存在（例如未出生的分支），并且没有给出<commit>，它将显示所有已缓存的修改。  -staged是-cached的同义词。"

#. type: Plain text
#: en/git-diff.txt:56
#, fuzzy, priority:280
#| msgid "If --merge-base is given, instead of using <commit>, use the merge base of <commit> and HEAD.  `git diff --merge-base A` is equivalent to `git diff $(git merge-base A HEAD)`."
msgid "If --merge-base is given, instead of using <commit>, use the merge base of <commit> and HEAD.  `git diff --cached --merge-base A` is equivalent to `git diff --cached $(git merge-base A HEAD)`."
msgstr "如果给出了 --merge-base，则不使用<commit>，而使用<commit>和HEAD的合并基数。  `git diff --merge-base A`等同于`git diff $(git merge-base A HEAD)`。"

#. type: Labeled list
#: en/git-diff.txt:57
#, ignore-ellipsis, no-wrap, priority:280
msgid "'git diff' [<options>] [--merge-base] <commit> [--] [<path>...]"
msgstr "'git diff' [<options>] [--merge-base] <commit> [--] [<path>...]"

#. type: Plain text
#: en/git-diff.txt:64
#, priority:280
msgid "This form is to view the changes you have in your working tree relative to the named <commit>.  You can use HEAD to compare it with the latest commit, or a branch name to compare with the tip of a different branch."
msgstr "这个表格是用来查看你的工作树中相对于命名为<commit>的修改。  您可以使用 HEAD 来与最新的提交进行比较，或者使用分支名称来与不同分支的顶端进行比较。"

#. type: Plain text
#: en/git-diff.txt:68
#, priority:280
msgid "If --merge-base is given, instead of using <commit>, use the merge base of <commit> and HEAD.  `git diff --merge-base A` is equivalent to `git diff $(git merge-base A HEAD)`."
msgstr "如果给出了 --merge-base，则不使用<commit>，而使用<commit>和HEAD的合并基数。  `git diff --merge-base A`等同于`git diff $(git merge-base A HEAD)`。"

#. type: Labeled list
#: en/git-diff.txt:69
#, fuzzy, ignore-ellipsis, no-wrap, priority:280
msgid "'git diff' [<options>] [--merge-base] <commit> <commit> [--] [<path>...]"
msgstr "'git diff' [<options>] <commit> <commit> [--] [<path>...]"

#. type: Plain text
#: en/git-diff.txt:73
#, priority:280
msgid "This is to view the changes between two arbitrary <commit>."
msgstr "这是为了查看两个任意<commit>之间的变化。"

#. type: Plain text
#: en/git-diff.txt:77
#, priority:280
msgid "If --merge-base is given, use the merge base of the two commits for the \"before\" side.  `git diff --merge-base A B` is equivalent to `git diff $(git merge-base A B) B`."
msgstr "如果给出了 --merge-base，则使用两个提交的合并基础作为 \"之前 \"的一方。  `git diff --merge-base A B`等同于`git diff $(git merge-base A B) B`。"

#. type: Labeled list
#: en/git-diff.txt:78
#, fuzzy, ignore-ellipsis, no-wrap, priority:280
msgid "'git diff' [<options>] <commit> <commit>... <commit> [--] [<path>...]"
msgstr "'git diff' [<选项>] <提交> <提交>... <提交> [--] [<路径>...]"

#. type: Plain text
#: en/git-diff.txt:86
#, fuzzy, priority:280
#| msgid "This form is to view the results of a merge commit.  The first listed <commit> must be the merge itself; the remaining two or more commits should be its parents.  A convenient way to produce the desired set of revisions is to use the `^@` suffix.  For instance, if `master` names a merge commit, `git diff master master^@` gives the same combined diff as `git show master`."
msgid "This form is to view the results of a merge commit.  The first listed <commit> must be the merge itself; the remaining two or more commits should be its parents.  Convenient ways to produce the desired set of revisions are to use the suffixes `^@` and `^!`.  If A is a merge commit, then `git diff A A^@`, `git diff A^!` and `git show A` all give the same combined diff."
msgstr "这个表单是用来查看合并提交的结果。  第一个列出的<commit>必须是合并本身；其余两个或更多的提交应该是其父辈。  一个方便的方法是使用`^@`后缀来产生所需的修订集。  例如，如果`master`命名了一个合并提交，`git diff master master^@`给出的合并差异与`git show master`相同。"

#. type: Labeled list
#: en/git-diff.txt:87
#, fuzzy, ignore-ellipsis, no-wrap, priority:280
msgid "'git diff' [<options>] <commit>..<commit> [--] [<path>...]"
msgstr "'git diff' [<选项>] <提交>..<提交> [--] [<路径>...]"

#. type: Plain text
#: en/git-diff.txt:93
#, priority:280
msgid "This is synonymous to the earlier form (without the `..`) for viewing the changes between two arbitrary <commit>.  If <commit> on one side is omitted, it will have the same effect as using HEAD instead."
msgstr "这与早期的形式（没有`.`）是同义的，用于查看两个任意<commit>之间的变化。  如果省略了一侧的<commit>，将产生与使用HEAD相同的效果。"

#. type: Labeled list
#: en/git-diff.txt:94
#, ignore-ellipsis, no-wrap, priority:280
msgid "'git diff' [<options>] <commit>\\...<commit> [--] [<path>...]"
msgstr "'git diff' [<选项>] <提交>\\...<提交> [--] [<路径>...]"

#. type: Plain text
#: en/git-diff.txt:101
#, ignore-ellipsis, priority:280
msgid "This form is to view the changes on the branch containing and up to the second <commit>, starting at a common ancestor of both <commit>.  `git diff A...B` is equivalent to `git diff $(git merge-base A B) B`.  You can omit any one of <commit>, which has the same effect as using HEAD instead."
msgstr "这种形式是为了查看包含和直到第二个<commit>的分支上的变化，从两个<commit>的共同祖先开始。  `git diff A...B`等同于`git diff $(git merge-base A B) B`。  你可以省略<commit>中的任何一个，这与使用HEAD的效果相同。"

#. type: Plain text
#: en/git-diff.txt:110
#, priority:280
msgid "Just in case you are doing something exotic, it should be noted that all of the <commit> in the above description, except in the `--merge-base` case and in the last two forms that use `..` notations, can be any <tree>. A tree of interest is the one pointed to by the special ref `AUTO_MERGE`, which is written by the 'ort' merge strategy upon hitting merge conflicts (see linkgit:git-merge[1]).  Comparing the working tree with `AUTO_MERGE` shows changes you've made so far to resolve textual conflicts (see the examples below)."
msgstr ""

#. type: Plain text
#: en/git-diff.txt:117
#, ignore-ellipsis, priority:280
msgid "For a more complete list of ways to spell <commit>, see \"SPECIFYING REVISIONS\" section in linkgit:gitrevisions[7].  However, \"diff\" is about comparing two _endpoints_, not ranges, and the range notations (`<commit>..<commit>` and `<commit>...<commit>`) do not mean a range as defined in the \"SPECIFYING RANGES\" section in linkgit:gitrevisions[7]."
msgstr "关于<commit>的更完整的拼写方式，见linkgit:gitrevisions[7]中的 \"SPECIFYING REVISIONS \"部分。  然而，\"diff \"是关于比较两个_端点，而不是范围，而且范围符号（`<commit>...<commit>`和`<commit>...<commit>`）并不意味着linkgit:gitrevisions[7]中 \"SPECIFYING RANGES \"部分所定义的范围。"

#. type: Labeled list
#: en/git-diff.txt:118
#, no-wrap, priority:280
msgid "'git diff' [<options>] <blob> <blob>"
msgstr "'git diff' [<选项>] <blob> <blob>"

#. type: Plain text
#: en/git-diff.txt:122
#, priority:280
msgid "This form is to view the differences between the raw contents of two blob objects."
msgstr "这种形式是为了查看两个blob对象的原始内容之间的差异。"

#. type: Plain text
#: en/git-diff.txt:136
#, priority:280
msgid "Compare the working tree with the \"base\" version (stage #1), \"our branch\" (stage #2) or \"their branch\" (stage #3).  The index contains these stages only for unmerged entries i.e.  while resolving conflicts.  See linkgit:git-read-tree[1] section \"3-Way Merge\" for detailed information."
msgstr "将工作树与 \"基础 \"版本（阶段#1）、\"我们的分支\"（阶段#2）或 \"他们的分支\"（阶段#3）进行比较。  索引只对未合并的条目包含这些阶段，即在解决冲突时。  详细情况见 linkgit:git-read-tree[1] \"3-Way Merge\" 部分。"

#. type: Plain text
#: en/git-diff.txt:141
#, priority:280
msgid "Omit diff output for unmerged entries and just show \"Unmerged\".  Can be used only when comparing the working tree with the index."
msgstr "省略未合并的条目的差异输出，只显示 \"Unmerged\"。  只能在比较工作树和索引的时候使用。"

#. type: Plain text
#: en/git-diff.txt:146
#, priority:280
msgid "The <paths> parameters, when given, are used to limit the diff to the named paths (you can give directory names and get diff for all files under them)."
msgstr "<paths>参数，当给出时，用于将diff限制在指定的路径上（你可以给出目录名称，并获得其下所有文件的diff）。"

#. type: Labeled list
#: en/git-diff.txt:153
#, no-wrap, priority:280
msgid "Various ways to check your working tree"
msgstr "检查你的工作树的各种方法"

#. type: delimited block -
#: en/git-diff.txt:160
#, fuzzy, no-wrap, priority:280
msgid ""
"$ git diff            <1>\n"
"$ git diff --cached   <2>\n"
"$ git diff HEAD       <3>\n"
"$ git diff AUTO_MERGE <4>\n"
msgstr ""
"$ git diff            <1>\n"
"$ git diff --cached   <2>\n"
"$ git diff HEAD       <3>\n"

#. type: Plain text
#: en/git-diff.txt:163
#, priority:280
msgid "Changes in the working tree not yet staged for the next commit."
msgstr "工作树上的修改还没有为下一次提交做铺垫。"

#. type: Plain text
#: en/git-diff.txt:165
#, priority:280
msgid "Changes between the index and your last commit; what you would be committing if you run `git commit` without `-a` option."
msgstr "索引和你最后一次提交之间的变化；如果你运行`git commit`而不使用`-a`选项，你将会提交的内容。"

#. type: Plain text
#: en/git-diff.txt:167
#, priority:280
msgid "Changes in the working tree since your last commit; what you would be committing if you run `git commit -a`"
msgstr "自你上次提交后工作树上的变化；如果你运行`git commit -a'，你将提交的内容。"

#. type: Plain text
#: en/git-diff.txt:169
#, fuzzy, priority:280
#| msgid "Changes in the working tree not yet staged for the next commit."
msgid "Changes in the working tree you've made to resolve textual conflicts so far."
msgstr "工作树上的修改还没有为下一次提交做铺垫。"

#. type: Labeled list
#: en/git-diff.txt:170
#, no-wrap, priority:280
msgid "Comparing with arbitrary commits"
msgstr "与任意提交的比较"

#. type: delimited block -
#: en/git-diff.txt:176
#, no-wrap, priority:280
msgid ""
"$ git diff test            <1>\n"
"$ git diff HEAD -- ./test  <2>\n"
"$ git diff HEAD^ HEAD      <3>\n"
msgstr ""
"$ git diff test <1>\n"
"$ git diff HEAD -- ./test <2>\n"
"$ git diff HEAD^ HEAD <3>\n"

#. type: Plain text
#: en/git-diff.txt:180
#, priority:280
msgid "Instead of using the tip of the current branch, compare with the tip of \"test\" branch."
msgstr "不使用当前分支的顶端，而是与 \"测试 \"分支的顶端比较。"

#. type: Plain text
#: en/git-diff.txt:183
#, priority:280
msgid "Instead of comparing with the tip of \"test\" branch, compare with the tip of the current branch, but limit the comparison to the file \"test\"."
msgstr "与其说是与 \"test \"分支的顶端比较，不如说是与当前分支的顶端比较，但只限于与 \"test \"文件比较。"

#. type: Plain text
#: en/git-diff.txt:184
#, priority:280
msgid "Compare the version before the last commit and the last commit."
msgstr "比较上次提交前的版本和上次提交的版本。"

#. type: Labeled list
#: en/git-diff.txt:185
#, no-wrap, priority:280
msgid "Comparing branches"
msgstr "比较分支机构"

#. type: delimited block -
#: en/git-diff.txt:191
#, fuzzy, ignore-ellipsis, no-wrap, priority:280
msgid ""
"$ git diff topic master    <1>\n"
"$ git diff topic..master   <2>\n"
"$ git diff topic...master  <3>\n"
msgstr ""
"$ git diff topic master    <1>\n"
"$ git diff topic..master   <2>\n"
"$ git diff topic...master  <3>\n"

#. type: Plain text
#: en/git-diff.txt:194
#, priority:280
msgid "Changes between the tips of the topic and the master branches."
msgstr "专题的提示和主分支之间的变化。"

#. type: Plain text
#: en/git-diff.txt:195 en/git-remote-fd.txt:44 en/git-remote-fd.txt:52 en/git-web--browse.txt:52
#, fuzzy, priority:280
msgid "Same as above."
msgstr "同上。"

#. type: Plain text
#: en/git-diff.txt:197
#, priority:280
msgid "Changes that occurred on the master branch since when the topic branch was started off it."
msgstr "自专题分支开始以来，在主分支上发生的变化。"

#. type: Labeled list
#: en/git-diff.txt:198
#, no-wrap, priority:280
msgid "Limiting the diff output"
msgstr "限制差分输出"

#. type: delimited block -
#: en/git-diff.txt:204
#, fuzzy, no-wrap, priority:280
msgid ""
"$ git diff --diff-filter=MRC            <1>\n"
"$ git diff --name-status                <2>\n"
"$ git diff arch/i386 include/asm-i386   <3>\n"
msgstr ""
"$ git diff --diff-filter=MRC            <1>\n"
"$ git diff --name-status                <2>\n"
"$ git diff arch/i386 include/asm-i386   <3>\n"

#. type: Plain text
#: en/git-diff.txt:208
#, priority:280
msgid "Show only modification, rename, and copy, but not addition or deletion."
msgstr "只显示修改、重命名和复制，但不显示增加或删除。"

#. type: Plain text
#: en/git-diff.txt:210
#, priority:280
msgid "Show only names and the nature of change, but not actual diff output."
msgstr "只显示名称和变化的性质，但不显示实际的差异输出。"

#. type: Plain text
#: en/git-diff.txt:211
#, priority:280
msgid "Limit diff output to named subtrees."
msgstr "将diff输出限制在命名的子树上。"

#. type: Labeled list
#: en/git-diff.txt:212
#, no-wrap, priority:280
msgid "Munging the diff output"
msgstr "轧制差速器输出"

#. type: delimited block -
#: en/git-diff.txt:217
#, fuzzy, no-wrap, priority:280
msgid ""
"$ git diff --find-copies-harder -B -C  <1>\n"
"$ git diff -R                          <2>\n"
msgstr ""
"$ git diff --find-copies-harder -B -C  <1>\n"
"$ git diff -R                          <2>\n"

#. type: Plain text
#: en/git-diff.txt:221
#, priority:280
msgid "Spend extra cycles to find renames, copies and complete rewrites (very expensive)."
msgstr "花费额外的周期来寻找重命名、复制和完全重写（非常昂贵）。"

#. type: Plain text
#: en/git-diff.txt:222
#, priority:280
msgid "Output diff in reverse."
msgstr "反向输出差值。"

#. type: Plain text
#: en/git-diff.txt:239
#, fuzzy, priority:280
#| msgid "linkgit:git-status[1] linkgit:git-rm[1] linkgit:git-reset[1] linkgit:git-mv[1] linkgit:git-commit[1] linkgit:git-update-index[1]"
msgid "diff(1), linkgit:git-difftool[1], linkgit:git-log[1], linkgit:gitdiffcore[7], linkgit:git-format-patch[1], linkgit:git-apply[1], linkgit:git-show[1]"
msgstr "diff(1), linkgit:git-difftool[1], linkgit:git-log[1], linkgit:gitdiffcore[7], linkgit:git-format-patch[1], linkgit:git-apply[1], linkgit:git-show[1]"

#. type: Title =
#: en/git-fast-export.txt:2
#, ignore-same, no-wrap, priority:90
msgid "git-fast-export(1)"
msgstr "git-fast-export(1)"

#. type: Plain text
#: en/git-fast-export.txt:7
#, priority:90
msgid "git-fast-export - Git data exporter"
msgstr ""

#. type: Plain text
#: en/git-fast-export.txt:13
#, fuzzy, no-wrap, priority:90
msgid "'git fast-export' [<options>] | 'git fast-import'\n"
msgstr "$ git fast-export --all | (cd /empty/repository && git fast-import)\n"

#. type: Plain text
#: en/git-fast-export.txt:18
#, priority:90
msgid "This program dumps the given revisions in a form suitable to be piped into 'git fast-import'."
msgstr ""

#. type: Plain text
#: en/git-fast-export.txt:23
#, priority:90
msgid "You can use it as a human-readable bundle replacement (see linkgit:git-bundle[1]), or as a format that can be edited before being fed to 'git fast-import' in order to do history rewrites (an ability relied on by tools like 'git filter-repo')."
msgstr ""

#. type: Labeled list
#: en/git-fast-export.txt:26
#, no-wrap, priority:90
msgid "--progress=<n>"
msgstr ""

#. type: Plain text
#: en/git-fast-export.txt:29
#, priority:90
msgid "Insert 'progress' statements every <n> objects, to be shown by 'git fast-import' during import."
msgstr ""

#. type: Labeled list
#: en/git-fast-export.txt:30
#, no-wrap, priority:90
msgid "--signed-tags=(verbatim|warn|warn-strip|strip|abort)"
msgstr ""

#. type: Plain text
#: en/git-fast-export.txt:34
#, priority:90
msgid "Specify how to handle signed tags.  Since any transformation after the export can change the tag names (which can also happen when excluding revisions) the signatures will not match."
msgstr ""

#. type: Plain text
#: en/git-fast-export.txt:41
#, priority:90
msgid "When asking to 'abort' (which is the default), this program will die when encountering a signed tag.  With 'strip', the tags will silently be made unsigned, with 'warn-strip' they will be made unsigned but a warning will be displayed, with 'verbatim', they will be silently exported and with 'warn', they will be exported, but you will see a warning."
msgstr ""

#. type: Labeled list
#: en/git-fast-export.txt:42
#, fuzzy, no-wrap, priority:90
msgid "--tag-of-filtered-object=(abort|drop|rewrite)"
msgstr "--tag-of-filtered-object=(abort|drop|rewrite)"

#. type: Plain text
#: en/git-fast-export.txt:46
#, priority:90
msgid "Specify how to handle tags whose tagged object is filtered out.  Since revisions and files to export can be limited by path, tagged objects may be filtered completely."
msgstr ""

#. type: Plain text
#: en/git-fast-export.txt:52
#, priority:90
msgid "When asking to 'abort' (which is the default), this program will die when encountering such a tag.  With 'drop' it will omit such tags from the output.  With 'rewrite', if the tagged object is a commit, it will rewrite the tag to tag an ancestor commit (via parent rewriting; see linkgit:git-rev-list[1])"
msgstr ""

#. type: Plain text
#: en/git-fast-export.txt:58
#, priority:90
msgid "Perform move and/or copy detection, as described in the linkgit:git-diff[1] manual page, and use it to generate rename and copy commands in the output dump."
msgstr ""

#. type: Plain text
#: en/git-fast-export.txt:61
#, priority:90
msgid "Note that earlier versions of this command did not complain and produced incorrect results if you gave these options."
msgstr ""

#. type: Labeled list
#: en/git-fast-export.txt:62 en/git-fast-import.txt:93
#, fuzzy, no-wrap, priority:90
msgid "--export-marks=<file>"
msgstr "--export-marks=<file>"

#. type: Plain text
#: en/git-fast-export.txt:73
#, priority:90
msgid "Dumps the internal marks table to <file> when complete.  Marks are written one per line as `:markid SHA-1`. Only marks for revisions are dumped; marks for blobs are ignored.  Backends can use this file to validate imports after they have been completed, or to save the marks table across incremental runs.  As <file> is only opened and truncated at completion, the same path can also be safely given to --import-marks.  The file will not be written if no new object has been marked/exported."
msgstr ""

#. type: Labeled list
#: en/git-fast-export.txt:74 en/git-fast-import.txt:102
#, fuzzy, no-wrap, priority:90
msgid "--import-marks=<file>"
msgstr "--import-marks=<file>"

#. type: Plain text
#: en/git-fast-export.txt:78
#, priority:90
msgid "Before processing any input, load the marks specified in <file>.  The input file must exist, must be readable, and must use the same format as produced by --export-marks."
msgstr ""

#. type: Labeled list
#: en/git-fast-export.txt:79
#, ignore-same, no-wrap, priority:90
msgid "--mark-tags"
msgstr "--mark-tags"

#. type: Plain text
#: en/git-fast-export.txt:87
#, priority:90
msgid "In addition to labelling blobs and commits with mark ids, also label tags.  This is useful in conjunction with `--export-marks` and `--import-marks`, and is also useful (and necessary) for exporting of nested tags.  It does not hurt other cases and would be the default, but many fast-import frontends are not prepared to accept tags with mark identifiers."
msgstr ""

#. type: Plain text
#: en/git-fast-export.txt:92
#, priority:90
msgid "Any commits (or tags) that have already been marked will not be exported again.  If the backend uses a similar --import-marks file, this allows for incremental bidirectional exporting of the repository by keeping the marks the same across runs."
msgstr ""

#. type: Labeled list
#: en/git-fast-export.txt:93
#, ignore-same, no-wrap, priority:90
msgid "--fake-missing-tagger"
msgstr "--fake-missing-tagger"

#. type: Plain text
#: en/git-fast-export.txt:98
#, priority:90
msgid "Some old repositories have tags without a tagger.  The fast-import protocol was pretty strict about that, and did not allow that.  So fake a tagger to be able to fast-import the output."
msgstr ""

#. type: Labeled list
#: en/git-fast-export.txt:99
#, ignore-same, no-wrap, priority:90
msgid "--use-done-feature"
msgstr "--use-done-feature"

#. type: Plain text
#: en/git-fast-export.txt:102
#, priority:90
msgid "Start the stream with a 'feature done' stanza, and terminate it with a 'done' command."
msgstr ""

#. type: Labeled list
#: en/git-fast-export.txt:103
#, ignore-same, no-wrap, priority:90
msgid "--no-data"
msgstr "--no-data"

#. type: Plain text
#: en/git-fast-export.txt:110
#, priority:90
msgid "Skip output of blob objects and instead refer to blobs via their original SHA-1 hash.  This is useful when rewriting the directory structure or history of a repository without touching the contents of individual files.  Note that the resulting stream can only be used by a repository which already contains the necessary objects."
msgstr ""

#. type: Labeled list
#: en/git-fast-export.txt:111 en/git-ls-tree.txt:82
#, ignore-same, no-wrap, priority:90
msgid "--full-tree"
msgstr "--full-tree"

#. type: Plain text
#: en/git-fast-export.txt:116
#, priority:90
msgid "This option will cause fast-export to issue a \"deleteall\" directive for each commit followed by a full list of all files in the commit (as opposed to just listing the files which are different from the commit's first parent)."
msgstr ""

#. type: Labeled list
#: en/git-fast-export.txt:117
#, ignore-same, no-wrap, priority:90
msgid "--anonymize"
msgstr "--anonymize"

#. type: Plain text
#: en/git-fast-export.txt:121
#, priority:90
msgid "Anonymize the contents of the repository while still retaining the shape of the history and stored tree.  See the section on `ANONYMIZING` below."
msgstr ""

#. type: Labeled list
#: en/git-fast-export.txt:122
#, fuzzy, no-wrap, priority:90
msgid "--anonymize-map=<from>[:<to>]"
msgstr "--anonymize-map=<from>[:<to>]"

#. type: Plain text
#: en/git-fast-export.txt:126
#, priority:90
msgid "Convert token `<from>` to `<to>` in the anonymized output. If `<to>` is omitted, map `<from>` to itself (i.e., do not anonymize it). See the section on `ANONYMIZING` below."
msgstr ""

#. type: Labeled list
#: en/git-fast-export.txt:127
#, ignore-same, no-wrap, priority:90
msgid "--reference-excluded-parents"
msgstr "--reference-excluded-parents"

#. type: Plain text
#: en/git-fast-export.txt:138
#, priority:90
msgid "By default, running a command such as `git fast-export master~5..master` will not include the commit master{tilde}5 and will make master{tilde}4 no longer have master{tilde}5 as a parent (though both the old master{tilde}4 and new master{tilde}4 will have all the same files).  Use --reference-excluded-parents to instead have the stream refer to commits in the excluded range of history by their sha1sum.  Note that the resulting stream can only be used by a repository which already contains the necessary parent commits."
msgstr ""

#. type: Labeled list
#: en/git-fast-export.txt:139
#, ignore-same, no-wrap, priority:90
msgid "--show-original-ids"
msgstr "--show-original-ids"

#. type: Plain text
#: en/git-fast-export.txt:145
#, priority:90
msgid "Add an extra directive to the output for commits and blobs, `original-oid <SHA1SUM>`.  While such directives will likely be ignored by importers such as git-fast-import, it may be useful for intermediary filters (e.g. for rewriting commit messages which refer to older commits, or for stripping blobs by id)."
msgstr ""

#. type: Labeled list
#: en/git-fast-export.txt:146
#, fuzzy, no-wrap, priority:90
msgid "--reencode=(yes|no|abort)"
msgstr "--reencode=(yes|no|abort)"

#. type: Plain text
#: en/git-fast-export.txt:152
#, priority:90
msgid "Specify how to handle `encoding` header in commit objects.  When asking to 'abort' (which is the default), this program will die when encountering such a commit object.  With 'yes', the commit message will be re-encoded into UTF-8.  With 'no', the original encoding will be preserved."
msgstr ""

#. type: Labeled list
#: en/git-fast-export.txt:153
#, ignore-same, no-wrap, priority:90
msgid "--refspec"
msgstr "--refspec"

#. type: Plain text
#: en/git-fast-export.txt:156
#, priority:90
msgid "Apply the specified refspec to each ref exported. Multiple of them can be specified."
msgstr ""

#. type: Labeled list
#: en/git-fast-export.txt:157
#, fuzzy, ignore-ellipsis, no-wrap, priority:90
msgid "[<git-rev-list-args>...]"
msgstr "[<git-rev-list-args>...]"

#. type: Plain text
#: en/git-fast-export.txt:165
#, priority:90
msgid "A list of arguments, acceptable to 'git rev-parse' and 'git rev-list', that specifies the specific objects and references to export.  For example, `master~10..master` causes the current master reference to be exported along with all objects added since its 10th ancestor commit and (unless the --reference-excluded-parents option is specified) all files common to master{tilde}9 and master{tilde}10."
msgstr ""

#. type: delimited block -
#: en/git-fast-export.txt:171
#, fuzzy, no-wrap, priority:90
msgid "$ git fast-export --all | (cd /empty/repository && git fast-import)\n"
msgstr "$ git fast-export --all | (cd /empty/repository && git fast-import)\n"

#. type: Plain text
#: en/git-fast-export.txt:176
#, priority:90
msgid "This will export the whole repository and import it into the existing empty repository.  Except for reencoding commits that are not in UTF-8, it would be a one-to-one mirror."
msgstr ""

#. type: delimited block -
#: en/git-fast-export.txt:181
#, fuzzy, no-wrap, priority:90
msgid ""
"$ git fast-export master~5..master |\n"
"\tsed \"s|refs/heads/master|refs/heads/other|\" |\n"
"\tgit fast-import\n"
msgstr ""
"$ git fast-export master~5..master |\n"
"\tsed \"s|refs/heads/master|refs/heads/other|\" |\n"
"\tgit fast-import\n"

#. type: Plain text
#: en/git-fast-export.txt:185
#, priority:90
msgid "This makes a new branch called 'other' from 'master~5..master' (i.e. if 'master' has linear history, it will take the last 5 commits)."
msgstr ""

#. type: Plain text
#: en/git-fast-export.txt:189
#, priority:90
msgid "Note that this assumes that none of the blobs and commit messages referenced by that revision range contains the string 'refs/heads/master'."
msgstr ""

#. type: Title -
#: en/git-fast-export.txt:192
#, no-wrap, priority:90
msgid "ANONYMIZING"
msgstr ""

#. type: Plain text
#: en/git-fast-export.txt:200
#, priority:90
msgid "If the `--anonymize` option is given, git will attempt to remove all identifying information from the repository while still retaining enough of the original tree and history patterns to reproduce some bugs. The goal is that a git bug which is found on a private repository will persist in the anonymized repository, and the latter can be shared with git developers to help solve the bug."
msgstr ""

#. type: Plain text
#: en/git-fast-export.txt:212
#, priority:90
msgid "With this option, git will replace all refnames, paths, blob contents, commit and tag messages, names, and email addresses in the output with anonymized data.  Two instances of the same string will be replaced equivalently (e.g., two commits with the same author will have the same anonymized author in the output, but bear no resemblance to the original author string). The relationship between commits, branches, and tags is retained, as well as the commit timestamps (but the commit messages and refnames bear no resemblance to the originals). The relative makeup of the tree is retained (e.g., if you have a root tree with 10 files and 3 trees, so will the output), but their names and the contents of the files will be replaced."
msgstr ""

#. type: Plain text
#: en/git-fast-export.txt:215
#, priority:90
msgid "If you think you have found a git bug, you can start by exporting an anonymized stream of the whole repository:"
msgstr ""

#. type: delimited block -
#: en/git-fast-export.txt:218
#, no-wrap, priority:90
msgid "$ git fast-export --anonymize --all >anon-stream\n"
msgstr ""

#. type: Plain text
#: en/git-fast-export.txt:223
#, priority:90
msgid "Then confirm that the bug persists in a repository created from that stream (many bugs will not, as they really do depend on the exact repository contents):"
msgstr ""

#. type: delimited block -
#: en/git-fast-export.txt:229
#, fuzzy, ignore-ellipsis, no-wrap, priority:90
msgid ""
"$ git init anon-repo\n"
"$ cd anon-repo\n"
"$ git fast-import <../anon-stream\n"
"$ ... test your bug ...\n"
msgstr ""
"$ git init anon-repo\n"
"$ cd anon-repo\n"
"$ git fast-import <../anon-stream\n"
"$ ... test your bug ...\n"

#. type: Plain text
#: en/git-fast-export.txt:236
#, priority:90
msgid "If the anonymized repository shows the bug, it may be worth sharing `anon-stream` along with a regular bug report. Note that the anonymized stream compresses very well, so gzipping it is encouraged. If you want to examine the stream to see that it does not contain any private data, you can peruse it directly before sending. You may also want to try:"
msgstr ""

#. type: delimited block -
#: en/git-fast-export.txt:239
#, fuzzy, no-wrap, priority:90
msgid "$ perl -pe 's/\\d+/X/g' <anon-stream | sort -u | less\n"
msgstr "$ perl -pe 's/\\d+/X/g' <anon-stream | sort -u | less\n"

#. type: Plain text
#: en/git-fast-export.txt:245
#, priority:90
msgid "which shows all of the unique lines (with numbers converted to \"X\", to collapse \"User 0\", \"User 1\", etc into \"User X\"). This produces a much smaller output, and it is usually easy to quickly confirm that there is no private data in the stream."
msgstr ""

#. type: Plain text
#: en/git-fast-export.txt:251
#, priority:90
msgid "Reproducing some bugs may require referencing particular commits or paths, which becomes challenging after refnames and paths have been anonymized. You can ask for a particular token to be left as-is or mapped to a new value. For example, if you have a bug which reproduces with `git rev-list sensitive -- secret.c`, you can run:"
msgstr ""

#. type: delimited block -
#: en/git-fast-export.txt:257
#, fuzzy, no-wrap, priority:90
msgid ""
"$ git fast-export --anonymize --all \\\n"
"      --anonymize-map=sensitive:foo \\\n"
"      --anonymize-map=secret.c:bar.c \\\n"
"      >stream\n"
msgstr ""
"$ git fast-export --anonymize --all \\\n"
"      --anonymize-map=sensitive:foo \\\n"
"      --anonymize-map=secret.c:bar.c \\\n"
"      >stream\n"

#. type: Plain text
#: en/git-fast-export.txt:261
#, priority:90
msgid "After importing the stream, you can then run `git rev-list foo -- bar.c` in the anonymized repository."
msgstr ""

#. type: Plain text
#: en/git-fast-export.txt:266
#, priority:90
msgid "Note that paths and refnames are split into tokens at slash boundaries.  The command above would anonymize `subdir/secret.c` as something like `path123/bar.c`; you could then search for `bar.c` in the anonymized repository to determine the final pathname."
msgstr ""

#. type: Plain text
#: en/git-fast-export.txt:270
#, priority:90
msgid "To make referencing the final pathname simpler, you can map each path component; so if you also anonymize `subdir` to `publicdir`, then the final pathname would be `publicdir/bar.c`."
msgstr ""

#. type: Plain text
#: en/git-fast-export.txt:277
#, priority:90
msgid "Since 'git fast-import' cannot tag trees, you will not be able to export the linux.git repository completely, as it contains a tag referencing a tree instead of a commit."
msgstr ""

#. type: Title =
#: en/git-fast-import.txt:2
#, ignore-same, no-wrap, priority:90
msgid "git-fast-import(1)"
msgstr "git-fast-import(1)"

#. type: Plain text
#: en/git-fast-import.txt:7
#, priority:90
msgid "git-fast-import - Backend for fast Git data importers"
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:13
#, no-wrap, priority:90
msgid "frontend | 'git fast-import' [<options>]\n"
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:20
#, priority:90
msgid "This program is usually not what the end user wants to run directly.  Most end users want to use one of the existing frontend programs, which parses a specific type of foreign source and feeds the contents stored there to 'git fast-import'."
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:26
#, priority:90
msgid "fast-import reads a mixed command/data stream from standard input and writes one or more packfiles directly into the current repository.  When EOF is received on standard input, fast import writes out updated branch and tag refs, fully updating the current repository with the newly imported data."
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:32
#, priority:90
msgid "The fast-import backend itself can import into an empty repository (one that has already been initialized by 'git init') or incrementally update an existing populated repository.  Whether or not incremental imports are supported from a particular foreign source depends on the frontend program in use."
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:41
#, priority:90
msgid "Force updating modified existing branches, even if doing so would cause commits to be lost (as the new commit does not contain the old commit)."
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:47
#, priority:90
msgid "Disable the output shown by --stats, making fast-import usually be silent when it is successful.  However, if the import stream has directives intended to show user output (e.g. `progress` directives), the corresponding messages will still be shown."
msgstr ""

#. type: Labeled list
#: en/git-fast-import.txt:48
#, ignore-same, no-wrap, priority:90
msgid "--stats"
msgstr "--stats"

#. type: Plain text
#: en/git-fast-import.txt:53
#, priority:90
msgid "Display some basic statistics about the objects fast-import has created, the packfiles they were stored into, and the memory used by fast-import during this run.  Showing this output is currently the default, but can be disabled with --quiet."
msgstr ""

#. type: Labeled list
#: en/git-fast-import.txt:54
#, ignore-same, no-wrap, priority:90
msgid "--allow-unsafe-features"
msgstr "--allow-unsafe-features"

#. type: Plain text
#: en/git-fast-import.txt:63
#, priority:90
msgid "Many command-line options can be provided as part of the fast-import stream itself by using the `feature` or `option` commands. However, some of these options are unsafe (e.g., allowing fast-import to access the filesystem outside of the repository). These options are disabled by default, but can be allowed by providing this option on the command line.  This currently impacts only the `export-marks`, `import-marks`, and `import-marks-if-exists` feature commands."
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:68
#, priority:90
msgid "Only enable this option if you trust the program generating the fast-import stream! This option is enabled automatically for remote-helpers that use the `import` capability, as they are already trusted to run their own code."
msgstr ""

#. type: Title ~
#: en/git-fast-import.txt:70
#, no-wrap, priority:90
msgid "Options for Frontends"
msgstr ""

#. type: Labeled list
#: en/git-fast-import.txt:72
#, fuzzy, no-wrap, priority:90
msgid "--cat-blob-fd=<fd>"
msgstr "--cat-blob-fd=<fd>"

#. type: Plain text
#: en/git-fast-import.txt:77
#, priority:90
msgid "Write responses to `get-mark`, `cat-blob`, and `ls` queries to the file descriptor <fd> instead of `stdout`.  Allows `progress` output intended for the end-user to be separated from other output."
msgstr ""

#. type: Labeled list
#: en/git-fast-import.txt:78
#, fuzzy, no-wrap, priority:90
msgid "--date-format=<fmt>"
msgstr "--date-format=<fmt>"

#. type: Plain text
#: en/git-fast-import.txt:83
#, priority:90
msgid "Specify the type of dates the frontend will supply to fast-import within `author`, `committer` and `tagger` commands.  See ``Date Formats'' below for details about which formats are supported, and their syntax."
msgstr ""

#. type: Labeled list
#: en/git-fast-import.txt:84
#, ignore-same, no-wrap, priority:90
msgid "--done"
msgstr "--done"

#. type: Plain text
#: en/git-fast-import.txt:89
#, priority:90
msgid "Terminate with error if there is no `done` command at the end of the stream.  This option might be useful for detecting errors that cause the frontend to terminate before it has started to write a stream."
msgstr ""

#. type: Title ~
#: en/git-fast-import.txt:91
#, no-wrap, priority:90
msgid "Locations of Marks Files"
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:101
#, priority:90
msgid "Dumps the internal marks table to <file> when complete.  Marks are written one per line as `:markid SHA-1`.  Frontends can use this file to validate imports after they have been completed, or to save the marks table across incremental runs.  As <file> is only opened and truncated at checkpoint (or completion) the same path can also be safely given to --import-marks."
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:109
#, priority:90
msgid "Before processing any input, load the marks specified in <file>.  The input file must exist, must be readable, and must use the same format as produced by --export-marks.  Multiple options may be supplied to import more than one set of marks.  If a mark is defined to different values, the last file wins."
msgstr ""

#. type: Labeled list
#: en/git-fast-import.txt:110
#, fuzzy, no-wrap, priority:90
msgid "--import-marks-if-exists=<file>"
msgstr "--import-marks-if-exists=<file>"

#. type: Plain text
#: en/git-fast-import.txt:113
#, priority:90
msgid "Like --import-marks but instead of erroring out, silently skips the file if it does not exist."
msgstr ""

#. type: Labeled list
#: en/git-fast-import.txt:114
#, ignore-same, no-wrap, priority:90
msgid "--[no-]relative-marks"
msgstr "--[no-]relative-marks"

#. type: Plain text
#: en/git-fast-import.txt:121
#, priority:90
msgid "After specifying --relative-marks the paths specified with --import-marks= and --export-marks= are relative to an internal directory in the current repository.  In git-fast-import this means that the paths are relative to the .git/info/fast-import directory. However, other importers may use a different location."
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:124
#, priority:90
msgid "Relative and non-relative marks may be combined by interweaving --(no-)-relative-marks with the --(import|export)-marks= options."
msgstr ""

#. type: Title ~
#: en/git-fast-import.txt:126
#, no-wrap, priority:90
msgid "Submodule Rewriting"
msgstr ""

#. type: Labeled list
#: en/git-fast-import.txt:128
#, fuzzy, no-wrap, priority:90
msgid "--rewrite-submodules-from=<name>:<file>"
msgstr "--rewrite-submodules-from=<name>:<file>"

#. type: Labeled list
#: en/git-fast-import.txt:129
#, fuzzy, no-wrap, priority:90
#| msgid "--recurse-submodules[=<pathspec]"
msgid "--rewrite-submodules-to=<name>:<file>"
msgstr "--rewrite-submodules-to=<name>:<file>"

#. type: Plain text
#: en/git-fast-import.txt:134
#, priority:90
msgid "Rewrite the object IDs for the submodule specified by <name> from the values used in the from <file> to those used in the to <file>. The from marks should have been created by `git fast-export`, and the to marks should have been created by `git fast-import` when importing that same submodule."
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:139
#, priority:90
msgid "<name> may be any arbitrary string not containing a colon character, but the same value must be used with both options when specifying corresponding marks.  Multiple submodules may be specified with different values for <name>. It is an error not to use these options in corresponding pairs."
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:144
#, priority:90
msgid "These options are primarily useful when converting a repository from one hash algorithm to another; without them, fast-import will fail if it encounters a submodule because it has no way of writing the object ID into the new hash algorithm."
msgstr ""

#. type: Title ~
#: en/git-fast-import.txt:146
#, no-wrap, priority:90
msgid "Performance and Compression Tuning"
msgstr ""

#. type: Labeled list
#: en/git-fast-import.txt:148
#, fuzzy, no-wrap, priority:90
msgid "--active-branches=<n>"
msgstr "--active-branches=<n>"

#. type: Plain text
#: en/git-fast-import.txt:151
#, priority:90
msgid "Maximum number of branches to maintain active at once.  See ``Memory Utilization'' below for details.  Default is 5."
msgstr ""

#. type: Labeled list
#: en/git-fast-import.txt:152
#, fuzzy, no-wrap, priority:90
msgid "--big-file-threshold=<n>"
msgstr "--big-file-threshold=<n>"

#. type: Plain text
#: en/git-fast-import.txt:157
#, priority:90
msgid "Maximum size of a blob that fast-import will attempt to create a delta for, expressed in bytes.  The default is 512m (512 MiB).  Some importers may wish to lower this on systems with constrained memory."
msgstr ""

#. type: Labeled list
#: en/git-fast-import.txt:158 en/git-fetch-pack.txt:85 en/git-pack-objects.txt:129 en/git-repack.txt:108
#, no-wrap, priority:100
msgid "--depth=<n>"
msgstr "--depth=<n>"

#. type: Plain text
#: en/git-fast-import.txt:161
#, priority:90
msgid "Maximum delta depth, for blob and tree deltification.  Default is 50."
msgstr ""

#. type: Labeled list
#: en/git-fast-import.txt:162
#, fuzzy, no-wrap, priority:90
msgid "--export-pack-edges=<file>"
msgstr "--export-pack-edges=<file>"

#. type: Plain text
#: en/git-fast-import.txt:170
#, priority:90
msgid "After creating a packfile, print a line of data to <file> listing the filename of the packfile and the last commit on each branch that was written to that packfile.  This information may be useful after importing projects whose total object set exceeds the 4 GiB packfile limit, as these commits can be used as edge points during calls to 'git pack-objects'."
msgstr ""

#. type: Labeled list
#: en/git-fast-import.txt:171 en/git-pack-objects.txt:154 en/git-repack.txt:136
#, no-wrap, priority:100
msgid "--max-pack-size=<n>"
msgstr "--max-pack-size=<n>"

#. type: Plain text
#: en/git-fast-import.txt:174
#, priority:90
msgid "Maximum size of each output packfile.  The default is unlimited."
msgstr ""

#. type: Labeled list
#: en/git-fast-import.txt:175
#, ignore-same, no-wrap, priority:90
msgid "fastimport.unpackLimit"
msgstr "fastimport.unpackLimit"

#. type: Plain text
#: en/git-fast-import.txt:177
#, fuzzy, priority:90
msgid "See linkgit:git-config[1]"
msgstr "linkgit:git-config[1]"

#. type: Title -
#: en/git-fast-import.txt:179 en/git-filter-branch.txt:463 en/git-p4.txt:548
#, fuzzy, no-wrap, priority:90
msgid "PERFORMANCE"
msgstr "表现"

#. type: Plain text
#: en/git-fast-import.txt:186
#, priority:90
msgid "The design of fast-import allows it to import large projects in a minimum amount of memory usage and processing time.  Assuming the frontend is able to keep up with fast-import and feed it a constant stream of data, import times for projects holding 10+ years of history and containing 100,000+ individual commits are generally completed in just 1-2 hours on quite modest (~$2,000 USD) hardware."
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:192
#, priority:90
msgid "Most bottlenecks appear to be in foreign source data access (the source just cannot extract revisions fast enough) or disk IO (fast-import writes as fast as the disk will take the data).  Imports will run faster if the source data is stored on a different drive than the destination Git repository (due to less IO contention)."
msgstr ""

#. type: Title -
#: en/git-fast-import.txt:195
#, no-wrap, priority:90
msgid "DEVELOPMENT COST"
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:202
#, priority:90
msgid "A typical frontend for fast-import tends to weigh in at approximately 200 lines of Perl/Python/Ruby code.  Most developers have been able to create working importers in just a couple of hours, even though it is their first exposure to fast-import, and sometimes even to Git.  This is an ideal situation, given that most conversion tools are throw-away (use once, and never look back)."
msgstr ""

#. type: Title -
#: en/git-fast-import.txt:205
#, no-wrap, priority:90
msgid "PARALLEL OPERATION"
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:210
#, priority:90
msgid "Like 'git push' or 'git fetch', imports handled by fast-import are safe to run alongside parallel `git repack -a -d` or `git gc` invocations, or any other Git operation (including 'git prune', as loose objects are never used by fast-import)."
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:219
#, priority:90
msgid "fast-import does not lock the branch or tag refs it is actively importing.  After the import, during its ref update phase, fast-import tests each existing branch ref to verify the update will be a fast-forward update (the commit stored in the ref is contained in the new history of the commit to be written).  If the update is not a fast-forward update, fast-import will skip updating that ref and instead prints a warning message.  fast-import will always attempt to update all branch refs, and does not stop on the first failure."
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:223
#, priority:90
msgid "Branch updates can be forced with --force, but it's recommended that this only be used on an otherwise quiet repository.  Using --force is not necessary for an initial import into an empty repository."
msgstr ""

#. type: Title -
#: en/git-fast-import.txt:226
#, no-wrap, priority:90
msgid "TECHNICAL DISCUSSION"
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:233
#, priority:90
msgid "fast-import tracks a set of branches in memory.  Any branch can be created or modified at any point during the import process by sending a `commit` command on the input stream.  This design allows a frontend program to process an unlimited number of branches simultaneously, generating commits in the order they are available from the source data.  It also simplifies the frontend programs considerably."
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:242
#, priority:90
msgid "fast-import does not use or alter the current working directory, or any file within it.  (It does however update the current Git repository, as referenced by `GIT_DIR`.)  Therefore an import frontend may use the working directory for its own purposes, such as extracting file revisions from the foreign source.  This ignorance of the working directory also allows fast-import to run very quickly, as it does not need to perform any costly file update operations when switching between branches."
msgstr ""

#. type: Title -
#: en/git-fast-import.txt:244 en/git-merge-tree.txt:225
#, no-wrap, priority:100
msgid "INPUT FORMAT"
msgstr "输入格式"

#. type: Plain text
#: en/git-fast-import.txt:250
#, priority:90
msgid "With the exception of raw file data (which Git does not interpret)  the fast-import input format is text (ASCII) based.  This text based format simplifies development and debugging of frontend programs, especially when a higher level language such as Perl, Python or Ruby is being used."
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:258
#, priority:90
msgid "fast-import is very strict about its input.  Where we say SP below we mean *exactly* one space.  Likewise LF means one (and only one) linefeed and HT one (and only one) horizontal tab.  Supplying additional whitespace characters will cause unexpected results, such as branch names or file names with leading or trailing spaces in their name, or early termination of fast-import when it encounters unexpected input."
msgstr ""

#. type: Title ~
#: en/git-fast-import.txt:260
#, no-wrap, priority:90
msgid "Stream Comments"
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:267
#, priority:90
msgid "To aid in debugging frontends fast-import ignores any line that begins with `#` (ASCII pound/hash) up to and including the line ending `LF`.  A comment line may contain any sequence of bytes that does not contain an LF and therefore may be used to include any detailed debugging information that might be specific to the frontend and useful when inspecting a fast-import data stream."
msgstr ""

#. type: Title ~
#: en/git-fast-import.txt:269
#, fuzzy, no-wrap, priority:90
msgid "Date Formats"
msgstr "日期格式"

#. type: Plain text
#: en/git-fast-import.txt:273
#, priority:90
msgid "The following date formats are supported.  A frontend should select the format it will use for this import by passing the format name in the --date-format=<fmt> command-line option."
msgstr ""

#. type: Labeled list
#: en/git-fast-import.txt:274
#, ignore-same, no-wrap, priority:90
msgid "`raw`"
msgstr "`raw`"

#. type: Plain text
#: en/git-fast-import.txt:278
#, priority:90
msgid "This is the Git native format and is `<time> SP <offutc>`.  It is also fast-import's default format, if --date-format was not specified."
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:282
#, priority:90
msgid "The time of the event is specified by `<time>` as the number of seconds since the UNIX epoch (midnight, Jan 1, 1970, UTC) and is written as an ASCII decimal integer."
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:288
#, priority:90
msgid "The local offset is specified by `<offutc>` as a positive or negative offset from UTC.  For example EST (which is 5 hours behind UTC)  would be expressed in `<tz>` by ``-0500'' while UTC is ``+0000''.  The local offset does not affect `<time>`; it is used only as an advisement to help formatting routines display the timestamp."
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:294
#, priority:90
msgid "If the local offset is not available in the source material, use ``+0000'', or the most common local offset.  For example many organizations have a CVS repository which has only ever been accessed by users who are located in the same location and time zone.  In this case a reasonable offset from UTC could be assumed."
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:298
#, priority:90
msgid "Unlike the `rfc2822` format, this format is very strict.  Any variation in formatting will cause fast-import to reject the value, and some sanity checks on the numeric values may also be performed."
msgstr ""

#. type: Labeled list
#: en/git-fast-import.txt:299
#, ignore-same, no-wrap, priority:90
msgid "`raw-permissive`"
msgstr "`raw-permissive`"

#. type: Plain text
#: en/git-fast-import.txt:304
#, priority:90
msgid "This is the same as `raw` except that no sanity checks on the numeric epoch and local offset are performed.  This can be useful when trying to filter or import an existing history with e.g. bogus timezone values."
msgstr ""

#. type: Labeled list
#: en/git-fast-import.txt:305
#, fuzzy, no-wrap, priority:90
msgid "`rfc2822`"
msgstr "`rfc2822`"

#. type: Plain text
#: en/git-fast-import.txt:307
#, priority:90
msgid "This is the standard email format as described by RFC 2822."
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:312
#, priority:90
msgid "An example value is ``Tue Feb 6 11:22:18 2007 -0500''.  The Git parser is accurate, but a little on the lenient side.  It is the same parser used by 'git am' when applying patches received from email."
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:318
#, priority:90
msgid "Some malformed strings may be accepted as valid dates.  In some of these cases Git will still be able to obtain the correct date from the malformed string.  There are also some types of malformed strings which Git will parse wrong, and yet consider valid.  Seriously malformed strings will be rejected."
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:323
#, priority:90
msgid "Unlike the `raw` format above, the time zone/UTC offset information contained in an RFC 2822 date string is used to adjust the date value to UTC prior to storage.  Therefore it is important that this information be as accurate as possible."
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:328
#, priority:90
msgid "If the source material uses RFC 2822 style dates, the frontend should let fast-import handle the parsing and conversion (rather than attempting to do it itself) as the Git parser has been well tested in the wild."
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:333
#, priority:90
msgid "Frontends should prefer the `raw` format if the source material already uses UNIX-epoch format, can be coaxed to give dates in that format, or its format is easily convertible to it, as there is no ambiguity in parsing."
msgstr ""

#. type: Labeled list
#: en/git-fast-import.txt:334
#, ignore-same, no-wrap, priority:90
msgid "`now`"
msgstr "`now`"

#. type: Plain text
#: en/git-fast-import.txt:337
#, priority:90
msgid "Always use the current time and time zone.  The literal `now` must always be supplied for `<when>`."
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:342
#, priority:90
msgid "This is a toy format.  The current time and time zone of this system is always copied into the identity string at the time it is being created by fast-import.  There is no way to specify a different time or time zone."
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:347
#, priority:90
msgid "This particular format is supplied as it's short to implement and may be useful to a process that wants to create a new commit right now, without needing to use a working directory or 'git update-index'."
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:354
#, priority:90
msgid "If separate `author` and `committer` commands are used in a `commit` the timestamps may not match, as the system clock will be polled twice (once for each command).  The only way to ensure that both author and committer identity information has the same timestamp is to omit `author` (thus copying from `committer`) or to use a date format other than `now`."
msgstr ""

#. type: Title ~
#: en/git-fast-import.txt:356
#, fuzzy, no-wrap, priority:90
msgid "Commands"
msgstr "命令"

#. type: Plain text
#: en/git-fast-import.txt:360
#, priority:90
msgid "fast-import accepts several commands to update the current repository and control the current import process.  More detailed discussion (with examples) of each command follows later."
msgstr ""

#. type: Title ~
#: en/git-fast-import.txt:361 en/git-fast-import.txt:430
#, ignore-same, no-wrap, priority:90
msgid "`commit`"
msgstr "`commit`"

#. type: Plain text
#: en/git-fast-import.txt:365
#, priority:90
msgid "Creates a new branch or updates an existing branch by creating a new commit and updating the branch to point at the newly created commit."
msgstr ""

#. type: Title ~
#: en/git-fast-import.txt:366 en/git-fast-import.txt:820
#, ignore-same, no-wrap, priority:90
msgid "`tag`"
msgstr "`tag`"

#. type: Plain text
#: en/git-fast-import.txt:371
#, priority:90
msgid "Creates an annotated tag object from an existing commit or branch.  Lightweight tags are not supported by this command, as they are not recommended for recording meaningful points in time."
msgstr ""

#. type: Title ~
#: en/git-fast-import.txt:372 en/git-fast-import.txt:865
#, ignore-same, no-wrap, priority:90
msgid "`reset`"
msgstr "`reset`"

#. type: Plain text
#: en/git-fast-import.txt:376
#, priority:90
msgid "Reset an existing branch (or a new branch) to a specific revision.  This command must be used to change a branch to a specific revision without making a commit on it."
msgstr ""

#. type: Title ~
#: en/git-fast-import.txt:377 en/git-fast-import.txt:894
#, ignore-same, no-wrap, priority:90
msgid "`blob`"
msgstr "`blob`"

#. type: Plain text
#: en/git-fast-import.txt:381
#, priority:90
msgid "Convert raw file data into a blob, for future use in a `commit` command.  This command is optional and is not needed to perform an import."
msgstr ""

#. type: Title ~
#: en/git-fast-import.txt:382 en/git-fast-import.txt:967
#, ignore-same, no-wrap, priority:90
msgid "`alias`"
msgstr "`alias`"

#. type: Plain text
#: en/git-fast-import.txt:388
#, priority:90
msgid "Record that a mark refers to a given object without first creating any new object.  Using --import-marks and referring to missing marks will cause fast-import to fail, so aliases can provide a way to set otherwise pruned commits to a valid value (e.g. the nearest non-pruned ancestor)."
msgstr ""

#. type: Title ~
#: en/git-fast-import.txt:389 en/git-fast-import.txt:982
#, ignore-same, no-wrap, priority:90
msgid "`checkpoint`"
msgstr "`checkpoint`"

#. type: Plain text
#: en/git-fast-import.txt:394
#, priority:90
msgid "Forces fast-import to close the current packfile, generate its unique SHA-1 checksum and index, and start a new packfile.  This command is optional and is not needed to perform an import."
msgstr ""

#. type: Title ~
#: en/git-fast-import.txt:395 en/git-fast-import.txt:1010
#, ignore-same, no-wrap, priority:90
msgid "`progress`"
msgstr "`progress`"

#. type: Plain text
#: en/git-fast-import.txt:399
#, priority:90
msgid "Causes fast-import to echo the entire line to its own standard output.  This command is optional and is not needed to perform an import."
msgstr ""

#. type: Title ~
#: en/git-fast-import.txt:400 en/git-fast-import.txt:1217
#, ignore-same, no-wrap, priority:90
msgid "`done`"
msgstr "`done`"

#. type: Plain text
#: en/git-fast-import.txt:404
#, priority:90
msgid "Marks the end of the stream. This command is optional unless the `done` feature was requested using the `--done` command-line option or `feature done` command."
msgstr ""

#. type: Title ~
#: en/git-fast-import.txt:405 en/git-fast-import.txt:1035
#, ignore-same, no-wrap, priority:90
msgid "`get-mark`"
msgstr "`get-mark`"

#. type: Plain text
#: en/git-fast-import.txt:409
#, priority:90
msgid "Causes fast-import to print the SHA-1 corresponding to a mark to the file descriptor set with `--cat-blob-fd`, or `stdout` if unspecified."
msgstr ""

#. type: Title ~
#: en/git-fast-import.txt:410 en/git-fast-import.txt:1050
#, ignore-same, no-wrap, priority:90
msgid "`cat-blob`"
msgstr "`cat-blob`"

#. type: Plain text
#: en/git-fast-import.txt:414
#, priority:90
msgid "Causes fast-import to print a blob in 'cat-file --batch' format to the file descriptor set with `--cat-blob-fd` or `stdout` if unspecified."
msgstr ""

#. type: Title ~
#: en/git-fast-import.txt:415 en/git-fast-import.txt:1081
#, ignore-same, no-wrap, priority:90
msgid "`ls`"
msgstr "`ls`"

#. type: Plain text
#: en/git-fast-import.txt:419
#, priority:90
msgid "Causes fast-import to print a line describing a directory entry in 'ls-tree' format to the file descriptor set with `--cat-blob-fd` or `stdout` if unspecified."
msgstr ""

#. type: Title ~
#: en/git-fast-import.txt:420 en/git-fast-import.txt:1134
#, ignore-same, no-wrap, priority:90
msgid "`feature`"
msgstr "`feature`"

#. type: Plain text
#: en/git-fast-import.txt:423
#, priority:90
msgid "Enable the specified feature. This requires that fast-import supports the specified feature, and aborts if it does not."
msgstr ""

#. type: Title ~
#: en/git-fast-import.txt:424 en/git-fast-import.txt:1189
#, ignore-same, no-wrap, priority:90
msgid "`option`"
msgstr "`option`"

#. type: Plain text
#: en/git-fast-import.txt:428
#, priority:90
msgid "Specify any of the options listed under OPTIONS that do not change stream semantic to suit the frontend's needs. This command is optional and is not needed to perform an import."
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:433
#, priority:90
msgid "Create or update a branch with a new commit, recording one logical change to the project."
msgstr ""

#. type: delimited block .
#: en/git-fast-import.txt:446
#, no-wrap, priority:90
msgid ""
"\t'commit' SP <ref> LF\n"
"\tmark?\n"
"\toriginal-oid?\n"
"\t('author' (SP <name>)? SP LT <email> GT SP <when> LF)?\n"
"\t'committer' (SP <name>)? SP LT <email> GT SP <when> LF\n"
"\t('encoding' SP <encoding>)?\n"
"\tdata\n"
"\t('from' SP <commit-ish> LF)?\n"
"\t('merge' SP <commit-ish> LF)*\n"
"\t(filemodify | filedelete | filecopy | filerename | filedeleteall | notemodify)*\n"
"\tLF?\n"
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:454
#, priority:90
msgid "where `<ref>` is the name of the branch to make the commit on.  Typically branch names are prefixed with `refs/heads/` in Git, so importing the CVS branch symbol `RELENG-1_0` would use `refs/heads/RELENG-1_0` for the value of `<ref>`.  The value of `<ref>` must be a valid refname in Git.  As `LF` is not valid in a Git refname, no quoting or escaping syntax is supported here."
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:460
#, priority:90
msgid "A `mark` command may optionally appear, requesting fast-import to save a reference to the newly created commit for future use by the frontend (see below for format).  It is very common for frontends to mark every commit they create, thereby allowing future branch creation from any imported commit."
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:466
#, priority:90
msgid "The `data` command following `committer` must supply the commit message (see below for `data` command syntax).  To import an empty commit message use a 0 length data.  Commit messages are free-form and are not interpreted by Git.  Currently they must be encoded in UTF-8, as fast-import does not permit other encodings to be specified."
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:474
#, priority:90
msgid "Zero or more `filemodify`, `filedelete`, `filecopy`, `filerename`, `filedeleteall` and `notemodify` commands may be included to update the contents of the branch prior to creating the commit.  These commands may be supplied in any order.  However it is recommended that a `filedeleteall` command precede all `filemodify`, `filecopy`, `filerename` and `notemodify` commands in the same commit, as `filedeleteall` wipes the branch clean (see below)."
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:481
#, priority:90
msgid "The `LF` after the command is optional (it used to be required).  Note that for reasons of backward compatibility, if the commit ends with a `data` command (i.e. it has no `from`, `merge`, `filemodify`, `filedelete`, `filecopy`, `filerename`, `filedeleteall` or `notemodify` commands) then two `LF` commands may appear at the end of the command instead of just one."
msgstr ""

#. type: Title ^
#: en/git-fast-import.txt:483
#, ignore-same, no-wrap, priority:90
msgid "`author`"
msgstr "`author`"

#. type: Plain text
#: en/git-fast-import.txt:489
#, priority:90
msgid "An `author` command may optionally appear, if the author information might differ from the committer information.  If `author` is omitted then fast-import will automatically use the committer's information for the author portion of the commit.  See below for a description of the fields in `author`, as they are identical to `committer`."
msgstr ""

#. type: Title ^
#: en/git-fast-import.txt:491
#, ignore-same, no-wrap, priority:90
msgid "`committer`"
msgstr "`committer`"

#. type: Plain text
#: en/git-fast-import.txt:494
#, priority:90
msgid "The `committer` command indicates who made this commit, and when they made it."
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:502
#, priority:90
msgid "Here `<name>` is the person's display name (for example ``Com M Itter'') and `<email>` is the person's email address (``\\cm@example.com'').  `LT` and `GT` are the literal less-than (\\x3c)  and greater-than (\\x3e) symbols.  These are required to delimit the email address from the other fields in the line.  Note that `<name>` and `<email>` are free-form and may contain any sequence of bytes, except `LT`, `GT` and `LF`.  `<name>` is typically UTF-8 encoded."
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:507
#, priority:90
msgid "The time of the change is specified by `<when>` using the date format that was selected by the --date-format=<fmt> command-line option.  See ``Date Formats'' above for the set of supported formats, and their syntax."
msgstr ""

#. type: Title ^
#: en/git-fast-import.txt:509
#, ignore-same, no-wrap, priority:90
msgid "`encoding`"
msgstr "`encoding`"

#. type: Plain text
#: en/git-fast-import.txt:513
#, priority:90
msgid "The optional `encoding` command indicates the encoding of the commit message.  Most commits are UTF-8 and the encoding is omitted, but this allows importing commit messages into git without first reencoding them."
msgstr ""

#. type: Title ^
#: en/git-fast-import.txt:515
#, ignore-same, no-wrap, priority:90
msgid "`from`"
msgstr "`from`"

#. type: Plain text
#: en/git-fast-import.txt:521
#, priority:90
msgid "The `from` command is used to specify the commit to initialize this branch from.  This revision will be the first ancestor of the new commit.  The state of the tree built at this commit will begin with the state at the `from` commit, and be altered by the content modifications in this commit."
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:531
#, priority:90
msgid "Omitting the `from` command in the first commit of a new branch will cause fast-import to create that commit with no ancestor. This tends to be desired only for the initial commit of a project.  If the frontend creates all files from scratch when making a new branch, a `merge` command may be used instead of `from` to start the commit with an empty tree.  Omitting the `from` command on existing branches is usually desired, as the current commit on that branch is automatically assumed to be the first ancestor of the new commit."
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:534
#, priority:90
msgid "As `LF` is not valid in a Git refname or SHA-1 expression, no quoting or escaping syntax is supported within `<commit-ish>`."
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:536
#, priority:90
msgid "Here `<commit-ish>` is any of the following:"
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:540
#, priority:90
msgid "The name of an existing branch already in fast-import's internal branch table.  If fast-import doesn't know the name, it's treated as a SHA-1 expression."
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:542
#, priority:90
msgid "A mark reference, `:<idnum>`, where `<idnum>` is the mark number."
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:548
#, priority:90
msgid "The reason fast-import uses `:` to denote a mark reference is this character is not legal in a Git branch name.  The leading `:` makes it easy to distinguish between the mark 42 (`:42`) and the branch 42 (`42` or `refs/heads/42`), or an abbreviated SHA-1 which happened to consist only of base-10 digits."
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:550
#, priority:90
msgid "Marks must be declared (via `mark`) before they can be used."
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:552
#, priority:90
msgid "A complete 40 byte or abbreviated commit SHA-1 in hex."
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:555
#, priority:90
msgid "Any valid Git SHA-1 expression that resolves to a commit.  See ``SPECIFYING REVISIONS'' in linkgit:gitrevisions[7] for details."
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:558
#, priority:90
msgid "The special null SHA-1 (40 zeros) specifies that the branch is to be removed."
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:561
#, priority:90
msgid "The special case of restarting an incremental import from the current branch value should be written as:"
msgstr ""

#. type: delimited block -
#: en/git-fast-import.txt:563
#, no-wrap, priority:90
msgid "\tfrom refs/heads/branch^0\n"
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:570
#, priority:90
msgid "The `^0` suffix is necessary as fast-import does not permit a branch to start from itself, and the branch is created in memory before the `from` command is even read from the input.  Adding `^0` will force fast-import to resolve the commit through Git's revision parsing library, rather than its internal branch table, thereby loading in the existing value of the branch."
msgstr ""

#. type: Title ^
#: en/git-fast-import.txt:572
#, ignore-same, no-wrap, priority:90
msgid "`merge`"
msgstr "`merge`"

#. type: Plain text
#: en/git-fast-import.txt:580
#, priority:90
msgid "Includes one additional ancestor commit.  The additional ancestry link does not change the way the tree state is built at this commit.  If the `from` command is omitted when creating a new branch, the first `merge` commit will be the first ancestor of the current commit, and the branch will start out with no files.  An unlimited number of `merge` commands per commit are permitted by fast-import, thereby establishing an n-way merge."
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:583
#, priority:90
msgid "Here `<commit-ish>` is any of the commit specification expressions also accepted by `from` (see above)."
msgstr ""

#. type: Title ^
#: en/git-fast-import.txt:585
#, ignore-same, no-wrap, priority:90
msgid "`filemodify`"
msgstr "`filemodify`"

#. type: Plain text
#: en/git-fast-import.txt:589
#, priority:90
msgid "Included in a `commit` command to add a new file or change the content of an existing file.  This command has two different means of specifying the content of the file."
msgstr ""

#. type: Labeled list
#: en/git-fast-import.txt:590 en/git-fast-import.txt:757
#, no-wrap, priority:90
msgid "External data format"
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:593
#, priority:90
msgid "The data content for the file was already supplied by a prior `blob` command.  The frontend just needs to connect it."
msgstr ""

#. type: delimited block .
#: en/git-fast-import.txt:596
#, fuzzy, no-wrap, priority:90
msgid "\t'M' SP <mode> SP <dataref> SP <path> LF\n"
msgstr "\t'M' SP <mode> SP <dataref> SP <path> LF\n"

#. type: Plain text
#: en/git-fast-import.txt:603
#, priority:90
msgid "Here usually `<dataref>` must be either a mark reference (`:<idnum>`)  set by a prior `blob` command, or a full 40-byte SHA-1 of an existing Git blob object.  If `<mode>` is `040000`` then `<dataref>` must be the full 40-byte SHA-1 of an existing Git tree object or a mark reference set with `--import-marks`."
msgstr ""

#. type: Labeled list
#: en/git-fast-import.txt:604 en/git-fast-import.txt:770
#, no-wrap, priority:90
msgid "Inline data format"
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:608
#, priority:90
msgid "The data content for the file has not been supplied yet.  The frontend wants to supply it as part of this modify command."
msgstr ""

#. type: delimited block .
#: en/git-fast-import.txt:612
#, no-wrap, priority:90
msgid ""
"\t'M' SP <mode> SP 'inline' SP <path> LF\n"
"\tdata\n"
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:615 en/git-fast-import.txt:781
#, priority:90
msgid "See below for a detailed description of the `data` command."
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:618
#, priority:90
msgid "In both formats `<mode>` is the type of file entry, specified in octal.  Git only supports the following modes:"
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:622
#, priority:90
msgid "`100644` or `644`: A normal (not-executable) file.  The majority of files in most projects use this mode.  If in doubt, this is what you want."
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:623
#, priority:90
msgid "`100755` or `755`: A normal, but executable, file."
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:624
#, priority:90
msgid "`120000`: A symlink, the content of the file will be the link target."
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:627
#, priority:90
msgid "`160000`: A gitlink, SHA-1 of the object refers to a commit in another repository. Git links can only be specified by SHA or through a commit mark. They are used to implement submodules."
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:629
#, priority:90
msgid "`040000`: A subdirectory.  Subdirectories can only be specified by SHA or through a tree mark set with `--import-marks`."
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:632
#, priority:90
msgid "In both formats `<path>` is the complete path of the file to be added (if not already existing) or modified (if already existing)."
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:636
#, priority:90
msgid "A `<path>` string must use UNIX-style directory separators (forward slash `/`), may contain any byte other than `LF`, and must not start with double quote (`\"`)."
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:643
#, priority:90
msgid "A path can use C-style string quoting; this is accepted in all cases and mandatory if the filename starts with double quote or contains `LF`. In C-style quoting, the complete name should be surrounded with double quotes, and any `LF`, backslash, or double quote characters must be escaped by preceding them with a backslash (e.g., `\"path/with\\n, \\\\ and \\\" in it\"`)."
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:645
#, priority:90
msgid "The value of `<path>` must be in canonical form. That is it must not:"
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:647
#, priority:90
msgid "contain an empty directory component (e.g. `foo//bar` is invalid),"
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:648
#, priority:90
msgid "end with a directory separator (e.g. `foo/` is invalid),"
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:649
#, priority:90
msgid "start with a directory separator (e.g. `/foo` is invalid),"
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:651
#, priority:90
msgid "contain the special component `.` or `..` (e.g. `foo/./bar` and `foo/../bar` are invalid)."
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:653
#, priority:90
msgid "The root of the tree can be represented by an empty string as `<path>`."
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:655
#, priority:90
msgid "It is recommended that `<path>` always be encoded using UTF-8."
msgstr ""

#. type: Title ^
#: en/git-fast-import.txt:657
#, ignore-same, no-wrap, priority:90
msgid "`filedelete`"
msgstr "`filedelete`"

#. type: Plain text
#: en/git-fast-import.txt:663
#, priority:90
msgid "Included in a `commit` command to remove a file or recursively delete an entire directory from the branch.  If the file or directory removal makes its parent directory empty, the parent directory will be automatically removed too.  This cascades up the tree until the first non-empty directory or the root is reached."
msgstr ""

#. type: delimited block .
#: en/git-fast-import.txt:666
#, no-wrap, priority:90
msgid "\t'D' SP <path> LF\n"
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:671
#, priority:90
msgid "here `<path>` is the complete path of the file or subdirectory to be removed from the branch.  See `filemodify` above for a detailed description of `<path>`."
msgstr ""

#. type: Title ^
#: en/git-fast-import.txt:673
#, ignore-same, no-wrap, priority:90
msgid "`filecopy`"
msgstr "`filecopy`"

#. type: Plain text
#: en/git-fast-import.txt:678
#, priority:90
msgid "Recursively copies an existing file or subdirectory to a different location within the branch.  The existing file or directory must exist.  If the destination exists it will be completely replaced by the content copied from the source."
msgstr ""

#. type: delimited block .
#: en/git-fast-import.txt:681
#, fuzzy, no-wrap, priority:90
msgid "\t'C' SP <path> SP <path> LF\n"
msgstr "\t'C' SP <path> SP <path> LF\n"

#. type: Plain text
#: en/git-fast-import.txt:687 en/git-fast-import.txt:707
#, priority:90
msgid "here the first `<path>` is the source location and the second `<path>` is the destination.  See `filemodify` above for a detailed description of what `<path>` may look like.  To use a source path that contains SP the path must be quoted."
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:692
#, priority:90
msgid "A `filecopy` command takes effect immediately.  Once the source location has been copied to the destination any future commands applied to the source location will not impact the destination of the copy."
msgstr ""

#. type: Title ^
#: en/git-fast-import.txt:694
#, ignore-same, no-wrap, priority:90
msgid "`filerename`"
msgstr "`filerename`"

#. type: Plain text
#: en/git-fast-import.txt:698
#, priority:90
msgid "Renames an existing file or subdirectory to a different location within the branch.  The existing file or directory must exist. If the destination exists it will be replaced by the source directory."
msgstr ""

#. type: delimited block .
#: en/git-fast-import.txt:701
#, fuzzy, no-wrap, priority:90
msgid "\t'R' SP <path> SP <path> LF\n"
msgstr "\t'R' SP <path> SP <path> LF\n"

#. type: Plain text
#: en/git-fast-import.txt:712
#, priority:90
msgid "A `filerename` command takes effect immediately.  Once the source location has been renamed to the destination any future commands applied to the source location will create new files there and not impact the destination of the rename."
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:721
#, priority:90
msgid "Note that a `filerename` is the same as a `filecopy` followed by a `filedelete` of the source location.  There is a slight performance advantage to using `filerename`, but the advantage is so small that it is never worth trying to convert a delete/add pair in source material into a rename for fast-import.  This `filerename` command is provided just to simplify frontends that already have rename information and don't want bother with decomposing it into a `filecopy` followed by a `filedelete`."
msgstr ""

#. type: Title ^
#: en/git-fast-import.txt:723
#, ignore-same, no-wrap, priority:90
msgid "`filedeleteall`"
msgstr "`filedeleteall`"

#. type: Plain text
#: en/git-fast-import.txt:728
#, priority:90
msgid "Included in a `commit` command to remove all files (and also all directories) from the branch.  This command resets the internal branch structure to have no files in it, allowing the frontend to subsequently add all interesting files from scratch."
msgstr ""

#. type: delimited block .
#: en/git-fast-import.txt:731
#, no-wrap, priority:90
msgid "\t'deleteall' LF\n"
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:737
#, priority:90
msgid "This command is extremely useful if the frontend does not know (or does not care to know) what files are currently on the branch, and therefore cannot generate the proper `filedelete` commands to update the content."
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:745
#, priority:90
msgid "Issuing a `filedeleteall` followed by the needed `filemodify` commands to set the correct content will produce the same results as sending only the needed `filemodify` and `filedelete` commands.  The `filedeleteall` approach may however require fast-import to use slightly more memory per active branch (less than 1 MiB for even most large projects); so frontends that can easily obtain only the affected paths for a commit are encouraged to do so."
msgstr ""

#. type: Title ^
#: en/git-fast-import.txt:747
#, ignore-same, no-wrap, priority:90
msgid "`notemodify`"
msgstr "`notemodify`"

#. type: Plain text
#: en/git-fast-import.txt:756
#, priority:90
msgid "Included in a `commit` `<notes_ref>` command to add a new note annotating a `<commit-ish>` or change this annotation contents.  Internally it is similar to filemodify 100644 on `<commit-ish>` path (maybe split into subdirectories). It's not advised to use any other commands to write to the `<notes_ref>` tree except `filedeleteall` to delete all existing notes in this tree.  This command has two different means of specifying the content of the note."
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:761
#, priority:90
msgid "The data content for the note was already supplied by a prior `blob` command.  The frontend just needs to connect it to the commit that is to be annotated."
msgstr ""

#. type: delimited block .
#: en/git-fast-import.txt:764
#, fuzzy, no-wrap, priority:90
msgid "\t'N' SP <dataref> SP <commit-ish> LF\n"
msgstr "\t'N' SP <dataref> SP <commit-ish> LF\n"

#. type: Plain text
#: en/git-fast-import.txt:769
#, priority:90
msgid "Here `<dataref>` can be either a mark reference (`:<idnum>`)  set by a prior `blob` command, or a full 40-byte SHA-1 of an existing Git blob object."
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:774
#, priority:90
msgid "The data content for the note has not been supplied yet.  The frontend wants to supply it as part of this modify command."
msgstr ""

#. type: delimited block .
#: en/git-fast-import.txt:778
#, no-wrap, priority:90
msgid ""
"\t'N' SP 'inline' SP <commit-ish> LF\n"
"\tdata\n"
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:784
#, priority:90
msgid "In both formats `<commit-ish>` is any of the commit specification expressions also accepted by `from` (see above)."
msgstr ""

#. type: Title ~
#: en/git-fast-import.txt:786
#, ignore-same, no-wrap, priority:90
msgid "`mark`"
msgstr "`mark`"

#. type: Plain text
#: en/git-fast-import.txt:792
#, priority:90
msgid "Arranges for fast-import to save a reference to the current object, allowing the frontend to recall this object at a future point in time, without knowing its SHA-1.  Here the current object is the object creation command the `mark` command appears within.  This can be `commit`, `tag`, and `blob`, but `commit` is the most common usage."
msgstr ""

#. type: delimited block .
#: en/git-fast-import.txt:795
#, fuzzy, no-wrap, priority:90
msgid "\t'mark' SP ':' <idnum> LF\n"
msgstr "\t'mark' SP ':' <idnum> LF\n"

#. type: Plain text
#: en/git-fast-import.txt:801
#, priority:90
msgid "where `<idnum>` is the number assigned by the frontend to this mark.  The value of `<idnum>` is expressed as an ASCII decimal integer.  The value 0 is reserved and cannot be used as a mark.  Only values greater than or equal to 1 may be used as marks."
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:805
#, priority:90
msgid "New marks are created automatically.  Existing marks can be moved to another object simply by reusing the same `<idnum>` in another `mark` command."
msgstr ""

#. type: Title ~
#: en/git-fast-import.txt:807
#, ignore-same, no-wrap, priority:90
msgid "`original-oid`"
msgstr "`original-oid`"

#. type: Plain text
#: en/git-fast-import.txt:812
#, priority:90
msgid "Provides the name of the object in the original source control system.  fast-import will simply ignore this directive, but filter processes which operate on and modify the stream before feeding to fast-import may have uses for this information"
msgstr ""

#. type: delimited block .
#: en/git-fast-import.txt:815
#, no-wrap, priority:90
msgid "\t'original-oid' SP <object-identifier> LF\n"
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:818
#, priority:90
msgid "where `<object-identifier>` is any string not containing LF."
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:823
#, priority:90
msgid "Creates an annotated tag referring to a specific commit.  To create lightweight (non-annotated) tags see the `reset` command below."
msgstr ""

#. type: delimited block .
#: en/git-fast-import.txt:831
#, no-wrap, priority:90
msgid ""
"\t'tag' SP <name> LF\n"
"\tmark?\n"
"\t'from' SP <commit-ish> LF\n"
"\toriginal-oid?\n"
"\t'tagger' (SP <name>)? SP LT <email> GT SP <when> LF\n"
"\tdata\n"
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:834
#, priority:90
msgid "where `<name>` is the name of the tag to create."
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:839
#, priority:90
msgid "Tag names are automatically prefixed with `refs/tags/` when stored in Git, so importing the CVS branch symbol `RELENG-1_0-FINAL` would use just `RELENG-1_0-FINAL` for `<name>`, and fast-import will write the corresponding ref as `refs/tags/RELENG-1_0-FINAL`."
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:843
#, priority:90
msgid "The value of `<name>` must be a valid refname in Git and therefore may contain forward slashes.  As `LF` is not valid in a Git refname, no quoting or escaping syntax is supported here."
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:846
#, priority:90
msgid "The `from` command is the same as in the `commit` command; see above for details."
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:849
#, priority:90
msgid "The `tagger` command uses the same format as `committer` within `commit`; again see above for details."
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:855
#, priority:90
msgid "The `data` command following `tagger` must supply the annotated tag message (see below for `data` command syntax).  To import an empty tag message use a 0 length data.  Tag messages are free-form and are not interpreted by Git.  Currently they must be encoded in UTF-8, as fast-import does not permit other encodings to be specified."
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:863
#, priority:90
msgid "Signing annotated tags during import from within fast-import is not supported.  Trying to include your own PGP/GPG signature is not recommended, as the frontend does not (easily) have access to the complete set of bytes which normally goes into such a signature.  If signing is required, create lightweight tags from within fast-import with `reset`, then create the annotated versions of those tags offline with the standard 'git tag' process."
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:870
#, priority:90
msgid "Creates (or recreates) the named branch, optionally starting from a specific revision.  The reset command allows a frontend to issue a new `from` command for an existing branch, or to create a new branch from an existing commit without creating a new commit."
msgstr ""

#. type: delimited block .
#: en/git-fast-import.txt:875
#, no-wrap, priority:90
msgid ""
"\t'reset' SP <ref> LF\n"
"\t('from' SP <commit-ish> LF)?\n"
"\tLF?\n"
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:879
#, priority:90
msgid "For a detailed description of `<ref>` and `<commit-ish>` see above under `commit` and `from`."
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:881 en/git-fast-import.txt:1008
#, priority:90
msgid "The `LF` after the command is optional (it used to be required)."
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:884
#, priority:90
msgid "The `reset` command can also be used to create lightweight (non-annotated) tags.  For example:"
msgstr ""

#. type: delimited block =
#: en/git-fast-import.txt:888
#, no-wrap, priority:90
msgid ""
"\treset refs/tags/938\n"
"\tfrom :938\n"
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:892
#, priority:90
msgid "would create the lightweight tag `refs/tags/938` referring to whatever commit mark `:938` references."
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:899
#, priority:90
msgid "Requests writing one file revision to the packfile.  The revision is not connected to any commit; this connection must be formed in a subsequent `commit` command by referencing the blob through an assigned mark."
msgstr ""

#. type: delimited block .
#: en/git-fast-import.txt:905
#, no-wrap, priority:90
msgid ""
"\t'blob' LF\n"
"\tmark?\n"
"\toriginal-oid?\n"
"\tdata\n"
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:911
#, priority:90
msgid "The mark command is optional here as some frontends have chosen to generate the Git SHA-1 for the blob on their own, and feed that directly to `commit`.  This is typically more work than it's worth however, as marks are inexpensive to store and easy to use."
msgstr ""

#. type: Title ~
#: en/git-fast-import.txt:913
#, ignore-same, no-wrap, priority:90
msgid "`data`"
msgstr "`data`"

#. type: Plain text
#: en/git-fast-import.txt:920
#, priority:90
msgid "Supplies raw data (for use as blob/file content, commit messages, or annotated tag messages) to fast-import.  Data can be supplied using an exact byte count or delimited with a terminating line.  Real frontends intended for production-quality conversions should always use the exact byte count format, as it is more robust and performs better.  The delimited format is intended primarily for testing fast-import."
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:925
#, priority:90
msgid "Comment lines appearing within the `<raw>` part of `data` commands are always taken to be part of the body of the data and are therefore never ignored by fast-import.  This makes it safe to import any file/message content whose lines might start with `#`."
msgstr ""

#. type: Labeled list
#: en/git-fast-import.txt:926
#, no-wrap, priority:90
msgid "Exact byte count format"
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:928
#, priority:90
msgid "The frontend must specify the number of bytes of data."
msgstr ""

#. type: delimited block .
#: en/git-fast-import.txt:932
#, no-wrap, priority:90
msgid ""
"\t'data' SP <count> LF\n"
"\t<raw> LF?\n"
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:938
#, priority:90
msgid "where `<count>` is the exact number of bytes appearing within `<raw>`.  The value of `<count>` is expressed as an ASCII decimal integer.  The `LF` on either side of `<raw>` is not included in `<count>` and will not be included in the imported data."
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:943
#, priority:90
msgid "The `LF` after `<raw>` is optional (it used to be required) but recommended.  Always including it makes debugging a fast-import stream easier as the next command always starts in column 0 of the next line, even if `<raw>` did not end with an `LF`."
msgstr ""

#. type: Labeled list
#: en/git-fast-import.txt:944
#, no-wrap, priority:90
msgid "Delimited format"
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:949
#, priority:90
msgid "A delimiter string is used to mark the end of the data.  fast-import will compute the length by searching for the delimiter.  This format is primarily useful for testing and is not recommended for real data."
msgstr ""

#. type: delimited block .
#: en/git-fast-import.txt:955
#, no-wrap, priority:90
msgid ""
"\t'data' SP '<<' <delim> LF\n"
"\t<raw> LF\n"
"\t<delim> LF\n"
"\tLF?\n"
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:963
#, priority:90
msgid "where `<delim>` is the chosen delimiter string.  The string `<delim>` must not appear on a line by itself within `<raw>`, as otherwise fast-import will think the data ends earlier than it really does.  The `LF` immediately trailing `<raw>` is part of `<raw>`.  This is one of the limitations of the delimited format, it is impossible to supply a data chunk which does not have an LF as its last byte."
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:965
#, priority:90
msgid "The `LF` after `<delim> LF` is optional (it used to be required)."
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:970
#, priority:90
msgid "Record that a mark refers to a given object without first creating any new object."
msgstr ""

#. type: delimited block .
#: en/git-fast-import.txt:976
#, no-wrap, priority:90
msgid ""
"\t'alias' LF\n"
"\tmark\n"
"\t'to' SP <commit-ish> LF\n"
"\tLF?\n"
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:979
#, priority:90
msgid "For a detailed description of `<commit-ish>` see above under `from`."
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:985
#, priority:90
msgid "Forces fast-import to close the current packfile, start a new one, and to save out all current branch refs, tags and marks."
msgstr ""

#. type: delimited block .
#: en/git-fast-import.txt:989
#, no-wrap, priority:90
msgid ""
"\t'checkpoint' LF\n"
"\tLF?\n"
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:995
#, priority:90
msgid "Note that fast-import automatically switches packfiles when the current packfile reaches --max-pack-size, or 4 GiB, whichever limit is smaller.  During an automatic packfile switch fast-import does not update the branch refs, tags or marks."
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:1000
#, priority:90
msgid "As a `checkpoint` can require a significant amount of CPU time and disk IO (to compute the overall pack SHA-1 checksum, generate the corresponding index file, and update the refs) it can easily take several minutes for a single `checkpoint` command to complete."
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:1006
#, priority:90
msgid "Frontends may choose to issue checkpoints during extremely large and long running imports, or when they need to allow another Git process access to a branch.  However given that a 30 GiB Subversion repository can be loaded into Git through fast-import in about 3 hours, explicit checkpointing may not be necessary."
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:1015
#, priority:90
msgid "Causes fast-import to print the entire `progress` line unmodified to its standard output channel (file descriptor 1) when the command is processed from the input stream.  The command otherwise has no impact on the current import, or on any of fast-import's internal state."
msgstr ""

#. type: delimited block .
#: en/git-fast-import.txt:1019
#, no-wrap, priority:90
msgid ""
"\t'progress' SP <any> LF\n"
"\tLF?\n"
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:1025
#, priority:90
msgid "The `<any>` part of the command may contain any sequence of bytes that does not contain `LF`.  The `LF` after the command is optional.  Callers may wish to process the output through a tool such as sed to remove the leading part of the line, for example:"
msgstr ""

#. type: delimited block =
#: en/git-fast-import.txt:1028
#, no-wrap, priority:90
msgid "\tfrontend | git fast-import | sed 's/^progress //'\n"
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:1033
#, priority:90
msgid "Placing a `progress` command immediately after a `checkpoint` will inform the reader when the `checkpoint` has been completed and it can safely access the refs that fast-import updated."
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:1041
#, priority:90
msgid "Causes fast-import to print the SHA-1 corresponding to a mark to stdout or to the file descriptor previously arranged with the `--cat-blob-fd` argument. The command otherwise has no impact on the current import; its purpose is to retrieve SHA-1s that later commits might want to refer to in their commit messages."
msgstr ""

#. type: delimited block .
#: en/git-fast-import.txt:1044
#, no-wrap, priority:90
msgid "\t'get-mark' SP ':' <idnum> LF\n"
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:1048 en/git-fast-import.txt:1079 en/git-fast-import.txt:1132
#, priority:90
msgid "See ``Responses To Commands'' below for details about how to read this output safely."
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:1056
#, priority:90
msgid "Causes fast-import to print a blob to a file descriptor previously arranged with the `--cat-blob-fd` argument.  The command otherwise has no impact on the current import; its main purpose is to retrieve blobs that may be in fast-import's memory but not accessible from the target repository."
msgstr ""

#. type: delimited block .
#: en/git-fast-import.txt:1059
#, fuzzy, no-wrap, priority:90
msgid "\t'cat-blob' SP <dataref> LF\n"
msgstr "\t'cat-blob' SP <dataref> LF\n"

#. type: Plain text
#: en/git-fast-import.txt:1064
#, priority:90
msgid "The `<dataref>` can be either a mark reference (`:<idnum>`)  set previously or a full 40-byte SHA-1 of a Git blob, preexisting or ready to be written."
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:1066
#, priority:90
msgid "Output uses the same format as `git cat-file --batch`:"
msgstr ""

#. type: delimited block =
#: en/git-fast-import.txt:1070
#, no-wrap, priority:90
msgid ""
"\t<sha1> SP 'blob' SP <size> LF\n"
"\t<contents> LF\n"
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:1076
#, priority:90
msgid "This command can be used where a `filemodify` directive can appear, allowing it to be used in the middle of a commit.  For a `filemodify` using an inline directive, it can also appear right before the `data` directive."
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:1087
#, priority:90
msgid "Prints information about the object at a path to a file descriptor previously arranged with the `--cat-blob-fd` argument.  This allows printing a blob from the active commit (with `cat-blob`) or copying a blob or tree from a previous commit for use in the current one (with `filemodify`)."
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:1090
#, priority:90
msgid "The `ls` command can also be used where a `filemodify` directive can appear, allowing it to be used in the middle of a commit."
msgstr ""

#. type: Labeled list
#: en/git-fast-import.txt:1091
#, no-wrap, priority:90
msgid "Reading from the active commit"
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:1095
#, priority:90
msgid "This form can only be used in the middle of a `commit`.  The path names a directory entry within fast-import's active commit.  The path must be quoted in this case."
msgstr ""

#. type: delimited block .
#: en/git-fast-import.txt:1098
#, fuzzy, no-wrap, priority:90
msgid "\t'ls' SP <path> LF\n"
msgstr "\t'ls' SP <path> LF\n"

#. type: Labeled list
#: en/git-fast-import.txt:1100
#, no-wrap, priority:90
msgid "Reading from a named tree"
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:1106
#, priority:90
msgid "The `<dataref>` can be a mark reference (`:<idnum>`) or the full 40-byte SHA-1 of a Git tag, commit, or tree object, preexisting or waiting to be written.  The path is relative to the top level of the tree named by `<dataref>`."
msgstr ""

#. type: delimited block .
#: en/git-fast-import.txt:1109
#, fuzzy, no-wrap, priority:90
msgid "\t'ls' SP <dataref> SP <path> LF\n"
msgstr "\t'ls' SP <dataref> SP <path> LF\n"

#. type: Plain text
#: en/git-fast-import.txt:1112
#, priority:90
msgid "See `filemodify` above for a detailed description of `<path>`."
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:1114
#, priority:90
msgid "Output uses the same format as `git ls-tree <tree> -- <path>`:"
msgstr ""

#. type: delimited block =
#: en/git-fast-import.txt:1117
#, fuzzy, no-wrap, priority:90
msgid "\t<mode> SP ('blob' | 'tree' | 'commit') SP <dataref> HT <path> LF\n"
msgstr "\t<mode> SP ('blob' | 'tree' | 'commit') SP <dataref> HT <path> LF\n"

#. type: Plain text
#: en/git-fast-import.txt:1122
#, priority:90
msgid "The <dataref> represents the blob, tree, or commit object at <path> and can be used in later 'get-mark', 'cat-blob', 'filemodify', or 'ls' commands."
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:1125
#, priority:90
msgid "If there is no file or subtree at that path, 'git fast-import' will instead report"
msgstr ""

#. type: delimited block =
#: en/git-fast-import.txt:1128
#, no-wrap, priority:90
msgid "\tmissing SP <path> LF\n"
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:1137
#, priority:90
msgid "Require that fast-import supports the specified feature, or abort if it does not."
msgstr ""

#. type: delimited block .
#: en/git-fast-import.txt:1140
#, no-wrap, priority:90
msgid "\t'feature' SP <feature> ('=' <argument>)? LF\n"
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:1143
#, priority:90
msgid "The <feature> part of the command may be any one of the following:"
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:1144 en/git-fast-import.txt:1211
#, no-wrap, priority:90
msgid "date-format"
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:1145 en/git-fast-import.txt:1213
#, no-wrap, priority:90
msgid "export-marks"
msgstr ""

#. type: Labeled list
#: en/git-fast-import.txt:1146
#, fuzzy, no-wrap, priority:90
msgid "relative-marks"
msgstr "relative-marks"

#. type: Labeled list
#: en/git-fast-import.txt:1147
#, fuzzy, no-wrap, priority:90
msgid "no-relative-marks"
msgstr "no-relative-marks"

#. type: Plain text
#: en/git-fast-import.txt:1148 en/git-fast-import.txt:1215
#, fuzzy, no-wrap, priority:90
msgid "force"
msgstr "力"

#. type: Plain text
#: en/git-fast-import.txt:1152
#, priority:90
msgid "Act as though the corresponding command-line option with a leading `--` was passed on the command line (see OPTIONS, above)."
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:1153 en/git-fast-import.txt:1212
#, no-wrap, priority:90
msgid "import-marks"
msgstr ""

#. type: Labeled list
#: en/git-fast-import.txt:1154
#, no-wrap, priority:90
msgid "import-marks-if-exists"
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:1162
#, priority:90
msgid "Like --import-marks except in two respects: first, only one \"feature import-marks\" or \"feature import-marks-if-exists\" command is allowed per stream; second, an --import-marks= or --import-marks-if-exists command-line option overrides any of these \"feature\" commands in the stream; third, \"feature import-marks-if-exists\" like a corresponding command-line option silently skips a nonexistent file."
msgstr ""

#. type: Labeled list
#: en/git-fast-import.txt:1163
#, fuzzy, no-wrap, priority:90
msgid "get-mark"
msgstr "get-mark"

#. type: Labeled list
#: en/git-fast-import.txt:1164
#, fuzzy, no-wrap, priority:90
msgid "cat-blob"
msgstr "cat-blob"

#. type: Labeled list
#: en/git-fast-import.txt:1165
#, fuzzy, no-wrap, priority:90
msgid "ls"
msgstr "ls"

#. type: Plain text
#: en/git-fast-import.txt:1173
#, priority:90
msgid "Require that the backend support the 'get-mark', 'cat-blob', or 'ls' command respectively.  Versions of fast-import not supporting the specified command will exit with a message indicating so.  This lets the import error out early with a clear message, rather than wasting time on the early part of an import before the unsupported command is detected."
msgstr ""

#. type: Labeled list
#: en/git-fast-import.txt:1174
#, fuzzy, no-wrap, priority:90
msgid "notes"
msgstr "备注"

#. type: Plain text
#: en/git-fast-import.txt:1179
#, priority:90
msgid "Require that the backend support the 'notemodify' (N)  subcommand to the 'commit' command.  Versions of fast-import not supporting notes will exit with a message indicating so."
msgstr ""

#. type: Labeled list
#: en/git-fast-import.txt:1180
#, fuzzy, no-wrap, priority:90
msgid "done"
msgstr "完成"

#. type: Plain text
#: en/git-fast-import.txt:1187
#, priority:90
msgid "Error out if the stream ends without a 'done' command.  Without this feature, errors causing the frontend to end abruptly at a convenient point in the stream can go undetected.  This may occur, for example, if an import front end dies in mid-operation without emitting SIGTERM or SIGKILL at its subordinate git fast-import instance."
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:1194
#, priority:90
msgid "Processes the specified option so that git fast-import behaves in a way that suits the frontend's needs.  Note that options specified by the frontend are overridden by any options the user may specify to git fast-import itself."
msgstr ""

#. type: delimited block .
#: en/git-fast-import.txt:1197
#, no-wrap, priority:90
msgid "    'option' SP <option> LF\n"
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:1202
#, fuzzy, priority:90
msgid "The `<option>` part of the command may contain any of the options listed in the OPTIONS section that do not change import semantics, without the leading `--` and is treated in the same way."
msgstr "`<option>` 命令的一部分可能包含选项部分中列出的不更改导入语义的任何选项，而不更改前导 '--'，并且处理方式相同。"

#. type: Plain text
#: en/git-fast-import.txt:1206
#, priority:90
msgid "Option commands must be the first commands on the input (not counting feature commands), to give an option command after any non-option command is an error."
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:1209
#, priority:90
msgid "The following command-line options change import semantics and may therefore not be passed as option:"
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:1214
#, priority:90
msgid "cat-blob-fd"
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:1220
#, priority:90
msgid "If the `done` feature is not in use, treated as if EOF was read.  This can be used to tell fast-import to finish early."
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:1224
#, priority:90
msgid "If the `--done` command-line option or `feature done` command is in use, the `done` command is mandatory and marks the end of the stream."
msgstr ""

#. type: Title -
#: en/git-fast-import.txt:1226
#, no-wrap, priority:90
msgid "RESPONSES TO COMMANDS"
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:1233
#, priority:90
msgid "New objects written by fast-import are not available immediately.  Most fast-import commands have no visible effect until the next checkpoint (or completion).  The frontend can send commands to fill fast-import's input pipe without worrying about how quickly they will take effect, which improves performance by simplifying scheduling."
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:1240
#, priority:90
msgid "For some frontends, though, it is useful to be able to read back data from the current repository as it is being updated (for example when the source material describes objects in terms of patches to be applied to previously imported objects).  This can be accomplished by connecting the frontend and fast-import via bidirectional pipes:"
msgstr ""

#. type: delimited block =
#: en/git-fast-import.txt:1245
#, no-wrap, priority:90
msgid ""
"\tmkfifo fast-import-output\n"
"\tfrontend <fast-import-output |\n"
"\tgit fast-import >fast-import-output\n"
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:1249
#, priority:90
msgid "A frontend set up this way can use `progress`, `get-mark`, `ls`, and `cat-blob` commands to read information from the import in progress."
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:1253
#, priority:90
msgid "To avoid deadlock, such frontends must completely consume any pending output from `progress`, `ls`, `get-mark`, and `cat-blob` before performing writes to fast-import that might block."
msgstr ""

#. type: Title -
#: en/git-fast-import.txt:1255
#, no-wrap, priority:90
msgid "CRASH REPORTS"
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:1261
#, priority:90
msgid "If fast-import is supplied invalid input it will terminate with a non-zero exit status and create a crash report in the top level of the Git repository it was importing into.  Crash reports contain a snapshot of the internal fast-import state as well as the most recent commands that lead up to the crash."
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:1268
#, priority:90
msgid "All recent commands (including stream comments, file changes and progress commands) are shown in the command history within the crash report, but raw file data and commit messages are excluded from the crash report.  This exclusion saves space within the report file and reduces the amount of buffering that fast-import must perform during execution."
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:1276
#, priority:90
msgid "After writing a crash report fast-import will close the current packfile and export the marks table.  This allows the frontend developer to inspect the repository state and resume the import from the point where it crashed.  The modified branches and tags are not updated during a crash, as the import did not complete successfully.  Branch and tag information can be found in the crash report and must be applied manually if the update is needed."
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:1278
#, priority:90
msgid "An example crash:"
msgstr ""

#. type: delimited block =
#: en/git-fast-import.txt:1294
#, fuzzy, no-wrap, priority:90
msgid ""
"\t$ cat >in <<END_OF_INPUT\n"
"\t# my very first test commit\n"
"\tcommit refs/heads/master\n"
"\tcommitter Shawn O. Pearce <spearce> 19283 -0400\n"
"\t# who is that guy anyway?\n"
"\tdata <<EOF\n"
"\tthis is my commit\n"
"\tEOF\n"
"\tM 644 inline .gitignore\n"
"\tdata <<EOF\n"
"\t.gitignore\n"
"\tEOF\n"
"\tM 777 inline bob\n"
"\tEND_OF_INPUT\n"
msgstr ""
"\t$ cat >in <<END_OF_INPUT\n"
"\t# my very first test commit\n"
"\tcommit refs/heads/master\n"
"\tcommitter Shawn O. Pearce <spearce> 19283 -0400\n"
"\t# who is that guy anyway?\n"
"\tdata <<EOF\n"
"\tthis is my commit\n"
"\tEOF\n"
"\tM 644 inline .gitignore\n"
"\tdata <<EOF\n"
"\t.gitignore\n"
"\tEOF\n"
"\tM 777 inline bob\n"
"\tEND_OF_INPUT\n"

#. type: delimited block =
#: en/git-fast-import.txt:1298
#, fuzzy, no-wrap, priority:90
msgid ""
"\t$ git fast-import <in\n"
"\tfatal: Corrupt mode: M 777 inline bob\n"
"\tfast-import: dumping crash report to .git/fast_import_crash_8434\n"
msgstr ""
"\t$ git fast-import <in\n"
"\tfatal: Corrupt mode: M 777 inline bob\n"
"\tfast-import: dumping crash report to .git/fast_import_crash_8434\n"

#. type: delimited block =
#: en/git-fast-import.txt:1304
#, fuzzy, no-wrap, priority:90
msgid ""
"\t$ cat .git/fast_import_crash_8434\n"
"\tfast-import crash report:\n"
"\t    fast-import process: 8434\n"
"\t    parent process     : 1391\n"
"\t    at Sat Sep 1 00:58:12 2007\n"
msgstr ""
"\t$ cat .git/fast_import_crash_8434\n"
"\tfast-import crash report:\n"
"\t    fast-import process: 8434\n"
"\t    parent process     : 1391\n"
"\t    at Sat Sep 1 00:58:12 2007\n"

#. type: delimited block =
#: en/git-fast-import.txt:1306
#, no-wrap, priority:90
msgid "\tfatal: Corrupt mode: M 777 inline bob\n"
msgstr ""

#. type: delimited block =
#: en/git-fast-import.txt:1316
#, no-wrap, priority:90
msgid ""
"\tMost Recent Commands Before Crash\n"
"\t---------------------------------\n"
"\t  # my very first test commit\n"
"\t  commit refs/heads/master\n"
"\t  committer Shawn O. Pearce <spearce> 19283 -0400\n"
"\t  # who is that guy anyway?\n"
"\t  data <<EOF\n"
"\t  M 644 inline .gitignore\n"
"\t  data <<EOF\n"
msgstr ""

#. type: delimited block =
#: en/git-fast-import.txt:1317
#, fuzzy, no-wrap, priority:90
msgid "M 777 inline bob\n"
msgstr "M 777 inline bob\n"

#. type: delimited block =
#: en/git-fast-import.txt:1321
#, no-wrap, priority:90
msgid ""
"Active Branch LRU\n"
"-----------------\n"
"active_branches = 1 cur, 5 max\n"
msgstr ""

#. type: delimited block =
#: en/git-fast-import.txt:1324
#, fuzzy, priority:90
msgid "pos clock name ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
msgstr "pos clock name ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"

#. type: delimited block =
#: en/git-fast-import.txt:1325
#, fuzzy, priority:90
msgid "0 refs/heads/master"
msgstr "0 refs/heads/master"

#. type: delimited block =
#: en/git-fast-import.txt:1335
#, no-wrap, priority:90
msgid ""
"Inactive Branches\n"
"-----------------\n"
"refs/heads/master:\n"
"status      : active loaded dirty\n"
"tip commit  : 0000000000000000000000000000000000000000\n"
"old tree    : 0000000000000000000000000000000000000000\n"
"cur tree    : 0000000000000000000000000000000000000000\n"
"commit clock: 0\n"
"last pack   :\n"
msgstr ""

#. type: delimited block =
#: en/git-fast-import.txt:1339
#, fuzzy, priority:90
msgid "------------------- END OF CRASH REPORT"
msgstr "------------------- END OF CRASH REPORT"

#. type: Title -
#: en/git-fast-import.txt:1342
#, no-wrap, priority:90
msgid "TIPS AND TRICKS"
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:1345
#, priority:90
msgid "The following tips and tricks have been collected from various users of fast-import, and are offered here as suggestions."
msgstr ""

#. type: Title ~
#: en/git-fast-import.txt:1347
#, no-wrap, priority:90
msgid "Use One Mark Per Commit"
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:1355
#, priority:90
msgid "When doing a repository conversion, use a unique mark per commit (`mark :<n>`) and supply the --export-marks option on the command line.  fast-import will dump a file which lists every mark and the Git object SHA-1 that corresponds to it.  If the frontend can tie the marks back to the source repository, it is easy to verify the accuracy and completeness of the import by comparing each Git commit to the corresponding source revision."
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:1359
#, priority:90
msgid "Coming from a system such as Perforce or Subversion this should be quite simple, as the fast-import mark can also be the Perforce changeset number or the Subversion revision number."
msgstr ""

#. type: Title ~
#: en/git-fast-import.txt:1361
#, no-wrap, priority:90
msgid "Freely Skip Around Branches"
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:1366
#, priority:90
msgid "Don't bother trying to optimize the frontend to stick to one branch at a time during an import.  Although doing so might be slightly faster for fast-import, it tends to increase the complexity of the frontend code considerably."
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:1370
#, priority:90
msgid "The branch LRU builtin to fast-import tends to behave very well, and the cost of activating an inactive branch is so low that bouncing around between branches has virtually no impact on import performance."
msgstr ""

#. type: Title ~
#: en/git-fast-import.txt:1372
#, no-wrap, priority:90
msgid "Handling Renames"
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:1377
#, priority:90
msgid "When importing a renamed file or directory, simply delete the old name(s) and modify the new name(s) during the corresponding commit.  Git performs rename detection after-the-fact, rather than explicitly during a commit."
msgstr ""

#. type: Title ~
#: en/git-fast-import.txt:1379
#, no-wrap, priority:90
msgid "Use Tag Fixup Branches"
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:1383
#, priority:90
msgid "Some other SCM systems let the user create a tag from multiple files which are not from the same commit/changeset.  Or to create tags which are a subset of the files available in the repository."
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:1390
#, priority:90
msgid "Importing these tags as-is in Git is impossible without making at least one commit which ``fixes up'' the files to match the content of the tag.  Use fast-import's `reset` command to reset a dummy branch outside of your normal branch space to the base commit for the tag, then commit one or more file fixup commits, and finally tag the dummy branch."
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:1396
#, priority:90
msgid "For example since all normal branches are stored under `refs/heads/` name the tag fixup branch `TAG_FIXUP`.  This way it is impossible for the fixup branch used by the importer to have namespace conflicts with real branches imported from the source (the name `TAG_FIXUP` is not `refs/heads/TAG_FIXUP`)."
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:1402
#, priority:90
msgid "When committing fixups, consider using `merge` to connect the commit(s) which are supplying file revisions to the fixup branch.  Doing so will allow tools such as 'git blame' to track through the real commit history and properly annotate the source files."
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:1405
#, priority:90
msgid "After fast-import terminates the frontend will need to do `rm .git/TAG_FIXUP` to remove the dummy branch."
msgstr ""

#. type: Title ~
#: en/git-fast-import.txt:1407
#, no-wrap, priority:90
msgid "Import Now, Repack Later"
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:1411
#, priority:90
msgid "As soon as fast-import completes the Git repository is completely valid and ready for use.  Typically this takes only a very short time, even for considerably large projects (100,000+ commits)."
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:1418
#, priority:90
msgid "However repacking the repository is necessary to improve data locality and access performance.  It can also take hours on extremely large projects (especially if -f and a large --window parameter is used).  Since repacking is safe to run alongside readers and writers, run the repack in the background and let it finish when it finishes.  There is no reason to wait to explore your new Git project!"
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:1423
#, priority:90
msgid "If you choose to wait for the repack, don't try to run benchmarks or performance tests until repacking is completed.  fast-import outputs suboptimal packfiles that are simply never seen in real use situations."
msgstr ""

#. type: Title ~
#: en/git-fast-import.txt:1425
#, no-wrap, priority:90
msgid "Repacking Historical Data"
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:1432
#, priority:90
msgid "If you are repacking very old imported data (e.g. older than the last year), consider expending some extra CPU time and supplying --window=50 (or higher) when you run 'git repack'.  This will take longer, but will also produce a smaller packfile.  You only need to expend the effort once, and everyone using your project will benefit from the smaller repository."
msgstr ""

#. type: Title ~
#: en/git-fast-import.txt:1434
#, no-wrap, priority:90
msgid "Include Some Progress Messages"
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:1441
#, priority:90
msgid "Every once in a while have your frontend emit a `progress` message to fast-import.  The contents of the messages are entirely free-form, so one suggestion would be to output the current month and year each time the current commit date moves into the next month.  Your users will feel better knowing how much of the data stream has been processed."
msgstr ""

#. type: Title -
#: en/git-fast-import.txt:1444
#, no-wrap, priority:90
msgid "PACKFILE OPTIMIZATION"
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:1450
#, priority:90
msgid "When packing a blob fast-import always attempts to deltify against the last blob written.  Unless specifically arranged for by the frontend, this will probably not be a prior version of the same file, so the generated delta will not be the smallest possible.  The resulting packfile will be compressed, but will not be optimal."
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:1458
#, priority:90
msgid "Frontends which have efficient access to all revisions of a single file (for example reading an RCS/CVS ,v file) can choose to supply all revisions of that file as a sequence of consecutive `blob` commands.  This allows fast-import to deltify the different file revisions against each other, saving space in the final packfile.  Marks can be used to later identify individual file revisions during a sequence of `commit` commands."
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:1465
#, priority:90
msgid "The packfile(s) created by fast-import do not encourage good disk access patterns.  This is caused by fast-import writing the data in the order it is received on standard input, while Git typically organizes data within packfiles to make the most recent (current tip) data appear before historical data.  Git also clusters commits together, speeding up revision traversal through better cache locality."
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:1472
#, priority:90
msgid "For this reason it is strongly recommended that users repack the repository with `git repack -a -d` after fast-import completes, allowing Git to reorganize the packfiles for faster data access.  If blob deltas are suboptimal (see above) then also adding the `-f` option to force recomputation of all deltas can significantly reduce the final packfile size (30-50% smaller can be quite typical)."
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:1480
#, priority:90
msgid "Instead of running `git repack` you can also run `git gc --aggressive`, which will also optimize other things after an import (e.g. pack loose refs). As noted in the \"AGGRESSIVE\" section in linkgit:git-gc[1] the `--aggressive` option will find new deltas with the `-f` option to linkgit:git-repack[1]. For the reasons elaborated on above using `--aggressive` after a fast-import is one of the few cases where it's known to be worthwhile."
msgstr ""

#. type: Title -
#: en/git-fast-import.txt:1482
#, no-wrap, priority:90
msgid "MEMORY UTILIZATION"
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:1488
#, priority:90
msgid "There are a number of factors which affect how much memory fast-import requires to perform an import.  Like critical sections of core Git, fast-import uses its own memory allocators to amortize any overheads associated with malloc.  In practice fast-import tends to amortize any malloc overheads to 0, due to its use of large block allocations."
msgstr ""

#. type: Title ~
#: en/git-fast-import.txt:1490
#, no-wrap, priority:90
msgid "per object"
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:1497
#, priority:90
msgid "fast-import maintains an in-memory structure for every object written in this execution.  On a 32 bit system the structure is 32 bytes, on a 64 bit system the structure is 40 bytes (due to the larger pointer sizes).  Objects in the table are not deallocated until fast-import terminates.  Importing 2 million objects on a 32 bit system will require approximately 64 MiB of memory."
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:1503
#, priority:90
msgid "The object table is actually a hashtable keyed on the object name (the unique SHA-1).  This storage configuration allows fast-import to reuse an existing or already written object and avoid writing duplicates to the output packfile.  Duplicate blobs are surprisingly common in an import, typically due to branch merges in the source."
msgstr ""

#. type: Title ~
#: en/git-fast-import.txt:1505
#, no-wrap, priority:90
msgid "per mark"
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:1511
#, priority:90
msgid "Marks are stored in a sparse array, using 1 pointer (4 bytes or 8 bytes, depending on pointer size) per mark.  Although the array is sparse, frontends are still strongly encouraged to use marks between 1 and n, where n is the total number of marks required for this import."
msgstr ""

#. type: Title ~
#: en/git-fast-import.txt:1513
#, no-wrap, priority:90
msgid "per branch"
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:1516
#, priority:90
msgid "Branches are classified as active and inactive.  The memory usage of the two classes is significantly different."
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:1522
#, priority:90
msgid "Inactive branches are stored in a structure which uses 96 or 120 bytes (32 bit or 64 bit systems, respectively), plus the length of the branch name (typically under 200 bytes), per branch.  fast-import will easily handle as many as 10,000 inactive branches in under 2 MiB of memory."
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:1529
#, priority:90
msgid "Active branches have the same overhead as inactive branches, but also contain copies of every tree that has been recently modified on that branch.  If subtree `include` has not been modified since the branch became active, its contents will not be loaded into memory, but if subtree `src` has been modified by a commit since the branch became active, then its contents will be loaded in memory."
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:1533
#, priority:90
msgid "As active branches store metadata about the files contained on that branch, their in-memory storage size can grow to a considerable size (see below)."
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:1538
#, priority:90
msgid "fast-import automatically moves active branches to inactive status based on a simple least-recently-used algorithm.  The LRU chain is updated on each `commit` command.  The maximum number of active branches can be increased or decreased on the command line with --active-branches=."
msgstr ""

#. type: Title ~
#: en/git-fast-import.txt:1540
#, no-wrap, priority:90
msgid "per active tree"
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:1545
#, priority:90
msgid "Trees (aka directories) use just 12 bytes of memory on top of the memory required for their entries (see ``per active file'' below).  The cost of a tree is virtually 0, as its overhead amortizes out over the individual file entries."
msgstr ""

#. type: Title ~
#: en/git-fast-import.txt:1547
#, no-wrap, priority:90
msgid "per active file entry"
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:1553
#, priority:90
msgid "Files (and pointers to subtrees) within active trees require 52 or 64 bytes (32/64 bit platforms) per entry.  To conserve space, file and tree names are pooled in a common string table, allowing the filename ``Makefile'' to use just 16 bytes (after including the string header overhead) no matter how many times it occurs within the project."
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:1558
#, priority:90
msgid "The active branch LRU, when coupled with the filename string pool and lazy loading of subtrees, allows fast-import to efficiently import projects with 2,000+ branches and 45,114+ files in a very limited memory footprint (less than 2.7 MiB per active branch)."
msgstr ""

#. type: Title -
#: en/git-fast-import.txt:1560
#, no-wrap, priority:90
msgid "SIGNALS"
msgstr ""

#. type: Plain text
#: en/git-fast-import.txt:1566
#, priority:90
msgid "Sending *SIGUSR1* to the 'git fast-import' process ends the current packfile early, simulating a `checkpoint` command.  The impatient operator can use this facility to peek at the objects and refs from an import in progress, at the cost of some added running time and worse compression."
msgstr ""

#. type: Title =
#: en/git-fetch-pack.txt:2
#, ignore-same, no-wrap, priority:90
msgid "git-fetch-pack(1)"
msgstr "git-fetch-pack(1)"

#. type: Plain text
#: en/git-fetch-pack.txt:7
#, fuzzy, priority:90
msgid "git-fetch-pack - Receive missing objects from another repository"
msgstr "git-fetch-pack - Receive missing objects from another repository"

#. type: Plain text
#: en/git-fetch-pack.txt:16
#, ignore-ellipsis, no-wrap, priority:90
msgid ""
"'git fetch-pack' [--all] [--quiet|-q] [--keep|-k] [--thin] [--include-tag]\n"
"\t[--upload-pack=<git-upload-pack>]\n"
"\t[--depth=<n>] [--no-progress]\n"
"\t[-v] <repository> [<refs>...]\n"
msgstr ""

#. type: Plain text
#: en/git-fetch-pack.txt:21
#, priority:90
msgid "Usually you would want to use 'git fetch', which is a higher level wrapper of this command, instead."
msgstr ""

#. type: Plain text
#: en/git-fetch-pack.txt:27
#, priority:90
msgid "Invokes 'git-upload-pack' on a possibly remote repository and asks it to send objects missing from this repository, to update the named heads.  The list of commits available locally is found out by scanning the local refs/ hierarchy and sent to 'git-upload-pack' running on the other end."
msgstr ""

#. type: Plain text
#: en/git-fetch-pack.txt:31
#, priority:90
msgid "This command degenerates to download everything to complete the asked refs from the remote side when the local side does not have a common ancestor commit."
msgstr ""

#. type: Plain text
#: en/git-fetch-pack.txt:37
#, priority:90
msgid "Fetch all remote refs."
msgstr ""

#. type: Plain text
#: en/git-fetch-pack.txt:43 en/git-send-pack.txt:47
#, priority:90
msgid "Take the list of refs from stdin, one per line. If there are refs specified on the command line in addition to this option, then the refs from stdin are processed after those on the command line."
msgstr ""

#. type: Plain text
#: en/git-fetch-pack.txt:47 en/git-send-pack.txt:51
#, priority:90
msgid "If `--stateless-rpc` is specified together with this option then the list of refs must be in packet format (pkt-line). Each ref must be in a separate packet, and the list must end with a flush packet."
msgstr ""

#. type: Plain text
#: en/git-fetch-pack.txt:52
#, priority:90
msgid "Pass `-q` flag to 'git unpack-objects'; this makes the cloning process less verbose."
msgstr ""

#. type: Plain text
#: en/git-fetch-pack.txt:59
#, priority:90
msgid "Do not invoke 'git unpack-objects' on received data, but create a single packfile out of it instead, and store it in the object database. If provided twice then the pack is locked against repacking."
msgstr ""

#. type: Labeled list
#: en/git-fetch-pack.txt:60 en/git-pack-objects.txt:250 en/git-send-pack.txt:65
#, ignore-same, no-wrap, priority:100
msgid "--thin"
msgstr "--thin"

#. type: Plain text
#: en/git-fetch-pack.txt:63
#, priority:90
msgid "Fetch a \"thin\" pack, which records objects in deltified form based on objects not included in the pack to reduce network traffic."
msgstr ""

#. type: Labeled list
#: en/git-fetch-pack.txt:64 en/git-pack-objects.txt:84
#, ignore-same, no-wrap, priority:100
msgid "--include-tag"
msgstr "--include-tag"

#. type: Plain text
#: en/git-fetch-pack.txt:69
#, priority:90
msgid "If the remote side supports it, annotated tags objects will be downloaded on the same connection as the other objects if the object the tag references is downloaded.  The caller must otherwise determine the tags this option made available."
msgstr ""

#. type: Labeled list
#: en/git-fetch-pack.txt:70
#, fuzzy, no-wrap, priority:90
msgid "--upload-pack=<git-upload-pack>"
msgstr "--upload-pack=<git-upload-pack>"

#. type: Plain text
#: en/git-fetch-pack.txt:81
#, priority:90
msgid "Use this to specify the path to 'git-upload-pack' on the remote side, if is not found on your $PATH.  Installations of sshd ignores the user's environment setup scripts for login shells (e.g. .bash_profile) and your privately installed git may not be found on the system default $PATH.  Another workaround suggested is to set up your $PATH in \".bashrc\", but this flag is for people who do not want to pay the overhead for non-interactive shells by having a lean .bashrc file (they set most of the things up in .bash_profile)."
msgstr ""

#. type: Labeled list
#: en/git-fetch-pack.txt:82
#, fuzzy, no-wrap, priority:90
msgid "--exec=<git-upload-pack>"
msgstr "--exec=<git-upload-pack>"

#. type: Plain text
#: en/git-fetch-pack.txt:84
#, priority:90
msgid "Same as --upload-pack=<git-upload-pack>."
msgstr ""

#. type: Plain text
#: en/git-fetch-pack.txt:89
#, priority:90
msgid "Limit fetching to ancestor-chains not longer than n.  'git-upload-pack' treats the special depth 2147483647 as infinite even if there is an ancestor-chain that long."
msgstr ""

#. type: Labeled list
#: en/git-fetch-pack.txt:99
#, ignore-same, no-wrap, priority:90
msgid "--deepen-relative"
msgstr "--deepen-relative"

#. type: Plain text
#: en/git-fetch-pack.txt:103
#, priority:90
msgid "Argument --depth specifies the number of commits from the current shallow boundary instead of from the tip of each remote branch history."
msgstr ""

#. type: Plain text
#: en/git-fetch-pack.txt:107
#, priority:90
msgid "Skips negotiating commits with the server in order to fetch all matching objects. Use to reapply a new partial clone blob/tree filter."
msgstr ""

#. type: Plain text
#: en/git-fetch-pack.txt:110
#, priority:90
msgid "Do not show the progress."
msgstr ""

#. type: Labeled list
#: en/git-fetch-pack.txt:111 en/git-index-pack.txt:91
#, ignore-same, no-wrap, priority:100
msgid "--check-self-contained-and-connected"
msgstr "--check-self-contained-and-connected"

#. type: Plain text
#: en/git-fetch-pack.txt:114
#, priority:90
msgid "Output \"connectivity-ok\" if the received pack is self-contained and connected."
msgstr ""

#. type: Plain text
#: en/git-fetch-pack.txt:117 en/git-push.txt:395 en/git-send-pack.txt:64
#, priority:220
msgid "Run verbosely."
msgstr "详细运行。"

#. type: Plain text
#: en/git-fetch-pack.txt:120
#, priority:90
msgid "The URL to the remote repository."
msgstr ""

#. type: Labeled list
#: en/git-fetch-pack.txt:121
#, fuzzy, ignore-ellipsis, no-wrap, priority:90
msgid "<refs>..."
msgstr "<refs>..."

#. type: Plain text
#: en/git-fetch-pack.txt:125
#, priority:90
msgid "The remote heads to update from. This is relative to $GIT_DIR (e.g. \"HEAD\", \"refs/heads/master\").  When unspecified, update from all heads the remote side has."
msgstr ""

#. type: Plain text
#: en/git-fetch-pack.txt:129
#, priority:90
msgid "If the remote has enabled the options `uploadpack.allowTipSHA1InWant`, `uploadpack.allowReachableSHA1InWant`, or `uploadpack.allowAnySHA1InWant`, they may alternatively be 40-hex sha1s present on the remote."
msgstr ""

#. type: Title =
#: en/git-fetch.txt:2
#, ignore-same, no-wrap, priority:220
msgid "git-fetch(1)"
msgstr "git-fetch(1)"

#. type: Plain text
#: en/git-fetch.txt:7
#, fuzzy, priority:220
msgid "git-fetch - Download objects and refs from another repository"
msgstr "git-fetch - Download objects and refs from another repository"

#. type: Plain text
#: en/git-fetch.txt:16
#, ignore-ellipsis, no-wrap, priority:220
msgid ""
"'git fetch' [<options>] [<repository> [<refspec>...]]\n"
"'git fetch' [<options>] <group>\n"
"'git fetch' --multiple [<options>] [(<repository> | <group>)...]\n"
"'git fetch' --all [<options>]\n"
msgstr ""
"'git fetch' [<选项>] [<仓库> [<引用规范>...]]\n"
"'git fetch' [<选项>] <组>\n"
"'git fetch' --multiple [<选项>] [(<仓库> | <组>)...]\n"
"'git fetch' --all [<选项>]\n"

#. type: Plain text
#: en/git-fetch.txt:24
#, priority:220
msgid "Fetch branches and/or tags (collectively, \"refs\") from one or more other repositories, along with the objects necessary to complete their histories.  Remote-tracking branches are updated (see the description of <refspec> below for ways to control this behavior)."
msgstr "从一个或多个其它仓库获取分支和/或标记（统称为 \"refs\"），以及完成其历史所需的对象。  远程跟踪的分支会被更新（关于控制这种行为的方法，请参见下面 <引用规范> 的描述）。"

#. type: Plain text
#: en/git-fetch.txt:32
#, priority:220
msgid "By default, any tag that points into the histories being fetched is also fetched; the effect is to fetch tags that point at branches that you are interested in.  This default behavior can be changed by using the --tags or --no-tags options or by configuring remote.<name>.tagOpt.  By using a refspec that fetches tags explicitly, you can fetch tags that do not point into branches you are interested in as well."
msgstr "默认情况下，任何指向被获取的历史的标签也会被获取；其效果是获取指向你感兴趣的分支的标签。  这个默认行为可以通过使用 --tags 或 --no-tags 选项或者配置 remote.<远程仓库名称>.tagOpt 来改变。  通过使用明确获取标签的引用规范，你也可以获取那些没有指向你感兴趣的分支的标签。"

#. type: Plain text
#: en/git-fetch.txt:37
#, priority:220
msgid "'git fetch' can fetch from either a single named repository or URL, or from several repositories at once if <group> is given and there is a remotes.<group> entry in the configuration file.  (See linkgit:git-config[1])."
msgstr "'git fetch' 可以从一个命名的仓库或 URL 中获取，或者如果给定了 <组> 并且在配置文件中有 remotes.<组> 项，则可以同时从几个仓库获取。  (参见 linkgit:git-config[1]）。"

#. type: Plain text
#: en/git-fetch.txt:40
#, priority:220
msgid "When no remote is specified, by default the `origin` remote will be used, unless there's an upstream branch configured for the current branch."
msgstr "当没有指定远程仓库时，默认情况下将使用 `origin` 远程仓库，除非有一个上游分支配置在当前分支上。"

#. type: Plain text
#: en/git-fetch.txt:44
#, priority:220
msgid "The names of refs that are fetched, together with the object names they point at, are written to `.git/FETCH_HEAD`.  This information may be used by scripts or other git commands, such as linkgit:git-pull[1]."
msgstr "被获取的引用名称，以及它们所指向的对象名称，被写到 `.git/FETCH_HEAD`。  这些信息可以被脚本或其他 git 命令使用，比如linkgit:git-pull[1]。"

#. type: Plain text
#: en/git-fetch.txt:54
#, priority:220
msgid "Read refspecs, one per line, from stdin in addition to those provided as arguments. The \"tag <name>\" format is not supported."
msgstr "从stdin中读取引用规范，每行一个，除了作为参数提供的那些之外。不支持 \"标签 <名称>\" 格式。"

#. type: Title -
#: en/git-fetch.txt:59
#, no-wrap, priority:220
msgid "CONFIGURED REMOTE-TRACKING BRANCHES[[CRTB]]"
msgstr "配置的远程跟踪分支 [[CRTB]]"

#. type: Plain text
#: en/git-fetch.txt:65
#, priority:220
msgid "You often interact with the same remote repository by regularly and repeatedly fetching from it.  In order to keep track of the progress of such a remote repository, `git fetch` allows you to configure `remote.<repository>.fetch` configuration variables."
msgstr "你通过经常定期和重复地从同一个远程仓库取东西来与之互动。  为了跟踪这种远程仓库的进度，`git fetch` 允许你配置 `remote.<仓库>.fetch` 配置变量。"

#. type: Plain text
#: en/git-fetch.txt:67
#, priority:220
msgid "Typically such a variable may look like this:"
msgstr "一般来说，这种变量可能看起来像这样："

#. type: delimited block -
#: en/git-fetch.txt:71
#, fuzzy, no-wrap, priority:220
msgid ""
"[remote \"origin\"]\n"
"\tfetch = +refs/heads/*:refs/remotes/origin/*\n"
msgstr ""
"[remote \"origin\"]\n"
"\tfetch = +refs/heads/*:refs/remotes/origin/*\n"

#. type: Plain text
#: en/git-fetch.txt:74
#, priority:220
msgid "This configuration is used in two ways:"
msgstr "这种配置有两种使用方式："

#. type: Plain text
#: en/git-fetch.txt:84
#, priority:220
msgid "When `git fetch` is run without specifying what branches and/or tags to fetch on the command line, e.g. `git fetch origin` or `git fetch`, `remote.<repository>.fetch` values are used as the refspecs--they specify which refs to fetch and which local refs to update.  The example above will fetch all branches that exist in the `origin` (i.e. any ref that matches the left-hand side of the value, `refs/heads/*`) and update the corresponding remote-tracking branches in the `refs/remotes/origin/*` hierarchy."
msgstr "当 `git fetch` 运行时，没有在命令行中指定要取哪些分支和/或标记，例如 `git fetch origin` 或 `git fetch`，`remote.<仓库>.fetch` 值被用作引用规范——它们指定要取哪些引用和要更新哪些本地引用。  上面的例子将获取所有存在于 `origin` 中的分支（即任何与数值左边的`refs/heads/*`相匹配的引用），并更新 `refs/remotes/origin/*` 层次结构中相应的远程跟踪的分支。"

#. type: Plain text
#: en/git-fetch.txt:101
#, priority:220
msgid "When `git fetch` is run with explicit branches and/or tags to fetch on the command line, e.g. `git fetch origin master`, the <refspec>s given on the command line determine what are to be fetched (e.g. `master` in the example, which is a short-hand for `master:`, which in turn means \"fetch the 'master' branch but I do not explicitly say what remote-tracking branch to update with it from the command line\"), and the example command will fetch _only_ the 'master' branch.  The `remote.<repository>.fetch` values determine which remote-tracking branch, if any, is updated.  When used in this way, the `remote.<repository>.fetch` values do not have any effect in deciding _what_ gets fetched (i.e. the values are not used as refspecs when the command-line lists refspecs); they are only used to decide _where_ the refs that are fetched are stored by acting as a mapping."
msgstr "当 `git fetch` 运行时，命令行上有明确的要取的分支和/或标记，例如 `git fetch origin master`，命令行上给出的所有 <引用规范> 决定了要取的是什么（例如例子中的 `master` 是  `master:` 的简称，意思是 \"获取 'master' 分支，但我没有明确说要在命令行中更新哪个远程跟踪分支\"），而这个例子的命令将「只」获取 'master' 分支。  `remote.<仓库>.fetch`值决定了哪个远程跟踪分支（如果有的话）被更新。  当以这种方式使用时，`remote.<仓库>.fetch` 值对决定获取什么没有任何影响（即当命令行列出引用规范时，这些值不会被用作引用规范）；它们只是通过作为一个映射来决定获取的引用被存储在哪里。"

#. type: Plain text
#: en/git-fetch.txt:105
#, priority:220
msgid "The latter use of the `remote.<repository>.fetch` values can be overridden by giving the `--refmap=<refspec>` parameter(s) on the command line."
msgstr "后者对 `remote.<仓库>.fetch` 值的使用可以通过在命令行中给出 `--refmap=<引用规范>` 参数去覆盖。"

#. type: Title -
#: en/git-fetch.txt:107
#, no-wrap, priority:220
msgid "PRUNING"
msgstr "剪枝"

#. type: Plain text
#: en/git-fetch.txt:112
#, priority:220
msgid "Git has a default disposition of keeping data unless it's explicitly thrown away; this extends to holding onto local references to branches on remotes that have themselves deleted those branches."
msgstr "Git默认保留数据，除非它被明确地扔掉；这延伸到保留对远程分支的本地引用，而这些分支本身已经被删除。"

#. type: Plain text
#: en/git-fetch.txt:118
#, priority:220
msgid "If left to accumulate, these stale references might make performance worse on big and busy repos that have a lot of branch churn, and e.g. make the output of commands like `git branch -a --contains <commit>` needlessly verbose, as well as impacting anything else that'll work with the complete set of known references."
msgstr "如果任其积累，这些陈旧的引用可能会使大型繁忙仓库的性能变差，例如，使 `git branch -a --contains <提交>` 等命令的输出不必要地冗长，以及影响其他任何与完整的已知引用有关的工作。"

#. type: Plain text
#: en/git-fetch.txt:121
#, priority:220
msgid "These remote-tracking references can be deleted as a one-off with either of:"
msgstr "这些远程跟踪引用可以通过以下两种方式一次性删除："

#. type: delimited block -
#: en/git-fetch.txt:125
#, no-wrap, priority:220
msgid ""
"# While fetching\n"
"$ git fetch --prune <name>\n"
msgstr ""
"# 在获取的时候\n"
"$ git fetch --prune <名称>\n"

#. type: delimited block -
#: en/git-fetch.txt:128
#, fuzzy, no-wrap, priority:220
msgid ""
"# Only prune, don't fetch\n"
"$ git remote prune <name>\n"
msgstr ""
"# Only prune, don't fetch\n"
"$ git remote prune <name>\n"

#. type: Plain text
#: en/git-fetch.txt:134
#, priority:220
msgid "To prune references as part of your normal workflow without needing to remember to run that, set `fetch.prune` globally, or `remote.<name>.prune` per-remote in the config. See linkgit:git-config[1]."
msgstr "要把修剪引用作为正常工作流程的一部分，而不需要记住运行该程序，可以在全局设置 `fetch.prune`，或者在配置中设置 `remote.<名称>.prune`，为每个远程仓库进行设置。见linkgit:git-config[1]。"

#. type: Plain text
#: en/git-fetch.txt:139
#, priority:220
msgid "Here's where things get tricky and more specific. The pruning feature doesn't actually care about branches, instead it'll prune local <--> remote-references as a function of the refspec of the remote (see `<refspec>` and <<CRTB,CONFIGURED REMOTE-TRACKING BRANCHES>> above)."
msgstr "这里是事情变得棘手和更具体的地方。修剪功能实际上并不关心分支，相反，它将修剪本地<-->远程引用，作为远程的引用规范的函数（见上面的`<引用规范>`和上面的<<CRTB，配置远程跟踪分支>>）。"

#. type: Plain text
#: en/git-fetch.txt:145
#, priority:220
msgid "Therefore if the refspec for the remote includes e.g. `refs/tags/*:refs/tags/*`, or you manually run e.g. `git fetch --prune <name> \"refs/tags/*:refs/tags/*\"` it won't be stale remote tracking branches that are deleted, but any local tag that doesn't exist on the remote."
msgstr "因此，如果远程的引用规范包括例如 `refs/tags/*:refs/tags/*`这样的规范，或者你手动运行例如 `git fetch --prune <名称> \"refs/tags/*:refs/tags/*\"`，那么被删除的就不是过时的远程跟踪分支，而是远程上不存在的任何本地标签。"

#. type: Plain text
#: en/git-fetch.txt:150
#, priority:220
msgid "This might not be what you expect, i.e. you want to prune remote `<name>`, but also explicitly fetch tags from it, so when you fetch from it you delete all your local tags, most of which may not have come from the `<name>` remote in the first place."
msgstr "这可能不是你所期望的，即你想修剪远程的 `<名称>`，但也明确地从它那里获取标签，所以当你从它那里获取时，你会删除所有的本地标签，其中大部分可能首先不是来自远程的 `<名称>`。"

#. type: Plain text
#: en/git-fetch.txt:154
#, priority:220
msgid "So be careful when using this with a refspec like `refs/tags/*:refs/tags/*`, or any other refspec which might map references from multiple remotes to the same local namespace."
msgstr "因此，当与 `refs/tags/*:refs/tags/*` 这样的引用规范一起使用时要小心，或者任何其他可能将多个远程的引用映射到同一本地命名空间的引用规范。"

#. type: Plain text
#: en/git-fetch.txt:161
#, priority:220
msgid "Since keeping up-to-date with both branches and tags on the remote is a common use-case the `--prune-tags` option can be supplied along with `--prune` to prune local tags that don't exist on the remote, and force-update those tags that differ. Tag pruning can also be enabled with `fetch.pruneTags` or `remote.<name>.pruneTags` in the config. See linkgit:git-config[1]."
msgstr "由于在远程保持最新的分支和标签是一个常见的使用情况，`--prune-tags` 选项可以和 `--prune` 一起使用，以修剪在远程不存在的本地标签，并强制更新那些不同的标签。标签修剪也可以通过配置中的 `fetch.pruneTags` 或 `remote.<名称>.pruneTags` 启用。见linkgit:git-config[1]。"

#. type: Plain text
#: en/git-fetch.txt:165
#, priority:220
msgid "The `--prune-tags` option is equivalent to having `refs/tags/*:refs/tags/*` declared in the refspecs of the remote. This can lead to some seemingly strange interactions:"
msgstr "`--prune-tags` 选项相当于在远程的引用规范中声明 `refs/tags/*:refs/tags/*` 。这可能会导致一些看起来很奇怪的结果："

#. type: delimited block -
#: en/git-fetch.txt:170
#, no-wrap, priority:220
msgid ""
"# These both fetch tags\n"
"$ git fetch --no-tags origin 'refs/tags/*:refs/tags/*'\n"
"$ git fetch --no-tags --prune-tags origin\n"
msgstr ""
"# 这两个命令都可以用来获取标签\n"
"$ git fetch --no-tags origin 'refs/tags/*:refs/tags/*'\n"
"$ git fetch --no-tags --prune-tags origin\n"

#. type: Plain text
#: en/git-fetch.txt:176
#, priority:220
msgid "The reason it doesn't error out when provided without `--prune` or its config versions is for flexibility of the configured versions, and to maintain a 1=1 mapping between what the command line flags do, and what the configuration versions do."
msgstr "在没有 `--prune` 或其配置的情况下，它不会出错的原因是为了配置的灵活性，以及在命令行标志和配置之间保持 1=1 的映射。"

#. type: Plain text
#: en/git-fetch.txt:181
#, priority:220
msgid "It's reasonable to e.g. configure `fetch.pruneTags=true` in `~/.gitconfig` to have tags pruned whenever `git fetch --prune` is run, without making every invocation of `git fetch` without `--prune` an error."
msgstr "例如，在 `~/.gitconfig` 中配置 `fetch.pruneTags=true`，以便在运行 `git fetch --prune` 时修剪标签，这是很合理的，不会使每次调用 `git fetch` 而没有 `--prune` 时都出现错误。"

#. type: Plain text
#: en/git-fetch.txt:185
#, priority:220
msgid "Pruning tags with `--prune-tags` also works when fetching a URL instead of a named remote. These will all prune tags not found on origin:"
msgstr "使用 `--prune-tags` 修剪标签，在获取一个URL而不是一个命名的远程时也能发挥作用。这些都会修剪在原点没有发现的标签："

#. type: delimited block -
#: en/git-fetch.txt:191
#, fuzzy, no-wrap, priority:220
msgid ""
"$ git fetch origin --prune --prune-tags\n"
"$ git fetch origin --prune 'refs/tags/*:refs/tags/*'\n"
"$ git fetch <url of origin> --prune --prune-tags\n"
"$ git fetch <url of origin> --prune 'refs/tags/*:refs/tags/*'\n"
msgstr ""
"$ git fetch origin --prune --prune-tags\n"
"$ git fetch origin --prune 'refs/tags/*:refs/tags/*'\n"
"$ git fetch <url of origin> --prune --prune-tags\n"
"$ git fetch <url of origin> --prune 'refs/tags/*:refs/tags/*'\n"

#. type: Plain text
#: en/git-fetch.txt:199
#, priority:220
msgid "The output of \"git fetch\" depends on the transport method used; this section describes the output when fetching over the Git protocol (either locally or via ssh) and Smart HTTP protocol."
msgstr "\"git fetch\" 的输出取决于所使用的传输方式；本节描述了通过 Git 协议（本地或通过 ssh）和智能 HTTP 协议获取时的输出。"

#. type: Plain text
#: en/git-fetch.txt:202
#, priority:220
msgid "The status of the fetch is output in tabular form, with each line representing the status of a single ref. Each line is of the form:"
msgstr "获取的状态以表格的形式输出，每一行代表一个引用的状态。每一行的形式是："

#. type: delimited block -
#: en/git-fetch.txt:205
#, fuzzy, no-wrap, priority:220
msgid " <flag> <summary> <from> -> <to> [<reason>]\n"
msgstr " <flag> <summary> <from> -> <to> [<reason>]\n"

#. type: Plain text
#: en/git-fetch.txt:211
#, priority:220
msgid "When using `--porcelain`, the output format is intended to be machine-parseable. In contrast to the human-readable output formats it thus prints to standard output instead of standard error. Each line is of the form:"
msgstr "当使用 `--porcelain` 时，输出格式的目的是让机器可以解析。与人类可读的输出格式不同，它将打印到标准输出而不是标准错误。每一行都是这样的形式："

#. type: delimited block -
#: en/git-fetch.txt:214
#, no-wrap, priority:220
msgid "<flag> <old-object-id> <new-object-id> <local-reference>\n"
msgstr "<标志> <旧对象ID> <新对象ID> <本地引用>\n"

#. type: Plain text
#: en/git-fetch.txt:218
#, priority:220
msgid "The status of up-to-date refs is shown only if the --verbose option is used."
msgstr "只有在使用 --verbose 选项时，才会显示最新的引用状态。"

#. type: Plain text
#: en/git-fetch.txt:223
#, priority:220
msgid "In compact output mode, specified with configuration variable fetch.output, if either entire `<from>` or `<to>` is found in the other string, it will be substituted with `*` in the other string. For example, `master -> origin/master` becomes `master -> origin/*`."
msgstr "在紧凑输出模式下，通过配置变量 fetch.output 指定，如果在另一个字符串中发现整个 `<起点>` 或 `<终点>`，它将被替换成另一个字符串中的 `*`。例如，`master -> origin/master` 变成 `master -> origin/*`。"

#. type: Labeled list
#: en/git-fetch.txt:224 en/git-push.txt:460
#, fuzzy, no-wrap, priority:220
msgid "flag"
msgstr "标记"

#. type: Plain text
#: en/git-fetch.txt:226 en/git-push.txt:462
#, priority:220
msgid "A single character indicating the status of the ref:"
msgstr "表示引用状态的单个字符："

#. type: Labeled list
#: en/git-fetch.txt:226 en/git-push.txt:462
#, no-wrap, priority:220
msgid "(space)"
msgstr "（空格）"

#. type: Plain text
#: en/git-fetch.txt:227
#, priority:220
msgid "for a successfully fetched fast-forward;"
msgstr "表示成功的快速合并；"

#. type: Labeled list
#: en/git-fetch.txt:227 en/git-push.txt:463
#, fuzzy, no-wrap, priority:220
msgid "`+`"
msgstr "`+`"

#. type: Plain text
#: en/git-fetch.txt:228 en/git-push.txt:464
#, priority:220
msgid "for a successful forced update;"
msgstr "表示一个成功的强制更新；"

#. type: Labeled list
#: en/git-fetch.txt:228 en/git-push.txt:464
#, ignore-same, no-wrap, priority:220
msgid "`-`"
msgstr "`-`"

#. type: Plain text
#: en/git-fetch.txt:229
#, priority:220
msgid "for a successfully pruned ref;"
msgstr "表示成功修剪引用；"

#. type: Labeled list
#: en/git-fetch.txt:229
#, ignore-same, no-wrap, priority:220
msgid "`t`"
msgstr "`t`"

#. type: Plain text
#: en/git-fetch.txt:230
#, priority:220
msgid "for a successful tag update;"
msgstr "表示成功更新标签；"

#. type: Labeled list
#: en/git-fetch.txt:230 en/git-push.txt:465
#, fuzzy, no-wrap, priority:220
msgid "`*`"
msgstr "`*`"

#. type: Plain text
#: en/git-fetch.txt:231
#, priority:220
msgid "for a successfully fetched new ref;"
msgstr "表示成功获取新引用；"

#. type: Labeled list
#: en/git-fetch.txt:231 en/git-push.txt:466
#, fuzzy, no-wrap, priority:220
msgid "`!`"
msgstr "`!`"

#. type: Plain text
#: en/git-fetch.txt:232
#, priority:220
msgid "for a ref that was rejected or failed to update; and"
msgstr "表示被拒绝或更新失败的引用；以及"

#. type: Labeled list
#: en/git-fetch.txt:232 en/git-push.txt:467
#, fuzzy, no-wrap, priority:220
msgid "`=`"
msgstr "`=`"

#. type: Plain text
#: en/git-fetch.txt:233
#, priority:220
msgid "for a ref that was up to date and did not need fetching."
msgstr "表示一个最新的、不需要获取的引用。"

#. type: Labeled list
#: en/git-fetch.txt:234 en/git-push.txt:469
#, fuzzy, no-wrap, priority:220
msgid "summary"
msgstr "总结"

#. type: Plain text
#: en/git-fetch.txt:239
#, ignore-ellipsis, priority:220
msgid "For a successfully fetched ref, the summary shows the old and new values of the ref in a form suitable for using as an argument to `git log` (this is `<old>..<new>` in most cases, and `<old>...<new>` for forced non-fast-forward updates)."
msgstr "对于一个成功获取的引用，摘要以适合作为 `git log` 参数的形式显示该引用的新旧值（在大多数情况下是 `<旧>..<新>`，对于强制非快速合并是 `<旧>...<新>`）。"

#. type: Labeled list
#: en/git-fetch.txt:240 en/git-push.txt:497
#, fuzzy, no-wrap, priority:220
msgid "from"
msgstr "从"

#. type: Plain text
#: en/git-fetch.txt:244
#, priority:220
msgid "The name of the remote ref being fetched from, minus its `refs/<type>/` prefix. In the case of deletion, the name of the remote ref is \"(none)\"."
msgstr "被获取的远程引用的名称，减去其`refs/<类型>/`前缀。在删除的情况下，远程引用的名称是 \"(none)\"。"

#. type: Labeled list
#: en/git-fetch.txt:245 en/git-push.txt:502
#, fuzzy, no-wrap, priority:220
msgid "to"
msgstr "到"

#. type: Plain text
#: en/git-fetch.txt:248
#, priority:220
msgid "The name of the local ref being updated, minus its `refs/<type>/` prefix."
msgstr "被更新的本地引用的名称，去掉其 `refs/<类型>/` 前缀。"

#. type: Labeled list
#: en/git-fetch.txt:249 en/git-push.txt:506
#, fuzzy, no-wrap, priority:220
msgid "reason"
msgstr "原因"

#. type: Plain text
#: en/git-fetch.txt:253
#, priority:220
msgid "A human-readable explanation. In the case of successfully fetched refs, no explanation is needed. For a failed ref, the reason for failure is described."
msgstr "一个人类可读的解释。如果是成功获取的引用，不需要解释。对于失败的引用，将描述失败的原因。"

#. type: Plain text
#: en/git-fetch.txt:258
#, priority:220
msgid "Update the remote-tracking branches:"
msgstr "更新远程追踪的分支："

#. type: delimited block -
#: en/git-fetch.txt:261
#, fuzzy, no-wrap, priority:220
msgid "$ git fetch origin\n"
msgstr "$ git fetch origin\n"

#. type: Plain text
#: en/git-fetch.txt:267
#, priority:220
msgid "The above command copies all branches from the remote `refs/heads/` namespace and stores them to the local `refs/remotes/origin/` namespace, unless the `remote.<repository>.fetch` option is used to specify a non-default refspec."
msgstr "上述命令从远程的 `refs/heads/` 命名空间复制所有分支，并存储到本地的 `refs/remotes/origin/` 命名空间，除非使用 `remote.<仓库>.fetch` 选项来指定一个非默认的引用规范。"

#. type: Plain text
#: en/git-fetch.txt:269
#, priority:220
msgid "Using refspecs explicitly:"
msgstr "明确使用引用规范："

#. type: delimited block -
#: en/git-fetch.txt:272
#, fuzzy, no-wrap, priority:220
msgid "$ git fetch origin +seen:seen maint:tmp\n"
msgstr "$ git fetch origin +seen:seen maint:tmp\n"

#. type: Plain text
#: en/git-fetch.txt:277
#, priority:220
msgid "This updates (or creates, as necessary) branches `seen` and `tmp` in the local repository by fetching from the branches (respectively)  `seen` and `maint` from the remote repository."
msgstr "这通过从远程存储库的分支（分别）获取 `seen` 和 `maint` 来更新（或根据需要创建）本地存储库中的分支 `seen` 和 `tmp`。"

#. type: Plain text
#: en/git-fetch.txt:280
#, priority:220
msgid "The `seen` branch will be updated even if it does not fast-forward, because it is prefixed with a plus sign; `tmp` will not be."
msgstr "即使不快进，`seen` 分支也会被更新，因为它的前缀是加号；`tmp` 则不会。"

#. type: Plain text
#: en/git-fetch.txt:283
#, priority:220
msgid "Peek at a remote's branch, without configuring the remote in your local repository:"
msgstr "窥视一个远程的分支，而不需要在你的本地版本库中配置远程："

#. type: delimited block -
#: en/git-fetch.txt:287
#, no-wrap, priority:220
msgid ""
"$ git fetch git://git.kernel.org/pub/scm/git/git.git maint\n"
"$ git log FETCH_HEAD\n"
msgstr ""
"$ git fetch git://git.kernel.org/pub/scm/git/git.git maint\n"
"$ git log FETCH_HEAD\n"

#. type: Plain text
#: en/git-fetch.txt:294
#, priority:220
msgid "The first command fetches the `maint` branch from the repository at `git://git.kernel.org/pub/scm/git/git.git` and the second command uses `FETCH_HEAD` to examine the branch with linkgit:git-log[1].  The fetched objects will eventually be removed by git's built-in housekeeping (see linkgit:git-gc[1])."
msgstr "第一条命令从 `git://git.kernel.org/pub/scm/git.git` 的存储库中获取 `maint` 分支，第二条命令使用 `FETCH_HEAD` 用 linkgit:git-log[1] 来检查该分支。  取出的对象最终会被 git 内置的内务管理删除（见 linkgit:git-gc[1]）。"

#. type: Plain text
#: en/git-fetch.txt:310
#, priority:220
msgid "Using --recurse-submodules can only fetch new commits in submodules that are present locally e.g. in `$GIT_DIR/modules/`. If the upstream adds a new submodule, that submodule cannot be fetched until it is cloned e.g. by `git submodule update`. This is expected to be fixed in a future Git version."
msgstr "使用 --recurse-submodules 只能获取本地存在的子模块中的新提交，例如在 `$GIT_DIR/modules/`。如果上游添加了一个新的子模块，该子模块不能被获取，直到它被克隆，例如，通过`git submodule update`。这个问题有望在未来的 Git 版本中被修复。"

#. type: Title =
#: en/git-filter-branch.txt:2
#, ignore-same, no-wrap, priority:90
msgid "git-filter-branch(1)"
msgstr "git-filter-branch(1)"

#. type: Plain text
#: en/git-filter-branch.txt:7
#, priority:90
msgid "git-filter-branch - Rewrite branches"
msgstr ""

#. type: Plain text
#: en/git-filter-branch.txt:18
#, ignore-ellipsis, no-wrap, priority:90
msgid ""
"'git filter-branch' [--setup <command>] [--subdirectory-filter <directory>]\n"
"\t[--env-filter <command>] [--tree-filter <command>]\n"
"\t[--index-filter <command>] [--parent-filter <command>]\n"
"\t[--msg-filter <command>] [--commit-filter <command>]\n"
"\t[--tag-name-filter <command>] [--prune-empty]\n"
"\t[--original <namespace>] [-d <directory>] [-f | --force]\n"
"\t[--state-branch <branch>] [--] [<rev-list options>...]\n"
msgstr ""

#. type: Title -
#: en/git-filter-branch.txt:20 en/git-pack-redundant.txt:15
#, fuzzy, no-wrap, priority:100
msgid "WARNING"
msgstr "警告"

#. type: Plain text
#: en/git-filter-branch.txt:31
#, priority:90
msgid "'git filter-branch' has a plethora of pitfalls that can produce non-obvious manglings of the intended history rewrite (and can leave you with little time to investigate such problems since it has such abysmal performance).  These safety and performance issues cannot be backward compatibly fixed and as such, its use is not recommended.  Please use an alternative history filtering tool such as https://github.com/newren/git-filter-repo/[git filter-repo].  If you still need to use 'git filter-branch', please carefully read <<SAFETY>> (and <<PERFORMANCE>>) to learn about the land mines of filter-branch, and then vigilantly avoid as many of the hazards listed there as reasonably possible."
msgstr ""

#. type: Plain text
#: en/git-filter-branch.txt:40
#, priority:90
msgid "Lets you rewrite Git revision history by rewriting the branches mentioned in the <rev-list options>, applying custom filters on each revision.  Those filters can modify each tree (e.g. removing a file or running a perl rewrite on all files) or information about each commit.  Otherwise, all information (including original commit times or merge information) will be preserved."
msgstr ""

#. type: Plain text
#: en/git-filter-branch.txt:47
#, priority:90
msgid "The command will only rewrite the _positive_ refs mentioned in the command line (e.g. if you pass 'a..b', only 'b' will be rewritten).  If you specify no filters, the commits will be recommitted without any changes, which would normally have no effect.  Nevertheless, this may be useful in the future for compensating for some Git bugs or such, therefore such a usage is permitted."
msgstr ""

#. type: Plain text
#: en/git-filter-branch.txt:52
#, no-wrap, priority:90
msgid ""
"*NOTE*: This command honors `.git/info/grafts` file and refs in\n"
"the `refs/replace/` namespace.\n"
"If you have any grafts or replacement refs defined, running this command\n"
"will make them permanent.\n"
msgstr ""

#. type: Plain text
#: en/git-filter-branch.txt:61
#, no-wrap, priority:90
msgid ""
"*WARNING*! The rewritten history will have different object names for all\n"
"the objects and will not converge with the original branch.  You will not\n"
"be able to easily push and distribute the rewritten branch on top of the\n"
"original branch.  Please do not use this command if you do not know the\n"
"full implications, and avoid using it anyway, if a simple single commit\n"
"would suffice to fix your problem.  (See the \"RECOVERING FROM UPSTREAM\n"
"REBASE\" section in linkgit:git-rebase[1] for further information about\n"
"rewriting published history.)\n"
msgstr ""

#. type: Plain text
#: en/git-filter-branch.txt:65
#, priority:90
msgid "Always verify that the rewritten version is correct: The original refs, if different from the rewritten ones, will be stored in the namespace 'refs/original/'."
msgstr ""

#. type: Plain text
#: en/git-filter-branch.txt:69
#, priority:90
msgid "Note that since this operation is very I/O expensive, it might be a good idea to redirect the temporary directory off-disk with the `-d` option, e.g. on tmpfs.  Reportedly the speedup is very noticeable."
msgstr ""

#. type: Title ~
#: en/git-filter-branch.txt:72
#, fuzzy, no-wrap, priority:90
msgid "Filters"
msgstr "筛选"

#. type: Plain text
#: en/git-filter-branch.txt:84
#, priority:90
msgid "The filters are applied in the order as listed below.  The <command> argument is always evaluated in the shell context using the 'eval' command (with the notable exception of the commit filter, for technical reasons).  Prior to that, the `$GIT_COMMIT` environment variable will be set to contain the id of the commit being rewritten.  Also, GIT_AUTHOR_NAME, GIT_AUTHOR_EMAIL, GIT_AUTHOR_DATE, GIT_COMMITTER_NAME, GIT_COMMITTER_EMAIL, and GIT_COMMITTER_DATE are taken from the current commit and exported to the environment, in order to affect the author and committer identities of the replacement commit created by linkgit:git-commit-tree[1] after the filters have run."
msgstr ""

#. type: Plain text
#: en/git-filter-branch.txt:87
#, priority:90
msgid "If any evaluation of <command> returns a non-zero exit status, the whole operation will be aborted."
msgstr ""

#. type: Plain text
#: en/git-filter-branch.txt:93
#, priority:90
msgid "A 'map' function is available that takes an \"original sha1 id\" argument and outputs a \"rewritten sha1 id\" if the commit has been already rewritten, and \"original sha1 id\" otherwise; the 'map' function can return several ids on separate lines if your commit filter emitted multiple commits."
msgstr ""

#. type: Labeled list
#: en/git-filter-branch.txt:98
#, no-wrap, priority:90
msgid "--setup <command>"
msgstr ""

#. type: Plain text
#: en/git-filter-branch.txt:104
#, priority:90
msgid "This is not a real filter executed for each commit but a one time setup just before the loop. Therefore no commit-specific variables are defined yet.  Functions or variables defined here can be used or modified in the following filter steps except the commit filter, for technical reasons."
msgstr ""

#. type: Labeled list
#: en/git-filter-branch.txt:105
#, fuzzy, no-wrap, priority:90
msgid "--subdirectory-filter <directory>"
msgstr "--subdirectory-filter <directory>"

#. type: Plain text
#: en/git-filter-branch.txt:109
#, priority:90
msgid "Only look at the history which touches the given subdirectory.  The result will contain that directory (and only that) as its project root. Implies <<Remap_to_ancestor>>."
msgstr ""

#. type: Labeled list
#: en/git-filter-branch.txt:110
#, no-wrap, priority:90
msgid "--env-filter <command>"
msgstr ""

#. type: Plain text
#: en/git-filter-branch.txt:115
#, priority:90
msgid "This filter may be used if you only need to modify the environment in which the commit will be performed.  Specifically, you might want to rewrite the author/committer name/email/time environment variables (see linkgit:git-commit-tree[1] for details)."
msgstr ""

#. type: Labeled list
#: en/git-filter-branch.txt:116
#, fuzzy, no-wrap, priority:90
msgid "--tree-filter <command>"
msgstr "--tree-filter <command>"

#. type: Plain text
#: en/git-filter-branch.txt:123
#, priority:90
msgid "This is the filter for rewriting the tree and its contents.  The argument is evaluated in shell with the working directory set to the root of the checked out tree.  The new tree is then used as-is (new files are auto-added, disappeared files are auto-removed - neither .gitignore files nor any other ignore rules *HAVE ANY EFFECT*!)."
msgstr ""

#. type: Labeled list
#: en/git-filter-branch.txt:124
#, no-wrap, priority:90
msgid "--index-filter <command>"
msgstr ""

#. type: Plain text
#: en/git-filter-branch.txt:130
#, ignore-ellipsis, priority:90
msgid "This is the filter for rewriting the index.  It is similar to the tree filter but does not check out the tree, which makes it much faster.  Frequently used with `git rm --cached --ignore-unmatch ...`, see EXAMPLES below.  For hairy cases, see linkgit:git-update-index[1]."
msgstr ""

#. type: Labeled list
#: en/git-filter-branch.txt:131
#, no-wrap, priority:90
msgid "--parent-filter <command>"
msgstr ""

#. type: Plain text
#: en/git-filter-branch.txt:138
#, ignore-ellipsis, priority:90
msgid "This is the filter for rewriting the commit's parent list.  It will receive the parent string on stdin and shall output the new parent string on stdout.  The parent string is in the format described in linkgit:git-commit-tree[1]: empty for the initial commit, \"-p parent\" for a normal commit and \"-p parent1 -p parent2 -p parent3 ...\" for a merge commit."
msgstr ""

#. type: Labeled list
#: en/git-filter-branch.txt:139
#, fuzzy, no-wrap, priority:90
msgid "--msg-filter <command>"
msgstr "--msg-filter <command>"

#. type: Plain text
#: en/git-filter-branch.txt:144
#, priority:90
msgid "This is the filter for rewriting the commit messages.  The argument is evaluated in the shell with the original commit message on standard input; its standard output is used as the new commit message."
msgstr ""

#. type: Labeled list
#: en/git-filter-branch.txt:145
#, fuzzy, no-wrap, priority:90
msgid "--commit-filter <command>"
msgstr "--commit-filter <command>"

#. type: Plain text
#: en/git-filter-branch.txt:151
#, ignore-ellipsis, priority:90
msgid "This is the filter for performing the commit.  If this filter is specified, it will be called instead of the 'git commit-tree' command, with arguments of the form \"<TREE_ID> [(-p <PARENT_COMMIT_ID>)...]\" and the log message on stdin.  The commit id is expected on stdout."
msgstr ""

#. type: Plain text
#: en/git-filter-branch.txt:155
#, priority:90
msgid "As a special extension, the commit filter may emit multiple commit ids; in that case, the rewritten children of the original commit will have all of them as parents."
msgstr ""

#. type: Plain text
#: en/git-filter-branch.txt:160
#, priority:90
msgid "You can use the 'map' convenience function in this filter, and other convenience functions, too.  For example, calling 'skip_commit \"$@\"' will leave out the current commit (but not its changes! If you want that, use 'git rebase' instead)."
msgstr ""

#. type: Plain text
#: en/git-filter-branch.txt:164
#, priority:90
msgid "You can also use the `git_commit_non_empty_tree \"$@\"` instead of `git commit-tree \"$@\"` if you don't wish to keep commits with a single parent and that makes no change to the tree."
msgstr ""

#. type: Labeled list
#: en/git-filter-branch.txt:165
#, fuzzy, no-wrap, priority:90
msgid "--tag-name-filter <command>"
msgstr "--tag-name-filter <command>"

#. type: Plain text
#: en/git-filter-branch.txt:171
#, priority:90
msgid "This is the filter for rewriting tag names. When passed, it will be called for every tag ref that points to a rewritten object (or to a tag object which points to a rewritten object).  The original tag name is passed via standard input, and the new tag name is expected on standard output."
msgstr ""

#. type: Plain text
#: en/git-filter-branch.txt:176
#, priority:90
msgid "The original tags are not deleted, but can be overwritten; use \"--tag-name-filter cat\" to simply update the tags.  In this case, be very careful and make sure you have the old tags backed up in case the conversion has run afoul."
msgstr ""

#. type: Plain text
#: en/git-filter-branch.txt:187
#, priority:90
msgid "Nearly proper rewriting of tag objects is supported. If the tag has a message attached, a new tag object will be created with the same message, author, and timestamp. If the tag has a signature attached, the signature will be stripped. It is by definition impossible to preserve signatures. The reason this is \"nearly\" proper, is because ideally if the tag did not change (points to the same object, has the same name, etc.)  it should retain any signature. That is not the case, signatures will always be removed, buyer beware. There is also no support for changing the author or timestamp (or the tag message for that matter). Tags which point to other tags will be rewritten to point to the underlying commit."
msgstr ""

#. type: Labeled list
#: en/git-filter-branch.txt:188
#, ignore-same, no-wrap, priority:90
msgid "--prune-empty"
msgstr "--prune-empty"

#. type: Plain text
#: en/git-filter-branch.txt:195
#, priority:90
msgid "Some filters will generate empty commits that leave the tree untouched.  This option instructs git-filter-branch to remove such commits if they have exactly one or zero non-pruned parents; merge commits will therefore remain intact.  This option cannot be used together with `--commit-filter`, though the same effect can be achieved by using the provided `git_commit_non_empty_tree` function in a commit filter."
msgstr ""

#. type: Labeled list
#: en/git-filter-branch.txt:196
#, fuzzy, no-wrap, priority:90
msgid "--original <namespace>"
msgstr "--original <namespace>"

#. type: Plain text
#: en/git-filter-branch.txt:199
#, priority:90
msgid "Use this option to set the namespace where the original commits will be stored. The default value is 'refs/original'."
msgstr ""

#. type: Labeled list
#: en/git-filter-branch.txt:200
#, fuzzy, no-wrap, priority:90
msgid "-d <directory>"
msgstr "-d <directory>"

#. type: Plain text
#: en/git-filter-branch.txt:207
#, priority:90
msgid "Use this option to set the path to the temporary directory used for rewriting.  When applying a tree filter, the command needs to temporarily check out the tree to some directory, which may consume considerable space in case of large projects.  By default it does this in the `.git-rewrite/` directory but you can override that choice by this parameter."
msgstr ""

#. type: Plain text
#: en/git-filter-branch.txt:213
#, priority:90
msgid "'git filter-branch' refuses to start with an existing temporary directory or when there are already refs starting with 'refs/original/', unless forced."
msgstr ""

#. type: Labeled list
#: en/git-filter-branch.txt:214
#, fuzzy, no-wrap, priority:90
msgid "--state-branch <branch>"
msgstr "--state-branch <branch>"

#. type: Plain text
#: en/git-filter-branch.txt:219
#, priority:90
msgid "This option will cause the mapping from old to new objects to be loaded from named branch upon startup and saved as a new commit to that branch upon exit, enabling incremental of large trees. If '<branch>' does not exist it will be created."
msgstr ""

#. type: Labeled list
#: en/git-filter-branch.txt:220
#, ignore-ellipsis, no-wrap, priority:90
msgid "<rev-list options>..."
msgstr ""

#. type: Plain text
#: en/git-filter-branch.txt:225
#, fuzzy, priority:90
msgid "Arguments for 'git rev-list'.  All positive refs included by these options are rewritten.  You may also specify options such as `--all`, but you must use `--` to separate them from the 'git filter-branch' options. Implies <<Remap_to_ancestor>>."
msgstr "Arguments for 'git rev-list'.  All positive refs included by these options are rewritten.  You may also specify options such as `--all`, but you must use `--` to separate them from the 'git filter-branch' options. Implies <<Remap_to_ancestor>>."

#. type: Title ~
#: en/git-filter-branch.txt:229
#, no-wrap, priority:90
msgid "Remap to ancestor"
msgstr ""

#. type: Plain text
#: en/git-filter-branch.txt:236
#, priority:90
msgid "By using linkgit:git-rev-list[1] arguments, e.g., path limiters, you can limit the set of revisions which get rewritten. However, positive refs on the command line are distinguished: we don't let them be excluded by such limiters. For this purpose, they are instead rewritten to point at the nearest ancestor that was not excluded."
msgstr ""

#. type: Plain text
#: en/git-filter-branch.txt:244
#, priority:90
msgid "On success, the exit status is `0`.  If the filter can't find any commits to rewrite, the exit status is `2`.  On any other error, the exit status may be any other non-zero value."
msgstr ""

#. type: Plain text
#: en/git-filter-branch.txt:251
#, priority:90
msgid "Suppose you want to remove a file (containing confidential information or copyright violation) from all commits:"
msgstr ""

#. type: delimited block -
#: en/git-filter-branch.txt:254
#, no-wrap, priority:90
msgid "git filter-branch --tree-filter 'rm filename' HEAD\n"
msgstr ""

#. type: Plain text
#: en/git-filter-branch.txt:259
#, priority:90
msgid "However, if the file is absent from the tree of some commit, a simple `rm filename` will fail for that tree and commit.  Thus you may instead want to use `rm -f filename` as the script."
msgstr ""

#. type: Plain text
#: en/git-filter-branch.txt:265
#, priority:90
msgid "Using `--index-filter` with 'git rm' yields a significantly faster version.  Like with using `rm filename`, `git rm --cached filename` will fail if the file is absent from the tree of a commit.  If you want to \"completely forget\" a file, it does not matter when it entered history, so we also add `--ignore-unmatch`:"
msgstr ""

#. type: delimited block -
#: en/git-filter-branch.txt:268
#, no-wrap, priority:90
msgid "git filter-branch --index-filter 'git rm --cached --ignore-unmatch filename' HEAD\n"
msgstr ""

#. type: Plain text
#: en/git-filter-branch.txt:271
#, priority:90
msgid "Now, you will get the rewritten history saved in HEAD."
msgstr ""

#. type: Plain text
#: en/git-filter-branch.txt:274
#, priority:90
msgid "To rewrite the repository to look as if `foodir/` had been its project root, and discard all other history:"
msgstr ""

#. type: delimited block -
#: en/git-filter-branch.txt:277
#, no-wrap, priority:90
msgid "git filter-branch --subdirectory-filter foodir -- --all\n"
msgstr ""

#. type: Plain text
#: en/git-filter-branch.txt:282
#, priority:90
msgid "Thus you can, e.g., turn a library subdirectory into a repository of its own.  Note the `--` that separates 'filter-branch' options from revision options, and the `--all` to rewrite all branches and tags."
msgstr ""

#. type: Plain text
#: en/git-filter-branch.txt:286
#, priority:90
msgid "To set a commit (which typically is at the tip of another history) to be the parent of the current initial commit, in order to paste the other history behind the current history:"
msgstr ""

#. type: delimited block -
#: en/git-filter-branch.txt:289
#, no-wrap, priority:90
msgid "git filter-branch --parent-filter 'sed \"s/^\\$/-p <graft-id>/\"' HEAD\n"
msgstr ""

#. type: Plain text
#: en/git-filter-branch.txt:295
#, priority:90
msgid "(if the parent string is empty - which happens when we are dealing with the initial commit - add graftcommit as a parent).  Note that this assumes history with a single root (that is, no merge without common ancestors happened).  If this is not the case, use:"
msgstr ""

#. type: delimited block -
#: en/git-filter-branch.txt:299
#, no-wrap, priority:90
msgid ""
"git filter-branch --parent-filter \\\n"
"\t'test $GIT_COMMIT = <commit-id> && echo \"-p <graft-id>\" || cat' HEAD\n"
msgstr ""

#. type: Plain text
#: en/git-filter-branch.txt:302
#, priority:90
msgid "or even simpler:"
msgstr ""

#. type: delimited block -
#: en/git-filter-branch.txt:306
#, no-wrap, priority:90
msgid ""
"git replace --graft $commit-id $graft-id\n"
"git filter-branch $graft-id..HEAD\n"
msgstr ""

#. type: Plain text
#: en/git-filter-branch.txt:309
#, priority:90
msgid "To remove commits authored by \"Darl McBribe\" from the history:"
msgstr ""

#. type: delimited block -
#: en/git-filter-branch.txt:318
#, no-wrap, priority:90
msgid ""
"git filter-branch --commit-filter '\n"
"\tif [ \"$GIT_AUTHOR_NAME\" = \"Darl McBribe\" ];\n"
"\tthen\n"
"\t\tskip_commit \"$@\";\n"
"\telse\n"
"\t\tgit commit-tree \"$@\";\n"
"\tfi' HEAD\n"
msgstr ""

#. type: Plain text
#: en/git-filter-branch.txt:321
#, priority:90
msgid "The function 'skip_commit' is defined as follows:"
msgstr ""

#. type: delimited block -
#: en/git-filter-branch.txt:333
#, no-wrap, priority:90
msgid ""
"skip_commit()\n"
"{\n"
"\tshift;\n"
"\twhile [ -n \"$1\" ];\n"
"\tdo\n"
"\t\tshift;\n"
"\t\tmap \"$1\";\n"
"\t\tshift;\n"
"\tdone;\n"
"}\n"
msgstr ""

#. type: Plain text
#: en/git-filter-branch.txt:340
#, priority:90
msgid "The shift magic first throws away the tree id and then the -p parameters.  Note that this handles merges properly! In case Darl committed a merge between P1 and P2, it will be propagated properly and all children of the merge will become merge commits with P1,P2 as their parents instead of the merge commit."
msgstr ""

#. type: Plain text
#: en/git-filter-branch.txt:345
#, no-wrap, priority:90
msgid ""
"*NOTE* the changes introduced by the commits, and which are not reverted\n"
"by subsequent commits, will still be in the rewritten branch. If you want\n"
"to throw out _changes_ together with the commits, you should use the\n"
"interactive mode of 'git rebase'.\n"
msgstr ""

#. type: Plain text
#: en/git-filter-branch.txt:349
#, priority:90
msgid "You can rewrite the commit log messages using `--msg-filter`.  For example, 'git svn-id' strings in a repository created by 'git svn' can be removed this way:"
msgstr ""

#. type: delimited block -
#: en/git-filter-branch.txt:354
#, no-wrap, priority:90
msgid ""
"git filter-branch --msg-filter '\n"
"\tsed -e \"/^git-svn-id:/d\"\n"
"'\n"
msgstr ""

#. type: Plain text
#: en/git-filter-branch.txt:358
#, priority:90
msgid "If you need to add 'Acked-by' lines to, say, the last 10 commits (none of which is a merge), use this command:"
msgstr ""

#. type: delimited block -
#: en/git-filter-branch.txt:364
#, no-wrap, priority:90
msgid ""
"git filter-branch --msg-filter '\n"
"\tcat &&\n"
"\techo \"Acked-by: Bugs Bunny <bunny@bugzilla.org>\"\n"
"' HEAD~10..HEAD\n"
msgstr ""

#. type: Plain text
#: en/git-filter-branch.txt:370
#, priority:90
msgid "The `--env-filter` option can be used to modify committer and/or author identity.  For example, if you found out that your commits have the wrong identity due to a misconfigured user.email, you can make a correction, before publishing the project, like this:"
msgstr ""

#. type: delimited block -
#: en/git-filter-branch.txt:382
#, no-wrap, priority:90
msgid ""
"git filter-branch --env-filter '\n"
"\tif test \"$GIT_AUTHOR_EMAIL\" = \"root@localhost\"\n"
"\tthen\n"
"\t\tGIT_AUTHOR_EMAIL=john@example.com\n"
"\tfi\n"
"\tif test \"$GIT_COMMITTER_EMAIL\" = \"root@localhost\"\n"
"\tthen\n"
"\t\tGIT_COMMITTER_EMAIL=john@example.com\n"
"\tfi\n"
"' -- --all\n"
msgstr ""

#. type: Plain text
#: en/git-filter-branch.txt:388
#, priority:90
msgid "To restrict rewriting to only part of the history, specify a revision range in addition to the new branch name.  The new branch name will point to the top-most revision that a 'git rev-list' of this range will print."
msgstr ""

#. type: Plain text
#: en/git-filter-branch.txt:390
#, priority:90
msgid "Consider this history:"
msgstr ""

#. type: delimited block -
#: en/git-filter-branch.txt:395
#, no-wrap, priority:90
msgid ""
"     D--E--F--G--H\n"
"    /     /\n"
"A--B-----C\n"
msgstr ""

#. type: Plain text
#: en/git-filter-branch.txt:398
#, priority:90
msgid "To rewrite only commits D,E,F,G,H, but leave A, B and C alone, use:"
msgstr ""

#. type: delimited block -
#: en/git-filter-branch.txt:401
#, ignore-ellipsis, no-wrap, priority:90
msgid "git filter-branch ... C..H\n"
msgstr ""

#. type: Plain text
#: en/git-filter-branch.txt:404
#, priority:90
msgid "To rewrite commits E,F,G,H, use one of these:"
msgstr ""

#. type: delimited block -
#: en/git-filter-branch.txt:408
#, ignore-ellipsis, no-wrap, priority:90
msgid ""
"git filter-branch ... C..H --not D\n"
"git filter-branch ... D..H --not C\n"
msgstr ""

#. type: Plain text
#: en/git-filter-branch.txt:411
#, priority:90
msgid "To move the whole tree into a subdirectory, or remove it from there:"
msgstr ""

#. type: delimited block -
#: en/git-filter-branch.txt:418
#, no-wrap, priority:90
msgid ""
"git filter-branch --index-filter \\\n"
"\t'git ls-files -s | sed \"s-\\t\\\"*-&newsubdir/-\" |\n"
"\t\tGIT_INDEX_FILE=$GIT_INDEX_FILE.new \\\n"
"\t\t\tgit update-index --index-info &&\n"
"\t mv \"$GIT_INDEX_FILE.new\" \"$GIT_INDEX_FILE\"' HEAD\n"
msgstr ""

#. type: Title -
#: en/git-filter-branch.txt:423
#, no-wrap, priority:90
msgid "CHECKLIST FOR SHRINKING A REPOSITORY"
msgstr ""

#. type: Plain text
#: en/git-filter-branch.txt:431
#, priority:90
msgid "git-filter-branch can be used to get rid of a subset of files, usually with some combination of `--index-filter` and `--subdirectory-filter`.  People expect the resulting repository to be smaller than the original, but you need a few more steps to actually make it smaller, because Git tries hard not to lose your objects until you tell it to.  First make sure that:"
msgstr ""

#. type: Plain text
#: en/git-filter-branch.txt:435
#, priority:90
msgid "You really removed all variants of a filename, if a blob was moved over its lifetime.  `git log --name-only --follow --all -- filename` can help you find renames."
msgstr ""

#. type: Plain text
#: en/git-filter-branch.txt:438
#, priority:90
msgid "You really filtered all refs: use `--tag-name-filter cat -- --all` when calling git-filter-branch."
msgstr ""

#. type: Plain text
#: en/git-filter-branch.txt:441
#, priority:90
msgid "Then there are two ways to get a smaller repository.  A safer way is to clone, that keeps your original intact."
msgstr ""

#. type: Plain text
#: en/git-filter-branch.txt:445
#, priority:90
msgid "Clone it with `git clone file:///path/to/repo`.  The clone will not have the removed objects.  See linkgit:git-clone[1].  (Note that cloning with a plain path just hardlinks everything!)"
msgstr ""

#. type: Plain text
#: en/git-filter-branch.txt:450
#, priority:90
msgid "If you really don't want to clone it, for whatever reasons, check the following points instead (in this order).  This is a very destructive approach, so *make a backup* or go back to cloning it.  You have been warned."
msgstr ""

#. type: Plain text
#: en/git-filter-branch.txt:454
#, priority:90
msgid "Remove the original refs backed up by git-filter-branch: say `git for-each-ref --format=\"%(refname)\" refs/original/ | xargs -n 1 git update-ref -d`."
msgstr ""

#. type: Plain text
#: en/git-filter-branch.txt:456
#, priority:90
msgid "Expire all reflogs with `git reflog expire --expire=now --all`."
msgstr ""

#. type: Plain text
#: en/git-filter-branch.txt:460
#, priority:90
msgid "Garbage collect all unreferenced objects with `git gc --prune=now` (or if your git-gc is not new enough to support arguments to `--prune`, use `git repack -ad; git prune` instead)."
msgstr ""

#. type: Plain text
#: en/git-filter-branch.txt:467
#, fuzzy, priority:90
msgid "The performance of git-filter-branch is glacially slow; its design makes it impossible for a backward-compatible implementation to ever be fast:"
msgstr "The performance of git-filter-branch is glacially slow; its design makes it impossible for a backward-compatible implementation to ever be fast:"

#. type: Plain text
#: en/git-filter-branch.txt:473
#, priority:90
msgid "In editing files, git-filter-branch by design checks out each and every commit as it existed in the original repo.  If your repo has `10^5` files and `10^5` commits, but each commit only modifies five files, then git-filter-branch will make you do `10^10` modifications, despite only having (at most) `5*10^5` unique blobs."
msgstr ""

#. type: Plain text
#: en/git-filter-branch.txt:476
#, priority:90
msgid "If you try and cheat and try to make git-filter-branch only work on files modified in a commit, then two things happen"
msgstr ""

#. type: Plain text
#: en/git-filter-branch.txt:482
#, priority:90
msgid "you run into problems with deletions whenever the user is simply trying to rename files (because attempting to delete files that don't exist looks like a no-op; it takes some chicanery to remap deletes across file renames when the renames happen via arbitrary user-provided shell)"
msgstr ""

#. type: Plain text
#: en/git-filter-branch.txt:488
#, priority:90
msgid "even if you succeed at the map-deletes-for-renames chicanery, you still technically violate backward compatibility because users are allowed to filter files in ways that depend upon topology of commits instead of filtering solely based on file contents or names (though this has not been observed in the wild)."
msgstr ""

#. type: Plain text
#: en/git-filter-branch.txt:495
#, priority:90
msgid "Even if you don't need to edit files but only want to e.g. rename or remove some and thus can avoid checking out each file (i.e. you can use --index-filter), you still are passing shell snippets for your filters.  This means that for every commit, you have to have a prepared git repo where those filters can be run.  That's a significant setup."
msgstr ""

#. type: Plain text
#: en/git-filter-branch.txt:507
#, priority:90
msgid "Further, several additional files are created or updated per commit by git-filter-branch.  Some of these are for supporting the convenience functions provided by git-filter-branch (such as map()), while others are for keeping track of internal state (but could have also been accessed by user filters; one of git-filter-branch's regression tests does so).  This essentially amounts to using the filesystem as an IPC mechanism between git-filter-branch and the user-provided filters.  Disks tend to be a slow IPC mechanism, and writing these files also effectively represents a forced synchronization point between separate processes that we hit with every commit."
msgstr ""

#. type: Plain text
#: en/git-filter-branch.txt:513
#, priority:90
msgid "The user-provided shell commands will likely involve a pipeline of commands, resulting in the creation of many processes per commit.  Creating and running another process takes a widely varying amount of time between operating systems, but on any platform it is very slow relative to invoking a function."
msgstr ""

#. type: Plain text
#: en/git-filter-branch.txt:519
#, fuzzy, priority:90
msgid "git-filter-branch itself is written in shell, which is kind of slow.  This is the one performance issue that could be backward-compatibly fixed, but compared to the above problems that are intrinsic to the design of git-filter-branch, the language of the tool itself is a relatively minor issue."
msgstr "git-filter-branch itself is written in shell, which is kind of slow.  This is the one performance issue that could be backward-compatibly fixed, but compared to the above problems that are intrinsic to the design of git-filter-branch, the language of the tool itself is a relatively minor issue."

#. type: Plain text
#: en/git-filter-branch.txt:530
#, priority:90
msgid "Side note: Unfortunately, people tend to fixate on the written-in-shell aspect and periodically ask if git-filter-branch could be rewritten in another language to fix the performance issues.  Not only does that ignore the bigger intrinsic problems with the design, it'd help less than you'd expect: if git-filter-branch itself were not shell, then the convenience functions (map(), skip_commit(), etc) and the `--setup` argument could no longer be executed once at the beginning of the program but would instead need to be prepended to every user filter (and thus re-executed with every commit)."
msgstr ""

#. type: Plain text
#: en/git-filter-branch.txt:541
#, priority:90
msgid "The https://github.com/newren/git-filter-repo/[git filter-repo] tool is an alternative to git-filter-branch which does not suffer from these performance problems or the safety problems (mentioned below). For those with existing tooling which relies upon git-filter-branch, 'git filter-repo' also provides https://github.com/newren/git-filter-repo/blob/master/contrib/filter-repo-demos/filter-lamely[filter-lamely], a drop-in git-filter-branch replacement (with a few caveats).  While filter-lamely suffers from all the same safety issues as git-filter-branch, it at least ameliorates the performance issues a little."
msgstr ""

#. type: Title -
#: en/git-filter-branch.txt:544
#, fuzzy, no-wrap, priority:90
msgid "SAFETY"
msgstr "安全性"

#. type: Plain text
#: en/git-filter-branch.txt:549
#, priority:90
msgid "git-filter-branch is riddled with gotchas resulting in various ways to easily corrupt repos or end up with a mess worse than what you started with:"
msgstr ""

#. type: Plain text
#: en/git-filter-branch.txt:563
#, priority:90
msgid "Someone can have a set of \"working and tested filters\" which they document or provide to a coworker, who then runs them on a different OS where the same commands are not working/tested (some examples in the git-filter-branch manpage are also affected by this).  BSD vs. GNU userland differences can really bite.  If lucky, error messages are spewed.  But just as likely, the commands either don't do the filtering requested, or silently corrupt by making some unwanted change.  The unwanted change may only affect a few commits, so it's not necessarily obvious either.  (The fact that problems won't necessarily be obvious means they are likely to go unnoticed until the rewritten history is in use for quite a while, at which point it's really hard to justify another flag-day for another rewrite.)"
msgstr ""

#. type: Plain text
#: en/git-filter-branch.txt:573
#, priority:90
msgid "Filenames with spaces are often mishandled by shell snippets since they cause problems for shell pipelines.  Not everyone is familiar with find -print0, xargs -0, git-ls-files -z, etc.  Even people who are familiar with these may assume such flags are not relevant because someone else renamed any such files in their repo back before the person doing the filtering joined the project.  And often, even those familiar with handling arguments with spaces may not do so just because they aren't in the mindset of thinking about everything that could possibly go wrong."
msgstr ""

#. type: Plain text
#: en/git-filter-branch.txt:584
#, priority:90
msgid "Non-ascii filenames can be silently removed despite being in a desired directory.  Keeping only wanted paths is often done using pipelines like `git ls-files | grep -v ^WANTED_DIR/ | xargs git rm`.  ls-files will only quote filenames if needed, so folks may not notice that one of the files didn't match the regex (at least not until it's much too late).  Yes, someone who knows about core.quotePath can avoid this (unless they have other special characters like \\t, \\n, or \"), and people who use ls-files -z with something other than grep can avoid this, but that doesn't mean they will."
msgstr ""

#. type: Plain text
#: en/git-filter-branch.txt:591
#, priority:90
msgid "Similarly, when moving files around, one can find that filenames with non-ascii or special characters end up in a different directory, one that includes a double quote character.  (This is technically the same issue as above with quoting, but perhaps an interesting different way that it can and has manifested as a problem.)"
msgstr ""

#. type: Plain text
#: en/git-filter-branch.txt:600
#, priority:90
msgid "It's far too easy to accidentally mix up old and new history.  It's still possible with any tool, but git-filter-branch almost invites it.  If lucky, the only downside is users getting frustrated that they don't know how to shrink their repo and remove the old stuff.  If unlucky, they merge old and new history and end up with multiple \"copies\" of each commit, some of which have unwanted or sensitive files and others which don't.  This comes about in multiple different ways:"
msgstr ""

#. type: Plain text
#: en/git-filter-branch.txt:603
#, priority:90
msgid "the default to only doing a partial history rewrite ('--all' is not the default and few examples show it)"
msgstr ""

#. type: Plain text
#: en/git-filter-branch.txt:605
#, priority:90
msgid "the fact that there's no automatic post-run cleanup"
msgstr ""

#. type: Plain text
#: en/git-filter-branch.txt:608
#, priority:90
msgid "the fact that --tag-name-filter (when used to rename tags) doesn't remove the old tags but just adds new ones with the new name"
msgstr ""

#. type: Plain text
#: en/git-filter-branch.txt:617
#, priority:90
msgid "the fact that little educational information is provided to inform users of the ramifications of a rewrite and how to avoid mixing old and new history.  For example, this man page discusses how users need to understand that they need to rebase their changes for all their branches on top of new history (or delete and reclone), but that's only one of multiple concerns to consider.  See the \"DISCUSSION\" section of the git filter-repo manual page for more details."
msgstr ""

#. type: Plain text
#: en/git-filter-branch.txt:620
#, priority:90
msgid "Annotated tags can be accidentally converted to lightweight tags, due to either of two issues:"
msgstr ""

#. type: Plain text
#: en/git-filter-branch.txt:625
#, priority:90
msgid "Someone can do a history rewrite, realize they messed up, restore from the backups in refs/original/, and then redo their git-filter-branch command.  (The backup in refs/original/ is not a real backup; it dereferences tags first.)"
msgstr ""

#. type: Plain text
#: en/git-filter-branch.txt:630
#, priority:90
msgid "Running git-filter-branch with either --tags or --all in your <rev-list options>.  In order to retain annotated tags as annotated, you must use --tag-name-filter (and must not have restored from refs/original/ in a previously botched rewrite)."
msgstr ""

#. type: Plain text
#: en/git-filter-branch.txt:636
#, priority:90
msgid "Any commit messages that specify an encoding will become corrupted by the rewrite; git-filter-branch ignores the encoding, takes the original bytes, and feeds it to commit-tree without telling it the proper encoding.  (This happens whether or not --msg-filter is used.)"
msgstr ""

#. type: Plain text
#: en/git-filter-branch.txt:641
#, priority:90
msgid "Commit messages (even if they are all UTF-8) by default become corrupted due to not being updated -- any references to other commit hashes in commit messages will now refer to no-longer-extant commits."
msgstr ""

#. type: Plain text
#: en/git-filter-branch.txt:652
#, priority:90
msgid "There are no facilities for helping users find what unwanted crud they should delete, which means they are much more likely to have incomplete or partial cleanups that sometimes result in confusion and people wasting time trying to understand.  (For example, folks tend to just look for big files to delete instead of big directories or extensions, and once they do so, then sometime later folks using the new repository who are going through history will notice a build artifact directory that has some files but not others, or a cache of dependencies (node_modules or similar) which couldn't have ever been functional since it's missing some files.)"
msgstr ""

#. type: Plain text
#: en/git-filter-branch.txt:655
#, priority:90
msgid "If --prune-empty isn't specified, then the filtering process can create hoards of confusing empty commits"
msgstr ""

#. type: Plain text
#: en/git-filter-branch.txt:659
#, priority:90
msgid "If --prune-empty is specified, then intentionally placed empty commits from before the filtering operation are also pruned instead of just pruning commits that became empty due to filtering rules."
msgstr ""

#. type: Plain text
#: en/git-filter-branch.txt:662
#, ignore-ellipsis, priority:90
msgid "If --prune-empty is specified, sometimes empty commits are missed and left around anyway (a somewhat rare bug, but it happens...)"
msgstr ""

#. type: Plain text
#: en/git-filter-branch.txt:666
#, priority:90
msgid "A minor issue, but users who have a goal to update all names and emails in a repository may be led to --env-filter which will only update authors and committers, missing taggers."
msgstr ""

#. type: Plain text
#: en/git-filter-branch.txt:672
#, priority:90
msgid "If the user provides a --tag-name-filter that maps multiple tags to the same name, no warning or error is provided; git-filter-branch simply overwrites each tag in some undocumented pre-defined order resulting in only one tag at the end.  (A git-filter-branch regression test requires this surprising behavior.)"
msgstr ""

#. type: Plain text
#: en/git-filter-branch.txt:675
#, priority:90
msgid "Also, the poor performance of git-filter-branch often leads to safety issues:"
msgstr ""

#. type: Plain text
#: en/git-filter-branch.txt:692
#, priority:90
msgid "Coming up with the correct shell snippet to do the filtering you want is sometimes difficult unless you're just doing a trivial modification such as deleting a couple files.  Unfortunately, people often learn if the snippet is right or wrong by trying it out, but the rightness or wrongness can vary depending on special circumstances (spaces in filenames, non-ascii filenames, funny author names or emails, invalid timezones, presence of grafts or replace objects, etc.), meaning they may have to wait a long time, hit an error, then restart.  The performance of git-filter-branch is so bad that this cycle is painful, reducing the time available to carefully re-check (to say nothing about what it does to the patience of the person doing the rewrite even if they do technically have more time available).  This problem is extra compounded because errors from broken filters may not be shown for a long time and/or get lost in a sea of output.  Even worse, broken filters often just result in silent incorrect rewrites."
msgstr ""

#. type: Plain text
#: en/git-filter-branch.txt:700
#, priority:90
msgid "To top it all off, even when users finally find working commands, they naturally want to share them.  But they may be unaware that their repo didn't have some special cases that someone else's does.  So, when someone else with a different repository runs the same commands, they get hit by the problems above.  Or, the user just runs commands that really were vetted for special cases, but they run it on a different OS where it doesn't work, as noted above."
msgstr ""

#. type: Title =
#: en/git-fmt-merge-msg.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-fmt-merge-msg(1)"
msgstr "git-fmt-merge-msg(1)"

#. type: Plain text
#: en/git-fmt-merge-msg.txt:7
#, fuzzy, priority:100
msgid "git-fmt-merge-msg - Produce a merge commit message"
msgstr "git-fmt-merge-msg - Produce a merge commit message"

#. type: Plain text
#: en/git-fmt-merge-msg.txt:14
#, fuzzy, no-wrap, priority:100
msgid ""
"'git fmt-merge-msg' [-m <message>] [--into-name <branch>] [--log[=<n>] | --no-log]\n"
"'git fmt-merge-msg' [-m <message>] [--log[=<n>] | --no-log] -F <file>\n"
msgstr ""
"'git fmt-merge-msg' [-m <message>] [--log[=<n>] | --no-log]\n"
"'git fmt-merge-msg' [-m <message>] [--log[=<n>] | --no-log] -F <file>\n"

#. type: Plain text
#: en/git-fmt-merge-msg.txt:20
#, priority:100
msgid "Takes the list of merged objects on stdin and produces a suitable commit message to be used for the merge commit, usually to be passed as the '<merge-message>' argument of 'git merge'."
msgstr "接收标准输入流中的合并对象列表，并产生一个合适的提交信息，用于合并提交，通常作为 'git merge' 的 '<merge-message>' 参数传递。"

#. type: Plain text
#: en/git-fmt-merge-msg.txt:23
#, priority:100
msgid "This command is intended mostly for internal use by scripts automatically invoking 'git merge'."
msgstr "这条命令主要是供自动调用 'git merge' 的脚本内部使用。"

#. type: Labeled list
#: en/git-fmt-merge-msg.txt:27 en/merge-options.txt:93
#, no-wrap, priority:240
msgid "--log[=<n>]"
msgstr "--log[=<n>]"

#. type: Plain text
#: en/git-fmt-merge-msg.txt:33
#, priority:100
msgid "In addition to branch names, populate the log message with one-line descriptions from the actual commits that are being merged.  At most <n> commits from each merge parent will be used (20 if <n> is omitted).  This overrides the `merge.log` configuration variable."
msgstr "除了分支名称外，在日志信息中加入被合并的实际提交内容的单行描述。 最多使用每个合并父分支的 <n> 个提交（如果 <n> 被省略，则为 20 个）。 这覆盖了 `merge.log` 配置变量。"

#. type: Labeled list
#: en/git-fmt-merge-msg.txt:34 en/merge-options.txt:94
#, ignore-same, no-wrap, priority:240
msgid "--no-log"
msgstr "--no-log"

#. type: Plain text
#: en/git-fmt-merge-msg.txt:37
#, priority:100
msgid "Do not list one-line descriptions from the actual commits being merged."
msgstr "不要列出被合并的实际提交中的单行描述。"

#. type: Labeled list
#: en/git-fmt-merge-msg.txt:38
#, ignore-same, no-wrap, priority:100
msgid "--[no-]summary"
msgstr "--[no-]summary"

#. type: Plain text
#: en/git-fmt-merge-msg.txt:41
#, priority:100
msgid "Synonyms to --log and --no-log; these are deprecated and will be removed in the future."
msgstr "与 --log 和 --no-log 的同义词；这些都是废弃的，将来会被删除。"

#. type: Labeled list
#: en/git-fmt-merge-msg.txt:43
#, fuzzy, no-wrap, priority:100
msgid "--message <message>"
msgstr "--message <message>"

#. type: Plain text
#: en/git-fmt-merge-msg.txt:46
#, priority:100
msgid "Use <message> instead of the branch names for the first line of the log message.  For use with `--log`."
msgstr "在日志信息的第一行使用 <message> 而不是分支名称。 与 `--log` 一起使用。"

#. type: Labeled list
#: en/git-fmt-merge-msg.txt:47 en/git-merge.txt:81
#, fuzzy, no-wrap, priority:240
msgid "--into-name <branch>"
msgstr "--state-branch <branch>"

#. type: Plain text
#: en/git-fmt-merge-msg.txt:50
#, priority:100
msgid "Prepare the merge message as if merging to the branch `<branch>`, instead of the name of the real branch to which the merge is made."
msgstr "准备合并信息，就像合并到分支 `<branch>` 一样，而不是合并到真正的分支名称。"

#. type: Labeled list
#: en/git-fmt-merge-msg.txt:52
#, no-wrap, priority:100
msgid "--file <file>"
msgstr "--file <文件>"

#. type: Plain text
#: en/git-fmt-merge-msg.txt:55
#, priority:100
msgid "Take the list of merged objects from <file> instead of stdin."
msgstr "从 <文件> 而不是标准输入流获取合并后的对象列表。"

#. type: Labeled list
#: en/git-fmt-merge-msg.txt:60
#, ignore-same, no-wrap, priority:100
msgid "merge.summary"
msgstr "merge.summary"

#. type: Plain text
#: en/git-fmt-merge-msg.txt:63
#, priority:100
msgid "Synonym to `merge.log`; this is deprecated and will be removed in the future."
msgstr "`merge.log` 的同义词；这已被废弃，将来会被删除。"

#. type: delimited block -
#: en/git-fmt-merge-msg.txt:70
#, fuzzy, no-wrap, priority:100
msgid ""
"$ git fetch origin master\n"
"$ git fmt-merge-msg --log <$GIT_DIR/FETCH_HEAD\n"
msgstr ""
"$ git fetch origin master\n"
"$ git fmt-merge-msg --log <$GIT_DIR/FETCH_HEAD\n"

#. type: Plain text
#: en/git-fmt-merge-msg.txt:74
#, priority:100
msgid "Print a log message describing a merge of the \"master\" branch from the \"origin\" remote."
msgstr "打印一条日志信息，描述从 \"origin\" 远程分支合并到 \"master\" 分支的情况。"

#. type: Title =
#: en/git-for-each-ref.txt:2
#, ignore-same, no-wrap, priority:80
msgid "git-for-each-ref(1)"
msgstr "git-for-each-ref(1)"

#. type: Plain text
#: en/git-for-each-ref.txt:7
#, priority:80
msgid "git-for-each-ref - Output information on each ref"
msgstr ""

#. type: Plain text
#: en/git-for-each-ref.txt:18
#, fuzzy, ignore-ellipsis, no-wrap, priority:80
msgid ""
"'git for-each-ref' [--count=<count>] [--shell|--perl|--python|--tcl]\n"
"\t\t   [(--sort=<key>)...] [--format=<format>]\n"
"\t\t   [ --stdin | <pattern>... ]\n"
"\t\t   [--points-at=<object>]\n"
"\t\t   [--merged[=<object>]] [--no-merged[=<object>]]\n"
"\t\t   [--contains[=<object>]] [--no-contains[=<object>]]\n"
"\t\t   [--exclude=<pattern> ...]\n"
msgstr ""
"'git for-each-ref' [--count=<count>] [--shell|--perl|--python|--tcl]\n"
"\t\t   [(--sort=<key>)...] [--format=<format>] [<pattern>...]\n"
"\t\t   [--points-at=<object>]\n"
"\t\t   [--merged[=<object>]] [--no-merged[=<object>]]\n"
"\t\t   [--contains[=<object>]] [--no-contains[=<object>]]\n"

#. type: Plain text
#: en/git-for-each-ref.txt:28
#, priority:80
msgid "Iterate over all refs that match `<pattern>` and show them according to the given `<format>`, after sorting them according to the given set of `<key>`.  If `<count>` is given, stop after showing that many refs.  The interpolated values in `<format>` can optionally be quoted as string literals in the specified host language allowing their direct evaluation in that language."
msgstr ""

#. type: Labeled list
#: en/git-for-each-ref.txt:31 en/git-show-ref.txt:88
#, ignore-ellipsis, no-wrap, priority:80
msgid "<pattern>..."
msgstr ""

#. type: Plain text
#: en/git-for-each-ref.txt:36
#, priority:80
msgid "If one or more patterns are given, only refs are shown that match against at least one pattern, either using fnmatch(3) or literally, in the latter case matching completely or from the beginning up to a slash."
msgstr ""

#. type: Plain text
#: en/git-for-each-ref.txt:40
#, priority:80
msgid "If `--stdin` is supplied, then the list of patterns is read from standard input instead of from the argument list."
msgstr ""

#. type: Labeled list
#: en/git-for-each-ref.txt:41
#, fuzzy, no-wrap, priority:80
msgid "--count=<count>"
msgstr "--count=<count>"

#. type: Plain text
#: en/git-for-each-ref.txt:45
#, priority:80
msgid "By default the command shows all refs that match `<pattern>`.  This option makes it stop after showing that many refs."
msgstr ""

#. type: Plain text
#: en/git-for-each-ref.txt:52
#, priority:80
msgid "A field name to sort on.  Prefix `-` to sort in descending order of the value.  When unspecified, `refname` is used.  You may use the --sort=<key> option multiple times, in which case the last key becomes the primary key."
msgstr ""

#. type: Labeled list
#: en/git-for-each-ref.txt:53 en/git-ls-files.txt:218 en/git-ls-tree.txt:86 en/git-replace.txt:106 en/git-tag.txt:201 en/pretty-options.txt:2
#, fuzzy, no-wrap, priority:260
msgid "--format=<format>"
msgstr "--format=<format>"

#. type: Plain text
#: en/git-for-each-ref.txt:65
#, priority:80
msgid "A string that interpolates `%(fieldname)` from a ref being shown and the object it points at.  If `fieldname` is prefixed with an asterisk (`*`) and the ref points at a tag object, use the value for the field in the object which the tag object refers to (instead of the field in the tag object).  When unspecified, `<format>` defaults to `%(objectname) SPC %(objecttype) TAB %(refname)`.  It also interpolates `%%` to `%`, and `%xx` where `xx` are hex digits interpolates to character with hex code `xx`; for example `%00` interpolates to `\\0` (NUL), `%09` to `\\t` (TAB) and `%0a` to `\\n` (LF)."
msgstr ""

#. type: Plain text
#: en/git-for-each-ref.txt:70 en/git-tag.txt:129
#, priority:240
msgid "Respect any colors specified in the `--format` option. The `<when>` field must be one of `always`, `never`, or `auto` (if `<when>` is absent, behave as if `always` was given)."
msgstr "尊重`--format`选项中指定的任何颜色。`<什么时候>`字段必须是`always`、`never`或`auto`之一（如果没有`<什么时候>`，则表现为`always`）。"

#. type: Labeled list
#: en/git-for-each-ref.txt:71
#, ignore-same, no-wrap, priority:80
msgid "--shell"
msgstr "--shell"

#. type: Labeled list
#: en/git-for-each-ref.txt:72
#, ignore-same, no-wrap, priority:80
msgid "--perl"
msgstr "--perl"

#. type: Labeled list
#: en/git-for-each-ref.txt:73
#, ignore-same, no-wrap, priority:80
msgid "--python"
msgstr "--python"

#. type: Labeled list
#: en/git-for-each-ref.txt:74
#, ignore-same, no-wrap, priority:80
msgid "--tcl"
msgstr "--tcl"

#. type: Plain text
#: en/git-for-each-ref.txt:79
#, priority:80
msgid "If given, strings that substitute `%(fieldname)` placeholders are quoted as string literals suitable for the specified host language.  This is meant to produce a scriptlet that can directly be `eval`ed."
msgstr ""

#. type: Labeled list
#: en/git-for-each-ref.txt:80
#, fuzzy, no-wrap, priority:80
msgid "--points-at=<object>"
msgstr "--points-at=<object>"

#. type: Plain text
#: en/git-for-each-ref.txt:82
#, priority:80
msgid "Only list refs which points at the given object."
msgstr ""

#. type: Labeled list
#: en/git-for-each-ref.txt:83
#, fuzzy, no-wrap, priority:80
msgid "--merged[=<object>]"
msgstr "--merged[=<object>]"

#. type: Plain text
#: en/git-for-each-ref.txt:86
#, priority:80
msgid "Only list refs whose tips are reachable from the specified commit (HEAD if not specified)."
msgstr ""

#. type: Labeled list
#: en/git-for-each-ref.txt:87
#, no-wrap, priority:80
msgid "--no-merged[=<object>]"
msgstr ""

#. type: Plain text
#: en/git-for-each-ref.txt:90
#, priority:80
msgid "Only list refs whose tips are not reachable from the specified commit (HEAD if not specified)."
msgstr ""

#. type: Labeled list
#: en/git-for-each-ref.txt:91
#, fuzzy, no-wrap, priority:80
msgid "--contains[=<object>]"
msgstr "--contains[=<object>]"

#. type: Plain text
#: en/git-for-each-ref.txt:94
#, priority:80
msgid "Only list refs which contain the specified commit (HEAD if not specified)."
msgstr ""

#. type: Labeled list
#: en/git-for-each-ref.txt:95
#, fuzzy, no-wrap, priority:80
msgid "--no-contains[=<object>]"
msgstr "--no-contains[=<object>]"

#. type: Plain text
#: en/git-for-each-ref.txt:98
#, priority:80
msgid "Only list refs which don't contain the specified commit (HEAD if not specified)."
msgstr ""

#. type: Plain text
#: en/git-for-each-ref.txt:101
#, priority:80
msgid "Sorting and filtering refs are case insensitive."
msgstr ""

#. type: Plain text
#: en/git-for-each-ref.txt:110
#, priority:80
msgid "If one or more patterns are given, only refs which do not match any excluded pattern(s) are shown. Matching is done using the same rules as `<pattern>` above."
msgstr ""

#. type: Title -
#: en/git-for-each-ref.txt:112 en/git-ls-files.txt:265 en/git-ls-tree.txt:145
#, no-wrap, priority:80
msgid "FIELD NAMES"
msgstr ""

#. type: Plain text
#: en/git-for-each-ref.txt:117
#, priority:80
msgid "Various values from structured fields in referenced objects can be used to interpolate into the resulting output, or as sort keys."
msgstr ""

#. type: Plain text
#: en/git-for-each-ref.txt:119
#, priority:80
msgid "For all objects, the following names can be used:"
msgstr ""

#. type: Labeled list
#: en/git-for-each-ref.txt:120
#, no-wrap, priority:80
msgid "refname"
msgstr ""

#. type: Plain text
#: en/git-for-each-ref.txt:136
#, priority:80
msgid "The name of the ref (the part after $GIT_DIR/).  For a non-ambiguous short name of the ref append `:short`.  The option core.warnAmbiguousRefs is used to select the strict abbreviation mode. If `lstrip=<N>` (`rstrip=<N>`) is appended, strips `<N>` slash-separated path components from the front (back) of the refname (e.g. `%(refname:lstrip=2)` turns `refs/tags/foo` into `foo` and `%(refname:rstrip=2)` turns `refs/tags/foo` into `refs`).  If `<N>` is a negative number, strip as many path components as necessary from the specified end to leave `-<N>` path components (e.g. `%(refname:lstrip=-2)` turns `refs/tags/foo` into `tags/foo` and `%(refname:rstrip=-1)` turns `refs/tags/foo` into `refs`). When the ref does not have enough components, the result becomes an empty string if stripping with positive <N>, or it becomes the full refname if stripping with negative <N>.  Neither is an error."
msgstr ""

#. type: Plain text
#: en/git-for-each-ref.txt:138
#, priority:80
msgid "`strip` can be used as a synonym to `lstrip`."
msgstr ""

#. type: Labeled list
#: en/git-for-each-ref.txt:139 en/git-ls-files.txt:273 en/git-ls-tree.txt:153
#, fuzzy, no-wrap, priority:80
msgid "objecttype"
msgstr "objecttype"

#. type: Plain text
#: en/git-for-each-ref.txt:141
#, priority:80
msgid "The type of the object (`blob`, `tree`, `commit`, `tag`)."
msgstr ""

#. type: Labeled list
#: en/git-for-each-ref.txt:142
#, fuzzy, no-wrap, priority:80
msgid "objectsize"
msgstr "objectsize"

#. type: Plain text
#: en/git-for-each-ref.txt:146
#, priority:80
msgid "The size of the object (the same as 'git cat-file -s' reports).  Append `:disk` to get the size, in bytes, that the object takes up on disk. See the note about on-disk sizes in the `CAVEATS` section below."
msgstr ""

#. type: Labeled list
#: en/git-for-each-ref.txt:146 en/git-ls-files.txt:275 en/git-ls-tree.txt:155
#, fuzzy, no-wrap, priority:80
msgid "objectname"
msgstr "objectname"

#. type: Plain text
#: en/git-for-each-ref.txt:152
#, priority:80
msgid "The object name (aka SHA-1).  For a non-ambiguous abbreviation of the object name append `:short`.  For an abbreviation of the object name with desired length append `:short=<length>`, where the minimum length is MINIMUM_ABBREV. The length may be exceeded to ensure unique object names."
msgstr ""

#. type: Labeled list
#: en/git-for-each-ref.txt:152
#, fuzzy, no-wrap, priority:80
msgid "deltabase"
msgstr "deltabase"

#. type: Plain text
#: en/git-for-each-ref.txt:156
#, priority:80
msgid "This expands to the object name of the delta base for the given object, if it is stored as a delta.  Otherwise it expands to the null object name (all zeroes)."
msgstr ""

#. type: Labeled list
#: en/git-for-each-ref.txt:157
#, no-wrap, priority:80
msgid "upstream"
msgstr ""

#. type: Plain text
#: en/git-for-each-ref.txt:167
#, priority:80
msgid "The name of a local ref which can be considered ``upstream'' from the displayed ref. Respects `:short`, `:lstrip` and `:rstrip` in the same way as `refname` above.  Additionally respects `:track` to show \"[ahead N, behind M]\" and `:trackshort` to show the terse version: \">\" (ahead), \"<\" (behind), \"<>\" (ahead and behind), or \"=\" (in sync). `:track` also prints \"[gone]\" whenever unknown upstream ref is encountered. Append `:track,nobracket` to show tracking information without brackets (i.e \"ahead N, behind M\")."
msgstr ""

#. type: Plain text
#: en/git-for-each-ref.txt:174
#, priority:80
msgid "For any remote-tracking branch `%(upstream)`, `%(upstream:remotename)` and `%(upstream:remoteref)` refer to the name of the remote and the name of the tracked remote ref, respectively. In other words, the remote-tracking branch can be updated explicitly and individually by using the refspec `%(upstream:remoteref):%(upstream)` to fetch from `%(upstream:remotename)`."
msgstr ""

#. type: Plain text
#: en/git-for-each-ref.txt:178
#, priority:80
msgid "Has no effect if the ref does not have tracking information associated with it.  All the options apart from `nobracket` are mutually exclusive, but if used together the last option is selected."
msgstr ""

#. type: Labeled list
#: en/git-for-each-ref.txt:179
#, fuzzy, no-wrap, priority:80
msgid "push"
msgstr "push"

#. type: Plain text
#: en/git-for-each-ref.txt:185
#, priority:80
msgid "The name of a local ref which represents the `@{push}` location for the displayed ref. Respects `:short`, `:lstrip`, `:rstrip`, `:track`, `:trackshort`, `:remotename`, and `:remoteref` options as `upstream` does. Produces an empty string if no `@{push}` ref is configured."
msgstr ""

#. type: Labeled list
#: en/git-for-each-ref.txt:186 en/git.txt:427
#, fuzzy, no-wrap, priority:100
msgid "HEAD"
msgstr "标题"

#. type: Plain text
#: en/git-for-each-ref.txt:189
#, priority:80
msgid "'*' if HEAD matches current ref (the checked out branch), ' ' otherwise."
msgstr ""

#. type: Plain text
#: en/git-for-each-ref.txt:195
#, priority:80
msgid "Change output color. Followed by `:<colorname>`, where color names are described under Values in the \"CONFIGURATION FILE\" section of linkgit:git-config[1].  For example, `%(color:bold red)`."
msgstr ""

#. type: Labeled list
#: en/git-for-each-ref.txt:196
#, fuzzy, no-wrap, priority:80
msgid "align"
msgstr "对齐"

#. type: Plain text
#: en/git-for-each-ref.txt:210
#, ignore-ellipsis, priority:80
msgid "Left-, middle-, or right-align the content between %(align:...) and %(end). The \"align:\" is followed by `width=<width>` and `position=<position>` in any order separated by a comma, where the `<position>` is either left, right or middle, default being left and `<width>` is the total length of the content with alignment. For brevity, the \"width=\" and/or \"position=\" prefixes may be omitted, and bare <width> and <position> used instead.  For instance, `%(align:<width>,<position>)`. If the contents length is more than the width then no alignment is performed. If used with `--quote` everything in between %(align:...) and %(end) is quoted, but if nested then only the topmost level performs quoting."
msgstr ""

#. type: Labeled list
#: en/git-for-each-ref.txt:211
#, fuzzy, no-wrap, priority:80
msgid "if"
msgstr "如果"

#. type: Plain text
#: en/git-for-each-ref.txt:223
#, ignore-ellipsis, priority:80
msgid "Used as %(if)...%(then)...%(end) or %(if)...%(then)...%(else)...%(end).  If there is an atom with value or string literal after the %(if) then everything after the %(then) is printed, else if the %(else) atom is used, then everything after %(else) is printed. We ignore space when evaluating the string before %(then), this is useful when we use the %(HEAD) atom which prints either \"*\" or \" \" and we want to apply the 'if' condition only on the 'HEAD' ref.  Append \":equals=<string>\" or \":notequals=<string>\" to compare the value between the %(if:...) and %(then) atoms with the given string."
msgstr ""

#. type: Labeled list
#: en/git-for-each-ref.txt:224
#, fuzzy, no-wrap, priority:80
msgid "symref"
msgstr "symref"

#. type: Plain text
#: en/git-for-each-ref.txt:229
#, priority:80
msgid "The ref which the given symbolic ref refers to. If not a symbolic ref, nothing is printed. Respects the `:short`, `:lstrip` and `:rstrip` options in the same way as `refname` above."
msgstr ""

#. type: Labeled list
#: en/git-for-each-ref.txt:230
#, fuzzy, no-wrap, priority:80
#| msgid "--show-signature"
msgid "signature"
msgstr "--show-signature"

#. type: Plain text
#: en/git-for-each-ref.txt:232
#, fuzzy, priority:80
#| msgid "Check the GPG signature of commits."
msgid "The GPG signature of a commit."
msgstr "检查提交的GPG签名。"

#. type: Labeled list
#: en/git-for-each-ref.txt:233
#, no-wrap, priority:80
msgid "signature:grade"
msgstr ""

#. type: Plain text
#: en/git-for-each-ref.txt:240
#, fuzzy, priority:80
#| msgid "show \"G\" for a good (valid) signature, \"B\" for a bad signature, \"U\" for a good signature with unknown validity, \"X\" for a good signature that has expired, \"Y\" for a good signature made by an expired key, \"R\" for a good signature made by a revoked key, \"E\" if the signature cannot be checked (e.g. missing key)  and \"N\" for no signature"
msgid "Show \"G\" for a good (valid) signature, \"B\" for a bad signature, \"U\" for a good signature with unknown validity, \"X\" for a good signature that has expired, \"Y\" for a good signature made by an expired key, \"R\" for a good signature made by a revoked key, \"E\" if the signature cannot be checked (e.g. missing key) and \"N\" for no signature."
msgstr "显示 \"G \"代表一个好的（有效的）签名，\"B \"代表一个坏的签名，\"U \"代表一个有效性未知的好的签名，\"X \"代表一个已经过期的好的签名，\"Y \"代表一个由过期的钥匙制作的好的签名，\"R \"代表一个由撤销的钥匙制作的好的签名，\"E \"如果不能检查签名（如缺少钥匙），\"N \"代表没有签名。"

#. type: Labeled list
#: en/git-for-each-ref.txt:241
#, fuzzy, no-wrap, priority:80
msgid "signature:signer"
msgstr "--[no-]signature=<signature>"

#. type: Plain text
#: en/git-for-each-ref.txt:243
#, fuzzy, priority:80
#| msgid "Check the GPG signature of commits."
msgid "The signer of the GPG signature of a commit."
msgstr "检查提交的GPG签名。"

#. type: Labeled list
#: en/git-for-each-ref.txt:244
#, fuzzy, no-wrap, priority:80
#| msgid "--show-signature"
msgid "signature:key"
msgstr "--show-signature"

#. type: Plain text
#: en/git-for-each-ref.txt:246
#, fuzzy, priority:80
#| msgid "Check the GPG signature of commits."
msgid "The key of the GPG signature of a commit."
msgstr "检查提交的GPG签名。"

#. type: Labeled list
#: en/git-for-each-ref.txt:247
#, no-wrap, priority:80
msgid "signature:fingerprint"
msgstr ""

#. type: Plain text
#: en/git-for-each-ref.txt:249
#, fuzzy, priority:80
#| msgid "Check the GPG signature of commits."
msgid "The fingerprint of the GPG signature of a commit."
msgstr "检查提交的GPG签名。"

#. type: Labeled list
#: en/git-for-each-ref.txt:250
#, no-wrap, priority:80
msgid "signature:primarykeyfingerprint"
msgstr ""

#. type: Plain text
#: en/git-for-each-ref.txt:252
#, fuzzy, priority:80
#| msgid "Check the GPG signature of commits."
msgid "The primary key fingerprint of the GPG signature of a commit."
msgstr "检查提交的GPG签名。"

#. type: Labeled list
#: en/git-for-each-ref.txt:253
#, no-wrap, priority:80
msgid "signature:trustlevel"
msgstr ""

#. type: Plain text
#: en/git-for-each-ref.txt:256
#, priority:80
msgid "The trust level of the GPG signature of a commit. Possible outputs are `ultimate`, `fully`, `marginal`, `never` and `undefined`."
msgstr ""

#. type: Labeled list
#: en/git-for-each-ref.txt:257
#, no-wrap, priority:80
msgid "worktreepath"
msgstr ""

#. type: Plain text
#: en/git-for-each-ref.txt:261
#, priority:80
msgid "The absolute path to the worktree in which the ref is checked out, if it is checked out in any linked worktree. Empty string otherwise."
msgstr ""

#. type: Labeled list
#: en/git-for-each-ref.txt:262
#, fuzzy, no-wrap, priority:80
#| msgid "--ahead-behind"
msgid "ahead-behind:<committish>"
msgstr "--ahead-behind"

#. type: Plain text
#: en/git-for-each-ref.txt:266
#, priority:80
msgid "Two integers, separated by a space, demonstrating the number of commits ahead and behind, respectively, when comparing the output ref to the `<committish>` specified in the format."
msgstr ""

#. type: Labeled list
#: en/git-for-each-ref.txt:267
#, fuzzy, no-wrap, priority:80
#| msgid "'%(describe[:options])'"
msgid "describe[:options]"
msgstr "'%(description[:options])'"

#. type: Plain text
#: en/git-for-each-ref.txt:271
#, fuzzy, priority:80
#| msgid "human-readable name, like linkgit:git-describe[1]; empty string for undescribable commits.  The `describe` string may be followed by a colon and zero or more comma-separated options.  Descriptions can be inconsistent when tags are added or removed at the same time."
msgid "A human-readable name, like linkgit:git-describe[1]; empty string for undescribable commits. The `describe` string may be followed by a colon and one or more comma-separated options."
msgstr "人类可读的名字，像linkgit:git-describe[1]；空字符串表示不可描述的提交。  `describe`字符串后面可以有冒号和零个或多个逗号分隔的选项。  当标签同时被添加或删除时，描述可能不一致。"

#. type: Labeled list
#: en/git-for-each-ref.txt:273
#, no-wrap, priority:80
msgid "tags=<bool-value>"
msgstr ""

#. type: Plain text
#: en/git-for-each-ref.txt:277
#, fuzzy, priority:80
#| msgid "'tags[=<bool-value>]': Instead of only considering annotated tags, consider lightweight tags as well."
msgid "Instead of only considering annotated tags, consider lightweight tags as well; see the corresponding option in linkgit:git-describe[1] for details."
msgstr "'tags[=<bool-value>]'：不仅考虑带注释的标签，还考虑轻量级标签。"

#. type: Labeled list
#: en/git-for-each-ref.txt:277
#, fuzzy, no-wrap, priority:80
msgid "abbrev=<number>"
msgstr "--abbrev=<n>"

#. type: Plain text
#: en/git-for-each-ref.txt:280
#, fuzzy, priority:80
#| msgid "If true, this is equivalent to the --verify-signatures command line option. See linkgit:git-merge[1] for details."
msgid "Use at least <number> hexadecimal digits; see the corresponding option in linkgit:git-describe[1] for details."
msgstr "如果为真，这等同于 --verify-signatures 命令行选项。详见 linkgit:git-merge[1]。"

#. type: Labeled list
#: en/git-for-each-ref.txt:280
#, fuzzy, no-wrap, priority:80
#| msgid "--match <pattern>"
msgid "match=<pattern>"
msgstr "--match <pattern>"

#. type: Plain text
#: en/git-for-each-ref.txt:284
#, fuzzy, priority:80
#| msgid "'match=<pattern>': Only consider tags matching the given `glob(7)` pattern, excluding the \"refs/tags/\" prefix."
msgid "Only consider tags matching the given `glob(7)` pattern, excluding the \"refs/tags/\" prefix; see the corresponding option in linkgit:git-describe[1] for details."
msgstr "'match=<pattern>':只考虑与给定的`glob(7)`模式匹配的标签，不包括 \"refs/tags/\"前缀。"

#. type: Labeled list
#: en/git-for-each-ref.txt:284
#, fuzzy, no-wrap, priority:80
msgid "exclude=<pattern>"
msgstr "--exclude=<pattern>"

#. type: Plain text
#: en/git-for-each-ref.txt:288
#, fuzzy, priority:80
#| msgid "'exclude=<pattern>': Do not consider tags matching the given `glob(7)` pattern, excluding the \"refs/tags/\" prefix."
msgid "Do not consider tags matching the given `glob(7)` pattern, excluding the \"refs/tags/\" prefix; see the corresponding option in linkgit:git-describe[1] for details."
msgstr "'exclude=<pattern>':不考虑匹配给定`glob(7)`模式的标签，排除 \"refs/tags/\"前缀。"

#. type: Plain text
#: en/git-for-each-ref.txt:295
#, priority:80
msgid "In addition to the above, for commit and tag objects, the header field names (`tree`, `parent`, `object`, `type`, and `tag`) can be used to specify the value in the header field.  Fields `tree` and `parent` can also be used with modifier `:short` and `:short=<length>` just like `objectname`."
msgstr ""

#. type: Plain text
#: en/git-for-each-ref.txt:300
#, priority:80
msgid "For commit and tag objects, the special `creatordate` and `creator` fields will correspond to the appropriate date or name-email-date tuple from the `committer` or `tagger` fields depending on the object type.  These are intended for working on a mix of annotated and lightweight tags."
msgstr ""

#. type: Plain text
#: en/git-for-each-ref.txt:307
#, priority:80
msgid "Fields that have name-email-date tuple as its value (`author`, `committer`, and `tagger`) can be suffixed with `name`, `email`, and `date` to extract the named component.  For email fields (`authoremail`, `committeremail` and `taggeremail`), `:trim` can be appended to get the email without angle brackets, and `:localpart` to get the part before the `@` symbol out of the trimmed email."
msgstr ""

#. type: Plain text
#: en/git-for-each-ref.txt:309
#, priority:80
msgid "The raw data in an object is `raw`."
msgstr ""

#. type: Labeled list
#: en/git-for-each-ref.txt:310
#, no-wrap, priority:80
msgid "raw:size"
msgstr ""

#. type: Plain text
#: en/git-for-each-ref.txt:312
#, priority:80
msgid "The raw data size of the object."
msgstr ""

#. type: Plain text
#: en/git-for-each-ref.txt:316
#, priority:80
msgid "Note that `--format=%(raw)` can not be used with `--python`, `--shell`, `--tcl`, because such language may not support arbitrary binary data in their string variable type."
msgstr ""

#. type: Plain text
#: en/git-for-each-ref.txt:319
#, priority:80
msgid "The message in a commit or a tag object is `contents`, from which `contents:<part>` can be used to extract various parts out of:"
msgstr ""

#. type: Labeled list
#: en/git-for-each-ref.txt:320
#, fuzzy, no-wrap, priority:80
msgid "contents:size"
msgstr "contents:size"

#. type: Plain text
#: en/git-for-each-ref.txt:322
#, priority:80
msgid "The size in bytes of the commit or tag message."
msgstr ""

#. type: Labeled list
#: en/git-for-each-ref.txt:323
#, no-wrap, priority:80
msgid "contents:subject"
msgstr ""

#. type: Plain text
#: en/git-for-each-ref.txt:330
#, priority:80
msgid "The first paragraph of the message, which typically is a single line, is taken as the \"subject\" of the commit or the tag message.  Instead of `contents:subject`, field `subject` can also be used to obtain same results. `:sanitize` can be appended to `subject` for subject line suitable for filename."
msgstr ""

#. type: Labeled list
#: en/git-for-each-ref.txt:331
#, no-wrap, priority:80
msgid "contents:body"
msgstr ""

#. type: Plain text
#: en/git-for-each-ref.txt:334
#, priority:80
msgid "The remainder of the commit or the tag message that follows the \"subject\"."
msgstr ""

#. type: Labeled list
#: en/git-for-each-ref.txt:335
#, no-wrap, priority:80
msgid "contents:signature"
msgstr ""

#. type: Plain text
#: en/git-for-each-ref.txt:337
#, priority:80
msgid "The optional GPG signature of the tag."
msgstr "tag的可选GPG签名。"

#. type: Labeled list
#: en/git-for-each-ref.txt:338
#, fuzzy, no-wrap, priority:80
#| msgid "--comment-lines"
msgid "contents:lines=N"
msgstr "contents:lines=N"

#. type: Plain text
#: en/git-for-each-ref.txt:340
#, priority:80
msgid "The first `N` lines of the message."
msgstr ""

#. type: Plain text
#: en/git-for-each-ref.txt:345
#, priority:80
msgid "Additionally, the trailers as interpreted by linkgit:git-interpret-trailers[1] are obtained as `trailers[:options]` (or by using the historical alias `contents:trailers[:options]`). For valid [:option] values see `trailers` section of linkgit:git-log[1]."
msgstr ""

#. type: Plain text
#: en/git-for-each-ref.txt:349
#, priority:80
msgid "For sorting purposes, fields with numeric values sort in numeric order (`objectsize`, `authordate`, `committerdate`, `creatordate`, `taggerdate`).  All other fields are used to sort in their byte-value order."
msgstr ""

#. type: Plain text
#: en/git-for-each-ref.txt:352
#, priority:80
msgid "There is also an option to sort by versions, this can be done by using the fieldname `version:refname` or its alias `v:refname`."
msgstr ""

#. type: Plain text
#: en/git-for-each-ref.txt:356
#, priority:80
msgid "In any case, a field name that refers to a field inapplicable to the object referred by the ref does not cause an error.  It returns an empty string instead."
msgstr ""

#. type: Plain text
#: en/git-for-each-ref.txt:360
#, priority:80
msgid "As a special case for the date-type fields, you may specify a format for the date by adding `:` followed by date format name (see the values the `--date` option to linkgit:git-rev-list[1] takes)."
msgstr ""

#. type: Plain text
#: en/git-for-each-ref.txt:363
#, priority:80
msgid "Some atoms like %(align) and %(if) always require a matching %(end).  We call them \"opening atoms\" and sometimes denote them as %($open)."
msgstr ""

#. type: Plain text
#: en/git-for-each-ref.txt:368
#, priority:80
msgid "When a scripting language specific quoting is in effect, everything between a top-level opening atom and its matching %(end) is evaluated according to the semantics of the opening atom and only its result from the top-level is quoted."
msgstr ""

#. type: Plain text
#: en/git-for-each-ref.txt:375
#, priority:80
msgid "An example directly producing formatted text.  Show the most recent 3 tagged commits:"
msgstr ""

#. type: delimited block -
#: en/git-for-each-ref.txt:378 en/git-for-each-ref.txt:394 en/git-for-each-ref.txt:408 en/git-bisect-lk2009.txt:933
#, fuzzy, no-wrap, priority:100
msgid "#!/bin/sh\n"
msgstr "#!/bin/sh\n"

#. type: delimited block -
#: en/git-for-each-ref.txt:384
#, no-wrap, priority:80
msgid ""
"git for-each-ref --count=3 --sort='-*authordate' \\\n"
"--format='From: %(*authorname) %(*authoremail)\n"
"Subject: %(*subject)\n"
"Date: %(*authordate)\n"
"Ref: %(*refname)\n"
msgstr ""

#. type: delimited block -
#: en/git-for-each-ref.txt:387
#, fuzzy, no-wrap, priority:80
msgid ""
"%(*body)\n"
"' 'refs/tags'\n"
msgstr ""
"%(*body)\n"
"' 'refs/tags'\n"

#. type: Plain text
#: en/git-for-each-ref.txt:392
#, priority:80
msgid "A simple example showing the use of shell eval on the output, demonstrating the use of --shell.  List the prefixes of all heads:"
msgstr ""

#. type: delimited block -
#: en/git-for-each-ref.txt:401
#, fuzzy, no-wrap, priority:80
msgid ""
"git for-each-ref --shell --format=\"ref=%(refname)\" refs/heads | \\\n"
"while read entry\n"
"do\n"
"\teval \"$entry\"\n"
"\techo `dirname $ref`\n"
"done\n"
msgstr ""
"git for-each-ref --shell --format=\"ref=%(refname)\" refs/heads | \\\n"
"while read entry\n"
"do\n"
"\teval \"$entry\"\n"
"\techo `dirname $ref`\n"
"done\n"

#. type: Plain text
#: en/git-for-each-ref.txt:406
#, priority:80
msgid "A bit more elaborate report on tags, demonstrating that the format may be an entire script:"
msgstr ""

#. type: delimited block -
#: en/git-for-each-ref.txt:413
#, no-wrap, priority:80
msgid ""
"fmt='\n"
"\tr=%(refname)\n"
"\tt=%(*objecttype)\n"
"\tT=${r#refs/tags/}\n"
msgstr ""

#. type: delimited block -
#: en/git-for-each-ref.txt:420
#, fuzzy, no-wrap, priority:80
msgid ""
"\to=%(*objectname)\n"
"\tn=%(*authorname)\n"
"\te=%(*authoremail)\n"
"\ts=%(*subject)\n"
"\td=%(*authordate)\n"
"\tb=%(*body)\n"
msgstr ""
"\to=%(*objectname)\n"
"\tn=%(*authorname)\n"
"\te=%(*authoremail)\n"
"\ts=%(*subject)\n"
"\td=%(*authordate)\n"
"\tb=%(*body)\n"

#. type: delimited block -
#: en/git-for-each-ref.txt:439
#, no-wrap, priority:80
msgid ""
"\tkind=Tag\n"
"\tif test \"z$t\" = z\n"
"\tthen\n"
"\t\t# could be a lightweight tag\n"
"\t\tt=%(objecttype)\n"
"\t\tkind=\"Lightweight tag\"\n"
"\t\to=%(objectname)\n"
"\t\tn=%(authorname)\n"
"\t\te=%(authoremail)\n"
"\t\ts=%(subject)\n"
"\t\td=%(authordate)\n"
"\t\tb=%(body)\n"
"\tfi\n"
"\techo \"$kind $T points at a $t object $o\"\n"
"\tif test \"z$t\" = zcommit\n"
"\tthen\n"
"\t\techo \"The commit was authored by $n $e\n"
"at $d, and titled\n"
msgstr ""

#. type: delimited block -
#: en/git-for-each-ref.txt:441
#, no-wrap, priority:80
msgid "    $s\n"
msgstr ""

#. type: delimited block -
#: en/git-for-each-ref.txt:448
#, no-wrap, priority:80
msgid ""
"Its message reads as:\n"
"\"\n"
"\t\techo \"$b\" | sed -e \"s/^/    /\"\n"
"\t\techo\n"
"\tfi\n"
"'\n"
msgstr ""

#. type: delimited block -
#: en/git-for-each-ref.txt:454
#, no-wrap, priority:80
msgid ""
"eval=`git for-each-ref --shell --format=\"$fmt\" \\\n"
"\t--sort='*objecttype' \\\n"
"\t--sort=-taggerdate \\\n"
"\trefs/tags`\n"
"eval \"$eval\"\n"
msgstr ""

#. type: Plain text
#: en/git-for-each-ref.txt:459
#, ignore-ellipsis, priority:80
msgid "An example to show the usage of %(if)...%(then)...%(else)...%(end).  This prefixes the current branch with a star."
msgstr ""

#. type: delimited block -
#: en/git-for-each-ref.txt:462
#, fuzzy, no-wrap, priority:80
msgid "git for-each-ref --format=\"%(if)%(HEAD)%(then)* %(else)  %(end)%(refname:short)\" refs/heads/\n"
msgstr "git for-each-ref --format=\"%(if)%(HEAD)%(then)* %(else)  %(end)%(refname:short)\" refs/heads/\n"

#. type: Plain text
#: en/git-for-each-ref.txt:467
#, ignore-ellipsis, priority:80
msgid "An example to show the usage of %(if)...%(then)...%(end).  This prints the authorname, if present."
msgstr ""

#. type: delimited block -
#: en/git-for-each-ref.txt:470
#, fuzzy, no-wrap, priority:80
msgid "git for-each-ref --format=\"%(refname)%(if)%(authorname)%(then) Authored by: %(authorname)%(end)\"\n"
msgstr "git for-each-ref --format=\"%(refname)%(if)%(authorname)%(then) Authored by: %(authorname)%(end)\"\n"

#. type: Title =
#: en/git-format-patch.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-format-patch(1)"
msgstr "git-format-patch(1)"

#. type: Plain text
#: en/git-format-patch.txt:7
#, priority:100
msgid "git-format-patch - Prepare patches for e-mail submission"
msgstr "git-format-patch - 为提交电子邮件准备补丁"

#. type: Plain text
#: en/git-format-patch.txt:35
#, fuzzy, no-wrap, priority:100
msgid ""
"'git format-patch' [-k] [(-o|--output-directory) <dir> | --stdout]\n"
"\t\t   [--no-thread | --thread[=<style>]]\n"
"\t\t   [(--attach|--inline)[=<boundary>] | --no-attach]\n"
"\t\t   [-s | --signoff]\n"
"\t\t   [--signature=<signature> | --no-signature]\n"
"\t\t   [--signature-file=<file>]\n"
"\t\t   [-n | --numbered | -N | --no-numbered]\n"
"\t\t   [--start-number <n>] [--numbered-files]\n"
"\t\t   [--in-reply-to=<message id>] [--suffix=.<sfx>]\n"
"\t\t   [--ignore-if-in-upstream] [--always]\n"
"\t\t   [--cover-from-description=<mode>]\n"
"\t\t   [--rfc] [--subject-prefix=<subject prefix>]\n"
"\t\t   [(--reroll-count|-v) <n>]\n"
"\t\t   [--to=<email>] [--cc=<email>]\n"
"\t\t   [--[no-]cover-letter] [--quiet]\n"
"\t\t   [--[no-]encode-email-headers]\n"
"\t\t   [--no-notes | --notes[=<ref>]]\n"
"\t\t   [--interdiff=<previous>]\n"
"\t\t   [--range-diff=<previous> [--creation-factor=<percent>]]\n"
"\t\t   [--filename-max-length=<n>]\n"
"\t\t   [--progress]\n"
"\t\t   [<common diff options>]\n"
"\t\t   [ <since> | <revision range> ]\n"
msgstr ""
"'git format-patch' [-k] [(-o|--output-directory) <dir> | --stdout]\n"
"\t\t   [--no-thread | --thread[=<风格>]]\n"
"\t\t   [(--attach|--inline)[=<boundary>] | --no-attach]\n"
"\t\t   [-s | --signoff]\n"
"\t\t   [--signature=<signature> | --no-signature]\n"
"\t\t   [--signature-file=<file>]\n"
"\t\t   [-n | --numbered | -N | --no-numbered]\n"
"\t\t   [--start-number <n>] [--numbered-files]\n"
"\t\t   [--in-reply-to=<message id>] [--suffix=.<sfx>]\n"
"\t\t   [--ignore-if-in-upstream] [--always]\n"
"\t\t   [--cover-from-description=<模式>]\n"
"\t\t   [--rfc] [--subject-prefix=<subject prefix>]\n"
"\t\t   [(--reroll-count|-v) <n>]\n"
"\t\t   [--to=<e-mail>] [--cc=<e-mail>]\n"
"\t\t   [--[no-]cover-letter] [--quiet]\n"
"\t\t   [--[no-]encode-email-headers]\n"
"\t\t   [--no-notes | --notes[=<引用>]]\n"
"\t\t   [--interdiff=<previous>]\n"
"\t\t   [--range-diff=<previous> [--creation-factor=<percent>]]\n"
"\t\t   [--filename-max-length=<n>]\n"
"\t\t   [--progress]\n"
"\t\t   [<common diff options>]\n"
"\t\t   [ <since> | <revision range> ]\n"

#. type: Plain text
#: en/git-format-patch.txt:43
#, priority:100
msgid "Prepare each non-merge commit with its \"patch\" in one \"message\" per commit, formatted to resemble a UNIX mailbox.  The output of this command is convenient for e-mail submission or for use with 'git am'."
msgstr "将每个非合并提交及其 “补丁” 准备在每个提交的一个 “消息” 中，格式类似于 UNIX 邮箱。 这条命令的输出便于提交电子邮件或与 \"git am\" 一起使用。"

#. type: Plain text
#: en/git-format-patch.txt:45
#, priority:100
msgid "A \"message\" generated by the command consists of three parts:"
msgstr "命令产生的 \"信息\" 由三部分组成："

#. type: Plain text
#: en/git-format-patch.txt:52
#, priority:100
msgid "A brief metadata header that begins with `From <commit>` with a fixed `Mon Sep 17 00:00:00 2001` datestamp to help programs like \"file(1)\" to recognize that the file is an output from this command, fields that record the author identity, the author date, and the title of the change (taken from the first paragraph of the commit log message)."
msgstr "一个简短的元数据头，以 \"From <提交>\" 开始，带有固定的 \"Mon Sep 17 00:00:00 2001\" 的日期，以帮助 \"file(1)\" 等程序识别该文件是该命令的输出，记录作者身份、作者日期和修改标题的字段（取自提交日志信息的第一段）。"

#. type: Plain text
#: en/git-format-patch.txt:54
#, priority:100
msgid "The second and subsequent paragraphs of the commit log message."
msgstr "提交日志信息的第二段和后续段落。"

#. type: Plain text
#: en/git-format-patch.txt:57
#, priority:100
msgid "The \"patch\", which is the \"diff -p --stat\" output (see linkgit:git-diff[1]) between the commit and its parent."
msgstr "“补丁”，也就是该提交和其父辈之间的 \"diff -p -stat\" 输出（见 linkgit:git-diff[1]）。"

#. type: Plain text
#: en/git-format-patch.txt:60
#, priority:100
msgid "The log message and the patch is separated by a line with a three-dash line."
msgstr "日志信息和补丁之间用一行三折线分开。"

#. type: Plain text
#: en/git-format-patch.txt:62
#, priority:100
msgid "There are two ways to specify which commits to operate on."
msgstr "有两种方法可以指定要对哪些提交进行操作。"

#. type: Plain text
#: en/git-format-patch.txt:66
#, fuzzy, priority:100
msgid "A single commit, <since>, specifies that the commits leading to the tip of the current branch that are not in the history that leads to the <since> to be output."
msgstr "单一的提交，<since>，指定导致当前分支顶端的提交不在导致<since>的历史中，要被输出。"

#. type: Plain text
#: en/git-format-patch.txt:70
#, priority:100
msgid "Generic <revision range> expression (see \"SPECIFYING REVISIONS\" section in linkgit:gitrevisions[7]) means the commits in the specified range."
msgstr "通用的 <修订范围> 表达式（见 linkgit:gitrevisions[7]中的 \"指定修订\" 一节）表示指定范围内的提交。"

#. type: Plain text
#: en/git-format-patch.txt:76
#, priority:100
msgid "The first rule takes precedence in the case of a single <commit>.  To apply the second rule, i.e., format everything since the beginning of history up until <commit>, use the `--root` option: `git format-patch --root <commit>`.  If you want to format only <commit> itself, you can do this with `git format-patch -1 <commit>`."
msgstr "在只有一个 <提交> 的情况下，第一条规则具有优先权。 要应用第二条规则，即格式化从历史开始到 <提交> 为止的所有内容，使用 `--root` 选项：`git format-patch --root <提交>`。 如果你只想格式化 <提交> 本身，你可以用`git format-patch -1 <提交>`来做。"

#. type: Plain text
#: en/git-format-patch.txt:83
#, priority:100
msgid "By default, each output file is numbered sequentially from 1, and uses the first line of the commit message (massaged for pathname safety) as the filename. With the `--numbered-files` option, the output file names will only be numbers, without the first line of the commit appended.  The names of the output files are printed to standard output, unless the `--stdout` option is specified."
msgstr "默认情况下，每个输出文件从 1 开始依次编号，并使用提交信息的第一行（为保证路径名的安全而进行了调整）作为文件名。使用 `--numbered-files` 选项，输出文件名将只有数字，而没有附加提交信息的第一行。 除非指定 `--stdout` 选项，否则输出文件的名称将被打印到标准输出。"

#. type: Plain text
#: en/git-format-patch.txt:91
#, priority:100
msgid "If `-o` is specified, output files are created in <dir>.  Otherwise they are created in the current working directory. The default path can be set with the `format.outputDirectory` configuration option.  The `-o` option takes precedence over `format.outputDirectory`.  To store patches in the current working directory even when `format.outputDirectory` points elsewhere, use `-o .`. All directory components will be created."
msgstr "如果指定了 `-o`，输出文件将在<目录>创建。 否则，它们将在当前工作目录下创建。默认路径可以通过 `format.outputDirectory` 配置选项来设置。 `-o` 选项优先于 `format.outputDirectory`。 要在当前工作目录下存储补丁，即使 `format.outputDirectory` 指向其他地方，使用 `-o .`。所有的目录组件都将被创建。"

#. type: Plain text
#: en/git-format-patch.txt:95
#, priority:100
msgid "By default, the subject of a single patch is \"[PATCH] \" followed by the concatenation of lines from the commit message up to the first blank line (see the DISCUSSION section of linkgit:git-commit[1])."
msgstr "默认情况下，单个补丁的主题是 \"[PATCH]\"，后面是提交信息到第一个空行的串联（见 linkgit:git-commit[1] 的讨论部分）。"

#. type: Plain text
#: en/git-format-patch.txt:99
#, priority:100
msgid "When multiple patches are output, the subject prefix will instead be \"[PATCH n/m] \".  To force 1/1 to be added for a single patch, use `-n`.  To omit patch numbers from the subject, use `-N`."
msgstr "当输出多个补丁时，主题前缀将改为 \"[PATCH n/m] \"。 要强制为单个补丁添加 1/1，使用 `-n`。 要从主题中省略补丁编号，使用 `-N`。"

#. type: Plain text
#: en/git-format-patch.txt:104
#, priority:100
msgid "If given `--thread`, `git-format-patch` will generate `In-Reply-To` and `References` headers to make the second and subsequent patch mails appear as replies to the first mail; this also generates a `Message-ID` header to reference."
msgstr "如果给出 `--thread`，`git-format-patch` 将生成 `In-Reply-To` 和 `References` 头，使第二封和随后的补丁邮件显示为对第一封邮件的回复；这也会生成一个 `Message-ID` 头供参考。"

#. type: Labeled list
#: en/git-format-patch.txt:110
#, fuzzy, no-wrap, priority:100
msgid "-<n>"
msgstr "-<n>"

#. type: Plain text
#: en/git-format-patch.txt:112
#, priority:100
msgid "Prepare patches from the topmost <n> commits."
msgstr "从最上面的 <n> 个提交中准备补丁。"

#. type: Labeled list
#: en/git-format-patch.txt:113
#, no-wrap, priority:100
msgid "-o <dir>"
msgstr "-o <目录>"

#. type: Labeled list
#: en/git-format-patch.txt:114
#, fuzzy, no-wrap, priority:100
msgid "--output-directory <dir>"
msgstr "--output-directory <dir>"

#. type: Plain text
#: en/git-format-patch.txt:117
#, priority:100
msgid "Use <dir> to store the resulting files, instead of the current working directory."
msgstr "使用 <目录> 来存储结果文件，而不是当前工作目录。"

#. type: Labeled list
#: en/git-format-patch.txt:119 en/git-shortlog.txt:30
#, ignore-same, no-wrap, priority:260
msgid "--numbered"
msgstr "--numbered"

#. type: Plain text
#: en/git-format-patch.txt:121
#, priority:100
msgid "Name output in '[PATCH n/m]' format, even with a single patch."
msgstr "以 '[PATCH n/m]' 的格式输出名称，即使只有一个补丁。"

#. type: Labeled list
#: en/git-format-patch.txt:123
#, ignore-same, no-wrap, priority:100
msgid "--no-numbered"
msgstr "--no-numbered"

#. type: Plain text
#: en/git-format-patch.txt:125
#, priority:100
msgid "Name output in '[PATCH]' format."
msgstr "以 '[PATCH]' 格式输出名称。"

#. type: Labeled list
#: en/git-format-patch.txt:126
#, no-wrap, priority:100
msgid "--start-number <n>"
msgstr "--start-number <n>"

#. type: Plain text
#: en/git-format-patch.txt:128
#, priority:100
msgid "Start numbering the patches at <n> instead of 1."
msgstr "从<n>开始个给补丁编号，替代默认从1开始。"

#. type: Labeled list
#: en/git-format-patch.txt:129
#, ignore-same, no-wrap, priority:100
msgid "--numbered-files"
msgstr "--numbered-files"

#. type: Plain text
#: en/git-format-patch.txt:132
#, priority:100
msgid "Output file names will be a simple number sequence without the default first line of the commit appended."
msgstr "输出文件名将是一个简单的数字序列，没有附加默认的第一行提交。"

#. type: Labeled list
#: en/git-format-patch.txt:134
#, ignore-same, no-wrap, priority:100
msgid "--keep-subject"
msgstr "--keep-subject"

#. type: Plain text
#: en/git-format-patch.txt:137
#, priority:100
msgid "Do not strip/add '[PATCH]' from the first line of the commit log message."
msgstr "不要从提交日志信息的第一行剥离/添加 '[PATCH]'。"

#. type: Labeled list
#: en/git-format-patch.txt:144 en/git-pack-objects.txt:60
#, ignore-same, no-wrap, priority:100
msgid "--stdout"
msgstr "--stdout"

#. type: Plain text
#: en/git-format-patch.txt:147
#, priority:100
msgid "Print all commits to the standard output in mbox format, instead of creating a file for each one."
msgstr "以 mbox 格式将所有的提交打印到标准输出，而不是为每个提交创建一个文件。"

#. type: Labeled list
#: en/git-format-patch.txt:148
#, fuzzy, no-wrap, priority:100
msgid "--attach[=<boundary>]"
msgstr "--attach[=<boundary>]"

#. type: Plain text
#: en/git-format-patch.txt:152
#, priority:100
msgid "Create multipart/mixed attachment, the first part of which is the commit message and the patch itself in the second part, with `Content-Disposition: attachment`."
msgstr "创建多部分/混合附件，第一部分是提交信息，第二部分是补丁本身，`Content-Disposition: attachment`。"

#. type: Labeled list
#: en/git-format-patch.txt:153
#, ignore-same, no-wrap, priority:100
msgid "--no-attach"
msgstr "--no-attach"

#. type: Plain text
#: en/git-format-patch.txt:156
#, priority:100
msgid "Disable the creation of an attachment, overriding the configuration setting."
msgstr "禁用附件的创建，覆盖配置设置。"

#. type: Labeled list
#: en/git-format-patch.txt:157
#, fuzzy, no-wrap, priority:100
msgid "--inline[=<boundary>]"
msgstr "--inline[=<boundary>]"

#. type: Plain text
#: en/git-format-patch.txt:161
#, priority:100
msgid "Create multipart/mixed attachment, the first part of which is the commit message and the patch itself in the second part, with `Content-Disposition: inline`."
msgstr "创建 multipart/mixed 附件，第一部分是提交信息，第二部分是补丁本身，使用 `Content-Disposition: inline`。"

#. type: Labeled list
#: en/git-format-patch.txt:162
#, fuzzy, no-wrap, priority:100
msgid "--thread[=<style>]"
msgstr "--thread[=<style>]"

#. type: Labeled list
#: en/git-format-patch.txt:163
#, ignore-same, no-wrap, priority:100
msgid "--no-thread"
msgstr "--no-thread"

#. type: Plain text
#: en/git-format-patch.txt:168
#, priority:100
msgid "Controls addition of `In-Reply-To` and `References` headers to make the second and subsequent mails appear as replies to the first.  Also controls generation of the `Message-ID` header to reference."
msgstr "控制添加 `In-Reply-To` 和 `References` 标头，使第二封及以后的邮件显示为对第一封邮件的回复。 还控制生成 `Message-ID` 头，以便参考。"

#. type: Plain text
#: en/git-format-patch.txt:174
#, priority:100
msgid "The optional <style> argument can be either `shallow` or `deep`.  'shallow' threading makes every mail a reply to the head of the series, where the head is chosen from the cover letter, the `--in-reply-to`, and the first patch mail, in this order.  'deep' threading makes every mail a reply to the previous one."
msgstr "可选的 <风格> 参数可以是 `shallow` 或 `deep`。 ‘浅’ 线程使每封邮件都是对该系列的头的回复，其中头是从封面信、`--in-reply-to` 和第一个补丁邮件中选择的，按这个顺序。 ‘深’ 线程使每封邮件都是对前一封的回复。"

#. type: Plain text
#: en/git-format-patch.txt:177
#, priority:100
msgid "The default is `--no-thread`, unless the `format.thread` configuration is set.  `--thread` without an argument is equivalent to `--thread=shallow`."
msgstr "默认是 `--no-thread`，除非设置了 `format.thread` 配置。 没有参数的 `--thread` 等同于 `--thread=shallow`。"

#. type: Plain text
#: en/git-format-patch.txt:181
#, priority:100
msgid "Beware that the default for 'git send-email' is to thread emails itself.  If you want `git format-patch` to take care of threading, you will want to ensure that threading is disabled for `git send-email`."
msgstr "请注意，'git send-email' 的默认设置是对邮件本身进行线程处理。 如果你想让 `git format-patch` 负责线程，你要确保 `git send-email` 的线程被禁用。"

#. type: Labeled list
#: en/git-format-patch.txt:182
#, fuzzy, no-wrap, priority:100
#| msgid "--no-message-id"
msgid "--in-reply-to=<message id>"
msgstr "--in-reply-to=<message id>"

#. type: Plain text
#: en/git-format-patch.txt:186
#, priority:100
msgid "Make the first mail (or all the mails with `--no-thread`) appear as a reply to the given <message id>, which avoids breaking threads to provide a new patch series."
msgstr "使第一封邮件（或所有带有 `--no-thread` 的邮件）作为给定的 <消息 id> 的回复出现，这可以避免破坏线程以提供一个新的补丁系列。"

#. type: Labeled list
#: en/git-format-patch.txt:187
#, ignore-same, no-wrap, priority:100
msgid "--ignore-if-in-upstream"
msgstr "--ignore-if-in-upstream"

#. type: Plain text
#: en/git-format-patch.txt:193
#, priority:100
msgid "Do not include a patch that matches a commit in <until>..<since>.  This will examine all patches reachable from <since> but not from <until> and compare them with the patches being generated, and any patch that matches is ignored."
msgstr "不包括与 <until>...<since> 中的提交相匹配的补丁。 这将检查所有可从 <since> 到达但不在 <until> 的补丁，并将它们与正在生成的补丁进行比较，任何匹配的补丁都将被忽略。"

#. type: Plain text
#: en/git-format-patch.txt:197
#, priority:100
msgid "Include patches for commits that do not introduce any change, which are omitted by default."
msgstr "包括那些没有引入任何变化的提交的补丁，这些补丁默认是省略的。"

#. type: Labeled list
#: en/git-format-patch.txt:198
#, fuzzy, no-wrap, priority:100
#| msgid "--edit-description"
msgid "--cover-from-description=<mode>"
msgstr "--cover-from-description=<mode>"

#. type: Plain text
#: en/git-format-patch.txt:201
#, priority:100
msgid "Controls which parts of the cover letter will be automatically populated using the branch's description."
msgstr "控制求职信的哪些部分将使用分支机构的描述自动填充。"

#. type: Plain text
#: en/git-format-patch.txt:206
#, priority:100
msgid "If `<mode>` is `message` or `default`, the cover letter subject will be populated with placeholder text. The body of the cover letter will be populated with the branch's description. This is the default mode when no configuration nor command line option is specified."
msgstr "如果 `<模式>` 是 `message` 或 `default`，求职信的主题将被填充为占位符文本。信函的正文将被填入分支的描述。这是没有指定配置或命令行选项时的默认模式。"

#. type: Plain text
#: en/git-format-patch.txt:210
#, priority:100
msgid "If `<mode>` is `subject`, the first paragraph of the branch description will populate the cover letter subject. The remainder of the description will populate the body of the cover letter."
msgstr "如果 `<模式>` 是 `subject`，分支描述的第一段将填入求职信的主题。描述的其余部分将填充到求职信的正文中。"

#. type: Plain text
#: en/git-format-patch.txt:214
#, priority:100
msgid "If `<mode>` is `auto`, if the first paragraph of the branch description is greater than 100 bytes, then the mode will be `message`, otherwise `subject` will be used."
msgstr "如果 `<模式>` 是 `auto`，如果分支描述的第一段大于100字节，那么模式将是 `message`，否则将使用 `subject`。"

#. type: Plain text
#: en/git-format-patch.txt:217
#, priority:100
msgid "If `<mode>` is `none`, both the cover letter subject and body will be populated with placeholder text."
msgstr "如果 `<模式>` 为 `none`，求职信的主题和正文都将被填充为占位符文本。"

#. type: Labeled list
#: en/git-format-patch.txt:218
#, fuzzy, no-wrap, priority:100
msgid "--subject-prefix=<subject prefix>"
msgstr "--subject-prefix=<subject prefix>"

#. type: Plain text
#: en/git-format-patch.txt:223
#, priority:100
msgid "Instead of the standard '[PATCH]' prefix in the subject line, instead use '[<subject prefix>]'. This allows for useful naming of a patch series, and can be combined with the `--numbered` option."
msgstr "在主题行中不要使用标准的 '[PATCH]' 前缀，而要使用 '[<subject prefix>]'。这允许对一个补丁系列进行有用的命名，并可以与 `--numbered` 选项结合使用。"

#. type: Labeled list
#: en/git-format-patch.txt:224
#, no-wrap, priority:100
msgid "--filename-max-length=<n>"
msgstr "--filename-max-length=<n>"

#. type: Plain text
#: en/git-format-patch.txt:230
#, priority:100
msgid "Instead of the standard 64 bytes, chomp the generated output filenames at around '<n>' bytes (too short a value will be silently raised to a reasonable length).  Defaults to the value of the `format.filenameMaxLength` configuration variable, or 64 if unconfigured."
msgstr "代替标准的 64 字节，将生成的输出文件名压缩到 '<n>' 字节左右（太短的值会被默默提升到合理的长度）。 默认为 `format.filenameMaxLength` 配置变量的值，如果没有配置，则为 64。"

#. type: Labeled list
#: en/git-format-patch.txt:231
#, ignore-same, no-wrap, priority:100
msgid "--rfc"
msgstr "--rfc"

#. type: Plain text
#: en/git-format-patch.txt:235
#, priority:100
msgid "Alias for `--subject-prefix=\"RFC PATCH\"`. RFC means \"Request For Comments\"; use this when sending an experimental patch for discussion rather than application."
msgstr "`--subject-prefix=\"RFC PATCH\"` 的别名。RFC 的意思是 \"Request For Comments\"；在发送实验性补丁供讨论而非应用时使用。"

#. type: Labeled list
#: en/git-format-patch.txt:236
#, fuzzy, no-wrap, priority:100
msgid "-v <n>"
msgstr "-v <n>"

#. type: Labeled list
#: en/git-format-patch.txt:237
#, fuzzy, no-wrap, priority:100
msgid "--reroll-count=<n>"
msgstr "--reroll-count=<n>"

#. type: Plain text
#: en/git-format-patch.txt:249
#, fuzzy, priority:100
#| msgid "Mark the series as the <n>-th iteration of the topic. The output filenames have `v<n>` prepended to them, and the subject prefix (\"PATCH\" by default, but configurable via the `--subject-prefix` option) has ` v<n>` appended to it.  E.g.  `--reroll-count=4` may produce `v4-0001-add-makefile.patch` file that has \"Subject: [PATCH v4 1/20] Add makefile\" in it.  `<n>` does not have to be an integer (e.g. \"--reroll-count=4.4\", or \"--reroll-count=4rev2\" are allowed), but the downside of using such a reroll-count is that the range-diff/interdiff with the previous version does not state exactly which version the new interation is compared against."
msgid "Mark the series as the <n>-th iteration of the topic. The output filenames have `v<n>` prepended to them, and the subject prefix (\"PATCH\" by default, but configurable via the `--subject-prefix` option) has ` v<n>` appended to it.  E.g.  `--reroll-count=4` may produce `v4-0001-add-makefile.patch` file that has \"Subject: [PATCH v4 1/20] Add makefile\" in it.  `<n>` does not have to be an integer (e.g. \"--reroll-count=4.4\", or \"--reroll-count=4rev2\" are allowed), but the downside of using such a reroll-count is that the range-diff/interdiff with the previous version does not state exactly which version the new iteration is compared against."
msgstr "将该系列标记为该主题的第 <n> 次迭代。输出的文件名有 `v<n>`，主题前缀（默认为 \"PATCH\"，但可通过 `--subject-prefix` 选项配置）有 `v<n>` 附加在上面。 例如，`--reroll-count=4` 可能产生 `v4-0001-add-makefile.patch` 文件，其中有 \"Subject： [PATCH v4 1/20] Add makefile\"。 `<n>` 不一定是整数（例如，\"--reroll-count=4.4\"，或 \"--reroll-count=4rev2 \"都可以），但使用这种 reroll-count 的缺点是，与前一版本的 range-diff/interdiff 并没有准确说明新的 interation 是与哪个版本比较。"

#. type: Labeled list
#: en/git-format-patch.txt:250
#, no-wrap, priority:100
msgid "--to=<email>"
msgstr "--to=<e-mail>"

#. type: Plain text
#: en/git-format-patch.txt:255
#, priority:100
msgid "Add a `To:` header to the email headers. This is in addition to any configured headers, and may be used multiple times.  The negated form `--no-to` discards all `To:` headers added so far (from config or command line)."
msgstr "在邮件标题中增加一个 `To: ` 头。这是在任何配置的头信息之外的，可以多次使用。 否定的形式 `--no-to` 会丢弃到目前为止添加的所有 `To:` 头信息（来自配置或命令行）。"

#. type: Labeled list
#: en/git-format-patch.txt:256
#, fuzzy, no-wrap, priority:100
msgid "--cc=<email>"
msgstr "--cc=<email>"

#. type: Plain text
#: en/git-format-patch.txt:261
#, priority:100
msgid "Add a `Cc:` header to the email headers. This is in addition to any configured headers, and may be used multiple times.  The negated form `--no-cc` discards all `Cc:` headers added so far (from config or command line)."
msgstr "在邮件标题中添加 `Cc: ` 标头。这是在任何配置的头信息之外的，可以多次使用。 否定的形式 `--no-cc` 会丢弃到目前为止添加的所有 `Cc:` 头信息（来自配置或命令行）。"

#. type: Labeled list
#: en/git-format-patch.txt:262
#, ignore-same, no-wrap, priority:100
msgid "--from"
msgstr "--from"

#. type: Labeled list
#: en/git-format-patch.txt:263
#, fuzzy, no-wrap, priority:100
msgid "--from=<ident>"
msgstr "--from=<ident>"

#. type: Plain text
#: en/git-format-patch.txt:269
#, priority:100
msgid "Use `ident` in the `From:` header of each commit email. If the author ident of the commit is not textually identical to the provided `ident`, place a `From:` header in the body of the message with the original author. If no `ident` is given, use the committer ident."
msgstr "在每封提交邮件的`From:` 标头中使用 `ident`。如果提交的作者身份与所提供的 `ident` 在文字上不一致，则在邮件正文中放置一个 `From: ` 头，注明原作者。如果没有给出 `ident`，则使用提交者的身份。"

#. type: Plain text
#: en/git-format-patch.txt:276
#, priority:100
msgid "Note that this option is only useful if you are actually sending the emails and want to identify yourself as the sender, but retain the original author (and `git am` will correctly pick up the in-body header). Note also that `git send-email` already handles this transformation for you, and this option should not be used if you are feeding the result to `git send-email`."
msgstr "注意，这个选项只有在你实际发送邮件时才有用，并且想把你自己确定为发件人，但保留原作者（`git am` 会正确接收正文头）。还要注意的是，`git send-email` 已经为你处理了这种转换，如果你将结果反馈给 `git send-email`，就不应该使用这个选项。"

#. type: Labeled list
#: en/git-format-patch.txt:277
#, ignore-same, no-wrap, priority:100
msgid "--[no-]force-in-body-from"
msgstr "--[no-]force-in-body-from"

#. type: Plain text
#: en/git-format-patch.txt:287
#, priority:100
msgid "With the e-mail sender specified via the `--from` option, by default, an in-body \"From:\" to identify the real author of the commit is added at the top of the commit log message if the sender is different from the author.  With this option, the in-body \"From:\" is added even when the sender and the author have the same name and address, which may help if the mailing list software mangles the sender's identity.  Defaults to the value of the `format.forceInBodyFrom` configuration variable."
msgstr "对于通过 `--from` 选项指定的电子邮件发件人，默认情况下，如果发件人与作者不同，会在提交日志信息的顶部添加一个内文 \"From:\"，以确定提交的真正作者。 有了这个选项，即使发件人和作者的名字和地址相同，也会在正文中加入 \"From：\"，这在邮件列表软件混淆发件人身份时可能会有帮助。 默认为 `format.forceInBodyFrom` 配置变量的值。"

#. type: Labeled list
#: en/git-format-patch.txt:288
#, fuzzy, no-wrap, priority:100
msgid "--add-header=<header>"
msgstr "--add-header=<header>"

#. type: Plain text
#: en/git-format-patch.txt:295
#, priority:100
msgid "Add an arbitrary header to the email headers.  This is in addition to any configured headers, and may be used multiple times.  For example, `--add-header=\"Organization: git-foo\"`.  The negated form `--no-add-header` discards *all* (`To:`, `Cc:`, and custom) headers added so far from config or command line."
msgstr "在邮件头中添加一个任意的头。 这是在任何配置的头文件之外的，并且可以多次使用。 例如，`--add-header=\"Organization: git-foo\"`。 否定的形式 `--no-add-header` 会丢弃 *所有*（`To:`, `Cc:`, 和自定义）从配置或命令行添加的头信息。"

#. type: Labeled list
#: en/git-format-patch.txt:296
#, ignore-same, no-wrap, priority:100
msgid "--[no-]cover-letter"
msgstr "--[no-]cover-letter"

#. type: Plain text
#: en/git-format-patch.txt:300
#, priority:100
msgid "In addition to the patches, generate a cover letter file containing the branch description, shortlog and the overall diffstat.  You can fill in a description in the file before sending it out."
msgstr "除了补丁之外，还要生成一个包含分支描述、短日志和整体差异状态的封面文件。 你可以在发送之前在文件中填写描述。"

#. type: Labeled list
#: en/git-format-patch.txt:301
#, ignore-same, no-wrap, priority:100
msgid "--encode-email-headers"
msgstr "--encode-email-headers"

#. type: Labeled list
#: en/git-format-patch.txt:302
#, ignore-same, no-wrap, priority:100
msgid "--no-encode-email-headers"
msgstr "--no-encode-email-headers"

#. type: Plain text
#: en/git-format-patch.txt:307
#, priority:100
msgid "Encode email headers that have non-ASCII characters with \"Q-encoding\" (described in RFC 2047), instead of outputting the headers verbatim. Defaults to the value of the `format.encodeEmailHeaders` configuration variable."
msgstr "用 \"Q-encoding\"（在RFC 2047中描述）对有非 ASCII 字符的邮件头进行编码，而不是逐字输出邮件头。默认为 `format.encodeEmailHeaders` 配置变量的值。"

#. type: Labeled list
#: en/git-format-patch.txt:308
#, fuzzy, no-wrap, priority:100
msgid "--interdiff=<previous>"
msgstr "--interdiff=<previous>"

#. type: Plain text
#: en/git-format-patch.txt:316
#, priority:100
msgid "As a reviewer aid, insert an interdiff into the cover letter, or as commentary of the lone patch of a 1-patch series, showing the differences between the previous version of the patch series and the series currently being formatted. `previous` is a single revision naming the tip of the previous series which shares a common base with the series being formatted (for example `git format-patch --cover-letter --interdiff=feature/v1 -3 feature/v2`)."
msgstr "作为审查员的帮助，在封面信中插入一个 interdiff，或者作为1个补丁系列中唯一一个补丁的注释，显示补丁系列的前一个版本与当前被格式化的系列之间的差异。`previous` 是一个单一的修订，命名了与被格式化的系列有共同基础的前一个系列的提示（例如 `git format-patch --cover-letter --interdiff=feature/v1 -3 feature/v2`）。"

#. type: Labeled list
#: en/git-format-patch.txt:317
#, fuzzy, no-wrap, priority:100
msgid "--range-diff=<previous>"
msgstr "--range-diff=<previous>"

#. type: Plain text
#: en/git-format-patch.txt:328
#, priority:100
msgid "As a reviewer aid, insert a range-diff (see linkgit:git-range-diff[1])  into the cover letter, or as commentary of the lone patch of a 1-patch series, showing the differences between the previous version of the patch series and the series currently being formatted.  `previous` can be a single revision naming the tip of the previous series if it shares a common base with the series being formatted (for example `git format-patch --cover-letter --range-diff=feature/v1 -3 feature/v2`), or a revision range if the two versions of the series are disjoint (for example `git format-patch --cover-letter --range-diff=feature/v1~3..feature/v1 -3 feature/v2`)."
msgstr "作为审查员的辅助工具，在封面信中插入一个 range-diff（见 linkgit:git-range-diff[1]），或者作为1个补丁系列中唯一一个补丁的注释，显示该补丁系列的前一个版本与当前被格式化的系列之间的差异。 `previous` 可以是一个单一的修订版，如果它与被格式化的系列有共同的基础，则命名为前一个系列的提示（例如 `git format-patch --cover-letter --range-diff=feature/v1 -3 feature/v2`），如果两个系列的版本不相干，则是一个修订范围（例如 `git format-patch --cover-letter --range-diff=feature/v1~3.feature/v1 -3 feature/v2`）。"

#. type: Plain text
#: en/git-format-patch.txt:333
#, priority:100
msgid "Note that diff options passed to the command affect how the primary product of `format-patch` is generated, and they are not passed to the underlying `range-diff` machinery used to generate the cover-letter material (this may change in the future)."
msgstr "请注意，传递给命令的差异选项会影响 `format-patch` 的主要产品如何生成，它们不会传递给用于生成封面材料的基础 `range-diff ` 机器（这在将来可能会改变）。"

#. type: Labeled list
#: en/git-format-patch.txt:334 en/git-range-diff.txt:68
#, no-wrap, priority:100
msgid "--creation-factor=<percent>"
msgstr "--creation-factor=<百分比>"

#. type: Plain text
#: en/git-format-patch.txt:339
#, priority:100
msgid "Used with `--range-diff`, tweak the heuristic which matches up commits between the previous and current series of patches by adjusting the creation/deletion cost fudge factor. See linkgit:git-range-diff[1])  for details."
msgstr "与 `--range-diff` 一起使用，通过调整创建/删除成本的模糊系数，来调整匹配上一个和当前系列补丁之间提交的启发式方法。详情见 linkgit:git-range-diff[1]）。"

#. type: Labeled list
#: en/git-format-patch.txt:340 en/pretty-options.txt:62
#, fuzzy, no-wrap, priority:260
msgid "--notes[=<ref>]"
msgstr "--notes[=<ref>]"

#. type: Labeled list
#: en/git-format-patch.txt:341 en/pretty-options.txt:83
#, ignore-same, no-wrap, priority:260
msgid "--no-notes"
msgstr "--no-notes"

#. type: Plain text
#: en/git-format-patch.txt:344
#, priority:100
msgid "Append the notes (see linkgit:git-notes[1]) for the commit after the three-dash line."
msgstr "在三折线之后添加该提交的注释（见 linkgit:git-notes[1]）。"

#. type: Plain text
#: en/git-format-patch.txt:352
#, priority:100
msgid "The expected use case of this is to write supporting explanation for the commit that does not belong to the commit log message proper, and include it with the patch submission. While one can simply write these explanations after `format-patch` has run but before sending, keeping them as Git notes allows them to be maintained between versions of the patch series (but see the discussion of the `notes.rewrite` configuration options in linkgit:git-notes[1] to use this workflow)."
msgstr "预期的用例是为提交编写不属于提交日志信息本身的支持性解释，并将其包含在补丁提交中。虽然我们可以在 `format-patch` 运行后但在发送前简单地写下这些解释，但将其保留为 Git 笔记，可以在补丁系列的不同版本之间进行维护（但要使用这种工作流程，请参考 linkgit:git-notes[1] 中关于`notes.rewrite` 配置选项的讨论）。"

#. type: Plain text
#: en/git-format-patch.txt:355
#, priority:100
msgid "The default is `--no-notes`, unless the `format.notes` configuration is set."
msgstr "默认为`--no-notes`，除非设置了 `format.notes` 配置。"

#. type: Labeled list
#: en/git-format-patch.txt:356
#, fuzzy, no-wrap, priority:100
msgid "--[no-]signature=<signature>"
msgstr "--[no-]signature=<signature>"

#. type: Plain text
#: en/git-format-patch.txt:361
#, priority:100
msgid "Add a signature to each message produced. Per RFC 3676 the signature is separated from the body by a line with '-- ' on it. If the signature option is omitted the signature defaults to the Git version number."
msgstr "给每个产生的信息添加一个签名。根据 RFC 3676，签名与正文之间用一行 '--' 分隔。如果签名选项被省略，则签名默认为 Git 版本号。"

#. type: Labeled list
#: en/git-format-patch.txt:362
#, fuzzy, no-wrap, priority:100
msgid "--signature-file=<file>"
msgstr "--signature-file=<file>"

#. type: Plain text
#: en/git-format-patch.txt:364
#, priority:100
msgid "Works just like --signature except the signature is read from a file."
msgstr "工作原理与--签名相同，只是签名是从文件中读取的。"

#. type: Labeled list
#: en/git-format-patch.txt:365
#, fuzzy, no-wrap, priority:100
msgid "--suffix=.<sfx>"
msgstr "--suffix=.<sfx>"

#. type: Plain text
#: en/git-format-patch.txt:370
#, priority:100
msgid "Instead of using `.patch` as the suffix for generated filenames, use specified suffix.  A common alternative is `--suffix=.txt`.  Leaving this empty will remove the `.patch` suffix."
msgstr "不使用 `.patch` 作为生成文件名的后缀，而使用指定的后缀。 一个常见的选择是 `--suffix=.txt`。 将此留空将删除 `.patch` 后缀。"

#. type: Plain text
#: en/git-format-patch.txt:373
#, priority:100
msgid "Note that the leading character does not have to be a dot; for example, you can use `--suffix=-patch` to get `0001-description-of-my-change-patch`."
msgstr "请注意，前导字符不一定是点；例如，你可以使用 `--suffix=-patch` 来获得 `0001-description-of-my-change-patch`。"

#. type: Plain text
#: en/git-format-patch.txt:377
#, priority:100
msgid "Do not print the names of the generated files to standard output."
msgstr "不要将生成的文件名打印到标准输出。"

#. type: Labeled list
#: en/git-format-patch.txt:378
#, ignore-same, no-wrap, priority:100
msgid "--no-binary"
msgstr "--no-binary"

#. type: Plain text
#: en/git-format-patch.txt:383
#, priority:100
msgid "Do not output contents of changes in binary files, instead display a notice that those files changed.  Patches generated using this option cannot be applied properly, but they are still useful for code review."
msgstr "不输出二进制文件中的变化内容，而是显示这些文件变化的通知。 使用该选项生成的补丁不能被正确应用，但它们对代码审查仍然有用。"

#. type: Labeled list
#: en/git-format-patch.txt:384
#, ignore-same, no-wrap, priority:100
msgid "--zero-commit"
msgstr "--zero-commit"

#. type: Plain text
#: en/git-format-patch.txt:387
#, priority:100
msgid "Output an all-zero hash in each patch's From header instead of the hash of the commit."
msgstr "在每个补丁的 From 头中输出一个全零的哈希值，而不是提交的哈希值。"

#. type: Labeled list
#: en/git-format-patch.txt:388
#, fuzzy, no-wrap, priority:100
#| msgid "--no-commit"
msgid "--[no-]base[=<commit>]"
msgstr "--[no-]base[=<commit>]"

#. type: Plain text
#: en/git-format-patch.txt:394
#, priority:100
msgid "Record the base tree information to identify the state the patch series applies to.  See the BASE TREE INFORMATION section below for details. If <commit> is \"auto\", a base commit is automatically chosen. The `--no-base` option overrides a `format.useAutoBase` configuration."
msgstr "记录基树信息，以确定该补丁系列所适用的状态。 详见下面的基树信息部分。如果 <提交> 是 \"auto\"，就会自动选择一个基数提交。`--no-base` 选项会覆盖 `format.useAutoBase` 配置。"

#. type: Plain text
#: en/git-format-patch.txt:401
#, priority:100
msgid "Treat the revision argument as a <revision range>, even if it is just a single commit (that would normally be treated as a <since>).  Note that root commits included in the specified range are always formatted as creation patches, independently of this flag."
msgstr "将修订版参数视为 <revision range>，即使它只是一个单一的提交（通常会被视为 <since>）。 注意，包含在指定范围内的根提交总是被格式化为创建补丁，与此标志无关。"

#. type: Plain text
#: en/git-format-patch.txt:404
#, priority:100
msgid "Show progress reports on stderr as patches are generated."
msgstr "在生成补丁时在标准错误流上显示进度报告。"

#. type: Plain text
#: en/git-format-patch.txt:412
#, priority:100
msgid "You can specify extra mail header lines to be added to each message, defaults for the subject prefix and file suffix, number patches when outputting more than one patch, add \"To:\" or \"Cc:\" headers, configure attachments, change the patch output directory, and sign off patches with configuration variables."
msgstr "你可以指定额外的邮件标题行添加到每封邮件中，主题前缀和文件后缀的默认值，在输出多个补丁时对补丁进行编号，添加 \"To: \" 或 \"Cc: \" 标题，配置附件，更改补丁输出目录，以及用配置变量签署补丁。"

#. type: delimited block -
#: en/git-format-patch.txt:426
#, fuzzy, no-wrap, priority:100
msgid ""
"[format]\n"
"\theaders = \"Organization: git-foo\\n\"\n"
"\tsubjectPrefix = CHANGE\n"
"\tsuffix = .txt\n"
"\tnumbered = auto\n"
"\tto = <email>\n"
"\tcc = <email>\n"
"\tattach [ = mime-boundary-string ]\n"
"\tsignOff = true\n"
"\toutputDirectory = <directory>\n"
"\tcoverLetter = auto\n"
"\tcoverFromDescription = auto\n"
msgstr ""
"[format]\n"
"\theaders = \"Organization: git-foo\\n\"\n"
"\tsubjectPrefix = CHANGE\n"
"\tsuffix = .txt\n"
"\tnumbered = auto\n"
"\tto = <email>\n"
"\tcc = <email>\n"
"\tattach [ = mime-boundary-string ]\n"
"\tsignOff = true\n"
"\toutputDirectory = <directory>\n"
"\tcoverLetter = auto\n"
"\tcoverFromDescription = auto\n"

#. type: Plain text
#: en/git-format-patch.txt:435
#, priority:100
msgid "The patch produced by 'git format-patch' is in UNIX mailbox format, with a fixed \"magic\" time stamp to indicate that the file is output from format-patch rather than a real mailbox, like so:"
msgstr "由 'git format-patch' 产生的补丁是 UNIX 邮箱格式，有一个固定的 \"magic\" 时间戳，以表明该文件是由 format-patch 输出的，而不是一个真正的邮箱，像这样："

#. type: delimited block -
#: en/git-format-patch.txt:445
#, no-wrap, priority:100
msgid ""
"From 8f72bad1baf19a53459661343e21d6491c3908d3 Mon Sep 17 00:00:00 2001\n"
"From: Tony Luck <tony.luck@intel.com>\n"
"Date: Tue, 13 Jul 2010 11:42:54 -0700\n"
"Subject: [PATCH] =?UTF-8?q?[IA64]=20Put=20ia64=20config=20files=20on=20the=20?=\n"
" =?UTF-8?q?Uwe=20Kleine-K=C3=B6nig=20diet?=\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
msgstr ""
"From 8f72bad1baf19a53459661343e21d6491c3908d3 Mon Sep 17 00:00:00 2001\n"
"From: Tony Luck <tony.luck@intel.com>\n"
"Date: Tue, 13 Jul 2010 11:42:54 -0700\n"
"Subject: [PATCH] =?UTF-8?q?[IA64]=20Put=20ia64=20config=20files=20on=20the=20?=\n"
" =?UTF-8?q?Uwe=20Kleine-K=C3=B6nig=20diet?=\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: delimited block -
#: en/git-format-patch.txt:448
#, no-wrap, priority:100
msgid ""
"arch/arm config files were slimmed down using a python script\n"
"(See commit c2330e286f68f1c408b4aa6515ba49d57f05beae comment)\n"
msgstr ""
"arch/arm config files were slimmed down using a python script\n"
"(见提交 c2330e286f68f1c408b4aa6515ba49d57f05beae 评论)\n"

#. type: delimited block -
#: en/git-format-patch.txt:451
#, ignore-ellipsis, no-wrap, priority:100
msgid ""
"Do the same for ia64 so we can have sleek & trim looking\n"
"...\n"
msgstr ""
"为 ia64 做同样的事情，这样我们就可以有光滑和修长的外观了。\n"
"...\n"

#. type: Plain text
#: en/git-format-patch.txt:459
#, ignore-ellipsis, priority:100
msgid "Typically it will be placed in a MUA's drafts folder, edited to add timely commentary that should not go in the changelog after the three dashes, and then sent as a message whose body, in our example, starts with \"arch/arm config files were...\".  On the receiving end, readers can save interesting patches in a UNIX mailbox and apply them with linkgit:git-am[1]."
msgstr "通常情况下，它会被放在 MUA 的 drafts 文件夹中，被编辑以添加及时的评论，这些评论不应该被放在 changelog 中的三个破折号之后，然后以消息的形式发送，在我们的例子中，其正文以 \"arch/arm config files were...\" 开始。 在接收端，读者可以将有趣的补丁保存在 UNIX 邮箱中，并通过 linkgit:git-am[1] 应用它们。"

#. type: Plain text
#: en/git-format-patch.txt:465
#, priority:100
msgid "When a patch is part of an ongoing discussion, the patch generated by 'git format-patch' can be tweaked to take advantage of the 'git am --scissors' feature.  After your response to the discussion comes a line that consists solely of \"`-- >8 --`\" (scissors and perforation), followed by the patch with unnecessary header fields removed:"
msgstr "当一个补丁是正在进行的讨论的一部分时，由 'git format-patch' 生成的补丁可以进行调整，以利用 'git am --scissors' 功能。 在你对讨论的回应之后，有一行只由 \"`-- >8 --`\"（剪刀和打孔）组成，后面是去除不必要的头域的补丁："

#. type: delimited block -
#: en/git-format-patch.txt:469
#, fuzzy, ignore-ellipsis, no-wrap, priority:100
msgid ""
"...\n"
"> So we should do such-and-such.\n"
msgstr ""
"...\n"
"> So we should do such-and-such.\n"

#. type: delimited block -
#: en/git-format-patch.txt:471
#, no-wrap, priority:100
msgid "Makes sense to me.  How about this patch?\n"
msgstr "对我来说是有意义的。 这个补丁怎么样？\n"

#. type: delimited block -
#: en/git-format-patch.txt:474
#, no-wrap, priority:100
msgid ""
"-- >8 --\n"
"Subject: [IA64] Put ia64 config files on the Uwe Kleine-KÃ¶nig diet\n"
msgstr ""
"-- >8 --\n"
"Subject: [IA64] Put ia64 config files on the Uwe Kleine-KÃ¶nig diet\n"

#. type: delimited block -
#: en/git-format-patch.txt:477
#, ignore-ellipsis, no-wrap, priority:100
msgid ""
"arch/arm config files were slimmed down using a python script\n"
"...\n"
msgstr ""
"使用 python 脚本对 arch/arm 配置文件进行了精简\n"
"...\n"

#. type: Plain text
#: en/git-format-patch.txt:485
#, priority:100
msgid "When sending a patch this way, most often you are sending your own patch, so in addition to the \"`From $SHA1 $magic_timestamp`\" marker you should omit `From:` and `Date:` lines from the patch file.  The patch title is likely to be different from the subject of the discussion the patch is in response to, so it is likely that you would want to keep the Subject: line, like the example above."
msgstr "当用这种方式发送补丁时，大多数情况下是发送你自己的补丁，所以除了 \"`From $SHA1 $magic_timestamp`\" 标记外，你应该从补丁文件中省略 `From: ` 和 `Date: ` 行。 补丁的标题很可能与补丁所回应的讨论主题不同，所以很可能要保留 Subject: 这一行，就像上面的例子一样。"

#. type: Title ~
#: en/git-format-patch.txt:487
#, no-wrap, priority:100
msgid "Checking for patch corruption"
msgstr "检查补丁是否损坏"

#. type: Plain text
#: en/git-format-patch.txt:490
#, priority:100
msgid "Many mailers if not set up properly will corrupt whitespace.  Here are two common types of corruption:"
msgstr "许多邮件如果设置不当就会破坏空白。 以下是两种常见的损坏类型："

#. type: Plain text
#: en/git-format-patch.txt:492
#, priority:100
msgid "Empty context lines that do not have _any_ whitespace."
msgstr "没有「任何」空格的空的上下文行。"

#. type: Plain text
#: en/git-format-patch.txt:495
#, priority:100
msgid "Non-empty context lines that have one extra whitespace at the beginning."
msgstr "非空的上下文行，在开头有一个额外的空白。"

#. type: Plain text
#: en/git-format-patch.txt:497
#, priority:100
msgid "One way to test if your MUA is set up correctly is:"
msgstr "测试你的 MUA 是否设置正确的一个方法是："

#. type: Plain text
#: en/git-format-patch.txt:501
#, priority:100
msgid "Send the patch to yourself, exactly the way you would, except with To: and Cc: lines that do not contain the list and maintainer address."
msgstr "将补丁发送给自己，完全按照你的方式，只是在 To: 和 Cc: 行中不包含列表和维护者地址。"

#. type: Plain text
#: en/git-format-patch.txt:504
#, priority:100
msgid "Save that patch to a file in UNIX mailbox format.  Call it a.patch, say."
msgstr "将该补丁保存为 UNIX 邮箱格式的文件。 称之为 a.patch，例如。"

#. type: Plain text
#: en/git-format-patch.txt:506
#, priority:100
msgid "Apply it:"
msgstr "应用它："

#. type: Plain text
#: en/git-format-patch.txt:511
#, fuzzy, no-wrap, priority:100
msgid ""
"$ git fetch <project> master:test-apply\n"
"$ git switch test-apply\n"
"$ git restore --source=HEAD --staged --worktree :/\n"
"$ git am a.patch\n"
msgstr ""
"$ git fetch <project> master:test-apply\n"
"$ git switch test-apply\n"
"$ git restore --source=HEAD --staged --worktree :/\n"
"$ git am a.patch\n"

#. type: Plain text
#: en/git-format-patch.txt:513
#, priority:100
msgid "If it does not apply correctly, there can be various reasons."
msgstr "如果它不能正确应用，可能有各种原因。"

#. type: Plain text
#: en/git-format-patch.txt:518
#, priority:100
msgid "The patch itself does not apply cleanly.  That is _bad_ but does not have much to do with your MUA.  You might want to rebase the patch with linkgit:git-rebase[1] before regenerating it in this case."
msgstr "补丁本身不能干净地应用。 这很糟糕，但与你的 MUA 没有多大关系。 在这种情况下，你可能要先用 linkgit:git-rebase[1] 把补丁重新归位，再重新生成。"

#. type: Plain text
#: en/git-format-patch.txt:523
#, priority:100
msgid "The MUA corrupted your patch; \"am\" would complain that the patch does not apply.  Look in the .git/rebase-apply/ subdirectory and see what 'patch' file contains and check for the common corruption patterns mentioned above."
msgstr "MUA 损坏了你的补丁；\"am\" 会抱怨补丁不适用。 查看 .git/rebase-apply/ 子目录，看看 \"补丁\" 文件包含哪些内容，并检查上面提到的常见损坏模式。"

#. type: Plain text
#: en/git-format-patch.txt:531
#, priority:100
msgid "While at it, check the 'info' and 'final-commit' files as well.  If what is in 'final-commit' is not exactly what you would want to see in the commit log message, it is very likely that the receiver would end up hand editing the log message when applying your patch.  Things like \"Hi, this is my first patch.\\n\" in the patch e-mail should come after the three-dash line that signals the end of the commit message."
msgstr "同时，还要检查 'info' 和 'final-commit' 文件。 如果 'final-commit' 中的内容与你希望在提交日志信息中看到的不完全一样，那么很可能接收者在应用你的补丁时最终会手工编辑日志信息。 补丁邮件中的 \"Hi, this is my first patch.\\n\" 等内容应该出现在提交信息末尾的三折线之后。"

#. type: Title -
#: en/git-format-patch.txt:533
#, no-wrap, priority:100
msgid "MUA-SPECIFIC HINTS"
msgstr "针对 Mua 的提示"

#. type: Plain text
#: en/git-format-patch.txt:536
#, priority:100
msgid "Here are some hints on how to successfully submit patches inline using various mailers."
msgstr "这里有一些关于如何使用各种邮件工具成功地在线提交补丁的提示。"

#. type: Title ~
#: en/git-format-patch.txt:538
#, fuzzy, no-wrap, priority:100
msgid "GMail"
msgstr "GMail"

#. type: Plain text
#: en/git-format-patch.txt:544
#, priority:100
msgid "GMail does not have any way to turn off line wrapping in the web interface, so it will mangle any emails that you send.  You can however use \"git send-email\" and send your patches through the GMail SMTP server, or use any IMAP email client to connect to the google IMAP server and forward the emails through that."
msgstr "GMail 没有办法在网页界面上关闭换行，所以它会把你发送的任何邮件弄得一团糟。 然而，你可以使用 \"git send-email\"，通过 GMail 的 SMTP 服务器发送你的补丁，或者使用任何 IMAP 电子邮件客户端连接到谷歌的 IMAP 服务器，并通过它转发电子邮件。"

#. type: Plain text
#: en/git-format-patch.txt:547
#, priority:100
msgid "For hints on using 'git send-email' to send your patches through the GMail SMTP server, see the EXAMPLE section of linkgit:git-send-email[1]."
msgstr "关于使用 'git send-email' 通过 GMail SMTP 服务器发送补丁的提示，请参见 linkgit:git-send-email[1] 的案例部分。"

#. type: Plain text
#: en/git-format-patch.txt:550
#, priority:100
msgid "For hints on submission using the IMAP interface, see the EXAMPLE section of linkgit:git-imap-send[1]."
msgstr "关于使用 IMAP 接口提交的提示，请参见 linkgit:git-imap-send[1] 的案例部分。"

#. type: Title ~
#: en/git-format-patch.txt:552
#, fuzzy, no-wrap, priority:100
msgid "Thunderbird"
msgstr "ThunderbirdName"

#. type: Plain text
#: en/git-format-patch.txt:556
#, priority:100
msgid "By default, Thunderbird will both wrap emails as well as flag them as being 'format=flowed', both of which will make the resulting email unusable by Git."
msgstr "默认情况下，Thunderbird 会将邮件包裹起来，并将其标记为 'format=flowed'，这两种情况都会使 Git 无法使用这些邮件。"

#. type: Plain text
#: en/git-format-patch.txt:560
#, priority:100
msgid "There are three different approaches: use an add-on to turn off line wraps, configure Thunderbird to not mangle patches, or use an external editor to keep Thunderbird from mangling the patches."
msgstr "有三种不同的方法：使用插件来关闭换行，配置 Thunderbird 使其不纠缠补丁，或者使用外部编辑器来防止 Thunderbird 纠缠补丁。"

#. type: Title ^
#: en/git-format-patch.txt:562
#, no-wrap, priority:100
msgid "Approach #1 (add-on)"
msgstr "办法1（附加的）"

#. type: Plain text
#: en/git-format-patch.txt:570
#, priority:100
msgid "Install the Toggle Word Wrap add-on that is available from https://addons.mozilla.org/thunderbird/addon/toggle-word-wrap/ It adds a menu entry \"Enable Word Wrap\" in the composer's \"Options\" menu that you can tick off. Now you can compose the message as you otherwise do (cut + paste, 'git format-patch' | 'git imap-send', etc), but you have to insert line breaks manually in any text that you type."
msgstr "安装 Toggle Word Wrap 插件，该插件可从 https://addons.mozilla.org/thunderbird/addon/toggle-word-wrap/。它在作曲家的 \"选项\" 菜单中增加了一个 \"启用换行符\" 的菜单项，你可以将其勾掉。现在你可以像其他方式一样编写信息（剪切+粘贴，'git format-patch'|'git imap-send'，等等），但你必须在你输入的任何文本中手动插入换行符。"

#. type: Title ^
#: en/git-format-patch.txt:572
#, no-wrap, priority:100
msgid "Approach #2 (configuration)"
msgstr "方法#2（配置）"

#. type: Plain text
#: en/git-format-patch.txt:574
#, priority:100
msgid "Three steps:"
msgstr "三个步骤："

#. type: Plain text
#: en/git-format-patch.txt:578
#, ignore-ellipsis, priority:100
msgid "Configure your mail server composition as plain text: Edit...Account Settings...Composition & Addressing, uncheck \"Compose Messages in HTML\"."
msgstr "将你的邮件服务器组成配置为纯文本： 编辑......账户设置......组成和地址，取消勾选 \"以HTML编写邮件\"。"

#. type: Plain text
#: en/git-format-patch.txt:580
#, priority:100
msgid "Configure your general composition window to not wrap."
msgstr "配置你的一般组成窗口，使其不被包裹。"

#. type: Plain text
#: en/git-format-patch.txt:583
#, priority:100
msgid "In Thunderbird 2: Edit..Preferences..Composition, wrap plain text messages at 0"
msgstr "在 Thunderbird 2 中：编辑...偏好...组成，将纯文本信息包在 0 处"

#. type: Plain text
#: en/git-format-patch.txt:589
#, priority:100
msgid "In Thunderbird 3: Edit..Preferences..Advanced..Config Editor.  Search for \"mail.wrap_long_lines\".  Toggle it to make sure it is set to `false`. Also, search for \"mailnews.wraplength\" and set the value to 0."
msgstr "在 Thunderbird 3 中：编辑...偏好...高级...配置编辑器。 搜索 \"mail.wrap_long_lines\"。 切换它，确保它被设置为 \"false\"。另外，搜索 \"mailnews.wraplength\" 并将其设置为 0。"

#. type: Plain text
#: en/git-format-patch.txt:594
#, priority:100
msgid "Disable the use of format=flowed: Edit..Preferences..Advanced..Config Editor.  Search for \"mailnews.send_plaintext_flowed\".  Toggle it to make sure it is set to `false`."
msgstr "禁止使用 format=flowed： 编辑...偏好...高级...配置编辑器。 搜索 \"mailnews.send_plaintext_flowed\"。 拨动它，确保它被设置为 `false`。"

#. type: Plain text
#: en/git-format-patch.txt:598
#, priority:100
msgid "After that is done, you should be able to compose email as you otherwise would (cut + paste, 'git format-patch' | 'git imap-send', etc), and the patches will not be mangled."
msgstr "完成后，你应该能够像其他方式一样编写电子邮件（剪切+粘贴，'git format-patch' | 'git imap-send'，等等），而且补丁不会被弄乱。"

#. type: Title ^
#: en/git-format-patch.txt:600
#, no-wrap, priority:100
msgid "Approach #3 (external editor)"
msgstr "方法三（外部编辑）"

#. type: Plain text
#: en/git-format-patch.txt:605
#, priority:100
msgid "The following Thunderbird extensions are needed: AboutConfig from http://aboutconfig.mozdev.org/ and External Editor from http://globs.org/articles.php?lng=en&pg=8"
msgstr "需要以下 Thunderbird 扩展： http://aboutconfig.mozdev.org/ 中的 AboutConfig和http://globs.org/articles.php?lng=en&pg=8 中的 External Editor"

#. type: Plain text
#: en/git-format-patch.txt:607
#, priority:100
msgid "Prepare the patch as a text file using your method of choice."
msgstr "用你选择的方法把补丁准备成一个文本文件。"

#. type: Plain text
#: en/git-format-patch.txt:612
#, priority:100
msgid "Before opening a compose window, use Edit->Account Settings to uncheck the \"Compose messages in HTML format\" setting in the \"Composition & Addressing\" panel of the account to be used to send the patch."
msgstr "在打开撰写窗口之前，使用 Edit->Account Settingd 取消勾选要用来发送补丁的账户的 \"Composition & Addressing\" 面板中的 \"Compose messages in HTML format\" 设置。"

#. type: Plain text
#: en/git-format-patch.txt:616
#, priority:100
msgid "In the main Thunderbird window, 'before' you open the compose window for the patch, use Tools->about:config to set the following to the indicated values:"
msgstr "在 Thunderbird 主窗口中，在你打开补丁的撰写窗口之前，使用 Tools->about:config 将以下内容设置为指定值："

#. type: delimited block -
#: en/git-format-patch.txt:620
#, no-wrap, priority:100
msgid ""
"\tmailnews.send_plaintext_flowed  => false\n"
"\tmailnews.wraplength             => 0\n"
msgstr ""
"\tmailnews.send_plaintext_flowed  => false\n"
"\tmailnews.wraplength             => 0\n"

#. type: Plain text
#: en/git-format-patch.txt:623
#, priority:100
msgid "Open a compose window and click the external editor icon."
msgstr "打开一个作曲窗口，点击外部编辑器图标。"

#. type: Plain text
#: en/git-format-patch.txt:626
#, priority:100
msgid "In the external editor window, read in the patch file and exit the editor normally."
msgstr "在外部编辑器窗口，读入补丁文件并正常退出编辑器。"

#. type: Plain text
#: en/git-format-patch.txt:629
#, priority:100
msgid "Side note: it may be possible to do step 2 with about:config and the following settings but no one's tried yet."
msgstr "题外话：也许可以用 about:config 和以下设置来完成第二步，但还没有人试过。"

#. type: delimited block -
#: en/git-format-patch.txt:634
#, no-wrap, priority:100
msgid ""
"\tmail.html_compose                       => false\n"
"\tmail.identity.default.compose_html      => false\n"
"\tmail.identity.id?.compose_html          => false\n"
msgstr ""
"\tmail.html_compose                       => false\n"
"\tmail.identity.default.compose_html      => false\n"
"\tmail.identity.id?.compose_html          => false\n"

#. type: Plain text
#: en/git-format-patch.txt:639
#, priority:100
msgid "There is a script in contrib/thunderbird-patch-inline which can help you include patches with Thunderbird in an easy way. To use it, do the steps above and then use the script as the external editor."
msgstr "contrib/thunderbird-patch-inline 中有一个脚本，可以帮助你以一种简单的方式将补丁加入 Thunderbird。要使用它，请执行上面的步骤，然后使用该脚本作为外部编辑器。"

#. type: Title ~
#: en/git-format-patch.txt:641
#, fuzzy, no-wrap, priority:100
msgid "KMail"
msgstr "KMail"

#. type: Plain text
#: en/git-format-patch.txt:643
#, priority:100
msgid "This should help you to submit patches inline using KMail."
msgstr "这应该有助于你使用 KMail 在线提交补丁。"

#. type: Plain text
#: en/git-format-patch.txt:645
#, priority:100
msgid "Prepare the patch as a text file."
msgstr "把补丁准备成一个文本文件。"

#. type: Plain text
#: en/git-format-patch.txt:647
#, priority:100
msgid "Click on New Mail."
msgstr "点击 \"New Mail\"。"

#. type: Plain text
#: en/git-format-patch.txt:650
#, priority:100
msgid "Go under \"Options\" in the Composer window and be sure that \"Word wrap\" is not set."
msgstr "在合成器窗口的 \"Otions\" 下，确保没有设置 \"Word warp\"。"

#. type: Plain text
#: en/git-format-patch.txt:652
#, ignore-ellipsis, priority:100
msgid "Use Message -> Insert file... and insert the patch."
msgstr "Use Message -> Insert file... 并插入补丁。"

#. type: Plain text
#: en/git-format-patch.txt:655
#, priority:100
msgid "Back in the compose window: add whatever other text you wish to the message, complete the addressing and subject fields, and press send."
msgstr "回到撰写窗口：在信息中添加你想要的任何其他文本，完成地址和主题字段，然后按发送。"

#. type: Title -
#: en/git-format-patch.txt:657
#, no-wrap, priority:100
msgid "BASE TREE INFORMATION"
msgstr "基准树信息"

#. type: Plain text
#: en/git-format-patch.txt:666
#, priority:100
msgid "The base tree information block is used for maintainers or third party testers to know the exact state the patch series applies to. It consists of the 'base commit', which is a well-known commit that is part of the stable part of the project history everybody else works off of, and zero or more 'prerequisite patches', which are well-known patches in flight that is not yet part of the 'base commit' that need to be applied on top of 'base commit' in topological order before the patches can be applied."
msgstr "基准树信息块用于维护者或第三方测试人员了解补丁系列所适用的确切状态。它由 ‘基本提交’ 和零个或多个 ‘前提补丁’ 组成，前者是众所周知的提交，是项目历史中稳定部分的一部分，而后者是正在运行的知名补丁，还不是 ‘基本提交’ 的一部分，在应用这些补丁之前需要在 ‘基本提交’ 之上按拓扑顺序应用。"

#. type: Plain text
#: en/git-format-patch.txt:672
#, priority:100
msgid "The 'base commit' is shown as \"base-commit: \" followed by the 40-hex of the commit object name.  A 'prerequisite patch' is shown as \"prerequisite-patch-id: \" followed by the 40-hex 'patch id', which can be obtained by passing the patch through the `git patch-id --stable` command."
msgstr "‘基本提交’ 显示为 \"base-commit: \"，后面是提交对象名称的 40-hex。 ‘先决补丁’ 显示为 \"prerequisite-patch-id: \"，后面是 40-hex 的 “补丁ID”，这个 ID 可以通过 `git patch-id --stable` 命令来获得。"

#. type: Plain text
#: en/git-format-patch.txt:676
#, priority:100
msgid "Imagine that on top of the public commit P, you applied well-known patches X, Y and Z from somebody else, and then built your three-patch series A, B, C, the history would be like:"
msgstr "想象一下，在公开提交的 P 之上，你应用了别人的知名补丁 X、Y 和 Z，然后建立了你的三套补丁系列 A、B、C，历史会是这样："

#. type: delimited block .
#: en/git-format-patch.txt:679
#, fuzzy, no-wrap, priority:100
msgid "---P---X---Y---Z---A---B---C\n"
msgstr "---P---X---Y---Z---A---B---C\n"

#. type: Plain text
#: en/git-format-patch.txt:686
#, priority:100
msgid "With `git format-patch --base=P -3 C` (or variants thereof, e.g. with `--cover-letter` or using `Z..C` instead of `-3 C` to specify the range), the base tree information block is shown at the end of the first message the command outputs (either the first patch, or the cover letter), like this:"
msgstr "使用 `git format-patch --base=P -3 C`（或其变体，例如使用 `-cover-letter` 或使用 `Z...C` 代替 `-3 C` 来指定范围），基础树信息块会显示在命令输出的第一个信息（第一个补丁，或封面信）的末尾，像这样："

#. type: delimited block -
#: en/git-format-patch.txt:692
#, no-wrap, priority:100
msgid ""
"base-commit: P\n"
"prerequisite-patch-id: X\n"
"prerequisite-patch-id: Y\n"
"prerequisite-patch-id: Z\n"
msgstr ""
"base-commit: P\n"
"prerequisite-patch-id: X\n"
"prerequisite-patch-id: Y\n"
"prerequisite-patch-id: Z\n"

#. type: Plain text
#: en/git-format-patch.txt:695
#, priority:100
msgid "For non-linear topology, such as"
msgstr "对于非线性拓扑结构，如"

#. type: delimited block .
#: en/git-format-patch.txt:700
#, fuzzy, no-wrap, priority:100
msgid ""
"---P---X---A---M---C\n"
"    \\         /\n"
"     Y---Z---B\n"
msgstr ""
"---P---X---A---M---C\n"
"    \\         /\n"
"     Y---Z---B\n"

#. type: Plain text
#: en/git-format-patch.txt:705
#, priority:100
msgid "You can also use `git format-patch --base=P -3 C` to generate patches for A, B and C, and the identifiers for P, X, Y, Z are appended at the end of the first message."
msgstr "你也可以使用 `git format-patch --base=P -3 C` 来生成 A、B 和 C 的补丁，P、X、Y、Z 的标识符被附加在第一条信息的末尾。"

#. type: Plain text
#: en/git-format-patch.txt:711
#, priority:100
msgid "If set `--base=auto` in cmdline, it will automatically compute the base commit as the merge base of tip commit of the remote-tracking branch and revision-range specified in cmdline.  For a local branch, you need to make it to track a remote branch by `git branch --set-upstream-to` before using this option."
msgstr "如果在 cmdline 中设置 `--base=auto`，它将自动计算基础提交，作为远程跟踪分支和 cmdline 中指定的修订范围的提示提交的合并基础。 对于本地分支，在使用此选项之前，需要通过 `git branch --set-upstream-to` 使其跟踪远程分支。"

#. type: Plain text
#: en/git-format-patch.txt:717
#, priority:100
msgid "Extract commits between revisions R1 and R2, and apply them on top of the current branch using 'git am' to cherry-pick them:"
msgstr "提取 R1 和 R2 修订版之间的提交，并用 \"git am\" 将其应用于当前分支之上，以拣选它们："

#. type: delimited block -
#: en/git-format-patch.txt:720
#, fuzzy, no-wrap, priority:100
msgid "$ git format-patch -k --stdout R1..R2 | git am -3 -k\n"
msgstr "$ git format-patch -k --stdout R1..R2 | git am -3 -k\n"

#. type: Plain text
#: en/git-format-patch.txt:724
#, priority:100
msgid "Extract all commits which are in the current branch but not in the origin branch:"
msgstr "提取所有在当前分支但不在原生分支中的提交："

#. type: delimited block -
#: en/git-format-patch.txt:727
#, fuzzy, no-wrap, priority:100
msgid "$ git format-patch origin\n"
msgstr "$ git format-patch origin\n"

#. type: Plain text
#: en/git-format-patch.txt:730
#, priority:100
msgid "For each commit a separate file is created in the current directory."
msgstr "每次提交都会在当前目录下创建一个单独的文件。"

#. type: Plain text
#: en/git-format-patch.txt:733
#, priority:100
msgid "Extract all commits that lead to 'origin' since the inception of the project:"
msgstr "提取自项目开始以来所有导致 'origin' 的提交："

#. type: delimited block -
#: en/git-format-patch.txt:736
#, fuzzy, no-wrap, priority:100
msgid "$ git format-patch --root origin\n"
msgstr "$ git format-patch --root origin\n"

#. type: Plain text
#: en/git-format-patch.txt:739
#, priority:100
msgid "The same as the previous one:"
msgstr "与前者相同："

#. type: delimited block -
#: en/git-format-patch.txt:742
#, fuzzy, no-wrap, priority:100
msgid "$ git format-patch -M -B origin\n"
msgstr "$ git format-patch -M -B origin\n"

#. type: Plain text
#: en/git-format-patch.txt:749
#, priority:100
msgid "Additionally, it detects and handles renames and complete rewrites intelligently to produce a renaming patch.  A renaming patch reduces the amount of text output, and generally makes it easier to review.  Note that non-Git \"patch\" programs won't understand renaming patches, so use it only when you know the recipient uses Git to apply your patch."
msgstr "此外，它还能智能地检测和处理重命名和完全重写，以产生重命名补丁。 重命名补丁减少了文本输出的数量，一般来说，它更容易审查。 注意，非 Git 的 “补丁” 程序不会理解重命名补丁，所以只有当你知道收件人使用 Git 来应用你的补丁时才会使用它。"

#. type: Plain text
#: en/git-format-patch.txt:752
#, priority:100
msgid "Extract three topmost commits from the current branch and format them as e-mailable patches:"
msgstr "从当前分支中提取三个最重要的提交，并将其格式化为可发送电子邮件的补丁："

#. type: delimited block -
#: en/git-format-patch.txt:755
#, fuzzy, no-wrap, priority:100
msgid "$ git format-patch -3\n"
msgstr "$ git format-patch -3\n"

#. type: Plain text
#: en/git-format-patch.txt:764
#, priority:100
msgid "Note that `format-patch` will omit merge commits from the output, even if they are part of the requested range. A simple \"patch\" does not include enough information for the receiving end to reproduce the same merge commit."
msgstr "请注意，`format-patch` 将从输出中省略合并提交，即使它们是请求范围的一部分。一个简单的 “补丁” 并不包括足够的信息让接收端重现同一个合并提交。"

#. type: Plain text
#: en/git-format-patch.txt:768
#, ignore-same, priority:100
msgid "linkgit:git-am[1], linkgit:git-send-email[1]"
msgstr "linkgit:git-am[1], linkgit:git-send-email[1]"

#. type: Title =
#: en/git-fsck-objects.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-fsck-objects(1)"
msgstr "git-fsck-objects(1)"

#. type: Plain text
#: en/git-fsck-objects.txt:7
#, priority:100
msgid "git-fsck-objects - Verifies the connectivity and validity of the objects in the database"
msgstr "git-fsck-objects - 验证数据库中对象的连接性和有效性"

#. type: Plain text
#: en/git-fsck-objects.txt:13
#, fuzzy, ignore-ellipsis, no-wrap, priority:100
msgid "'git fsck-objects' ...\n"
msgstr "'git fsck-objects' ...\n"

#. type: Plain text
#: en/git-fsck-objects.txt:19
#, priority:100
msgid "This is a synonym for linkgit:git-fsck[1].  Please refer to the documentation of that command."
msgstr "这是 linkgit:git-fsck[1] 的同义词。 请参考该命令的文档。"

#. type: Title =
#: en/git-fsck.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-fsck(1)"
msgstr "git-fsck(1)"

#. type: Plain text
#: en/git-fsck.txt:7
#, fuzzy, priority:100
msgid "git-fsck - Verifies the connectivity and validity of the objects in the database"
msgstr "git-fsck - Verifies the connectivity and validity of the objects in the database"

#. type: Plain text
#: en/git-fsck.txt:16
#, fuzzy, ignore-ellipsis, no-wrap, priority:100
msgid ""
"'git fsck' [--tags] [--root] [--unreachable] [--cache] [--no-reflogs]\n"
"\t [--[no-]full] [--strict] [--verbose] [--lost-found]\n"
"\t [--[no-]dangling] [--[no-]progress] [--connectivity-only]\n"
"\t [--[no-]name-objects] [<object>...]\n"
msgstr ""
"'git fsck' [--tags] [--root] [--unreachable] [--cache] [--no-reflogs]\n"
"\t [--[no-]full] [--strict] [--verbose] [--lost-found]\n"
"\t [--[no-]dangling] [--[no-]progress] [--connectivity-only]\n"
"\t [--[no-]name-objects] [<object>*]\n"

#. type: Plain text
#: en/git-fsck.txt:25
#, priority:100
msgid "An object to treat as the head of an unreachability trace."
msgstr "一个要作为不可及性追踪的头的对象。"

#. type: Plain text
#: en/git-fsck.txt:29
#, priority:100
msgid "If no objects are given, 'git fsck' defaults to using the index file, all SHA-1 references in `refs` namespace, and all reflogs (unless --no-reflogs is given) as heads."
msgstr "如果没有给出对象，'git fsck' 默认使用索引文件、`refs` 命名空间中的所有 SHA-1 引用，以及所有引用日志（除非--no-reflogs被给出）作为头。"

#. type: Labeled list
#: en/git-fsck.txt:30
#, ignore-same, no-wrap, priority:100
msgid "--unreachable"
msgstr "--unreachable"

#. type: Plain text
#: en/git-fsck.txt:33
#, priority:100
msgid "Print out objects that exist but that aren't reachable from any of the reference nodes."
msgstr "打印出存在但不能从任何参考节点到达的对象。"

#. type: Labeled list
#: en/git-fsck.txt:34
#, ignore-same, no-wrap, priority:100
msgid "--[no-]dangling"
msgstr "--[no-]dangling"

#. type: Plain text
#: en/git-fsck.txt:37
#, priority:100
msgid "Print objects that exist but that are never 'directly' used (default).  `--no-dangling` can be used to omit this information from the output."
msgstr "打印存在但从未 'directly ' 使用的对象（默认）。 `--no-dangling` 可以用来从输出中省略这一信息。"

#. type: Plain text
#: en/git-fsck.txt:40
#, priority:100
msgid "Report root nodes."
msgstr "报告根节点。"

#. type: Plain text
#: en/git-fsck.txt:43
#, priority:100
msgid "Report tags."
msgstr "报告标签。"

#. type: Labeled list
#: en/git-fsck.txt:44
#, ignore-same, no-wrap, priority:100
msgid "--cache"
msgstr "--cache"

#. type: Plain text
#: en/git-fsck.txt:47
#, priority:100
msgid "Consider any object recorded in the index also as a head node for an unreachability trace."
msgstr "考虑将索引中记录的任何对象也作为不可达性追踪的头节点。"

#. type: Labeled list
#: en/git-fsck.txt:48
#, ignore-same, no-wrap, priority:100
msgid "--no-reflogs"
msgstr "--no-reflogs"

#. type: Plain text
#: en/git-fsck.txt:53
#, priority:100
msgid "Do not consider commits that are referenced only by an entry in a reflog to be reachable.  This option is meant only to search for commits that used to be in a ref, but now aren't, but are still in that corresponding reflog."
msgstr "不认为那些只被引用日志中的条目引用的提交是可以达到的。 这个选项只是为了搜索那些曾经在引用中，但现在不在了，但仍在那个相应引用日志中的提交。"

#. type: Labeled list
#: en/git-fsck.txt:54
#, ignore-same, no-wrap, priority:100
msgid "--full"
msgstr "--full"

#. type: Plain text
#: en/git-fsck.txt:63
#, priority:100
msgid "Check not just objects in GIT_OBJECT_DIRECTORY ($GIT_DIR/objects), but also the ones found in alternate object pools listed in GIT_ALTERNATE_OBJECT_DIRECTORIES or $GIT_DIR/objects/info/alternates, and in packed Git archives found in $GIT_DIR/objects/pack and corresponding pack subdirectories in alternate object pools.  This is now default; you can turn it off with --no-full."
msgstr "不仅检查 GIT_OBJECT_DIRECTORY ($GIT_DIR/objects) 中的对象，还检查 GIT_ALTERNATE_OBJECT_DIRECTORIES 或 $GIT_DIR/objects/info/alternates 中列出的备用对象库中的对象，以及 $GIT_DIR/objects/pack 和备用对象库中相应 pack 子目录中的打包 Git 档案。 这现在是默认的；你可以用 --no-full 关闭它。"

#. type: Labeled list
#: en/git-fsck.txt:64
#, ignore-same, no-wrap, priority:100
msgid "--connectivity-only"
msgstr "--connectivity-only"

#. type: Plain text
#: en/git-fsck.txt:72
#, priority:100
msgid "Check only the connectivity of reachable objects, making sure that any objects referenced by a reachable tag, commit, or tree is present. This speeds up the operation by avoiding reading blobs entirely (though it does still check that referenced blobs exist). This will detect corruption in commits and trees, but not do any semantic checks (e.g., for format errors). Corruption in blob objects will not be detected at all."
msgstr "只检查可达对象的连接性，确保可达标签、提交或树所引用的任何对象都存在。这样可以完全避免读取 blobs，从而加快操作速度（尽管它仍然会检查被引用的 blobs 是否存在）。这将检测提交和树的损坏，但不做任何语义检查（例如，格式错误）。blob 对象中的损坏将完全不会被检测到。"

#. type: Plain text
#: en/git-fsck.txt:76
#, priority:100
msgid "Unreachable tags, commits, and trees will also be accessed to find the tips of dangling segments of history. Use `--no-dangling` if you don't care about this output and want to speed it up further."
msgstr "无法到达的标签、提交和树也会被访问，以找到历史的悬空部分的提示。如果你不关心这个输出并想进一步加快它的速度，请使用 `--no-dangling`。"

#. type: Labeled list
#: en/git-fsck.txt:77 en/git-index-pack.txt:82 en/git-mktag.txt:43 en/git-unpack-objects.txt:44
#, ignore-same, no-wrap, priority:100
msgid "--strict"
msgstr "--strict"

#. type: Plain text
#: en/git-fsck.txt:84
#, priority:100
msgid "Enable more strict checking, namely to catch a file mode recorded with g+w bit set, which was created by older versions of Git.  Existing repositories, including the Linux kernel, Git itself, and sparse repository have old objects that triggers this check, but it is recommended to check new projects with this flag."
msgstr "启用更严格的检查，即抓取记录有 g+w 位的文件模式，这是由旧版本的 Git 创建的。 现有的仓库，包括 Linux 内核、Git 本身和稀疏仓库都有旧的对象，会触发这个检查，但建议用这个标志检查新项目。"

#. type: Plain text
#: en/git-fsck.txt:87
#, priority:100
msgid "Be chatty."
msgstr "要健谈。"

#. type: Labeled list
#: en/git-fsck.txt:88
#, ignore-same, no-wrap, priority:100
msgid "--lost-found"
msgstr "--lost-found"

#. type: Plain text
#: en/git-fsck.txt:93
#, priority:100
msgid "Write dangling objects into .git/lost-found/commit/ or .git/lost-found/other/, depending on type.  If the object is a blob, the contents are written into the file, rather than its object name."
msgstr "将悬空的对象写入 .git/lost-found/commit/ 或 .git/lost-found/other/，具体取决于类型。 如果对象是一个 blob，其内容将被写入文件，而不是其对象名称。"

#. type: Labeled list
#: en/git-fsck.txt:94
#, ignore-same, no-wrap, priority:100
msgid "--name-objects"
msgstr "--name-objects"

#. type: Plain text
#: en/git-fsck.txt:99
#, priority:100
msgid "When displaying names of reachable objects, in addition to the SHA-1 also display a name that describes *how* they are reachable, compatible with linkgit:git-rev-parse[1], e.g.  `HEAD@{1234567890}~25^2:src/`."
msgstr "当显示可达对象的名称时，除了 SHA-1外，还显示描述 *如何* 可达的名称，与 linkgit:git-rev-parse[1] 兼容，例如，`HEAD@{1234567890}~25^2:src/`。"

#. type: Plain text
#: en/git-fsck.txt:106
#, priority:100
msgid "Progress status is reported on the standard error stream by default when it is attached to a terminal, unless --no-progress or --verbose is specified. --progress forces progress status even if the standard error stream is not directed to a terminal."
msgstr "除非指定 --no-progress 或 --verbose，否则当标准错误流连接到终端时，默认情况下会报告进度状态。--progress 即使标准错误流没有指向终端，也会强制显示进度状态。"

#. type: Plain text
#: en/git-fsck.txt:123
#, priority:100
msgid "git-fsck tests SHA-1 and general object sanity, and it does full tracking of the resulting reachability and everything else. It prints out any corruption it finds (missing or bad objects), and if you use the `--unreachable` flag it will also print out objects that exist but that aren't reachable from any of the specified head nodes (or the default set, as mentioned above)."
msgstr "git-fsck 测试 SHA-1和一般对象的正确性，并对结果的可及性和其他一切进行全面跟踪。它打印出它发现的任何损坏（缺失或坏的对象），如果你使用 `--unreachable` 标志，它也会打印出存在但从任何指定的头部节点（或默认集，如上所述）无法到达的对象。"

#. type: Plain text
#: en/git-fsck.txt:127
#, priority:100
msgid "Any corrupt objects you will have to find in backups or other archives (i.e., you can just remove them and do an 'rsync' with some other site in the hopes that somebody else has the object you have corrupted)."
msgstr "任何损坏的对象，你将不得不在备份或其他档案中找到（也就是说，你可以直接删除它们，并与其他网站做一个 'rsync'，希望别人拥有你损坏的对象）。"

#. type: Plain text
#: en/git-fsck.txt:130
#, priority:100
msgid "If core.commitGraph is true, the commit-graph file will also be inspected using 'git commit-graph verify'. See linkgit:git-commit-graph[1]."
msgstr "如果 core.commitGraph 为真，提交的图形文件也将用 'git commit-graph verify' 来检查。见 linkgit:git-commit-graph[1]。"

#. type: Title -
#: en/git-fsck.txt:132
#, no-wrap, priority:100
msgid "Extracted Diagnostics"
msgstr "提取的诊断方法"

#. type: Labeled list
#: en/git-fsck.txt:134
#, no-wrap, priority:100
msgid "unreachable <type> <object>"
msgstr "无法到达 <类型> <对象> 的问题"

#. type: Plain text
#: en/git-fsck.txt:141
#, fuzzy, priority:100
msgid "The <type> object <object>, isn't actually referred to directly or indirectly in any of the trees or commits seen. This can mean that there's another root node that you're not specifying or that the tree is corrupt. If you haven't missed a root node then you might as well delete unreachable nodes since they can't be used."
msgstr "<类型> 对象 <object>，实际上在看到的任何树或提交中都没有直接或间接地提到过。这可能意味着还有一个根节点没有被你指定，或者树被破坏了。如果你没有漏掉一个根节点，那么你不妨删除不可达的节点，因为它们不能被使用。"

#. type: Labeled list
#: en/git-fsck.txt:142
#, no-wrap, priority:100
msgid "missing <type> <object>"
msgstr "缺少 <类型> <对象>"

#. type: Plain text
#: en/git-fsck.txt:145
#, priority:100
msgid "The <type> object <object>, is referred to but isn't present in the database."
msgstr "<类型> 对象 <object>，被提及但不存在于数据库中。"

#. type: Labeled list
#: en/git-fsck.txt:146
#, no-wrap, priority:100
msgid "dangling <type> <object>"
msgstr "悬空的 <类型> <对象>"

#. type: Plain text
#: en/git-fsck.txt:149
#, priority:100
msgid "The <type> object <object>, is present in the database but never 'directly' used. A dangling commit could be a root node."
msgstr "<类型> 对象 <object>，存在于数据库中，但从未 'directly' 使用。一个悬空的提交可能是一个根节点。"

#. type: Labeled list
#: en/git-fsck.txt:150
#, no-wrap, priority:100
msgid "hash mismatch <object>"
msgstr "哈希值不匹配 <对象>"

#. type: Plain text
#: en/git-fsck.txt:154
#, priority:100
msgid "The database has an object whose hash doesn't match the object database value.  This indicates a serious data integrity problem."
msgstr "数据库中有一个对象的哈希值与对象数据库的值不一致。 这表明一个严重的数据完整性问题。"

#. type: Title -
#: en/git-fsck.txt:157
#, no-wrap, priority:100
msgid "FSCK MESSAGES"
msgstr "FSCK 信息"

#. type: Plain text
#: en/git-fsck.txt:163
#, priority:100
msgid "The following lists the types of errors `git fsck` detects and what each error means, with their default severity.  The severity of the error, other than those that are marked as \"(FATAL)\", can be tweaked by setting the corresponding `fsck.<msg-id>` configuration variable."
msgstr "下面列出了 `git fsck` 检测的错误类型和每个错误的含义，以及它们的默认严重程度。 除了那些被标记为 \"(FATAL)\" 的错误，其他错误的严重程度可以通过设置相应的 `fsck.<msg-id>` 配置变量来调整。"

#. type: Title -
#: en/git-fsck.txt:168 en/git.txt:459
#, fuzzy, no-wrap, priority:100
msgid "Environment Variables"
msgstr "环境变量"

#. type: Labeled list
#: en/git-fsck.txt:170
#, ignore-same, no-wrap, priority:100
msgid "GIT_OBJECT_DIRECTORY"
msgstr "GIT_OBJECT_DIRECTORY"

#. type: Plain text
#: en/git-fsck.txt:172
#, priority:100
msgid "used to specify the object database root (usually $GIT_DIR/objects)"
msgstr "用来指定对象数据库的根（通常是 $GIT_DIR/objects）"

#. type: Labeled list
#: en/git-fsck.txt:173
#, ignore-same, no-wrap, priority:100
msgid "GIT_INDEX_FILE"
msgstr "GIT_INDEX_FILE"

#. type: Plain text
#: en/git-fsck.txt:175
#, priority:100
msgid "used to specify the index file of the index"
msgstr "用来指定索引的索引文件"

#. type: Labeled list
#: en/git-fsck.txt:176
#, ignore-same, no-wrap, priority:100
msgid "GIT_ALTERNATE_OBJECT_DIRECTORIES"
msgstr "GIT_ALTERNATE_OBJECT_DIRECTORIES"

#. type: Plain text
#: en/git-fsck.txt:178
#, priority:100
msgid "used to specify additional object database roots (usually unset)"
msgstr "用来指定额外的对象数据库根（通常不设置）"

#. type: Title =
#: en/git-gc.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-gc(1)"
msgstr "git-gc(1)"

#. type: Plain text
#: en/git-gc.txt:7
#, fuzzy, priority:100
msgid "git-gc - Cleanup unnecessary files and optimize the local repository"
msgstr "git-gc - Cleanup unnecessary files and optimize the local repository"

#. type: Plain text
#: en/git-gc.txt:13
#, fuzzy, no-wrap, priority:100
msgid "'git gc' [--aggressive] [--auto] [--quiet] [--prune=<date> | --no-prune] [--force] [--keep-largest-pack]\n"
msgstr "'git gc' [--aggressive] [--auto] [--quiet] [--prune=<date> | --no-prune] [--force] [--keep-largest-pack]\n"

#. type: Plain text
#: en/git-gc.txt:22
#, priority:100
msgid "Runs a number of housekeeping tasks within the current repository, such as compressing file revisions (to reduce disk space and increase performance), removing unreachable objects which may have been created from prior invocations of 'git add', packing refs, pruning reflog, rerere metadata or stale working trees. May also update ancillary indexes such as the commit-graph."
msgstr "在当前版本库中执行一些内务管理任务，比如压缩文件修订（以减少磁盘空间并提高性能），移除之前调用 'git add' 所创建的不可达对象，打包引用，修剪引用日志、rerere metadata 或过时的工作区。也可以更新辅助索引，如提交图。"

#. type: Plain text
#: en/git-gc.txt:27
#, priority:100
msgid "When common porcelain operations that create objects are run, they will check whether the repository has grown substantially since the last maintenance, and if so run `git gc` automatically. See `gc.auto` below for how to disable this behavior."
msgstr "当运行创建对象的普通上层命令操作时，它们会检查仓库在上次维护后是否有大幅增长，如果有，就自动运行 `git gc`。参见下面的 `gc.auto` 以了解如何禁用这一行为。"

#. type: Plain text
#: en/git-gc.txt:33
#, priority:100
msgid "Running `git gc` manually should only be needed when adding objects to a repository without regularly running such porcelain commands, to do a one-off repository optimization, or e.g. to clean up a suboptimal mass-import. See the \"PACKFILE OPTIMIZATION\" section in linkgit:git-fast-import[1] for more details on the import case."
msgstr "手动运行 `git gc` 应该只在向仓库添加对象而不定期运行这种上层命令时才需要，以进行一次性的仓库优化，或者例如清理次优的大规模导入。关于导入情况的更多细节，请参见 linkgit:git-fast-import[1] 中的 “包装文件优化” 部分。"

#. type: Labeled list
#: en/git-gc.txt:37 en/git-read-tree.txt:72
#, ignore-same, no-wrap, priority:100
msgid "--aggressive"
msgstr "--aggressive"

#. type: Plain text
#: en/git-gc.txt:43
#, priority:100
msgid "Usually 'git gc' runs very quickly while providing good disk space utilization and performance.  This option will cause 'git gc' to more aggressively optimize the repository at the expense of taking much more time.  The effects of this optimization are mostly persistent. See the \"AGGRESSIVE\" section below for details."
msgstr "通常，'git gc' 运行得非常快，同时提供良好的磁盘空间利用率和性能。 这个选项会使 'git gc' 更积极地优化仓库，代价是花费更多的时间。 这种优化的效果大多是持续性的。详情见下面的 \"AGGRESSIVE\" 部分。"

#. type: Labeled list
#: en/git-gc.txt:44
#, ignore-same, no-wrap, priority:100
msgid "--auto"
msgstr "--auto"

#. type: Plain text
#: en/git-gc.txt:47
#, priority:100
msgid "With this option, 'git gc' checks whether any housekeeping is required; if not, it exits without performing any work."
msgstr "有了这个选项，'git gc' 就会检查是否需要任何内务处理；如果不需要，它就会退出，不执行任何工作。"

#. type: Plain text
#: en/git-gc.txt:50
#, priority:100
msgid "See the `gc.auto` option in the \"CONFIGURATION\" section below for how this heuristic works."
msgstr "关于这个启发式的工作原理，请看下面 “配置” 部分的 `gc.auto` 选项。"

#. type: Plain text
#: en/git-gc.txt:55
#, ignore-ellipsis, priority:100
msgid "Once housekeeping is triggered by exceeding the limits of configuration options such as `gc.auto` and `gc.autoPackLimit`, all other housekeeping tasks (e.g. rerere, working trees, reflog...) will be performed as well."
msgstr "一旦超过配置选项如 `gc.auto` 和 `gc.autoPackLimit` 的限制而触发内务管理，所有其他内务管理任务（如 reere、working trees、reflog...）也将被执行。"

#. type: Labeled list
#: en/git-gc.txt:57
#, ignore-same, no-wrap, priority:100
msgid "--[no-]cruft"
msgstr "--[no-]cruft"

#. type: Plain text
#: en/git-gc.txt:61
#, priority:100
msgid "When expiring unreachable objects, pack them separately into a cruft pack instead of storing them as loose objects. `--cruft` is on by default."
msgstr "当无法到达的对象过期时，将它们单独打包到一个 cruft 包中，而不是将它们作为散装对象存储。`--cruft` 是默认开启的。"

#. type: Labeled list
#: en/git-gc.txt:62
#, no-wrap, priority:100
msgid "--prune=<date>"
msgstr "--prune=<日期>"

#. type: Plain text
#: en/git-gc.txt:69
#, priority:100
msgid "Prune loose objects older than date (default is 2 weeks ago, overridable by the config variable `gc.pruneExpire`).  --prune=now prunes loose objects regardless of their age and increases the risk of corruption if another process is writing to the repository concurrently; see \"NOTES\" below. --prune is on by default."
msgstr "修剪超过日期的松散对象（默认是 2 周前，可由配置变量 `gc.pruneExpire` 覆盖）。 --prune=now 删减松散对象，无论其年龄大小，如果有其他进程同时向仓库写入，则会增加损坏的风险；见下面的 “注意事项”。--prune 默认是打开的。"

#. type: Labeled list
#: en/git-gc.txt:70 en/git-pack-refs.txt:58
#, ignore-same, no-wrap, priority:100
msgid "--no-prune"
msgstr "--no-prune"

#. type: Plain text
#: en/git-gc.txt:72
#, priority:100
msgid "Do not prune any loose objects."
msgstr "不要修剪任何松散的对象。"

#. type: Plain text
#: en/git-gc.txt:75
#, priority:100
msgid "Suppress all progress reports."
msgstr "抑制所有进度报告。"

#. type: Plain text
#: en/git-gc.txt:79
#, priority:100
msgid "Force `git gc` to run even if there may be another `git gc` instance running on this repository."
msgstr "强制 `git gc` 运行，即使这个仓库可能有另一个 `git gc` 实例在运行。"

#. type: Labeled list
#: en/git-gc.txt:80
#, ignore-same, no-wrap, priority:100
msgid "--keep-largest-pack"
msgstr "--keep-largest-pack"

#. type: Plain text
#: en/git-gc.txt:85
#, priority:100
msgid "All packs except the largest non-cruft pack, any packs marked with a `.keep` file, and any cruft pack(s) are consolidated into a single pack. When this option is used, `gc.bigPackThreshold` is ignored."
msgstr "除了最大的非破坏性包，任何标有 `.keep` 文件的包，以及任何破坏性的包，都会被合并为一个包。当使用这个选项时，`gc.bigPackThreshold` 被忽略。"

#. type: Title -
#: en/git-gc.txt:87
#, fuzzy, no-wrap, priority:100
msgid "AGGRESSIVE"
msgstr "侵略的"

#. type: Plain text
#: en/git-gc.txt:94
#, priority:100
msgid "When the `--aggressive` option is supplied, linkgit:git-repack[1] will be invoked with the `-f` flag, which in turn will pass `--no-reuse-delta` to linkgit:git-pack-objects[1]. This will throw away any existing deltas and re-compute them, at the expense of spending much more time on the repacking."
msgstr "当提供 `--aggressive` 选项时，linkgit:git-repack[1] 将被调用，并带有 `-f` 标志，这又将把 `--no-reuse-delta` 传递给 linkgit:git-pack-objects[1]。这将丢弃任何现有的 delta 并重新计算，代价是在重新打包上花费更多的时间。"

#. type: Plain text
#: en/git-gc.txt:99
#, priority:100
msgid "The effects of this are mostly persistent, e.g. when packs and loose objects are coalesced into one another pack the existing deltas in that pack might get re-used, but there are also various cases where we might pick a sub-optimal delta from a newer pack instead."
msgstr "这方面的影响主要是持久性的，例如，当包和松散对象被凝聚成另一个包时，该包中现有的 delta 可能会被重新使用，但也有各种情况，我们可能会从一个较新的包中挑选一个次优 delta。"

#. type: Plain text
#: en/git-gc.txt:105
#, priority:100
msgid "Furthermore, supplying `--aggressive` will tweak the `--depth` and `--window` options passed to linkgit:git-repack[1]. See the `gc.aggressiveDepth` and `gc.aggressiveWindow` settings below. By using a larger window size we're more likely to find more optimal deltas."
msgstr "此外，提供 `--aggressive` 将调整传递给 linkgit:git-repack[1] 的 `--depth` 和 `--window` 选项。见下面的 `gc.aggressiveDepth` 和 `gc.aggressiveWindow` 设置。通过使用较大的窗口尺寸，我们更有可能找到更多的最佳 deltas。"

#. type: Plain text
#: en/git-gc.txt:111
#, priority:100
msgid "It's probably not worth it to use this option on a given repository without running tailored performance benchmarks on it. It takes a lot more time, and the resulting space/delta optimization may or may not be worth it. Not using this at all is the right trade-off for most users and their repositories."
msgstr "在没有运行定制的性能基准的情况下，在一个给定的仓库上使用这个选项可能是不值得的。它需要更多的时间，而由此产生的空间/延迟优化可能值得也可能不值得。对于大多数用户和他们的仓库来说，完全不使用这个选项是正确的权衡。"

#. type: Plain text
#: en/git-gc.txt:133
#, priority:100
msgid "'git gc' tries very hard not to delete objects that are referenced anywhere in your repository. In particular, it will keep not only objects referenced by your current set of branches and tags, but also objects referenced by the index, remote-tracking branches, reflogs (which may reference commits in branches that were later amended or rewound), and anything else in the refs/* namespace. Note that a note (of the kind created by 'git notes') attached to an object does not contribute in keeping the object alive. If you are expecting some objects to be deleted and they aren't, check all of those locations and decide whether it makes sense in your case to remove those references."
msgstr "'git gc' 非常努力地不删除在你的仓库中任何地方被引用的对象。特别是，它不仅会保留当前分支和标记集所引用的对象，还会保留索引、远程跟踪分支、 引用日志（可能引用了后来被修改或回绕的分支中的提交）以及 refs/* 名称空间中的任何其他对象。请注意，附在一个对象上的注释（由 'git notes' 创建的那种）并不有助于保持该对象的活力。如果你期待一些对象被删除，而它们没有被删除，请检查所有这些位置，并决定在你的情况下，删除这些引用是否有意义。"

#. type: Plain text
#: en/git-gc.txt:140
#, priority:100
msgid "On the other hand, when 'git gc' runs concurrently with another process, there is a risk of it deleting an object that the other process is using but hasn't created a reference to. This may just cause the other process to fail or may corrupt the repository if the other process later adds a reference to the deleted object. Git has two features that significantly mitigate this problem:"
msgstr "另一方面，当 'git gc' 与另一个进程同时运行时，它有可能删除另一个进程正在使用但还没有创建引用的对象。这可能会导致其他进程失败，或者如果其他进程后来添加了对被删除对象的引用，则可能会破坏仓库。Git 有两个功能可以大大缓解这个问题："

#. type: Plain text
#: en/git-gc.txt:143
#, priority:100
msgid "Any object with modification time newer than the `--prune` date is kept, along with everything reachable from it."
msgstr "任何修改时间早于 `--prune` 日期的对象都会被保留，同时也会保留所有可以到达的对象。"

#. type: Plain text
#: en/git-gc.txt:147
#, priority:100
msgid "Most operations that add an object to the database update the modification time of the object if it is already present so that #1 applies."
msgstr "大多数向数据库添加对象的操作都会更新对象的修改时间，如果它已经存在，那么 #1 就适用。"

#. type: Plain text
#: en/git-gc.txt:151
#, priority:100
msgid "However, these features fall short of a complete solution, so users who run commands concurrently have to live with some risk of corruption (which seems to be low in practice)."
msgstr "然而，这些功能并不是一个完整的解决方案，所以同时运行命令的用户不得不忍受一些损坏的风险（在实践中似乎很低）。"

#. type: Plain text
#: en/git-gc.txt:157
#, fuzzy, priority:100
msgid "The 'git gc --auto' command will run the 'pre-auto-gc' hook.  See linkgit:githooks[5] for more information."
msgstr "The 'git gc --auto' command will run the 'pre-auto-gc' hook.  See linkgit:githooks[5] for more information."

#. type: Plain text
#: en/git-gc.txt:165
#, ignore-same, priority:100
msgid "linkgit:git-prune[1] linkgit:git-reflog[1] linkgit:git-repack[1] linkgit:git-rerere[1]"
msgstr "linkgit:git-prune[1] linkgit:git-reflog[1] linkgit:git-repack[1] linkgit:git-rerere[1]"

#. type: Title =
#: en/git-get-tar-commit-id.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-get-tar-commit-id(1)"
msgstr "git-get-tar-commit-id(1)"

#. type: Plain text
#: en/git-get-tar-commit-id.txt:7
#, fuzzy, priority:100
msgid "git-get-tar-commit-id - Extract commit ID from an archive created using git-archive"
msgstr "git-get-tar-commit-id - Extract commit ID from an archive created using git-archive"

#. type: Plain text
#: en/git-get-tar-commit-id.txt:13
#, fuzzy, no-wrap, priority:100
msgid "'git get-tar-commit-id'\n"
msgstr "'git get-tar-commit-id'\n"

#. type: Plain text
#: en/git-get-tar-commit-id.txt:22
#, priority:100
msgid "Read a tar archive created by 'git archive' from the standard input and extract the commit ID stored in it.  It reads only the first 1024 bytes of input, thus its runtime is not influenced by the size of the tar archive very much."
msgstr "从标准输入中读取 'git archive' 创建的 tar 档案，并提取其中的提交 ID。 它只读取输入的前 1024 字节，因此它的运行时间不会受到 tar 压缩包大小的影响。"

#. type: Plain text
#: en/git-get-tar-commit-id.txt:27
#, priority:100
msgid "If no commit ID is found, 'git get-tar-commit-id' quietly exists with a return code of 1.  This can happen if the archive had not been created using 'git archive' or if the first parameter of 'git archive' had been a tree ID instead of a commit ID or tag."
msgstr "如果没有找到提交 ID，'git get-tar-commit-id' 就会悄悄存在，返回代码为 1。如果档案没有用 'git archive' 创建，或者 'git archive' 的第一个参数是树的 ID 而不是提交 ID 或标签，就会发生这种情况。"

#. type: Title =
#: en/git-grep.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-grep(1)"
msgstr "git-grep(1)"

#. type: Plain text
#: en/git-grep.txt:7
#, fuzzy, priority:100
msgid "git-grep - Print lines matching a pattern"
msgstr "git-grep - Print lines matching a pattern"

#. type: Plain text
#: en/git-grep.txt:33
#, fuzzy, ignore-ellipsis, no-wrap, priority:100
msgid ""
"'git grep' [-a | --text] [-I] [--textconv] [-i | --ignore-case] [-w | --word-regexp]\n"
"\t   [-v | --invert-match] [-h|-H] [--full-name]\n"
"\t   [-E | --extended-regexp] [-G | --basic-regexp]\n"
"\t   [-P | --perl-regexp]\n"
"\t   [-F | --fixed-strings] [-n | --line-number] [--column]\n"
"\t   [-l | --files-with-matches] [-L | --files-without-match]\n"
"\t   [(-O | --open-files-in-pager) [<pager>]]\n"
"\t   [-z | --null]\n"
"\t   [ -o | --only-matching ] [-c | --count] [--all-match] [-q | --quiet]\n"
"\t   [--max-depth <depth>] [--[no-]recursive]\n"
"\t   [--color[=<when>] | --no-color]\n"
"\t   [--break] [--heading] [-p | --show-function]\n"
"\t   [-A <post-context>] [-B <pre-context>] [-C <context>]\n"
"\t   [-W | --function-context]\n"
"\t   [(-m | --max-count) <num>]\n"
"\t   [--threads <num>]\n"
"\t   [-f <file>] [-e] <pattern>\n"
"\t   [--and|--or|--not|(|)|-e <pattern>...]\n"
"\t   [--recurse-submodules] [--parent-basename <basename>]\n"
"\t   [ [--[no-]exclude-standard] [--cached | --no-index | --untracked] | <tree>...]\n"
"\t   [--] [<pathspec>...]\n"
msgstr ""
"'git grep' [-a | --text] [-I] [--textconv] [-i | --ignore-case] [-w | --word-regexp]\n"
"\t   [-v | --invert-match] [-h|-H] [--full-name]\n"
"\t   [-E | --extended-regexp] [-G | --basic-regexp]\n"
"\t   [-P | --perl-regexp]\n"
"\t   [-F | --fixed-strings] [-n | --line-number] [--column]\n"
"\t   [-l | --files-with-matches] [-L | --files-without-match]\n"
"\t   [(-O | --open-files-in-pager) [<分页器>]]\n"
"\t   [-z | --null]\n"
"\t   [ -o | --only-matching ] [-c | --count] [--all-match] [-q | --quiet]\n"
"\t   [--max-depth <depth>] [--[no-]recursive]\n"
"\t   [--color[=<when>] | --no-color]\n"
"\t   [--break] [--heading] [-p | --show-function]\n"
"\t   [-A <post-context>] [-B <pre-context>] [-C <context>]\n"
"\t   [-W | --function-context]\n"
"\t   [(-m | --max-count) <num>]\n"
"\t   [--threads <num>]\n"
"\t   [-f <file>] [-e] <模式>\n"
"\t   [--and|--or|--not|(|)|-e <模式>...]\n"
"\t   [--recurse-submodules] [--parent-basename <basename>]\n"
"\t   [ [--[no-]exclude-standard] [--cached | --no-index | --untracked] | <目录树>...]\n"
"\t   [--] [<路径规范>...]\n"

#. type: Plain text
#: en/git-grep.txt:40
#, priority:100
msgid "Look for specified patterns in the tracked files in the work tree, blobs registered in the index file, or blobs in given tree objects.  Patterns are lists of one or more search expressions separated by newline characters.  An empty string as search expression matches all lines."
msgstr "在工作区中的跟踪文件、在索引文件中注册的 blobs 或给定树对象中的 blobs 中寻找指定的模式。 模式是由一个或多个搜索表达式组成的列表，用换行符分隔。 一个空的字符串作为搜索表达式可以匹配所有的行。"

#. type: Plain text
#: en/git-grep.txt:47
#, priority:100
msgid "Instead of searching tracked files in the working tree, search blobs registered in the index file."
msgstr "与其搜索工作区中的跟踪文件，不如搜索索引文件中注册的 blobs。"

#. type: Plain text
#: en/git-grep.txt:50
#, priority:100
msgid "Search files in the current directory that is not managed by Git."
msgstr "搜索当前目录中不被 Git 管理的文件。"

#. type: Labeled list
#: en/git-grep.txt:51
#, ignore-same, no-wrap, priority:100
msgid "--untracked"
msgstr "--untracked"

#. type: Plain text
#: en/git-grep.txt:54
#, priority:100
msgid "In addition to searching in the tracked files in the working tree, search also in untracked files."
msgstr "除了在工作区中的跟踪文件中搜索外，还可以在未跟踪的文件中搜索。"

#. type: Labeled list
#: en/git-grep.txt:55
#, ignore-same, no-wrap, priority:100
msgid "--no-exclude-standard"
msgstr "--no-exclude-standard"

#. type: Plain text
#: en/git-grep.txt:58
#, priority:100
msgid "Also search in ignored files by not honoring the `.gitignore` mechanism. Only useful with `--untracked`."
msgstr "也可以通过不遵守 `.gitignore` 机制在被忽略的文件中搜索。只对 `--untracked` 有用。"

#. type: Labeled list
#: en/git-grep.txt:59 en/git-ls-files.txt:125
#, ignore-same, no-wrap, priority:100
msgid "--exclude-standard"
msgstr "--exclude-standard"

#. type: Plain text
#: en/git-grep.txt:63
#, priority:100
msgid "Do not pay attention to ignored files specified via the `.gitignore` mechanism.  Only useful when searching files in the current directory with `--no-index`."
msgstr "不注意通过 `.gitignore` 机制指定的被忽略的文件。 只有在用 `--no-index` 搜索当前目录下的文件时才有用。"

#. type: Plain text
#: en/git-grep.txt:70
#, priority:100
msgid "Recursively search in each submodule that is active and checked out in the repository.  When used in combination with the <tree> option the prefix of all submodule output will be the name of the parent project's <tree> object. This option has no effect if `--no-index` is given."
msgstr "递归搜索在仓库中激活和检出的每个子模块。 当与 <tree> 选项结合使用时，所有子模块输出的前缀将是父项目的 <tree> 对象的名称。如果给了 `--no-index`，这个选项就没有效果。"

#. type: Plain text
#: en/git-grep.txt:74
#, priority:100
msgid "Process binary files as if they were text."
msgstr "像处理文本一样处理二进制文件。"

#. type: Plain text
#: en/git-grep.txt:77
#, priority:100
msgid "Honor textconv filter settings."
msgstr "认可 textconv 过滤器设置。"

#. type: Plain text
#: en/git-grep.txt:81
#, priority:100
msgid "Do not honor textconv filter settings.  This is the default."
msgstr "不用认可 textconv 过滤器的设置。 这是默认的。"

#. type: Plain text
#: en/git-grep.txt:86
#, priority:100
msgid "Ignore case differences between the patterns and the files."
msgstr "忽略图案和文件之间的大小写差异。"

#. type: Labeled list
#: en/git-grep.txt:87
#, fuzzy, no-wrap, priority:100
msgid "-I"
msgstr "-I"

#. type: Plain text
#: en/git-grep.txt:89
#, priority:100
msgid "Don't match the pattern in binary files."
msgstr "不匹配二进制文件中的模式。"

#. type: Labeled list
#: en/git-grep.txt:90
#, fuzzy, no-wrap, priority:100
msgid "--max-depth <depth>"
msgstr "--max-depth <depth>"

#. type: Plain text
#: en/git-grep.txt:96
#, priority:100
msgid "For each <pathspec> given on command line, descend at most <depth> levels of directories. A value of -1 means no limit.  This option is ignored if <pathspec> contains active wildcards.  In other words if \"a*\" matches a directory named \"a*\", \"*\" is matched literally so --max-depth is still effective."
msgstr "对于命令行上给出的每个 <路径规范>，最多下降 <深度> 级目录。值为-1意味着没有限制。 如果 <路径规范> 包含有效的通配符，这个选项会被忽略。 换句话说，如果 \"a*\" 匹配名为 \"a* \"的目录，\"*\" 就会被匹配，所以 --max-depth 仍然有效。"

#. type: Labeled list
#: en/git-grep.txt:98 en/git-submodule.txt:421
#, ignore-same, no-wrap, priority:220
msgid "--recursive"
msgstr "--recursive"

#. type: Plain text
#: en/git-grep.txt:100
#, priority:100
msgid "Same as `--max-depth=-1`; this is the default."
msgstr "与 `--max-depth=-1` 相同；这是默认值。"

#. type: Labeled list
#: en/git-grep.txt:101
#, ignore-same, no-wrap, priority:100
msgid "--no-recursive"
msgstr "--no-recursive"

#. type: Plain text
#: en/git-grep.txt:103
#, priority:100
msgid "Same as `--max-depth=0`."
msgstr "与 `--max-depth=0` 相同。"

#. type: Labeled list
#: en/git-grep.txt:105
#, ignore-same, no-wrap, priority:100
msgid "--word-regexp"
msgstr "--word-regexp"

#. type: Plain text
#: en/git-grep.txt:109
#, priority:100
msgid "Match the pattern only at word boundary (either begin at the beginning of a line, or preceded by a non-word character; end at the end of a line or followed by a non-word character)."
msgstr "只在词的边界处匹配模式（要么从一行的开头开始，要么前面是一个非词的字符；要么在一行的结尾结束，要么后面是一个非词的字符）。"

#. type: Labeled list
#: en/git-grep.txt:111
#, ignore-same, no-wrap, priority:100
msgid "--invert-match"
msgstr "--invert-match"

#. type: Plain text
#: en/git-grep.txt:113
#, priority:100
msgid "Select non-matching lines."
msgstr "选择非匹配的行。"

#. type: Plain text
#: en/git-grep.txt:121
#, priority:100
msgid "By default, the command shows the filename for each match.  `-h` option is used to suppress this output.  `-H` is there for completeness and does not do anything except it overrides `-h` given earlier on the command line."
msgstr "默认情况下，该命令显示每个匹配的文件名。 `-h` 选项用于抑制这种输出。 `-H` 是为了完整性而存在的，除了覆盖先前在命令行中给出的 `-h` 外，它不做任何事情。"

#. type: Labeled list
#: en/git-grep.txt:122 en/git-ls-files.txt:174 en/git-ls-tree.txt:78
#, ignore-same, no-wrap, priority:100
msgid "--full-name"
msgstr "--full-name"

#. type: Plain text
#: en/git-grep.txt:127 en/git-ls-files.txt:179
#, priority:100
msgid "When run from a subdirectory, the command usually outputs paths relative to the current directory.  This option forces paths to be output relative to the project top directory."
msgstr "当从一个子目录运行时，该命令通常会输出相对于当前目录的路径。 这个选项强制输出相对于项目顶层目录的路径。"

#. type: Labeled list
#: en/git-grep.txt:128 en/rev-list-options.txt:87
#, fuzzy, no-wrap, priority:260
msgid "-E"
msgstr "-E"

#. type: Labeled list
#: en/git-grep.txt:129 en/rev-list-options.txt:88
#, ignore-same, no-wrap, priority:260
msgid "--extended-regexp"
msgstr "--extended-regexp"

#. type: Labeled list
#: en/git-grep.txt:130
#, fuzzy, no-wrap, priority:100
msgid "-G"
msgstr "-G"

#. type: Labeled list
#: en/git-grep.txt:131 en/rev-list-options.txt:83
#, ignore-same, no-wrap, priority:260
msgid "--basic-regexp"
msgstr "--basic-regexp"

#. type: Plain text
#: en/git-grep.txt:134
#, priority:100
msgid "Use POSIX extended/basic regexp for patterns.  Default is to use basic regexp."
msgstr "对模式使用 POSIX 扩展/基本的正则表达式。 默认是使用基本的正则表达式。"

#. type: Labeled list
#: en/git-grep.txt:136 en/rev-list-options.txt:98
#, ignore-same, no-wrap, priority:260
msgid "--perl-regexp"
msgstr "--perl-regexp"

#. type: Plain text
#: en/git-grep.txt:138
#, priority:100
msgid "Use Perl-compatible regular expressions for patterns."
msgstr "使用与 Perl 兼容的正则表达式的模式。"

#. type: Plain text
#: en/git-grep.txt:142 en/rev-list-options.txt:105
#, priority:260
msgid "Support for these types of regular expressions is an optional compile-time dependency. If Git wasn't compiled with support for them providing this option will cause it to die."
msgstr "对这些类型的正则表达式的支持是一个可选的编译时依赖。如果Git在编译时没有对它们的支持，提供这个选项将导致它死亡。"

#. type: Labeled list
#: en/git-grep.txt:143 en/git-repack.txt:91 en/rev-list-options.txt:92
#, fuzzy, no-wrap, priority:260
msgid "-F"
msgstr "-F"

#. type: Labeled list
#: en/git-grep.txt:144 en/rev-list-options.txt:93
#, ignore-same, no-wrap, priority:260
msgid "--fixed-strings"
msgstr "--fixed-strings"

#. type: Plain text
#: en/git-grep.txt:147
#, priority:100
msgid "Use fixed strings for patterns (don't interpret pattern as a regex)."
msgstr "使用固定的字符串来表示模式（不要把模式解释为一个重合词）。"

#. type: Labeled list
#: en/git-grep.txt:149
#, ignore-same, no-wrap, priority:100
msgid "--line-number"
msgstr "--line-number"

#. type: Plain text
#: en/git-grep.txt:151
#, priority:100
msgid "Prefix the line number to matching lines."
msgstr "在匹配的行前加上行号。"

#. type: Labeled list
#: en/git-grep.txt:152
#, ignore-same, no-wrap, priority:100
msgid "--column"
msgstr "--column"

#. type: Plain text
#: en/git-grep.txt:155
#, priority:100
msgid "Prefix the 1-indexed byte-offset of the first match from the start of the matching line."
msgstr "前缀为从匹配行开始的第一个匹配的索引的字节偏移量。"

#. type: Labeled list
#: en/git-grep.txt:157
#, ignore-same, no-wrap, priority:100
msgid "--files-with-matches"
msgstr "--files-with-matches"

#. type: Labeled list
#: en/git-grep.txt:159
#, fuzzy, no-wrap, priority:100
msgid "-L"
msgstr "-L"

#. type: Labeled list
#: en/git-grep.txt:160
#, ignore-same, no-wrap, priority:100
msgid "--files-without-match"
msgstr "--files-without-match"

#. type: Plain text
#: en/git-grep.txt:165
#, priority:100
msgid "Instead of showing every matched line, show only the names of files that contain (or do not contain) matches.  For better compatibility with 'git diff', `--name-only` is a synonym for `--files-with-matches`."
msgstr "不显示每个匹配行，只显示包含（或不包含）匹配的文件名。 为了与 'git diff' 更好地兼容，`--name-only` 是 `--files-with-matches` 的同义词。"

#. type: Labeled list
#: en/git-grep.txt:166
#, fuzzy, no-wrap, priority:100
msgid "-O[<pager>]"
msgstr "-O[<pager>]"

#. type: Labeled list
#: en/git-grep.txt:167
#, no-wrap, priority:100
msgid "--open-files-in-pager[=<pager>]"
msgstr "--在分页中打开文件[=<分页器>]"

#. type: Plain text
#: en/git-grep.txt:175
#, priority:100
msgid "Open the matching files in the pager (not the output of 'grep').  If the pager happens to be \"less\" or \"vi\", and the user specified only one pattern, the first file is positioned at the first match automatically. The `pager` argument is optional; if specified, it must be stuck to the option without a space. If `pager` is unspecified, the default pager will be used (see `core.pager` in linkgit:git-config[1])."
msgstr "在分页器中打开匹配的文件（不是 'grep' 的输出）。 如果分页器恰好是 \"less\" 或 \"vi\"，而用户只指定了一个模式，那么第一个文件就会自动定位在第一个匹配处。`pager` 参数是可选的；如果指定，它必须与选项卡在一起，没有空格。如果没有指定 `pager`，将使用默认的分页器（见 linkgit:git-config[1] 中的 `core.pager`）。"

#. type: Plain text
#: en/git-grep.txt:182
#, priority:100
msgid "Use \\0 as the delimiter for pathnames in the output, and print them verbatim. Without this option, pathnames with \"unusual\" characters are quoted as explained for the configuration variable core.quotePath (see linkgit:git-config[1])."
msgstr "使用\\0作为输出中路径名的分隔符，并逐字打印它们。按照配置变量core.quotePath的说明，引用带有“ unusual”字符的路径名 (查阅linkgit:git-config[1])。"

#. type: Labeled list
#: en/git-grep.txt:184
#, ignore-same, no-wrap, priority:100
msgid "--only-matching"
msgstr "--only-matching"

#. type: Plain text
#: en/git-grep.txt:187
#, priority:100
msgid "Print only the matched (non-empty) parts of a matching line, with each such part on a separate output line."
msgstr "只打印匹配行中的匹配（非空）部分，每一个这样的部分都在单独的输出行中。"

#. type: Labeled list
#: en/git-grep.txt:189 en/rev-list-options.txt:1193
#, ignore-same, no-wrap, priority:260
msgid "--count"
msgstr "--count"

#. type: Plain text
#: en/git-grep.txt:192
#, priority:100
msgid "Instead of showing every matched line, show the number of lines that match."
msgstr "与其显示每一个匹配的行，不如显示匹配的行数。"

#. type: Plain text
#: en/git-grep.txt:196
#, priority:100
msgid "Show colored matches.  The value must be always (the default), never, or auto."
msgstr "显示有颜色的匹配。 该值必须是总是（默认值）、从不、或自动。"

#. type: Plain text
#: en/git-grep.txt:201
#, priority:100
msgid "Turn off match highlighting, even when the configuration file gives the default to color output.  Same as `--color=never`."
msgstr "关闭匹配高亮，即使在配置文件中默认为彩色输出。 与 `--color=never` 相同。"

#. type: Labeled list
#: en/git-grep.txt:202
#, ignore-same, no-wrap, priority:100
msgid "--break"
msgstr "--break"

#. type: Plain text
#: en/git-grep.txt:204
#, priority:100
msgid "Print an empty line between matches from different files."
msgstr "在不同文件的匹配之间打印一个空行。"

#. type: Labeled list
#: en/git-grep.txt:205
#, ignore-same, no-wrap, priority:100
msgid "--heading"
msgstr "--heading"

#. type: Plain text
#: en/git-grep.txt:208
#, priority:100
msgid "Show the filename above the matches in that file instead of at the start of each shown line."
msgstr "在该文件中的匹配项上方显示文件名，而不是在每个显示行的开头。"

#. type: Labeled list
#: en/git-grep.txt:210
#, ignore-same, no-wrap, priority:100
msgid "--show-function"
msgstr "--show-function"

#. type: Plain text
#: en/git-grep.txt:216
#, priority:100
msgid "Show the preceding line that contains the function name of the match, unless the matching line is a function name itself.  The name is determined in the same way as `git diff` works out patch hunk headers (see 'Defining a custom hunk-header' in linkgit:gitattributes[5])."
msgstr "显示包含匹配的函数名的前一行，除非匹配的一行本身就是一个函数名。 该名称的确定方式与 `git diff` 编制补丁组头的方式相同（见 linkgit:gitattributes[5] 中的 ‘定义自定义组头’）。"

#. type: Labeled list
#: en/git-grep.txt:217
#, no-wrap, priority:100
msgid "-<num>"
msgstr "-<num>"

#. type: Labeled list
#: en/git-grep.txt:218
#, fuzzy, no-wrap, priority:100
msgid "-C <num>"
msgstr "-C <num>"

#. type: Labeled list
#: en/git-grep.txt:219
#, fuzzy, no-wrap, priority:100
msgid "--context <num>"
msgstr "--context <num>"

#. type: Plain text
#: en/git-grep.txt:222
#, priority:100
msgid "Show <num> leading and trailing lines, and place a line containing `--` between contiguous groups of matches."
msgstr "显示 <num> 前导行和后导行，并在连续的匹配组之间放置一个包含`--`的行。"

#. type: Labeled list
#: en/git-grep.txt:223
#, no-wrap, priority:100
msgid "-A <num>"
msgstr "-A <num>"

#. type: Labeled list
#: en/git-grep.txt:224
#, fuzzy, no-wrap, priority:100
msgid "--after-context <num>"
msgstr "--after-context <num>"

#. type: Plain text
#: en/git-grep.txt:227
#, priority:100
msgid "Show <num> trailing lines, and place a line containing `--` between contiguous groups of matches."
msgstr "显示 <num> 尾行，并在连续的匹配组之间放置一个包含 `--` 的行。"

#. type: Labeled list
#: en/git-grep.txt:228
#, no-wrap, priority:100
msgid "-B <num>"
msgstr "-B <num>"

#. type: Labeled list
#: en/git-grep.txt:229
#, no-wrap, priority:100
msgid "--before-context <num>"
msgstr "--before-context <num>"

#. type: Plain text
#: en/git-grep.txt:232
#, priority:100
msgid "Show <num> leading lines, and place a line containing `--` between contiguous groups of matches."
msgstr "显示 <num> 引导行，并在连续的匹配组之间放置一个包含 `--` 的行。"

#. type: Plain text
#: en/git-grep.txt:241
#, priority:100
msgid "Show the surrounding text from the previous line containing a function name up to the one before the next function name, effectively showing the whole function in which the match was found. The function names are determined in the same way as `git diff` works out patch hunk headers (see 'Defining a custom hunk-header' in linkgit:gitattributes[5])."
msgstr "显示从包含函数名的前一行到下一个函数名之前的周围文本，有效地显示找到匹配的整个函数。函数名的确定方式与 `git diff` 确定补丁组头的方式相同（见 linkgit:gitattributes[5] 中的 ‘定义自定义组头’）。"

#. type: Labeled list
#: en/git-grep.txt:242
#, fuzzy, no-wrap, priority:100
msgid "-m <num>"
msgstr "-C <num>"

#. type: Labeled list
#: en/git-grep.txt:243
#, fuzzy, no-wrap, priority:100
#| msgid "--max-count=<number>"
msgid "--max-count <num>"
msgstr "--max-count=<number>"

#. type: Plain text
#: en/git-grep.txt:249
#, priority:100
msgid "Limit the amount of matches per file. When using the `-v` or `--invert-match` option, the search stops after the specified number of non-matches. A value of -1 will return unlimited results (the default). A value of 0 will exit immediately with a non-zero status."
msgstr "限制每个文件的匹配数量。当使用 `-v` 或 `--invert-match` 选项时，搜索会在指定的非匹配数量后停止。值为 -1 将返回无限的结果（默认）。值为 0 将立即退出，状态为非零。"

#. type: Labeled list
#: en/git-grep.txt:250
#, fuzzy, no-wrap, priority:100
msgid "--threads <num>"
msgstr "--threads <num>"

#. type: Plain text
#: en/git-grep.txt:253
#, priority:100
msgid "Number of grep worker threads to use.  See `grep.threads` in 'CONFIGURATION' for more information."
msgstr "要使用的 grep 工作线程的数量。 更多信息见 “配置” 中的 `grep.threads`。"

#. type: Labeled list
#: en/git-grep.txt:254
#, fuzzy, no-wrap, priority:100
msgid "-f <file>"
msgstr "-f <file>"

#. type: Plain text
#: en/git-grep.txt:256
#, priority:100
msgid "Read patterns from <file>, one per line."
msgstr "从 <文件> 中读取模式，每行一个。"

#. type: Plain text
#: en/git-grep.txt:259
#, priority:100
msgid "Passing the pattern via <file> allows for providing a search pattern containing a \\0."
msgstr "通过<文件> 传递模式，可以提供一个包含一个 \\0 的搜索模式。"

#. type: Plain text
#: en/git-grep.txt:264
#, priority:100
msgid "Not all pattern types support patterns containing \\0. Git will error out if a given pattern type can't support such a pattern. The `--perl-regexp` pattern type when compiled against the PCRE v2 backend has the widest support for these types of patterns."
msgstr "不是所有的模式类型都支持包含 \\0 的模式。如果一个给定的模式类型不支持这样的模式，Git 会出错。`--perl-regexp` 模式类型在针对 PCRE v2 后端进行编译时，对这些类型的模式有最广泛的支持。"

#. type: Plain text
#: en/git-grep.txt:269
#, priority:100
msgid "In versions of Git before 2.23.0 patterns containing \\0 would be silently considered fixed. This was never documented, there were also odd and undocumented interactions between e.g. non-ASCII patterns containing \\0 and `--ignore-case`."
msgstr "在 2.23.0 之前的 Git 版本中，含有 \\0 的模式会被默默地认为是固定的。这一点从未被记录下来，还有一些奇怪的、未被记录的互动，例如包含 \\0 的非 ASCII 模式和 `--ignore-case` 之间。"

#. type: Plain text
#: en/git-grep.txt:273
#, priority:100
msgid "In future versions we may learn to support patterns containing \\0 for more search backends, until then we'll die when the pattern type in question doesn't support them."
msgstr "在未来的版本中，我们可能会学会为更多的搜索后端支持含有 \\0 的模式，在此之前，当有关的模式类型不支持它们时，我们就会死心。"

#. type: Plain text
#: en/git-grep.txt:279
#, priority:100
msgid "The next parameter is the pattern. This option has to be used for patterns starting with `-` and should be used in scripts passing user input to grep.  Multiple patterns are combined by 'or'."
msgstr "下一个参数是模式。这个选项必须用于以 `-` 开头的模式，并应在将用户输入传递给 grep 的脚本中使用。 多个模式用 'or' 组合。"

#. type: Labeled list
#: en/git-grep.txt:280
#, ignore-same, no-wrap, priority:100
msgid "--and"
msgstr "--and"

#. type: Labeled list
#: en/git-grep.txt:281
#, ignore-same, no-wrap, priority:100
msgid "--or"
msgstr "--or"

#. type: Labeled list
#: en/git-grep.txt:282 en/git-rev-parse.txt:139 en/rev-list-options.txt:151
#, ignore-same, no-wrap, priority:260
msgid "--not"
msgstr "--not"

#. type: Labeled list
#: en/git-grep.txt:283
#, fuzzy, ignore-ellipsis, no-wrap, priority:100
msgid "( ... )"
msgstr "( ... )"

#. type: Plain text
#: en/git-grep.txt:288
#, priority:100
msgid "Specify how multiple patterns are combined using Boolean expressions.  `--or` is the default operator.  `--and` has higher precedence than `--or`.  `-e` has to be used for all patterns."
msgstr "使用布尔表达式指定多个模式的组合方式。 `--or` 是默认的运算符。 `--and` 比 `--or` 有更高的优先权。 `-e` 必须用于所有模式。"

#. type: Labeled list
#: en/git-grep.txt:289 en/rev-list-options.txt:70
#, ignore-same, no-wrap, priority:260
msgid "--all-match"
msgstr "--all-match"

#. type: Plain text
#: en/git-grep.txt:293
#, priority:100
msgid "When giving multiple pattern expressions combined with `--or`, this flag is specified to limit the match to files that have lines to match all of them."
msgstr "当给出多个模式表达式与 `--or` 组合时，指定这个标志是为了将匹配限制在有行的文件中，以匹配所有的文件。"

#. type: Plain text
#: en/git-grep.txt:298
#, priority:100
msgid "Do not output matched lines; instead, exit with status 0 when there is a match and with non-zero status when there isn't."
msgstr "不输出匹配的行；相反，当有匹配时以状态 0 退出，没有匹配时以非零状态退出。"

#. type: Labeled list
#: en/git-grep.txt:299
#, fuzzy, ignore-ellipsis, no-wrap, priority:100
msgid "<tree>..."
msgstr "<tree>..."

#. type: Plain text
#: en/git-grep.txt:302
#, priority:100
msgid "Instead of searching tracked files in the working tree, search blobs in the given trees."
msgstr "与其在工作区中搜索被追踪的文件，不如在给定的目录树中搜索 blobs。"

#. type: Plain text
#: en/git-grep.txt:306
#, priority:100
msgid "Signals the end of options; the rest of the parameters are <pathspec> limiters."
msgstr "标志着选项的结束；其余的参数是 <路径规范> 限制器。"

#. type: Plain text
#: en/git-grep.txt:310
#, priority:100
msgid "If given, limit the search to paths matching at least one pattern.  Both leading paths match and glob(7) patterns are supported."
msgstr "如果给定，将搜索限制在与至少一个模式匹配的路径上。 前导路径匹配和 glob(7) 模式都被支持。"

#. type: Labeled list
#: en/git-grep.txt:317
#, fuzzy, no-wrap, priority:100
msgid "`git grep 'time_t' -- '*.[ch]'`"
msgstr "`git grep 'time_t' -- '*.[ch]'`"

#. type: Plain text
#: en/git-grep.txt:320
#, priority:100
msgid "Looks for `time_t` in all tracked .c and .h files in the working directory and its subdirectories."
msgstr "在工作目录及其子目录中所有跟踪的 .c 和 .h 文件中寻找 `time_t`。"

#. type: Labeled list
#: en/git-grep.txt:321
#, fuzzy, no-wrap, priority:100
msgid "`git grep -e '#define' --and \\( -e MAX_PATH -e PATH_MAX \\)`"
msgstr "`git grep -e '#define' --and \\( -e MAX_PATH -e PATH_MAX \\)`"

#. type: Plain text
#: en/git-grep.txt:324
#, priority:100
msgid "Looks for a line that has `#define` and either `MAX_PATH` or `PATH_MAX`."
msgstr "寻找有 `#define` 和 `MAX_PATH` 或 `PATH_MAX` 的行。"

#. type: Labeled list
#: en/git-grep.txt:325
#, fuzzy, no-wrap, priority:100
msgid "`git grep --all-match -e NODE -e Unexpected`"
msgstr "`git grep --all-match -e NODE -e Unexpected`"

#. type: Plain text
#: en/git-grep.txt:328
#, priority:100
msgid "Looks for a line that has `NODE` or `Unexpected` in files that have lines that match both."
msgstr "在文件中寻找有 `NODE` 或 `Unexpected` 字样的行，这些行与这两个字相匹配。"

#. type: Labeled list
#: en/git-grep.txt:329
#, fuzzy, no-wrap, priority:100
msgid "`git grep solution -- :^Documentation`"
msgstr "`git grep solution -- :^Documentation`"

#. type: Plain text
#: en/git-grep.txt:331
#, priority:100
msgid "Looks for `solution`, excluding files in `Documentation`."
msgstr "寻找 `solution`，排除 `Documentation`中的文件。"

#. type: Title -
#: en/git-grep.txt:333
#, no-wrap, priority:100
msgid "NOTES ON THREADS"
msgstr "线条的注释"

#. type: Plain text
#: en/git-grep.txt:337
#, priority:100
msgid "The `--threads` option (and the grep.threads configuration) will be ignored when `--open-files-in-pager` is used, forcing a single-threaded execution."
msgstr "当使用 `--open-files-in-pager` 时，`--threads` 选项（和 grep.threads 配置）将被忽略，强制单线程执行。"

#. type: Plain text
#: en/git-grep.txt:342
#, priority:100
msgid "When grepping the object store (with `--cached` or giving tree objects), running with multiple threads might perform slower than single threaded if `--textconv` is given and there're too many text conversions. So if you experience low performance in this case, it might be desirable to use `--threads=1`."
msgstr "当检索对象存储时（使用 `--cached` 或给出树状对象），如果给出 `--textconv` 并且有太多的文本转换，多线程运行可能比单线程运行要慢。因此，如果你在这种情况下遇到低性能，使用 `--threads=1` 可能是可取的。"

#. type: Title =
#: en/git-gui.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-gui(1)"
msgstr "git-gui(1)"

#. type: Plain text
#: en/git-gui.txt:7
#, priority:100
msgid "git-gui - A portable graphical interface to Git"
msgstr "git-gui - 一个可移植的git图形界面"

#. type: Plain text
#: en/git-gui.txt:12
#, fuzzy, no-wrap, priority:100
msgid "'git gui' [<command>] [<arguments>]\n"
msgstr "'git gui' [<command>] [arguments]\n"

#. type: Plain text
#: en/git-gui.txt:19
#, priority:100
msgid "A Tcl/Tk based graphical user interface to Git.  'git gui' focuses on allowing users to make changes to their repository by making new commits, amending existing ones, creating branches, performing local merges, and fetching/pushing to remote repositories."
msgstr "一个基于 Tcl/Tk 的 Git 图形化用户界面。 'git gui' 的重点是允许用户对他们的仓库进行修改，包括做出新的提交，修改现有的提交，创建分支，执行本地合并，以及获取/推送到远程仓库。"

#. type: Plain text
#: en/git-gui.txt:24
#, priority:100
msgid "Unlike 'gitk', 'git gui' focuses on commit generation and single file annotation and does not show project history.  It does however supply menu actions to start a 'gitk' session from within 'git gui'."
msgstr "与 'gitk' 不同，'git gui' 专注于提交生成和单一文件注释，不显示项目历史。 不过它提供了菜单操作，可以从 'git gui' 中启动 'gitk' 会话。"

#. type: Plain text
#: en/git-gui.txt:29
#, priority:100
msgid "'git gui' is known to work on all popular UNIX systems, Mac OS X, and Windows (under both Cygwin and MSYS).  To the extent possible OS specific user interface guidelines are followed, making 'git gui' a fairly native interface for users."
msgstr "众所周知，'git gui' 可以在所有流行的UNIX系统、Mac OS X 和 Windows（在 Cygwin 和 MSYS 下）运行。 在可能的范围内，遵循操作系统特定的用户界面准则，使 'git gui' 成为用户的一个相当原始的界面。"

#. type: Title -
#: en/git-gui.txt:31 en/git-p4.txt:63 en/git-remote.txt:44 en/git-rerere.txt:32 en/git-shell.txt:25 en/git-stash.txt:51 en/git-submodule.txt:33 en/git-svn.txt:29 en/git-worktree.txt:65
#, no-wrap, priority:240
msgid "COMMANDS"
msgstr "命令"

#. type: Labeled list
#: en/git-gui.txt:32
#, fuzzy, no-wrap, priority:100
msgid "blame"
msgstr "blame"

#. type: Plain text
#: en/git-gui.txt:35
#, priority:100
msgid "Start a blame viewer on the specified file on the given version (or working directory if not specified)."
msgstr "在指定的版本（如果没有指定，则为工作目录）上对指定的文件启动一个历史追溯查看器。"

#. type: Labeled list
#: en/git-gui.txt:36
#, fuzzy, no-wrap, priority:100
msgid "browser"
msgstr "浏览器"

#. type: Plain text
#: en/git-gui.txt:40
#, priority:100
msgid "Start a tree browser showing all files in the specified commit.  Files selected through the browser are opened in the blame viewer."
msgstr "启动一个树状浏览器，显示指定提交中的所有文件。 通过浏览器选择的文件会在历史追溯查看器中打开。"

#. type: Labeled list
#: en/git-gui.txt:41
#, no-wrap, priority:100
msgid "citool"
msgstr "citool"

#. type: Plain text
#: en/git-gui.txt:46
#, priority:100
msgid "Start 'git gui' and arrange to make exactly one commit before exiting and returning to the shell.  The interface is limited to only commit actions, slightly reducing the application's startup time and simplifying the menubar."
msgstr "启动 'git gui' 并安排在退出并返回 shell 之前正好做一次提交。 该界面只限于提交操作，稍微减少了应用程序的启动时间，并简化了菜单栏。"

#. type: Labeled list
#: en/git-gui.txt:47
#, fuzzy, no-wrap, priority:100
msgid "version"
msgstr "版本"

#. type: Plain text
#: en/git-gui.txt:49
#, priority:100
msgid "Display the currently running version of 'git gui'."
msgstr "显示当前运行的 'git gui' 的版本。"

#. type: Title -
#: en/git-gui.txt:52 en/git-whatchanged.txt:29
#, fuzzy, no-wrap, priority:100
msgid "Examples"
msgstr "例如"

#. type: Labeled list
#: en/git-gui.txt:53
#, fuzzy, no-wrap, priority:100
msgid "`git gui blame Makefile`"
msgstr "`git gui blame Makefile`"

#. type: Plain text
#: en/git-gui.txt:61
#, priority:100
msgid "Show the contents of the file 'Makefile' in the current working directory, and provide annotations for both the original author of each line, and who moved the line to its current location.  The uncommitted file is annotated, and uncommitted changes (if any) are explicitly attributed to 'Not Yet Committed'."
msgstr "显示当前工作目录中 'Makefile' 文件的内容，并为每一行的原作者和谁把这一行移到当前位置提供注释。 未提交的文件有注释，未提交的修改（如果有的话）被明确地归结为 ‘尚未提交’。"

#. type: Labeled list
#: en/git-gui.txt:62
#, no-wrap, priority:100
msgid "`git gui blame v0.99.8 Makefile`"
msgstr "`git gui blame v0.99.8 Makefile`"

#. type: Plain text
#: en/git-gui.txt:68
#, priority:100
msgid "Show the contents of 'Makefile' in revision 'v0.99.8' and provide annotations for each line.  Unlike the above example the file is read from the object database and not the working directory."
msgstr "显示修订版 'v0.99.8' 中 'Makefile' 的内容，并为每一行提供注释。 与上面的例子不同，该文件是从对象数据库而不是工作目录中读取的。"

#. type: Labeled list
#: en/git-gui.txt:69
#, fuzzy, no-wrap, priority:100
msgid "`git gui blame --line=100 Makefile`"
msgstr "`git gui blame --line=100 Makefile`"

#. type: Plain text
#: en/git-gui.txt:73
#, priority:100
msgid "Loads annotations as described above and automatically scrolls the view to center on line '100'."
msgstr "如上所述加载注释，并自动滚动视图至第 '100' 行中心。"

#. type: Labeled list
#: en/git-gui.txt:74
#, no-wrap, priority:100
msgid "`git gui citool`"
msgstr "`git gui citool`"

#. type: Plain text
#: en/git-gui.txt:79
#, priority:100
msgid "Make one commit and return to the shell when it is complete.  This command returns a non-zero exit code if the window was closed in any way other than by making a commit."
msgstr "进行一次提交，完成后返回到 shell。 如果窗口被关闭，而不是通过提交的方式，该命令会返回一个非零的退出代码。"

#. type: Labeled list
#: en/git-gui.txt:80
#, no-wrap, priority:100
msgid "`git gui citool --amend`"
msgstr "`git gui citool --amend`"

#. type: Plain text
#: en/git-gui.txt:84
#, priority:100
msgid "Automatically enter the 'Amend Last Commit' mode of the interface."
msgstr "自动进入界面的 ‘修正最后提交’ 模式。"

#. type: Labeled list
#: en/git-gui.txt:85
#, fuzzy, no-wrap, priority:100
msgid "`git gui citool --nocommit`"
msgstr "`git gui citool --nocommit`"

#. type: Plain text
#: en/git-gui.txt:91
#, priority:100
msgid "Behave as normal citool, but instead of making a commit simply terminate with a zero exit code. It still checks that the index does not contain any unmerged entries, so you can use it as a GUI version of linkgit:git-mergetool[1]"
msgstr "和普通的 citool 一样，但不做提交，而是以零退出代码结束。它仍然会检查索引是否包含任何未合并的条目，所以你可以把它当作 linkgit:git-mergetool[1] 的 GUI 版本"

#. type: Labeled list
#: en/git-gui.txt:92
#, fuzzy, no-wrap, priority:100
msgid "`git citool`"
msgstr "`git citool`"

#. type: Plain text
#: en/git-gui.txt:95
#, priority:100
msgid "Same as `git gui citool` (above)."
msgstr "与 `git gui citool`（上文）相同。"

#. type: Labeled list
#: en/git-gui.txt:96
#, fuzzy, no-wrap, priority:100
msgid "`git gui browser maint`"
msgstr "`git gui browser maint`"

#. type: Plain text
#: en/git-gui.txt:101
#, priority:100
msgid "Show a browser for the tree of the 'maint' branch.  Files selected in the browser can be viewed with the internal blame viewer."
msgstr "显示 'maint' 分支的树的浏览器。 在浏览器中选择的文件可以用内部责备查看器查看。"

#. type: Plain text
#: en/git-gui.txt:108
#, priority:100
msgid "The Git repository browser.  Shows branches, commit history and file differences.  gitk is the utility started by 'git gui''s Repository Visualize actions."
msgstr "Git 仓库浏览器。 gitk 是由 'git gui' 的 Repository Visualize 操作启动的实用程序，显示分支、提交历史和文件差异。"

#. type: Title -
#: en/git-gui.txt:110
#, fuzzy, no-wrap, priority:100
msgid "Other"
msgstr "其它"

#. type: Plain text
#: en/git-gui.txt:114
#, fuzzy, priority:100
msgid "'git gui' is actually maintained as an independent project, but stable versions are distributed as part of the Git suite for the convenience of end users."
msgstr "'git gui' is actually maintained as an independent project, but stable versions are distributed as part of the Git suite for the convenience of end users."

#. type: Plain text
#: en/git-gui.txt:116
#, priority:100
msgid "The official repository of the 'git gui' project can be found at:"
msgstr "'git gui' 项目的官方仓库可以在以下网址找到："

#. type: Plain text
#: en/git-gui.txt:118
#, fuzzy, no-wrap, priority:100
msgid "  https://github.com/prati0100/git-gui.git/\n"
msgstr "  https://github.com/prati0100/git-gui.git/\n"

#. type: Title =
#: en/git-hash-object.txt:2
#, ignore-same, no-wrap, priority:80
msgid "git-hash-object(1)"
msgstr "git-hash-object(1)"

#. type: Plain text
#: en/git-hash-object.txt:7
#, fuzzy, priority:80
#| msgid "git-hash-object - Compute object ID and optionally creates a blob from a file"
msgid "git-hash-object - Compute object ID and optionally create an object from a file"
msgstr "git-hash-object - 计算对象ID，并可选择从文件创建blob。"

#. type: Plain text
#: en/git-hash-object.txt:15
#, ignore-ellipsis, no-wrap, priority:80
msgid ""
"'git hash-object' [-t <type>] [-w] [--path=<file> | --no-filters]\n"
"\t\t[--stdin [--literally]] [--] <file>...\n"
"'git hash-object' [-t <type>] [-w] --stdin-paths [--no-filters]\n"
msgstr ""

#. type: Plain text
#: en/git-hash-object.txt:23
#, priority:80
msgid "Computes the object ID value for an object with specified type with the contents of the named file (which can be outside of the work tree), and optionally writes the resulting object into the object database.  Reports its object ID to its standard output.  When <type> is not specified, it defaults to \"blob\"."
msgstr ""

#. type: Labeled list
#: en/git-hash-object.txt:27
#, fuzzy, no-wrap, priority:80
msgid "-t <type>"
msgstr "-t <type>"

#. type: Plain text
#: en/git-hash-object.txt:30
#, priority:80
msgid "Specify the type of object to be created (default: \"blob\"). Possible values are `commit`, `tree`, `blob`, and `tag`."
msgstr ""

#. type: Plain text
#: en/git-hash-object.txt:33
#, priority:80
msgid "Actually write the object into the object database."
msgstr ""

#. type: Plain text
#: en/git-hash-object.txt:36
#, priority:80
msgid "Read the object from standard input instead of from a file."
msgstr ""

#. type: Labeled list
#: en/git-hash-object.txt:37
#, ignore-same, no-wrap, priority:80
msgid "--stdin-paths"
msgstr "--stdin-paths"

#. type: Plain text
#: en/git-hash-object.txt:40
#, priority:80
msgid "Read file names from the standard input, one per line, instead of from the command-line."
msgstr ""

#. type: Plain text
#: en/git-hash-object.txt:50
#, priority:80
msgid "Hash object as it were located at the given path. The location of file does not directly influence on the hash value, but path is used to determine what Git filters should be applied to the object before it can be placed to the object database, and, as result of applying filters, the actual blob put into the object database may differ from the given file. This option is mainly useful for hashing temporary files located outside of the working directory or files read from stdin."
msgstr ""

#. type: Labeled list
#: en/git-hash-object.txt:51
#, ignore-same, no-wrap, priority:80
msgid "--no-filters"
msgstr "--no-filters"

#. type: Plain text
#: en/git-hash-object.txt:56
#, priority:80
msgid "Hash the contents as is, ignoring any input filter that would have been chosen by the attributes mechanism, including the end-of-line conversion. If the file is read from standard input then this is always implied, unless the `--path` option is given."
msgstr ""

#. type: Labeled list
#: en/git-hash-object.txt:57
#, ignore-same, no-wrap, priority:80
msgid "--literally"
msgstr "--literally"

#. type: Plain text
#: en/git-hash-object.txt:62
#, priority:80
msgid "Allow `--stdin` to hash any garbage into a loose object which might not otherwise pass standard object parsing or git-fsck checks. Useful for stress-testing Git itself or reproducing characteristics of corrupt or bogus objects encountered in the wild."
msgstr ""

#. type: Title =
#: en/git-help.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-help(1)"
msgstr "git-help(1)"

#. type: Plain text
#: en/git-help.txt:7
#, priority:100
msgid "git-help - Display help information about Git"
msgstr "git-help - 显示有关git的帮助信息"

#. type: Plain text
#: en/git-help.txt:17
#, no-wrap, priority:100
msgid ""
"'git help' [-a|--all] [--[no-]verbose] [--[no-]external-commands] [--[no-]aliases]\n"
"'git help' [[-i|--info] [-m|--man] [-w|--web]] [<command>|<doc>]\n"
"'git help' [-g|--guides]\n"
"'git help' [-c|--config]\n"
"'git help' [--user-interfaces]\n"
"'git help' [--developer-interfaces]\n"
msgstr ""
"'git help' [-a|--all] [--[no-]verbose] [--[no-]external-commands] [--[no-]aliases]\n"
"'git help' [[-i|--info] [-m|--man] [-w|--web]] [<命令>|<文档>]\n"
"'git help' [-g|--guides]\n"
"'git help' [-c|--config]\n"
"'git help' [--user-interfaces]\n"
"'git help' [--developer-interfaces]\n"

#. type: Plain text
#: en/git-help.txt:24
#, priority:100
msgid "With no options and no '<command>' or '<doc>' given, the synopsis of the 'git' command and a list of the most commonly used Git commands are printed on the standard output."
msgstr "如果没有选项，也没有给出 '<命令>' 或 '<文档>'，'git' 命令的概要和最常用的 Git 命令的列表会被打印在标准输出上。"

#. type: Plain text
#: en/git-help.txt:27
#, priority:100
msgid "If the option `--all` or `-a` is given, all available commands are printed on the standard output."
msgstr "如果给出选项 `--all` 或 `--a`，所有可用的命令都会打印在标准输出上。"

#. type: Plain text
#: en/git-help.txt:30
#, priority:100
msgid "If the option `--guides` or `-g` is given, a list of the Git concept guides is also printed on the standard output."
msgstr "如果给了 `--guide` 或 `--g` 选项，Git 概念指南的列表也会打印在标准输出上。"

#. type: Plain text
#: en/git-help.txt:35
#, priority:100
msgid "If a command or other documentation is given, the relevant manual page will be brought up. The 'man' program is used by default for this purpose, but this can be overridden by other options or configuration variables."
msgstr "如果给出了一个命令或其他文件，相关的手册页就会被调出来。默认情况下使用 'man' 程序来实现这一目的，但这可以被其他选项或配置变量所覆盖。"

#. type: Plain text
#: en/git-help.txt:39
#, priority:100
msgid "If an alias is given, git shows the definition of the alias on standard output. To get the manual page for the aliased command, use `git <command> --help`."
msgstr "如果给了一个别名，git 会在标准输出上显示该别名的定义。要获得别名命令的手册页，请使用 `git <command> --help`。"

#. type: Plain text
#: en/git-help.txt:42
#, ignore-ellipsis, priority:100
msgid "Note that `git --help ...` is identical to `git help ...` because the former is internally converted into the latter."
msgstr "请注意，`git --help ...` 与 `git help ...` 相同，因为前者在内部被转换为后者。"

#. type: Plain text
#: en/git-help.txt:44
#, priority:100
msgid "To display the linkgit:git[1] man page, use `git help git`."
msgstr "要显示 linkgit:git[1] 的帮助页，请使用 `git help git`。"

#. type: Plain text
#: en/git-help.txt:46
#, priority:100
msgid "This page can be displayed with 'git help help' or `git help --help`"
msgstr "这个页面可以用 'git help help' 或 'git help --help' 显示"

#. type: Plain text
#: en/git-help.txt:52
#, priority:100
msgid "Prints all the available commands on the standard output."
msgstr "在标准输出上打印所有可用的命令。"

#. type: Labeled list
#: en/git-help.txt:53
#, ignore-same, no-wrap, priority:100
msgid "--no-external-commands"
msgstr "--no-external-commands"

#. type: Plain text
#: en/git-help.txt:56
#, priority:100
msgid "When used with `--all`, exclude the listing of external \"git-*\" commands found in the `$PATH`."
msgstr "当与 `--all` 一起使用时，排除在`$PATH` 中发现的外部 \"git-*\" 命令的列表。"

#. type: Labeled list
#: en/git-help.txt:57
#, ignore-same, no-wrap, priority:100
msgid "--no-aliases"
msgstr "--no-aliases"

#. type: Plain text
#: en/git-help.txt:60
#, priority:100
msgid "When used with `--all`, exclude the listing of configured aliases."
msgstr "当与 `--all` 一起使用时，不包括配置的别名列表。"

#. type: Plain text
#: en/git-help.txt:64
#, priority:100
msgid "When used with `--all` print description for all recognized commands. This is the default."
msgstr "当与 `--all` 一起使用时，打印所有识别的命令的描述。这是默认的。"

#. type: Labeled list
#: en/git-help.txt:66
#, ignore-same, no-wrap, priority:100
msgid "--config"
msgstr "--config"

#. type: Plain text
#: en/git-help.txt:69
#, priority:100
msgid "List all available configuration variables. This is a short summary of the list in linkgit:git-config[1]."
msgstr "列出所有可用的配置变量。这是对 linkgit:git-config[1] 中的列表的简短总结。"

#. type: Labeled list
#: en/git-help.txt:71
#, ignore-same, no-wrap, priority:100
msgid "--guides"
msgstr "--guides"

#. type: Plain text
#: en/git-help.txt:73
#, priority:100
msgid "Prints a list of the Git concept guides on the standard output."
msgstr "在标准输出上打印 Git 概念指南的列表。"

#. type: Labeled list
#: en/git-help.txt:74
#, ignore-same, no-wrap, priority:100
msgid "--user-interfaces"
msgstr "--user-interfaces"

#. type: Plain text
#: en/git-help.txt:77
#, priority:100
msgid "Prints a list of the repository, command and file interfaces documentation on the standard output."
msgstr "在标准输出上打印一个仓库、命令和文件接口文档的列表。"

#. type: Plain text
#: en/git-help.txt:81
#, priority:100
msgid "In-repository file interfaces such as `.git/info/exclude` are documented here (see linkgit:gitrepository-layout[5]), as well as in-tree configuration such as `.mailmap` (see linkgit:gitmailmap[5])."
msgstr "仓库内的文件接口，如 `.git/info/exclude`，在这里有记录（见 linkgit:gitrepository-layout[5]），以及树内配置，如 `.mailmap`（见linkgit:gitmailmap[5]）。"

#. type: Plain text
#: en/git-help.txt:86
#, priority:100
msgid "This section of the documentation also covers general or widespread user-interface conventions (e.g. linkgit:gitcli[7]), and pseudo-configuration such as the file-based `.git/hooks/*` interface described in linkgit:githooks[5]."
msgstr "这一部分的文档还包括一般的或普遍的用户界面惯例（例如 linkgit:gitcli[7]），以及伪配置，例如 linkgit:githooks[5] 中描述的基于文件的 `.git/hooks/*` 界面。"

#. type: Labeled list
#: en/git-help.txt:87
#, ignore-same, no-wrap, priority:100
msgid "--developer-interfaces"
msgstr "--developer-interfaces"

#. type: Plain text
#: en/git-help.txt:90
#, priority:100
msgid "Print list of file formats, protocols and other developer interfaces documentation on the standard output."
msgstr "在标准输出上打印文件格式、协议和其他开发者接口文件的清单。"

#. type: Labeled list
#: en/git-help.txt:92
#, ignore-same, no-wrap, priority:100
msgid "--info"
msgstr "--info"

#. type: Plain text
#: en/git-help.txt:95
#, priority:100
msgid "Display manual page for the command in the 'info' format. The 'info' program will be used for that purpose."
msgstr "以 'info' 格式显示该命令的手册页。'info' 程序将被用于该目的。"

#. type: Labeled list
#: en/git-help.txt:97
#, ignore-same, no-wrap, priority:100
msgid "--man"
msgstr "--man"

#. type: Plain text
#: en/git-help.txt:101
#, priority:100
msgid "Display manual page for the command in the 'man' format. This option may be used to override a value set in the `help.format` configuration variable."
msgstr "以 'man' 格式显示该命令的手册页。这个选项可以用来覆盖 `help.format` 配置变量中设置的值。"

#. type: Plain text
#: en/git-help.txt:105
#, priority:100
msgid "By default the 'man' program will be used to display the manual page, but the `man.viewer` configuration variable may be used to choose other display programs (see below)."
msgstr "默认情况下，将使用 'man' 程序来显示手册页面，但 `man.viewer` 配置变量可以用来选择其他显示程序（见下文）。"

#. type: Labeled list
#: en/git-help.txt:107
#, ignore-same, no-wrap, priority:100
msgid "--web"
msgstr "--web"

#. type: Plain text
#: en/git-help.txt:110
#, priority:100
msgid "Display manual page for the command in the 'web' (HTML)  format. A web browser will be used for that purpose."
msgstr "以 ‘网页’（HTML）格式显示该命令的手册页面。为此将使用一个网络浏览器。"

#. type: Plain text
#: en/git-help.txt:116
#, priority:100
msgid "The web browser can be specified using the configuration variable `help.browser`, or `web.browser` if the former is not set. If none of these config variables is set, the 'git web{litdd}browse' helper script (called by 'git help') will pick a suitable default. See linkgit:git-web{litdd}browse[1] for more information about this."
msgstr "网络浏览器可以用配置变量 `help.browser` 来指定，如果前者没有设置，则用 `web.browser`。如果这些配置变量都没有设置，'git web{litdd}browse' 辅助脚本（由 \"git help \"调用）会选择一个合适的默认值。参见 linkgit:git-web{litdd}browse[1] 获取更多相关信息。"

#. type: Title -
#: en/git-help.txt:118 en/git-interpret-trailers.txt:160 en/git-p4.txt:556 en/git-web--browse.txt:59
#, no-wrap, priority:100
msgid "CONFIGURATION VARIABLES"
msgstr "配置变量"

#. type: Title ~
#: en/git-help.txt:121
#, ignore-same, no-wrap, priority:100
msgid "help.format"
msgstr "help.format"

#. type: Plain text
#: en/git-help.txt:127
#, priority:100
msgid "If no command-line option is passed, the `help.format` configuration variable will be checked. The following values are supported for this variable; they make 'git help' behave as their corresponding command- line option:"
msgstr "如果没有传递命令行选项，将检查 `help.format` 配置变量。该变量支持以下值；它们使 'git help' 的行为与它们相应的命令行选项相同："

#. type: Plain text
#: en/git-help.txt:129
#, priority:100
msgid "\"man\" corresponds to '-m|--man',"
msgstr "\"man\" 对应的是 '-m|--man'，"

#. type: Plain text
#: en/git-help.txt:130
#, priority:100
msgid "\"info\" corresponds to '-i|--info',"
msgstr "\"info\" 对应的是 '-i|--info'，"

#. type: Plain text
#: en/git-help.txt:131
#, priority:100
msgid "\"web\" or \"html\" correspond to '-w|--web'."
msgstr "\"web\" 或 \"html\" 对应于 '-w|-web'。"

#. type: Title ~
#: en/git-help.txt:133
#, no-wrap, priority:100
msgid "help.browser, web.browser and browser.<tool>.path"
msgstr "help.browser, web.browser 和 browser.<工具>.path"

#. type: Plain text
#: en/git-help.txt:139
#, priority:100
msgid "The `help.browser`, `web.browser` and `browser.<tool>.path` will also be checked if the 'web' format is chosen (either by command-line option or configuration variable). See '-w|--web' in the OPTIONS section above and linkgit:git-web{litdd}browse[1]."
msgstr "如果选择了 'web' 格式（通过命令行选项或配置变量），`help.browser`、`web.browser` 和 `browser.<工具>.path` 也将被检查。见上面选项部分的 '-w|-web' 和 linkgit:git-web{litdd}browse[1]。"

#. type: Title ~
#: en/git-help.txt:141
#, no-wrap, priority:100
msgid "man.viewer"
msgstr "man.viewer"

#. type: Plain text
#: en/git-help.txt:145
#, priority:100
msgid "The `man.viewer` configuration variable will be checked if the 'man' format is chosen. The following values are currently supported:"
msgstr "如果选择 'man' 格式，`man.viewer` 配置变量将被检查。目前支持以下数值："

#. type: Plain text
#: en/git-help.txt:147
#, priority:100
msgid "\"man\": use the 'man' program as usual,"
msgstr "\"man\" : 像往常一样使用 'man' 程序、"

#. type: Plain text
#: en/git-help.txt:149
#, priority:100
msgid "\"woman\": use 'emacsclient' to launch the \"woman\" mode in emacs (this only works starting with emacsclient versions 22),"
msgstr "\"woman\": 使用 'emacsclient' 在 emacs 中启动 \"woman\" 模式（这只在 emacsclient 第 22 版开始工作），"

#. type: Plain text
#: en/git-help.txt:151
#, priority:100
msgid "\"konqueror\": use 'kfmclient' to open the man page in a new konqueror tab (see 'Note about konqueror' below)."
msgstr "\"konqueror\": 使用 'kfmclient' 在一个新的 konqueror 标签中打开手册页（见下文 ‘关于 konqueror 的说明’）。"

#. type: Plain text
#: en/git-help.txt:154
#, priority:100
msgid "Values for other tools can be used if there is a corresponding `man.<tool>.cmd` configuration entry (see below)."
msgstr "如果有相应的 `man.<工具>.cmd` 配置项，可以使用其他工具的值（见下文）。"

#. type: Plain text
#: en/git-help.txt:158
#, priority:100
msgid "Multiple values may be given to the `man.viewer` configuration variable. Their corresponding programs will be tried in the order listed in the configuration file."
msgstr "可以给 `man.viewer` 配置变量设置多个值。他们相应的程序将按照配置文件中列出的顺序进行尝试。"

#. type: Plain text
#: en/git-help.txt:160
#, priority:100
msgid "For example, this configuration:"
msgstr "例如，这种配置："

#. type: delimited block -
#: en/git-help.txt:165
#, fuzzy, no-wrap, priority:100
msgid ""
"\t[man]\n"
"\t\tviewer = konqueror\n"
"\t\tviewer = woman\n"
msgstr ""
"\t[man]\n"
"\t\tviewer = konqueror\n"
"\t\tviewer = woman\n"

#. type: Plain text
#: en/git-help.txt:169
#, priority:100
msgid "will try to use konqueror first. But this may fail (for example, if DISPLAY is not set) and in that case emacs' woman mode will be tried."
msgstr "将首先尝试使用 konqueror。但这可能会失败（例如，如果没有设置DISPLAY），在这种情况下，将尝试 Emacs 的 woman 模式。"

#. type: Plain text
#: en/git-help.txt:173
#, priority:100
msgid "If everything fails, or if no viewer is configured, the viewer specified in the `GIT_MAN_VIEWER` environment variable will be tried.  If that fails too, the 'man' program will be tried anyway."
msgstr "如果一切都失败了，或者没有配置查看器，将尝试 `GIT_MAN_VIEWER` 环境变量中指定的查看器。 如果这也失败了，将尝试使用 'man' 程序。"

#. type: Title ~
#: en/git-help.txt:175
#, no-wrap, priority:100
msgid "man.<tool>.path"
msgstr "man.<工具>.path"

#. type: Plain text
#: en/git-help.txt:182
#, priority:100
msgid "You can explicitly provide a full path to your preferred man viewer by setting the configuration variable `man.<tool>.path`. For example, you can configure the absolute path to konqueror by setting 'man.konqueror.path'. Otherwise, 'git help' assumes the tool is available in PATH."
msgstr "你可以通过设置配置变量 `man.<工具>.path` 来明确提供你喜欢的 man viewer 的完整路径。例如，你可以通过设置 'man.konqueror.path' 来配置 konqueror 的绝对路径。否则，'git help' 会假定该工具在 PATH中 是可用的。"

#. type: Title ~
#: en/git-help.txt:184
#, no-wrap, priority:100
msgid "man.<tool>.cmd"
msgstr "man.<工具>.cmd"

#. type: Plain text
#: en/git-help.txt:192
#, priority:100
msgid "When the man viewer, specified by the `man.viewer` configuration variables, is not among the supported ones, then the corresponding `man.<tool>.cmd` configuration variable will be looked up. If this variable exists then the specified tool will be treated as a custom command and a shell eval will be used to run the command with the man page passed as arguments."
msgstr "当由 `man.viewer` 配置变量指定的 man viewer 不在支持的范围内时，将查找相应的 `man.<工具>.cmd` 配置变量。如果这个变量存在，那么指定的工具将被视为一个自定义的命令，shell eval 将被用来运行命令，并将 man page 作为参数传递。"

#. type: Title ~
#: en/git-help.txt:194
#, no-wrap, priority:100
msgid "Note about konqueror"
msgstr "关于 konqueror 的说明"

#. type: Plain text
#: en/git-help.txt:199
#, priority:100
msgid "When 'konqueror' is specified in the `man.viewer` configuration variable, we launch 'kfmclient' to try to open the man page on an already opened konqueror in a new tab if possible."
msgstr "当 `man.viewer` 配置变量中指定为 'konqueror' 时，我们启动 'kfmclient'，以尝试在新标签页中打开已经打开的 konqueror 的 man 页面。"

#. type: Plain text
#: en/git-help.txt:203
#, fuzzy, priority:100
msgid "For consistency, we also try such a trick if 'man.konqueror.path' is set to something like `A_PATH_TO/konqueror`. That means we will try to launch `A_PATH_TO/kfmclient` instead."
msgstr "为了保持一致性，如果 'man.konqueror.path' 被设置为 `A_PATH_TO/konqueror`，这意味着我们将尝试启动 `A_PATH_TO/kfmclient`，而不是尝试这样的技巧。"

#. type: Plain text
#: en/git-help.txt:206 en/git-web--browse.txt:100
#, priority:100
msgid "If you really want to use 'konqueror', then you can use something like the following:"
msgstr "如果你真的想使用 'konqueror'，那么你可以使用类似以下的东西："

#. type: delimited block -
#: en/git-help.txt:210
#, fuzzy, no-wrap, priority:100
msgid ""
"\t[man]\n"
"\t\tviewer = konq\n"
msgstr ""
"\t[man]\n"
"\t\tviewer = konq\n"

#. type: delimited block -
#: en/git-help.txt:213
#, fuzzy, no-wrap, priority:100
msgid ""
"\t[man \"konq\"]\n"
"\t\tcmd = A_PATH_TO/konqueror\n"
msgstr ""
"\t[man \"konq\"]\n"
"\t\tcmd = A_PATH_TO/konqueror\n"

#. type: Title ~
#: en/git-help.txt:216
#, no-wrap, priority:100
msgid "Note about git config --global"
msgstr "关于 git config --global 的说明"

#. type: Plain text
#: en/git-help.txt:220
#, priority:100
msgid "Note that all these configuration variables should probably be set using the `--global` flag, for example like this:"
msgstr "请注意，所有这些配置变量可能都应该使用 `--global` 标志来设置，比如说像这样："

#. type: delimited block -
#: en/git-help.txt:224
#, fuzzy, no-wrap, priority:100
msgid ""
"$ git config --global help.format web\n"
"$ git config --global web.browser firefox\n"
msgstr ""
"$ git config --global help.format web\n"
"$ git config --global web.browser firefox\n"

#. type: Plain text
#: en/git-help.txt:228 en/git-web--browse.txt:121
#, priority:100
msgid "as they are probably more user specific than repository specific.  See linkgit:git-config[1] for more information about this."
msgstr "因为它们可能更多是针对用户而不是针对仓库。 更多相关信息见 linkgit:git-config[1]。"

#. type: Title =
#: en/git-http-backend.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-http-backend(1)"
msgstr "git-http-backend(1)"

#. type: Plain text
#: en/git-http-backend.txt:7
#, priority:100
msgid "git-http-backend - Server side implementation of Git over HTTP"
msgstr "git-http-backend - Git 在 HTTP 上的服务器端实现"

#. type: Plain text
#: en/git-http-backend.txt:12
#, fuzzy, no-wrap, priority:100
msgid "'git http-backend'\n"
msgstr "'git http-backend'\n"

#. type: Plain text
#: en/git-http-backend.txt:22
#, priority:100
msgid "A simple CGI program to serve the contents of a Git repository to Git clients accessing the repository over http:// and https:// protocols.  The program supports clients fetching using both the smart HTTP protocol and the backwards-compatible dumb HTTP protocol, as well as clients pushing using the smart HTTP protocol. It also supports Git's more-efficient \"v2\" protocol if properly configured; see the discussion of `GIT_PROTOCOL` in the ENVIRONMENT section below."
msgstr "一个简单的 CGI 程序，为通过 http:// 和 https:// 协议访问仓库的 Git 客户提供内容。 该程序支持客户端使用智能 HTTP 协议和向后兼容的哑 HTTP 协议获取内容，以及客户端使用智能 HTTP 协议推送内容。如果配置得当，它还支持 Git 更高效的 \"v2\" 协议；见下文环境部分关于`GIT_PROTOCOL` 的讨论。"

#. type: Plain text
#: en/git-http-backend.txt:27
#, fuzzy, priority:100
msgid "It verifies that the directory has the magic file \"git-daemon-export-ok\", and it will refuse to export any Git directory that hasn't explicitly been marked for export this way (unless the `GIT_HTTP_EXPORT_ALL` environmental variable is set)."
msgstr "它验证该目录是否有魔术文件 \"git-daemon-export-ok\"，它将拒绝导出任何没有明确标记为这种方式导出的 Git 目录（除非设置了 `GIT_HTTP_EXPORT_ALL` 环境变量）。"

#. type: Plain text
#: en/git-http-backend.txt:33
#, priority:100
msgid "By default, only the `upload-pack` service is enabled, which serves 'git fetch-pack' and 'git ls-remote' clients, which are invoked from 'git fetch', 'git pull', and 'git clone'.  If the client is authenticated, the `receive-pack` service is enabled, which serves 'git send-pack' clients, which is invoked from 'git push'."
msgstr "默认情况下，只有 `upload-pack` 服务被启用，它为 'git fetch-pack' 和 'git ls-remote' 客户端服务，这些客户端被 'git fetch'、'git pull' 和 'git clone' 调用。 如果客户端经过认证，`receive-pack` 服务将被启用，它为 'git send-pack' 客户端服务，该服务由 'git push' 调用。"

#. type: Plain text
#: en/git-http-backend.txt:38
#, priority:100
msgid "These services can be enabled/disabled using the per-repository configuration file:"
msgstr "这些服务可以使用每个库的配置文件来启用/禁用："

#. type: Labeled list
#: en/git-http-backend.txt:39
#, no-wrap, priority:100
msgid "http.getanyfile"
msgstr "http.getanyfile"

#. type: Plain text
#: en/git-http-backend.txt:46
#, priority:100
msgid "This serves Git clients older than version 1.6.6 that are unable to use the upload pack service.  When enabled, clients are able to read any file within the repository, including objects that are no longer reachable from a branch but are still present.  It is enabled by default, but a repository can disable it by setting this configuration item to `false`."
msgstr "这是为 1.6.6 版本以上的 Git 客户端提供服务，它们无法使用上传包服务。 启用后，客户端能够读取仓库内的任何文件，包括不再能从分支到达但仍然存在的对象。 默认情况下是启用的，但仓库可以通过将此配置项设置为 `false` 来禁用它。"

#. type: Labeled list
#: en/git-http-backend.txt:47
#, no-wrap, priority:100
msgid "http.uploadpack"
msgstr "http.uploadpack"

#. type: Plain text
#: en/git-http-backend.txt:51
#, priority:100
msgid "This serves 'git fetch-pack' and 'git ls-remote' clients.  It is enabled by default, but a repository can disable it by setting this configuration item to `false`."
msgstr "这为 'git fetch-pack' 和 'git ls-remote' 客户端服务。 它在默认情况下是启用的，但仓库可以通过将此配置项设置为`false`来禁用它。"

#. type: Labeled list
#: en/git-http-backend.txt:52
#, no-wrap, priority:100
msgid "http.receivepack"
msgstr "http.receivepack"

#. type: Plain text
#: en/git-http-backend.txt:58
#, priority:100
msgid "This serves 'git send-pack' clients, allowing push.  It is disabled by default for anonymous users, and enabled by default for users authenticated by the web server.  It can be disabled by setting this item to `false`, or enabled for all users, including anonymous users, by setting it to `true`."
msgstr "这为 'git send-pack' 客户提供服务，允许推送。 默认情况下，它对匿名用户是禁用的，而对通过网络服务器认证的用户是启用的。 可以通过设置该项为 `false` 来禁用它，或者通过设置为 `true` 来为所有用户（包括匿名用户）启用。"

#. type: Title -
#: en/git-http-backend.txt:60
#, fuzzy, no-wrap, priority:100
msgid "URL TRANSLATION"
msgstr "url 翻译"

#. type: Plain text
#: en/git-http-backend.txt:67
#, priority:100
msgid "To determine the location of the repository on disk, 'git http-backend' concatenates the environment variables PATH_INFO, which is set automatically by the web server, and GIT_PROJECT_ROOT, which must be set manually in the web server configuration.  If GIT_PROJECT_ROOT is not set, 'git http-backend' reads PATH_TRANSLATED, which is also set automatically by the web server."
msgstr "为了确定磁盘上仓库的位置，'git http-backend' 将环境变量 PATH_INFO 和 GIT_PROJECT_ROOT 连接起来，前者由 Web 服务器自动设置，后者则必须在 Web 服务器配置中手动设置。 如果 GIT_PROJECT_ROOT 没有设置，'git http-backend '会读取 PATH_TRANSLATED，这也是由网络服务器自动设置的。"

#. type: Plain text
#: en/git-http-backend.txt:72
#, priority:100
msgid "All of the following examples map `http://$hostname/git/foo/bar.git` to `/var/www/git/foo/bar.git`."
msgstr "下面所有的例子都把 `http://$hostname/git/foo/bar.git` 映射到 `/var/www/git/foo/bar.git`。"

#. type: Labeled list
#: en/git-http-backend.txt:73
#, no-wrap, priority:100
msgid "Apache 2.x"
msgstr "Apache 2.x"

#. type: Plain text
#: en/git-http-backend.txt:77
#, priority:100
msgid "Ensure mod_cgi, mod_alias, and mod_env are enabled, set GIT_PROJECT_ROOT (or DocumentRoot) appropriately, and create a ScriptAlias to the CGI:"
msgstr "确保 mod_cgi、mod_alias 和 mod_env被 启用，适当地设置 GIT_PROJECT_ROOT（或 DocumentRoot），并为 CGI 创建一个 ScriptAlias："

#. type: delimited block -
#: en/git-http-backend.txt:82
#, no-wrap, priority:100
msgid ""
"SetEnv GIT_PROJECT_ROOT /var/www/git\n"
"SetEnv GIT_HTTP_EXPORT_ALL\n"
"ScriptAlias /git/ /usr/libexec/git-core/git-http-backend/\n"
msgstr ""
"SetEnv GIT_PROJECT_ROOT /var/www/git\n"
"SetEnv GIT_HTTP_EXPORT_ALL\n"
"ScriptAlias /git/ /usr/libexec/git-core/git-http-backend/\n"

#. type: delimited block -
#: en/git-http-backend.txt:94
#, no-wrap, priority:100
msgid ""
"# This is not strictly necessary using Apache and a modern version of\n"
"# git-http-backend, as the webserver will pass along the header in the\n"
"# environment as HTTP_GIT_PROTOCOL, and http-backend will copy that into\n"
"# GIT_PROTOCOL. But you may need this line (or something similar if you\n"
"# are using a different webserver), or if you want to support older Git\n"
"# versions that did not do that copying.\n"
"#\n"
"# Having the webserver set up GIT_PROTOCOL is perfectly fine even with\n"
"# modern versions (and will take precedence over HTTP_GIT_PROTOCOL,\n"
"# which means it can be used to override the client's request).\n"
"SetEnvIf Git-Protocol \".*\" GIT_PROTOCOL=$0\n"
msgstr ""
"# 这在使用 Apache 和现代版本的\n"
"# git-http-backend，因为网络服务器会把头信息在\n"
"# 环境中作为 HTTP_GIT_PROTOCOL 传递，而 http-backend 会将其复制到\n"
"# git_protocol。但你可能需要这一行（或类似的东西，如果你\n"
"# 使用不同的 webserver），或者如果你想支持旧的 Git\n"
"# 版本没有做这样的复制。\n"
"#\n"
"# 让 webserver 设置 GIT_PROTOCOL 是完全可以的，即使在\n"
"# 现代版本也是如此（并且优先于 HTTP_GIT_PROTOCOL，\n"
"# 这意味着它可以被用来覆盖客户端的请求）。\n"
"SetEnvIf Git-Protocol \".*\"GIT_PROTOCOL=$0\n"

#. type: Plain text
#: en/git-http-backend.txt:100
#, priority:100
msgid "To enable anonymous read access but authenticated write access, require authorization for both the initial ref advertisement (which we detect as a push via the service parameter in the query string), and the receive-pack invocation itself:"
msgstr "为了实现匿名的读取访问，但要有认证的写入访问，需要对最初的引用广播（我们通过查询字符串中的服务参数检测为推送）和接收包调用本身进行授权："

#. type: delimited block -
#: en/git-http-backend.txt:105
#, no-wrap, priority:100
msgid ""
"RewriteCond %{QUERY_STRING} service=git-receive-pack [OR]\n"
"RewriteCond %{REQUEST_URI} /git-receive-pack$\n"
"RewriteRule ^/git/ - [E=AUTHREQUIRED:yes]\n"
msgstr ""
"RewriteCond %{QUERY_STRING} service=git-receive-pack [OR]\n"
"RewriteCond %{REQUEST_URI} /git-receive-pack$\n"
"RewriteRule ^/git/ - [E=AUTHREQUIRED:yes]\n"

#. type: delimited block -
#: en/git-http-backend.txt:109
#, no-wrap, priority:100
msgid ""
"<LocationMatch \"^/git/\">\n"
"\tOrder Deny,Allow\n"
"\tDeny from env=AUTHREQUIRED\n"
msgstr ""
"<LocationMatch \"^/git/\">\n"
"\tOrder Deny,Allow\n"
"\tDeny from env=AUTHREQUIRED\n"

#. type: delimited block -
#: en/git-http-backend.txt:116
#, ignore-ellipsis, no-wrap, priority:100
msgid ""
"\tAuthType Basic\n"
"\tAuthName \"Git Access\"\n"
"\tRequire group committers\n"
"\tSatisfy Any\n"
"\t...\n"
"</LocationMatch>\n"
msgstr ""
"\tAuthType Basic\n"
"\tAuthName \"Git Access\"\n"
"\tRequire group committers\n"
"\tSatisfy Any\n"
"\t...\n"
"</LocationMatch>\n"

#. type: Plain text
#: en/git-http-backend.txt:121
#, priority:100
msgid "If you do not have `mod_rewrite` available to match against the query string, it is sufficient to just protect `git-receive-pack` itself, like:"
msgstr "如果你没有 `mod_rewrite` 可用来匹配查询字符串，只需保护 `git-receive-pack` 本身即可，比如："

#. type: delimited block -
#: en/git-http-backend.txt:129
#, ignore-ellipsis, no-wrap, priority:100
msgid ""
"<LocationMatch \"^/git/.*/git-receive-pack$\">\n"
"\tAuthType Basic\n"
"\tAuthName \"Git Access\"\n"
"\tRequire group committers\n"
"\t...\n"
"</LocationMatch>\n"
msgstr ""
"<LocationMatch \"^/git/.*/git-receive-pack$\">\n"
"\tAuthType Basic\n"
"\tAuthName \"Git Access\"\n"
"\tRequire group committers\n"
"\t...\n"
"</LocationMatch>\n"

#. type: Plain text
#: en/git-http-backend.txt:139
#, priority:100
msgid "In this mode, the server will not request authentication until the client actually starts the object negotiation phase of the push, rather than during the initial contact.  For this reason, you must also enable the `http.receivepack` config option in any repositories that should accept a push. The default behavior, if `http.receivepack` is not set, is to reject any pushes by unauthenticated users; the initial request will therefore report `403 Forbidden` to the client, without even giving an opportunity for authentication."
msgstr "在这种模式下，服务器将不会请求认证，直到客户端实际开始推送的对象协商阶段，而不是在最初的接触中。 由于这个原因，你必须在任何应该接受推送的存储库中启用 `http.receivepack` 配置选项。如果没有设置 `http.receivepack`，默认行为是拒绝任何未经认证的用户的推送；因此初始请求将向客户端报告 `403 Forbidden`，甚至不给认证机会。"

#. type: Plain text
#: en/git-http-backend.txt:142
#, priority:100
msgid "To require authentication for both reads and writes, use a Location directive around the repository, or one of its parent directories:"
msgstr "要对读和写都要求认证，可以在仓库或它的一个父目录周围使用 Location 指令："

#. type: delimited block -
#: en/git-http-backend.txt:150
#, ignore-ellipsis, no-wrap, priority:100
msgid ""
"<Location /git/private>\n"
"\tAuthType Basic\n"
"\tAuthName \"Private Git Access\"\n"
"\tRequire group committers\n"
"\t...\n"
"</Location>\n"
msgstr ""
"<Location /git/private>\n"
"\tAuthType Basic\n"
"\tAuthName \"Private Git Access\"\n"
"\tRequire group committers\n"
"\t...\n"
"</Location>\n"

#. type: Plain text
#: en/git-http-backend.txt:155
#, priority:100
msgid "To serve gitweb at the same url, use a ScriptAliasMatch to only those URLs that 'git http-backend' can handle, and forward the rest to gitweb:"
msgstr "要在同一个网址上为 gitweb 提供服务，使用 ScriptAliasMatch，只对那些 'git http-backend' 可以处理的网址进行匹配，其余的转发给 gitweb："

#. type: delimited block -
#: en/git-http-backend.txt:165
#, no-wrap, priority:100
msgid ""
"ScriptAliasMatch \\\n"
"\t\"(?x)^/git/(.*/(HEAD | \\\n"
"\t\t\tinfo/refs | \\\n"
"\t\t\tobjects/(info/[^/]+ | \\\n"
"\t\t\t\t [0-9a-f]{2}/[0-9a-f]{38} | \\\n"
"\t\t\t\t pack/pack-[0-9a-f]{40}\\.(pack|idx)) | \\\n"
"\t\t\tgit-(upload|receive)-pack))$\" \\\n"
"\t/usr/libexec/git-core/git-http-backend/$1\n"
msgstr ""
"ScriptAliasMatch \\\n"
"\t\"(?x)^/git/(.*/(HEAD | \\\n"
"\t\t\tinfo/refs | \\\n"
"\t\t\tobjects/(info/[^/]+ | \\\n"
"\t\t\t\t [0-9a-f]{2}/[0-9a-f]{38} | \\\n"
"\t\t\t\t pack/pack-[0-9a-f]{40}\\.(pack|idx)) | \\\n"
"\t\t\tgit-(upload|receive)-pack))$\" \\\n"
"\t/usr/libexec/git-core/git-http-backend/$1\n"

#. type: delimited block -
#: en/git-http-backend.txt:167
#, no-wrap, priority:100
msgid "ScriptAlias /git/ /var/www/cgi-bin/gitweb.cgi/\n"
msgstr "ScriptAlias /git/ /var/www/cgi-bin/gitweb.cgi/\n"

#. type: Plain text
#: en/git-http-backend.txt:171
#, priority:100
msgid "To serve multiple repositories from different linkgit:gitnamespaces[7] in a single repository:"
msgstr "在一个仓库中为来自不同 linkgit:gitnamespaces[7] 的多个仓库提供服务："

#. type: delimited block -
#: en/git-http-backend.txt:175
#, no-wrap, priority:100
msgid ""
"SetEnvIf Request_URI \"^/git/([^/]*)\" GIT_NAMESPACE=$1\n"
"ScriptAliasMatch ^/git/[^/]*(.*) /usr/libexec/git-core/git-http-backend/storage.git$1\n"
msgstr ""
"SetEnvIf Request_URI \"^/git/([^/]*)\" GIT_NAMESPACE=$1\n"
"ScriptAliasMatch ^/git/[^/]*(.*) /usr/libexec/git-core/git-http-backend/storage.git$1\n"

#. type: Labeled list
#: en/git-http-backend.txt:177
#, no-wrap, priority:100
msgid "Accelerated static Apache 2.x"
msgstr "Accelerated static Apache 2.x"

#. type: Plain text
#: en/git-http-backend.txt:182
#, priority:100
msgid "Similar to the above, but Apache can be used to return static files that are stored on disk.  On many systems this may be more efficient as Apache can ask the kernel to copy the file contents from the file system directly to the network:"
msgstr "与上述情况类似，但 Apache 可以用来返回存储在磁盘上的静态文件。 在许多系统上，这可能更有效率，因为 Apache 可以要求内核将文件内容从文件系统直接复制到网络上："

#. type: delimited block -
#: en/git-http-backend.txt:185 en/git-http-backend.txt:195
#, no-wrap, priority:100
msgid "SetEnv GIT_PROJECT_ROOT /var/www/git\n"
msgstr "SetEnv GIT_PROJECT_ROOT /var/www/git\n"

#. type: delimited block -
#: en/git-http-backend.txt:189
#, no-wrap, priority:100
msgid ""
"AliasMatch ^/git/(.*/objects/[0-9a-f]{2}/[0-9a-f]{38})$          /var/www/git/$1\n"
"AliasMatch ^/git/(.*/objects/pack/pack-[0-9a-f]{40}.(pack|idx))$ /var/www/git/$1\n"
"ScriptAlias /git/ /usr/libexec/git-core/git-http-backend/\n"
msgstr ""
"AliasMatch ^/git/(.*/objects/[0-9a-f]{2}/[0-9a-f]{38})$          /var/www/git/$1\n"
"AliasMatch ^/git/(.*/objects/pack/pack-[0-9a-f]{40}.(pack|idx))$ /var/www/git/$1\n"
"ScriptAlias /git/ /usr/libexec/git-core/git-http-backend/\n"

#. type: Plain text
#: en/git-http-backend.txt:192
#, priority:100
msgid "This can be combined with the gitweb configuration:"
msgstr "这可以与 gitweb 的配置相结合："

#. type: delimited block -
#: en/git-http-backend.txt:205
#, no-wrap, priority:100
msgid ""
"AliasMatch ^/git/(.*/objects/[0-9a-f]{2}/[0-9a-f]{38})$          /var/www/git/$1\n"
"AliasMatch ^/git/(.*/objects/pack/pack-[0-9a-f]{40}.(pack|idx))$ /var/www/git/$1\n"
"ScriptAliasMatch \\\n"
"\t\"(?x)^/git/(.*/(HEAD | \\\n"
"\t\t\tinfo/refs | \\\n"
"\t\t\tobjects/info/[^/]+ | \\\n"
"\t\t\tgit-(upload|receive)-pack))$\" \\\n"
"\t/usr/libexec/git-core/git-http-backend/$1\n"
"ScriptAlias /git/ /var/www/cgi-bin/gitweb.cgi/\n"
msgstr ""
"AliasMatch ^/git/(.*/objects/[0-9a-f]{2}/[0-9a-f]{38})$          /var/www/git/$1\n"
"AliasMatch ^/git/(.*/objects/pack/pack-[0-9a-f]{40}.(pack|idx))$ /var/www/git/$1\n"
"ScriptAliasMatch \\\n"
"\t\"(?x)^/git/(.*/(HEAD | \\\n"
"\t\t\tinfo/refs | \\\n"
"\t\t\tobjects/info/[^/]+ | \\\n"
"\t\t\tgit-(upload|receive)-pack))$\" \\\n"
"\t/usr/libexec/git-core/git-http-backend/$1\n"
"ScriptAlias /git/ /var/www/cgi-bin/gitweb.cgi/\n"

#. type: Labeled list
#: en/git-http-backend.txt:207
#, no-wrap, priority:100
msgid "Lighttpd"
msgstr "Lighttpd"

#. type: Plain text
#: en/git-http-backend.txt:211
#, priority:100
msgid "Ensure that `mod_cgi`, `mod_alias`, `mod_auth`, `mod_setenv` are loaded, then set `GIT_PROJECT_ROOT` appropriately and redirect all requests to the CGI:"
msgstr "确保 `mod_cgi`、`mod_alias`、`mod_auth`、`mod_setenv` 已经加载，然后适当设置 `GIT_PROJECT_ROOT`，并将所有请求重定向到 CGI："

#. type: delimited block -
#: en/git-http-backend.txt:221
#, no-wrap, priority:100
msgid ""
"alias.url += ( \"/git\" => \"/usr/lib/git-core/git-http-backend\" )\n"
"$HTTP[\"url\"] =~ \"^/git\" {\n"
"\tcgi.assign = (\"\" => \"\")\n"
"\tsetenv.add-environment = (\n"
"\t\t\"GIT_PROJECT_ROOT\" => \"/var/www/git\",\n"
"\t\t\"GIT_HTTP_EXPORT_ALL\" => \"\"\n"
"\t)\n"
"}\n"
msgstr ""
"alias.url += ( \"/git\" => \"/usr/lib/git-core/git-http-backend\" )\n"
"$HTTP[\"url\"] =~ \"^/git\" {\n"
"\tcgi.assign = (\"\" => \"\")\n"
"\tsetenv.add-environment = (\n"
"\t\t\"GIT_PROJECT_ROOT\" => \"/var/www/git\",\n"
"\t\t\"GIT_HTTP_EXPORT_ALL\" => \"\"\n"
"\t)\n"
"}\n"

#. type: Plain text
#: en/git-http-backend.txt:224
#, priority:100
msgid "To enable anonymous read access but authenticated write access:"
msgstr "要启用匿名的读取访问，但要有认证的写入访问："

#. type: delimited block -
#: en/git-http-backend.txt:232
#, fuzzy, no-wrap, priority:100
msgid ""
"$HTTP[\"querystring\"] =~ \"service=git-receive-pack\" {\n"
"\tinclude \"git-auth.conf\"\n"
"}\n"
"$HTTP[\"url\"] =~ \"^/git/.*/git-receive-pack$\" {\n"
"\tinclude \"git-auth.conf\"\n"
"}\n"
msgstr ""
"$HTTP[\"querystring\"] =~ \"service=git-receive-pack\" {\n"
"\tinclude \"git-auth.conf\"\n"
"}\n"
"$HTTP[\"url\"] =~ \"^/git/.*/git-receive-pack$\" {\n"
"\tinclude \"git-auth.conf\"\n"
"}\n"

#. type: Plain text
#: en/git-http-backend.txt:235
#, priority:100
msgid "where `git-auth.conf` looks something like:"
msgstr "其中 `git-auth.conf` 看起来像："

#. type: delimited block -
#: en/git-http-backend.txt:245
#, ignore-ellipsis, no-wrap, priority:100
msgid ""
"auth.require = (\n"
"\t\"/\" => (\n"
"\t\t\"method\" => \"basic\",\n"
"\t\t\"realm\" => \"Git Access\",\n"
"\t\t\"require\" => \"valid-user\"\n"
"\t       )\n"
")\n"
"# ...and set up auth.backend here\n"
msgstr ""
"auth.require = (\n"
"\t\"/\" => (\n"
"\t\t\"method\" => \"basic\",\n"
"\t\t\"realm\" => \"Git Access\",\n"
"\t\t\"require\" => \"valid-user\"\n"
"\t       )\n"
")\n"
"# ...并在此设置auth.backend\n"

#. type: Plain text
#: en/git-http-backend.txt:248
#, priority:100
msgid "To require authentication for both reads and writes:"
msgstr "要求对读和写都进行认证："

#. type: delimited block -
#: en/git-http-backend.txt:253
#, fuzzy, no-wrap, priority:100
msgid ""
"$HTTP[\"url\"] =~ \"^/git/private\" {\n"
"\tinclude \"git-auth.conf\"\n"
"}\n"
msgstr ""
"$HTTP[\"url\"] =~ \"^/git/private\" {\n"
"\tinclude \"git-auth.conf\"\n"
"}\n"

#. type: Plain text
#: en/git-http-backend.txt:260
#, fuzzy, priority:100
msgid "'git http-backend' relies upon the `CGI` environment variables set by the invoking web server, including:"
msgstr "'git http-backend' relies upon the `CGI` environment variables set by the invoking web server, including:"

#. type: Plain text
#: en/git-http-backend.txt:262
#, priority:100
msgid "PATH_INFO (if GIT_PROJECT_ROOT is set, otherwise PATH_TRANSLATED)"
msgstr "PATH_INFO（如果设置了 GIT_PROJECT_ROOT，否则为 PATH_TRANSLATED）"

#. type: Plain text
#: en/git-http-backend.txt:263
#, fuzzy, priority:100
msgid "REMOTE_USER"
msgstr "REMOTE_USER"

#. type: Plain text
#: en/git-http-backend.txt:264
#, fuzzy, priority:100
msgid "REMOTE_ADDR"
msgstr "REMOTE_ADDR"

#. type: Plain text
#: en/git-http-backend.txt:265
#, fuzzy, priority:100
msgid "CONTENT_TYPE"
msgstr "内容类型"

#. type: Plain text
#: en/git-http-backend.txt:266
#, fuzzy, priority:100
msgid "QUERY_STRING"
msgstr "QUERY_STRING"

#. type: Plain text
#: en/git-http-backend.txt:267
#, fuzzy, priority:100
msgid "REQUEST_METHOD"
msgstr "REQUEST_METHOD"

#. type: Plain text
#: en/git-http-backend.txt:271
#, priority:100
msgid "The `GIT_HTTP_EXPORT_ALL` environmental variable may be passed to 'git-http-backend' to bypass the check for the \"git-daemon-export-ok\" file in each repository before allowing export of that repository."
msgstr "`GIT_HTTP_EXPORT_ALL` 环境变量可以传递给 'git-http-backend'，以绕过在允许导出每个仓库前对 \"git-daemon-export-ok\" 文件的检查。"

#. type: Plain text
#: en/git-http-backend.txt:280
#, priority:100
msgid "The `GIT_HTTP_MAX_REQUEST_BUFFER` environment variable (or the `http.maxRequestBuffer` config variable) may be set to change the largest ref negotiation request that git will handle during a fetch; any fetch requiring a larger buffer will not succeed.  This value should not normally need to be changed, but may be helpful if you are fetching from a repository with an extremely large number of refs.  The value can be specified with a unit (e.g., `100M` for 100 megabytes). The default is 10 megabytes."
msgstr "`GIT_HTTP_MAX_REQUEST_BUFFER` 环境变量（或 `http.maxRequestBuffer` 配置变量）可以被设置为改变 git 在获取过程中所处理的最大引用协商请求；任何需要更大缓冲区的获取将不会成功。 这个值通常不需要改变，但如果你从一个有大量引用的仓库中获取，可能会有帮助。 这个值可以指定一个单位（例如，`100M` 表示 100 兆字节）。默认是 10 兆字节。"

#. type: Plain text
#: en/git-http-backend.txt:290
#, priority:100
msgid "Clients may probe for optional protocol capabilities (like the v2 protocol) using the `Git-Protocol` HTTP header. In order to support these, the contents of that header must appear in the `GIT_PROTOCOL` environment variable. Most webservers will pass this header to the CGI via the `HTTP_GIT_PROTOCOL` variable, and `git-http-backend` will automatically copy that to `GIT_PROTOCOL`. However, some webservers may be more selective about which headers they'll pass, in which case they need to be configured explicitly (see the mention of `Git-Protocol` in the Apache config from the earlier EXAMPLES section)."
msgstr "客户端可以使用 `Git-Protocol` HTTP 头来探测可选的协议能力（如 v2 协议）。为了支持这些，该标头的内容必须出现在 `GIT_PROTOCOL` 环境变量中。大多数网络服务器将通过 `HTTP_GIT_PROTOCOL` 变量把这个头传递给 CGI，`git-http-backend` 将自动把它复制到 `GIT_PROTOCOL`。然而，一些网络服务器可能对他们要传递的头信息更有选择性，在这种情况下，他们需要明确配置（见前面例子部分的 Apache 配置中对 `Git-Protocol` 的提及）。"

#. type: Plain text
#: en/git-http-backend.txt:295
#, priority:100
msgid "The backend process sets GIT_COMMITTER_NAME to '$REMOTE_USER' and GIT_COMMITTER_EMAIL to '$\\{REMOTE_USER}@http.$\\{REMOTE_ADDR\\}', ensuring that any reflogs created by 'git-receive-pack' contain some identifying information of the remote user who performed the push."
msgstr "后台进程将 GIT_COMMITTER_NAME 设置为 '$REMOTE_USER'，将 GIT_COMMITTER_EMAIL 设置为 '$\\{REMOTE_USER}\\@http.${REMOTE_ADDR\\}'，确保任何由 'git-receive-pack' 创建的引用日志包含执行推送的远程用户的一些识别信息。"

#. type: Plain text
#: en/git-http-backend.txt:298
#, priority:100
msgid "All `CGI` environment variables are available to each of the hooks invoked by the 'git-receive-pack'."
msgstr "所有 `CGI` 环境变量对 'git-receive-pack' 调用的每个钩子都是可用的。"

#. type: Title =
#: en/git-http-fetch.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-http-fetch(1)"
msgstr "git-http-fetch(1)"

#. type: Plain text
#: en/git-http-fetch.txt:7
#, fuzzy, priority:100
msgid "git-http-fetch - Download from a remote Git repository via HTTP"
msgstr "git-http-fetch - Download from a remote Git repository via HTTP"

#. type: Plain text
#: en/git-http-fetch.txt:13
#, fuzzy, no-wrap, priority:100
msgid "'git http-fetch' [-c] [-t] [-a] [-d] [-v] [-w <filename>] [--recover] [--stdin | --packfile=<hash> | <commit>] <URL>\n"
msgstr "'git http-fetch' [-c] [-t] [-a] [-d] [-v] [-w filename] [--recover] [--stdin | --packfile=<hash> | <commit>] <url>\n"

#. type: Plain text
#: en/git-http-fetch.txt:17
#, priority:100
msgid "Downloads a remote Git repository via HTTP."
msgstr "通过HTTP下载远程Git存储库。"

#. type: Plain text
#: en/git-http-fetch.txt:21
#, priority:100
msgid "This command always gets all objects. Historically, there were three options `-a`, `-c` and `-t` for choosing which objects to download. They are now silently ignored."
msgstr "这个命令总是获取所有的对象。在过去，有三个选项 `-a`、`-c` 和 `-t`用于选择下载哪些对象。现在它们被默默地忽略了。"

#. type: Labeled list
#: en/git-http-fetch.txt:24
#, fuzzy, no-wrap, priority:100
msgid "commit-id"
msgstr "commit-id"

#. type: Plain text
#: en/git-http-fetch.txt:27
#, priority:100
msgid "Either the hash or the filename under [URL]/refs/ to pull."
msgstr "在 [URL]/refs/ 下的哈希值或文件名来拉取。"

#. type: Labeled list
#: en/git-http-fetch.txt:28
#, no-wrap, priority:100
msgid "-a, -c, -t"
msgstr "-a, -c, -t"

#. type: Plain text
#: en/git-http-fetch.txt:30
#, priority:100
msgid "These options are ignored for historical reasons."
msgstr "由于历史原因，这些选项被忽略了。"

#. type: Plain text
#: en/git-http-fetch.txt:32
#, priority:100
msgid "Report what is downloaded."
msgstr "报告所下载的内容。"

#. type: Labeled list
#: en/git-http-fetch.txt:33
#, fuzzy, no-wrap, priority:100
msgid "-w <filename>"
msgstr "-w <filename>"

#. type: Plain text
#: en/git-http-fetch.txt:36
#, priority:100
msgid "Writes the commit-id into the filename under $GIT_DIR/refs/<filename> on the local end after the transfer is complete."
msgstr "转移完成后，在本地端将 commit-id 写入 $GIT_DIR/refs/<文件名>下的文件名。"

#. type: Plain text
#: en/git-http-fetch.txt:40
#, priority:100
msgid "Instead of a commit id on the command line (which is not expected in this case), 'git http-fetch' expects lines on stdin in the format"
msgstr "'git http-fetch' 希望在标准输入流上看到格式为以下的行，而不是命令行上的提交 ID（在这种情况下不需要提交 ID）"

#. type: Plain text
#: en/git-http-fetch.txt:42
#, fuzzy, no-wrap, priority:100
msgid "<commit-id>['\\t'<filename-as-in--w>]\n"
msgstr "<commit-id>['\\t'<filename-as-in--w>]\n"

#. type: Labeled list
#: en/git-http-fetch.txt:43
#, fuzzy, no-wrap, priority:100
msgid "--packfile=<hash>"
msgstr "--packfile=<hash>"

#. type: Plain text
#: en/git-http-fetch.txt:51
#, fuzzy, priority:100
msgid "For internal use only. Instead of a commit id on the command line (which is not expected in this case), 'git http-fetch' fetches the packfile directly at the given URL and uses index-pack to generate corresponding .idx and .keep files.  The hash is used to determine the name of the temporary file and is arbitrary. The output of index-pack is printed to stdout. Requires --index-pack-args."
msgstr "Instead of a commit id on the command line (which is not expected in this case), 'git http-fetch' fetches the packfile directly at the given URL and uses index-pack to generate corresponding .idx and .keep files.  The hash is used to determine the name of the temporary file and is arbitrary. The output of index-pack is printed to stdout."

#. type: Labeled list
#: en/git-http-fetch.txt:52
#, fuzzy, no-wrap, priority:100
msgid "--index-pack-args=<args>"
msgstr "--export-pack-edges=<file>"

#. type: Plain text
#: en/git-http-fetch.txt:55
#, priority:100
msgid "For internal use only. The command to run on the contents of the downloaded pack. Arguments are URL-encoded separated by spaces."
msgstr "仅供内部使用。对下载的包的内容运行的命令。参数为 URL 编码，以空格分隔。"

#. type: Labeled list
#: en/git-http-fetch.txt:56
#, ignore-same, no-wrap, priority:100
msgid "--recover"
msgstr "--recover"

#. type: Plain text
#: en/git-http-fetch.txt:59
#, priority:100
msgid "Verify that everything reachable from target is fetched.  Used after an earlier fetch is interrupted."
msgstr "验证所有可以从目标地可达的东西都被取走了。 在一个较早的获取被中断后使用。"

#. type: Title =
#: en/git-http-push.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-http-push(1)"
msgstr "git-http-push(1)"

#. type: Plain text
#: en/git-http-push.txt:7
#, priority:100
msgid "git-http-push - Push objects over HTTP/DAV to another repository"
msgstr "git-http-push - 通过http/DAV将对象推送到另一个存储库"

#. type: Plain text
#: en/git-http-push.txt:13
#, fuzzy, ignore-ellipsis, no-wrap, priority:100
msgid "'git http-push' [--all] [--dry-run] [--force] [--verbose] <URL> <ref> [<ref>...]\n"
msgstr "'git http-push' [--all] [--dry-run] [--force] [--verbose] <url> <ref> [<ref>...]\n"

#. type: Plain text
#: en/git-http-push.txt:18
#, priority:100
msgid "Sends missing objects to remote repository, and updates the remote branch."
msgstr "将丢失的对象发送到远程仓库，并更新远程分支。"

#. type: Plain text
#: en/git-http-push.txt:22
#, no-wrap, priority:100
msgid ""
"*NOTE*: This command is temporarily disabled if your libcurl\n"
"is older than 7.16, as the combination has been reported\n"
"not to work and sometimes corrupts repository.\n"
msgstr ""
"*注意*： 如果你的 libcurl 的版本超过 7.16，这个命令会暂时失效。\n"
"早于 7.16，这个命令会被暂时禁用，因为有报告说这个组合\n"
"不起作用，并且有时会破坏仓库。\n"

#. type: Plain text
#: en/git-http-push.txt:29
#, priority:100
msgid "Do not assume that the remote repository is complete in its current state, and verify all objects in the entire local ref's history exist in the remote repository."
msgstr "不要假设远程仓库的当前状态是完整的，要验证整个本地引用的历史中的所有对象是否存在于远程仓库。"

#. type: Plain text
#: en/git-http-push.txt:36 en/git-send-pack.txt:61
#, priority:100
msgid "Usually, the command refuses to update a remote ref that is not an ancestor of the local ref used to overwrite it.  This flag disables the check.  What this means is that the remote repository can lose commits; use it with care."
msgstr "通常情况下，命令拒绝更新一个不是用来覆盖它的本地引用的祖先远程引用。 这个标志可以禁止这种检查。 这意味着远程仓库可能会丢失提交，使用时要小心。"

#. type: Plain text
#: en/git-http-push.txt:39 en/git-push.txt:176 en/git-send-pack.txt:54
#, priority:220
msgid "Do everything except actually send the updates."
msgstr "做除了实际发送更新外的所有事。"

#. type: Plain text
#: en/git-http-push.txt:43
#, priority:100
msgid "Report the list of objects being walked locally and the list of objects successfully sent to the remote repository."
msgstr "报告正在本地行走的对象的列表和成功发送到远程仓库的对象的列表。"

#. type: Plain text
#: en/git-http-push.txt:49
#, priority:100
msgid "Remove <ref> from remote repository.  The specified branch cannot be the remote HEAD.  If -d is specified the following other conditions must also be met:"
msgstr "从远程仓库中删除 <引用>。 指定的分支不能是远程的 HEAD。 如果指定了 -d，还必须满足以下其他条件："

#. type: Plain text
#: en/git-http-push.txt:51
#, priority:100
msgid "Remote HEAD must resolve to an object that exists locally"
msgstr "远程 HEAD 必须解析到一个本地存在的对象"

#. type: Plain text
#: en/git-http-push.txt:52
#, priority:100
msgid "Specified branch resolves to an object that exists locally"
msgstr "指定的分支解析到一个本地存在的对象"

#. type: Plain text
#: en/git-http-push.txt:53
#, priority:100
msgid "Specified branch is an ancestor of the remote HEAD"
msgstr "指定的分支是远程 HEAD 的一个祖先"

#. type: Labeled list
#: en/git-http-push.txt:54 en/git-send-pack.txt:99
#, fuzzy, ignore-ellipsis, no-wrap, priority:100
msgid "<ref>..."
msgstr "<ref>..."

#. type: Plain text
#: en/git-http-push.txt:56 en/git-send-pack.txt:101
#, priority:100
msgid "The remote refs to update."
msgstr "要更新的远程引用。"

#. type: Title -
#: en/git-http-push.txt:59 en/git-send-pack.txt:104
#, no-wrap, priority:100
msgid "SPECIFYING THE REFS"
msgstr "指定引用"

#. type: Plain text
#: en/git-http-push.txt:65
#, priority:100
msgid "A '<ref>' specification can be either a single pattern, or a pair of such patterns separated by a colon \":\" (this means that a ref name cannot have a colon in it).  A single pattern '<name>' is just a shorthand for '<name>:<name>'."
msgstr "一个 '<引用>' 规范既可以是一个单一的模式，也可以是一对由冒号 \":\" 隔开的模式（这意味着一个引用名称中不能有冒号）。 一个单一的模式 '<名称>' 只是 '<名称>:<名称>' 的一个缩写。"

#. type: Plain text
#: en/git-http-push.txt:70
#, priority:100
msgid "Each pattern pair '<src>:<dst>' consists of the source side (before the colon) and the destination side (after the colon).  The ref to be pushed is determined by finding a match that matches the source side, and where it is pushed is determined by using the destination side."
msgstr "每个模式对 '<src>:<dst>' 由源端（冒号之前）和目标端（冒号之后）组成。 要推送的引用是通过找到与源端相匹配的匹配物来确定的，而推送的位置是通过目的地端来确定的。"

#. type: Plain text
#: en/git-http-push.txt:73
#, priority:100
msgid "It is an error if '<src>' does not match exactly one of the local refs."
msgstr "如果 '<src>' 与本地引用中的一个不完全匹配，则是一个错误。"

#. type: Plain text
#: en/git-http-push.txt:75
#, priority:100
msgid "If '<dst>' does not match any remote ref, either"
msgstr "如果 '<dst>' 不匹配任何远程引用，或者"

#. type: Plain text
#: en/git-http-push.txt:78 en/git-send-pack.txt:139
#, priority:100
msgid "it has to start with \"refs/\"; <dst> is used as the destination literally in this case."
msgstr "它必须以 \"refs/\" 开头；在这种情况下，<dst> 被用作目标字面。"

#. type: Plain text
#: en/git-http-push.txt:82 en/git-send-pack.txt:143
#, priority:100
msgid "<src> == <dst> and the ref that matched the <src> must not exist in the set of remote refs; the ref matched <src> locally is used as the name of the destination."
msgstr "<src> == <dst>，并且与 <src> 相匹配的引用必须不存在于远程引用集合中；本地匹配的 <src>引用被用作目的地的名称。"

#. type: Plain text
#: en/git-http-push.txt:88 en/git-send-pack.txt:149
#, priority:100
msgid "Without `--force`, the <src> ref is stored at the remote only if <dst> does not exist, or <dst> is a proper subset (i.e. an ancestor) of <src>.  This check, known as \"fast-forward check\", is performed in order to avoid accidentally overwriting the remote ref and lose other peoples' commits from there."
msgstr "如果没有 `--force`，只有当 <dst> 不存在，或者 <dst> 是 <src> 的适当子集（即祖先）时，<src> 的引用才会被保存在远程。 这个检查被称为 “快速检查”，是为了避免不小心覆盖了远程引用而丢失其他人在那里的提交。"

#. type: Plain text
#: en/git-http-push.txt:90 en/git-send-pack.txt:151
#, priority:100
msgid "With `--force`, the fast-forward check is disabled for all refs."
msgstr "使用 `--force`，所有裁判的快进检查都被禁用。"

#. type: Plain text
#: en/git-http-push.txt:93 en/git-send-pack.txt:154
#, priority:100
msgid "Optionally, a <ref> parameter can be prefixed with a plus '+' sign to disable the fast-forward check only on that ref."
msgstr "可以选择在 <ref> 参数前加上一个加号 '+' 号，以便仅在该引用上禁用快进检查。"

#. type: Title =
#: en/git-imap-send.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-imap-send(1)"
msgstr "git-imap-send(1)"

#. type: Plain text
#: en/git-imap-send.txt:7
#, fuzzy, priority:100
msgid "git-imap-send - Send a collection of patches from stdin to an IMAP folder"
msgstr "IMAP"

#. type: Plain text
#: en/git-imap-send.txt:13
#, fuzzy, no-wrap, priority:100
msgid "'git imap-send' [-v] [-q] [--[no-]curl]\n"
msgstr "'git imap-send' [-v] [-q] [--[no-]curl]\n"

#. type: Plain text
#: en/git-imap-send.txt:23
#, priority:100
msgid "This command uploads a mailbox generated with 'git format-patch' into an IMAP drafts folder.  This allows patches to be sent as other email is when using mail clients that cannot read mailbox files directly. The command also works with any general mailbox in which emails have the fields \"From\", \"Date\", and \"Subject\" in that order."
msgstr "这条命令将用 'git format-patch' 生成的邮箱上传到 IMAP 的 drafts 文件夹。 这允许在使用不能直接读取邮箱文件的邮件客户端时，将补丁作为其他邮件发送。该命令也适用于任何一般的邮箱，其中的邮件按顺序有 \"Form\"、\"Date\" 和 \"Subject\" 字段。"

#. type: Plain text
#: en/git-imap-send.txt:25
#, priority:100
msgid "Typical usage is something like:"
msgstr "典型的用法是这样的："

#. type: Plain text
#: en/git-imap-send.txt:27
#, priority:100
msgid "git format-patch --signoff --stdout --attach origin | git imap-send"
msgstr "git format-patch --signoff --stdout --attach origin | git imap-send"

#. type: Plain text
#: en/git-imap-send.txt:39
#, fuzzy, priority:100
msgid "Be quiet."
msgstr "Be quiet."

#. type: Labeled list
#: en/git-imap-send.txt:40
#, ignore-same, no-wrap, priority:100
msgid "--curl"
msgstr "--curl"

#. type: Plain text
#: en/git-imap-send.txt:44
#, priority:100
msgid "Use libcurl to communicate with the IMAP server, unless tunneling into it.  Ignored if Git was built without the USE_CURL_FOR_IMAP_SEND option set."
msgstr "使用 libcurl 与 IMAP 服务器通信，除非通过隧道进入。 如果 Git 在构建时没有设置 USE_CURL_FOR_IMAP_SEND 选项，则会被忽略。"

#. type: Labeled list
#: en/git-imap-send.txt:45
#, ignore-same, no-wrap, priority:100
msgid "--no-curl"
msgstr "--no-curl"

#. type: Plain text
#: en/git-imap-send.txt:49
#, priority:100
msgid "Talk to the IMAP server using git's own IMAP routines instead of using libcurl.  Ignored if Git was built with the NO_OPENSSL option set."
msgstr "使用 git 自己的 IMAP 例程与 IMAP 服务器对话，而不是使用 libcurl。 如果 Git 在构建时设置了 NO_OPENSSL 选项，则忽略。"

#. type: Plain text
#: en/git-imap-send.txt:56
#, priority:100
msgid "To use the tool, `imap.folder` and either `imap.tunnel` or `imap.host` must be set to appropriate values."
msgstr "要使用该工具，`imap.folder` 和 `imap.tunnel` 或 `imap.host` 必须被设置为适当的值。"

#. type: Plain text
#: en/git-imap-send.txt:64
#, priority:100
msgid "Using tunnel mode:"
msgstr "使用隧道模式："

#. type: delimited block .
#: en/git-imap-send.txt:69
#, fuzzy, no-wrap, priority:100
msgid ""
"[imap]\n"
"    folder = \"INBOX.Drafts\"\n"
"    tunnel = \"ssh -q -C user@example.com /usr/bin/imapd ./Maildir 2> /dev/null\"\n"
msgstr ""
"[imap]\n"
"    folder = \"INBOX.Drafts\"\n"
"    tunnel = \"ssh -q -C user@example.com /usr/bin/imapd ./Maildir 2> /dev/null\"\n"

#. type: Plain text
#: en/git-imap-send.txt:72
#, priority:100
msgid "Using direct mode:"
msgstr "使用直接模式："

#. type: delimited block .
#: en/git-imap-send.txt:79
#, fuzzy, no-wrap, priority:100
msgid ""
"[imap]\n"
"    folder = \"INBOX.Drafts\"\n"
"    host = imap://imap.example.com\n"
"    user = bob\n"
"    pass = p4ssw0rd\n"
msgstr ""
"[imap]\n"
"    folder = \"INBOX.Drafts\"\n"
"    host = imap://imap.example.com\n"
"    user = bob\n"
"    pass = p4ssw0rd\n"

#. type: Plain text
#: en/git-imap-send.txt:82
#, priority:100
msgid "Using direct mode with SSL:"
msgstr "使用 SSL 的直接模式："

#. type: delimited block .
#: en/git-imap-send.txt:91
#, no-wrap, priority:100
msgid ""
"[imap]\n"
"    folder = \"INBOX.Drafts\"\n"
"    host = imaps://imap.example.com\n"
"    user = bob\n"
"    pass = p4ssw0rd\n"
"    port = 123\n"
"    ; sslVerify = false\n"
msgstr ""
"[imap]\n"
"    folder = \"INBOX.Drafts\"\n"
"    host = imaps://imap.example.com\n"
"    user = bob\n"
"    pass = p4ssw0rd\n"
"    port = 123\n"
"    ; sslVerify = false\n"

#. type: Plain text
#: en/git-imap-send.txt:100
#, priority:100
msgid "You may want to use `sslVerify=false` while troubleshooting, if you suspect that the reason you are having trouble connecting is because the certificate you use at the private server `example.com` you are trying to set up (or have set up) may not be verified correctly."
msgstr "在排除故障时，如果你怀疑连接有问题的原因是你在试图建立（或已经建立）的私人服务器 `example.com`上使用的证书可能没有被正确验证，你可能想使用 `sslVerify=false`。"

#. type: Plain text
#: en/git-imap-send.txt:102
#, priority:100
msgid "Using Gmail's IMAP interface:"
msgstr "使用 Gmail 的 IMAP 界面："

#. type: delimited block -
#: en/git-imap-send.txt:109
#, fuzzy, no-wrap, priority:100
msgid ""
"[imap]\n"
"\tfolder = \"[Gmail]/Drafts\"\n"
"\thost = imaps://imap.gmail.com\n"
"\tuser = user@gmail.com\n"
"\tport = 993\n"
msgstr ""
"[imap]\n"
"\tfolder = \"[Gmail]/Drafts\"\n"
"\thost = imaps://imap.gmail.com\n"
"\tuser = user@gmail.com\n"
"\tport = 993\n"

#. type: Plain text
#: en/git-imap-send.txt:114
#, priority:100
msgid "You might need to instead use: `folder = \"[Google Mail]/Drafts\"` if you get an error that the \"Folder doesn't exist\"."
msgstr "如果你得到一个错误，即 “文件夹不存在”，你可能需要改用： `folder = \"[Google Mail]/Drafts\"` 。"

#. type: Plain text
#: en/git-imap-send.txt:118
#, priority:100
msgid "If your Gmail account is set to another language than English, the name of the \"Drafts\" folder will be localized."
msgstr "如果你的 Gmail 账户被设置为英语以外的其他语言，\"Drafts\" 文件夹的名称将被本地化。"

#. type: Plain text
#: en/git-imap-send.txt:120
#, priority:100
msgid "Once the commits are ready to be sent, run the following command:"
msgstr "一旦准备好发送提交，请运行以下命令："

#. type: Plain text
#: en/git-imap-send.txt:122
#, fuzzy, no-wrap, priority:100
msgid "  $ git format-patch --cover-letter -M --stdout origin/master | git imap-send\n"
msgstr "  $ git format-patch --cover-letter -M --stdout origin/master | git imap-send\n"

#. type: Plain text
#: en/git-imap-send.txt:126
#, priority:100
msgid "Just make sure to disable line wrapping in the email client (Gmail's web interface will wrap lines no matter what, so you need to use a real IMAP client)."
msgstr "只要确保禁用电子邮件客户端的换行功能（Gmail 的网络界面无论如何都会换行，所以你需要使用真正的 IMAP 客户端）。"

#. type: Title -
#: en/git-imap-send.txt:128
#, fuzzy, no-wrap, priority:100
msgid "CAUTION"
msgstr "小心"

#. type: Plain text
#: en/git-imap-send.txt:135
#, priority:100
msgid "It is still your responsibility to make sure that the email message sent by your email program meets the standards of your project.  Many projects do not like patches to be attached.  Some mail agents will transform patches (e.g. wrap lines, send them as format=flowed) in ways that make them fail.  You will get angry flames ridiculing you if you don't check this."
msgstr "你仍然有责任确保你的电子邮件程序所发送的电子邮件符合你的项目的标准。 许多项目不喜欢附加补丁。 一些邮件代理会对补丁进行转换（例如，包行，以 format=flowed 的方式发送），使其失败。 如果你不检查这个，你会得到愤怒的火苗。"

#. type: Plain text
#: en/git-imap-send.txt:139
#, no-wrap, priority:100
msgid ""
"Thunderbird in particular is known to be problematic.  Thunderbird\n"
"users may wish to visit this web page for more information:\n"
"  http://kb.mozillazine.org/Plain_text_e-mail_-_Thunderbird#Completely_plain_email\n"
msgstr ""
"尤其是Thunderbird，众所周知，它存在问题。 Thunderbird\n"
"用户可能希望访问这个网页以了解更多信息：\n"
"  http://kb.mozillazine.org/Plain_text_e-mail_-_Thunderbird#Completely_plain_email\n"

#. type: Plain text
#: en/git-imap-send.txt:143
#, priority:100
msgid "linkgit:git-format-patch[1], linkgit:git-send-email[1], mbox(5)"
msgstr "linkgit:git-format-patch[1], linkgit:git-send-email[1], mbox(5)"

#. type: Title =
#: en/git-index-pack.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-index-pack(1)"
msgstr "git-index-pack(1)"

#. type: Plain text
#: en/git-index-pack.txt:7
#, fuzzy, priority:100
msgid "git-index-pack - Build pack index file for an existing packed archive"
msgstr "git-index-pack - Build pack index file for an existing packed archive"

#. type: Plain text
#: en/git-index-pack.txt:15
#, fuzzy, no-wrap, priority:100
msgid ""
"'git index-pack' [-v] [-o <index-file>] [--[no-]rev-index] <pack-file>\n"
"'git index-pack' --stdin [--fix-thin] [--keep] [-v] [-o <index-file>]\n"
"\t\t  [--[no-]rev-index] [<pack-file>]\n"
msgstr ""
"'git index-pack' [-v] [-o <index-file>] [--[no-]rev-index] <pack-file>\n"
"'git index-pack' --stdin [--fix-thin] [--keep] [-v] [-o <index-file>]\n"
"\t\t  [--[no-]rev-index] [<pack-file>]\n"

#. type: Plain text
#: en/git-index-pack.txt:24
#, priority:100
msgid "Reads a packed archive (.pack) from the specified file, and builds a pack index file (.idx) for it. Optionally writes a reverse-index (.rev) for the specified pack. The packed archive together with the pack index can then be placed in the objects/pack/ directory of a Git repository."
msgstr "从指定的文件中读取一个打包的档案（.pack），并为其建立一个打包索引文件（.idx）。可以选择为指定的包写一个反向索引（.rev）。打包后的归档文件连同打包索引可以放在 Git 仓库的 objects/pack/ 目录中。"

#. type: Plain text
#: en/git-index-pack.txt:30
#, priority:100
msgid "Be verbose about what is going on, including progress status."
msgstr "对正在发生的事情要言之有物，包括进度状态。"

#. type: Labeled list
#: en/git-index-pack.txt:31
#, no-wrap, priority:100
msgid "-o <index-file>"
msgstr "-o <index-file>"

#. type: Plain text
#: en/git-index-pack.txt:38
#, priority:100
msgid "Write the generated pack index into the specified file.  Without this option the name of pack index file is constructed from the name of packed archive file by replacing .pack with .idx (and the program fails if the name of packed archive does not end with .pack)."
msgstr "将生成的数据包索引写入指定的文件中。 如果没有这个选项，打包索引文件的名称是根据打包档案文件的名称构建的，将 .pack 替换为 .idx（如果打包档案的名称不是以 .pack 结尾，程序将失败）。"

#. type: Labeled list
#: en/git-index-pack.txt:39
#, ignore-same, no-wrap, priority:100
msgid "--[no-]rev-index"
msgstr "--[no-]rev-index"

#. type: Plain text
#: en/git-index-pack.txt:45
#, priority:100
msgid "When this flag is provided, generate a reverse index (a `.rev` file) corresponding to the given pack. If `--verify` is given, ensure that the existing reverse index is correct. Takes precedence over `pack.writeReverseIndex`."
msgstr "当提供这个标志时，生成一个与给定包对应的反向索引（一个 `.rev` 文件）。如果给了 `--verify`，确保现有的反向索引是正确的。优先于 `pack.writeReverseIndex`。"

#. type: Plain text
#: en/git-index-pack.txt:55
#, priority:100
msgid "When this flag is provided, the pack is read from stdin instead and a copy is then written to <pack-file>. If <pack-file> is not specified, the pack is written to objects/pack/ directory of the current Git repository with a default name determined from the pack content.  If <pack-file> is not specified consider using --keep to prevent a race condition between this process and 'git repack'."
msgstr "当提供这个标志时，数据包将从标注输入流读取，然后将副本写入 <pack-file>。如果没有指定 <pack-file>，数据包会被写入当前 Git 仓库的 objects/pack/ 目录中，其默认名称由数据包内容决定。 如果没有指定 <pack-file>，可以考虑使用 --keep 来防止这个过程和 'git repack' 之间出现竞争状态。"

#. type: Labeled list
#: en/git-index-pack.txt:56
#, ignore-same, no-wrap, priority:100
msgid "--fix-thin"
msgstr "--fix-thin"

#. type: Plain text
#: en/git-index-pack.txt:61
#, priority:100
msgid "Fix a \"thin\" pack produced by `git pack-objects --thin` (see linkgit:git-pack-objects[1] for details) by adding the excluded objects the deltified objects are based on to the pack. This option only makes sense in conjunction with --stdin."
msgstr "修正由 `git pack-objects --thin` 产生的 “轻量” 包（详见 linkgit:git-pack-objects[1]），将被删除的对象所基于的排除对象加入包中。这个选项只有在与 --stdin 结合时才有意义。"

#. type: Plain text
#: en/git-index-pack.txt:69
#, priority:100
msgid "Before moving the index into its final destination create an empty .keep file for the associated pack file.  This option is usually necessary with --stdin to prevent a simultaneous 'git repack' process from deleting the newly constructed pack and index before refs can be updated to use objects contained in the pack."
msgstr "在将索引移到其最终目的地之前，为相关的包文件创建一个空的 .keep 文件。 这个选项通常需要和 --stdin一起使用，以防止同时进行的 \"git repack\" 进程在更新引用以使用 pack 中包含的对象之前删除新建的 pack 和 index。"

#. type: Labeled list
#: en/git-index-pack.txt:70
#, fuzzy, no-wrap, priority:100
msgid "--keep=<msg>"
msgstr "--keep=<msg>"

#. type: Plain text
#: en/git-index-pack.txt:76
#, priority:100
msgid "Like --keep create a .keep file before moving the index into its final destination, but rather than creating an empty file place '<msg>' followed by an LF into the .keep file.  The '<msg>' message can later be searched for within all .keep files to locate any which have outlived their usefulness."
msgstr "像 --keep 一样，在将索引移到最终目的地之前创建一个 .keep 文件，但不是创建一个空文件，而是在 .keep 文件中放入 '<msg>' 和一个 LF。 以后可以在所有的 .keep 文件中搜索 '<msg>' 信息，以找到任何已经失去作用的文件。"

#. type: Labeled list
#: en/git-index-pack.txt:77 en/git-pack-objects.txt:291
#, fuzzy, no-wrap, priority:100
msgid "--index-version=<version>[,<offset>]"
msgstr "--index-version=<version>[,<offset>]"

#. type: Plain text
#: en/git-index-pack.txt:81 en/git-pack-objects.txt:295
#, priority:100
msgid "This is intended to be used by the test suite only. It allows to force the version for the generated pack index, and to force 64-bit index entries on objects located above the given offset."
msgstr "这是为测试套件准备的。它允许为生成的数据包索引强制选择版本，并对位于给定偏移量以上的对象强制选择 64 位索引条目。"

#. type: Plain text
#: en/git-index-pack.txt:84
#, priority:100
msgid "Die, if the pack contains broken objects or links."
msgstr "死亡，如果该包包含破碎的对象或链接。"

#. type: Labeled list
#: en/git-index-pack.txt:85
#, ignore-same, no-wrap, priority:100
msgid "--progress-title"
msgstr "--progress-title"

#. type: Plain text
#: en/git-index-pack.txt:87 en/git-index-pack.txt:96
#, priority:100
msgid "For internal use only."
msgstr "仅供内部使用。"

#. type: Plain text
#: en/git-index-pack.txt:90
#, priority:100
msgid "Set the title of the progress bar. The title is \"Receiving objects\" by default and \"Indexing objects\" when `--stdin` is specified."
msgstr "设置进度条的标题。标题默认为 \"Receiving objects\"，当指定 `--stdin` 时为 \"Indexing objects\"。"

#. type: Plain text
#: en/git-index-pack.txt:93
#, priority:100
msgid "Die if the pack contains broken links. For internal use only."
msgstr "如果数据包中包含无法链接的链接则死亡。仅供内部使用。"

#. type: Labeled list
#: en/git-index-pack.txt:94
#, ignore-same, no-wrap, priority:100
msgid "--fsck-objects"
msgstr "--fsck-objects"

#. type: Plain text
#: en/git-index-pack.txt:101
#, priority:100
msgid "Die if the pack contains broken objects. If the pack contains a tree pointing to a .gitmodules blob that does not exist, prints the hash of that blob (for the caller to check) after the hash that goes into the name of the pack/idx file (see \"Notes\")."
msgstr "如果数据包中包含破损的对象，则死亡。如果数据包包含一个指向不存在的 .gitmodules blob 的树，则在进入数据包 /idx 文件名的哈希值之后打印该 blob 的哈希值（供调用者检查）（见 “注意事项”）。"

#. type: Labeled list
#: en/git-index-pack.txt:102 en/git-pack-objects.txt:281 en/git-repack.txt:120
#, fuzzy, no-wrap, priority:100
msgid "--threads=<n>"
msgstr "--threads=<n>"

#. type: Plain text
#: en/git-index-pack.txt:111
#, priority:100
msgid "Specifies the number of threads to spawn when resolving deltas. This requires that index-pack be compiled with pthreads otherwise this option is ignored with a warning.  This is meant to reduce packing time on multiprocessor machines. The required amount of memory for the delta search window is however multiplied by the number of threads.  Specifying 0 will cause Git to auto-detect the number of CPU's and use maximum 3 threads."
msgstr "指定解析 deltas 时产生的线程数量。这要求 index-pack 在编译时使用 pthreads，否则这个选项会被忽略并发出警告。 这是为了减少多处理器机器上的打包时间。然而，delta 搜索窗口所需的内存量要乘以线程的数量。 指定为 0 将导致 Git 自动检测 CPU 的数量并使用最多 3 个线程。"

#. type: Labeled list
#: en/git-index-pack.txt:112 en/git-unpack-objects.txt:47
#, fuzzy, no-wrap, priority:100
msgid "--max-input-size=<size>"
msgstr "--max-input-size=<size>"

#. type: Plain text
#: en/git-index-pack.txt:114 en/git-unpack-objects.txt:49
#, priority:100
msgid "Die, if the pack is larger than <size>."
msgstr "如果数据包大于 <size>，则死亡。"

#. type: Labeled list
#: en/git-index-pack.txt:115 en/git-show-index.txt:42
#, fuzzy, no-wrap, priority:100
msgid "--object-format=<hash-algorithm>"
msgstr "--object-format=<hash-algorithm>"

#. type: Plain text
#: en/git-index-pack.txt:120
#, fuzzy, priority:100
#| msgid "Specify the given object format (hash algorithm) for the repository.  The valid values are 'sha1' and (if enabled) 'sha256'.  'sha1' is the default."
msgid "Specify the given object format (hash algorithm) for the pack.  The valid values are 'sha1' and (if enabled) 'sha256'.  The default is the algorithm for the current repository (set by `extensions.objectFormat`), or 'sha1' if no value is set or outside a repository."
msgstr "指定存储库的对象格式（哈希算法）。有效值为 'sha1' 和（如果启用）'sha256'。'sha1' 是默认值。"

#. type: Plain text
#: en/git-index-pack.txt:122
#, fuzzy, priority:100
#| msgid "This option may be specified more than once."
msgid "This option cannot be used with --stdin."
msgstr "这个选项可以被指定多次。"

#. type: Labeled list
#: en/git-index-pack.txt:125
#, fuzzy, no-wrap, priority:100
msgid "--promisor[=<message>]"
msgstr "-m <message>"

#. type: Plain text
#: en/git-index-pack.txt:132
#, priority:100
msgid "Before committing the pack-index, create a .promisor file for this pack. Particularly helpful when writing a promisor pack with --fix-thin since the name of the pack is not final until the pack has been fully written. If a `<message>` is provided, then that content will be written to the .promisor file for future reference. See link:technical/partial-clone.html[partial clone] for more information."
msgstr "在提交 pack-index 之前，为这个 pack 创建一个 .promosor 文件。在用 --fix-thin 编写 pack 时特别有帮助，因为在完全编写完 pack 之前，pack 的名字还不是最终的。如果提供了 `<message>`，那么该内容将被写入 .promosor 文件，供将来参考。参见 link:technical/partial-clone.html[partial clone] 以了解更多信息。"

#. type: Plain text
#: en/git-index-pack.txt:140
#, priority:100
msgid "Once the index has been created, the hash that goes into the name of the pack/idx file is printed to stdout. If --stdin was also used then this is prefixed by either \"pack\\t\", or \"keep\\t\" if a new .keep file was successfully created. This is useful to remove a"
msgstr "一旦索引被创建，进入 pack/idx 文件名的哈希值将被打印到标准输出流。如果还使用了 --stdin，那么它的前缀是 \"pack\\t\"，或者 \"keep\\t\"（如果成功创建了一个新的 .keep 文件）。这对于删除一个"

#. type: Block title
#: en/git-index-pack.txt:140
#, no-wrap, priority:100
msgid "keep file used as a lock to prevent the race with 'git repack'"
msgstr "用一个锁来持有文件，以防止与 'git repack' 竞争"

#. type: Plain text
#: en/git-index-pack.txt:142
#, priority:100
msgid "mentioned above."
msgstr "上述提到的。"

#. type: Title =
#: en/git-init-db.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-init-db(1)"
msgstr "git-init-db(1)"

#. type: Plain text
#: en/git-init-db.txt:7
#, priority:100
msgid "git-init-db - Creates an empty Git repository"
msgstr "git-init-db - 创建一个空的 Git 仓库"

#. type: Plain text
#: en/git-init-db.txt:13
#, fuzzy, no-wrap, priority:100
msgid "'git init-db' [-q | --quiet] [--bare] [--template=<template-directory>] [--separate-git-dir <git-dir>] [--shared[=<permissions>]]\n"
msgstr "'git init-db' [-q | --quiet] [--bare] [--template=<template_directory>] [--separate-git-dir <git dir>] [--shared[=<permissions>]]\n"

#. type: Plain text
#: en/git-init-db.txt:20
#, priority:100
msgid "This is a synonym for linkgit:git-init[1].  Please refer to the documentation of that command."
msgstr "这是 linkgit:git-init[1] 的一个同义词。 请参考该命令的文档。"

#. type: Title =
#: en/git-init.txt:2
#, ignore-same, no-wrap, priority:300
msgid "git-init(1)"
msgstr "git-init(1)"

#. type: Plain text
#: en/git-init.txt:7
#, fuzzy, priority:300
msgid "git-init - Create an empty Git repository or reinitialize an existing one"
msgstr "git-init - Create an empty Git repository or reinitialize an existing one"

#. type: Plain text
#: en/git-init.txt:16
#, fuzzy, no-wrap, priority:300
#| msgid ""
#| "'git init' [-q | --quiet] [--bare] [--template=<template_directory>]\n"
#| "\t  [--separate-git-dir <git dir>]\n"
#| "\t  [--shared[=<permissions>]] [directory]\n"
msgid ""
"'git init' [-q | --quiet] [--bare] [--template=<template-directory>]\n"
"\t  [--separate-git-dir <git-dir>] [--object-format=<format>]\n"
"\t  [-b <branch-name> | --initial-branch=<branch-name>]\n"
"\t  [--shared[=<permissions>]] [<directory>]\n"
msgstr ""
"'git init' [-q | --quiet] [--bare] [--template=<template_directory>]\n"
"\t  [--separate-git-dir <git dir>] [--object-format=<format>]\n"
"\t  [-b <branch-name> | --initial-branch=<branch-name>]\n"
"\t  [--shared[=<permissions>]] [directory]\n"

#. type: Plain text
#: en/git-init.txt:26
#, fuzzy, priority:300
msgid "This command creates an empty Git repository - basically a `.git` directory with subdirectories for `objects`, `refs/heads`, `refs/tags`, and template files.  An initial branch without any commits will be created (see the `--initial-branch` option below for its name)."
msgstr "该命令创建一个空的Git存储库 - 本质上是一个 `.git` 目录，其中包含 `objects`、`refs/heads`、`refs/tags`和模板文件的子目录。还将创建一个引用master分支 HEAD 的初始 `HEAD` 文件。"

#. type: Plain text
#: en/git-init.txt:29
#, fuzzy, priority:300
msgid "If the `$GIT_DIR` environment variable is set then it specifies a path to use instead of `./.git` for the base of the repository."
msgstr "如果设置了 `$GIT_DIR` 环境变量，那么它将指定用于仓库基础的路径，而不是 `./.git` ."

#. type: Plain text
#: en/git-init.txt:34
#, fuzzy, priority:300
msgid "If the object storage directory is specified via the `$GIT_OBJECT_DIRECTORY` environment variable then the sha1 directories are created underneath - otherwise the default `$GIT_DIR/objects` directory is used."
msgstr "如果通过 `$GIT_OBJECT_DIRECTORY` 环境变量指定了对象存储目录，那么将在该目录下创建 sha1 目录，否则将使用默认的 `$GIT_DIR/objects` 目录。"

#. type: Plain text
#: en/git-init.txt:39
#, fuzzy, priority:300
msgid "Running 'git init' in an existing repository is safe. It will not overwrite things that are already there. The primary reason for rerunning 'git init' is to pick up newly added templates (or to move the repository to another place if --separate-git-dir is given)."
msgstr "在现有存储库中运行 'git init' 是安全的。它不会覆盖已经存在的内容。重新运行 'git init' 的主要原因是选择新添加的模板（如果给定了 --separate-git-dir 参数，则将存储库移至另一个位置）。"

#. type: Plain text
#: en/git-init.txt:47
#, fuzzy, priority:300
msgid "Only print error and warning messages; all other output will be suppressed."
msgstr "仅打印错误和警告消息；所有其他输出将不会显示。"

#. type: Plain text
#: en/git-init.txt:52
#, fuzzy, priority:300
msgid "Create a bare repository. If `GIT_DIR` environment is not set, it is set to the current working directory."
msgstr "创建一个纯仓库。如果未设置 `GIT_DIR` 环境变量，则将其设置为当前工作目录。"

#. type: Labeled list
#: en/git-init.txt:53
#, fuzzy, no-wrap, priority:300
msgid "--object-format=<format>"
msgstr "--object-format=<format>"

#. type: Plain text
#: en/git-init.txt:57
#, fuzzy, priority:300
msgid "Specify the given object format (hash algorithm) for the repository.  The valid values are 'sha1' and (if enabled) 'sha256'.  'sha1' is the default."
msgstr "指定存储库的对象格式（哈希算法）。有效值为 'sha1' 和（如果启用）'sha256'。'sha1' 是默认值。"

#. type: Plain text
#: en/git-init.txt:64
#, fuzzy, priority:300
msgid "Specify the directory from which templates will be used.  (See the \"TEMPLATE DIRECTORY\" section below.)"
msgstr "指定要使用模板的目录。（请参见下面的“模板目录”部分。）"

#. type: Plain text
#: en/git-init.txt:71
#, fuzzy, priority:300
msgid "Instead of initializing the repository as a directory to either `$GIT_DIR` or `./.git/`, create a text file there containing the path to the actual repository.  This file acts as filesystem-agnostic Git symbolic link to the repository."
msgstr "并不将存储库初始化至 `$GIT_DIR` 或 `./.git/` 目录，而是在其中创建一个包含实际存储库路径的文本文件。此文件作为连接到仓库的 Git 符号链接，其与文件系统无关。"

#. type: Plain text
#: en/git-init.txt:73
#, fuzzy, priority:300
msgid "If this is reinitialization, the repository will be moved to the specified path."
msgstr "如果为重新初始化操作，则将存储库移动到指定的路径。"

#. type: Labeled list
#: en/git-init.txt:74
#, fuzzy, no-wrap, priority:300
#| msgid "--branch <name>"
msgid "-b <branch-name>"
msgstr "-b <branch-name>"

#. type: Labeled list
#: en/git-init.txt:75
#, fuzzy, no-wrap, priority:300
#| msgid "--branch <name>"
msgid "--initial-branch=<branch-name>"
msgstr "--initial-branch=<branch-name>"

#. type: Plain text
#: en/git-init.txt:81
#, fuzzy, priority:300
msgid "Use the specified name for the initial branch in the newly created repository.  If not specified, fall back to the default name (currently `master`, but this is subject to change in the future; the name can be customized via the `init.defaultBranch` configuration variable)."
msgstr "在新创建的仓库中为初始分支指定名称。如果没有指定，则使用默认名称：`master`。"

#. type: Labeled list
#: en/git-init.txt:82
#, fuzzy, no-wrap, priority:300
msgid "--shared[=(false|true|umask|group|all|world|everybody|<perm>)]"
msgstr "--shared[=(false|true|umask|group|all|world|everybody)]"

#. type: Plain text
#: en/git-init.txt:90
#, fuzzy, priority:300
msgid "Specify that the Git repository is to be shared amongst several users.  This allows users belonging to the same group to push into that repository.  When specified, the config variable \"core.sharedRepository\" is set so that files and directories under `$GIT_DIR` are created with the requested permissions.  When not specified, Git will use permissions reported by umask(2)."
msgstr "指定 Git 存储库在多个用户之间共享。这允许属于同一组的用户推送到该存储库。指定时，将设置配置变量 \"core.sharedRepository\"，以便使用请求的权限创建 `$GIT_DIR` 下的文件和目录。未指定时，Git 将使用 umask(2) 返回的权限。"

#. type: Plain text
#: en/git-init.txt:93
#, fuzzy, priority:300
msgid "The option can have the following values, defaulting to 'group' if no value is given:"
msgstr "此选项可以有以下值，如果未给定值，则默认为 'group'："

#. type: Labeled list
#: en/git-init.txt:95
#, fuzzy, no-wrap, priority:300
msgid "'umask' (or 'false')"
msgstr "'umask'（或 'false'）"

#. type: Plain text
#: en/git-init.txt:99
#, fuzzy, priority:300
msgid "Use permissions reported by umask(2). The default, when `--shared` is not specified."
msgstr "使用 umask(2) 返回的权限。未指定 `--shared` 时，此为默认值。"

#. type: Labeled list
#: en/git-init.txt:100
#, fuzzy, no-wrap, priority:300
msgid "'group' (or 'true')"
msgstr "'group' (or 'true')"

#. type: Plain text
#: en/git-init.txt:108
#, fuzzy, priority:300
msgid "Make the repository group-writable, (and g+sx, since the git group may be not the primary group of all users). This is used to loosen the permissions of an otherwise safe umask(2) value. Note that the umask still applies to the other permission bits (e.g. if umask is '0022', using 'group' will not remove read privileges from other (non-group) users). See '0xxx' for how to exactly specify the repository permissions."
msgstr "使存储库组可写（并且 g+sx，因为 git 组可能不是所有用户的主要组）。这用于放宽原本安全的 umask(2) 值的权限。请注意，umask 仍然适用于其他权限位（例如，如果 umask 为 '0022'，则使用 'group' 不会删除其他（非组）用户的读取特权）。有关如何精确指定存储库权限的信息，请参见 '0xxx'。"

#. type: Labeled list
#: en/git-init.txt:109
#, fuzzy, no-wrap, priority:300
msgid "'all' (or 'world' or 'everybody')"
msgstr "'all' （或 'world' 或 'everybody'）"

#. type: Plain text
#: en/git-init.txt:112
#, fuzzy, priority:300
msgid "Same as 'group', but make the repository readable by all users."
msgstr "与使用 'group' 选项相同，但使存储库对所有用户可读。"

#. type: Labeled list
#: en/git-init.txt:113
#, no-wrap, priority:300
msgid "'<perm>'"
msgstr "'<perm>'"

#. type: Plain text
#: en/git-init.txt:123
#, fuzzy, priority:300
msgid "'<perm>' is a 3-digit octal number prefixed with `0` and each file will have mode '<perm>'. '<perm>' will override users' umask(2)  value (and not only loosen permissions as 'group' and 'all' does). '0640' will create a repository which is group-readable, but not group-writable or accessible to others. '0660' will create a repo that is readable and writable to the current user and group, but inaccessible to others (directories and executable files get their `x` bit from the `r` bit for corresponding classes of users)."
msgstr "'0xxx' 是一个八进制数，每个文件的模式均为 '0xxx'。' 0xxx' 将覆盖用户的 umask(2) 值（不仅像 'group 和 'all' 那样放宽权限）。'0640' 将创建一个组可读取但不能组写入且其他用户无法访问的存储库。'0660' 将创建当前用户和组可读可写但其他用户无法访问的存储库。"

#. type: Plain text
#: en/git-init.txt:128
#, fuzzy, priority:300
msgid "By default, the configuration flag `receive.denyNonFastForwards` is enabled in shared repositories, so that you cannot force a non fast-forwarding push into it."
msgstr "默认情况下，共享存储库中启用了配置标志 `receive.denyNonFastForwards`，因此您不能强制将非快速前进提交推送到其中。"

#. type: Plain text
#: en/git-init.txt:131
#, fuzzy, priority:300
msgid "If you provide a 'directory', the command is run inside it. If this directory does not exist, it will be created."
msgstr "如果提供 'dicrectory'，则命令在其中运行。如果此目录不存在，则创建它。"

#. type: Title -
#: en/git-init.txt:133
#, fuzzy, no-wrap, priority:300
msgid "TEMPLATE DIRECTORY"
msgstr "模板目录"

#. type: Plain text
#: en/git-init.txt:137
#, fuzzy, priority:300
msgid "Files and directories in the template directory whose name do not start with a dot will be copied to the `$GIT_DIR` after it is created."
msgstr "模板目录中名称不以点开头的文件和目录将在创建后复制到 `$GIT_DIR` 中。"

#. type: Plain text
#: en/git-init.txt:139
#, fuzzy, priority:300
msgid "The template directory will be one of the following (in order):"
msgstr "模板目录将是以下之一（按顺序）："

#. type: Plain text
#: en/git-init.txt:141
#, fuzzy, priority:300
msgid "the argument given with the `--template` option;"
msgstr "用 `--template` 选项给出的参数；"

#. type: Plain text
#: en/git-init.txt:143
#, priority:300
msgid "the contents of the `$GIT_TEMPLATE_DIR` environment variable;"
msgstr "`$GIT_TEMPLATE_DIR` 环境变量的内容；"

#. type: Plain text
#: en/git-init.txt:145
#, fuzzy, priority:300
msgid "the `init.templateDir` configuration variable; or"
msgstr "`init.templateDir` 配置变量；或者"

#. type: Plain text
#: en/git-init.txt:147
#, fuzzy, priority:300
msgid "the default template directory: `/usr/share/git-core/templates`."
msgstr "默认模板目录：`/usr/share/git-core/templates`。"

#. type: Plain text
#: en/git-init.txt:150
#, fuzzy, priority:300
msgid "The default template directory includes some directory structure, suggested \"exclude patterns\" (see linkgit:gitignore[5]), and sample hook files."
msgstr "默认的模板目录包括一些目录结构，建议的“排除模式”（请参阅 linkgit:gitignore[5]）和示例钩子文件。"

#. type: Plain text
#: en/git-init.txt:153
#, fuzzy, priority:300
msgid "The sample hooks are all disabled by default. To enable one of the sample hooks rename it by removing its `.sample` suffix."
msgstr "默认情况下，样例钩子都被禁用。要启用一个示例挂钩，请通过删除其后缀 `.sample` 对其重命名。"

#. type: Plain text
#: en/git-init.txt:155
#, fuzzy, priority:300
msgid "See linkgit:githooks[5] for more general info on hook execution."
msgstr "有关钩子执行的更多信息，请参见 linkgit:githooks[5]。"

#. type: Labeled list
#: en/git-init.txt:159
#, fuzzy, no-wrap, priority:300
msgid "Start a new Git repository for an existing code base"
msgstr "为现有代码库启动新的 Git 仓库"

#. type: delimited block -
#: en/git-init.txt:166
#, fuzzy, no-wrap, priority:300
msgid ""
"$ cd /path/to/my/codebase\n"
"$ git init      <1>\n"
"$ git add .     <2>\n"
"$ git commit    <3>\n"
msgstr ""
"$ cd /path/to/my/codebase\n"
"$ git init      <1>\n"
"$ git add .     <2>\n"
"$ git commit    <3>\n"

#. type: Plain text
#: en/git-init.txt:169
#, fuzzy, priority:300
msgid "Create a /path/to/my/codebase/.git directory."
msgstr "创建 /path/to/my/codebase/.git 目录。"

#. type: Plain text
#: en/git-init.txt:170
#, fuzzy, priority:300
msgid "Add all existing files to the index."
msgstr "将所有现有文件添加到索引。"

#. type: Plain text
#: en/git-init.txt:171
#, fuzzy, priority:300
msgid "Record the pristine state as the first commit in the history."
msgstr "将原始状态记录为历史记录中的第一次提交。"

#. type: Title =
#: en/git-instaweb.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-instaweb(1)"
msgstr "git-instaweb(1)"

#. type: Plain text
#: en/git-instaweb.txt:7
#, priority:100
msgid "git-instaweb - Instantly browse your working repository in gitweb"
msgstr "git-instaweb - 立即在 gitweb 中浏览您的工作仓库"

#. type: Plain text
#: en/git-instaweb.txt:14
#, no-wrap, priority:100
msgid ""
"'git instaweb' [--local] [--httpd=<httpd>] [--port=<port>]\n"
"               [--browser=<browser>]\n"
"'git instaweb' [--start] [--stop] [--restart]\n"
msgstr ""
"'git instaweb' [--local] [--httpd=<httpd>] [--port=<端口>]\n"
"               [--browser=<浏览器>]\n"
"'git instaweb' [--start] [--stop] [--restart]\n"

#. type: Plain text
#: en/git-instaweb.txt:19
#, priority:100
msgid "A simple script to set up `gitweb` and a web server for browsing the local repository."
msgstr "一个简单的脚本，用来设置 `gitweb` 和浏览本地仓库的网络服务器。"

#. type: Plain text
#: en/git-instaweb.txt:26
#, priority:100
msgid "Only bind the web server to the local IP (127.0.0.1)."
msgstr "只将 Web 服务器绑定到本地 IP（127.0.0.1）。"

#. type: Labeled list
#: en/git-instaweb.txt:28
#, ignore-same, no-wrap, priority:100
msgid "--httpd"
msgstr "--httpd"

#. type: Plain text
#: en/git-instaweb.txt:35
#, priority:100
msgid "The HTTP daemon command-line that will be executed.  Command-line options may be specified here, and the configuration file will be added at the end of the command-line.  Currently apache2, lighttpd, mongoose, plackup, python and webrick are supported.  (Default: lighttpd)"
msgstr "将被执行的 HTTP 守护程序的命令行。 命令行选项可以在这里指定，配置文件将被添加到命令行的最后。 目前支持 apache2、lighttpd、mongoose、plackup、python 和 webrick。 (默认：lighttpd)"

#. type: Labeled list
#: en/git-instaweb.txt:37
#, ignore-same, no-wrap, priority:100
msgid "--module-path"
msgstr "--module-path"

#. type: Plain text
#: en/git-instaweb.txt:40
#, priority:100
msgid "The module path (only needed if httpd is Apache).  (Default: /usr/lib/apache2/modules)"
msgstr "模块路径（只有当 httpd 是 Apache 时才需要）。 (默认：/usr/lib/apache2/modules)"

#. type: Labeled list
#: en/git-instaweb.txt:42
#, ignore-same, no-wrap, priority:100
msgid "--port"
msgstr "--port"

#. type: Plain text
#: en/git-instaweb.txt:44
#, priority:100
msgid "The port number to bind the httpd to.  (Default: 1234)"
msgstr "绑定 httpd 的端口号。 (默认：1234)"

#. type: Labeled list
#: en/git-instaweb.txt:46
#, ignore-same, no-wrap, priority:100
msgid "--browser"
msgstr "--browser"

#. type: Plain text
#: en/git-instaweb.txt:52
#, priority:100
msgid "The web browser that should be used to view the gitweb page. This will be passed to the 'git web{litdd}browse' helper script along with the URL of the gitweb instance. See linkgit:git-web{litdd}browse[1] for more information about this. If the script fails, the URL will be printed to stdout."
msgstr "查看 gitweb 页面时应使用的网络浏览器。这将与 gitweb 实例的 URL 一起传递给 'git web{litdd}browse' 辅助脚本。参见 linkgit:git-web{litdd}browse[1] 获取更多相关信息。如果脚本失败，URL 会被打印到标准输出流。"

#. type: Labeled list
#: en/git-instaweb.txt:53 en/git-update-ref.txt:125
#, fuzzy, no-wrap, priority:100
msgid "start"
msgstr "起点"

#. type: Labeled list
#: en/git-instaweb.txt:54
#, ignore-same, no-wrap, priority:100
msgid "--start"
msgstr "--start"

#. type: Plain text
#: en/git-instaweb.txt:57
#, priority:100
msgid "Start the httpd instance and exit.  Regenerate configuration files as necessary for spawning a new instance."
msgstr "启动 httpd 实例并退出。 根据需要重新生成配置文件以生成新的实例。"

#. type: Labeled list
#: en/git-instaweb.txt:58
#, fuzzy, no-wrap, priority:100
msgid "stop"
msgstr "停止"

#. type: Labeled list
#: en/git-instaweb.txt:59
#, ignore-same, no-wrap, priority:100
msgid "--stop"
msgstr "--stop"

#. type: Plain text
#: en/git-instaweb.txt:63
#, priority:100
msgid "Stop the httpd instance and exit.  This does not generate any of the configuration files for spawning a new instance, nor does it close the browser."
msgstr "停止 httpd 实例并退出。 这不会生成任何用于生成新实例的配置文件，也不会关闭浏览器。"

#. type: Labeled list
#: en/git-instaweb.txt:64
#, fuzzy, no-wrap, priority:100
msgid "restart"
msgstr "重新启动"

#. type: Labeled list
#: en/git-instaweb.txt:65
#, ignore-same, no-wrap, priority:100
msgid "--restart"
msgstr "--restart"

#. type: Plain text
#: en/git-instaweb.txt:68
#, priority:100
msgid "Restart the httpd instance and exit.  Regenerate configuration files as necessary for spawning a new instance."
msgstr "重新启动 httpd 实例并退出。 根据需要重新生成配置文件以生成新的实例。"

#. type: Plain text
#: en/git-instaweb.txt:73
#, priority:100
msgid "You may specify configuration in your .git/config"
msgstr "你可以在你的 .git/config 中指定配置"

#. type: delimited block -
#: en/git-instaweb.txt:81
#, fuzzy, no-wrap, priority:100
msgid ""
"[instaweb]\n"
"\tlocal = true\n"
"\thttpd = apache2 -f\n"
"\tport = 4321\n"
"\tbrowser = konqueror\n"
"\tmodulePath = /usr/lib/apache2/modules\n"
msgstr ""
"[instaweb]\n"
"\tlocal = true\n"
"\thttpd = apache2 -f\n"
"\tport = 4321\n"
"\tbrowser = konqueror\n"
"\tmodulePath = /usr/lib/apache2/modules\n"

#. type: Plain text
#: en/git-instaweb.txt:87
#, priority:100
msgid "If the configuration variable `instaweb.browser` is not set, `web.browser` will be used instead if it is defined. See linkgit:git-web{litdd}browse[1] for more information about this."
msgstr "如果配置变量 `instaweb.browser` 没有设置，如果定义了 `web.browser`，将使用它来代替。参见 linkgit:git-web{litdd}browse[1] 以了解更多相关信息。"

#. type: Title =
#: en/git-interpret-trailers.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-interpret-trailers(1)"
msgstr "git-interpret-trailers(1)"

#. type: Plain text
#: en/git-interpret-trailers.txt:7
#, priority:100
msgid "git-interpret-trailers - Add or parse structured information in commit messages"
msgstr "git-interpret-trailers - 添加或解析提交消息中的结构化信息"

#. type: Plain text
#: en/git-interpret-trailers.txt:14
#, ignore-ellipsis, no-wrap, priority:100
msgid ""
"'git interpret-trailers' [--in-place] [--trim-empty]\n"
"\t\t\t[(--trailer <token>[(=|:)<value>])...]\n"
"\t\t\t[--parse] [<file>...]\n"
msgstr ""
"'git interpret-trailers' [--in-place] [--trim-empty]\n"
"\t\t\t[(--trailer <token>[(=|:)<值>])...]\n"
"\t\t\t[--parse] [<文件>...]\n"

#. type: Plain text
#: en/git-interpret-trailers.txt:20
#, fuzzy, priority:100
#| msgid "Help parsing or adding 'trailers' lines, that look similar to RFC 822 e-mail headers, at the end of the otherwise free-form part of a commit message."
msgid "Add or parse 'trailer' lines that look similar to RFC 822 e-mail headers, at the end of the otherwise free-form part of a commit message. For example, in the following commit message"
msgstr "帮助解析或添加 ‘尾注’ 行，看起来类似于 RFC 822 电子邮件标题，在提交消息的自由格式部分的末尾。"

#. type: delimited block -
#: en/git-interpret-trailers.txt:23
#, fuzzy, no-wrap, priority:100
msgid "subject\n"
msgstr "主题"

#. type: delimited block -
#: en/git-interpret-trailers.txt:25
#, no-wrap, priority:100
msgid "Lorem ipsum dolor sit amet, consectetur adipiscing elit.\n"
msgstr ""

#. type: delimited block -
#: en/git-interpret-trailers.txt:28 en/git-interpret-trailers.txt:312
#, no-wrap, priority:100
msgid ""
"Signed-off-by: Alice <alice@example.com>\n"
"Signed-off-by: Bob <bob@example.com>\n"
msgstr ""
"Signed-off-by: Alice <alice@example.com>\n"
"Signed-off-by: Bob <bob@example.com>\n"

#. type: Plain text
#: en/git-interpret-trailers.txt:31
#, priority:100
msgid "the last two lines starting with \"Signed-off-by\" are trailers."
msgstr ""

#. type: Plain text
#: en/git-interpret-trailers.txt:38
#, fuzzy, priority:100
#| msgid "This command reads some patches or commit messages from either the <file> arguments or the standard input if no <file> is specified. If `--parse` is specified, the output consists of the parsed trailers."
msgid "This command reads commit messages from either the <file> arguments or the standard input if no <file> is specified.  If `--parse` is specified, the output consists of the parsed trailers.  Otherwise, this command applies the arguments passed using the `--trailer` option, if any, to each input file. The result is emitted on the standard output."
msgstr "这个命令从 <文件> 参数或标准输入（如果没有指定 <文件>）中读取一些补丁或提交信息。如果指定了 `--parse`，则输出由解析后的预告片组成。"

#. type: Plain text
#: en/git-interpret-trailers.txt:45
#, priority:100
msgid "This command can also operate on the output of linkgit:git-format-patch[1], which is more elaborate than a plain commit message. Namely, such output includes a commit message (as above), a \"---\" divider line, and a patch part.  For these inputs, the divider and patch parts are not modified by this command and are emitted as is on the output, unless `--no-divider` is specified."
msgstr ""

#. type: Plain text
#: en/git-interpret-trailers.txt:50
#, fuzzy, priority:100
#| msgid "Some configuration variables control the way the `--trailer` arguments are applied to each commit message and the way any existing trailer in the commit message is changed. They also make it possible to automatically add some trailers."
msgid "Some configuration variables control the way the `--trailer` arguments are applied to each input and the way any existing trailer in the input is changed. They also make it possible to automatically add some trailers."
msgstr "一些配置变量可以控制 `--trailer` 参数应用于每条提交信息的方式，以及修改提交信息中任何现有尾注的方式。它们还可以自动添加一些尾注。"

#. type: Plain text
#: en/git-interpret-trailers.txt:57
#, fuzzy, priority:100
#| msgid "By default, a '<token>=<value>' or '<token>:<value>' argument given using `--trailer` will be appended after the existing trailers only if the last trailer has a different (<token>, <value>) pair (or if there is no existing trailer). The <token> and <value> parts will be trimmed to remove starting and trailing whitespace, and the resulting trimmed <token> and <value> will appear in the message like this:"
msgid "By default, a '<token>=<value>' or '<token>:<value>' argument given using `--trailer` will be appended after the existing trailers only if the last trailer has a different (<token>, <value>) pair (or if there is no existing trailer). The <token> and <value> parts will be trimmed to remove starting and trailing whitespace, and the resulting trimmed <token> and <value> will appear in the output like this:"
msgstr "默认情况下，使用 `--trailer` 给出的 '<token>=<值>' 或 '<token>:<值>' 参数将被附加到现有的尾注之后，只有当最后一个尾注有不同的（<token>, <值>）对（或者没有现有的尾注）。<token> 和 <值>部分将被修剪，以去除开头和结尾的空白，修剪后的 <token> 和 <值> 将像这样出现在消息中："

#. type: delimited block -
#: en/git-interpret-trailers.txt:60
#, no-wrap, priority:100
msgid "token: value\n"
msgstr "token: value\n"

#. type: Plain text
#: en/git-interpret-trailers.txt:67
#, priority:100
msgid "This means that the trimmed <token> and <value> will be separated by `': '` (one colon followed by one space). For convenience, the <token> can be a shortened string key (e.g., \"sign\") instead of the full string which should appear before the separator on the output (e.g., \"Signed-off-by\"). This can be configured using the 'trailer.<token>.key' configuration variable."
msgstr ""

#. type: Plain text
#: en/git-interpret-trailers.txt:72
#, fuzzy, priority:100
#| msgid "By default the new trailer will appear at the end of all the existing trailers. If there is no existing trailer, the new trailer will appear after the commit message part of the output, and, if there is no line with only spaces at the end of the commit message part, one blank line will be added before the new trailer."
msgid "By default the new trailer will appear at the end of all the existing trailers. If there is no existing trailer, the new trailer will appear at the end of the input. A blank line will be added before the new trailer if there isn't one already."
msgstr "默认情况下，新尾注将出现在所有现有尾注的末尾。如果没有现有的尾注，新的尾注将出现在输出的提交信息部分之后，如果在提交信息部分的末尾没有只有空格的行，在新的尾注之前将增加一个空行。"

#. type: Plain text
#: en/git-interpret-trailers.txt:81
#, fuzzy, priority:100
#| msgid "Existing trailers are extracted from the input message by looking for a group of one or more lines that (i) is all trailers, or (ii) contains at least one Git-generated or user-configured trailer and consists of at least 25% trailers.  The group must be preceded by one or more empty (or whitespace-only) lines.  The group must either be at the end of the message or be the last non-whitespace lines before a line that starts with '---' (followed by a space or the end of the line). Such three minus signs start the patch part of the message. See also `--no-divider` below."
msgid "Existing trailers are extracted from the input by looking for a group of one or more lines that (i) is all trailers, or (ii) contains at least one Git-generated or user-configured trailer and consists of at least 25% trailers.  The group must be preceded by one or more empty (or whitespace-only) lines.  The group must either be at the end of the input or be the last non-whitespace lines before a line that starts with '---' (followed by a space or the end of the line)."
msgstr "从输入的信息中提取现有的预告片，方法是寻找一组或多行，(i) 全部是尾注，或(ii)至少包含一个 Git 生成的或用户配置的尾注，并且至少由 25% 的尾注组成。 该组的前面必须有一个或多个空行（或仅有白色空间）。 该组必须位于信息的末尾，或者是以 '---' 开头的一行（后面是空格或行尾）之前的最后几行非空格。这样的三个减号开始了消息的补丁部分。也可参见下面的 `---no-divider`。"

#. type: Plain text
#: en/git-interpret-trailers.txt:88
#, fuzzy, priority:100
#| msgid "When reading trailers, there can be no whitespace before or inside the token, but any number of regular space and tab characters are allowed between the token and the separator. There can be whitespaces before, inside or after the value. The value may be split over multiple lines with each subsequent line starting with at least one whitespace, like the \"folding\" in RFC 822."
msgid "When reading trailers, there can be no whitespace before or inside the <token>, but any number of regular space and tab characters are allowed between the <token> and the separator. There can be whitespaces before, inside or after the <value>. The <value> may be split over multiple lines with each subsequent line starting with at least one whitespace, like the \"folding\" in RFC 822. Example:"
msgstr "读取尾注时，在标记之前或内部不能有空白，但在标记和分隔符之间允许有任何数量的常规空格和制表符。在值的前面、里面或后面都可以有空白。该值可以被分割成多行，每一行都以至少一个空白开始，就像 RFC 822 中的 “折叠”。"

#. type: delimited block -
#: en/git-interpret-trailers.txt:92
#, no-wrap, priority:100
msgid ""
"token: This is a very long value, with spaces and\n"
"  newlines in it.\n"
msgstr ""

#. type: Plain text
#: en/git-interpret-trailers.txt:96
#, fuzzy, priority:100
#| msgid "Note that 'trailers' do not follow and are not intended to follow many rules for RFC 822 headers. For example they do not follow the encoding rules and probably many other rules."
msgid "Note that trailers do not follow (nor are they intended to follow) many of the rules for RFC 822 headers. For example they do not follow the encoding rule."
msgstr "请注意，‘尾注’ 不遵循也不打算遵循RFC 822报头的许多规则。例如，它们不遵循编码规则，可能还有许多其他规则。"

#. type: Labeled list
#: en/git-interpret-trailers.txt:99
#, ignore-same, no-wrap, priority:100
msgid "--in-place"
msgstr "--in-place"

#. type: Plain text
#: en/git-interpret-trailers.txt:101
#, priority:100
msgid "Edit the files in place."
msgstr "在原地编辑文件。"

#. type: Labeled list
#: en/git-interpret-trailers.txt:102
#, ignore-same, no-wrap, priority:100
msgid "--trim-empty"
msgstr "--trim-empty"

#. type: Plain text
#: en/git-interpret-trailers.txt:106
#, fuzzy, priority:100
#| msgid "If the <value> part of any trailer contains only whitespace, the whole trailer will be removed from the resulting message.  This applies to existing trailers as well as new trailers."
msgid "If the <value> part of any trailer contains only whitespace, the whole trailer will be removed from the output.  This applies to existing trailers as well as new trailers."
msgstr "如果任何尾注的 <值> 部分只包含空格，整个尾注将从产生的消息中被删除。  这适用于现有的尾注和新的尾注。"

#. type: Plain text
#: en/git-interpret-trailers.txt:111
#, fuzzy, priority:100
#| msgid "Specify a (<token>, <value>) pair that should be applied as a trailer to the input messages. See the description of this command."
msgid "Specify a (<token>, <value>) pair that should be applied as a trailer to the inputs. See the description of this command."
msgstr "指定一个（<token>, <value>）对，应该作为尾注应用到输入信息中。参见此命令的描述。"

#. type: Labeled list
#: en/git-interpret-trailers.txt:112
#, fuzzy, no-wrap, priority:100
msgid "--where <placement>"
msgstr "--where <placement>"

#. type: Labeled list
#: en/git-interpret-trailers.txt:113
#, ignore-same, no-wrap, priority:100
msgid "--no-where"
msgstr "--no-where"

#. type: Plain text
#: en/git-interpret-trailers.txt:119
#, priority:100
msgid "Specify where all new trailers will be added.  A setting provided with '--where' overrides all configuration variables and applies to all '--trailer' options until the next occurrence of '--where' or '--no-where'. Possible values are `after`, `before`, `end` or `start`."
msgstr "指定所有新尾注的添加位置。 '--where' 提供的设置将覆盖所有配置变量并应用于所有 '--trailer' 选项，直到下一次出现 '--where' 或 '--no-where'。可能的值为 `after`、`before`、`end` 或 `start`。"

#. type: Labeled list
#: en/git-interpret-trailers.txt:120
#, no-wrap, priority:100
msgid "--if-exists <action>"
msgstr "--if-exists <action>"

#. type: Labeled list
#: en/git-interpret-trailers.txt:121
#, ignore-same, no-wrap, priority:100
msgid "--no-if-exists"
msgstr "--no-if-exists"

#. type: Plain text
#: en/git-interpret-trailers.txt:128
#, fuzzy, priority:100
#| msgid "Specify what action will be performed when there is already at least one trailer with the same <token> in the message.  A setting provided with '--if-exists' overrides all configuration variables and applies to all '--trailer' options until the next occurrence of '--if-exists' or '--no-if-exists'. Possible actions are `addIfDifferent`, `addIfDifferentNeighbor`, `add`, `replace` and `doNothing`."
msgid "Specify what action will be performed when there is already at least one trailer with the same <token> in the input.  A setting provided with '--if-exists' overrides all configuration variables and applies to all '--trailer' options until the next occurrence of '--if-exists' or '--no-if-exists'. Possible actions are `addIfDifferent`, `addIfDifferentNeighbor`, `add`, `replace` and `doNothing`."
msgstr "指定当消息中已经有至少一个具有相同 <token> 的尾注时，将执行什么。  用 '--if-exists' 提供的设置覆盖了所有的配置变量，并适用于所有 '--trailer ' 选项，直到下一次出现 '--if-exists' 或 '--no-if-exists'。可能的操作有：`addIfDifferent`, `addIfDifferentNeighbor`， `add`， `replace` 和 `doNothing`。"

#. type: Labeled list
#: en/git-interpret-trailers.txt:129
#, no-wrap, priority:100
msgid "--if-missing <action>"
msgstr "--if-missing <action>"

#. type: Labeled list
#: en/git-interpret-trailers.txt:130
#, ignore-same, no-wrap, priority:100
msgid "--no-if-missing"
msgstr "--no-if-missing"

#. type: Plain text
#: en/git-interpret-trailers.txt:137
#, fuzzy, priority:100
#| msgid "Specify what action will be performed when there is no other trailer with the same <token> in the message.  A setting provided with '--if-missing' overrides all configuration variables and applies to all '--trailer' options until the next occurrence of '--if-missing' or '--no-if-missing'. Possible actions are `doNothing` or `add`."
msgid "Specify what action will be performed when there is no other trailer with the same <token> in the input.  A setting provided with '--if-missing' overrides all configuration variables and applies to all '--trailer' options until the next occurrence of '--if-missing' or '--no-if-missing'. Possible actions are `doNothing` or `add`."
msgstr "指定当消息中没有其他具有相同 <token> 的尾注时，将执行什么行为。 用 '--if-missing' 提供的设置覆盖所有的配置变量，并适用于所有的 '--trailer' 选项，直到下次出现 '--if-missing' 或  '--no-if-missing'。可能的操作是 `doNothing` 或 `add`。"

#. type: Labeled list
#: en/git-interpret-trailers.txt:138
#, ignore-same, no-wrap, priority:100
msgid "--only-trailers"
msgstr "--only-trailers"

#. type: Plain text
#: en/git-interpret-trailers.txt:140
#, priority:100
msgid "Output only the trailers, not any other parts of the input."
msgstr "只输出尾注，不输出输入的任何其他部分。"

#. type: Labeled list
#: en/git-interpret-trailers.txt:141
#, ignore-same, no-wrap, priority:100
msgid "--only-input"
msgstr "--only-input"

#. type: Plain text
#: en/git-interpret-trailers.txt:145
#, priority:100
msgid "Output only trailers that exist in the input; do not add any from the command-line or by following configured `trailer.*` rules."
msgstr "只输出输入中存在的尾注；不要从命令行或按照配置的 `trailer.*` 规则添加任何尾注。"

#. type: Labeled list
#: en/git-interpret-trailers.txt:146
#, ignore-same, no-wrap, priority:100
msgid "--unfold"
msgstr "--unfold"

#. type: Plain text
#: en/git-interpret-trailers.txt:149
#, priority:100
msgid "Remove any whitespace-continuation in trailers, so that each trailer appears on a line by itself with its full content."
msgstr "移除尾注中的任何空格，以便每个尾注都能以其完整的内容出现在一行中。"

#. type: Labeled list
#: en/git-interpret-trailers.txt:150
#, ignore-same, no-wrap, priority:100
msgid "--parse"
msgstr "--parse"

#. type: Plain text
#: en/git-interpret-trailers.txt:153
#, priority:100
msgid "A convenience alias for `--only-trailers --only-input --unfold`."
msgstr "`--only-trailers --only-input --unfold` 的别名。"

#. type: Labeled list
#: en/git-interpret-trailers.txt:154
#, ignore-same, no-wrap, priority:100
msgid "--no-divider"
msgstr "--no-divider"

#. type: Plain text
#: en/git-interpret-trailers.txt:158
#, priority:100
msgid "Do not treat `---` as the end of the commit message. Use this when you know your input contains just the commit message itself (and not an email or the output of `git format-patch`)."
msgstr "不要把 `---` 当作提交信息的结尾。当你知道你的输入只包含提交信息本身（而不是电子邮件或 `git format-patch` 的输出）时，请使用这个方法。"

#. type: Labeled list
#: en/git-interpret-trailers.txt:162
#, no-wrap, priority:100
msgid "trailer.separators"
msgstr "trailer.separators"

#. type: Plain text
#: en/git-interpret-trailers.txt:167
#, priority:100
msgid "This option tells which characters are recognized as trailer separators. By default only ':' is recognized as a trailer separator, except that '=' is always accepted on the command line for compatibility with other git commands."
msgstr "这个选项告诉我们哪些字符可以被识别为尾注分隔符。默认情况下，只有 ':' 被识别为尾注分隔符，但为了与其他 git 命令兼容，命令行上总是接受 '='。"

#. type: Plain text
#: en/git-interpret-trailers.txt:171
#, priority:100
msgid "The first character given by this option will be the default character used when another separator is not specified in the config for this trailer."
msgstr "当这个尾注的配置中没有指定其他分隔符时，这个选项给出的第一个字符将是默认使用的字符。"

#. type: Plain text
#: en/git-interpret-trailers.txt:178
#, priority:100
msgid "For example, if the value for this option is \"%=$\", then only lines using the format '<token><sep><value>' with <sep> containing '%', '=' or '$' and then spaces will be considered trailers. And '%' will be the default separator used, so by default trailers will appear like: '<token>% <value>' (one percent sign and one space will appear between the token and the value)."
msgstr "例如，如果这个选项的值是 \"%=$\"，那么只有使用 '<token><sep><value>' 格式的行，<sep> 包含 '%'、'=' 或 '$'，然后是空格，才会被视为尾注。而 '%' 将是默认使用的分隔符，所以默认情况下，尾注会出现如下情况： '<token>% <value>' （一个百分号和一个空格将出现在标记和值之间）。"

#. type: Labeled list
#: en/git-interpret-trailers.txt:179
#, no-wrap, priority:100
msgid "trailer.where"
msgstr "trailer.where"

#. type: Plain text
#: en/git-interpret-trailers.txt:181
#, priority:100
msgid "This option tells where a new trailer will be added."
msgstr "这个选项告诉人们新的尾注将被添加到哪里。"

#. type: Plain text
#: en/git-interpret-trailers.txt:183
#, priority:100
msgid "This can be `end`, which is the default, `start`, `after` or `before`."
msgstr "默认是 `end`，也可以是 `start`，`after` 或 `before`。"

#. type: Plain text
#: en/git-interpret-trailers.txt:186
#, priority:100
msgid "If it is `end`, then each new trailer will appear at the end of the existing trailers."
msgstr "如果它是 `end`，那么每个新的拖车将出现在现有拖车的末尾。"

#. type: Plain text
#: en/git-interpret-trailers.txt:189
#, priority:100
msgid "If it is `start`, then each new trailer will appear at the start, instead of the end, of the existing trailers."
msgstr "如果是 `start`，那么每个新尾注将出现在现有尾注的开端，而不是结尾。"

#. type: Plain text
#: en/git-interpret-trailers.txt:192
#, priority:100
msgid "If it is `after`, then each new trailer will appear just after the last trailer with the same <token>."
msgstr "如果是 `after`，那么每个新的尾注将出现在具有相同 <token> 的最后一个尾注之后。"

#. type: Plain text
#: en/git-interpret-trailers.txt:195
#, priority:100
msgid "If it is `before`, then each new trailer will appear just before the first trailer with the same <token>."
msgstr "如果是 `before`，那么每个新的尾注将出现在具有相同 <token> 的第一个尾注之前。"

#. type: Labeled list
#: en/git-interpret-trailers.txt:196
#, no-wrap, priority:100
msgid "trailer.ifexists"
msgstr "trailer.ifexists"

#. type: Plain text
#: en/git-interpret-trailers.txt:200
#, fuzzy, priority:100
#| msgid "This option makes it possible to choose what action will be performed when there is already at least one trailer with the same <token> in the message."
msgid "This option makes it possible to choose what action will be performed when there is already at least one trailer with the same <token> in the input."
msgstr "这个选项可以选择当信息中已经有至少一个具有相同 <token> 的尾注时，将执行什么行为。"

#. type: Plain text
#: en/git-interpret-trailers.txt:203
#, priority:100
msgid "The valid values for this option are: `addIfDifferentNeighbor` (this is the default), `addIfDifferent`, `add`, `replace` or `doNothing`."
msgstr "这个选项的有效值是： `addIfDifferentNeighbor`（这是默认值），`addIfDifferent`，`add`，`replace` 或 `doNothing`。"

#. type: Plain text
#: en/git-interpret-trailers.txt:207
#, priority:100
msgid "With `addIfDifferentNeighbor`, a new trailer will be added only if no trailer with the same (<token>, <value>) pair is above or below the line where the new trailer will be added."
msgstr "使用 `addIfDifferentNeighbor`，只有在没有相同（<token>, <value>）的尾注对在新尾注的上方或下方，才会添加新的尾注。"

#. type: Plain text
#: en/git-interpret-trailers.txt:210
#, fuzzy, priority:100
#| msgid "With `addIfDifferent`, a new trailer will be added only if no trailer with the same (<token>, <value>) pair is already in the message."
msgid "With `addIfDifferent`, a new trailer will be added only if no trailer with the same (<token>, <value>) pair is already in the input."
msgstr "使用 `addIfDifferent`，只有当信息中没有相同的（<token>, <value>）尾注时，才会添加新的尾注。"

#. type: Plain text
#: en/git-interpret-trailers.txt:213
#, fuzzy, priority:100
#| msgid "With `add`, a new trailer will be added, even if some trailers with the same (<token>, <value>) pair are already in the message."
msgid "With `add`, a new trailer will be added, even if some trailers with the same (<token>, <value>) pair are already in the input."
msgstr "使用 `add`，一个新的尾注将被添加，即使一些具有相同（<token>, <value>）对的尾注已经在信息中。"

#. type: Plain text
#: en/git-interpret-trailers.txt:218
#, priority:100
msgid "With `replace`, an existing trailer with the same <token> will be deleted and the new trailer will be added. The deleted trailer will be the closest one (with the same <token>) to the place where the new one will be added."
msgstr "使用 `replace`，一个具有相同 <token> 的现有尾注将被删除，新的尾注将被添加。被删除的尾注将是离新尾注位置最近的一个（具有相同的<token>）。"

#. type: Plain text
#: en/git-interpret-trailers.txt:221
#, fuzzy, priority:100
#| msgid "With `doNothing`, nothing will be done; that is no new trailer will be added if there is already one with the same <token> in the message."
msgid "With `doNothing`, nothing will be done; that is no new trailer will be added if there is already one with the same <token> in the input."
msgstr "使用 `doNothing`，将不做任何事情；也就是说，如果消息中已经有一个相同的<token>，将不会再添加新的尾注。"

#. type: Labeled list
#: en/git-interpret-trailers.txt:222
#, no-wrap, priority:100
msgid "trailer.ifmissing"
msgstr "trailer.ifmissing"

#. type: Plain text
#: en/git-interpret-trailers.txt:226
#, fuzzy, priority:100
#| msgid "This option makes it possible to choose what action will be performed when there is not yet any trailer with the same <token> in the message."
msgid "This option makes it possible to choose what action will be performed when there is not yet any trailer with the same <token> in the input."
msgstr "这个选项使我们有可能选择当信息中还没有任何具有相同 <token> 的尾注时，将执行什么行为。"

#. type: Plain text
#: en/git-interpret-trailers.txt:229
#, priority:100
msgid "The valid values for this option are: `add` (this is the default) and `doNothing`."
msgstr "这个选项的有效值是： `add`（这是默认值）和 `doNothing`。"

#. type: Plain text
#: en/git-interpret-trailers.txt:231
#, priority:100
msgid "With `add`, a new trailer will be added."
msgstr "使用 `add`，一个新的尾注将被添加。"

#. type: Plain text
#: en/git-interpret-trailers.txt:233
#, priority:100
msgid "With `doNothing`, nothing will be done."
msgstr "有了 `doNothing`，就不会有任何事情发生。"

#. type: Labeled list
#: en/git-interpret-trailers.txt:234
#, no-wrap, priority:100
msgid "trailer.<token>.key"
msgstr "trailer.<token>.key"

#. type: Plain text
#: en/git-interpret-trailers.txt:240
#, priority:100
msgid "This `key` will be used instead of <token> in the trailer. At the end of this key, a separator can appear and then some space characters. By default the only valid separator is ':', but this can be changed using the `trailer.separators` config variable."
msgstr "这个 `key` 将被用来代替尾注中的 <token>。在这个键的末端，可以出现一个分隔符，然后是一些空格字符。默认情况下，唯一有效的分隔符是 ':'，但这可以通过 `trailer.separators` 配置变量来改变。"

#. type: Plain text
#: en/git-interpret-trailers.txt:243
#, priority:100
msgid "If there is a separator, then the key will be used instead of both the <token> and the default separator when adding the trailer."
msgstr "如果有一个分隔符，那么在添加尾注时，将使用该键而不是 <token> 和默认的分隔符。"

#. type: Labeled list
#: en/git-interpret-trailers.txt:244
#, no-wrap, priority:100
msgid "trailer.<token>.where"
msgstr "trailer.<token>.where"

#. type: Plain text
#: en/git-interpret-trailers.txt:248
#, priority:100
msgid "This option takes the same values as the 'trailer.where' configuration variable and it overrides what is specified by that option for trailers with the specified <token>."
msgstr "这个选项与 'trailer.where' 配置变量的取值相同，对于指定 <token> 的尾注，它覆盖了该选项所指定的内容。"

#. type: Labeled list
#: en/git-interpret-trailers.txt:249
#, no-wrap, priority:100
msgid "trailer.<token>.ifexists"
msgstr "trailer.<token>.ifexists"

#. type: Plain text
#: en/git-interpret-trailers.txt:253
#, priority:100
msgid "This option takes the same values as the 'trailer.ifexists' configuration variable and it overrides what is specified by that option for trailers with the specified <token>."
msgstr "这个选项与 'trailer.ifexists' 配置变量的取值相同，对于具有指定 <token> 的尾注，它覆盖了该选项所指定的内容。"

#. type: Labeled list
#: en/git-interpret-trailers.txt:254
#, no-wrap, priority:100
msgid "trailer.<token>.ifmissing"
msgstr "trailer.<token>.ifmissing"

#. type: Plain text
#: en/git-interpret-trailers.txt:258
#, priority:100
msgid "This option takes the same values as the 'trailer.ifmissing' configuration variable and it overrides what is specified by that option for trailers with the specified <token>."
msgstr "这个选项与'trailer.ifmissing' 配置变量的取值相同，对于指定 <token> 的尾注，它覆盖该选项所指定的内容。"

#. type: Labeled list
#: en/git-interpret-trailers.txt:259
#, no-wrap, priority:100
msgid "trailer.<token>.command"
msgstr "trailer.<token>.command"

#. type: Plain text
#: en/git-interpret-trailers.txt:265
#, fuzzy, priority:100
#| msgid "This option behaves in the same way as 'trailer.<token>.cmd', except that it doesn't pass anything as argument to the specified command.  Instead the first occurrence of substring $ARG is replaced by the value that would be passed as argument."
msgid "Deprecated in favor of 'trailer.<token>.cmd'.  This option behaves in the same way as 'trailer.<token>.cmd', except that it doesn't pass anything as argument to the specified command.  Instead the first occurrence of substring $ARG is replaced by the <value> that would be passed as argument."
msgstr "这个选项的作用与 'trailer.<token>.cmd' 相同，只是它不把任何东西作为参数传递给指定命令。 相反，子串 $ARG 的第一次出现会被作为参数传递的值所取代。"

#. type: Plain text
#: en/git-interpret-trailers.txt:268
#, fuzzy, priority:100
#| msgid "The 'trailer.<token>.command' option has been deprecated in favor of 'trailer.<token>.cmd' due to the fact that $ARG in the user's command is only replaced once and that the original way of replacing $ARG is not safe."
msgid "Note that $ARG in the user's command is only replaced once and that the original way of replacing $ARG is not safe."
msgstr "'trailer.<token>.command' 选项已被弃用，改为 'trailer.<token>.cmd'，原因是用户命令中的 $ARG 只被替换一次，而且原来替换 $ARG 的方式并不安全。"

#. type: Plain text
#: en/git-interpret-trailers.txt:272
#, priority:100
msgid "When both 'trailer.<token>.cmd' and 'trailer.<token>.command' are given for the same <token>, 'trailer.<token>.cmd' is used and 'trailer.<token>.command' is ignored."
msgstr "当'trailer.<token>.cmd' 和 'trailer.<token>.command' 都是针对同一个 <token> 给出的时候，使用 'trailer.<token>.cmd'，'trailer.<token>.command' 被忽略。"

#. type: Labeled list
#: en/git-interpret-trailers.txt:273
#, no-wrap, priority:100
msgid "trailer.<token>.cmd"
msgstr "trailer.<token>.cmd"

#. type: Plain text
#: en/git-interpret-trailers.txt:278
#, fuzzy, priority:100
#| msgid "This option can be used to specify a shell command that will be called: once to automatically add a trailer with the specified <token>, and then each time a '--trailer <token>=<value>' argument to modify the <value> of the trailer that this option would produce."
msgid "This option can be used to specify a shell command that will be called once to automatically add a trailer with the specified <token>, and then called each time a '--trailer <token>=<value>' argument is specified to modify the <value> of the trailer that this option would produce."
msgstr "这个选项可以用来指定一个将被调用的shell 命令：一次自动添加一个指定的 <token> 的尾注，然后每次用 '--trailer <token>=<value>' 参数来修改这个选项将产生的尾注的 <value>。"

#. type: Plain text
#: en/git-interpret-trailers.txt:285
#, priority:100
msgid "When the specified command is first called to add a trailer with the specified <token>, the behavior is as if a special '--trailer <token>=<value>' argument was added at the beginning of the \"git interpret-trailers\" command, where <value> is taken to be the standard output of the command with any leading and trailing whitespace trimmed off."
msgstr "当第一次调用指定的命令来添加带有指定 <token> 的尾注时，其行为就像在 \"git interpret-trailers\" 命令的开头添加了一个特殊的 '-trailer <token>=<value>' 参 数，其中 <value> 被认为是该命令的标准输出，其前面和后面的空白被修剪掉。"

#. type: Plain text
#: en/git-interpret-trailers.txt:292
#, priority:100
msgid "If some '--trailer <token>=<value>' arguments are also passed on the command line, the command is called again once for each of these arguments with the same <token>. And the <value> part of these arguments, if any, will be passed to the command as its first argument. This way the command can produce a <value> computed from the <value> passed in the '--trailer <token>=<value>' argument."
msgstr "如果在命令行中还传递了一些 '--trailer <token>=<value>' 参数，那么对于这些参数中的每一个，都会以相同的 <token> 再次调用该命令。而这些参数的 <value>部分，如果有的话，将作为第一个参数传递给命令。这样，命令可以产生一个从 '--trailer <token>=<value>' 参数中传递的 <value> 计算出来的 <value>。"

#. type: Plain text
#: en/git-interpret-trailers.txt:298
#, fuzzy, priority:100
#| msgid "Configure a 'sign' trailer with a 'Signed-off-by' key, and then add two of these trailers to a message:"
msgid "Configure a 'sign' trailer with a 'Signed-off-by' key, and then add two of these trailers to a commit message file:"
msgstr "配置一个带有 'Signed-off-by' 密钥的 'sign' 尾注，然后在一封邮件中添加两个这样的尾注："

#. type: delimited block -
#: en/git-interpret-trailers.txt:303
#, fuzzy, no-wrap, priority:100
msgid ""
"$ git config trailer.sign.key \"Signed-off-by\"\n"
"$ cat msg.txt\n"
"subject\n"
msgstr ""
"$ git config trailer.sign.key \"Signed-off-by\"\n"
"$ cat msg.txt\n"
"subject\n"

#. type: delimited block -
#: en/git-interpret-trailers.txt:307
#, fuzzy, no-wrap, priority:100
#| msgid ""
#| "message\n"
#| "$ git interpret-trailers --trailer 'sign: Alice <alice@example.com>' --trailer 'sign: Bob <bob@example.com>' <msg.txt\n"
#| "subject\n"
msgid ""
"body text\n"
"$ git interpret-trailers --trailer 'sign: Alice <alice@example.com>' --trailer 'sign: Bob <bob@example.com>' <msg.txt\n"
"subject\n"
msgstr ""
"message\n"
"$ git interpret-trailers --trailer 'sign: Alice <alice@example.com>' --trailer 'sign: Bob <bob@example.com>' <msg.txt\n"
"subject\n"

#. type: delimited block -
#: en/git-interpret-trailers.txt:309 en/git-interpret-trailers.txt:321 en/git-interpret-trailers.txt:328 en/git-interpret-trailers.txt:359 en/git-interpret-trailers.txt:365 en/git-interpret-trailers.txt:371 en/git-interpret-trailers.txt:406 en/git-interpret-trailers.txt:430 en/git-interpret-trailers.txt:442 en/git-interpret-trailers.txt:455
#, no-wrap, priority:100
msgid "body text\n"
msgstr ""

#. type: Plain text
#: en/git-interpret-trailers.txt:315
#, fuzzy, priority:100
#| msgid "Use the `--in-place` option to edit a message file in place:"
msgid "Use the `--in-place` option to edit a commit message file in place:"
msgstr "使用 `--in-place` 选项来就地编辑一个信息文件："

#. type: delimited block -
#: en/git-interpret-trailers.txt:319 en/git-interpret-trailers.txt:440
#, no-wrap, priority:100
msgid ""
"$ cat msg.txt\n"
"subject\n"
msgstr ""
"$ cat msg.txt\n"
"subject\n"

#. type: delimited block -
#: en/git-interpret-trailers.txt:326
#, no-wrap, priority:100
msgid ""
"Signed-off-by: Bob <bob@example.com>\n"
"$ git interpret-trailers --trailer 'Acked-by: Alice <alice@example.com>' --in-place msg.txt\n"
"$ cat msg.txt\n"
"subject\n"
msgstr ""
"Signed-off-by: Bob <bob@example.com>\n"
"$ git interpret-trailers --trailer 'Acked-by: Alice <alice@example.com>' --in-place msg.txt\n"
"$ cat msg.txt\n"
"subject\n"

#. type: delimited block -
#: en/git-interpret-trailers.txt:331
#, no-wrap, priority:100
msgid ""
"Signed-off-by: Bob <bob@example.com>\n"
"Acked-by: Alice <alice@example.com>\n"
msgstr ""
"Signed-off-by: Bob <bob@example.com>\n"
"Acked-by: Alice <alice@example.com>\n"

#. type: Plain text
#: en/git-interpret-trailers.txt:335
#, priority:100
msgid "Extract the last commit as a patch, and add a 'Cc' and a 'Reviewed-by' trailer to it:"
msgstr "将最后一次提交的内容提取为补丁，并在其中加入 'Cc' 和 'Reviewed-by' 尾注："

#. type: delimited block -
#: en/git-interpret-trailers.txt:340
#, no-wrap, priority:100
msgid ""
"$ git format-patch -1\n"
"0001-foo.patch\n"
"$ git interpret-trailers --trailer 'Cc: Alice <alice@example.com>' --trailer 'Reviewed-by: Bob <bob@example.com>' 0001-foo.patch >0001-bar.patch\n"
msgstr ""
"$ git format-patch -1\n"
"0001-foo.patch\n"
"$ git interpret-trailers --trailer 'Cc: Alice <alice@example.com>' --trailer 'Reviewed-by: Bob <bob@example.com>' 0001-foo.patch >0001-bar.patch\n"

#. type: Plain text
#: en/git-interpret-trailers.txt:345
#, priority:100
msgid "Configure a 'sign' trailer with a command to automatically add a 'Signed-off-by: ' with the author information only if there is no 'Signed-off-by: ' already, and show how it works:"
msgstr "配置一个带有命令的 'sign' 拖车，只有在没有 'Signed-off-by: ' 的情况下，才会自动添加带有作者信息的 'Signed-off-by: ' ，以下展示它是如何工作的："

#. type: delimited block -
#: en/git-interpret-trailers.txt:349
#, no-wrap, priority:100
msgid ""
"$ cat msg1.txt\n"
"subject\n"
msgstr ""
"$ cat msg1.txt\n"
"subject\n"

#. type: delimited block -
#: en/git-interpret-trailers.txt:357
#, fuzzy, no-wrap, priority:100
msgid ""
"body text\n"
"$ git config trailer.sign.key \"Signed-off-by: \"\n"
"$ git config trailer.sign.ifmissing add\n"
"$ git config trailer.sign.ifexists doNothing\n"
"$ git config trailer.sign.cmd 'echo \"$(git config user.name) <$(git config user.email)>\"'\n"
"$ git interpret-trailers --trailer sign <msg1.txt\n"
"subject\n"
msgstr ""
"$ git config trailer.sign.key \"Signed-off-by: \"\n"
"$ git config trailer.sign.ifmissing add\n"
"$ git config trailer.sign.ifexists doNothing\n"
"$ git config trailer.sign.command 'echo \"$(git config user.name) <$(git config user.email)>\"'\n"
"$ git interpret-trailers <<EOF\n"
"> EOF\n"

#. type: delimited block -
#: en/git-interpret-trailers.txt:363
#, no-wrap, priority:100
msgid ""
"Signed-off-by: Bob <bob@example.com>\n"
"$ cat msg2.txt\n"
"subject\n"
msgstr ""
"Signed-off-by: Bob <bob@example.com>\n"
"$ cat msg2.txt\n"
"subject\n"

#. type: delimited block -
#: en/git-interpret-trailers.txt:369
#, no-wrap, priority:100
msgid ""
"Signed-off-by: Alice <alice@example.com>\n"
"$ git interpret-trailers --trailer sign <msg2.txt\n"
"subject\n"
msgstr ""
"Signed-off-by: Alice <alice@example.com>\n"
"$ git interpret-trailers --trailer sign <msg2.txt\n"
"subject\n"

#. type: delimited block -
#: en/git-interpret-trailers.txt:373
#, no-wrap, priority:100
msgid "Signed-off-by: Alice <alice@example.com>\n"
msgstr "Signed-off-by: Alice <alice@example.com>\n"

#. type: Plain text
#: en/git-interpret-trailers.txt:377
#, priority:100
msgid "Configure a 'fix' trailer with a key that contains a '#' and no space after this character, and show how it works:"
msgstr "配置一个 'fix' 尾注，其关键是包含一个 '#'，并且这个字符后面没有空格，以下展示它是如何工作的："

#. type: delimited block -
#: en/git-interpret-trailers.txt:383
#, fuzzy, no-wrap, priority:100
msgid ""
"$ git config trailer.separators \":#\"\n"
"$ git config trailer.fix.key \"Fix #\"\n"
"$ echo \"subject\" | git interpret-trailers --trailer fix=42\n"
"subject\n"
msgstr ""
"$ git config trailer.separators \":#\"\n"
"$ git config trailer.fix.key \"Fix #\"\n"
"$ echo \"subject\" | git interpret-trailers --trailer fix=42\n"
"subject\n"

#. type: delimited block -
#: en/git-interpret-trailers.txt:385
#, no-wrap, priority:100
msgid "Fix #42\n"
msgstr "Fix #42\n"

#. type: Plain text
#: en/git-interpret-trailers.txt:390
#, priority:100
msgid "Configure a 'help' trailer with a cmd use a script `glog-find-author` which search specified author identity from git log in git repository and show how it works:"
msgstr "在 cmd 中使用脚本 `glog-find-author` 配置一个 'help' 尾注，从 git 仓库的 git日志中搜索指定的作者身份，以下展示它是如何工作的："

#. type: delimited block -
#: en/git-interpret-trailers.txt:397
#, no-wrap, priority:100
msgid ""
"$ cat ~/bin/glog-find-author\n"
"#!/bin/sh\n"
"test -n \"$1\" && git log --author=\"$1\" --pretty=\"%an <%ae>\" -1 || true\n"
"$ cat msg.txt\n"
"subject\n"
msgstr ""
"$ cat ~/bin/glog-find-author\n"
"#!/bin/sh\n"
"test -n \"$1\" && git log --author=\"$1\" --pretty=\"%an <%ae>\" -1 || true\n"
"$ cat msg.txt\n"
"subject\n"

#. type: delimited block -
#: en/git-interpret-trailers.txt:404
#, fuzzy, no-wrap, priority:100
#| msgid ""
#| "message\n"
#| "$ git config trailer.help.key \"Helped-by: \"\n"
#| "$ git config trailer.help.ifExists \"addIfDifferentNeighbor\"\n"
#| "$ git config trailer.help.cmd \"~/bin/glog-find-author\"\n"
#| "$ git interpret-trailers --trailer=\"help:Junio\" --trailer=\"help:Couder\" <msg.txt\n"
#| "subject\n"
msgid ""
"body text\n"
"$ git config trailer.help.key \"Helped-by: \"\n"
"$ git config trailer.help.ifExists \"addIfDifferentNeighbor\"\n"
"$ git config trailer.help.cmd \"~/bin/glog-find-author\"\n"
"$ git interpret-trailers --trailer=\"help:Junio\" --trailer=\"help:Couder\" <msg.txt\n"
"subject\n"
msgstr ""
"message\n"
"$ git config trailer.help.key \"Helped-by: \"\n"
"$ git config trailer.help.ifExists \"addIfDifferentNeighbor\"\n"
"$ git config trailer.help.cmd \"~/bin/glog-find-author\"\n"
"$ git interpret-trailers --trailer=\"help:Junio\" --trailer=\"help:Couder\" <msg.txt\n"
"subject\n"

#. type: delimited block -
#: en/git-interpret-trailers.txt:409
#, no-wrap, priority:100
msgid ""
"Helped-by: Junio C Hamano <gitster@pobox.com>\n"
"Helped-by: Christian Couder <christian.couder@gmail.com>\n"
msgstr ""
"Helped-by: Junio C Hamano <gitster@pobox.com>\n"
"Helped-by: Christian Couder <christian.couder@gmail.com>\n"

#. type: Plain text
#: en/git-interpret-trailers.txt:414
#, priority:100
msgid "Configure a 'ref' trailer with a cmd use a script `glog-grep` to grep last relevant commit from git log in the git repository and show how it works:"
msgstr "在 cmd 中用脚本 `glog-grep` 从git仓库的git日志中搜索最后一次相关的提交并配置一个 'ref' 尾注，以下展示它是如何工作的："

#. type: delimited block -
#: en/git-interpret-trailers.txt:421
#, no-wrap, priority:100
msgid ""
"$ cat ~/bin/glog-grep\n"
"#!/bin/sh\n"
"test -n \"$1\" && git log --grep \"$1\" --pretty=reference -1 || true\n"
"$ cat msg.txt\n"
"subject\n"
msgstr ""
"$ cat ~/bin/glog-grep\n"
"#!/bin/sh\n"
"test -n \"$1\" && git log --grep \"$1\" --pretty=reference -1 || true\n"
"$ cat msg.txt\n"
"subject\n"

#. type: delimited block -
#: en/git-interpret-trailers.txt:428
#, fuzzy, no-wrap, priority:100
#| msgid ""
#| "message\n"
#| "$ git config trailer.ref.key \"Reference-to: \"\n"
#| "$ git config trailer.ref.ifExists \"replace\"\n"
#| "$ git config trailer.ref.cmd \"~/bin/glog-grep\"\n"
#| "$ git interpret-trailers --trailer=\"ref:Add copyright notices.\" <msg.txt\n"
#| "subject\n"
msgid ""
"body text\n"
"$ git config trailer.ref.key \"Reference-to: \"\n"
"$ git config trailer.ref.ifExists \"replace\"\n"
"$ git config trailer.ref.cmd \"~/bin/glog-grep\"\n"
"$ git interpret-trailers --trailer=\"ref:Add copyright notices.\" <msg.txt\n"
"subject\n"
msgstr ""
"message\n"
"$ git config trailer.ref.key \"Reference-to: \"\n"
"$ git config trailer.ref.ifExists \"replace\"\n"
"$ git config trailer.ref.cmd \"~/bin/glog-grep\"\n"
"$ git interpret-trailers --trailer=\"ref:Add copyright notices.\" <msg.txt\n"
"subject\n"

#. type: delimited block -
#: en/git-interpret-trailers.txt:432
#, no-wrap, priority:100
msgid "Reference-to: 8bc9a0c769 (Add copyright notices., 2005-04-07)\n"
msgstr "Reference-to: 8bc9a0c769 (Add copyright notices., 2005-04-07)\n"

#. type: Plain text
#: en/git-interpret-trailers.txt:436
#, priority:100
msgid "Configure a 'see' trailer with a command to show the subject of a commit that is related, and show how it works:"
msgstr "配置一个带有命令的 'see' 尾注，以显示相关提交的主题，以下展示它是如何工作的："

#. type: delimited block -
#: en/git-interpret-trailers.txt:453
#, fuzzy, no-wrap, priority:100
msgid ""
"see: HEAD~2\n"
"$ cat ~/bin/glog-ref\n"
"#!/bin/sh\n"
"git log -1 --oneline --format=\"%h (%s)\" --abbrev-commit --abbrev=14\n"
"$ git config trailer.see.key \"See-also: \"\n"
"$ git config trailer.see.ifExists \"replace\"\n"
"$ git config trailer.see.ifMissing \"doNothing\"\n"
"$ git config trailer.see.cmd \"glog-ref\"\n"
"$ git interpret-trailers --trailer=see <msg.txt\n"
"subject\n"
msgstr ""
"$ git config trailer.see.key \"See-also: \"\n"
"$ git config trailer.see.ifExists \"replace\"\n"
"$ git config trailer.see.ifMissing \"doNothing\"\n"
"$ git config trailer.see.command \"git log -1 --oneline --format=\\\"%h (%s)\\\" --abbrev-commit --abbrev=14 \\$ARG\"\n"
"$ git interpret-trailers <<EOF\n"
"> subject\n"
"> \n"
"> message\n"
"> \n"
"> see: HEAD~2\n"
"> EOF\n"
"subject\n"

#. type: delimited block -
#: en/git-interpret-trailers.txt:457
#, no-wrap, priority:100
msgid "See-also: fe3187489d69c4 (subject of related commit)\n"
msgstr "See-also: fe3187489d69c4 (subject of related commit)\n"

#. type: Plain text
#: en/git-interpret-trailers.txt:464
#, priority:100
msgid "Configure a commit template with some trailers with empty values (using sed to show and keep the trailing spaces at the end of the trailers), then configure a commit-msg hook that uses 'git interpret-trailers' to remove trailers with empty values and to add a 'git-version' trailer:"
msgstr "配置一个带有一些空尾注的提交模板（使用 sed 来显示并保留尾注末尾的空格），然后配置一个 commit-msg 钩子，使用 'git interpret-trailers' 来移除空值尾注，并添加一个 'git-version' 尾注："

#. type: delimited block -
#: en/git-interpret-trailers.txt:468
#, no-wrap, priority:100
msgid ""
"$ cat temp.txt\n"
"***subject***\n"
msgstr ""
"$ cat temp.txt\n"
"***subject***\n"

#. type: delimited block -
#: en/git-interpret-trailers.txt:470
#, fuzzy, no-wrap, priority:100
msgid "***message***\n"
msgstr "消息\n"

#. type: delimited block -
#: en/git-interpret-trailers.txt:482
#, no-wrap, priority:100
msgid ""
"Fixes: Z\n"
"Cc: Z\n"
"Reviewed-by: Z\n"
"Signed-off-by: Z\n"
"$ sed -e 's/ Z$/ /' temp.txt > commit_template.txt\n"
"$ git config commit.template commit_template.txt\n"
"$ cat .git/hooks/commit-msg\n"
"#!/bin/sh\n"
"git interpret-trailers --trim-empty --trailer \"git-version: \\$(git describe)\" \"\\$1\" > \"\\$1.new\"\n"
"mv \"\\$1.new\" \"\\$1\"\n"
"$ chmod +x .git/hooks/commit-msg\n"
msgstr ""
"Fixes: Z\n"
"Cc: Z\n"
"Reviewed-by: Z\n"
"Signed-off-by: Z\n"
"$ sed -e 's/ Z$/ /' temp.txt > commit_template.txt\n"
"$ git config commit.template commit_template.txt\n"
"$ cat .git/hooks/commit-msg\n"
"#!/bin/sh\n"
"git interpret-trailers --trim-empty --trailer \"git-version: \\$(git describe)\" \"\\$1\" > \"\\$1.new\"\n"
"mv \"\\$1.new\" \"\\$1\"\n"
"$ chmod +x .git/hooks/commit-msg\n"

#. type: Plain text
#: en/git-interpret-trailers.txt:487
#, ignore-same, priority:100
msgid "linkgit:git-commit[1], linkgit:git-format-patch[1], linkgit:git-config[1]"
msgstr "linkgit:git-commit[1], linkgit:git-format-patch[1], linkgit:git-config[1]"

#. type: Title =
#: en/git-log.txt:2
#, ignore-same, no-wrap, priority:260
msgid "git-log(1)"
msgstr "git-log(1)"

#. type: Plain text
#: en/git-log.txt:7
#, priority:260
msgid "git-log - Show commit logs"
msgstr "git-log - 显示提交日志"

#. type: Plain text
#: en/git-log.txt:13
#, fuzzy, ignore-ellipsis, no-wrap, priority:260
msgid "'git log' [<options>] [<revision-range>] [[--] <path>...]\n"
msgstr "'git log' [<options>] [<revision range>] [[--] <path>...]\n"

#. type: Plain text
#: en/git-log.txt:17
#, priority:260
msgid "Shows the commit logs."
msgstr "显示提交日志。"

#. type: Plain text
#: en/git-log.txt:25
#, priority:260
msgid "The command takes options applicable to the linkgit:git-rev-list[1] command to control what is shown and how, and options applicable to the linkgit:git-diff[1] command to control how the changes each commit introduces are shown."
msgstr "该命令采用适用于 linkgit:git-rev-list[1] 命令的选项来控制显示的内容和方式，以及适用于 linkgit:git-diff[1] 命令的选项来控制每次提交引入的更改的显示方式。"

#. type: Labeled list
#: en/git-log.txt:30
#, ignore-same, no-wrap, priority:260
msgid "--follow"
msgstr "--follow"

#. type: Plain text
#: en/git-log.txt:33
#, priority:260
msgid "Continue listing the history of a file beyond renames (works only for a single file)."
msgstr "继续列出一个文件的历史，超过重命名（只对单个文件有效）。"

#. type: Labeled list
#: en/git-log.txt:34
#, ignore-same, no-wrap, priority:260
msgid "--no-decorate"
msgstr "--no-decorate"

#. type: Labeled list
#: en/git-log.txt:35
#, no-wrap, priority:260
msgid "--decorate[=short|full|auto|no]"
msgstr "--装饰[=短|全|自动|无]"

#. type: Plain text
#: en/git-log.txt:45
#, fuzzy, priority:260
#| msgid "Print out the ref names of any commits that are shown. If 'short' is specified, the ref name prefixes 'refs/heads/', 'refs/tags/' and 'refs/remotes/' will not be printed. If 'full' is specified, the full ref name (including prefix) will be printed. If 'auto' is specified, then if the output is going to a terminal, the ref names are shown as if 'short' were given, otherwise no ref names are shown. The default option is 'short'."
msgid "Print out the ref names of any commits that are shown. If 'short' is specified, the ref name prefixes 'refs/heads/', 'refs/tags/' and 'refs/remotes/' will not be printed. If 'full' is specified, the full ref name (including prefix) will be printed. If 'auto' is specified, then if the output is going to a terminal, the ref names are shown as if 'short' were given, otherwise no ref names are shown. The option `--decorate` is short-hand for `--decorate=short`.  Default to configuration value of `log.decorate` if configured, otherwise, `auto`."
msgstr "打印出显示的任何提交的参考名称。如果指定了'short'，将不打印 ref name 的前缀'refs/heads/'、'refs/tags/'和'refs/remotes/'。如果指定'full'，完整的参考文献名称（包括前缀）将被打印。如果指定了'auto'，那么如果输出到终端，参考文献的名称将被显示，就像给了'short'一样，否则不显示参考文献的名称。默认选项是'short'。"

#. type: Labeled list
#: en/git-log.txt:46
#, fuzzy, no-wrap, priority:260
msgid "--decorate-refs=<pattern>"
msgstr "--decorate-refs=<pattern>"

#. type: Labeled list
#: en/git-log.txt:47
#, fuzzy, no-wrap, priority:260
msgid "--decorate-refs-exclude=<pattern>"
msgstr "--decorate-refs-exclude=<pattern>"

#. type: Plain text
#: en/git-log.txt:54
#, priority:260
msgid "For each candidate reference, do not use it for decoration if it matches any patterns given to `--decorate-refs-exclude` or if it doesn't match any of the patterns given to `--decorate-refs`. The `log.excludeDecoration` config option allows excluding refs from the decorations, but an explicit `--decorate-refs` pattern will override a match in `log.excludeDecoration`."
msgstr "对于每个候选者，如果它与`--decorate-refs-exclude`给出的任何模式相匹配，或者它与`--decorate-refs`给出的任何模式不匹配，就不要将其用于装饰。`log.excludeDecoration`配置选项允许从装饰中排除参考文献，但明确的`--decorate-refs`模式将覆盖`log.excludeDecoration`的匹配。"

#. type: Plain text
#: en/git-log.txt:58
#, priority:260
msgid "If none of these options or config settings are given, then references are used as decoration if they match `HEAD`, `refs/heads/`, `refs/remotes/`, `refs/stash/`, or `refs/tags/`."
msgstr "如果没有给出这些选项或配置设置，那么如果引用与`HEAD`、`refs/heads/`、`refs/remotes/`、`refs/stash/`或`refs/tags/`相匹配，则被用作装饰引用。"

#. type: Labeled list
#: en/git-log.txt:59
#, ignore-same, no-wrap, priority:260
msgid "--clear-decorations"
msgstr "--clear-decorations"

#. type: Plain text
#: en/git-log.txt:65
#, priority:260
msgid "When specified, this option clears all previous `--decorate-refs` or `--decorate-refs-exclude` options and relaxes the default decoration filter to include all references. This option is assumed if the config value `log.initialDecorationSet` is set to `all`."
msgstr "当指定时，这个选项会清除之前所有的`--decorate-refs`或`--decorate-refs-exclude`选项，并释放默认的装饰过滤器，包括所有的引用。该选项假设配置值`log.initialDecorationSet`被设置为`all`。"

#. type: Labeled list
#: en/git-log.txt:66
#, ignore-same, no-wrap, priority:260
msgid "--source"
msgstr "--source"

#. type: Plain text
#: en/git-log.txt:69
#, priority:260
msgid "Print out the ref name given on the command line by which each commit was reached."
msgstr "打印出命令行上给出的每一次提交所依据的参考名称。"

#. type: Plain text
#: en/git-log.txt:75
#, priority:260
msgid "Use mailmap file to map author and committer names and email addresses to canonical real names and email addresses. See linkgit:git-shortlog[1]."
msgstr "使用 mailmap 文件将作者和提交者的名字和电子邮件地址映射为规范的真实姓名和电子邮件地址。参见 linkgit:git-shortlog[1]。"

#. type: Labeled list
#: en/git-log.txt:76
#, ignore-same, no-wrap, priority:260
msgid "--full-diff"
msgstr "--full-diff"

#. type: Plain text
#: en/git-log.txt:82
#, ignore-ellipsis, priority:260
msgid "Without this flag, `git log -p <path>...` shows commits that touch the specified paths, and diffs about the same specified paths.  With this, the full diff is shown for commits that touch the specified paths; this means that \"<path>...\" limits only commits, and doesn't limit diff for those commits."
msgstr "没有这个标志，`git log -p <path>...`会显示触及指定路径的提交，以及关于相同指定路径的差异。  有了这个，就会显示触及指定路径的提交的全部差异；这意味着\"<path>... \"只限制提交，而不限制这些提交的差异。"

#. type: Plain text
#: en/git-log.txt:85
#, priority:260
msgid "Note that this affects all diff-based output types, e.g. those produced by `--stat`, etc."
msgstr "请注意，这将影响所有基于diff的输出类型，例如那些由`--stat`产生的输出。"

#. type: Labeled list
#: en/git-log.txt:86
#, ignore-same, no-wrap, priority:260
msgid "--log-size"
msgstr "--log-size"

#. type: Plain text
#: en/git-log.txt:91
#, priority:260
msgid "Include a line ``log size <number>'' in the output for each commit, where <number> is the length of that commit's message in bytes.  Intended to speed up tools that read log messages from `git log` output by allowing them to allocate space in advance."
msgstr "在每次提交的输出中包括一行\"`日志大小<number>'\"，其中<number>是该提交信息的长度，单位为字节。  旨在加快从`git log`输出中读取日志信息的工具的速度，允许它们提前分配空间。"

#. type: Labeled list
#: en/git-log.txt:94 en/git-shortlog.txt:100
#, fuzzy, no-wrap, priority:260
#| msgid "<revision range>"
msgid "<revision-range>"
msgstr "<修订版范围>。"

#. type: Plain text
#: en/git-log.txt:102
#, fuzzy, priority:260
#| msgid "Show only commits in the specified revision range.  When no <revision range> is specified, it defaults to `HEAD` (i.e. the whole history leading to the current commit).  `origin..HEAD` specifies all the commits reachable from the current commit (i.e. `HEAD`), but not from `origin`. For a complete list of ways to spell <revision range>, see the 'Specifying Ranges' section of linkgit:gitrevisions[7]."
msgid "Show only commits in the specified revision range.  When no <revision-range> is specified, it defaults to `HEAD` (i.e. the whole history leading to the current commit).  `origin..HEAD` specifies all the commits reachable from the current commit (i.e. `HEAD`), but not from `origin`. For a complete list of ways to spell <revision-range>, see the 'Specifying Ranges' section of linkgit:gitrevisions[7]."
msgstr "只显示指定修订范围内的提交。  当没有指定<修订范围>时，默认为`HEAD`（即导致当前提交的整个历史）。  `origin...HEAD`指定从当前提交（即`HEAD`）开始的所有提交，但不是从`origin`开始。关于<revision range>的完整拼写方式，请参见linkgit:gitrevisions[7]的 \"指定范围 \"部分。"

#. type: Labeled list
#: en/git-log.txt:103 en/git-shortlog.txt:109
#, ignore-ellipsis, no-wrap, priority:260
msgid "[--] <path>..."
msgstr "[--] <路径>..."

#. type: Plain text
#: en/git-log.txt:108
#, priority:260
msgid "Show only commits that are enough to explain how the files that match the specified paths came to be.  See 'History Simplification' below for details and other simplification modes."
msgstr "只显示那些足以解释符合指定路径的文件是如何形成的提交。  有关细节和其他简化模式，请参见下面的'历史简化'。"

#. type: Plain text
#: en/git-log.txt:111 en/git-shortlog.txt:115
#, priority:260
msgid "Paths may need to be prefixed with `--` to separate them from options or the revision range, when confusion arises."
msgstr "当出现混淆时，路径可能需要以`--`为前缀，以便将其与选项或修订范围分开。"

#. type: Title -
#: en/git-log.txt:117 en/git-show.txt:49
#, no-wrap, priority:260
msgid "DIFF FORMATTING"
msgstr "差异格式化"

#. type: Plain text
#: en/git-log.txt:121
#, priority:260
msgid "By default, `git log` does not generate any diff output. The options below can be used to show the changes made by each commit."
msgstr "默认情况下，`git log`不会产生任何差异输出。下面的选项可以用来显示每次提交所做的修改。"

#. type: Plain text
#: en/git-log.txt:128
#, priority:260
msgid "Note that unless one of `--diff-merges` variants (including short `-m`, `-c`, and `--cc` options) is explicitly given, merge commits will not show a diff, even if a diff format like `--patch` is selected, nor will they match search options like `-S`. The exception is when `--first-parent` is in use, in which case `first-parent` is the default format."
msgstr "注意，除非明确给出`--diff-merges`的变体（包括短的`-m`，`-c`和`-cc`选项），否则合并提交不会显示差异，即使选择了`--patch`这样的差异格式，也不会匹配`-S`这样的搜索选项。例外情况是当`--first-parent`被使用时，在这种情况下，`first-parent`是默认格式。"

#. type: Labeled list
#: en/git-log.txt:137
#, no-wrap, priority:260
msgid "`git log --no-merges`"
msgstr "`git log --no-merges`。"

#. type: Plain text
#: en/git-log.txt:140
#, priority:260
msgid "Show the whole commit history, but skip any merges"
msgstr "显示整个提交历史，但跳过任何合并内容"

#. type: Labeled list
#: en/git-log.txt:141
#, fuzzy, no-wrap, priority:260
msgid "`git log v2.6.12.. include/scsi drivers/scsi`"
msgstr "`git log v2.6.12.. include/scsi drivers/scsi`"

#. type: Plain text
#: en/git-log.txt:145
#, priority:260
msgid "Show all commits since version 'v2.6.12' that changed any file in the `include/scsi` or `drivers/scsi` subdirectories"
msgstr "显示自版本'v2.6.12'以来改变`include/scsi`或`drivers/scsi`子目录中任何文件的所有提交。"

#. type: Labeled list
#: en/git-log.txt:146
#, no-wrap, priority:260
msgid "`git log --since=\"2 weeks ago\" -- gitk`"
msgstr "`git log --since=\"2 weeks ago\" -- gitk`。"

#. type: Plain text
#: en/git-log.txt:151
#, priority:260
msgid "Show the changes during the last two weeks to the file 'gitk'.  The `--` is necessary to avoid confusion with the *branch* named 'gitk'"
msgstr "显示过去两周内对文件'gitk'的修改。  `--`是必要的，以避免与名为'gitk'的*分支相混淆。"

#. type: Labeled list
#: en/git-log.txt:152
#, fuzzy, no-wrap, priority:260
msgid "`git log --name-status release..test`"
msgstr "`git log --name-status release..test`"

#. type: Plain text
#: en/git-log.txt:157
#, priority:260
msgid "Show the commits that are in the \"test\" branch but not yet in the \"release\" branch, along with the list of paths each commit modifies."
msgstr "显示在 \"test \"分支中但尚未在 \"release \"分支中的提交，以及每个提交修改的路径列表。"

#. type: Labeled list
#: en/git-log.txt:158
#, no-wrap, priority:260
msgid "`git log --follow builtin/rev-list.c`"
msgstr "`git log --follow builtin/rev-list.c`。"

#. type: Plain text
#: en/git-log.txt:163
#, priority:260
msgid "Shows the commits that changed `builtin/rev-list.c`, including those commits that occurred before the file was given its present name."
msgstr "显示改变`builtin/rev-list.c`的提交，包括那些在文件被赋予现在名字之前发生的提交。"

#. type: Labeled list
#: en/git-log.txt:164
#, no-wrap, priority:260
msgid "`git log --branches --not --remotes=origin`"
msgstr "`git log --branches --not --remotes=origin`。"

#. type: Plain text
#: en/git-log.txt:169
#, priority:260
msgid "Shows all commits that are in any of local branches but not in any of remote-tracking branches for 'origin' (what you have that origin doesn't)."
msgstr "显示所有在本地分支中但不在 \"origin \"的远程跟踪分支中的提交（你有而origin没有的东西）。"

#. type: Labeled list
#: en/git-log.txt:170
#, no-wrap, priority:260
msgid "`git log master --not --remotes=*/master`"
msgstr "`git log master --not --remotes=*/master`。"

#. type: Plain text
#: en/git-log.txt:174
#, priority:260
msgid "Shows all commits that are in local master but not in any remote repository master branches."
msgstr "显示所有在本地主库但不在任何远程仓库主库分支中的提交。"

#. type: Labeled list
#: en/git-log.txt:175
#, no-wrap, priority:260
msgid "`git log -p -m --first-parent`"
msgstr "`git log -p -m -first-parent`。"

#. type: Plain text
#: en/git-log.txt:182
#, priority:260
msgid "Shows the history including change diffs, but only from the ``main branch'' perspective, skipping commits that come from merged branches, and showing full diffs of changes introduced by the merges.  This makes sense only when following a strict policy of merging all topic branches when staying on a single integration branch."
msgstr "显示包括变化差异的历史，但只从 \"主分支 \"的角度，跳过来自合并分支的提交，并显示合并带来的全部变化差异。  这只有在遵循严格的政策，在停留在一个集成分支时合并所有主题分支时才有意义。"

#. type: Labeled list
#: en/git-log.txt:183
#, no-wrap, priority:260
msgid "`git log -L '/int main/',/^}/:main.c`"
msgstr "`git log -L '/int main/',/^}/:main.c`。"

#. type: Plain text
#: en/git-log.txt:187
#, priority:260
msgid "Shows how the function `main()` in the file `main.c` evolved over time."
msgstr "显示了文件`main.c`中的函数`main()`是如何随时间演变的。"

#. type: Labeled list
#: en/git-log.txt:188
#, no-wrap, priority:260
msgid "`git log -3`"
msgstr "`git log -3`"

#. type: Plain text
#: en/git-log.txt:191
#, priority:260
msgid "Limits the number of commits to show to 3."
msgstr "将显示的提交数量限制在3个。"

#. type: Plain text
#: en/git-log.txt:202
#, priority:260
msgid "See linkgit:git-config[1] for core variables and linkgit:git-diff[1] for settings related to diff generation."
msgstr "核心变量见 linkgit:git-config[1] ，与 diff 生成相关的设置见 linkgit:git-diff[1] 。"

#. type: Labeled list
#: en/git-log.txt:203
#, ignore-same, no-wrap, priority:260
msgid "format.pretty"
msgstr "format.pretty"

#. type: Plain text
#: en/git-log.txt:206
#, priority:260
msgid "Default for the `--format` option.  (See 'Pretty Formats' above.)  Defaults to `medium`."
msgstr "`--format`选项的默认值。  (见上面的 \"漂亮的格式\"。)默认为 \"中等\"。"

#. type: Labeled list
#: en/git-log.txt:207
#, ignore-same, no-wrap, priority:260
msgid "i18n.logOutputEncoding"
msgstr "i18n.logOutputEncoding"

#. type: Plain text
#: en/git-log.txt:211
#, priority:260
msgid "Encoding to use when displaying logs.  (See 'Discussion' above.)  Defaults to the value of `i18n.commitEncoding` if set, and UTF-8 otherwise."
msgstr "显示日志时要使用的编码。  (见上面的 \"讨论\"。)如果设置了，默认为`i18n.commitEncoding`的值，否则为UTF-8。"

#. type: Title =
#: en/git-ls-files.txt:2
#, ignore-same, no-wrap, priority:80
msgid "git-ls-files(1)"
msgstr "git-ls-files(1)"

#. type: Plain text
#: en/git-ls-files.txt:7
#, fuzzy, priority:80
msgid "git-ls-files - Show information about files in the index and the working tree"
msgstr "git-ls-files - Show information about files in the index and the working tree"

#. type: Plain text
#: en/git-ls-files.txt:25
#, ignore-ellipsis, no-wrap, priority:80
msgid ""
"'git ls-files' [-z] [-t] [-v] [-f]\n"
"\t\t[-c|--cached] [-d|--deleted] [-o|--others] [-i|--ignored]\n"
"\t\t[-s|--stage] [-u|--unmerged] [-k|--killed] [-m|--modified]\n"
"\t\t[--resolve-undo]\n"
"\t\t[--directory [--no-empty-directory]] [--eol]\n"
"\t\t[--deduplicate]\n"
"\t\t[-x <pattern>|--exclude=<pattern>]\n"
"\t\t[-X <file>|--exclude-from=<file>]\n"
"\t\t[--exclude-per-directory=<file>]\n"
"\t\t[--exclude-standard]\n"
"\t\t[--error-unmatch] [--with-tree=<tree-ish>]\n"
"\t\t[--full-name] [--recurse-submodules]\n"
"\t\t[--abbrev[=<n>]] [--format=<format>] [--] [<file>...]\n"
msgstr ""

#. type: Plain text
#: en/git-ls-files.txt:30
#, priority:80
msgid "This merges the file listing in the index with the actual working directory list, and shows different combinations of the two."
msgstr ""

#. type: Plain text
#: en/git-ls-files.txt:35
#, priority:80
msgid "One or more of the options below may be used to determine the files shown, and each file may be printed multiple times if there are multiple entries in the index or multiple statuses are applicable for the relevant file selection options."
msgstr ""

#. type: Plain text
#: en/git-ls-files.txt:43
#, priority:80
msgid "Show all files cached in Git's index, i.e. all tracked files.  (This is the default if no -c/-s/-d/-o/-u/-k/-m/--resolve-undo options are specified.)"
msgstr ""

#. type: Labeled list
#: en/git-ls-files.txt:45
#, ignore-same, no-wrap, priority:80
msgid "--deleted"
msgstr "--deleted"

#. type: Plain text
#: en/git-ls-files.txt:47
#, priority:80
msgid "Show files with an unstaged deletion"
msgstr ""

#. type: Labeled list
#: en/git-ls-files.txt:49
#, ignore-same, no-wrap, priority:80
msgid "--modified"
msgstr "--modified"

#. type: Plain text
#: en/git-ls-files.txt:52
#, priority:80
msgid "Show files with an unstaged modification (note that an unstaged deletion also counts as an unstaged modification)"
msgstr ""

#. type: Labeled list
#: en/git-ls-files.txt:54
#, ignore-same, no-wrap, priority:80
msgid "--others"
msgstr "--others"

#. type: Plain text
#: en/git-ls-files.txt:56
#, priority:80
msgid "Show other (i.e. untracked) files in the output"
msgstr ""

#. type: Labeled list
#: en/git-ls-files.txt:58
#, ignore-same, no-wrap, priority:80
msgid "--ignored"
msgstr "--ignored"

#. type: Plain text
#: en/git-ls-files.txt:67
#, priority:80
msgid "Show only ignored files in the output.  Must be used with either an explicit '-c' or '-o'.  When showing files in the index (i.e. when used with '-c'), print only those files matching an exclude pattern.  When showing \"other\" files (i.e. when used with '-o'), show only those matched by an exclude pattern.  Standard ignore rules are not automatically activated, therefore at least one of the `--exclude*` options is required."
msgstr ""

#. type: Labeled list
#: en/git-ls-files.txt:69
#, ignore-same, no-wrap, priority:80
msgid "--stage"
msgstr "--stage"

#. type: Plain text
#: en/git-ls-files.txt:71
#, priority:80
msgid "Show staged contents' mode bits, object name and stage number in the output."
msgstr ""

#. type: Labeled list
#: en/git-ls-files.txt:72
#, ignore-same, no-wrap, priority:80
msgid "--directory"
msgstr "--directory"

#. type: Plain text
#: en/git-ls-files.txt:76
#, priority:80
msgid "If a whole directory is classified as \"other\", show just its name (with a trailing slash) and not its whole contents.  Has no effect without -o/--others."
msgstr ""

#. type: Labeled list
#: en/git-ls-files.txt:77
#, ignore-same, no-wrap, priority:80
msgid "--no-empty-directory"
msgstr "--no-empty-directory"

#. type: Plain text
#: en/git-ls-files.txt:79
#, priority:80
msgid "Do not list empty directories. Has no effect without --directory."
msgstr ""

#. type: Labeled list
#: en/git-ls-files.txt:81 en/git-update-index.txt:67
#, ignore-same, no-wrap, priority:80
msgid "--unmerged"
msgstr "--unmerged"

#. type: Plain text
#: en/git-ls-files.txt:85
#, priority:80
msgid "Show information about unmerged files in the output, but do not show any other tracked files (forces --stage, overrides --cached)."
msgstr ""

#. type: Labeled list
#: en/git-ls-files.txt:87
#, ignore-same, no-wrap, priority:80
msgid "--killed"
msgstr "--killed"

#. type: Plain text
#: en/git-ls-files.txt:91
#, priority:80
msgid "Show untracked files on the filesystem that need to be removed due to file/directory conflicts for tracked files to be able to be written to the filesystem."
msgstr ""

#. type: Labeled list
#: en/git-ls-files.txt:92
#, ignore-same, no-wrap, priority:80
msgid "--resolve-undo"
msgstr "--resolve-undo"

#. type: Plain text
#: en/git-ls-files.txt:98
#, priority:80
msgid "Show files having resolve-undo information in the index together with their resolve-undo information.  (resolve-undo information is what is used to implement \"git checkout -m $PATH\", i.e. to recreate merge conflicts that were accidentally resolved)"
msgstr ""

#. type: Plain text
#: en/git-ls-files.txt:102
#, priority:80
msgid "\\0 line termination on output and do not quote filenames.  See OUTPUT below for more information."
msgstr ""

#. type: Labeled list
#: en/git-ls-files.txt:103
#, ignore-same, no-wrap, priority:80
msgid "--deduplicate"
msgstr "--deduplicate"

#. type: Plain text
#: en/git-ls-files.txt:109
#, priority:80
msgid "When only filenames are shown, suppress duplicates that may come from having multiple stages during a merge, or giving `--deleted` and `--modified` option at the same time.  When any of the `-t`, `--unmerged`, or `--stage` option is in use, this option has no effect."
msgstr ""

#. type: Labeled list
#: en/git-ls-files.txt:110
#, fuzzy, no-wrap, priority:80
msgid "-x <pattern>"
msgstr "-x <pattern>"

#. type: Plain text
#: en/git-ls-files.txt:115
#, priority:80
msgid "Skip untracked files matching pattern.  Note that pattern is a shell wildcard pattern. See EXCLUDE PATTERNS below for more information."
msgstr ""

#. type: Labeled list
#: en/git-ls-files.txt:116
#, fuzzy, no-wrap, priority:80
msgid "-X <file>"
msgstr "-X <file>"

#. type: Labeled list
#: en/git-ls-files.txt:117
#, fuzzy, no-wrap, priority:80
msgid "--exclude-from=<file>"
msgstr "--exclude-from=<file>"

#. type: Plain text
#: en/git-ls-files.txt:119
#, priority:80
msgid "Read exclude patterns from <file>; 1 per line."
msgstr ""

#. type: Labeled list
#: en/git-ls-files.txt:120
#, fuzzy, no-wrap, priority:80
msgid "--exclude-per-directory=<file>"
msgstr "--exclude-per-directory=<file>"

#. type: Plain text
#: en/git-ls-files.txt:124
#, priority:80
msgid "Read additional exclude patterns that apply only to the directory and its subdirectories in <file>.  Deprecated; use --exclude-standard instead."
msgstr ""

#. type: Plain text
#: en/git-ls-files.txt:128
#, priority:80
msgid "Add the standard Git exclusions: .git/info/exclude, .gitignore in each directory, and the user's global exclusion file."
msgstr ""

#. type: Labeled list
#: en/git-ls-files.txt:129
#, ignore-same, no-wrap, priority:80
msgid "--error-unmatch"
msgstr "--error-unmatch"

#. type: Plain text
#: en/git-ls-files.txt:132
#, priority:80
msgid "If any <file> does not appear in the index, treat this as an error (return 1)."
msgstr ""

#. type: Labeled list
#: en/git-ls-files.txt:133
#, no-wrap, priority:80
msgid "--with-tree=<tree-ish>"
msgstr ""

#. type: Plain text
#: en/git-ls-files.txt:139
#, priority:80
msgid "When using --error-unmatch to expand the user supplied <file> (i.e. path pattern) arguments to paths, pretend that paths which were removed in the index since the named <tree-ish> are still present.  Using this option with `-s` or `-u` options does not make any sense."
msgstr ""

#. type: Plain text
#: en/git-ls-files.txt:147
#, priority:80
msgid "Show status tags together with filenames.  Note that for scripting purposes, linkgit:git-status[1] `--porcelain` and linkgit:git-diff-files[1] `--name-status` are almost always superior alternatives, and users should look at linkgit:git-status[1] `--short` or linkgit:git-diff[1] `--name-status` for more user-friendly alternatives."
msgstr ""

#. type: Plain text
#: en/git-ls-files.txt:152
#, priority:80
msgid "This option provides a reason for showing each filename, in the form of a status tag (which is followed by a space and then the filename).  The status tags are all single characters from the following list:"
msgstr ""

#. type: Labeled list
#: en/git-ls-files.txt:153
#, fuzzy, no-wrap, priority:80
msgid "H"
msgstr "H"

#. type: Plain text
#: en/git-ls-files.txt:154
#, priority:80
msgid "tracked file that is not either unmerged or skip-worktree"
msgstr ""

#. type: Labeled list
#: en/git-ls-files.txt:154
#, fuzzy, no-wrap, priority:80
msgid "S"
msgstr "S"

#. type: Plain text
#: en/git-ls-files.txt:155
#, priority:80
msgid "tracked file that is skip-worktree"
msgstr ""

#. type: Labeled list
#: en/git-ls-files.txt:155
#, fuzzy, no-wrap, priority:80
msgid "M"
msgstr "M"

#. type: Plain text
#: en/git-ls-files.txt:156
#, priority:80
msgid "tracked file that is unmerged"
msgstr ""

#. type: Labeled list
#: en/git-ls-files.txt:156
#, fuzzy, no-wrap, priority:80
msgid "R"
msgstr "R"

#. type: Plain text
#: en/git-ls-files.txt:157
#, priority:80
msgid "tracked file with unstaged removal/deletion"
msgstr ""

#. type: Labeled list
#: en/git-ls-files.txt:157
#, fuzzy, no-wrap, priority:80
msgid "C"
msgstr "C"

#. type: Plain text
#: en/git-ls-files.txt:158
#, priority:80
msgid "tracked file with unstaged modification/change"
msgstr ""

#. type: Labeled list
#: en/git-ls-files.txt:158
#, fuzzy, no-wrap, priority:80
msgid "K"
msgstr "K"

#. type: Plain text
#: en/git-ls-files.txt:160
#, priority:80
msgid "untracked paths which are part of file/directory conflicts which prevent checking out tracked files"
msgstr ""

#. type: Labeled list
#: en/git-ls-files.txt:160
#, fuzzy, no-wrap, priority:80
msgid "?"
msgstr "?"

#. type: Plain text
#: en/git-ls-files.txt:161
#, fuzzy, priority:80
msgid "untracked file"
msgstr "显示未追踪文件。"

#. type: Labeled list
#: en/git-ls-files.txt:161
#, no-wrap, priority:80
msgid "U"
msgstr ""

#. type: Plain text
#: en/git-ls-files.txt:162
#, fuzzy, priority:80
#| msgid "Manage reflog information."
msgid "file with resolve-undo information"
msgstr "管理reflog信息。"

#. type: Plain text
#: en/git-ls-files.txt:168
#, priority:80
msgid "Similar to `-t`, but use lowercase letters for files that are marked as 'assume unchanged' (see linkgit:git-update-index[1])."
msgstr ""

#. type: Plain text
#: en/git-ls-files.txt:173
#, priority:80
msgid "Similar to `-t`, but use lowercase letters for files that are marked as 'fsmonitor valid' (see linkgit:git-update-index[1])."
msgstr ""

#. type: Plain text
#: en/git-ls-files.txt:183
#, priority:80
msgid "Recursively calls ls-files on each active submodule in the repository.  Currently there is only support for the --cached and --stage modes."
msgstr ""

#. type: Plain text
#: en/git-ls-files.txt:189 en/git-ls-tree.txt:77
#, fuzzy, priority:80
#| msgid "Instead of showing the full 40-byte hexadecimal object name in diff-raw format output and diff-tree header lines, show only a partial prefix.  This is independent of the `--full-index` option above, which controls the diff-patch output format.  Non default number of digits can be specified with `--abbrev=<n>`."
msgid "Instead of showing the full 40-byte hexadecimal object lines, show the shortest prefix that is at least '<n>' hexdigits long that uniquely refers the object.  Non default number of digits can be specified with --abbrev=<n>."
msgstr "在 diff-raw（原始差异）格式输出和 diff-tree（树状差异）头行中，不显示完整的 40 字节十六进制对象名称，而只显示部分前缀。这与上面的 `--full-index` 选项无关，后者控制了 diff-patch（差异补丁）的输出格式。非默认的位数可以用 `--abbrev=<n>` 指定。"

#. type: Plain text
#: en/git-ls-files.txt:195
#, priority:80
msgid "After each line that describes a file, add more data about its cache entry.  This is intended to show as much information as possible for manual inspection; the exact format may change at any time."
msgstr ""

#. type: Labeled list
#: en/git-ls-files.txt:196
#, ignore-same, no-wrap, priority:80
msgid "--eol"
msgstr "--eol"

#. type: Plain text
#: en/git-ls-files.txt:201
#, priority:80
msgid "Show <eolinfo> and <eolattr> of files.  <eolinfo> is the file content identification used by Git when the \"text\" attribute is \"auto\" (or not set and core.autocrlf is not false).  <eolinfo> is either \"-text\", \"none\", \"lf\", \"crlf\", \"mixed\" or \"\"."
msgstr ""

#. type: Plain text
#: en/git-ls-files.txt:204
#, priority:80
msgid "\"\" means the file is not a regular file, it is not in the index or not accessible in the working tree."
msgstr ""

#. type: Plain text
#: en/git-ls-files.txt:208
#, priority:80
msgid "<eolattr> is the attribute that is used when checking out or committing, it is either \"\", \"-text\", \"text\", \"text=auto\", \"text eol=lf\", \"text eol=crlf\".  Since Git 2.10 \"text=auto eol=lf\" and \"text=auto eol=crlf\" are supported."
msgstr ""

#. type: Plain text
#: en/git-ls-files.txt:212
#, priority:80
msgid "Both the <eolinfo> in the index (\"i/<eolinfo>\")  and in the working tree (\"w/<eolinfo>\") are shown for regular files, followed by the (\"attr/<eolattr>\")."
msgstr ""

#. type: Plain text
#: en/git-ls-files.txt:217
#, priority:80
msgid "If the index is sparse, show the sparse directories without expanding to the contained files. Sparse directories will be shown with a trailing slash, such as \"x/\" for a sparse directory \"x\"."
msgstr ""

#. type: Plain text
#: en/git-ls-files.txt:225
#, priority:80
msgid "A string that interpolates `%(fieldname)` from the result being shown.  It also interpolates `%%` to `%`, and `%xx` where `xx` are hex digits interpolates to character with hex code `xx`; for example `%00` interpolates to `\\0` (NUL), `%09` to `\\t` (TAB) and %0a to `\\n` (LF).  --format cannot be combined with `-s`, `-o`, `-k`, `-t`, `--resolve-undo` and `--eol`."
msgstr ""

#. type: Labeled list
#: en/git-ls-files.txt:228 en/git.txt:418 en/git-update-index.txt:229
#, fuzzy, no-wrap, priority:100
msgid "<file>"
msgstr "<file>"

#. type: Plain text
#: en/git-ls-files.txt:231
#, priority:80
msgid "Files to show. If no files are given all files which match the other specified criteria are shown."
msgstr ""

#. type: Plain text
#: en/git-ls-files.txt:236
#, fuzzy, priority:80
msgid "'git ls-files' just outputs the filenames unless `--stage` is specified in which case it outputs:"
msgstr "'git ls-files' just outputs the filenames unless `--stage` is specified in which case it outputs:"

#. type: Plain text
#: en/git-ls-files.txt:238
#, fuzzy, no-wrap, priority:80
msgid "        [<tag> ]<mode> <object> <stage> <file>\n"
msgstr "        [<tag> ]<mode> <object> <stage> <file>\n"

#. type: Plain text
#: en/git-ls-files.txt:241
#, fuzzy, no-wrap, priority:80
msgid ""
"'git ls-files --eol' will show\n"
"\ti/<eolinfo><SPACES>w/<eolinfo><SPACES>attr/<eolattr><SPACE*><TAB><file>\n"
msgstr ""
"'git ls-files --eol' will show\n"
"\ti/<eolinfo><SPACES>w/<eolinfo><SPACES>attr/<eolattr><SPACE*><TAB><file>\n"

#. type: Plain text
#: en/git-ls-files.txt:244
#, fuzzy, priority:80
msgid "'git ls-files --unmerged' and 'git ls-files --stage' can be used to examine detailed information on unmerged paths."
msgstr "'git ls-files --unmerged' and 'git ls-files --stage' can be used to examine detailed information on unmerged paths."

#. type: Plain text
#: en/git-ls-files.txt:250
#, priority:80
msgid "For an unmerged path, instead of recording a single mode/SHA-1 pair, the index records up to three such pairs; one from tree O in stage 1, A in stage 2, and B in stage 3.  This information can be used by the user (or the porcelain) to see what should eventually be recorded at the path. (see linkgit:git-read-tree[1] for more information on state)"
msgstr ""

#. type: Plain text
#: en/git-ls-files.txt:261
#, priority:80
msgid "It is possible to print in a custom format by using the `--format` option, which is able to interpolate different fields using a `%(fieldname)` notation. For example, if you only care about the \"objectname\" and \"path\" fields, you can execute with a specific \"--format\" like"
msgstr ""

#. type: Plain text
#: en/git-ls-files.txt:263
#, no-wrap, priority:80
msgid "\tgit ls-files --format='%(objectname) %(path)'\n"
msgstr ""

#. type: Plain text
#: en/git-ls-files.txt:270
#, priority:80
msgid "The way each path is shown can be customized by using the `--format=<format>` option, where the %(fieldname) in the <format> string for various aspects of the index entry are interpolated.  The following \"fieldname\" are understood:"
msgstr ""

#. type: Labeled list
#: en/git-ls-files.txt:271 en/git-ls-tree.txt:151
#, fuzzy, no-wrap, priority:80
msgid "objectmode"
msgstr "objectname"

#. type: Plain text
#: en/git-ls-files.txt:273
#, priority:80
msgid "The mode of the file which is recorded in the index."
msgstr ""

#. type: Plain text
#: en/git-ls-files.txt:275
#, priority:80
msgid "The object type of the file which is recorded in the index."
msgstr ""

#. type: Plain text
#: en/git-ls-files.txt:277
#, priority:80
msgid "The name of the file which is recorded in the index."
msgstr ""

#. type: Labeled list
#: en/git-ls-files.txt:277 en/git-ls-tree.txt:157
#, fuzzy, no-wrap, priority:80
msgid "objectsize[:padded]"
msgstr "objectsize"

#. type: Plain text
#: en/git-ls-files.txt:281
#, priority:80
msgid "The object size of the file which is recorded in the index (\"-\" if the object is a `commit` or `tree`).  It also supports a padded format of size with \"%(objectsize:padded)\"."
msgstr ""

#. type: Labeled list
#: en/git-ls-files.txt:281
#, fuzzy, no-wrap, priority:80
#| msgid "--stage"
msgid "stage"
msgstr "--stage"

#. type: Plain text
#: en/git-ls-files.txt:283
#, priority:80
msgid "The stage of the file which is recorded in the index."
msgstr ""

#. type: Labeled list
#: en/git-ls-files.txt:283
#, fuzzy, no-wrap, priority:80
#| msgid "--no-index"
msgid "eolinfo:index"
msgstr "--no-index"

#. type: Labeled list
#: en/git-ls-files.txt:284
#, fuzzy, no-wrap, priority:80
msgid "eolinfo:worktree"
msgstr "skip-worktree"

#. type: Plain text
#: en/git-ls-files.txt:287
#, priority:80
msgid "The <eolinfo> (see the description of the `--eol` option) of the contents in the index or in the worktree for the path."
msgstr ""

#. type: Labeled list
#: en/git-ls-files.txt:287
#, fuzzy, no-wrap, priority:80
#| msgid "attr"
msgid "eolattr"
msgstr "attr"

#. type: Plain text
#: en/git-ls-files.txt:290
#, priority:80
msgid "The <eolattr> (see the description of the `--eol` option)  that applies to the path."
msgstr ""

#. type: Labeled list
#: en/git-ls-files.txt:290 en/git-ls-tree.txt:160
#, fuzzy, no-wrap, priority:80
msgid "path"
msgstr "<path>"

#. type: Plain text
#: en/git-ls-files.txt:292
#, priority:80
msgid "The pathname of the file which is recorded in the index."
msgstr ""

#. type: Title -
#: en/git-ls-files.txt:294
#, no-wrap, priority:80
msgid "EXCLUDE PATTERNS"
msgstr ""

#. type: Plain text
#: en/git-ls-files.txt:300
#, priority:80
msgid "'git ls-files' can use a list of \"exclude patterns\" when traversing the directory tree and finding files to show when the flags --others or --ignored are specified.  linkgit:gitignore[5] specifies the format of exclude patterns."
msgstr ""

#. type: Plain text
#: en/git-ls-files.txt:304
#, priority:80
msgid "Generally, you should just use --exclude-standard, but for historical reasons the exclude patterns can be specified from the following places, in order:"
msgstr ""

#. type: Plain text
#: en/git-ls-files.txt:308
#, priority:80
msgid "The command-line flag --exclude=<pattern> specifies a single pattern.  Patterns are ordered in the same order they appear in the command line."
msgstr ""

#. type: Plain text
#: en/git-ls-files.txt:312
#, priority:80
msgid "The command-line flag --exclude-from=<file> specifies a file containing a list of patterns.  Patterns are ordered in the same order they appear in the file."
msgstr ""

#. type: Plain text
#: en/git-ls-files.txt:318
#, priority:80
msgid "The command-line flag --exclude-per-directory=<name> specifies a name of the file in each directory 'git ls-files' examines, normally `.gitignore`.  Files in deeper directories take precedence.  Patterns are ordered in the same order they appear in the files."
msgstr ""

#. type: Plain text
#: en/git-ls-files.txt:324
#, priority:80
msgid "A pattern specified on the command line with --exclude or read from the file specified with --exclude-from is relative to the top of the directory tree.  A pattern read from a file specified by --exclude-per-directory is relative to the directory that the pattern file appears in."
msgstr ""

#. type: Plain text
#: en/git-ls-files.txt:328
#, ignore-same, priority:80
msgid "linkgit:git-read-tree[1], linkgit:gitignore[5]"
msgstr "linkgit:git-read-tree[1], linkgit:gitignore[5]"

#. type: Title =
#: en/git-ls-remote.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-ls-remote(1)"
msgstr "git-ls-remote(1)"

#. type: Plain text
#: en/git-ls-remote.txt:7
#, fuzzy, priority:100
msgid "git-ls-remote - List references in a remote repository"
msgstr "git-ls-remote - List references in a remote repository"

#. type: Plain text
#: en/git-ls-remote.txt:15
#, fuzzy, ignore-ellipsis, no-wrap, priority:100
msgid ""
"'git ls-remote' [--heads] [--tags] [--refs] [--upload-pack=<exec>]\n"
"\t      [-q | --quiet] [--exit-code] [--get-url] [--sort=<key>]\n"
"\t      [--symref] [<repository> [<patterns>...]]\n"
msgstr ""
"'git ls-remote' [--heads] [--tags] [--refs] [--upload-pack=<exec>]\n"
"\t      [-q | --quiet] [--exit-code] [--get-url] [--sort=<key>]\n"
"\t      [--symref] [<repository> [<refs>...]]\n"

#. type: Plain text
#: en/git-ls-remote.txt:20
#, priority:100
msgid "Displays references available in a remote repository along with the associated commit IDs."
msgstr "显示远程版本库中可用的引用以及相关的提交 ID。"

#. type: Labeled list
#: en/git-ls-remote.txt:25 en/git-show-ref.txt:40
#, ignore-same, no-wrap, priority:100
msgid "--heads"
msgstr "--heads"

#. type: Plain text
#: en/git-ls-remote.txt:34
#, priority:100
msgid "Limit to only refs/heads and refs/tags, respectively.  These options are _not_ mutually exclusive; when given both, references stored in refs/heads and refs/tags are displayed.  Note that `git ls-remote -h` used without anything else on the command line gives help, consistent with other git subcommands."
msgstr "分别限制在 refs/heads 和 refs/tags。 这些选项不是相互排斥的；当两个选项都给出时，存储在 refs/heads 和 refs/tags 中的引用会被显示。 注意，`git ls-remote -h` 在命令行中不使用任何其他东西，就会提供帮助，与其他 git 子命令一致。"

#. type: Labeled list
#: en/git-ls-remote.txt:35
#, ignore-same, no-wrap, priority:100
msgid "--refs"
msgstr "--refs"

#. type: Plain text
#: en/git-ls-remote.txt:37
#, priority:100
msgid "Do not show peeled tags or pseudorefs like `HEAD` in the output."
msgstr "在输出中不显示剥离的标签或像 `HEAD` 这样的伪引用。"

#. type: Plain text
#: en/git-ls-remote.txt:41
#, priority:100
msgid "Do not print remote URL to stderr."
msgstr "不将远程 URL 打印到标准错误流。"

#. type: Labeled list
#: en/git-ls-remote.txt:42
#, fuzzy, no-wrap, priority:100
msgid "--upload-pack=<exec>"
msgstr "--upload-pack=<exec>"

#. type: Plain text
#: en/git-ls-remote.txt:47
#, priority:100
msgid "Specify the full path of 'git-upload-pack' on the remote host. This allows listing references from repositories accessed via SSH and where the SSH daemon does not use the PATH configured by the user."
msgstr "指定远程主机上 'git-upload-pack' 的完整路径。这允许列出通过 SSH 访问的存储库的引用，而且 SSH 守护程序不使用用户配置的 PATH。"

#. type: Plain text
#: en/git-ls-remote.txt:53
#, priority:100
msgid "Exit with status \"2\" when no matching refs are found in the remote repository. Usually the command exits with status \"0\" to indicate it successfully talked with the remote repository, whether it found any matching refs."
msgstr "当在远程版本库中没有找到匹配的引用时，以状态 \"2\" 退出。通常该命令以状态 \"0\" 退出，表示它成功地与远程版本库进行了对话，无论是否找到了匹配的引用。"

#. type: Labeled list
#: en/git-ls-remote.txt:54
#, ignore-same, no-wrap, priority:100
msgid "--get-url"
msgstr "--get-url"

#. type: Plain text
#: en/git-ls-remote.txt:58
#, priority:100
msgid "Expand the URL of the given remote repository taking into account any \"url.<base>.insteadOf\" config setting (See linkgit:git-config[1]) and exit without talking to the remote."
msgstr "考虑任何 \"url.<base>.insteadOf\" 的配置设置（见linkgit:git-config[1]），展开给定的远程仓库的URL，然后退出，不与远程对话。"

#. type: Labeled list
#: en/git-ls-remote.txt:59
#, ignore-same, no-wrap, priority:100
msgid "--symref"
msgstr "--symref"

#. type: Plain text
#: en/git-ls-remote.txt:64
#, priority:100
msgid "In addition to the object pointed by it, show the underlying ref pointed by it when showing a symbolic ref.  Currently, upload-pack only shows the symref HEAD, so it will be the only one shown by ls-remote."
msgstr "除了它所指向的对象之外，在显示一个符号引用时，还要显示它所指向的底层引用。 目前，upload-pack 只显示符号引用HEAD，所以它将是 ls-remote 显示的唯一对象。"

#. type: Plain text
#: en/git-ls-remote.txt:74
#, priority:100
msgid "Sort based on the key given. Prefix `-` to sort in descending order of the value. Supports \"version:refname\" or \"v:refname\" (tag names are treated as versions). The \"version:refname\" sort order can also be affected by the \"versionsort.suffix\" configuration variable.  See linkgit:git-for-each-ref[1] for more sort options, but be aware keys like `committerdate` that require access to the objects themselves will not work for refs whose objects have not yet been fetched from the remote, and will give a `missing object` error."
msgstr "根据给定的键进行排序。前缀 `-` 以数值的降序来排序。支持 \"version:refname\" 或 \"v:refname\"（标签名被视为版本）。\"version:refname\" 的排序顺序也可以由 \"versionort.suffix\" 配置的变量影响。 见 linkgit:git-for-each-ref[1] 以获得更多的排序选项，但要注意像 `committerdate` 这样需要访问对象本身的键，对对象尚未从远程获取的引用不起作用，并会出现 `missing object` 的错误。"

#. type: Plain text
#: en/git-ls-remote.txt:82
#, priority:100
msgid "Transmit the given string to the server when communicating using protocol version 2.  The given string must not contain a NUL or LF character.  When multiple `--server-option=<option>` are given, they are all sent to the other side in the order listed on the command line."
msgstr "当使用协议版本2进行通信时，将给定的字符串传输给服务器。 给定的字符串不能包含 NUL 或 LF 字符。 当给出多个 `--server-option=<option>` 时，它们将按照命令行中列出的顺序全部发送给对方。"

#. type: Plain text
#: en/git-ls-remote.txt:87
#, priority:100
msgid "The \"remote\" repository to query.  This parameter can be either a URL or the name of a remote (see the GIT URLS and REMOTES sections of linkgit:git-fetch[1])."
msgstr "要查询的 \"远程\" 版本库。 这个参数可以是一个 URL，也可以是一个远程的名称（见 linkgit:git-fetch[1] 的 GIT URLS 和远端部分）。"

#. type: Labeled list
#: en/git-ls-remote.txt:88
#, fuzzy, ignore-ellipsis, no-wrap, priority:100
#| msgid "<path>..."
msgid "<patterns>..."
msgstr "<路径>..."

#. type: Plain text
#: en/git-ls-remote.txt:98
#, ignore-ellipsis, priority:100
msgid "When unspecified, all references, after filtering done with --heads and --tags, are shown.  When <patterns>... are specified, only references matching one or more of the given patterns are displayed. Each pattern is interpreted as a glob (see `glob` in linkgit:gitglossary[7]) which is matched against the \"tail\" of a ref, starting either from the start of the ref (so a full name like `refs/heads/foo` matches) or from a slash separator (so `bar` matches `refs/heads/bar` but not `refs/heads/foobar`)."
msgstr "当未指定时，在用 --heads 和 --tags 过滤后，所有引用都会被显示。 当 <patterns>... 被指定时，只显示匹配一个或多个给定模式的引用。每个模式都被解释为一个 glob（见 linkgit:gitglossary[7] 中的 `glob`），它与引用的 \"尾巴\" 相匹配，从引用的开头开始（所以像 `refs/heads/foo` 这样的全名匹配）或者从斜线分隔符开始（所以 `bar` 匹配 `refs/heads/bar`，而不是 `refs/heads/foobar`）。"

#. type: Plain text
#: en/git-ls-remote.txt:103 en/git-show-ref.txt:100
#, fuzzy, priority:100
#| msgid "Give the output in the short-format."
msgid "The output is in the format:"
msgstr "以简短的形式给出输出。"

#. type: delimited block -
#: en/git-ls-remote.txt:106
#, no-wrap, priority:100
msgid "<oid> TAB <ref> LF\n"
msgstr ""

#. type: Plain text
#: en/git-ls-remote.txt:112
#, priority:100
msgid "When showing an annotated tag, unless `--refs` is given, two such lines are shown: one with the refname for the tag itself as `<ref>`, and another with `<ref>` followed by `^{}`. The `<oid>` on the latter line shows the name of the object the tag points at."
msgstr ""

#. type: Plain text
#: en/git-ls-remote.txt:118
#, priority:100
msgid "List all references (including symbolics and pseudorefs), peeling tags:"
msgstr ""

#. type: delimited block -
#: en/git-ls-remote.txt:126
#, no-wrap, priority:100
msgid ""
"$ git ls-remote\n"
"27d43aaaf50ef0ae014b88bba294f93658016a2e\tHEAD\n"
"950264636c68591989456e3ba0a5442f93152c1a\trefs/heads/main\n"
"d9ab777d41f92a8c1684c91cfb02053d7dd1046b\trefs/heads/next\n"
"d4ca2e3147b409459955613c152220f4db848ee1\trefs/tags/v2.40.0\n"
"73876f4861cd3d187a4682290ab75c9dccadbc56\trefs/tags/v2.40.0^{}\n"
msgstr ""

#. type: Plain text
#: en/git-ls-remote.txt:129
#, fuzzy, priority:100
#| msgid "Print lines matching a pattern."
msgid "List all references matching given patterns:"
msgstr "打印符合模式的行。"

#. type: delimited block -
#: en/git-ls-remote.txt:134
#, no-wrap, priority:100
msgid ""
"$ git ls-remote http://www.kernel.org/pub/scm/git/git.git master seen rc\n"
"5fe978a5381f1fbad26a80e682ddd2a401966740\trefs/heads/master\n"
"c781a84b5204fb294c9ccc79f8b3baceeb32c061\trefs/heads/seen\n"
msgstr ""
"$ git ls-remote http://www.kernel.org/pub/scm/git/git.git master seen rc\n"
"5fe978a5381f1fbad26a80e682ddd2a401966740\trefs/heads/master\n"
"c781a84b5204fb294c9ccc79f8b3baceeb32c061\trefs/heads/seen\n"

#. type: Plain text
#: en/git-ls-remote.txt:137
#, fuzzy, priority:100
#| msgid "Print lines matching a pattern."
msgid "List only tags matching a given wildcard pattern:"
msgstr "打印符合模式的行。"

#. type: delimited block -
#: en/git-ls-remote.txt:144
#, no-wrap, priority:100
msgid ""
"$ git ls-remote --tags http://www.kernel.org/pub/scm/git/git.git v\\*\n"
"485a869c64a68cc5795dd99689797c5900f4716d\trefs/tags/v2.39.2\n"
"cbf04937d5b9fcf0a76c28f69e6294e9e3ecd7e6\trefs/tags/v2.39.2^{}\n"
"d4ca2e3147b409459955613c152220f4db848ee1\trefs/tags/v2.40.0\n"
"73876f4861cd3d187a4682290ab75c9dccadbc56\trefs/tags/v2.40.0^{}\n"
msgstr ""

#. type: Plain text
#: en/git-ls-remote.txt:149
#, ignore-same, priority:100
msgid "linkgit:git-check-ref-format[1]."
msgstr "linkgit:git-check-ref-format[1]."

#. type: Title =
#: en/git-ls-tree.txt:2
#, ignore-same, no-wrap, priority:80
msgid "git-ls-tree(1)"
msgstr "git-ls-tree(1)"

#. type: Plain text
#: en/git-ls-tree.txt:7
#, priority:80
msgid "git-ls-tree - List the contents of a tree object"
msgstr ""

#. type: Plain text
#: en/git-ls-tree.txt:15
#, fuzzy, ignore-ellipsis, no-wrap, priority:80
msgid ""
"'git ls-tree' [-d] [-r] [-t] [-l] [-z]\n"
"\t    [--name-only] [--name-status] [--object-only] [--full-name] [--full-tree] [--abbrev[=<n>]] [--format=<format>]\n"
"\t    <tree-ish> [<path>...]\n"
msgstr ""
"'git ls-tree' [-d] [-r] [-t] [-l] [-z]\n"
"\t    [--name-only] [--name-status] [--full-name] [--full-tree] [--abbrev[=<n>]]\n"
"\t    <tree-ish> [<path>...]\n"

#. type: Plain text
#: en/git-ls-tree.txt:20
#, priority:80
msgid "Lists the contents of a given tree object, like what \"/bin/ls -a\" does in the current working directory.  Note that:"
msgstr ""

#. type: Plain text
#: en/git-ls-tree.txt:25
#, priority:80
msgid "the behaviour is slightly different from that of \"/bin/ls\" in that the '<path>' denotes just a list of patterns to match, e.g. so specifying directory name (without `-r`) will behave differently, and order of the arguments does not matter."
msgstr ""

#. type: Plain text
#: en/git-ls-tree.txt:35
#, priority:80
msgid "the behaviour is similar to that of \"/bin/ls\" in that the '<path>' is taken as relative to the current working directory.  E.g. when you are in a directory 'sub' that has a directory 'dir', you can run 'git ls-tree -r HEAD dir' to list the contents of the tree (that is `sub/dir` in `HEAD`).  You don't want to give a tree that is not at the root level (e.g. `git ls-tree -r HEAD:sub dir`) in this case, as that would result in asking for `sub/sub/dir` in the `HEAD` commit.  However, the current working directory can be ignored by passing --full-tree option."
msgstr ""

#. type: Plain text
#: en/git-ls-tree.txt:40
#, priority:80
msgid "Id of a tree-ish."
msgstr ""

#. type: Plain text
#: en/git-ls-tree.txt:43
#, priority:80
msgid "Show only the named tree entry itself, not its children."
msgstr ""

#. type: Plain text
#: en/git-ls-tree.txt:46
#, priority:80
msgid "Recurse into sub-trees."
msgstr ""

#. type: Plain text
#: en/git-ls-tree.txt:50
#, priority:80
msgid "Show tree entries even when going to recurse them. Has no effect if `-r` was not passed. `-d` implies `-t`."
msgstr ""

#. type: Plain text
#: en/git-ls-tree.txt:54
#, priority:80
msgid "Show object size of blob (file) entries."
msgstr ""

#. type: Plain text
#: en/git-ls-tree.txt:58
#, priority:80
msgid "\\0 line termination on output and do not quote filenames.  See OUTPUT FORMAT below for more information."
msgstr ""

#. type: Plain text
#: en/git-ls-tree.txt:63
#, priority:80
msgid "List only filenames (instead of the \"long\" output), one per line.  Cannot be combined with `--object-only`."
msgstr ""

#. type: Labeled list
#: en/git-ls-tree.txt:64
#, ignore-same, no-wrap, priority:80
msgid "--object-only"
msgstr "--object-only"

#. type: Plain text
#: en/git-ls-tree.txt:71
#, priority:80
msgid "List only names of the objects, one per line. Cannot be combined with `--name-only` or `--name-status`.  This is equivalent to specifying `--format='%(objectname)'`, but for both this option and that exact format the command takes a hand-optimized codepath instead of going through the generic formatting mechanism."
msgstr ""

#. type: Plain text
#: en/git-ls-tree.txt:81
#, priority:80
msgid "Instead of showing the path names relative to the current working directory, show the full path names."
msgstr ""

#. type: Plain text
#: en/git-ls-tree.txt:85
#, priority:80
msgid "Do not limit the listing to the current working directory.  Implies --full-name."
msgstr ""

#. type: Plain text
#: en/git-ls-tree.txt:95
#, priority:80
msgid "A string that interpolates `%(fieldname)` from the result being shown. It also interpolates `%%` to `%`, and `%xNN` where `NN` are hex digits interpolates to character with hex code `NN`; for example `%x00` interpolates to `\\0` (NUL), `%x09` to `\\t` (TAB) and `%x0a` to `\\n` (LF).  When specified, `--format` cannot be combined with other format-altering options, including `--long`, `--name-only` and `--object-only`."
msgstr ""

#. type: Labeled list
#: en/git-ls-tree.txt:96
#, ignore-ellipsis, no-wrap, priority:80
msgid "[<path>...]"
msgstr ""

#. type: Plain text
#: en/git-ls-tree.txt:100
#, priority:80
msgid "When paths are given, show them (note that this isn't really raw pathnames, but rather a list of patterns to match).  Otherwise implicitly uses the root level of the tree as the sole path argument."
msgstr ""

#. type: Title -
#: en/git-ls-tree.txt:103
#, fuzzy, no-wrap, priority:80
msgid "Output Format"
msgstr "输出格式"

#. type: Plain text
#: en/git-ls-tree.txt:108
#, priority:80
msgid "The output format of `ls-tree` is determined by either the `--format` option, or other format-altering options such as `--name-only` etc.  (see `--format` above)."
msgstr ""

#. type: Plain text
#: en/git-ls-tree.txt:112
#, priority:80
msgid "The use of certain `--format` directives is equivalent to using those options, but invoking the full formatting machinery can be slower than using an appropriate formatting option."
msgstr ""

#. type: Plain text
#: en/git-ls-tree.txt:116
#, priority:80
msgid "In cases where the `--format` would exactly map to an existing option `ls-tree` will use the appropriate faster path. Thus the default format is equivalent to:"
msgstr ""

#. type: Plain text
#: en/git-ls-tree.txt:118
#, no-wrap, priority:80
msgid "\t%(objectmode) %(objecttype) %(objectname)%x09%(path)\n"
msgstr ""

#. type: Plain text
#: en/git-ls-tree.txt:121
#, priority:80
msgid "This output format is compatible with what `--index-info --stdin` of 'git update-index' expects."
msgstr ""

#. type: Plain text
#: en/git-ls-tree.txt:123
#, priority:80
msgid "When the `-l` option is used, format changes to"
msgstr ""

#. type: Plain text
#: en/git-ls-tree.txt:125
#, no-wrap, priority:80
msgid "\t%(objectmode) %(objecttype) %(objectname) %(objectsize:padded)%x09%(path)\n"
msgstr ""

#. type: Plain text
#: en/git-ls-tree.txt:129
#, priority:80
msgid "Object size identified by <objectname> is given in bytes, and right-justified with minimum width of 7 characters.  Object size is given only for blobs (file) entries; for other entries `-` character is used in place of size."
msgstr ""

#. type: Plain text
#: en/git-ls-tree.txt:136
#, fuzzy, priority:80
#| msgid "Combined diff format"
msgid "Customized format:"
msgstr "合并的差异格式"

#. type: Plain text
#: en/git-ls-tree.txt:141
#, priority:80
msgid "It is possible to print in a custom format by using the `--format` option, which is able to interpolate different fields using a `%(fieldname)` notation.  For example, if you only care about the \"objectname\" and \"path\" fields, you can execute with a specific \"--format\" like"
msgstr ""

#. type: Plain text
#: en/git-ls-tree.txt:143
#, no-wrap, priority:80
msgid "\tgit ls-tree --format='%(objectname) %(path)' <tree-ish>\n"
msgstr ""

#. type: Plain text
#: en/git-ls-tree.txt:150
#, priority:80
msgid "Various values from structured fields can be used to interpolate into the resulting output. For each outputting line, the following names can be used:"
msgstr ""

#. type: Plain text
#: en/git-ls-tree.txt:153
#, fuzzy, priority:80
msgid "The mode of the object."
msgstr "--objects"

#. type: Plain text
#: en/git-ls-tree.txt:155
#, priority:80
msgid "The type of the object (`commit`, `blob` or `tree`)."
msgstr ""

#. type: Plain text
#: en/git-ls-tree.txt:157
#, fuzzy, priority:80
msgid "The name of the object."
msgstr "--objects"

#. type: Plain text
#: en/git-ls-tree.txt:160
#, priority:80
msgid "The size of a `blob` object (\"-\" if it's a `commit` or `tree`).  It also supports a padded format of size with \"%(objectsize:padded)\"."
msgstr ""

#. type: Plain text
#: en/git-ls-tree.txt:162
#, priority:80
msgid "The pathname of the object."
msgstr ""

#. type: Title =
#: en/git-mailinfo.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-mailinfo(1)"
msgstr "git-mailinfo(1)"

#. type: Plain text
#: en/git-mailinfo.txt:7
#, priority:100
msgid "git-mailinfo - Extracts patch and authorship from a single e-mail message"
msgstr "git-mailinfo - 从单个电子邮件信息中提取补丁和作者"

#. type: Plain text
#: en/git-mailinfo.txt:15
#, no-wrap, priority:100
msgid ""
"'git mailinfo' [-k|-b] [-u | --encoding=<encoding> | -n]\n"
"\t       [--[no-]scissors] [--quoted-cr=<action>]\n"
"\t       <msg> <patch>\n"
msgstr ""
"'git mailinfo' [-k|-b] [-u | --encoding=<encoding> | -n]\n"
"\t       [--[no-]scissors] [--quoted-cr=<action>]\n"
"\t       <msg> <patch>\n"

#. type: Plain text
#: en/git-mailinfo.txt:25
#, priority:100
msgid "Reads a single e-mail message from the standard input, and writes the commit log message in <msg> file, and the patches in <patch> file.  The author name, e-mail and e-mail subject are written out to the standard output to be used by 'git am' to create a commit.  It is usually not necessary to use this command directly.  See linkgit:git-am[1] instead."
msgstr "从标准输入中读取一条电子邮件，并将提交日志信息写入<msg> 文件，将补丁写入<patch>文件。 作者姓名、电子邮件和电子邮件主题会被写到标准输出，以便被 'git am' 用来创建一个提交。 通常没有必要直接使用这个命令。 请参见 linkgit:git-am[1]。"

#. type: Plain text
#: en/git-mailinfo.txt:34
#, priority:100
msgid "Usually the program removes email cruft from the Subject: header line to extract the title line for the commit log message.  This option prevents this munging, and is most useful when used to read back 'git format-patch -k' output."
msgstr "通常情况下，程序会从Subject: header  行中删除电子邮件的残余部分，以提取提交日志信息的标题行。 这个选项可以防止这种删除，在用于回读 'git format-patch -k' 输出时最有用。"

#. type: Plain text
#: en/git-mailinfo.txt:36
#, priority:100
msgid "Specifically, the following are removed until none of them remain:"
msgstr "具体来说，以下内容会被删除，直到一个都不剩："

#. type: Plain text
#: en/git-mailinfo.txt:39
#, priority:100
msgid "Leading and trailing whitespace."
msgstr "前导和尾部的多余空白字符。"

#. type: Plain text
#: en/git-mailinfo.txt:41
#, priority:100
msgid "Leading `Re:`, `re:`, and `:`."
msgstr "前导的的 `Re:`，`re:`，和 `:`。"

#. type: Plain text
#: en/git-mailinfo.txt:43
#, priority:100
msgid "Leading bracketed strings (between `[` and `]`, usually"
msgstr "前导括号内的字符串（在 `[` 和 `]` 之间，通常是"

#. type: Plain text
#: en/git-mailinfo.txt:44
#, priority:100
msgid "`[PATCH]`)."
msgstr "`[PATCH]`）。"

#. type: Plain text
#: en/git-mailinfo.txt:48
#, priority:100
msgid "Finally, runs of whitespace are normalized to a single ASCII space character."
msgstr "最后，空格被规范化为一个ASCII空格字符。"

#. type: Plain text
#: en/git-mailinfo.txt:53
#, priority:100
msgid "When -k is not in effect, all leading strings bracketed with '[' and ']' pairs are stripped.  This option limits the stripping to only the pairs whose bracketed string contains the word \"PATCH\"."
msgstr "当-k 不生效时，所有用 '[' 和 ']' 对括起来的前导字符串都被剥离。 这个选项限制了剥离的范围，只限于括号内的字符串包含 \"PATCH \" 一词的对括号。"

#. type: Plain text
#: en/git-mailinfo.txt:60
#, priority:100
msgid "The commit log message, author name and author email are taken from the e-mail, and after minimally decoding MIME transfer encoding, re-coded in the charset specified by `i18n.commitEncoding` (defaulting to UTF-8) by transliterating them.  This used to be optional but now it is the default."
msgstr "提交日志信息、作者姓名和作者的电子邮件来自电子邮件，在对 MIME 传输编码进行最小化解码后，通过音译将其重新编码为 `i18n.commitEncoding` 指定的字符集（默认为 UTF-8）。 这曾经是可选的，但现在是默认的。"

#. type: Plain text
#: en/git-mailinfo.txt:63
#, priority:100
msgid "Note that the patch is always used as-is without charset conversion, even with this flag."
msgstr "注意，即使有这个标志，补丁也总是按原样使用，不进行字符集转换。"

#. type: Plain text
#: en/git-mailinfo.txt:67
#, priority:100
msgid "Similar to -u.  But when re-coding, the charset specified here is used instead of the one specified by `i18n.commitEncoding` or UTF-8."
msgstr "与 -u 类似。 但在重新编码时，使用这里指定的字符集，而不是 `i18n.commitEncoding` 或 UTF-8 所指定的。"

#. type: Plain text
#: en/git-mailinfo.txt:70
#, priority:100
msgid "Disable all charset re-coding of the metadata."
msgstr "禁用元数据的所有字符集重新编码。"

#. type: Plain text
#: en/git-mailinfo.txt:75
#, priority:100
msgid "Copy the Message-ID header at the end of the commit message.  This is useful in order to associate commits with mailing list discussions."
msgstr "复制提交信息末尾的 Message-ID 头。 这对于将提交与邮件列表讨论联系起来是很有用的。"

#. type: Plain text
#: en/git-mailinfo.txt:83
#, priority:100
msgid "Remove everything in body before a scissors line (e.g. \"-- >8 --\").  The line represents scissors and perforation marks, and is used to request the reader to cut the message at that line.  If that line appears in the body of the message before the patch, everything before it (including the scissors line itself) is ignored when this option is used."
msgstr "删除正文中剪刀线之前的所有内容（如\"-->8--\"）。 这条线代表剪刀和打孔的标记，用来要求读者在该线处剪切信息。 如果该行出现在邮件正文中的补丁之前，当使用该选项时，它之前的所有内容（包括剪刀线本身）都会被忽略。"

#. type: Plain text
#: en/git-mailinfo.txt:88
#, priority:100
msgid "This is useful if you want to begin your message in a discussion thread with comments and suggestions on the message you are responding to, and to conclude it with a patch submission, separating the discussion and the beginning of the proposed commit log message with a scissors line."
msgstr "如果你想在讨论线中开始你的信息，对你所回应的信息提出评论和建议，并以提交补丁作为结束，用剪刀线把讨论和建议的提交日志信息的开头分开，这很有用。"

#. type: Plain text
#: en/git-mailinfo.txt:90
#, priority:100
msgid "This can be enabled by default with the configuration option mailinfo.scissors."
msgstr "这可以通过配置选项 mailinfo.scissors 来默认启用。"

#. type: Plain text
#: en/git-mailinfo.txt:93
#, priority:100
msgid "Ignore scissors lines. Useful for overriding mailinfo.scissors settings."
msgstr "忽略剪切线。对于覆盖 mailinfo.scissors 设置很有用。"

#. type: Plain text
#: en/git-mailinfo.txt:98
#, priority:100
msgid "Action when processes email messages sent with base64 or quoted-printable encoding, and the decoded lines end with a CRLF instead of a simple LF."
msgstr "当处理以 base64 或 quoted-printable 编码发送的电子邮件，并且解码后的行以 CRLF 而不是简单的 LF 结尾时，就会启用。"

#. type: Plain text
#: en/git-mailinfo.txt:100
#, priority:100
msgid "The valid actions are:"
msgstr "有效的行为是："

#. type: Plain text
#: en/git-mailinfo.txt:103
#, priority:100
msgid "`nowarn`: Git will do nothing when such a CRLF is found."
msgstr "`nowarn`： 当发现这样的 CRLF 时，Git将不做任何事情。"

#. type: Plain text
#: en/git-mailinfo.txt:104
#, priority:100
msgid "`warn`: Git will issue a warning for each message if such a CRLF is"
msgstr "`warn`： 如果有这样的 CRLF，Git 会对每条信息发出警告。"

#. type: Plain text
#: en/git-mailinfo.txt:105
#, priority:100
msgid "found."
msgstr "找到了。"

#. type: Plain text
#: en/git-mailinfo.txt:106
#, priority:100
msgid "`strip`: Git will convert those CRLF to LF."
msgstr "`strip`： Git 将把这些 CRLF 转换为 LF。"

#. type: Plain text
#: en/git-mailinfo.txt:110
#, priority:100
msgid "The default action could be set by configuration option `mailinfo.quotedCR`.  If no such configuration option has been set, `warn` will be used."
msgstr "默认动作可以通过配置选项 `mailinfo.quotedCR` 设置。 如果没有设置这样的配置选项，将使用 `warn`。"

#. type: Labeled list
#: en/git-mailinfo.txt:111
#, fuzzy, no-wrap, priority:100
msgid "<msg>"
msgstr "<msg>"

#. type: Plain text
#: en/git-mailinfo.txt:114
#, priority:100
msgid "The commit log message extracted from e-mail, usually except the title line which comes from e-mail Subject."
msgstr "从电子邮件中提取的提交日志信息，通常除了来自电子邮件主题的标题行。"

#. type: Labeled list
#: en/git-mailinfo.txt:115
#, fuzzy, no-wrap, priority:100
msgid "<patch>"
msgstr "<patch>"

#. type: Plain text
#: en/git-mailinfo.txt:117
#, priority:100
msgid "The patch extracted from e-mail."
msgstr "从电子邮件中提取的补丁。"

#. type: Title =
#: en/git-mailsplit.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-mailsplit(1)"
msgstr "git-mailsplit(1)"

#. type: Plain text
#: en/git-mailsplit.txt:7
#, priority:100
msgid "git-mailsplit - Simple UNIX mbox splitter program"
msgstr "git-mailsplit - 简单的UNIX mbox分割程序"

#. type: Plain text
#: en/git-mailsplit.txt:13
#, ignore-ellipsis, no-wrap, priority:100
msgid ""
"'git mailsplit' [-b] [-f<nn>] [-d<prec>] [--keep-cr] [--mboxrd]\n"
"\t\t-o<directory> [--] [(<mbox>|<Maildir>)...]\n"
msgstr ""
"'git mailsplit' [-b] [-f<nn>] [-d<prec>] [--keep-cr] [--mboxrd]\n"
"\t\t-o<directory> [--] [(<mbox>|<Maildir>)...]\n"

#. type: Plain text
#: en/git-mailsplit.txt:18
#, priority:100
msgid "Splits a mbox file or a Maildir into a list of files: \"0001\" \"0002\" ..  in the specified directory so you can process them further from there."
msgstr "将一个 mbox 文件或一个 Maildir 分割成一个文件列表： \"0001\" \"0002\"...... 存放在指定的目录中，这样你就可以从那里进一步处理它们。"

#. type: Plain text
#: en/git-mailsplit.txt:21
#, priority:100
msgid "Maildir splitting relies upon filenames being sorted to output patches in the correct order."
msgstr "Maildir 分割依赖于文件名的排序，以便按照正确的顺序输出补丁。"

#. type: Labeled list
#: en/git-mailsplit.txt:24
#, fuzzy, no-wrap, priority:100
msgid "<mbox>"
msgstr "<mbox>"

#. type: Plain text
#: en/git-mailsplit.txt:27
#, priority:100
msgid "Mbox file to split.  If not given, the mbox is read from the standard input."
msgstr "要分割的 Mbox 文件。 如果没有给出，则从标准输入中读取 Mbox。"

#. type: Labeled list
#: en/git-mailsplit.txt:28
#, fuzzy, no-wrap, priority:100
msgid "<Maildir>"
msgstr "<Maildir>"

#. type: Plain text
#: en/git-mailsplit.txt:31
#, priority:100
msgid "Root of the Maildir to split. This directory should contain the cur, tmp and new subdirectories."
msgstr "要分割的 Maildir 的根目录。这个目录应该包含 cur、tmp 和新的子目录。"

#. type: Labeled list
#: en/git-mailsplit.txt:32
#, fuzzy, no-wrap, priority:100
msgid "-o<directory>"
msgstr "-o<directory>"

#. type: Plain text
#: en/git-mailsplit.txt:34
#, priority:100
msgid "Directory in which to place the individual messages."
msgstr "放置各个信息的目录。"

#. type: Plain text
#: en/git-mailsplit.txt:38
#, priority:100
msgid "If any file doesn't begin with a From line, assume it is a single mail message instead of signaling error."
msgstr "如果任何文件没有以发件人行开始，就假定它是一个单一的邮件信息，而不是说这是错误。"

#. type: Labeled list
#: en/git-mailsplit.txt:39
#, fuzzy, no-wrap, priority:100
msgid "-d<prec>"
msgstr "-d<prec>"

#. type: Plain text
#: en/git-mailsplit.txt:43
#, priority:100
msgid "Instead of the default 4 digits with leading zeros, different precision can be specified for the generated filenames."
msgstr "可以为生成的文件名指定不同的精度，而不是默认的带前导零的4位数。"

#. type: Labeled list
#: en/git-mailsplit.txt:44
#, fuzzy, no-wrap, priority:100
msgid "-f<nn>"
msgstr "-f<nn>"

#. type: Plain text
#: en/git-mailsplit.txt:47
#, priority:100
msgid "Skip the first <nn> numbers, for example if -f3 is specified, start the numbering with 0004."
msgstr "跳过第一个 <nn>数字，例如如果指定了-f3，就从 0004 开始编号。"

#. type: Labeled list
#: en/git-mailsplit.txt:48
#, ignore-same, no-wrap, priority:100
msgid "--keep-cr"
msgstr "--keep-cr"

#. type: Plain text
#: en/git-mailsplit.txt:50
#, priority:100
msgid "Do not remove `\\r` from lines ending with `\\r\\n`."
msgstr "不要从以 `\\r\\n` 结尾的行中删除`\\r`。"

#. type: Labeled list
#: en/git-mailsplit.txt:51
#, ignore-same, no-wrap, priority:100
msgid "--mboxrd"
msgstr "--mboxrd"

#. type: Plain text
#: en/git-mailsplit.txt:54
#, priority:100
msgid "Input is of the \"mboxrd\" format and \"^>+From \" line escaping is reversed."
msgstr "输入是 \"mboxrd\" 格式，\"^>+From\" 行转义被颠倒。"

#. type: Title =
#: en/git-merge-base.txt:2
#, ignore-same, no-wrap, priority:80
msgid "git-merge-base(1)"
msgstr "git-merge-base(1)"

#. type: Plain text
#: en/git-merge-base.txt:7
#, fuzzy, priority:80
msgid "git-merge-base - Find as good common ancestors as possible for a merge"
msgstr "git-merge-base - Find as good common ancestors as possible for a merge"

#. type: Plain text
#: en/git-merge-base.txt:17
#, ignore-ellipsis, no-wrap, priority:80
msgid ""
"'git merge-base' [-a | --all] <commit> <commit>...\n"
"'git merge-base' [-a | --all] --octopus <commit>...\n"
"'git merge-base' --is-ancestor <commit> <commit>\n"
"'git merge-base' --independent <commit>...\n"
"'git merge-base' --fork-point <ref> [<commit>]\n"
msgstr ""

#. type: Plain text
#: en/git-merge-base.txt:27
#, priority:80
msgid "'git merge-base' finds best common ancestor(s) between two commits to use in a three-way merge.  One common ancestor is 'better' than another common ancestor if the latter is an ancestor of the former.  A common ancestor that does not have any better common ancestor is a 'best common ancestor', i.e. a 'merge base'.  Note that there can be more than one merge base for a pair of commits."
msgstr ""

#. type: Title -
#: en/git-merge-base.txt:29
#, no-wrap, priority:80
msgid "OPERATION MODES"
msgstr ""

#. type: Plain text
#: en/git-merge-base.txt:33
#, priority:80
msgid "As the most common special case, specifying only two commits on the command line means computing the merge base between the given two commits."
msgstr ""

#. type: Plain text
#: en/git-merge-base.txt:38
#, priority:80
msgid "More generally, among the two commits to compute the merge base from, one is specified by the first commit argument on the command line; the other commit is a (possibly hypothetical) commit that is a merge across all the remaining commits on the command line."
msgstr ""

#. type: Plain text
#: en/git-merge-base.txt:42
#, priority:80
msgid "As a consequence, the 'merge base' is not necessarily contained in each of the commit arguments if more than two commits are specified. This is different from linkgit:git-show-branch[1] when used with the `--merge-base` option."
msgstr ""

#. type: Labeled list
#: en/git-merge-base.txt:43
#, ignore-same, no-wrap, priority:80
msgid "--octopus"
msgstr "--octopus"

#. type: Plain text
#: en/git-merge-base.txt:47
#, priority:80
msgid "Compute the best common ancestors of all supplied commits, in preparation for an n-way merge.  This mimics the behavior of 'git show-branch --merge-base'."
msgstr ""

#. type: Labeled list
#: en/git-merge-base.txt:48 en/git-show-branch.txt:89
#, ignore-same, no-wrap, priority:100
msgid "--independent"
msgstr "--independent"

#. type: Plain text
#: en/git-merge-base.txt:54
#, priority:80
msgid "Instead of printing merge bases, print a minimal subset of the supplied commits with the same ancestors.  In other words, among the commits given, list those which cannot be reached from any other.  This mimics the behavior of 'git show-branch --independent'."
msgstr ""

#. type: Labeled list
#: en/git-merge-base.txt:55
#, ignore-same, no-wrap, priority:80
msgid "--is-ancestor"
msgstr "--is-ancestor"

#. type: Plain text
#: en/git-merge-base.txt:59
#, priority:80
msgid "Check if the first <commit> is an ancestor of the second <commit>, and exit with status 0 if true, or with status 1 if not.  Errors are signaled by a non-zero status that is not 1."
msgstr ""

#. type: Labeled list
#: en/git-merge-base.txt:60 en/git-rebase.txt:451
#, ignore-same, no-wrap, priority:100
msgid "--fork-point"
msgstr "--fork-point"

#. type: Plain text
#: en/git-merge-base.txt:68
#, priority:80
msgid "Find the point at which a branch (or any history that leads to <commit>) forked from another branch (or any reference)  <ref>. This does not just look for the common ancestor of the two commits, but also takes into account the reflog of <ref> to see if the history leading to <commit> forked from an earlier incarnation of the branch <ref> (see discussion on this mode below)."
msgstr ""

#. type: Plain text
#: en/git-merge-base.txt:74
#, priority:80
msgid "Output all merge bases for the commits, instead of just one."
msgstr ""

#. type: Plain text
#: en/git-merge-base.txt:80
#, priority:80
msgid "Given two commits 'A' and 'B', `git merge-base A B` will output a commit which is reachable from both 'A' and 'B' through the parent relationship."
msgstr ""

#. type: Plain text
#: en/git-merge-base.txt:82
#, priority:80
msgid "For example, with this topology:"
msgstr ""

#. type: delimited block .
#: en/git-merge-base.txt:87
#, fuzzy, no-wrap, priority:80
msgid ""
"\t o---o---o---B\n"
"\t/\n"
"---o---1---o---o---o---A\n"
msgstr ""
"\t o---o---o---B\n"
"\t/\n"
"---o---1---o---o---o---A\n"

#. type: Plain text
#: en/git-merge-base.txt:90
#, priority:80
msgid "the merge base between 'A' and 'B' is '1'."
msgstr ""

#. type: Plain text
#: en/git-merge-base.txt:94
#, priority:80
msgid "Given three commits 'A', 'B' and 'C', `git merge-base A B C` will compute the merge base between 'A' and a hypothetical commit 'M', which is a merge between 'B' and 'C'.  For example, with this topology:"
msgstr ""

#. type: delimited block .
#: en/git-merge-base.txt:101
#, fuzzy, no-wrap, priority:80
msgid ""
"       o---o---o---o---C\n"
"      /\n"
"     /   o---o---o---B\n"
"    /   /\n"
"---2---1---o---o---o---A\n"
msgstr ""
"       o---o---o---o---C\n"
"      /\n"
"     /   o---o---o---B\n"
"    /   /\n"
"---2---1---o---o---o---A\n"

#. type: Plain text
#: en/git-merge-base.txt:105
#, fuzzy, priority:80
msgid "the result of `git merge-base A B C` is '1'.  This is because the equivalent topology with a merge commit 'M' between 'B' and 'C' is:"
msgstr "the result of `git merge-base A B C` is '1'.  This is because the equivalent topology with a merge commit 'M' between 'B' and 'C' is:"

#. type: delimited block .
#: en/git-merge-base.txt:113
#, fuzzy, no-wrap, priority:80
msgid ""
"       o---o---o---o---o\n"
"      /                 \\\n"
"     /   o---o---o---o---M\n"
"    /   /\n"
"---2---1---o---o---o---A\n"
msgstr ""
"       o---o---o---o---o\n"
"      /                 \\\n"
"     /   o---o---o---o---M\n"
"    /   /\n"
"---2---1---o---o---o---A\n"

#. type: Plain text
#: en/git-merge-base.txt:118
#, priority:80
msgid "and the result of `git merge-base A M` is '1'.  Commit '2' is also a common ancestor between 'A' and 'M', but '1' is a better common ancestor, because '2' is an ancestor of '1'.  Hence, '2' is not a merge base."
msgstr ""

#. type: Plain text
#: en/git-merge-base.txt:121
#, priority:80
msgid "The result of `git merge-base --octopus A B C` is '2', because '2' is the best common ancestor of all commits."
msgstr ""

#. type: Plain text
#: en/git-merge-base.txt:124
#, priority:80
msgid "When the history involves criss-cross merges, there can be more than one 'best' common ancestor for two commits.  For example, with this topology:"
msgstr ""

#. type: delimited block .
#: en/git-merge-base.txt:131
#, fuzzy, no-wrap, priority:80
msgid ""
"---1---o---A\n"
"    \\ /\n"
"     X\n"
"    / \\\n"
"---2---o---o---B\n"
msgstr ""
"---1---o---A\n"
"    \\ /\n"
"     X\n"
"    / \\\n"
"---2---o---o---B\n"

#. type: Plain text
#: en/git-merge-base.txt:136
#, priority:80
msgid "both '1' and '2' are merge-bases of A and B.  Neither one is better than the other (both are 'best' merge bases).  When the `--all` option is not given, it is unspecified which best one is output."
msgstr ""

#. type: Plain text
#: en/git-merge-base.txt:141
#, priority:80
msgid "A common idiom to check \"fast-forward-ness\" between two commits A and B is (or at least used to be) to compute the merge base between A and B, and check if it is the same as A, in which case, A is an ancestor of B.  You will see this idiom used often in older scripts."
msgstr ""

#. type: delimited block .
#: en/git-merge-base.txt:148
#, ignore-ellipsis, no-wrap, priority:80
msgid ""
"A=$(git rev-parse --verify A)\n"
"if test \"$A\" = \"$(git merge-base A B)\"\n"
"then\n"
"\t... A is an ancestor of B ...\n"
"fi\n"
msgstr ""

#. type: Plain text
#: en/git-merge-base.txt:151
#, priority:80
msgid "In modern git, you can say this in a more direct way:"
msgstr ""

#. type: delimited block .
#: en/git-merge-base.txt:157
#, ignore-ellipsis, no-wrap, priority:80
msgid ""
"if git merge-base --is-ancestor A B\n"
"then\n"
"\t... A is an ancestor of B ...\n"
"fi\n"
msgstr ""

#. type: Plain text
#: en/git-merge-base.txt:160
#, fuzzy, priority:80
msgid "instead."
msgstr "代替。"

#. type: Title -
#: en/git-merge-base.txt:162
#, no-wrap, priority:80
msgid "Discussion on fork-point mode"
msgstr ""

#. type: Plain text
#: en/git-merge-base.txt:168
#, priority:80
msgid "After working on the `topic` branch created with `git switch -c topic origin/master`, the history of remote-tracking branch `origin/master` may have been rewound and rebuilt, leading to a history of this shape:"
msgstr ""

#. type: delimited block .
#: en/git-merge-base.txt:177
#, fuzzy, no-wrap, priority:80
msgid ""
"\t\t o---B2\n"
"\t\t/\n"
"---o---o---B1--o---o---o---B (origin/master)\n"
"\t\\\n"
"\t B0\n"
"\t  \\\n"
"\t   D0---D1---D (topic)\n"
msgstr ""
"\t\t o---B2\n"
"\t\t/\n"
"---o---o---B1--o---o---o---B (origin/master)\n"
"\t\\\n"
"\t B0\n"
"\t  \\\n"
"\t   D0---D1---D (topic)\n"

#. type: Plain text
#: en/git-merge-base.txt:184
#, priority:80
msgid "where `origin/master` used to point at commits B0, B1, B2 and now it points at B, and your `topic` branch was started on top of it back when `origin/master` was at B0, and you built three commits, D0, D1, and D, on top of it.  Imagine that you now want to rebase the work you did on the topic on top of the updated origin/master."
msgstr ""

#. type: Plain text
#: en/git-merge-base.txt:190
#, priority:80
msgid "In such a case, `git merge-base origin/master topic` would return the parent of B0 in the above picture, but B0^..D is *not* the range of commits you would want to replay on top of B (it includes B0, which is not what you wrote; it is a commit the other side discarded when it moved its tip from B0 to B1)."
msgstr ""

#. type: Plain text
#: en/git-merge-base.txt:198
#, priority:80
msgid "`git merge-base --fork-point origin/master topic` is designed to help in such a case.  It takes not only B but also B0, B1, and B2 (i.e. old tips of the remote-tracking branches your repository's reflog knows about) into account to see on which commit your topic branch was built and finds B0, allowing you to replay only the commits on your topic, excluding the commits the other side later discarded."
msgstr ""

#. type: Plain text
#: en/git-merge-base.txt:200
#, priority:80
msgid "Hence"
msgstr ""

#. type: Plain text
#: en/git-merge-base.txt:202
#, fuzzy, no-wrap, priority:80
msgid "    $ fork_point=$(git merge-base --fork-point origin/master topic)\n"
msgstr "    $ fork_point=$(git merge-base --fork-point origin/master topic)\n"

#. type: Plain text
#: en/git-merge-base.txt:204
#, priority:80
msgid "will find B0, and"
msgstr ""

#. type: Plain text
#: en/git-merge-base.txt:206
#, fuzzy, no-wrap, priority:80
msgid "    $ git rebase --onto origin/master $fork_point topic\n"
msgstr "    $ git rebase --onto origin/master $fork_point topic\n"

#. type: Plain text
#: en/git-merge-base.txt:209
#, priority:80
msgid "will replay D0, D1 and D on top of B to create a new history of this shape:"
msgstr ""

#. type: delimited block .
#: en/git-merge-base.txt:218
#, fuzzy, no-wrap, priority:80
msgid ""
"\t\t o---B2\n"
"\t\t/\n"
"---o---o---B1--o---o---o---B (origin/master)\n"
"\t\\                   \\\n"
"\t B0                  D0'--D1'--D' (topic - updated)\n"
"\t  \\\n"
"\t   D0---D1---D (topic - old)\n"
msgstr ""
"\t\t o---B2\n"
"\t\t/\n"
"---o---o---B1--o---o---o---B (origin/master)\n"
"\t\\                   \\\n"
"\t B0                  D0'--D1'--D' (topic - updated)\n"
"\t  \\\n"
"\t   D0---D1---D (topic - old)\n"

#. type: Plain text
#: en/git-merge-base.txt:226
#, priority:80
msgid "A caveat is that older reflog entries in your repository may be expired by `git gc`.  If B0 no longer appears in the reflog of the remote-tracking branch `origin/master`, the `--fork-point` mode obviously cannot find it and fails, avoiding to give a random and useless result (such as the parent of B0, like the same command without the `--fork-point` option gives)."
msgstr ""

#. type: Plain text
#: en/git-merge-base.txt:237
#, priority:80
msgid "Also, the remote-tracking branch you use the `--fork-point` mode with must be the one your topic forked from its tip.  If you forked from an older commit than the tip, this mode would not find the fork point (imagine in the above sample history B0 did not exist, origin/master started at B1, moved to B2 and then B, and you forked your topic at origin/master^ when origin/master was B1; the shape of the history would be the same as above, without B0, and the parent of B1 is what `git merge-base origin/master topic` correctly finds, but the `--fork-point` mode will not, because it is not one of the commits that used to be at the tip of origin/master)."
msgstr ""

#. type: Title -
#: en/git-merge-base.txt:240
#, fuzzy, no-wrap, priority:80
msgid "See also"
msgstr "推荐"

#. type: Plain text
#: en/git-merge-base.txt:244
#, ignore-same, priority:80
msgid "linkgit:git-rev-list[1], linkgit:git-show-branch[1], linkgit:git-merge[1]"
msgstr "linkgit:git-rev-list[1], linkgit:git-show-branch[1], linkgit:git-merge[1]"

#. type: Title =
#: en/git-merge-file.txt:2
#, ignore-same, no-wrap, priority:90
msgid "git-merge-file(1)"
msgstr "git-merge-file(1)"

#. type: Plain text
#: en/git-merge-file.txt:7
#, fuzzy, priority:90
msgid "git-merge-file - Run a three-way file merge"
msgstr "git-merge-file - Run a three-way file merge"

#. type: Plain text
#: en/git-merge-file.txt:15
#, no-wrap, priority:90
msgid ""
"'git merge-file' [-L <current-name> [-L <base-name> [-L <other-name>]]]\n"
"\t[--ours|--theirs|--union] [-p|--stdout] [-q|--quiet] [--marker-size=<n>]\n"
"\t[--[no-]diff3] <current-file> <base-file> <other-file>\n"
msgstr ""

#. type: Plain text
#: en/git-merge-file.txt:25
#, priority:90
msgid "'git merge-file' incorporates all changes that lead from the `<base-file>` to `<other-file>` into `<current-file>`. The result ordinarily goes into `<current-file>`. 'git merge-file' is useful for combining separate changes to an original. Suppose `<base-file>` is the original, and both `<current-file>` and `<other-file>` are modifications of `<base-file>`, then 'git merge-file' combines both changes."
msgstr ""

#. type: Plain text
#: en/git-merge-file.txt:30
#, priority:90
msgid "A conflict occurs if both `<current-file>` and `<other-file>` have changes in a common segment of lines. If a conflict is found, 'git merge-file' normally outputs a warning and brackets the conflict with lines containing <<<<<<< and >>>>>>> markers. A typical conflict will look like this:"
msgstr ""

#. type: Plain text
#: en/git-merge-file.txt:36
#, no-wrap, priority:90
msgid ""
"\t<<<<<<< A\n"
"\tlines in file A\n"
"\t=======\n"
"\tlines in file B\n"
"\t>>>>>>> B\n"
msgstr ""

#. type: Plain text
#: en/git-merge-file.txt:42
#, priority:90
msgid "If there are conflicts, the user should edit the result and delete one of the alternatives.  When `--ours`, `--theirs`, or `--union` option is in effect, however, these conflicts are resolved favouring lines from `<current-file>`, lines from `<other-file>`, or lines from both respectively.  The length of the conflict markers can be given with the `--marker-size` option."
msgstr ""

#. type: Plain text
#: en/git-merge-file.txt:46
#, priority:90
msgid "The exit value of this program is negative on error, and the number of conflicts otherwise (truncated to 127 if there are more than that many conflicts). If the merge was clean, the exit value is 0."
msgstr ""

#. type: Plain text
#: en/git-merge-file.txt:50
#, priority:90
msgid "'git merge-file' is designed to be a minimal clone of RCS 'merge'; that is, it implements all of RCS 'merge''s functionality which is needed by linkgit:git[1]."
msgstr ""

#. type: Labeled list
#: en/git-merge-file.txt:55
#, fuzzy, no-wrap, priority:90
msgid "-L <label>"
msgstr "-L <label>"

#. type: Plain text
#: en/git-merge-file.txt:62
#, priority:90
msgid "This option may be given up to three times, and specifies labels to be used in place of the corresponding file names in conflict reports. That is, `git merge-file -L x -L y -L z a b c` generates output that looks like it came from files x, y and z instead of from files a, b and c."
msgstr ""

#. type: Plain text
#: en/git-merge-file.txt:66
#, priority:90
msgid "Send results to standard output instead of overwriting `<current-file>`."
msgstr ""

#. type: Plain text
#: en/git-merge-file.txt:69
#, priority:90
msgid "Quiet; do not warn about conflicts."
msgstr ""

#. type: Labeled list
#: en/git-merge-file.txt:70
#, ignore-same, no-wrap, priority:90
msgid "--diff3"
msgstr "--diff3"

#. type: Plain text
#: en/git-merge-file.txt:72
#, priority:90
msgid "Show conflicts in \"diff3\" style."
msgstr ""

#. type: Labeled list
#: en/git-merge-file.txt:73
#, ignore-same, no-wrap, priority:90
msgid "--zdiff3"
msgstr "--zdiff3"

#. type: Plain text
#: en/git-merge-file.txt:75
#, priority:90
msgid "Show conflicts in \"zdiff3\" style."
msgstr ""

#. type: Labeled list
#: en/git-merge-file.txt:78
#, ignore-same, no-wrap, priority:90
msgid "--union"
msgstr "--union"

#. type: Plain text
#: en/git-merge-file.txt:81
#, priority:90
msgid "Instead of leaving conflicts in the file, resolve conflicts favouring our (or their or both) side of the lines."
msgstr ""

#. type: Labeled list
#: en/git-merge-file.txt:86
#, no-wrap, priority:90
msgid "`git merge-file README.my README README.upstream`"
msgstr ""

#. type: Plain text
#: en/git-merge-file.txt:90
#, priority:90
msgid "combines the changes of README.my and README.upstream since README, tries to merge them and writes the result into README.my."
msgstr ""

#. type: Labeled list
#: en/git-merge-file.txt:91
#, no-wrap, priority:90
msgid "`git merge-file -L a -L b -L c tmp/a123 tmp/b234 tmp/c345`"
msgstr ""

#. type: Plain text
#: en/git-merge-file.txt:95
#, priority:90
msgid "merges tmp/a123 and tmp/c345 with the base tmp/b234, but uses labels `a` and `c` instead of `tmp/a123` and `tmp/c345`."
msgstr ""

#. type: Title =
#: en/git-merge-index.txt:2
#, ignore-same, no-wrap, priority:90
msgid "git-merge-index(1)"
msgstr "git-merge-index(1)"

#. type: Plain text
#: en/git-merge-index.txt:7
#, fuzzy, priority:90
msgid "git-merge-index - Run a merge for files needing merging"
msgstr "git-merge-index - Run a merge for files needing merging"

#. type: Plain text
#: en/git-merge-index.txt:13
#, fuzzy, ignore-ellipsis, no-wrap, priority:90
msgid "'git merge-index' [-o] [-q] <merge-program> (-a | ( [--] <file>...) )\n"
msgstr "'git merge-index' [-o] [-q] <merge-program> (-a | [--] <file>*)\n"

#. type: Plain text
#: en/git-merge-index.txt:20
#, priority:90
msgid "This looks up the <file>(s) in the index and, if there are any merge entries, passes the SHA-1 hash for those files as arguments 1, 2, 3 (empty argument if no file), and <file> as argument 4.  File modes for the three files are passed as arguments 5, 6 and 7."
msgstr ""

#. type: Plain text
#: en/git-merge-index.txt:28
#, priority:90
msgid "Run merge against all files in the index that need merging."
msgstr ""

#. type: Plain text
#: en/git-merge-index.txt:34
#, priority:90
msgid "Instead of stopping at the first failed merge, do all of them in one shot - continue with merging even when previous merges returned errors, and only return the error code after all the merges."
msgstr ""

#. type: Plain text
#: en/git-merge-index.txt:39
#, priority:90
msgid "Do not complain about a failed merge program (a merge program failure usually indicates conflicts during the merge). This is for porcelains which might want to emit custom messages."
msgstr ""

#. type: Plain text
#: en/git-merge-index.txt:43
#, priority:90
msgid "If 'git merge-index' is called with multiple <file>s (or -a) then it processes them in turn only stopping if merge returns a non-zero exit code."
msgstr ""

#. type: Plain text
#: en/git-merge-index.txt:46
#, priority:90
msgid "Typically this is run with a script calling Git's imitation of the 'merge' command from the RCS package."
msgstr ""

#. type: Plain text
#: en/git-merge-index.txt:49
#, priority:90
msgid "A sample script called 'git merge-one-file' is included in the distribution."
msgstr ""

#. type: Plain text
#: en/git-merge-index.txt:54
#, priority:90
msgid "ALERT ALERT ALERT! The Git \"merge object order\" is different from the RCS 'merge' program merge object order. In the above ordering, the original is first. But the argument order to the 3-way merge program 'merge' is to have the original in the middle. Don't ask me why."
msgstr ""

#. type: Plain text
#: en/git-merge-index.txt:56 en/git-svn.txt:171
#, fuzzy, priority:100
msgid "Examples:"
msgstr "实例："

#. type: delimited block -
#: en/git-merge-index.txt:63
#, no-wrap, priority:90
msgid ""
"torvalds@ppc970:~/merge-test> git merge-index cat MM\n"
"This is MM from the original tree.\t\t# original\n"
"This is modified MM in the branch A.\t\t# merge1\n"
"This is modified MM in the branch B.\t\t# merge2\n"
"This is modified MM in the branch B.\t\t# current contents\n"
msgstr ""

#. type: delimited block -
#: en/git-merge-index.txt:74
#, fuzzy, no-wrap, priority:90
msgid ""
"torvalds@ppc970:~/merge-test> git merge-index cat AA MM\n"
"cat: : No such file or directory\n"
"This is added AA in the branch A.\n"
"This is added AA in the branch B.\n"
"This is added AA in the branch B.\n"
"fatal: merge program failed\n"
msgstr ""
"torvalds@ppc970:~/merge-test> git merge-index cat AA MM\n"
"cat: : No such file or directory\n"
"This is added AA in the branch A.\n"
"This is added AA in the branch B.\n"
"This is added AA in the branch B.\n"
"fatal: merge program failed\n"

#. type: Plain text
#: en/git-merge-index.txt:80
#, priority:90
msgid "where the latter example shows how 'git merge-index' will stop trying to merge once anything has returned an error (i.e., `cat` returned an error for the AA file, because it didn't exist in the original, and thus 'git merge-index' didn't even try to merge the MM thing)."
msgstr ""

#. type: Title =
#: en/git-merge-one-file.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-merge-one-file(1)"
msgstr "git-merge-one-file(1)"

#. type: Plain text
#: en/git-merge-one-file.txt:7
#, priority:100
msgid "git-merge-one-file - The standard helper program to use with git-merge-index"
msgstr "git-merge-one-file - 与 git-merge-index 一起使用的标准辅助程序。"

#. type: Plain text
#: en/git-merge-one-file.txt:13
#, fuzzy, no-wrap, priority:100
msgid "'git merge-one-file'\n"
msgstr "'git merge-one-file'\n"

#. type: Plain text
#: en/git-merge-one-file.txt:18
#, priority:100
msgid "This is the standard helper program to use with 'git merge-index' to resolve a merge after the trivial merge done with 'git read-tree -m'."
msgstr "这是标准的辅助程序，与 'git merge-index' 一起使用，以解决用 'git read-tree -m' 进行的琐碎合并后的合并问题。"

#. type: Title =
#: en/git-mergetool--lib.txt:2
#, no-wrap, priority:100
msgid "git-mergetool{litdd}lib(1)"
msgstr "git-mergetool{litdd}lib(1)"

#. type: Plain text
#: en/git-mergetool--lib.txt:7
#, priority:100
msgid "git-mergetool--lib - Common Git merge tool shell scriptlets"
msgstr "git-mergetool--lib - 常见的 Git 合并工具壳 shell 脚本程序"

#. type: Plain text
#: en/git-mergetool--lib.txt:12
#, fuzzy, no-wrap, priority:100
msgid "'TOOL_MODE=(diff|merge) . \"$(git --exec-path)/git-mergetool{litdd}lib\"'\n"
msgstr "'TOOL_MODE=(diff|merge) . \"$(git --exec-path)/git-mergetool{litdd}lib\"'\n"

#. type: Plain text
#: en/git-mergetool--lib.txt:19 en/git-sh-i18n.txt:19 en/git-sh-setup.txt:19
#, priority:100
msgid "This is not a command the end user would want to run.  Ever.  This documentation is meant for people who are studying the Porcelain-ish scripts and/or are writing new ones."
msgstr "这不是一个终端用户想要运行的命令。 永远不会。 这个文档是为研究 Porcelain-ish 脚本和/或正在编写新脚本的人准备的。"

#. type: Plain text
#: en/git-mergetool--lib.txt:23
#, priority:100
msgid "The 'git-mergetool{litdd}lib' scriptlet is designed to be sourced (using `.`) by other shell scripts to set up functions for working with Git merge tools."
msgstr "'git-mergetool{litdd}lib' 脚本被设计成可以被其他 shell 脚本引用（使用 `.`），以设置与 Git 合并工具一起工作的功能。"

#. type: Plain text
#: en/git-mergetool--lib.txt:27
#, priority:100
msgid "Before sourcing 'git-mergetool{litdd}lib', your script must set `TOOL_MODE` to define the operation mode for the functions listed below.  'diff' and 'merge' are valid values."
msgstr "在链接到 'git-mergetool{litdd}lib' 之前，你的脚本必须设置 `TOOL_MODE` 来定义下列函数的操作模式。 'diff' 和 'merge'是有效值。"

#. type: Title -
#: en/git-mergetool--lib.txt:29 en/git-sh-i18n.txt:28 en/git-sh-setup.txt:34
#, fuzzy, no-wrap, priority:100
msgid "FUNCTIONS"
msgstr "功能"

#. type: Labeled list
#: en/git-mergetool--lib.txt:30
#, no-wrap, priority:100
msgid "get_merge_tool"
msgstr "get_merge_tool"

#. type: Plain text
#: en/git-mergetool--lib.txt:34
#, priority:100
msgid "returns a merge tool. the return code is 1 if we returned a guessed merge tool, else 0. '$GIT_MERGETOOL_GUI' may be set to 'true' to search for the appropriate guitool."
msgstr "返回一个合并工具。如果我们返回一个被猜中的合并工具，返回代码为 1，否则为0。'$GIT_MERGETOOL_GUI' 可以被设置为 'true' 以搜索合适的 guitool。"

#. type: Labeled list
#: en/git-mergetool--lib.txt:35
#, no-wrap, priority:100
msgid "get_merge_tool_cmd"
msgstr "get_merge_tool_cmd"

#. type: Plain text
#: en/git-mergetool--lib.txt:37
#, priority:100
msgid "returns the custom command for a merge tool."
msgstr "返回一个合并工具的自定义命令。"

#. type: Labeled list
#: en/git-mergetool--lib.txt:38
#, no-wrap, priority:100
msgid "get_merge_tool_path"
msgstr "get_merge_tool_path"

#. type: Plain text
#: en/git-mergetool--lib.txt:40
#, priority:100
msgid "returns the custom path for a merge tool."
msgstr "返回一个合并工具的自定义路径。"

#. type: Labeled list
#: en/git-mergetool--lib.txt:41
#, fuzzy, no-wrap, priority:100
msgid "initialize_merge_tool"
msgstr "run_merge_tool"

#. type: Plain text
#: en/git-mergetool--lib.txt:44
#, priority:100
msgid "bring merge tool specific functions into scope so they can be used or overridden."
msgstr "将合并工具的特定函数带入范围，以便它们可以被使用或重写。"

#. type: Labeled list
#: en/git-mergetool--lib.txt:45
#, fuzzy, no-wrap, priority:100
msgid "run_merge_tool"
msgstr "run_merge_tool"

#. type: Plain text
#: en/git-mergetool--lib.txt:50
#, priority:100
msgid "launches a merge tool given the tool name and a true/false flag to indicate whether a merge base is present.  '$MERGED', '$LOCAL', '$REMOTE', and '$BASE' must be defined for use by the merge tool."
msgstr "启动一个合并工具，给定工具名称和一个 true/false 标志，表示是否存在一个合并基础。 $MERGED'， '$LOCAL'，'$REMOTE' 和 '$BASE' 必须被定义，以便由合并工具使用。"

#. type: Title =
#: en/git-mergetool.txt:2
#, ignore-same, no-wrap, priority:240
msgid "git-mergetool(1)"
msgstr "git-mergetool(1)"

#. type: Plain text
#: en/git-mergetool.txt:7
#, fuzzy, priority:240
msgid "git-mergetool - Run merge conflict resolution tools to resolve merge conflicts"
msgstr "git-mergetool - Run merge conflict resolution tools to resolve merge conflicts"

#. type: Plain text
#: en/git-mergetool.txt:12
#, ignore-ellipsis, no-wrap, priority:240
msgid "'git mergetool' [--tool=<tool>] [-y | --[no-]prompt] [<file>...]\n"
msgstr "'git mergetool' [--tool=<工具>] [-y |-[no-]prompt] [<文件>...] 。\n"

#. type: Plain text
#: en/git-mergetool.txt:18
#, priority:240
msgid "Use `git mergetool` to run one of several merge utilities to resolve merge conflicts.  It is typically run after 'git merge'."
msgstr "使用`git mergetool`来运行几个合并工具中的一个来解决合并冲突。  它通常在 \"git merge \"之后运行。"

#. type: Plain text
#: en/git-mergetool.txt:24
#, priority:240
msgid "If one or more <file> parameters are given, the merge tool program will be run to resolve differences on each file (skipping those without conflicts).  Specifying a directory will include all unresolved files in that path.  If no <file> names are specified, 'git mergetool' will run the merge tool program on every file with merge conflicts."
msgstr "如果给出一个或多个<文件>参数，合并工具程序会运行以解决每个文件的差异（跳过那些没有冲突的文件）。  指定一个目录将包括该路径中所有未解决的文件。  如果没有指定<文件>名称，'git mergetool'将对每个有合并冲突的文件运行合并工具程序。"

#. type: Plain text
#: en/git-mergetool.txt:33
#, priority:240
msgid "Use the merge resolution program specified by <tool>.  Valid values include emerge, gvimdiff, kdiff3, meld, vimdiff, and tortoisemerge. Run `git mergetool --tool-help` for the list of valid <tool> settings."
msgstr "使用由<工具>指定的合并解决程序。  有效值包括 emerge、gvimdiff、kdiff3、meld、vimdiff 和 tortoisemerge。运行`git mergetool --tool-help`以获得有效的<工具>设置列表。"

#. type: Plain text
#: en/git-mergetool.txt:38
#, priority:240
msgid "If a merge resolution program is not specified, 'git mergetool' will use the configuration variable `merge.tool`.  If the configuration variable `merge.tool` is not set, 'git mergetool' will pick a suitable default."
msgstr "如果没有指定合并解决程序，'git mergetool'将使用配置变量`merge.tool`。  如果配置变量`merge.tool`没有设置，'git mergetool'将自行挑选一个合适的程序。"

#. type: Plain text
#: en/git-mergetool.txt:44
#, priority:240
msgid "You can explicitly provide a full path to the tool by setting the configuration variable `mergetool.<tool>.path`. For example, you can configure the absolute path to kdiff3 by setting `mergetool.kdiff3.path`. Otherwise, 'git mergetool' assumes the tool is available in PATH."
msgstr "你可以通过设置配置变量`mergetool.<工具>.path`来明确提供工具的完整路径。例如，你可以通过设置`mergetool.kdiff3.path`来配置kdiff3的绝对路径。否则，\"git mergetool\"会假定该工具在PATH中配置过。"

#. type: Plain text
#: en/git-mergetool.txt:49
#, priority:240
msgid "Instead of running one of the known merge tool programs, 'git mergetool' can be customized to run an alternative program by specifying the command line to invoke in a configuration variable `mergetool.<tool>.cmd`."
msgstr "通过在配置变量`mergetool.<工具>.cmd`中指定调用的命令行，'git mergetool'可以代替运行一个已知的合并工具程序，从而指定运行另一个程序。"

#. type: Plain text
#: en/git-mergetool.txt:60
#, priority:240
msgid "When 'git mergetool' is invoked with this tool (either through the `-t` or `--tool` option or the `merge.tool` configuration variable) the configured command line will be invoked with `$BASE` set to the name of a temporary file containing the common base for the merge, if available; `$LOCAL` set to the name of a temporary file containing the contents of the file on the current branch; `$REMOTE` set to the name of a temporary file containing the contents of the file to be merged, and `$MERGED` set to the name of the file to which the merge tool should write the result of the merge resolution."
msgstr "当'git mergetool'与该工具一起被调用时（通过`-t`或`--tool`选项或`merge.tool`配置变量），配置的命令行将被调用，`$BASE`被设置为临时文件的名称，包含合并的共同基础（如果有的话）；`$LOCAL`被设置为包含当前分支上的文件内容的临时文件名称；`$REMOTE`被设置为包含要合并文件内容的临时文件名称，以及合并工具应该将合并的结果写入`$MERGED`设置的文件中。"

#. type: Plain text
#: en/git-mergetool.txt:66
#, priority:240
msgid "If the custom merge tool correctly indicates the success of a merge resolution with its exit code, then the configuration variable `mergetool.<tool>.trustExitCode` can be set to `true`.  Otherwise, 'git mergetool' will prompt the user to indicate the success of the resolution after the custom tool has exited."
msgstr "如果自定义合并工具能够正确地用其退出代码指示合并成功，那么配置变量`mergetool.<工具>.trustExitCode`可以被设置为`true`。  否则，'git mergetool'将在用户在自定义工具退出后表明解决成功。"

#. type: Plain text
#: en/git-mergetool.txt:69
#, priority:240
msgid "Print a list of merge tools that may be used with `--tool`."
msgstr "打印出可以和\"--tool\"命令一起使用的merge工具列表。"

#. type: Plain text
#: en/git-mergetool.txt:77
#, priority:240
msgid "Don't prompt before each invocation of the merge resolution program.  This is the default if the merge resolution program is explicitly specified with the `--tool` option or with the `merge.tool` configuration variable."
msgstr "在每次调用合并解决程序之前不会提示。  如果用`--tool`选项或`merge.tool`配置变量明确指定了合并解决程序，默认就是这种做法。"

#. type: Plain text
#: en/git-mergetool.txt:81
#, priority:240
msgid "Prompt before each invocation of the merge resolution program to give the user a chance to skip the path."
msgstr "在每次调用合并解决程序前提示，让用户有机会跳过该路径。"

#. type: Labeled list
#: en/git-mergetool.txt:83
#, ignore-same, no-wrap, priority:240
msgid "--gui"
msgstr "--gui"

#. type: Plain text
#: en/git-mergetool.txt:90
#, fuzzy, priority:240
#| msgid "When 'git-mergetool' is invoked with the `-g` or `--gui` option the default merge tool will be read from the configured `merge.guitool` variable instead of `merge.tool`. If `merge.guitool` is not set, we will fallback to the tool configured under `merge.tool`."
msgid "When 'git-mergetool' is invoked with the `-g` or `--gui` option the default merge tool will be read from the configured `merge.guitool` variable instead of `merge.tool`. If `merge.guitool` is not set, we will fallback to the tool configured under `merge.tool`. This may be autoselected using the configuration variable `mergetool.guiDefault`."
msgstr "当'git-mergetool'以`-g`或`--gui`选项调用时，默认的合并工具将从配置的`merge.guitool`变量读取，而不是`merge.tool`。如果`merge.guitool`没有设置，git将会使用`merge.tool`配置的工具。"

#. type: Labeled list
#: en/git-mergetool.txt:91
#, ignore-same, no-wrap, priority:240
msgid "--no-gui"
msgstr "--no-gui"

#. type: Plain text
#: en/git-mergetool.txt:95
#, fuzzy, priority:240
#| msgid "This overrides a previous `-g` or `--gui` setting and reads the default merge tool will be read from the configured `merge.tool` variable."
msgid "This overrides a previous `-g` or `--gui` setting or `mergetool.guiDefault` configuration and reads the default merge tool from the configured `merge.tool` variable."
msgstr "这将覆盖之前的`-g`或`-gui`设置，并将从配置的`merge.tool`变量读取默认的合并工具。"

#. type: Plain text
#: en/git-mergetool.txt:102
#, priority:240
msgid "Process files in the order specified in the <orderfile>, which has one shell glob pattern per line.  This overrides the `diff.orderFile` configuration variable (see linkgit:git-config[1]).  To cancel `diff.orderFile`, use `-O/dev/null`."
msgstr "按照 <顺序文件> 中指定的顺序处理文件，每行有一个 shell匹配模式。  这会覆盖 `diff.orderFile` 配置的变量（见 linkgit:git-config[1]）。  可以使用使用 `-O/dev/null`取消 `diff.orderFile`。"

#. type: Title -
#: en/git-mergetool.txt:112
#, no-wrap, priority:240
msgid "TEMPORARY FILES"
msgstr "临时文件"

#. type: Plain text
#: en/git-mergetool.txt:116
#, priority:240
msgid "`git mergetool` creates `*.orig` backup files while resolving merges.  These are safe to remove once a file has been merged and its `git mergetool` session has completed."
msgstr "`git mergetool`在解决合并问题时创建`*.orig`备份文件。  一旦文件被合并，并且其`git mergetool`会话完成，这些文件就可以安全地删除。"

#. type: Plain text
#: en/git-mergetool.txt:120
#, priority:240
msgid "Setting the `mergetool.keepBackup` configuration variable to `false` causes `git mergetool` to automatically remove the backup as files are successfully merged."
msgstr "将`mergetool.keepBackup`配置变量设置为`false`会使`git mergetool`在文件成功合并后自动删除备份。"

#. type: Title -
#: en/git-mergetool.txt:122
#, fuzzy, no-wrap, priority:240
msgid "BACKEND SPECIFIC HINTS"
msgstr "后端特定提示"

#. type: Title ~
#: en/git-mergetool.txt:125
#, ignore-same, no-wrap, priority:240
msgid "vimdiff"
msgstr "vimdiff"

#. type: Title =
#: en/git-merge-tree.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-merge-tree(1)"
msgstr "git-merge-tree(1)"

#. type: Plain text
#: en/git-merge-tree.txt:7
#, fuzzy, priority:100
msgid "git-merge-tree - Perform merge without touching index or working tree"
msgstr "git-merge-tree - Show three-way merge without touching index"

#. type: Plain text
#: en/git-merge-tree.txt:14
#, no-wrap, priority:100
msgid ""
"'git merge-tree' [--write-tree] [<options>] <branch1> <branch2>\n"
"'git merge-tree' [--trivial-merge] <base-tree> <branch1> <branch2> (deprecated)\n"
msgstr ""
"'git merge-tree' [--write-tree] [<options>] <branch1> <branch2>\n"
"'git merge-tree' [--trivial-merge] <base-tree> <branch1> <branch2> (deprecated)\n"

#. type: Plain text
#: en/git-merge-tree.txt:23
#, fuzzy, priority:100
msgid "This command has a modern `--write-tree` mode and a deprecated `--trivial-merge` mode.  With the exception of the <<DEPMERGE,DEPRECATED DESCRIPTION>> section at the end, the rest of this documentation describes modern `--write-tree` mode."
msgstr " "

#. type: Plain text
#: en/git-merge-tree.txt:26
#, priority:100
msgid "Performs a merge, but does not make any new commits and does not read from or write to either the working tree or index."
msgstr "执行合并，但不做任何新的提交，也不从工作区或索引中读取或写入。"

#. type: Plain text
#: en/git-merge-tree.txt:29
#, priority:100
msgid "The performed merge will use the same feature as the \"real\" linkgit:git-merge[1], including:"
msgstr "执行的合并将使用与 “真正的” linkgit:git-merge[1] 相同的功能，包括："

#. type: Plain text
#: en/git-merge-tree.txt:31
#, priority:100
msgid "three way content merges of individual files"
msgstr "单个文件的多路合并"

#. type: Plain text
#: en/git-merge-tree.txt:32
#, fuzzy, priority:100
#| msgid "--rename-section"
msgid "rename detection"
msgstr "--rename-section"

#. type: Plain text
#: en/git-merge-tree.txt:33
#, priority:100
msgid "proper directory/file conflict handling"
msgstr "正确处理目录/文件冲突"

#. type: Plain text
#: en/git-merge-tree.txt:35
#, priority:100
msgid "recursive ancestor consolidation (i.e. when there is more than one merge base, creating a virtual merge base by merging the merge bases)"
msgstr "递归祖先合并（即当有一个以上的合并基数时，通过合并基数创建一个虚拟合并基数）。"

#. type: Plain text
#: en/git-merge-tree.txt:36
#, priority:100
msgid "etc."
msgstr "等等。"

#. type: Plain text
#: en/git-merge-tree.txt:39
#, priority:100
msgid "After the merge completes, a new toplevel tree object is created.  See `OUTPUT` below for details."
msgstr "合并完成后，会创建一个新的顶层树对象。 详见下面的 “输出”。"

#. type: Plain text
#: en/git-merge-tree.txt:48
#, priority:100
msgid "Do not quote filenames in the <Conflicted file info> section, and end each filename with a NUL character rather than newline.  Also begin the messages section with a NUL character instead of a newline.  See <<OUTPUT>> below for more information."
msgstr "在 <冲突文件信息> 部分不要引用文件名，每个文件名用 NUL 字符而不是换行来结束。 在信息部分也要用 NUL 字符而不是换行来开始。 更多信息见下面的 <<OUTPUT>>。"

#. type: Plain text
#: en/git-merge-tree.txt:55
#, priority:100
msgid "In the Conflicted file info section, instead of writing a list of (mode, oid, stage, path) tuples to output for conflicted files, just provide a list of filenames with conflicts (and do not list filenames multiple times if they have multiple conflicting stages)."
msgstr "在冲突的文件信息部分，不要为冲突的文件写一个（mode, oid, stage, path）图元列表来输出，只需提供一个有冲突的文件名列表（如果文件有多个冲突的阶段，不多次列出文件名）。"

#. type: Labeled list
#: en/git-merge-tree.txt:56
#, ignore-same, no-wrap, priority:100
msgid "--[no-]messages"
msgstr "--[no-]messages"

#. type: Plain text
#: en/git-merge-tree.txt:61
#, priority:100
msgid "Write any informational messages such as \"Auto-merging <path>\" or CONFLICT notices to the end of stdout.  If unspecified, the default is to include these messages if there are merge conflicts, and to omit them otherwise."
msgstr "将任何信息性的消息，如\"Auto-merging <path>\" 或冲突通知写到标准输出流的末尾。 如果没有指定，默认情况下，如果有合并冲突，就包括这些信息，否则就省略它们。"

#. type: Labeled list
#: en/git-merge-tree.txt:62 en/merge-options.txt:200
#, ignore-same, no-wrap, priority:240
msgid "--allow-unrelated-histories"
msgstr "--allow-unrelated-histories"

#. type: Plain text
#: en/git-merge-tree.txt:66
#, priority:100
msgid "merge-tree will by default error out if the two branches specified share no common history.  This flag can be given to override that check and make the merge proceed anyway."
msgstr "如果指定的两个分支没有共同的历史，merge-tree 默认会出错。 这个标志可以用来覆盖这个检查，并使合并继续进行。"

#. type: Labeled list
#: en/git-merge-tree.txt:67
#, fuzzy, no-wrap, priority:100
msgid "--merge-base=<commit>"
msgstr "--merged [<commit>]"

#. type: Plain text
#: en/git-merge-tree.txt:71
#, priority:100
msgid "Instead of finding the merge-bases for <branch1> and <branch2>, specify a merge-base for the merge, and specifying multiple bases is currently not supported. This option is incompatible with `--stdin`."
msgstr "不需要为 <branch1> 和 <branch2> 寻找合并基础，而是为合并指定一个合并基础，目前不支持指定多个合并基础。该选项与 `--stdin` 不兼容。"

#. type: Plain text
#: en/git-merge-tree.txt:78
#, priority:100
msgid "For a successful merge, the output from git-merge-tree is simply one line:"
msgstr "对于一个成功的合并，git-merge-tree 的输出仅仅是一行："

#. type: Plain text
#: en/git-merge-tree.txt:80
#, no-wrap, priority:100
msgid "\t<OID of toplevel tree>\n"
msgstr "\t<OID of toplevel tree>\n"

#. type: Plain text
#: en/git-merge-tree.txt:82
#, priority:100
msgid "Whereas for a conflicted merge, the output is by default of the form:"
msgstr "而对于有冲突的合并，默认的输出形式是："

#. type: Plain text
#: en/git-merge-tree.txt:86
#, no-wrap, priority:100
msgid ""
"\t<OID of toplevel tree>\n"
"\t<Conflicted file info>\n"
"\t<Informational messages>\n"
msgstr ""
"\t<OID of toplevel tree>\n"
"\t<Conflicted file info>\n"
"\t<Informational messages>\n"

#. type: Plain text
#: en/git-merge-tree.txt:88
#, priority:100
msgid "These are discussed individually below."
msgstr "下面将分别讨论这些问题。"

#. type: Plain text
#: en/git-merge-tree.txt:93
#, priority:100
msgid "However, there is an exception.  If `--stdin` is passed, then there is an extra section at the beginning, a NUL character at the end, and then all the sections repeat for each line of input.  Thus, if the first merge is conflicted and the second is clean, the output would be of the form:"
msgstr "然而，有一个例外。 如果通过了 `--stdin`，那么在开头有一个额外的部分，在结尾有一个 NUL 字符，然后所有的部分在每行输入中都会重复。 因此，如果第一次合并是冲突的，而第二次是干净的，输出将是这样的形式："

#. type: Plain text
#: en/git-merge-tree.txt:102
#, no-wrap, priority:100
msgid ""
"\t<Merge status>\n"
"\t<OID of toplevel tree>\n"
"\t<Conflicted file info>\n"
"\t<Informational messages>\n"
"\tNUL\n"
"\t<Merge status>\n"
"\t<OID of toplevel tree>\n"
"\tNUL\n"
msgstr ""
"\t<Merge status>\n"
"\t<OID of toplevel tree>\n"
"\t<Conflicted file info>\n"
"\t<Informational messages>\n"
"\tNUL\n"
"\t<Merge status>\n"
"\t<OID of toplevel tree>\n"
"\tNUL\n"

#. type: Title ~
#: en/git-merge-tree.txt:105
#, fuzzy, no-wrap, priority:100
#| msgid "merge.stat"
msgid "Merge status"
msgstr "merge.stat"

#. type: Plain text
#: en/git-merge-tree.txt:108
#, priority:100
msgid "This is an integer status followed by a NUL character.  The integer status is:"
msgstr "这是一个整数状态，后面有一个 NUL 字符。 整数状态是："

#. type: Plain text
#: en/git-merge-tree.txt:113
#, no-wrap, priority:100
msgid ""
"     0: merge had conflicts\n"
"     1: merge was clean\n"
"     <0: something prevented the merge from running (e.g. access to repository\n"
"\t objects denied by filesystem)\n"
msgstr ""
"     0：合并后有冲突\n"
"     1： 合并是干净的\n"
"     <0：有什么东西阻止了合并的运行（例如，文件系统拒绝对仓库对象的访问\n"
"\t 对象的访问被文件系统拒绝)\n"

#. type: Title ~
#: en/git-merge-tree.txt:116
#, no-wrap, priority:100
msgid "OID of toplevel tree"
msgstr "顶层目录树的 OID"

#. type: Plain text
#: en/git-merge-tree.txt:122
#, priority:100
msgid "This is a tree object that represents what would be checked out in the working tree at the end of `git merge`.  If there were conflicts, then files within this tree may have embedded conflict markers.  This section is always followed by a newline (or NUL if `-z` is passed)."
msgstr "这是一个树状对象，代表在`git merge` 结束时工作区上检查出来的东西。 如果有冲突，那么这个目录树中的文件可能会有嵌入式冲突标记。 这一部分的后面总是有一个换行符（如果传递了 `-z` 则为 NUL）。"

#. type: Title ~
#: en/git-merge-tree.txt:125
#, no-wrap, priority:100
msgid "Conflicted file info"
msgstr "冲突的文件信息"

#. type: Plain text
#: en/git-merge-tree.txt:128
#, priority:100
msgid "This is a sequence of lines with the format"
msgstr "这是一连串的行，格式为"

#. type: Plain text
#: en/git-merge-tree.txt:130
#, no-wrap, priority:100
msgid "\t<mode> <object> <stage> <filename>\n"
msgstr "\t<mode> <object> <stage> <filename>\n"

#. type: Plain text
#: en/git-merge-tree.txt:136
#, fuzzy, priority:100
msgid "The filename will be quoted as explained for the configuration variable `core.quotePath` (see linkgit:git-config[1]).  However, if the `--name-only` option is passed, the mode, object, and stage will be omitted.  If `-z` is passed, the \"lines\" are terminated by a NUL character instead of a newline character."
msgstr "如果没有 `-z` 选项，带 \"不常见\" 字符的路径名会被加上引号，正如配置变量 \"core.quotePath\" 所解释的那样（参见 linkgit:git-config[1]）。  使用 `-z` 选项，文件名将被逐字输出，并以 NUL 字节结束。"

#. type: Title ~
#: en/git-merge-tree.txt:139
#, fuzzy, no-wrap, priority:100
msgid "Informational messages"
msgstr "信息"

#. type: Plain text
#: en/git-merge-tree.txt:144
#, priority:100
msgid "This section provides informational messages, typically about conflicts.  The format of the section varies significantly depending on whether `-z` is passed."
msgstr "这一部分提供信息，通常是关于冲突的信息。 该部分的格式因是否传递了 `-z` 而有很大不同。"

#. type: Plain text
#: en/git-merge-tree.txt:146
#, priority:100
msgid "If `-z` is passed:"
msgstr "如果 `-z`被传递："

#. type: Plain text
#: en/git-merge-tree.txt:149
#, priority:100
msgid "The output format is zero or more conflict informational records, each of the form:"
msgstr "输出格式是零条或更多的冲突信息记录，每条记录的形式都是："

#. type: Plain text
#: en/git-merge-tree.txt:151
#, no-wrap, priority:100
msgid "\t<list-of-paths><conflict-type>NUL<conflict-message>NUL\n"
msgstr "\t<list-of-paths><conflict-type>NUL<conflict-message>NUL\n"

#. type: Plain text
#: en/git-merge-tree.txt:153
#, priority:100
msgid "where <list-of-paths> is of the form"
msgstr "其中 <list-of-paths> 的形式为"

#. type: Plain text
#: en/git-merge-tree.txt:155
#, ignore-ellipsis, no-wrap, priority:100
msgid "\t<number-of-paths>NUL<path1>NUL<path2>NUL...<pathN>NUL\n"
msgstr "\t<number-of-paths>NUL<path1>NUL<path2>NUL...<pathN>NUL\n"

#. type: Plain text
#: en/git-merge-tree.txt:159
#, priority:100
msgid "and includes paths (or branch names) affected by the conflict or informational message in <conflict-message>.  Also, <conflict-type> is a stable string explaining the type of conflict, such as"
msgstr "并包括受冲突影响的路径（或分支名称）或 <conflict-message> 中的信息消息。 另外，<conflict-type> 是一个稳定的字符串，解释了冲突的类型，比如说"

#. type: Plain text
#: en/git-merge-tree.txt:161
#, fuzzy, priority:100
msgid "\"Auto-merging\""
msgstr "--series <file>"

#. type: Plain text
#: en/git-merge-tree.txt:162
#, priority:100
msgid "\"CONFLICT (rename/delete)\""
msgstr "\"CONFLICT (rename/delete)\""

#. type: Plain text
#: en/git-merge-tree.txt:163
#, priority:100
msgid "\"CONFLICT (submodule lacks merge base)\""
msgstr "\"CONFLICT (submodule lacks merge base)\""

#. type: Plain text
#: en/git-merge-tree.txt:164
#, priority:100
msgid "\"CONFLICT (binary)\""
msgstr "\"CONFLICT (binary)\""

#. type: Plain text
#: en/git-merge-tree.txt:168
#, priority:100
msgid "and <conflict-message> is a more detailed message about the conflict which often (but not always) embeds the <stable-short-type-description> within it.  These strings may change in future Git versions.  Some examples:"
msgstr "和 <conflict-message> 是关于冲突的更详细的信息，通常（但不一定）会嵌入 <stable-short-type-description> 中。 这些字符串在未来的Git版本中可能会改变。 一些例子："

#. type: Plain text
#: en/git-merge-tree.txt:170
#, fuzzy, priority:100
msgid "\"Auto-merging <file>\""
msgstr "--series <file>"

#. type: Plain text
#: en/git-merge-tree.txt:171
#, ignore-ellipsis, priority:100
msgid "\"CONFLICT (rename/delete): <oldfile> renamed...but deleted in...\""
msgstr "\"CONFLICT (rename/delete): <oldfile> 被重命名... 但在... 被删除。\""

#. type: Plain text
#: en/git-merge-tree.txt:172
#, priority:100
msgid "\"Failed to merge submodule <submodule> (no merge base)\""
msgstr "“合并子模块 <submodule> 失败（没有合并基础）”"

#. type: Plain text
#: en/git-merge-tree.txt:173
#, priority:100
msgid "\"Warning: cannot merge binary files: <filename>\""
msgstr "“警告：不能合并二进制文件： <filename>”"

#. type: Plain text
#: en/git-merge-tree.txt:175
#, priority:100
msgid "If `-z` is NOT passed:"
msgstr "如果没有传递 `-z`："

#. type: Plain text
#: en/git-merge-tree.txt:185
#, priority:100
msgid "This section starts with a blank line to separate it from the previous sections, and then only contains the <conflict-message> information from the previous section (separated by newlines).  These are non-stable strings that should not be parsed by scripts, and are just meant for human consumption.  Also, note that while <conflict-message> strings usually do not contain embedded newlines, they sometimes do.  (However, the free-form messages will never have an embedded NUL character).  So, the entire block of information is meant for human readers as an agglomeration of all conflict messages."
msgstr "这一节以空行开始，与前几节分开，然后只包含前一节的 <conflict-message> 信息（用换行符分开）。 这些是不稳定的字符串，不应该被脚本解析，只是为了供人使用。 另外，请注意，虽然 <conflict-message> 字符串通常不包含嵌入式换行符，但有时也会包含。 (然而，自由格式的信息永远不会有一个嵌入的 NUL 字符）。 所以，整个信息块是作为所有冲突信息的集合体提供给人类阅读的。"

#. type: Plain text
#: en/git-merge-tree.txt:196
#, priority:100
msgid "For a successful, non-conflicted merge, the exit status is 0.  When the merge has conflicts, the exit status is 1.  If the merge is not able to complete (or start) due to some kind of error, the exit status is something other than 0 or 1 (and the output is unspecified).  When --stdin is passed, the return status is 0 for both successful and conflicted merges, and something other than 0 or 1 if it cannot complete all the requested merges."
msgstr "如果合并成功，没有冲突，退出状态为 0；如果合并有冲突，退出状态为 1；如果合并由于某种错误而无法完成（或开始），退出状态为 0 或 1 以外的内容（而且输出结果未指明）。 当传递 --stdin 时，对于成功的合并和有冲突的合并，返回状态都是 0，如果不能完成所有要求的合并，则返回 0 或 1 以外的其他状态。"

#. type: Title -
#: en/git-merge-tree.txt:198
#, fuzzy, no-wrap, priority:100
msgid "USAGE NOTES"
msgstr "注释"

#. type: Plain text
#: en/git-merge-tree.txt:205
#, priority:100
msgid "This command is intended as low-level plumbing, similar to linkgit:git-hash-object[1], linkgit:git-mktree[1], linkgit:git-commit-tree[1], linkgit:git-write-tree[1], linkgit:git-update-ref[1], and linkgit:git-mktag[1].  Thus, it can be used as a part of a series of steps such as:"
msgstr "这个命令旨在作为低级的底层命令，类似于 linkgit:git-hash-object[1]，linkgit:git-mktree[1]， linkgit:git-commit-tree[1]， linkgit:git-write-tree[1]，linkgit:git-update-ref[1] 和 linkgit:git-mktag[1]。 因此，它可以作为一系列步骤的一部分来使用，比如："

#. type: Plain text
#: en/git-merge-tree.txt:210
#, ignore-ellipsis, no-wrap, priority:100
msgid ""
"       NEWTREE=$(git merge-tree --write-tree $BRANCH1 $BRANCH2)\n"
"       test $? -eq 0 || die \"There were conflicts...\"\n"
"       NEWCOMMIT=$(git commit-tree $NEWTREE -p $BRANCH1 -p $BRANCH2)\n"
"       git update-ref $BRANCH1 $NEWCOMMIT\n"
msgstr ""
"       NEWTREE=$(git merge-tree --write-tree $BRANCH1 $BRANCH2)\n"
"       test $? -eq 0 || die \"There were conflicts...\"\n"
"       NEWCOMMIT=$(git commit-tree $NEWTREE -p $BRANCH1 -p $BRANCH2)\n"
"       git update-ref $BRANCH1 $NEWCOMMIT\n"

#. type: Plain text
#: en/git-merge-tree.txt:213
#, priority:100
msgid "Note that when the exit status is non-zero, `NEWTREE` in this sequence will contain a lot more output than just a tree."
msgstr "注意，当退出状态为非零时，这个序列中的 `NEWTREE` 将包含很多输出，而不仅仅是一棵目录树。"

#. type: Plain text
#: en/git-merge-tree.txt:216
#, priority:100
msgid "For conflicts, the output includes the same information that you'd get with linkgit:git-merge[1]:"
msgstr "对于冲突，输出包括你用 linkgit:git-merge[1] 得到的相同信息："

#. type: Plain text
#: en/git-merge-tree.txt:219
#, priority:100
msgid "what would be written to the working tree (the <<OIDTLT,OID of toplevel tree>>)"
msgstr "什么会被写入工作区（<<OIDTLT,顶层目录树树的 OID>>）"

#. type: Plain text
#: en/git-merge-tree.txt:221
#, priority:100
msgid "the higher order stages that would be written to the index (the <<CFI,Conflicted file info>>)"
msgstr "将被写入索引的高阶阶段（<<CFI,冲突的文件信息>>）"

#. type: Plain text
#: en/git-merge-tree.txt:223
#, priority:100
msgid "any messages that would have been printed to stdout (the <<IM,Informational messages>>)"
msgstr "任何会被打印到标准输出流的信息（<<IM,信息性信息>>）。"

#. type: Plain text
#: en/git-merge-tree.txt:228
#, priority:100
msgid "'git merge-tree --stdin' input format is fully text based. Each line has this format:"
msgstr "'git merge-tree --stdin' 的输入格式是完全基于文本的。每一行都有这样的格式："

#. type: Plain text
#: en/git-merge-tree.txt:230
#, no-wrap, priority:100
msgid "\t[<base-commit> -- ]<branch1> <branch2>\n"
msgstr "\t[<基础提交> -- ]<分支1> <分支2>\n"

#. type: Plain text
#: en/git-merge-tree.txt:234
#, priority:100
msgid "If one line is separated by `--`, the string before the separator is used for specifying a merge-base for the merge and the string after the separator describes the branches to be merged."
msgstr "如果一行被 `--` 分隔，分隔符前的字符串用于指定合并的基础，分隔符后的字符串描述要合并的分支。"

#. type: Title -
#: en/git-merge-tree.txt:236
#, no-wrap, priority:100
msgid "MISTAKES TO AVOID"
msgstr "应避免的错误"

#. type: Plain text
#: en/git-merge-tree.txt:245
#, priority:100
msgid "Do NOT look through the resulting toplevel tree to try to find which files conflict; parse the <<CFI,Conflicted file info>> section instead.  Not only would parsing an entire tree be horrendously slow in large repositories, there are numerous types of conflicts not representable by conflict markers (modify/delete, mode conflict, binary file changed on both sides, file/directory conflicts, various rename conflict permutations, etc.)"
msgstr "不要在产生的顶层目录树中寻找哪些文件有冲突，而要解析 <<CFI,冲突文件信息>> 部分。 在大型存储库中，不仅解析整个目录树会慢得吓人，而且有许多冲突类型无法用冲突标记来表示（修改/删除，模式冲突，二进制文件在两边都有改变，文件/目录冲突，各种重命名冲突的变种，等等。）"

#. type: Plain text
#: en/git-merge-tree.txt:251
#, priority:100
msgid "Do NOT interpret an empty <<CFI,Conflicted file info>> list as a clean merge; check the exit status.  A merge can have conflicts without having individual files conflict (there are a few types of directory rename conflicts that fall into this category, and others might also be added in the future)."
msgstr "不要把一个空的 <<CFI,冲突文件信息>> 列表理解为一个干净的合并；检查退出状态。 一个合并可以有冲突而没有单个文件的冲突（有几种类型的目录重命名冲突属于这个类别，其他的也可能在将来被添加）。"

#. type: Plain text
#: en/git-merge-tree.txt:265
#, priority:100
msgid "Do NOT attempt to guess or make the user guess the conflict types from the <<CFI,Conflicted file info>> list.  The information there is insufficient to do so.  For example: Rename/rename(1to2) conflicts (both sides renamed the same file differently) will result in three different file having higher order stages (but each only has one higher order stage), with no way (short of the <<IM,Informational messages>> section)  to determine which three files are related.  File/directory conflicts also result in a file with exactly one higher order stage.  Possibly-involved-in-directory-rename conflicts (when \"merge.directoryRenames\" is unset or set to \"conflicts\") also result in a file with exactly one higher order stage.  In all cases, the <<IM,Informational messages>> section has the necessary info, though it is not designed to be machine parseable."
msgstr "不要试图猜测或让用户猜测 <<CFI,冲突文件信息>> 列表中的冲突类型。 那里的信息不足以做到这一点。 比如说： Rname/rename（ 1 对 2 ）冲突（双方以不同方式重命名同一文件）将导致三个不同的文件具有高阶阶段(但每个文件只有一个高阶阶段），没有办法（除了 <<IM,信息消息>> 部分）确定哪三个文件是相关的。 文件/目录冲突也会导致一个文件正好有一个高阶阶段。 可能涉及目录重命名的冲突（当 \"merge.directoryRenames\" 未设置或设置为 \"conflict\" 时）也会导致一个文件正好有一个高阶阶段。 在所有情况下，<<IM,消息性信息>> 部分都有必要的信息，尽管它不是被设计为可被机器解析的。"

#. type: Plain text
#: en/git-merge-tree.txt:272
#, priority:100
msgid "Do NOT assume that each paths from <<CFI,Conflicted file info>>, and the logical conflicts in the <<IM,Informational messages>> have a one-to-one mapping, nor that there is a one-to-many mapping, nor a many-to-one mapping.  Many-to-many mappings exist, meaning that each path can have many logical conflict types in a single merge, and each logical conflict type can affect many paths."
msgstr "不要假设 <<CFI,冲突文件信息>> 中的每个路径和 <<IM,信息消息>> 中的逻辑冲突有一对一的映射，也不要假设存在一对多的映射，更不要假设存在多对一的映射。 存在多对多的映射，意味着每个路径在一次合并中可以有许多逻辑冲突类型，每个逻辑冲突类型可以影响许多路径。"

#. type: Plain text
#: en/git-merge-tree.txt:276
#, priority:100
msgid "Do NOT assume all filenames listed in the <<IM,Informational messages>> section had conflicts.  Messages can be included for files that have no conflicts, such as \"Auto-merging <file>\"."
msgstr "不要认为 <<IM,信息消息>> 部分列出的所有文件名都有冲突。 对于没有冲突的文件，可以包括信息，如 \"Auto-merging <文件>\"。"

#. type: Plain text
#: en/git-merge-tree.txt:287
#, priority:100
msgid "AVOID taking the OIDS from the <<CFI,Conflicted file info>> and re-merging them to present the conflicts to the user.  This will lose information.  Instead, look up the version of the file found within the <<OIDTLT,OID of toplevel tree>> and show that instead.  In particular, the latter will have conflict markers annotated with the original branch/commit being merged and, if renames were involved, the original filename.  While you could include the original branch/commit in the conflict marker annotations when re-merging, the original filename is not available from the <<CFI,Conflicted file info>> and thus you would be losing information that might help the user resolve the conflict."
msgstr "避免从 <<CFI,冲突文件信息>> 中提取 OIDS，并将它们重新合并以向用户展示冲突。 这将丢失信息。 相反，在 <<OIDTLT,顶层目录树的OID>> 中查找文件的版本，并显示它。 特别是，后者将有冲突标记，并标明被合并的原始分支/提交，如果涉及重名，则标明原始文件名。 虽然你可以在重新合并时将原始分支/提交包括在冲突标记的注释中，但原始文件名不能从 <<CFI,冲突文件信息>> 中获得，因此你会失去可能帮助用户解决冲突的信息。"

#. type: Title -
#: en/git-merge-tree.txt:290
#, fuzzy, no-wrap, priority:100
#| msgid "DESCRIPTION"
msgid "DEPRECATED DESCRIPTION"
msgstr "描述"

#. type: Plain text
#: en/git-merge-tree.txt:295
#, priority:100
msgid "Per the <<NEWMERGE,DESCRIPTION>> and unlike the rest of this documentation, this section describes the deprecated `--trivial-merge` mode."
msgstr "根据 <<NEWMERGE,DESCRIPTION>>，与本文档的其他部分不同，本节描述了被废弃的 `--trivial-merge` 模式。"

#. type: Plain text
#: en/git-merge-tree.txt:298
#, priority:100
msgid "Other than the optional `--trivial-merge`, this mode accepts no options."
msgstr "除了可选的 `--trivial-merge` 外，该模式不接受任何选项。"

#. type: Plain text
#: en/git-merge-tree.txt:306
#, priority:100
msgid "This mode reads three tree-ish, and outputs trivial merge results and conflicting stages to the standard output in a semi-diff format.  Since this was designed for higher level scripts to consume and merge the results back into the index, it omits entries that match <branch1>.  The result of this second form is similar to what three-way 'git read-tree -m' does, but instead of storing the results in the index, the command outputs the entries to the standard output."
msgstr "这种模式读取三个树状的，并将琐碎的合并结果和冲突的阶段以 semi-diff 格式输出到标准输出。 由于这是为更高级别的脚本设计的，以消耗并将结果合并回索引中，所以它省略了与 <branch1> 相匹配的条目。 第二种形式的结果类似于三方 \"git read-tree -m\" 的做法，但该命令不是将结果存储在索引中，而是将条目输出到标准输出。"

#. type: Plain text
#: en/git-merge-tree.txt:313
#, priority:100
msgid "This form not only has limited applicability (a trivial merge cannot handle content merges of individual files, rename detection, proper directory/file conflict handling, etc.), the output format is also difficult to work with, and it will generally be less performant than the first form even on successful merges (especially if working in large repositories)."
msgstr "这种形式不仅适用性有限（一个琐碎的合并不能处理单个文件的内容合并、重命名检测、适当的目录/文件冲突处理等），输出格式也很难处理，而且即使在成功的合并中，它的性能一般也不如第一种形式（特别是在大型仓库中工作）。"

#. type: Title =
#: en/git-merge.txt:2
#, ignore-same, no-wrap, priority:240
msgid "git-merge(1)"
msgstr "git-merge(1)"

#. type: Plain text
#: en/git-merge.txt:7
#, fuzzy, priority:240
msgid "git-merge - Join two or more development histories together"
msgstr "git-merge - Join two or more development histories together"

#. type: Plain text
#: en/git-merge.txt:18
#, fuzzy, ignore-ellipsis, no-wrap, priority:240
msgid ""
"'git merge' [-n] [--stat] [--no-commit] [--squash] [--[no-]edit]\n"
"\t[--no-verify] [-s <strategy>] [-X <strategy-option>] [-S[<keyid>]]\n"
"\t[--[no-]allow-unrelated-histories]\n"
"\t[--[no-]rerere-autoupdate] [-m <msg>] [-F <file>]\n"
"\t[--into-name <branch>] [<commit>...]\n"
"'git merge' (--continue | --abort | --quit)\n"
msgstr ""
"'git merge' [-n] [-stat] [--no-commit] [--squash] [--[no-]edit] [--[no-] edit\n"
"\t[--no-verify] [-s <strategy>] [-X <strategy-option>] [-S[<keyid>]] 。\n"
"\t[--[no-]allow-unrelated-histories] [--[no-]allow-unrelated-histories]。\n"
"\t[--[no-]reer-autoupdate] [-m <msg>] [-F <file>] 。\n"
"\t[--into-name <branch>] [<commit>...］\n"
"'git merge' (--continue |-abort |-quit)\n"

#. type: Plain text
#: en/git-merge.txt:26
#, priority:240
msgid "Incorporates changes from the named commits (since the time their histories diverged from the current branch) into the current branch.  This command is used by 'git pull' to incorporate changes from another repository and can be used by hand to merge changes from one branch into another."
msgstr "将指定的提交内容（从它们的历史与当前分支相分离时起）并入当前分支。  这条命令被 \"git pull \"用来合并另一个仓库的改动，也可以用手将一个分支的改动合并到另一个分支。"

#. type: Plain text
#: en/git-merge.txt:29 en/git-pull.txt:43
#, priority:240
msgid "Assume the following history exists and the current branch is \"`master`\":"
msgstr "假设存在以下历史，且当前分支为\"`master`\"："

#. type: delimited block -
#: en/git-merge.txt:34
#, no-wrap, priority:240
msgid ""
"\t  A---B---C topic\n"
"\t /\n"
"    D---E---F---G master\n"
msgstr ""
"\t  A---B---C topic\n"
"\t /\n"
"    D---E---F---G master\n"

#. type: Plain text
#: en/git-merge.txt:42
#, priority:240
msgid "Then \"`git merge topic`\" will replay the changes made on the `topic` branch since it diverged from `master` (i.e., `E`) until its current commit (`C`) on top of `master`, and record the result in a new commit along with the names of the two parent commits and a log message from the user describing the changes. Before the operation, `ORIG_HEAD` is set to the tip of the current branch (`C`)."
msgstr "然后\"`git merge topic`\"将重现`topic`分支从`master`（即`E`）分流到`master`之上的当前提交（`C`）所做的修改，并将结果与两个父提交的名称和用户描述修改的日志信息一起记录在一个新提交中。在操作之前，`ORIG_HEAD`被设置为当前分支（`C`）的顶端。"

#. type: delimited block -
#: en/git-merge.txt:47
#, no-wrap, priority:240
msgid ""
"\t  A---B---C topic\n"
"\t /         \\\n"
"    D---E---F---G---H master\n"
msgstr ""
"\t  A---B---C topic\n"
"\t /         \\\n"
"    D---E---F---G---H master\n"

#. type: Plain text
#: en/git-merge.txt:56
#, priority:240
msgid "The second syntax (\"`git merge --abort`\") can only be run after the merge has resulted in conflicts. 'git merge --abort' will abort the merge process and try to reconstruct the pre-merge state. However, if there were uncommitted changes when the merge started (and especially if those changes were further modified after the merge was started), 'git merge --abort' will in some cases be unable to reconstruct the original (pre-merge) changes. Therefore:"
msgstr "第二种语法（\"`git merge --abort`\"）只能在合并导致冲突后运行。\"git merge --abort\"将中止合并过程，并尝试重建合并前的状态。然而，如果合并开始时有未提交的修改（特别是如果这些修改在合并开始后被进一步修改），'git merge --abort'在某些情况下将无法重建原始（合并前）修改。因此："

#. type: Plain text
#: en/git-merge.txt:60
#, no-wrap, priority:240
msgid ""
"*Warning*: Running 'git merge' with non-trivial uncommitted changes is\n"
"discouraged: while possible, it may leave you in a state that is hard to\n"
"back out of in the case of a conflict.\n"
msgstr ""
"*警告*：在非重要的未提交的修改中运行 \"git merge \"是不可取的。\n"
"不鼓励这样做：虽然有可能，但它可能会让你处于一个很难在冲突中恢复的状态。\n"
"并且如果发生冲突的话会处于一个很难退出的状态。\n"

#. type: Plain text
#: en/git-merge.txt:63
#, priority:240
msgid "The third syntax (\"`git merge --continue`\") can only be run after the merge has resulted in conflicts."
msgstr "第三种语法（\"`git merge --continue`\"）只能在合并导致冲突后运行。"

#. type: Plain text
#: en/git-merge.txt:73
#, priority:240
msgid "Set the commit message to be used for the merge commit (in case one is created)."
msgstr "设置用于合并提交的提交信息（如果创建了一个的话）。"

#. type: Plain text
#: en/git-merge.txt:76 en/git-merge.txt:93
#, priority:240
msgid "If `--log` is specified, a shortlog of the commits being merged will be appended to the specified message."
msgstr "如果指定了`--log`，正在合并的提交的简短日志将被附加到指定的消息中。"

#. type: Plain text
#: en/git-merge.txt:80
#, fuzzy, priority:240
msgid "The 'git fmt-merge-msg' command can be used to give a good default for automated 'git merge' invocations. The automated message can include the branch description."
msgstr "The 'git fmt-merge-msg' command can be used to give a good default for automated 'git merge' invocations. The automated message can include the branch description."

#. type: Plain text
#: en/git-merge.txt:85
#, priority:240
msgid "Prepare the default merge message as if merging to the branch `<branch>`, instead of the name of the real branch to which the merge is made."
msgstr "准备默认的合并信息，就像合并到分支`<分支>`一样，而不是真正要合并的分支名称。"

#. type: Plain text
#: en/git-merge.txt:90
#, priority:240
msgid "Read the commit message to be used for the merge commit (in case one is created)."
msgstr "读取用于合并提交的提交信息（如果创建了）。"

#. type: Plain text
#: en/git-merge.txt:100
#, priority:240
msgid "Silently overwrite ignored files from the merge result. This is the default behavior. Use `--no-overwrite-ignore` to abort."
msgstr "默认会静默地覆盖合并结果中被忽略的文件。使用`--no-overwrite-ignore`来终止。"

#. type: Plain text
#: en/git-merge.txt:105
#, priority:240
msgid "Abort the current conflict resolution process, and try to reconstruct the pre-merge state. If an autostash entry is present, apply it to the worktree."
msgstr "中止当前的冲突解决过程，并尝试重建合并前的状态。工作区会自动应用自动存储条目。"

#. type: Plain text
#: en/git-merge.txt:110
#, priority:240
msgid "If there were uncommitted worktree changes present when the merge started, 'git merge --abort' will in some cases be unable to reconstruct these changes. It is therefore recommended to always commit or stash your changes before running 'git merge'."
msgstr "如果合并开始时有未提交的工作区变化，'git merge --abort'在某些情况下将无法重现这些变化。因此，建议在运行'git merge'之前，一定要提交或储存你的修改。"

#. type: Plain text
#: en/git-merge.txt:116
#, fuzzy, priority:240
msgid "'git merge --abort' is equivalent to 'git reset --merge' when `MERGE_HEAD` is present unless `MERGE_AUTOSTASH` is also present in which case 'git merge --abort' applies the stash entry to the worktree whereas 'git reset --merge' will save the stashed changes in the stash list."
msgstr "'git merge --abort' is equivalent to 'git reset --merge' when `MERGE_HEAD` is present unless `MERGE_AUTOSTASH` is also present in which case 'git merge --abort' applies the stash entry to the worktree whereas 'git reset --merge' will save the stashed changes in the stash list."

#. type: Plain text
#: en/git-merge.txt:121
#, priority:240
msgid "Forget about the current merge in progress. Leave the index and the working tree as-is. If `MERGE_AUTOSTASH` is present, the stash entry will be saved to the stash list."
msgstr "忘记当前正在进行的合并。让索引和工作区保持原样。如果`MERGE_AUTOSTASH`存在，储藏库条目将被保存到储藏库列表。"

#. type: Plain text
#: en/git-merge.txt:126
#, priority:240
msgid "After a 'git merge' stops due to conflicts you can conclude the merge by running 'git merge --continue' (see \"HOW TO RESOLVE CONFLICTS\" section below)."
msgstr "在 \"git merge \"因冲突而停止后，你可以通过运行 \"git merge --continue \"来结束当前合并（见下文 \"如何解决冲突\"部分）。"

#. type: Plain text
#: en/git-merge.txt:131
#, priority:240
msgid "Commits, usually other branch heads, to merge into our branch.  Specifying more than one commit will create a merge with more than two parents (affectionately called an Octopus merge)."
msgstr "提交，通常是其他分支负责人，合并到我们的分支中。 指定多个提交将创建具有两个以上父项的合并（亲切地称为八爪/多路合并）。"

#. type: Plain text
#: en/git-merge.txt:135
#, priority:240
msgid "If no commit is given from the command line, merge the remote-tracking branches that the current branch is configured to use as its upstream.  See also the configuration section of this manual page."
msgstr "如果命令行没有给出提交，则合并当前分支被配置为上游的远程跟踪分支。  参见本手册页的配置部分。"

#. type: Plain text
#: en/git-merge.txt:139
#, priority:240
msgid "When `FETCH_HEAD` (and no other commit) is specified, the branches recorded in the `.git/FETCH_HEAD` file by the previous invocation of `git fetch` for merging are merged to the current branch."
msgstr "当指定`FETCH_HEAD`（没有其他提交）时，之前调用 `git fetch`进行合并时记录在`.git/FETCH_HEAD`文件中的分支会被合并到当前分支。"

#. type: Title -
#: en/git-merge.txt:142
#, no-wrap, priority:240
msgid "PRE-MERGE CHECKS"
msgstr "合并前检查"

#. type: Plain text
#: en/git-merge.txt:150
#, priority:240
msgid "Before applying outside changes, you should get your own work in good shape and committed locally, so it will not be clobbered if there are conflicts.  See also linkgit:git-stash[1].  'git pull' and 'git merge' will stop without doing anything when local uncommitted changes overlap with files that 'git pull'/'git merge' may need to update."
msgstr "在应用外部的修改之前，你应该把自己的工作做好，并在本地提交，这样在有冲突的时候就不会被打乱了。  参见 linkgit:git-stash[1]。  \"git pul \"和 \"git merge \"会在本地未提交的修改与 \"git pull\"/\"git merge \"可能需要更新的文件重叠时会不做任何操作，立即停止。"

#. type: Plain text
#: en/git-merge.txt:156
#, priority:240
msgid "To avoid recording unrelated changes in the merge commit, 'git pull' and 'git merge' will also abort if there are any changes registered in the index relative to the `HEAD` commit.  (Special narrow exceptions to this rule may exist depending on which merge strategy is in use, but generally, the index must match HEAD.)"
msgstr "为了避免在合并提交中记录不相关的变化，'git pull'和'git merge'也会在相对于`HEAD`提交的索引中存在任何变化时中止。  (根据使用的合并策略，这一规则可能存在特殊的狭义例外，但一般来说，索引必须与HEAD相匹配。)"

#. type: Plain text
#: en/git-merge.txt:159
#, priority:240
msgid "If all named commits are already ancestors of `HEAD`, 'git merge' will exit early with the message \"Already up to date.\""
msgstr "如果所有命名的提交都已经是`HEAD`的祖先，'git merge'将提前退出，提示 \"已经是最新的。\""

#. type: Title -
#: en/git-merge.txt:161
#, no-wrap, priority:240
msgid "FAST-FORWARD MERGE"
msgstr "快进式合并"

#. type: Plain text
#: en/git-merge.txt:171
#, priority:240
msgid "Often the current branch head is an ancestor of the named commit.  This is the most common case especially when invoked from 'git pull': you are tracking an upstream repository, you have committed no local changes, and now you want to update to a newer upstream revision.  In this case, a new commit is not needed to store the combined history; instead, the `HEAD` (along with the index) is updated to point at the named commit, without creating an extra merge commit."
msgstr "通常情况下，当前的分支头是指定提交的祖先。  这是最常见的情况，特别是当从'git pull'调用时：你正在跟踪一个上游仓库，你没有提交本地的修改，现在你想更新到一个更新的上游版本。  在这种情况下，不需要新的提交来存储合并历史；相反，`HEAD`（连同索引）被更新为指向指定的提交，而不需要创建额外的合并提交。"

#. type: Plain text
#: en/git-merge.txt:173
#, priority:240
msgid "This behavior can be suppressed with the `--no-ff` option."
msgstr "这种行为可以通过`--no-ff`选项来抑制。"

#. type: Title -
#: en/git-merge.txt:175
#, no-wrap, priority:240
msgid "TRUE MERGE"
msgstr "正确的合并"

#. type: Plain text
#: en/git-merge.txt:180
#, priority:240
msgid "Except in a fast-forward merge (see above), the branches to be merged must be tied together by a merge commit that has both of them as its parents."
msgstr "除了快进合并（见上文），被合并的分支必须由一个以它们两个为父分支的合并提交捆绑在一起。"

#. type: Plain text
#: en/git-merge.txt:185
#, priority:240
msgid "A merged version reconciling the changes from all branches to be merged is committed, and your `HEAD`, index, and working tree are updated to it.  It is possible to have modifications in the working tree as long as they do not overlap; the update will preserve them."
msgstr "一个调和了所有要合并的分支的修改的合并版本被提交，你的`HEAD`、索引和工作区将更新到这个版本。  在工作区中可以有一些修改，只要它们不重叠；更新将保留这些修改。"

#. type: Plain text
#: en/git-merge.txt:188
#, priority:240
msgid "When it is not obvious how to reconcile the changes, the following happens:"
msgstr "当不清楚如何调和这些变化时，就会发生以下情况："

#. type: Plain text
#: en/git-merge.txt:190
#, priority:240
msgid "The `HEAD` pointer stays the same."
msgstr "`HEAD`的指针保持不变。"

#. type: Plain text
#: en/git-merge.txt:191
#, priority:240
msgid "The `MERGE_HEAD` ref is set to point to the other branch head."
msgstr "`MERGE_HEAD`参数被设置为指向另一个分支头部。"

#. type: Plain text
#: en/git-merge.txt:193
#, priority:240
msgid "Paths that merged cleanly are updated both in the index file and in your working tree."
msgstr "合并干净的路径在索引文件和你的工作区中都更新了。"

#. type: Plain text
#: en/git-merge.txt:199
#, fuzzy, priority:240
#| msgid "For conflicting paths, the index file records up to three versions: stage 1 stores the version from the common ancestor, stage 2 from `HEAD`, and stage 3 from `MERGE_HEAD` (you can inspect the stages with `git ls-files -u`).  The working tree files contain the result of the \"merge\" program; i.e. 3-way merge results with familiar conflict markers `<<<` `===` `>>>`."
msgid "For conflicting paths, the index file records up to three versions: stage 1 stores the version from the common ancestor, stage 2 from `HEAD`, and stage 3 from `MERGE_HEAD` (you can inspect the stages with `git ls-files -u`).  The working tree files contain the result of the merge operation; i.e. 3-way merge results with familiar conflict markers `<<<` `===` `>>>`."
msgstr "对于冲突的路径，索引文件最多记录三个版本：第1阶段存储来自共同祖先的版本，第2阶段来自`HEAD`，第3阶段来自`MERGE_HEAD`（你可以用`git ls-files -u`检查这些阶段）。  工作区文件包含了\"合并\"程序的结果；即带有熟悉的冲突标记`<<<` `===``>>>`的三方合并结果。"

#. type: Plain text
#: en/git-merge.txt:203
#, priority:240
msgid "A special ref `AUTO_MERGE` is written, pointing to a tree corresponding to the current content of the working tree (including conflict markers for textual conflicts).  Note that this ref is only written when the 'ort' merge strategy is used (the default)."
msgstr ""

#. type: Plain text
#: en/git-merge.txt:207
#, priority:240
msgid "No other changes are made.  In particular, the local modifications you had before you started merge will stay the same and the index entries for them stay as they were, i.e. matching `HEAD`."
msgstr "没有其他变化。  特别是，你在开始合并之前的本地修改将保持不变，它们的索引条目保持原样，即匹配`HEAD`。"

#. type: Plain text
#: en/git-merge.txt:210
#, priority:240
msgid "If you tried a merge which resulted in complex conflicts and want to start over, you can recover with `git merge --abort`."
msgstr "如果你尝试的合并导致了复杂的冲突，并想重新开始，你可以用`git merge --abort`恢复。"

#. type: Title -
#: en/git-merge.txt:212
#, no-wrap, priority:240
msgid "MERGING TAG"
msgstr "合并标签"

#. type: Plain text
#: en/git-merge.txt:219
#, priority:240
msgid "When merging an annotated (and possibly signed) tag, Git always creates a merge commit even if a fast-forward merge is possible, and the commit message template is prepared with the tag message.  Additionally, if the tag is signed, the signature check is reported as a comment in the message template. See also linkgit:git-tag[1]."
msgstr "当合并一个有注释的（可能是有签名的）标签时，即使可以进行快速合并，Git也会创建一个合并提交，并且会一起准备提交消息模板和标签消息。  此外，如果标签有签名，签名检查会在消息模板中作为注释报告。参见 linkgit:git-tag[1]。"

#. type: Plain text
#: en/git-merge.txt:223
#, priority:240
msgid "When you want to just integrate with the work leading to the commit that happens to be tagged, e.g. synchronizing with an upstream release point, you may not want to make an unnecessary merge commit."
msgstr "当你只想与恰好被标记的提交的工作整合时，比如说与上游发布点同步，你可能不想做一个不必要的合并提交。"

#. type: Plain text
#: en/git-merge.txt:227
#, priority:240
msgid "In such a case, you can \"unwrap\" the tag yourself before feeding it to `git merge`, or pass `--ff-only` when you do not have any work on your own. e.g."
msgstr "在这种情况下，你可以在把标签送入`git merge`之前自己 \"解包\"，或者在自己没有任何工作的时候设置`--ff-only`，如下例。"

#. type: delimited block -
#: en/git-merge.txt:232
#, no-wrap, priority:240
msgid ""
"git fetch origin\n"
"git merge v1.2.3^0\n"
"git merge --ff-only v1.2.3\n"
msgstr ""
"git fetch origin\n"
"git merge v1.2.3^0\n"
"git merge --ff-only v1.2.3\n"

#. type: Title -
#: en/git-merge.txt:236
#, fuzzy, no-wrap, priority:240
msgid "HOW CONFLICTS ARE PRESENTED"
msgstr "冲突是如何出现的"

#. type: Plain text
#: en/git-merge.txt:245
#, priority:240
msgid "During a merge, the working tree files are updated to reflect the result of the merge.  Among the changes made to the common ancestor's version, non-overlapping ones (that is, you changed an area of the file while the other side left that area intact, or vice versa) are incorporated in the final result verbatim.  When both sides made changes to the same area, however, Git cannot randomly pick one side over the other, and asks you to resolve it by leaving what both sides did to that area."
msgstr "在合并过程中，工作区文件被更新以反映合并的结果。  在对共同祖先的版本所做的修改中，非重叠的修改（即你改变了文件的某个区域，而另一方则保留了该区域，反之亦然）会被逐字纳入最终结果中。  然而，当双方都对同一区域进行了修改时，Git不能随机地选择一方而不是另一方，而是要求你通过保留双方对该区域的修改来解决这个问题。"

#. type: Plain text
#: en/git-merge.txt:248
#, priority:240
msgid "By default, Git uses the same style as the one used by the \"merge\" program from the RCS suite to present such a conflicted hunk, like this:"
msgstr "默认情况下，Git使用与RCS套件中的 \"merge\"程序相同的样式来呈现这样一个有冲突的大块，像这样："

#. type: delimited block -
#: en/git-merge.txt:260
#, no-wrap, priority:240
msgid ""
"Here are lines that are either unchanged from the common\n"
"ancestor, or cleanly resolved because only one side changed,\n"
"or cleanly resolved because both sides changed the same way.\n"
"<<<<<<< yours:sample.txt\n"
"Conflict resolution is hard;\n"
"let's go shopping.\n"
"=======\n"
"Git makes conflict resolution easy.\n"
">>>>>>> theirs:sample.txt\n"
"And here is another line that is cleanly resolved or unmodified.\n"
msgstr ""
"这里是与共同的祖先相比没有变化的行。\n"
"祖先没有变化，或者因为只有一方发生了变化而得到干净的解决、\n"
"或者因为两边都有相同的变化而被干净地解决了。\n"
"<<<<<<< yours:sample.txt\n"
"冲突的解决是困难的；\n"
"让我们去购物吧。\n"
"=======\n"
"Git让冲突解决变得简单。\n"
">>>>>>> theirs:sample.txt\n"
"而这里是另一行干净利落的解决或未修改的内容。\n"

#. type: Plain text
#: en/git-merge.txt:265
#, priority:240
msgid "The area where a pair of conflicting changes happened is marked with markers `<<<<<<<`, `=======`, and `>>>>>>>`.  The part before the `=======` is typically your side, and the part afterwards is typically their side."
msgstr "发生一对冲突变化的区域被标记为`<<<<<<<`、`=======`和`>>>>>>>`。  `=======`之前的部分通常是你做的修改，而之后的部分通常是别人的修改。"

#. type: Plain text
#: en/git-merge.txt:271
#, priority:240
msgid "The default format does not show what the original said in the conflicting area.  You cannot tell how many lines are deleted and replaced with Barbie's remark on your side.  The only thing you can tell is that your side wants to say it is hard and you'd prefer to go shopping, while the other side wants to claim it is easy."
msgstr "默认的格式并不显示原文在冲突区说了什么。  你无法知道有多少行被删除，并被替换成你方的芭比娃娃的言论。  你唯一能知道的是，你方想说这很难，你更愿意去购物，而另一方则想说这很容易。"

#. type: Plain text
#: en/git-merge.txt:275
#, priority:240
msgid "An alternative style can be used by setting the \"merge.conflictStyle\" configuration variable to either \"diff3\" or \"zdiff3\".  In \"diff3\" style, the above conflict may look like this:"
msgstr "通过将 \"merge.conflictStyle \"配置变量设置为 \"diff3 \"或 \"zdiff3\"，可以使用另一种风格。  在 \"diff3 \"风格中，上述冲突可能看起来像这样："

#. type: delimited block -
#: en/git-merge.txt:291
#, no-wrap, priority:240
msgid ""
"Here are lines that are either unchanged from the common\n"
"ancestor, or cleanly resolved because only one side changed,\n"
"<<<<<<< yours:sample.txt\n"
"or cleanly resolved because both sides changed the same way.\n"
"Conflict resolution is hard;\n"
"let's go shopping.\n"
"||||||| base:sample.txt\n"
"or cleanly resolved because both sides changed identically.\n"
"Conflict resolution is hard.\n"
"=======\n"
"or cleanly resolved because both sides changed the same way.\n"
"Git makes conflict resolution easy.\n"
">>>>>>> theirs:sample.txt\n"
"And here is another line that is cleanly resolved or unmodified.\n"
msgstr ""
"这里是与共同的祖先相比没有变化的行。\n"
"祖先没有变化，或者因为只有一方发生了变化而得到了干净的解决、\n"
"<<<<<<< yours:sample.txt\n"
"或干净地解决了，因为双方都以同样的方式改变了。\n"
"冲突的解决是很难的；\n"
"让我们去购物吧。\n"
"||||||| base:sample.txt\n"
"或干净利落地解决了，因为双方的变化都一样。\n"
"冲突的解决是很难的。\n"
"=======\n"
"或干净利落地解决了，因为双方都有相同的变化。\n"
"Git使冲突解决变得容易。\n"
">>>>>>> theirs:sample.txt\n"
"而这里是另一行被干净地解决或未修改的。\n"

#. type: Plain text
#: en/git-merge.txt:294
#, fuzzy, priority:240
#| msgid "A \"combined diff\" format looks like this:"
msgid "while in \"zdiff3\" style, it may look like this:"
msgstr "\"合并的差异\" 的格式如下："

#. type: delimited block -
#: en/git-merge.txt:309
#, fuzzy, no-wrap, priority:240
msgid ""
"Here are lines that are either unchanged from the common\n"
"ancestor, or cleanly resolved because only one side changed,\n"
"or cleanly resolved because both sides changed the same way.\n"
"<<<<<<< yours:sample.txt\n"
"Conflict resolution is hard;\n"
"let's go shopping.\n"
"||||||| base:sample.txt\n"
"or cleanly resolved because both sides changed identically.\n"
"Conflict resolution is hard.\n"
"=======\n"
"Git makes conflict resolution easy.\n"
">>>>>>> theirs:sample.txt\n"
"And here is another line that is cleanly resolved or unmodified.\n"
msgstr ""
"这里是与共同的祖先相比没有变化的行。\n"
"祖先没有变化，或者因为只有一方发生了变化而得到干净的解决、\n"
"或者因为两边都有相同的变化而被干净地解决了。\n"
"<<<<<<< yours:sample.txt\n"
"冲突的解决是困难的；\n"
"让我们去购物吧。\n"
"||||||| base:sample.txt\n"
"或干净利落地解决，因为双方的变化都一样。\n"
"冲突的解决是很难的。\n"
"=======\n"
"Git让冲突解决变得简单。\n"
">>>>>>> theirs:sample.txt\n"
"而这里是另一行被干净地解决或未修改的内容。\n"

#. type: Plain text
#: en/git-merge.txt:317
#, priority:240
msgid "In addition to the `<<<<<<<`, `=======`, and `>>>>>>>` markers, it uses another `|||||||` marker that is followed by the original text.  You can tell that the original just stated a fact, and your side simply gave in to that statement and gave up, while the other side tried to have a more positive attitude.  You can sometimes come up with a better resolution by viewing the original."
msgstr "除了`<<<<<<<`、`=======`和`>>>>>>>`标记外，它还使用了另一个`|||||||`标记，后面是原文。  你可以看出，原文只是陈述了一个事实，而你的一方只是屈服于这个陈述而放弃了，而另一方则试图有一个更积极的态度。  你有时可以通过查看原文得出一个更好的解决方案。"

#. type: Title -
#: en/git-merge.txt:320
#, no-wrap, priority:240
msgid "HOW TO RESOLVE CONFLICTS"
msgstr "如何解决冲突"

#. type: Plain text
#: en/git-merge.txt:323
#, priority:240
msgid "After seeing a conflict, you can do two things:"
msgstr "看到冲突后，你可以做两件事："

#. type: Plain text
#: en/git-merge.txt:328
#, priority:240
msgid "Decide not to merge.  The only clean-ups you need are to reset the index file to the `HEAD` commit to reverse 2. and to clean up working tree changes made by 2. and 3.; `git merge --abort` can be used for this."
msgstr "决定不进行合并。  唯一需要清理的是将索引文件重置为`HEAD`提交，以逆转2.，并清理2.和3.对工作树的修改；可以用`git merge --abort`来做这份工作。"

#. type: Plain text
#: en/git-merge.txt:335
#, priority:240
msgid "Resolve the conflicts.  Git will mark the conflicts in the working tree.  Edit the files into shape and 'git add' them to the index.  Use 'git commit' or 'git merge --continue' to seal the deal. The latter command checks whether there is a (interrupted) merge in progress before calling 'git commit'."
msgstr "解决冲突。  Git会在工作树上标记冲突。  将文件编辑成形，然后'git add'它们到索引中。  使用'git commit'或'git merge --continue'解决。后一个命令在调用'git commit'之前会检查是否有一个（中断的）合并正在进行。"

#. type: Plain text
#: en/git-merge.txt:337
#, priority:240
msgid "You can work through the conflict with a number of tools:"
msgstr "你可以用一些工具来解决冲突："

#. type: Plain text
#: en/git-merge.txt:340
#, priority:240
msgid "Use a mergetool.  `git mergetool` to launch a graphical mergetool which will work you through the merge."
msgstr "使用一个mergetool。  `git mergetool`启动一个图形化的mergetool，它将帮助你完成合并工作。"

#. type: Plain text
#: en/git-merge.txt:345
#, fuzzy, priority:240
#| msgid "Look at the diffs.  `git diff` will show a three-way diff, highlighting changes from both the `HEAD` and `MERGE_HEAD` versions."
msgid "Look at the diffs.  `git diff` will show a three-way diff, highlighting changes from both the `HEAD` and `MERGE_HEAD` versions. `git diff AUTO_MERGE` will show what changes you've made so far to resolve textual conflicts."
msgstr "查看差异。`git diff`将会显示一个三向差异，突出显示从`HEAD`和`MERGE_HEAD`版本的变化。"

#. type: Plain text
#: en/git-merge.txt:349
#, priority:240
msgid "Look at the diffs from each branch. `git log --merge -p <path>` will show diffs first for the `HEAD` version and then the `MERGE_HEAD` version."
msgstr "看看每个分支的差异。`git log --merge -p <路径>`将首先显示`HEAD`版本的差异，然后是`MERGE_HEAD`版本。"

#. type: Plain text
#: en/git-merge.txt:354
#, priority:240
msgid "Look at the originals.  `git show :1:filename` shows the common ancestor, `git show :2:filename` shows the `HEAD` version, and `git show :3:filename` shows the `MERGE_HEAD` version."
msgstr "看一下原件。  `git show :1:filename`显示共同的祖先，`git show :2:filename`显示`HEAD`版本，`git show :3:filename`显示`MERGE_HEAD`版本。"

#. type: Plain text
#: en/git-merge.txt:361
#, priority:240
msgid "Merge branches `fixes` and `enhancements` on top of the current branch, making an octopus merge:"
msgstr "合并分支 `fixes` 和 `enhancements`到当前分支之上, 进行多路合并。"

#. type: delimited block -
#: en/git-merge.txt:364
#, fuzzy, no-wrap, priority:240
msgid "$ git merge fixes enhancements\n"
msgstr "$ git merge fixes enhancements\n"

#. type: Plain text
#: en/git-merge.txt:368
#, priority:240
msgid "Merge branch `obsolete` into the current branch, using `ours` merge strategy:"
msgstr "将分支`obsolete`合并到当前分支，使用`ours`的合并策略："

#. type: delimited block -
#: en/git-merge.txt:371
#, fuzzy, no-wrap, priority:240
msgid "$ git merge -s ours obsolete\n"
msgstr "$ git merge -s ours obsolete\n"

#. type: Plain text
#: en/git-merge.txt:375
#, priority:240
msgid "Merge branch `maint` into the current branch, but do not make a new commit automatically:"
msgstr "合并分支`maint`到当前分支，但是我们不做自动创建新提交:"

#. type: delimited block -
#: en/git-merge.txt:378
#, fuzzy, no-wrap, priority:240
msgid "$ git merge --no-commit maint\n"
msgstr "$ git merge --no-commit maint\n"

#. type: Plain text
#: en/git-merge.txt:382
#, priority:240
msgid "This can be used when you want to include further changes to the merge, or want to write your own merge commit message."
msgstr "当您想在合并中加入进一步的更改，或者您想手动编写合并提交信息时，就可以使用此功能。"

#. type: Plain text
#: en/git-merge.txt:386
#, priority:240
msgid "You should refrain from abusing this option to sneak substantial changes into a merge commit.  Small fixups like bumping release/version name would be acceptable."
msgstr "你应该避免滥用这个选项，它可以在合并提交中偷偷地进行版本库中实质性的修改。 小的修正，例如修改发布日志内容/版本名称，是推荐的。"

#. type: Labeled list
#: en/git-merge.txt:393
#, no-wrap, priority:240
msgid "branch.<name>.mergeOptions"
msgstr "分支 .<名字>.合并操作选项"

#. type: Plain text
#: en/git-merge.txt:397
#, priority:240
msgid "Sets default options for merging into branch <name>. The syntax and supported options are the same as those of 'git merge', but option values containing whitespace characters are currently not supported."
msgstr "设置合并到分支<分支名>的默认选项。语法和支持的选项与'git merge'相同，不过目前不支持包含空格的选项值。"

#. type: Plain text
#: en/git-merge.txt:410
#, ignore-same, priority:240
msgid "linkgit:git-fmt-merge-msg[1], linkgit:git-pull[1], linkgit:gitattributes[5], linkgit:git-reset[1], linkgit:git-diff[1], linkgit:git-ls-files[1], linkgit:git-add[1], linkgit:git-rm[1], linkgit:git-mergetool[1]"
msgstr "linkgit:git-fmt-merge-msg[1], linkgit:git-pull[1], linkgit:gitattributes[5], linkgit:git-reset[1], linkgit:git-diff[1], linkgit:git-ls-files[1], linkgit:git-add[1], linkgit:git-rm[1], linkgit:git-mergetool[1]"

#. type: Title =
#: en/git-mktag.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-mktag(1)"
msgstr "git-mktag(1)"

#. type: Plain text
#: en/git-mktag.txt:7
#, fuzzy, priority:100
msgid "git-mktag - Creates a tag object with extra validation"
msgstr "git-mktag - Creates a tag object"

#. type: Plain text
#: en/git-mktag.txt:13
#, fuzzy, no-wrap, priority:100
msgid "'git mktag'\n"
msgstr "'git mktag'\n"

#. type: Plain text
#: en/git-mktag.txt:19
#, priority:100
msgid "Reads a tag contents on standard input and creates a tag object. The output is the new tag's <object> identifier."
msgstr "读取标准输入中的标签内容并创建一个标签对象。输出是新标签的 <object> 标识符。"

#. type: Plain text
#: en/git-mktag.txt:23
#, priority:100
msgid "This command is mostly equivalent to linkgit:git-hash-object[1] invoked with `-t tag -w --stdin`. I.e. both of these will create and write a tag found in `my-tag`:"
msgstr "这个命令主要等同于 linkgit:git-hash-object[1] 与 `-t tag -w -stdin` 一起调用。也就是说，这两个命令都会创建并写入一个在 `my-tag` 中找到的标签："

#. type: Plain text
#: en/git-mktag.txt:26
#, no-wrap, priority:100
msgid ""
"    git mktag <my-tag\n"
"    git hash-object -t tag -w --stdin <my-tag\n"
msgstr ""
"    git mktag <my-tag\n"
"    git hash-object -t tag -w --stdin <my-tag\n"

#. type: Plain text
#: en/git-mktag.txt:29
#, priority:100
msgid "The difference is that mktag will die before writing the tag if the tag doesn't pass a linkgit:git-fsck[1] check."
msgstr "不同的是，如果标签没有通过 linkgit:git-fsck[1] 的检查，mktag 进程会在写入标签前结束。"

#. type: Plain text
#: en/git-mktag.txt:33
#, priority:100
msgid "The \"fsck\" check done mktag is stricter than what linkgit:git-fsck[1] would run by default in that all `fsck.<msg-id>` messages are promoted from warnings to errors (so e.g. a missing \"tagger\" line is an error)."
msgstr "mktag 的 \"fsck\" 检查比 linkgit:git-fsck[1] 默认运行的更严格，因为所有的 `fsck.<msg-id>` 信息都从警告提升为错误（所以例如，缺少 \"tagger\" 行就是一个错误）。"

#. type: Plain text
#: en/git-mktag.txt:37
#, fuzzy, priority:100
#| msgid "Extra headers in the object are also an error under mktag, but ignored by linkgit:git-fsck[1]. This extra check can be turned off by setting the appropriate `fsck.<msg-id>` varible:"
msgid "Extra headers in the object are also an error under mktag, but ignored by linkgit:git-fsck[1]. This extra check can be turned off by setting the appropriate `fsck.<msg-id>` variable:"
msgstr "对象中的额外头文件在 mktag 下也是一个错误，但被 linkgit:git-fsck[1] 忽略。这个额外的检查可以通过设置适当的 `fsck.<msg-id>` 变量来关闭："

#. type: Plain text
#: en/git-mktag.txt:39
#, no-wrap, priority:100
msgid "    git -c fsck.extraHeaderEntry=ignore mktag <my-tag-with-headers\n"
msgstr "    git -c fsck.extraHeaderEntry=ignore mktag <my-tag-with-headers\n"

#. type: Plain text
#: en/git-mktag.txt:47
#, priority:100
msgid "By default mktag turns on the equivalent of linkgit:git-fsck[1] `--strict` mode. Use `--no-strict` to disable it."
msgstr "默认情况下，mktag 打开了相当于 linkgit:git-fsck[1] 的 `--strict` 模式。使用 `--no-strict` 来禁用它。"

#. type: Title -
#: en/git-mktag.txt:49
#, fuzzy, no-wrap, priority:100
msgid "Tag Format"
msgstr "标签格式"

#. type: Plain text
#: en/git-mktag.txt:52
#, priority:100
msgid "A tag signature file, to be fed to this command's standard input, has a very simple fixed format: four lines of"
msgstr "将被送入该命令的标准输入的标签签名文件有一个非常简单的固定格式：四行的"

#. type: Plain text
#: en/git-mktag.txt:57
#, no-wrap, priority:100
msgid ""
"  object <hash>\n"
"  type <typename>\n"
"  tag <tagname>\n"
"  tagger <tagger>\n"
msgstr ""
"  object <hash>\n"
"  type <typename>\n"
"  tag <tagname>\n"
"  tagger <tagger>\n"

#. type: Plain text
#: en/git-mktag.txt:63
#, priority:100
msgid "followed by some 'optional' free-form message (some tags created by older Git may not have `tagger` line).  The message, when it exists, is separated by a blank line from the header.  The message part may contain a signature that Git itself doesn't care about, but that can be verified with gpg."
msgstr "后面是一些 \"可选的\" 自由形式的信息（一些由旧版 Git 创建的标签可能没有 `tagger` 行）。 当信息存在时，会用一行空行与标头分开。 消息部分可能包含一个 Git 自己并不关心的签名，但可以用 gpg 验证。"

#. type: Title =
#: en/git-mktree.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-mktree(1)"
msgstr "git-mktree(1)"

#. type: Plain text
#: en/git-mktree.txt:7
#, priority:100
msgid "git-mktree - Build a tree-object from ls-tree formatted text"
msgstr "git-mktree - 从 ls-tree 格式化文本构建树对象"

#. type: Plain text
#: en/git-mktree.txt:13
#, fuzzy, no-wrap, priority:100
msgid "'git mktree' [-z] [--missing] [--batch]\n"
msgstr "'git mktree' [-z] [--missing] [--batch]\n"

#. type: Plain text
#: en/git-mktree.txt:20
#, priority:100
msgid "Reads standard input in non-recursive `ls-tree` output format, and creates a tree object.  The order of the tree entries is normalized by mktree so pre-sorting the input is not required.  The object name of the tree object built is written to the standard output."
msgstr "以非递归的 `ls-tree` 输出格式读取标准输入，并创建一个树形对象。 树条目的顺序由 mktree 规范化，所以不需要对输入进行预先排序。 建立的树形对象的对象名称被写入标准输出。"

#. type: Plain text
#: en/git-mktree.txt:25
#, priority:100
msgid "Read the NUL-terminated `ls-tree -z` output instead."
msgstr "读取以 NUL 结尾的 `ls-tree -z` 输出。"

#. type: Labeled list
#: en/git-mktree.txt:26
#, ignore-same, no-wrap, priority:100
msgid "--missing"
msgstr "--missing"

#. type: Plain text
#: en/git-mktree.txt:31
#, priority:100
msgid "Allow missing objects.  The default behaviour (without this option)  is to verify that each tree entry's sha1 identifies an existing object.  This option has no effect on the treatment of gitlink entries (aka \"submodules\") which are always allowed to be missing."
msgstr "允许缺失的对象。 默认行为（没有这个选项）是验证每个树条目的 sha1 标识了一个现有对象。 这个选项对处理 gitlink 条目（又称 \"子模块\"）没有影响，它总是被允许缺失。"

#. type: Plain text
#: en/git-mktree.txt:37
#, priority:100
msgid "Allow building of more than one tree object before exiting.  Each tree is separated by a single blank line. The final new-line is optional.  Note - if the `-z` option is used, lines are terminated with NUL."
msgstr "允许在退出前建立一个以上的树对象。 每棵树之间都有一个空行。最后的换行是可选的。 注意 - 如果使用 `-z` 选项，则以 NUL 结束行。"

#. type: Title =
#: en/git-mv.txt:2
#, ignore-same, no-wrap, priority:280
msgid "git-mv(1)"
msgstr "git-mv(1)"

#. type: Plain text
#: en/git-mv.txt:7
#, priority:280
msgid "git-mv - Move or rename a file, a directory, or a symlink"
msgstr "git-mv - 移动或重命名一个文件、一个目录或一个符号链接"

#. type: Plain text
#: en/git-mv.txt:13
#, fuzzy, ignore-ellipsis, no-wrap, priority:280
msgid "'git mv' [<options>] <source>... <destination>\n"
msgstr "'git annotate' [<options>] <file> [<revision>]\n"

#. type: Plain text
#: en/git-mv.txt:17
#, priority:280
msgid "Move or rename a file, directory or symlink."
msgstr "移动或重命名一个文件、目录或符号链接。"

#. type: Plain text
#: en/git-mv.txt:20
#, ignore-ellipsis, no-wrap, priority:280
msgid ""
" git mv [-v] [-f] [-n] [-k] <source> <destination>\n"
" git mv [-v] [-f] [-n] [-k] <source> ... <destination directory>\n"
msgstr ""
" git mv [-v] [-f] [-n] [-k] <来源> <目的地>。\n"
" git mv [-v] [-f] [-n] [-k] <source> ...<目的地>目录\n"

#. type: Plain text
#: en/git-mv.txt:25
#, priority:280
msgid "In the first form, it renames <source>, which must exist and be either a file, symlink or directory, to <destination>.  In the second form, the last argument has to be an existing directory; the given sources will be moved into this directory."
msgstr "在第一种形式中，它将<source>重命名为<destination>，它必须存在并且是一个文件、符号链接或目录。  在第二种形式中，最后一个参数必须是一个现有的目录；给定的源将被移到这个目录中。"

#. type: Plain text
#: en/git-mv.txt:28
#, priority:280
msgid "The index is updated after successful completion, but the change must still be committed."
msgstr "索引在成功完成后被更新，但变化仍必须被提交。"

#. type: Plain text
#: en/git-mv.txt:34
#, fuzzy, priority:280
#| msgid "Force renaming or moving of a file even if the target exists"
msgid "Force renaming or moving of a file even if the <destination> exists."
msgstr "强制重命名或移动一个文件，即使目标存在。"

#. type: Plain text
#: en/git-mv.txt:39
#, priority:280
msgid "Skip move or rename actions which would lead to an error condition. An error happens when a source is neither existing nor controlled by Git, or when it would overwrite an existing file unless `-f` is given."
msgstr "跳过会导致错误情况的移动或重命名操作。当一个源文件既不存在也不被Git控制，或者它将覆盖一个现有的文件时，就会发生错误，除非给出`-f`。"

#. type: Plain text
#: en/git-mv.txt:42
#, priority:280
msgid "Do nothing; only show what would happen"
msgstr "什么都不做；只显示会发生什么"

#. type: Plain text
#: en/git-mv.txt:46
#, priority:280
msgid "Report the names of files as they are moved."
msgstr "当文件被移动时，报告它们的名称。"

#. type: Plain text
#: en/git-mv.txt:54
#, priority:280
msgid "Moving a submodule using a gitfile (which means they were cloned with a Git version 1.7.8 or newer) will update the gitfile and core.worktree setting to make the submodule work in the new location.  It also will attempt to update the submodule.<name>.path setting in the linkgit:gitmodules[5] file and stage that file (unless -n is used)."
msgstr "使用 gitfile 移动一个子模块（这意味着它们是用 1.7.8 或更新的 Git 版本克隆的）将更新 gitfile 和 core.worktree 设置以使子模块在新的位置工作。  它也会尝试更新linkgit:gitmodules[5]文件中的submodule.<name>.path设置，并将该文件放入舞台（除非使用-n）。"

#. type: Plain text
#: en/git-mv.txt:66
#, priority:280
msgid "Each time a superproject update moves a populated submodule (e.g. when switching between commits before and after the move) a stale submodule checkout will remain in the old location and an empty directory will appear in the new location. To populate the submodule again in the new location the user will have to run \"git submodule update\" afterwards. Removing the old directory is only safe when it uses a gitfile, as otherwise the history of the submodule will be deleted too. Both steps will be obsolete when recursive submodule update has been implemented."
msgstr "每次超级项目更新移动一个已填充的子模块（例如，当在移动前后的提交之间切换时），一个陈旧的子模块检出将保留在旧的位置，一个空目录将出现在新的位置。要在新的位置再次填充子模块，用户将不得不在之后运行 \"git submodule update\"。移除舊目錄只有在使用 gitfile 時才是安全的，否則子模塊的歷史也會被刪除。当递归子模块更新被实施后，这两个步骤将被淘汰。"

#. type: Title =
#: en/git-name-rev.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-name-rev(1)"
msgstr "git-name-rev(1)"

#. type: Plain text
#: en/git-name-rev.txt:7
#, priority:100
msgid "git-name-rev - Find symbolic names for given revs"
msgstr "git-name-rev - 为给定的 rev 查找符号名称"

#. type: Plain text
#: en/git-name-rev.txt:14
#, ignore-ellipsis, no-wrap, priority:100
msgid ""
"'git name-rev' [--tags] [--refs=<pattern>]\n"
"\t       ( --all | --annotate-stdin | <commit-ish>... )\n"
msgstr ""
"'git name-rev' [--tags] [--refs=<pattern>]\n"
"\t       ( --all | --annotate-stdin | <commit-ish>... )\n"

#. type: Plain text
#: en/git-name-rev.txt:19
#, priority:100
msgid "Finds symbolic names suitable for human digestion for revisions given in any format parsable by 'git rev-parse'."
msgstr "查找适合人类理解的符号名称，这些名称是以 'git rev-parse' 可解析的任何格式给出的修订。"

#. type: Plain text
#: en/git-name-rev.txt:26
#, priority:100
msgid "Do not use branch names, but only tags to name the commits"
msgstr "不要使用分支名称，只用标签来命名提交内容"

#. type: Labeled list
#: en/git-name-rev.txt:27
#, fuzzy, no-wrap, priority:100
msgid "--refs=<pattern>"
msgstr "--refs=<pattern>"

#. type: Plain text
#: en/git-name-rev.txt:32
#, priority:100
msgid "Only use refs whose names match a given shell pattern.  The pattern can be one of branch name, tag name or fully qualified ref name. If given multiple times, use refs whose names match any of the given shell patterns. Use `--no-refs` to clear any previous ref patterns given."
msgstr "只使用名称与给定的 shell 模式相匹配的引用。 该模式可以是分支名称、标签名称或完全合格的引用名之一。如果给定多次，使用名称与任何给定的 shell 模式相匹配的引用。使用 `--no-refs` 来清除之前给出的任何引用模式。"

#. type: Plain text
#: en/git-name-rev.txt:41
#, priority:100
msgid "Do not use any ref whose name matches a given shell pattern. The pattern can be one of branch name, tag name or fully qualified ref name. If given multiple times, a ref will be excluded when it matches any of the given patterns. When used together with --refs, a ref will be used as a match only when it matches at least one --refs pattern and does not match any --exclude patterns. Use `--no-exclude` to clear the list of exclude patterns."
msgstr "不要使用其名称与给定的壳模式相匹配的任何引用。该模式可以是分支名称、标签名称或完全合格的引用名称之一。如果多次给定，当一个引用与任何给定的模式匹配时，它将被排除。当与 --refs 一起使用时，只有当一个引用至少与一个 --refs 模式相匹配，并且不与任何 --exclude 模式相匹配时，才会被用作匹配。使用 `--no-exclude` 来清除排除模式的列表。"

#. type: Plain text
#: en/git-name-rev.txt:44
#, priority:100
msgid "List all commits reachable from all refs"
msgstr "列出所有引用所可达的所有提交"

#. type: Labeled list
#: en/git-name-rev.txt:45
#, ignore-same, no-wrap, priority:100
msgid "--annotate-stdin"
msgstr "--annotate-stdin"

#. type: Plain text
#: en/git-name-rev.txt:51
#, priority:100
msgid "Transform stdin by substituting all the 40-character SHA-1 hexes (say $hex) with \"$hex ($rev_name)\".  When used with --name-only, substitute with \"$rev_name\", omitting $hex altogether. This option was called `--stdin` in older versions of Git."
msgstr "通过用 \"$hex ($rev_name)\" 替换所有 40 个字符的 SHA-1 六位数（比如 $hex）来转换标准输入。 当与 --name-only 一起使用时，用 \"$rev_name\" 替代，完全省略 $hex。这个选项在旧版本的 Git 中被称为 `--stdin`。"

#. type: delimited block -
#: en/git-name-rev.txt:56
#, no-wrap, priority:100
msgid "$ cat sample.txt\n"
msgstr "$ cat sample.txt\n"

#. type: delimited block -
#: en/git-name-rev.txt:60
#, no-wrap, priority:100
msgid ""
"An abbreviated revision 2ae0a9cb82 will not be substituted.\n"
"The full name after substitution is 2ae0a9cb8298185a94e5998086f380a355dd8907,\n"
"while its tree object is 70d105cc79e63b81cfdcb08a15297c23e60b07ad\n"
msgstr ""
"An abbreviated revision 2ae0a9cb82 will not be substituted.\n"
"The full name after substitution is 2ae0a9cb8298185a94e5998086f380a355dd8907,\n"
"while its tree object is 70d105cc79e63b81cfdcb08a15297c23e60b07ad\n"

#. type: delimited block -
#: en/git-name-rev.txt:62
#, no-wrap, priority:100
msgid "$ git name-rev --annotate-stdin <sample.txt\n"
msgstr "$ git name-rev --annotate-stdin <sample.txt\n"

#. type: delimited block -
#: en/git-name-rev.txt:66
#, no-wrap, priority:100
msgid ""
"An abbreviated revision 2ae0a9cb82 will not be substituted.\n"
"The full name after substitution is 2ae0a9cb8298185a94e5998086f380a355dd8907 (master),\n"
"while its tree object is 70d105cc79e63b81cfdcb08a15297c23e60b07ad\n"
msgstr ""
"An abbreviated revision 2ae0a9cb82 will not be substituted.\n"
"The full name after substitution is 2ae0a9cb8298185a94e5998086f380a355dd8907 (master),\n"
"while its tree object is 70d105cc79e63b81cfdcb08a15297c23e60b07ad\n"

#. type: delimited block -
#: en/git-name-rev.txt:68
#, no-wrap, priority:100
msgid "$ git name-rev --name-only --annotate-stdin <sample.txt\n"
msgstr "$ git name-rev --name-only --annotate-stdin <sample.txt\n"

#. type: delimited block -
#: en/git-name-rev.txt:72
#, no-wrap, priority:100
msgid ""
"An abbreviated revision 2ae0a9cb82 will not be substituted.\n"
"The full name after substitution is master,\n"
"while its tree object is 70d105cc79e63b81cfdcb08a15297c23e60b07ad\n"
msgstr ""
"An abbreviated revision 2ae0a9cb82 will not be substituted.\n"
"The full name after substitution is master,\n"
"while its tree object is 70d105cc79e63b81cfdcb08a15297c23e60b07ad\n"

#. type: Plain text
#: en/git-name-rev.txt:79
#, priority:100
msgid "Instead of printing both the SHA-1 and the name, print only the name.  If given with --tags the usual tag prefix of \"tags/\" is also omitted from the name, matching the output of `git-describe` more closely."
msgstr "不要同时打印 SHA-1 和名字，而只打印名字。 如果给与--标签，通常的标签前缀 \"tags/\" 也会从名称中省略，与 `git-describe` 的输出更接近。"

#. type: Labeled list
#: en/git-name-rev.txt:80
#, ignore-same, no-wrap, priority:100
msgid "--no-undefined"
msgstr "--no-undefined"

#. type: Plain text
#: en/git-name-rev.txt:83
#, priority:100
msgid "Die with error code != 0 when a reference is undefined, instead of printing `undefined`."
msgstr "当一个引用未被定义时，以错误代码不为 0 的方式退出，而不是打印 `undefined`。"

#. type: Plain text
#: en/git-name-rev.txt:94
#, priority:100
msgid "Given a commit, find out where it is relative to the local refs. Say somebody wrote you about that fantastic commit 33db5f4d9027a10e477ccf054b2c1ab94f74c85a.  Of course, you look into the commit, but that only tells you what happened, but not the context."
msgstr "给出一个提交，找出它在本地引用中的相对位置。假设有人给你写了关于 33db5f4d9027a10e477ccf054b2c1ab94f74c85a 的精彩提交。 当然，你会去查这个提交，但这只能告诉你发生了什么，但不能告诉你背景。"

#. type: Plain text
#: en/git-name-rev.txt:96
#, priority:100
msgid "Enter 'git name-rev':"
msgstr "输入 'git name-rev'："

#. type: delimited block -
#: en/git-name-rev.txt:100
#, fuzzy, no-wrap, priority:100
msgid ""
"% git name-rev 33db5f4d9027a10e477ccf054b2c1ab94f74c85a\n"
"33db5f4d9027a10e477ccf054b2c1ab94f74c85a tags/v0.99~940\n"
msgstr ""
"% git name-rev 33db5f4d9027a10e477ccf054b2c1ab94f74c85a\n"
"33db5f4d9027a10e477ccf054b2c1ab94f74c85a tags/v0.99~940\n"

#. type: Plain text
#: en/git-name-rev.txt:103
#, priority:100
msgid "Now you are wiser, because you know that it happened 940 revisions before v0.99."
msgstr "现在你更聪明了，因为你知道它发生在 v0.99 之前的 940 次修订。"

#. type: Plain text
#: en/git-name-rev.txt:105
#, priority:100
msgid "Another nice thing you can do is:"
msgstr "你可以做的另一件好事是："

#. type: delimited block -
#: en/git-name-rev.txt:108
#, no-wrap, priority:100
msgid "% git log | git name-rev --annotate-stdin\n"
msgstr "% git log | git name-rev --annotate-stdin\n"

#. type: Title =
#: en/git-notes.txt:2
#, ignore-same, no-wrap, priority:280
msgid "git-notes(1)"
msgstr "git-notes(1)"

#. type: Plain text
#: en/git-notes.txt:7
#, fuzzy, priority:280
msgid "git-notes - Add or inspect object notes"
msgstr "git-notes - Add or inspect object notes"

#. type: Plain text
#: en/git-notes.txt:23
#, fuzzy, ignore-ellipsis, no-wrap, priority:280
#| msgid ""
#| "'git notes' [list [<object>]]\n"
#| "'git notes' add [-f] [--allow-empty] [-F <file> | -m <msg> | (-c | -C) <object>] [<object>]\n"
#| "'git notes' copy [-f] ( --stdin | <from-object> [<to-object>] )\n"
#| "'git notes' append [--allow-empty] [-F <file> | -m <msg> | (-c | -C) <object>] [<object>]\n"
#| "'git notes' edit [--allow-empty] [<object>]\n"
#| "'git notes' show [<object>]\n"
#| "'git notes' merge [-v | -q] [-s <strategy> ] <notes-ref>\n"
#| "'git notes' merge --commit [-v | -q]\n"
#| "'git notes' merge --abort [-v | -q]\n"
#| "'git notes' remove [--ignore-missing] [--stdin] [<object>...]\n"
#| "'git notes' prune [-n] [-v]\n"
#| "'git notes' get-ref\n"
msgid ""
"'git notes' [list [<object>]]\n"
"'git notes' add [-f] [--allow-empty] [--[no-]separator | --separator=<paragraph-break>] [--[no-]stripspace] [-F <file> | -m <msg> | (-c | -C) <object>] [<object>]\n"
"'git notes' copy [-f] ( --stdin | <from-object> [<to-object>] )\n"
"'git notes' append [--allow-empty] [--[no-]separator | --separator=<paragraph-break>] [--[no-]stripspace] [-F <file> | -m <msg> | (-c | -C) <object>] [<object>]\n"
"'git notes' edit [--allow-empty] [<object>] [--[no-]stripspace]\n"
"'git notes' show [<object>]\n"
"'git notes' merge [-v | -q] [-s <strategy> ] <notes-ref>\n"
"'git notes' merge --commit [-v | -q]\n"
"'git notes' merge --abort [-v | -q]\n"
"'git notes' remove [--ignore-missing] [--stdin] [<object>...]\n"
"'git notes' prune [-n] [-v]\n"
"'git notes' get-ref\n"
msgstr ""
"'git notes' [list [<object>]]\n"
"'git notes' add [-f] [--allow-empty] [-F <file> | -m <msg> | (-c | -C) <object>] [<object>] 。\n"
"'git notes' copy [-f] ( --stdin | <from-object> [<to-object>] )\n"
"'git notes' append [--allow-empty] [-F <file> | -m <msg> | (-c | -C) <object>] [<object>]\n"
"'git notes' edit [--allow-empty] [<object>])\n"
"'git notes' 显示 [<object>]\n"
"'git notes' merge [-v | -q] [-s <strategy> ] <notes-ref>\n"
"'git notes' merge --commit [-v | -q]\n"
"'git notes' merge --abort [-v | -q]\n"
"'git notes' remove [--ignore-missing] [--stdin] [<object>...]。\n"
"'git notes' prune [-n] [-v]\n"
"'git notes' get-ref\n"

#. type: Plain text
#: en/git-notes.txt:29
#, priority:280
msgid "Adds, removes, or reads notes attached to objects, without touching the objects themselves."
msgstr "添加、删除或读取附在物体上的注释，而不接触物体本身。"

#. type: Plain text
#: en/git-notes.txt:34
#, priority:280
msgid "By default, notes are saved to and read from `refs/notes/commits`, but this default can be overridden.  See the OPTIONS, CONFIGURATION, and ENVIRONMENT sections below.  If this ref does not exist, it will be quietly created when it is first needed to store a note."
msgstr "默认情况下，笔记被保存到`refs/notes/commits`并从那里读取，但这个默认值可以被覆盖。  参见下面的OPTIONS, CONFIGURATION和ENVIRONMENT部分。  如果这个参考文献不存在，当它第一次需要存储笔记时，它将被悄悄地创建。"

#. type: Plain text
#: en/git-notes.txt:41
#, priority:280
msgid "A typical use of notes is to supplement a commit message without changing the commit itself. Notes can be shown by 'git log' along with the original commit message. To distinguish these notes from the message stored in the commit object, the notes are indented like the message, after an unindented line saying \"Notes (<refname>):\" (or \"Notes:\" for `refs/notes/commits`)."
msgstr "注释的一个典型用途是在不改变提交本身的情况下补充提交信息。注释可以通过 \"git log \"与原始提交信息一起显示。为了将这些注释与保存在提交对象中的消息区分开来，注释会像消息一样缩进，在未缩进的一行后面写上 \"注释（<参考名称>）：\"（或 \"注释：\"用于`参考/注释/提交`）。"

#. type: Plain text
#: en/git-notes.txt:45
#, priority:280
msgid "Notes can also be added to patches prepared with `git format-patch` by using the `--notes` option. Such notes are added as a patch commentary after a three dash separator line."
msgstr "注释也可以通过使用`git format-patch`选项添加到补丁中，`--notes`。这样的注释会作为补丁注释添加在三个破折号的分隔线之后。"

#. type: Plain text
#: en/git-notes.txt:48
#, fuzzy, priority:280
#| msgid "To change which notes are shown by 'git log', see the \"notes.displayRef\" configuration in linkgit:git-log[1]."
msgid "To change which notes are shown by 'git log', see the \"notes.displayRef\" discussion in <<CONFIGURATION>>."
msgstr "要改变 \"git log \"所显示的笔记，请看 linkgit:git-log[1] 中的 \"notes.displayRef \"配置。"

#. type: Plain text
#: en/git-notes.txt:51
#, priority:280
msgid "See the \"notes.rewrite.<command>\" configuration for a way to carry notes across commands that rewrite commits."
msgstr "参见 \"notes.rewrite.<command>\"配置，以了解在重写提交的命令中携带笔记的方法。"

#. type: Title -
#: en/git-notes.txt:54
#, no-wrap, priority:280
msgid "SUBCOMMANDS"
msgstr "次级单位"

#. type: Labeled list
#: en/git-notes.txt:56 en/git-worktree.txt:109
#, ignore-same, no-wrap, priority:280
msgid "list"
msgstr "list"

#. type: Plain text
#: en/git-notes.txt:61
#, priority:280
msgid "List the notes object for a given object. If no object is given, show a list of all note objects and the objects they annotate (in the format \"<note object> <annotated object>\").  This is the default subcommand if no subcommand is given."
msgstr "列出给定对象的注释对象。如果没有给定对象，则显示所有注解对象及其注解的对象的列表（格式为\"<注解对象><注解对象>\"）。  如果没有给出子命令，这是默认的子命令。"

#. type: Labeled list
#: en/git-notes.txt:62
#, ignore-same, no-wrap, priority:280
msgid "add"
msgstr "add"

#. type: Plain text
#: en/git-notes.txt:71
#, fuzzy, priority:280
#| msgid "Add notes for a given object (defaults to HEAD). Abort if the object already has notes (use `-f` to overwrite existing notes).  However, if you're using `add` interactively (using an editor to supply the notes contents), then - instead of aborting - the existing notes will be opened in the editor (like the `edit` subcommand)."
msgid "Add notes for a given object (defaults to HEAD). Abort if the object already has notes (use `-f` to overwrite existing notes).  However, if you're using `add` interactively (using an editor to supply the notes contents), then - instead of aborting - the existing notes will be opened in the editor (like the `edit` subcommand). If you specify multiple `-m` and `-F`, a blank line will be inserted between the messages. Use the `--separator` option to insert other delimiters."
msgstr "为一个给定的对象添加注释（默认为HEAD）。如果该对象已经有了注释，则放弃（使用`-f`覆盖现有的注释）。  然而，如果你正在交互式地使用`add`（使用编辑器提供注释内容），那么--而不是中止--现有的注释将在编辑器中打开（像`edit`子命令）。"

#. type: Labeled list
#: en/git-notes.txt:72
#, ignore-same, no-wrap, priority:280
msgid "copy"
msgstr "copy"

#. type: Plain text
#: en/git-notes.txt:78
#, priority:280
msgid "Copy the notes for the first object onto the second object (defaults to HEAD). Abort if the second object already has notes, or if the first object has none (use -f to overwrite existing notes to the second object). This subcommand is equivalent to: `git notes add [-f] -C $(git notes list <from-object>) <to-object>`"
msgstr "将第一个对象的注释复制到第二个对象上（默认为HEAD）。如果第二个对象已经有注解，或者第一个对象没有注解，则放弃（使用-f将现有注解覆盖到第二个对象）。这个子命令等同于。`git notes add [-f] -C $(git notes list <from-object>) <to-object>`。"

#. type: Plain text
#: en/git-notes.txt:80
#, priority:280
msgid "In `--stdin` mode, take lines in the format"
msgstr "在`--stdin`模式下，采取格式为"

#. type: delimited block -
#: en/git-notes.txt:83
#, fuzzy, no-wrap, priority:280
msgid "<from-object> SP <to-object> [ SP <rest> ] LF\n"
msgstr "<from-object> SP <to-object> [ SP <rest> ] LF\n"

#. type: Plain text
#: en/git-notes.txt:88
#, priority:280
msgid "on standard input, and copy the notes from each <from-object> to its corresponding <to-object>.  (The optional `<rest>` is ignored so that the command can read the input given to the `post-rewrite` hook.)"
msgstr "在标准输入中，将每个<from-object>中的注释复制到相应的<to-object>中。（可选的`<rest>`被忽略，以便命令可以读取给`post-rewrite`钩的输入）。"

#. type: Labeled list
#: en/git-notes.txt:89
#, ignore-same, no-wrap, priority:280
msgid "append"
msgstr "append"

#. type: Plain text
#: en/git-notes.txt:96
#, priority:280
msgid "Append new message(s) given by `-m` or `-F` options to an existing note, or add them as a new note if one does not exist, for the object (defaults to HEAD).  When appending to an existing note, a blank line is added before each new message as an inter-paragraph separator.  The separator can be customized with the `--separator` option."
msgstr ""

#. type: Labeled list
#: en/git-notes.txt:97
#, ignore-same, no-wrap, priority:280
msgid "edit"
msgstr "edit"

#. type: Plain text
#: en/git-notes.txt:99
#, priority:280
msgid "Edit the notes for a given object (defaults to HEAD)."
msgstr "编辑一个给定对象的注释（默认为HEAD）。"

#. type: Labeled list
#: en/git-notes.txt:100
#, ignore-same, no-wrap, priority:280
msgid "show"
msgstr "show"

#. type: Plain text
#: en/git-notes.txt:102
#, priority:280
msgid "Show the notes for a given object (defaults to HEAD)."
msgstr "显示一个给定对象的注释（默认为HEAD）。"

#. type: Labeled list
#: en/git-notes.txt:103 en/git-submodule.txt:165
#, ignore-same, no-wrap, priority:280
msgid "merge"
msgstr "merge"

#. type: Plain text
#: en/git-notes.txt:108
#, priority:280
msgid "Merge the given notes ref into the current notes ref.  This will try to merge the changes made by the given notes ref (called \"remote\") since the merge-base (if any) into the current notes ref (called \"local\")."
msgstr "将给定的注释参考文献合并到当前的注释参考文献中。  这将尝试把给定的注释（称为 \"远程\"）自合并基础（如果有的话）以来所做的修改合并到当前的注释（称为 \"本地\"）。"

#. type: Plain text
#: en/git-notes.txt:117
#, priority:280
msgid "If conflicts arise and a strategy for automatically resolving conflicting notes (see the \"NOTES MERGE STRATEGIES\" section) is not given, the \"manual\" resolver is used. This resolver checks out the conflicting notes in a special worktree (`.git/NOTES_MERGE_WORKTREE`), and instructs the user to manually resolve the conflicts there.  When done, the user can either finalize the merge with 'git notes merge --commit', or abort the merge with 'git notes merge --abort'."
msgstr "如果出现冲突，并且没有给出自动解决冲突笔记的策略（见 \"NOTES MERGE STRATEGIES \"一节），就会使用 \"手动 \"解决器。这个解决方法在一个特殊的工作树（`.git/NOTES_MERGE_WORKTREE`）中检查出冲突的笔记，并指示用户手动解决那里的冲突。  完成后，用户可以用 \"git notes merge --commit \"最终完成合并，或者用 \"git notes merge --abort \"中止合并。"

#. type: Labeled list
#: en/git-notes.txt:118 en/git-worktree.txt:136
#, ignore-same, no-wrap, priority:280
msgid "remove"
msgstr "remove"

#. type: Plain text
#: en/git-notes.txt:123
#, priority:280
msgid "Remove the notes for given objects (defaults to HEAD). When giving zero or one object from the command line, this is equivalent to specifying an empty note message to the `edit` subcommand."
msgstr "删除给定对象的注释（默认为HEAD）。当从命令行给出零或一个对象时，这相当于给`edit`子命令指定一个空的注释信息。"

#. type: Labeled list
#: en/git-notes.txt:124 en/git-worktree.txt:132
#, ignore-same, no-wrap, priority:280
msgid "prune"
msgstr "prune"

#. type: Plain text
#: en/git-notes.txt:126
#, priority:280
msgid "Remove all notes for non-existing/unreachable objects."
msgstr "删除所有不存在/无法到达的对象的注释。"

#. type: Labeled list
#: en/git-notes.txt:127
#, ignore-same, no-wrap, priority:280
msgid "get-ref"
msgstr "get-ref"

#. type: Plain text
#: en/git-notes.txt:130
#, priority:280
msgid "Print the current notes ref. This provides an easy way to retrieve the current notes ref (e.g. from scripts)."
msgstr "打印当前的注释参考。这提供了一个简单的方法来检索当前的笔记参考文献（例如从脚本中）。"

#. type: Plain text
#: en/git-notes.txt:137
#, priority:280
msgid "When adding notes to an object that already has notes, overwrite the existing notes (instead of aborting)."
msgstr "当向一个已经有注释的对象添加注释时，覆盖现有的注释（而不是中止）。"

#. type: Plain text
#: en/git-notes.txt:146
#, fuzzy, priority:280
#| msgid "Use the given note message (instead of prompting).  If multiple `-m` options are given, their values are concatenated as separate paragraphs.  Lines starting with `#` and empty lines other than a single line between paragraphs will be stripped out."
msgid "Use the given note message (instead of prompting).  If multiple `-m` options are given, their values are concatenated as separate paragraphs.  Lines starting with `#` and empty lines other than a single line between paragraphs will be stripped out, if you wish to keep them verbatim, use `--no-stripspace`."
msgstr "使用给定的注释信息（而不是提示）。  如果给定了多个`-m`选项，它们的值将作为单独的段落串联起来。  以`#`开头的行和段落之间的单行以外的空行将被剥离出来。"

#. type: Plain text
#: en/git-notes.txt:155
#, fuzzy, priority:280
#| msgid "Take the note message from the given file.  Use '-' to read the note message from the standard input.  Lines starting with `#` and empty lines other than a single line between paragraphs will be stripped out."
msgid "Take the note message from the given file.  Use '-' to read the note message from the standard input.  Lines starting with `#` and empty lines other than a single line between paragraphs will be stripped out, if you wish to keep them verbatim, use with `--no-stripspace` option."
msgstr "从给定的文件中获取注释信息。  使用'-'可以从标准输入中读取注释信息。  以 \"#\"开头的行和段落之间的单行以外的空行将被剥离出来。"

#. type: Labeled list
#: en/git-notes.txt:156
#, no-wrap, priority:280
msgid "-C <object>"
msgstr "-C <对象>"

#. type: Labeled list
#: en/git-notes.txt:157
#, fuzzy, no-wrap, priority:280
msgid "--reuse-message=<object>"
msgstr "--reuse-message=<object>"

#. type: Plain text
#: en/git-notes.txt:164
#, fuzzy, priority:280
#| msgid "Take the note message from the given file.  Use '-' to read the note message from the standard input.  Lines starting with `#` and empty lines other than a single line between paragraphs will be stripped out."
msgid "Take the given blob object (for example, another note) as the note message. (Use `git notes copy <object>` instead to copy notes between objects.).  By default, message will be copied verbatim, but if you wish to strip out the lines starting with `#` and empty lines other than a single line between paragraphs, use with`--stripspace` option."
msgstr "从给定的文件中获取注释信息。  使用'-'可以从标准输入中读取注释信息。  以 \"#\"开头的行和段落之间的单行以外的空行将被剥离出来。"

#. type: Labeled list
#: en/git-notes.txt:165
#, no-wrap, priority:280
msgid "-c <object>"
msgstr "-c <对象>"

#. type: Labeled list
#: en/git-notes.txt:166
#, fuzzy, no-wrap, priority:280
msgid "--reedit-message=<object>"
msgstr "--reedit-message=<object>"

#. type: Plain text
#: en/git-notes.txt:169
#, priority:280
msgid "Like '-C', but with `-c` the editor is invoked, so that the user can further edit the note message."
msgstr "像'-C'一样，但有了`-c'就会调用编辑器，这样用户就可以进一步编辑注释信息。"

#. type: Plain text
#: en/git-notes.txt:173
#, priority:280
msgid "Allow an empty note object to be stored. The default behavior is to automatically remove empty notes."
msgstr "允许存储一个空的笔记对象。默认行为是自动删除空笔记。"

#. type: Labeled list
#: en/git-notes.txt:174
#, no-wrap, priority:280
msgid "--[no-]separator, --separator=<paragraph-break>"
msgstr ""

#. type: Plain text
#: en/git-notes.txt:179
#, priority:280
msgid "Specify a string used as a custom inter-paragraph separator (a newline is added at the end as needed). If `--no-separator`, no separators will be added between paragraphs.  Defaults to a blank line."
msgstr ""

#. type: Labeled list
#: en/git-notes.txt:180
#, ignore-same, no-wrap, priority:280
msgid "--[no-]stripspace"
msgstr "--[no-]stripspace"

#. type: Plain text
#: en/git-notes.txt:186
#, priority:280
msgid "Strip leading and trailing whitespace from the note message.  Also strip out empty lines other than a single line between paragraphs. For lines starting with `#` will be stripped out in non-editor cases like \"-m\", \"-F\" and \"-C\", but not in editor case like \"git notes edit\", \"-c\", etc."
msgstr ""

#. type: Labeled list
#: en/git-notes.txt:187
#, fuzzy, no-wrap, priority:280
msgid "--ref <ref>"
msgstr "--ref <ref>"

#. type: Plain text
#: en/git-notes.txt:193
#, priority:280
msgid "Manipulate the notes tree in <ref>.  This overrides `GIT_NOTES_REF` and the \"core.notesRef\" configuration.  The ref specifies the full refname when it begins with `refs/notes/`; when it begins with `notes/`, `refs/` and otherwise `refs/notes/` is prefixed to form a full name of the ref."
msgstr "操纵<ref>中的笔记树。  这覆盖了`GIT_NOTES_REF`和 \"core.notesRef \"配置。  当Ref以`refs/notes/`开始时，指定完整的Ref名称；当它以`notes/`开始时，`refs/`，否则`refs/notes/`前缀，形成Ref的全名。"

#. type: Plain text
#: en/git-notes.txt:197
#, priority:280
msgid "Do not consider it an error to request removing notes from an object that does not have notes attached to it."
msgstr "不要认为请求从一个没有附加注释的对象上删除注释是一个错误。"

#. type: Plain text
#: en/git-notes.txt:202
#, priority:280
msgid "Also read the object names to remove notes from the standard input (there is no reason you cannot combine this with object names from the command line)."
msgstr "还可以从标准输入中读取对象名称来删除注释（你没有理由不把它与命令行的对象名称结合起来）。"

#. type: Plain text
#: en/git-notes.txt:207
#, priority:280
msgid "Do not remove anything; just report the object names whose notes would be removed."
msgstr "不要删除任何东西；只是报告其注释将被删除的对象名称。"

#. type: Labeled list
#: en/git-notes.txt:208 en/git-rebase.txt:375 en/merge-options.txt:143
#, fuzzy, no-wrap, priority:280
msgid "-s <strategy>"
msgstr "-s <strategy>"

#. type: Plain text
#: en/git-notes.txt:216
#, priority:280
msgid "When merging notes, resolve notes conflicts using the given strategy. The following strategies are recognized: \"manual\" (default), \"ours\", \"theirs\", \"union\" and \"cat_sort_uniq\".  This option overrides the \"notes.mergeStrategy\" configuration setting.  See the \"NOTES MERGE STRATEGIES\" section below for more information on each notes merge strategy."
msgstr "合并笔记时，使用给定的策略解决笔记冲突。以下策略是被认可的。\"手动\"（默认）、\"我们的\"、\"他们的\"、\"联合 \"和 \"cat_sort_uniq\"。  这个选项覆盖了 \"notes.mergeStrategy \"的配置设置。  关于每种笔记合并策略的更多信息，请看下面的 \"笔记合并策略 \"部分。"

#. type: Labeled list
#: en/git-notes.txt:217 en/merge-options.txt:1
#, ignore-same, no-wrap, priority:280
msgid "--commit"
msgstr "--commit"

#. type: Plain text
#: en/git-notes.txt:225
#, priority:280
msgid "Finalize an in-progress 'git notes merge'. Use this option when you have resolved the conflicts that 'git notes merge' stored in .git/NOTES_MERGE_WORKTREE. This amends the partial merge commit created by 'git notes merge' (stored in .git/NOTES_MERGE_PARTIAL) by adding the notes in .git/NOTES_MERGE_WORKTREE. The notes ref stored in the .git/NOTES_MERGE_REF symref is updated to the resulting commit."
msgstr "最终确定一个正在进行的'git notes merge'。当您解决了'git notes merge'存储在.git/NOTES_MERGE_WORKTREE中的冲突后，使用此选项。这将修正由'git notes merge'创建的部分合并提交（存储在.git/NOTES_MERGE_PARTIAL中），加入.git/NOTES_MERGE_WORKTREE中的注释。存储在 .git/NOTES_MERGE_REF 符号参考中的注释会被更新到结果提交中。"

#. type: Plain text
#: en/git-notes.txt:230
#, priority:280
msgid "Abort/reset an in-progress 'git notes merge', i.e. a notes merge with conflicts. This simply removes all files related to the notes merge."
msgstr "中止/重置正在进行的 \"git笔记合并\"，即有冲突的笔记合并。这只是删除了所有与笔记合并有关的文件。"

#. type: Plain text
#: en/git-notes.txt:234
#, priority:280
msgid "When merging notes, operate quietly."
msgstr "合并笔记时，要安静地操作。"

#. type: Plain text
#: en/git-notes.txt:240
#, priority:280
msgid "When merging notes, be more verbose.  When pruning notes, report all object names whose notes are removed."
msgstr "当合并笔记时，要更加详细。  当修剪注释时，报告所有被删除注释的对象名称。"

#. type: Plain text
#: en/git-notes.txt:254
#, ignore-ellipsis, priority:280
msgid "Commit notes are blobs containing extra information about an object (usually information to supplement a commit's message).  These blobs are taken from notes refs.  A notes ref is usually a branch which contains \"files\" whose paths are the object names for the objects they describe, with some directory separators included for performance reasons footnote:[Permitted pathnames have the form 'bf'`/`'fe'`/`'30'`/`'...'`/`'680d5a...': a sequence of directory names of two hexadecimal digits each followed by a filename with the rest of the object ID.]."
msgstr "提交注释是包含关于一个对象的额外信息（通常是补充提交信息的信息）的 blobs。  这些blobs取自注释参考。  一个注释参考通常是一个包含 \"文件 \"的分支，这些文件的路径是它们所描述的对象的名称，出于性能的考虑，还包括一些目录分隔符 footnote:[允许的路径名有'bf'`/`'fe'`/`'30'`/`'...`/`'680d5a...'的形式：一串由两个十六进制数字组成的目录名，后面是一个带有其余对象ID的文件名。]"

#. type: Plain text
#: en/git-notes.txt:261
#, priority:280
msgid "Every notes change creates a new commit at the specified notes ref.  You can therefore inspect the history of the notes by invoking, e.g., `git log -p notes/commits`.  Currently the commit message only records which operation triggered the update, and the commit authorship is determined according to the usual rules (see linkgit:git-commit[1]).  These details may change in the future."
msgstr "每一个笔记的变化都会在指定的笔记参考号上创建一个新的提交。  因此，你可以通过调用，例如，`git log -p notes/commits`，来检查笔记的历史。  目前，提交信息只记录了哪个操作触发了更新，而提交者的身份则根据通常的规则确定（见 linkgit:git-commit[1]）。  这些细节在未来可能会发生变化。"

#. type: Plain text
#: en/git-notes.txt:265
#, priority:280
msgid "It is also permitted for a notes ref to point directly to a tree object, in which case the history of the notes can be read with `git log -p -g <refname>`."
msgstr "也允许注释直接指向树状对象，在这种情况下，可以用`git log -p -g <refname>`读取注释的历史。"

#. type: Title -
#: en/git-notes.txt:268
#, no-wrap, priority:280
msgid "NOTES MERGE STRATEGIES"
msgstr "注释 合并策略"

#. type: Plain text
#: en/git-notes.txt:277
#, priority:280
msgid "The default notes merge strategy is \"manual\", which checks out conflicting notes in a special work tree for resolving notes conflicts (`.git/NOTES_MERGE_WORKTREE`), and instructs the user to resolve the conflicts in that work tree.  When done, the user can either finalize the merge with 'git notes merge --commit', or abort the merge with 'git notes merge --abort'."
msgstr "默认的笔记合并策略是 \"手动\"，它在一个用于解决笔记冲突的特殊工作树（`.git/NOTES_MERGE_WORKTREE`）中检查出冲突的笔记，并指示用户在该工作树中解决冲突。  完成后，用户可以用 \"git notes merge --commit \"最终完成合并，或者用 \"git notes merge --abort \"中止合并。"

#. type: Plain text
#: en/git-notes.txt:280
#, priority:280
msgid "Users may select an automated merge strategy from among the following using either -s/--strategy option or configuring notes.mergeStrategy accordingly:"
msgstr "用户可以使用-s/--strategy选项或相应地配置notes.mergeStrategy，从以下内容中选择一个自动合并策略。"

#. type: Plain text
#: en/git-notes.txt:283
#, priority:280
msgid "\"ours\" automatically resolves conflicting notes in favor of the local version (i.e. the current notes ref)."
msgstr "\"我们的 \"自动解决冲突的注释，支持本地版本（即当前的注释参考）。"

#. type: Plain text
#: en/git-notes.txt:287
#, priority:280
msgid "\"theirs\" automatically resolves notes conflicts in favor of the remote version (i.e. the given notes ref being merged into the current notes ref)."
msgstr "\"他们的 \"自动解决笔记冲突，有利于远程版本（即给定的笔记参考文献被合并到当前的笔记参考文献中）。"

#. type: Plain text
#: en/git-notes.txt:290
#, priority:280
msgid "\"union\" automatically resolves notes conflicts by concatenating the local and remote versions."
msgstr "\"union \"通过串联本地和远程版本自动解决注释冲突。"

#. type: Plain text
#: en/git-notes.txt:300
#, priority:280
msgid "\"cat_sort_uniq\" is similar to \"union\", but in addition to concatenating the local and remote versions, this strategy also sorts the resulting lines, and removes duplicate lines from the result. This is equivalent to applying the \"cat | sort | uniq\" shell pipeline to the local and remote versions. This strategy is useful if the notes follow a line-based format where one wants to avoid duplicated lines in the merge result.  Note that if either the local or remote version contain duplicate lines prior to the merge, these will also be removed by this notes merge strategy."
msgstr "\"cat_sort_uniq \"与 \"union \"类似，但除了连接本地和远程版本之外，这个策略还对结果行进行排序，并从结果中删除重复的行。这相当于对本地和远程版本应用 \"cat | sort | uniq \"shell流水线。如果笔记是基于行的格式，希望在合并结果中避免重复的行，那么这个策略就很有用。  请注意，如果本地或远程版本在合并前包含重复的行，这些行也会被这个笔记合并策略所删除。"

#. type: Plain text
#: en/git-notes.txt:307
#, priority:280
msgid "You can use notes to add annotations with information that was not available at the time a commit was written."
msgstr "你可以使用注释来添加提交时无法获得的信息的注释。"

#. type: delimited block -
#: en/git-notes.txt:313
#, fuzzy, ignore-ellipsis, no-wrap, priority:280
msgid ""
"$ git notes add -m 'Tested-by: Johannes Sixt <j6t@kdbg.org>' 72a144e2\n"
"$ git show -s 72a144e\n"
"[...]\n"
"    Signed-off-by: Junio C Hamano <gitster@pobox.com>\n"
msgstr ""
"$ git notes add -m 'Tested-by: Johannes Sixt <j6t@kdbg.org>' 72a144e2\n"
"$ git show -s 72a144e\n"
"[...]\n"
"    Signed-off-by: Junio C Hamano <gitster@pobox.com>\n"

#. type: delimited block -
#: en/git-notes.txt:316
#, no-wrap, priority:280
msgid ""
"Notes:\n"
"    Tested-by: Johannes Sixt <j6t@kdbg.org>\n"
msgstr ""
"注意事项。\n"
"    测试者： Johannes Sixt <j6t@kdbg.org>\n"

#. type: Plain text
#: en/git-notes.txt:321
#, priority:280
msgid "In principle, a note is a regular Git blob, and any kind of (non-)format is accepted.  You can binary-safely create notes from arbitrary files using 'git hash-object':"
msgstr "原则上，笔记是一个普通的Git blob，任何种类的（非）格式都可以接受。  你可以使用 \"git hash-object \"从任意文件中二进制安全地创建注释。"

#. type: delimited block -
#: en/git-notes.txt:326
#, fuzzy, no-wrap, priority:280
msgid ""
"$ cc *.c\n"
"$ blob=$(git hash-object -w a.out)\n"
"$ git notes --ref=built add --allow-empty -C \"$blob\" HEAD\n"
msgstr ""
"$ cc *.c\n"
"$ blob=$(git hash-object -w a.out)\n"
"$ git notes --ref=built add --allow-empty -C \"$blob\" HEAD\n"

#. type: Plain text
#: en/git-notes.txt:333
#, priority:280
msgid "(You cannot simply use `git notes --ref=built add -F a.out HEAD` because that is not binary-safe.)  Of course, it doesn't make much sense to display non-text-format notes with 'git log', so if you use such notes, you'll probably need to write some special-purpose tools to do something useful with them."
msgstr "(你不能简单地使用`git notes --ref=built add -F a.out HEAD`，因为这不是二进制安全的。)  当然，用'git log'来显示非文本格式的笔记没有什么意义，所以如果你使用这样的笔记，你可能需要写一些特殊用途的工具来对它们做一些有用的事情。"

#. type: Labeled list
#: en/git-notes.txt:339
#, ignore-same, no-wrap, priority:280
msgid "core.notesRef"
msgstr "core.notesRef"

#. type: Plain text
#: en/git-notes.txt:344
#, priority:280
msgid "Notes ref to read and manipulate instead of `refs/notes/commits`.  Must be an unabbreviated ref name.  This setting can be overridden through the environment and command line."
msgstr "读取和操作的注释，而不是`refs/notes/commits`。  必须是一个不简略的参考文献名称。  这个设置可以通过环境和命令行来覆盖。"

#. type: Labeled list
#: en/git-notes.txt:353
#, ignore-same, no-wrap, priority:280
msgid "`GIT_NOTES_REF`"
msgstr "`GIT_NOTES_REF`"

#. type: Plain text
#: en/git-notes.txt:356
#, priority:280
msgid "Which ref to manipulate notes from, instead of `refs/notes/commits`.  This overrides the `core.notesRef` setting."
msgstr "从哪个参考文献来操作笔记，而不是`refs/notes/commits`。  这覆盖了`core.notesRef'的设置。"

#. type: Labeled list
#: en/git-notes.txt:357
#, ignore-same, no-wrap, priority:280
msgid "`GIT_NOTES_DISPLAY_REF`"
msgstr "`GIT_NOTES_DISPLAY_REF`"

#. type: Plain text
#: en/git-notes.txt:363
#, priority:280
msgid "Colon-delimited list of refs or globs indicating which refs, in addition to the default from `core.notesRef` or `GIT_NOTES_REF`, to read notes from when showing commit messages.  This overrides the `notes.displayRef` setting."
msgstr "以冒号为界的参考文献或globs列表，表示除了默认的`core.notesRef`或`GIT_NOTES_REF`之外，在显示提交信息时要从哪些参考文献读取。  这取代了`notes.displayRef`的设置。"

#. type: Plain text
#: en/git-notes.txt:366
#, priority:280
msgid "A warning will be issued for refs that do not exist, but a glob that does not match any refs is silently ignored."
msgstr "对于不存在的 refs 将会发出警告，但是不匹配任何 refs 的 glob 会被默默地忽略。"

#. type: Labeled list
#: en/git-notes.txt:367
#, ignore-same, no-wrap, priority:280
msgid "`GIT_NOTES_REWRITE_MODE`"
msgstr "`GIT_NOTES_REWRITE_MODE`"

#. type: Plain text
#: en/git-notes.txt:372
#, priority:280
msgid "When copying notes during a rewrite, what to do if the target commit already has a note.  Must be one of `overwrite`, `concatenate`, `cat_sort_uniq`, or `ignore`.  This overrides the `core.rewriteMode` setting."
msgstr "在重写过程中复制注释时，如果目标提交已经有一个注释，该如何处理。  必须是`overwrite`, `concatenate`, `cat_sort_uniq`, 或 `ignore`之一。  这覆盖了`core.rewriteMode`的设置。"

#. type: Labeled list
#: en/git-notes.txt:373
#, ignore-same, no-wrap, priority:280
msgid "`GIT_NOTES_REWRITE_REF`"
msgstr "`GIT_NOTES_REWRITE_REF`"

#. type: Plain text
#: en/git-notes.txt:377
#, priority:280
msgid "When rewriting commits, which notes to copy from the original to the rewritten commit.  Must be a colon-delimited list of refs or globs."
msgstr "当重写提交时，要从原始提交中复制哪些注释到重写的提交中。  必须是一个以冒号分隔的 refs 或 globs 列表。"

#. type: Plain text
#: en/git-notes.txt:380
#, priority:280
msgid "If not set in the environment, the list of notes to copy depends on the `notes.rewrite.<command>` and `notes.rewriteRef` settings."
msgstr "如果环境中没有设置，要复制的笔记列表取决于`notes.rewrite.<command>`和`notes.rewriteRef`设置。"

#. type: Title =
#: en/git-p4.txt:2
#, ignore-same, no-wrap, priority:90
msgid "git-p4(1)"
msgstr "git-p4(1)"

#. type: Plain text
#: en/git-p4.txt:7
#, priority:90
msgid "git-p4 - Import from and submit to Perforce repositories"
msgstr "git-p4 - 从 Perforce 仓库导入和提交"

#. type: Plain text
#: en/git-p4.txt:16
#, fuzzy, ignore-ellipsis, no-wrap, priority:90
msgid ""
"'git p4 clone' [<sync-options>] [<clone-options>] <p4-depot-path>...\n"
"'git p4 sync' [<sync-options>] [<p4-depot-path>...]\n"
"'git p4 rebase'\n"
"'git p4 submit' [<submit-options>] [<master-branch-name>]\n"
msgstr ""
"'git p4 clone' [<sync options>] [<clone options>] <p4 depot path>...\n"
"'git p4 sync' [<sync options>] [<p4 depot path>...]\n"
"'git p4 rebase'\n"
"'git p4 submit' [<submit options>] [<master branch name>]\n"

#. type: Plain text
#: en/git-p4.txt:22
#, priority:90
msgid "This command provides a way to interact with p4 repositories using Git."
msgstr ""

#. type: Plain text
#: en/git-p4.txt:30
#, priority:90
msgid "Create a new Git repository from an existing p4 repository using 'git p4 clone', giving it one or more p4 depot paths.  Incorporate new commits from p4 changes with 'git p4 sync'.  The 'sync' command is also used to include new branches from other p4 depot paths.  Submit Git changes back to p4 using 'git p4 submit'.  The command 'git p4 rebase' does a sync plus rebases the current branch onto the updated p4 remote branch."
msgstr ""

#. type: Plain text
#: en/git-p4.txt:35
#, priority:90
msgid "Clone a repository:"
msgstr ""

#. type: delimited block -
#: en/git-p4.txt:38 en/git-p4.txt:71
#, no-wrap, priority:90
msgid "$ git p4 clone //depot/path/project\n"
msgstr ""

#. type: Plain text
#: en/git-p4.txt:41
#, priority:90
msgid "Do some work in the newly created Git repository:"
msgstr ""

#. type: delimited block -
#: en/git-p4.txt:46
#, fuzzy, no-wrap, priority:90
msgid ""
"$ cd project\n"
"$ vi foo.h\n"
"$ git commit -a -m \"edited foo.h\"\n"
msgstr ""
"$ cd project\n"
"$ vi foo.h\n"
"$ git commit -a -m \"edited foo.h\"\n"

#. type: Plain text
#: en/git-p4.txt:50
#, priority:90
msgid "Update the Git repository with recent changes from p4, rebasing your work on top:"
msgstr ""

#. type: delimited block -
#: en/git-p4.txt:53 en/git-p4.txt:130
#, fuzzy, no-wrap, priority:90
msgid "$ git p4 rebase\n"
msgstr "$ git p4 rebase\n"

#. type: Plain text
#: en/git-p4.txt:56
#, priority:90
msgid "Submit your commits back to p4:"
msgstr ""

#. type: delimited block -
#: en/git-p4.txt:59 en/git-p4.txt:145
#, fuzzy, no-wrap, priority:90
msgid "$ git p4 submit\n"
msgstr "$ git p4 submit\n"

#. type: Title ~
#: en/git-p4.txt:66
#, fuzzy, no-wrap, priority:90
msgid "Clone"
msgstr "克隆"

#. type: Plain text
#: en/git-p4.txt:69
#, priority:90
msgid "Generally, 'git p4 clone' is used to create a new Git directory from an existing p4 repository:"
msgstr ""

#. type: Plain text
#: en/git-p4.txt:73
#, priority:90
msgid "This:"
msgstr ""

#. type: Plain text
#: en/git-p4.txt:75
#, priority:90
msgid "Creates an empty Git repository in a subdirectory called 'project'."
msgstr ""

#. type: Plain text
#: en/git-p4.txt:78
#, priority:90
msgid "Imports the full contents of the head revision from the given p4 depot path into a single commit in the Git branch 'refs/remotes/p4/master'."
msgstr ""

#. type: Plain text
#: en/git-p4.txt:80
#, priority:90
msgid "Creates a local branch, 'master' from this remote and checks it out."
msgstr ""

#. type: Plain text
#: en/git-p4.txt:83
#, priority:90
msgid "To reproduce the entire p4 history in Git, use the '@all' modifier on the depot path:"
msgstr ""

#. type: delimited block -
#: en/git-p4.txt:85
#, fuzzy, no-wrap, priority:90
msgid "$ git p4 clone //depot/path/project@all\n"
msgstr "$ git p4 clone //depot/path/project@all\n"

#. type: Title ~
#: en/git-p4.txt:89
#, fuzzy, no-wrap, priority:90
msgid "Sync"
msgstr "同步"

#. type: Plain text
#: en/git-p4.txt:92
#, priority:90
msgid "As development continues in the p4 repository, those changes can be included in the Git repository using:"
msgstr ""

#. type: delimited block -
#: en/git-p4.txt:94
#, fuzzy, no-wrap, priority:90
msgid "$ git p4 sync\n"
msgstr "$ git p4 sync\n"

#. type: Plain text
#: en/git-p4.txt:96
#, priority:90
msgid "This command finds new changes in p4 and imports them as Git commits."
msgstr ""

#. type: Plain text
#: en/git-p4.txt:99
#, priority:90
msgid "P4 repositories can be added to an existing Git repository using 'git p4 sync' too:"
msgstr ""

#. type: delimited block -
#: en/git-p4.txt:104
#, fuzzy, no-wrap, priority:90
msgid ""
"$ mkdir repo-git\n"
"$ cd repo-git\n"
"$ git init\n"
"$ git p4 sync //path/in/your/perforce/depot\n"
msgstr ""
"$ mkdir repo-git\n"
"$ cd repo-git\n"
"$ git init\n"
"$ git p4 sync //path/in/your/perforce/depot\n"

#. type: Plain text
#: en/git-p4.txt:109
#, priority:90
msgid "This imports the specified depot into 'refs/remotes/p4/master' in an existing Git repository.  The `--branch` option can be used to specify a different branch to be used for the p4 content."
msgstr ""

#. type: Plain text
#: en/git-p4.txt:114
#, priority:90
msgid "If a Git repository includes branches 'refs/remotes/origin/p4', these will be fetched and consulted first during a 'git p4 sync'.  Since importing directly from p4 is considerably slower than pulling changes from a Git remote, this can be useful in a multi-developer environment."
msgstr ""

#. type: Plain text
#: en/git-p4.txt:119
#, priority:90
msgid "If there are multiple branches, doing 'git p4 sync' will automatically use the \"BRANCH DETECTION\" algorithm to try to partition new changes into the right branch.  This can be overridden with the `--branch` option to specify just a single branch to update."
msgstr ""

#. type: Title ~
#: en/git-p4.txt:122
#, fuzzy, no-wrap, priority:90
msgid "Rebase"
msgstr "重写"

#. type: Plain text
#: en/git-p4.txt:128
#, priority:90
msgid "A common working pattern is to fetch the latest changes from the p4 depot and merge them with local uncommitted changes.  Often, the p4 repository is the ultimate location for all code, thus a rebase workflow makes sense.  This command does 'git p4 sync' followed by 'git rebase' to move local commits on top of updated p4 changes."
msgstr ""

#. type: Title ~
#: en/git-p4.txt:134
#, fuzzy, no-wrap, priority:90
msgid "Submit"
msgstr "提交"

#. type: Plain text
#: en/git-p4.txt:140
#, priority:90
msgid "Submitting changes from a Git repository back to the p4 repository requires a separate p4 client workspace.  This should be specified using the `P4CLIENT` environment variable or the Git configuration variable 'git-p4.client'.  The p4 client must exist, but the client root will be created and populated if it does not already exist."
msgstr ""

#. type: Plain text
#: en/git-p4.txt:143
#, priority:90
msgid "To submit all changes that are in the current Git branch but not in the 'p4/master' branch, use:"
msgstr ""

#. type: Plain text
#: en/git-p4.txt:148
#, priority:90
msgid "To specify a branch other than the current one, use:"
msgstr ""

#. type: delimited block -
#: en/git-p4.txt:150
#, fuzzy, no-wrap, priority:90
msgid "$ git p4 submit topicbranch\n"
msgstr "$ git p4 submit topicbranch\n"

#. type: Plain text
#: en/git-p4.txt:153
#, priority:90
msgid "To specify a single commit or a range of commits, use:"
msgstr ""

#. type: delimited block -
#: en/git-p4.txt:156
#, fuzzy, no-wrap, priority:90
msgid ""
"$ git p4 submit --commit <sha1>\n"
"$ git p4 submit --commit <sha1..sha1>\n"
msgstr ""
"$ git p4 submit --commit <sha1>\n"
"$ git p4 submit --commit <sha1..sha1>\n"

#. type: Plain text
#: en/git-p4.txt:160
#, priority:90
msgid "The upstream reference is generally 'refs/remotes/p4/master', but can be overridden using the `--origin=` command-line option."
msgstr ""

#. type: Plain text
#: en/git-p4.txt:165
#, priority:90
msgid "The p4 changes will be created as the user invoking 'git p4 submit'. The `--preserve-user` option will cause ownership to be modified according to the author of the Git commit.  This option requires admin privileges in p4, which can be granted using 'p4 protect'."
msgstr ""

#. type: Plain text
#: en/git-p4.txt:167
#, priority:90
msgid "To shelve changes instead of submitting, use `--shelve` and `--update-shelve`:"
msgstr ""

#. type: delimited block -
#: en/git-p4.txt:171
#, fuzzy, no-wrap, priority:90
msgid ""
"$ git p4 submit --shelve\n"
"$ git p4 submit --update-shelve 1234 --update-shelve 2345\n"
msgstr ""
"$ git p4 submit --shelve\n"
"$ git p4 submit --update-shelve 1234 --update-shelve 2345\n"

#. type: Title ~
#: en/git-p4.txt:175
#, fuzzy, no-wrap, priority:90
msgid "Unshelve"
msgstr "Unshelve"

#. type: Plain text
#: en/git-p4.txt:178
#, priority:90
msgid "Unshelving will take a shelved P4 changelist, and produce the equivalent git commit in the branch refs/remotes/p4-unshelved/<changelist>."
msgstr ""

#. type: Plain text
#: en/git-p4.txt:182
#, priority:90
msgid "The git commit is created relative to the current origin revision (HEAD by default).  A parent commit is created based on the origin, and then the unshelve commit is created based on that."
msgstr ""

#. type: Plain text
#: en/git-p4.txt:184
#, priority:90
msgid "The origin revision can be changed with the \"--origin\" option."
msgstr ""

#. type: Plain text
#: en/git-p4.txt:187
#, priority:90
msgid "If the target branch in refs/remotes/p4-unshelved already exists, the old one will be renamed."
msgstr ""

#. type: delimited block -
#: en/git-p4.txt:195
#, fuzzy, no-wrap, priority:90
msgid ""
"$ git p4 sync\n"
"$ git p4 unshelve 12345\n"
"$ git show p4-unshelved/12345\n"
"<submit more changes via p4 to the same files>\n"
"$ git p4 unshelve 12345\n"
"<refuses to unshelve until git is in sync with p4 again>\n"
msgstr ""
"$ git p4 sync\n"
"$ git p4 unshelve 12345\n"
"$ git show p4-unshelved/12345\n"
"<submit more changes via p4 to the same files>\n"
"$ git p4 unshelve 12345\n"
"<refuses to unshelve until git is in sync with p4 again>\n"

#. type: Title ~
#: en/git-p4.txt:202
#, fuzzy, no-wrap, priority:90
msgid "General options"
msgstr "常规选项"

#. type: Plain text
#: en/git-p4.txt:204
#, priority:90
msgid "All commands except clone accept these options."
msgstr ""

#. type: Labeled list
#: en/git-p4.txt:205
#, fuzzy, no-wrap, priority:90
msgid "--git-dir <dir>"
msgstr "--git-dir <dir>"

#. type: Plain text
#: en/git-p4.txt:207
#, priority:90
msgid "Set the `GIT_DIR` environment variable.  See linkgit:git[1]."
msgstr ""

#. type: Plain text
#: en/git-p4.txt:211
#, priority:90
msgid "Provide more progress information."
msgstr ""

#. type: Title ~
#: en/git-p4.txt:213
#, fuzzy, no-wrap, priority:90
msgid "Sync options"
msgstr "同步选项"

#. type: Plain text
#: en/git-p4.txt:216
#, priority:90
msgid "These options can be used in the initial 'clone' as well as in subsequent 'sync' operations."
msgstr ""

#. type: Labeled list
#: en/git-p4.txt:217
#, fuzzy, no-wrap, priority:90
msgid "--branch <ref>"
msgstr "--branch <ref>"

#. type: Plain text
#: en/git-p4.txt:221
#, priority:90
msgid "Import changes into <ref> instead of refs/remotes/p4/master.  If <ref> starts with refs/, it is used as is.  Otherwise, if it does not start with p4/, that prefix is added."
msgstr ""

#. type: Plain text
#: en/git-p4.txt:225
#, priority:90
msgid "By default a <ref> not starting with refs/ is treated as the name of a remote-tracking branch (under refs/remotes/).  This behavior can be modified using the --import-local option."
msgstr ""

#. type: Plain text
#: en/git-p4.txt:227
#, priority:90
msgid "The default <ref> is \"master\"."
msgstr ""

#. type: Plain text
#: en/git-p4.txt:230
#, priority:90
msgid "This example imports a new remote \"p4/proj2\" into an existing Git repository:"
msgstr ""

#. type: delimited block -
#: en/git-p4.txt:234
#, fuzzy, no-wrap, priority:90
msgid ""
"    $ git init\n"
"    $ git p4 sync --branch=refs/remotes/p4/proj2 //depot/proj2\n"
msgstr ""
"    $ git init\n"
"    $ git p4 sync --branch=refs/remotes/p4/proj2 //depot/proj2\n"

#. type: Labeled list
#: en/git-p4.txt:236
#, ignore-same, no-wrap, priority:90
msgid "--detect-branches"
msgstr "--detect-branches"

#. type: Plain text
#: en/git-p4.txt:239
#, priority:90
msgid "Use the branch detection algorithm to find new paths in p4.  It is documented below in \"BRANCH DETECTION\"."
msgstr ""

#. type: Labeled list
#: en/git-p4.txt:240
#, no-wrap, priority:90
msgid "--changesfile <file>"
msgstr ""

#. type: Plain text
#: en/git-p4.txt:244
#, priority:90
msgid "Import exactly the p4 change numbers listed in 'file', one per line.  Normally, 'git p4' inspects the current p4 repository state and detects the changes it should import."
msgstr ""

#. type: Labeled list
#: en/git-p4.txt:245
#, ignore-same, no-wrap, priority:90
msgid "--silent"
msgstr "--silent"

#. type: Plain text
#: en/git-p4.txt:247
#, priority:90
msgid "Do not print any progress information."
msgstr ""

#. type: Labeled list
#: en/git-p4.txt:248
#, ignore-same, no-wrap, priority:90
msgid "--detect-labels"
msgstr "--detect-labels"

#. type: Plain text
#: en/git-p4.txt:252
#, priority:90
msgid "Query p4 for labels associated with the depot paths, and add them as tags in Git. Limited usefulness as only imports labels associated with new changelists. Deprecated."
msgstr ""

#. type: Labeled list
#: en/git-p4.txt:253 en/git-p4.txt:430
#, ignore-same, no-wrap, priority:90
msgid "--import-labels"
msgstr "--import-labels"

#. type: Plain text
#: en/git-p4.txt:255
#, priority:90
msgid "Import labels from p4 into Git."
msgstr ""

#. type: Labeled list
#: en/git-p4.txt:256
#, ignore-same, no-wrap, priority:90
msgid "--import-local"
msgstr "--import-local"

#. type: Plain text
#: en/git-p4.txt:263
#, priority:90
msgid "By default, p4 branches are stored in 'refs/remotes/p4/', where they will be treated as remote-tracking branches by linkgit:git-branch[1] and other commands.  This option instead puts p4 branches in 'refs/heads/p4/'.  Note that future sync operations must specify `--import-local` as well so that they can find the p4 branches in refs/heads."
msgstr ""

#. type: Labeled list
#: en/git-p4.txt:264
#, fuzzy, no-wrap, priority:90
msgid "--max-changes <n>"
msgstr "--max-changes <n>"

#. type: Plain text
#: en/git-p4.txt:270
#, priority:90
msgid "Import at most 'n' changes, rather than the entire range of changes included in the given revision specifier. A typical usage would be use '@all' as the revision specifier, but then to use '--max-changes 1000' to import only the last 1000 revisions rather than the entire revision history."
msgstr ""

#. type: Labeled list
#: en/git-p4.txt:271
#, no-wrap, priority:90
msgid "--changes-block-size <n>"
msgstr ""

#. type: Plain text
#: en/git-p4.txt:279
#, priority:90
msgid "The internal block size to use when converting a revision specifier such as '@all' into a list of specific change numbers. Instead of using a single call to 'p4 changes' to find the full list of changes for the conversion, there are a sequence of calls to 'p4 changes -m', each of which requests one block of changes of the given size. The default block size is 500, which should usually be suitable."
msgstr ""

#. type: Labeled list
#: en/git-p4.txt:280
#, ignore-same, no-wrap, priority:90
msgid "--keep-path"
msgstr "--keep-path"

#. type: Plain text
#: en/git-p4.txt:287
#, priority:90
msgid "The mapping of file names from the p4 depot path to Git, by default, involves removing the entire depot path.  With this option, the full p4 depot path is retained in Git.  For example, path '//depot/main/foo/bar.c', when imported from '//depot/main/', becomes 'foo/bar.c'.  With `--keep-path`, the Git path is instead 'depot/main/foo/bar.c'."
msgstr ""

#. type: Labeled list
#: en/git-p4.txt:288
#, ignore-same, no-wrap, priority:90
msgid "--use-client-spec"
msgstr "--use-client-spec"

#. type: Plain text
#: en/git-p4.txt:291
#, priority:90
msgid "Use a client spec to find the list of interesting files in p4.  See the \"CLIENT SPEC\" section below."
msgstr ""

#. type: Labeled list
#: en/git-p4.txt:292
#, no-wrap, priority:90
msgid "-/ <path>"
msgstr ""

#. type: Plain text
#: en/git-p4.txt:294
#, priority:90
msgid "Exclude selected depot paths when cloning or syncing."
msgstr ""

#. type: Title ~
#: en/git-p4.txt:296
#, no-wrap, priority:90
msgid "Clone options"
msgstr ""

#. type: Plain text
#: en/git-p4.txt:299
#, priority:90
msgid "These options can be used in an initial 'clone', along with the 'sync' options described above."
msgstr ""

#. type: Labeled list
#: en/git-p4.txt:300
#, no-wrap, priority:90
msgid "--destination <directory>"
msgstr ""

#. type: Plain text
#: en/git-p4.txt:304
#, priority:90
msgid "Where to create the Git repository.  If not provided, the last component in the p4 depot path is used to create a new directory."
msgstr ""

#. type: Plain text
#: en/git-p4.txt:307
#, priority:90
msgid "Perform a bare clone.  See linkgit:git-clone[1]."
msgstr ""

#. type: Title ~
#: en/git-p4.txt:309
#, no-wrap, priority:90
msgid "Submit options"
msgstr ""

#. type: Plain text
#: en/git-p4.txt:311
#, priority:90
msgid "These options can be used to modify 'git p4 submit' behavior."
msgstr ""

#. type: Labeled list
#: en/git-p4.txt:312
#, fuzzy, no-wrap, priority:90
msgid "--origin <commit>"
msgstr "--origin <commit>"

#. type: Plain text
#: en/git-p4.txt:316
#, priority:90
msgid "Upstream location from which commits are identified to submit to p4.  By default, this is the most recent p4 commit reachable from `HEAD`."
msgstr ""

#. type: Plain text
#: en/git-p4.txt:322
#, priority:90
msgid "Detect renames.  See linkgit:git-diff[1].  Renames will be represented in p4 using explicit 'move' operations.  There is no corresponding option to detect copies, but there are variables for both moves and copies."
msgstr ""

#. type: Labeled list
#: en/git-p4.txt:323
#, ignore-same, no-wrap, priority:90
msgid "--preserve-user"
msgstr "--preserve-user"

#. type: Plain text
#: en/git-p4.txt:326
#, priority:90
msgid "Re-author p4 changes before submitting to p4.  This option requires p4 admin privileges."
msgstr ""

#. type: Labeled list
#: en/git-p4.txt:327
#, ignore-same, no-wrap, priority:90
msgid "--export-labels"
msgstr "--export-labels"

#. type: Plain text
#: en/git-p4.txt:330
#, priority:90
msgid "Export tags from Git as p4 labels. Tags found in Git are applied to the perforce working directory."
msgstr ""

#. type: Plain text
#: en/git-p4.txt:335
#, priority:90
msgid "Show just what commits would be submitted to p4; do not change state in Git or p4."
msgstr ""

#. type: Labeled list
#: en/git-p4.txt:336
#, ignore-same, no-wrap, priority:90
msgid "--prepare-p4-only"
msgstr "--prepare-p4-only"

#. type: Plain text
#: en/git-p4.txt:342
#, priority:90
msgid "Apply a commit to the p4 workspace, opening, adding and deleting files in p4 as for a normal submit operation.  Do not issue the final \"p4 submit\", but instead print a message about how to submit manually or revert.  This option always stops after the first (oldest) commit.  Git tags are not exported to p4."
msgstr ""

#. type: Labeled list
#: en/git-p4.txt:343
#, ignore-same, no-wrap, priority:90
msgid "--shelve"
msgstr "--shelve"

#. type: Plain text
#: en/git-p4.txt:347
#, priority:90
msgid "Instead of submitting create a series of shelved changelists.  After creating each shelve, the relevant files are reverted/deleted.  If you have multiple commits pending multiple shelves will be created."
msgstr ""

#. type: Labeled list
#: en/git-p4.txt:348
#, no-wrap, priority:90
msgid "--update-shelve CHANGELIST"
msgstr ""

#. type: Plain text
#: en/git-p4.txt:351
#, priority:90
msgid "Update an existing shelved changelist with this commit. Implies --shelve. Repeat for multiple shelved changelists."
msgstr ""

#. type: Labeled list
#: en/git-p4.txt:352
#, fuzzy, no-wrap, priority:90
msgid "--conflict=(ask|skip|quit)"
msgstr "--conflict=(ask|skip|quit)"

#. type: Plain text
#: en/git-p4.txt:358
#, priority:90
msgid "Conflicts can occur when applying a commit to p4.  When this happens, the default behavior (\"ask\") is to prompt whether to skip this commit and continue, or quit.  This option can be used to bypass the prompt, causing conflicting commits to be automatically skipped, or to quit trying to apply commits, without prompting."
msgstr ""

#. type: Labeled list
#: en/git-p4.txt:359 en/git-submodule.txt:292
#, fuzzy, no-wrap, priority:220
msgid "--branch <branch>"
msgstr "--branch <branch>"

#. type: Plain text
#: en/git-p4.txt:363
#, priority:90
msgid "After submitting, sync this named branch instead of the default p4/master.  See the \"Sync options\" section above for more information."
msgstr ""

#. type: Labeled list
#: en/git-p4.txt:364
#, fuzzy, no-wrap, priority:90
msgid "--commit (<sha1>|<sha1>..<sha1>)"
msgstr "--commit <sha1>|<sha1..sha1>"

#. type: Plain text
#: en/git-p4.txt:367
#, priority:90
msgid "Submit only the specified commit or range of commits, instead of the full list of changes that are in the current Git branch."
msgstr ""

#. type: Labeled list
#: en/git-p4.txt:368
#, ignore-same, no-wrap, priority:90
msgid "--disable-rebase"
msgstr "--disable-rebase"

#. type: Plain text
#: en/git-p4.txt:371
#, priority:90
msgid "Disable the automatic rebase after all commits have been successfully submitted. Can also be set with git-p4.disableRebase."
msgstr ""

#. type: Labeled list
#: en/git-p4.txt:372
#, ignore-same, no-wrap, priority:90
msgid "--disable-p4sync"
msgstr "--disable-p4sync"

#. type: Plain text
#: en/git-p4.txt:376
#, priority:90
msgid "Disable the automatic sync of p4/master from Perforce after commits have been submitted. Implies --disable-rebase. Can also be set with git-p4.disableP4Sync. Sync with origin/master still goes ahead if possible."
msgstr ""

#. type: Title -
#: en/git-p4.txt:378
#, no-wrap, priority:90
msgid "Hooks for submit"
msgstr ""

#. type: Title ~
#: en/git-p4.txt:381
#, no-wrap, priority:90
msgid "p4-pre-submit"
msgstr ""

#. type: Plain text
#: en/git-p4.txt:387
#, priority:90
msgid "The `p4-pre-submit` hook is executed if it exists and is executable.  The hook takes no parameters and nothing from standard input. Exiting with non-zero status from this script prevents `git-p4 submit` from launching.  It can be bypassed with the `--no-verify` command line option."
msgstr ""

#. type: Plain text
#: en/git-p4.txt:389
#, priority:90
msgid "One usage scenario is to run unit tests in the hook."
msgstr ""

#. type: Title ~
#: en/git-p4.txt:391
#, fuzzy, no-wrap, priority:90
#| msgid "--ignore-space-change"
msgid "p4-prepare-changelist"
msgstr "p4-prepare-changelist"

#. type: Plain text
#: en/git-p4.txt:398
#, priority:90
msgid "The `p4-prepare-changelist` hook is executed right after preparing the default changelist message and before the editor is started.  It takes one parameter, the name of the file that contains the changelist text. Exiting with a non-zero status from the script will abort the process."
msgstr ""

#. type: Plain text
#: en/git-p4.txt:402
#, priority:90
msgid "The purpose of the hook is to edit the message file in place, and it is not suppressed by the `--no-verify` option. This hook is called even if `--prepare-p4-only` is set."
msgstr ""

#. type: Title ~
#: en/git-p4.txt:404
#, fuzzy, no-wrap, priority:90
#| msgid "`changes`"
msgid "p4-changelist"
msgstr "p4-changelist"

#. type: Plain text
#: en/git-p4.txt:411
#, priority:90
msgid "The `p4-changelist` hook is executed after the changelist message has been edited by the user. It can be bypassed with the `--no-verify` option. It takes a single parameter, the name of the file that holds the proposed changelist text. Exiting with a non-zero status causes the command to abort."
msgstr ""

#. type: Plain text
#: en/git-p4.txt:415
#, priority:90
msgid "The hook is allowed to edit the changelist file and can be used to normalize the text into some project standard format. It can also be used to refuse the Submit after inspect the message file."
msgstr ""

#. type: Title ~
#: en/git-p4.txt:417
#, no-wrap, priority:90
msgid "p4-post-changelist"
msgstr ""

#. type: Plain text
#: en/git-p4.txt:423
#, priority:90
msgid "The `p4-post-changelist` hook is invoked after the submit has successfully occurred in P4. It takes no parameters and is meant primarily for notification and cannot affect the outcome of the git p4 submit action."
msgstr ""

#. type: Title ~
#: en/git-p4.txt:427
#, no-wrap, priority:90
msgid "Rebase options"
msgstr ""

#. type: Plain text
#: en/git-p4.txt:429
#, priority:90
msgid "These options can be used to modify 'git p4 rebase' behavior."
msgstr ""

#. type: Plain text
#: en/git-p4.txt:432
#, priority:90
msgid "Import p4 labels."
msgstr ""

#. type: Title ~
#: en/git-p4.txt:434
#, no-wrap, priority:90
msgid "Unshelve options"
msgstr ""

#. type: Labeled list
#: en/git-p4.txt:436
#, ignore-same, no-wrap, priority:90
msgid "--origin"
msgstr "--origin"

#. type: Plain text
#: en/git-p4.txt:439
#, priority:90
msgid "Sets the git refspec against which the shelved P4 changelist is compared.  Defaults to p4/master."
msgstr ""

#. type: Title -
#: en/git-p4.txt:441
#, no-wrap, priority:90
msgid "DEPOT PATH SYNTAX"
msgstr ""

#. type: Plain text
#: en/git-p4.txt:445
#, priority:90
msgid "The p4 depot path argument to 'git p4 sync' and 'git p4 clone' can be one or more space-separated p4 depot paths, with an optional p4 revision specifier on the end:"
msgstr ""

#. type: Labeled list
#: en/git-p4.txt:446
#, no-wrap, priority:90
msgid "\"//depot/my/project\""
msgstr ""

#. type: Plain text
#: en/git-p4.txt:448
#, priority:90
msgid "Import one commit with all files in the '#head' change under that tree."
msgstr ""

#. type: Labeled list
#: en/git-p4.txt:449
#, no-wrap, priority:90
msgid "\"//depot/my/project@all\""
msgstr ""

#. type: Plain text
#: en/git-p4.txt:451
#, priority:90
msgid "Import one commit for each change in the history of that depot path."
msgstr ""

#. type: Labeled list
#: en/git-p4.txt:452
#, no-wrap, priority:90
msgid "\"//depot/my/project@1,6\""
msgstr ""

#. type: Plain text
#: en/git-p4.txt:454
#, priority:90
msgid "Import only changes 1 through 6."
msgstr ""

#. type: Labeled list
#: en/git-p4.txt:455
#, no-wrap, priority:90
msgid "\"//depot/proj1@all //depot/proj2@all\""
msgstr ""

#. type: Plain text
#: en/git-p4.txt:464
#, priority:90
msgid "Import all changes from both named depot paths into a single repository.  Only files below these directories are included.  There is not a subdirectory in Git for each \"proj1\" and \"proj2\".  You must use the `--destination` option when specifying more than one depot path.  The revision specifier must be specified identically on each depot path.  If there are files in the depot paths with the same name, the path with the most recently updated version of the file is the one that appears in Git."
msgstr ""

#. type: Plain text
#: en/git-p4.txt:466
#, fuzzy, priority:90
msgid "See 'p4 help revisions' for the full syntax of p4 revision specifiers."
msgstr "有关 p4 修订说明符的完整语法，请参阅 \"p4 帮助修订\"。"

#. type: Title -
#: en/git-p4.txt:469
#, fuzzy, no-wrap, priority:90
msgid "CLIENT SPEC"
msgstr "CLIENT SPEC"

#. type: Plain text
#: en/git-p4.txt:479
#, priority:90
msgid "The p4 client specification is maintained with the 'p4 client' command and contains among other fields, a View that specifies how the depot is mapped into the client repository.  The 'clone' and 'sync' commands can consult the client spec when given the `--use-client-spec` option or when the useClientSpec variable is true.  After 'git p4 clone', the useClientSpec variable is automatically set in the repository configuration file.  This allows future 'git p4 submit' commands to work properly; the submit command looks only at the variable and does not have a command-line option."
msgstr ""

#. type: Plain text
#: en/git-p4.txt:486
#, ignore-ellipsis, priority:90
msgid "The full syntax for a p4 view is documented in 'p4 help views'.  'git p4' knows only a subset of the view syntax.  It understands multi-line mappings, overlays with '+', exclusions with '-' and double-quotes around whitespace.  Of the possible wildcards, 'git p4' only handles '...', and only when it is at the end of the path.  'git p4' will complain if it encounters an unhandled wildcard."
msgstr ""

#. type: Plain text
#: en/git-p4.txt:491
#, priority:90
msgid "Bugs in the implementation of overlap mappings exist.  If multiple depot paths map through overlays to the same location in the repository, 'git p4' can choose the wrong one.  This is hard to solve without dedicating a client spec just for 'git p4'."
msgstr ""

#. type: Plain text
#: en/git-p4.txt:496
#, priority:90
msgid "The name of the client can be given to 'git p4' in multiple ways.  The variable 'git-p4.client' takes precedence if it exists.  Otherwise, normal p4 mechanisms of determining the client are used: environment variable `P4CLIENT`, a file referenced by `P4CONFIG`, or the local host name."
msgstr ""

#. type: Title -
#: en/git-p4.txt:499
#, no-wrap, priority:90
msgid "BRANCH DETECTION"
msgstr ""

#. type: Plain text
#: en/git-p4.txt:506
#, priority:90
msgid "P4 does not have the same concept of a branch as Git.  Instead, p4 organizes its content as a directory tree, where by convention different logical branches are in different locations in the tree.  The 'p4 branch' command is used to maintain mappings between different areas in the tree, and indicate related content.  'git p4' can use these mappings to determine branch relationships."
msgstr ""

#. type: Plain text
#: en/git-p4.txt:511
#, priority:90
msgid "If you have a repository where all the branches of interest exist as subdirectories of a single depot path, you can use `--detect-branches` when cloning or syncing to have 'git p4' automatically find subdirectories in p4, and to generate these as branches in Git."
msgstr ""

#. type: Plain text
#: en/git-p4.txt:513
#, priority:90
msgid "For example, if the P4 repository structure is:"
msgstr ""

#. type: delimited block -
#: en/git-p4.txt:516
#, ignore-ellipsis, no-wrap, priority:90
msgid ""
"//depot/main/...\n"
"//depot/branch1/...\n"
msgstr ""

#. type: Plain text
#: en/git-p4.txt:519
#, priority:90
msgid "And \"p4 branch -o branch1\" shows a View line that looks like:"
msgstr ""

#. type: delimited block -
#: en/git-p4.txt:521
#, ignore-ellipsis, no-wrap, priority:90
msgid "//depot/main/... //depot/branch1/...\n"
msgstr ""

#. type: Plain text
#: en/git-p4.txt:524
#, priority:90
msgid "Then this 'git p4 clone' command:"
msgstr ""

#. type: delimited block -
#: en/git-p4.txt:526
#, fuzzy, no-wrap, priority:90
msgid "git p4 clone --detect-branches //depot@all\n"
msgstr "git p4 clone --detect-branches //depot@all\n"

#. type: Plain text
#: en/git-p4.txt:529
#, priority:90
msgid "produces a separate branch in 'refs/remotes/p4/' for //depot/main, called 'master', and one for //depot/branch1 called 'depot/branch1'."
msgstr ""

#. type: Plain text
#: en/git-p4.txt:539
#, priority:90
msgid "However, it is not necessary to create branches in p4 to be able to use them like branches.  Because it is difficult to infer branch relationships automatically, a Git configuration setting 'git-p4.branchList' can be used to explicitly identify branch relationships.  It is a list of \"source:destination\" pairs, like a simple p4 branch specification, where the \"source\" and \"destination\" are the path elements in the p4 repository.  The example above relied on the presence of the p4 branch.  Without p4 branches, the same result will occur with:"
msgstr ""

#. type: delimited block -
#: en/git-p4.txt:544
#, fuzzy, no-wrap, priority:90
msgid ""
"git init depot\n"
"cd depot\n"
"git config git-p4.branchList main:branch1\n"
"git p4 clone --detect-branches //depot@all .\n"
msgstr ""
"git init depot\n"
"cd depot\n"
"git config git-p4.branchList main:branch1\n"
"git p4 clone --detect-branches //depot@all .\n"

#. type: Plain text
#: en/git-p4.txt:553
#, fuzzy, priority:90
msgid "The fast-import mechanism used by 'git p4' creates one pack file for each invocation of 'git p4 sync'.  Normally, Git garbage compression (linkgit:git-gc[1]) automatically compresses these to fewer pack files, but explicit invocation of 'git repack -adf' may improve performance."
msgstr "The fast-import mechanism used by 'git p4' creates one pack file for each invocation of 'git p4 sync'.  Normally, Git garbage compression (linkgit:git-gc[1]) automatically compresses these to fewer pack files, but explicit invocation of 'git repack -adf' may improve performance."

#. type: Plain text
#: en/git-p4.txt:559
#, priority:90
msgid "The following config settings can be used to modify 'git p4' behavior.  They all are in the 'git-p4' section."
msgstr ""

#. type: Title ~
#: en/git-p4.txt:561
#, fuzzy, no-wrap, priority:90
msgid "General variables"
msgstr "常规变量"

#. type: Labeled list
#: en/git-p4.txt:562
#, ignore-same, no-wrap, priority:90
msgid "git-p4.user"
msgstr "git-p4.user"

#. type: Plain text
#: en/git-p4.txt:565
#, priority:90
msgid "User specified as an option to all p4 commands, with '-u <user>'.  The environment variable `P4USER` can be used instead."
msgstr ""

#. type: Labeled list
#: en/git-p4.txt:566
#, ignore-same, no-wrap, priority:90
msgid "git-p4.password"
msgstr "git-p4.password"

#. type: Plain text
#: en/git-p4.txt:570
#, priority:90
msgid "Password specified as an option to all p4 commands, with '-P <password>'.  The environment variable `P4PASS` can be used instead."
msgstr ""

#. type: Labeled list
#: en/git-p4.txt:571
#, ignore-same, no-wrap, priority:90
msgid "git-p4.port"
msgstr "git-p4.port"

#. type: Plain text
#: en/git-p4.txt:575
#, priority:90
msgid "Port specified as an option to all p4 commands, with '-p <port>'.  The environment variable `P4PORT` can be used instead."
msgstr ""

#. type: Labeled list
#: en/git-p4.txt:576
#, ignore-same, no-wrap, priority:90
msgid "git-p4.host"
msgstr "git-p4.host"

#. type: Plain text
#: en/git-p4.txt:580
#, priority:90
msgid "Host specified as an option to all p4 commands, with '-h <host>'.  The environment variable `P4HOST` can be used instead."
msgstr ""

#. type: Labeled list
#: en/git-p4.txt:581
#, ignore-same, no-wrap, priority:90
msgid "git-p4.client"
msgstr "git-p4.client"

#. type: Plain text
#: en/git-p4.txt:584
#, priority:90
msgid "Client specified as an option to all p4 commands, with '-c <client>', including the client spec."
msgstr ""

#. type: Labeled list
#: en/git-p4.txt:585
#, ignore-same, no-wrap, priority:90
msgid "git-p4.retries"
msgstr "git-p4.retries"

#. type: Plain text
#: en/git-p4.txt:590
#, priority:90
msgid "Specifies the number of times to retry a p4 command (notably, 'p4 sync') if the network times out. The default value is 3.  Set the value to 0 to disable retries or if your p4 version does not support retries (pre 2012.2)."
msgstr ""

#. type: Title ~
#: en/git-p4.txt:592
#, no-wrap, priority:90
msgid "Clone and sync variables"
msgstr ""

#. type: Labeled list
#: en/git-p4.txt:593
#, ignore-same, no-wrap, priority:90
msgid "git-p4.syncFromOrigin"
msgstr "git-p4.syncFromOrigin"

#. type: Plain text
#: en/git-p4.txt:599
#, priority:90
msgid "Because importing commits from other Git repositories is much faster than importing them from p4, a mechanism exists to find p4 changes first in Git remotes.  If branches exist under 'refs/remote/origin/p4', those will be fetched and used when syncing from p4.  This variable can be set to 'false' to disable this behavior."
msgstr ""

#. type: Labeled list
#: en/git-p4.txt:600
#, ignore-same, no-wrap, priority:90
msgid "git-p4.branchUser"
msgstr "git-p4.branchUser"

#. type: Plain text
#: en/git-p4.txt:605
#, priority:90
msgid "One phase in branch detection involves looking at p4 branches to find new ones to import.  By default, all branches are inspected.  This option limits the search to just those owned by the single user named in the variable."
msgstr ""

#. type: Labeled list
#: en/git-p4.txt:606
#, ignore-same, no-wrap, priority:90
msgid "git-p4.branchList"
msgstr "git-p4.branchList"

#. type: Plain text
#: en/git-p4.txt:611
#, priority:90
msgid "List of branches to be imported when branch detection is enabled.  Each entry should be a pair of branch names separated by a colon (:).  This example declares that both branchA and branchB were created from main:"
msgstr ""

#. type: delimited block -
#: en/git-p4.txt:615
#, no-wrap, priority:90
msgid ""
"git config       git-p4.branchList main:branchA\n"
"git config --add git-p4.branchList main:branchB\n"
msgstr ""

#. type: Labeled list
#: en/git-p4.txt:617
#, no-wrap, priority:90
msgid "git-p4.ignoredP4Labels"
msgstr ""

#. type: Plain text
#: en/git-p4.txt:620
#, priority:90
msgid "List of p4 labels to ignore. This is built automatically as unimportable labels are discovered."
msgstr ""

#. type: Labeled list
#: en/git-p4.txt:621
#, ignore-same, no-wrap, priority:90
msgid "git-p4.importLabels"
msgstr "git-p4.importLabels"

#. type: Plain text
#: en/git-p4.txt:623
#, priority:90
msgid "Import p4 labels into git, as per --import-labels."
msgstr ""

#. type: Labeled list
#: en/git-p4.txt:624
#, ignore-same, no-wrap, priority:90
msgid "git-p4.labelImportRegexp"
msgstr "git-p4.labelImportRegexp"

#. type: Plain text
#: en/git-p4.txt:627
#, priority:90
msgid "Only p4 labels matching this regular expression will be imported. The default value is '[a-zA-Z0-9_\\-.]+$'."
msgstr ""

#. type: Labeled list
#: en/git-p4.txt:628
#, ignore-same, no-wrap, priority:90
msgid "git-p4.useClientSpec"
msgstr "git-p4.useClientSpec"

#. type: Plain text
#: en/git-p4.txt:633
#, priority:90
msgid "Specify that the p4 client spec should be used to identify p4 depot paths of interest.  This is equivalent to specifying the option `--use-client-spec`.  See the \"CLIENT SPEC\" section above.  This variable is a boolean, not the name of a p4 client."
msgstr ""

#. type: Labeled list
#: en/git-p4.txt:634
#, ignore-same, no-wrap, priority:90
msgid "git-p4.pathEncoding"
msgstr "git-p4.pathEncoding"

#. type: Plain text
#: en/git-p4.txt:642
#, priority:90
msgid "Perforce keeps the encoding of a path as given by the originating OS.  Git expects paths encoded as UTF-8. Use this config to tell git-p4 what encoding Perforce had used for the paths. This encoding is used to transcode the paths to UTF-8. As an example, Perforce on Windows often uses \"cp1252\" to encode path names. If this option is passed into a p4 clone request, it is persisted in the resulting new git repo."
msgstr ""

#. type: Labeled list
#: en/git-p4.txt:643
#, ignore-same, no-wrap, priority:90
msgid "git-p4.metadataDecodingStrategy"
msgstr "git-p4.metadataDecodingStrategy"

#. type: Plain text
#: en/git-p4.txt:667
#, priority:90
msgid "Perforce keeps the encoding of a changelist descriptions and user full names as stored by the client on a given OS. The p4v client uses the OS-local encoding, and so different users can end up storing different changelist descriptions or user full names in different encodings, in the same depot.  Git tolerates inconsistent/incorrect encodings in commit messages and author names, but expects them to be specified in utf-8.  git-p4 can use three different decoding strategies in handling the encoding uncertainty in Perforce: 'passthrough' simply passes the original bytes through from Perforce to git, creating usable but incorrectly-encoded data when the Perforce data is encoded as anything other than utf-8. 'strict' expects the Perforce data to be encoded as utf-8, and fails to import when this is not true.  'fallback' attempts to interpret the data as utf-8, and otherwise falls back to using a secondary encoding - by default the common windows encoding 'cp-1252' - with upper-range bytes escaped if decoding with the fallback encoding also fails.  Under python2 the default strategy is 'passthrough' for historical reasons, and under python3 the default is 'fallback'.  When 'strict' is selected and decoding fails, the error message will propose changing this config parameter as a workaround. If this option is passed into a p4 clone request, it is persisted into the resulting new git repo."
msgstr ""

#. type: Labeled list
#: en/git-p4.txt:668
#, ignore-same, no-wrap, priority:90
msgid "git-p4.metadataFallbackEncoding"
msgstr "git-p4.metadataFallbackEncoding"

#. type: Plain text
#: en/git-p4.txt:675
#, priority:90
msgid "Specify the fallback encoding to use when decoding Perforce author names and changelists descriptions using the 'fallback' strategy (see git-p4.metadataDecodingStrategy). The fallback encoding will only be used when decoding as utf-8 fails. This option defaults to cp1252, a common windows encoding. If this option is passed into a p4 clone request, it is persisted into the resulting new git repo."
msgstr ""

#. type: Labeled list
#: en/git-p4.txt:676
#, ignore-same, no-wrap, priority:90
msgid "git-p4.largeFileSystem"
msgstr "git-p4.largeFileSystem"

#. type: Plain text
#: en/git-p4.txt:682
#, priority:90
msgid "Specify the system that is used for large (binary) files. Please note that large file systems do not support the 'git p4 submit' command.  Only Git LFS is implemented right now (see https://git-lfs.github.com/ for more information). Download and install the Git LFS command line extension to use this option and configure it like this:"
msgstr ""

#. type: delimited block -
#: en/git-p4.txt:685
#, no-wrap, priority:90
msgid "git config       git-p4.largeFileSystem GitLFS\n"
msgstr ""

#. type: Labeled list
#: en/git-p4.txt:687
#, ignore-same, no-wrap, priority:90
msgid "git-p4.largeFileExtensions"
msgstr "git-p4.largeFileExtensions"

#. type: Plain text
#: en/git-p4.txt:690
#, priority:90
msgid "All files matching a file extension in the list will be processed by the large file system. Do not prefix the extensions with '.'."
msgstr ""

#. type: Labeled list
#: en/git-p4.txt:691
#, ignore-same, no-wrap, priority:90
msgid "git-p4.largeFileThreshold"
msgstr "git-p4.largeFileThreshold"

#. type: Plain text
#: en/git-p4.txt:695
#, priority:90
msgid "All files with an uncompressed size exceeding the threshold will be processed by the large file system. By default the threshold is defined in bytes. Add the suffix k, m, or g to change the unit."
msgstr ""

#. type: Labeled list
#: en/git-p4.txt:696
#, ignore-same, no-wrap, priority:90
msgid "git-p4.largeFileCompressedThreshold"
msgstr "git-p4.largeFileCompressedThreshold"

#. type: Plain text
#: en/git-p4.txt:701
#, priority:90
msgid "All files with a compressed size exceeding the threshold will be processed by the large file system. This option might slow down your clone/sync process. By default the threshold is defined in bytes. Add the suffix k, m, or g to change the unit."
msgstr ""

#. type: Labeled list
#: en/git-p4.txt:702
#, ignore-same, no-wrap, priority:90
msgid "git-p4.largeFilePush"
msgstr "git-p4.largeFilePush"

#. type: Plain text
#: en/git-p4.txt:705
#, priority:90
msgid "Boolean variable which defines if large files are automatically pushed to a server."
msgstr ""

#. type: Labeled list
#: en/git-p4.txt:706
#, ignore-same, no-wrap, priority:90
msgid "git-p4.keepEmptyCommits"
msgstr "git-p4.keepEmptyCommits"

#. type: Plain text
#: en/git-p4.txt:709
#, priority:90
msgid "A changelist that contains only excluded files will be imported as an empty commit if this boolean option is set to true."
msgstr ""

#. type: Labeled list
#: en/git-p4.txt:710
#, ignore-same, no-wrap, priority:90
msgid "git-p4.mapUser"
msgstr "git-p4.mapUser"

#. type: Plain text
#: en/git-p4.txt:713
#, priority:90
msgid "Map a P4 user to a name and email address in Git. Use a string with the following format to create a mapping:"
msgstr ""

#. type: delimited block -
#: en/git-p4.txt:716
#, no-wrap, priority:90
msgid "git config --add git-p4.mapUser \"p4user = First Last <mail@address.com>\"\n"
msgstr ""

#. type: Plain text
#: en/git-p4.txt:720
#, priority:90
msgid "A mapping will override any user information from P4. Mappings for multiple P4 user can be defined."
msgstr ""

#. type: Title ~
#: en/git-p4.txt:722
#, no-wrap, priority:90
msgid "Submit variables"
msgstr ""

#. type: Labeled list
#: en/git-p4.txt:723
#, ignore-same, no-wrap, priority:90
msgid "git-p4.detectRenames"
msgstr "git-p4.detectRenames"

#. type: Plain text
#: en/git-p4.txt:726
#, priority:90
msgid "Detect renames.  See linkgit:git-diff[1].  This can be true, false, or a score as expected by 'git diff -M'."
msgstr ""

#. type: Labeled list
#: en/git-p4.txt:727
#, ignore-same, no-wrap, priority:90
msgid "git-p4.detectCopies"
msgstr "git-p4.detectCopies"

#. type: Plain text
#: en/git-p4.txt:730
#, priority:90
msgid "Detect copies.  See linkgit:git-diff[1].  This can be true, false, or a score as expected by 'git diff -C'."
msgstr ""

#. type: Labeled list
#: en/git-p4.txt:731
#, ignore-same, no-wrap, priority:90
msgid "git-p4.detectCopiesHarder"
msgstr "git-p4.detectCopiesHarder"

#. type: Plain text
#: en/git-p4.txt:733
#, priority:90
msgid "Detect copies harder.  See linkgit:git-diff[1].  A boolean."
msgstr ""

#. type: Labeled list
#: en/git-p4.txt:734
#, ignore-same, no-wrap, priority:90
msgid "git-p4.preserveUser"
msgstr "git-p4.preserveUser"

#. type: Plain text
#: en/git-p4.txt:737
#, priority:90
msgid "On submit, re-author changes to reflect the Git author, regardless of who invokes 'git p4 submit'."
msgstr ""

#. type: Labeled list
#: en/git-p4.txt:738
#, no-wrap, priority:90
msgid "git-p4.allowMissingP4Users"
msgstr ""

#. type: Plain text
#: en/git-p4.txt:742
#, priority:90
msgid "When 'preserveUser' is true, 'git p4' normally dies if it cannot find an author in the p4 user map.  This setting submits the change regardless."
msgstr ""

#. type: Labeled list
#: en/git-p4.txt:743
#, ignore-same, no-wrap, priority:90
msgid "git-p4.skipSubmitEdit"
msgstr "git-p4.skipSubmitEdit"

#. type: Plain text
#: en/git-p4.txt:747
#, priority:90
msgid "The submit process invokes the editor before each p4 change is submitted.  If this setting is true, though, the editing step is skipped."
msgstr ""

#. type: Labeled list
#: en/git-p4.txt:748
#, ignore-same, no-wrap, priority:90
msgid "git-p4.skipSubmitEditCheck"
msgstr "git-p4.skipSubmitEditCheck"

#. type: Plain text
#: en/git-p4.txt:752
#, priority:90
msgid "After editing the p4 change message, 'git p4' makes sure that the description really was changed by looking at the file modification time.  This option disables that test."
msgstr ""

#. type: Labeled list
#: en/git-p4.txt:753
#, ignore-same, no-wrap, priority:90
msgid "git-p4.allowSubmit"
msgstr "git-p4.allowSubmit"

#. type: Plain text
#: en/git-p4.txt:759
#, priority:90
msgid "By default, any branch can be used as the source for a 'git p4 submit' operation.  This configuration variable, if set, permits only the named branches to be used as submit sources.  Branch names must be the short names (no \"refs/heads/\"), and should be separated by commas (\",\"), with no spaces."
msgstr ""

#. type: Labeled list
#: en/git-p4.txt:760
#, ignore-same, no-wrap, priority:90
msgid "git-p4.skipUserNameCheck"
msgstr "git-p4.skipUserNameCheck"

#. type: Plain text
#: en/git-p4.txt:764
#, priority:90
msgid "If the user running 'git p4 submit' does not exist in the p4 user map, 'git p4' exits.  This option can be used to force submission regardless."
msgstr ""

#. type: Labeled list
#: en/git-p4.txt:765
#, ignore-same, no-wrap, priority:90
msgid "git-p4.attemptRCSCleanup"
msgstr "git-p4.attemptRCSCleanup"

#. type: Plain text
#: en/git-p4.txt:770
#, priority:90
msgid "If enabled, 'git p4 submit' will attempt to cleanup RCS keywords ($Header$, etc). These would otherwise cause merge conflicts and prevent the submit going ahead. This option should be considered experimental at present."
msgstr ""

#. type: Labeled list
#: en/git-p4.txt:771
#, ignore-same, no-wrap, priority:90
msgid "git-p4.exportLabels"
msgstr "git-p4.exportLabels"

#. type: Plain text
#: en/git-p4.txt:773
#, priority:90
msgid "Export Git tags to p4 labels, as per --export-labels."
msgstr ""

#. type: Labeled list
#: en/git-p4.txt:774
#, ignore-same, no-wrap, priority:90
msgid "git-p4.labelExportRegexp"
msgstr "git-p4.labelExportRegexp"

#. type: Plain text
#: en/git-p4.txt:777
#, priority:90
msgid "Only p4 labels matching this regular expression will be exported. The default value is '[a-zA-Z0-9_\\-.]+$'."
msgstr ""

#. type: Labeled list
#: en/git-p4.txt:778
#, ignore-same, no-wrap, priority:90
msgid "git-p4.conflict"
msgstr "git-p4.conflict"

#. type: Plain text
#: en/git-p4.txt:781
#, priority:90
msgid "Specify submit behavior when a conflict with p4 is found, as per --conflict.  The default behavior is 'ask'."
msgstr ""

#. type: Labeled list
#: en/git-p4.txt:782
#, ignore-same, no-wrap, priority:90
msgid "git-p4.disableRebase"
msgstr "git-p4.disableRebase"

#. type: Plain text
#: en/git-p4.txt:784
#, priority:90
msgid "Do not rebase the tree against p4/master following a submit."
msgstr ""

#. type: Labeled list
#: en/git-p4.txt:785
#, no-wrap, priority:90
msgid "git-p4.disableP4Sync"
msgstr ""

#. type: Plain text
#: en/git-p4.txt:787
#, priority:90
msgid "Do not sync p4/master with Perforce following a submit. Implies git-p4.disableRebase."
msgstr ""

#. type: Title -
#: en/git-p4.txt:789
#, no-wrap, priority:90
msgid "IMPLEMENTATION DETAILS"
msgstr ""

#. type: Plain text
#: en/git-p4.txt:791
#, priority:90
msgid "Changesets from p4 are imported using Git fast-import."
msgstr ""

#. type: Plain text
#: en/git-p4.txt:793
#, priority:90
msgid "Cloning or syncing does not require a p4 client; file contents are collected using 'p4 print'."
msgstr ""

#. type: Plain text
#: en/git-p4.txt:796
#, priority:90
msgid "Submitting requires a p4 client, which is not in the same location as the Git repository.  Patches are applied, one at a time, to this p4 client and submitted from there."
msgstr ""

#. type: Plain text
#: en/git-p4.txt:800
#, priority:90
msgid "Each commit imported by 'git p4' has a line at the end of the log message indicating the p4 depot location and change number.  This line is used by later 'git p4 sync' operations to know which p4 changes are new."
msgstr ""

#. type: Title =
#: en/git-pack-objects.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-pack-objects(1)"
msgstr "git-pack-objects(1)"

#. type: Plain text
#: en/git-pack-objects.txt:7
#, fuzzy, priority:100
msgid "git-pack-objects - Create a packed archive of objects"
msgstr "git-pack-objects - Create a packed archive of objects"

#. type: Plain text
#: en/git-pack-objects.txt:19
#, no-wrap, priority:100
msgid ""
"'git pack-objects' [-q | --progress | --all-progress] [--all-progress-implied]\n"
"\t[--no-reuse-delta] [--delta-base-offset] [--non-empty]\n"
"\t[--local] [--incremental] [--window=<n>] [--depth=<n>]\n"
"\t[--revs [--unpacked | --all]] [--keep-pack=<pack-name>]\n"
"\t[--cruft] [--cruft-expiration=<time>]\n"
"\t[--stdout [--filter=<filter-spec>] | <base-name>]\n"
"\t[--shallow] [--keep-true-parents] [--[no-]sparse] < <object-list>\n"
msgstr ""
"'git pack-objects' [-q | --progress | --all-progress] [--all-progress-implied]\n"
"\t[--no-reuse-delta] [--delta-base-offset] [--non-empty]\n"
"\t[--local] [--incremental] [--window=<n>] [--depth=<n>]\n"
"\t[--revs [--unpacked | --all]] [--keep-pack=<pack-name>]\n"
"\t[--cruft] [--cruft-expiration=<time>]\n"
"\t[--stdout [--filter=<filter-spec>] | <base-name>]\n"
"\t[--shallow] [--keep-true-parents] [--[no-]sparse] < <object-list>\n"

#. type: Plain text
#: en/git-pack-objects.txt:26
#, priority:100
msgid "Reads list of objects from the standard input, and writes either one or more packed archives with the specified base-name to disk, or a packed archive to the standard output."
msgstr "从标准输入读取对象列表，并将一个或多个指定基数名称的打包档案写入磁盘，或将一个打包档案写入标准输出。"

#. type: Plain text
#: en/git-pack-objects.txt:32
#, priority:100
msgid "A packed archive is an efficient way to transfer a set of objects between two repositories as well as an access efficient archival format.  In a packed archive, an object is either stored as a compressed whole or as a difference from some other object.  The latter is often called a delta."
msgstr "打包档案是在两个储存库之间转移一组对象的有效方法，也是一种有效的存取档案格式。 在打包的档案中，一个对象要么是作为一个压缩的整体来存储，要么是作为与其他对象的区别来存储。 后者通常被称为 delta。"

#. type: Plain text
#: en/git-pack-objects.txt:36
#, priority:100
msgid "The packed archive format (.pack) is designed to be self-contained so that it can be unpacked without any further information. Therefore, each object that a delta depends upon must be present within the pack."
msgstr "打包的档案格式（.pack）被设计为自成一体，这样它就可以在没有任何进一步信息的情况下被解包。因此，delta 所依赖的每个对象都必须存在于pack 中。"

#. type: Plain text
#: en/git-pack-objects.txt:42
#, priority:100
msgid "A pack index file (.idx) is generated for fast, random access to the objects in the pack. Placing both the index file (.idx) and the packed archive (.pack) in the pack/ subdirectory of $GIT_OBJECT_DIRECTORY (or any of the directories on $GIT_ALTERNATE_OBJECT_DIRECTORIES)  enables Git to read from the pack archive."
msgstr "一个打包的索引文件（.idx）被生成，以便快速、随机地访问打包中的对象。将索引文件（.idx）和打包的归档文件（.pack）放在$GIT_OBJECT_DIRECTORY（或 $GIT_ALTERNATE_OBJECT_DIRECTORIES 上的任何一个目录）的 pack/ 子目录下，可以使 Git 从打包的归档文件中读取。"

#. type: Plain text
#: en/git-pack-objects.txt:48
#, priority:100
msgid "The 'git unpack-objects' command can read the packed archive and expand the objects contained in the pack into \"one-file one-object\" format; this is typically done by the smart-pull commands when a pack is created on-the-fly for efficient network transport by their peers."
msgstr "'git unpack-objects' 命令可以读取打包后的档案，并将打包后的对象扩展为 “一对一的文件 - 对象” 的格式；这通常是由 smart-pull 命令在即时创建打包时完成的，以便由它们的同行进行有效的网络传输。"

#. type: Labeled list
#: en/git-pack-objects.txt:52
#, no-wrap, priority:100
msgid "base-name"
msgstr "base-name"

#. type: Plain text
#: en/git-pack-objects.txt:59
#, priority:100
msgid "Write into pairs of files (.pack and .idx), using <base-name> to determine the name of the created file.  When this option is used, the two files in a pair are written in <base-name>-<SHA-1>.{pack,idx} files.  <SHA-1> is a hash based on the pack content and is written to the standard output of the command."
msgstr "写入成对的文件（.pack 和 .idx），使用 <base-name> 来确定创建的文件名。 当使用该选项时，一对中的两个文件被写入 <base-name>-<SHA-1>.{pack,idx} 文件。 <SHA-1> 是一个基于 pack 内容的哈希值，会写入命令的标准输出中。"

#. type: Plain text
#: en/git-pack-objects.txt:63
#, priority:100
msgid "Write the pack contents (what would have been written to .pack file) out to the standard output."
msgstr "将包的内容（本来要写到 .pack 文件中的内容）写到标准输出中。"

#. type: Labeled list
#: en/git-pack-objects.txt:64
#, ignore-same, no-wrap, priority:100
msgid "--revs"
msgstr "--revs"

#. type: Plain text
#: en/git-pack-objects.txt:72
#, priority:100
msgid "Read the revision arguments from the standard input, instead of individual object names.  The revision arguments are processed the same way as 'git rev-list' with the `--objects` flag uses its `commit` arguments to build the list of objects it outputs.  The objects on the resulting list are packed.  Besides revisions, `--not` or `--shallow <SHA-1>` lines are also accepted."
msgstr "从标准输入读取修订参数，而不是单个对象名称。 修订版参数的处理方式与带有 `--object` 标志的 'git rev-list' 使用其 `commit` 参数来建立其输出的对象列表相同。 结果列表上的对象被打包。 除了修订，还接受 `--not` 或 `--shallow <SHA-1>` 行。"

#. type: Labeled list
#: en/git-pack-objects.txt:73 en/rev-list-options.txt:918
#, ignore-same, no-wrap, priority:260
msgid "--unpacked"
msgstr "--unpacked"

#. type: Plain text
#: en/git-pack-objects.txt:77
#, priority:100
msgid "This implies `--revs`.  When processing the list of revision arguments read from the standard input, limit the objects packed to those that are not already packed."
msgstr "这暗指 `--revs`。 当处理从标准输入读取的修订参数列表时，将打包的对象限制在那些尚未打包的对象。"

#. type: Plain text
#: en/git-pack-objects.txt:83
#, priority:100
msgid "This implies `--revs`.  In addition to the list of revision arguments read from the standard input, pretend as if all refs under `refs/` are specified to be included."
msgstr "这暗指 `--revs`。 除了从标准输入中读取的修订参数列表外，还假设指定要包括 `refs/`下的所有引用。"

#. type: Plain text
#: en/git-pack-objects.txt:88
#, priority:100
msgid "Include unasked-for annotated tags if the object they reference was included in the resulting packfile.  This can be useful to send new tags to native Git clients."
msgstr "包括未被要求的注释标签，如果它们引用的对象被包含在结果的打包文件中。 这对于向本地 Git 客户端发送新的标签很有用。"

#. type: Labeled list
#: en/git-pack-objects.txt:89
#, ignore-same, no-wrap, priority:100
msgid "--stdin-packs"
msgstr "--stdin-packs"

#. type: Plain text
#: en/git-pack-objects.txt:95
#, priority:100
msgid "Read the basenames of packfiles (e.g., `pack-1234abcd.pack`)  from the standard input, instead of object names or revision arguments. The resulting pack contains all objects listed in the included packs (those not beginning with `^`), excluding any objects listed in the excluded packs (beginning with `^`)."
msgstr "从标准输入中读取 packfiles（例如：`pack-1234abcd.pack`）的基本名称，而不是对象名称或修订参数。产生的数据包包含所有在包含的数据包中列出的对象（那些不是以 `^` 开头的），排除在排除的数据包中列出的任何对象（以 `^` 开头）。"

#. type: Plain text
#: en/git-pack-objects.txt:98
#, priority:100
msgid "Incompatible with `--revs`, or options that imply `--revs` (such as `--all`), with the exception of `--unpacked`, which is compatible."
msgstr "与 `--revs` 或暗指 `--revs` 的选项（如 `--all`）不兼容，但 `--unpacked` 除外，它是兼容的。"

#. type: Labeled list
#: en/git-pack-objects.txt:99 en/git-repack.txt:66
#, ignore-same, no-wrap, priority:100
msgid "--cruft"
msgstr "--cruft"

#. type: Plain text
#: en/git-pack-objects.txt:109
#, priority:100
msgid "Packs unreachable objects into a separate \"cruft\" pack, denoted by the existence of a `.mtimes` file. Typically used by `git repack --cruft`. Callers provide a list of pack names and indicate which packs will remain in the repository, along with which packs will be deleted (indicated by the `-` prefix). The contents of the cruft pack are all objects not contained in the surviving packs which have not exceeded the grace period (see `--cruft-expiration` below), or which have exceeded the grace period, but are reachable from an other object which hasn't."
msgstr "将无法到达的对象打包到一个单独的 \"cruft\" 包中，以 `.mtimes` 文件的存在为标志。通常由`git repack --cruft`使用。调用者提供一个包的名称列表，并指出哪些包将保留在版本库中，以及哪些包将被删除（用 `-` 前缀表示）。cruft 包的内容是所有不包含在幸存的包中的对象，它们没有超过宽限期（见下面的 `--cruft-expiration`），或者它们已经超过了宽限期，但可以从其他没有超过宽限期的对象中到达。"

#. type: Plain text
#: en/git-pack-objects.txt:116
#, priority:100
msgid "When the input lists a pack containing all reachable objects (and lists all other packs as pending deletion), the corresponding cruft pack will contain all unreachable objects (with mtime newer than the `--cruft-expiration`) along with any unreachable objects whose mtime is older than the `--cruft-expiration`, but are reachable from an unreachable object whose mtime is newer than the `--cruft-expiration`)."
msgstr "当输入列出一个包含所有可达对象的包（并将所有其他包列为待删除），相应的 cruft 包将包含所有不可达对象（其 mtime 比 `--cruft-expiration` 新），以及任何 mtime 比 `--cruft-expiration` 早，但可从 mtime 比 `--cruft-expiration` 新的不可达对象到达的不可达对象）。"

#. type: Plain text
#: en/git-pack-objects.txt:122
#, priority:100
msgid "Incompatible with `--unpack-unreachable`, `--keep-unreachable`, `--pack-loose-unreachable`, `--stdin-packs`, as well as any other options which imply `--revs`. Also incompatible with `--max-pack-size`; when this option is set, the maximum pack size is not inferred from `pack.packSizeLimit`."
msgstr "与 `--unpack-unreachable`, `--keep-unreachable`, `--pack-loose-unreachable`, `--stdin-packs`，以及任何其他暗指 `--revs` 的选项不兼容。也与 `--max-pack-size` 不兼容；当这个选项被设置时，最大的包尺寸不会从`pack.packSizeLimit`中推断出来。"

#. type: Labeled list
#: en/git-pack-objects.txt:123 en/git-repack.txt:72
#, no-wrap, priority:100
msgid "--cruft-expiration=<approxidate>"
msgstr "--cruft-expiration=<approxidate>"

#. type: Plain text
#: en/git-pack-objects.txt:127
#, priority:100
msgid "If specified, objects are eliminated from the cruft pack if they have an mtime older than `<approxidate>`. If unspecified (and given `--cruft`), then no objects are eliminated."
msgstr "如果指定了，且对象的 mtime 超过 `<approxidate>`，就会从 cruft 包中剔除。如果没有指定（并给出 `--cruft'），那么没有对象被淘汰。"

#. type: Labeled list
#: en/git-pack-objects.txt:128 en/git-repack.txt:107
#, fuzzy, no-wrap, priority:100
msgid "--window=<n>"
msgstr "--window=<n>"

#. type: Plain text
#: en/git-pack-objects.txt:139
#, priority:100
msgid "These two options affect how the objects contained in the pack are stored using delta compression.  The objects are first internally sorted by type, size and optionally names and compared against the other objects within --window to see if using delta compression saves space.  --depth limits the maximum delta depth; making it too deep affects the performance on the unpacker side, because delta data needs to be applied that many times to get to the necessary object."
msgstr "这两个选项影响了使用 delta 压缩法存储数据包中的对象的方式。 这些对象首先按照类型、大小和可选的名称进行内部排序，并与 --window 内的其他对象进行比较，看使用 delta 压缩是否节省了空间。 --depth 限制了最大的 delta 深度；使其过深会影响到解包方的性能，因为 delta 数据需要应用那么多次才能到达必要的对象。"

#. type: Plain text
#: en/git-pack-objects.txt:142 en/git-repack.txt:119
#, fuzzy, priority:100
msgid "The default value for --window is 10 and --depth is 50. The maximum depth is 4095."
msgstr "--window 的默认值为 10，-depth 的默认值为 50。最大深度为 4095。"

#. type: Labeled list
#: en/git-pack-objects.txt:143 en/git-repack.txt:123
#, no-wrap, priority:100
msgid "--window-memory=<n>"
msgstr "--window-memory=<n>"

#. type: Plain text
#: en/git-pack-objects.txt:153
#, priority:100
msgid "This option provides an additional limit on top of `--window`; the window size will dynamically scale down so as to not take up more than '<n>' bytes in memory.  This is useful in repositories with a mix of large and small objects to not run out of memory with a large window, but still be able to take advantage of the large window for the smaller objects.  The size can be suffixed with \"k\", \"m\", or \"g\".  `--window-memory=0` makes memory usage unlimited.  The default is taken from the `pack.windowMemory` configuration variable."
msgstr "这个选项在 `--window` 的基础上提供了一个额外的限制；窗口的大小将动态地缩小，以便不占用超过 '<n>' 字节的内存。 这对有大有小的对象的存储库很有用，它不会因为大窗口而耗尽内存，但仍然能够利用大窗口来处理小对象。 大小可以以 \"k\"、\"m \"或 \"g \"为后缀。 `--window-memory=0` 使内存使用不受限制。 默认值取自`pack.windowMemory` 配置变量。"

#. type: Plain text
#: en/git-pack-objects.txt:165
#, priority:100
msgid "In unusual scenarios, you may not be able to create files larger than a certain size on your filesystem, and this option can be used to tell the command to split the output packfile into multiple independent packfiles, each not larger than the given size. The size can be suffixed with \"k\", \"m\", or \"g\". The minimum size allowed is limited to 1 MiB.  The default is unlimited, unless the config variable `pack.packSizeLimit` is set. Note that this option may result in a larger and slower repository; see the discussion in `pack.packSizeLimit`."
msgstr "在不寻常的情况下，你可能无法在你的文件系统上创建大于一定大小的文件，这个选项可以用来告诉命令将输出的 packfile 分割成多个独立的 packfile，每个 packfile 都不大于给定的大小。大小可以以 \"k\"、\"m \"或 \"g \"为后缀。允许的最小尺寸被限制为1 MiB。 默认是无限制的，除非配置变量`pack.packSizeLimit` 被设置。注意，这个选项可能会导致仓库变大变慢；参见 `pack.packSizeLimit`中的讨论。"

#. type: Labeled list
#: en/git-pack-objects.txt:166
#, ignore-same, no-wrap, priority:100
msgid "--honor-pack-keep"
msgstr "--honor-pack-keep"

#. type: Plain text
#: en/git-pack-objects.txt:170
#, priority:100
msgid "This flag causes an object already in a local pack that has a .keep file to be ignored, even if it would have otherwise been packed."
msgstr "这个标志会使一个已经在本地打包的对象被忽略，即使它本来会被打包。"

#. type: Labeled list
#: en/git-pack-objects.txt:171 en/git-repack.txt:164
#, fuzzy, no-wrap, priority:100
msgid "--keep-pack=<pack-name>"
msgstr "--keep-pack=<pack-name>"

#. type: Plain text
#: en/git-pack-objects.txt:177
#, priority:100
msgid "This flag causes an object already in the given pack to be ignored, even if it would have otherwise been packed. `<pack-name>` is the pack file name without leading directory (e.g. `pack-123.pack`). The option could be specified multiple times to keep multiple packs."
msgstr "这个标志使已经在给定包中的对象被忽略，即使它本来已经被打包。`<pack-name>` 是不带前导目录的包文件名（例如：`pack-123.pack`）。该选项可以被多次指定以保留多个包。"

#. type: Plain text
#: en/git-pack-objects.txt:181
#, priority:100
msgid "This flag causes an object already in a pack to be ignored even if it would have otherwise been packed."
msgstr "这个标志使已经在包装中的对象被忽略，即使它本来会被包装。"

#. type: Plain text
#: en/git-pack-objects.txt:186
#, priority:100
msgid "This flag causes an object that is borrowed from an alternate object store to be ignored even if it would have otherwise been packed."
msgstr "这个标志导致从另一个对象存储空间借来的对象被忽略，即使它本来会被打包。"

#. type: Labeled list
#: en/git-pack-objects.txt:187
#, ignore-same, no-wrap, priority:100
msgid "--non-empty"
msgstr "--non-empty"

#. type: Plain text
#: en/git-pack-objects.txt:190
#, priority:100
msgid "Only create a packed archive if it would contain at least one object."
msgstr "只有在至少包含一个对象的情况下才会创建一个打包的档案。"

#. type: Labeled list
#: en/git-pack-objects.txt:197
#, ignore-same, no-wrap, priority:100
msgid "--all-progress"
msgstr "--all-progress"

#. type: Plain text
#: en/git-pack-objects.txt:207
#, priority:100
msgid "When --stdout is specified then progress report is displayed during the object count and compression phases but inhibited during the write-out phase. The reason is that in some cases the output stream is directly linked to another command which may wish to display progress status of its own as it processes incoming pack data.  This flag is like --progress except that it forces progress report for the write-out phase as well even if --stdout is used."
msgstr "当指定 --stdout 时，在对象计数和压缩阶段会显示进度报告，但在写出阶段会被抑制。原因是在某些情况下，输出流直接与另一个命令相连，而后者在处理输入的数据时可能希望显示自己的进度状态。 这个标志和 --progress 一样，只是它在写出阶段也强制显示进度报告，即使使用了 --stdout。"

#. type: Labeled list
#: en/git-pack-objects.txt:208
#, ignore-same, no-wrap, priority:100
msgid "--all-progress-implied"
msgstr "--all-progress-implied"

#. type: Plain text
#: en/git-pack-objects.txt:212
#, priority:100
msgid "This is used to imply --all-progress whenever progress display is activated.  Unlike --all-progress this flag doesn't actually force any progress display by itself."
msgstr "当进度显示被激活时，它被用来暗指 --all-progress。 与 --all-progress 不同的是，这个标志本身实际上并不强制显示任何进度。"

#. type: Labeled list
#: en/git-pack-objects.txt:217
#, ignore-same, no-wrap, priority:100
msgid "--no-reuse-delta"
msgstr "--no-reuse-delta"

#. type: Plain text
#: en/git-pack-objects.txt:223
#, priority:100
msgid "When creating a packed archive in a repository that has existing packs, the command reuses existing deltas.  This sometimes results in a slightly suboptimal pack.  This flag tells the command not to reuse existing deltas but compute them from scratch."
msgstr "当在已有打包的版本库中创建一个打包的归档文件时，该命令会重用现有的三角洲。 这有时会导致一个稍微次优的打包。 这个标志告诉命令不要重用现有的 deltas，而是从头开始计算。"

#. type: Labeled list
#: en/git-pack-objects.txt:224
#, ignore-same, no-wrap, priority:100
msgid "--no-reuse-object"
msgstr "--no-reuse-object"

#. type: Plain text
#: en/git-pack-objects.txt:230
#, priority:100
msgid "This flag tells the command not to reuse existing object data at all, including non deltified object, forcing recompression of everything.  This implies --no-reuse-delta. Useful only in the obscure case where wholesale enforcement of a different compression level on the packed data is desired."
msgstr "这个标志告诉命令不要重复使用现有的对象数据，包括非延迟对象，强迫重新压缩所有东西。 这意味着 --no-reuse-delta。只有在需要对打包的数据全盘执行不同的压缩级别的隐蔽情况下才有用。"

#. type: Labeled list
#: en/git-pack-objects.txt:231
#, fuzzy, no-wrap, priority:100
msgid "--compression=<n>"
msgstr "--compression=<n>"

#. type: Plain text
#: en/git-pack-objects.txt:238
#, priority:100
msgid "Specifies compression level for newly-compressed data in the generated pack.  If not specified, pack compression level is determined first by pack.compression, then by core.compression, and defaults to -1, the zlib default, if neither is set.  Add --no-reuse-object if you want to force a uniform compression level on all data no matter the source."
msgstr "为生成的数据包中新压缩的数据指定压缩级别。 如果没有指定，数据包的压缩级别首先由 pack.compression 决定，然后由 core.compression 决定，如果两者都没有设置，则默认为 -1，即 zlib 默认值。 如果你想在所有的数据上强制使用统一的压缩级别，无论其来源如何，请添加 --no-reuse-object。"

#. type: Labeled list
#: en/git-pack-objects.txt:239
#, ignore-same, no-wrap, priority:100
msgid "--[no-]sparse"
msgstr "--[no-]sparse"

#. type: Plain text
#: en/git-pack-objects.txt:249
#, priority:100
msgid "Toggle the \"sparse\" algorithm to determine which objects to include in the pack, when combined with the \"--revs\" option. This algorithm only walks trees that appear in paths that introduce new objects.  This can have significant performance benefits when computing a pack to send a small change. However, it is possible that extra objects are added to the pack-file if the included commits contain certain types of direct renames. If this option is not included, it defaults to the value of `pack.useSparse`, which is true unless otherwise specified."
msgstr "与 \"--revs\" 选项结合使用时，切换 \"稀疏\" 算法，以确定哪些对象应包含在数据包中。这种算法只行走那些出现在引入新对象的路径中的树。 当计算一个包来发送一个小的变化时，这可能有显著的性能优势。然而，如果所包含的提交包含某些类型的直接重命名，则可能会有额外的对象被添加到包文件中。如果不包括这个选项，它默认为 `pack.useSparse` 的值，除非另有规定，否则为真。"

#. type: Plain text
#: en/git-pack-objects.txt:254
#, priority:100
msgid "Create a \"thin\" pack by omitting the common objects between a sender and a receiver in order to reduce network transfer. This option only makes sense in conjunction with --stdout."
msgstr "通过省略发送方和接收方之间的共同对象来创建一个 \"轻量\" 包，以减少网络传输。这个选项只有在与 --stdout 一起使用时才有意义。"

#. type: Plain text
#: en/git-pack-objects.txt:259
#, priority:100
msgid "Note: A thin pack violates the packed archive format by omitting required objects and is thus unusable by Git without making it self-contained. Use `git index-pack --fix-thin` (see linkgit:git-index-pack[1]) to restore the self-contained property."
msgstr "注意：轻量包由于省略了所需的对象而违反了打包的存档格式，因此如果不使其自成一体，Git 就无法使用。使用 `git index-pack --fix-thin` （ linkgit:git-index-pack[1]）来恢复自包含的属性。"

#. type: Labeled list
#: en/git-pack-objects.txt:260
#, ignore-same, no-wrap, priority:100
msgid "--shallow"
msgstr "--shallow"

#. type: Plain text
#: en/git-pack-objects.txt:264
#, priority:100
msgid "Optimize a pack that will be provided to a client with a shallow repository.  This option, combined with --thin, can result in a smaller pack at the cost of speed."
msgstr "优化将被提供给客户的浅克隆仓库的数据包。 这个选项和 --thin 结合起来，可以以速度为代价，产生一个更小的包。"

#. type: Labeled list
#: en/git-pack-objects.txt:265
#, ignore-same, no-wrap, priority:100
msgid "--delta-base-offset"
msgstr "--delta-base-offset"

#. type: Plain text
#: en/git-pack-objects.txt:275
#, priority:100
msgid "A packed archive can express the base object of a delta as either a 20-byte object name or as an offset in the stream, but ancient versions of Git don't understand the latter.  By default, 'git pack-objects' only uses the former format for better compatibility.  This option allows the command to use the latter format for compactness.  Depending on the average delta chain length, this option typically shrinks the resulting packfile by 3-5 per-cent."
msgstr "打包后的归档文件可以用 20 字节的对象名称或流中的偏移量来表达 delta 的基础对象，但早期版本的 Git 不理解后者。 默认情况下，'git pack-objects' 只使用前一种格式，以提高兼容性。 这个选项允许该命令使用后者的格式以达到紧凑的目的。 根据 delta 链的平均长度，这个选项通常会将生成的 packfile 缩小 3-5%。"

#. type: Plain text
#: en/git-pack-objects.txt:280
#, priority:100
msgid "Note: Porcelain commands such as `git gc` (see linkgit:git-gc[1]), `git repack` (see linkgit:git-repack[1]) pass this option by default in modern Git when they put objects in your repository into pack files.  So does `git bundle` (see linkgit:git-bundle[1]) when it creates a bundle."
msgstr "注意: 在现版本 Git 中，诸如 `git gc` (参见 linkgit:git-gc[1])、`git repack` (参见 linkgit:git-repack[1])之类的上层命令在将仓库中的对象放入打包文件时，默认会传递这个选项。 当 `git bundle` (参见 linkgit:git-bundle[1])创建一个捆绑包时也会这样做。"

#. type: Plain text
#: en/git-pack-objects.txt:290
#, priority:100
msgid "Specifies the number of threads to spawn when searching for best delta matches.  This requires that pack-objects be compiled with pthreads otherwise this option is ignored with a warning.  This is meant to reduce packing time on multiprocessor machines.  The required amount of memory for the delta search window is however multiplied by the number of threads.  Specifying 0 will cause Git to auto-detect the number of CPU's and set the number of threads accordingly."
msgstr "指定搜索最佳 delta 匹配时产生的线程数。 这要求 pack-objects 使用 pthreads 编译，否则该选项将被忽略并发出警告。 这样做的目的是在多处理器机器上减少打包时间。 然而，delta 搜索窗口所需的内存会乘以线程数。 指定 0 将导致 Git 自动检测 CPU 数量并相应设置线程数量。"

#. type: Labeled list
#: en/git-pack-objects.txt:296
#, ignore-same, no-wrap, priority:100
msgid "--keep-true-parents"
msgstr "--keep-true-parents"

#. type: Plain text
#: en/git-pack-objects.txt:299
#, priority:100
msgid "With this option, parents that are hidden by grafts are packed nevertheless."
msgstr "通过这种方法，被移植物覆盖的父母还是会被打包。"

#. type: Plain text
#: en/git-pack-objects.txt:304
#, priority:100
msgid "Requires `--stdout`.  Omits certain objects (usually blobs) from the resulting packfile.  See linkgit:git-rev-list[1] for valid `<filter-spec>` forms."
msgstr "需要 `--stdout`。 从生成的 packfile 中省略某些对象（通常是 blobs）。 参见 linkgit:git-rev-list[1] 以了解有效的 `<filter-spec>` 形式。"

#. type: Labeled list
#: en/git-pack-objects.txt:305 en/rev-list-options.txt:987
#, ignore-same, no-wrap, priority:260
msgid "--no-filter"
msgstr "--no-filter"

#. type: Plain text
#: en/git-pack-objects.txt:307
#, priority:100
msgid "Turns off any previous `--filter=` argument."
msgstr "关闭之前的 `--filter=` 参数。"

#. type: Labeled list
#: en/git-pack-objects.txt:308 en/rev-list-options.txt:999
#, no-wrap, priority:260
msgid "--missing=<missing-action>"
msgstr "--missing=<missing-action>（缺失）。"

#. type: Plain text
#: en/git-pack-objects.txt:311 en/rev-list-options.txt:1002
#, priority:260
msgid "A debug option to help with future \"partial clone\" development.  This option specifies how missing objects are handled."
msgstr "一个调试选项，帮助未来的 \"部分克隆 \"开发。  这个选项指定了如何处理丢失的对象。"

#. type: Plain text
#: en/git-pack-objects.txt:316
#, priority:100
msgid "The form '--missing=error' requests that pack-objects stop with an error if a missing object is encountered.  If the repository is a partial clone, an attempt to fetch missing objects will be made before declaring them missing.  This is the default action."
msgstr "表格 '--missing=error' 请求在遇到丢失对象时以错误停止 pack-objects。 如果仓库是部分克隆，在宣布丢失之前会尝试获取丢失的对象。 这是默认行为。"

#. type: Plain text
#: en/git-pack-objects.txt:320
#, priority:100
msgid "The form '--missing=allow-any' will allow object traversal to continue if a missing object is encountered.  No fetch of a missing object will occur.  Missing objects will silently be omitted from the results."
msgstr "形式 '--missing=allow-any' 将允许在遇到丢失对象时继续遍历对象。 不会获取丢失的对象。 缺少的对象将从结果中被静默省略。"

#. type: Plain text
#: en/git-pack-objects.txt:325
#, priority:100
msgid "The form '--missing=allow-promisor' is like 'allow-any', but will only allow object traversal to continue for EXPECTED promisor missing objects.  No fetch of a missing object will occur.  An unexpected missing object will raise an error."
msgstr "形式 '--missing=allow-promisor' 类似于 'allow-any'，但只允许继续遍历预期 promisor 丢失的对象。 不会获取丢失的对象。 意外丢失的对象将引发错误。"

#. type: Labeled list
#: en/git-pack-objects.txt:326 en/rev-list-options.txt:1017
#, ignore-same, no-wrap, priority:260
msgid "--exclude-promisor-objects"
msgstr "--exclude-promisor-objects"

#. type: Plain text
#: en/git-pack-objects.txt:332
#, priority:100
msgid "Omit objects that are known to be in the promisor remote.  (This option has the purpose of operating only on locally created objects, so that when we repack, we still maintain a distinction between locally created objects [without .promisor] and objects from the promisor remote [with .promisor].)  This is used with partial clone."
msgstr "省略已知在远程 promisor 中的对象。 （该选项的目的是只对本地创建的对象执行操作，这样当我们重新打包时，仍然可以区分本地创建的对象 [不含 .promisor] 和来自远程 promisor [含 .promisor] 的对象)。 该选项与部分克隆一起使用。"

#. type: Labeled list
#: en/git-pack-objects.txt:333 en/git-repack.txt:178
#, ignore-same, no-wrap, priority:100
msgid "--keep-unreachable"
msgstr "--keep-unreachable"

#. type: Plain text
#: en/git-pack-objects.txt:338
#, priority:100
msgid "Objects unreachable from the refs in packs named with --unpacked= option are added to the resulting pack, in addition to the reachable objects that are not in packs marked with *.keep files. This implies `--revs`."
msgstr "除了标有 *.keep 文件的包中没有的可到达对象之外，用 --unpacked= 选项命名的包中的引用无法到达的对象也会被添加到生成的包中。这意味着`--revs`。"

#. type: Labeled list
#: en/git-pack-objects.txt:339
#, ignore-same, no-wrap, priority:100
msgid "--pack-loose-unreachable"
msgstr "--pack-loose-unreachable"

#. type: Plain text
#: en/git-pack-objects.txt:342
#, priority:100
msgid "Pack unreachable loose objects (and their loose counterparts removed). This implies `--revs`."
msgstr "打包不可达的松散对象（并移除它们的松散对应对象）。这意味着`--revs`."

#. type: Labeled list
#: en/git-pack-objects.txt:343
#, ignore-same, no-wrap, priority:100
msgid "--unpack-unreachable"
msgstr "--unpack-unreachable"

#. type: Plain text
#: en/git-pack-objects.txt:345
#, priority:100
msgid "Keep unreachable objects in loose form. This implies `--revs`."
msgstr "以松散的形式保存无法访问的对象。这意味着 `--revs`。"

#. type: Labeled list
#: en/git-pack-objects.txt:346 en/git-repack.txt:185
#, ignore-same, no-wrap, priority:100
msgid "--delta-islands"
msgstr "--delta-islands"

#. type: Plain text
#: en/git-pack-objects.txt:349
#, priority:100
msgid "Restrict delta matches based on \"islands\". See DELTA ISLANDS below."
msgstr "根据 “岛屿” 限制增量匹配。请参阅下文的增量匹配。"

#. type: Title -
#: en/git-pack-objects.txt:352
#, fuzzy, no-wrap, priority:100
msgid "DELTA ISLANDS"
msgstr "DELTA ISLANDS"

#. type: Plain text
#: en/git-pack-objects.txt:364
#, priority:100
msgid "When possible, `pack-objects` tries to reuse existing on-disk deltas to avoid having to search for new ones on the fly. This is an important optimization for serving fetches, because it means the server can avoid inflating most objects at all and just send the bytes directly from disk. This optimization can't work when an object is stored as a delta against a base which the receiver does not have (and which we are not already sending). In that case the server \"breaks\" the delta and has to find a new one, which has a high CPU cost. Therefore it's important for performance that the set of objects in on-disk delta relationships match what a client would fetch."
msgstr "在可能的情况下， `pack-objects` 尝试重用现有的磁盘上的 deltas，以避免临时搜索新的 deltas。这对于服务获取来说是一个重要的优化，因为它意味着服务器可以完全避免膨胀大多数对象，而只是直接从磁盘发送字节。当一个对象以 delta 的形式存储，而接收者并不拥有（而且我们也没有发送）这个基数时，这种优化就不起作用了。在这种情况下，服务器将 “中断” delta，并必须找到一个新的delta，这将产生很高的 CPU 成本。因此，磁盘上 delta 关系中的对象集必须与客户端获取的对象相匹配，这对性能非常重要。"

#. type: Plain text
#: en/git-pack-objects.txt:369
#, priority:100
msgid "In a normal repository, this tends to work automatically. The objects are mostly reachable from the branches and tags, and that's what clients fetch. Any deltas we find on the server are likely to be between objects the client has or will have."
msgstr "在正常的仓库中，这往往是自动进行的。对象大多可以从分支和标签中获取，这也是客户端获取的内容。我们在服务器上发现的任何脱节都可能是客户端已经拥有或将要拥有的对象之间的脱节。"

#. type: Plain text
#: en/git-pack-objects.txt:379
#, priority:100
msgid "But in some repository setups, you may have several related but separate groups of ref tips, with clients tending to fetch those groups independently. For example, imagine that you are hosting several \"forks\" of a repository in a single shared object store, and letting clients view them as separate repositories through `GIT_NAMESPACE` or separate repos using the alternates mechanism. A naive repack may find that the optimal delta for an object is against a base that is only found in another fork. But when a client fetches, they will not have the base object, and we'll have to find a new delta on the fly."
msgstr "但在某些仓库设置中，您可能有几个相关但独立的引用提示组，客户端倾向于独立获取这些组。例如，假设你在一个共享对象存储空间中托管了多个版本库的 \"fork\"，并通过`GIT_NAMESPACE`或使用替代机制的独立仓库让客户端将它们视为独立的仓库。天真的 repack 可能会发现，一个对象的最佳 delta 是针对只有在另一个 fork 中才能找到的基数。但是，当客户端获取时，他们将没有基础对象，我们将不得不临时找到一个新的 delta。"

#. type: Plain text
#: en/git-pack-objects.txt:385
#, priority:100
msgid "A similar situation may exist if you have many refs outside of `refs/heads/` and `refs/tags/` that point to related objects (e.g., `refs/pull` or `refs/changes` used by some hosting providers). By default, clients fetch only heads and tags, and deltas against objects found only in those other groups cannot be sent as-is."
msgstr "如果在 `refs/heads/` 和 `refs/tags/` 之外有许多指向相关对象的引用（例如，某些托管提供商使用的 `refs/pull` 或 `refs/changes`），也可能存在类似的情况。默认情况下，客户端只获取 heads 和 tags，因此不能发送只在这些组中找到的对象的 deltas。"

#. type: Plain text
#: en/git-pack-objects.txt:393
#, priority:100
msgid "Delta islands solve this problem by allowing you to group your refs into distinct \"islands\". Pack-objects computes which objects are reachable from which islands, and refuses to make a delta from an object `A` against a base which is not present in all of `A`'s islands. This results in slightly larger packs (because we miss some delta opportunities), but guarantees that a fetch of one island will not have to recompute deltas on the fly due to crossing island boundaries."
msgstr "Delta 岛解决了这个问题，它允许您将您的引用分组为不同的 “岛”。Pack-objects 会计算哪些对象可以从哪些岛屿到达，并拒绝从对象 `A` 针对不存在于所有 `A` 岛屿中的基准进行 delta。这会导致数据包略微变大(因为我们错过了一些 delta 机会)，但保证了对一个岛的取值不会因为跨越岛的边界而不得不重新计算 delta。"

#. type: Plain text
#: en/git-pack-objects.txt:399
#, priority:100
msgid "When repacking with delta islands the delta window tends to get clogged with candidates that are forbidden by the config. Repacking with a big --window helps (and doesn't take as long as it otherwise might because we can reject some object pairs based on islands before doing any computation on the content)."
msgstr "当使用 delta 岛重新打包时，delta 窗口往往会被配置禁止的候选对象堵塞。使用大的 --window 进行重新打包会有所帮助（而且不会像其他情况下花费那么长的时间，因为在对内容进行任何计算之前，我们可以根据岛拒绝一些对象对）。"

#. type: Plain text
#: en/git-pack-objects.txt:403
#, priority:100
msgid "Islands are configured via the `pack.island` option, which can be specified multiple times. Each value is a left-anchored regular expressions matching refnames. For example:"
msgstr "岛是通过 `pack.island` 选项配置的，可以多次指定。每个值都是匹配 refnames 的左锚正则表达式。例如 :"

#. type: delimited block -
#: en/git-pack-objects.txt:408
#, fuzzy, no-wrap, priority:100
msgid ""
"[pack]\n"
"island = refs/heads/\n"
"island = refs/tags/\n"
msgstr ""
"[pack]\n"
"island = refs/heads/\n"
"island = refs/tags/\n"

#. type: Plain text
#: en/git-pack-objects.txt:415
#, priority:100
msgid "puts heads and tags into an island (whose name is the empty string; see below for more on naming). Any refs which do not match those regular expressions (e.g., `refs/pull/123`) is not in any island. Any object which is reachable only from `refs/pull/` (but not heads or tags) is therefore not a candidate to be used as a base for `refs/heads/`."
msgstr "将 heads 和 tags 放入一个 “岛” 中（其名称为空字符串；有关命名的更多信息，请参阅下文）。任何不匹配这些正则表达式的引用（例如 `refs/pull/123`）都不在任何岛中。因此，任何只能从 `refs/pull/` (而不能从 heads 或 tags) 访问的对象都不能作为 `refs/heads/` 的基础。"

#. type: Plain text
#: en/git-pack-objects.txt:423
#, priority:100
msgid "Refs are grouped into islands based on their \"names\", and two regexes that produce the same name are considered to be in the same island. The names are computed from the regexes by concatenating any capture groups from the regex, with a '-' dash in between. (And if there are no capture groups, then the name is the empty string, as in the above example.) This allows you to create arbitrary numbers of islands. Only up to 14 such capture groups are supported though."
msgstr "参考文件根据其 “名称” 分组，产生相同名称的两个 regex 被视为在同一个岛中。名称是通过连接 regex 中的任何捕获组和中间的 '-' 破折号来计算的。(如果没有捕获组，则名称为空字符串，如上例）。这允许您创建任意数量的岛屿。但最多只支持 14 个这样的捕获组。"

#. type: Plain text
#: en/git-pack-objects.txt:427
#, priority:100
msgid "For example, imagine you store the refs for each fork in `refs/virtual/ID`, where `ID` is a numeric identifier. You might then configure:"
msgstr "例如，假设你在 `refs/virtual/ID` 中存储了每个 fork 的引用，其中 `ID` 是一个数字标识符。然后您可以配置 :"

#. type: delimited block -
#: en/git-pack-objects.txt:433
#, fuzzy, no-wrap, priority:100
msgid ""
"[pack]\n"
"island = refs/virtual/([0-9]+)/heads/\n"
"island = refs/virtual/([0-9]+)/tags/\n"
"island = refs/virtual/([0-9]+)/(pull)/\n"
msgstr ""
"[pack]\n"
"island = refs/virtual/([0-9]+)/heads/\n"
"island = refs/virtual/([0-9]+)/tags/\n"
"island = refs/virtual/([0-9]+)/(pull)/\n"

#. type: Plain text
#: en/git-pack-objects.txt:438
#, priority:100
msgid "That puts the heads and tags for each fork in their own island (named \"1234\" or similar), and the pull refs for each go into their own \"1234-pull\"."
msgstr "这就将每个分叉的头和标签放在自己的岛（命名为 \"1234\" 或类似的名字）中，而每个分叉的拉动参考则放在自己的 \"1234-pull \"中。"

#. type: Plain text
#: en/git-pack-objects.txt:442
#, priority:100
msgid "Note that we pick a single island for each regex to go into, using \"last one wins\" ordering (which allows repo-specific config to take precedence over user-wide config, and so forth)."
msgstr "请注意，我们为每个 regex 选择一个单独的岛，使用 \"最后一个获胜\" 的排序（这允许特定于仓库的配置优先于用户范围内的配置，等等）。"

#. type: Plain text
#: en/git-pack-objects.txt:449 en/git-repack.txt:226
#, priority:100
msgid "Various configuration variables affect packing, see linkgit:git-config[1] (search for \"pack\" and \"delta\")."
msgstr "各种配置变量会影响打包，参见 linkgit:git-config[1] (搜索 \"pack\" 和 \"delta\")。"

#. type: Plain text
#: en/git-pack-objects.txt:453
#, priority:100
msgid "Notably, delta compression is not used on objects larger than the `core.bigFileThreshold` configuration variable and on files with the attribute `delta` set to false."
msgstr "值得注意的是，delta 压缩不用于大于 `core.bigFileThreshold` 配置变量的对象和属性 `delta` 设置为 false 的文件。"

#. type: Plain text
#: en/git-pack-objects.txt:459
#, ignore-same, priority:100
msgid "linkgit:git-rev-list[1] linkgit:git-repack[1] linkgit:git-prune-packed[1]"
msgstr "linkgit:git-rev-list[1] linkgit:git-repack[1] linkgit:git-prune-packed[1]"

#. type: Title =
#: en/git-pack-redundant.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-pack-redundant(1)"
msgstr "git-pack-redundant(1)"

#. type: Plain text
#: en/git-pack-redundant.txt:7
#, fuzzy, priority:100
msgid "git-pack-redundant - Find redundant pack files"
msgstr "git-pack-redundant - Find redundant pack files"

#. type: Plain text
#: en/git-pack-redundant.txt:13
#, fuzzy, ignore-ellipsis, no-wrap, priority:100
msgid "'git pack-redundant' [--verbose] [--alt-odb] (--all | <pack-filename>...)\n"
msgstr "'git verify-pack' [-v|--verbose] [-s|--stat-only] [--] <pack>.idx ...\n"

#. type: Plain text
#: en/git-pack-redundant.txt:21
#, priority:100
msgid "`git pack-redundant` has been deprecated and is scheduled for removal in a future version of Git. Because it can only remove entire duplicate packs and not individual duplicate objects, it is generally not a useful tool for reducing repository size. You are better off using `git gc` to do so, which will put objects into a new pack, removing duplicates."
msgstr "`git pack-redundant` 已被弃用，并计划在未来的 Git 版本中移除。因为它只能移除整个重复的包，而不能移除单个重复的对象，所以它通常不是减少版本库大小的有用工具。最好使用 `git gc`，它会将对象放入一个新的包，删除重复的对象。"

#. type: Plain text
#: en/git-pack-redundant.txt:27
#, priority:100
msgid "Running `pack-redundant` without the `--i-still-use-this` flag will fail in this release. If you believe you have a use case for which `pack-redundant` is better suited and oppose this removal, please contact the Git mailing list at git@vger.kernel.org. More information about the list is available at https://git-scm.com/community."
msgstr "在此版本中，运行不带 `--i-still-use-this` 标志的`pack-redundant` 将失败。如果您认为 `pack-redundant` 更适合您的用例，并反对删除该标志，请联系 Git 邮件列表 git@vger.kernel.org。有关该列表的更多信息，请访问 https://git-scm.com/community。"

#. type: Plain text
#: en/git-pack-redundant.txt:33
#, priority:100
msgid "This program computes which packs in your repository are redundant. The output is suitable for piping to `xargs rm` if you are in the root of the repository."
msgstr "该程序计算仓库中哪些包是多余的。如果你在仓库的根目录下，输出结果可以通过管道连接到 `xargs rm`。"

#. type: Plain text
#: en/git-pack-redundant.txt:38
#, priority:100
msgid "'git pack-redundant' accepts a list of objects on standard input. Any objects given will be ignored when checking which packs are required. This makes the following command useful when wanting to remove packs which contain unreachable objects."
msgstr "'git pack-redundant' 接受标准输入的对象列表。在检查需要哪些包时，给定的对象将被忽略。这使得下面的命令在移除包含不可达对象的包时非常有用。"

#. type: Plain text
#: en/git-pack-redundant.txt:41
#, priority:100
msgid "git fsck --full --unreachable | cut -d ' ' -f3 | \\ git pack-redundant --all | xargs rm"
msgstr "git fsck --full --unreachable | cut -d ' ' -f3 | \\ git pack-redundant --all | xargs rm"

#. type: Plain text
#: en/git-pack-redundant.txt:48
#, priority:100
msgid "Processes all packs. Any filenames on the command line are ignored."
msgstr "处理所有数据包。忽略命令行中的任何文件名。"

#. type: Labeled list
#: en/git-pack-redundant.txt:49
#, ignore-same, no-wrap, priority:100
msgid "--alt-odb"
msgstr "--alt-odb"

#. type: Plain text
#: en/git-pack-redundant.txt:52
#, priority:100
msgid "Don't require objects present in packs from alternate object database (odb) directories to be present in local packs."
msgstr "不要求来自备用对象数据库（odb）目录的数据包中的对象也出现在本地数据包中。"

#. type: Plain text
#: en/git-pack-redundant.txt:55
#, priority:100
msgid "Outputs some statistics to stderr. Has a small performance penalty."
msgstr "向标注错误流输出一些统计数据。对性能有一点影响。"

#. type: Plain text
#: en/git-pack-redundant.txt:61
#, ignore-same, priority:100
msgid "linkgit:git-pack-objects[1] linkgit:git-repack[1] linkgit:git-prune-packed[1]"
msgstr "linkgit:git-pack-objects[1] linkgit:git-repack[1] linkgit:git-prune-packed[1]"

#. type: Title =
#: en/git-pack-refs.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-pack-refs(1)"
msgstr "git-pack-refs(1)"

#. type: Plain text
#: en/git-pack-refs.txt:7
#, priority:100
msgid "git-pack-refs - Pack heads and tags for efficient repository access"
msgstr "git-pack-refs - 打包头和标签，以便有效地访问仓库"

#. type: Plain text
#: en/git-pack-refs.txt:12
#, fuzzy, no-wrap, priority:100
msgid "'git pack-refs' [--all] [--no-prune] [--include <pattern>] [--exclude <pattern>]\n"
msgstr "'git pack-refs' [--all] [--no-prune]\n"

#. type: Plain text
#: en/git-pack-refs.txt:24
#, priority:100
msgid "Traditionally, tips of branches and tags (collectively known as 'refs') were stored one file per ref in a (sub)directory under `$GIT_DIR/refs` directory.  While many branch tips tend to be updated often, most tags and some branch tips are never updated.  When a repository has hundreds or thousands of tags, this one-file-per-ref format both wastes storage and hurts performance."
msgstr "传统上，分支和标签的提示（统称为 'refs'）是在 `$GIT_DIR/refs` 目录下的一个（子）目录中，为每个引用储存一个文件。 虽然许多分支的提示经常被更新，但大多数标签和一些分支的提示从未被更新。 当一个仓库库有成百上千的标签时，这种每个引用一个文件的格式既浪费了存储空间，又损害了性能。"

#. type: Plain text
#: en/git-pack-refs.txt:31
#, priority:100
msgid "This command is used to solve the storage and performance problem by storing the refs in a single file, `$GIT_DIR/packed-refs`.  When a ref is missing from the traditional `$GIT_DIR/refs` directory hierarchy, it is looked up in this file and used if found."
msgstr "这个命令是用来解决存储和性能问题的，将引用存储在一个文件中，`$GIT_DIR/packed-refs`。 当传统的 `$GIT_DIR/refs`目录层次中缺少一个引用时，就在这个文件中查找，如果找到就使用。"

#. type: Plain text
#: en/git-pack-refs.txt:34
#, priority:100
msgid "Subsequent updates to branches always create new files under `$GIT_DIR/refs` directory hierarchy."
msgstr "分支的后续更新总是在 `$GIT_DIR/refs` 目录层次下创建新文件。"

#. type: Plain text
#: en/git-pack-refs.txt:43
#, priority:100
msgid "A recommended practice to deal with a repository with too many refs is to pack its refs with `--all` once, and occasionally run `git pack-refs`.  Tags are by definition stationary and are not expected to change.  Branch heads will be packed with the initial `pack-refs --all`, but only the currently active branch heads will become unpacked, and the next `pack-refs` (without `--all`) will leave them unpacked."
msgstr "处理一个有太多引用的仓库的推荐做法是，用 `--all` 来打包它的引用一次，然后偶尔运行 `git pack-refs` 。 根据定义，标签是固定的，不应该改变。 分支头会被初始的 `pack-refs --all` 打包，但只有当前活动的分支头会被解压，下一次 `pack-refs`（没有 `--all`）会让它们被解压。"

#. type: Plain text
#: en/git-pack-refs.txt:57
#, fuzzy, priority:100
#| msgid "The command by default packs all tags and refs that are already packed, and leaves other refs alone.  This is because branches are expected to be actively developed and packing their tips does not help performance.  This option causes branch tips to be packed as well.  Useful for a repository with many branches of historical interests."
msgid "The command by default packs all tags and refs that are already packed, and leaves other refs alone.  This is because branches are expected to be actively developed and packing their tips does not help performance.  This option causes all refs to be packed as well, with the exception of hidden refs, broken refs, and symbolic refs. Useful for a repository with many branches of historical interests."
msgstr "该命令默认打包所有已经打包的标签和引用，而对其他引用不作任何处理。 这是因为预计分支会被积极开发，打包它们的提示对性能没有帮助。 这个选项使分支的提示也被打包。 这对有许多具有历史意义的分支的仓库很有用。"

#. type: Plain text
#: en/git-pack-refs.txt:62
#, priority:100
msgid "The command usually removes loose refs under `$GIT_DIR/refs` hierarchy after packing them.  This option tells it not to."
msgstr "该命令通常在打包后删除 `$GIT_DIR/refs` 层次下的松散引用。 这个选项告诉它不要这样做。"

#. type: Labeled list
#: en/git-pack-refs.txt:63
#, fuzzy, no-wrap, priority:100
#| msgid "--exclude <pattern>"
msgid "--include <pattern>"
msgstr "--排除<pattern>。"

#. type: Plain text
#: en/git-pack-refs.txt:71
#, priority:100
msgid "Pack refs based on a `glob(7)` pattern. Repetitions of this option accumulate inclusion patterns. If a ref is both included in `--include` and `--exclude`, `--exclude` takes precedence. Using `--include` will preclude all tags from being included by default. Symbolic refs and broken refs will never be packed. When used with `--all`, it will be a noop. Use `--no-include` to clear and reset the list of patterns."
msgstr ""

#. type: Plain text
#: en/git-pack-refs.txt:78
#, priority:100
msgid "Do not pack refs matching the given `glob(7)` pattern. Repetitions of this option accumulate exclusion patterns. Use `--no-exclude` to clear and reset the list of patterns. If a ref is already packed, including it with `--exclude` will not unpack it."
msgstr ""

#. type: Plain text
#: en/git-pack-refs.txt:81
#, priority:100
msgid "When used with `--all`, pack only loose refs which do not match any of the provided `--exclude` patterns."
msgstr ""

#. type: Plain text
#: en/git-pack-refs.txt:84
#, priority:100
msgid "When used with `--include`, refs provided to `--include`, minus refs that are provided to `--exclude` will be packed."
msgstr ""

#. type: Plain text
#: en/git-pack-refs.txt:92
#, priority:100
msgid "Older documentation written before the packed-refs mechanism was introduced may still say things like \".git/refs/heads/<branch> file exists\" when it means \"branch <branch> exists\"."
msgstr "在引入 packed-refs 机制之前编写的旧文档可能仍然会说 \".git/refs/heads/<branch>文件存在\" 这样的话，而它的意思是 \"<branch> 分支存在\"。"

#. type: Title =
#: en/git-patch-id.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-patch-id(1)"
msgstr "git-patch-id(1)"

#. type: Plain text
#: en/git-patch-id.txt:7
#, fuzzy, priority:100
msgid "git-patch-id - Compute unique ID for a patch"
msgstr "git-patch-id - Compute unique ID for a patch"

#. type: Plain text
#: en/git-patch-id.txt:12
#, no-wrap, priority:100
msgid "'git patch-id' [--stable | --unstable | --verbatim]\n"
msgstr "'git patch-id' [--stable | --unstable | --verbatim]\n"

#. type: Plain text
#: en/git-patch-id.txt:16
#, priority:100
msgid "Read a patch from the standard input and compute the patch ID for it."
msgstr "从标准输入读取一个补丁，并计算出它的补丁 ID。"

#. type: Plain text
#: en/git-patch-id.txt:21
#, priority:100
msgid "A \"patch ID\" is nothing but a sum of SHA-1 of the file diffs associated with a patch, with line numbers ignored.  As such, it's \"reasonably stable\", but at the same time also reasonably unique, i.e., two patches that have the same \"patch ID\" are almost guaranteed to be the same thing."
msgstr "\"补丁ID\" 只不过是一个与补丁相关的文件差异的 SHA-1 之和，行号被忽略。 因此，它是 \"相当稳定的\"，但同时也是相当独特的，也就是说，两个具有相同 \"补丁ID\" 的补丁几乎可以保证是同一个东西。"

#. type: Plain text
#: en/git-patch-id.txt:23
#, priority:100
msgid "The main usecase for this command is to look for likely duplicate commits."
msgstr "这个命令的主要用途是寻找可能的重复提交。"

#. type: Plain text
#: en/git-patch-id.txt:29
#, priority:100
msgid "When dealing with 'git diff-tree' output, it takes advantage of the fact that the patch is prefixed with the object name of the commit, and outputs two 40-byte hexadecimal strings.  The first string is the patch ID, and the second string is the commit ID.  This can be used to make a mapping from patch ID to commit ID."
msgstr "在处理 'git diff-tree' 输出时，它利用了补丁的前缀是提交的对象名称这一事实，并输出两个 40 字节的十六进制字符串。 第一个字符串是补丁的 ID，第二个字符串是提交的 ID。 这可以用来做一个从补丁ID 到提交 ID 的映射。"

#. type: Labeled list
#: en/git-patch-id.txt:33
#, ignore-same, no-wrap, priority:100
msgid "--verbatim"
msgstr "--verbatim"

#. type: Plain text
#: en/git-patch-id.txt:36
#, priority:100
msgid "Calculate the patch-id of the input as it is given, do not strip any whitespace."
msgstr "计算输入的补丁 ID，因为它是给定的，不要剥离任何空白字符。"

#. type: Plain text
#: en/git-patch-id.txt:38
#, priority:100
msgid "This is the default if patchid.verbatim is true."
msgstr "如果 patchid.verbatim 为真，这是默认的。"

#. type: Labeled list
#: en/git-patch-id.txt:39
#, ignore-same, no-wrap, priority:100
msgid "--stable"
msgstr "--stable"

#. type: Plain text
#: en/git-patch-id.txt:41
#, priority:100
msgid "Use a \"stable\" sum of hashes as the patch ID. With this option:"
msgstr "使用一个 \"稳定的\" 哈希值之和作为补丁 ID。有了这个选项："

#. type: Plain text
#: en/git-patch-id.txt:47
#, priority:100
msgid "Reordering file diffs that make up a patch does not affect the ID.  In particular, two patches produced by comparing the same two trees with two different settings for \"-O<orderfile>\" result in the same patch ID signature, thereby allowing the computed result to be used as a key to index some meta-information about the change between the two trees;"
msgstr "对组成补丁的文件差异进行重新排序并不影响 ID。 特别是，用两个不同的 \"-O<orderfile>\" 设置比较相同的两棵树所产生的两个补丁，会产生相同的补丁 ID 签名，从而允许计算结果被用作索引两个树之间变化的一些元信息的关键；"

#. type: Plain text
#: en/git-patch-id.txt:53
#, priority:100
msgid "Result is different from the value produced by git 1.9 and older or produced when an \"unstable\" hash (see --unstable below) is configured - even when used on a diff output taken without any use of \"-O<orderfile>\", thereby making existing databases storing such \"unstable\" or historical patch-ids unusable."
msgstr "结果与 git 1.9 及更早版本产生的值不同，或者在配置了 \"不稳定\" 哈希值（见下文 --unstable）时产生的值不同——即使在没有使用 \"-O<orderfile>\" 的情况下用于 diff 输出，从而使存储这种 \"不稳定“或历史补丁标识的现有数据库无法使用。"

#. type: Plain text
#: en/git-patch-id.txt:55
#, priority:100
msgid "All whitespace within the patch is ignored and does not affect the id."
msgstr "补丁中的所有空白都将被忽略，并且不影响 id。"

#. type: Plain text
#: en/git-patch-id.txt:57
#, no-wrap, priority:100
msgid "This is the default if patchid.stable is set to true.\n"
msgstr "如果 patchid.stable 设置为 true，则默认使用此值。\n"

#. type: Labeled list
#: en/git-patch-id.txt:58
#, ignore-same, no-wrap, priority:100
msgid "--unstable"
msgstr "--unstable"

#. type: Plain text
#: en/git-patch-id.txt:64
#, priority:100
msgid "Use an \"unstable\" hash as the patch ID. With this option, the result produced is compatible with the patch-id value produced by git 1.9 and older and whitespace is ignored.  Users with pre-existing databases storing patch-ids produced by git 1.9 and older (who do not deal with reordered patches) may want to use this option."
msgstr "使用 “不稳定” 哈希值作为补丁 ID。有了这个选项，产生的结果与 git 1.9 及更早版本产生的补丁 ID 值兼容，空白被忽略。 如果您的数据库中已有 git 1.9 及更早版本产生的补丁标识（不处理重新排序的补丁），可能需要使用此选项。"

#. type: Plain text
#: en/git-patch-id.txt:66
#, fuzzy, priority:100
msgid "This is the default."
msgstr "这是默认设置。"

#. type: Title =
#: en/git-prune-packed.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-prune-packed(1)"
msgstr "git-prune-packed(1)"

#. type: Plain text
#: en/git-prune-packed.txt:7
#, fuzzy, priority:100
msgid "git-prune-packed - Remove extra objects that are already in pack files"
msgstr "git-prune-packed - Remove extra objects that are already in pack files"

#. type: Plain text
#: en/git-prune-packed.txt:13
#, fuzzy, no-wrap, priority:100
msgid "'git prune-packed' [-n | --dry-run] [-q | --quiet]\n"
msgstr "'git prune-packed' [-n|--dry-run] [-q|--quiet]\n"

#. type: Plain text
#: en/git-prune-packed.txt:19
#, priority:100
msgid "This program searches the `$GIT_OBJECT_DIRECTORY` for all objects that currently exist in a pack file as well as the independent object directories."
msgstr "这个程序会搜索 `$GIT_OBJECT_DIRECTORY` 所有当前存在于 pack 文件中的对象以及独立的对象目录。"

#. type: Plain text
#: en/git-prune-packed.txt:21
#, priority:100
msgid "All such extra objects are removed."
msgstr "所有这些额外的对象都会被删除。"

#. type: Plain text
#: en/git-prune-packed.txt:24 en/git-repack.txt:24
#, priority:100
msgid "A pack is a collection of objects, individually compressed, with delta compression applied, stored in a single file, with an associated index file."
msgstr "压缩包是对象的集合，单独压缩，应用 delta 压缩，存储在单个文件中，并带有相关索引文件。"

#. type: Plain text
#: en/git-prune-packed.txt:27 en/git-repack.txt:27
#, priority:100
msgid "Packs are used to reduce the load on mirror systems, backup engines, disk storage, etc."
msgstr "软件包用于减少镜像系统、备份引擎、磁盘存储等的负载。"

#. type: Plain text
#: en/git-prune-packed.txt:35
#, priority:100
msgid "Don't actually remove any objects, only show those that would have been removed."
msgstr "实际不删除任何对象，只显示本应删除的对象。"

#. type: Plain text
#: en/git-prune-packed.txt:39
#, priority:100
msgid "Squelch the progress indicator."
msgstr "关闭进度指示器。"

#. type: Plain text
#: en/git-prune-packed.txt:44
#, ignore-same, priority:100
msgid "linkgit:git-pack-objects[1] linkgit:git-repack[1]"
msgstr "linkgit:git-pack-objects[1] linkgit:git-repack[1]"

#. type: Title =
#: en/git-prune.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-prune(1)"
msgstr "git-prune(1)"

#. type: Plain text
#: en/git-prune.txt:7
#, fuzzy, priority:100
msgid "git-prune - Prune all unreachable objects from the object database"
msgstr "git-prune - Prune all unreachable objects from the object database"

#. type: Plain text
#: en/git-prune.txt:13
#, fuzzy, ignore-ellipsis, no-wrap, priority:100
msgid "'git prune' [-n] [-v] [--progress] [--expire <time>] [--] [<head>...]\n"
msgstr "'git prune' [-n] [-v] [--progress] [--expire <time>] [--] [<head>...]\n"

#. type: Plain text
#: en/git-prune.txt:19
#, priority:100
msgid "In most cases, users should run 'git gc', which calls 'git prune'. See the section \"NOTES\", below."
msgstr "在大多数情况下，用户应该运行 'git gc'，它调用 'git prune'。参见下文 “注意” 一节。"

#. type: Plain text
#: en/git-prune.txt:29
#, priority:100
msgid "This runs 'git fsck --unreachable' using all the refs available in `refs/`, optionally with additional set of objects specified on the command line, and prunes all unpacked objects unreachable from any of these head objects from the object database.  In addition, it prunes the unpacked objects that are also found in packs by running 'git prune-packed'.  It also removes entries from .git/shallow that are not reachable by any ref."
msgstr "运行 'git fsck --unreachable'，使用 `refs/` 中可用的所有引用，可选地使用命令行中指定的附加对象集，并从对象数据库中删除所有从这些头对象中无法访问的未打包对象。 此外，它还会删除通过运行 'git prune-packed' 在包中找到的未打包对象。 它还会删除 .git/shallow 中任何引用都无法访问的条目。"

#. type: Plain text
#: en/git-prune.txt:32
#, priority:100
msgid "Note that unreachable, packed objects will remain.  If this is not desired, see linkgit:git-repack[1]."
msgstr "需要注意的是，无法到达的打包对象将被保留。 如果不希望这样，请参见 linkgit:git-repack[1]。"

#. type: Plain text
#: en/git-prune.txt:40
#, priority:100
msgid "Do not remove anything; just report what it would remove."
msgstr "不删除任何内容；只需报告将删除的内容。"

#. type: Plain text
#: en/git-prune.txt:44
#, priority:100
msgid "Report all removed objects."
msgstr "报告所有移除的对象。"

#. type: Plain text
#: en/git-prune.txt:47
#, priority:100
msgid "Show progress."
msgstr "显示进度。"

#. type: Labeled list
#: en/git-prune.txt:48 en/git-worktree.txt:261
#, fuzzy, no-wrap, priority:240
msgid "--expire <time>"
msgstr "--expire <time>"

#. type: Plain text
#: en/git-prune.txt:50
#, priority:100
msgid "Only expire loose objects older than <time>."
msgstr "仅过期超过 <时间> 的松散对象。"

#. type: Labeled list
#: en/git-prune.txt:54
#, fuzzy, ignore-ellipsis, no-wrap, priority:100
msgid "<head>..."
msgstr "<head>..."

#. type: Plain text
#: en/git-prune.txt:58
#, priority:100
msgid "In addition to objects reachable from any of our references, keep objects reachable from listed <head>s."
msgstr "除了可从我们的任何引用到达的对象外，还保留可从列出的 <head> 到达的对象。"

#. type: Plain text
#: en/git-prune.txt:65
#, priority:100
msgid "To prune objects not used by your repository or another that borrows from your repository via its `.git/objects/info/alternates`:"
msgstr "剪切您的仓库或其他通过 `.git/objects/info/alternates` 借用您仓库的仓库不使用的对象："

#. type: delimited block -
#: en/git-prune.txt:68
#, fuzzy, no-wrap, priority:100
msgid "$ git prune $(cd ../another && git rev-parse --all)\n"
msgstr "$ git prune $(cd ../another && git rev-parse --all)\n"

#. type: Plain text
#: en/git-prune.txt:76
#, priority:100
msgid "In most cases, users will not need to call 'git prune' directly, but should instead call 'git gc', which handles pruning along with many other housekeeping tasks."
msgstr "在大多数情况下，用户不需要直接调用 'git prune'，而应该调用 'git gc'，它可以处理剪枝和许多其他内务工作。"

#. type: Plain text
#: en/git-prune.txt:79
#, priority:100
msgid "For a description of which objects are considered for pruning, see 'git fsck''s --unreachable option."
msgstr "关于哪些对象会被考虑剪枝，请参见 'git fsck' 的 --unreachable 选项。"

#. type: Plain text
#: en/git-prune.txt:86
#, ignore-same, priority:100
msgid "linkgit:git-fsck[1], linkgit:git-gc[1], linkgit:git-reflog[1]"
msgstr "linkgit:git-fsck[1], linkgit:git-gc[1], linkgit:git-reflog[1]"

#. type: Title =
#: en/git-pull.txt:2
#, ignore-same, no-wrap, priority:220
msgid "git-pull(1)"
msgstr "git-pull(1)"

#. type: Plain text
#: en/git-pull.txt:7
#, fuzzy, priority:220
msgid "git-pull - Fetch from and integrate with another repository or a local branch"
msgstr "git-pull - Fetch from and integrate with another repository or a local branch"

#. type: Plain text
#: en/git-pull.txt:13
#, fuzzy, ignore-ellipsis, no-wrap, priority:220
msgid "'git pull' [<options>] [<repository> [<refspec>...]]\n"
msgstr "'git pull' [<options>] [<repository> [<refspec>...]]\n"

#. type: Plain text
#: en/git-pull.txt:24
#, priority:220
msgid "Incorporates changes from a remote repository into the current branch.  If the current branch is behind the remote, then by default it will fast-forward the current branch to match the remote.  If the current branch and the remote have diverged, the user needs to specify how to reconcile the divergent branches with `--rebase` or `--no-rebase` (or the corresponding configuration option in `pull.rebase`)."
msgstr "将远程版本库的修改并入当前分支。 如果当前分支落后于远程分支，那么默认情况下，它将快速合并当前分支以匹配远程分支。 如果当前分支和远程分支有分歧，用户需要用 `--rebase` 或 `--no-rebase`（或 `pull.rebase` 中的相应配置选项）来指定如何调和分歧的分支。"

#. type: Plain text
#: en/git-pull.txt:29
#, priority:220
msgid "More precisely, `git pull` runs `git fetch` with the given parameters and then depending on configuration options or command line flags, will call either `git rebase` or `git merge` to reconcile diverging branches."
msgstr "更确切地说，`git pull` 运行 `git fetch` 并给出参数，然后根据配置选项或命令行标志，调用 `git rebase` 或 `git merge` 来协调不同的分支。"

#. type: Plain text
#: en/git-pull.txt:36
#, priority:220
msgid "<repository> should be the name of a remote repository as passed to linkgit:git-fetch[1].  <refspec> can name an arbitrary remote ref (for example, the name of a tag) or even a collection of refs with corresponding remote-tracking branches (e.g., refs/heads/{asterisk}:refs/remotes/origin/{asterisk}), but usually it is the name of a branch in the remote repository."
msgstr "<仓库> 应该是传递给 linkgit:git-fetch[1] 的远程仓库的名称。 < 用引规范 > 可以命名一个任意的远程引用（例如，一个标签的名称），甚至是一个有相应远程跟踪分支的引用集合（例如，refs/heads/{asterisk}:refs/remotes/origin/{asterisk}），但通常它是远程仓库的一个分支名称。"

#. type: Plain text
#: en/git-pull.txt:40
#, priority:220
msgid "Default values for <repository> and <branch> are read from the \"remote\" and \"merge\" configuration for the current branch as set by linkgit:git-branch[1] `--track`."
msgstr "<仓库> 和 < 分支 > 的默认值是从 linkgit:git-branch[1] `--track` 设置的当前分支的 \"远程\" 和 \"合并\" 配置中读取。"

#. type: delimited block -
#: en/git-pull.txt:50
#, no-wrap, priority:220
msgid ""
"\t  A---B---C master on origin\n"
"\t /\n"
"    D---E---F---G master\n"
"\t^\n"
"\torigin/master in your repository\n"
msgstr ""
"\t  A---B---C master on origin\n"
"\t /\n"
"    D---E---F---G master\n"
"\t^\n"
"\t你仓库中的 origin/master\n"

#. type: Plain text
#: en/git-pull.txt:57
#, priority:220
msgid "Then \"`git pull`\" will fetch and replay the changes from the remote `master` branch since it diverged from the local `master` (i.e., `E`)  until its current commit (`C`) on top of `master` and record the result in a new commit along with the names of the two parent commits and a log message from the user describing the changes."
msgstr "然后，\"`git pull`\" 将从远程的 `master` 分支获取并重放自它与本地 `master`（即 `E`）分歧以来的变化，直到它在 `master` 之上的当前提交（`C`），并将结果与两个父提交的名称和用户描述变化的日志信息一起记录在一个新提交中。"

#. type: delimited block -
#: en/git-pull.txt:62
#, no-wrap, priority:220
msgid ""
"\t  A---B---C origin/master\n"
"\t /         \\\n"
"    D---E---F---G---H master\n"
msgstr ""
"\t  A---B---C origin/master\n"
"\t /         \\\n"
"    D---E---F---G---H master\n"

#. type: Plain text
#: en/git-pull.txt:66
#, priority:220
msgid "See linkgit:git-merge[1] for details, including how conflicts are presented and handled."
msgstr "详情见 linkgit:git-merge[1]，包括如何呈现和处理冲突。"

#. type: Plain text
#: en/git-pull.txt:71
#, priority:220
msgid "In Git 1.7.0 or later, to cancel a conflicting merge, use `git reset --merge`.  *Warning*: In older versions of Git, running 'git pull' with uncommitted changes is discouraged: while possible, it leaves you in a state that may be hard to back out of in the case of a conflict."
msgstr "在 Git 1.7.0 或更高版本中，要取消一个冲突的合并，请使用 `git reset --merge`。 * 警告 *：在旧版本的 Git 中，不鼓励在未提交的情况下运行 \"git pull\"：虽然有可能，但在发生冲突的情况下，会让你处于一个难以恢复的状态。"

#. type: Plain text
#: en/git-pull.txt:76
#, priority:220
msgid "If any of the remote changes overlap with local uncommitted changes, the merge will be automatically canceled and the work tree untouched.  It is generally best to get any local changes in working order before pulling or stash them away with linkgit:git-stash[1]."
msgstr "如果任何远程修改与本地未提交的修改重叠，合并将被自动取消，工作目录树不会被改动。  一般来说，最好是在拉取之前把任何本地的修改弄到工作状态，或者用 linkgit:git-stash[1] 把它们贮藏起来。"

#. type: Plain text
#: en/git-pull.txt:85
#, priority:220
msgid "This is passed to both underlying git-fetch to squelch reporting of during transfer, and underlying git-merge to squelch output during merging."
msgstr "这将被传递给底层的 git-fetch，以便在传输过程中抑制报告，以及底层的 git-merge，以便在合并过程中抑制输出。"

#. type: Plain text
#: en/git-pull.txt:89
#, priority:220
msgid "Pass --verbose to git-fetch and git-merge."
msgstr "将 --verbose 传给 git-fetch 和 git-merge。"

#. type: Labeled list
#: en/git-pull.txt:90
#, fuzzy, no-wrap, priority:220
msgid "--[no-]recurse-submodules[=yes|on-demand|no]"
msgstr "--[no-]recurse-submodules[=yes|on-demand|no]"

#. type: Plain text
#: en/git-pull.txt:95
#, priority:220
msgid "This option controls if new commits of populated submodules should be fetched, and if the working trees of active submodules should be updated, too (see linkgit:git-fetch[1], linkgit:git-config[1] and linkgit:gitmodules[5])."
msgstr "这个选项控制是否应该获取已填充子模块的新提交，以及是否应该更新活动子模块的工作树（见linkgit:git-fetch[1], linkgit:git-config[1] 和 linkgit:gitmodules[5]）。"

#. type: Plain text
#: en/git-pull.txt:97
#, priority:220
msgid "If the checkout is done via rebase, local submodule commits are rebased as well."
msgstr "如果签出是通过变基完成的，那么本地子模块的提交也会被变基。"

#. type: Plain text
#: en/git-pull.txt:99
#, priority:220
msgid "If the update is done via merge, the submodule conflicts are resolved and checked out."
msgstr "如果更新是通过合并完成的，子模块的冲突就会被解决并被检查出来。"

#. type: Title ~
#: en/git-pull.txt:101
#, no-wrap, priority:220
msgid "Options related to merging"
msgstr "与合并有关的选项"

#. type: Labeled list
#: en/git-pull.txt:108
#, fuzzy, no-wrap, priority:220
msgid "--rebase[=false|true|merges|interactive]"
msgstr "--preserve-merges and --interactive"

#. type: Plain text
#: en/git-pull.txt:114
#, priority:220
msgid "When true, rebase the current branch on top of the upstream branch after fetching. If there is a remote-tracking branch corresponding to the upstream branch and the upstream branch was rebased since last fetched, the rebase uses that information to avoid rebasing non-local changes."
msgstr "为真时，在获取后将当前分支变基到上游分支之上。如果有一个远程跟踪的分支与上游分支相对应，并且上游分支在上次获取后被重新建立了基础，那么变基就会使用该信息以避免重新建立非本地的变化。"

#. type: Plain text
#: en/git-pull.txt:118
#, priority:220
msgid "When set to `merges`, rebase using `git rebase --rebase-merges` so that the local merge commits are included in the rebase (see linkgit:git-rebase[1] for details)."
msgstr "当设置为 `merges` 时，使用 `git rebase --rebase-merges` 进行重建，这样本地的合并提交就会包含在重建中（详见 linkgit:git-rebase[1]）。"

#. type: Plain text
#: en/git-pull.txt:120
#, priority:220
msgid "When false, merge the upstream branch into the current branch."
msgstr "如果为false，则将上游分支合并到当前分支中。"

#. type: Plain text
#: en/git-pull.txt:122
#, priority:220
msgid "When `interactive`, enable the interactive mode of rebase."
msgstr "当设置为 `interactive` 时，启用变基的交互模式。"

#. type: Plain text
#: en/git-pull.txt:126
#, priority:220
msgid "See `pull.rebase`, `branch.<name>.rebase` and `branch.autoSetupRebase` in linkgit:git-config[1] if you want to make `git pull` always use `--rebase` instead of merging."
msgstr "如果你想让 `git pull` 总是使用 `--rebase` 而不是合并，请参见 linkgit:git-config[1] 中的 `pull.rebase`, `branch.< 分支名 >.rebase` 和 `branch.autoSetupRebase`。"

#. type: Plain text
#: en/git-pull.txt:132
#, priority:220
msgid "This is a potentially _dangerous_ mode of operation.  It rewrites history, which does not bode well when you published that history already.  Do *not* use this option unless you have read linkgit:git-rebase[1] carefully."
msgstr "这是一种潜在的「危险的」操作模式。  它重写了历史，当你已经发布了这些历史时，这并不是一个好兆头。  除非你仔细阅读了linkgit:git-rebase[1]，否则请「不要」使用这个选项。"

#. type: Labeled list
#: en/git-pull.txt:133 en/git-svn.txt:261
#, ignore-same, no-wrap, priority:220
msgid "--no-rebase"
msgstr "--no-rebase"

#. type: Plain text
#: en/git-pull.txt:135
#, priority:220
msgid "This is shorthand for --rebase=false."
msgstr "这是对 --rebase=false 的简写。"

#. type: Title ~
#: en/git-pull.txt:137
#, no-wrap, priority:220
msgid "Options related to fetching"
msgstr "与获取有关的选项"

#. type: Title -
#: en/git-pull.txt:148
#, no-wrap, priority:220
msgid "DEFAULT BEHAVIOUR"
msgstr "默认行为"

#. type: Plain text
#: en/git-pull.txt:155
#, priority:220
msgid "Often people use `git pull` without giving any parameter.  Traditionally, this has been equivalent to saying `git pull origin`.  However, when configuration `branch.<name>.remote` is present while on branch `<name>`, that value is used instead of `origin`."
msgstr "人们经常使用 `git pull` 而不给任何参数。 传统上，这等同于说 `git pull origin`。 然而，当配置 `branch.<分支名>.remote` 在分支 `< 分支名 >` 上出现时，该值会被用来代替 `origin`。"

#. type: Plain text
#: en/git-pull.txt:160
#, priority:220
msgid "In order to determine what URL to use to fetch from, the value of the configuration `remote.<origin>.url` is consulted and if there is not any such variable, the value on the `URL:` line in `$GIT_DIR/remotes/<origin>` is used."
msgstr "为了确定使用什么 URL 来获取，将查询配置 `remote.<远程名>.url` 的值，如果没有这样的变量，将使用 `$GIT_DIR/remotes/< 远程名 >` 中 `URL:` 一行的值。"

#. type: Plain text
#: en/git-pull.txt:169
#, priority:220
msgid "In order to determine what remote branches to fetch (and optionally store in the remote-tracking branches) when the command is run without any refspec parameters on the command line, values of the configuration variable `remote.<origin>.fetch` are consulted, and if there aren't any, `$GIT_DIR/remotes/<origin>` is consulted and its `Pull:` lines are used.  In addition to the refspec formats described in the OPTIONS section, you can have a globbing refspec that looks like this:"
msgstr "当命令行上没有任何引用规范参数时，为了确定要获取哪些远程分支（并可选择存储在远程跟踪分支中），会查询配置变量 `remote.<远程名>.fetch` 的值，如果没有，会查询 `$GIT_DIR/remotes/< 远程名 >` 并使用其 `Pull:` 行。 除了在『选项』部分描述的引用规范格式之外，你还可以有一个看起来像这样的引用规范通配符："

#. type: delimited block -
#: en/git-pull.txt:172
#, no-wrap, priority:220
msgid "refs/heads/*:refs/remotes/origin/*\n"
msgstr "refs/heads/*:refs/remotes/origin/*\n"

#. type: Plain text
#: en/git-pull.txt:179
#, priority:220
msgid "A globbing refspec must have a non-empty RHS (i.e. must store what were fetched in remote-tracking branches), and its LHS and RHS must end with `/*`.  The above specifies that all remote branches are tracked using remote-tracking branches in `refs/remotes/origin/` hierarchy under the same name."
msgstr "一个引用规范通配符必须有一个非空的 RHS（即必须存储在远程跟踪分支中获取的内容），其 LHS 和 RHS 必须以 `/*` 结尾。 以上规定了所有远程分支都使用同名的 `refs/remotes/origin/` 层次结构中的远程跟踪分支进行跟踪。"

#. type: Plain text
#: en/git-pull.txt:183
#, priority:220
msgid "The rule to determine which remote branch to merge after fetching is a bit involved, in order not to break backward compatibility."
msgstr "为了不破坏后向兼容性，确定在获取后合并哪个远程分支的规则有点复杂。"

#. type: Plain text
#: en/git-pull.txt:186
#, priority:220
msgid "If explicit refspecs were given on the command line of `git pull`, they are all merged."
msgstr "如果在 `git pull` 的命令行中给出了明确的引用规范，它们都会被合并。"

#. type: Plain text
#: en/git-pull.txt:191
#, priority:220
msgid "When no refspec was given on the command line, then `git pull` uses the refspec from the configuration or `$GIT_DIR/remotes/<origin>`.  In such cases, the following rules apply:"
msgstr "当命令行没有给出引用规范时，那么 `git pull` 使用配置或 `$GIT_DIR/remotes/<远程名>` 中的引用规范。 在这种情况下，以下规则适用："

#. type: Plain text
#: en/git-pull.txt:195
#, priority:220
msgid "If `branch.<name>.merge` configuration for the current branch `<name>` exists, that is the name of the branch at the remote site that is merged."
msgstr "如果当前分支 `<分支名>` 的 `branch.< 分支名 >.merge` 配置存在，这就是被合并的远程站点的分支名称。"

#. type: Plain text
#: en/git-pull.txt:197
#, fuzzy, priority:220
msgid "If the refspec is a globbing one, nothing is merged."
msgstr "如果 refspec 是全局的， 则不合并任何信息。"

#. type: Plain text
#: en/git-pull.txt:199
#, priority:220
msgid "Otherwise the remote branch of the first refspec is merged."
msgstr "否则将合并第一个引用规范的远程分支。"

#. type: Plain text
#: en/git-pull.txt:207
#, priority:220
msgid "Update the remote-tracking branches for the repository you cloned from, then merge one of them into your current branch:"
msgstr "更新你所克隆的仓库的远程跟踪分支，然后将其中一个分支合并到你当前的分支："

#. type: delimited block -
#: en/git-pull.txt:211
#, fuzzy, no-wrap, priority:220
msgid ""
"$ git pull\n"
"$ git pull origin\n"
msgstr ""
"$ git pull\n"
"$ git pull origin\n"

#. type: Plain text
#: en/git-pull.txt:216
#, priority:220
msgid "Normally the branch merged in is the HEAD of the remote repository, but the choice is determined by the branch.<name>.remote and branch.<name>.merge options; see linkgit:git-config[1] for details."
msgstr "通常情况下，合并进来的分支是远程仓库的 HEAD，但选择由 branch.<分支名>.remote 和 branch.< 分支名 >.merge 选项决定；详见 linkgit:git-config[1] 。"

#. type: Plain text
#: en/git-pull.txt:218
#, priority:220
msgid "Merge into the current branch the remote branch `next`:"
msgstr "将远程分支 `next` 合并到当前分支："

#. type: delimited block -
#: en/git-pull.txt:221
#, fuzzy, no-wrap, priority:220
msgid "$ git pull origin next\n"
msgstr "$ git pull origin next\n"

#. type: Plain text
#: en/git-pull.txt:226
#, priority:220
msgid "This leaves a copy of `next` temporarily in FETCH_HEAD, and updates the remote-tracking branch `origin/next`.  The same can be done by invoking fetch and merge:"
msgstr "这将在 FETCH_HEAD 中暂时留下 `next` 的副本，并更新远程跟踪分支 `origin/next`。 同样可以通过调用 fetch 和 merge 来完成："

#. type: delimited block -
#: en/git-pull.txt:230
#, fuzzy, no-wrap, priority:220
msgid ""
"$ git fetch origin\n"
"$ git merge origin/next\n"
msgstr ""
"$ git fetch origin\n"
"$ git merge origin/next\n"

#. type: Plain text
#: en/git-pull.txt:235
#, priority:220
msgid "If you tried a pull which resulted in complex conflicts and would want to start over, you can recover with 'git reset'."
msgstr "如果你尝试了一次拉取，导致了复杂的冲突，想重新开始，你可以用 'git reset' 来恢复。"

#. type: Plain text
#: en/git-pull.txt:247
#, priority:220
msgid "Using --recurse-submodules can only fetch new commits in already checked out submodules right now. When e.g. upstream added a new submodule in the just fetched commits of the superproject the submodule itself cannot be fetched, making it impossible to check out that submodule later without having to do a fetch again. This is expected to be fixed in a future Git version."
msgstr "使用 --recurse-submodules 现在只能获取已经签出的子模块的新提交。例如，当上游在刚刚获取的超级项目的提交中添加了一个新的子模块时，子模块本身不能被获取，这使得以后不需要再次获取就能签出该子模块。这个问题有望在未来的 Git 版本中被修复。"

#. type: Plain text
#: en/git-pull.txt:251
#, ignore-same, priority:220
msgid "linkgit:git-fetch[1], linkgit:git-merge[1], linkgit:git-config[1]"
msgstr "linkgit:git-fetch[1], linkgit:git-merge[1], linkgit:git-config[1]"

#. type: Title =
#: en/git-push.txt:2
#, ignore-same, no-wrap, priority:220
msgid "git-push(1)"
msgstr "git-push(1)"

#. type: Plain text
#: en/git-push.txt:7
#, priority:220
msgid "git-push - Update remote refs along with associated objects"
msgstr "git-push - 与相关对象一起更新远程分支引用"

#. type: Plain text
#: en/git-push.txt:18
#, ignore-ellipsis, no-wrap, priority:220
msgid ""
"'git push' [--all | --branches | --mirror | --tags] [--follow-tags] [--atomic] [-n | --dry-run] [--receive-pack=<git-receive-pack>]\n"
"\t   [--repo=<repository>] [-f | --force] [-d | --delete] [--prune] [-v | --verbose]\n"
"\t   [-u | --set-upstream] [-o <string> | --push-option=<string>]\n"
"\t   [--[no-]signed|--signed=(true|false|if-asked)]\n"
"\t   [--force-with-lease[=<refname>[:<expect>]] [--force-if-includes]]\n"
"\t   [--no-verify] [<repository> [<refspec>...]]\n"
msgstr ""
"'git push' [--all | --branches | --mirror | --tags] [--follow-tags] [--atomic] [-n | --dry-run] [--receive-pack=<git-receive-pack>]\n"
"\t   [--repo=<仓库>] [-f | --force] [-d | --delete] [--prune] [-v | --verbose]\n"
"\t   [-u | --set-upstream] [-o <字符串> | --push-option=<字符串>]\n"
"\t   [--[no-]signed|--signed=(true|false|if-asked)]\n"
"\t   [--force-with-lease[=<引用名>[:<expect>]] [--force-if-includes]]\n"
"\t   [--no-verify] [<仓库> [<引用规范>...]]\n"

#. type: Plain text
#: en/git-push.txt:24
#, priority:220
msgid "Updates remote refs using local refs, while sending objects necessary to complete the given refs."
msgstr "使用本地引用更新远程仓库引用，同时发送完成给定引用的必要对象。"

#. type: Plain text
#: en/git-push.txt:28
#, priority:220
msgid "You can make interesting things happen to a repository every time you push into it, by setting up 'hooks' there.  See documentation for linkgit:git-receive-pack[1]."
msgstr "通过设置 “钩子”，你可以在每次推送到一个仓库时，让它发生有趣的事情。 见 linkgit:git-receive-pack[1] 的文档。"

#. type: Plain text
#: en/git-push.txt:33
#, priority:220
msgid "When the command line does not specify where to push with the `<repository>` argument, `branch.*.remote` configuration for the current branch is consulted to determine where to push.  If the configuration is missing, it defaults to 'origin'."
msgstr "当命令行没有用 `<仓库>` 参数指定推送位置时，会参考当前分支的 `branch.*.remote` 配置来决定推送位置。 如果配置丢失，则默认为 \"origin\"。"

#. type: Plain text
#: en/git-push.txt:39
#, ignore-ellipsis, priority:220
msgid "When the command line does not specify what to push with `<refspec>...` arguments or `--all`, `--mirror`, `--tags` options, the command finds the default `<refspec>` by consulting `remote.*.push` configuration, and if it is not found, honors `push.default` configuration to decide what to push (See linkgit:git-config[1] for the meaning of `push.default`)."
msgstr "当命令行没有用 `<引用规范>...` 参数或 `--all`、`--mirror`、`--tags` 选项指定推送内容时，命令通过查阅 `remote.*.push` 配置找到默认的 `< 引用规范 >`，如果没有找到，则以 `push.default` 配置决定推送内容（关于 `push.default` 的含义，见 linkgit：git-config[1] ）。"

#. type: Plain text
#: en/git-push.txt:46
#, priority:220
msgid "When neither the command-line nor the configuration specify what to push, the default behavior is used, which corresponds to the `simple` value for `push.default`: the current branch is pushed to the corresponding upstream branch, but as a safety measure, the push is aborted if the upstream branch does not have the same name as the local one."
msgstr "当命令行和配置都没有指定推送的内容时，将使用默认行为，这与 `push.default` 的 `simple` 值相对应：当前分支被推送到相应的上游分支，但作为一项安全措施，如果上游分支的名称与本地分支不一致，推送将被中止。"

#. type: Title -
#: en/git-push.txt:49
#, no-wrap, priority:220
msgid "OPTIONS[[OPTIONS]]"
msgstr "选项[[OPTIONS]]"

#. type: Plain text
#: en/git-push.txt:55
#, priority:220
msgid "The \"remote\" repository that is destination of a push operation.  This parameter can be either a URL (see the section <<URLS,GIT URLS>> below) or the name of a remote (see the section <<REMOTES,REMOTES>> below)."
msgstr "作为推送操作的目的地的“远程”仓库。 这个参数可以是一个 URL（见下面 <<URLS,GIT URLS>> 一节），也可以是一个远程库的名称（见下面 <<远程仓库,REMOTES>> 一节）。"

#. type: Labeled list
#: en/git-push.txt:56
#, fuzzy, ignore-ellipsis, no-wrap, priority:220
msgid "<refspec>..."
msgstr "<refspec>..."

#. type: Plain text
#: en/git-push.txt:61
#, priority:220
msgid "Specify what destination ref to update with what source object.  The format of a <refspec> parameter is an optional plus `+`, followed by the source object <src>, followed by a colon `:`, followed by the destination ref <dst>."
msgstr "指定用什么源对象来更新哪个目标参考文献。 <引用规范> 参数的格式是一个可选的加号 `+`，后面是源对象 <src>，后面是冒号 `:`，后面是目标引用 <dst>。"

#. type: Plain text
#: en/git-push.txt:65
#, priority:220
msgid "The <src> is often the name of the branch you would want to push, but it can be any arbitrary \"SHA-1 expression\", such as `master~4` or `HEAD` (see linkgit:gitrevisions[7])."
msgstr "<src> 通常是你想推送的分支的名字，但它可以是任何任意的“SHA-1 表达式”，比如 `master~4` 或 `HEAD`（见 linkgit:gitrevisions[7]）。"

#. type: Plain text
#: en/git-push.txt:75
#, priority:220
msgid "The <dst> tells which ref on the remote side is updated with this push. Arbitrary expressions cannot be used here, an actual ref must be named.  If `git push [<repository>]` without any `<refspec>` argument is set to update some ref at the destination with `<src>` with `remote.<repository>.push` configuration variable, `:<dst>` part can be omitted--such a push will update a ref that `<src>` normally updates without any `<refspec>` on the command line.  Otherwise, missing `:<dst>` means to update the same ref as the `<src>`."
msgstr "<dst> 远程仓库的哪个引用被这个推送更新。这里不能使用任意的表达式，必须命名一个实际的引用。 如果 `git push [< 仓库 >]` 没有任何 `< 引用规范 >` 参数被设置用 `remote.< 仓库 >.push` 配置变量更新目的地 `<src>` 的某个引用，则`:<dst>` 部分可以省略 —— 这样的推送将更新 `<src>` 通常更新的引用，命令行上没有任何 `< 引用规范 >`。 否则，缺少 `:<dst>` 意味着更新与 `<src>` 相同的引用。"

#. type: Plain text
#: en/git-push.txt:80
#, priority:220
msgid "If <dst> doesn't start with `refs/` (e.g. `refs/heads/master`) we will try to infer where in `refs/*` on the destination <repository> it belongs based on the type of <src> being pushed and whether <dst> is ambiguous."
msgstr "如果 <dst> 不是以 `refs/` 开头（例如 `refs/heads/master`），我们将根据被推送的 <src> 的类型和 <dst> 是否含糊不清，尝试推断它在目的地 < 仓库 > 的 `refs/*` 中的位置。"

#. type: Plain text
#: en/git-push.txt:84
#, priority:220
msgid "If <dst> unambiguously refers to a ref on the <repository> remote, then push to that ref."
msgstr "如果 <dst> 明确地指向 < 仓库 > 远程的一个引用，那么就推送到该引用。"

#. type: Plain text
#: en/git-push.txt:87
#, priority:220
msgid "If <src> resolves to a ref starting with refs/heads/ or refs/tags/, then prepend that to <dst>."
msgstr "如果 <src> 解析为以 refs/heads/ 或 refs/tags/ 开头的引用，则将其前置到 <dst>。"

#. type: Plain text
#: en/git-push.txt:93
#, priority:220
msgid "Other ambiguity resolutions might be added in the future, but for now any other cases will error out with an error indicating what we tried, and depending on the `advice.pushUnqualifiedRefname` configuration (see linkgit:git-config[1]) suggest what refs/ namespace you may have wanted to push to."
msgstr "其他含糊的解决方案可能会在未来加入，但现在我们所尝试的任何其他情况都会出错，并根据`advice.pushUnqualifiedRefname`配置（见linkgit:git-config[1]）建议你可能想推送到哪个类型的引用中。"

#. type: Plain text
#: en/git-push.txt:101
#, priority:220
msgid "The object referenced by <src> is used to update the <dst> reference on the remote side. Whether this is allowed depends on where in `refs/*` the <dst> reference lives as described in detail below, in those sections \"update\" means any modifications except deletes, which as noted after the next few sections are treated differently."
msgstr "由 <src> 引用的对象被用来更新远程端的 <dst> 引用。这是否被允许取决于 <dst> 引用在`refs/*`中的位置，下面将详细描述，在这些章节中，“更新”意味着除了删除之外的任何修改，正如在接下来的几节中所指出的，这将被不同地对待。"

#. type: Plain text
#: en/git-push.txt:104
#, priority:220
msgid "The `refs/heads/*` namespace will only accept commit objects, and updates only if they can be fast-forwarded."
msgstr "`refs/heads/*` 命名空间只接受提交对象，只有在可以快进的情况下才接受更新。"

#. type: Plain text
#: en/git-push.txt:108
#, priority:220
msgid "The `refs/tags/*` namespace will accept any kind of object (as commits, trees and blobs can be tagged), and any updates to them will be rejected."
msgstr "`refs/tags/*` 命名空间将接受任何种类的对象（因为提交、树和二进制对象都可以被标记），对它们的任何更新都将被拒绝。"

#. type: Plain text
#: en/git-push.txt:113
#, priority:220
msgid "It's possible to push any type of object to any namespace outside of `refs/{tags,heads}/*`. In the case of tags and commits, these will be treated as if they were the commits inside `refs/heads/*` for the purposes of whether the update is allowed."
msgstr "可以将任何类型的对象推送到 `refs/{tags,heads}/*` 之外的任何命名空间。在标签和提交的情况下，这些将被视为 `refs/heads/*` 内的提交，以决定是否允许更新。"

#. type: Plain text
#: en/git-push.txt:122
#, priority:220
msgid "I.e. a fast-forward of commits and tags outside `refs/{tags,heads}/*` is allowed, even in cases where what's being fast-forwarded is not a commit, but a tag object which happens to point to a new commit which is a fast-forward of the commit the last tag (or commit) it's replacing. Replacing a tag with an entirely different tag is also allowed, if it points to the same commit, as well as pushing a peeled tag, i.e. pushing the commit that existing tag object points to, or a new tag object which an existing commit points to."
msgstr "也就是说，允许在 `refs/{tags,heads}/*` 之外进行快进提交和标签，即使被快进的不是一个提交，而是一个标签对象，它恰好指向一个新的提交，而这个提交是它所替代的最后一个标签（或提交）的快进。用一个完全不同的标签替换一个标签也是允许的，如果它指向同一个提交，以及推送一个剥离的标签，即推送现有标签对象所指向的提交，或现有提交所指向的新标签对象。"

#. type: Plain text
#: en/git-push.txt:126
#, priority:220
msgid "Tree and blob objects outside of `refs/{tags,heads}/*` will be treated the same way as if they were inside `refs/tags/*`, any update of them will be rejected."
msgstr "在 `refs/{tags,heads}/*` 之外的树和二进制对象的处理方式与在 `refs/tags/*` 之内的相同，它们的任何更新都会被拒绝。"

#. type: Plain text
#: en/git-push.txt:135
#, priority:220
msgid "All of the rules described above about what's not allowed as an update can be overridden by adding an the optional leading `+` to a refspec (or using `--force` command line option). The only exception to this is that no amount of forcing will make the `refs/heads/*` namespace accept a non-commit object. Hooks and configuration can also override or amend these rules, see e.g. `receive.denyNonFastForwards` in linkgit:git-config[1] and `pre-receive` and `update` in linkgit:githooks[5]."
msgstr "上面描述的所有关于不允许更新的规则都可以通过在引用规范前面添加一个可选 `+` 来覆盖（或者使用 `--force` 命令行选项）。唯一的例外是，无论如何强制都不会使 `refs/heads/*` 命名空间接受一个非提交对象。钩子和配置也可以覆盖或修改这些规则，例如见 linkgit:git-config[1] 中的 `receive.denyNonFastForwards` 和 linkgit:githooks[5] 中的 `pre-receive` 和 `update`。"

#. type: Plain text
#: en/git-push.txt:141
#, priority:220
msgid "Pushing an empty <src> allows you to delete the <dst> ref from the remote repository. Deletions are always accepted without a leading `+` in the refspec (or `--force`), except when forbidden by configuration or hooks. See `receive.denyDeletes` in linkgit:git-config[1] and `pre-receive` and `update` in linkgit:githooks[5]."
msgstr "推送一个空的 <src> 允许你从远程版本库中删除 <dst> 的引用。除非配置或钩子禁止，否则在引用规范中没有前面的 `+` (或 `--force`) ，删除总是被接受的。参见 linkgit:git-config[1] 中的 `receive.denyDeletes` 以及 linkgit:githooks[5] 中的 `pre-receive` 和 `update`。"

#. type: Plain text
#: en/git-push.txt:146
#, priority:220
msgid "The special refspec `:` (or `+:` to allow non-fast-forward updates)  directs Git to push \"matching\" branches: for every branch that exists on the local side, the remote side is updated if a branch of the same name already exists on the remote side."
msgstr "特殊的引用规范 `:`（或`+:`以允许非快进式更新）指示 Git 推送“匹配”的分支：对于每一个存在于本地的分支，如果远程仓库已经有一个同名的分支存在，则远程仓库会被更新。"

#. type: Plain text
#: en/git-push.txt:148
#, priority:220
msgid "`tag <tag>` means the same as `refs/tags/<tag>:refs/tags/<tag>`."
msgstr "`tag <tag>` 与 `refs/tags/<tag>:refs/tags/<tag>` 意思相同。"

#. type: Labeled list
#: en/git-push.txt:150
#, ignore-same, no-wrap, priority:220
msgid "--branches"
msgstr "--branches"

#. type: Plain text
#: en/git-push.txt:153
#, priority:220
msgid "Push all branches (i.e. refs under `refs/heads/`); cannot be used with other <refspec>."
msgstr "推送所有分支（即`refs/heads/`下的引用）；不能与其他 < 引用规范 > 一起使用。"

#. type: Plain text
#: en/git-push.txt:161
#, priority:220
msgid "Remove remote branches that don't have a local counterpart. For example a remote branch `tmp` will be removed if a local branch with the same name doesn't exist any more. This also respects refspecs, e.g.  `git push --prune remote refs/heads/*:refs/tmp/*` would make sure that remote `refs/tmp/foo` will be removed if `refs/heads/foo` doesn't exist."
msgstr "删除没有本地对应分支的远程分支。例如，如果本地的同名分支不存在了，那么远程分支 `tmp` 将被删除。这也是对引用规范的尊重，例如，`git push --prune remote refs/heads/*:refs/tmp/*` 将确保如果 `refs/heads/foo` 不存在，那么远程的 `refs/tmp/foo` 将被删除。"

#. type: Plain text
#: en/git-push.txt:172
#, priority:220
msgid "Instead of naming each ref to push, specifies that all refs under `refs/` (which includes but is not limited to `refs/heads/`, `refs/remotes/`, and `refs/tags/`)  be mirrored to the remote repository.  Newly created local refs will be pushed to the remote end, locally updated refs will be force updated on the remote end, and deleted refs will be removed from the remote end.  This is the default if the configuration option `remote.<remote>.mirror` is set."
msgstr "而不是命名每一个要推送的引用，指定`refs/`（包括但不限于`refs/heads/`、`refs/remotes/`和`refs/tags/`）下的所有引用都被镜像到远程仓库。  新创建的本地引用将被推送到远程端，本地更新的引用将被强制更新到远程端，而删除的引用将从远程仓库删除。  如果配置选项 `remote.<remote>.mirror`被设置，这就是默认的。"

#. type: Plain text
#: en/git-push.txt:181
#, priority:220
msgid "Produce machine-readable output.  The output status line for each ref will be tab-separated and sent to stdout instead of stderr.  The full symbolic names of the refs will be given."
msgstr "生成机器可读的输出。  每个引用的输出状态行将以制表符分隔，并发送至标准输出而不是标准报错。  将给出引用的完整符号名称。"

#. type: Plain text
#: en/git-push.txt:186
#, priority:220
msgid "All listed refs are deleted from the remote repository. This is the same as prefixing all refs with a colon."
msgstr "所有列出的引用都从远程仓库中删除。这与在所有引用前加冒号的做法相同。"

#. type: Plain text
#: en/git-push.txt:191
#, priority:220
msgid "All refs under `refs/tags` are pushed, in addition to refspecs explicitly listed on the command line."
msgstr "除了命令行上明确列出的引用规范之外，`refs/tags` 下的所有引用都被推送。"

#. type: Labeled list
#: en/git-push.txt:192
#, ignore-same, no-wrap, priority:220
msgid "--follow-tags"
msgstr "--follow-tags"

#. type: Plain text
#: en/git-push.txt:199
#, priority:220
msgid "Push all the refs that would be pushed without this option, and also push annotated tags in `refs/tags` that are missing from the remote but are pointing at commit-ish that are reachable from the refs being pushed.  This can also be specified with configuration variable `push.followTags`.  For more information, see `push.followTags` in linkgit:git-config[1]."
msgstr "推送所有在没有这个选项的情况下会被推送的引用，同时也推送 `refs/tags` 中的注释标签，这些标签在远程中缺失，但却指向被推送的引用中可以到达的提交号。  这也可以用配置变量 `push.followTags` 来指定。  更多信息，见 linkgit:git-config[1] 中的 `push.followTags`。"

#. type: Labeled list
#: en/git-push.txt:200 en/git-send-pack.txt:74
#, ignore-same, no-wrap, priority:220
msgid "--[no-]signed"
msgstr "--[no-]signed"

#. type: Labeled list
#: en/git-push.txt:201 en/git-send-pack.txt:75
#, fuzzy, no-wrap, priority:220
msgid "--signed=(true|false|if-asked)"
msgstr "--signed=(true|false|if-asked)"

#. type: Plain text
#: en/git-push.txt:210 en/git-send-pack.txt:84
#, priority:220
msgid "GPG-sign the push request to update refs on the receiving side, to allow it to be checked by the hooks and/or be logged.  If `false` or `--no-signed`, no signing will be attempted.  If `true` or `--signed`, the push will fail if the server does not support signed pushes.  If set to `if-asked`, sign if and only if the server supports signed pushes.  The push will also fail if the actual call to `gpg --sign` fails.  See linkgit:git-receive-pack[1] for the details on the receiving end."
msgstr "对推送请求进行 GPG 签名，以更新接收方的引用，使其能够被钩子检查和/或被记录下来。  如果指定 `false` 或 `--no-signed`，将不尝试签名。  如果指定 `true` 或 `--signed`，且服务器不支持签名推送，推送将失败。  如果设置为 `if-asked`，仅当服务器支持签名推送时才签名。  如果实际调用 `gpg --sign` 失败，推送也将失败。  关于接收端的细节，见 linkgit:git-receive-pack[1]。"

#. type: Labeled list
#: en/git-push.txt:211
#, ignore-same, no-wrap, priority:220
msgid "--[no-]atomic"
msgstr "--[no-]atomic"

#. type: Plain text
#: en/git-push.txt:215
#, priority:220
msgid "Use an atomic transaction on the remote side if available.  Either all refs are updated, or on error, no refs are updated.  If the server does not support atomic pushes the push will fail."
msgstr "如果有的话，在远程仓库使用一个原子事务。  要么所有的引用都被更新，要么出错时，没有引用被更新。  如果服务器不支持原子推送，推送将会失败。"

#. type: Labeled list
#: en/git-push.txt:217
#, fuzzy, no-wrap, priority:220
msgid "--push-option=<option>"
msgstr "--push-option=<option>"

#. type: Plain text
#: en/git-push.txt:227
#, priority:220
msgid "Transmit the given string to the server, which passes them to the pre-receive as well as the post-receive hook. The given string must not contain a NUL or LF character.  When multiple `--push-option=<option>` are given, they are all sent to the other side in the order listed on the command line.  When no `--push-option=<option>` is given from the command line, the values of configuration variable `push.pushOption` are used instead."
msgstr "将给定的字符串传输给服务器，服务器将它们传递给 pre-receive 以及 post-receive 钩子。给定的字符串不能包含 NUL 或 LF 字符。  当给出多个 `--push-option=< 选项 >` 时，它们将按照命令行中列出的顺序全部发送给对方。  当命令行中没有给出 `--push-option=< 选项 >` 时，将使用配置变量`push.pushOption` 的值来代替。"

#. type: Labeled list
#: en/git-push.txt:228 en/git-send-pack.txt:29
#, fuzzy, no-wrap, priority:220
msgid "--receive-pack=<git-receive-pack>"
msgstr "--receive-pack=<git-receive-pack>"

#. type: Labeled list
#: en/git-push.txt:229 en/git-send-pack.txt:35
#, fuzzy, no-wrap, priority:220
msgid "--exec=<git-receive-pack>"
msgstr "--exec=<git-receive-pack>"

#. type: Plain text
#: en/git-push.txt:234 en/git-send-pack.txt:34
#, priority:220
msgid "Path to the 'git-receive-pack' program on the remote end.  Sometimes useful when pushing to a remote repository over ssh, and you do not have the program in a directory on the default $PATH."
msgstr "到远端的 'git-receive-pack' 程序的路径。  当通过 ssh 推送到远程版本库，而你没有在默认的 $PATH 目录下的程序时，有时会很有用。"

#. type: Labeled list
#: en/git-push.txt:235
#, ignore-same, no-wrap, priority:220
msgid "--[no-]force-with-lease"
msgstr "--[no-]force-with-lease"

#. type: Labeled list
#: en/git-push.txt:236
#, fuzzy, no-wrap, priority:220
msgid "--force-with-lease=<refname>"
msgstr "--force-with-lease=<refname>"

#. type: Labeled list
#: en/git-push.txt:237
#, no-wrap, priority:220
msgid "--force-with-lease=<refname>:<expect>"
msgstr "--force-with-lease=< 引用名 >:< 期望>"

#. type: Plain text
#: en/git-push.txt:240
#, priority:220
msgid "Usually, \"git push\" refuses to update a remote ref that is not an ancestor of the local ref used to overwrite it."
msgstr "通常，\"git push\" 会拒绝更新一个不是用来覆盖它的本地引用的远程父引用。"

#. type: Plain text
#: en/git-push.txt:243
#, priority:220
msgid "This option overrides this restriction if the current value of the remote ref is the expected value.  \"git push\" fails otherwise."
msgstr "如果远程引用的当前值是预期值，该选项会覆盖这一限制。否则，\"git push\" 会失败。"

#. type: Plain text
#: en/git-push.txt:250
#, priority:220
msgid "Imagine that you have to rebase what you have already published.  You will have to bypass the \"must fast-forward\" rule in order to replace the history you originally published with the rebased history.  If somebody else built on top of your original history while you are rebasing, the tip of the branch at the remote may advance with their commit, and blindly pushing with `--force` will lose their work."
msgstr "想象一下，你必须对你已经发表的内容进行重新定位。  你必须绕过“必须快速合并”的规则，以便用重写的历史替换你最初发布的历史。  如果在你重新发布的时候，有其他人在你原来的历史之上构建，那么远程分支的顶端可能会随着他们的提交而前进，而盲目地用 `--force` 推送会丢失他们的改动。"

#. type: Plain text
#: en/git-push.txt:257
#, priority:220
msgid "This option allows you to say that you expect the history you are updating is what you rebased and want to replace. If the remote ref still points at the commit you specified, you can be sure that no other people did anything to the ref. It is like taking a \"lease\" on the ref without explicitly locking it, and the remote ref is updated only if the \"lease\" is still valid."
msgstr "这个选项允许你说，你希望你更新的历史是你重新建立的，并希望取代它。如果远程引用仍然指向你指定的提交，你就可以确定没有其他人对该引用做了什么。这就像在没有明确锁定的情况下对引用进行“租赁”，只有在 “租赁”仍然有效的情况下才会更新远程引用。"

#. type: Plain text
#: en/git-push.txt:262
#, priority:220
msgid "`--force-with-lease` alone, without specifying the details, will protect all remote refs that are going to be updated by requiring their current value to be the same as the remote-tracking branch we have for them."
msgstr "`--force-with-lease`，不指定细节，将保护所有将被更新的远程引用，要求它们的当前值与我们为它们准备的远程跟踪分支相同。"

#. type: Plain text
#: en/git-push.txt:267
#, priority:220
msgid "`--force-with-lease=<refname>`, without specifying the expected value, will protect the named ref (alone), if it is going to be updated, by requiring its current value to be the same as the remote-tracking branch we have for it."
msgstr "`--force-with-lease=< 引用名 >`，没有指定预期值，将保护命名的引用（单独），如果它要被更新，要求其当前值与我们对它的远程跟踪分支相同。"

#. type: Plain text
#: en/git-push.txt:275
#, priority:220
msgid "`--force-with-lease=<refname>:<expect>` will protect the named ref (alone), if it is going to be updated, by requiring its current value to be the same as the specified value `<expect>` (which is allowed to be different from the remote-tracking branch we have for the refname, or we do not even have to have such a remote-tracking branch when this form is used).  If `<expect>` is the empty string, then the named ref must not already exist."
msgstr "`--force-with-lease=< 引用名 >:< 期望 >`将保护指定的引用（单独），如果它要被更新，要求它的当前值与指定的值`< 期望 >`相同（允许与我们对引用名的远程跟踪分支不同，或者在使用这种形式时，我们甚至不需要有这样一个远程跟踪分支）。  如果`< 期望 >`是空字符串，那么命名的引用必须不存在。"

#. type: Plain text
#: en/git-push.txt:280
#, priority:220
msgid "Note that all forms other than `--force-with-lease=<refname>:<expect>` that specifies the expected current value of the ref explicitly are still experimental and their semantics may change as we gain experience with this feature."
msgstr "请注意，除了`--force-with-lease=< 引用名 >:< 期望 >`以外的所有形式都是明确指定引用的预期当前值，这些形式仍然是试验性的，它们的语义可能会随着我们对这个功能的经验积累而改变。"

#. type: Plain text
#: en/git-push.txt:283
#, priority:220
msgid "\"--no-force-with-lease\" will cancel all the previous --force-with-lease on the command line."
msgstr "\"--no-force-with-lease \" 将取消之前在命令行上所有的 --force-with-lease。"

#. type: Plain text
#: en/git-push.txt:289
#, priority:220
msgid "A general note on safety: supplying this option without an expected value, i.e. as `--force-with-lease` or `--force-with-lease=<refname>` interacts very badly with anything that implicitly runs `git fetch` on the remote to be pushed to in the background, e.g. `git fetch origin` on your repository in a cronjob."
msgstr "关于安全性的一般说明：在没有预期值的情况下提供这个选项，即 `--force-with-lease` 或`--force-with-lease=< 引用名 >`，会与任何在后台隐式运行 `git fetch` 的远端推送的进程产生非常不好的互动，例如仓库中 cronjob 的 `git fetch origin`。"

#. type: Plain text
#: en/git-push.txt:296
#, priority:220
msgid "The protection it offers over `--force` is ensuring that subsequent changes your work wasn't based on aren't clobbered, but this is trivially defeated if some background process is updating refs in the background. We don't have anything except the remote tracking info to go by as a heuristic for refs you're expected to have seen & are willing to clobber."
msgstr "与 `--force` 相比，它提供的保护是确保你的工作不基于后续的变化，但如果有后台进程在后台更新引用，这一点就很容易被破坏。除了远程跟踪信息外，我们没有任何你期望看到并愿意去破解可以作为启发式引用的东西。"

#. type: Plain text
#: en/git-push.txt:300
#, priority:220
msgid "If your editor or some other system is running `git fetch` in the background for you a way to mitigate this is to simply set up another remote:"
msgstr "如果你的编辑器或其他系统在后台为你运行`git fetch`，减轻这种情况的方法是简单地设置另一个远程："

#. type: Plain text
#: en/git-push.txt:303
#, no-wrap, priority:220
msgid ""
"\tgit remote add origin-push $(git config remote.origin.url)\n"
"\tgit fetch origin-push\n"
msgstr ""
"\tgit remote add origin-push $(git config remote.origin.url)\n"
"\tgit fetch origin-push\n"

#. type: Plain text
#: en/git-push.txt:306
#, priority:220
msgid "Now when the background process runs `git fetch origin` the references on `origin-push` won't be updated, and thus commands like:"
msgstr "现在，当后台进程运行 `git fetch origin` 时，`origin-push`上的引用将不会被更新，因此，像这样的命令："

#. type: Plain text
#: en/git-push.txt:308
#, fuzzy, no-wrap, priority:220
msgid "\tgit push --force-with-lease origin-push\n"
msgstr "\tgit push --force-with-lease origin-push\n"

#. type: Plain text
#: en/git-push.txt:313
#, priority:220
msgid "Will fail unless you manually run `git fetch origin-push`. This method is of course entirely defeated by something that runs `git fetch --all`, in that case you'd need to either disable it or do something more tedious like:"
msgstr "除非你手动运行 `git fetch origin-push`，否则会失败。当然，这种方法完全可以被运行 `git fetch --all` 的东西打败，在这种情况下，你需要禁用它或者做一些更繁琐的事情，比如："

#. type: Plain text
#: en/git-push.txt:318
#, no-wrap, priority:220
msgid ""
"\tgit fetch              # update 'master' from remote\n"
"\tgit tag base master    # mark our base point\n"
"\tgit rebase -i master   # rewrite some commits\n"
"\tgit push --force-with-lease=master:base master:master\n"
msgstr ""
"\tgit fetch              # 从远程仓库更新 'master' 分支\n"
"\tgit tag base master    # 标记基点\n"
"\tgit rebase -i master   # 重写某些提交\n"
"\tgit push --force-with-lease=master:base master:master\n"

#. type: Plain text
#: en/git-push.txt:324
#, priority:220
msgid "I.e. create a `base` tag for versions of the upstream code that you've seen and are willing to overwrite, then rewrite history, and finally force push changes to `master` if the remote version is still at `base`, regardless of what your local `remotes/origin/master` has been updated to in the background."
msgstr "也就是说，为你已经看到并愿意覆盖的上游仓库创建一个`base` 标签，然后重写历史，最后如果远程版本仍然在 `base`，则强制推送修改到`master`，不管你本地的 `remotes/origin/master` 在后台更新了什么。"

#. type: Plain text
#: en/git-push.txt:332
#, priority:220
msgid "Alternatively, specifying `--force-if-includes` as an ancillary option along with `--force-with-lease[=<refname>]` (i.e., without saying what exact commit the ref on the remote side must be pointing at, or which refs on the remote side are being protected) at the time of \"push\" will verify if updates from the remote-tracking refs that may have been implicitly updated in the background are integrated locally before allowing a forced update."
msgstr "另外，在“推送”时将 `--force-if-includes` 作为辅助选项与 `--force-with-lease[=< 引用名 >]` 一起指定（即不说远程的引用必须指向什么确切的提交，或远程的哪些引用被保护），将验证远程跟踪引用的更新是否在允许强制更新之前被整合在本地。"

#. type: Plain text
#: en/git-push.txt:340
#, priority:220
msgid "Usually, the command refuses to update a remote ref that is not an ancestor of the local ref used to overwrite it.  Also, when `--force-with-lease` option is used, the command refuses to update a remote ref whose current value does not match what is expected."
msgstr "通常情况下，命令会拒绝更新一个不属于用来覆盖它的本地引用祖先的远程引用。  另外，当使用 `--force-with-lease` 选项时，命令会拒绝更新一个当前值与预期不符的远程引用。"

#. type: Plain text
#: en/git-push.txt:343
#, priority:220
msgid "This flag disables these checks, and can cause the remote repository to lose commits; use it with care."
msgstr "这个标志禁用了这些检查，并可能导致远程版本库丢失提交，使用时要小心。"

#. type: Plain text
#: en/git-push.txt:352
#, ignore-ellipsis, priority:220
msgid "Note that `--force` applies to all the refs that are pushed, hence using it with `push.default` set to `matching` or with multiple push destinations configured with `remote.*.push` may overwrite refs other than the current branch (including local refs that are strictly behind their remote counterpart).  To force a push to only one branch, use a `+` in front of the refspec to push (e.g `git push origin +master` to force a push to the `master` branch). See the `<refspec>...` section above for details."
msgstr "注意，`--force` 适用于所有被推送的引用，因此在 `push.default` 设置为 `matching` 的情况下使用它，或者在 `remote.*.push` 配置了多个推送目的地的情况下，可能会覆盖当前分支以外的引用（包括严格落后于其远程对应的本地引用）。  要强制推送到一个分支，请在推送的引用规范前面使用 `+`（例如 `git push origin +master`，强制推送到 `master` 分支）。详情见上面的 `< 引用规范 >...` 部分。"

#. type: Labeled list
#: en/git-push.txt:353
#, ignore-same, no-wrap, priority:220
msgid "--[no-]force-if-includes"
msgstr "--[no-]force-if-includes"

#. type: Plain text
#: en/git-push.txt:356
#, priority:220
msgid "Force an update only if the tip of the remote-tracking ref has been integrated locally."
msgstr "只有远程跟踪的引用顶端被整合到本地才强制更新。"

#. type: Plain text
#: en/git-push.txt:362
#, priority:220
msgid "This option enables a check that verifies if the tip of the remote-tracking ref is reachable from one of the \"reflog\" entries of the local branch based in it for a rewrite. The check ensures that any updates from the remote have been incorporated locally by rejecting the forced update if that is not the case."
msgstr "这个选项启用了一个检查，以验证远程跟踪引用的顶端是否可以从本地分支的“引用日志”条目中到达，以便进行重写。该检查确保来自远程的任何更新都已纳入本地，如果不是这样，则拒绝强制更新。"

#. type: Plain text
#: en/git-push.txt:366
#, priority:220
msgid "If the option is passed without specifying `--force-with-lease`, or specified along with `--force-with-lease=<refname>:<expect>`, it is a \"no-op\"."
msgstr "如果该选项没有指定 `--force-with-lease`，或者与 `--force-with-lease=< 引用名 >:< 期望 >`一起指定，则是“无选项”的。"

#. type: Plain text
#: en/git-push.txt:368
#, priority:220
msgid "Specifying `--no-force-if-includes` disables this behavior."
msgstr "指定 `---no-force-if-includes` 就可以禁止这种行为。"

#. type: Labeled list
#: en/git-push.txt:369
#, fuzzy, no-wrap, priority:220
msgid "--repo=<repository>"
msgstr "--repo=<repository>"

#. type: Plain text
#: en/git-push.txt:372
#, priority:220
msgid "This option is equivalent to the <repository> argument. If both are specified, the command-line argument takes precedence."
msgstr "这个选项等同于 < 仓库 > 参数。如果两者都被指定，则以命令行参数为优先。"

#. type: Plain text
#: en/git-push.txt:379
#, priority:220
msgid "For every branch that is up to date or successfully pushed, add upstream (tracking) reference, used by argument-less linkgit:git-pull[1] and other commands. For more information, see `branch.<name>.merge` in linkgit:git-config[1]."
msgstr "对于每一个已经更新或成功推送的分支，添加上游（跟踪）引用，由无参数的 linkgit:git-pull[1] 和其他命令使用。更多信息，见 linkgit:git-config[1] 中的 `branch.< 分支名 >.merge`。"

#. type: Labeled list
#: en/git-push.txt:380
#, ignore-same, no-wrap, priority:220
msgid "--[no-]thin"
msgstr "--[no-]thin"

#. type: Plain text
#: en/git-push.txt:385
#, priority:220
msgid "These options are passed to linkgit:git-send-pack[1]. A thin transfer significantly reduces the amount of sent data when the sender and receiver share many of the same objects in common. The default is `--thin`."
msgstr "这些选项被传递给 linkgit:git-send-pack[1]。当发送方和接收方有许多共同的对象时，稀松传输会大大减少发送的数据量。默认是 `--thin`。"

#. type: Plain text
#: en/git-push.txt:391
#, priority:220
msgid "Suppress all output, including the listing of updated refs, unless an error occurs. Progress is not reported to the standard error stream."
msgstr "抑制所有的输出，包括更新的引用的列表，除非发生错误。进度不会报告给标准错误流。"

#. type: Labeled list
#: en/git-push.txt:403
#, fuzzy, no-wrap, priority:220
msgid "--recurse-submodules=check|on-demand|only|no"
msgstr "--recurse-submodules=check|on-demand|only|no"

#. type: Plain text
#: en/git-push.txt:417
#, priority:220
msgid "May be used to make sure all submodule commits used by the revisions to be pushed are available on a remote-tracking branch.  If 'check' is used Git will verify that all submodule commits that changed in the revisions to be pushed are available on at least one remote of the submodule. If any commits are missing the push will be aborted and exit with non-zero status. If 'on-demand' is used all submodules that changed in the revisions to be pushed will be pushed. If on-demand was not able to push all necessary revisions it will also be aborted and exit with non-zero status. If 'only' is used all submodules will be pushed while the superproject is left unpushed. A value of 'no' or using `--no-recurse-submodules` can be used to override the push.recurseSubmodules configuration variable when no submodule recursion is required."
msgstr "可以用来确保要推送的修订版所使用的所有子模块提交都在远程跟踪分支上可用。  如果使用 'check'，Git 将验证所有在要推送的修订版中发生变化的子模块提交是否在该子模块的至少一个远程上可用。如果缺少任何提交，推送将被中止并以非零状态退出。如果使用 'on-demand'，所有在要推送的修订版中发生变化的子模块都会被推送。如果 on-demand 不能推送所有必要的修订版，它也将被中止并以非零状态退出。如果使用 'only'，所有的子模块将被推送，父级项目则不被推送。当不需要子模块递归时，一个 \"no\" 的值或使用 `--no-recurse-submodules` 可以用来覆盖 push.recurseSubmodules 配置变量。"

#. type: Plain text
#: en/git-push.txt:421
#, priority:220
msgid "When using 'on-demand' or 'only', if a submodule has a \"push.recurseSubmodules={on-demand,only}\" or \"submodule.recurse\" configuration, further recursion will occur. In this case, \"only\" is treated as \"on-demand\"."
msgstr "当使用 \"on-demand\" 或 \"only\" 时，如果一个子模块有 \"push.recurseSubmodules={on-demand,only}\" 或 \"submodule.recurse\"配置，将发生进一步递归。在这种情况下，\"only\" 被视为 \"on-demand\"。"

#. type: Plain text
#: en/git-push.txt:426
#, priority:220
msgid "Toggle the pre-push hook (see linkgit:githooks[5]).  The default is --verify, giving the hook a chance to prevent the push.  With --no-verify, the hook is bypassed completely."
msgstr "切换 pre-push 钩子（见 linkgit:githooks[5]）。  默认是 --verify，给钩子一个机会来阻止推送。  如果使用 --no-verify，钩子会被完全绕过。"

#. type: Plain text
#: en/git-push.txt:443
#, fuzzy, priority:220
msgid "The output of \"git push\" depends on the transport method used; this section describes the output when pushing over the Git protocol (either locally or via ssh)."
msgstr "The output of \"git push\" depends on the transport method used; this section describes the output when pushing over the Git protocol (either locally or via ssh)."

#. type: Plain text
#: en/git-push.txt:446
#, priority:220
msgid "The status of the push is output in tabular form, with each line representing the status of a single ref. Each line is of the form:"
msgstr "推送的状态以表格的形式输出，每一行代表一个引用的状态。每一行的形式是："

#. type: delimited block -
#: en/git-push.txt:449
#, fuzzy, no-wrap, priority:220
msgid " <flag> <summary> <from> -> <to> (<reason>)\n"
msgstr " <flag> <summary> <from> -> <to> (<reason>)\n"

#. type: Plain text
#: en/git-push.txt:452
#, priority:220
msgid "If --porcelain is used, then each line of the output is of the form:"
msgstr "如果使用了 --porcelain ，那么输出的每一行都是这样的："

#. type: delimited block -
#: en/git-push.txt:455
#, fuzzy, no-wrap, priority:220
msgid " <flag> \\t <from>:<to> \\t <summary> (<reason>)\n"
msgstr " <flag> \\t <from>:<to> \\t <summary> (<reason>)\n"

#. type: Plain text
#: en/git-push.txt:459
#, priority:220
msgid "The status of up-to-date refs is shown only if --porcelain or --verbose option is used."
msgstr "只有在使用 --porcelain 或 --verbose 选项时，才会显示最新引用的状态。"

#. type: Plain text
#: en/git-push.txt:463
#, priority:220
msgid "for a successfully pushed fast-forward;"
msgstr "表示推送成功的快速合并；"

#. type: Plain text
#: en/git-push.txt:465
#, priority:220
msgid "for a successfully deleted ref;"
msgstr "表示一个成功删除的引用；"

#. type: Plain text
#: en/git-push.txt:466
#, priority:220
msgid "for a successfully pushed new ref;"
msgstr "表示成功推送的引用；"

#. type: Plain text
#: en/git-push.txt:467
#, priority:220
msgid "for a ref that was rejected or failed to push; and"
msgstr "表示一个被拒绝或推送失败的引用；并且"

#. type: Plain text
#: en/git-push.txt:468
#, priority:220
msgid "for a ref that was up to date and did not need pushing."
msgstr "表示一个最新的、不需要推送的引用。"

#. type: Plain text
#: en/git-push.txt:474
#, ignore-ellipsis, priority:220
msgid "For a successfully pushed ref, the summary shows the old and new values of the ref in a form suitable for using as an argument to `git log` (this is `<old>..<new>` in most cases, and `<old>...<new>` for forced non-fast-forward updates)."
msgstr "对于一个成功获取的引用，摘要以适合作为 `git log` 参数的形式显示该引用的新旧值（在大多数情况下是 `<旧>..<新>`，对于强制非快速合并是 `<旧>...<新>`）。"

#. type: Plain text
#: en/git-push.txt:476
#, priority:220
msgid "For a failed update, more details are given:"
msgstr "对于失败的更新，会给出更多的细节："

#. type: Labeled list
#: en/git-push.txt:478
#, fuzzy, no-wrap, priority:220
msgid "rejected"
msgstr "已拒绝"

#. type: Plain text
#: en/git-push.txt:481
#, priority:220
msgid "Git did not try to send the ref at all, typically because it is not a fast-forward and you did not force the update."
msgstr "Git 根本没有尝试发送引用，典型的原因是它不是快速合并并且你没有强制更新。"

#. type: Labeled list
#: en/git-push.txt:482
#, no-wrap, priority:220
msgid "remote rejected"
msgstr "远程拒绝"

#. type: Plain text
#: en/git-push.txt:490
#, priority:220
msgid "The remote end refused the update.  Usually caused by a hook on the remote side, or because the remote repository has one of the following safety options in effect: `receive.denyCurrentBranch` (for pushes to the checked out branch), `receive.denyNonFastForwards` (for forced non-fast-forward updates), `receive.denyDeletes` or `receive.denyDeleteCurrent`.  See linkgit:git-config[1]."
msgstr "远程仓库拒绝更新。  通常是由远程仓库的钩子引起的，或者是因为远程仓库有以下安全选项：`receive.denyCurrentBranch`（用于推送到已检出的分支），`receive.denyNonFastForwards`（用于强制非快进更新），`receive.denyDeletes` 或者 `receive.denyDeleteCurrent`。  见 linkgit:git-config[1]。"

#. type: Labeled list
#: en/git-push.txt:491
#, no-wrap, priority:220
msgid "remote failure"
msgstr "远程故障"

#. type: Plain text
#: en/git-push.txt:495
#, priority:220
msgid "The remote end did not report the successful update of the ref, perhaps because of a temporary error on the remote side, a break in the network connection, or other transient error."
msgstr "远程端没有报告引用的成功更新，可能是因为远程端的临时错误，网络连接中断，或其他瞬时错误。"

#. type: Plain text
#: en/git-push.txt:501
#, priority:220
msgid "The name of the local ref being pushed, minus its `refs/<type>/` prefix. In the case of deletion, the name of the local ref is omitted."
msgstr "被推送的本地引用的名称，减去其 `refs/< 类型 >/` 前缀。在删除的情况下，本地引用的名称被省略。"

#. type: Plain text
#: en/git-push.txt:505
#, priority:220
msgid "The name of the remote ref being updated, minus its `refs/<type>/` prefix."
msgstr "被更新的本地引用的名称，去掉其 `refs/< 类型 >/` 前缀。"

#. type: Plain text
#: en/git-push.txt:510
#, priority:220
msgid "A human-readable explanation. In the case of successfully pushed refs, no explanation is needed. For a failed ref, the reason for failure is described."
msgstr "一个人类可读的解释。在成功推送引用的情况下，不需要解释。对于操作失败的引用，要描述失败的原因。"

#. type: Title -
#: en/git-push.txt:512
#, no-wrap, priority:220
msgid "NOTE ABOUT FAST-FORWARDS"
msgstr "关于快速合并的说明"

#. type: Plain text
#: en/git-push.txt:517
#, priority:220
msgid "When an update changes a branch (or more in general, a ref) that used to point at commit A to point at another commit B, it is called a fast-forward update if and only if B is a descendant of A."
msgstr "当一个更新将原来指向提交 A 的分支（或更普遍的，一个引用）改为指向另一个提交 B 时，当且仅当 B 是 A 的后代时，它被称为快速合并。"

#. type: Plain text
#: en/git-push.txt:521
#, priority:220
msgid "In a fast-forward update from A to B, the set of commits that the original commit A built on top of is a subset of the commits the new commit B builds on top of.  Hence, it does not lose any history."
msgstr "在从 A 到 B 的快速合并中，原始提交 A 所建立的提交集是新提交 B 所建立的提交集的一个子集。  因此，它不会丢失任何历史。"

#. type: Plain text
#: en/git-push.txt:526
#, priority:220
msgid "In contrast, a non-fast-forward update will lose history.  For example, suppose you and somebody else started at the same commit X, and you built a history leading to commit B while the other person built a history leading to commit A.  The history looks like this:"
msgstr "相反，非快速合并更新会丢失历史。  例如，假设你和别人从同一个提交 X 开始，你建立了一个通往提交 B 的历史，而另一个人建立了一个通往提交 A 的历史。  这段历史看起来像这样："

#. type: delimited block -
#: en/git-push.txt:532
#, no-wrap, priority:220
msgid ""
"      B\n"
"     /\n"
" ---X---A\n"
msgstr ""
"      B\n"
"     /\n"
" ---X---A\n"

#. type: Plain text
#: en/git-push.txt:538
#, priority:220
msgid "Further suppose that the other person already pushed changes leading to A back to the original repository from which you two obtained the original commit X."
msgstr "进一步假设对方已经将 A 导致的修改推送回原仓库，你们俩从原仓库中获得原始提交 X。"

#. type: Plain text
#: en/git-push.txt:541
#, priority:220
msgid "The push done by the other person updated the branch that used to point at commit X to point at commit A.  It is a fast-forward."
msgstr "另一个人所做的推送，将原来指向提交 X 的分支更新为指向提交 A 的分支。"

#. type: Plain text
#: en/git-push.txt:546
#, priority:220
msgid "But if you try to push, you will attempt to update the branch (that now points at A) with commit B.  This does _not_ fast-forward.  If you did so, the changes introduced by commit A will be lost, because everybody will now start building on top of B."
msgstr "但如果你试图推送，你会试图用提交 B 来更新分支（现在指向 A）。这不是快速合并。  如果你这样做了，提交 A 引入的修改就会丢失，因为大家现在都会在 B 的基础上开始构建。"

#. type: Plain text
#: en/git-push.txt:549
#, priority:220
msgid "The command by default does not allow an update that is not a fast-forward to prevent such loss of history."
msgstr "该命令默认不允许非快速合并的更新，以防止这种历史的损失。"

#. type: Plain text
#: en/git-push.txt:554
#, priority:220
msgid "If you do not want to lose your work (history from X to B) or the work by the other person (history from X to A), you would need to first fetch the history from the repository, create a history that contains changes done by both parties, and push the result back."
msgstr "如果你不想丢失你的工作（从 X 到 B 的历史）或对方的工作（从 X 到 A 的历史），你需要先从仓库中获取历史，创建一个包含双方修改的历史，并将结果推送回去。"

#. type: Plain text
#: en/git-push.txt:558
#, priority:220
msgid "You can perform \"git pull\", resolve potential conflicts, and \"git push\" the result.  A \"git pull\" will create a merge commit C between commits A and B."
msgstr "您可以执行 \"git pull\"，解决潜在的冲突，然后将结果 \"git push\"。  一个 \"git pull \"会在提交 A 和 B 之间创建一个合并提交 C。"

#. type: delimited block -
#: en/git-push.txt:564
#, no-wrap, priority:220
msgid ""
"      B---C\n"
"     /   /\n"
" ---X---A\n"
msgstr ""
"      B---C\n"
"     /   /\n"
" ---X---A\n"

#. type: Plain text
#: en/git-push.txt:569
#, priority:220
msgid "Updating A with the resulting merge commit will fast-forward and your push will be accepted."
msgstr "用所产生的合并提交更新 A，将快速合并，你的推送将被接受。"

#. type: Plain text
#: en/git-push.txt:574
#, priority:220
msgid "Alternatively, you can rebase your change between X and B on top of A, with \"git pull --rebase\", and push the result back.  The rebase will create a new commit D that builds the change between X and B on top of A."
msgstr "另外，你也可以用 \"git pull --rebase\" 将 X 和 B 之间的改动重新归档到 A 之上，然后将结果推送回来。  重置将创建一个新的提交 D，将 X 和 B 之间的修改建立在 A 的基础上。"

#. type: delimited block -
#: en/git-push.txt:580
#, no-wrap, priority:220
msgid ""
"      B   D\n"
"     /   /\n"
" ---X---A\n"
msgstr ""
"      B   D\n"
"     /   /\n"
" ---X---A\n"

#. type: Plain text
#: en/git-push.txt:585
#, priority:220
msgid "Again, updating A with this commit will fast-forward and your push will be accepted."
msgstr "同样的，用这个提交更新 A 会快速合并，你的推送会被接受。"

#. type: Plain text
#: en/git-push.txt:596
#, priority:220
msgid "There is another common situation where you may encounter non-fast-forward rejection when you try to push, and it is possible even when you are pushing into a repository nobody else pushes into. After you push commit A yourself (in the first picture in this section), replace it with \"git commit --amend\" to produce commit B, and you try to push it out, because forgot that you have pushed A out already. In such a case, and only if you are certain that nobody in the meantime fetched your earlier commit A (and started building on top of it), you can run \"git push --force\" to overwrite it. In other words, \"git push --force\" is a method reserved for a case where you do mean to lose history."
msgstr "还有一种常见的情况是，当你试图推送时，可能会遇到非快速合并拒绝，即使你推送到一个没有人推送的版本库中也有可能。在你自己推送了提交 A（在本节的第一幅图中），用 \"git commit --amend\" 替换后产生了提交 B，你试图推送它，因为忘记了你已经推送了 A。在这种情况下，只有当您确定在此期间没有人取走您先前的提交 A（并在其基础上开始构建），您才能运行 \"git push --force\" 来覆盖它。换句话说，\"git push --force\" 是一种保留给你确实想失去历史的情况的方法。"

#. type: Labeled list
#: en/git-push.txt:601
#, fuzzy, no-wrap, priority:220
msgid "`git push`"
msgstr "`git push`"

#. type: Plain text
#: en/git-push.txt:605
#, priority:220
msgid "Works like `git push <remote>`, where <remote> is the current branch's remote (or `origin`, if no remote is configured for the current branch)."
msgstr "像`git push < 远端 >`那样工作，其中 < 远端 > 是当前分支的远程仓库（或者`origin`，如果没有为当前分支配置远程仓库）。"

#. type: Labeled list
#: en/git-push.txt:606
#, fuzzy, no-wrap, priority:220
msgid "`git push origin`"
msgstr "`git push origin`"

#. type: Plain text
#: en/git-push.txt:611
#, priority:220
msgid "Without additional configuration, pushes the current branch to the configured upstream (`branch.<name>.merge` configuration variable) if it has the same name as the current branch, and errors out without pushing otherwise."
msgstr "不需要额外配置，如果它与当前分支同名，并且错误输出而不推送其他分支，则将其推送到配置过的上游仓库（`branch.<分支名>.merge` 配置变量）。"

#. type: Plain text
#: en/git-push.txt:615
#, priority:220
msgid "The default behavior of this command when no <refspec> is given can be configured by setting the `push` option of the remote, or the `push.default` configuration variable."
msgstr "当没有给出< 引用规范 >时，该命令的默认行为可以通过设置远程仓库的 `push` 选项或 `push.default`配置变量来配置。"

#. type: Plain text
#: en/git-push.txt:620
#, priority:220
msgid "For example, to default to pushing only the current branch to `origin` use `git config remote.origin.push HEAD`.  Any valid <refspec> (like the ones in the examples below) can be configured as the default for `git push origin`."
msgstr "例如，要默认只将当前分支推送到 `origin`，使用 `git config remote.origin.push HEAD`。  任何有效的< 引用规范 >（比如下面例子中的那些）都可以被配置为 `git push origin` 的默认值。"

#. type: Labeled list
#: en/git-push.txt:621
#, fuzzy, no-wrap, priority:220
msgid "`git push origin :`"
msgstr "`git push origin :`"

#. type: Plain text
#: en/git-push.txt:625
#, priority:220
msgid "Push \"matching\" branches to `origin`. See <refspec> in the <<OPTIONS,OPTIONS>> section above for a description of \"matching\" branches."
msgstr "将 “匹配” 的分支推送到 `origin`。关于 “匹配” 分支的描述，请参见上面 <<选项,OPTIONS>> 部分的 <<引用规范>>。"

#. type: Labeled list
#: en/git-push.txt:626
#, no-wrap, priority:220
msgid "`git push origin master`"
msgstr "`git push origin master`"

#. type: Plain text
#: en/git-push.txt:632
#, priority:220
msgid "Find a ref that matches `master` in the source repository (most likely, it would find `refs/heads/master`), and update the same ref (e.g. `refs/heads/master`) in `origin` repository with it.  If `master` did not exist remotely, it would be created."
msgstr "在源仓库中找到一个与 `master` 相匹配的引用（最可能的是找到 `refs/heads/master`），并在 `origin` 仓库中用它更新相同的引用（例如`refs/heads/master`）。  如果 `master` 不存在，它将被创建。"

#. type: Labeled list
#: en/git-push.txt:633
#, fuzzy, no-wrap, priority:220
msgid "`git push origin HEAD`"
msgstr "`git push origin HEAD`"

#. type: Plain text
#: en/git-push.txt:636
#, priority:220
msgid "A handy way to push the current branch to the same name on the remote."
msgstr "一个方便的方法是将当前分支推送到远程的相同名称。"

#. type: Labeled list
#: en/git-push.txt:637
#, fuzzy, no-wrap, priority:220
msgid "`git push mothership master:satellite/master dev:satellite/dev`"
msgstr "`git push mothership master:satellite/master dev:satellite/dev`"

#. type: Plain text
#: en/git-push.txt:642
#, priority:220
msgid "Use the source ref that matches `master` (e.g. `refs/heads/master`)  to update the ref that matches `satellite/master` (most probably `refs/remotes/satellite/master`) in the `mothership` repository; do the same for `dev` and `satellite/dev`."
msgstr "使用与 \"master\" 相匹配的源引用（例如，`refs/heads/master`）来更新 `mothership` 仓库中与 `satellite/master` 相匹配的引用（很可能是 `refs/remotes/satellite/master`）；对 `dev` 和 `satellite/dev`做同样的操作。"

#. type: Plain text
#: en/git-push.txt:645
#, ignore-ellipsis, priority:220
msgid "See the section describing `<refspec>...` above for a discussion of the matching semantics."
msgstr "关于匹配语义的讨论，请参见上面描述 `<引用规范>...` 的部分。"

#. type: Plain text
#: en/git-push.txt:652
#, priority:220
msgid "This is to emulate `git fetch` run on the `mothership` using `git push` that is run in the opposite direction in order to integrate the work done on `satellite`, and is often necessary when you can only make connection in one way (i.e. satellite can ssh into mothership but mothership cannot initiate connection to satellite because the latter is behind a firewall or does not run sshd)."
msgstr "这是为了模拟在`母舰` 上运行的 `git fetch` ，使用 `git push` 以相反的方向运行，以便整合 `卫星` 上完成的工作，当你只能以一种方式进行连接时（即卫星可以ssh到母舰，但母舰不能启动与卫星的连接，因为后者在防火墙后面或不运行 sshd），这往往是必要的。"

#. type: Plain text
#: en/git-push.txt:657
#, priority:220
msgid "After running this `git push` on the `satellite` machine, you would ssh into the `mothership` and run `git merge` there to complete the emulation of `git pull` that were run on `mothership` to pull changes made on `satellite`."
msgstr "在 `卫星` 机器上运行这个 `git push` 后，你将 ssh 进入 `母舰` 并在那里运行 `git merge` ，以完成对 `母舰` 上运行的 `git pull` 的模拟，以拉取 `卫星` 上的修改。"

#. type: Labeled list
#: en/git-push.txt:658
#, fuzzy, no-wrap, priority:220
msgid "`git push origin HEAD:master`"
msgstr "`git push origin HEAD:master`"

#. type: Plain text
#: en/git-push.txt:662
#, priority:220
msgid "Push the current branch to the remote ref matching `master` in the `origin` repository. This form is convenient to push the current branch without thinking about its local name."
msgstr "推送当前分支到远程引用匹配 `master` 的 `origin` 仓库中。这种形式可以方便地推送当前分支，而不必考虑其本地名称。"

#. type: Labeled list
#: en/git-push.txt:663
#, fuzzy, no-wrap, priority:220
msgid "`git push origin master:refs/heads/experimental`"
msgstr "`git push origin master:refs/heads/experimental`"

#. type: Plain text
#: en/git-push.txt:669
#, priority:220
msgid "Create the branch `experimental` in the `origin` repository by copying the current `master` branch.  This form is only needed to create a new branch or tag in the remote repository when the local name and the remote name are different; otherwise, the ref name on its own will work."
msgstr "通过复制当前的 `master` 分支，在 `origin` 仓库创建 `experimental` 分支。  只有在本地名称和远程名称不同的情况下，在远程仓库中创建新的分支或标签时才需要这个表单；否则，参考名称本身就可以了。"

#. type: Labeled list
#: en/git-push.txt:670
#, no-wrap, priority:220
msgid "`git push origin :experimental`"
msgstr "`git push origin :experimental`"

#. type: Plain text
#: en/git-push.txt:673
#, priority:220
msgid "Find a ref that matches `experimental` in the `origin` repository (e.g. `refs/heads/experimental`), and delete it."
msgstr "在 `origin` 仓库（例如`refs/heads/experimental`）中找到一个与 `experimental` 相匹配的引用，并将其删除。"

#. type: Labeled list
#: en/git-push.txt:674
#, fuzzy, no-wrap, priority:220
msgid "`git push origin +dev:master`"
msgstr "`git push origin +dev:master`"

#. type: Plain text
#: en/git-push.txt:679
#, priority:220
msgid "Update the origin repository's master branch with the dev branch, allowing non-fast-forward updates.  *This can leave unreferenced commits dangling in the origin repository.* Consider the following situation, where a fast-forward is not possible:"
msgstr "用开发分支更新仓库的主分支，允许非快速合并更新。  *这可能会使未引用的提交在源码库中悬空。*考虑以下情况，即不可能进行快速合并："

#. type: delimited block -
#: en/git-push.txt:684
#, fuzzy, no-wrap, priority:220
msgid ""
"\t    o---o---o---A---B  origin/master\n"
"\t\t     \\\n"
"\t\t      X---Y---Z  dev\n"
msgstr ""
"\t    o---o---o---A---B  origin/master\n"
"\t\t     \\\n"
"\t\t      X---Y---Z  dev\n"

#. type: Plain text
#: en/git-push.txt:687
#, priority:220
msgid "The above command would change the origin repository to"
msgstr "上面的命令将 origin 仓库更改为"

#. type: delimited block -
#: en/git-push.txt:692
#, no-wrap, priority:220
msgid ""
"\t\t      A---B  (unnamed branch)\n"
"\t\t     /\n"
"\t    o---o---o---X---Y---Z  master\n"
msgstr ""
"\t\t      A---B  (unnamed branch)\n"
"\t\t     /\n"
"\t    o---o---o---X---Y---Z  master\n"

#. type: Plain text
#: en/git-push.txt:697
#, priority:220
msgid "Commits A and B would no longer belong to a branch with a symbolic name, and so would be unreachable.  As such, these commits would be removed by a `git gc` command on the origin repository."
msgstr "提交 A 和 B 将不再属于具有符号名称的分支，因此将不可访问。因此，这些提交将被原始存储库上的“ gitgc”命令删除。"

#. type: Title =
#: en/git-quiltimport.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-quiltimport(1)"
msgstr "git-quiltimport(1)"

#. type: Plain text
#: en/git-quiltimport.txt:7
#, priority:100
msgid "git-quiltimport - Applies a quilt patchset onto the current branch"
msgstr "git-quiltimport - 在当前分支上应用被子补丁集"

#. type: Plain text
#: en/git-quiltimport.txt:14
#, fuzzy, no-wrap, priority:100
msgid ""
"'git quiltimport' [--dry-run | -n] [--author <author>] [--patches <dir>]\n"
"\t\t[--series <file>] [--keep-non-patch]\n"
msgstr ""
"'git quiltimport' [--dry-run | -n] [--author <author>] [--patches <dir>]\n"
"\t\t[--series <file>] [--keep-non-patch]\n"

#. type: Plain text
#: en/git-quiltimport.txt:21
#, priority:100
msgid "Applies a quilt patchset onto the current Git branch, preserving the patch boundaries, patch order, and patch descriptions present in the quilt patchset."
msgstr "在当前 Git 分支上应用拼接补丁集，保留拼接补丁集中的补丁边界、补丁顺序和补丁描述。"

#. type: Plain text
#: en/git-quiltimport.txt:27
#, priority:100
msgid "For each patch the code attempts to extract the author from the patch description.  If that fails it falls back to the author specified with --author.  If the --author flag was not given the patch description is displayed and the user is asked to interactively enter the author of the patch."
msgstr "对于每个补丁，代码会尝试从补丁描述中提取作者。 如果失败，则返回到用 --author 指定的作者。 如果没有给定 --author 标志，则显示补丁描述，并要求用户交互式输入补丁的作者。"

#. type: Plain text
#: en/git-quiltimport.txt:30
#, priority:100
msgid "If a subject is not found in the patch description the patch name is preserved as the 1 line subject in the Git description."
msgstr "如果在补丁描述中找不到主题，补丁名称将保留为 Git 描述中的一行主题。"

#. type: Plain text
#: en/git-quiltimport.txt:40
#, priority:100
msgid "Walk through the patches in the series and warn if we cannot find all of the necessary information to commit a patch.  At the time of this writing only missing author information is warned about."
msgstr "浏览系列补丁，并在无法找到提交补丁所需的全部信息时发出警告。 在写这篇文章的时候，只有缺少作者信息的补丁才会被警告。"

#. type: Labeled list
#: en/git-quiltimport.txt:41
#, fuzzy, no-wrap, priority:100
msgid "--author Author Name <Author Email>"
msgstr "--author Author Name <Author Email>"

#. type: Plain text
#: en/git-quiltimport.txt:44
#, priority:100
msgid "The author name and email address to use when no author information can be found in the patch description."
msgstr "在补丁说明中找不到作者信息时使用的作者姓名和电子邮件地址。"

#. type: Labeled list
#: en/git-quiltimport.txt:45
#, fuzzy, no-wrap, priority:100
msgid "--patches <dir>"
msgstr "--patches <dir>"

#. type: Plain text
#: en/git-quiltimport.txt:47
#, priority:100
msgid "The directory to find the quilt patches."
msgstr "查找被子补丁的目录。"

#. type: Plain text
#: en/git-quiltimport.txt:51
#, priority:100
msgid "The default for the patch directory is patches or the value of the `$QUILT_PATCHES` environment variable."
msgstr "补丁目录的默认值是 patches 或 `$QUILT_PATCHES` 环境变量的值。"

#. type: Labeled list
#: en/git-quiltimport.txt:52
#, fuzzy, no-wrap, priority:100
msgid "--series <file>"
msgstr "--series <file>"

#. type: Plain text
#: en/git-quiltimport.txt:54
#, priority:100
msgid "The quilt series file."
msgstr "被子系列文件。"

#. type: Plain text
#: en/git-quiltimport.txt:58
#, priority:100
msgid "The default for the series file is <patches>/series or the value of the `$QUILT_SERIES` environment variable."
msgstr "系列文件的默认值是 <patches>/series 或 `$QUILT_SERIES` 环境变量的值。"

#. type: Title =
#: en/git-range-diff.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-range-diff(1)"
msgstr "git-range-diff(1)"

#. type: Plain text
#: en/git-range-diff.txt:7
#, priority:100
msgid "git-range-diff - Compare two commit ranges (e.g. two versions of a branch)"
msgstr "git-range-diff - 比较两个提交范围（例如一个分支的两个版本）"

#. type: Plain text
#: en/git-range-diff.txt:16
#, ignore-ellipsis, no-wrap, priority:100
msgid ""
"'git range-diff' [--color=[<when>]] [--no-color] [<diff-options>]\n"
"\t[--no-dual-color] [--creation-factor=<factor>]\n"
"\t[--left-only | --right-only]\n"
"\t( <range1> <range2> | <rev1>...<rev2> | <base> <rev1> <rev2> )\n"
"\t[[--] <path>...]\n"
msgstr ""
"'git range-diff' [--color=[<when>]] [--no-color] [<diff-options>]\n"
"\t[--no-dual-color] [--creation-factor=<factor>]\n"
"\t[--left-only | --right-only]\n"
"\t( <range1> <range2> | <rev1>...<rev2> | <base> <rev1> <rev2> )\n"
"\t[[--] <path>...]\n"

#. type: Plain text
#: en/git-range-diff.txt:22
#, priority:100
msgid "This command shows the differences between two versions of a patch series, or more generally, two commit ranges (ignoring merge commits)."
msgstr "该命令显示补丁系列的两个版本之间的差异，或者更笼统地说，两个提交范围之间的差异（忽略合并提交）。"

#. type: Plain text
#: en/git-range-diff.txt:25
#, priority:100
msgid "In the presence of `<path>` arguments, these commit ranges are limited accordingly."
msgstr "如果存在 `<path>` 参数，这些提交范围将受到相应的限制。"

#. type: Plain text
#: en/git-range-diff.txt:31
#, priority:100
msgid "To that end, it first finds pairs of commits from both commit ranges that correspond with each other. Two commits are said to correspond when the diff between their patches (i.e. the author information, the commit message and the commit diff) is reasonably small compared to the patches' size. See ``Algorithm`` below for details."
msgstr "为此，它首先从两个提交范围中找到相互对应的提交对。当两个补丁之间的差值（即作者信息、提交信息和提交差值）相对于补丁的大小相当小时，这两个提交就被认为是对应的。详见下面的 ``算法``。"

#. type: Plain text
#: en/git-range-diff.txt:35
#, priority:100
msgid "Finally, the list of matching commits is shown in the order of the second commit range, with unmatched commits being inserted just after all of their ancestors have been shown."
msgstr "最后，匹配的提交列表会按照第二个提交范围的顺序显示，未匹配的提交会在其所有祖先提交显示之后插入。"

#. type: Plain text
#: en/git-range-diff.txt:37
#, priority:100
msgid "There are three ways to specify the commit ranges:"
msgstr "指定提交范围有三种方法 :"

#. type: Plain text
#: en/git-range-diff.txt:41
#, priority:100
msgid "`<range1> <range2>`: Either commit range can be of the form `<base>..<rev>`, `<rev>^!` or `<rev>^-<n>`. See `SPECIFYING RANGES` in linkgit:gitrevisions[7] for more details."
msgstr "`<range1> <range2>`： 提交范围可以是 `<base>...<rev>`、`<rev>^!` 或 `<rev>^-<n>`。详见 linkgit:gitrevisions[7] 中的 `指定范围`。"

#. type: Plain text
#: en/git-range-diff.txt:44
#, ignore-ellipsis, priority:100
msgid "`<rev1>...<rev2>`. This is equivalent to `<rev2>..<rev1> <rev1>..<rev2>`."
msgstr "`<rev1>...<rev2>`。这等同于 `<rev2>...<rev1> <rev1>...<rev2>`."

#. type: Plain text
#: en/git-range-diff.txt:47
#, priority:100
msgid "`<base> <rev1> <rev2>`: This is equivalent to `<base>..<rev1> <base>..<rev2>`."
msgstr "`<base> <rev1> <rev2>`： 等同于 `<base>..<rev1> <base>..<rev2>`."

#. type: Labeled list
#: en/git-range-diff.txt:50
#, ignore-same, no-wrap, priority:100
msgid "--no-dual-color"
msgstr "--no-dual-color"

#. type: Plain text
#: en/git-range-diff.txt:55
#, priority:100
msgid "When the commit diffs differ, `git range-diff` recreates the original diffs' coloring, and adds outer -/+ diff markers with the *background* being red/green to make it easier to see e.g.  when there was a change in what exact lines were added."
msgstr "当提交的差异不同时，`git range-diff`会重现原始差异的颜色，并添加外层的 -/+ 差异标记，*背景* 为红/绿色，以便于查看，例如，当具体添加了哪些行时。"

#. type: Plain text
#: en/git-range-diff.txt:63
#, priority:100
msgid "Additionally, the commit diff lines that are only present in the first commit range are shown \"dimmed\" (this can be overridden using the `color.diff.<slot>` config setting where `<slot>` is one of `contextDimmed`, `oldDimmed` and `newDimmed`), and the commit diff lines that are only present in the second commit range are shown in bold (which can be overridden using the config settings `color.diff.<slot>` with `<slot>` being one of `contextBold`, `oldBold` or `newBold`)."
msgstr "此外，只出现在第一个提交范围内的提交差异行会显示为 \"dimmed\"（这可以使用 `color.diff. <slot>` 配置设置，其中 `<slot>` 是`contextDimmed`、`oldDimmed` 和 `newDimmed` 中的一个），而仅出现在第二个提交范围内的提交差异行以粗体显示（这可以通过配置设置 `color.diff.<slot>` 来覆盖，其中 `<slot>` 是 `contextBold`、`oldBold` 和 `newBold` 中的一个）。"

#. type: Plain text
#: en/git-range-diff.txt:67
#, priority:100
msgid "This is known to `range-diff` as \"dual coloring\". Use `--no-dual-color` to revert to color all lines according to the outer diff markers (and completely ignore the inner diff when it comes to color)."
msgstr "这在 `range-diff` 中被称为 \"双重着色\"。使用 `--no-dual-color` 可以还原为根据外部差异标记对所有线条着色（在着色时完全忽略内部差异）。"

#. type: Plain text
#: en/git-range-diff.txt:75
#, priority:100
msgid "Set the creation/deletion cost fudge factor to `<percent>`.  Defaults to 60. Try a larger value if `git range-diff` erroneously considers a large change a total rewrite (deletion of one commit and addition of another), and a smaller one in the reverse case.  See the ``Algorithm`` section below for an explanation why this is needed."
msgstr "将创建/删除成本误差因子设置为 `<percent>`。 默认为 60。如果 `git range-diff` 错误地认为一个大的改动是完全重写 (删除一个提交，增加另一个提交)，可以使用较大的值，反之则使用较小的值。 请参阅下面的 ``算法`` 部分以了解为什么需要这个值。"

#. type: Labeled list
#: en/git-range-diff.txt:76 en/rev-list-options.txt:283
#, ignore-same, no-wrap, priority:260
msgid "--left-only"
msgstr "--left-only"

#. type: Plain text
#: en/git-range-diff.txt:79
#, ignore-ellipsis, priority:100
msgid "Suppress commits that are missing from the first specified range (or the \"left range\" when using the `<rev1>...<rev2>` format)."
msgstr "忽略第一个指定范围（或使用 `<rev1>...<rev2>` 格式时的 \"左侧范围\"）中丢失的提交。"

#. type: Labeled list
#: en/git-range-diff.txt:80 en/rev-list-options.txt:284
#, ignore-same, no-wrap, priority:260
msgid "--right-only"
msgstr "--right-only"

#. type: Plain text
#: en/git-range-diff.txt:83
#, ignore-ellipsis, priority:100
msgid "Suppress commits that are missing from the second specified range (or the \"right range\" when using the `<rev1>...<rev2>` format)."
msgstr "忽略第二个指定范围（或使用 `<rev1>...<rev2>` 格式时的 \"右侧范围\"）中丢失的提交。"

#. type: Labeled list
#: en/git-range-diff.txt:84
#, fuzzy, no-wrap, priority:100
msgid "--[no-]notes[=<ref>]"
msgstr "--notes[=<ref>]"

#. type: Plain text
#: en/git-range-diff.txt:87
#, priority:100
msgid "This flag is passed to the `git log` program (see linkgit:git-log[1]) that generates the patches."
msgstr "这个标志将传递给生成补丁的 `git log` 程序（参见 linkgit:git-log[1]）。"

#. type: Labeled list
#: en/git-range-diff.txt:88
#, no-wrap, priority:100
msgid "<range1> <range2>"
msgstr "<range1> <range2>"

#. type: Plain text
#: en/git-range-diff.txt:91
#, priority:100
msgid "Compare the commits specified by the two ranges, where `<range1>` is considered an older version of `<range2>`."
msgstr "比较两个范围指定的提交，其中 `<range1>` 被认为是 `<range2>` 的旧版本。"

#. type: Labeled list
#: en/git-range-diff.txt:92
#, fuzzy, ignore-ellipsis, no-wrap, priority:100
msgid "<rev1>...<rev2>"
msgstr "'<rev1>..<rev2>'"

#. type: Plain text
#: en/git-range-diff.txt:94
#, priority:100
msgid "Equivalent to passing `<rev2>..<rev1>` and `<rev1>..<rev2>`."
msgstr "相当于传递 `<rev2>...<rev1>` 和 `<rev1>...<rev2>`。"

#. type: Labeled list
#: en/git-range-diff.txt:95
#, fuzzy, no-wrap, priority:100
msgid "<base> <rev1> <rev2>"
msgstr "'<rev1>..<rev2>'"

#. type: Plain text
#: en/git-range-diff.txt:101
#, priority:100
msgid "Equivalent to passing `<base>..<rev1>` and `<base>..<rev2>`.  Note that `<base>` does not need to be the exact branch point of the branches. Example: after rebasing a branch `my-topic`, `git range-diff my-topic@{u} my-topic@{1} my-topic` would show the differences introduced by the rebase."
msgstr "等同于传递 `<base>...<rev1>` 和 `<base>...<rev2>`。 注意 `<base>` 不需要是分支的确切分支点。例如： 在重定向分支 `my-topic` 之后， `git range-diff my-topic@{u} my-topic@{1} my-topic` 将显示重定向带来的差异。"

#. type: Plain text
#: en/git-range-diff.txt:108
#, priority:100
msgid "`git range-diff` also accepts the regular diff options (see linkgit:git-diff[1]), most notably the `--color=[<when>]` and `--no-color` options. These options are used when generating the \"diff between patches\", i.e. to compare the author, commit message and diff of corresponding old/new commits. There is currently no means to tweak most of the diff options passed to `git log` when generating those patches."
msgstr "`git range-diff` 也接受常规的 diff 选项 (参见 linkgit:git-diff[1])，特别是 `--color=[<when>]` 和 `--no-color` 选项。这些选项用于生成 “补丁间的差异”，即比较新旧提交的作者、提交信息和差异。目前还没有办法调整生成补丁时传递给 `git log` 的大部分 diff 选项。"

#. type: Title -
#: en/git-range-diff.txt:110
#, no-wrap, priority:100
msgid "OUTPUT STABILITY"
msgstr "输出稳定性"

#. type: Plain text
#: en/git-range-diff.txt:119
#, priority:100
msgid "The output of the `range-diff` command is subject to change. It is intended to be human-readable porcelain output, not something that can be used across versions of Git to get a textually stable `range-diff` (as opposed to something like the `--stable` option to linkgit:git-patch-id[1]). There's also no equivalent of linkgit:git-apply[1] for `range-diff`, the output is not intended to be machine-readable."
msgstr "`range-diff` 命令的输出可能会改变。它的目的是提供人类可读的上层命令输出，而不是可以在不同版本的 Git 中使用以获得文本稳定的 `range-diff` (与 linkgit:git-patch-id[1] 的 `--stable` 选项不同)。对于 `range-diff` 来说，也没有与 linkgit:git-apply[1] 等价的东西，其输出不是机器可读的。"

#. type: Plain text
#: en/git-range-diff.txt:126
#, priority:100
msgid "This is particularly true when passing in diff options. Currently some options like `--stat` can, as an emergent effect, produce output that's quite useless in the context of `range-diff`. Future versions of `range-diff` may learn to interpret such options in a manner specific to `range-diff` (e.g. for `--stat` producing human-readable output which summarizes how the diffstat changed)."
msgstr "当传递 diff 选项时尤其如此。目前，一些选项，例如 `--stat`，会在 `range-diff` 的上下文中产生无用的输出。未来版本的 `range-diff` 可能会学习如何以 `range-diff` 特有的方式来解释这些选项 (例如， `--stat` 产生人类可读的输出，总结了 diffstat 的变化情况)。"

#. type: Plain text
#: en/git-range-diff.txt:132
#, priority:100
msgid "This command uses the `diff.color.*` and `pager.range-diff` settings (the latter is on by default).  See linkgit:git-config[1]."
msgstr "该命令使用 `diff.color.*` 和 `pager.range-diff` 设置（后者默认开启）。 参见 linkgit:git-config[1]。"

#. type: Plain text
#: en/git-range-diff.txt:139
#, priority:100
msgid "When a rebase required merge conflicts to be resolved, compare the changes introduced by the rebase directly afterwards using:"
msgstr "当重置需要解决合并冲突时，直接比较重置后引入的更改，使用 :"

#. type: delimited block -
#: en/git-range-diff.txt:142
#, no-wrap, priority:100
msgid "$ git range-diff @{u} @{1} @\n"
msgstr "$ git range-diff @{u} @{1} @\n"

#. type: Plain text
#: en/git-range-diff.txt:146
#, priority:100
msgid "A typical output of `git range-diff` would look like this:"
msgstr "`git range-diff` 的典型输出如下："

#. type: delimited block -
#: en/git-range-diff.txt:153
#, no-wrap, priority:100
msgid ""
"-:  ------- > 1:  0ddba11 Prepare for the inevitable!\n"
"1:  c0debee = 2:  cab005e Add a helpful message at the start\n"
"2:  f00dbal ! 3:  decafe1 Describe a bug\n"
"    @@ -1,3 +1,3 @@\n"
"     Author: A U Thor <author@example.com>\n"
msgstr ""
"-:  ------- > 1:  0ddba11 Prepare for the inevitable!\n"
"1:  c0debee = 2:  cab005e Add a helpful message at the start\n"
"2:  f00dbal ! 3:  decafe1 Describe a bug\n"
"    @@ -1,3 +1,3 @@\n"
"     Author: A U Thor <author@example.com>\n"

#. type: delimited block -
#: en/git-range-diff.txt:158
#, no-wrap, priority:100
msgid ""
"    -TODO: Describe a bug\n"
"    +Describe a bug\n"
"    @@ -324,5 +324,6\n"
"      This is expected.\n"
msgstr ""
"    -TODO: Describe a bug\n"
"    +Describe a bug\n"
"    @@ -324,5 +324,6\n"
"      This is expected.\n"

#. type: delimited block -
#: en/git-range-diff.txt:162
#, no-wrap, priority:100
msgid ""
"    -+What is unexpected is that it will also crash.\n"
"    ++Unexpectedly, it also crashes. This is a bug, and the jury is\n"
"    ++still out there how to fix it best. See ticket #314 for details.\n"
msgstr ""
"    -+出乎意料的是，它也会崩溃。\n"
"    ++出乎意料的是，它也会崩溃。这是一个bug，陪审团还在讨论如何最好地修复它。\n"
"    ++如何最好地修复它，还没有定论。详见 #314 号记录。\n"

#. type: delimited block -
#: en/git-range-diff.txt:165
#, no-wrap, priority:100
msgid ""
"      Contact\n"
"3:  bedead < -:  ------- TO-UNDO\n"
msgstr ""
"      Contact\n"
"3:  bedead < -:  ------- TO-UNDO\n"

#. type: Plain text
#: en/git-range-diff.txt:170
#, priority:100
msgid "In this example, there are 3 old and 3 new commits, where the developer removed the 3rd, added a new one before the first two, and modified the commit message of the 2nd commit as well its diff."
msgstr "在这个例子中，有 3 个旧提交和 3 个新提交，开发者删除了第 3 个提交，在前两个提交之前添加了一个新提交，并修改了第 2 个提交的提交信息及其差异。"

#. type: Plain text
#: en/git-range-diff.txt:177
#, priority:100
msgid "When the output goes to a terminal, it is color-coded by default, just like regular `git diff`'s output. In addition, the first line (adding a commit) is green, the last line (deleting a commit) is red, the second line (with a perfect match) is yellow like the commit header of `git show`'s output, and the third line colors the old commit red, the new one green and the rest like `git show`'s commit header."
msgstr "当输出到终端时，默认是用颜色编码的，就像普通的 `git diff` 输出一样。此外，第一行（添加提交）是绿色的，最后一行（删除提交）是红色的，第二行（完全匹配）是黄色的，就像 `git show` 输出的提交头一样，第三行旧提交是红色的，新提交是绿色的，其余的就像 `git show` 的提交头一样。"

#. type: Plain text
#: en/git-range-diff.txt:182
#, priority:100
msgid "A naive color-coded diff of diffs is actually a bit hard to read, though, as it colors the entire lines red or green. The line that added \"What is unexpected\" in the old commit, for example, is completely red, even if the intent of the old commit was to add something."
msgstr "不过，用颜色编码的原 diff 实际上有点难读，因为它会把整行都染成红色或绿色。例如，在旧提交中添加了 \"What is unexpected\" 的那行就完全是红色的，即使旧提交的意图是添加一些东西。"

#. type: Plain text
#: en/git-range-diff.txt:188
#, priority:100
msgid "To help with that, `range` uses the `--dual-color` mode by default. In this mode, the diff of diffs will retain the original diff colors, and prefix the lines with -/+ markers that have their *background* red or green, to make it more obvious that they describe how the diff itself changed."
msgstr "为了解决这个问题，`range` 默认使用 `--dual-color` 模式。在这种模式下，diffs 的 diff 将保留原始的 diff 颜色，并在行的前缀加上 -/+ 标记，其 *背景* 为红色或绿色，以便更明显地描述 diff 本身是如何改变的。"

#. type: Title -
#: en/git-range-diff.txt:191
#, no-wrap, priority:100
msgid "Algorithm"
msgstr "算法"

#. type: Plain text
#: en/git-range-diff.txt:195
#, priority:100
msgid "The general idea is this: we generate a cost matrix between the commits in both commit ranges, then solve the least-cost assignment."
msgstr "总体思路是这样的：我们在两个提交范围内的提交之间生成一个成本矩阵，然后求解最小成本分配。"

#. type: Plain text
#: en/git-range-diff.txt:199
#, priority:100
msgid "The cost matrix is populated thusly: for each pair of commits, both diffs are generated and the \"diff of diffs\" is generated, with 3 context lines, then the number of lines in that diff is used as cost."
msgstr "成本矩阵是这样填充的：对于每一对提交，生成两个差异，并生成 “差异的差异”，其中包含 3 行上下文，然后将差异中的行数作为成本。"

#. type: Plain text
#: en/git-range-diff.txt:204
#, priority:100
msgid "To avoid false positives (e.g. when a patch has been removed, and an unrelated patch has been added between two iterations of the same patch series), the cost matrix is extended to allow for that, by adding fixed-cost entries for wholesale deletes/adds."
msgstr "为了避免假阳性（例如，当一个补丁被删除，而在同一补丁系列的两次迭代之间又添加了一个不相关的补丁），成本矩阵通过为整体删除/添加添加固定成本条目进行扩展，以考虑到这一点。"

#. type: Plain text
#: en/git-range-diff.txt:209
#, priority:100
msgid "Example: Let commits `1--2` be the first iteration of a patch series and `A--C` the second iteration. Let's assume that `A` is a cherry-pick of `2,` and `C` is a cherry-pick of `1` but with a small modification (say, a fixed typo). Visualize the commits as a bipartite graph:"
msgstr "示例： 假设 `1--2` 是补丁系列的第一次迭代，`A--C`是第二次迭代。假设 `A`是从 `2` 中挑选出来的，而 `C` 是从 `1` 中挑选出来的，但做了一点修改（比如，一个固定的错别字）。将提交可视化为一个二元图："

#. type: delimited block -
#: en/git-range-diff.txt:212
#, no-wrap, priority:100
msgid "    1            A\n"
msgstr "    1            A\n"

#. type: delimited block -
#: en/git-range-diff.txt:214
#, no-wrap, priority:100
msgid "    2            B\n"
msgstr "    2            B\n"

#. type: delimited block -
#: en/git-range-diff.txt:216 en/git-range-diff.txt:228
#, no-wrap, priority:100
msgid "\t\t C\n"
msgstr "\t\t C\n"

#. type: Plain text
#: en/git-range-diff.txt:220
#, priority:100
msgid "We are looking for a \"best\" explanation of the new series in terms of the old one. We can represent an \"explanation\" as an edge in the graph:"
msgstr "我们正在寻找新系列对旧系列的 “最佳” 解释。我们可以将 “解释” 表示为图中的一条边："

#. type: delimited block -
#: en/git-range-diff.txt:226
#, fuzzy, no-wrap, priority:100
msgid ""
"    1            A\n"
"\t       /\n"
"    2 --------'  B\n"
msgstr ""
"    1            A\n"
"\t       /\n"
"    2 --------'  B\n"

#. type: Plain text
#: en/git-range-diff.txt:233
#, priority:100
msgid "This explanation comes for \"free\" because there was no change. Similarly `C` could be explained using `1`, but that comes at some cost c>0 because of the modification:"
msgstr "这个解释是 “免费” 的，因为没有任何改变。同样地，`C` 可以用 `1`来解释，但由于修改，这需要付出一定的代价 c>0 :"

#. type: delimited block -
#: en/git-range-diff.txt:241
#, no-wrap, priority:100
msgid ""
"    1 ----.      A\n"
"\t  |    /\n"
"    2 ----+---'  B\n"
"\t  |\n"
"\t  `----- C\n"
"\t  c>0\n"
msgstr ""
"    1 ----.      A\n"
"\t  |    /\n"
"    2 ----+---'  B\n"
"\t  |\n"
"\t  `----- C\n"
"\t  c>0\n"

#. type: Plain text
#: en/git-range-diff.txt:249
#, priority:100
msgid "In mathematical terms, what we are looking for is some sort of a minimum cost bipartite matching; `1` is matched to `C` at some cost, etc. The underlying graph is in fact a complete bipartite graph; the cost we associate with every edge is the size of the diff between the two commits' patches. To explain also new commits, we introduce dummy nodes on both sides:"
msgstr "用数学术语来说，我们要寻找的是某种最小代价的双栅格匹配；`1` 以某种代价匹配到 `C`，等等。底层图实际上是一个完整的双向图；我们与每条边相关联的代价是两个提交补丁之间的差值大小。为了解释新提交，我们在两边都引入了虚节点："

#. type: delimited block -
#: en/git-range-diff.txt:258
#, fuzzy, no-wrap, priority:100
msgid ""
"    1 ----.      A\n"
"\t  |    /\n"
"    2 ----+---'  B\n"
"\t  |\n"
"    o     `----- C\n"
"\t  c>0\n"
"    o            o\n"
msgstr ""
"    1 ----.      A\n"
"\t  |    /\n"
"    2 ----+---'  B\n"
"\t  |\n"
"    o     `----- C\n"
"\t  c>0\n"
"    o            o\n"

#. type: delimited block -
#: en/git-range-diff.txt:260
#, no-wrap, priority:100
msgid "    o            o\n"
msgstr "    o            o\n"

#. type: Plain text
#: en/git-range-diff.txt:270
#, priority:100
msgid "The cost of an edge `o--C` is the size of `C`'s diff, modified by a fudge factor that should be smaller than 100%. The cost of an edge `o--o` is free. The fudge factor is necessary because even if `1` and `C` have nothing in common, they may still share a few empty lines and such, possibly making the assignment `1--C`, `o--o` slightly cheaper than `1--o`, `o--C` even if `1` and `C` have nothing in common. With the fudge factor we require a much larger common part to consider patches as corresponding."
msgstr "边 `o--C` 的代价是 `C` 的差值大小，再加上一个应小于 100% 的修正系数。边 `o--o` 的代价是免费的。修正系数是必要的，因为即使 `1` 和 `C` 没有共同点，它们仍可能共享一些空行等，这可能会使赋值 `1--C`, `o--o` 比 `1--o`, `o--C` 稍微便宜一些，即使 `1` 和 `C` 没有共同点。有了模糊因子，我们需要更大的公共部分才能将补丁视为一对的。"

#. type: Plain text
#: en/git-range-diff.txt:277
#, priority:100
msgid "The overall time needed to compute this algorithm is the time needed to compute n+m commit diffs and then n*m diffs of patches, plus the time needed to compute the least-cost assignment between n and m diffs. Git uses an implementation of the Jonker-Volgenant algorithm to solve the assignment problem, which has cubic runtime complexity. The matching found in this case will look like this:"
msgstr "计算该算法所需的总时间是计算 n+m 个提交差异和 n*m 个补丁差异所需的时间，再加上计算 n 和 m 个差异之间的最小成本赋值所需的时间。Git 使用 Jonker-Volgenant 算法来解决分配问题，该算法的运行复杂度为立方。在这种情况下找到的匹配结果是这样的 :"

#. type: delimited block -
#: en/git-range-diff.txt:286
#, fuzzy, no-wrap, priority:100
msgid ""
"    1 ----.      A\n"
"\t  |    /\n"
"    2 ----+---'  B\n"
"       .--+-----'\n"
"    o -'  `----- C\n"
"\t  c>0\n"
"    o ---------- o\n"
msgstr ""
"    1 ----.      A\n"
"\t  |    /\n"
"    2 ----+---'  B\n"
"       .--+-----'\n"
"    o -'  `----- C\n"
"\t  c>0\n"
"    o ---------- o\n"

#. type: delimited block -
#: en/git-range-diff.txt:288
#, fuzzy, no-wrap, priority:100
msgid "    o ---------- o\n"
msgstr "    o ---------- o\n"

#. type: Title =
#: en/git-read-tree.txt:2
#, ignore-same, no-wrap, priority:80
msgid "git-read-tree(1)"
msgstr "git-read-tree(1)"

#. type: Plain text
#: en/git-read-tree.txt:7
#, fuzzy, priority:80
msgid "git-read-tree - Reads tree information into the index"
msgstr "git-read-tree - Reads tree information into the index"

#. type: Plain text
#: en/git-read-tree.txt:15
#, no-wrap, priority:80
msgid ""
"'git read-tree' [(-m [--trivial] [--aggressive] | --reset | --prefix=<prefix>)\n"
"\t\t[-u | -i]] [--index-output=<file>] [--no-sparse-checkout]\n"
"\t\t(--empty | <tree-ish1> [<tree-ish2> [<tree-ish3>]])\n"
msgstr ""
"'git read-tree' [(-m [--trivial] [--aggressive] | --reset | --prefix=<prefix>)\n"
"\t\t[-u | -i]] [--index-output=<file>] [--no-sparse-checkout]\n"
"\t\t(--empty | <tree-ish1> [<tree-ish2> [<tree-ish3>]])\n"

#. type: Plain text
#: en/git-read-tree.txt:22
#, priority:80
msgid "Reads the tree information given by <tree-ish> into the index, but does not actually *update* any of the files it \"caches\". (see: linkgit:git-checkout-index[1])"
msgstr ""

#. type: Plain text
#: en/git-read-tree.txt:27
#, priority:80
msgid "Optionally, it can merge a tree into the index, perform a fast-forward (i.e. 2-way) merge, or a 3-way merge, with the `-m` flag.  When used with `-m`, the `-u` flag causes it to also update the files in the work tree with the result of the merge."
msgstr ""

#. type: Plain text
#: en/git-read-tree.txt:30
#, priority:80
msgid "Trivial merges are done by 'git read-tree' itself.  Only conflicting paths will be in unmerged state when 'git read-tree' returns."
msgstr ""

#. type: Plain text
#: en/git-read-tree.txt:38
#, priority:80
msgid "Perform a merge, not just a read.  The command will refuse to run if your index file has unmerged entries, indicating that you have not finished previous merge you started."
msgstr ""

#. type: Labeled list
#: en/git-read-tree.txt:39
#, ignore-same, no-wrap, priority:80
msgid "--reset"
msgstr "--reset"

#. type: Plain text
#: en/git-read-tree.txt:44
#, priority:80
msgid "Same as -m, except that unmerged entries are discarded instead of failing.  When used with `-u`, updates leading to loss of working tree changes or untracked files or directories will not abort the operation."
msgstr ""

#. type: Plain text
#: en/git-read-tree.txt:48
#, priority:80
msgid "After a successful merge, update the files in the work tree with the result of the merge."
msgstr ""

#. type: Plain text
#: en/git-read-tree.txt:57
#, priority:80
msgid "Usually a merge requires the index file as well as the files in the working tree to be up to date with the current head commit, in order not to lose local changes.  This flag disables the check with the working tree and is meant to be used when creating a merge of trees that are not directly related to the current working tree status into a temporary index file."
msgstr ""

#. type: Plain text
#: en/git-read-tree.txt:62
#, priority:80
msgid "Check if the command would error out, without updating the index or the files in the working tree for real."
msgstr ""

#. type: Plain text
#: en/git-read-tree.txt:65
#, priority:80
msgid "Show the progress of checking files out."
msgstr ""

#. type: Labeled list
#: en/git-read-tree.txt:66
#, ignore-same, no-wrap, priority:80
msgid "--trivial"
msgstr "--trivial"

#. type: Plain text
#: en/git-read-tree.txt:71
#, priority:80
msgid "Restrict three-way merge by 'git read-tree' to happen only if there is no file-level merging required, instead of resolving merge for trivial cases and leaving conflicting files unresolved in the index."
msgstr ""

#. type: Plain text
#: en/git-read-tree.txt:78
#, priority:80
msgid "Usually a three-way merge by 'git read-tree' resolves the merge for really trivial cases and leaves other cases unresolved in the index, so that porcelains can implement different merge policies.  This flag makes the command resolve a few more cases internally:"
msgstr ""

#. type: Plain text
#: en/git-read-tree.txt:81
#, priority:80
msgid "when one side removes a path and the other side leaves the path unmodified.  The resolution is to remove that path."
msgstr ""

#. type: Plain text
#: en/git-read-tree.txt:82
#, priority:80
msgid "when both sides remove a path.  The resolution is to remove that path."
msgstr ""

#. type: Plain text
#: en/git-read-tree.txt:84
#, priority:80
msgid "when both sides add a path identically.  The resolution is to add that path."
msgstr ""

#. type: Labeled list
#: en/git-read-tree.txt:85 en/git-svn.txt:75
#, fuzzy, no-wrap, priority:100
msgid "--prefix=<prefix>"
msgstr "--prefix=<prefix>"

#. type: Plain text
#: en/git-read-tree.txt:90
#, priority:80
msgid "Keep the current index contents, and read the contents of the named tree-ish under the directory at `<prefix>`.  The command will refuse to overwrite entries that already existed in the original index file."
msgstr ""

#. type: Labeled list
#: en/git-read-tree.txt:91
#, no-wrap, priority:80
msgid "--index-output=<file>"
msgstr ""

#. type: Plain text
#: en/git-read-tree.txt:102
#, priority:80
msgid "Instead of writing the results out to `$GIT_INDEX_FILE`, write the resulting index in the named file.  While the command is operating, the original index file is locked with the same mechanism as usual.  The file must allow to be rename(2)ed into from a temporary file that is created next to the usual index file; typically this means it needs to be on the same filesystem as the index file itself, and you need write permission to the directories the index file and index output file are located in."
msgstr ""

#. type: Labeled list
#: en/git-read-tree.txt:103 en/git-reset.txt:93
#, ignore-same, no-wrap, priority:280
msgid "--[no-]recurse-submodules"
msgstr "--[no-]recurse-submodules"

#. type: Plain text
#: en/git-read-tree.txt:108
#, priority:80
msgid "Using --recurse-submodules will update the content of all active submodules according to the commit recorded in the superproject by calling read-tree recursively, also setting the submodules' HEAD to be detached at that commit."
msgstr ""

#. type: Labeled list
#: en/git-read-tree.txt:109
#, ignore-same, no-wrap, priority:80
msgid "--no-sparse-checkout"
msgstr "--no-sparse-checkout"

#. type: Plain text
#: en/git-read-tree.txt:112
#, priority:80
msgid "Disable sparse checkout support even if `core.sparseCheckout` is true."
msgstr ""

#. type: Labeled list
#: en/git-read-tree.txt:113
#, ignore-same, no-wrap, priority:80
msgid "--empty"
msgstr "--empty"

#. type: Plain text
#: en/git-read-tree.txt:116
#, priority:80
msgid "Instead of reading tree object(s) into the index, just empty it."
msgstr ""

#. type: Labeled list
#: en/git-read-tree.txt:121
#, no-wrap, priority:80
msgid "<tree-ish#>"
msgstr ""

#. type: Plain text
#: en/git-read-tree.txt:123
#, priority:80
msgid "The id of the tree object(s) to be read/merged."
msgstr ""

#. type: Title -
#: en/git-read-tree.txt:126
#, no-wrap, priority:80
msgid "MERGING"
msgstr ""

#. type: Plain text
#: en/git-read-tree.txt:131
#, priority:80
msgid "If `-m` is specified, 'git read-tree' can perform 3 kinds of merge, a single tree merge if only 1 tree is given, a fast-forward merge with 2 trees, or a 3-way merge if 3 or more trees are provided."
msgstr ""

#. type: Title ~
#: en/git-read-tree.txt:134
#, no-wrap, priority:80
msgid "Single Tree Merge"
msgstr ""

#. type: Plain text
#: en/git-read-tree.txt:140
#, priority:80
msgid "If only 1 tree is specified, 'git read-tree' operates as if the user did not specify `-m`, except that if the original index has an entry for a given pathname, and the contents of the path match with the tree being read, the stat info from the index is used. (In other words, the index's stat()s take precedence over the merged tree's)."
msgstr ""

#. type: Plain text
#: en/git-read-tree.txt:144
#, priority:80
msgid "That means that if you do a `git read-tree -m <newtree>` followed by a `git checkout-index -f -u -a`, the 'git checkout-index' only checks out the stuff that really changed."
msgstr ""

#. type: Plain text
#: en/git-read-tree.txt:147
#, priority:80
msgid "This is used to avoid unnecessary false hits when 'git diff-files' is run after 'git read-tree'."
msgstr ""

#. type: Title ~
#: en/git-read-tree.txt:150
#, no-wrap, priority:80
msgid "Two Tree Merge"
msgstr ""

#. type: Plain text
#: en/git-read-tree.txt:156
#, priority:80
msgid "Typically, this is invoked as `git read-tree -m $H $M`, where $H is the head commit of the current repository, and $M is the head of a foreign tree, which is simply ahead of $H (i.e. we are in a fast-forward situation)."
msgstr ""

#. type: Plain text
#: en/git-read-tree.txt:159
#, priority:80
msgid "When two trees are specified, the user is telling 'git read-tree' the following:"
msgstr ""

#. type: Plain text
#: en/git-read-tree.txt:161
#, priority:80
msgid "The current index and work tree is derived from $H, but"
msgstr ""

#. type: Plain text
#: en/git-read-tree.txt:162
#, priority:80
msgid "the user may have local changes in them since $H."
msgstr ""

#. type: Plain text
#: en/git-read-tree.txt:164
#, priority:80
msgid "The user wants to fast-forward to $M."
msgstr ""

#. type: Plain text
#: en/git-read-tree.txt:170
#, priority:80
msgid "In this case, the `git read-tree -m $H $M` command makes sure that no local change is lost as the result of this \"merge\".  Here are the \"carry forward\" rules, where \"I\" denotes the index, \"clean\" means that index and work tree coincide, and \"exists\"/\"nothing\" refer to the presence of a path in the specified commit:"
msgstr ""

#. type: delimited block .
#: en/git-read-tree.txt:181
#, no-wrap, priority:80
msgid ""
"\tI                   H        M        Result\n"
"       -------------------------------------------------------\n"
"     0  nothing             nothing  nothing  (does not happen)\n"
"     1  nothing             nothing  exists   use M\n"
"     2  nothing             exists   nothing  remove path from index\n"
"     3  nothing             exists   exists,  use M if \"initial checkout\",\n"
"\t\t\t\t     H == M   keep index otherwise\n"
"\t\t\t\t     exists,  fail\n"
"\t\t\t\t     H != M\n"
msgstr ""

#. type: delimited block .
#: en/git-read-tree.txt:186
#, no-wrap, priority:80
msgid ""
"        clean I==H  I==M\n"
"       ------------------\n"
"     4  yes   N/A   N/A     nothing  nothing  keep index\n"
"     5  no    N/A   N/A     nothing  nothing  keep index\n"
msgstr ""

#. type: delimited block .
#: en/git-read-tree.txt:191
#, no-wrap, priority:80
msgid ""
"     6  yes   N/A   yes     nothing  exists   keep index\n"
"     7  no    N/A   yes     nothing  exists   keep index\n"
"     8  yes   N/A   no      nothing  exists   fail\n"
"     9  no    N/A   no      nothing  exists   fail\n"
msgstr ""

#. type: delimited block .
#: en/git-read-tree.txt:196
#, no-wrap, priority:80
msgid ""
"     10 yes   yes   N/A     exists   nothing  remove path from index\n"
"     11 no    yes   N/A     exists   nothing  fail\n"
"     12 yes   no    N/A     exists   nothing  fail\n"
"     13 no    no    N/A     exists   nothing  fail\n"
msgstr ""

#. type: delimited block .
#: en/git-read-tree.txt:201
#, no-wrap, priority:80
msgid ""
"\tclean (H==M)\n"
"       ------\n"
"     14 yes                 exists   exists   keep index\n"
"     15 no                  exists   exists   keep index\n"
msgstr ""

#. type: delimited block .
#: en/git-read-tree.txt:210
#, no-wrap, priority:80
msgid ""
"        clean I==H  I==M (H!=M)\n"
"       ------------------\n"
"     16 yes   no    no      exists   exists   fail\n"
"     17 no    no    no      exists   exists   fail\n"
"     18 yes   no    yes     exists   exists   keep index\n"
"     19 no    no    yes     exists   exists   keep index\n"
"     20 yes   yes   no      exists   exists   use M\n"
"     21 no    yes   no      exists   exists   fail\n"
msgstr ""

#. type: Plain text
#: en/git-read-tree.txt:216
#, priority:80
msgid "In all \"keep index\" cases, the index entry stays as in the original index file.  If the entry is not up to date, 'git read-tree' keeps the copy in the work tree intact when operating under the -u flag."
msgstr ""

#. type: Plain text
#: en/git-read-tree.txt:227
#, priority:80
msgid "When this form of 'git read-tree' returns successfully, you can see which of the \"local changes\" that you made were carried forward by running `git diff-index --cached $M`.  Note that this does not necessarily match what `git diff-index --cached $H` would have produced before such a two tree merge.  This is because of cases 18 and 19 -- if you already had the changes in $M (e.g. maybe you picked it up via e-mail in a patch form), `git diff-index --cached $H` would have told you about the change before this merge, but it would not show in `git diff-index --cached $M` output after the two-tree merge."
msgstr ""

#. type: Plain text
#: en/git-read-tree.txt:234
#, priority:80
msgid "Case 3 is slightly tricky and needs explanation.  The result from this rule logically should be to remove the path if the user staged the removal of the path and then switching to a new branch.  That however will prevent the initial checkout from happening, so the rule is modified to use M (new tree) only when the content of the index is empty.  Otherwise the removal of the path is kept as long as $H and $M are the same."
msgstr ""

#. type: Title ~
#: en/git-read-tree.txt:236
#, no-wrap, priority:80
msgid "3-Way Merge"
msgstr ""

#. type: Plain text
#: en/git-read-tree.txt:239
#, priority:80
msgid "Each \"index\" entry has two bits worth of \"stage\" state. stage 0 is the normal one, and is the only one you'd see in any kind of normal use."
msgstr ""

#. type: Plain text
#: en/git-read-tree.txt:242
#, priority:80
msgid "However, when you do 'git read-tree' with three trees, the \"stage\" starts out at 1."
msgstr ""

#. type: Plain text
#: en/git-read-tree.txt:244
#, priority:80
msgid "This means that you can do"
msgstr ""

#. type: delimited block -
#: en/git-read-tree.txt:247
#, fuzzy, no-wrap, priority:80
msgid "$ git read-tree -m <tree1> <tree2> <tree3>\n"
msgstr "$ git read-tree -m <tree1> <tree2> <tree3>\n"

#. type: Plain text
#: en/git-read-tree.txt:255
#, priority:80
msgid "and you will end up with an index with all of the <tree1> entries in \"stage1\", all of the <tree2> entries in \"stage2\" and all of the <tree3> entries in \"stage3\".  When performing a merge of another branch into the current branch, we use the common ancestor tree as <tree1>, the current branch head as <tree2>, and the other branch head as <tree3>."
msgstr ""

#. type: Plain text
#: en/git-read-tree.txt:259
#, priority:80
msgid "Furthermore, 'git read-tree' has special-case logic that says: if you see a file that matches in all respects in the following states, it \"collapses\" back to \"stage0\":"
msgstr ""

#. type: Plain text
#: en/git-read-tree.txt:263
#, priority:80
msgid "stage 2 and 3 are the same; take one or the other (it makes no difference - the same work has been done on our branch in stage 2 and their branch in stage 3)"
msgstr ""

#. type: Plain text
#: en/git-read-tree.txt:268
#, priority:80
msgid "stage 1 and stage 2 are the same and stage 3 is different; take stage 3 (our branch in stage 2 did not do anything since the ancestor in stage 1 while their branch in stage 3 worked on it)"
msgstr ""

#. type: Plain text
#: en/git-read-tree.txt:271
#, priority:80
msgid "stage 1 and stage 3 are the same and stage 2 is different take stage 2 (we did something while they did nothing)"
msgstr ""

#. type: Plain text
#: en/git-read-tree.txt:275
#, priority:80
msgid "The 'git write-tree' command refuses to write a nonsensical tree, and it will complain about unmerged entries if it sees a single entry that is not stage 0."
msgstr ""

#. type: Plain text
#: en/git-read-tree.txt:281
#, priority:80
msgid "OK, this all sounds like a collection of totally nonsensical rules, but it's actually exactly what you want in order to do a fast merge. The different stages represent the \"result tree\" (stage 0, aka \"merged\"), the original tree (stage 1, aka \"orig\"), and the two trees you are trying to merge (stage 2 and 3 respectively)."
msgstr ""

#. type: Plain text
#: en/git-read-tree.txt:286
#, priority:80
msgid "The order of stages 1, 2 and 3 (hence the order of three <tree-ish> command-line arguments) are significant when you start a 3-way merge with an index file that is already populated.  Here is an outline of how the algorithm works:"
msgstr ""

#. type: Plain text
#: en/git-read-tree.txt:289
#, priority:80
msgid "if a file exists in identical format in all three trees, it will automatically collapse to \"merged\" state by 'git read-tree'."
msgstr ""

#. type: Plain text
#: en/git-read-tree.txt:294
#, priority:80
msgid "a file that has _any_ difference what-so-ever in the three trees will stay as separate entries in the index. It's up to \"porcelain policy\" to determine how to remove the non-0 stages, and insert a merged version."
msgstr ""

#. type: Plain text
#: en/git-read-tree.txt:299
#, priority:80
msgid "the index file saves and restores with all this information, so you can merge things incrementally, but as long as it has entries in stages 1/2/3 (i.e., \"unmerged entries\") you can't write the result. So now the merge algorithm ends up being really simple:"
msgstr ""

#. type: Plain text
#: en/git-read-tree.txt:302
#, priority:80
msgid "you walk the index in order, and ignore all entries of stage 0, since they've already been done."
msgstr ""

#. type: Plain text
#: en/git-read-tree.txt:306
#, priority:80
msgid "if you find a \"stage1\", but no matching \"stage2\" or \"stage3\", you know it's been removed from both trees (it only existed in the original tree), and you remove that entry."
msgstr ""

#. type: Plain text
#: en/git-read-tree.txt:311
#, priority:80
msgid "if you find a matching \"stage2\" and \"stage3\" tree, you remove one of them, and turn the other into a \"stage0\" entry. Remove any matching \"stage1\" entry if it exists too.  .. all the normal trivial rules .."
msgstr ""

#. type: Plain text
#: en/git-read-tree.txt:316
#, priority:80
msgid "You would normally use 'git merge-index' with supplied 'git merge-one-file' to do this last step.  The script updates the files in the working tree as it merges each path and at the end of a successful merge."
msgstr ""

#. type: Plain text
#: en/git-read-tree.txt:324
#, priority:80
msgid "When you start a 3-way merge with an index file that is already populated, it is assumed that it represents the state of the files in your work tree, and you can even have files with changes unrecorded in the index file.  It is further assumed that this state is \"derived\" from the stage 2 tree.  The 3-way merge refuses to run if it finds an entry in the original index file that does not match stage 2."
msgstr ""

#. type: Plain text
#: en/git-read-tree.txt:329
#, priority:80
msgid "This is done to prevent you from losing your work-in-progress changes, and mixing your random changes in an unrelated merge commit.  To illustrate, suppose you start from what has been committed last to your repository:"
msgstr ""

#. type: delimited block -
#: en/git-read-tree.txt:333
#, fuzzy, no-wrap, priority:80
msgid ""
"$ JC=`git rev-parse --verify \"HEAD^0\"`\n"
"$ git checkout-index -f -u -a $JC\n"
msgstr ""
"$ JC=`git rev-parse --verify \"HEAD^0\"`\n"
"$ git checkout-index -f -u -a $JC\n"

#. type: Plain text
#: en/git-read-tree.txt:338
#, priority:80
msgid "You do random edits, without running 'git update-index'.  And then you notice that the tip of your \"upstream\" tree has advanced since you pulled from him:"
msgstr ""

#. type: delimited block -
#: en/git-read-tree.txt:342
#, fuzzy, ignore-ellipsis, no-wrap, priority:80
msgid ""
"$ git fetch git://.... linus\n"
"$ LT=`git rev-parse FETCH_HEAD`\n"
msgstr ""
"$ git fetch git://.... linus\n"
"$ LT=`git rev-parse FETCH_HEAD`\n"

#. type: Plain text
#: en/git-read-tree.txt:348
#, priority:80
msgid "Your work tree is still based on your HEAD ($JC), but you have some edits since.  Three-way merge makes sure that you have not added or modified index entries since $JC, and if you haven't, then does the right thing.  So with the following sequence:"
msgstr ""

#. type: delimited block -
#: en/git-read-tree.txt:354
#, fuzzy, no-wrap, priority:80
msgid ""
"$ git read-tree -m -u `git merge-base $JC $LT` $JC $LT\n"
"$ git merge-index git-merge-one-file -a\n"
"$ echo \"Merge with Linus\" | \\\n"
"  git commit-tree `git write-tree` -p $JC -p $LT\n"
msgstr ""
"$ git read-tree -m -u `git merge-base $JC $LT` $JC $LT\n"
"$ git merge-index git-merge-one-file -a\n"
"$ echo \"Merge with Linus\" | \\\n"
"  git commit-tree `git write-tree` -p $JC -p $LT\n"

#. type: Plain text
#: en/git-read-tree.txt:359
#, priority:80
msgid "what you would commit is a pure merge between $JC and $LT without your work-in-progress changes, and your work tree would be updated to the result of the merge."
msgstr ""

#. type: Plain text
#: en/git-read-tree.txt:363
#, priority:80
msgid "However, if you have local changes in the working tree that would be overwritten by this merge, 'git read-tree' will refuse to run to prevent your changes from being lost."
msgstr ""

#. type: Plain text
#: en/git-read-tree.txt:373
#, priority:80
msgid "In other words, there is no need to worry about what exists only in the working tree.  When you have local changes in a part of the project that is not involved in the merge, your changes do not interfere with the merge, and are kept intact.  When they *do* interfere, the merge does not even start ('git read-tree' complains loudly and fails without modifying anything).  In such a case, you can simply continue doing what you were in the middle of doing, and when your working tree is ready (i.e. you have finished your work-in-progress), attempt the merge again."
msgstr ""

#. type: Title -
#: en/git-read-tree.txt:376
#, fuzzy, no-wrap, priority:80
msgid "SPARSE CHECKOUT"
msgstr "SPARSE CHECKOUT"

#. type: Plain text
#: en/git-read-tree.txt:385
#, priority:80
msgid "Note: The skip-worktree capabilities in linkgit:git-update-index[1] and `read-tree` predated the introduction of linkgit:git-sparse-checkout[1].  Users are encouraged to use the `sparse-checkout` command in preference to these plumbing commands for sparse-checkout/skip-worktree related needs.  However, the information below might be useful to users trying to understand the pattern style used in non-cone mode of the `sparse-checkout` command."
msgstr ""

#. type: Plain text
#: en/git-read-tree.txt:389
#, priority:80
msgid "\"Sparse checkout\" allows populating the working directory sparsely.  It uses the skip-worktree bit (see linkgit:git-update-index[1]) to tell Git whether a file in the working directory is worth looking at."
msgstr ""

#. type: Plain text
#: en/git-read-tree.txt:399
#, ignore-ellipsis, priority:80
msgid "'git read-tree' and other merge-based commands ('git merge', 'git checkout'...) can help maintaining the skip-worktree bitmap and working directory update. `$GIT_DIR/info/sparse-checkout` is used to define the skip-worktree reference bitmap. When 'git read-tree' needs to update the working directory, it resets the skip-worktree bit in the index based on this file, which uses the same syntax as .gitignore files.  If an entry matches a pattern in this file, or the entry corresponds to a file present in the working tree, then skip-worktree will not be set on that entry. Otherwise, skip-worktree will be set."
msgstr ""

#. type: Plain text
#: en/git-read-tree.txt:403
#, priority:80
msgid "Then it compares the new skip-worktree value with the previous one. If skip-worktree turns from set to unset, it will add the corresponding file back. If it turns from unset to set, that file will be removed."
msgstr ""

#. type: Plain text
#: en/git-read-tree.txt:407
#, priority:80
msgid "While `$GIT_DIR/info/sparse-checkout` is usually used to specify what files are in, you can also specify what files are _not_ in, using negate patterns. For example, to remove the file `unwanted`:"
msgstr ""

#. type: delimited block -
#: en/git-read-tree.txt:411
#, fuzzy, no-wrap, priority:80
msgid ""
"/*\n"
"!unwanted\n"
msgstr ""
"/*\n"
"!unwanted\n"

#. type: Plain text
#: en/git-read-tree.txt:419
#, priority:80
msgid "Another tricky thing is fully repopulating the working directory when you no longer want sparse checkout. You cannot just disable \"sparse checkout\" because skip-worktree bits are still in the index and your working directory is still sparsely populated. You should re-populate the working directory with the `$GIT_DIR/info/sparse-checkout` file content as follows:"
msgstr ""

#. type: delimited block -
#: en/git-read-tree.txt:422
#, fuzzy, no-wrap, priority:80
msgid "/*\n"
msgstr "/*\n"

#. type: Plain text
#: en/git-read-tree.txt:428
#, priority:80
msgid "Then you can disable sparse checkout. Sparse checkout support in 'git read-tree' and similar commands is disabled by default. You need to turn `core.sparseCheckout` on in order to have sparse checkout support."
msgstr ""

#. type: Plain text
#: en/git-read-tree.txt:434
#, ignore-same, priority:80
msgid "linkgit:git-write-tree[1], linkgit:git-ls-files[1], linkgit:gitignore[5], linkgit:git-sparse-checkout[1]"
msgstr "linkgit:git-write-tree[1], linkgit:git-ls-files[1], linkgit:gitignore[5], linkgit:git-sparse-checkout[1]"

#. type: Title =
#: en/git-rebase.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-rebase(1)"
msgstr "git-rebase(1)"

#. type: Plain text
#: en/git-rebase.txt:7
#, priority:100
msgid "git-rebase - Reapply commits on top of another base tip"
msgstr "git-rebase - 在另一个基础提示之上重新应用提交内容"

#. type: Plain text
#: en/git-rebase.txt:16
#, no-wrap, priority:100
msgid ""
"'git rebase' [-i | --interactive] [<options>] [--exec <cmd>]\n"
"\t[--onto <newbase> | --keep-base] [<upstream> [<branch>]]\n"
"'git rebase' [-i | --interactive] [<options>] [--exec <cmd>] [--onto <newbase>]\n"
"\t--root [<branch>]\n"
"'git rebase' (--continue | --skip | --abort | --quit | --edit-todo | --show-current-patch)\n"
msgstr ""
"'git rebase' [-i | --interactive] [<options>] [--exec <cmd>]\n"
"\t[--onto <newbase> | --keep-base] [<upstream> [<branch>]]\n"
"'git rebase' [-i | --interactive] [<options>] [--exec <cmd>] [--onto <newbase>]\n"
"\t--root [<branch>]\n"
"'git rebase' (--continue | --skip | --abort | --quit | --edit-todo | --show-current-patch)\n"

#. type: Plain text
#: en/git-rebase.txt:22
#, priority:100
msgid "If `<branch>` is specified, `git rebase` will perform an automatic `git switch <branch>` before doing anything else.  Otherwise it remains on the current branch."
msgstr "如果指定了 `<branch>`，`git rebase` 会自动执行 `git switch <branch>`，然后再做其他事情。 否则，它会保留在当前分支上。"

#. type: Plain text
#: en/git-rebase.txt:28
#, priority:100
msgid "If `<upstream>` is not specified, the upstream configured in `branch.<name>.remote` and `branch.<name>.merge` options will be used (see linkgit:git-config[1] for details) and the `--fork-point` option is assumed.  If you are currently not on any branch or if the current branch does not have a configured upstream, the rebase will abort."
msgstr "如果未指定 `<upstream>`，将使用 `branch.<name>.remote` 和 `branch.<name>.merge` 选项中配置的上游（详见 linkgit:git-config[1]），并假定使用 `-fork-point`选项。  如果您当前不在任何分支上，或者当前分支没有配置上游，变基操作会中止。"

#. type: Plain text
#: en/git-rebase.txt:35
#, priority:100
msgid "All changes made by commits in the current branch but that are not in `<upstream>` are saved to a temporary area.  This is the same set of commits that would be shown by `git log <upstream>..HEAD`; or by `git log 'fork_point'..HEAD`, if `--fork-point` is active (see the description on `--fork-point` below); or by `git log HEAD`, if the `--root` option is specified."
msgstr "当前分支中的所有提交所做的改动，但不在 `<upstream>` 中的，都会被保存到一个临时区域。  这与 `git log <upstream>..HEAD` 或 `git log 'fork_point'..HEAD` 所显示的提交相同（如果启用了 `-fork-point`，请参阅下文关于 `-fork-point`的描述）；或者，如果指定了 `--root` 选项，则与 `git log HEAD` 所显示的提交相同。"

#. type: Plain text
#: en/git-rebase.txt:40
#, priority:100
msgid "The current branch is reset to `<upstream>` or `<newbase>` if the `--onto` option was supplied.  This has the exact same effect as `git reset --hard <upstream>` (or `<newbase>`). `ORIG_HEAD` is set to point at the tip of the branch before the reset."
msgstr "如果提供了 `--onto` 选项，当前分支会重置为 `<upstream>` 或 `<newbase>`。  这与 `git reset --hard <upstream>`（或 `<newbase>`）的效果完全相同。`ORIG_HEAD` 设置为指向重置前分支的顶端。"

#. type: Plain text
#: en/git-rebase.txt:47
#, priority:100
msgid "`ORIG_HEAD` is not guaranteed to still point to the previous branch tip at the end of the rebase if other commands that write that pseudo-ref (e.g. `git reset`) are used during the rebase. The previous branch tip, however, is accessible using the reflog of the current branch (i.e. `@{1}`, see linkgit:gitrevisions[7])."
msgstr "如果在重置过程中使用了其他写入伪引用的命令（例如 `git reset`），就不能保证 `ORIG_HEAD` 在重置结束时仍然指向前一个分支的分支提示。不过，使用当前分支的 引用日志（即 `@{1}`，参见 linkgit:gitrevisions[7]）可以访问前一个分支的分支提示。"

#. type: Plain text
#: en/git-rebase.txt:53
#, priority:100
msgid "The commits that were previously saved into the temporary area are then reapplied to the current branch, one by one, in order. Note that any commits in `HEAD` which introduce the same textual changes as a commit in `HEAD..<upstream>` are omitted (i.e., a patch already accepted upstream with a different commit message or timestamp will be skipped)."
msgstr "然后，先前保存在临时区域的提交将按顺序逐一重新应用到当前分支。请注意，`HEAD` 中任何与 `HEAD...<upstream>` 中的提交有相同文字改动的提交都会被省略（也就是说，上游已经接受的补丁，如果提交信息或时间戳不同，就会被跳过）。"

#. type: Plain text
#: en/git-rebase.txt:60
#, priority:100
msgid "It is possible that a merge failure will prevent this process from being completely automatic.  You will have to resolve any such merge failure and run `git rebase --continue`.  Another option is to bypass the commit that caused the merge failure with `git rebase --skip`.  To check out the original `<branch>` and remove the `.git/rebase-apply` working files, use the command `git rebase --abort` instead."
msgstr "合并失败有可能导致该过程无法完全自动进行。  您必须解决合并失败问题，然后运行 `git rebase --continue`。  另一种方法是使用 `git rebase --skip` 绕过导致合并失败的提交。  要检查原始的 `<branch>` 并移除 `.git/rebase-apply` 工作文件，请使用 `git rebase --abort` 命令。"

#. type: Plain text
#: en/git-rebase.txt:62
#, priority:100
msgid "Assume the following history exists and the current branch is \"topic\":"
msgstr "假设存在以下历史记录，当前分支为 \"topic\"："

#. type: delimited block -
#: en/git-rebase.txt:67
#, no-wrap, priority:100
msgid ""
"          A---B---C topic\n"
"         /\n"
"    D---E---F---G master\n"
msgstr ""
"          A---B---C topic\n"
"         /\n"
"    D---E---F---G master\n"

#. type: Plain text
#: en/git-rebase.txt:70
#, priority:100
msgid "From this point, the result of either of the following commands:"
msgstr "从这一点来看，以下任一命令的结果都是如此："

#. type: Plain text
#: en/git-rebase.txt:74
#, fuzzy, no-wrap, priority:100
msgid ""
"    git rebase master\n"
"    git rebase master topic\n"
msgstr ""
"    git rebase master\n"
"    git rebase master topic\n"

#. type: Plain text
#: en/git-rebase.txt:76
#, priority:100
msgid "would be:"
msgstr "那就是 :"

#. type: delimited block -
#: en/git-rebase.txt:81
#, no-wrap, priority:100
msgid ""
"                  A'--B'--C' topic\n"
"                 /\n"
"    D---E---F---G master\n"
msgstr ""
"                  A'--B'--C' topic\n"
"                 /\n"
"    D---E---F---G master\n"

#. type: Plain text
#: en/git-rebase.txt:86
#, no-wrap, priority:100
msgid ""
"*NOTE:* The latter form is just a short-hand of `git checkout topic`\n"
"followed by `git rebase master`. When rebase exits `topic` will\n"
"remain the checked-out branch.\n"
msgstr ""
"*注：* 后一种形式只是 `git checkout topic` 的简写。\n"
"后接 `git rebase master`。当 rebase 退出时，`topic` 将\n"
"仍是已签出的分支。\n"

#. type: Plain text
#: en/git-rebase.txt:93
#, priority:100
msgid "If the upstream branch already contains a change you have made (e.g., because you mailed a patch which was applied upstream), then that commit will be skipped and warnings will be issued (if the 'merge' backend is used).  For example, running `git rebase master` on the following history (in which `A'` and `A` introduce the same set of changes, but have different committer information):"
msgstr "如果上游分支已经包含了您所做的修改（例如，因为您邮寄的补丁被应用到了上游），那么该提交将被跳过，并发出警告（如果使用了 “合并” 后台）。 例如，在以下历史记录上运行 `git rebase master`（其中 `A'` 和 `A` 引入了相同的变更集，但提交者信息不同）："

#. type: delimited block -
#: en/git-rebase.txt:98
#, no-wrap, priority:100
msgid ""
"          A---B---C topic\n"
"         /\n"
"    D---E---A'---F master\n"
msgstr ""
"          A---B---C topic\n"
"         /\n"
"    D---E---A'---F master\n"

#. type: Plain text
#: en/git-rebase.txt:101
#, priority:100
msgid "will result in:"
msgstr "将导致 :"

#. type: delimited block -
#: en/git-rebase.txt:106
#, fuzzy, no-wrap, priority:100
msgid ""
"                   B'---C' topic\n"
"                  /\n"
"    D---E---A'---F master\n"
msgstr ""
"                   B'---C' 主题\n"
"                  /\n"
"    D---E---A'---F 主分支\n"

#. type: Plain text
#: en/git-rebase.txt:111
#, priority:100
msgid "Here is how you would transplant a topic branch based on one branch to another, to pretend that you forked the topic branch from the latter branch, using `rebase --onto`."
msgstr "下面是如何使用 `rebase --onto` 将基于一个分支的特性分支移植到另一个分支，以假装特性分支是从后一个分支分叉而来。"

#. type: Plain text
#: en/git-rebase.txt:115
#, priority:100
msgid "First let's assume your 'topic' is based on branch 'next'.  For example, a feature developed in 'topic' depends on some functionality which is found in 'next'."
msgstr "首先，我们假设 'topic' 基于 'next' 分支。 例如，'topic' 中开发的功能依赖于 'next' 中的某些功能。"

#. type: delimited block -
#: en/git-rebase.txt:122
#, fuzzy, no-wrap, priority:100
msgid ""
"    o---o---o---o---o  master\n"
"         \\\n"
"          o---o---o---o---o  next\n"
"                           \\\n"
"                            o---o---o  topic\n"
msgstr ""
"    o---o---o---o---o  master\n"
"         \\\n"
"          o---o---o---o---o  next\n"
"                           \\\n"
"                            o---o---o  topic\n"

#. type: Plain text
#: en/git-rebase.txt:127
#, priority:100
msgid "We want to make 'topic' forked from branch 'master'; for example, because the functionality on which 'topic' depends was merged into the more stable 'master' branch. We want our tree to look like this:"
msgstr "我们想让 'topic' 从分支 'master' 中分叉出来；例如，因为 'topic' 所依赖的功能已经合并到了更稳定的分支 'master' 中。我们希望我们的提交树看起来像这样 :"

#. type: delimited block -
#: en/git-rebase.txt:134
#, no-wrap, priority:100
msgid ""
"    o---o---o---o---o  master\n"
"        |            \\\n"
"        |             o'--o'--o'  topic\n"
"         \\\n"
"          o---o---o---o---o  next\n"
msgstr ""
"    o---o---o---o---o  master\n"
"        |            \\\n"
"        |             o'--o'--o'  topic\n"
"         \\\n"
"          o---o---o---o---o  next\n"

#. type: Plain text
#: en/git-rebase.txt:137
#, priority:100
msgid "We can get this using the following command:"
msgstr "我们可以使用以下命令来获取 :"

#. type: Plain text
#: en/git-rebase.txt:139
#, no-wrap, priority:100
msgid "    git rebase --onto master next topic\n"
msgstr "    git rebase --onto master next topic\n"

#. type: Plain text
#: en/git-rebase.txt:143
#, fuzzy, priority:100
msgid "Another example of --onto option is to rebase part of a branch.  If we have the following situation:"
msgstr "--onto 选项的另一个示例是重新基点分支的一部分。 如果我们有以下情况："

#. type: delimited block -
#: en/git-rebase.txt:150
#, fuzzy, no-wrap, priority:100
msgid ""
"                            H---I---J topicB\n"
"                           /\n"
"                  E---F---G  topicA\n"
"                 /\n"
"    A---B---C---D  master\n"
msgstr ""
"                            H---I---J topicB\n"
"                           /\n"
"                  E---F---G  topicA\n"
"                 /\n"
"    A---B---C---D  master\n"

#. type: Plain text
#: en/git-rebase.txt:153 en/git-rebase.txt:176
#, priority:100
msgid "then the command"
msgstr "那么命令"

#. type: Plain text
#: en/git-rebase.txt:155
#, fuzzy, no-wrap, priority:100
msgid "    git rebase --onto master topicA topicB\n"
msgstr "    git rebase --onto master topicA topicB\n"

#. type: Plain text
#: en/git-rebase.txt:157
#, priority:100
msgid "would result in:"
msgstr "将导致 :"

#. type: delimited block -
#: en/git-rebase.txt:164
#, fuzzy, no-wrap, priority:100
msgid ""
"                 H'--I'--J'  topicB\n"
"                /\n"
"                | E---F---G  topicA\n"
"                |/\n"
"    A---B---C---D  master\n"
msgstr ""
"                 H'--I'--J'  topicB\n"
"                /\n"
"                | E---F---G  topicA\n"
"                |/\n"
"    A---B---C---D  master\n"

#. type: Plain text
#: en/git-rebase.txt:167
#, priority:100
msgid "This is useful when topicB does not depend on topicA."
msgstr "这在主题 B 不依赖于主题 A 的情况下非常有用。"

#. type: Plain text
#: en/git-rebase.txt:170
#, priority:100
msgid "A range of commits could also be removed with rebase.  If we have the following situation:"
msgstr "也可以用变基删除一系列提交。 如果我们遇到以下情况 :"

#. type: delimited block -
#: en/git-rebase.txt:173
#, no-wrap, priority:100
msgid "    E---F---G---H---I---J  topicA\n"
msgstr "    E---F---G---H---I---J  topicA\n"

#. type: Plain text
#: en/git-rebase.txt:178
#, fuzzy, no-wrap, priority:100
msgid "    git rebase --onto topicA~5 topicA~3 topicA\n"
msgstr "    git rebase --onto topicA~5 topicA~3 topicA\n"

#. type: Plain text
#: en/git-rebase.txt:180
#, priority:100
msgid "would result in the removal of commits F and G:"
msgstr "将导致删除 F 和 G 项："

#. type: delimited block -
#: en/git-rebase.txt:183
#, no-wrap, priority:100
msgid "    E---H'---I'---J'  topicA\n"
msgstr "    E---H'---I'---J'  topicA\n"

#. type: Plain text
#: en/git-rebase.txt:188
#, priority:100
msgid "This is useful if F and G were flawed in some way, or should not be part of topicA.  Note that the argument to `--onto` and the `<upstream>` parameter can be any valid commit-ish."
msgstr "如果 F 和 G 在某些方面有缺陷，或者不应该是 topicA 的一部分，这一点就很有用。 请注意，`--onto` 参数和 `<upstream>` 参数可以是任何有效的提交。"

#. type: Plain text
#: en/git-rebase.txt:194
#, priority:100
msgid "In case of conflict, `git rebase` will stop at the first problematic commit and leave conflict markers in the tree.  You can use `git diff` to locate the markers (<<<<<<) and make edits to resolve the conflict.  For each file you edit, you need to tell Git that the conflict has been resolved, typically this would be done with"
msgstr "如果出现冲突，`git rebase` 会在第一个有问题的提交处停止，并在树中留下冲突标记。 你可以用 `git diff` 找到这些标记 (<<<<<<)，并进行编辑以解决冲突。 每编辑一个文件，都需要告诉 Git 冲突已被解决，通常可以用"

#. type: Plain text
#: en/git-rebase.txt:197
#, no-wrap, priority:100
msgid "    git add <filename>\n"
msgstr "    git add <filename>\n"

#. type: Plain text
#: en/git-rebase.txt:201
#, priority:100
msgid "After resolving the conflict manually and updating the index with the desired resolution, you can continue the rebasing process with"
msgstr "手动解决冲突并以所需的分辨率更新索引后，您可以使用"

#. type: Plain text
#: en/git-rebase.txt:204
#, fuzzy, no-wrap, priority:100
msgid "    git rebase --continue\n"
msgstr "    git rebase --continue\n"

#. type: Plain text
#: en/git-rebase.txt:207
#, priority:100
msgid "Alternatively, you can undo the 'git rebase' with"
msgstr "或者，您也可以通过以下方法撤销 'git rebase' 操作"

#. type: Plain text
#: en/git-rebase.txt:210
#, fuzzy, no-wrap, priority:100
msgid "    git rebase --abort\n"
msgstr "    git rebase --abort\n"

#. type: Title -
#: en/git-rebase.txt:212
#, fuzzy, no-wrap, priority:100
#| msgid "OPTIONS"
msgid "MODE OPTIONS"
msgstr "选项"

#. type: Plain text
#: en/git-rebase.txt:216
#, priority:100
msgid "The options in this section cannot be used with any other option, including not with each other:"
msgstr "本节中的选项不能与任何其他选项一起使用，包括不能相互使用："

#. type: Plain text
#: en/git-rebase.txt:219
#, priority:100
msgid "Restart the rebasing process after having resolved a merge conflict."
msgstr "解决合并冲突后，重新启动重新分区进程。"

#. type: Plain text
#: en/git-rebase.txt:222
#, priority:100
msgid "Restart the rebasing process by skipping the current patch."
msgstr "跳过当前补丁，重新启动重新分区进程。"

#. type: Plain text
#: en/git-rebase.txt:229
#, priority:100
msgid "Abort the rebase operation and reset HEAD to the original branch. If `<branch>` was provided when the rebase operation was started, then `HEAD` will be reset to `<branch>`. Otherwise `HEAD` will be reset to where it was when the rebase operation was started."
msgstr "终止变基操作并将 HEAD 重置为原始分支。如果在启动变基操作时提供了 `<分支>`，那么 `HEAD` 将被重置为 `<分支>`。否则，`HEAD` 将被重置为启动变基操作时的位置。"

#. type: Plain text
#: en/git-rebase.txt:235
#, priority:100
msgid "Abort the rebase operation but `HEAD` is not reset back to the original branch. The index and working tree are also left unchanged as a result. If a temporary stash entry was created using `--autostash`, it will be saved to the stash list."
msgstr "放弃变基操作，但 `HEAD` 不会重置回原始分支。索引和工作树也会因此保持不变。如果使用 `--autostash` 创建了临时储藏条目，它将被保存到储藏列表中。"

#. type: Labeled list
#: en/git-rebase.txt:236
#, ignore-same, no-wrap, priority:100
msgid "--edit-todo"
msgstr "--edit-todo"

#. type: Plain text
#: en/git-rebase.txt:238
#, priority:100
msgid "Edit the todo list during an interactive rebase."
msgstr "在交互式变基过程中编辑待办事项列表。"

#. type: Labeled list
#: en/git-rebase.txt:239
#, ignore-same, no-wrap, priority:100
msgid "--show-current-patch"
msgstr "--show-current-patch"

#. type: Plain text
#: en/git-rebase.txt:243
#, priority:100
msgid "Show the current patch in an interactive rebase or when rebase is stopped because of conflicts. This is the equivalent of `git show REBASE_HEAD`."
msgstr "在交互式变基或因冲突而停止变基时显示当前补丁。相当于 `git show REBASE_HEAD`。"

#. type: Labeled list
#: en/git-rebase.txt:246
#, fuzzy, no-wrap, priority:100
msgid "--onto <newbase>"
msgstr "--onto <newbase>"

#. type: Plain text
#: en/git-rebase.txt:251
#, priority:100
msgid "Starting point at which to create the new commits. If the `--onto` option is not specified, the starting point is `<upstream>`.  May be any valid commit, and not just an existing branch name."
msgstr "创建新提交的起点。如果未指定 `--onto` 选项，则起点为 `<upstream>`。 可以是任何有效的提交，而不仅仅是现有的分支名称。"

#. type: Plain text
#: en/git-rebase.txt:255
#, ignore-ellipsis, priority:100
msgid "As a special case, you may use \"A\\...B\" as a shortcut for the merge base of A and B if there is exactly one merge base. You can leave out at most one of A and B, in which case it defaults to HEAD."
msgstr "作为一种特殊情况，如果 A 和 B 的合并库只有一个，则可以使用 \"A\\...B \"作为合并库的快捷方式。您最多可以省略 A 和 B 中的一个，在这种情况下，它默认为 HEAD。"

#. type: Labeled list
#: en/git-rebase.txt:256
#, ignore-same, no-wrap, priority:100
msgid "--keep-base"
msgstr "--keep-base"

#. type: Plain text
#: en/git-rebase.txt:262
#, ignore-ellipsis, priority:100
msgid "Set the starting point at which to create the new commits to the merge base of `<upstream>` and `<branch>`. Running `git rebase --keep-base <upstream> <branch>` is equivalent to running `git rebase --reapply-cherry-picks --no-fork-point --onto <upstream>...<branch> <upstream> <branch>`."
msgstr "将创建新提交的起点设为 `<upstream>` 和 `<branch>` 的合并库。运行 `git rebase --keep-base <upstream> <branch>` 相当于运行 `git rebase --reapply-cherry-picks --no-fork-point --onto <upstream>...<branch> <upstream> <branch>` 。"

#. type: Plain text
#: en/git-rebase.txt:269
#, priority:100
msgid "This option is useful in the case where one is developing a feature on top of an upstream branch. While the feature is being worked on, the upstream branch may advance and it may not be the best idea to keep rebasing on top of the upstream but to keep the base commit as-is. As the base commit is unchanged this option implies `--reapply-cherry-picks` to avoid losing commits."
msgstr "该选项适用于在上游分支上开发功能的情况。在开发功能的过程中，上游分支可能会前进，这时最好的办法可能不是继续在上游分支上重新加载，而是保持基本提交不变。由于基本提交保持不变，该选项意味着 `--reapply-cherry-picks`，以避免丢失提交。"

#. type: Plain text
#: en/git-rebase.txt:274
#, priority:100
msgid "Although both this option and `--fork-point` find the merge base between `<upstream>` and `<branch>`, this option uses the merge base as the _starting point_ on which new commits will be created, whereas `--fork-point` uses the merge base to determine the _set of commits_ which will be rebased."
msgstr "虽然该选项和 `-fork-point` 都能找到 `<upstream>` 和 `<branch>` 之间的合并基数，但该选项使用合并基数作为创建新提交的_起点_，而 `-fork-point`则使用合并基数来确定将被重定向的_提交集_。"

#. type: Plain text
#: en/git-rebase.txt:276 en/git-rebase.txt:291 en/git-rebase.txt:311 en/git-rebase.txt:332 en/git-rebase.txt:354 en/git-rebase.txt:362 en/git-rebase.txt:374 en/git-rebase.txt:386 en/git-rebase.txt:395 en/git-rebase.txt:437 en/git-rebase.txt:472 en/git-rebase.txt:497 en/git-rebase.txt:510 en/git-rebase.txt:517 en/git-rebase.txt:529 en/git-rebase.txt:582 en/git-rebase.txt:589 en/git-rebase.txt:609 en/git-rebase.txt:641
#, priority:100
msgid "See also INCOMPATIBLE OPTIONS below."
msgstr "另请参阅下面的不兼容选项。"

#. type: Plain text
#: en/git-rebase.txt:281
#, priority:100
msgid "Upstream branch to compare against.  May be any valid commit, not just an existing branch name. Defaults to the configured upstream for the current branch."
msgstr "要与之比较的上游分支。 可以是任何有效的提交，而不仅仅是现有的分支名称。默认为当前分支配置的上游分支。"

#. type: Plain text
#: en/git-rebase.txt:284
#, priority:100
msgid "Working branch; defaults to `HEAD`."
msgstr "工作分支；默认为 `HEAD`。"

#. type: Plain text
#: en/git-rebase.txt:289
#, priority:100
msgid "Use applying strategies to rebase (calling `git-am` internally).  This option may become a no-op in the future once the merge backend handles everything the apply one does."
msgstr "使用应用策略来变基（内部调用 `git-am`）。 一旦合并后端处理了应用后端所做的一切，这个选项将来可能就不再适用了。"

#. type: Labeled list
#: en/git-rebase.txt:292
#, fuzzy, no-wrap, priority:100
msgid "--empty={drop,keep,ask}"
msgstr "--empty={drop,keep,ask}"

#. type: Plain text
#: en/git-rebase.txt:303
#, priority:100
msgid "How to handle commits that are not empty to start and are not clean cherry-picks of any upstream commit, but which become empty after rebasing (because they contain a subset of already upstream changes).  With drop (the default), commits that become empty are dropped.  With keep, such commits are kept.  With ask (implied by `--interactive`), the rebase will halt when an empty commit is applied allowing you to choose whether to drop it, edit files more, or just commit the empty changes.  Other options, like `--exec`, will use the default of drop unless `-i`/`--interactive` is explicitly specified."
msgstr "如何处理开始时不是空的提交，也不是对上游提交的纯粹撷取，但在重排序后变为空的提交（因为它们包含了上游修改的子集）。 如果使用 drop（默认），则会丢弃变为空的提交。 如果使用 keep，则会保留此类提交。 如果使用 ask（隐含 `--interactive`），当应用空提交时，变基停止，允许你选择是丢弃它、编辑更多文件，还是只提交空改动。 其他选项，如 `--exec`，除非明确指定了 `-i`/`-interactive`，否则将使用默认的 drop。"

#. type: Plain text
#: en/git-rebase.txt:309
#, ignore-ellipsis, priority:100
msgid "Note that commits which start empty are kept (unless `--no-keep-empty` is specified), and commits which are clean cherry-picks (as determined by `git log --cherry-mark ...`) are detected and dropped as a preliminary step (unless `--reapply-cherry-picks` or `--keep-base` is passed)."
msgstr "需要注意的是，开始时为空的提交会被保留（除非指定了 `--no-keep-empty`），而干净的 cherry-picks 提交（由 `git log --cherry-mark ...`）会被检测到并作为第一步被丢弃（除非通过了 `--reapply-cherry-picks`或 `--keep-base`）。"

#. type: Plain text
#: en/git-rebase.txt:312 en/git-rebase.txt:661
#, ignore-same, no-wrap, priority:100
msgid "--no-keep-empty"
msgstr "--no-keep-empty"

#. type: Labeled list
#: en/git-rebase.txt:313
#, ignore-same, no-wrap, priority:100
msgid "--keep-empty"
msgstr "--keep-empty"

#. type: Plain text
#: en/git-rebase.txt:321
#, priority:100
msgid "Do not keep commits that start empty before the rebase (i.e. that do not change anything from its parent) in the result.  The default is to keep commits which start empty, since creating such commits requires passing the `--allow-empty` override flag to `git commit`, signifying that a user is very intentionally creating such a commit and thus wants to keep it."
msgstr "不在结果中保留重置前开始为空的提交（即不改变父提交的任何内容）。 默认情况下保留开始时为空的提交，因为创建此类提交需要向 `git commit` 传递 `--allow-empty` 覆盖标志，表明用户非常有意地创建此类提交，因此希望保留它。"

#. type: Plain text
#: en/git-rebase.txt:327
#, priority:100
msgid "Usage of this flag will probably be rare, since you can get rid of commits that start empty by just firing up an interactive rebase and removing the lines corresponding to the commits you don't want.  This flag exists as a convenient shortcut, such as for cases where external tools generate many empty commits and you want them all removed."
msgstr "使用这个标记的情况可能很少，因为你只需启动交互式变基，并删除与你不想要的提交对应的行，就能删除开始时为空的提交。 该标记是一种方便的快捷方式，比如当外部工具生成许多空提交，而你希望将它们全部删除时。"

#. type: Plain text
#: en/git-rebase.txt:330
#, priority:100
msgid "For commits which do not start empty but become empty after rebasing, see the `--empty` flag."
msgstr ""

#. type: Labeled list
#: en/git-rebase.txt:333
#, ignore-same, no-wrap, priority:100
msgid "--reapply-cherry-picks"
msgstr "--reapply-cherry-picks"

#. type: Labeled list
#: en/git-rebase.txt:334
#, ignore-same, no-wrap, priority:100
msgid "--no-reapply-cherry-picks"
msgstr "--no-reapply-cherry-picks"

#. type: Plain text
#: en/git-rebase.txt:340
#, priority:100
msgid "Reapply all clean cherry-picks of any upstream commit instead of preemptively dropping them. (If these commits then become empty after rebasing, because they contain a subset of already upstream changes, the behavior towards them is controlled by the `--empty` flag.)"
msgstr ""

#. type: Plain text
#: en/git-rebase.txt:349
#, priority:100
msgid "In the absence of `--keep-base` (or if `--no-reapply-cherry-picks` is given), these commits will be automatically dropped.  Because this necessitates reading all upstream commits, this can be expensive in repositories with a large number of upstream commits that need to be read. When using the 'merge' backend, warnings will be issued for each dropped commit (unless `--quiet` is given). Advice will also be issued unless `advice.skippedCherryPicks` is set to false (see linkgit:git-config[1])."
msgstr ""

#. type: Plain text
#: en/git-rebase.txt:352
#, priority:100
msgid "`--reapply-cherry-picks` allows rebase to forgo reading all upstream commits, potentially improving performance."
msgstr ""

#. type: Plain text
#: en/git-rebase.txt:360
#, priority:100
msgid "No-op.  Rebasing commits with an empty message used to fail and this option would override that behavior, allowing commits with empty messages to be rebased.  Now commits with an empty message do not cause rebasing to halt."
msgstr ""

#. type: Plain text
#: en/git-rebase.txt:366
#, priority:100
msgid "Using merging strategies to rebase (default)."
msgstr ""

#. type: Plain text
#: en/git-rebase.txt:372
#, priority:100
msgid "Note that a rebase merge works by replaying each commit from the working branch on top of the `<upstream>` branch.  Because of this, when a merge conflict happens, the side reported as 'ours' is the so-far rebased series, starting with `<upstream>`, and 'theirs' is the working branch.  In other words, the sides are swapped."
msgstr ""

#. type: Plain text
#: en/git-rebase.txt:379
#, priority:100
msgid "Use the given merge strategy, instead of the default `ort`.  This implies `--merge`."
msgstr ""

#. type: Plain text
#: en/git-rebase.txt:384
#, priority:100
msgid "Because `git rebase` replays each commit from the working branch on top of the `<upstream>` branch using the given strategy, using the `ours` strategy simply empties all patches from the `<branch>`, which makes little sense."
msgstr ""

#. type: Labeled list
#: en/git-rebase.txt:387
#, fuzzy, no-wrap, priority:100
msgid "-X <strategy-option>"
msgstr "-X <strategy-option>"

#. type: Labeled list
#: en/git-rebase.txt:388
#, fuzzy, no-wrap, priority:100
msgid "--strategy-option=<strategy-option>"
msgstr "--strategy-option=<strategy-option>"

#. type: Plain text
#: en/git-rebase.txt:393
#, priority:100
msgid "Pass the <strategy-option> through to the merge strategy.  This implies `--merge` and, if no strategy has been specified, `-s ort`.  Note the reversal of 'ours' and 'theirs' as noted above for the `-m` option."
msgstr ""

#. type: Plain text
#: en/git-rebase.txt:410
#, fuzzy, priority:100
msgid "Be quiet. Implies `--no-stat`."
msgstr "安静。意味着 --no-stat"

#. type: Plain text
#: en/git-rebase.txt:414
#, fuzzy, priority:100
msgid "Be verbose. Implies `--stat`."
msgstr "安静。意味着 --no-stat"

#. type: Plain text
#: en/git-rebase.txt:418
#, priority:100
msgid "Show a diffstat of what changed upstream since the last rebase. The diffstat is also controlled by the configuration option rebase.stat."
msgstr ""

#. type: Plain text
#: en/git-rebase.txt:422
#, priority:100
msgid "Do not show a diffstat as part of the rebase process."
msgstr ""

#. type: Plain text
#: en/git-rebase.txt:425
#, priority:100
msgid "This option bypasses the pre-rebase hook.  See also linkgit:githooks[5]."
msgstr ""

#. type: Labeled list
#: en/git-rebase.txt:426 en/git-rev-parse.txt:98 en/git-show-ref.txt:59 en/git-tag.txt:88
#, ignore-same, no-wrap, priority:240
msgid "--verify"
msgstr "--verify"

#. type: Plain text
#: en/git-rebase.txt:429
#, priority:100
msgid "Allows the pre-rebase hook to run, which is the default.  This option can be used to override `--no-verify`.  See also linkgit:githooks[5]."
msgstr ""

#. type: Plain text
#: en/git-rebase.txt:435
#, priority:100
msgid "Ensure at least `<n>` lines of surrounding context match before and after each change.  When fewer lines of surrounding context exist they all must match.  By default no context is ever ignored.  Implies `--apply`."
msgstr ""

#. type: Labeled list
#: en/git-rebase.txt:438 en/merge-options.txt:47 en/merge-options.txt:62
#, ignore-same, no-wrap, priority:240
msgid "--no-ff"
msgstr "--no-ff"

#. type: Labeled list
#: en/git-rebase.txt:439
#, ignore-same, no-wrap, priority:100
msgid "--force-rebase"
msgstr "--force-rebase"

#. type: Plain text
#: en/git-rebase.txt:444
#, priority:100
msgid "Individually replay all rebased commits instead of fast-forwarding over the unchanged ones.  This ensures that the entire history of the rebased branch is composed of new commits."
msgstr ""

#. type: Plain text
#: en/git-rebase.txt:450
#, priority:100
msgid "You may find this helpful after reverting a topic branch merge, as this option recreates the topic branch with fresh commits so it can be remerged successfully without needing to \"revert the reversion\" (see the link:howto/revert-a-faulty-merge.html[revert-a-faulty-merge How-To] for details)."
msgstr ""

#. type: Labeled list
#: en/git-rebase.txt:452
#, ignore-same, no-wrap, priority:100
msgid "--no-fork-point"
msgstr "--no-fork-point"

#. type: Plain text
#: en/git-rebase.txt:456
#, priority:100
msgid "Use reflog to find a better common ancestor between `<upstream>` and `<branch>` when calculating which commits have been introduced by `<branch>`."
msgstr ""

#. type: Plain text
#: en/git-rebase.txt:462
#, priority:100
msgid "When `--fork-point` is active, 'fork_point' will be used instead of `<upstream>` to calculate the set of commits to rebase, where 'fork_point' is the result of `git merge-base --fork-point <upstream> <branch>` command (see linkgit:git-merge-base[1]).  If 'fork_point' ends up being empty, the `<upstream>` will be used as a fallback."
msgstr ""

#. type: Plain text
#: en/git-rebase.txt:466
#, priority:100
msgid "If `<upstream>` or `--keep-base` is given on the command line, then the default is `--no-fork-point`, otherwise the default is `--fork-point`. See also `rebase.forkpoint` in linkgit:git-config[1]."
msgstr ""

#. type: Plain text
#: en/git-rebase.txt:470
#, priority:100
msgid "If your branch was based on `<upstream>` but `<upstream>` was rewound and your branch contains commits which were dropped, this option can be used with `--keep-base` in order to drop those commits from your branch."
msgstr ""

#. type: Plain text
#: en/git-rebase.txt:477
#, priority:100
msgid "Ignore whitespace differences when trying to reconcile differences. Currently, each backend implements an approximation of this behavior:"
msgstr ""

#. type: Labeled list
#: en/git-rebase.txt:478
#, no-wrap, priority:100
msgid "apply backend"
msgstr ""

#. type: Plain text
#: en/git-rebase.txt:484
#, priority:100
msgid "When applying a patch, ignore changes in whitespace in context lines. Unfortunately, this means that if the \"old\" lines being replaced by the patch differ only in whitespace from the existing file, you will get a merge conflict instead of a successful patch application."
msgstr ""

#. type: Labeled list
#: en/git-rebase.txt:485
#, fuzzy, no-wrap, priority:100
#| msgid "--merge-base"
msgid "merge backend"
msgstr "--merge-base"

#. type: Plain text
#: en/git-rebase.txt:490
#, priority:100
msgid "Treat lines with only whitespace changes as unchanged when merging.  Unfortunately, this means that any patch hunks that were intended to modify whitespace and nothing else will be dropped, even if the other side had no changes that conflicted."
msgstr ""

#. type: Plain text
#: en/git-rebase.txt:495
#, priority:100
msgid "This flag is passed to the `git apply` program (see linkgit:git-apply[1]) that applies the patch.  Implies `--apply`."
msgstr ""

#. type: Plain text
#: en/git-rebase.txt:502
#, priority:100
msgid "Instead of using the current time as the committer date, use the author date of the commit being rebased as the committer date. This option implies `--force-rebase`."
msgstr ""

#. type: Labeled list
#: en/git-rebase.txt:504
#, ignore-same, no-wrap, priority:100
msgid "--reset-author-date"
msgstr "--reset-author-date"

#. type: Plain text
#: en/git-rebase.txt:508
#, priority:100
msgid "Instead of using the author date of the original commit, use the current time as the\tauthor date of the rebased commit.  This option implies `--force-rebase`."
msgstr ""

#. type: Plain text
#: en/git-rebase.txt:515
#, priority:100
msgid "Add a `Signed-off-by` trailer to all the rebased commits. Note that if `--interactive` is given then only commits marked to be picked, edited or reworded will have the trailer added."
msgstr ""

#. type: Plain text
#: en/git-rebase.txt:523
#, priority:100
msgid "Make a list of the commits which are about to be rebased.  Let the user edit that list before rebasing.  This mode can also be used to split commits (see SPLITTING COMMITS below)."
msgstr ""

#. type: Plain text
#: en/git-rebase.txt:527
#, priority:100
msgid "The commit list format can be changed by setting the configuration option rebase.instructionFormat.  A customized instruction format will automatically have the long commit hash prepended to the format."
msgstr ""

#. type: Labeled list
#: en/git-rebase.txt:531
#, fuzzy, no-wrap, priority:100
msgid "--rebase-merges[=(rebase-cousins|no-rebase-cousins)]"
msgstr "--rebase-merges[=(rebase-cousins|no-rebase-cousins)]"

#. type: Labeled list
#: en/git-rebase.txt:532
#, ignore-same, no-wrap, priority:100
msgid "--no-rebase-merges"
msgstr "--no-rebase-merges"

#. type: Plain text
#: en/git-rebase.txt:542
#, priority:100
msgid "By default, a rebase will simply drop merge commits from the todo list, and put the rebased commits into a single, linear branch.  With `--rebase-merges`, the rebase will instead try to preserve the branching structure within the commits that are to be rebased, by recreating the merge commits. Any resolved merge conflicts or manual amendments in these merge commits will have to be resolved/re-applied manually. `--no-rebase-merges` can be used to countermand both the `rebase.rebaseMerges` config option and a previous `--rebase-merges`."
msgstr ""

#. type: Plain text
#: en/git-rebase.txt:551
#, priority:100
msgid "When rebasing merges, there are two modes: `rebase-cousins` and `no-rebase-cousins`. If the mode is not specified, it defaults to `no-rebase-cousins`. In `no-rebase-cousins` mode, commits which do not have `<upstream>` as direct ancestor will keep their original branch point, i.e.  commits that would be excluded by linkgit:git-log[1]'s `--ancestry-path` option will keep their original ancestry by default. In `rebase-cousins` mode, such commits are instead rebased onto `<upstream>` (or `<onto>`, if specified)."
msgstr ""

#. type: Plain text
#: en/git-rebase.txt:555
#, ignore-ellipsis, priority:100
msgid "It is currently only possible to recreate the merge commits using the `ort` merge strategy; different merge strategies can be used only via explicit `exec git merge -s <strategy> [...]` commands."
msgstr ""

#. type: Plain text
#: en/git-rebase.txt:557
#, priority:100
msgid "See also REBASING MERGES and INCOMPATIBLE OPTIONS below."
msgstr ""

#. type: Labeled list
#: en/git-rebase.txt:558
#, no-wrap, priority:100
msgid "-x <cmd>"
msgstr ""

#. type: Labeled list
#: en/git-rebase.txt:559
#, fuzzy, no-wrap, priority:100
msgid "--exec <cmd>"
msgstr "--exec <cmd>"

#. type: Plain text
#: en/git-rebase.txt:564
#, priority:100
msgid "Append \"exec <cmd>\" after each line creating a commit in the final history. `<cmd>` will be interpreted as one or more shell commands. Any command that fails will interrupt the rebase, with exit code 1."
msgstr ""

#. type: Plain text
#: en/git-rebase.txt:567
#, priority:100
msgid "You may execute several commands by either using one instance of `--exec` with several commands:"
msgstr ""

#. type: Plain text
#: en/git-rebase.txt:569
#, fuzzy, ignore-ellipsis, no-wrap, priority:100
msgid "\tgit rebase -i --exec \"cmd1 && cmd2 && ...\"\n"
msgstr "\tgit rebase -i --exec \"cmd1 && cmd2 && ...\"\n"

#. type: Plain text
#: en/git-rebase.txt:571
#, priority:100
msgid "or by giving more than one `--exec`:"
msgstr ""

#. type: Plain text
#: en/git-rebase.txt:573
#, fuzzy, ignore-ellipsis, no-wrap, priority:100
msgid "\tgit rebase -i --exec \"cmd1\" --exec \"cmd2\" --exec ...\n"
msgstr "\tgit rebase -i --exec \"cmd1\" --exec \"cmd2\" --exec ...\n"

#. type: Plain text
#: en/git-rebase.txt:577
#, priority:100
msgid "If `--autosquash` is used, `exec` lines will not be appended for the intermediate commits, and will only appear at the end of each squash/fixup series."
msgstr ""

#. type: Plain text
#: en/git-rebase.txt:580
#, priority:100
msgid "This uses the `--interactive` machinery internally, but it can be run without an explicit `--interactive`."
msgstr ""

#. type: Plain text
#: en/git-rebase.txt:587
#, priority:100
msgid "Rebase all commits reachable from `<branch>`, instead of limiting them with an `<upstream>`.  This allows you to rebase the root commit(s) on a branch."
msgstr ""

#. type: Plain text
#: en/git-rebase.txt:590 en/git-rebase.txt:657
#, ignore-same, no-wrap, priority:100
msgid "--autosquash"
msgstr "--autosquash"

#. type: Labeled list
#: en/git-rebase.txt:591
#, ignore-same, no-wrap, priority:100
msgid "--no-autosquash"
msgstr "--no-autosquash"

#. type: Plain text
#: en/git-rebase.txt:603
#, ignore-ellipsis, priority:100
msgid "When the commit log message begins with \"squash! ...\" or \"fixup! ...\" or \"amend! ...\", and there is already a commit in the todo list that matches the same `...`, automatically modify the todo list of `rebase -i`, so that the commit marked for squashing comes right after the commit to be modified, and change the action of the moved commit from `pick` to `squash` or `fixup` or `fixup -C` respectively. A commit matches the `...` if the commit subject matches, or if the `...` refers to the commit's hash. As a fall-back, partial matches of the commit subject work, too. The recommended way to create fixup/amend/squash commits is by using the `--fixup`, `--fixup=amend:` or `--fixup=reword:` and `--squash` options respectively of linkgit:git-commit[1]."
msgstr ""

#. type: Plain text
#: en/git-rebase.txt:607
#, priority:100
msgid "If the `--autosquash` option is enabled by default using the configuration variable `rebase.autoSquash`, this option can be used to override and disable this setting."
msgstr ""

#. type: Labeled list
#: en/git-rebase.txt:610 en/merge-options.txt:191
#, ignore-same, no-wrap, priority:240
msgid "--autostash"
msgstr "--autostash"

#. type: Labeled list
#: en/git-rebase.txt:611 en/merge-options.txt:192
#, ignore-same, no-wrap, priority:240
msgid "--no-autostash"
msgstr "--no-autostash"

#. type: Plain text
#: en/git-rebase.txt:617
#, priority:100
msgid "Automatically create a temporary stash entry before the operation begins, and apply it after the operation ends.  This means that you can run rebase on a dirty worktree.  However, use with care: the final stash application after a successful rebase might result in non-trivial conflicts."
msgstr ""

#. type: Labeled list
#: en/git-rebase.txt:618
#, ignore-same, no-wrap, priority:100
msgid "--reschedule-failed-exec"
msgstr "--reschedule-failed-exec"

#. type: Labeled list
#: en/git-rebase.txt:619
#, ignore-same, no-wrap, priority:100
msgid "--no-reschedule-failed-exec"
msgstr "--no-reschedule-failed-exec"

#. type: Plain text
#: en/git-rebase.txt:622
#, priority:100
msgid "Automatically reschedule `exec` commands that failed. This only makes sense in interactive mode (or when an `--exec` option was provided)."
msgstr ""

#. type: Plain text
#: en/git-rebase.txt:630
#, priority:100
msgid "Even though this option applies once a rebase is started, it's set for the whole rebase at the start based on either the `rebase.rescheduleFailedExec` configuration (see linkgit:git-config[1] or \"CONFIGURATION\" below) or whether this option is provided. Otherwise an explicit `--no-reschedule-failed-exec` at the start would be overridden by the presence of `rebase.rescheduleFailedExec=true` configuration."
msgstr ""

#. type: Plain text
#: en/git-rebase.txt:631 en/git-rebase.txt:664
#, ignore-same, no-wrap, priority:100
msgid "--update-refs"
msgstr "--update-refs"

#. type: Labeled list
#: en/git-rebase.txt:632
#, ignore-same, no-wrap, priority:100
msgid "--no-update-refs"
msgstr "--no-update-refs"

#. type: Plain text
#: en/git-rebase.txt:636
#, priority:100
msgid "Automatically force-update any branches that point to commits that are being rebased. Any branches that are checked out in a worktree are not updated in this way."
msgstr ""

#. type: Plain text
#: en/git-rebase.txt:639
#, priority:100
msgid "If the configuration variable `rebase.updateRefs` is set, then this option can be used to override and disable this setting."
msgstr ""

#. type: Title -
#: en/git-rebase.txt:643
#, no-wrap, priority:100
msgid "INCOMPATIBLE OPTIONS"
msgstr ""

#. type: Plain text
#: en/git-rebase.txt:646
#, priority:100
msgid "The following options:"
msgstr ""

#. type: Plain text
#: en/git-rebase.txt:649
#, ignore-same, priority:100
msgid "--whitespace"
msgstr "--whitespace"

#. type: Plain text
#: en/git-rebase.txt:652
#, priority:100
msgid "are incompatible with the following options:"
msgstr ""

#. type: Plain text
#: en/git-rebase.txt:655
#, ignore-same, priority:100
msgid "--strategy"
msgstr "--strategy"

#. type: Plain text
#: en/git-rebase.txt:656
#, ignore-same, priority:100
msgid "--strategy-option"
msgstr "--strategy-option"

#. type: Labeled list
#: en/git-rebase.txt:658 en/git-svn.txt:680
#, ignore-same, no-wrap, priority:100
msgid "--rebase-merges"
msgstr "--rebase-merges"

#. type: Plain text
#: en/git-rebase.txt:660
#, ignore-same, priority:100
msgid "--exec"
msgstr "--exec"

#. type: Plain text
#: en/git-rebase.txt:662
#, fuzzy, priority:100
#| msgid "--empty"
msgid "--empty="
msgstr "--empty"

#. type: Plain text
#: en/git-rebase.txt:663
#, fuzzy, priority:100
#| msgid "--no-reapply-cherry-picks"
msgid "--[no-]reapply-cherry-picks when used without --keep-base"
msgstr "--no-reapply-cherry-picks"

#. type: Plain text
#: en/git-rebase.txt:665
#, fuzzy, priority:100
msgid "--root when used without --onto"
msgstr "--root when used in combination with --onto"

#. type: Plain text
#: en/git-rebase.txt:667
#, priority:100
msgid "In addition, the following pairs of options are incompatible:"
msgstr ""

#. type: Plain text
#: en/git-rebase.txt:669
#, fuzzy, priority:100
msgid "--keep-base and --onto"
msgstr "--keep-base and --onto"

#. type: Plain text
#: en/git-rebase.txt:670
#, fuzzy, priority:100
msgid "--keep-base and --root"
msgstr "--keep-base and --root"

#. type: Plain text
#: en/git-rebase.txt:671
#, fuzzy, priority:100
#| msgid "--fork-point"
msgid "--fork-point and --root"
msgstr "--fork-point and --root"

#. type: Title -
#: en/git-rebase.txt:673
#, no-wrap, priority:100
msgid "BEHAVIORAL DIFFERENCES"
msgstr ""

#. type: Plain text
#: en/git-rebase.txt:682
#, priority:100
msgid "`git rebase` has two primary backends: 'apply' and 'merge'.  (The 'apply' backend used to be known as the 'am' backend, but the name led to confusion as it looks like a verb instead of a noun.  Also, the 'merge' backend used to be known as the interactive backend, but it is now used for non-interactive cases as well.  Both were renamed based on lower-level functionality that underpinned each.) There are some subtle differences in how these two backends behave:"
msgstr ""

#. type: Title ~
#: en/git-rebase.txt:684
#, fuzzy, no-wrap, priority:100
msgid "Empty commits"
msgstr "Empty commits"

#. type: Plain text
#: en/git-rebase.txt:690
#, priority:100
msgid "The 'apply' backend unfortunately drops intentionally empty commits, i.e.  commits that started empty, though these are rare in practice.  It also drops commits that become empty and has no option for controlling this behavior."
msgstr ""

#. type: Plain text
#: en/git-rebase.txt:694
#, priority:100
msgid "The 'merge' backend keeps intentionally empty commits by default (though with `-i` they are marked as empty in the todo list editor, or they can be dropped automatically with `--no-keep-empty`)."
msgstr ""

#. type: Plain text
#: en/git-rebase.txt:700
#, priority:100
msgid "Similar to the apply backend, by default the merge backend drops commits that become empty unless `-i`/`--interactive` is specified (in which case it stops and asks the user what to do).  The merge backend also has an `--empty={drop,keep,ask}` option for changing the behavior of handling commits that become empty."
msgstr ""

#. type: Title ~
#: en/git-rebase.txt:702
#, no-wrap, priority:100
msgid "Directory rename detection"
msgstr ""

#. type: Plain text
#: en/git-rebase.txt:712
#, priority:100
msgid "Due to the lack of accurate tree information (arising from constructing fake ancestors with the limited information available in patches), directory rename detection is disabled in the 'apply' backend.  Disabled directory rename detection means that if one side of history renames a directory and the other adds new files to the old directory, then the new files will be left behind in the old directory without any warning at the time of rebasing that you may want to move these files into the new directory."
msgstr ""

#. type: Plain text
#: en/git-rebase.txt:715
#, priority:100
msgid "Directory rename detection works with the 'merge' backend to provide you warnings in such cases."
msgstr ""

#. type: Title ~
#: en/git-rebase.txt:717
#, fuzzy, no-wrap, priority:100
#| msgid "--text"
msgid "Context"
msgstr "--text"

#. type: Plain text
#: en/git-rebase.txt:733
#, priority:100
msgid "The 'apply' backend works by creating a sequence of patches (by calling `format-patch` internally), and then applying the patches in sequence (calling `am` internally).  Patches are composed of multiple hunks, each with line numbers, a context region, and the actual changes.  The line numbers have to be taken with some fuzz, since the other side will likely have inserted or deleted lines earlier in the file.  The context region is meant to help find how to adjust the line numbers in order to apply the changes to the right lines.  However, if multiple areas of the code have the same surrounding lines of context, the wrong one can be picked.  There are real-world cases where this has caused commits to be reapplied incorrectly with no conflicts reported.  Setting `diff.context` to a larger value may prevent such types of problems, but increases the chance of spurious conflicts (since it will require more lines of matching context to apply)."
msgstr ""

#. type: Plain text
#: en/git-rebase.txt:736
#, priority:100
msgid "The 'merge' backend works with a full copy of each relevant file, insulating it from these types of problems."
msgstr ""

#. type: Title ~
#: en/git-rebase.txt:738
#, fuzzy, no-wrap, priority:100
msgid "Labelling of conflicts markers"
msgstr "pos clock name ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"

#. type: Plain text
#: en/git-rebase.txt:750
#, priority:100
msgid "When there are content conflicts, the merge machinery tries to annotate each side's conflict markers with the commits where the content came from.  Since the 'apply' backend drops the original information about the rebased commits and their parents (and instead generates new fake commits based off limited information in the generated patches), those commits cannot be identified; instead it has to fall back to a commit summary.  Also, when `merge.conflictStyle` is set to `diff3` or `zdiff3`, the 'apply' backend will use \"constructed merge base\" to label the content from the merge base, and thus provide no information about the merge base commit whatsoever."
msgstr ""

#. type: Plain text
#: en/git-rebase.txt:753
#, priority:100
msgid "The 'merge' backend works with the full commits on both sides of history and thus has no such limitations."
msgstr ""

#. type: Title ~
#: en/git-rebase.txt:755
#, fuzzy, no-wrap, priority:100
msgid "Hooks"
msgstr "钩子"

#. type: Plain text
#: en/git-rebase.txt:769
#, priority:100
msgid "The 'apply' backend has not traditionally called the post-commit hook, while the 'merge' backend has.  Both have called the post-checkout hook, though the 'merge' backend has squelched its output.  Further, both backends only call the post-checkout hook with the starting point commit of the rebase, not the intermediate commits nor the final commit.  In each case, the calling of these hooks was by accident of implementation rather than by design (both backends were originally implemented as shell scripts and happened to invoke other commands like `git checkout` or `git commit` that would call the hooks).  Both backends should have the same behavior, though it is not entirely clear which, if any, is correct.  We will likely make rebase stop calling either of these hooks in the future."
msgstr ""

#. type: Title ~
#: en/git-rebase.txt:771
#, no-wrap, priority:100
msgid "Interruptability"
msgstr ""

#. type: Plain text
#: en/git-rebase.txt:780
#, priority:100
msgid "The 'apply' backend has safety problems with an ill-timed interrupt; if the user presses Ctrl-C at the wrong time to try to abort the rebase, the rebase can enter a state where it cannot be aborted with a subsequent `git rebase --abort`.  The 'merge' backend does not appear to suffer from the same shortcoming.  (See https://lore.kernel.org/git/20200207132152.GC2868@szeder.dev/ for details.)"
msgstr ""

#. type: Title ~
#: en/git-rebase.txt:782
#, no-wrap, priority:100
msgid "Commit Rewording"
msgstr ""

#. type: Plain text
#: en/git-rebase.txt:790
#, priority:100
msgid "When a conflict occurs while rebasing, rebase stops and asks the user to resolve.  Since the user may need to make notable changes while resolving conflicts, after conflicts are resolved and the user has run `git rebase --continue`, the rebase should open an editor and ask the user to update the commit message.  The 'merge' backend does this, while the 'apply' backend blindly applies the original commit message."
msgstr ""

#. type: Title ~
#: en/git-rebase.txt:792
#, no-wrap, priority:100
msgid "Miscellaneous differences"
msgstr ""

#. type: Plain text
#: en/git-rebase.txt:797
#, priority:100
msgid "There are a few more behavioral differences that most folks would probably consider inconsequential but which are mentioned for completeness:"
msgstr ""

#. type: Plain text
#: en/git-rebase.txt:801
#, priority:100
msgid "Reflog: The two backends will use different wording when describing the changes made in the reflog, though both will make use of the word \"rebase\"."
msgstr ""

#. type: Plain text
#: en/git-rebase.txt:807
#, ignore-ellipsis, priority:100
msgid "Progress, informational, and error messages: The two backends provide slightly different progress and informational messages.  Also, the apply backend writes error messages (such as \"Your files would be overwritten...\") to stdout, while the merge backend writes them to stderr."
msgstr ""

#. type: Plain text
#: en/git-rebase.txt:810
#, priority:100
msgid "State directories: The two backends keep their state in different directories under `.git/`"
msgstr ""

#. type: Plain text
#: en/git-rebase.txt:819
#, fuzzy, priority:100
#| msgid "You should understand the implications of rewriting history if you amend a commit that has already been published.  (See the \"RECOVERING FROM UPSTREAM REBASE\" section in linkgit:git-rebase[1].)"
msgid "You should understand the implications of using `git rebase` on a repository that you share.  See also RECOVERING FROM UPSTREAM REBASE below."
msgstr "如果你修改了一个已经发布的提交，你应该明白重写历史的意义。  参见 linkgit:git-rebase[1]中的 \"RECOVERING FROM UPSTREAM REBASE\" 部分）。"

#. type: Plain text
#: en/git-rebase.txt:824
#, priority:100
msgid "When the rebase is run, it will first execute a `pre-rebase` hook if one exists.  You can use this hook to do sanity checks and reject the rebase if it isn't appropriate.  Please see the template `pre-rebase` hook script for an example."
msgstr ""

#. type: Plain text
#: en/git-rebase.txt:826
#, priority:100
msgid "Upon completion, `<branch>` will be the current branch."
msgstr ""

#. type: Plain text
#: en/git-rebase.txt:833
#, priority:100
msgid "Rebasing interactively means that you have a chance to edit the commits which are rebased.  You can reorder the commits, and you can remove them (weeding out bad or otherwise unwanted patches)."
msgstr ""

#. type: Plain text
#: en/git-rebase.txt:835
#, priority:100
msgid "The interactive mode is meant for this type of workflow:"
msgstr ""

#. type: Plain text
#: en/git-rebase.txt:837
#, priority:100
msgid "have a wonderful idea"
msgstr ""

#. type: Plain text
#: en/git-rebase.txt:838
#, priority:100
msgid "hack on the code"
msgstr ""

#. type: Plain text
#: en/git-rebase.txt:839
#, priority:100
msgid "prepare a series for submission"
msgstr ""

#. type: Plain text
#: en/git-rebase.txt:840
#, fuzzy, priority:100
msgid "submit"
msgstr "提交"

#. type: Plain text
#: en/git-rebase.txt:842
#, priority:100
msgid "where point 2. consists of several instances of"
msgstr ""

#. type: Plain text
#: en/git-rebase.txt:844
#, priority:100
msgid "regular use"
msgstr ""

#. type: Plain text
#: en/git-rebase.txt:846
#, priority:100
msgid "finish something worthy of a commit"
msgstr ""

#. type: Labeled list
#: en/git-rebase.txt:847 en/git-update-ref.txt:136
#, fuzzy, no-wrap, priority:100
msgid "commit"
msgstr "提交"

#. type: Plain text
#: en/git-rebase.txt:849
#, priority:100
msgid "independent fixup"
msgstr ""

#. type: Plain text
#: en/git-rebase.txt:851
#, priority:100
msgid "realize that something does not work"
msgstr ""

#. type: Plain text
#: en/git-rebase.txt:852
#, fuzzy, priority:100
msgid "fix that"
msgstr "fix that"

#. type: Plain text
#: en/git-rebase.txt:853
#, priority:100
msgid "commit it"
msgstr ""

#. type: Plain text
#: en/git-rebase.txt:859
#, priority:100
msgid "Sometimes the thing fixed in b.2. cannot be amended to the not-quite perfect commit it fixes, because that commit is buried deeply in a patch series.  That is exactly what interactive rebase is for: use it after plenty of \"a\"s and \"b\"s, by rearranging and editing commits, and squashing multiple commits into one."
msgstr ""

#. type: Plain text
#: en/git-rebase.txt:861
#, priority:100
msgid "Start it with the last commit you want to retain as-is:"
msgstr ""

#. type: Plain text
#: en/git-rebase.txt:863
#, fuzzy, no-wrap, priority:100
msgid "\tgit rebase -i <after-this-commit>\n"
msgstr "\tgit rebase -i <after-this-commit>\n"

#. type: Plain text
#: en/git-rebase.txt:868
#, priority:100
msgid "An editor will be fired up with all the commits in your current branch (ignoring merge commits), which come after the given commit.  You can reorder the commits in this list to your heart's content, and you can remove them.  The list looks more or less like this:"
msgstr ""

#. type: delimited block -
#: en/git-rebase.txt:873
#, ignore-ellipsis, no-wrap, priority:100
msgid ""
"pick deadbee The oneline of this commit\n"
"pick fa1afe1 The oneline of the next commit\n"
"...\n"
msgstr ""

#. type: Plain text
#: en/git-rebase.txt:878
#, priority:100
msgid "The oneline descriptions are purely for your pleasure; 'git rebase' will not look at them but at the commit names (\"deadbee\" and \"fa1afe1\" in this example), so do not delete or edit the names."
msgstr ""

#. type: Plain text
#: en/git-rebase.txt:883
#, priority:100
msgid "By replacing the command \"pick\" with the command \"edit\", you can tell `git rebase` to stop after applying that commit, so that you can edit the files and/or the commit message, amend the commit, and continue rebasing."
msgstr ""

#. type: Plain text
#: en/git-rebase.txt:886
#, priority:100
msgid "To interrupt the rebase (just like an \"edit\" command would do, but without cherry-picking any commit first), use the \"break\" command."
msgstr ""

#. type: Plain text
#: en/git-rebase.txt:889
#, priority:100
msgid "If you just want to edit the commit message for a commit, replace the command \"pick\" with the command \"reword\"."
msgstr ""

#. type: Plain text
#: en/git-rebase.txt:892
#, priority:100
msgid "To drop a commit, replace the command \"pick\" with \"drop\", or just delete the matching line."
msgstr ""

#. type: Plain text
#: en/git-rebase.txt:907
#, priority:100
msgid "If you want to fold two or more commits into one, replace the command \"pick\" for the second and subsequent commits with \"squash\" or \"fixup\".  If the commits had different authors, the folded commit will be attributed to the author of the first commit.  The suggested commit message for the folded commit is the concatenation of the first commit's message with those identified by \"squash\" commands, omitting the messages of commits identified by \"fixup\" commands, unless \"fixup -c\" is used.  In that case the suggested commit message is only the message of the \"fixup -c\" commit, and an editor is opened allowing you to edit the message.  The contents (patch) of the \"fixup -c\" commit are still incorporated into the folded commit. If there is more than one \"fixup -c\" commit, the message from the final one is used.  You can also use \"fixup -C\" to get the same behavior as \"fixup -c\" except without opening an editor."
msgstr ""

#. type: Plain text
#: en/git-rebase.txt:911
#, priority:100
msgid "`git rebase` will stop when \"pick\" has been replaced with \"edit\" or when a command fails due to merge errors. When you are done editing and/or resolving conflicts you can continue with `git rebase --continue`."
msgstr ""

#. type: Plain text
#: en/git-rebase.txt:915
#, priority:100
msgid "For example, if you want to reorder the last 5 commits, such that what was `HEAD~4` becomes the new `HEAD`. To achieve that, you would call `git rebase` like this:"
msgstr ""

#. type: delimited block -
#: en/git-rebase.txt:918
#, fuzzy, no-wrap, priority:100
msgid "$ git rebase -i HEAD~5\n"
msgstr "$ git rebase -i HEAD~5\n"

#. type: Plain text
#: en/git-rebase.txt:921
#, priority:100
msgid "And move the first patch to the end of the list."
msgstr ""

#. type: Plain text
#: en/git-rebase.txt:924
#, priority:100
msgid "You might want to recreate merge commits, e.g. if you have a history like this:"
msgstr ""

#. type: delimited block -
#: en/git-rebase.txt:931
#, fuzzy, no-wrap, priority:100
msgid ""
"           X\n"
"            \\\n"
"         A---M---B\n"
"        /\n"
"---o---O---P---Q\n"
msgstr ""
"           X\n"
"            \\\n"
"         A---M---B\n"
"        /\n"
"---o---O---P---Q\n"

#. type: Plain text
#: en/git-rebase.txt:935
#, priority:100
msgid "Suppose you want to rebase the side branch starting at \"A\" to \"Q\". Make sure that the current `HEAD` is \"B\", and call"
msgstr ""

#. type: delimited block -
#: en/git-rebase.txt:938
#, fuzzy, no-wrap, priority:100
msgid "$ git rebase -i -r --onto Q O\n"
msgstr "$ git rebase -i -r --onto Q O\n"

#. type: Plain text
#: en/git-rebase.txt:945
#, priority:100
msgid "Reordering and editing commits usually creates untested intermediate steps.  You may want to check that your history editing did not break anything by running a test, or at least recompiling at intermediate points in history by using the \"exec\" command (shortcut \"x\").  You may do so by creating a todo list like this one:"
msgstr ""

#. type: delimited block -
#: en/git-rebase.txt:954
#, ignore-ellipsis, no-wrap, priority:100
msgid ""
"pick deadbee Implement feature XXX\n"
"fixup f1a5c00 Fix to feature XXX\n"
"exec make\n"
"pick c0ffeee The oneline of the next commit\n"
"edit deadbab The oneline of the commit after\n"
"exec cd subdir; make test\n"
"...\n"
msgstr ""

#. type: Plain text
#: en/git-rebase.txt:959
#, priority:100
msgid "The interactive rebase will stop when a command fails (i.e. exits with non-0 status) to give you an opportunity to fix the problem. You can continue with `git rebase --continue`."
msgstr ""

#. type: Plain text
#: en/git-rebase.txt:964
#, ignore-ellipsis, priority:100
msgid "The \"exec\" command launches the command in a shell (the one specified in `$SHELL`, or the default shell if `$SHELL` is not set), so you can use shell features (like \"cd\", \">\", \";\" ...). The command is run from the root of the working tree."
msgstr ""

#. type: delimited block -
#: en/git-rebase.txt:967
#, fuzzy, no-wrap, priority:100
msgid "$ git rebase -i --exec \"make test\"\n"
msgstr "$ git rebase -i --exec \"make test\"\n"

#. type: Plain text
#: en/git-rebase.txt:971
#, priority:100
msgid "This command lets you check that intermediate commits are compilable.  The todo list becomes like that:"
msgstr ""

#. type: delimited block -
#: en/git-rebase.txt:981
#, no-wrap, priority:100
msgid ""
"pick 5928aea one\n"
"exec make test\n"
"pick 04d0fda two\n"
"exec make test\n"
"pick ba46169 three\n"
"exec make test\n"
"pick f4593f9 four\n"
"exec make test\n"
msgstr ""

#. type: Title -
#: en/git-rebase.txt:984
#, no-wrap, priority:100
msgid "SPLITTING COMMITS"
msgstr ""

#. type: Plain text
#: en/git-rebase.txt:990
#, priority:100
msgid "In interactive mode, you can mark commits with the action \"edit\".  However, this does not necessarily mean that `git rebase` expects the result of this edit to be exactly one commit.  Indeed, you can undo the commit, or you can add other commits.  This can be used to split a commit into two:"
msgstr ""

#. type: Plain text
#: en/git-rebase.txt:994
#, priority:100
msgid "Start an interactive rebase with `git rebase -i <commit>^`, where `<commit>` is the commit you want to split.  In fact, any commit range will do, as long as it contains that commit."
msgstr ""

#. type: Plain text
#: en/git-rebase.txt:996
#, priority:100
msgid "Mark the commit you want to split with the action \"edit\"."
msgstr ""

#. type: Plain text
#: en/git-rebase.txt:1000
#, priority:100
msgid "When it comes to editing that commit, execute `git reset HEAD^`.  The effect is that the `HEAD` is rewound by one, and the index follows suit.  However, the working tree stays the same."
msgstr ""

#. type: Plain text
#: en/git-rebase.txt:1004
#, priority:100
msgid "Now add the changes to the index that you want to have in the first commit.  You can use `git add` (possibly interactively) or `git gui` (or both) to do that."
msgstr ""

#. type: Plain text
#: en/git-rebase.txt:1007
#, priority:100
msgid "Commit the now-current index with whatever commit message is appropriate now."
msgstr ""

#. type: Plain text
#: en/git-rebase.txt:1009
#, priority:100
msgid "Repeat the last two steps until your working tree is clean."
msgstr ""

#. type: Plain text
#: en/git-rebase.txt:1011
#, priority:100
msgid "Continue the rebase with `git rebase --continue`."
msgstr ""

#. type: Plain text
#: en/git-rebase.txt:1016
#, priority:100
msgid "If you are not absolutely sure that the intermediate revisions are consistent (they compile, pass the testsuite, etc.) you should use `git stash` to stash away the not-yet-committed changes after each commit, test, and amend the commit if fixes are necessary."
msgstr ""

#. type: Title -
#: en/git-rebase.txt:1019
#, no-wrap, priority:100
msgid "RECOVERING FROM UPSTREAM REBASE"
msgstr ""

#. type: Plain text
#: en/git-rebase.txt:1026
#, priority:100
msgid "Rebasing (or any other form of rewriting) a branch that others have based work on is a bad idea: anyone downstream of it is forced to manually fix their history.  This section explains how to do the fix from the downstream's point of view.  The real fix, however, would be to avoid rebasing the upstream in the first place."
msgstr ""

#. type: Plain text
#: en/git-rebase.txt:1031
#, priority:100
msgid "To illustrate, suppose you are in a situation where someone develops a 'subsystem' branch, and you are working on a 'topic' that is dependent on this 'subsystem'.  You might end up with a history like the following:"
msgstr ""

#. type: delimited block -
#: en/git-rebase.txt:1038
#, fuzzy, no-wrap, priority:100
msgid ""
"    o---o---o---o---o---o---o---o  master\n"
"\t \\\n"
"\t  o---o---o---o---o  subsystem\n"
"\t\t\t   \\\n"
"\t\t\t    *---*---*  topic\n"
msgstr ""
"    o---o---o---o---o---o---o---o  master\n"
"\t \\\n"
"\t  o---o---o---o---o  subsystem\n"
"\t\t\t   \\\n"
"\t\t\t    *---*---*  topic\n"

#. type: Plain text
#: en/git-rebase.txt:1041
#, priority:100
msgid "If 'subsystem' is rebased against 'master', the following happens:"
msgstr ""

#. type: delimited block -
#: en/git-rebase.txt:1048
#, fuzzy, no-wrap, priority:100
msgid ""
"    o---o---o---o---o---o---o---o  master\n"
"\t \\\t\t\t \\\n"
"\t  o---o---o---o---o\t  o'--o'--o'--o'--o'  subsystem\n"
"\t\t\t   \\\n"
"\t\t\t    *---*---*  topic\n"
msgstr ""
"    o---o---o---o---o---o---o---o  master\n"
"\t \\\t\t\t \\\n"
"\t  o---o---o---o---o\t  o'--o'--o'--o'--o'  subsystem\n"
"\t\t\t   \\\n"
"\t\t\t    *---*---*  topic\n"

#. type: Plain text
#: en/git-rebase.txt:1052
#, priority:100
msgid "If you now continue development as usual, and eventually merge 'topic' to 'subsystem', the commits from 'subsystem' will remain duplicated forever:"
msgstr ""

#. type: delimited block -
#: en/git-rebase.txt:1059
#, fuzzy, ignore-ellipsis, no-wrap, priority:100
msgid ""
"    o---o---o---o---o---o---o---o  master\n"
"\t \\\t\t\t \\\n"
"\t  o---o---o---o---o\t  o'--o'--o'--o'--o'--M\t subsystem\n"
"\t\t\t   \\\t\t\t     /\n"
"\t\t\t    *---*---*-..........-*--*  topic\n"
msgstr ""
"    o---o---o---o---o---o---o---o  master\n"
"\t \\\t\t\t \\\n"
"\t  o---o---o---o---o\t  o'--o'--o'--o'--o'--M\t subsystem\n"
"\t\t\t   \\\t\t\t     /\n"
"\t\t\t    *---*---*-..........-*--*  topic\n"

#. type: Plain text
#: en/git-rebase.txt:1066
#, priority:100
msgid "Such duplicates are generally frowned upon because they clutter up history, making it harder to follow.  To clean things up, you need to transplant the commits on 'topic' to the new 'subsystem' tip, i.e., rebase 'topic'.  This becomes a ripple effect: anyone downstream from 'topic' is forced to rebase too, and so on!"
msgstr ""

#. type: Plain text
#: en/git-rebase.txt:1068
#, priority:100
msgid "There are two kinds of fixes, discussed in the following subsections:"
msgstr ""

#. type: Labeled list
#: en/git-rebase.txt:1069
#, no-wrap, priority:100
msgid "Easy case: The changes are literally the same."
msgstr ""

#. type: Plain text
#: en/git-rebase.txt:1073
#, priority:100
msgid "This happens if the 'subsystem' rebase was a simple rebase and had no conflicts."
msgstr ""

#. type: Labeled list
#: en/git-rebase.txt:1074
#, no-wrap, priority:100
msgid "Hard case: The changes are not the same."
msgstr ""

#. type: Plain text
#: en/git-rebase.txt:1081
#, priority:100
msgid "This happens if the 'subsystem' rebase had conflicts, or used `--interactive` to omit, edit, squash, or fixup commits; or if the upstream used one of `commit --amend`, `reset`, or a full history rewriting command like https://github.com/newren/git-filter-repo[`filter-repo`]."
msgstr ""

#. type: Title ~
#: en/git-rebase.txt:1084
#, no-wrap, priority:100
msgid "The easy case"
msgstr ""

#. type: Plain text
#: en/git-rebase.txt:1089
#, priority:100
msgid "Only works if the changes (patch IDs based on the diff contents) on 'subsystem' are literally the same before and after the rebase 'subsystem' did."
msgstr ""

#. type: Plain text
#: en/git-rebase.txt:1094
#, priority:100
msgid "In that case, the fix is easy because 'git rebase' knows to skip changes that are already present in the new upstream (unless `--reapply-cherry-picks` is given). So if you say (assuming you're on 'topic')"
msgstr ""

#. type: delimited block -
#: en/git-rebase.txt:1096
#, fuzzy, no-wrap, priority:100
msgid "    $ git rebase subsystem\n"
msgstr "    $ git rebase subsystem\n"

#. type: Plain text
#: en/git-rebase.txt:1098
#, priority:100
msgid "you will end up with the fixed history"
msgstr ""

#. type: delimited block -
#: en/git-rebase.txt:1104
#, fuzzy, no-wrap, priority:100
msgid ""
"    o---o---o---o---o---o---o---o  master\n"
"\t\t\t\t \\\n"
"\t\t\t\t  o'--o'--o'--o'--o'  subsystem\n"
"\t\t\t\t\t\t   \\\n"
"\t\t\t\t\t\t    *---*---*  topic\n"
msgstr ""
"    o---o---o---o---o---o---o---o  master\n"
"\t\t\t\t \\\n"
"\t\t\t\t  o'--o'--o'--o'--o'  subsystem\n"
"\t\t\t\t\t\t   \\\n"
"\t\t\t\t\t\t    *---*---*  topic\n"

#. type: Title ~
#: en/git-rebase.txt:1108
#, no-wrap, priority:100
msgid "The hard case"
msgstr ""

#. type: Plain text
#: en/git-rebase.txt:1112
#, priority:100
msgid "Things get more complicated if the 'subsystem' changes do not exactly correspond to the ones before the rebase."
msgstr ""

#. type: Plain text
#: en/git-rebase.txt:1117
#, no-wrap, priority:100
msgid ""
"While an \"easy case recovery\" sometimes appears to be successful\n"
"      even in the hard case, it may have unintended consequences.  For\n"
"      example, a commit that was removed via `git rebase\n"
"      --interactive` will be **resurrected**!\n"
msgstr ""

#. type: Plain text
#: en/git-rebase.txt:1122
#, priority:100
msgid "The idea is to manually tell `git rebase` \"where the old 'subsystem' ended and your 'topic' began\", that is, what the old merge base between them was.  You will have to find a way to name the last commit of the old 'subsystem', for example:"
msgstr ""

#. type: Plain text
#: en/git-rebase.txt:1126
#, priority:100
msgid "With the 'subsystem' reflog: after `git fetch`, the old tip of 'subsystem' is at `subsystem@{1}`.  Subsequent fetches will increase the number.  (See linkgit:git-reflog[1].)"
msgstr ""

#. type: Plain text
#: en/git-rebase.txt:1129
#, priority:100
msgid "Relative to the tip of 'topic': knowing that your 'topic' has three commits, the old tip of 'subsystem' must be `topic~3`."
msgstr ""

#. type: Plain text
#: en/git-rebase.txt:1132
#, priority:100
msgid "You can then transplant the old `subsystem..topic` to the new tip by saying (for the reflog case, and assuming you are on 'topic' already):"
msgstr ""

#. type: delimited block -
#: en/git-rebase.txt:1134
#, fuzzy, no-wrap, priority:100
msgid "    $ git rebase --onto subsystem subsystem@{1}\n"
msgstr "    $ git rebase --onto subsystem subsystem@{1}\n"

#. type: Plain text
#: en/git-rebase.txt:1139
#, priority:100
msgid "The ripple effect of a \"hard case\" recovery is especially bad: 'everyone' downstream from 'topic' will now have to perform a \"hard case\" recovery too!"
msgstr ""

#. type: Title -
#: en/git-rebase.txt:1141
#, no-wrap, priority:100
msgid "REBASING MERGES"
msgstr ""

#. type: Plain text
#: en/git-rebase.txt:1149
#, priority:100
msgid "The interactive rebase command was originally designed to handle individual patch series. As such, it makes sense to exclude merge commits from the todo list, as the developer may have merged the then-current `master` while working on the branch, only to rebase all the commits onto `master` eventually (skipping the merge commits)."
msgstr ""

#. type: Plain text
#: en/git-rebase.txt:1153
#, priority:100
msgid "However, there are legitimate reasons why a developer may want to recreate merge commits: to keep the branch structure (or \"commit topology\") when working on multiple, inter-related branches."
msgstr ""

#. type: Plain text
#: en/git-rebase.txt:1158
#, priority:100
msgid "In the following example, the developer works on a topic branch that refactors the way buttons are defined, and on another topic branch that uses that refactoring to implement a \"Report a bug\" button. The output of `git log --graph --format=%s -5` may look like this:"
msgstr ""

#. type: delimited block -
#: en/git-rebase.txt:1168
#, fuzzy, no-wrap, priority:100
msgid ""
"*   Merge branch 'report-a-bug'\n"
"|\\\n"
"| * Add the feedback button\n"
"* | Merge branch 'refactor-button'\n"
"|\\ \\\n"
"| |/\n"
"| * Use the Button class for all buttons\n"
"| * Extract a generic Button class from the DownloadButton one\n"
msgstr ""
"*   Merge branch 'report-a-bug'\n"
"|\\\n"
"| * Add the feedback button\n"
"* | Merge branch 'refactor-button'\n"
"|\\ \\\n"
"| |/\n"
"| * Use the Button class for all buttons\n"
"| * Extract a generic Button class from the DownloadButton one\n"

#. type: Plain text
#: en/git-rebase.txt:1175
#, priority:100
msgid "The developer might want to rebase those commits to a newer `master` while keeping the branch topology, for example when the first topic branch is expected to be integrated into `master` much earlier than the second one, say, to resolve merge conflicts with changes to the DownloadButton class that made it into `master`."
msgstr ""

#. type: Plain text
#: en/git-rebase.txt:1178
#, priority:100
msgid "This rebase can be performed using the `--rebase-merges` option.  It will generate a todo list looking like this:"
msgstr ""

#. type: delimited block -
#: en/git-rebase.txt:1181 en/git-rebase.txt:1262
#, no-wrap, priority:100
msgid "label onto\n"
msgstr ""

#. type: delimited block -
#: en/git-rebase.txt:1187
#, no-wrap, priority:100
msgid ""
"# Branch: refactor-button\n"
"reset onto\n"
"pick 123456 Extract a generic Button class from the DownloadButton one\n"
"pick 654321 Use the Button class for all buttons\n"
"label refactor-button\n"
msgstr ""

#. type: delimited block -
#: en/git-rebase.txt:1192
#, no-wrap, priority:100
msgid ""
"# Branch: report-a-bug\n"
"reset refactor-button # Use the Button class for all buttons\n"
"pick abcdef Add the feedback button\n"
"label report-a-bug\n"
msgstr ""

#. type: delimited block -
#: en/git-rebase.txt:1196
#, no-wrap, priority:100
msgid ""
"reset onto\n"
"merge -C a1b2c3 refactor-button # Merge 'refactor-button'\n"
"merge -C 6f5e4d report-a-bug # Merge 'report-a-bug'\n"
msgstr ""

#. type: Plain text
#: en/git-rebase.txt:1200
#, priority:100
msgid "In contrast to a regular interactive rebase, there are `label`, `reset` and `merge` commands in addition to `pick` ones."
msgstr ""

#. type: Plain text
#: en/git-rebase.txt:1208
#, priority:100
msgid "The `label` command associates a label with the current HEAD when that command is executed. These labels are created as worktree-local refs (`refs/rewritten/<label>`) that will be deleted when the rebase finishes. That way, rebase operations in multiple worktrees linked to the same repository do not interfere with one another. If the `label` command fails, it is rescheduled immediately, with a helpful message how to proceed."
msgstr ""

#. type: Plain text
#: en/git-rebase.txt:1215
#, priority:100
msgid "The `reset` command resets the HEAD, index and worktree to the specified revision. It is similar to an `exec git reset --hard <label>`, but refuses to overwrite untracked files. If the `reset` command fails, it is rescheduled immediately, with a helpful message how to edit the todo list (this typically happens when a `reset` command was inserted into the todo list manually and contains a typo)."
msgstr ""

#. type: Plain text
#: en/git-rebase.txt:1221
#, priority:100
msgid "The `merge` command will merge the specified revision(s) into whatever is HEAD at that time. With `-C <original-commit>`, the commit message of the specified merge commit will be used. When the `-C` is changed to a lower-case `-c`, the message will be opened in an editor after a successful merge so that the user can edit the message."
msgstr ""

#. type: Plain text
#: en/git-rebase.txt:1224
#, priority:100
msgid "If a `merge` command fails for any reason other than merge conflicts (i.e.  when the merge operation did not even start), it is rescheduled immediately."
msgstr ""

#. type: Plain text
#: en/git-rebase.txt:1235
#, priority:100
msgid "By default, the `merge` command will use the `ort` merge strategy for regular merges, and `octopus` for octopus merges.  One can specify a default strategy for all merges using the `--strategy` argument when invoking rebase, or can override specific merges in the interactive list of commands by using an `exec` command to call `git merge` explicitly with a `--strategy` argument.  Note that when calling `git merge` explicitly like this, you can make use of the fact that the labels are worktree-local refs (the ref `refs/rewritten/onto` would correspond to the label `onto`, for example) in order to refer to the branches you want to merge."
msgstr ""

#. type: Plain text
#: en/git-rebase.txt:1239
#, priority:100
msgid "Note: the first command (`label onto`) labels the revision onto which the commits are rebased; The name `onto` is just a convention, as a nod to the `--onto` option."
msgstr ""

#. type: Plain text
#: en/git-rebase.txt:1246
#, priority:100
msgid "It is also possible to introduce completely new merge commits from scratch by adding a command of the form `merge <merge-head>`. This form will generate a tentative commit message and always open an editor to let the user edit it. This can be useful e.g. when a topic branch turns out to address more than a single concern and wants to be split into two or even more topic branches. Consider this todo list:"
msgstr ""

#. type: delimited block -
#: en/git-rebase.txt:1253
#, no-wrap, priority:100
msgid ""
"pick 192837 Switch from GNU Makefiles to CMake\n"
"pick 5a6c7e Document the switch to CMake\n"
"pick 918273 Fix detection of OpenSSL in CMake\n"
"pick afbecd http: add support for TLS v1.3\n"
"pick fdbaec Fix detection of cURL in CMake on Windows\n"
msgstr ""

#. type: Plain text
#: en/git-rebase.txt:1259
#, priority:100
msgid "The one commit in this list that is not related to CMake may very well have been motivated by working on fixing all those bugs introduced by switching to CMake, but it addresses a different concern. To split this branch into two topic branches, the todo list could be edited like this:"
msgstr ""

#. type: delimited block -
#: en/git-rebase.txt:1265
#, no-wrap, priority:100
msgid ""
"pick afbecd http: add support for TLS v1.3\n"
"label tlsv1.3\n"
msgstr ""

#. type: delimited block -
#: en/git-rebase.txt:1272
#, no-wrap, priority:100
msgid ""
"reset onto\n"
"pick 192837 Switch from GNU Makefiles to CMake\n"
"pick 918273 Fix detection of OpenSSL in CMake\n"
"pick fdbaec Fix detection of cURL in CMake on Windows\n"
"pick 5a6c7e Document the switch to CMake\n"
"label cmake\n"
msgstr ""

#. type: delimited block -
#: en/git-rebase.txt:1276
#, no-wrap, priority:100
msgid ""
"reset onto\n"
"merge tlsv1.3\n"
"merge cmake\n"
msgstr ""

#. type: Title =
#: en/git-receive-pack.txt:2
#, ignore-same, no-wrap, priority:90
msgid "git-receive-pack(1)"
msgstr "git-receive-pack(1)"

#. type: Plain text
#: en/git-receive-pack.txt:7
#, priority:90
msgid "git-receive-pack - Receive what is pushed into the repository"
msgstr ""

#. type: Plain text
#: en/git-receive-pack.txt:13
#, fuzzy, no-wrap, priority:90
msgid "'git receive-pack' <git-dir>\n"
msgstr "'git-receive-pack' <directory>\n"

#. type: Plain text
#: en/git-receive-pack.txt:18
#, priority:90
msgid "Invoked by 'git send-pack' and updates the repository with the information fed from the remote end."
msgstr ""

#. type: Plain text
#: en/git-receive-pack.txt:23
#, priority:90
msgid "This command is usually not invoked directly by the end user.  The UI for the protocol is on the 'git send-pack' side, and the program pair is meant to be used to push updates to remote repository.  For pull operations, see linkgit:git-fetch-pack[1]."
msgstr ""

#. type: Plain text
#: en/git-receive-pack.txt:28
#, priority:90
msgid "The command allows for creation and fast-forwarding of sha1 refs (heads/tags) on the remote end (strictly speaking, it is the local end 'git-receive-pack' runs, but to the user who is sitting at the send-pack end, it is updating the remote.  Confused?)"
msgstr ""

#. type: Plain text
#: en/git-receive-pack.txt:31
#, priority:90
msgid "There are other real-world examples of using update and post-update hooks found in the Documentation/howto directory."
msgstr ""

#. type: Plain text
#: en/git-receive-pack.txt:35
#, priority:90
msgid "'git-receive-pack' honours the receive.denyNonFastForwards config option, which tells it if updates to a ref should be denied if they are not fast-forwards."
msgstr ""

#. type: Plain text
#: en/git-receive-pack.txt:38
#, priority:90
msgid "A number of other receive.* config options are available to tweak its behavior, see linkgit:git-config[1]."
msgstr ""

#. type: Labeled list
#: en/git-receive-pack.txt:41
#, fuzzy, no-wrap, priority:90
#| msgid "--git-dir"
msgid "<git-dir>"
msgstr "--git-dir"

#. type: Plain text
#: en/git-receive-pack.txt:43
#, priority:90
msgid "The repository to sync into."
msgstr ""

#. type: Labeled list
#: en/git-receive-pack.txt:44 en/git-upload-pack.txt:39
#, ignore-same, no-wrap, priority:100
msgid "--http-backend-info-refs"
msgstr "--http-backend-info-refs"

#. type: Plain text
#: en/git-receive-pack.txt:48
#, priority:90
msgid "Used by linkgit:git-http-backend[1] to serve up `$GIT_URL/info/refs?service=git-receive-pack` requests. See `--http-backend-info-refs` in linkgit:git-upload-pack[1]."
msgstr ""

#. type: Title -
#: en/git-receive-pack.txt:50
#, no-wrap, priority:90
msgid "PRE-RECEIVE HOOK"
msgstr ""

#. type: Plain text
#: en/git-receive-pack.txt:54
#, priority:90
msgid "Before any ref is updated, if $GIT_DIR/hooks/pre-receive file exists and is executable, it will be invoked once with no parameters.  The standard input of the hook will be one line per ref to be updated:"
msgstr ""

#. type: Plain text
#: en/git-receive-pack.txt:56 en/git-receive-pack.txt:155
#, no-wrap, priority:90
msgid "       sha1-old SP sha1-new SP refname LF\n"
msgstr ""

#. type: Plain text
#: en/git-receive-pack.txt:63
#, priority:90
msgid "The refname value is relative to $GIT_DIR; e.g. for the master head this is \"refs/heads/master\".  The two sha1 values before each refname are the object names for the refname before and after the update.  Refs to be created will have sha1-old equal to 0\\{40}, while refs to be deleted will have sha1-new equal to 0\\{40}, otherwise sha1-old and sha1-new should be valid objects in the repository."
msgstr ""

#. type: Plain text
#: en/git-receive-pack.txt:70
#, priority:90
msgid "When accepting a signed push (see linkgit:git-push[1]), the signed push certificate is stored in a blob and an environment variable `GIT_PUSH_CERT` can be consulted for its object name.  See the description of `post-receive` hook for an example.  In addition, the certificate is verified using GPG and the result is exported with the following environment variables:"
msgstr ""

#. type: Labeled list
#: en/git-receive-pack.txt:71
#, ignore-same, no-wrap, priority:90
msgid "`GIT_PUSH_CERT_SIGNER`"
msgstr "`GIT_PUSH_CERT_SIGNER`"

#. type: Plain text
#: en/git-receive-pack.txt:74
#, priority:90
msgid "The name and the e-mail address of the owner of the key that signed the push certificate."
msgstr ""

#. type: Labeled list
#: en/git-receive-pack.txt:75
#, ignore-same, no-wrap, priority:90
msgid "`GIT_PUSH_CERT_KEY`"
msgstr "`GIT_PUSH_CERT_KEY`"

#. type: Plain text
#: en/git-receive-pack.txt:77
#, priority:90
msgid "The GPG key ID of the key that signed the push certificate."
msgstr ""

#. type: Labeled list
#: en/git-receive-pack.txt:78
#, ignore-same, no-wrap, priority:90
msgid "`GIT_PUSH_CERT_STATUS`"
msgstr "`GIT_PUSH_CERT_STATUS`"

#. type: Plain text
#: en/git-receive-pack.txt:82
#, priority:90
msgid "The status of GPG verification of the push certificate, using the same mnemonic as used in `%G?` format of `git log` family of commands (see linkgit:git-log[1])."
msgstr ""

#. type: Labeled list
#: en/git-receive-pack.txt:83
#, ignore-same, no-wrap, priority:90
msgid "`GIT_PUSH_CERT_NONCE`"
msgstr "`GIT_PUSH_CERT_NONCE`"

#. type: Plain text
#: en/git-receive-pack.txt:89
#, priority:90
msgid "The nonce string the process asked the signer to include in the push certificate.  If this does not match the value recorded on the \"nonce\" header in the push certificate, it may indicate that the certificate is a valid one that is being replayed from a separate \"git push\" session."
msgstr ""

#. type: Labeled list
#: en/git-receive-pack.txt:90
#, ignore-same, no-wrap, priority:90
msgid "`GIT_PUSH_CERT_NONCE_STATUS`"
msgstr "`GIT_PUSH_CERT_NONCE_STATUS`"

#. type: Labeled list
#: en/git-receive-pack.txt:91
#, ignore-same, no-wrap, priority:90
msgid "`UNSOLICITED`"
msgstr "`UNSOLICITED`"

#. type: Plain text
#: en/git-receive-pack.txt:94
#, fuzzy, priority:90
msgid "\"git push --signed\" sent a nonce when we did not ask it to send one."
msgstr "\"git push --signed\" sent a nonce when we did not ask it to send one."

#. type: Labeled list
#: en/git-receive-pack.txt:94
#, ignore-same, no-wrap, priority:90
msgid "`MISSING`"
msgstr "`MISSING`"

#. type: Plain text
#: en/git-receive-pack.txt:96
#, priority:90
msgid "\"git push --signed\" did not send any nonce header."
msgstr ""

#. type: Labeled list
#: en/git-receive-pack.txt:96
#, ignore-same, no-wrap, priority:90
msgid "`BAD`"
msgstr "`BAD`"

#. type: Plain text
#: en/git-receive-pack.txt:98
#, fuzzy, priority:90
msgid "\"git push --signed\" sent a bogus nonce."
msgstr "\"git push --signed\" sent a bogus nonce."

#. type: Labeled list
#: en/git-receive-pack.txt:98
#, ignore-same, no-wrap, priority:90
msgid "`OK`"
msgstr "`OK`"

#. type: Plain text
#: en/git-receive-pack.txt:100
#, priority:90
msgid "\"git push --signed\" sent the nonce we asked it to send."
msgstr ""

#. type: Labeled list
#: en/git-receive-pack.txt:100
#, ignore-same, no-wrap, priority:90
msgid "`SLOP`"
msgstr "`SLOP`"

#. type: Plain text
#: en/git-receive-pack.txt:104
#, fuzzy, priority:90
msgid "\"git push --signed\" sent a nonce different from what we asked it to send now, but in a previous session.  See `GIT_PUSH_CERT_NONCE_SLOP` environment variable."
msgstr "\"git push --signed\" sent a nonce different from what we asked it to send now, but in a previous session.  See `GIT_PUSH_CERT_NONCE_SLOP` environment variable."

#. type: Labeled list
#: en/git-receive-pack.txt:105
#, ignore-same, no-wrap, priority:90
msgid "`GIT_PUSH_CERT_NONCE_SLOP`"
msgstr "`GIT_PUSH_CERT_NONCE_SLOP`"

#. type: Plain text
#: en/git-receive-pack.txt:113
#, fuzzy, priority:90
msgid "\"git push --signed\" sent a nonce different from what we asked it to send now, but in a different session whose starting time is different by this many seconds from the current session.  Only meaningful when `GIT_PUSH_CERT_NONCE_STATUS` says `SLOP`.  Also read about `receive.certNonceSlop` variable in linkgit:git-config[1]."
msgstr "\"git push --signed\" sent a nonce different from what we asked it to send now, but in a different session whose starting time is different by this many seconds from the current session.  Only meaningful when `GIT_PUSH_CERT_NONCE_STATUS` says `SLOP`.  Also read about `receive.certNonceSlop` variable in linkgit:git-config[1]."

#. type: Plain text
#: en/git-receive-pack.txt:116
#, priority:90
msgid "This hook is called before any refname is updated and before any fast-forward checks are performed."
msgstr ""

#. type: Plain text
#: en/git-receive-pack.txt:121
#, priority:90
msgid "If the pre-receive hook exits with a non-zero exit status no updates will be performed, and the update, post-receive and post-update hooks will not be invoked either.  This can be useful to quickly bail out if the update is not to be supported."
msgstr ""

#. type: Plain text
#: en/git-receive-pack.txt:123
#, priority:90
msgid "See the notes on the quarantine environment below."
msgstr ""

#. type: Title -
#: en/git-receive-pack.txt:125
#, no-wrap, priority:90
msgid "UPDATE HOOK"
msgstr ""

#. type: Plain text
#: en/git-receive-pack.txt:128
#, priority:90
msgid "Before each ref is updated, if $GIT_DIR/hooks/update file exists and is executable, it is invoked once per ref, with three parameters:"
msgstr ""

#. type: Plain text
#: en/git-receive-pack.txt:130
#, fuzzy, no-wrap, priority:90
msgid "       $GIT_DIR/hooks/update refname sha1-old sha1-new\n"
msgstr "       $GIT_DIR/hooks/update refname sha1-old sha1-new\n"

#. type: Plain text
#: en/git-receive-pack.txt:137
#, priority:90
msgid "The refname parameter is relative to $GIT_DIR; e.g. for the master head this is \"refs/heads/master\".  The two sha1 arguments are the object names for the refname before and after the update.  Note that the hook is called before the refname is updated, so either sha1-old is 0\\{40} (meaning there is no such ref yet), or it should match what is recorded in refname."
msgstr ""

#. type: Plain text
#: en/git-receive-pack.txt:140
#, priority:90
msgid "The hook should exit with non-zero status if it wants to disallow updating the named ref.  Otherwise it should exit with zero."
msgstr ""

#. type: Plain text
#: en/git-receive-pack.txt:145
#, priority:90
msgid "Successful execution (a zero exit status) of this hook does not ensure the ref will actually be updated, it is only a prerequisite.  As such it is not a good idea to send notices (e.g. email) from this hook.  Consider using the post-receive hook instead."
msgstr ""

#. type: Title -
#: en/git-receive-pack.txt:147
#, no-wrap, priority:90
msgid "POST-RECEIVE HOOK"
msgstr ""

#. type: Plain text
#: en/git-receive-pack.txt:153
#, priority:90
msgid "After all refs were updated (or attempted to be updated), if any ref update was successful, and if $GIT_DIR/hooks/post-receive file exists and is executable, it will be invoked once with no parameters.  The standard input of the hook will be one line for each successfully updated ref:"
msgstr ""

#. type: Plain text
#: en/git-receive-pack.txt:163
#, priority:90
msgid "The refname value is relative to $GIT_DIR; e.g. for the master head this is \"refs/heads/master\".  The two sha1 values before each refname are the object names for the refname before and after the update.  Refs that were created will have sha1-old equal to 0\\{40}, while refs that were deleted will have sha1-new equal to 0\\{40}, otherwise sha1-old and sha1-new should be valid objects in the repository."
msgstr ""

#. type: Plain text
#: en/git-receive-pack.txt:166
#, priority:90
msgid "The `GIT_PUSH_CERT*` environment variables can be inspected, just as in `pre-receive` hook, after accepting a signed push."
msgstr ""

#. type: Plain text
#: en/git-receive-pack.txt:172
#, priority:90
msgid "Using this hook, it is easy to generate mails describing the updates to the repository.  This example script sends one mail message per ref listing the commits pushed to the repository, and logs the push certificates of signed pushes with good signatures to a logger service:"
msgstr ""

#. type: delimited block -
#: en/git-receive-pack.txt:197
#, no-wrap, priority:90
msgid ""
"#!/bin/sh\n"
"# mail out commit update information.\n"
"while read oval nval ref\n"
"do\n"
"\tif expr \"$oval\" : '0*$' >/dev/null\n"
"\tthen\n"
"\t\techo \"Created a new ref, with the following commits:\"\n"
"\t\tgit rev-list --pretty \"$nval\"\n"
"\telse\n"
"\t\techo \"New commits:\"\n"
"\t\tgit rev-list --pretty \"$nval\" \"^$oval\"\n"
"\tfi |\n"
"\tmail -s \"Changes to ref $ref\" commit-list@mydomain\n"
"done\n"
"# log signed push certificate, if any\n"
"if test -n \"${GIT_PUSH_CERT-}\" && test ${GIT_PUSH_CERT_STATUS} = G\n"
"then\n"
"\t(\n"
"\t\techo expected nonce is ${GIT_PUSH_NONCE}\n"
"\t\tgit cat-file blob ${GIT_PUSH_CERT}\n"
"\t) | mail -s \"push certificate from $GIT_PUSH_CERT_SIGNER\" push-log@mydomain\n"
"fi\n"
"exit 0\n"
msgstr ""

#. type: Plain text
#: en/git-receive-pack.txt:201
#, priority:90
msgid "The exit code from this hook invocation is ignored, however a non-zero exit code will generate an error message."
msgstr ""

#. type: Plain text
#: en/git-receive-pack.txt:207
#, priority:90
msgid "Note that it is possible for refname to not have sha1-new when this hook runs.  This can easily occur if another user modifies the ref after it was updated by 'git-receive-pack', but before the hook was able to evaluate it.  It is recommended that hooks rely on sha1-new rather than the current value of refname."
msgstr ""

#. type: Title -
#: en/git-receive-pack.txt:209
#, no-wrap, priority:90
msgid "POST-UPDATE HOOK"
msgstr ""

#. type: Plain text
#: en/git-receive-pack.txt:214
#, priority:90
msgid "After all other processing, if at least one ref was updated, and if $GIT_DIR/hooks/post-update file exists and is executable, then post-update will be called with the list of refs that have been updated.  This can be used to implement any repository wide cleanup tasks."
msgstr ""

#. type: Plain text
#: en/git-receive-pack.txt:218
#, priority:90
msgid "The exit code from this hook invocation is ignored; the only thing left for 'git-receive-pack' to do at that point is to exit itself anyway."
msgstr ""

#. type: Plain text
#: en/git-receive-pack.txt:221
#, priority:90
msgid "This hook can be used, for example, to run `git update-server-info` if the repository is packed and is served via a dumb transport."
msgstr ""

#. type: delimited block -
#: en/git-receive-pack.txt:225
#, fuzzy, no-wrap, priority:90
msgid ""
"#!/bin/sh\n"
"exec git update-server-info\n"
msgstr ""
"#!/bin/sh\n"
"exec git update-server-info\n"

#. type: Title -
#: en/git-receive-pack.txt:229
#, no-wrap, priority:90
msgid "QUARANTINE ENVIRONMENT"
msgstr ""

#. type: Plain text
#: en/git-receive-pack.txt:236
#, priority:90
msgid "When `receive-pack` takes in objects, they are placed into a temporary \"quarantine\" directory within the `$GIT_DIR/objects` directory and migrated into the main object store only after the `pre-receive` hook has completed. If the push fails before then, the temporary directory is removed entirely."
msgstr ""

#. type: Plain text
#: en/git-receive-pack.txt:238
#, priority:90
msgid "This has a few user-visible effects and caveats:"
msgstr ""

#. type: Plain text
#: en/git-receive-pack.txt:244
#, priority:90
msgid "Pushes which fail due to problems with the incoming pack, missing objects, or due to the `pre-receive` hook will not leave any on-disk data. This is usually helpful to prevent repeated failed pushes from filling up your disk, but can make debugging more challenging."
msgstr ""

#. type: Plain text
#: en/git-receive-pack.txt:247
#, priority:90
msgid "Any objects created by the `pre-receive` hook will be created in the quarantine directory (and migrated only if it succeeds)."
msgstr ""

#. type: Plain text
#: en/git-receive-pack.txt:253
#, priority:90
msgid "The `pre-receive` hook MUST NOT update any refs to point to quarantined objects. Other programs accessing the repository will not be able to see the objects (and if the pre-receive hook fails, those refs would become corrupted). For safety, any ref updates from within `pre-receive` are automatically rejected."
msgstr ""

#. type: Plain text
#: en/git-receive-pack.txt:258
#, ignore-same, priority:90
msgid "linkgit:git-send-pack[1], linkgit:gitnamespaces[7]"
msgstr "linkgit:git-send-pack[1], linkgit:gitnamespaces[7]"

#. type: Title =
#: en/git-reflog.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-reflog(1)"
msgstr "git-reflog(1)"

#. type: Plain text
#: en/git-reflog.txt:7
#, fuzzy, priority:100
msgid "git-reflog - Manage reflog information"
msgstr "git-reflog - Manage reflog information"

#. type: Plain text
#: en/git-reflog.txt:19
#, ignore-ellipsis, no-wrap, priority:100
msgid ""
"'git reflog' [show] [<log-options>] [<ref>]\n"
"'git reflog expire' [--expire=<time>] [--expire-unreachable=<time>]\n"
"\t[--rewrite] [--updateref] [--stale-fix]\n"
"\t[--dry-run | -n] [--verbose] [--all [--single-worktree] | <refs>...]\n"
"'git reflog delete' [--rewrite] [--updateref]\n"
"\t[--dry-run | -n] [--verbose] <ref>@{<specifier>}...\n"
"'git reflog exists' <ref>\n"
msgstr ""

#. type: Plain text
#: en/git-reflog.txt:23
#, priority:100
msgid "This command manages the information recorded in the reflogs."
msgstr ""

#. type: Plain text
#: en/git-reflog.txt:31
#, priority:100
msgid "Reference logs, or \"reflogs\", record when the tips of branches and other references were updated in the local repository. Reflogs are useful in various Git commands, to specify the old value of a reference. For example, `HEAD@{2}` means \"where HEAD used to be two moves ago\", `master@{one.week.ago}` means \"where master used to point to one week ago in this local repository\", and so on. See linkgit:gitrevisions[7] for more details."
msgstr ""

#. type: Plain text
#: en/git-reflog.txt:41
#, priority:100
msgid "The \"show\" subcommand (which is also the default, in the absence of any subcommands) shows the log of the reference provided in the command-line (or `HEAD`, by default). The reflog covers all recent actions, and in addition the `HEAD` reflog records branch switching.  `git reflog show` is an alias for `git log -g --abbrev-commit --pretty=oneline`; see linkgit:git-log[1] for more information."
msgstr ""

#. type: Plain text
#: en/git-reflog.txt:47
#, priority:100
msgid "The \"expire\" subcommand prunes older reflog entries. Entries older than `expire` time, or entries older than `expire-unreachable` time and not reachable from the current tip, are removed from the reflog.  This is typically not used directly by end users -- instead, see linkgit:git-gc[1]."
msgstr ""

#. type: Plain text
#: en/git-reflog.txt:52
#, priority:100
msgid "The \"delete\" subcommand deletes single entries from the reflog. Its argument must be an _exact_ entry (e.g. \"`git reflog delete master@{2}`\"). This subcommand is also typically not used directly by end users."
msgstr ""

#. type: Plain text
#: en/git-reflog.txt:56
#, priority:100
msgid "The \"exists\" subcommand checks whether a ref has a reflog.  It exits with zero status if the reflog exists, and non-zero status if it does not."
msgstr ""

#. type: Title ~
#: en/git-reflog.txt:61
#, no-wrap, priority:100
msgid "Options for `show`"
msgstr ""

#. type: Plain text
#: en/git-reflog.txt:64
#, priority:100
msgid "`git reflog show` accepts any of the options accepted by `git log`."
msgstr ""

#. type: Title ~
#: en/git-reflog.txt:67
#, no-wrap, priority:100
msgid "Options for `expire`"
msgstr ""

#. type: Plain text
#: en/git-reflog.txt:71
#, priority:100
msgid "Process the reflogs of all references."
msgstr ""

#. type: Labeled list
#: en/git-reflog.txt:72 en/rev-list-options.txt:218
#, ignore-same, no-wrap, priority:260
msgid "--single-worktree"
msgstr "--single-worktree"

#. type: Plain text
#: en/git-reflog.txt:76
#, priority:100
msgid "By default when `--all` is specified, reflogs from all working trees are processed. This option limits the processing to reflogs from the current working tree only."
msgstr ""

#. type: Labeled list
#: en/git-reflog.txt:77
#, no-wrap, priority:100
msgid "--expire=<time>"
msgstr ""

#. type: Plain text
#: en/git-reflog.txt:84
#, priority:100
msgid "Prune entries older than the specified time. If this option is not specified, the expiration time is taken from the configuration setting `gc.reflogExpire`, which in turn defaults to 90 days. `--expire=all` prunes entries regardless of their age; `--expire=never` turns off pruning of reachable entries (but see `--expire-unreachable`)."
msgstr ""

#. type: Labeled list
#: en/git-reflog.txt:85
#, no-wrap, priority:100
msgid "--expire-unreachable=<time>"
msgstr ""

#. type: Plain text
#: en/git-reflog.txt:94
#, priority:100
msgid "Prune entries older than `<time>` that are not reachable from the current tip of the branch. If this option is not specified, the expiration time is taken from the configuration setting `gc.reflogExpireUnreachable`, which in turn defaults to 30 days. `--expire-unreachable=all` prunes unreachable entries regardless of their age; `--expire-unreachable=never` turns off early pruning of unreachable entries (but see `--expire`)."
msgstr ""

#. type: Labeled list
#: en/git-reflog.txt:95
#, ignore-same, no-wrap, priority:100
msgid "--updateref"
msgstr "--updateref"

#. type: Plain text
#: en/git-reflog.txt:99
#, priority:100
msgid "Update the reference to the value of the top reflog entry (i.e.  <ref>@\\{0\\}) if the previous top entry was pruned.  (This option is ignored for symbolic references.)"
msgstr ""

#. type: Labeled list
#: en/git-reflog.txt:100
#, ignore-same, no-wrap, priority:100
msgid "--rewrite"
msgstr "--rewrite"

#. type: Plain text
#: en/git-reflog.txt:104
#, priority:100
msgid "If a reflog entry's predecessor is pruned, adjust its \"old\" SHA-1 to be equal to the \"new\" SHA-1 field of the entry that now precedes it."
msgstr ""

#. type: Labeled list
#: en/git-reflog.txt:105
#, ignore-same, no-wrap, priority:100
msgid "--stale-fix"
msgstr "--stale-fix"

#. type: Plain text
#: en/git-reflog.txt:110
#, priority:100
msgid "Prune any reflog entries that point to \"broken commits\". A broken commit is a commit that is not reachable from any of the reference tips and that refers, directly or indirectly, to a missing commit, tree, or blob object."
msgstr ""

#. type: Plain text
#: en/git-reflog.txt:115
#, priority:100
msgid "This computation involves traversing all the reachable objects, i.e. it has the same cost as 'git prune'.  It is primarily intended to fix corruption caused by garbage collecting using older versions of Git, which didn't protect objects referred to by reflogs."
msgstr ""

#. type: Plain text
#: en/git-reflog.txt:120
#, priority:100
msgid "Do not actually prune any entries; just show what would have been pruned."
msgstr ""

#. type: Plain text
#: en/git-reflog.txt:123
#, priority:100
msgid "Print extra information on screen."
msgstr ""

#. type: Title ~
#: en/git-reflog.txt:126
#, no-wrap, priority:100
msgid "Options for `delete`"
msgstr ""

#. type: Plain text
#: en/git-reflog.txt:131
#, fuzzy, priority:100
msgid "`git reflog delete` accepts options `--updateref`, `--rewrite`, `-n`, `--dry-run`, and `--verbose`, with the same meanings as when they are used with `expire`."
msgstr "`git reflog delete` accepts options `--updateref`, `--rewrite`, `-n`, `--dry-run`, and `--verbose`, with the same meanings as when they are used with `expire`."

#. type: Title =
#: en/git-remote-ext.txt:2
#, ignore-same, no-wrap, priority:90
msgid "git-remote-ext(1)"
msgstr "git-remote-ext(1)"

#. type: Plain text
#: en/git-remote-ext.txt:7
#, priority:90
msgid "git-remote-ext - Bridge smart transport to external command."
msgstr ""

#. type: Plain text
#: en/git-remote-ext.txt:12
#, ignore-ellipsis, no-wrap, priority:90
msgid "git remote add <nick> \"ext::<command>[ <arguments>...]\"\n"
msgstr ""

#. type: Plain text
#: en/git-remote-ext.txt:17
#, priority:90
msgid "This remote helper uses the specified '<command>' to connect to a remote Git server."
msgstr ""

#. type: Plain text
#: en/git-remote-ext.txt:23
#, priority:90
msgid "Data written to stdin of the specified '<command>' is assumed to be sent to a git:// server, git-upload-pack, git-receive-pack or git-upload-archive (depending on situation), and data read from stdout of <command> is assumed to be received from the same service."
msgstr ""

#. type: Plain text
#: en/git-remote-ext.txt:25
#, priority:90
msgid "Command and arguments are separated by an unescaped space."
msgstr ""

#. type: Plain text
#: en/git-remote-ext.txt:27
#, priority:90
msgid "The following sequences have a special meaning:"
msgstr ""

#. type: Labeled list
#: en/git-remote-ext.txt:28
#, fuzzy, no-wrap, priority:90
msgid "'% '"
msgstr "'% '"

#. type: Plain text
#: en/git-remote-ext.txt:30
#, priority:90
msgid "Literal space in command or argument."
msgstr ""

#. type: Labeled list
#: en/git-remote-ext.txt:31 en/pretty-formats.txt:124
#, fuzzy, no-wrap, priority:260
msgid "'%%'"
msgstr "'%%'"

#. type: Plain text
#: en/git-remote-ext.txt:33
#, priority:90
msgid "Literal percent sign."
msgstr ""

#. type: Labeled list
#: en/git-remote-ext.txt:34 en/pretty-formats.txt:247
#, ignore-same, no-wrap, priority:260
msgid "'%s'"
msgstr "'%s'"

#. type: Plain text
#: en/git-remote-ext.txt:37
#, priority:90
msgid "Replaced with name (receive-pack, upload-pack, or upload-archive) of the service Git wants to invoke."
msgstr ""

#. type: Labeled list
#: en/git-remote-ext.txt:38 en/pretty-formats.txt:244
#, ignore-same, no-wrap, priority:260
msgid "'%S'"
msgstr "'%S'"

#. type: Plain text
#: en/git-remote-ext.txt:42
#, priority:90
msgid "Replaced with long name (git-receive-pack, git-upload-pack, or git-upload-archive) of the service Git wants to invoke."
msgstr ""

#. type: Labeled list
#: en/git-remote-ext.txt:43
#, no-wrap, priority:90
msgid "'%G' (must be the first characters in an argument)"
msgstr ""

#. type: Plain text
#: en/git-remote-ext.txt:49
#, priority:90
msgid "This argument will not be passed to '<command>'. Instead, it will cause the helper to start by sending git:// service requests to the remote side with the service field set to an appropriate value and the repository field set to rest of the argument. Default is not to send such a request."
msgstr ""

#. type: Plain text
#: en/git-remote-ext.txt:52
#, priority:90
msgid "This is useful if remote side is git:// server accessed over some tunnel."
msgstr ""

#. type: Labeled list
#: en/git-remote-ext.txt:53
#, fuzzy, no-wrap, priority:90
msgid "'%V' (must be first characters in argument)"
msgstr "'%V' （必须是参数中的第一个字符）"

#. type: Plain text
#: en/git-remote-ext.txt:57
#, priority:90
msgid "This argument will not be passed to '<command>'. Instead it sets the vhost field in the git:// service request (to rest of the argument).  Default is not to send vhost in such request (if sent)."
msgstr ""

#. type: Title -
#: en/git-remote-ext.txt:59 en/git-remote-fd.txt:32
#, no-wrap, priority:90
msgid "ENVIRONMENT VARIABLES"
msgstr ""

#. type: Labeled list
#: en/git-remote-ext.txt:61 en/git-remote-fd.txt:33
#, ignore-same, no-wrap, priority:90
msgid "GIT_TRANSLOOP_DEBUG"
msgstr "GIT_TRANSLOOP_DEBUG"

#. type: Plain text
#: en/git-remote-ext.txt:63 en/git-remote-fd.txt:35
#, priority:90
msgid "If set, prints debugging information about various reads/writes."
msgstr ""

#. type: Title -
#: en/git-remote-ext.txt:65
#, no-wrap, priority:90
msgid "ENVIRONMENT VARIABLES PASSED TO COMMAND"
msgstr ""

#. type: Labeled list
#: en/git-remote-ext.txt:67
#, ignore-same, no-wrap, priority:90
msgid "GIT_EXT_SERVICE"
msgstr "GIT_EXT_SERVICE"

#. type: Plain text
#: en/git-remote-ext.txt:70
#, ignore-ellipsis, priority:90
msgid "Set to long name (git-upload-pack, etc...) of service helper needs to invoke."
msgstr ""

#. type: Labeled list
#: en/git-remote-ext.txt:71
#, ignore-same, no-wrap, priority:90
msgid "GIT_EXT_SERVICE_NOPREFIX"
msgstr "GIT_EXT_SERVICE_NOPREFIX"

#. type: Plain text
#: en/git-remote-ext.txt:74
#, ignore-ellipsis, priority:90
msgid "Set to long name (upload-pack, etc...) of service helper needs to invoke."
msgstr ""

#. type: Plain text
#: en/git-remote-ext.txt:82
#, priority:90
msgid "This remote helper is transparently used by Git when you use commands such as \"git fetch <URL>\", \"git clone <URL>\", , \"git push <URL>\" or \"git remote add <nick> <URL>\", where <URL> begins with `ext::`.  Examples:"
msgstr ""

#. type: Labeled list
#: en/git-remote-ext.txt:83
#, no-wrap, priority:90
msgid "\"ext::ssh -i /home/foo/.ssh/somekey user&#64;host.example %S 'foo/repo'\""
msgstr ""

#. type: Plain text
#: en/git-remote-ext.txt:87
#, priority:90
msgid "Like host.example:foo/repo, but use /home/foo/.ssh/somekey as keypair and user as user on remote side. This avoids needing to edit .ssh/config."
msgstr ""

#. type: Labeled list
#: en/git-remote-ext.txt:88
#, no-wrap, priority:90
msgid "\"ext::socat -t3600 - ABSTRACT-CONNECT:/git-server %G/somerepo\""
msgstr ""

#. type: Plain text
#: en/git-remote-ext.txt:91
#, priority:90
msgid "Represents repository with path /somerepo accessible over git protocol at abstract namespace address /git-server."
msgstr ""

#. type: Labeled list
#: en/git-remote-ext.txt:92
#, no-wrap, priority:90
msgid "\"ext::git-server-alias foo %G/repo\""
msgstr ""

#. type: Plain text
#: en/git-remote-ext.txt:98
#, priority:90
msgid "Represents a repository with path /repo accessed using the helper program \"git-server-alias foo\".  The path to the repository and type of request are not passed on the command line but as part of the protocol stream, as usual with git:// protocol."
msgstr ""

#. type: Labeled list
#: en/git-remote-ext.txt:99
#, no-wrap, priority:90
msgid "\"ext::git-server-alias foo %G/repo %Vfoo\""
msgstr ""

#. type: Plain text
#: en/git-remote-ext.txt:105
#, priority:90
msgid "Represents a repository with path /repo accessed using the helper program \"git-server-alias foo\".  The hostname for the remote server passed in the protocol stream will be \"foo\" (this allows multiple virtual Git servers to share a link-level address)."
msgstr ""

#. type: Labeled list
#: en/git-remote-ext.txt:106
#, no-wrap, priority:90
msgid "\"ext::git-server-alias foo %G/repo% with% spaces %Vfoo\""
msgstr ""

#. type: Plain text
#: en/git-remote-ext.txt:112
#, priority:90
msgid "Represents a repository with path `/repo with spaces` accessed using the helper program \"git-server-alias foo\".  The hostname for the remote server passed in the protocol stream will be \"foo\" (this allows multiple virtual Git servers to share a link-level address)."
msgstr ""

#. type: Labeled list
#: en/git-remote-ext.txt:113
#, no-wrap, priority:90
msgid "\"ext::git-ssl foo.example /bar\""
msgstr ""

#. type: Plain text
#: en/git-remote-ext.txt:118
#, priority:90
msgid "Represents a repository accessed using the helper program \"git-ssl foo.example /bar\".  The type of request can be determined by the helper using environment variables (see above)."
msgstr ""

#. type: Title =
#: en/git-remote-fd.txt:2
#, ignore-same, no-wrap, priority:90
msgid "git-remote-fd(1)"
msgstr "git-remote-fd(1)"

#. type: Plain text
#: en/git-remote-fd.txt:7
#, priority:90
msgid "git-remote-fd - Reflect smart transport stream back to caller"
msgstr ""

#. type: Plain text
#: en/git-remote-fd.txt:11
#, priority:90
msgid "\"fd::<infd>[,<outfd>][/<anything>]\" (as URL)"
msgstr ""

#. type: Plain text
#: en/git-remote-fd.txt:17
#, priority:90
msgid "This helper uses specified file descriptors to connect to a remote Git server.  This is not meant for end users but for programs and scripts calling git fetch, push or archive."
msgstr ""

#. type: Plain text
#: en/git-remote-fd.txt:23
#, priority:90
msgid "If only <infd> is given, it is assumed to be a bidirectional socket connected to remote Git server (git-upload-pack, git-receive-pack or git-upload-archive). If both <infd> and <outfd> are given, they are assumed to be pipes connected to a remote Git server (<infd> being the inbound pipe and <outfd> being the outbound pipe."
msgstr ""

#. type: Plain text
#: en/git-remote-fd.txt:26
#, priority:90
msgid "It is assumed that any handshaking procedures have already been completed (such as sending service request for git://) before this helper is started."
msgstr ""

#. type: Plain text
#: en/git-remote-fd.txt:30
#, priority:90
msgid "<anything> can be any string. It is ignored. It is meant for providing information to user in the URL in case that URL is displayed in some context."
msgstr ""

#. type: Labeled list
#: en/git-remote-fd.txt:38
#, no-wrap, priority:90
msgid "`git fetch fd::17 master`"
msgstr ""

#. type: Plain text
#: en/git-remote-fd.txt:41
#, priority:90
msgid "Fetch master, using file descriptor #17 to communicate with git-upload-pack."
msgstr ""

#. type: Labeled list
#: en/git-remote-fd.txt:42
#, no-wrap, priority:90
msgid "`git fetch fd::17/foo master`"
msgstr ""

#. type: Labeled list
#: en/git-remote-fd.txt:45
#, fuzzy, no-wrap, priority:90
msgid "`git push fd::7,8 master (as URL)`"
msgstr "`git push fd::7,8 master (as URL)`"

#. type: Plain text
#: en/git-remote-fd.txt:49
#, priority:90
msgid "Push master, using file descriptor #7 to read data from git-receive-pack and file descriptor #8 to write data to same service."
msgstr ""

#. type: Labeled list
#: en/git-remote-fd.txt:50
#, no-wrap, priority:90
msgid "`git push fd::7,8/bar master`"
msgstr ""

#. type: Title =
#: en/git-remote.txt:2
#, ignore-same, no-wrap, priority:220
msgid "git-remote(1)"
msgstr "git-remote(1)"

#. type: Plain text
#: en/git-remote.txt:7
#, fuzzy, priority:220
msgid "git-remote - Manage set of tracked repositories"
msgstr "git-remote - Manage set of tracked repositories"

#. type: Plain text
#: en/git-remote.txt:25
#, fuzzy, ignore-ellipsis, no-wrap, priority:220
msgid ""
"'git remote' [-v | --verbose]\n"
"'git remote add' [-t <branch>] [-m <master>] [-f] [--[no-]tags] [--mirror=(fetch|push)] <name> <URL>\n"
"'git remote rename' [--[no-]progress] <old> <new>\n"
"'git remote remove' <name>\n"
"'git remote set-head' <name> (-a | --auto | -d | --delete | <branch>)\n"
"'git remote set-branches' [--add] <name> <branch>...\n"
"'git remote get-url' [--push] [--all] <name>\n"
"'git remote set-url' [--push] <name> <newurl> [<oldurl>]\n"
"'git remote set-url --add' [--push] <name> <newurl>\n"
"'git remote set-url --delete' [--push] <name> <URL>\n"
"'git remote' [-v | --verbose] 'show' [-n] <name>...\n"
"'git remote prune' [-n | --dry-run] <name>...\n"
"'git remote' [-v | --verbose] 'update' [-p | --prune] [(<group> | <remote>)...]\n"
msgstr ""
"'git remote' [-v | --verbose]\n"
"'git remote add' [-t <分支>] [-m <master>] [-f] [--[no-]tags] [--mirror=(fetch|push)] <名称> <URL>\n"
"'git remote rename' [--[no-]progress] <旧名> <新名>\n"
"'git remote remove' <名称>\n"
"'git remote set-head' <名称> (-a | --auto | -d | --delete | <分支>)\n"
"'git remote set-branches' [--add] <名称> <branch>...\n"
"'git remote get-url' [--push] [--all] <名称>\n"
"'git remote set-url' [--push] <名称> <新url> [<旧url>]\n"
"'git remote set-url --add' [--push] <名称> <新url>\n"
"'git remote set-url --delete' [--push] <名称> <URL>\n"
"'git remote' [-v | --verbose] 'show' [-n] <名称>...\n"
"'git remote prune' [-n | --dry-run] <名称>...\n"
"'git remote' [-v | --verbose] 'update' [-p | --prune] [(<组> | <remote>)...]\n"

#. type: Plain text
#: en/git-remote.txt:30
#, priority:220
msgid "Manage the set of repositories (\"remotes\") whose branches you track."
msgstr "管理仓库（\"远程\"）的集合，这些仓库的分支由你跟踪。"

#. type: Plain text
#: en/git-remote.txt:41
#, priority:220
msgid "Be a little more verbose and show remote url after name.  For promisor remotes, also show which filter (`blob:none` etc.)  are configured.  NOTE: This must be placed between `remote` and subcommand."
msgstr "更详细一点，在名称后显示远程 URL。对于允诺者远程，还要显示配置了哪个过滤器(` blob: none` 等)。注意: 这必须放在 `remote` 和子命令之间。"

#. type: Plain text
#: en/git-remote.txt:48
#, priority:220
msgid "With no arguments, shows a list of existing remotes.  Several subcommands are available to perform operations on the remotes."
msgstr "不带参数，显示现有远程的列表。有几个子命令可用于对远程执行操作。"

#. type: Labeled list
#: en/git-remote.txt:49
#, fuzzy, no-wrap, priority:220
msgid "'add'"
msgstr "'add'"

#. type: Plain text
#: en/git-remote.txt:54
#, priority:220
msgid "Add a remote named <name> for the repository at <URL>.  The command `git fetch <name>` can then be used to create and update remote-tracking branches <name>/<branch>."
msgstr "在 <URL> 为存储库添加一个名为 <名称> 的远程名称。然后可以使用命令 `git get <名称>`创建和更新远程跟踪分支 <名称>/<分支> 。"

#. type: Plain text
#: en/git-remote.txt:57
#, priority:220
msgid "With `-f` option, `git fetch <name>` is run immediately after the remote information is set up."
msgstr "使用 `-f` 选项，在设置远程信息之后立即运行 `git get <名称>`。"

#. type: Plain text
#: en/git-remote.txt:60
#, priority:220
msgid "With `--tags` option, `git fetch <name>` imports every tag from the remote repository."
msgstr "使用 `--tag` 选项，`git get <名称>` 从远程仓库导入每个标记。"

#. type: Plain text
#: en/git-remote.txt:63
#, priority:220
msgid "With `--no-tags` option, `git fetch <name>` does not import tags from the remote repository."
msgstr "使用 `--no-tags` 选项，`git fetch <名称>` 不会从远程仓库导入标签。"

#. type: Plain text
#: en/git-remote.txt:66
#, priority:220
msgid "By default, only tags on fetched branches are imported (see linkgit:git-fetch[1])."
msgstr "默认情况下，只导入获取的分支上的标记（参见 linkgit:git-fetch[1]）。"

#. type: Plain text
#: en/git-remote.txt:72
#, priority:220
msgid "With `-t <branch>` option, instead of the default glob refspec for the remote to track all branches under the `refs/remotes/<name>/` namespace, a refspec to track only `<branch>` is created.  You can give more than one `-t <branch>` to track multiple branches without grabbing all branches."
msgstr "使用 `-t <分支>` 选项，将创建一个仅跟踪 `refs/remotes/<名称>/` 命名空间下的所有分支的引用规范，而不是用于远程跟踪的默认引用规范通配符。您可以提供多个 `-t <分支>` 来跟踪多个分支，而不需要获取所有分支。"

#. type: Plain text
#: en/git-remote.txt:75
#, priority:220
msgid "With `-m <master>` option, a symbolic-ref `refs/remotes/<name>/HEAD` is set up to point at remote's `<master>` branch. See also the set-head command."
msgstr "使用 `-m <master>` 选项，可以设置一个符号引用 `/remotes/<名称>/HEAD` 来指向远程仓库的 `<master>` 分支。另请参见 set-head 命令。"

#. type: Plain text
#: en/git-remote.txt:81
#, priority:220
msgid "When a fetch mirror is created with `--mirror=fetch`, the refs will not be stored in the 'refs/remotes/' namespace, but rather everything in 'refs/' on the remote will be directly mirrored into 'refs/' in the local repository. This option only makes sense in bare repositories, because a fetch would overwrite any local commits."
msgstr "当用 `--mirror=fetch` 创建一个 fetch 镜像时， 引用不会被存储在 'refs/remotes/' 命名空间中，而是远程的 'refs/' 中的所有内容将直接被镜像到本地版本库的 'refs/' 中。这个选项只有在裸库中才有意义，因为获取会覆盖任何本地提交。"

#. type: Plain text
#: en/git-remote.txt:84
#, priority:220
msgid "When a push mirror is created with `--mirror=push`, then `git push` will always behave as if `--mirror` was passed."
msgstr "当用 `--mirror=push` 创建推送镜像时，`git push` 的行为就像传递 `--mirror` 一样。"

#. type: Labeled list
#: en/git-remote.txt:85
#, fuzzy, no-wrap, priority:220
msgid "'rename'"
msgstr "'rebase'"

#. type: Plain text
#: en/git-remote.txt:89
#, priority:220
msgid "Rename the remote named <old> to <new>. All remote-tracking branches and configuration settings for the remote are updated."
msgstr "将名为 < 旧名称 > 的远程重命名为 < 新名称 > 。所有远程跟踪的分支和远程的配置设置都被更新。"

#. type: Plain text
#: en/git-remote.txt:93
#, priority:220
msgid "In case <old> and <new> are the same, and <old> is a file under `$GIT_DIR/remotes` or `$GIT_DIR/branches`, the remote is converted to the configuration file format."
msgstr "如果 <旧名称 >和< 新名称 >相同，并且< 旧名称 >是 `$GIT_DIR/remotes` 或 `$GIT_DIR/branches` 下的文件，远程将被转换为配置文件格式。"

#. type: Labeled list
#: en/git-remote.txt:94
#, fuzzy, no-wrap, priority:220
msgid "'remove'"
msgstr "'remove'"

#. type: Labeled list
#: en/git-remote.txt:95
#, fuzzy, no-wrap, priority:220
msgid "'rm'"
msgstr "'rm'"

#. type: Plain text
#: en/git-remote.txt:99
#, priority:220
msgid "Remove the remote named <name>. All remote-tracking branches and configuration settings for the remote are removed."
msgstr "删除名为 < 名称 > 的远程。该远程的所有远程跟踪分支和配置设置都被删除。"

#. type: Labeled list
#: en/git-remote.txt:100
#, no-wrap, priority:220
msgid "'set-head'"
msgstr "'set-head'"

#. type: Plain text
#: en/git-remote.txt:109
#, priority:220
msgid "Sets or deletes the default branch (i.e. the target of the symbolic-ref `refs/remotes/<name>/HEAD`) for the named remote. Having a default branch for a remote is not required, but allows the name of the remote to be specified in lieu of a specific branch. For example, if the default branch for `origin` is set to `master`, then `origin` may be specified wherever you would normally specify `origin/master`."
msgstr "设置或删除命名远程仓库的默认分支（即符号引用 `refs/remotes/<名称>/HEAD` 的目标）。不需要为远程仓库设置默认分支，但允许指定远程仓库的名称来代替特定分支。例如，如果 `origin` 的默认分支设置为 `master`，则可以在通常指定 `origin/master` 的任何位置指定 `origin`。"

#. type: Plain text
#: en/git-remote.txt:111
#, priority:220
msgid "With `-d` or `--delete`, the symbolic ref `refs/remotes/<name>/HEAD` is deleted."
msgstr "设置 `-d` 或 `--delete` 选项，符号引用 `refs/remotes/<名称>/HEAD` 将被删除."

#. type: Plain text
#: en/git-remote.txt:118
#, priority:220
msgid "With `-a` or `--auto`, the remote is queried to determine its `HEAD`, then the symbolic-ref `refs/remotes/<name>/HEAD` is set to the same branch. e.g., if the remote `HEAD` is pointed at `next`, `git remote set-head origin -a` will set the symbolic-ref `refs/remotes/origin/HEAD` to `refs/remotes/origin/next`. This will only work if `refs/remotes/origin/next` already exists; if not it must be fetched first."
msgstr "使用 `-a` 或 `--auto`，查询远程仓库以确定其 `HEAD`，然后将符号引用 `refs/remotes/<名称>/HEAD` 设置为同一分支。 例如，如果远程 `HEAD` 指向`next`，`git remote set-head origin -a`会将符号引用 `refs/remotes/origin/HEAD` 设置为 `refs/remotes/origin/next`。这仅在 `refs/remotes/origin/next` 已经存在时才有效；如果不是，则必须首先获取它。"

#. type: Plain text
#: en/git-remote.txt:123
#, priority:220
msgid "Use `<branch>` to set the symbolic-ref `refs/remotes/<name>/HEAD` explicitly. e.g., `git remote set-head origin master` will set the symbolic-ref `refs/remotes/origin/HEAD` to `refs/remotes/origin/master`. This will only work if `refs/remotes/origin/master` already exists; if not it must be fetched first."
msgstr "使用 `<branch>` 显式地设置符号引用 `refs/remotes/<名称>/HEAD`。例如，`git remote set-head source master` 会将这个符号引用 ` refs/remotes/source/HEAD`设置为 `ref/remotes/source/master`。这只有在 `refs/remote/source/master` 已经存在的情况下才能工作；如果不存在，则必须首先获取它。"

#. type: Labeled list
#: en/git-remote.txt:125
#, no-wrap, priority:220
msgid "'set-branches'"
msgstr "'set-branches'"

#. type: Plain text
#: en/git-remote.txt:130
#, priority:220
msgid "Changes the list of branches tracked by the named remote.  This can be used to track a subset of the available remote branches after the initial setup for a remote."
msgstr "改变命名的远程所追踪的分支列表。 这可以用来在最初设置一个远程分支后，追踪一个可用的远程分支子集。"

#. type: Plain text
#: en/git-remote.txt:133
#, priority:220
msgid "The named branches will be interpreted as if specified with the `-t` option on the `git remote add` command line."
msgstr "被命名的分支将被解释为在 `git remote add`命令中用 `-t` 选项指定的。"

#. type: Plain text
#: en/git-remote.txt:136
#, priority:220
msgid "With `--add`, instead of replacing the list of currently tracked branches, adds to that list."
msgstr "使用 `--add`，不是替换当前跟踪分支列表，而是添加到该列表中。"

#. type: Labeled list
#: en/git-remote.txt:137
#, fuzzy, no-wrap, priority:220
msgid "'get-url'"
msgstr "'get-url'"

#. type: Plain text
#: en/git-remote.txt:141
#, priority:220
msgid "Retrieves the URLs for a remote. Configurations for `insteadOf` and `pushInsteadOf` are expanded here. By default, only the first URL is listed."
msgstr "检索一个远程的 URLs。`insteadOf` 和 `pushInsteadOf` 的配置在此列出。默认情况下，只有第一个 URL 被列出。"

#. type: Plain text
#: en/git-remote.txt:143
#, priority:220
msgid "With `--push`, push URLs are queried rather than fetch URLs."
msgstr "使用 `--push`，查询的是推送的URLs，而不是获取的URLs。"

#. type: Plain text
#: en/git-remote.txt:145
#, priority:220
msgid "With `--all`, all URLs for the remote will be listed."
msgstr "使用 `--all`选项，远程仓库的所有 URL 将被列出。"

#. type: Labeled list
#: en/git-remote.txt:146
#, no-wrap, priority:220
msgid "'set-url'"
msgstr "'set-url'"

#. type: Plain text
#: en/git-remote.txt:151
#, priority:220
msgid "Changes URLs for the remote. Sets first URL for remote <name> that matches regex <oldurl> (first URL if no <oldurl> is given) to <newurl>. If <oldurl> doesn't match any URL, an error occurs and nothing is changed."
msgstr "改变远程的URLs。将远程 <名称> 的第一个匹配正则表达式 <旧url> 的URL（如果没有给出 <旧url>，则为第一个URL）设置为 <新url>。如果 <旧url> 不匹配任何URL，就会发生错误，并且什么都不会被改变。"

#. type: Plain text
#: en/git-remote.txt:153
#, priority:220
msgid "With `--push`, push URLs are manipulated instead of fetch URLs."
msgstr "使用 `--push` ，推送 URLs 被操作，而不是获取 URLs。"

#. type: Plain text
#: en/git-remote.txt:155
#, priority:220
msgid "With `--add`, instead of changing existing URLs, new URL is added."
msgstr "使用 `--add`，不改变现有的 URLs，而是添加新的 URL。"

#. type: Plain text
#: en/git-remote.txt:159
#, priority:220
msgid "With `--delete`, instead of changing existing URLs, all URLs matching regex <URL> are deleted for remote <name>.  Trying to delete all non-push URLs is an error."
msgstr "使用 `--delete`选项，不是改变现有的 URL，而是删除远程 <名称> 的所有正则匹配 <URL> 的 URL。 试图删除所有非推送 URLs 是错的。"

#. type: Plain text
#: en/git-remote.txt:166
#, priority:220
msgid "Note that the push URL and the fetch URL, even though they can be set differently, must still refer to the same place.  What you pushed to the push URL should be what you would see if you immediately fetched from the fetch URL.  If you are trying to fetch from one place (e.g. your upstream) and push to another (e.g.  your publishing repository), use two separate remotes."
msgstr "请注意，推送 URL 和获取 URL，即使它们的设置不同，也必须指的是同一个地方。 你推送到推送 URL 的内容应该是你立即从获取的 URL 中获取的内容。 如果你试图从一个地方（如你的上游）获取并推送到另一个地方（如你的发布库），请使用两个独立的远程。"

#. type: Labeled list
#: en/git-remote.txt:168
#, no-wrap, priority:220
msgid "'show'"
msgstr "'show'"

#. type: Plain text
#: en/git-remote.txt:171
#, priority:220
msgid "Gives some information about the remote <name>."
msgstr "提供关于远程 <名称> 的一些信息。"

#. type: Plain text
#: en/git-remote.txt:174
#, priority:220
msgid "With `-n` option, the remote heads are not queried first with `git ls-remote <name>`; cached information is used instead."
msgstr "使用 `-n` 选项，就不会先用 `git ls-remote <名称>` 查询远程头指针，而是使用缓存的信息。"

#. type: Labeled list
#: en/git-remote.txt:175
#, fuzzy, no-wrap, priority:220
msgid "'prune'"
msgstr "'prune'"

#. type: Plain text
#: en/git-remote.txt:182
#, priority:220
msgid "Deletes stale references associated with <name>. By default, stale remote-tracking branches under <name> are deleted, but depending on global configuration and the configuration of the remote we might even prune local tags that haven't been pushed there. Equivalent to `git fetch --prune <name>`, except that no new references will be fetched."
msgstr "删除与 <名称> 相关的陈旧引用。默认情况下，<名称>下的陈旧远程跟踪分支会被删除，但根据全局配置和远程的配置，我们甚至可能修剪没有被推送到那里的本地标签。相当于 `git fetch --prune <名称>`，只是不会取到新的引用。"

#. type: Plain text
#: en/git-remote.txt:185
#, priority:220
msgid "See the PRUNING section of linkgit:git-fetch[1] for what it'll prune depending on various configuration."
msgstr "参见 linkgit:git-fetch[1] 的剪枝部分，了解它将根据不同的配置修剪什么。"

#. type: Plain text
#: en/git-remote.txt:188
#, priority:220
msgid "With `--dry-run` option, report what branches would be pruned, but do not actually prune them."
msgstr "使用 `--dry-run` 选项，报告哪些分支将被修剪，但实际上不修剪它们。"

#. type: Labeled list
#: en/git-remote.txt:189
#, fuzzy, no-wrap, priority:220
msgid "'update'"
msgstr "'update'"

#. type: Plain text
#: en/git-remote.txt:197
#, priority:220
msgid "Fetch updates for remotes or remote groups in the repository as defined by `remotes.<group>`. If neither group nor remote is specified on the command line, the configuration parameter remotes.default will be used; if remotes.default is not defined, all remotes which do not have the configuration parameter `remote.<name>.skipDefaultUpdate` set to true will be updated.  (See linkgit:git-config[1])."
msgstr "为仓库中由 `remotes.<组>` 定义的远程或远程组获取更新。如果在命令行中既没有指定组也没有指定远程，将使用配置参数 remotes.default；如果没有定义 remotes.default，所有没有将配置参数 `remote.<名称>.skipDefaultUpdate` 设置为 true 的远程将被更新。 (参见 linkgit:git-config[1]）。"

#. type: Plain text
#: en/git-remote.txt:199
#, priority:220
msgid "With `--prune` option, run pruning against all the remotes that are updated."
msgstr "使用 `--prune` 选项，对所有被更新的远程进行修剪。"

#. type: Plain text
#: en/git-remote.txt:207
#, priority:220
msgid "The remote configuration is achieved using the `remote.origin.url` and `remote.origin.fetch` configuration variables.  (See linkgit:git-config[1])."
msgstr "远程配置是通过 `remote.origin.url` 和 `remote.origin.fetch` 配置变量实现的。 (见 linkgit:git-config[1]）。"

#. type: Plain text
#: en/git-remote.txt:212
#, priority:220
msgid "On success, the exit status is `0`."
msgstr "成功的时候，退出状态码为 `0`。"

#. type: Plain text
#: en/git-remote.txt:216
#, priority:220
msgid "When subcommands such as 'add', 'rename', and 'remove' can't find the remote in question, the exit status is `2`. When the remote already exists, the exit status is `3`."
msgstr "当诸如 'add'、'rename' 和 'remove' 等子命令不能找到相关的远程，退出状态码为 `2`。当远程已经存在时，退出状态码是 `3`。"

#. type: Plain text
#: en/git-remote.txt:218
#, priority:220
msgid "On any other error, the exit status may be any other non-zero value."
msgstr "对于其他错误，退出状态码可能是任何其他非零值。"

#. type: Plain text
#: en/git-remote.txt:223
#, priority:220
msgid "Add a new remote, fetch, and check out a branch from it"
msgstr "添加一个新的远程，获取并检出一个分支"

#. type: delimited block -
#: en/git-remote.txt:248
#, ignore-ellipsis, no-wrap, priority:220
msgid ""
"$ git remote\n"
"origin\n"
"$ git branch -r\n"
"  origin/HEAD -> origin/master\n"
"  origin/master\n"
"$ git remote add staging git://git.kernel.org/.../gregkh/staging.git\n"
"$ git remote\n"
"origin\n"
"staging\n"
"$ git fetch staging\n"
"...\n"
"From git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/staging\n"
" * [new branch]      master     -> staging/master\n"
" * [new branch]      staging-linus -> staging/staging-linus\n"
" * [new branch]      staging-next -> staging/staging-next\n"
"$ git branch -r\n"
"  origin/HEAD -> origin/master\n"
"  origin/master\n"
"  staging/master\n"
"  staging/staging-linus\n"
"  staging/staging-next\n"
"$ git switch -c staging staging/master\n"
"...\n"
msgstr ""
"$ git remote\n"
"origin\n"
"$ git branch -r\n"
"  origin/HEAD -> origin/master\n"
"  origin/master\n"
"$ git remote add staging git://git.kernel.org/.../gregkh/staging.git\n"
"$ git remote\n"
"origin\n"
"staging\n"
"$ git fetch staging\n"
"...\n"
"From git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/staging\n"
" * [new branch]      master     -> staging/master\n"
" * [new branch]      staging-linus -> staging/staging-linus\n"
" * [new branch]      staging-next -> staging/staging-next\n"
"$ git branch -r\n"
"  origin/HEAD -> origin/master\n"
"  origin/master\n"
"  staging/master\n"
"  staging/staging-linus\n"
"  staging/staging-next\n"
"$ git switch -c staging staging/master\n"
"...\n"

#. type: Plain text
#: en/git-remote.txt:251
#, priority:220
msgid "Imitate 'git clone' but track only selected branches"
msgstr "模仿 'git clone'，但只跟踪选定的分支"

#. type: delimited block -
#: en/git-remote.txt:258
#, fuzzy, no-wrap, priority:220
msgid ""
"$ mkdir project.git\n"
"$ cd project.git\n"
"$ git init\n"
"$ git remote add -f -t master -m master origin git://example.com/git.git/\n"
"$ git merge origin\n"
msgstr ""
"$ mkdir project.git\n"
"$ cd project.git\n"
"$ git init\n"
"$ git remote add -f -t master -m master origin git://example.com/git.git/\n"
"$ git merge origin\n"

#. type: Plain text
#: en/git-remote.txt:266
#, ignore-same, priority:220
msgid "linkgit:git-fetch[1] linkgit:git-branch[1] linkgit:git-config[1]"
msgstr "linkgit:git-fetch[1] linkgit:git-branch[1] linkgit:git-config[1]"

#. type: Title =
#: en/git-repack.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-repack(1)"
msgstr "git-repack(1)"

#. type: Plain text
#: en/git-repack.txt:7
#, fuzzy, priority:100
msgid "git-repack - Pack unpacked objects in a repository"
msgstr "git-repack - Pack unpacked objects in a repository"

#. type: Plain text
#: en/git-repack.txt:13
#, fuzzy, no-wrap, priority:100
msgid "'git repack' [-a] [-A] [-d] [-f] [-F] [-l] [-n] [-q] [-b] [-m] [--window=<n>] [--depth=<n>] [--threads=<n>] [--keep-pack=<pack-name>] [--write-midx]\n"
msgstr "'git repack' [-a] [-A] [-d] [-f] [-F] [-l] [-n] [-q] [-b] [--window=<n>] [--depth=<n>] [--threads=<n>] [--keep-pack=<pack-name>]\n"

#. type: Plain text
#: en/git-repack.txt:20
#, priority:100
msgid "This command is used to combine all objects that do not currently reside in a \"pack\", into a pack.  It can also be used to re-organize existing packs into a single, more efficient pack."
msgstr ""

#. type: Plain text
#: en/git-repack.txt:39
#, priority:100
msgid "Instead of incrementally packing the unpacked objects, pack everything referenced into a single pack.  Especially useful when packing a repository that is used for private development. Use with `-d`.  This will clean up the objects that `git prune` leaves behind, but `git fsck --full --dangling` shows as dangling."
msgstr ""

#. type: Plain text
#: en/git-repack.txt:43
#, priority:100
msgid "Note that users fetching over dumb protocols will have to fetch the whole new pack in order to get any contained object, no matter how many other objects in that pack they already have locally."
msgstr ""

#. type: Plain text
#: en/git-repack.txt:48
#, priority:100
msgid "Promisor packfiles are repacked separately: if there are packfiles that have an associated \".promisor\" file, these packfiles will be repacked into another separate pack, and an empty \".promisor\" file corresponding to the new separate pack will be written."
msgstr ""

#. type: Plain text
#: en/git-repack.txt:59
#, priority:100
msgid "Same as `-a`, unless `-d` is used.  Then any unreachable objects in a previous pack become loose, unpacked objects, instead of being left in the old pack.  Unreachable objects are never intentionally added to a pack, even when repacking.  This option prevents unreachable objects from being immediately deleted by way of being left in the old pack and then removed.  Instead, the loose unreachable objects will be pruned according to normal expiry rules with the next 'git gc' invocation. See linkgit:git-gc[1]."
msgstr ""

#. type: Plain text
#: en/git-repack.txt:65
#, priority:100
msgid "After packing, if the newly created packs make some existing packs redundant, remove the redundant packs.  Also run 'git prune-packed' to remove redundant loose object files."
msgstr ""

#. type: Plain text
#: en/git-repack.txt:71
#, priority:100
msgid "Same as `-a`, unless `-d` is used. Then any unreachable objects are packed into a separate cruft pack. Unreachable objects can be pruned using the normal expiry rules with the next `git gc` invocation (see linkgit:git-gc[1]). Incompatible with `-k`."
msgstr ""

#. type: Plain text
#: en/git-repack.txt:76
#, priority:100
msgid "Expire unreachable objects older than `<approxidate>` immediately instead of waiting for the next `git gc` invocation.  Only useful with `--cruft -d`."
msgstr ""

#. type: Labeled list
#: en/git-repack.txt:77
#, fuzzy, no-wrap, priority:100
msgid "--expire-to=<dir>"
msgstr "--directory=<dir>"

#. type: Plain text
#: en/git-repack.txt:82
#, priority:100
msgid "Write a cruft pack containing pruned objects (if any) to the directory `<dir>`. This option is useful for keeping a copy of any pruned objects in a separate directory as a backup. Only useful with `--cruft -d`."
msgstr ""

#. type: Plain text
#: en/git-repack.txt:86
#, priority:100
msgid "Pass the `--local` option to 'git pack-objects'. See linkgit:git-pack-objects[1]."
msgstr ""

#. type: Plain text
#: en/git-repack.txt:90
#, priority:100
msgid "Pass the `--no-reuse-delta` option to `git-pack-objects`, see linkgit:git-pack-objects[1]."
msgstr ""

#. type: Plain text
#: en/git-repack.txt:94
#, priority:100
msgid "Pass the `--no-reuse-object` option to `git-pack-objects`, see linkgit:git-pack-objects[1]."
msgstr ""

#. type: Plain text
#: en/git-repack.txt:99
#, priority:100
msgid "Show no progress over the standard error stream and pass the `-q` option to 'git pack-objects'. See linkgit:git-pack-objects[1]."
msgstr ""

#. type: Plain text
#: en/git-repack.txt:106
#, priority:100
msgid "Do not update the server information with 'git update-server-info'.  This option skips updating local catalog files needed to publish this repository (or a direct copy of it)  over HTTP or FTP.  See linkgit:git-update-server-info[1]."
msgstr ""

#. type: Plain text
#: en/git-repack.txt:116
#, priority:100
msgid "These two options affect how the objects contained in the pack are stored using delta compression. The objects are first internally sorted by type, size and optionally names and compared against the other objects within `--window` to see if using delta compression saves space. `--depth` limits the maximum delta depth; making it too deep affects the performance on the unpacker side, because delta data needs to be applied that many times to get to the necessary object."
msgstr ""

#. type: Plain text
#: en/git-repack.txt:122
#, priority:100
msgid "This option is passed through to `git pack-objects`."
msgstr ""

#. type: Plain text
#: en/git-repack.txt:135
#, priority:100
msgid "This option provides an additional limit on top of `--window`; the window size will dynamically scale down so as to not take up more than '<n>' bytes in memory.  This is useful in repositories with a mix of large and small objects to not run out of memory with a large window, but still be able to take advantage of the large window for the smaller objects.  The size can be suffixed with \"k\", \"m\", or \"g\".  `--window-memory=0` makes memory usage unlimited.  The default is taken from the `pack.windowMemory` configuration variable.  Note that the actual memory usage will be the limit multiplied by the number of threads used by linkgit:git-pack-objects[1]."
msgstr ""

#. type: Plain text
#: en/git-repack.txt:145
#, priority:100
msgid "Maximum size of each output pack file. The size can be suffixed with \"k\", \"m\", or \"g\". The minimum size allowed is limited to 1 MiB.  If specified, multiple packfiles may be created, which also prevents the creation of a bitmap index.  The default is unlimited, unless the config variable `pack.packSizeLimit` is set. Note that this option may result in a larger and slower repository; see the discussion in `pack.packSizeLimit`."
msgstr ""

#. type: Labeled list
#: en/git-repack.txt:147
#, ignore-same, no-wrap, priority:100
msgid "--write-bitmap-index"
msgstr "--write-bitmap-index"

#. type: Plain text
#: en/git-repack.txt:154
#, priority:100
msgid "Write a reachability bitmap index as part of the repack. This only makes sense when used with `-a`, `-A` or `-m`, as the bitmaps must be able to refer to all reachable objects. This option overrides the setting of `repack.writeBitmaps`. This option has no effect if multiple packfiles are created, unless writing a MIDX (in which case a multi-pack bitmap is created)."
msgstr ""

#. type: Labeled list
#: en/git-repack.txt:155
#, ignore-same, no-wrap, priority:100
msgid "--pack-kept-objects"
msgstr "--pack-kept-objects"

#. type: Plain text
#: en/git-repack.txt:163
#, priority:100
msgid "Include objects in `.keep` files when repacking.  Note that we still do not delete `.keep` packs after `pack-objects` finishes.  This means that we may duplicate objects, but this makes the option safe to use when there are concurrent pushes or fetches.  This option is generally only useful if you are writing bitmaps with `-b` or `repack.writeBitmaps`, as it ensures that the bitmapped packfile has the necessary objects."
msgstr ""

#. type: Plain text
#: en/git-repack.txt:170
#, priority:100
msgid "Exclude the given pack from repacking. This is the equivalent of having `.keep` file on the pack. `<pack-name>` is the pack file name without leading directory (e.g. `pack-123.pack`).  The option could be specified multiple times to keep multiple packs."
msgstr ""

#. type: Labeled list
#: en/git-repack.txt:171
#, fuzzy, no-wrap, priority:100
msgid "--unpack-unreachable=<when>"
msgstr "--unpack-unreachable=<when>"

#. type: Plain text
#: en/git-repack.txt:176
#, priority:100
msgid "When loosening unreachable objects, do not bother loosening any objects older than `<when>`. This can be used to optimize out the write of any objects that would be immediately pruned by a follow-up `git prune`."
msgstr ""

#. type: Plain text
#: en/git-repack.txt:183
#, priority:100
msgid "When used with `-ad`, any unreachable objects from existing packs will be appended to the end of the packfile instead of being removed. In addition, any unreachable loose objects will be packed (and their loose counterparts removed)."
msgstr ""

#. type: Plain text
#: en/git-repack.txt:188
#, priority:100
msgid "Pass the `--delta-islands` option to `git-pack-objects`, see linkgit:git-pack-objects[1]."
msgstr ""

#. type: Labeled list
#: en/git-repack.txt:189
#, no-wrap, priority:100
msgid "-g=<factor>"
msgstr ""

#. type: Labeled list
#: en/git-repack.txt:190
#, no-wrap, priority:100
msgid "--geometric=<factor>"
msgstr ""

#. type: Plain text
#: en/git-repack.txt:194
#, priority:100
msgid "Arrange resulting pack structure so that each successive pack contains at least `<factor>` times the number of objects as the next-largest pack."
msgstr ""

#. type: Plain text
#: en/git-repack.txt:200
#, priority:100
msgid "`git repack` ensures this by determining a \"cut\" of packfiles that need to be repacked into one in order to ensure a geometric progression. It picks the smallest set of packfiles such that as many of the larger packfiles (by count of objects contained in that pack) may be left intact."
msgstr ""

#. type: Plain text
#: en/git-repack.txt:205
#, priority:100
msgid "Unlike other repack modes, the set of objects to pack is determined uniquely by the set of packs being \"rolled-up\"; in other words, the packs determined to need to be combined in order to restore a geometric progression."
msgstr ""

#. type: Plain text
#: en/git-repack.txt:211
#, priority:100
msgid "When `--unpacked` is specified, loose objects are implicitly included in this \"roll-up\", without respect to their reachability. This is subject to change in the future. This option (implying a drastically different repack mode) is not guaranteed to work with all other combinations of option to `git repack`."
msgstr ""

#. type: Plain text
#: en/git-repack.txt:215
#, priority:100
msgid "When writing a multi-pack bitmap, `git repack` selects the largest resulting pack as the preferred pack for object selection by the MIDX (see linkgit:git-multi-pack-index[1])."
msgstr ""

#. type: Labeled list
#: en/git-repack.txt:217
#, ignore-same, no-wrap, priority:100
msgid "--write-midx"
msgstr "--write-midx"

#. type: Plain text
#: en/git-repack.txt:220
#, priority:100
msgid "Write a multi-pack index (see linkgit:git-multi-pack-index[1])  containing the non-redundant packs."
msgstr ""

#. type: Plain text
#: en/git-repack.txt:236
#, priority:100
msgid "By default, the command passes `--delta-base-offset` option to 'git pack-objects'; this typically results in slightly smaller packs, but the generated packs are incompatible with versions of Git older than version 1.4.4. If you need to share your repository with such ancient Git versions, either directly or via the dumb http protocol, then you need to set the configuration variable `repack.UseDeltaBaseOffset` to \"false\" and repack. Access from old Git versions over the native protocol is unaffected by this option as the conversion is performed on the fly as needed in that case."
msgstr ""

#. type: Plain text
#: en/git-repack.txt:240
#, priority:100
msgid "Delta compression is not used on objects larger than the `core.bigFileThreshold` configuration variable and on files with the attribute `delta` set to false."
msgstr ""

#. type: Plain text
#: en/git-repack.txt:245
#, ignore-same, priority:100
msgid "linkgit:git-pack-objects[1] linkgit:git-prune-packed[1]"
msgstr "linkgit:git-pack-objects[1] linkgit:git-prune-packed[1]"

#. type: Title =
#: en/git-replace.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-replace(1)"
msgstr "git-replace(1)"

#. type: Plain text
#: en/git-replace.txt:7
#, priority:100
msgid "git-replace - Create, list, delete refs to replace objects"
msgstr ""

#. type: Plain text
#: en/git-replace.txt:17
#, fuzzy, ignore-ellipsis, no-wrap, priority:100
msgid ""
"'git replace' [-f] <object> <replacement>\n"
"'git replace' [-f] --edit <object>\n"
"'git replace' [-f] --graft <commit> [<parent>...]\n"
"'git replace' [-f] --convert-graft-file\n"
"'git replace' -d <object>...\n"
"'git replace' [--format=<format>] [-l [<pattern>]]\n"
msgstr ""
"'git replace' [-f] <object> <replacement>\n"
"'git replace' [-f] --edit <object>\n"
"'git replace' [-f] --graft <commit> [<parent>...]\n"
"'git replace' [-f] --convert-graft-file\n"
"'git replace' -d <object>...\n"
"'git replace' [--format=<format>] [-l [<pattern>]]\n"

#. type: Plain text
#: en/git-replace.txt:21
#, priority:100
msgid "Adds a 'replace' reference in `refs/replace/` namespace."
msgstr ""

#. type: Plain text
#: en/git-replace.txt:25
#, priority:100
msgid "The name of the 'replace' reference is the SHA-1 of the object that is replaced. The content of the 'replace' reference is the SHA-1 of the replacement object."
msgstr ""

#. type: Plain text
#: en/git-replace.txt:28
#, priority:100
msgid "The replaced object and the replacement object must be of the same type.  This restriction can be bypassed using `-f`."
msgstr ""

#. type: Plain text
#: en/git-replace.txt:30
#, priority:100
msgid "Unless `-f` is given, the 'replace' reference must not yet exist."
msgstr ""

#. type: Plain text
#: en/git-replace.txt:33
#, priority:100
msgid "There is no other restriction on the replaced and replacement objects.  Merge commits can be replaced by non-merge commits and vice versa."
msgstr ""

#. type: Plain text
#: en/git-replace.txt:37
#, priority:100
msgid "Replacement references will be used by default by all Git commands except those doing reachability traversal (prune, pack transfer and fsck)."
msgstr ""

#. type: Plain text
#: en/git-replace.txt:40
#, priority:100
msgid "It is possible to disable use of replacement references for any command using the `--no-replace-objects` option just after 'git'."
msgstr ""

#. type: Plain text
#: en/git-replace.txt:42
#, priority:100
msgid "For example if commit 'foo' has been replaced by commit 'bar':"
msgstr ""

#. type: delimited block -
#: en/git-replace.txt:45
#, fuzzy, no-wrap, priority:100
msgid "$ git --no-replace-objects cat-file commit foo\n"
msgstr "$ git --no-replace-objects cat-file commit foo\n"

#. type: Plain text
#: en/git-replace.txt:48
#, priority:100
msgid "shows information about commit 'foo', while:"
msgstr ""

#. type: delimited block -
#: en/git-replace.txt:51
#, fuzzy, no-wrap, priority:100
msgid "$ git cat-file commit foo\n"
msgstr "$ git cat-file commit foo\n"

#. type: Plain text
#: en/git-replace.txt:54
#, priority:100
msgid "shows information about commit 'bar'."
msgstr ""

#. type: Plain text
#: en/git-replace.txt:57
#, priority:100
msgid "The `GIT_NO_REPLACE_OBJECTS` environment variable can be set to achieve the same effect as the `--no-replace-objects` option."
msgstr ""

#. type: Plain text
#: en/git-replace.txt:64
#, priority:100
msgid "If an existing replace ref for the same object exists, it will be overwritten (instead of failing)."
msgstr ""

#. type: Plain text
#: en/git-replace.txt:68
#, priority:100
msgid "Delete existing replace refs for the given objects."
msgstr ""

#. type: Labeled list
#: en/git-replace.txt:69
#, fuzzy, no-wrap, priority:100
msgid "--edit <object>"
msgstr "--edit <object>"

#. type: Plain text
#: en/git-replace.txt:77
#, priority:100
msgid "Edit an object's content interactively. The existing content for <object> is pretty-printed into a temporary file, an editor is launched on the file, and the result is parsed to create a new object of the same type as <object>. A replacement ref is then created to replace <object> with the newly created object. See linkgit:git-var[1] for details about how the editor will be chosen."
msgstr ""

#. type: Plain text
#: en/git-replace.txt:85
#, priority:100
msgid "When editing, provide the raw object contents rather than pretty-printed ones. Currently this only affects trees, which will be shown in their binary form. This is harder to work with, but can help when repairing a tree that is so corrupted it cannot be pretty-printed. Note that you may need to configure your editor to cleanly read and write binary data."
msgstr ""

#. type: Labeled list
#: en/git-replace.txt:86
#, fuzzy, ignore-ellipsis, no-wrap, priority:100
msgid "--graft <commit> [<parent>...]"
msgstr "--graft <commit> [<parent>...]"

#. type: Plain text
#: en/git-replace.txt:93
#, ignore-ellipsis, priority:100
msgid "Create a graft commit. A new commit is created with the same content as <commit> except that its parents will be [<parent>...] instead of <commit>'s parents. A replacement ref is then created to replace <commit> with the newly created commit. Use `--convert-graft-file` to convert a `$GIT_DIR/info/grafts` file and use replace refs instead."
msgstr ""

#. type: Labeled list
#: en/git-replace.txt:94
#, ignore-same, no-wrap, priority:100
msgid "--convert-graft-file"
msgstr "--convert-graft-file"

#. type: Plain text
#: en/git-replace.txt:98
#, priority:100
msgid "Creates graft commits for all entries in `$GIT_DIR/info/grafts` and deletes that file upon success. The purpose is to help users with transitioning off of the now-deprecated graft file."
msgstr ""

#. type: Labeled list
#: en/git-replace.txt:99
#, fuzzy, no-wrap, priority:100
msgid "-l <pattern>"
msgstr "-l <pattern>"

#. type: Labeled list
#: en/git-replace.txt:100
#, fuzzy, no-wrap, priority:100
msgid "--list <pattern>"
msgstr "--list <pattern>"

#. type: Plain text
#: en/git-replace.txt:105
#, priority:100
msgid "List replace refs for objects that match the given pattern (or all if no pattern is given).  Typing \"git replace\" without arguments, also lists all replace refs."
msgstr ""

#. type: Plain text
#: en/git-replace.txt:110
#, priority:100
msgid "When listing, use the specified <format>, which can be one of 'short', 'medium' and 'long'. When omitted, the format defaults to 'short'."
msgstr ""

#. type: Title -
#: en/git-replace.txt:112
#, fuzzy, no-wrap, priority:100
msgid "FORMATS"
msgstr "模式"

#. type: Plain text
#: en/git-replace.txt:115
#, priority:100
msgid "The following format are available:"
msgstr ""

#. type: Plain text
#: en/git-replace.txt:117
#, fuzzy, priority:100
msgid "'short':"
msgstr "'short'："

#. type: Plain text
#: en/git-replace.txt:118
#, priority:100
msgid "<replaced sha1>"
msgstr ""

#. type: Plain text
#: en/git-replace.txt:119
#, fuzzy, priority:100
msgid "'medium':"
msgstr "'medium':"

#. type: Plain text
#: en/git-replace.txt:120
#, priority:100
msgid "<replaced sha1> -> <replacement sha1>"
msgstr ""

#. type: Plain text
#: en/git-replace.txt:121
#, fuzzy, priority:100
msgid "'long':"
msgstr "'long':"

#. type: Plain text
#: en/git-replace.txt:122
#, priority:100
msgid "<replaced sha1> (<replaced type>) -> <replacement sha1> (<replacement type>)"
msgstr ""

#. type: Title -
#: en/git-replace.txt:124
#, no-wrap, priority:100
msgid "CREATING REPLACEMENT OBJECTS"
msgstr ""

#. type: Plain text
#: en/git-replace.txt:131
#, priority:100
msgid "linkgit:git-hash-object[1], linkgit:git-rebase[1], and https://github.com/newren/git-filter-repo[git-filter-repo], among other git commands, can be used to create replacement objects from existing objects. The `--edit` option can also be used with 'git replace' to create a replacement object by editing an existing object."
msgstr ""

#. type: Plain text
#: en/git-replace.txt:137
#, priority:100
msgid "If you want to replace many blobs, trees or commits that are part of a string of commits, you may just want to create a replacement string of commits and then only replace the commit at the tip of the target string of commits with the commit at the tip of the replacement string of commits."
msgstr ""

#. type: Plain text
#: en/git-replace.txt:144
#, priority:100
msgid "Comparing blobs or trees that have been replaced with those that replace them will not work properly. And using `git reset --hard` to go back to a replaced commit will move the branch to the replacement commit instead of the replaced commit."
msgstr ""

#. type: Plain text
#: en/git-replace.txt:147
#, priority:100
msgid "There may be other problems when using 'git rev-list' related to pending objects."
msgstr ""

#. type: Plain text
#: en/git-replace.txt:158
#, fuzzy, priority:100
#| msgid "linkgit:git-status[1] linkgit:git-rm[1] linkgit:git-reset[1] linkgit:git-mv[1] linkgit:git-commit[1] linkgit:git-update-index[1]"
msgid "linkgit:git-hash-object[1] linkgit:git-rebase[1] linkgit:git-tag[1] linkgit:git-branch[1] linkgit:git-commit[1] linkgit:git-var[1] linkgit:git[1] https://github.com/newren/git-filter-repo[git-filter-repo]"
msgstr "linkgit:git-hash-object[1] linkgit:git-rebase[1] linkgit:git-tag[1] linkgit:git-branch[1] linkgit:git-commit[1] linkgit:git-var[1] linkgit:git[1] https://github.com/newren/git-filter-repo[git-filter-repo]"

#. type: Title =
#: en/git-request-pull.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-request-pull(1)"
msgstr "git-request-pull(1)"

#. type: Plain text
#: en/git-request-pull.txt:7
#, priority:100
msgid "git-request-pull - Generates a summary of pending changes"
msgstr ""

#. type: Plain text
#: en/git-request-pull.txt:12
#, no-wrap, priority:100
msgid "'git request-pull' [-p] <start> <URL> [<end>]\n"
msgstr ""

#. type: Plain text
#: en/git-request-pull.txt:20
#, priority:100
msgid "Generate a request asking your upstream project to pull changes into their tree.  The request, printed to the standard output, begins with the branch description, summarizes the changes and indicates from where they can be pulled."
msgstr ""

#. type: Plain text
#: en/git-request-pull.txt:25
#, priority:100
msgid "The upstream project is expected to have the commit named by `<start>` and the output asks it to integrate the changes you made since that commit, up to the commit named by `<end>`, by visiting the repository named by `<URL>`."
msgstr ""

#. type: Plain text
#: en/git-request-pull.txt:31
#, priority:100
msgid "Include patch text in the output."
msgstr ""

#. type: Labeled list
#: en/git-request-pull.txt:32
#, fuzzy, no-wrap, priority:100
msgid "<start>"
msgstr "<start>"

#. type: Plain text
#: en/git-request-pull.txt:35
#, priority:100
msgid "Commit to start at.  This names a commit that is already in the upstream history."
msgstr ""

#. type: Labeled list
#: en/git-request-pull.txt:36
#, no-wrap, priority:100
msgid "<URL>"
msgstr ""

#. type: Plain text
#: en/git-request-pull.txt:38
#, priority:100
msgid "The repository URL to be pulled from."
msgstr ""

#. type: Labeled list
#: en/git-request-pull.txt:39
#, fuzzy, no-wrap, priority:100
msgid "<end>"
msgstr "<end>"

#. type: Plain text
#: en/git-request-pull.txt:42
#, priority:100
msgid "Commit to end at (defaults to HEAD).  This names the commit at the tip of the history you are asking to be pulled."
msgstr ""

#. type: Plain text
#: en/git-request-pull.txt:47
#, priority:100
msgid "When the repository named by `<URL>` has the commit at a tip of a ref that is different from the ref you have locally, you can use the `<local>:<remote>` syntax, to have its local name, a colon `:`, and its remote name."
msgstr ""

#. type: Plain text
#: en/git-request-pull.txt:56
#, priority:100
msgid "Imagine that you built your work on your `master` branch on top of the `v1.0` release, and want it to be integrated to the project.  First you push that change to your public repository for others to see:"
msgstr ""

#. type: Plain text
#: en/git-request-pull.txt:58
#, no-wrap, priority:100
msgid "\tgit push https://git.ko.xz/project master\n"
msgstr ""

#. type: Plain text
#: en/git-request-pull.txt:60
#, priority:100
msgid "Then, you run this command:"
msgstr ""

#. type: Plain text
#: en/git-request-pull.txt:62
#, no-wrap, priority:100
msgid "\tgit request-pull v1.0 https://git.ko.xz/project master\n"
msgstr ""

#. type: Plain text
#: en/git-request-pull.txt:66
#, priority:100
msgid "which will produce a request to the upstream, summarizing the changes between the `v1.0` release and your `master`, to pull it from your public repository."
msgstr ""

#. type: Plain text
#: en/git-request-pull.txt:69
#, priority:100
msgid "If you pushed your change to a branch whose name is different from the one you have locally, e.g."
msgstr ""

#. type: Plain text
#: en/git-request-pull.txt:71
#, no-wrap, priority:100
msgid "\tgit push https://git.ko.xz/project master:for-linus\n"
msgstr ""

#. type: Plain text
#: en/git-request-pull.txt:73
#, priority:100
msgid "then you can ask that to be pulled with"
msgstr ""

#. type: Plain text
#: en/git-request-pull.txt:75
#, no-wrap, priority:100
msgid "\tgit request-pull v1.0 https://git.ko.xz/project master:for-linus\n"
msgstr ""

#. type: Title =
#: en/git-rerere.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-rerere(1)"
msgstr "git-rerere(1)"

#. type: Plain text
#: en/git-rerere.txt:7
#, fuzzy, priority:100
msgid "git-rerere - Reuse recorded resolution of conflicted merges"
msgstr "git-rerere - Reuse recorded resolution of conflicted merges"

#. type: Plain text
#: en/git-rerere.txt:12
#, fuzzy, ignore-ellipsis, no-wrap, priority:100
msgid "'git rerere' [clear | forget <pathspec>... | diff | status | remaining | gc]\n"
msgstr "'git rerere' ['clear'|'forget' <pathspec>|'diff'|'remaining'|'status'|'gc']\n"

#. type: Plain text
#: en/git-rerere.txt:20
#, priority:100
msgid "In a workflow employing relatively long lived topic branches, the developer sometimes needs to resolve the same conflicts over and over again until the topic branches are done (either merged to the \"release\" branch, or sent out and accepted upstream)."
msgstr ""

#. type: Plain text
#: en/git-rerere.txt:25
#, priority:100
msgid "This command assists the developer in this process by recording conflicted automerge results and corresponding hand resolve results on the initial manual merge, and applying previously recorded hand resolutions to their corresponding automerge results."
msgstr ""

#. type: Plain text
#: en/git-rerere.txt:29
#, priority:100
msgid "You need to set the configuration variable `rerere.enabled` in order to enable this command."
msgstr ""

#. type: Plain text
#: en/git-rerere.txt:37
#, priority:100
msgid "Normally, 'git rerere' is run without arguments or user-intervention.  However, it has several commands that allow it to interact with its working state."
msgstr ""

#. type: Labeled list
#: en/git-rerere.txt:38
#, no-wrap, priority:100
msgid "'clear'"
msgstr ""

#. type: Plain text
#: en/git-rerere.txt:43
#, priority:100
msgid "Reset the metadata used by rerere if a merge resolution is to be aborted.  Calling 'git am [--skip|--abort]' or 'git rebase [--skip|--abort]' will automatically invoke this command."
msgstr ""

#. type: Labeled list
#: en/git-rerere.txt:44
#, no-wrap, priority:100
msgid "'forget' <pathspec>"
msgstr ""

#. type: Plain text
#: en/git-rerere.txt:48
#, priority:100
msgid "Reset the conflict resolutions which rerere has recorded for the current conflict in <pathspec>."
msgstr ""

#. type: Labeled list
#: en/git-rerere.txt:49
#, no-wrap, priority:100
msgid "'diff'"
msgstr ""

#. type: Plain text
#: en/git-rerere.txt:55
#, priority:100
msgid "Display diffs for the current state of the resolution.  It is useful for tracking what has changed while the user is resolving conflicts.  Additional arguments are passed directly to the system 'diff' command installed in PATH."
msgstr ""

#. type: Labeled list
#: en/git-rerere.txt:56
#, fuzzy, no-wrap, priority:100
msgid "'status'"
msgstr "'status'"

#. type: Plain text
#: en/git-rerere.txt:59
#, priority:100
msgid "Print paths with conflicts whose merge resolution rerere will record."
msgstr ""

#. type: Labeled list
#: en/git-rerere.txt:60
#, no-wrap, priority:100
msgid "'remaining'"
msgstr ""

#. type: Plain text
#: en/git-rerere.txt:65
#, priority:100
msgid "Print paths with conflicts that have not been autoresolved by rerere.  This includes paths whose resolutions cannot be tracked by rerere, such as conflicting submodules."
msgstr ""

#. type: Labeled list
#: en/git-rerere.txt:66 en/git-svn.txt:511
#, fuzzy, no-wrap, priority:100
msgid "'gc'"
msgstr "'gc'"

#. type: Plain text
#: en/git-rerere.txt:74
#, priority:100
msgid "Prune records of conflicted merges that occurred a long time ago.  By default, unresolved conflicts older than 15 days and resolved conflicts older than 60 days are pruned.  These defaults are controlled via the `gc.rerereUnresolved` and `gc.rerereResolved` configuration variables respectively."
msgstr ""

#. type: Plain text
#: en/git-rerere.txt:83
#, priority:100
msgid "When your topic branch modifies an overlapping area that your master branch (or upstream) touched since your topic branch forked from it, you may want to test it with the latest master, even before your topic branch is ready to be pushed upstream:"
msgstr ""

#. type: delimited block -
#: en/git-rerere.txt:88
#, fuzzy, no-wrap, priority:100
msgid ""
"              o---*---o topic\n"
"             /\n"
"    o---o---o---*---o---o master\n"
msgstr ""
"              o---*---o topic\n"
"             /\n"
"    o---o---o---*---o---o master\n"

#. type: Plain text
#: en/git-rerere.txt:92
#, priority:100
msgid "For such a test, you need to merge master and topic somehow.  One way to do it is to pull master into the topic branch:"
msgstr ""

#. type: delimited block -
#: en/git-rerere.txt:96
#, fuzzy, no-wrap, priority:100
msgid ""
"\t$ git switch topic\n"
"\t$ git merge master\n"
msgstr ""
"\t$ git switch topic\n"
"\t$ git merge master\n"

#. type: delimited block -
#: en/git-rerere.txt:100
#, fuzzy, no-wrap, priority:100
msgid ""
"              o---*---o---+ topic\n"
"             /           /\n"
"    o---o---o---*---o---o master\n"
msgstr ""
"              o---*---o---+ topic\n"
"             /           /\n"
"    o---o---o---*---o---o master\n"

#. type: Plain text
#: en/git-rerere.txt:106
#, priority:100
msgid "The commits marked with `*` touch the same area in the same file; you need to resolve the conflicts when creating the commit marked with `+`.  Then you can test the result to make sure your work-in-progress still works with what is in the latest master."
msgstr ""

#. type: Plain text
#: en/git-rerere.txt:114
#, priority:100
msgid "After this test merge, there are two ways to continue your work on the topic.  The easiest is to build on top of the test merge commit `+`, and when your work in the topic branch is finally ready, pull the topic branch into master, and/or ask the upstream to pull from you.  By that time, however, the master or the upstream might have been advanced since the test merge `+`, in which case the final commit graph would look like this:"
msgstr ""

#. type: delimited block -
#: en/git-rerere.txt:121
#, ignore-ellipsis, no-wrap, priority:100
msgid ""
"\t$ git switch topic\n"
"\t$ git merge master\n"
"\t$ ... work on both topic and master branches\n"
"\t$ git switch master\n"
"\t$ git merge topic\n"
msgstr ""

#. type: delimited block -
#: en/git-rerere.txt:125
#, fuzzy, no-wrap, priority:100
msgid ""
"              o---*---o---+---o---o topic\n"
"             /           /         \\\n"
"    o---o---o---*---o---o---o---o---+ master\n"
msgstr ""
"              o---*---o---+---o---o topic\n"
"             /           /         \\\n"
"    o---o---o---*---o---o---o---o---+ master\n"

#. type: Plain text
#: en/git-rerere.txt:133
#, priority:100
msgid "When your topic branch is long-lived, however, your topic branch would end up having many such \"Merge from master\" commits on it, which would unnecessarily clutter the development history.  Readers of the Linux kernel mailing list may remember that Linus complained about such too frequent test merges when a subsystem maintainer asked to pull from a branch full of \"useless merges\"."
msgstr ""

#. type: Plain text
#: en/git-rerere.txt:137
#, priority:100
msgid "As an alternative, to keep the topic branch clean of test merges, you could blow away the test merge, and keep building on top of the tip before the test merge:"
msgstr ""

#. type: delimited block -
#: en/git-rerere.txt:145
#, fuzzy, ignore-ellipsis, no-wrap, priority:100
msgid ""
"\t$ git switch topic\n"
"\t$ git merge master\n"
"\t$ git reset --hard HEAD^ ;# rewind the test merge\n"
"\t$ ... work on both topic and master branches\n"
"\t$ git switch master\n"
"\t$ git merge topic\n"
msgstr ""
"\t$ git switch topic\n"
"\t$ git merge master\n"
"\t$ git reset --hard HEAD^ ;# rewind the test merge\n"
"\t$ ... work on both topic and master branches\n"
"\t$ git switch master\n"
"\t$ git merge topic\n"

#. type: delimited block -
#: en/git-rerere.txt:149
#, fuzzy, no-wrap, priority:100
msgid ""
"              o---*---o-------o---o topic\n"
"             /                     \\\n"
"    o---o---o---*---o---o---o---o---+ master\n"
msgstr ""
"              o---*---o-------o---o topic\n"
"             /                     \\\n"
"    o---o---o---*---o---o---o---o---+ master\n"

#. type: Plain text
#: en/git-rerere.txt:159
#, priority:100
msgid "This would leave only one merge commit when your topic branch is finally ready and merged into the master branch.  This merge would require you to resolve the conflict, introduced by the commits marked with `*`.  However, this conflict is often the same conflict you resolved when you created the test merge you blew away.  'git rerere' helps you resolve this final conflicted merge using the information from your earlier hand resolve."
msgstr ""

#. type: Plain text
#: en/git-rerere.txt:167
#, priority:100
msgid "Running the 'git rerere' command immediately after a conflicted automerge records the conflicted working tree files, with the usual conflict markers `<<<<<<<`, `=======`, and `>>>>>>>` in them.  Later, after you are done resolving the conflicts, running 'git rerere' again will record the resolved state of these files.  Suppose you did this when you created the test merge of master into the topic branch."
msgstr ""

#. type: Plain text
#: en/git-rerere.txt:177
#, priority:100
msgid "Next time, after seeing the same conflicted automerge, running 'git rerere' will perform a three-way merge between the earlier conflicted automerge, the earlier manual resolution, and the current conflicted automerge.  If this three-way merge resolves cleanly, the result is written out to your working tree file, so you do not have to manually resolve it.  Note that 'git rerere' leaves the index file alone, so you still need to do the final sanity checks with `git diff` (or `git diff -c`) and 'git add' when you are satisfied."
msgstr ""

#. type: Plain text
#: en/git-rerere.txt:185
#, priority:100
msgid "As a convenience measure, 'git merge' automatically invokes 'git rerere' upon exiting with a failed automerge and 'git rerere' records the hand resolve when it is a new conflict, or reuses the earlier hand resolve when it is not.  'git commit' also invokes 'git rerere' when committing a merge result.  What this means is that you do not have to do anything special yourself (besides enabling the rerere.enabled config variable)."
msgstr ""

#. type: Plain text
#: en/git-rerere.txt:190
#, priority:100
msgid "In our example, when you do the test merge, the manual resolution is recorded, and it will be reused when you do the actual merge later with the updated master and topic branch, as long as the recorded resolution is still applicable."
msgstr ""

#. type: Plain text
#: en/git-rerere.txt:194
#, priority:100
msgid "The information 'git rerere' records is also used when running 'git rebase'.  After blowing away the test merge and continuing development on the topic branch:"
msgstr ""

#. type: delimited block -
#: en/git-rerere.txt:199
#, fuzzy, no-wrap, priority:100
msgid ""
"              o---*---o-------o---o topic\n"
"             /\n"
"    o---o---o---*---o---o---o---o   master\n"
msgstr ""
"              o---*---o-------o---o topic\n"
"             /\n"
"    o---o---o---*---o---o---o---o   master\n"

#. type: delimited block -
#: en/git-rerere.txt:201
#, fuzzy, no-wrap, priority:100
msgid "\t$ git rebase master topic\n"
msgstr "\t$ git rebase master topic\n"

#. type: delimited block -
#: en/git-rerere.txt:205
#, fuzzy, no-wrap, priority:100
msgid ""
"\t\t\t\t  o---*---o-------o---o topic\n"
"\t\t\t\t /\n"
"    o---o---o---*---o---o---o---o   master\n"
msgstr ""
"\t\t\t\t  o---*---o-------o---o topic\n"
"\t\t\t\t /\n"
"    o---o---o---*---o---o---o---o   master\n"

#. type: Plain text
#: en/git-rerere.txt:213
#, priority:100
msgid "you could run `git rebase master topic`, to bring yourself up to date before your topic is ready to be sent upstream.  This would result in falling back to a three-way merge, and it would conflict the same way as the test merge you resolved earlier.  'git rerere' will be run by 'git rebase' to help you resolve this conflict."
msgstr ""

#. type: Plain text
#: en/git-rerere.txt:219
#, fuzzy, priority:100
msgid "[NOTE] 'git rerere' relies on the conflict markers in the file to detect the conflict.  If the file already contains lines that look the same as lines with conflict markers, 'git rerere' may fail to record a conflict resolution.  To work around this, the `conflict-marker-size` setting in linkgit:gitattributes[5] can be used."
msgstr "[NOTE] 'git rerere' relies on the conflict markers in the file to detect the conflict.  If the file already contains lines that look the same as lines with conflict markers, 'git rerere' may fail to record a conflict resolution.  To work around this, the `conflict-marker-size` setting in linkgit:gitattributes[5] can be used."

#. type: Title =
#: en/git-reset.txt:2
#, ignore-same, no-wrap, priority:280
msgid "git-reset(1)"
msgstr "git-reset(1)"

#. type: Plain text
#: en/git-reset.txt:7
#, priority:280
msgid "git-reset - Reset current HEAD to the specified state"
msgstr "git-reset - 重置当前HEAD到指定的状态"

#. type: Plain text
#: en/git-reset.txt:15
#, fuzzy, ignore-ellipsis, no-wrap, priority:280
msgid ""
"'git reset' [-q] [<tree-ish>] [--] <pathspec>...\n"
"'git reset' [-q] [--pathspec-from-file=<file> [--pathspec-file-nul]] [<tree-ish>]\n"
"'git reset' (--patch | -p) [<tree-ish>] [--] [<pathspec>...]\n"
"'git reset' [--soft | --mixed [-N] | --hard | --merge | --keep] [-q] [<commit>]\n"
msgstr ""
"'git reset' [-q] [<tree-ish>] [--] <pathspec>...\n"
"'git reset' [-q] [--pathspec-from-file=<file> [--pathspec-file-nul]] [<tree-ish>]\n"
"'git reset' (--patch | -p) [<tree-ish>] [--] [<pathspec>...]\n"
"'git reset' [--soft | --mixed [-N] | --hard | --merge | --keep] [-q] [<commit>]\n"

#. type: Plain text
#: en/git-reset.txt:22
#, priority:280
msgid "In the first three forms, copy entries from `<tree-ish>` to the index.  In the last form, set the current branch head (`HEAD`) to `<commit>`, optionally modifying index and working tree to match.  The `<tree-ish>`/`<commit>` defaults to `HEAD` in all forms."
msgstr "在前三种形式中，从`<treeish>`复制条目到索引。  在最后一个表格中，将当前的分支头(`HEAD`)设置为`<commit>`，可以选择修改索引和工作树来匹配。  `<tree-ish>`/`<commit>`在所有表格中默认为`HEAD`。"

#. type: Labeled list
#: en/git-reset.txt:23
#, fuzzy, ignore-ellipsis, no-wrap, priority:280
msgid "'git reset' [-q] [<tree-ish>] [--] <pathspec>..."
msgstr "'git reset' [-q] [<tree-ish>] [--] <pathspec>..."

#. type: Labeled list
#: en/git-reset.txt:24
#, fuzzy, no-wrap, priority:280
msgid "'git reset' [-q] [--pathspec-from-file=<file> [--pathspec-file-nul]] [<tree-ish>]"
msgstr "'git reset' [-q] [--pathspec-from-file=<file> [--pathspec-file-nul]] [<tree-ish>]"

#. type: Plain text
#: en/git-reset.txt:28
#, priority:280
msgid "These forms reset the index entries for all paths that match the `<pathspec>` to their state at `<tree-ish>`.  (It does not affect the working tree or the current branch.)"
msgstr "这些表格将所有符合`<pathspec>`的路径的索引项重置为`<treeish>`时的状态。  (它不影响工作树或当前分支)。"

#. type: Plain text
#: en/git-reset.txt:32
#, ignore-ellipsis, priority:280
msgid "This means that `git reset <pathspec>` is the opposite of `git add <pathspec>`. This command is equivalent to `git restore [--source=<tree-ish>] --staged <pathspec>...`."
msgstr "这意味着，`git reset <pathspec>`与`git add <pathspec>`相反。该命令等同于`git restore [--source=<treeish>] --staged <pathspec>...`。"

#. type: Plain text
#: en/git-reset.txt:39
#, priority:280
msgid "After running `git reset <pathspec>` to update the index entry, you can use linkgit:git-restore[1] to check the contents out of the index to the working tree. Alternatively, using linkgit:git-restore[1] and specifying a commit with `--source`, you can copy the contents of a path out of a commit to the index and to the working tree in one go."
msgstr "运行 `git reset <pathspec>` 来更新索引条目后，您可以使用 linkgit:git-restore[1] 来检查索引中的内容到工作树上。另外，使用 linkgit:git-restore[1] 并用 `--source` 指定一个提交，你可以一次性将一个路径的内容从提交中复制到索引和工作树上。"

#. type: Labeled list
#: en/git-reset.txt:40
#, fuzzy, ignore-ellipsis, no-wrap, priority:280
msgid "'git reset' (--patch | -p) [<tree-ish>] [--] [<pathspec>...]"
msgstr "'git reset' (--patch | -p) [<tree-ish>] [--] [<pathspec>...]"

#. type: Plain text
#: en/git-reset.txt:44
#, priority:280
msgid "Interactively select hunks in the difference between the index and `<tree-ish>` (defaults to `HEAD`).  The chosen hunks are applied in reverse to the index."
msgstr "在索引和`<tree-ish>`（默认为`HEAD`）之间的差异中交互式地选择猎物。  选择的猎物将被反向应用到索引中。"

#. type: Plain text
#: en/git-reset.txt:48
#, priority:280
msgid "This means that `git reset -p` is the opposite of `git add -p`, i.e.  you can use it to selectively reset hunks. See the ``Interactive Mode'' section of linkgit:git-add[1] to learn how to operate the `--patch` mode."
msgstr "这意味着 `git reset -p` 与 `git add -p` 相反，也就是说，你可以用它来有选择地重置 hunks。参见 linkgit:git-add[1] 的 ``互动模式''部分，了解如何操作`--patch`模式。"

#. type: Labeled list
#: en/git-reset.txt:49
#, fuzzy, no-wrap, priority:280
msgid "'git reset' [<mode>] [<commit>]"
msgstr "'git reset' [<mode>] [<commit>]"

#. type: Plain text
#: en/git-reset.txt:55
#, fuzzy, priority:280
#| msgid "This form resets the current branch head to `<commit>` and possibly updates the index (resetting it to the tree of `<commit>`) and the working tree depending on `<mode>`. If `<mode>` is omitted, defaults to `--mixed`. The `<mode>` must be one of the following:"
msgid "This form resets the current branch head to `<commit>` and possibly updates the index (resetting it to the tree of `<commit>`) and the working tree depending on `<mode>`. Before the operation, `ORIG_HEAD` is set to the tip of the current branch. If `<mode>` is omitted, defaults to `--mixed`. The `<mode>` must be one of the following:"
msgstr "这种形式将当前分支头重设为`<commit>`，并可能更新索引（重设为`<commit>`的树）和工作树，具体取决于`<mode>`。如果省略了`<mode>`，默认为`--mixed`。`<mode>`必须是下列之一。"

#. type: Labeled list
#: en/git-reset.txt:57
#, ignore-same, no-wrap, priority:280
msgid "--soft"
msgstr "--soft"

#. type: Plain text
#: en/git-reset.txt:62
#, priority:280
msgid "Does not touch the index file or the working tree at all (but resets the head to `<commit>`, just like all modes do). This leaves all your changed files \"Changes to be committed\", as `git status` would put it."
msgstr "完全不碰索引文件或工作树（但将头部重置为`<commit>`，就像所有模式一样）。这使你的所有更改的文件都是 \"待提交的更改\"，正如`git status`所说的。"

#. type: Labeled list
#: en/git-reset.txt:63
#, ignore-same, no-wrap, priority:280
msgid "--mixed"
msgstr "--mixed"

#. type: Plain text
#: en/git-reset.txt:67
#, priority:280
msgid "Resets the index but not the working tree (i.e., the changed files are preserved but not marked for commit) and reports what has not been updated. This is the default action."
msgstr "重置索引，但不重置工作树（即保留已修改的文件，但不标记为提交）并报告未更新的内容。这是默认动作。"

#. type: Plain text
#: en/git-reset.txt:70
#, fuzzy, priority:280
msgid "If `-N` is specified, removed paths are marked as intent-to-add (see linkgit:git-add[1])."
msgstr "如果指定了 `-N`，则删除的路径将被标记为要添加（请参阅 linkgit:git-add[1]）。"

#. type: Labeled list
#: en/git-reset.txt:71
#, ignore-same, no-wrap, priority:280
msgid "--hard"
msgstr "--hard"

#. type: Plain text
#: en/git-reset.txt:75
#, fuzzy, priority:280
#| msgid "Resets the index and working tree. Any changes to tracked files in the working tree since `<commit>` are discarded."
msgid "Resets the index and working tree. Any changes to tracked files in the working tree since `<commit>` are discarded.  Any untracked files or directories in the way of writing any tracked files are simply deleted."
msgstr "重置索引和工作树。自`<commit>以来，工作树中被追踪文件的任何变化都会被丢弃。"

#. type: Plain text
#: en/git-reset.txt:83
#, priority:280
msgid "Resets the index and updates the files in the working tree that are different between `<commit>` and `HEAD`, but keeps those which are different between the index and working tree (i.e. which have changes which have not been added).  If a file that is different between `<commit>` and the index has unstaged changes, reset is aborted."
msgstr "重置索引并更新工作树中在`<commit>`和`HEAD`之间不同的文件，但保留那些在索引和工作树之间不同的文件（即那些有未被添加的修改）。  如果一个在`<commit>`和索引之间不同的文件有未分阶段的变化，重置将被中止。"

#. type: Plain text
#: en/git-reset.txt:86
#, priority:280
msgid "In other words, `--merge` does something like a `git read-tree -u -m <commit>`, but carries forward unmerged index entries."
msgstr "换句话说，`--merge`做的是类似于`git read-tree -u -m <commit>`的事情，但会转发未合并的索引条目。"

#. type: Plain text
#: en/git-reset.txt:92
#, priority:280
msgid "Resets index entries and updates files in the working tree that are different between `<commit>` and `HEAD`.  If a file that is different between `<commit>` and `HEAD` has local changes, reset is aborted."
msgstr "重置索引项并更新工作树中`<commit>`和`HEAD`之间不同的文件。  如果一个在`<commit>`和`HEAD`之间不同的文件有本地修改，重置将被中止。"

#. type: Plain text
#: en/git-reset.txt:98
#, priority:280
msgid "When the working tree is updated, using --recurse-submodules will also recursively reset the working tree of all active submodules according to the commit recorded in the superproject, also setting the submodules' HEAD to be detached at that commit."
msgstr "当工作树被更新时，使用 --recurse-submodules 也将根据超级项目中记录的提交，递归地重置所有活动的子模块的工作树，同时也将子模块的 HEAD 设置为在该提交中被分离。"

#. type: Plain text
#: en/git-reset.txt:102 en/git-restore.txt:30 en/git-revert.txt:33
#, priority:280
msgid "See \"Reset, restore and revert\" in linkgit:git[1] for the differences between the three commands."
msgstr "关于这三个命令的区别，见linkgit:git[1]中的 \"重置、恢复和还原\"。"

#. type: Plain text
#: en/git-reset.txt:110
#, fuzzy, priority:280
msgid "Be quiet, only report errors."
msgstr "静默，只报告错误。"

#. type: Labeled list
#: en/git-reset.txt:112
#, ignore-same, no-wrap, priority:280
msgid "--no-refresh"
msgstr "--no-refresh"

#. type: Plain text
#: en/git-reset.txt:114
#, priority:280
msgid "Refresh the index after a mixed reset. Enabled by default."
msgstr "在混合重置后刷新索引，默认启用。"

#. type: Labeled list
#: en/git-reset.txt:139
#, no-wrap, priority:280
msgid "Undo add"
msgstr "撤销添加"

#. type: delimited block -
#: en/git-reset.txt:147
#, fuzzy, no-wrap, priority:280
msgid ""
"$ edit                                     <1>\n"
"$ git add frotz.c filfre.c\n"
"$ mailx                                    <2>\n"
"$ git reset                                <3>\n"
"$ git pull git://info.example.com/ nitfol  <4>\n"
msgstr ""
"$ edit                                     <1>\n"
"$ git add frotz.c filfre.c\n"
"$ mailx                                    <2>\n"
"$ git reset                                <3>\n"
"$ git pull git://info.example.com/ nitfol  <4>\n"

#. type: Plain text
#: en/git-reset.txt:153
#, priority:280
msgid "You are happily working on something, and find the changes in these files are in good order.  You do not want to see them when you run `git diff`, because you plan to work on other files and changes with these files are distracting."
msgstr "你正在愉快地工作，发现这些文件中的修改都很有秩序。  你不希望在运行`git diff'时看到它们，因为你打算在其他文件上工作，而这些文件的变化会让你分心。"

#. type: Plain text
#: en/git-reset.txt:154
#, priority:280
msgid "Somebody asks you to pull, and the changes sound worthy of merging."
msgstr "有人要求你拉，而且这些变化听起来值得合并。"

#. type: Plain text
#: en/git-reset.txt:159
#, priority:280
msgid "However, you already dirtied the index (i.e. your index does not match the `HEAD` commit).  But you know the pull you are going to make does not affect `frotz.c` or `filfre.c`, so you revert the index changes for these two files.  Your changes in working tree remain there."
msgstr "然而，你已经破坏了索引（也就是说，你的索引与`HEAD`提交不匹配）。  但你知道你要做的拉动并不影响`frotz.c`或`filfre.c`，所以你恢复了这两个文件的索引修改。  你在工作树上的修改仍然存在。"

#. type: Plain text
#: en/git-reset.txt:161
#, priority:280
msgid "Then you can pull and merge, leaving `frotz.c` and `filfre.c` changes still in the working tree."
msgstr "然后你可以拉出并合并，留下`frotz.c`和`filfre.c`的修改仍在工作树上。"

#. type: Labeled list
#: en/git-reset.txt:162
#, no-wrap, priority:280
msgid "Undo a commit and redo"
msgstr "撤销一个提交并重做"

#. type: delimited block -
#: en/git-reset.txt:169
#, fuzzy, ignore-ellipsis, no-wrap, priority:280
msgid ""
"$ git commit ...\n"
"$ git reset --soft HEAD^      <1>\n"
"$ edit                        <2>\n"
"$ git commit -a -c ORIG_HEAD  <3>\n"
msgstr ""
"$ git commit ...\n"
"$ git reset --soft HEAD^      <1>\n"
"$ edit                        <2>\n"
"$ git commit -a -c ORIG_HEAD  <3>\n"

#. type: Plain text
#: en/git-reset.txt:174
#, priority:280
msgid "This is most often done when you remembered what you just committed is incomplete, or you misspelled your commit message, or both.  Leaves working tree as it was before \"reset\"."
msgstr "这通常是在你记得你刚提交的内容不完整，或者你的提交信息拼错了，或者两者都是。  留下工作树在 \"重置 \"之前的样子。"

#. type: Plain text
#: en/git-reset.txt:175
#, priority:280
msgid "Make corrections to working tree files."
msgstr "对工作树文件进行修正。"

#. type: Plain text
#: en/git-reset.txt:178
#, priority:280
msgid "\"reset\" copies the old head to `.git/ORIG_HEAD`; redo the commit by starting with its log message.  If you do not need to edit the message further, you can give `-C` option instead."
msgstr "\"reset \"将旧的头部复制到`.git/ORIG_HEAD`；从其日志信息开始重做提交。  如果你不需要进一步编辑信息，你可以给`-C`选项代替。"

#. type: Plain text
#: en/git-reset.txt:180
#, priority:280
msgid "See also the `--amend` option to linkgit:git-commit[1]."
msgstr "参见linkgit:git-commit[1]的`--amend`选项。"

#. type: Labeled list
#: en/git-reset.txt:181
#, no-wrap, priority:280
msgid "Undo a commit, making it a topic branch"
msgstr "撤销一个提交，使其成为一个主题分支"

#. type: delimited block -
#: en/git-reset.txt:187
#, fuzzy, no-wrap, priority:280
msgid ""
"$ git branch topic/wip          <1>\n"
"$ git reset --hard HEAD~3       <2>\n"
"$ git switch topic/wip          <3>\n"
msgstr ""
"$ git branch topic/wip          <1>\n"
"$ git reset --hard HEAD~3       <2>\n"
"$ git switch topic/wip          <3>\n"

#. type: Plain text
#: en/git-reset.txt:193
#, priority:280
msgid "You have made some commits, but realize they were premature to be in the `master` branch.  You want to continue polishing them in a topic branch, so create `topic/wip` branch off of the current `HEAD`."
msgstr "你已经做了一些提交，但意识到它们在 \"master \"分支中还不成熟。  你想在一个主题分支中继续完善它们，所以在当前的`HEAD'之外创建了`topic/wip'分支。"

#. type: Plain text
#: en/git-reset.txt:194
#, priority:280
msgid "Rewind the master branch to get rid of those three commits."
msgstr "回溯主分支，去掉这三个提交。"

#. type: Plain text
#: en/git-reset.txt:195
#, priority:280
msgid "Switch to `topic/wip` branch and keep working."
msgstr "切换到`topic/wip`分支并继续工作。"

#. type: Labeled list
#: en/git-reset.txt:196
#, no-wrap, priority:280
msgid "Undo commits permanently"
msgstr "永久撤销提交"

#. type: delimited block -
#: en/git-reset.txt:201
#, ignore-ellipsis, no-wrap, priority:280
msgid ""
"$ git commit ...\n"
"$ git reset --hard HEAD~3   <1>\n"
msgstr ""
"$ git commit ...\n"
"$ git reset --hard HEAD~3 <1>\n"

#. type: Plain text
#: en/git-reset.txt:208
#, priority:280
msgid "The last three commits (`HEAD`, `HEAD^`, and `HEAD~2`) were bad and you do not want to ever see them again.  Do *not* do this if you have already given these commits to somebody else.  (See the \"RECOVERING FROM UPSTREAM REBASE\" section in linkgit:git-rebase[1] for the implications of doing so.)"
msgstr "最后三个提交（`HEAD`，`HEAD^`，和`HEAD~2`）是坏的，你不希望再看到它们。  如果你已经把这些提交给了别人，请不要**这样做。  参见 linkgit:git-rebase[1] 中的 \"RECOVERING FROM UPSTREAM REBASE\" 一节，了解这样做的意义）。"

#. type: Labeled list
#: en/git-reset.txt:209
#, no-wrap, priority:280
msgid "Undo a merge or pull"
msgstr "撤销合并或拉动"

#. type: delimited block -
#: en/git-reset.txt:221
#, ignore-ellipsis, no-wrap, priority:280
msgid ""
"$ git pull                         <1>\n"
"Auto-merging nitfol\n"
"CONFLICT (content): Merge conflict in nitfol\n"
"Automatic merge failed; fix conflicts and then commit the result.\n"
"$ git reset --hard                 <2>\n"
"$ git pull . topic/branch          <3>\n"
"Updating from 41223... to 13134...\n"
"Fast-forward\n"
"$ git reset --hard ORIG_HEAD       <4>\n"
msgstr ""
"$ git pull <1>\n"
"自动合并nitfol\n"
"CONFLICT（内容）。nitfol的合并冲突\n"
"自动合并失败；修复冲突，然后提交结果。\n"
"$ git reset --hard <2>\n"
"$ git pull . topic/branch <3>\n"
"从41223...更新到13134...\n"
"快进\n"
"$ git reset --hard ORIG_HEAD <4>\n"

#. type: Plain text
#: en/git-reset.txt:226
#, priority:280
msgid "Try to update from the upstream resulted in a lot of conflicts; you were not ready to spend a lot of time merging right now, so you decide to do that later."
msgstr "试图从上游更新导致了很多冲突；你现在还没有准备好花费大量的时间来合并，所以你决定以后再做这个。"

#. type: Plain text
#: en/git-reset.txt:229
#, priority:280
msgid "\"pull\" has not made merge commit, so `git reset --hard` which is a synonym for `git reset --hard HEAD` clears the mess from the index file and the working tree."
msgstr "\"pull \"没有进行合并提交，所以`git reset --hard`是`git reset --hard HEAD`的同义词，它清除了索引文件和工作树上的混乱。"

#. type: Plain text
#: en/git-reset.txt:231
#, priority:280
msgid "Merge a topic branch into the current branch, which resulted in a fast-forward."
msgstr "将一个主题分支合并到当前分支，这导致了快进。"

#. type: Plain text
#: en/git-reset.txt:236
#, priority:280
msgid "But you decided that the topic branch is not ready for public consumption yet.  \"pull\" or \"merge\" always leaves the original tip of the current branch in `ORIG_HEAD`, so resetting hard to it brings your index file and the working tree back to that state, and resets the tip of the branch to that commit."
msgstr "但你决定这个主题分支还不适合公开使用。  \"pull \"或 \"merge \"总是在`ORIG_HEAD`中留下当前分支的原始提示，所以硬重置到它会使你的索引文件和工作树回到那个状态，并将分支的提示重置到那个提交。"

#. type: Labeled list
#: en/git-reset.txt:237
#, no-wrap, priority:280
msgid "Undo a merge or pull inside a dirty working tree"
msgstr "撤消合并或拉动肮脏的工作树的行为"

#. type: delimited block -
#: en/git-reset.txt:246
#, fuzzy, ignore-ellipsis, no-wrap, priority:280
msgid ""
"$ git pull                         <1>\n"
"Auto-merging nitfol\n"
"Merge made by recursive.\n"
" nitfol                |   20 +++++----\n"
" ...\n"
"$ git reset --merge ORIG_HEAD      <2>\n"
msgstr ""
"$ git pull                         <1>\n"
"Auto-merging nitfol\n"
"Merge made by recursive.\n"
" nitfol                |   20 +++++----\n"
" ...\n"
"$ git reset --merge ORIG_HEAD      <2>\n"

#. type: Plain text
#: en/git-reset.txt:252
#, priority:280
msgid "Even if you may have local modifications in your working tree, you can safely say `git pull` when you know that the change in the other branch does not overlap with them."
msgstr "即使你的工作树中可能有局部的修改，当你知道另一个分支中的修改没有与之重叠时，你可以放心地说`git pull`。"

#. type: Plain text
#: en/git-reset.txt:257
#, priority:280
msgid "After inspecting the result of the merge, you may find that the change in the other branch is unsatisfactory.  Running `git reset --hard ORIG_HEAD` will let you go back to where you were, but it will discard your local changes, which you do not want.  `git reset --merge` keeps your local changes."
msgstr "在检查了合并的结果后，你可能会发现另一个分支的修改不尽人意。  运行`git reset --hard ORIG_HEAD`可以让你回到原来的位置，但它会丢弃你的本地修改，这是你不想要的。  `git reset --merge`会保留你的本地修改。"

#. type: Labeled list
#: en/git-reset.txt:259 en/git-stash.txt:309
#, no-wrap, priority:280
msgid "Interrupted workflow"
msgstr "中断的工作流程"

#. type: Plain text
#: en/git-reset.txt:265
#, priority:280
msgid "Suppose you are interrupted by an urgent fix request while you are in the middle of a large change.  The files in your working tree are not in any shape to be committed yet, but you need to get to the other branch for a quick bugfix."
msgstr "假设你在做一个大的改动时被一个紧急的修复请求打断了。  你工作树上的文件还没到可以提交的地步，但你需要到另一个分支去快速修复错误。"

#. type: delimited block -
#: en/git-reset.txt:276
#, no-wrap, priority:280
msgid ""
"$ git switch feature  ;# you were working in \"feature\" branch and\n"
"$ work work work      ;# got interrupted\n"
"$ git commit -a -m \"snapshot WIP\"                 <1>\n"
"$ git switch master\n"
"$ fix fix fix\n"
"$ git commit ;# commit with real log\n"
"$ git switch feature\n"
"$ git reset --soft HEAD^ ;# go back to WIP state  <2>\n"
"$ git reset                                       <3>\n"
msgstr ""
"$ git switch feature ;# 你在 \"feature \"分支工作，并且\n"
"$ work work work;# 被打断了\n"
"$ git commit -a -m \"snapshot WIP\" <1\n"
"$ git switch master\n"
"$ fix fix fix\n"
"$ git commit ;# 提交时有真实日志\n"
"$ git switch feature\n"
"$ git reset --soft HEAD^ ;# 回到 WIP 状态 <2>\n"
"$ git reset <3>\n"

#. type: Plain text
#: en/git-reset.txt:279
#, priority:280
msgid "This commit will get blown away so a throw-away log message is OK."
msgstr "这个提交会被吹走，所以扔掉的日志信息是可以的。"

#. type: Plain text
#: en/git-reset.txt:281
#, priority:280
msgid "This removes the 'WIP' commit from the commit history, and sets your working tree to the state just before you made that snapshot."
msgstr "这将从提交历史中删除 \"WIP \"提交，并将你的工作树设置为刚刚做出快照之前的状态。"

#. type: Plain text
#: en/git-reset.txt:284
#, priority:280
msgid "At this point the index file still has all the WIP changes you committed as 'snapshot WIP'.  This updates the index to show your WIP files as uncommitted."
msgstr "在这一点上，索引文件仍然有你提交的所有WIP修改，作为 \"快照WIP\"。  这样就可以更新索引，将你的WIP文件显示为未提交的。"

#. type: Plain text
#: en/git-reset.txt:286
#, priority:280
msgid "See also linkgit:git-stash[1]."
msgstr "也请参见 linkgit:git-stash[1]。"

#. type: Labeled list
#: en/git-reset.txt:287
#, no-wrap, priority:280
msgid "Reset a single file in the index"
msgstr "重置索引中的单个文件"

#. type: Plain text
#: en/git-reset.txt:292
#, priority:280
msgid "Suppose you have added a file to your index, but later decide you do not want to add it to your commit. You can remove the file from the index while keeping your changes with git reset."
msgstr "假设你在索引中添加了一个文件，但后来决定不想把它加入你的提交中。你可以用git reset将该文件从索引中删除，同时保留你的修改。"

#. type: delimited block -
#: en/git-reset.txt:297
#, no-wrap, priority:280
msgid ""
"$ git reset -- frotz.c                      <1>\n"
"$ git commit -m \"Commit files in index\"     <2>\n"
"$ git add frotz.c                           <3>\n"
msgstr ""
"$ git reset -- frotz.c <1>.\n"
"$ git commit -m \"将文件存入索引\" <2>\n"
"$ git add frotz.c <3>\n"

#. type: Plain text
#: en/git-reset.txt:301
#, priority:280
msgid "This removes the file from the index while keeping it in the working directory."
msgstr "这将从索引中删除该文件，同时将其保留在工作目录中。"

#. type: Plain text
#: en/git-reset.txt:302
#, priority:280
msgid "This commits all other changes in the index."
msgstr "这将提交索引中的所有其他变化。"

#. type: Plain text
#: en/git-reset.txt:303
#, priority:280
msgid "Adds the file to the index again."
msgstr "再次将该文件添加到索引中。"

#. type: Labeled list
#: en/git-reset.txt:304
#, no-wrap, priority:280
msgid "Keep changes in working tree while discarding some previous commits"
msgstr "在工作树中保留修改，同时丢弃一些以前的提交内容"

#. type: Plain text
#: en/git-reset.txt:311
#, priority:280
msgid "Suppose you are working on something and you commit it, and then you continue working a bit more, but now you think that what you have in your working tree should be in another branch that has nothing to do with what you committed previously. You can start a new branch and reset it while keeping the changes in your working tree."
msgstr "假设你正在做某件事，并提交了它，然后你又继续做了一会儿，但现在你认为你工作树中的内容应该在另一个分支中，而这个分支与你之前提交的内容毫无关系。你可以启动一个新的分支，并重置它，同时保留工作树中的变化。"

#. type: delimited block -
#: en/git-reset.txt:320
#, fuzzy, ignore-ellipsis, no-wrap, priority:280
msgid ""
"$ git tag start\n"
"$ git switch -c branch1\n"
"$ edit\n"
"$ git commit ...                            <1>\n"
"$ edit\n"
"$ git switch -c branch2                     <2>\n"
"$ git reset --keep start                    <3>\n"
msgstr ""
"$ git tag start\n"
"$ git switch -c branch1\n"
"$ edit\n"
"$ git commit ...                            <1>\n"
"$ edit\n"
"$ git switch -c branch2                     <2>\n"
"$ git reset --keep start                    <3>\n"

#. type: Plain text
#: en/git-reset.txt:323
#, priority:280
msgid "This commits your first edits in `branch1`."
msgstr "这将提交你在 `branch1`中的第一次编辑。"

#. type: Plain text
#: en/git-reset.txt:327
#, priority:280
msgid "In the ideal world, you could have realized that the earlier commit did not belong to the new topic when you created and switched to `branch2` (i.e. `git switch -c branch2 start`), but nobody is perfect."
msgstr "在理想的世界里，你可以在创建并切换到 \"分支2\"（即 \"git switch -c branch2 start\"）时意识到先前的提交不属于新主题，但人无完人。"

#. type: Plain text
#: en/git-reset.txt:329
#, priority:280
msgid "But you can use `reset --keep` to remove the unwanted commit after you switched to `branch2`."
msgstr "但你可以用`reset --keep`来删除你切换到`branch2`后不需要的提交。"

#. type: Labeled list
#: en/git-reset.txt:330
#, no-wrap, priority:280
msgid "Split a commit apart into a sequence of commits"
msgstr "将一个提交分割成一连串的提交"

#. type: Plain text
#: en/git-reset.txt:338
#, priority:280
msgid "Suppose that you have created lots of logically separate changes and committed them together. Then, later you decide that it might be better to have each logical chunk associated with its own commit. You can use git reset to rewind history without changing the contents of your local files, and then successively use `git add -p` to interactively select which hunks to include into each commit, using `git commit -c` to pre-populate the commit message."
msgstr "假设你创建了很多逻辑上独立的修改，并将它们一起提交。然后，后来你决定让每个逻辑块与自己的提交相关联可能更好。你可以使用 git reset 来回溯历史，而不改变本地文件的内容，然后连续使用 `git add -p` 来交互式地选择哪些块包含在每个提交中，使用 `git commit -c` 来预先填入提交信息。"

#. type: delimited block -
#: en/git-reset.txt:348
#, ignore-ellipsis, no-wrap, priority:280
msgid ""
"$ git reset -N HEAD^                        <1>\n"
"$ git add -p                                <2>\n"
"$ git diff --cached                         <3>\n"
"$ git commit -c HEAD@{1}                    <4>\n"
"...                                         <5>\n"
"$ git add ...                               <6>\n"
"$ git diff --cached                         <7>\n"
"$ git commit ...                            <8>\n"
msgstr ""
"$ git reset -N HEAD^ <1>\n"
"$ git add -p <2>\n"
"$ git diff --cached <3>\n"
"$ git commit -c HEAD@{1}.                    <4>\n"
"...                                         <5>\n"
"$ git add ...                               <6>\n"
"$ git diff --cached <7>\n"
"$ git commit ...                            <8>\n"

#. type: Plain text
#: en/git-reset.txt:354
#, priority:280
msgid "First, reset the history back one commit so that we remove the original commit, but leave the working tree with all the changes. The -N ensures that any new files added with `HEAD` are still marked so that `git add -p` will find them."
msgstr "首先，将历史记录向后重设一次提交，这样我们就删除了原始提交，但保留了工作树上的所有修改。N确保任何用`HEAD`添加的新文件仍然被标记，以便`git add -p`能够找到它们。"

#. type: Plain text
#: en/git-reset.txt:358
#, priority:280
msgid "Next, we interactively select diff hunks to add using the `git add -p` facility. This will ask you about each diff hunk in sequence and you can use simple commands such as \"yes, include this\", \"No don't include this\" or even the very powerful \"edit\" facility."
msgstr "接下来，我们使用 \"git add -p \"工具，交互式地选择要添加的diff hunks。这将依次询问每个差异块，你可以使用简单的命令，如 \"是，包括这个\"，\"不，不包括这个\"，甚至是非常强大的 \"编辑 \"工具。"

#. type: Plain text
#: en/git-reset.txt:362
#, priority:280
msgid "Once satisfied with the hunks you want to include, you should verify what has been prepared for the first commit by using `git diff --cached`. This shows all the changes that have been moved into the index and are about to be committed."
msgstr "一旦对你想要包括的hunks感到满意，你应该通过使用`git diff --cached`来验证为第一次提交准备了什么。这将显示所有已经移入索引并即将提交的修改。"

#. type: Plain text
#: en/git-reset.txt:369
#, priority:280
msgid "Next, commit the changes stored in the index. The `-c` option specifies to pre-populate the commit message from the original message that you started with in the first commit. This is helpful to avoid retyping it. The `HEAD@{1}` is a special notation for the commit that `HEAD` used to be at prior to the original reset commit (1 change ago).  See linkgit:git-reflog[1] for more details. You may also use any other valid commit reference."
msgstr "接下来，提交存储在索引中的修改。`-c`选项指定从你第一次提交时的原始信息中预先填入提交信息。这对避免重复输入很有帮助。`HEAD@{1}`是一个特殊的符号，表示`HEAD`在最初的重置提交（1次变更前）之前曾经处于的提交。  更多细节见 linkgit:git-reflog[1]。你也可以使用任何其他有效的提交参考。"

#. type: Plain text
#: en/git-reset.txt:371
#, priority:280
msgid "You can repeat steps 2-4 multiple times to break the original code into any number of commits."
msgstr "你可以多次重复第2-4步，将原始代码分解成任意数量的提交。"

#. type: Plain text
#: en/git-reset.txt:374
#, priority:280
msgid "Now you've split out many of the changes into their own commits, and might no longer use the patch mode of `git add`, in order to select all remaining uncommitted changes."
msgstr "现在你已经把许多修改拆成了自己的提交，可能不再使用`git add`的补丁模式，以便选择所有剩余的未提交的修改。"

#. type: Plain text
#: en/git-reset.txt:377
#, priority:280
msgid "Once again, check to verify that you've included what you want to. You may also wish to verify that git diff doesn't show any remaining changes to be committed later."
msgstr "再一次检查以确认你已经包含了你想要的东西。你可能还想确认git diff没有显示任何剩余的修改，以便以后提交。"

#. type: Plain text
#: en/git-reset.txt:378
#, priority:280
msgid "And finally create the final commit."
msgstr "最后创建最后的提交。"

#. type: Plain text
#: en/git-reset.txt:384
#, priority:280
msgid "The tables below show what happens when running:"
msgstr "下面的表格显示了运行时发生的情况："

#. type: delimited block -
#: en/git-reset.txt:387
#, fuzzy, no-wrap, priority:280
msgid "git reset --option target\n"
msgstr "git reset --option target\n"

#. type: Plain text
#: en/git-reset.txt:391
#, priority:280
msgid "to reset the `HEAD` to another commit (`target`) with the different reset options depending on the state of the files."
msgstr "来重置`HEAD`到另一个提交（`target`），根据文件的状态，有不同的重置选项。"

#. type: Plain text
#: en/git-reset.txt:400
#, priority:280
msgid "In these tables, `A`, `B`, `C` and `D` are some different states of a file. For example, the first line of the first table means that if a file is in state `A` in the working tree, in state `B` in the index, in state `C` in `HEAD` and in state `D` in the target, then `git reset --soft target` will leave the file in the working tree in state `A` and in the index in state `B`.  It resets (i.e. moves) the `HEAD` (i.e. the tip of the current branch, if you are on one) to `target` (which has the file in state `D`)."
msgstr "在这些表中，`A`、`B`、`C`和`D`是一个文件的一些不同状态。例如，第一个表格的第一行意味着如果一个文件在工作树中处于`A`状态，在索引中处于`B`状态，在`HEAD`中处于`C`状态，在目标中处于`D`状态，那么`git reset --soft target`将使文件在工作树中处于`A`状态，在索引中处于`B`状态。  它重设（即移动）`HEAD`（即当前分支的顶端，如果你在一个分支上）到`target`（它的文件处于`D`状态）。"

#. type: delimited block .
#: en/git-reset.txt:409
#, no-wrap, priority:280
msgid ""
"working index HEAD target         working index HEAD\n"
"----------------------------------------------------\n"
" A       B     C    D     --soft   A       B     D\n"
"\t\t\t  --mixed  A       D     D\n"
"\t\t\t  --hard   D       D     D\n"
"\t\t\t  --merge (disallowed)\n"
"\t\t\t  --keep  (disallowed)\n"
msgstr ""
"工作索引 HEAD 目标工作索引 HEAD\n"
"----------------------------------------------------\n"
" A B C D --软的 A B D\n"
"\t\t\t  -混合型 A D D\n"
"\t\t\t  --硬的 D D D\n"
"\t\t\t  --合并 (不允许)\n"
"\t\t\t  --保持 (不允许)\n"

#. type: delimited block .
#: en/git-reset.txt:419
#, no-wrap, priority:280
msgid ""
"working index HEAD target         working index HEAD\n"
"----------------------------------------------------\n"
" A       B     C    C     --soft   A       B     C\n"
"\t\t\t  --mixed  A       C     C\n"
"\t\t\t  --hard   C       C     C\n"
"\t\t\t  --merge (disallowed)\n"
"\t\t\t  --keep   A       C     C\n"
msgstr ""
"工作索引 HEAD 目标工作索引 HEAD\n"
"----------------------------------------------------\n"
" A B C C --软的 A B C\n"
"\t\t\t  -混合型 A C C\n"
"\t\t\t  --硬性 C C C\n"
"\t\t\t  --合并(不允许)\n"
"\t\t\t  --保持A C C\n"

#. type: delimited block .
#: en/git-reset.txt:429
#, no-wrap, priority:280
msgid ""
"working index HEAD target         working index HEAD\n"
"----------------------------------------------------\n"
" B       B     C    D     --soft   B       B     D\n"
"\t\t\t  --mixed  B       D     D\n"
"\t\t\t  --hard   D       D     D\n"
"\t\t\t  --merge  D       D     D\n"
"\t\t\t  --keep  (disallowed)\n"
msgstr ""
"工作索引 HEAD 目标工作索引 HEAD\n"
"----------------------------------------------------\n"
" B B C D --软B B D\n"
"\t\t\t  -混合型 B D D\n"
"\t\t\t  --硬的 D D D\n"
"\t\t\t  --合并 D D D\n"
"\t\t\t  --保持(不允许)\n"

#. type: delimited block .
#: en/git-reset.txt:439
#, no-wrap, priority:280
msgid ""
"working index HEAD target         working index HEAD\n"
"----------------------------------------------------\n"
" B       B     C    C     --soft   B       B     C\n"
"\t\t\t  --mixed  B       C     C\n"
"\t\t\t  --hard   C       C     C\n"
"\t\t\t  --merge  C       C     C\n"
"\t\t\t  --keep   B       C     C\n"
msgstr ""
"工作索引 HEAD 目标工作索引 HEAD\n"
"----------------------------------------------------\n"
" B B C C --软B B C\n"
"\t\t\t  -混合型 B C C\n"
"\t\t\t  --硬性 C C C\n"
"\t\t\t  --合并 C C C\n"
"\t\t\t  --保持B C C\n"

#. type: delimited block .
#: en/git-reset.txt:449
#, no-wrap, priority:280
msgid ""
"working index HEAD target         working index HEAD\n"
"----------------------------------------------------\n"
" B       C     C    D     --soft   B       C     D\n"
"\t\t\t  --mixed  B       D     D\n"
"\t\t\t  --hard   D       D     D\n"
"\t\t\t  --merge (disallowed)\n"
"\t\t\t  --keep  (disallowed)\n"
msgstr ""
"工作索引 HEAD 目标工作索引 HEAD\n"
"----------------------------------------------------\n"
" B C C D --软B C D\n"
"\t\t\t  -混合型 B D D\n"
"\t\t\t  --硬的 D D D\n"
"\t\t\t  --合并 (不允许)\n"
"\t\t\t  --保持 (不允许)\n"

#. type: delimited block .
#: en/git-reset.txt:459
#, no-wrap, priority:280
msgid ""
"working index HEAD target         working index HEAD\n"
"----------------------------------------------------\n"
" B       C     C    C     --soft   B       C     C\n"
"\t\t\t  --mixed  B       C     C\n"
"\t\t\t  --hard   C       C     C\n"
"\t\t\t  --merge  B       C     C\n"
"\t\t\t  --keep   B       C     C\n"
msgstr ""
"工作索引 HEAD 目标工作索引 HEAD\n"
"----------------------------------------------------\n"
" B C C C --软B C C\n"
"\t\t\t  -混合型 B C C\n"
"\t\t\t  --硬性 C C C\n"
"\t\t\t  --合并 B C C\n"
"\t\t\t  --保持B C C\n"

#. type: Plain text
#: en/git-reset.txt:469
#, priority:280
msgid "`reset --merge` is meant to be used when resetting out of a conflicted merge. Any mergy operation guarantees that the working tree file that is involved in the merge does not have a local change with respect to the index before it starts, and that it writes the result out to the working tree. So if we see some difference between the index and the target and also between the index and the working tree, then it means that we are not resetting out from a state that a mergy operation left after failing with a conflict. That is why we disallow `--merge` option in this case."
msgstr "`reset --merge`是指在重设冲突的合并时使用。任何合并操作都会保证参与合并的工作树文件在开始之前没有相对于索引的局部变化，并且会将结果写入工作树。因此，如果我们看到索引和目标之间，以及索引和工作树之间有一些差异，那么这意味着我们没有从一个合并操作失败后留下的冲突状态中重新设置出来。这就是为什么我们在这种情况下不允许使用`--合并`选项。"

#. type: Plain text
#: en/git-reset.txt:478
#, priority:280
msgid "`reset --keep` is meant to be used when removing some of the last commits in the current branch while keeping changes in the working tree. If there could be conflicts between the changes in the commit we want to remove and the changes in the working tree we want to keep, the reset is disallowed. That's why it is disallowed if there are both changes between the working tree and `HEAD`, and between `HEAD` and the target. To be safe, it is also disallowed when there are unmerged entries."
msgstr "`reset --keep 意思是在删除当前分支中的一些最后的提交，同时保留工作树中的修改时使用。如果我们想删除的提交和我们想保留的工作树上的修改之间可能存在冲突，那么重置是不允许的。这就是为什么如果工作树和`HEAD'之间，以及`HEAD'和目标之间都有变化，那么就不允许重置。为了安全起见，当有未合并的条目时，也不允许这样做。"

#. type: Plain text
#: en/git-reset.txt:481
#, priority:280
msgid "The following tables show what happens when there are unmerged entries:"
msgstr "下表显示了有未合并的条目时发生的情况。"

#. type: delimited block .
#: en/git-reset.txt:490
#, no-wrap, priority:280
msgid ""
"working index HEAD target         working index HEAD\n"
"----------------------------------------------------\n"
" X       U     A    B     --soft  (disallowed)\n"
"\t\t\t  --mixed  X       B     B\n"
"\t\t\t  --hard   B       B     B\n"
"\t\t\t  --merge  B       B     B\n"
"\t\t\t  --keep  (disallowed)\n"
msgstr ""
"工作索引 HEAD 目标工作索引 HEAD\n"
"----------------------------------------------------\n"
" X U A B --软（不允许）。\n"
"\t\t\t  --混合型 X B B\n"
"\t\t\t  --硬的 B B B\n"
"\t\t\t  --合并 B B B\n"
"\t\t\t  --保持(不允许)\n"

#. type: delimited block .
#: en/git-reset.txt:500
#, no-wrap, priority:280
msgid ""
"working index HEAD target         working index HEAD\n"
"----------------------------------------------------\n"
" X       U     A    A     --soft  (disallowed)\n"
"\t\t\t  --mixed  X       A     A\n"
"\t\t\t  --hard   A       A     A\n"
"\t\t\t  --merge  A       A     A\n"
"\t\t\t  --keep  (disallowed)\n"
msgstr ""
"工作索引 HEAD 目标工作索引 HEAD\n"
"----------------------------------------------------\n"
" X U A A --软(不允许)\n"
"\t\t\t  --混合型 X A A\n"
"\t\t\t  --硬性 A A A\n"
"\t\t\t  --合并 A A A\n"
"\t\t\t  --保持(不允许)\n"

#. type: Plain text
#: en/git-reset.txt:503
#, priority:280
msgid "`X` means any state and `U` means an unmerged index."
msgstr "`X`指任何状态，`U`指未合并的索引。"

#. type: Title =
#: en/git-restore.txt:2
#, ignore-same, no-wrap, priority:280
msgid "git-restore(1)"
msgstr "git-restore(1)"

#. type: Plain text
#: en/git-restore.txt:7
#, priority:280
msgid "git-restore - Restore working tree files"
msgstr "git-restore - 恢复工作树文件"

#. type: Plain text
#: en/git-restore.txt:14
#, ignore-ellipsis, no-wrap, priority:280
msgid ""
"'git restore' [<options>] [--source=<tree>] [--staged] [--worktree] [--] <pathspec>...\n"
"'git restore' [<options>] [--source=<tree>] [--staged] [--worktree] --pathspec-from-file=<file> [--pathspec-file-nul]\n"
"'git restore' (-p|--patch) [<options>] [--source=<tree>] [--staged] [--worktree] [--] [<pathspec>...]\n"
msgstr ""
"'git restore' [<options>] [--source=<tree>] [--staged] [--worktree] [--] <pathspec>...\n"
"'git restore' [<options>] [--source=<tree>] [--staged] [--worktree] --pathspec-from-file=<file> [--pathspec-file-nul] 。\n"
"'git restore' (-p|--patch) [<options>] [--source=<tree>] [--staged] [--worktree] [--] [<pathspec>...]\n"

#. type: Plain text
#: en/git-restore.txt:20
#, priority:280
msgid "Restore specified paths in the working tree with some contents from a restore source. If a path is tracked but does not exist in the restore source, it will be removed to match the source."
msgstr "用还原源的一些内容还原工作树中的指定路径。如果一个路径被跟踪，但在还原源中不存在，它将被删除以匹配源。"

#. type: Plain text
#: en/git-restore.txt:24
#, priority:280
msgid "The command can also be used to restore the content in the index with `--staged`, or restore both the working tree and the index with `--staged --worktree`."
msgstr "该命令还可以用来用`--staged`恢复索引中的内容，或者用`--staged --worktree`同时恢复工作树和索引。"

#. type: Plain text
#: en/git-restore.txt:27
#, priority:280
msgid "By default, if `--staged` is given, the contents are restored from `HEAD`, otherwise from the index. Use `--source` to restore from a different commit."
msgstr "默认情况下，如果给了`--staged`，内容将从`HEAD`恢复，否则从索引恢复。使用`--source`来恢复不同的提交。"

#. type: Plain text
#: en/git-restore.txt:32 en/git-switch.txt:33
#, priority:280
msgid "THIS COMMAND IS EXPERIMENTAL. THE BEHAVIOR MAY CHANGE."
msgstr "这个命令是试验性的。其行为可能会改变。"

#. type: Labeled list
#: en/git-restore.txt:35
#, fuzzy, no-wrap, priority:280
msgid "-s <tree>"
msgstr "-s <tree>"

#. type: Labeled list
#: en/git-restore.txt:36
#, no-wrap, priority:280
msgid "--source=<tree>"
msgstr "--source=<tree>（来源）。"

#. type: Plain text
#: en/git-restore.txt:40
#, priority:280
msgid "Restore the working tree files with the content from the given tree. It is common to specify the source tree by naming a commit, branch or tag associated with it."
msgstr "用给定树的内容恢复工作树的文件。通常是通过命名与之相关的提交、分支或标签来指定源树。"

#. type: Plain text
#: en/git-restore.txt:43
#, priority:280
msgid "If not specified, the contents are restored from `HEAD` if `--staged` is given, otherwise from the index."
msgstr "如果没有指定，如果给了`--staged`，则从`HEAD`恢复内容，否则从索引恢复。"

#. type: Plain text
#: en/git-restore.txt:54
#, priority:280
msgid "Interactively select hunks in the difference between the restore source and the restore location. See the ``Interactive Mode'' section of linkgit:git-add[1] to learn how to operate the `--patch` mode."
msgstr "交互式地选择还原源和还原位置之间的差异中的猎物。参见 linkgit:git-add[1] 的 \"互动模式 \"部分，了解如何操作\"--补丁 \"模式。"

#. type: Plain text
#: en/git-restore.txt:57
#, priority:280
msgid "Note that `--patch` can accept no pathspec and will prompt to restore all modified paths."
msgstr "请注意，`--patch`可以不接受任何pathspec，并会提示恢复所有修改的路径。"

#. type: Labeled list
#: en/git-restore.txt:60 en/git-stash.txt:211
#, fuzzy, no-wrap, priority:280
msgid "-S"
msgstr "-S"

#. type: Labeled list
#: en/git-restore.txt:61 en/git-stash.txt:212
#, ignore-same, no-wrap, priority:280
msgid "--staged"
msgstr "--staged"

#. type: Plain text
#: en/git-restore.txt:65
#, priority:280
msgid "Specify the restore location. If neither option is specified, by default the working tree is restored. Specifying `--staged` will only restore the index. Specifying both restores both."
msgstr "指定恢复的位置。如果两个选项都没有指定，默认情况下会还原工作树。指定`--staged`将只恢复索引。指定两个选项将同时还原。"

#. type: Plain text
#: en/git-restore.txt:69
#, priority:280
msgid "Quiet, suppress feedback messages. Implies `--no-progress`."
msgstr "安静，抑制反馈信息。意味着\"--没有进展\"。"

#. type: Plain text
#: en/git-restore.txt:81
#, priority:280
msgid "When restoring files in the working tree from the index, use stage #2 ('ours') or #3 ('theirs') for unmerged paths."
msgstr "当从索引中恢复工作树中的文件时，对未合并的路径使用阶段#2（'我们的'）或#3（'他们的'）。"

#. type: Plain text
#: en/git-restore.txt:85
#, priority:280
msgid "Note that during `git rebase` and `git pull --rebase`, 'ours' and 'theirs' may appear swapped. See the explanation of the same options in linkgit:git-checkout[1] for details."
msgstr "注意，在`git rebase`和`git pull --rebase`过程中，'我们的'和'他们的'可能会出现互换。详见 linkgit:git-checkout[1] 中对相同选项的解释。"

#. type: Plain text
#: en/git-restore.txt:90
#, priority:280
msgid "When restoring files on the working tree from the index, recreate the conflicted merge in the unmerged paths."
msgstr "当从索引恢复工作树上的文件时，在未合并的路径中重新创建冲突的合并。"

#. type: Labeled list
#: en/git-restore.txt:97
#, ignore-same, no-wrap, priority:280
msgid "--ignore-unmerged"
msgstr "--ignore-unmerged"

#. type: Plain text
#: en/git-restore.txt:102
#, priority:280
msgid "When restoring files on the working tree from the index, do not abort the operation if there are unmerged entries and neither `--ours`, `--theirs`, `--merge` or `--conflict` is specified. Unmerged paths on the working tree are left alone."
msgstr "当从索引中恢复工作树上的文件时，如果有未合并的条目，并且没有指定`--我们的`、`--他们的`、`--合并`或`--冲突`，不要中止操作。工作树上未合并的路径将被忽略。"

#. type: Plain text
#: en/git-restore.txt:109
#, priority:280
msgid "In sparse checkout mode, by default is to only update entries matched by `<pathspec>` and sparse patterns in $GIT_DIR/info/sparse-checkout. This option ignores the sparse patterns and unconditionally restores any files in `<pathspec>`."
msgstr "在稀疏检出模式下，默认情况下只更新由`<pathspec>`和$GIT_DIR/info/sparse-checkout中稀疏模式匹配的条目。这个选项忽略了稀疏模式，无条件地恢复了`<pathspec>`中的任何文件。"

#. type: Plain text
#: en/git-restore.txt:120
#, priority:280
msgid "If `<pathspec>` names an active submodule and the restore location includes the working tree, the submodule will only be updated if this option is given, in which case its working tree will be restored to the commit recorded in the superproject, and any local modifications overwritten. If nothing (or `--no-recurse-submodules`) is used, submodules working trees will not be updated. Just like linkgit:git-checkout[1], this will detach `HEAD` of the submodule."
msgstr "如果`<pathspec>`命名了一个活动的子模块，并且恢复的位置包括工作树，只有在给出这个选项的情况下，子模块才会被更新，在这种情况下，它的工作树将被恢复到超级项目中记录的提交，并且任何本地修改都会被覆盖。如果什么都不使用（或`--no-recurse-submodules`），子模块的工作树将不会被更新。就像linkgit:git-checkout[1]，这将分离子模块的`HEAD`。"

#. type: Plain text
#: en/git-restore.txt:127
#, priority:280
msgid "In overlay mode, the command never removes files when restoring. In no-overlay mode, tracked files that do not appear in the `--source` tree are removed, to make them match `<tree>` exactly. The default is no-overlay mode."
msgstr "在覆盖模式下，该命令在恢复时不会删除文件。在无覆盖模式下，不出现在\"--源 \"树中的被追踪文件会被删除，以使它们与\"<tree>\"完全匹配。默认是无覆盖模式。"

#. type: Plain text
#: en/git-restore.txt:155
#, priority:280
msgid "The following sequence switches to the `master` branch, reverts the `Makefile` to two revisions back, deletes hello.c by mistake, and gets it back from the index."
msgstr "下面的序列切换到 \"master \"分支，将 \"Makefile \"恢复到两个修订版，错误地删除了hello.c，并从索引中取回它。"

#. type: delimited block -
#: en/git-restore.txt:161
#, fuzzy, no-wrap, priority:280
msgid ""
"$ git switch master\n"
"$ git restore --source master~2 Makefile  <1>\n"
"$ rm -f hello.c\n"
"$ git restore hello.c                     <2>\n"
msgstr ""
"$ git switch master\n"
"$ git restore --source master~2 Makefile  <1>\n"
"$ rm -f hello.c\n"
"$ git restore hello.c                     <2>\n"

#. type: Plain text
#: en/git-restore.txt:165
#, priority:280
msgid "restore hello.c from the index"
msgstr "从索引中恢复 hello.c"

#. type: Plain text
#: en/git-restore.txt:168
#, priority:280
msgid "If you want to restore _all_ C source files to match the version in the index, you can say"
msgstr "如果你想恢复_所有的C源文件，使之与索引中的版本一致，你可以说"

#. type: delimited block -
#: en/git-restore.txt:171
#, fuzzy, no-wrap, priority:280
msgid "$ git restore '*.c'\n"
msgstr "$ git restore '*.c'\n"

#. type: Plain text
#: en/git-restore.txt:177
#, priority:280
msgid "Note the quotes around `*.c`.  The file `hello.c` will also be restored, even though it is no longer in the working tree, because the file globbing is used to match entries in the index (not in the working tree by the shell)."
msgstr "注意 \"*.c \"周围的引号。  文件`hello.c`也将被恢复，尽管它已经不在工作树中了，因为文件globbing是用来匹配索引中的条目的（不是由shell在工作树中）。"

#. type: Plain text
#: en/git-restore.txt:179
#, priority:280
msgid "To restore all files in the current directory"
msgstr "要恢复当前目录下的所有文件"

#. type: delimited block -
#: en/git-restore.txt:182
#, fuzzy, no-wrap, priority:280
msgid "$ git restore .\n"
msgstr "$ git restore .\n"

#. type: Plain text
#: en/git-restore.txt:186
#, priority:280
msgid "or to restore all working tree files with 'top' pathspec magic (see linkgit:gitglossary[7])"
msgstr "或者用'top'pathspec魔法恢复所有工作树文件（见linkgit:gitglossary[7]）。"

#. type: delimited block -
#: en/git-restore.txt:189
#, fuzzy, no-wrap, priority:280
msgid "$ git restore :/\n"
msgstr "$ git restore :/\n"

#. type: Plain text
#: en/git-restore.txt:193
#, priority:280
msgid "To restore a file in the index to match the version in `HEAD` (this is the same as using linkgit:git-reset[1])"
msgstr "将索引中的文件恢复到与`HEAD`中的版本一致（这与使用linkgit:git-reset[1]相同）。"

#. type: delimited block -
#: en/git-restore.txt:196
#, fuzzy, no-wrap, priority:280
msgid "$ git restore --staged hello.c\n"
msgstr "$ git restore --staged hello.c\n"

#. type: Plain text
#: en/git-restore.txt:200
#, priority:280
msgid "or you can restore both the index and the working tree (this the same as using linkgit:git-checkout[1])"
msgstr "或者你可以同时恢复索引和工作树（这与使用linkgit:git-checkout[1]相同）。"

#. type: delimited block -
#: en/git-restore.txt:203
#, fuzzy, no-wrap, priority:280
msgid "$ git restore --source=HEAD --staged --worktree hello.c\n"
msgstr "$ git restore --source=HEAD --staged --worktree hello.c\n"

#. type: Plain text
#: en/git-restore.txt:206
#, priority:280
msgid "or the short form which is more practical but less readable:"
msgstr "或更实用但可读性较差的简短形式。"

#. type: delimited block -
#: en/git-restore.txt:209
#, fuzzy, no-wrap, priority:280
msgid "$ git restore -s@ -SW hello.c\n"
msgstr "$ git restore -s@ -SW hello.c\n"

#. type: Plain text
#: en/git-restore.txt:215
#, ignore-same, priority:280
msgid "linkgit:git-checkout[1], linkgit:git-reset[1]"
msgstr "linkgit:git-checkout[1], linkgit:git-reset[1]"

#. type: Title =
#: en/git-revert.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-revert(1)"
msgstr "git-revert(1)"

#. type: Plain text
#: en/git-revert.txt:7
#, priority:100
msgid "git-revert - Revert some existing commits"
msgstr ""

#. type: Plain text
#: en/git-revert.txt:13
#, ignore-ellipsis, no-wrap, priority:100
msgid ""
"'git revert' [--[no-]edit] [-n] [-m <parent-number>] [-s] [-S[<keyid>]] <commit>...\n"
"'git revert' (--continue | --skip | --abort | --quit)\n"
msgstr ""
"'git revert' [--[no-]edit] [-n] [-m <parent-number>] [-s] [-S[<keyid>]] <commit>...\n"
"'git revert' (--continue | --skip | --abort | --quit)\n"

#. type: Plain text
#: en/git-revert.txt:21
#, priority:100
msgid "Given one or more existing commits, revert the changes that the related patches introduce, and record some new commits that record them.  This requires your working tree to be clean (no modifications from the HEAD commit)."
msgstr ""

#. type: Plain text
#: en/git-revert.txt:30
#, priority:100
msgid "Note: 'git revert' is used to record some new commits to reverse the effect of some earlier commits (often only a faulty one).  If you want to throw away all uncommitted changes in your working directory, you should see linkgit:git-reset[1], particularly the `--hard` option.  If you want to extract specific files as they were in another commit, you should see linkgit:git-restore[1], specifically the `--source` option. Take care with these alternatives as both will discard uncommitted changes in your working directory."
msgstr ""

#. type: Plain text
#: en/git-revert.txt:43
#, priority:100
msgid "Commits to revert.  For a more complete list of ways to spell commit names, see linkgit:gitrevisions[7].  Sets of commits can also be given but no traversal is done by default, see linkgit:git-rev-list[1] and its `--no-walk` option."
msgstr ""

#. type: Plain text
#: en/git-revert.txt:49
#, priority:100
msgid "With this option, 'git revert' will let you edit the commit message prior to committing the revert. This is the default if you run the command from a terminal."
msgstr ""

#. type: Labeled list
#: en/git-revert.txt:50
#, no-wrap, priority:100
msgid "-m parent-number"
msgstr ""

#. type: Labeled list
#: en/git-revert.txt:51
#, fuzzy, no-wrap, priority:100
msgid "--mainline parent-number"
msgstr "--mainline parent-number"

#. type: Plain text
#: en/git-revert.txt:57
#, priority:100
msgid "Usually you cannot revert a merge because you do not know which side of the merge should be considered the mainline.  This option specifies the parent number (starting from 1) of the mainline and allows revert to reverse the change relative to the specified parent."
msgstr ""

#. type: Plain text
#: en/git-revert.txt:62
#, priority:100
msgid "Reverting a merge commit declares that you will never want the tree changes brought in by the merge.  As a result, later merges will only bring in tree changes introduced by commits that are not ancestors of the previously reverted merge.  This may or may not be what you want."
msgstr ""

#. type: Plain text
#: en/git-revert.txt:65
#, priority:100
msgid "See the link:howto/revert-a-faulty-merge.html[revert-a-faulty-merge How-To] for more details."
msgstr ""

#. type: Plain text
#: en/git-revert.txt:69
#, priority:100
msgid "With this option, 'git revert' will not start the commit message editor."
msgstr ""

#. type: Plain text
#: en/git-revert.txt:87
#, priority:100
msgid "Usually the command automatically creates some commits with commit log messages stating which commits were reverted.  This flag applies the changes necessary to revert the named commits to your working tree and the index, but does not make the commits.  In addition, when this option is used, your index does not have to match the HEAD commit.  The revert is done against the beginning state of your index."
msgstr ""

#. type: Plain text
#: en/git-revert.txt:90
#, priority:100
msgid "This is useful when reverting more than one commits' effect to your index in a row."
msgstr ""

#. type: Labeled list
#: en/git-revert.txt:117
#, ignore-same, no-wrap, priority:100
msgid "--reference"
msgstr "--reference"

#. type: Plain text
#: en/git-revert.txt:124
#, priority:100
msgid "Instead of starting the body of the log message with \"This reverts <full object name of the commit being reverted>.\", refer to the commit using \"--pretty=reference\" format (cf. linkgit:git-log[1]).  The `revert.reference` configuration variable can be used to enable this option by default."
msgstr ""

#. type: Labeled list
#: en/git-revert.txt:132
#, no-wrap, priority:100
msgid "`git revert HEAD~3`"
msgstr ""

#. type: Plain text
#: en/git-revert.txt:136
#, priority:100
msgid "Revert the changes specified by the fourth last commit in HEAD and create a new commit with the reverted changes."
msgstr ""

#. type: Labeled list
#: en/git-revert.txt:137
#, no-wrap, priority:100
msgid "`git revert -n master~5..master~2`"
msgstr ""

#. type: Plain text
#: en/git-revert.txt:144
#, priority:100
msgid "Revert the changes done by commits from the fifth last commit in master (included) to the third last commit in master (included), but do not create any commit with the reverted changes. The revert only modifies the working tree and the index."
msgstr ""

#. type: Title =
#: en/git-rev-list.txt:2
#, ignore-same, no-wrap, priority:80
msgid "git-rev-list(1)"
msgstr "git-rev-list(1)"

#. type: Plain text
#: en/git-rev-list.txt:7
#, priority:80
msgid "git-rev-list - Lists commit objects in reverse chronological order"
msgstr "git-rev-list 按照时间倒序列出提交对象"

#. type: Plain text
#: en/git-rev-list.txt:13
#, fuzzy, ignore-ellipsis, no-wrap, priority:80
#| msgid "'git rev-list' [<options>] <commit>... [[--] <path>...]\n"
msgid "'git rev-list' [<options>] <commit>... [--] [<path>...]\n"
msgstr "'git rev-list' [<options>] <commit>... [[--] <path>...]\n"

#. type: Plain text
#: en/git-rev-list.txt:25
#, fuzzy, priority:80
msgid "'rev-list' is a very essential Git command, since it provides the ability to build and traverse commit ancestry graphs. For this reason, it has a lot of different options that enables it to be used by commands as different as 'git bisect' and 'git repack'."
msgstr "'rev-list' 是一个非常必要的Git命令，因为它提供了构建和遍历祖先图的功能。正因如此，它有很多不同的选项，使得它可以被不同的命令使用，如 'git bisect' 和 'git repack'。"

#. type: Plain text
#: en/git-rev-list.txt:38
#, priority:80
msgid "Print the list of commits reachable from the current branch."
msgstr "打印可从当前分支访问的提交列表。"

#. type: delimited block -
#: en/git-rev-list.txt:41
#, fuzzy, no-wrap, priority:80
msgid "git rev-list HEAD\n"
msgstr "$ git rebase -i HEAD~5\n"

#. type: Plain text
#: en/git-rev-list.txt:45
#, priority:80
msgid "Print the list of commits on this branch, but not present in the upstream branch."
msgstr ""

#. type: delimited block -
#: en/git-rev-list.txt:48
#, no-wrap, priority:80
msgid "git rev-list @{upstream}..HEAD\n"
msgstr ""

#. type: Plain text
#: en/git-rev-list.txt:52
#, priority:80
msgid "Format commits with their author and commit message (see also the porcelain linkgit:git-log[1])."
msgstr ""

#. type: delimited block -
#: en/git-rev-list.txt:55
#, fuzzy, no-wrap, priority:80
msgid "git rev-list --format=medium HEAD\n"
msgstr "$ git rev-parse --verify HEAD\n"

#. type: Plain text
#: en/git-rev-list.txt:59
#, priority:80
msgid "Format commits along with their diffs (see also the porcelain linkgit:git-log[1], which can do this in a single process)."
msgstr ""

#. type: delimited block -
#: en/git-rev-list.txt:63
#, no-wrap, priority:80
msgid ""
"git rev-list HEAD |\n"
"git diff-tree --stdin --format=medium -p\n"
msgstr ""

#. type: Plain text
#: en/git-rev-list.txt:67
#, priority:80
msgid "Print the list of commits on the current branch that touched any file in the `Documentation` directory."
msgstr ""

#. type: delimited block -
#: en/git-rev-list.txt:70
#, fuzzy, no-wrap, priority:80
msgid "git rev-list HEAD -- Documentation/\n"
msgstr "git rev-list HEAD -- Documentation/\n"

#. type: Plain text
#: en/git-rev-list.txt:74
#, priority:80
msgid "Print the list of commits authored by you in the past year, on any branch, tag, or other ref."
msgstr ""

#. type: delimited block -
#: en/git-rev-list.txt:77
#, no-wrap, priority:80
msgid "git rev-list --author=you@example.com --since=1.year.ago --all\n"
msgstr ""

#. type: Plain text
#: en/git-rev-list.txt:81
#, priority:80
msgid "Print the list of objects reachable from the current branch (i.e., all commits and the blobs and trees they contain)."
msgstr ""

#. type: delimited block -
#: en/git-rev-list.txt:84
#, fuzzy, no-wrap, priority:80
msgid "git rev-list --objects HEAD\n"
msgstr "$ git rev-parse --verify HEAD\n"

#. type: Plain text
#: en/git-rev-list.txt:91
#, priority:80
msgid "Compare the disk size of all reachable objects, versus those reachable from reflogs, versus the total packed size. This can tell you whether running `git repack -ad` might reduce the repository size (by dropping unreachable objects), and whether expiring reflogs might help."
msgstr ""

#. type: delimited block -
#: en/git-rev-list.txt:101
#, no-wrap, priority:80
msgid ""
"# reachable objects\n"
"git rev-list --disk-usage --objects --all\n"
"# plus reflogs\n"
"git rev-list --disk-usage --objects --all --reflog\n"
"# total disk size used\n"
"du -c .git/objects/pack/*.pack .git/objects/??/*\n"
"# alternative to du: add up \"size\" and \"size-pack\" fields\n"
"git count-objects -v\n"
msgstr ""

#. type: Plain text
#: en/git-rev-list.txt:107
#, priority:80
msgid "Report the disk size of each branch, not including objects used by the current branch. This can find outliers that are contributing to a bloated repository size (e.g., because somebody accidentally committed large build artifacts)."
msgstr ""

#. type: delimited block -
#: en/git-rev-list.txt:116
#, no-wrap, priority:80
msgid ""
"git for-each-ref --format='%(refname)' |\n"
"while read branch\n"
"do\n"
"\tsize=$(git rev-list --disk-usage --objects HEAD..$branch)\n"
"\techo \"$size $branch\"\n"
"done |\n"
"sort -n\n"
msgstr ""

#. type: Plain text
#: en/git-rev-list.txt:122
#, priority:80
msgid "Compare the on-disk size of branches in one group of refs, excluding another. If you co-mingle objects from multiple remotes in a single repository, this can show which remotes are contributing to the repository size (taking the size of `origin` as a baseline)."
msgstr ""

#. type: delimited block -
#: en/git-rev-list.txt:125
#, no-wrap, priority:80
msgid "git rev-list --disk-usage --objects --remotes=$suspect --not --remotes=origin\n"
msgstr ""

#. type: Title =
#: en/git-rev-parse.txt:2
#, ignore-same, no-wrap, priority:80
msgid "git-rev-parse(1)"
msgstr "git-rev-parse(1)"

#. type: Plain text
#: en/git-rev-parse.txt:7
#, priority:80
msgid "git-rev-parse - Pick out and massage parameters"
msgstr ""

#. type: Plain text
#: en/git-rev-parse.txt:13
#, fuzzy, ignore-ellipsis, no-wrap, priority:80
msgid "'git rev-parse' [<options>] <args>...\n"
msgstr "'git rev-parse' [<options>] <args>...\n"

#. type: Plain text
#: en/git-rev-parse.txt:23
#, priority:80
msgid "Many Git porcelainish commands take mixture of flags (i.e. parameters that begin with a dash '-') and parameters meant for the underlying 'git rev-list' command they use internally and flags and parameters for the other commands they use downstream of 'git rev-list'.  This command is used to distinguish between them."
msgstr ""

#. type: Title ~
#: en/git-rev-parse.txt:29
#, fuzzy, no-wrap, priority:80
msgid "Operation Modes"
msgstr "操作模式"

#. type: Plain text
#: en/git-rev-parse.txt:32
#, priority:80
msgid "Each of these options must appear first on the command line."
msgstr ""

#. type: Labeled list
#: en/git-rev-parse.txt:33
#, ignore-same, no-wrap, priority:80
msgid "--parseopt"
msgstr "--parseopt"

#. type: Plain text
#: en/git-rev-parse.txt:35
#, priority:80
msgid "Use 'git rev-parse' in option parsing mode (see PARSEOPT section below)."
msgstr ""

#. type: Labeled list
#: en/git-rev-parse.txt:36
#, ignore-same, no-wrap, priority:80
msgid "--sq-quote"
msgstr "--sq-quote"

#. type: Plain text
#: en/git-rev-parse.txt:40
#, priority:80
msgid "Use 'git rev-parse' in shell quoting mode (see SQ-QUOTE section below). In contrast to the `--sq` option below, this mode does only quoting. Nothing else is done to command input."
msgstr ""

#. type: Title ~
#: en/git-rev-parse.txt:42
#, fuzzy, no-wrap, priority:80
msgid "Options for --parseopt"
msgstr "选项 --parseopt"

#. type: Labeled list
#: en/git-rev-parse.txt:44
#, ignore-same, no-wrap, priority:80
msgid "--keep-dashdash"
msgstr "--keep-dashdash"

#. type: Plain text
#: en/git-rev-parse.txt:47
#, priority:80
msgid "Only meaningful in `--parseopt` mode. Tells the option parser to echo out the first `--` met instead of skipping it."
msgstr ""

#. type: Labeled list
#: en/git-rev-parse.txt:48
#, ignore-same, no-wrap, priority:80
msgid "--stop-at-non-option"
msgstr "--stop-at-non-option"

#. type: Plain text
#: en/git-rev-parse.txt:52
#, priority:80
msgid "Only meaningful in `--parseopt` mode.  Lets the option parser stop at the first non-option argument.  This can be used to parse sub-commands that take options themselves."
msgstr ""

#. type: Labeled list
#: en/git-rev-parse.txt:53
#, ignore-same, no-wrap, priority:80
msgid "--stuck-long"
msgstr "--stuck-long"

#. type: Plain text
#: en/git-rev-parse.txt:56
#, priority:80
msgid "Only meaningful in `--parseopt` mode. Output the options in their long form if available, and with their arguments stuck."
msgstr ""

#. type: Title ~
#: en/git-rev-parse.txt:58
#, no-wrap, priority:80
msgid "Options for Filtering"
msgstr ""

#. type: Labeled list
#: en/git-rev-parse.txt:60
#, ignore-same, no-wrap, priority:80
msgid "--revs-only"
msgstr "--revs-only"

#. type: Plain text
#: en/git-rev-parse.txt:63
#, priority:80
msgid "Do not output flags and parameters not meant for 'git rev-list' command."
msgstr ""

#. type: Labeled list
#: en/git-rev-parse.txt:64
#, ignore-same, no-wrap, priority:80
msgid "--no-revs"
msgstr "--no-revs"

#. type: Plain text
#: en/git-rev-parse.txt:67
#, priority:80
msgid "Do not output flags and parameters meant for 'git rev-list' command."
msgstr ""

#. type: Labeled list
#: en/git-rev-parse.txt:68
#, ignore-same, no-wrap, priority:80
msgid "--flags"
msgstr "--flags"

#. type: Plain text
#: en/git-rev-parse.txt:70
#, priority:80
msgid "Do not output non-flag parameters."
msgstr ""

#. type: Labeled list
#: en/git-rev-parse.txt:71
#, ignore-same, no-wrap, priority:80
msgid "--no-flags"
msgstr "--no-flags"

#. type: Plain text
#: en/git-rev-parse.txt:73
#, priority:80
msgid "Do not output flag parameters."
msgstr ""

#. type: Title ~
#: en/git-rev-parse.txt:75
#, no-wrap, priority:80
msgid "Options for Output"
msgstr ""

#. type: Labeled list
#: en/git-rev-parse.txt:77
#, fuzzy, no-wrap, priority:80
msgid "--default <arg>"
msgstr "--default <arg>"

#. type: Plain text
#: en/git-rev-parse.txt:80
#, priority:80
msgid "If there is no parameter given by the user, use `<arg>` instead."
msgstr ""

#. type: Labeled list
#: en/git-rev-parse.txt:81
#, fuzzy, no-wrap, priority:80
msgid "--prefix <arg>"
msgstr "--prefix <arg>"

#. type: Plain text
#: en/git-rev-parse.txt:86
#, priority:80
msgid "Behave as if 'git rev-parse' was invoked from the `<arg>` subdirectory of the working tree.  Any relative filenames are resolved as if they are prefixed by `<arg>` and will be printed in that form."
msgstr ""

#. type: Plain text
#: en/git-rev-parse.txt:90
#, priority:80
msgid "This can be used to convert arguments to a command run in a subdirectory so that they can still be used after moving to the top-level of the repository.  For example:"
msgstr ""

#. type: delimited block -
#: en/git-rev-parse.txt:96
#, no-wrap, priority:80
msgid ""
"prefix=$(git rev-parse --show-prefix)\n"
"cd \"$(git rev-parse --show-toplevel)\"\n"
"# rev-parse provides the -- needed for 'set'\n"
"eval \"set $(git rev-parse --sq --prefix \"$prefix\" -- \"$@\")\"\n"
msgstr ""

#. type: Plain text
#: en/git-rev-parse.txt:103
#, priority:80
msgid "Verify that exactly one parameter is provided, and that it can be turned into a raw 20-byte SHA-1 that can be used to access the object database. If so, emit it to the standard output; otherwise, error out."
msgstr ""

#. type: Plain text
#: en/git-rev-parse.txt:112
#, priority:80
msgid "If you want to make sure that the output actually names an object in your object database and/or can be used as a specific type of object you require, you can add the `^{type}` peeling operator to the parameter.  For example, `git rev-parse \"$VAR^{commit}\"` will make sure `$VAR` names an existing object that is a commit-ish (i.e. a commit, or an annotated tag that points at a commit).  To make sure that `$VAR` names an existing object of any type, `git rev-parse \"$VAR^{object}\"` can be used."
msgstr ""

#. type: Plain text
#: en/git-rev-parse.txt:116
#, priority:80
msgid "Note that if you are verifying a name from an untrusted source, it is wise to use `--end-of-options` so that the name argument is not mistaken for another option."
msgstr ""

#. type: Plain text
#: en/git-rev-parse.txt:123
#, priority:80
msgid "Only meaningful in `--verify` mode. Do not output an error message if the first argument is not a valid object name; instead exit with non-zero status silently.  SHA-1s for valid object names are printed to stdout on success."
msgstr ""

#. type: Labeled list
#: en/git-rev-parse.txt:124
#, ignore-same, no-wrap, priority:80
msgid "--sq"
msgstr "--sq"

#. type: Plain text
#: en/git-rev-parse.txt:132
#, priority:80
msgid "Usually the output is made one line per flag and parameter.  This option makes output a single line, properly quoted for consumption by shell.  Useful when you expect your parameter to contain whitespaces and newlines (e.g. when using pickaxe `-S` with 'git diff-{asterisk}'). In contrast to the `--sq-quote` option, the command input is still interpreted as usual."
msgstr ""

#. type: Labeled list
#: en/git-rev-parse.txt:133
#, no-wrap, priority:80
msgid "--short[=length]"
msgstr ""

#. type: Plain text
#: en/git-rev-parse.txt:138
#, priority:80
msgid "Same as `--verify` but shortens the object name to a unique prefix with at least `length` characters. The minimum length is 4, the default is the effective value of the `core.abbrev` configuration variable (see linkgit:git-config[1])."
msgstr ""

#. type: Plain text
#: en/git-rev-parse.txt:143
#, priority:80
msgid "When showing object names, prefix them with '{caret}' and strip '{caret}' prefix from the object names that already have one."
msgstr ""

#. type: Labeled list
#: en/git-rev-parse.txt:144
#, fuzzy, no-wrap, priority:80
msgid "--abbrev-ref[=(strict|loose)]"
msgstr "--abbrev-ref[=(strict|loose)]"

#. type: Plain text
#: en/git-rev-parse.txt:148
#, priority:80
msgid "A non-ambiguous short name of the objects name.  The option core.warnAmbiguousRefs is used to select the strict abbreviation mode."
msgstr ""

#. type: Labeled list
#: en/git-rev-parse.txt:149
#, ignore-same, no-wrap, priority:80
msgid "--symbolic"
msgstr "--symbolic"

#. type: Plain text
#: en/git-rev-parse.txt:153
#, priority:80
msgid "Usually the object names are output in SHA-1 form (with possible '{caret}' prefix); this option makes them output in a form as close to the original input as possible."
msgstr ""

#. type: Labeled list
#: en/git-rev-parse.txt:154
#, ignore-same, no-wrap, priority:80
msgid "--symbolic-full-name"
msgstr "--symbolic-full-name"

#. type: Plain text
#: en/git-rev-parse.txt:161
#, priority:80
msgid "This is similar to --symbolic, but it omits input that are not refs (i.e. branch or tag names; or more explicitly disambiguating \"heads/master\" form, when you want to name the \"master\" branch when there is an unfortunately named tag \"master\"), and show them as full refnames (e.g. \"refs/heads/master\")."
msgstr ""

#. type: Title ~
#: en/git-rev-parse.txt:163
#, no-wrap, priority:80
msgid "Options for Objects"
msgstr ""

#. type: Plain text
#: en/git-rev-parse.txt:167
#, priority:80
msgid "Show all refs found in `refs/`."
msgstr ""

#. type: Labeled list
#: en/git-rev-parse.txt:168
#, fuzzy, no-wrap, priority:80
msgid "--branches[=pattern]"
msgstr "--branches[=pattern]"

#. type: Labeled list
#: en/git-rev-parse.txt:169
#, fuzzy, no-wrap, priority:80
msgid "--tags[=pattern]"
msgstr "--tags[=pattern]"

#. type: Labeled list
#: en/git-rev-parse.txt:170
#, fuzzy, no-wrap, priority:80
msgid "--remotes[=pattern]"
msgstr "--remotes[=pattern]"

#. type: Plain text
#: en/git-rev-parse.txt:174
#, priority:80
msgid "Show all branches, tags, or remote-tracking branches, respectively (i.e., refs found in `refs/heads`, `refs/tags`, or `refs/remotes`, respectively)."
msgstr ""

#. type: Plain text
#: en/git-rev-parse.txt:178
#, priority:80
msgid "If a `pattern` is given, only refs matching the given shell glob are shown.  If the pattern does not contain a globbing character (`?`, `*`, or `[`), it is turned into a prefix match by appending `/*`."
msgstr ""

#. type: Labeled list
#: en/git-rev-parse.txt:179
#, fuzzy, no-wrap, priority:80
msgid "--glob=pattern"
msgstr "--glob=pattern"

#. type: Plain text
#: en/git-rev-parse.txt:185
#, priority:80
msgid "Show all refs matching the shell glob pattern `pattern`. If the pattern does not start with `refs/`, this is automatically prepended.  If the pattern does not contain a globbing character (`?`, `*`, or `[`), it is turned into a prefix match by appending `/*`."
msgstr ""

#. type: Labeled list
#: en/git-rev-parse.txt:186 en/rev-list-options.txt:183
#, no-wrap, priority:260
msgid "--exclude=<glob-pattern>"
msgstr "--exclude=<glob-pattern>（排除）。"

#. type: Plain text
#: en/git-rev-parse.txt:193 en/rev-list-options.txt:191
#, priority:260
msgid "Do not include refs matching '<glob-pattern>' that the next `--all`, `--branches`, `--tags`, `--remotes`, or `--glob` would otherwise consider. Repetitions of this option accumulate exclusion patterns up to the next `--all`, `--branches`, `--tags`, `--remotes`, or `--glob` option (other options or arguments do not clear accumulated patterns)."
msgstr "不包括匹配\"<glob-pattern>\"的参考文献，否则下一个`--all`、`--branches`、`--tags`、`--remotes`或`--glob`会考虑这些参考文献。重复这个选项可以累积排除模式，直到下一个`----all`、`---branches`、`---tags`、`---remotes`或`---glob`选项（其他选项或参数不清除累积模式）。"

#. type: Plain text
#: en/git-rev-parse.txt:199 en/rev-list-options.txt:197
#, priority:260
msgid "The patterns given should not begin with `refs/heads`, `refs/tags`, or `refs/remotes` when applied to `--branches`, `--tags`, or `--remotes`, respectively, and they must begin with `refs/` when applied to `--glob` or `--all`. If a trailing '/{asterisk}' is intended, it must be given explicitly."
msgstr "当应用于\"--分支\"、\"--标签 \"或\"--远程 \"时，给出的模式不应该以 \"refs/heads\"、\"refs/tags \"或 \"refs/remotes \"开头，而当应用于\"--glob \"或 \"all \"时，必须以 \"refs/\"开头。如果打算使用尾部的\"/{asterisk}\"，必须明确给出。"

#. type: Labeled list
#: en/git-rev-parse.txt:200 en/rev-list-options.txt:198
#, no-wrap, priority:260
msgid "--exclude-hidden=[fetch|receive|uploadpack]"
msgstr "--exclude-hidden=[fetch|receive|uploadpack]"

#. type: Plain text
#: en/git-rev-parse.txt:207 en/rev-list-options.txt:205
#, fuzzy, priority:260
#| msgid "Do not include refs that would be hidden by `git-receive-pack` or `git-upload-pack` by consulting the appropriate `receive.hideRefs` or `uploadpack.hideRefs` configuration along with `transfer.hideRefs` (see linkgit:git-config[1]). This option affects the next pseudo-ref option `--all` or `--glob` and is cleared after processing them."
msgid "Do not include refs that would be hidden by `git-fetch`, `git-receive-pack` or `git-upload-pack` by consulting the appropriate `fetch.hideRefs`, `receive.hideRefs` or `uploadpack.hideRefs` configuration along with `transfer.hideRefs` (see linkgit:git-config[1]). This option affects the next pseudo-ref option `--all` or `--glob` and is cleared after processing them."
msgstr "想不包括那些会被`git-receive-pack`或`git-upload-pack`隐藏的引用，方法是进行适当的`receive.hideRefs`或`uploadpack.hideRefs`以及`transfer.hideRefs`配置（见linkgit:git-config[1]）。选项`--all`或`--glob项会影响到下一个伪引用，并在处理完它们之后清除。"

#. type: Labeled list
#: en/git-rev-parse.txt:208
#, fuzzy, no-wrap, priority:80
msgid "--disambiguate=<prefix>"
msgstr "--disambiguate=<prefix>"

#. type: Plain text
#: en/git-rev-parse.txt:213
#, priority:80
msgid "Show every object whose name begins with the given prefix.  The <prefix> must be at least 4 hexadecimal digits long to avoid listing each and every object in the repository by mistake."
msgstr ""

#. type: Title ~
#: en/git-rev-parse.txt:215
#, no-wrap, priority:80
msgid "Options for Files"
msgstr ""

#. type: Labeled list
#: en/git-rev-parse.txt:217
#, ignore-same, no-wrap, priority:80
msgid "--local-env-vars"
msgstr "--local-env-vars"

#. type: Plain text
#: en/git-rev-parse.txt:222
#, priority:80
msgid "List the GIT_* environment variables that are local to the repository (e.g. GIT_DIR or GIT_WORK_TREE, but not GIT_EDITOR).  Only the names of the variables are listed, not their value, even if they are set."
msgstr ""

#. type: Labeled list
#: en/git-rev-parse.txt:223
#, no-wrap, priority:80
msgid "--path-format=(absolute|relative)"
msgstr ""

#. type: Plain text
#: en/git-rev-parse.txt:228
#, priority:80
msgid "Controls the behavior of certain other options. If specified as absolute, the paths printed by those options will be absolute and canonical. If specified as relative, the paths will be relative to the current working directory if that is possible.  The default is option specific."
msgstr ""

#. type: Plain text
#: en/git-rev-parse.txt:232
#, priority:80
msgid "This option may be specified multiple times and affects only the arguments that follow it on the command line, either to the end of the command line or the next instance of this option."
msgstr ""

#. type: Plain text
#: en/git-rev-parse.txt:234
#, priority:80
msgid "The following options are modified by `--path-format`:"
msgstr ""

#. type: Labeled list
#: en/git-rev-parse.txt:235
#, ignore-same, no-wrap, priority:80
msgid "--git-dir"
msgstr "--git-dir"

#. type: Plain text
#: en/git-rev-parse.txt:239
#, priority:80
msgid "Show `$GIT_DIR` if defined. Otherwise show the path to the .git directory. The path shown, when relative, is relative to the current working directory."
msgstr ""

#. type: Plain text
#: en/git-rev-parse.txt:243
#, priority:80
msgid "If `$GIT_DIR` is not defined and the current directory is not detected to lie in a Git repository or work tree print a message to stderr and exit with nonzero status."
msgstr ""

#. type: Labeled list
#: en/git-rev-parse.txt:244
#, ignore-same, no-wrap, priority:80
msgid "--git-common-dir"
msgstr "--git-common-dir"

#. type: Plain text
#: en/git-rev-parse.txt:246
#, priority:80
msgid "Show `$GIT_COMMON_DIR` if defined, else `$GIT_DIR`."
msgstr ""

#. type: Labeled list
#: en/git-rev-parse.txt:247
#, fuzzy, no-wrap, priority:80
msgid "--resolve-git-dir <path>"
msgstr "--resolve-git-dir <path>"

#. type: Plain text
#: en/git-rev-parse.txt:252
#, priority:80
msgid "Check if <path> is a valid repository or a gitfile that points at a valid repository, and print the location of the repository.  If <path> is a gitfile then the resolved path to the real repository is printed."
msgstr ""

#. type: Labeled list
#: en/git-rev-parse.txt:253
#, fuzzy, no-wrap, priority:80
msgid "--git-path <path>"
msgstr "--git-path <path>"

#. type: Plain text
#: en/git-rev-parse.txt:259
#, ignore-ellipsis, priority:80
msgid "Resolve \"$GIT_DIR/<path>\" and takes other path relocation variables such as $GIT_OBJECT_DIRECTORY, $GIT_INDEX_FILE... into account. For example, if $GIT_OBJECT_DIRECTORY is set to /foo/bar then \"git rev-parse --git-path objects/abc\" returns /foo/bar/abc."
msgstr ""

#. type: Labeled list
#: en/git-rev-parse.txt:260
#, ignore-same, no-wrap, priority:80
msgid "--show-toplevel"
msgstr "--show-toplevel"

#. type: Plain text
#: en/git-rev-parse.txt:263
#, priority:80
msgid "Show the (by default, absolute) path of the top-level directory of the working tree. If there is no working tree, report an error."
msgstr ""

#. type: Labeled list
#: en/git-rev-parse.txt:264
#, ignore-same, no-wrap, priority:80
msgid "--show-superproject-working-tree"
msgstr "--show-superproject-working-tree"

#. type: Plain text
#: en/git-rev-parse.txt:269
#, priority:80
msgid "Show the absolute path of the root of the superproject's working tree (if exists) that uses the current repository as its submodule.  Outputs nothing if the current repository is not used as a submodule by any project."
msgstr ""

#. type: Labeled list
#: en/git-rev-parse.txt:270
#, ignore-same, no-wrap, priority:80
msgid "--shared-index-path"
msgstr "--shared-index-path"

#. type: Plain text
#: en/git-rev-parse.txt:273
#, priority:80
msgid "Show the path to the shared index file in split index mode, or empty if not in split-index mode."
msgstr ""

#. type: Plain text
#: en/git-rev-parse.txt:275
#, priority:80
msgid "The following options are unaffected by `--path-format`:"
msgstr ""

#. type: Labeled list
#: en/git-rev-parse.txt:276
#, ignore-same, no-wrap, priority:80
msgid "--absolute-git-dir"
msgstr "--absolute-git-dir"

#. type: Plain text
#: en/git-rev-parse.txt:279
#, priority:80
msgid "Like `--git-dir`, but its output is always the canonicalized absolute path."
msgstr ""

#. type: Labeled list
#: en/git-rev-parse.txt:280
#, ignore-same, no-wrap, priority:80
msgid "--is-inside-git-dir"
msgstr "--is-inside-git-dir"

#. type: Plain text
#: en/git-rev-parse.txt:283
#, priority:80
msgid "When the current working directory is below the repository directory print \"true\", otherwise \"false\"."
msgstr ""

#. type: Labeled list
#: en/git-rev-parse.txt:284
#, ignore-same, no-wrap, priority:80
msgid "--is-inside-work-tree"
msgstr "--is-inside-work-tree"

#. type: Plain text
#: en/git-rev-parse.txt:287
#, priority:80
msgid "When the current working directory is inside the work tree of the repository print \"true\", otherwise \"false\"."
msgstr ""

#. type: Labeled list
#: en/git-rev-parse.txt:288
#, ignore-same, no-wrap, priority:80
msgid "--is-bare-repository"
msgstr "--is-bare-repository"

#. type: Plain text
#: en/git-rev-parse.txt:290
#, priority:80
msgid "When the repository is bare print \"true\", otherwise \"false\"."
msgstr ""

#. type: Labeled list
#: en/git-rev-parse.txt:291
#, ignore-same, no-wrap, priority:80
msgid "--is-shallow-repository"
msgstr "--is-shallow-repository"

#. type: Plain text
#: en/git-rev-parse.txt:293
#, priority:80
msgid "When the repository is shallow print \"true\", otherwise \"false\"."
msgstr ""

#. type: Labeled list
#: en/git-rev-parse.txt:294
#, ignore-same, no-wrap, priority:80
msgid "--show-cdup"
msgstr "--show-cdup"

#. type: Plain text
#: en/git-rev-parse.txt:298
#, priority:80
msgid "When the command is invoked from a subdirectory, show the path of the top-level directory relative to the current directory (typically a sequence of \"../\", or an empty string)."
msgstr ""

#. type: Labeled list
#: en/git-rev-parse.txt:299
#, ignore-same, no-wrap, priority:80
msgid "--show-prefix"
msgstr "--show-prefix"

#. type: Plain text
#: en/git-rev-parse.txt:303
#, priority:80
msgid "When the command is invoked from a subdirectory, show the path of the current directory relative to the top-level directory."
msgstr ""

#. type: Labeled list
#: en/git-rev-parse.txt:304
#, no-wrap, priority:80
msgid "--show-object-format[=(storage|input|output)]"
msgstr ""

#. type: Plain text
#: en/git-rev-parse.txt:309
#, priority:80
msgid "Show the object format (hash algorithm) used for the repository for storage inside the `.git` directory, input, or output. For input, multiple algorithms may be printed, space-separated.  If not specified, the default is \"storage\"."
msgstr ""

#. type: Title ~
#: en/git-rev-parse.txt:312
#, fuzzy, no-wrap, priority:80
msgid "Other Options"
msgstr "其他选项"

#. type: Labeled list
#: en/git-rev-parse.txt:314
#, no-wrap, priority:80
msgid "--since=datestring"
msgstr ""

#. type: Labeled list
#: en/git-rev-parse.txt:315
#, fuzzy, no-wrap, priority:80
msgid "--after=datestring"
msgstr "--after=datestring"

#. type: Plain text
#: en/git-rev-parse.txt:318
#, priority:80
msgid "Parse the date string, and output the corresponding --max-age= parameter for 'git rev-list'."
msgstr ""

#. type: Labeled list
#: en/git-rev-parse.txt:319
#, fuzzy, no-wrap, priority:80
msgid "--until=datestring"
msgstr "--until=datestring"

#. type: Labeled list
#: en/git-rev-parse.txt:320
#, no-wrap, priority:80
msgid "--before=datestring"
msgstr ""

#. type: Plain text
#: en/git-rev-parse.txt:323
#, priority:80
msgid "Parse the date string, and output the corresponding --min-age= parameter for 'git rev-list'."
msgstr ""

#. type: Labeled list
#: en/git-rev-parse.txt:324
#, ignore-ellipsis, no-wrap, priority:80
msgid "<args>..."
msgstr ""

#. type: Plain text
#: en/git-rev-parse.txt:326
#, priority:80
msgid "Flags and parameters to be parsed."
msgstr ""

#. type: Title -
#: en/git-rev-parse.txt:331
#, fuzzy, no-wrap, priority:80
msgid "PARSEOPT"
msgstr "PARSEOPT"

#. type: Plain text
#: en/git-rev-parse.txt:336
#, priority:80
msgid "In `--parseopt` mode, 'git rev-parse' helps massaging options to bring to shell scripts the same facilities C builtins have. It works as an option normalizer (e.g. splits single switches aggregate values), a bit like `getopt(1)` does."
msgstr ""

#. type: Plain text
#: en/git-rev-parse.txt:341
#, priority:80
msgid "It takes on the standard input the specification of the options to parse and understand, and echoes on the standard output a string suitable for `sh(1)` `eval` to replace the arguments with normalized ones.  In case of error, it outputs usage on the standard error stream, and exits with code 129."
msgstr ""

#. type: Plain text
#: en/git-rev-parse.txt:344
#, priority:80
msgid "Note: Make sure you quote the result when passing it to `eval`.  See below for an example."
msgstr ""

#. type: Title ~
#: en/git-rev-parse.txt:346
#, no-wrap, priority:80
msgid "Input Format"
msgstr ""

#. type: Plain text
#: en/git-rev-parse.txt:352
#, fuzzy, priority:80
msgid "'git rev-parse --parseopt' input format is fully text based. It has two parts, separated by a line that contains only `--`. The lines before the separator (should be one or more) are used for the usage.  The lines after the separator describe the options."
msgstr "'git rev-parse --parseopt' input format is fully text based. It has two parts, separated by a line that contains only `--`. The lines before the separator (should be one or more) are used for the usage.  The lines after the separator describe the options."

#. type: Plain text
#: en/git-rev-parse.txt:354
#, priority:80
msgid "Each line of options has this format:"
msgstr ""

#. type: delimited block -
#: en/git-rev-parse.txt:357
#, no-wrap, priority:80
msgid "<opt-spec><flags>*<arg-hint>? SP+ help LF\n"
msgstr ""

#. type: Labeled list
#: en/git-rev-parse.txt:359
#, fuzzy, no-wrap, priority:80
msgid "`<opt-spec>`"
msgstr "`<opt-spec>`"

#. type: Plain text
#: en/git-rev-parse.txt:364
#, priority:80
msgid "its format is the short option character, then the long option name separated by a comma. Both parts are not required, though at least one is necessary. May not contain any of the `<flags>` characters.  `h,help`, `dry-run` and `f` are examples of correct `<opt-spec>`."
msgstr ""

#. type: Labeled list
#: en/git-rev-parse.txt:365
#, no-wrap, priority:80
msgid "`<flags>`"
msgstr ""

#. type: Plain text
#: en/git-rev-parse.txt:367
#, priority:80
msgid "`<flags>` are of `*`, `=`, `?` or `!`."
msgstr ""

#. type: Plain text
#: en/git-rev-parse.txt:368
#, priority:80
msgid "Use `=` if the option takes an argument."
msgstr ""

#. type: Plain text
#: en/git-rev-parse.txt:372
#, priority:80
msgid "Use `?` to mean that the option takes an optional argument. You probably want to use the `--stuck-long` mode to be able to unambiguously parse the optional argument."
msgstr ""

#. type: Plain text
#: en/git-rev-parse.txt:376
#, priority:80
msgid "Use `*` to mean that this option should not be listed in the usage generated for the `-h` argument. It's shown for `--help-all` as documented in linkgit:gitcli[7]."
msgstr ""

#. type: Plain text
#: en/git-rev-parse.txt:378
#, priority:80
msgid "Use `!` to not make the corresponding negated long option available."
msgstr ""

#. type: Labeled list
#: en/git-rev-parse.txt:379
#, fuzzy, no-wrap, priority:80
msgid "`<arg-hint>`"
msgstr "`<arg-hint>`"

#. type: Plain text
#: en/git-rev-parse.txt:384
#, priority:80
msgid "`<arg-hint>`, if specified, is used as a name of the argument in the help output, for options that take arguments. `<arg-hint>` is terminated by the first whitespace.  It is customary to use a dash to separate words in a multi-word argument hint."
msgstr ""

#. type: Plain text
#: en/git-rev-parse.txt:387
#, priority:80
msgid "The remainder of the line, after stripping the spaces, is used as the help associated to the option."
msgstr ""

#. type: Plain text
#: en/git-rev-parse.txt:391
#, priority:80
msgid "Blank lines are ignored, and lines that don't match this specification are used as option group headers (start the line with a space to create such lines on purpose)."
msgstr ""

#. type: delimited block -
#: en/git-rev-parse.txt:398
#, ignore-ellipsis, no-wrap, priority:80
msgid ""
"OPTS_SPEC=\"\\\n"
"some-command [<options>] <args>...\n"
msgstr ""

#. type: delimited block -
#: en/git-rev-parse.txt:400
#, no-wrap, priority:80
msgid ""
"some-command does foo and bar!\n"
"--\n"
msgstr ""

#. type: delimited block -
#: en/git-rev-parse.txt:402
#, no-wrap, priority:80
msgid "h,help    show the help\n"
msgstr ""

#. type: delimited block -
#: en/git-rev-parse.txt:407
#, no-wrap, priority:80
msgid ""
"foo       some nifty option --foo\n"
"bar=      some cool option --bar with an argument\n"
"baz=arg   another cool option --baz with a named argument\n"
"qux?path  qux may take a path argument but has meaning by itself\n"
msgstr ""

#. type: delimited block -
#: en/git-rev-parse.txt:410
#, no-wrap, priority:80
msgid ""
"  An option group Header\n"
"C?        option C with an optional argument\"\n"
msgstr ""

#. type: delimited block -
#: en/git-rev-parse.txt:412
#, no-wrap, priority:80
msgid "eval \"$(echo \"$OPTS_SPEC\" | git rev-parse --parseopt -- \"$@\" || echo exit $?)\"\n"
msgstr ""

#. type: Title ~
#: en/git-rev-parse.txt:416
#, no-wrap, priority:80
msgid "Usage text"
msgstr ""

#. type: Plain text
#: en/git-rev-parse.txt:420
#, priority:80
msgid "When `\"$@\"` is `-h` or `--help` in the above example, the following usage text would be shown:"
msgstr ""

#. type: delimited block -
#: en/git-rev-parse.txt:423
#, ignore-ellipsis, no-wrap, priority:80
msgid "usage: some-command [<options>] <args>...\n"
msgstr ""

#. type: delimited block -
#: en/git-rev-parse.txt:425
#, no-wrap, priority:80
msgid "    some-command does foo and bar!\n"
msgstr ""

#. type: delimited block -
#: en/git-rev-parse.txt:431
#, ignore-ellipsis, no-wrap, priority:80
msgid ""
"    -h, --help            show the help\n"
"    --foo                 some nifty option --foo\n"
"    --bar ...             some cool option --bar with an argument\n"
"    --baz <arg>           another cool option --baz with a named argument\n"
"    --qux[=<path>]        qux may take a path argument but has meaning by itself\n"
msgstr ""

#. type: delimited block -
#: en/git-rev-parse.txt:434
#, ignore-ellipsis, no-wrap, priority:80
msgid ""
"An option group Header\n"
"    -C[...]               option C with an optional argument\n"
msgstr ""

#. type: Title -
#: en/git-rev-parse.txt:437
#, fuzzy, no-wrap, priority:80
msgid "SQ-QUOTE"
msgstr "SQ-QUOTE"

#. type: Plain text
#: en/git-rev-parse.txt:443
#, priority:80
msgid "In `--sq-quote` mode, 'git rev-parse' echoes on the standard output a single line suitable for `sh(1)` `eval`. This line is made by normalizing the arguments following `--sq-quote`. Nothing other than quoting the arguments is done."
msgstr ""

#. type: Plain text
#: en/git-rev-parse.txt:447
#, priority:80
msgid "If you want command input to still be interpreted as usual by 'git rev-parse' before the output is shell quoted, see the `--sq` option."
msgstr ""

#. type: delimited block -
#: en/git-rev-parse.txt:459
#, no-wrap, priority:80
msgid ""
"$ cat >your-git-script.sh <<\\EOF\n"
"#!/bin/sh\n"
"args=$(git rev-parse --sq-quote \"$@\")   # quote user-supplied arguments\n"
"command=\"git frotz -n24 $args\"          # and use it inside a handcrafted\n"
"\t\t\t\t\t# command line\n"
"eval \"$command\"\n"
"EOF\n"
msgstr ""

#. type: delimited block -
#: en/git-rev-parse.txt:461
#, fuzzy, no-wrap, priority:80
msgid "$ sh your-git-script.sh \"a b'c\"\n"
msgstr "$ sh your-git-script.sh \"a b'c\"\n"

#. type: Plain text
#: en/git-rev-parse.txt:467
#, priority:80
msgid "Print the object name of the current commit:"
msgstr ""

#. type: delimited block -
#: en/git-rev-parse.txt:470
#, fuzzy, no-wrap, priority:80
msgid "$ git rev-parse --verify HEAD\n"
msgstr "$ git rev-parse --verify HEAD\n"

#. type: Plain text
#: en/git-rev-parse.txt:473
#, priority:80
msgid "Print the commit object name from the revision in the $REV shell variable:"
msgstr ""

#. type: delimited block -
#: en/git-rev-parse.txt:476
#, fuzzy, no-wrap, priority:80
msgid "$ git rev-parse --verify --end-of-options $REV^{commit}\n"
msgstr "$ git rev-parse --verify HEAD\n"

#. type: Plain text
#: en/git-rev-parse.txt:479
#, priority:80
msgid "This will error out if $REV is empty or not a valid revision."
msgstr ""

#. type: Plain text
#: en/git-rev-parse.txt:481
#, priority:80
msgid "Similar to above:"
msgstr ""

#. type: delimited block -
#: en/git-rev-parse.txt:484
#, fuzzy, no-wrap, priority:80
msgid "$ git rev-parse --default master --verify --end-of-options $REV\n"
msgstr "$ git rev-parse --default master --verify $REV\n"

#. type: Plain text
#: en/git-rev-parse.txt:487
#, priority:80
msgid "but if $REV is empty, the commit object name from master will be printed."
msgstr ""

#. type: Title =
#: en/git-rm.txt:2
#, ignore-same, no-wrap, priority:280
msgid "git-rm(1)"
msgstr "git-rm(1)"

#. type: Plain text
#: en/git-rm.txt:7
#, fuzzy, priority:280
msgid "git-rm - Remove files from the working tree and from the index"
msgstr "git-rm - 从工作树和索引中删除文件"

#. type: Plain text
#: en/git-rm.txt:14
#, fuzzy, ignore-ellipsis, no-wrap, priority:280
msgid ""
"'git rm' [-f | --force] [-n] [-r] [--cached] [--ignore-unmatch]\n"
"\t  [--quiet] [--pathspec-from-file=<file> [--pathspec-file-nul]]\n"
"\t  [--] [<pathspec>...]\n"
msgstr ""
"'git rm' [-f | --force] [-n] [-r] [--cached] [--ignore-unmatch]\n"
"\t  [--quiet] [--pathspec-from-file=<file> [--pathspec-file-nul]]\n"
"\t  [--] [<pathspec>...]\n"

#. type: Plain text
#: en/git-rm.txt:29
#, priority:280
msgid "Remove files matching pathspec from the index, or from the working tree and the index. `git rm` will not remove a file from just your working directory. (There is no option to remove a file only from the working tree and yet keep it in the index; use `/bin/rm` if you want to do that.) The files being removed have to be identical to the tip of the branch, and no updates to their contents can be staged in the index, though that default behavior can be overridden with the `-f` option.  When `--cached` is given, the staged content has to match either the tip of the branch or the file on disk, allowing the file to be removed from just the index. When sparse-checkouts are in use (see linkgit:git-sparse-checkout[1]), `git rm` will only remove paths within the sparse-checkout patterns."
msgstr "从索引中，或从工作树和索引中删除与pathspec匹配的文件。`git rm`不会只从你的工作目录中删除一个文件。(没有选项可以只从工作树中删除一个文件，但在索引中保留它；如果你想这样做，就用`/bin/rm`)。被删除的文件必须与分支的顶端相同，而且它们的内容不能在索引中进行更新，尽管可以用`-f`选项覆盖这一默认行为。  当给定`--cached`时，缓存的内容必须与分支的顶端或磁盘上的文件相匹配，允许文件只从索引中被删除。当使用稀疏检查时（见linkgit:git-sparse-checkout[1]），`git rm`将只删除稀疏检查模式内的路径。"

#. type: Plain text
#: en/git-rm.txt:38
#, priority:280
msgid "Files to remove.  A leading directory name (e.g. `dir` to remove `dir/file1` and `dir/file2`) can be given to remove all files in the directory, and recursively all sub-directories, but this requires the `-r` option to be explicitly given."
msgstr "要删除的文件。  可以给一个领先的目录名（例如，`dir`删除`dir/file1`和`dir/file2`）来删除该目录下的所有文件，并递归所有子目录，但这需要明确给出`-r`选项。"

#. type: Plain text
#: en/git-rm.txt:40
#, priority:280
msgid "The command removes only the paths that are known to Git."
msgstr "该命令只删除Git已知的路径。"

#. type: Plain text
#: en/git-rm.txt:45
#, priority:280
msgid "File globbing matches across directory boundaries.  Thus, given two directories `d` and `d2`, there is a difference between using `git rm 'd*'` and `git rm 'd/*'`, as the former will also remove all of directory `d2`."
msgstr "文件球化可以跨越目录边界进行匹配。  因此，给定两个目录`d`和`d2`，使用`git rm 'd*'`和`git rm 'd/*'`是有区别的，因为前者会同时删除`d2`目录的所有内容。"

#. type: Plain text
#: en/git-rm.txt:51
#, priority:280
msgid "Override the up-to-date check."
msgstr "覆盖最新的检查。"

#. type: Plain text
#: en/git-rm.txt:57
#, priority:280
msgid "Don't actually remove any file(s).  Instead, just show if they exist in the index and would otherwise be removed by the command."
msgstr "实际上不要删除任何文件。  相反，只是显示它们是否存在于索引中，否则会被命令删除。"

#. type: Plain text
#: en/git-rm.txt:61
#, priority:280
msgid "Allow recursive removal when a leading directory name is given."
msgstr "当给出一个领先的目录名称时，允许递归删除。"

#. type: Plain text
#: en/git-rm.txt:71
#, priority:280
msgid "Use this option to unstage and remove paths only from the index.  Working tree files, whether modified or not, will be left alone."
msgstr "使用这个选项，只从索引中解开阶段并删除路径。  工作树文件，无论是否被修改过，都将被单独留下。"

#. type: Labeled list
#: en/git-rm.txt:72
#, ignore-same, no-wrap, priority:280
msgid "--ignore-unmatch"
msgstr "--ignore-unmatch"

#. type: Plain text
#: en/git-rm.txt:74
#, priority:280
msgid "Exit with a zero status even if no files matched."
msgstr "即使没有文件匹配，也以零状态退出。"

#. type: Plain text
#: en/git-rm.txt:80
#, fuzzy, priority:280
msgid "Allow updating index entries outside of the sparse-checkout cone.  Normally, `git rm` refuses to update index entries whose paths do not fit within the sparse-checkout cone. See linkgit:git-sparse-checkout[1] for more."
msgstr "允许更新稀疏结帐锥之外的索引条目。通常，`git rm` 拒绝更新其路径不适合稀疏结帐锥的索引条目。有关更多信息，请参见 linkgit:git-sparse-checkout[1]。"

#. type: Plain text
#: en/git-rm.txt:85
#, fuzzy, priority:280
msgid "`git rm` normally outputs one line (in the form of an `rm` command)  for each file removed. This option suppresses that output."
msgstr "`git rm` normally outputs one line (in the form of an `rm` command)  for each file removed. This option suppresses that output."

#. type: Title -
#: en/git-rm.txt:101
#, no-wrap, priority:280
msgid "REMOVING FILES THAT HAVE DISAPPEARED FROM THE FILESYSTEM"
msgstr "删除从文件系统中消失的文件"

#. type: Plain text
#: en/git-rm.txt:106
#, priority:280
msgid "There is no option for `git rm` to remove from the index only the paths that have disappeared from the filesystem. However, depending on the use case, there are several ways that can be done."
msgstr "`git rm`没有选项可以从索引中只删除已经从文件系统中消失的路径。然而，根据不同的使用情况，有几种方法可以做到这一点。"

#. type: Title ~
#: en/git-rm.txt:108
#, no-wrap, priority:280
msgid "Using ``git commit -a''"
msgstr "使用``git commit -a''"

#. type: Plain text
#: en/git-rm.txt:115
#, priority:280
msgid "If you intend that your next commit should record all modifications of tracked files in the working tree and record all removals of files that have been removed from the working tree with `rm` (as opposed to `git rm`), use `git commit -a`, as it will automatically notice and record all removals.  You can also have a similar effect without committing by using `git add -u`."
msgstr "如果你想让你的下一次提交记录工作树中所有被跟踪的文件的修改，并记录所有用`rm`从工作树中删除的文件（而不是`git rm`），请使用`git commit -a`，它将自动注意并记录所有的删除。  你也可以通过使用`git add -u`在不提交的情况下获得类似的效果。"

#. type: Title ~
#: en/git-rm.txt:117
#, no-wrap, priority:280
msgid "Using ``git add -A''"
msgstr "使用``git add -A''"

#. type: Plain text
#: en/git-rm.txt:121
#, priority:280
msgid "When accepting a new code drop for a vendor branch, you probably want to record both the removal of paths and additions of new paths as well as modifications of existing paths."
msgstr "当接受一个供应商分支的新代码投放时，你可能想同时记录删除路径和增加新路径以及修改现有路径的内容。"

#. type: Plain text
#: en/git-rm.txt:124
#, priority:280
msgid "Typically you would first remove all tracked files from the working tree using this command:"
msgstr "通常情况下，你会先用这个命令从工作树上删除所有被追踪的文件。"

#. type: delimited block -
#: en/git-rm.txt:127
#, fuzzy, no-wrap, priority:280
msgid "git ls-files -z | xargs -0 rm -f\n"
msgstr "git ls-files -z | xargs -0 rm -f\n"

#. type: Plain text
#: en/git-rm.txt:131
#, priority:280
msgid "and then untar the new code in the working tree. Alternately you could 'rsync' the changes into the working tree."
msgstr "然后解开工作树上的新代码。另外，你也可以通过 \"rsync \"把修改的内容放到工作树上。"

#. type: Plain text
#: en/git-rm.txt:134
#, priority:280
msgid "After that, the easiest way to record all removals, additions, and modifications in the working tree is:"
msgstr "之后，记录工作树中所有的删除、添加和修改的最简单方法是。"

#. type: delimited block -
#: en/git-rm.txt:137
#, fuzzy, no-wrap, priority:280
msgid "git add -A\n"
msgstr "git add -A\n"

#. type: Plain text
#: en/git-rm.txt:140
#, fuzzy, priority:280
msgid "See linkgit:git-add[1]."
msgstr "linkgit:git-add[1]"

#. type: Title ~
#: en/git-rm.txt:142
#, fuzzy, no-wrap, priority:280
msgid "Other ways"
msgstr "其他方式"

#. type: Plain text
#: en/git-rm.txt:147
#, priority:280
msgid "If all you really want to do is to remove from the index the files that are no longer present in the working tree (perhaps because your working tree is dirty so that you cannot use `git commit -a`), use the following command:"
msgstr "如果你真正想做的只是从索引中删除那些不再出现在工作树中的文件（也许是因为你的工作树很脏，所以你不能使用`git commit -a`），使用以下命令。"

#. type: delimited block -
#: en/git-rm.txt:150
#, fuzzy, no-wrap, priority:280
msgid "git diff --name-only --diff-filter=D -z | xargs -0 git rm --cached\n"
msgstr "git diff --name-only --diff-filter=D -z | xargs -0 git rm --cached\n"

#. type: Plain text
#: en/git-rm.txt:163
#, priority:280
msgid "Only submodules using a gitfile (which means they were cloned with a Git version 1.7.8 or newer) will be removed from the work tree, as their repository lives inside the .git directory of the superproject. If a submodule (or one of those nested inside it)  still uses a .git directory, `git rm` will move the submodules git directory into the superprojects git directory to protect the submodule's history. If it exists the submodule.<name> section in the linkgit:gitmodules[5] file will also be removed and that file will be staged (unless --cached or -n are used)."
msgstr "只有使用 gitfile 的子模块（这意味着它们是用 1.7.8 或更新的 Git 版本克隆的）才会从工作树中移除，因为它们的仓库住在超级项目的 .git 目录中。如果一个子模块（或嵌套在它里面的一个）仍然使用.git目录，`git rm`将把子模块的git目录移到超级项目的git目录中，以保护子模块的历史。如果它存在，linkgit:gitmodules[5]文件中的submodule.<name>部分也将被移除，该文件将被暂存（除非使用了-cached或-n）。"

#. type: Plain text
#: en/git-rm.txt:169
#, priority:280
msgid "A submodule is considered up to date when the HEAD is the same as recorded in the index, no tracked files are modified and no untracked files that aren't ignored are present in the submodules work tree.  Ignored files are deemed expendable and won't stop a submodule's work tree from being removed."
msgstr "当HEAD与索引中记录的相同时，一个子模块被认为是最新的，没有跟踪的文件被修改，在子模块的工作树中没有没有被忽略的未跟踪的文件。  忽略的文件被认为是可消耗的，不会阻止一个子模块的工作树被删除。"

#. type: Plain text
#: en/git-rm.txt:173
#, priority:280
msgid "If you only want to remove the local checkout of a submodule from your work tree without committing the removal, use linkgit:git-submodule[1] `deinit` instead. Also see linkgit:gitsubmodules[7] for details on submodule removal."
msgstr "如果你只想从你的工作树中移除一个子模块的本地签出而不提交移除，使用linkgit:git-submodule[1] `deinit`代替。也请看 linkgit:gitsubmodules[7] 了解关于子模块移除的细节。"

#. type: Labeled list
#: en/git-rm.txt:176
#, fuzzy, no-wrap, priority:280
msgid "`git rm Documentation/\\*.txt`"
msgstr "`git rm Documentation/\\*.txt`"

#. type: Plain text
#: en/git-rm.txt:179
#, priority:280
msgid "Removes all `*.txt` files from the index that are under the `Documentation` directory and any of its subdirectories."
msgstr "从索引中删除所有`*.txt`文件，这些文件在`Documentation`目录和它的任何子目录下。"

#. type: Plain text
#: en/git-rm.txt:183
#, priority:280
msgid "Note that the asterisk `*` is quoted from the shell in this example; this lets Git, and not the shell, expand the pathnames of files and subdirectories under the `Documentation/` directory."
msgstr "注意，在这个例子中，星号`*`被引自shell；这让Git，而不是shell，扩展`Documentation/`目录下的文件和子目录的路径名。"

#. type: Labeled list
#: en/git-rm.txt:184
#, fuzzy, no-wrap, priority:280
msgid "`git rm -f git-*.sh`"
msgstr "`git rm -f git-*.sh`"

#. type: Plain text
#: en/git-rm.txt:188
#, priority:280
msgid "Because this example lets the shell expand the asterisk (i.e. you are listing the files explicitly), it does not remove `subdir/git-foo.sh`."
msgstr "因为这个例子让shell展开星号（即你明确列出了文件），它没有删除`subdir/git-foo.sh`。"

#. type: Plain text
#: en/git-rm.txt:197
#, priority:280
msgid "Each time a superproject update removes a populated submodule (e.g. when switching between commits before and after the removal) a stale submodule checkout will remain in the old location. Removing the old directory is only safe when it uses a gitfile, as otherwise the history of the submodule will be deleted too. This step will be obsolete when recursive submodule update has been implemented."
msgstr "每次超级项目更新删除一个已填充的子模块（例如，在删除前后的提交之间切换时），一个陈旧的子模块检出将保留在旧的位置。只有在使用gitfile时，删除旧目录才是安全的，否则子模块的历史也会被删除。当递归子模块更新被实施后，这个步骤将被淘汰。"

#. type: Title =
#: en/git-send-email.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-send-email(1)"
msgstr "git-send-email(1)"

#. type: Plain text
#: en/git-send-email.txt:7
#, fuzzy, priority:100
msgid "git-send-email - Send a collection of patches as emails"
msgstr "git-send-email - Send a collection of patches as emails"

#. type: Plain text
#: en/git-send-email.txt:15
#, ignore-ellipsis, no-wrap, priority:100
msgid ""
"'git send-email' [<options>] <file|directory>...\n"
"'git send-email' [<options>] <format-patch options>\n"
"'git send-email' --dump-aliases\n"
msgstr ""

#. type: Plain text
#: en/git-send-email.txt:25
#, priority:100
msgid "Takes the patches given on the command line and emails them out.  Patches can be specified as files, directories (which will send all files in the directory), or directly as a revision list.  In the last case, any format accepted by linkgit:git-format-patch[1] can be passed to git send-email, as well as options understood by linkgit:git-format-patch[1]."
msgstr ""

#. type: Plain text
#: en/git-send-email.txt:29
#, priority:100
msgid "The header of the email is configurable via command-line options.  If not specified on the command line, the user will be prompted with a ReadLine enabled interface to provide the necessary information."
msgstr ""

#. type: Plain text
#: en/git-send-email.txt:31
#, priority:100
msgid "There are two formats accepted for patch files:"
msgstr ""

#. type: Plain text
#: en/git-send-email.txt:33
#, priority:100
msgid "mbox format files"
msgstr ""

#. type: Plain text
#: en/git-send-email.txt:36
#, priority:100
msgid "This is what linkgit:git-format-patch[1] generates.  Most headers and MIME formatting are ignored."
msgstr ""

#. type: Plain text
#: en/git-send-email.txt:39
#, priority:100
msgid "The original format used by Greg Kroah-Hartman's 'send_lots_of_email.pl' script"
msgstr ""

#. type: Plain text
#: en/git-send-email.txt:42
#, priority:100
msgid "This format expects the first line of the file to contain the \"Cc:\" value and the \"Subject:\" of the message as the second line."
msgstr ""

#. type: Title ~
#: en/git-send-email.txt:48
#, fuzzy, no-wrap, priority:100
msgid "Composing"
msgstr "撰写"

#. type: Labeled list
#: en/git-send-email.txt:50 en/git-tag.txt:61
#, ignore-same, no-wrap, priority:240
msgid "--annotate"
msgstr "--annotate"

#. type: Plain text
#: en/git-send-email.txt:54
#, priority:100
msgid "Review and edit each patch you're about to send. Default is the value of `sendemail.annotate`. See the CONFIGURATION section for `sendemail.multiEdit`."
msgstr ""

#. type: Labeled list
#: en/git-send-email.txt:55
#, fuzzy, ignore-ellipsis, no-wrap, priority:100
msgid "--bcc=<address>,..."
msgstr "--bcc=<address>,..."

#. type: Plain text
#: en/git-send-email.txt:58
#, priority:100
msgid "Specify a \"Bcc:\" value for each email. Default is the value of `sendemail.bcc`."
msgstr ""

#. type: Plain text
#: en/git-send-email.txt:60 en/git-send-email.txt:66 en/git-send-email.txt:128
#, priority:100
msgid "This option may be specified multiple times."
msgstr ""

#. type: Labeled list
#: en/git-send-email.txt:61
#, fuzzy, ignore-ellipsis, no-wrap, priority:100
msgid "--cc=<address>,..."
msgstr "--cc=<address>,..."

#. type: Plain text
#: en/git-send-email.txt:64
#, priority:100
msgid "Specify a starting \"Cc:\" value for each email.  Default is the value of `sendemail.cc`."
msgstr ""

#. type: Labeled list
#: en/git-send-email.txt:67
#, ignore-same, no-wrap, priority:100
msgid "--compose"
msgstr "--compose"

#. type: Plain text
#: en/git-send-email.txt:70
#, priority:100
msgid "Invoke a text editor (see GIT_EDITOR in linkgit:git-var[1])  to edit an introductory message for the patch series."
msgstr ""

#. type: Plain text
#: en/git-send-email.txt:76
#, priority:100
msgid "When `--compose` is used, git send-email will use the From, Subject, and In-Reply-To headers specified in the message. If the body of the message (what you type after the headers and a blank line) only contains blank (or Git: prefixed) lines, the summary won't be sent, but From, Subject, and In-Reply-To headers will be used unless they are removed."
msgstr ""

#. type: Plain text
#: en/git-send-email.txt:78
#, priority:100
msgid "Missing From or In-Reply-To headers will be prompted for."
msgstr ""

#. type: Plain text
#: en/git-send-email.txt:80
#, priority:100
msgid "See the CONFIGURATION section for `sendemail.multiEdit`."
msgstr ""

#. type: Labeled list
#: en/git-send-email.txt:81
#, fuzzy, no-wrap, priority:100
msgid "--from=<address>"
msgstr "--from=<address>"

#. type: Plain text
#: en/git-send-email.txt:88
#, priority:100
msgid "Specify the sender of the emails.  If not specified on the command line, the value of the `sendemail.from` configuration option is used.  If neither the command-line option nor `sendemail.from` are set, then the user will be prompted for the value.  The default for the prompt will be the value of GIT_AUTHOR_IDENT, or GIT_COMMITTER_IDENT if that is not set, as returned by \"git var -l\"."
msgstr ""

#. type: Labeled list
#: en/git-send-email.txt:89
#, fuzzy, no-wrap, priority:100
msgid "--reply-to=<address>"
msgstr "--reply-to=<address>"

#. type: Plain text
#: en/git-send-email.txt:93
#, priority:100
msgid "Specify the address where replies from recipients should go to.  Use this if replies to messages should go to another address than what is specified with the --from parameter."
msgstr ""

#. type: Labeled list
#: en/git-send-email.txt:94
#, fuzzy, no-wrap, priority:100
msgid "--in-reply-to=<identifier>"
msgstr "--in-reply-to=<identifier>"

#. type: Plain text
#: en/git-send-email.txt:100
#, priority:100
msgid "Make the first mail (or all the mails with `--no-thread`) appear as a reply to the given Message-ID, which avoids breaking threads to provide a new patch series.  The second and subsequent emails will be sent as replies according to the `--[no-]chain-reply-to` setting."
msgstr ""

#. type: Plain text
#: en/git-send-email.txt:104
#, priority:100
msgid "So for example when `--thread` and `--no-chain-reply-to` are specified, the second and subsequent patches will be replies to the first one like in the illustration below where `[PATCH v2 0/3]` is in reply to `[PATCH 0/2]`:"
msgstr ""

#. type: Plain text
#: en/git-send-email.txt:112
#, fuzzy, ignore-ellipsis, no-wrap, priority:100
msgid ""
"  [PATCH 0/2] Here is what I did...\n"
"    [PATCH 1/2] Clean up and tests\n"
"    [PATCH 2/2] Implementation\n"
"    [PATCH v2 0/3] Here is a reroll\n"
"      [PATCH v2 1/3] Clean up\n"
"      [PATCH v2 2/3] New tests\n"
"      [PATCH v2 3/3] Implementation\n"
msgstr ""
"  [PATCH 0/2] Here is what I did...\n"
"    [PATCH 1/2] Clean up and tests\n"
"    [PATCH 2/2] Implementation\n"
"    [PATCH v2 0/3] Here is a reroll\n"
"      [PATCH v2 1/3] Clean up\n"
"      [PATCH v2 2/3] New tests\n"
"      [PATCH v2 3/3] Implementation\n"

#. type: Plain text
#: en/git-send-email.txt:115
#, priority:100
msgid "Only necessary if --compose is also set.  If --compose is not set, this will be prompted for."
msgstr ""

#. type: Labeled list
#: en/git-send-email.txt:116
#, fuzzy, no-wrap, priority:100
msgid "--subject=<string>"
msgstr "--subject=<string>"

#. type: Plain text
#: en/git-send-email.txt:120
#, priority:100
msgid "Specify the initial subject of the email thread.  Only necessary if --compose is also set.  If --compose is not set, this will be prompted for."
msgstr ""

#. type: Labeled list
#: en/git-send-email.txt:121
#, fuzzy, ignore-ellipsis, no-wrap, priority:100
msgid "--to=<address>,..."
msgstr "--to=<address>,..."

#. type: Plain text
#: en/git-send-email.txt:126
#, priority:100
msgid "Specify the primary recipient of the emails generated. Generally, this will be the upstream maintainer of the project involved. Default is the value of the `sendemail.to` configuration value; if that is unspecified, and --to-cmd is not specified, this will be prompted for."
msgstr ""

#. type: Labeled list
#: en/git-send-email.txt:129
#, fuzzy, no-wrap, priority:100
msgid "--8bit-encoding=<encoding>"
msgstr "--8bit-encoding=<encoding>"

#. type: Plain text
#: en/git-send-email.txt:135
#, priority:100
msgid "When encountering a non-ASCII message or subject that does not declare its encoding, add headers/quoting to indicate it is encoded in <encoding>.  Default is the value of the 'sendemail.assume8bitEncoding'; if that is unspecified, this will be prompted for if any non-ASCII files are encountered."
msgstr ""

#. type: Plain text
#: en/git-send-email.txt:137
#, priority:100
msgid "Note that no attempts whatsoever are made to validate the encoding."
msgstr ""

#. type: Labeled list
#: en/git-send-email.txt:138
#, fuzzy, no-wrap, priority:100
msgid "--compose-encoding=<encoding>"
msgstr "--compose-encoding=<encoding>"

#. type: Plain text
#: en/git-send-email.txt:141
#, priority:100
msgid "Specify encoding of compose message. Default is the value of the 'sendemail.composeencoding'; if that is unspecified, UTF-8 is assumed."
msgstr ""

#. type: Labeled list
#: en/git-send-email.txt:142
#, fuzzy, no-wrap, priority:100
msgid "--transfer-encoding=(7bit|8bit|quoted-printable|base64|auto)"
msgstr "--transfer-encoding=(7bit|8bit|quoted-printable|base64|auto)"

#. type: Plain text
#: en/git-send-email.txt:150
#, priority:100
msgid "Specify the transfer encoding to be used to send the message over SMTP.  7bit will fail upon encountering a non-ASCII message.  quoted-printable can be useful when the repository contains files that contain carriage returns, but makes the raw patch email file (as saved from a MUA) much harder to inspect manually.  base64 is even more fool proof, but also even more opaque.  auto will use 8bit when possible, and quoted-printable otherwise."
msgstr ""

#. type: Plain text
#: en/git-send-email.txt:153
#, priority:100
msgid "Default is the value of the `sendemail.transferEncoding` configuration value; if that is unspecified, default to `auto`."
msgstr ""

#. type: Labeled list
#: en/git-send-email.txt:154
#, ignore-same, no-wrap, priority:100
msgid "--xmailer"
msgstr "--xmailer"

#. type: Labeled list
#: en/git-send-email.txt:155
#, ignore-same, no-wrap, priority:100
msgid "--no-xmailer"
msgstr "--no-xmailer"

#. type: Plain text
#: en/git-send-email.txt:159
#, priority:100
msgid "Add (or prevent adding) the \"X-Mailer:\" header.  By default, the header is added, but it can be turned off by setting the `sendemail.xmailer` configuration variable to `false`."
msgstr ""

#. type: Title ~
#: en/git-send-email.txt:161
#, fuzzy, no-wrap, priority:100
msgid "Sending"
msgstr "发送中"

#. type: Labeled list
#: en/git-send-email.txt:163
#, fuzzy, no-wrap, priority:100
msgid "--envelope-sender=<address>"
msgstr "--envelope-sender=<address>"

#. type: Plain text
#: en/git-send-email.txt:171
#, priority:100
msgid "Specify the envelope sender used to send the emails.  This is useful if your default address is not the address that is subscribed to a list. In order to use the 'From' address, set the value to \"auto\". If you use the sendmail binary, you must have suitable privileges for the -f parameter.  Default is the value of the `sendemail.envelopeSender` configuration variable; if that is unspecified, choosing the envelope sender is left to your MTA."
msgstr ""

#. type: Labeled list
#: en/git-send-email.txt:172
#, fuzzy, no-wrap, priority:100
msgid "--sendmail-cmd=<command>"
msgstr "--to-cmd=<command>"

#. type: Plain text
#: en/git-send-email.txt:179
#, priority:100
msgid "Specify a command to run to send the email. The command should be sendmail-like; specifically, it must support the `-i` option.  The command will be executed in the shell if necessary.  Default is the value of `sendemail.sendmailcmd`.  If unspecified, and if --smtp-server is also unspecified, git-send-email will search for `sendmail` in `/usr/sbin`, `/usr/lib` and $PATH."
msgstr ""

#. type: Labeled list
#: en/git-send-email.txt:180
#, fuzzy, no-wrap, priority:100
msgid "--smtp-encryption=<encryption>"
msgstr "--smtp-encryption=<encryption>"

#. type: Plain text
#: en/git-send-email.txt:193
#, priority:100
msgid "Specify in what way encrypting begins for the SMTP connection.  Valid values are 'ssl' and 'tls'. Any other value reverts to plain (unencrypted) SMTP, which defaults to port 25.  Despite the names, both values will use the same newer version of TLS, but for historic reasons have these names. 'ssl' refers to \"implicit\" encryption (sometimes called SMTPS), that uses port 465 by default.  'tls' refers to \"explicit\" encryption (often known as STARTTLS), that uses port 25 by default. Other ports might be used by the SMTP server, which are not the default. Commonly found alternative port for 'tls' and unencrypted is 587. You need to check your provider's documentation or your server configuration to make sure for your own case. Default is the value of `sendemail.smtpEncryption`."
msgstr ""

#. type: Labeled list
#: en/git-send-email.txt:194
#, fuzzy, no-wrap, priority:100
msgid "--smtp-domain=<FQDN>"
msgstr "--smtp-domain=<FQDN>"

#. type: Plain text
#: en/git-send-email.txt:200
#, priority:100
msgid "Specifies the Fully Qualified Domain Name (FQDN) used in the HELO/EHLO command to the SMTP server.  Some servers require the FQDN to match your IP address.  If not set, git send-email attempts to determine your FQDN automatically.  Default is the value of `sendemail.smtpDomain`."
msgstr ""

#. type: Labeled list
#: en/git-send-email.txt:201
#, no-wrap, priority:100
msgid "--smtp-auth=<mechanisms>"
msgstr ""

#. type: Plain text
#: en/git-send-email.txt:204
#, priority:100
msgid "Whitespace-separated list of allowed SMTP-AUTH mechanisms. This setting forces using only the listed mechanisms. Example:"
msgstr ""

#. type: delimited block -
#: en/git-send-email.txt:207
#, fuzzy, ignore-ellipsis, no-wrap, priority:100
msgid "$ git send-email --smtp-auth=\"PLAIN LOGIN GSSAPI\" ...\n"
msgstr "$ git send-email --smtp-auth=\"PLAIN LOGIN GSSAPI\" ...\n"

#. type: Plain text
#: en/git-send-email.txt:215
#, priority:100
msgid "If at least one of the specified mechanisms matches the ones advertised by the SMTP server and if it is supported by the utilized SASL library, the mechanism is used for authentication. If neither 'sendemail.smtpAuth' nor `--smtp-auth` is specified, all mechanisms supported by the SASL library can be used. The special value 'none' maybe specified to completely disable authentication independently of `--smtp-user`"
msgstr ""

#. type: Labeled list
#: en/git-send-email.txt:216
#, fuzzy, no-wrap, priority:100
msgid "--smtp-pass[=<password>]"
msgstr "--smtp-pass[=<password>]"

#. type: Plain text
#: en/git-send-email.txt:221
#, priority:100
msgid "Password for SMTP-AUTH. The argument is optional: If no argument is specified, then the empty string is used as the password. Default is the value of `sendemail.smtpPass`, however `--smtp-pass` always overrides this value."
msgstr ""

#. type: Plain text
#: en/git-send-email.txt:227
#, priority:100
msgid "Furthermore, passwords need not be specified in configuration files or on the command line. If a username has been specified (with `--smtp-user` or a `sendemail.smtpUser`), but no password has been specified (with `--smtp-pass` or `sendemail.smtpPass`), then a password is obtained using 'git-credential'."
msgstr ""

#. type: Labeled list
#: en/git-send-email.txt:228
#, ignore-same, no-wrap, priority:100
msgid "--no-smtp-auth"
msgstr "--no-smtp-auth"

#. type: Plain text
#: en/git-send-email.txt:230
#, priority:100
msgid "Disable SMTP authentication. Short hand for `--smtp-auth=none`"
msgstr ""

#. type: Labeled list
#: en/git-send-email.txt:231
#, no-wrap, priority:100
msgid "--smtp-server=<host>"
msgstr ""

#. type: Plain text
#: en/git-send-email.txt:237
#, priority:100
msgid "If set, specifies the outgoing SMTP server to use (e.g.  `smtp.example.com` or a raw IP address).  If unspecified, and if `--sendmail-cmd` is also unspecified, the default is to search for `sendmail` in `/usr/sbin`, `/usr/lib` and $PATH if such a program is available, falling back to `localhost` otherwise."
msgstr ""

#. type: Plain text
#: en/git-send-email.txt:243
#, priority:100
msgid "For backward compatibility, this option can also specify a full pathname of a sendmail-like program instead; the program must support the `-i` option.  This method does not support passing arguments or using plain command names.  For those use cases, consider using `--sendmail-cmd` instead."
msgstr ""

#. type: Labeled list
#: en/git-send-email.txt:244
#, fuzzy, no-wrap, priority:100
msgid "--smtp-server-port=<port>"
msgstr "--smtp-server-port=<port>"

#. type: Plain text
#: en/git-send-email.txt:251
#, priority:100
msgid "Specifies a port different from the default port (SMTP servers typically listen to smtp port 25, but may also listen to submission port 587, or the common SSL smtp port 465); symbolic port names (e.g. \"submission\" instead of 587)  are also accepted. The port can also be set with the `sendemail.smtpServerPort` configuration variable."
msgstr ""

#. type: Labeled list
#: en/git-send-email.txt:252
#, no-wrap, priority:100
msgid "--smtp-server-option=<option>"
msgstr ""

#. type: Plain text
#: en/git-send-email.txt:256
#, priority:100
msgid "If set, specifies the outgoing SMTP server option to use.  Default value can be specified by the `sendemail.smtpServerOption` configuration option."
msgstr ""

#. type: Plain text
#: en/git-send-email.txt:260
#, priority:100
msgid "The --smtp-server-option option must be repeated for each option you want to pass to the server. Likewise, different lines in the configuration files must be used for each option."
msgstr ""

#. type: Labeled list
#: en/git-send-email.txt:261
#, ignore-same, no-wrap, priority:100
msgid "--smtp-ssl"
msgstr "--smtp-ssl"

#. type: Plain text
#: en/git-send-email.txt:263
#, priority:100
msgid "Legacy alias for '--smtp-encryption ssl'."
msgstr ""

#. type: Labeled list
#: en/git-send-email.txt:264
#, ignore-same, no-wrap, priority:100
msgid "--smtp-ssl-cert-path"
msgstr "--smtp-ssl-cert-path"

#. type: Plain text
#: en/git-send-email.txt:274
#, priority:100
msgid "Path to a store of trusted CA certificates for SMTP SSL/TLS certificate validation (either a directory that has been processed by 'c_rehash', or a single file containing one or more PEM format certificates concatenated together: see verify(1) -CAfile and -CApath for more information on these). Set it to an empty string to disable certificate verification. Defaults to the value of the `sendemail.smtpsslcertpath` configuration variable, if set, or the backing SSL library's compiled-in default otherwise (which should be the best choice on most platforms)."
msgstr ""

#. type: Labeled list
#: en/git-send-email.txt:275
#, fuzzy, no-wrap, priority:100
msgid "--smtp-user=<user>"
msgstr "--smtp-user=<user>"

#. type: Plain text
#: en/git-send-email.txt:279
#, priority:100
msgid "Username for SMTP-AUTH. Default is the value of `sendemail.smtpUser`; if a username is not specified (with `--smtp-user` or `sendemail.smtpUser`), then authentication is not attempted."
msgstr ""

#. type: Labeled list
#: en/git-send-email.txt:280
#, fuzzy, no-wrap, priority:100
msgid "--smtp-debug=0|1"
msgstr "--smtp-debug=0|1"

#. type: Plain text
#: en/git-send-email.txt:284
#, priority:100
msgid "Enable (1) or disable (0) debug output. If enabled, SMTP commands and replies will be printed. Useful to debug TLS connection and authentication problems."
msgstr ""

#. type: Labeled list
#: en/git-send-email.txt:285
#, no-wrap, priority:100
msgid "--batch-size=<num>"
msgstr ""

#. type: Plain text
#: en/git-send-email.txt:294
#, priority:100
msgid "Some email servers (e.g. smtp.163.com) limit the number emails to be sent per session (connection) and this will lead to a failure when sending many messages.  With this option, send-email will disconnect after sending $<num> messages and wait for a few seconds (see --relogin-delay)  and reconnect, to work around such a limit.  You may want to use some form of credential helper to avoid having to retype your password every time this happens.  Defaults to the `sendemail.smtpBatchSize` configuration variable."
msgstr ""

#. type: Labeled list
#: en/git-send-email.txt:295
#, fuzzy, no-wrap, priority:100
msgid "--relogin-delay=<int>"
msgstr "--relogin-delay=<int>"

#. type: Plain text
#: en/git-send-email.txt:299
#, priority:100
msgid "Waiting $<int> seconds before reconnecting to SMTP server. Used together with --batch-size option.  Defaults to the `sendemail.smtpReloginDelay` configuration variable."
msgstr ""

#. type: Title ~
#: en/git-send-email.txt:301
#, no-wrap, priority:100
msgid "Automating"
msgstr ""

#. type: Labeled list
#: en/git-send-email.txt:303
#, no-wrap, priority:100
msgid "--no-[to|cc|bcc]"
msgstr ""

#. type: Plain text
#: en/git-send-email.txt:306
#, priority:100
msgid "Clears any list of \"To:\", \"Cc:\", \"Bcc:\" addresses previously set via config."
msgstr ""

#. type: Labeled list
#: en/git-send-email.txt:307
#, ignore-same, no-wrap, priority:100
msgid "--no-identity"
msgstr "--no-identity"

#. type: Plain text
#: en/git-send-email.txt:310
#, priority:100
msgid "Clears the previously read value of `sendemail.identity` set via config, if any."
msgstr ""

#. type: Labeled list
#: en/git-send-email.txt:311
#, fuzzy, no-wrap, priority:100
msgid "--to-cmd=<command>"
msgstr "--to-cmd=<command>"

#. type: Plain text
#: en/git-send-email.txt:316
#, priority:100
msgid "Specify a command to execute once per patch file which should generate patch file specific \"To:\" entries.  Output of this command must be single email address per line.  Default is the value of 'sendemail.tocmd' configuration value."
msgstr ""

#. type: Labeled list
#: en/git-send-email.txt:317
#, fuzzy, no-wrap, priority:100
msgid "--cc-cmd=<command>"
msgstr "--cc-cmd=<command>"

#. type: Plain text
#: en/git-send-email.txt:322
#, priority:100
msgid "Specify a command to execute once per patch file which should generate patch file specific \"Cc:\" entries.  Output of this command must be single email address per line.  Default is the value of `sendemail.ccCmd` configuration value."
msgstr ""

#. type: Labeled list
#: en/git-send-email.txt:323
#, fuzzy, no-wrap, priority:100
msgid "--header-cmd=<command>"
msgstr "--to-cmd=<command>"

#. type: Plain text
#: en/git-send-email.txt:330
#, priority:100
msgid "Specify a command that is executed once per outgoing message and output RFC 2822 style header lines to be inserted into them. When the `sendemail.headerCmd` configuration variable is set, its value is always used. When --header-cmd is provided at the command line, its value takes precedence over the `sendemail.headerCmd` configuration variable."
msgstr ""

#. type: Labeled list
#: en/git-send-email.txt:331
#, ignore-same, no-wrap, priority:100
msgid "--no-header-cmd"
msgstr "--no-header-cmd"

#. type: Plain text
#: en/git-send-email.txt:333
#, priority:100
msgid "Disable any header command in use."
msgstr ""

#. type: Labeled list
#: en/git-send-email.txt:334
#, ignore-same, no-wrap, priority:100
msgid "--[no-]chain-reply-to"
msgstr "--[no-]chain-reply-to"

#. type: Plain text
#: en/git-send-email.txt:341
#, priority:100
msgid "If this is set, each email will be sent as a reply to the previous email sent.  If disabled with \"--no-chain-reply-to\", all emails after the first will be sent as replies to the first email sent.  When using this, it is recommended that the first file given be an overview of the entire patch series. Disabled by default, but the `sendemail.chainReplyTo` configuration variable can be used to enable it."
msgstr ""

#. type: Labeled list
#: en/git-send-email.txt:342
#, fuzzy, no-wrap, priority:100
msgid "--identity=<identity>"
msgstr "--identity=<identity>"

#. type: Plain text
#: en/git-send-email.txt:347
#, priority:100
msgid "A configuration identity. When given, causes values in the 'sendemail.<identity>' subsection to take precedence over values in the 'sendemail' section. The default identity is the value of `sendemail.identity`."
msgstr ""

#. type: Labeled list
#: en/git-send-email.txt:348
#, ignore-same, no-wrap, priority:100
msgid "--[no-]signed-off-by-cc"
msgstr "--[no-]signed-off-by-cc"

#. type: Plain text
#: en/git-send-email.txt:352
#, priority:100
msgid "If this is set, add emails found in the `Signed-off-by` trailer or Cc: lines to the cc list. Default is the value of `sendemail.signedoffbycc` configuration value; if that is unspecified, default to --signed-off-by-cc."
msgstr "如果设置了此选项，请将“ Signed-off-by”预告或抄送：行中的电子邮件添加到抄送列表中。默认为`sendmail.signedoffbycc`配置值的值；如果未指定，则默认为--signed-off-by-cc。"

#. type: Labeled list
#: en/git-send-email.txt:353
#, ignore-same, no-wrap, priority:100
msgid "--[no-]cc-cover"
msgstr "--[no-]cc-cover"

#. type: Plain text
#: en/git-send-email.txt:358
#, priority:100
msgid "If this is set, emails found in Cc: headers in the first patch of the series (typically the cover letter) are added to the cc list for each email set. Default is the value of 'sendemail.cccover' configuration value; if that is unspecified, default to --no-cc-cover."
msgstr ""

#. type: Labeled list
#: en/git-send-email.txt:359
#, ignore-same, no-wrap, priority:100
msgid "--[no-]to-cover"
msgstr "--[no-]to-cover"

#. type: Plain text
#: en/git-send-email.txt:364
#, priority:100
msgid "If this is set, emails found in To: headers in the first patch of the series (typically the cover letter) are added to the to list for each email set. Default is the value of 'sendemail.tocover' configuration value; if that is unspecified, default to --no-to-cover."
msgstr ""

#. type: Labeled list
#: en/git-send-email.txt:365
#, fuzzy, no-wrap, priority:100
msgid "--suppress-cc=<category>"
msgstr "--suppress-cc=<category>"

#. type: Plain text
#: en/git-send-email.txt:368
#, priority:100
msgid "Specify an additional category of recipients to suppress the auto-cc of:"
msgstr ""

#. type: Plain text
#: en/git-send-email.txt:371
#, priority:100
msgid "'author' will avoid including the patch author."
msgstr ""

#. type: Plain text
#: en/git-send-email.txt:372
#, priority:100
msgid "'self' will avoid including the sender."
msgstr ""

#. type: Plain text
#: en/git-send-email.txt:374
#, priority:100
msgid "'cc' will avoid including anyone mentioned in Cc lines in the patch header except for self (use 'self' for that)."
msgstr ""

#. type: Plain text
#: en/git-send-email.txt:376
#, priority:100
msgid "'bodycc' will avoid including anyone mentioned in Cc lines in the patch body (commit message) except for self (use 'self' for that)."
msgstr ""

#. type: Plain text
#: en/git-send-email.txt:378
#, fuzzy, priority:100
msgid "'sob' will avoid including anyone mentioned in the Signed-off-by trailers except for self (use 'self' for that)."
msgstr "'sob' 将避免包括签名行中提到的任何人， 除了自我 （为此使用 \"自我\" ）。"

#. type: Plain text
#: en/git-send-email.txt:381
#, priority:100
msgid "'misc-by' will avoid including anyone mentioned in Acked-by, Reviewed-by, Tested-by and other \"-by\" lines in the patch body, except Signed-off-by (use 'sob' for that)."
msgstr ""

#. type: Plain text
#: en/git-send-email.txt:382
#, priority:100
msgid "'cccmd' will avoid running the --cc-cmd."
msgstr ""

#. type: Plain text
#: en/git-send-email.txt:383
#, priority:100
msgid "'body' is equivalent to 'sob' + 'bodycc' + 'misc-by'."
msgstr ""

#. type: Plain text
#: en/git-send-email.txt:384
#, priority:100
msgid "'all' will suppress all auto cc values."
msgstr ""

#. type: Plain text
#: en/git-send-email.txt:389
#, priority:100
msgid "Default is the value of `sendemail.suppresscc` configuration value; if that is unspecified, default to 'self' if --suppress-from is specified, as well as 'body' if --no-signed-off-cc is specified."
msgstr ""

#. type: Labeled list
#: en/git-send-email.txt:390
#, ignore-same, no-wrap, priority:100
msgid "--[no-]suppress-from"
msgstr "--[no-]suppress-from"

#. type: Plain text
#: en/git-send-email.txt:394
#, priority:100
msgid "If this is set, do not add the From: address to the cc: list.  Default is the value of `sendemail.suppressFrom` configuration value; if that is unspecified, default to --no-suppress-from."
msgstr ""

#. type: Labeled list
#: en/git-send-email.txt:395
#, ignore-same, no-wrap, priority:100
msgid "--[no-]thread"
msgstr "--[no-]thread"

#. type: Plain text
#: en/git-send-email.txt:401
#, priority:100
msgid "If this is set, the In-Reply-To and References headers will be added to each email sent.  Whether each mail refers to the previous email (`deep` threading per 'git format-patch' wording) or to the first email (`shallow` threading) is governed by \"--[no-]chain-reply-to\"."
msgstr ""

#. type: Plain text
#: en/git-send-email.txt:406
#, fuzzy, priority:100
msgid "If disabled with \"--no-thread\", those headers will not be added (unless specified with --in-reply-to).  Default is the value of the `sendemail.thread` configuration value; if that is unspecified, default to --thread."
msgstr "If disabled with \"--no-thread\", those headers will not be added (unless specified with --in-reply-to).  Default is the value of the `sendemail.thread` configuration value; if that is unspecified, default to --thread."

#. type: Plain text
#: en/git-send-email.txt:412
#, priority:100
msgid "It is up to the user to ensure that no In-Reply-To header already exists when 'git send-email' is asked to add it (especially note that 'git format-patch' can be configured to do the threading itself).  Failure to do so may not produce the expected result in the recipient's MUA."
msgstr ""

#. type: Title ~
#: en/git-send-email.txt:415
#, no-wrap, priority:100
msgid "Administering"
msgstr ""

#. type: Labeled list
#: en/git-send-email.txt:417
#, fuzzy, no-wrap, priority:100
msgid "--confirm=<mode>"
msgstr "--confirm=<mode>"

#. type: Plain text
#: en/git-send-email.txt:419
#, priority:100
msgid "Confirm just before sending:"
msgstr ""

#. type: Plain text
#: en/git-send-email.txt:422
#, priority:100
msgid "'always' will always confirm before sending"
msgstr ""

#. type: Plain text
#: en/git-send-email.txt:423
#, priority:100
msgid "'never' will never confirm before sending"
msgstr ""

#. type: Plain text
#: en/git-send-email.txt:425
#, priority:100
msgid "'cc' will confirm before sending when send-email has automatically added addresses from the patch to the Cc list"
msgstr ""

#. type: Plain text
#: en/git-send-email.txt:426
#, priority:100
msgid "'compose' will confirm before sending the first message when using --compose."
msgstr ""

#. type: Plain text
#: en/git-send-email.txt:427
#, priority:100
msgid "'auto' is equivalent to 'cc' + 'compose'"
msgstr ""

#. type: Plain text
#: en/git-send-email.txt:432
#, priority:100
msgid "Default is the value of `sendemail.confirm` configuration value; if that is unspecified, default to 'auto' unless any of the suppress options have been specified, in which case default to 'compose'."
msgstr ""

#. type: Plain text
#: en/git-send-email.txt:435
#, priority:100
msgid "Do everything except actually send the emails."
msgstr ""

#. type: Labeled list
#: en/git-send-email.txt:436
#, ignore-same, no-wrap, priority:100
msgid "--[no-]format-patch"
msgstr "--[no-]format-patch"

#. type: Plain text
#: en/git-send-email.txt:441
#, priority:100
msgid "When an argument may be understood either as a reference or as a file name, choose to understand it as a format-patch argument (`--format-patch`)  or as a file name (`--no-format-patch`). By default, when such a conflict occurs, git send-email will fail."
msgstr ""

#. type: Plain text
#: en/git-send-email.txt:445
#, priority:100
msgid "Make git-send-email less verbose.  One line per email should be all that is output."
msgstr ""

#. type: Labeled list
#: en/git-send-email.txt:446
#, ignore-same, no-wrap, priority:100
msgid "--[no-]validate"
msgstr "--[no-]validate"

#. type: Plain text
#: en/git-send-email.txt:449
#, priority:100
msgid "Perform sanity checks on patches.  Currently, validation means the following:"
msgstr ""

#. type: Plain text
#: en/git-send-email.txt:452
#, priority:100
msgid "Invoke the sendemail-validate hook if present (see linkgit:githooks[5])."
msgstr ""

#. type: Plain text
#: en/git-send-email.txt:453
#, priority:100
msgid "Warn of patches that contain lines longer than"
msgstr ""

#. type: Plain text
#: en/git-send-email.txt:457
#, no-wrap, priority:100
msgid ""
"998 characters unless a suitable transfer encoding\n"
"('auto', 'base64', or 'quoted-printable') is used;\n"
"this is due to SMTP limits as described by\n"
"http://www.ietf.org/rfc/rfc5322.txt.\n"
msgstr ""

#. type: Plain text
#: en/git-send-email.txt:461
#, priority:100
msgid "Default is the value of `sendemail.validate`; if this is not set, default to `--validate`."
msgstr ""

#. type: Plain text
#: en/git-send-email.txt:464
#, priority:100
msgid "Send emails even if safety checks would prevent it."
msgstr ""

#. type: Title ~
#: en/git-send-email.txt:467
#, fuzzy, no-wrap, priority:100
msgid "Information"
msgstr "信息"

#. type: Labeled list
#: en/git-send-email.txt:469
#, ignore-same, no-wrap, priority:100
msgid "--dump-aliases"
msgstr "--dump-aliases"

#. type: Plain text
#: en/git-send-email.txt:474
#, priority:100
msgid "Instead of the normal operation, dump the shorthand alias names from the configured alias file(s), one per line in alphabetical order. Note, this only includes the alias name and not its expanded email addresses.  See 'sendemail.aliasesfile' for more information about aliases."
msgstr ""

#. type: Title ~
#: en/git-send-email.txt:486
#, no-wrap, priority:100
msgid "Use gmail as the smtp server"
msgstr ""

#. type: Plain text
#: en/git-send-email.txt:489
#, priority:100
msgid "To use 'git send-email' to send your patches through the GMail SMTP server, edit ~/.gitconfig to specify your account settings:"
msgstr ""

#. type: delimited block -
#: en/git-send-email.txt:496
#, fuzzy, no-wrap, priority:100
msgid ""
"[sendemail]\n"
"\tsmtpEncryption = tls\n"
"\tsmtpServer = smtp.gmail.com\n"
"\tsmtpUser = yourname@gmail.com\n"
"\tsmtpServerPort = 587\n"
msgstr ""
"[sendemail]\n"
"\tsmtpEncryption = tls\n"
"\tsmtpServer = smtp.gmail.com\n"
"\tsmtpUser = yourname@gmail.com\n"
"\tsmtpServerPort = 587\n"

#. type: Plain text
#: en/git-send-email.txt:501
#, priority:100
msgid "If you have multi-factor authentication set up on your Gmail account, you can generate an app-specific password for use with 'git send-email'. Visit https://security.google.com/settings/security/apppasswords to create it."
msgstr ""

#. type: Plain text
#: en/git-send-email.txt:504
#, priority:100
msgid "Once your commits are ready to be sent to the mailing list, run the following commands:"
msgstr ""

#. type: Plain text
#: en/git-send-email.txt:508
#, fuzzy, no-wrap, priority:100
msgid ""
"\t$ git format-patch --cover-letter -M origin/master -o outgoing/\n"
"\t$ edit outgoing/0000-*\n"
"\t$ git send-email outgoing/*\n"
msgstr ""
"\t$ git format-patch --cover-letter -M origin/master -o outgoing/\n"
"\t$ edit outgoing/0000-*\n"
"\t$ git send-email outgoing/*\n"

#. type: Plain text
#: en/git-send-email.txt:513
#, priority:100
msgid "The first time you run it, you will be prompted for your credentials.  Enter the app-specific or your regular password as appropriate.  If you have credential helper configured (see linkgit:git-credential[1]), the password will be saved in the credential store so you won't have to type it the next time."
msgstr ""

#. type: Plain text
#: en/git-send-email.txt:519
#, priority:100
msgid "Note: the following core Perl modules that may be installed with your distribution of Perl are required: MIME::Base64, MIME::QuotedPrint, Net::Domain and Net::SMTP.  These additional Perl modules are also required: Authen::SASL and Mail::Address."
msgstr ""

#. type: Plain text
#: en/git-send-email.txt:524
#, priority:100
msgid "linkgit:git-format-patch[1], linkgit:git-imap-send[1], mbox(5)"
msgstr ""

#. type: Title =
#: en/git-send-pack.txt:2
#, ignore-same, no-wrap, priority:90
msgid "git-send-pack(1)"
msgstr "git-send-pack(1)"

#. type: Plain text
#: en/git-send-pack.txt:7
#, priority:90
msgid "git-send-pack - Push objects over Git protocol to another repository"
msgstr "git-send-pack - 通过 Git 协议将对象推送到另一个仓库"

#. type: Plain text
#: en/git-send-pack.txt:17
#, ignore-ellipsis, no-wrap, priority:90
msgid ""
"'git send-pack' [--mirror] [--dry-run] [--force]\n"
"\t\t[--receive-pack=<git-receive-pack>]\n"
"\t\t[--verbose] [--thin] [--atomic]\n"
"\t\t[--[no-]signed | --signed=(true|false|if-asked)]\n"
"\t\t[<host>:]<directory> (--all | <ref>...)\n"
msgstr ""

#. type: Plain text
#: en/git-send-pack.txt:22
#, priority:90
msgid "Usually you would want to use 'git push', which is a higher-level wrapper of this command, instead. See linkgit:git-push[1]."
msgstr ""

#. type: Plain text
#: en/git-send-pack.txt:25
#, priority:90
msgid "Invokes 'git-receive-pack' on a possibly remote repository, and updates it from the current repository, sending named refs."
msgstr ""

#. type: Plain text
#: en/git-send-pack.txt:37
#, priority:90
msgid "Same as --receive-pack=<git-receive-pack>."
msgstr ""

#. type: Plain text
#: en/git-send-pack.txt:41
#, priority:90
msgid "Instead of explicitly specifying which refs to update, update all heads that locally exist."
msgstr ""

#. type: Plain text
#: en/git-send-pack.txt:68
#, priority:90
msgid "Send a \"thin\" pack, which records objects in deltified form based on objects not included in the pack to reduce network traffic."
msgstr ""

#. type: Plain text
#: en/git-send-pack.txt:73
#, priority:90
msgid "Use an atomic transaction for updating the refs. If any of the refs fails to update then the entire push will fail without changing any refs."
msgstr ""

#. type: Labeled list
#: en/git-send-pack.txt:85
#, fuzzy, no-wrap, priority:90
msgid "--push-option=<string>"
msgstr "--push-option=<string>"

#. type: Plain text
#: en/git-send-pack.txt:90
#, priority:90
msgid "Pass the specified string as a push option for consumption by hooks on the server side.  If the server doesn't support push options, error out.  See linkgit:git-push[1] and linkgit:githooks[5] for details."
msgstr ""

#. type: Labeled list
#: en/git-send-pack.txt:91
#, fuzzy, no-wrap, priority:90
msgid "<host>"
msgstr "<host>"

#. type: Plain text
#: en/git-send-pack.txt:95
#, priority:90
msgid "A remote host to house the repository.  When this part is specified, 'git-receive-pack' is invoked via ssh."
msgstr ""

#. type: Plain text
#: en/git-send-pack.txt:98
#, priority:90
msgid "The repository to update."
msgstr ""

#. type: Plain text
#: en/git-send-pack.txt:108
#, priority:90
msgid "There are three ways to specify which refs to update on the remote end."
msgstr ""

#. type: Plain text
#: en/git-send-pack.txt:112
#, priority:90
msgid "With `--all` flag, all refs that exist locally are transferred to the remote side.  You cannot specify any '<ref>' if you use this flag."
msgstr ""

#. type: Plain text
#: en/git-send-pack.txt:115
#, priority:90
msgid "Without `--all` and without any '<ref>', the heads that exist both on the local side and on the remote side are updated."
msgstr ""

#. type: Plain text
#: en/git-send-pack.txt:121
#, priority:90
msgid "When one or more '<ref>' are specified explicitly (whether on the command line or via `--stdin`), it can be either a single pattern, or a pair of such pattern separated by a colon \":\" (this means that a ref name cannot have a colon in it).  A single pattern '<name>' is just a shorthand for '<name>:<name>'."
msgstr ""

#. type: Plain text
#: en/git-send-pack.txt:129
#, priority:90
msgid "Each pattern pair consists of the source side (before the colon)  and the destination side (after the colon).  The ref to be pushed is determined by finding a match that matches the source side, and where it is pushed is determined by using the destination side. The rules used to match a ref are the same rules used by 'git rev-parse' to resolve a symbolic ref name. See linkgit:git-rev-parse[1]."
msgstr ""

#. type: Plain text
#: en/git-send-pack.txt:132
#, priority:90
msgid "It is an error if <src> does not match exactly one of the local refs."
msgstr ""

#. type: Plain text
#: en/git-send-pack.txt:134
#, priority:90
msgid "It is an error if <dst> matches more than one remote refs."
msgstr ""

#. type: Plain text
#: en/git-send-pack.txt:136
#, priority:90
msgid "If <dst> does not match any remote ref, either"
msgstr ""

#. type: Title =
#: en/git-shell.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-shell(1)"
msgstr "git-shell(1)"

#. type: Plain text
#: en/git-shell.txt:7
#, priority:100
msgid "git-shell - Restricted login shell for Git-only SSH access"
msgstr "git-shell - 仅限 Git SSH 访问的受限登录 shell"

#. type: Plain text
#: en/git-shell.txt:15
#, no-wrap, priority:100
msgid ""
"'chsh' -s $(command -v git-shell) <user>\n"
"'git clone' <user>`@localhost:/path/to/repo.git`\n"
"'ssh' <user>`@localhost`\n"
msgstr ""

#. type: Plain text
#: en/git-shell.txt:23
#, priority:100
msgid "This is a login shell for SSH accounts to provide restricted Git access.  It permits execution only of server-side Git commands implementing the pull/push functionality, plus custom commands present in a subdirectory named `git-shell-commands` in the user's home directory."
msgstr ""

#. type: Plain text
#: en/git-shell.txt:28
#, fuzzy, priority:100
msgid "'git shell' accepts the following commands after the `-c` option:"
msgstr "'git shell' accepts the following commands after the `-c` option:"

#. type: Labeled list
#: en/git-shell.txt:29
#, no-wrap, priority:100
msgid "'git receive-pack <argument>'"
msgstr ""

#. type: Labeled list
#: en/git-shell.txt:30
#, no-wrap, priority:100
msgid "'git upload-pack <argument>'"
msgstr ""

#. type: Labeled list
#: en/git-shell.txt:31
#, no-wrap, priority:100
msgid "'git upload-archive <argument>'"
msgstr ""

#. type: Plain text
#: en/git-shell.txt:35
#, priority:100
msgid "Call the corresponding server-side command to support the client's 'git push', 'git fetch', or 'git archive --remote' request."
msgstr ""

#. type: Labeled list
#: en/git-shell.txt:35
#, no-wrap, priority:100
msgid "'cvs server'"
msgstr ""

#. type: Plain text
#: en/git-shell.txt:37
#, priority:100
msgid "Imitate a CVS server.  See linkgit:git-cvsserver[1]."
msgstr ""

#. type: Plain text
#: en/git-shell.txt:42
#, priority:100
msgid "If a `~/git-shell-commands` directory is present, 'git shell' will also handle other, custom commands by running \"`git-shell-commands/<command> <arguments>`\" from the user's home directory."
msgstr ""

#. type: Title -
#: en/git-shell.txt:44
#, no-wrap, priority:100
msgid "INTERACTIVE USE"
msgstr ""

#. type: Plain text
#: en/git-shell.txt:48
#, priority:100
msgid "By default, the commands above can be executed only with the `-c` option; the shell is not interactive."
msgstr ""

#. type: Plain text
#: en/git-shell.txt:56
#, priority:100
msgid "If a `~/git-shell-commands` directory is present, 'git shell' can also be run interactively (with no arguments).  If a `help` command is present in the `git-shell-commands` directory, it is run to provide the user with an overview of allowed actions.  Then a \"git> \" prompt is presented at which one can enter any of the commands from the `git-shell-commands` directory, or `exit` to close the connection."
msgstr ""

#. type: Plain text
#: en/git-shell.txt:61
#, priority:100
msgid "Generally this mode is used as an administrative interface to allow users to list repositories they have access to, create, delete, or rename repositories, or change repository descriptions and permissions."
msgstr ""

#. type: Plain text
#: en/git-shell.txt:64
#, priority:100
msgid "If a `no-interactive-login` command exists, then it is run and the interactive shell is aborted."
msgstr ""

#. type: Plain text
#: en/git-shell.txt:69
#, priority:100
msgid "To disable interactive logins, displaying a greeting instead:"
msgstr ""

#. type: delimited block -
#: en/git-shell.txt:80
#, fuzzy, no-wrap, priority:100
msgid ""
"$ chsh -s /usr/bin/git-shell\n"
"$ mkdir $HOME/git-shell-commands\n"
"$ cat >$HOME/git-shell-commands/no-interactive-login <<\\EOF\n"
"#!/bin/sh\n"
"printf '%s\\n' \"Hi $USER! You've successfully authenticated, but I do not\"\n"
"printf '%s\\n' \"provide interactive shell access.\"\n"
"exit 128\n"
"EOF\n"
"$ chmod +x $HOME/git-shell-commands/no-interactive-login\n"
msgstr ""
"$ chsh -s /usr/bin/git-shell\n"
"$ mkdir $HOME/git-shell-commands\n"
"$ cat >$HOME/git-shell-commands/no-interactive-login <<\\EOF\n"
"#!/bin/sh\n"
"printf '%s\\n' \"Hi $USER! You've successfully authenticated, but I do not\"\n"
"printf '%s\\n' \"provide interactive shell access.\"\n"
"exit 128\n"
"EOF\n"
"$ chmod +x $HOME/git-shell-commands/no-interactive-login\n"

#. type: Plain text
#: en/git-shell.txt:85
#, priority:100
msgid "To enable git-cvsserver access (which should generally have the `no-interactive-login` example above as a prerequisite, as creating the git-shell-commands directory allows interactive logins):"
msgstr ""

#. type: delimited block -
#: en/git-shell.txt:96
#, fuzzy, no-wrap, priority:100
msgid ""
"$ cat >$HOME/git-shell-commands/cvs <<\\EOF\n"
"if ! test $# = 1 && test \"$1\" = \"server\"\n"
"then\n"
"\techo >&2 \"git-cvsserver only handles \\\"server\\\"\"\n"
"\texit 1\n"
"fi\n"
"exec git cvsserver server\n"
"EOF\n"
"$ chmod +x $HOME/git-shell-commands/cvs\n"
msgstr ""
"$ cat >$HOME/git-shell-commands/cvs <<\\EOF\n"
"if ! test $# = 1 && test \"$1\" = \"server\"\n"
"then\n"
"\techo >&2 \"git-cvsserver only handles \\\"server\\\"\"\n"
"\texit 1\n"
"fi\n"
"exec git cvsserver server\n"
"EOF\n"
"$ chmod +x $HOME/git-shell-commands/cvs\n"

#. type: Plain text
#: en/git-shell.txt:103
#, fuzzy, priority:100
msgid "ssh(1), linkgit:git-daemon[1], contrib/git-shell-commands/README"
msgstr "ssh(1), linkgit:git-daemon[1], contrib/git-shell-commands/README"

#. type: Title =
#: en/git-sh-i18n--envsubst.txt:2
#, no-wrap, priority:90
msgid "git-sh-i18n{litdd}envsubst(1)"
msgstr ""

#. type: Plain text
#: en/git-sh-i18n--envsubst.txt:7
#, priority:90
msgid "git-sh-i18n--envsubst - Git's own envsubst(1) for i18n fallbacks"
msgstr ""

#. type: Plain text
#: en/git-sh-i18n--envsubst.txt:17
#, no-wrap, priority:90
msgid ""
"eval_gettext () {\n"
"\tprintf \"%s\" \"$1\" | (\n"
"\t\texport PATH $('git sh-i18n{litdd}envsubst' --variables \"$1\");\n"
"\t\t'git sh-i18n{litdd}envsubst' \"$1\"\n"
"\t)\n"
"}\n"
msgstr ""

#. type: Plain text
#: en/git-sh-i18n--envsubst.txt:24
#, priority:90
msgid "This is not a command the end user would want to run.  Ever.  This documentation is meant for people who are studying the plumbing scripts and/or are writing new ones."
msgstr ""

#. type: Plain text
#: en/git-sh-i18n--envsubst.txt:29
#, fuzzy, priority:90
msgid "'git sh-i18n{litdd}envsubst' is Git's stripped-down copy of the GNU `envsubst(1)` program that comes with the GNU gettext package. It's used internally by linkgit:git-sh-i18n[1] to interpolate the variables passed to the `eval_gettext` function."
msgstr "'git sh-i18n{litdd}envsubst' is Git's stripped-down copy of the GNU `envsubst(1)` program that comes with the GNU gettext package. It's used internally by linkgit:git-sh-i18n[1] to interpolate the variables passed to the `eval_gettext` function."

#. type: Plain text
#: en/git-sh-i18n--envsubst.txt:33
#, priority:90
msgid "No promises are made about the interface, or that this program won't disappear without warning in the next version of Git. Don't use it."
msgstr ""

#. type: Title =
#: en/git-sh-i18n.txt:2
#, ignore-same, no-wrap, priority:90
msgid "git-sh-i18n(1)"
msgstr "git-sh-i18n(1)"

#. type: Plain text
#: en/git-sh-i18n.txt:7
#, priority:90
msgid "git-sh-i18n - Git's i18n setup code for shell scripts"
msgstr ""

#. type: Plain text
#: en/git-sh-i18n.txt:12
#, fuzzy, no-wrap, priority:90
msgid "'. \"$(git --exec-path)/git-sh-i18n\"'\n"
msgstr "'. \"$(git --exec-path)/git-sh-i18n\"'\n"

#. type: Plain text
#: en/git-sh-i18n.txt:26
#, fuzzy, priority:90
msgid "The 'git sh-i18n scriptlet is designed to be sourced (using `.`) by Git's porcelain programs implemented in shell script. It provides wrappers for the GNU `gettext` and `eval_gettext` functions accessible through the `gettext.sh` script, and provides pass-through fallbacks on systems without GNU gettext."
msgstr "The 'git sh-i18n scriptlet is designed to be sourced (using `.`) by Git's porcelain programs implemented in shell script. It provides wrappers for the GNU `gettext` and `eval_gettext` functions accessible through the `gettext.sh` script, and provides pass-through fallbacks on systems without GNU gettext."

#. type: Labeled list
#: en/git-sh-i18n.txt:30
#, fuzzy, no-wrap, priority:90
msgid "gettext"
msgstr "gettext"

#. type: Plain text
#: en/git-sh-i18n.txt:34
#, priority:90
msgid "Currently a dummy fall-through function implemented as a wrapper around `printf(1)`. Will be replaced by a real gettext implementation in a later version."
msgstr ""

#. type: Labeled list
#: en/git-sh-i18n.txt:35
#, no-wrap, priority:90
msgid "eval_gettext"
msgstr ""

#. type: Plain text
#: en/git-sh-i18n.txt:40
#, priority:90
msgid "Currently a dummy fall-through function implemented as a wrapper around `printf(1)` with variables expanded by the linkgit:git-sh-i18n{litdd}envsubst[1] helper. Will be replaced by a real gettext implementation in a later version."
msgstr ""

#. type: Title =
#: en/git-shortlog.txt:2
#, ignore-same, no-wrap, priority:260
msgid "git-shortlog(1)"
msgstr "git-shortlog(1)"

#. type: Plain text
#: en/git-shortlog.txt:7
#, fuzzy, priority:260
msgid "git-shortlog - Summarize 'git log' output"
msgstr "git-shortlog - Summarize 'git log' output"

#. type: Plain text
#: en/git-shortlog.txt:13
#, fuzzy, ignore-ellipsis, no-wrap, priority:260
#| msgid ""
#| "'git shortlog' [<options>] [<revision range>] [[--] <path>...]\n"
#| "git log --pretty=short | 'git shortlog' [<options>]\n"
msgid ""
"'git shortlog' [<options>] [<revision-range>] [[--] <path>...]\n"
"git log --pretty=short | 'git shortlog' [<options>]\n"
msgstr ""
"'git shortlog' [<options>] [<revision range>] [[--] <path>...] 。\n"
"git log --pretty=short | 'git shortlog' [<options>] 。\n"

#. type: Plain text
#: en/git-shortlog.txt:18
#, priority:260
msgid "Summarizes 'git log' output in a format suitable for inclusion in release announcements. Each commit will be grouped by author and title."
msgstr "将'git log'输出总结为适合纳入发布公告的格式。每个提交将按作者和标题分组。"

#. type: Plain text
#: en/git-shortlog.txt:20
#, priority:260
msgid "Additionally, \"[PATCH]\" will be stripped from the commit description."
msgstr "此外，\"[PATCH]\"将从提交描述中被剥离。"

#. type: Plain text
#: en/git-shortlog.txt:25
#, priority:260
msgid "If no revisions are passed on the command line and either standard input is not a terminal or there is no current branch, 'git shortlog' will output a summary of the log read from standard input, without reference to the current repository."
msgstr "如果命令行上没有传递修订版，而且标准输入不是终端，或者没有当前分支，'git shortlog'将输出从标准输入读取的日志摘要，而不参考当前版本库。"

#. type: Plain text
#: en/git-shortlog.txt:33
#, priority:260
msgid "Sort output according to the number of commits per author instead of author alphabetic order."
msgstr "根据每个作者的提交数量对输出进行排序，而不是按照作者的字母顺序。"

#. type: Plain text
#: en/git-shortlog.txt:37
#, priority:260
msgid "Suppress commit description and provide a commit count summary only."
msgstr "抑制提交描述，只提供提交计数摘要。"

#. type: Labeled list
#: en/git-shortlog.txt:39
#, ignore-same, no-wrap, priority:260
msgid "--email"
msgstr "--email"

#. type: Plain text
#: en/git-shortlog.txt:41
#, priority:260
msgid "Show the email address of each author."
msgstr "显示每个作者的电子邮件地址。"

#. type: Labeled list
#: en/git-shortlog.txt:42
#, fuzzy, no-wrap, priority:260
msgid "--format[=<format>]"
msgstr "--format[=<format>]"

#. type: Plain text
#: en/git-shortlog.txt:47
#, priority:260
msgid "Instead of the commit subject, use some other information to describe each commit.  '<format>' can be any string accepted by the `--format` option of 'git log', such as '* [%h] %s'.  (See the \"PRETTY FORMATS\" section of linkgit:git-log[1].)"
msgstr "代替提交主题，使用一些其他信息来描述每个提交。  <format>'可以是任何被'git log'的`--format'选项接受的字符串，比如'* [%h] %s'。  参见linkgit:git-log[1]的 \"PRETTY FORMATS \"部分）。"

#. type: Plain text
#: en/git-shortlog.txt:49
#, priority:260
msgid "Each pretty-printed commit will be rewrapped before it is shown."
msgstr "每个漂亮的印刷品承诺在展示之前都会被重新包装。"

#. type: Labeled list
#: en/git-shortlog.txt:50 en/rev-list-options.txt:1053
#, fuzzy, no-wrap, priority:260
msgid "--date=<format>"
msgstr "--date=<format>"

#. type: Plain text
#: en/git-shortlog.txt:54
#, priority:260
msgid "Show dates formatted according to the given date string. (See the `--date` option in the \"Commit Formatting\" section of linkgit:git-log[1]). Useful with `--group=format:<format>`."
msgstr "显示根据给定日期字符串格式化的日期。(参见linkgit:git-log[1]中 \"提交格式化\"部分的`--date`选项）。与 `--group=format:<format>`一起使用会非常有用。"

#. type: Labeled list
#: en/git-shortlog.txt:55
#, fuzzy, no-wrap, priority:260
#| msgid "--no-type"
msgid "--group=<type>"
msgstr "--group=<type>"

#. type: Plain text
#: en/git-shortlog.txt:58
#, priority:260
msgid "Group commits based on `<type>`. If no `--group` option is specified, the default is `author`. `<type>` is one of:"
msgstr "根据`<类型>`对提交进行分组。如果没有指定`--组'选项，默认为`作者'。`<类型>`是以下之一。"

#. type: Plain text
#: en/git-shortlog.txt:61
#, priority:260
msgid "`author`, commits are grouped by author"
msgstr "\"作者\"，提交内容按作者分组"

#. type: Plain text
#: en/git-shortlog.txt:62
#, priority:260
msgid "`committer`, commits are grouped by committer (the same as `-c`)"
msgstr "提交人\"，提交内容按提交人分组（与 \"c \"相同）。"

#. type: Plain text
#: en/git-shortlog.txt:67
#, priority:260
msgid "`trailer:<field>`, the `<field>` is interpreted as a case-insensitive commit message trailer (see linkgit:git-interpret-trailers[1]). For example, if your project uses `Reviewed-by` trailers, you might want to see who has been reviewing with `git shortlog -ns --group=trailer:reviewed-by`."
msgstr "`trailer:<field>`，`<field>`被解释为不区分大小写的提交消息预告片（见 linkgit:git-interpret-trailers[1]）。例如，如果你的项目使用 `Reviewed-by` 拖车，你可能想用 `git shortlog -ns --group=trailer:reviewed-by` 来查看谁在审核。"

#. type: Plain text
#: en/git-shortlog.txt:70
#, priority:260
msgid "`format:<format>`, any string accepted by the `--format` option of 'git log'. (See the \"PRETTY FORMATS\" section of linkgit:git-log[1].)"
msgstr "`格式：<format>`可以是任何被'git log'的`--format'选项接受的字符串，比如'* [%h] %s'。 参见linkgit:git-log[1]的 \"PRETTY FORMATS \"部分）。"

#. type: Plain text
#: en/git-shortlog.txt:75
#, priority:260
msgid "Note that commits that do not include the trailer will not be counted.  Likewise, commits with multiple trailers (e.g., multiple signoffs) may be counted more than once (but only once per unique trailer value in that commit)."
msgstr "请注意，不包括拖车的提交将不被计算在内。  同样地，有多个拖车的提交（例如多个签收）可以被计算一次（但该提交中每个独特的拖车值只能计算一次）。"

#. type: Plain text
#: en/git-shortlog.txt:80
#, priority:260
msgid "Shortlog will attempt to parse each trailer value as a `name <email>` identity. If successful, the mailmap is applied and the email is omitted unless the `--email` option is specified. If the value cannot be parsed as an identity, it will be taken literally and completely."
msgstr "Shortlog将尝试把每个拖车值解析为`name <email>`的身份。如果成功，将应用mailmap，除非指定`--email`选项，否则将省略email。如果该值不能被解析为一个身份，那么它将被完全视为字面意思。"

#. type: Plain text
#: en/git-shortlog.txt:86
#, priority:260
msgid "If `--group` is specified multiple times, commits are counted under each value (but again, only once per unique value in that commit). For example, `git shortlog --group=author --group=trailer:co-authored-by` counts both authors and co-authors."
msgstr "如果\"--组 \"被多次指定，每个值下的提交都会被计算（但同样，每个提交中的唯一值只能计算一次）。例如，`git shortlog --group=author --group=trailer:co-authored-by`同时计算作者和共同作者。"

#. type: Labeled list
#: en/git-shortlog.txt:88
#, ignore-same, no-wrap, priority:260
msgid "--committer"
msgstr "--committer"

#. type: Plain text
#: en/git-shortlog.txt:90
#, priority:260
msgid "This is an alias for `--group=committer`."
msgstr "这是`--group=committer`的一个别名。"

#. type: Labeled list
#: en/git-shortlog.txt:91
#, no-wrap, priority:260
msgid "-w[<width>[,<indent1>[,<indent2>]]]"
msgstr "-w[<width>[,<indent1>[,<indent2>]]]"

#. type: Plain text
#: en/git-shortlog.txt:96
#, priority:260
msgid "Linewrap the output by wrapping each line at `width`.  The first line of each entry is indented by `indent1` spaces, and the second and subsequent lines are indented by `indent2` spaces. `width`, `indent1`, and `indent2` default to 76, 6 and 9 respectively."
msgstr "通过以`width`包裹每一行来对输出进行换行。  每个条目的第一行缩进`缩进1`个空格，第二行和后续行缩进`缩进2`个空格。`width`, `indent1`, 和`indent2`分别默认为76, 6和9。"

#. type: Plain text
#: en/git-shortlog.txt:99
#, priority:260
msgid "If width is `0` (zero) then indent the lines of the output without wrapping them."
msgstr "如果宽度为`0`（零），则缩进输出的行数而不包裹它们。"

#. type: Plain text
#: en/git-shortlog.txt:108
#, fuzzy, priority:260
#| msgid "Show only commits in the specified revision range.  When no <revision range> is specified, it defaults to `HEAD` (i.e. the whole history leading to the current commit).  `origin..HEAD` specifies all the commits reachable from the current commit (i.e. `HEAD`), but not from `origin`. For a complete list of ways to spell <revision range>, see the \"Specifying Ranges\" section of linkgit:gitrevisions[7]."
msgid "Show only commits in the specified revision range.  When no <revision-range> is specified, it defaults to `HEAD` (i.e. the whole history leading to the current commit).  `origin..HEAD` specifies all the commits reachable from the current commit (i.e. `HEAD`), but not from `origin`. For a complete list of ways to spell <revision-range>, see the \"Specifying Ranges\" section of linkgit:gitrevisions[7]."
msgstr "只显示指定修订范围内的提交。  当没有指定<修订范围>时，默认为`HEAD`（即导致当前提交的整个历史）。  `origin...HEAD`指定了从当前提交（即`HEAD`）可以到达的所有提交，但不是从`origin`。关于<revision range>的完整拼写方式，见linkgit:gitrevisions[7]的 \"指定范围 \"部分。"

#. type: Plain text
#: en/git-shortlog.txt:112
#, priority:260
msgid "Consider only commits that are enough to explain how the files that match the specified paths came to be."
msgstr "只考虑那些足以解释符合指定路径的文件是如何产生的提交。"

#. type: Plain text
#: en/git-shortlog.txt:127
#, priority:260
msgid "Note that if `git shortlog` is run outside of a repository (to process log contents on standard input), it will look for a `.mailmap` file in the current directory."
msgstr "注意，如果`git shortlog`在版本库外运行（处理标准输入的日志内容），它将在当前目录下寻找一个`.mailmap`文件。"

#. type: Title =
#: en/git-show-branch.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-show-branch(1)"
msgstr "git-show-branch(1)"

#. type: Plain text
#: en/git-show-branch.txt:7
#, priority:100
msgid "git-show-branch - Show branches and their commits"
msgstr ""

#. type: Plain text
#: en/git-show-branch.txt:17
#, fuzzy, ignore-ellipsis, no-wrap, priority:100
msgid ""
"'git show-branch' [-a | --all] [-r | --remotes] [--topo-order | --date-order]\n"
"\t\t[--current] [--color[=<when>] | --no-color] [--sparse]\n"
"\t\t[--more=<n> | --list | --independent | --merge-base]\n"
"\t\t[--no-name | --sha1-name] [--topics]\n"
"\t\t[(<rev> | <glob>)...]\n"
"'git show-branch' (-g | --reflog)[=<n>[,<base>]] [--list] [<ref>]\n"
msgstr ""
"'git show-branch' [-a|--all] [-r|--remotes] [--topo-order | --date-order]\n"
"\t\t[--current] [--color[=<when>] | --no-color] [--sparse]\n"
"\t\t[--more=<n> | --list | --independent | --merge-base]\n"
"\t\t[--no-name | --sha1-name] [--topics]\n"
"\t\t[(<rev> | <glob>)...]\n"
"'git show-branch' (-g|--reflog)[=<n>[,<base>]] [--list] [<ref>]\n"

#. type: Plain text
#: en/git-show-branch.txt:24
#, priority:100
msgid "Shows the commit ancestry graph starting from the commits named with <rev>s or <glob>s (or all refs under refs/heads and/or refs/tags) semi-visually."
msgstr ""

#. type: Plain text
#: en/git-show-branch.txt:26
#, priority:100
msgid "It cannot show more than 29 branches and commits at a time."
msgstr ""

#. type: Plain text
#: en/git-show-branch.txt:29
#, priority:100
msgid "It uses `showbranch.default` multi-valued configuration items if no <rev> or <glob> is given on the command line."
msgstr ""

#. type: Labeled list
#: en/git-show-branch.txt:33
#, fuzzy, no-wrap, priority:100
msgid "<rev>"
msgstr "<rev>"

#. type: Plain text
#: en/git-show-branch.txt:36
#, priority:100
msgid "Arbitrary extended SHA-1 expression (see linkgit:gitrevisions[7])  that typically names a branch head or a tag."
msgstr ""

#. type: Labeled list
#: en/git-show-branch.txt:37
#, no-wrap, priority:100
msgid "<glob>"
msgstr ""

#. type: Plain text
#: en/git-show-branch.txt:42
#, priority:100
msgid "A glob pattern that matches branch or tag names under refs/.  For example, if you have many topic branches under refs/heads/topic, giving `topic/*` would show all of them."
msgstr ""

#. type: Plain text
#: en/git-show-branch.txt:46
#, priority:100
msgid "Show the remote-tracking branches."
msgstr ""

#. type: Plain text
#: en/git-show-branch.txt:50
#, priority:100
msgid "Show both remote-tracking branches and local branches."
msgstr ""

#. type: Labeled list
#: en/git-show-branch.txt:51
#, ignore-same, no-wrap, priority:100
msgid "--current"
msgstr "--current"

#. type: Plain text
#: en/git-show-branch.txt:55
#, priority:100
msgid "With this option, the command includes the current branch to the list of revs to be shown when it is not given on the command line."
msgstr ""

#. type: Labeled list
#: en/git-show-branch.txt:56 en/rev-list-options.txt:853
#, ignore-same, no-wrap, priority:260
msgid "--topo-order"
msgstr "--topo-order"

#. type: Plain text
#: en/git-show-branch.txt:61
#, priority:100
msgid "By default, the branches and their commits are shown in reverse chronological order.  This option makes them appear in topological order (i.e., descendant commits are shown before their parents)."
msgstr ""

#. type: Labeled list
#: en/git-show-branch.txt:62 en/rev-list-options.txt:845
#, ignore-same, no-wrap, priority:260
msgid "--date-order"
msgstr "--date-order"

#. type: Plain text
#: en/git-show-branch.txt:66
#, priority:100
msgid "This option is similar to `--topo-order` in the sense that no parent comes before all of its children, but otherwise commits are ordered according to their commit date."
msgstr ""

#. type: Plain text
#: en/git-show-branch.txt:71
#, priority:100
msgid "By default, the output omits merges that are reachable from only one tip being shown.  This option makes them visible."
msgstr ""

#. type: Labeled list
#: en/git-show-branch.txt:72
#, fuzzy, no-wrap, priority:100
msgid "--more=<n>"
msgstr "--more=<n>"

#. type: Plain text
#: en/git-show-branch.txt:78
#, priority:100
msgid "Usually the command stops output upon showing the commit that is the common ancestor of all the branches.  This flag tells the command to go <n> more common commits beyond that.  When <n> is negative, display only the <ref>s given, without showing the commit ancestry tree."
msgstr ""

#. type: Plain text
#: en/git-show-branch.txt:81
#, priority:100
msgid "Synonym to `--more=-1`"
msgstr "同 `--more=-1`"

#. type: Plain text
#: en/git-show-branch.txt:88
#, priority:100
msgid "Instead of showing the commit list, determine possible merge bases for the specified commits. All merge bases will be contained in all specified commits. This is different from how linkgit:git-merge-base[1] handles the case of three or more commits."
msgstr ""

#. type: Plain text
#: en/git-show-branch.txt:92
#, priority:100
msgid "Among the <ref>s given, display only the ones that cannot be reached from any other <ref>."
msgstr ""

#. type: Labeled list
#: en/git-show-branch.txt:93
#, ignore-same, no-wrap, priority:100
msgid "--no-name"
msgstr "--no-name"

#. type: Plain text
#: en/git-show-branch.txt:95
#, priority:100
msgid "Do not show naming strings for each commit."
msgstr ""

#. type: Labeled list
#: en/git-show-branch.txt:96
#, ignore-same, no-wrap, priority:100
msgid "--sha1-name"
msgstr "--sha1-name"

#. type: Plain text
#: en/git-show-branch.txt:101
#, priority:100
msgid "Instead of naming the commits using the path to reach them from heads (e.g. \"master~2\" to mean the grandparent of \"master\"), name them with the unique prefix of their object names."
msgstr ""

#. type: Labeled list
#: en/git-show-branch.txt:102
#, ignore-same, no-wrap, priority:100
msgid "--topics"
msgstr "--topics"

#. type: Plain text
#: en/git-show-branch.txt:109
#, priority:100
msgid "Shows only commits that are NOT on the first branch given.  This helps track topic branches by hiding any commit that is already in the main line of development.  When given \"git show-branch --topics master topic1 topic2\", this will show the revisions given by \"git rev-list {caret}master topic1 topic2\""
msgstr ""

#. type: Labeled list
#: en/git-show-branch.txt:111
#, fuzzy, no-wrap, priority:100
msgid "--reflog[=<n>[,<base>]] [<ref>]"
msgstr "--reflog[=<n>[,<base>]] [<ref>]"

#. type: Plain text
#: en/git-show-branch.txt:117
#, priority:100
msgid "Shows <n> most recent ref-log entries for the given ref.  If <base> is given, <n> entries going back from that entry.  <base> can be specified as count or date.  When no explicit <ref> parameter is given, it defaults to the current branch (or `HEAD` if it is detached)."
msgstr ""

#. type: Plain text
#: en/git-show-branch.txt:122
#, priority:100
msgid "Color the status sign (one of these: `*` `!` `+` `-`) of each commit corresponding to the branch it's in.  The value must be always (the default), never, or auto."
msgstr ""

#. type: Plain text
#: en/git-show-branch.txt:127
#, priority:100
msgid "Turn off colored output, even when the configuration file gives the default to color output.  Same as `--color=never`."
msgstr ""

#. type: Plain text
#: en/git-show-branch.txt:130
#, priority:100
msgid "Note that --more, --list, --independent and --merge-base options are mutually exclusive."
msgstr ""

#. type: Plain text
#: en/git-show-branch.txt:139
#, priority:100
msgid "Given N <ref>s, the first N lines are the one-line description from their commit message. The branch head that is pointed at by $GIT_DIR/HEAD is prefixed with an asterisk `*` character while other heads are prefixed with a `!` character."
msgstr ""

#. type: Plain text
#: en/git-show-branch.txt:146
#, priority:100
msgid "Following these N lines, one-line log for each commit is displayed, indented N places.  If a commit is on the I-th branch, the I-th indentation character shows a `+` sign; otherwise it shows a space.  Merge commits are denoted by a `-` sign.  Each commit shows a short name that can be used as an extended SHA-1 to name that commit."
msgstr ""

#. type: Plain text
#: en/git-show-branch.txt:149
#, priority:100
msgid "The following example shows three branches, \"master\", \"fixes\" and \"mhf\":"
msgstr ""

#. type: delimited block -
#: en/git-show-branch.txt:155
#, fuzzy, no-wrap, priority:100
msgid ""
"$ git show-branch master fixes mhf\n"
"* [master] Add 'git show-branch'.\n"
" ! [fixes] Introduce \"reset type\" flag to \"git reset\"\n"
"  ! [mhf] Allow \"+remote:local\" refspec to cause --force when fetching.\n"
"---\n"
msgstr ""
"$ git show-branch master fixes mhf\n"
"* [master] Add 'git show-branch'.\n"
" ! [fixes] Introduce \"reset type\" flag to \"git reset\"\n"
"  ! [mhf] Allow \"+remote:local\" refspec to cause --force when fetching.\n"
"---\n"

#. type: delimited block -
#: en/git-show-branch.txt:167
#, no-wrap, priority:100
msgid ""
"  + [mhf] Allow \"+remote:local\" refspec to cause --force when fetching.\n"
"  + [mhf~1] Use git-octopus when pulling more than one heads.\n"
" +  [fixes] Introduce \"reset type\" flag to \"git reset\"\n"
"  + [mhf~2] \"git fetch --force\".\n"
"  + [mhf~3] Use .git/remote/origin, not .git/branches/origin.\n"
"  + [mhf~4] Make \"git pull\" and \"git fetch\" default to origin\n"
"  + [mhf~5] Infamous 'octopus merge'\n"
"  + [mhf~6] Retire git-parse-remote.\n"
"  + [mhf~7] Multi-head fetch.\n"
"  + [mhf~8] Start adding the $GIT_DIR/remotes/ support.\n"
"*++ [master] Add 'git show-branch'.\n"
msgstr ""

#. type: Plain text
#: en/git-show-branch.txt:174
#, priority:100
msgid "These three branches all forked from a common commit, [master], whose commit message is \"Add \\'git show-branch'\".  The \"fixes\" branch adds one commit \"Introduce \"reset type\" flag to \"git reset\"\". The \"mhf\" branch adds many other commits.  The current branch is \"master\"."
msgstr ""

#. type: Plain text
#: en/git-show-branch.txt:182
#, priority:100
msgid "If you keep your primary branches immediately under `refs/heads`, and topic branches in subdirectories of it, having the following in the configuration file may help:"
msgstr ""

#. type: delimited block -
#: en/git-show-branch.txt:187
#, no-wrap, priority:100
msgid ""
"[showbranch]\n"
"\tdefault = --topo-order\n"
"\tdefault = heads/*\n"
msgstr ""

#. type: Plain text
#: en/git-show-branch.txt:193
#, priority:100
msgid "With this, `git show-branch` without extra parameters would show only the primary branches.  In addition, if you happen to be on your topic branch, it is shown as well."
msgstr ""

#. type: delimited block -
#: en/git-show-branch.txt:196
#, fuzzy, no-wrap, priority:100
msgid "$ git show-branch --reflog=\"10,1 hour ago\" --list master\n"
msgstr "$ git show-branch --reflog=\"10,1 hour ago\" --list master\n"

#. type: Plain text
#: en/git-show-branch.txt:201
#, priority:100
msgid "shows 10 reflog entries going back from the tip as of 1 hour ago.  Without `--list`, the output also shows how these tips are topologically related with each other."
msgstr ""

#. type: Title =
#: en/git-show-index.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-show-index(1)"
msgstr "git-show-index(1)"

#. type: Plain text
#: en/git-show-index.txt:7
#, priority:100
msgid "git-show-index - Show packed archive index"
msgstr ""

#. type: Plain text
#: en/git-show-index.txt:13
#, fuzzy, no-wrap, priority:100
msgid "'git show-index' [--object-format=<hash-algorithm>]\n"
msgstr "'git show-index' [--object-format=<hash-algorithm>]\n"

#. type: Plain text
#: en/git-show-index.txt:22
#, priority:100
msgid "Read the `.idx` file for a Git packfile (created with linkgit:git-pack-objects[1] or linkgit:git-index-pack[1]) from the standard input, and dump its contents. The output consists of one object per line, with each line containing two or three space-separated columns:"
msgstr ""

#. type: Plain text
#: en/git-show-index.txt:25
#, priority:100
msgid "the first column is the offset in bytes of the object within the corresponding packfile"
msgstr ""

#. type: Plain text
#: en/git-show-index.txt:27
#, priority:100
msgid "the second column is the object id of the object"
msgstr ""

#. type: Plain text
#: en/git-show-index.txt:30
#, priority:100
msgid "if the index version is 2 or higher, the third column contains the CRC32 of the object data"
msgstr ""

#. type: Plain text
#: en/git-show-index.txt:34
#, priority:100
msgid "The objects are output in the order in which they are found in the index file, which should be (in a correctly constructed file) sorted by object id."
msgstr ""

#. type: Plain text
#: en/git-show-index.txt:38
#, priority:100
msgid "Note that you can get more information on a packfile by calling linkgit:git-verify-pack[1]. However, as this command considers only the index file itself, it's both faster and more flexible."
msgstr ""

#. type: Plain text
#: en/git-show-index.txt:47
#, fuzzy, priority:100
#| msgid "Specify the given object format (hash algorithm) for the repository.  The valid values are 'sha1' and (if enabled) 'sha256'.  'sha1' is the default."
msgid "Specify the given object format (hash algorithm) for the index file.  The valid values are 'sha1' and (if enabled) 'sha256'.  The default is the algorithm for the current repository (set by `extensions.objectFormat`), or 'sha1' if no value is set or outside a repository.."
msgstr "指定存储库的对象格式（哈希算法）。有效值为 'sha1' 和（如果启用）'sha256'。'sha1' 是默认值。"

#. type: Title =
#: en/git-show-ref.txt:2
#, ignore-same, no-wrap, priority:80
msgid "git-show-ref(1)"
msgstr "git-show-ref(1)"

#. type: Plain text
#: en/git-show-ref.txt:7
#, fuzzy, priority:80
msgid "git-show-ref - List references in a local repository"
msgstr "git-show-ref - List references in a local repository"

#. type: Plain text
#: en/git-show-ref.txt:15
#, fuzzy, ignore-ellipsis, no-wrap, priority:80
msgid ""
"'git show-ref' [-q | --quiet] [--verify] [--head] [-d | --dereference]\n"
"\t     [-s | --hash[=<n>]] [--abbrev[=<n>]] [--tags]\n"
"\t     [--heads] [--] [<pattern>...]\n"
"'git show-ref' --exclude-existing[=<pattern>]\n"
msgstr ""
"'git show-ref' [-q|--quiet] [--verify] [--head] [-d|--dereference]\n"
"\t     [-s|--hash[=<n>]] [--abbrev[=<n>]] [--tags]\n"
"\t     [--heads] [--] [<pattern>...]\n"
"'git show-ref' --exclude-existing[=<pattern>]\n"

#. type: Plain text
#: en/git-show-ref.txt:23
#, priority:80
msgid "Displays references available in a local repository along with the associated commit IDs. Results can be filtered using a pattern and tags can be dereferenced into object IDs. Additionally, it can be used to test whether a particular ref exists."
msgstr ""

#. type: Plain text
#: en/git-show-ref.txt:25
#, priority:80
msgid "By default, shows the tags, heads, and remote refs."
msgstr ""

#. type: Plain text
#: en/git-show-ref.txt:29
#, fuzzy, priority:80
msgid "The `--exclude-existing` form is a filter that does the inverse. It reads refs from stdin, one ref per line, and shows those that don't exist in the local repository."
msgstr "——exclude-existing 表单是一个执行相反操作的过滤器。它从 stdin 读取 refs (每行一个 ref)，并显示本地仓库中不存在的 refs。"

#. type: Plain text
#: en/git-show-ref.txt:32
#, priority:80
msgid "Use of this utility is encouraged in favor of directly accessing files under the `.git` directory."
msgstr ""

#. type: Labeled list
#: en/git-show-ref.txt:36
#, ignore-same, no-wrap, priority:80
msgid "--head"
msgstr "--head"

#. type: Plain text
#: en/git-show-ref.txt:39
#, priority:80
msgid "Show the HEAD reference, even if it would normally be filtered out."
msgstr "显示 HEAD 参考，即使它通常会被过滤掉。"

#. type: Plain text
#: en/git-show-ref.txt:46
#, priority:80
msgid "Limit to \"refs/heads\" and \"refs/tags\", respectively.  These options are not mutually exclusive; when given both, references stored in \"refs/heads\" and \"refs/tags\" are displayed."
msgstr ""

#. type: Labeled list
#: en/git-show-ref.txt:48
#, ignore-same, no-wrap, priority:80
msgid "--dereference"
msgstr "--dereference"

#. type: Plain text
#: en/git-show-ref.txt:52
#, priority:80
msgid "Dereference tags into object IDs as well. They will be shown with `{caret}{}` appended."
msgstr ""

#. type: Labeled list
#: en/git-show-ref.txt:54
#, fuzzy, no-wrap, priority:80
msgid "--hash[=<n>]"
msgstr "--hash[=<n>]"

#. type: Plain text
#: en/git-show-ref.txt:58
#, priority:80
msgid "Only show the OID, not the reference name. When combined with `--dereference`, the dereferenced tag will still be shown after the OID."
msgstr ""

#. type: Plain text
#: en/git-show-ref.txt:64
#, priority:80
msgid "Enable stricter reference checking by requiring an exact ref path.  Aside from returning an error code of 1, it will also print an error message if `--quiet` was not specified."
msgstr ""

#. type: Plain text
#: en/git-show-ref.txt:69
#, priority:80
msgid "Abbreviate the object name.  When using `--hash`, you do not have to say `--hash --abbrev`; `--hash=n` would do."
msgstr ""

#. type: Plain text
#: en/git-show-ref.txt:75
#, priority:80
msgid "Do not print any results to stdout. When combined with `--verify`, this can be used to silently check if a reference exists."
msgstr ""

#. type: Labeled list
#: en/git-show-ref.txt:76
#, fuzzy, no-wrap, priority:80
msgid "--exclude-existing[=<pattern>]"
msgstr "--exclude-existing[=<pattern>]"

#. type: Plain text
#: en/git-show-ref.txt:81
#, priority:80
msgid "Make `git show-ref` act as a filter that reads refs from stdin of the form `^(?:<anything>\\s)?<refname>(?:\\^{})?$` and performs the following actions on each:"
msgstr ""

#. type: Plain text
#: en/git-show-ref.txt:82
#, priority:80
msgid "strip `{caret}{}` at the end of line if any;"
msgstr ""

#. type: Plain text
#: en/git-show-ref.txt:83
#, priority:80
msgid "ignore if pattern is provided and does not head-match refname;"
msgstr ""

#. type: Plain text
#: en/git-show-ref.txt:84
#, priority:80
msgid "warn if refname is not a well-formed refname and skip;"
msgstr ""

#. type: Plain text
#: en/git-show-ref.txt:85
#, priority:80
msgid "ignore if refname is a ref that exists in the local repository;"
msgstr ""

#. type: Plain text
#: en/git-show-ref.txt:86
#, priority:80
msgid "otherwise output the line."
msgstr ""

#. type: Plain text
#: en/git-show-ref.txt:95
#, priority:80
msgid "Show references matching one or more patterns. Patterns are matched from the end of the full name, and only complete parts are matched, e.g.  'master' matches 'refs/heads/master', 'refs/remotes/origin/master', 'refs/tags/jedi/master' but not 'refs/heads/mymaster' or 'refs/remotes/master/jedi'."
msgstr ""

#. type: delimited block -
#: en/git-show-ref.txt:103
#, fuzzy, no-wrap, priority:80
msgid "<oid> SP <ref> LF\n"
msgstr "\t'cat-blob' SP <dataref> LF\n"

#. type: Plain text
#: en/git-show-ref.txt:106 en/git-show-ref.txt:126
#, fuzzy, priority:80
msgid "For example,"
msgstr "例如："

#. type: delimited block -
#: en/git-show-ref.txt:117
#, ignore-ellipsis, no-wrap, priority:80
msgid ""
"$ git show-ref --head --dereference\n"
"832e76a9899f560a90ffd62ae2ce83bbeff58f54 HEAD\n"
"832e76a9899f560a90ffd62ae2ce83bbeff58f54 refs/heads/master\n"
"832e76a9899f560a90ffd62ae2ce83bbeff58f54 refs/heads/origin\n"
"3521017556c5de4159da4615a39fa4d5d2c279b5 refs/tags/v0.99.9c\n"
"6ddc0964034342519a87fe013781abf31c6db6ad refs/tags/v0.99.9c^{}\n"
"055e4ae3ae6eb344cbabf2a5256a49ea66040131 refs/tags/v1.0rc4\n"
"423325a2d24638ddcc82ce47be5e40be550f4507 refs/tags/v1.0rc4^{}\n"
"...\n"
msgstr ""

#. type: Plain text
#: en/git-show-ref.txt:120
#, priority:80
msgid "When using `--hash` (and not `--dereference`), the output is in the format:"
msgstr ""

#. type: delimited block -
#: en/git-show-ref.txt:123
#, no-wrap, priority:80
msgid "<oid> LF\n"
msgstr ""

#. type: delimited block -
#: en/git-show-ref.txt:133
#, fuzzy, ignore-ellipsis, no-wrap, priority:80
msgid ""
"$ git show-ref --heads --hash\n"
"2e3ba0114a1f52b47df29743d6915d056be13278\n"
"185008ae97960c8d551adcd9e23565194651b5d1\n"
"03adf42c988195b50e1a1935ba5fcbc39b2b029b\n"
"...\n"
msgstr ""
"$ git show-ref --heads --hash\n"
"2e3ba0114a1f52b47df29743d6915d056be13278\n"
"185008ae97960c8d551adcd9e23565194651b5d1\n"
"03adf42c988195b50e1a1935ba5fcbc39b2b029b\n"
"...\n"

#. type: Plain text
#: en/git-show-ref.txt:141
#, priority:80
msgid "To show all references called \"master\", whether tags or heads or anything else, and regardless of how deep in the reference naming hierarchy they are, use:"
msgstr ""

#. type: delimited block -
#: en/git-show-ref.txt:144
#, no-wrap, priority:80
msgid "\tgit show-ref master\n"
msgstr ""

#. type: Plain text
#: en/git-show-ref.txt:148
#, priority:80
msgid "This will show \"refs/heads/master\" but also \"refs/remote/other-repo/master\", if such references exists."
msgstr ""

#. type: Plain text
#: en/git-show-ref.txt:150
#, priority:80
msgid "When using the `--verify` flag, the command requires an exact path:"
msgstr ""

#. type: delimited block -
#: en/git-show-ref.txt:153
#, fuzzy, no-wrap, priority:80
msgid "\tgit show-ref --verify refs/heads/master\n"
msgstr "\tgit show-ref --verify refs/heads/master\n"

#. type: Plain text
#: en/git-show-ref.txt:156
#, priority:80
msgid "will only match the exact branch called \"master\"."
msgstr ""

#. type: Plain text
#: en/git-show-ref.txt:159
#, priority:80
msgid "If nothing matches, `git show-ref` will return an error code of 1, and in the case of verification, it will show an error message."
msgstr ""

#. type: Plain text
#: en/git-show-ref.txt:162
#, priority:80
msgid "For scripting, you can ask it to be quiet with the `--quiet` flag, which allows you to do things like"
msgstr ""

#. type: delimited block -
#: en/git-show-ref.txt:166
#, fuzzy, no-wrap, priority:80
msgid ""
"\tgit show-ref --quiet --verify -- \"refs/heads/$headname\" ||\n"
"\t\techo \"$headname is not a valid branch\"\n"
msgstr ""
"\tgit show-ref --quiet --verify -- \"refs/heads/$headname\" ||\n"
"\t\techo \"$headname is not a valid branch\"\n"

#. type: Plain text
#: en/git-show-ref.txt:171
#, priority:80
msgid "to check whether a particular branch exists or not (notice how we don't actually want to show any results, and we want to use the full refname for it in order to not trigger the problem with ambiguous partial matches)."
msgstr ""

#. type: Plain text
#: en/git-show-ref.txt:175
#, priority:80
msgid "To show only tags, or only proper branch heads, use `--tags` and/or `--heads` respectively (using both means that it shows tags and heads, but not other random references under the refs/ subdirectory)."
msgstr ""

#. type: Plain text
#: en/git-show-ref.txt:178
#, priority:80
msgid "To do automatic tag object dereferencing, use the `-d` or `--dereference` flag, so you can do"
msgstr ""

#. type: delimited block -
#: en/git-show-ref.txt:181
#, no-wrap, priority:80
msgid "\tgit show-ref --tags --dereference\n"
msgstr ""

#. type: Plain text
#: en/git-show-ref.txt:184
#, priority:80
msgid "to get a listing of all tags together with what they dereference."
msgstr ""

#. type: Plain text
#: en/git-show-ref.txt:188
#, fuzzy, priority:80
msgid "`.git/refs/*`, `.git/packed-refs`"
msgstr "`.git/refs/*`, `.git/packed-refs`"

#. type: Plain text
#: en/git-show-ref.txt:195
#, ignore-same, priority:80
msgid "linkgit:git-for-each-ref[1], linkgit:git-ls-remote[1], linkgit:git-update-ref[1], linkgit:gitrepository-layout[5]"
msgstr "linkgit:git-for-each-ref[1], linkgit:git-ls-remote[1], linkgit:git-update-ref[1], linkgit:gitrepository-layout[5]"

#. type: Title =
#: en/git-show.txt:2
#, ignore-same, no-wrap, priority:240
msgid "git-show(1)"
msgstr "git-show(1)"

#. type: Plain text
#: en/git-show.txt:7
#, fuzzy, priority:240
msgid "git-show - Show various types of objects"
msgstr "git-show - Show various types of objects"

#. type: Plain text
#: en/git-show.txt:13
#, fuzzy, ignore-ellipsis, no-wrap, priority:240
msgid "'git show' [<options>] [<object>...]\n"
msgstr "'git show' [<options>] [<object>...]\n"

#. type: Plain text
#: en/git-show.txt:17
#, priority:240
msgid "Shows one or more objects (blobs, trees, tags and commits)."
msgstr "显示一个或多个对象（Blobs、树、标签和提交）。"

#. type: Plain text
#: en/git-show.txt:21
#, fuzzy, priority:240
msgid "For commits it shows the log message and textual diff. It also presents the merge commit in a special format as produced by 'git diff-tree --cc'."
msgstr "对于提交，它显示日志信息和文本差异。并会以一种特殊的格式显示合并提交，就像 \"git diff-tree --cc \"所产生的信息那样。"

#. type: Plain text
#: en/git-show.txt:23
#, priority:240
msgid "For tags, it shows the tag message and the referenced objects."
msgstr "对于标签，它显示标签信息和引用的对象。"

#. type: Plain text
#: en/git-show.txt:26
#, priority:240
msgid "For trees, it shows the names (equivalent to 'git ls-tree' with --name-only)."
msgstr "对于目录树，它显示名字（相当于'git ls-tree'添加了--name-only选项）。"

#. type: Plain text
#: en/git-show.txt:28
#, priority:240
msgid "For plain blobs, it shows the plain contents."
msgstr "对于普通二进制对象，它显示普通内容。"

#. type: Plain text
#: en/git-show.txt:31
#, priority:240
msgid "The command takes options applicable to the 'git diff-tree' command to control how the changes the commit introduces are shown."
msgstr "该命令采用适用于'git diff-tree'命令的选项来控制提交所带来的变化的显示方式。"

#. type: Plain text
#: en/git-show.txt:33
#, priority:240
msgid "This manual page describes only the most frequently used options."
msgstr "本手册页只描述了最常用的选项。"

#. type: Labeled list
#: en/git-show.txt:37
#, ignore-ellipsis, no-wrap, priority:240
msgid "<object>..."
msgstr "<对象>..."

#. type: Plain text
#: en/git-show.txt:41
#, priority:240
msgid "The names of objects to show (defaults to 'HEAD').  For a more complete list of ways to spell object names, see \"SPECIFYING REVISIONS\" section in linkgit:gitrevisions[7]."
msgstr "要显示的对象的名称（默认为'HEAD'）。  更完整的对象名称拼写方式列表，请参见 linkgit:gitrevisions[7] 中的 \"特别修订\" 部分。"

#. type: Plain text
#: en/git-show.txt:52
#, priority:240
msgid "The options below can be used to change the way `git show` generates diff output."
msgstr "下面的选项可以用来改变`git show`生成差异输出的方式。"

#. type: Labeled list
#: en/git-show.txt:63
#, fuzzy, no-wrap, priority:240
msgid "`git show v1.0.0`"
msgstr "`git show v1.0.0`"

#. type: Plain text
#: en/git-show.txt:66
#, priority:240
msgid "Shows the tag `v1.0.0`, along with the object the tags points at."
msgstr "显示标签`v1.0.0`，以及标签指向的对象。"

#. type: Labeled list
#: en/git-show.txt:67
#, fuzzy, no-wrap, priority:240
msgid "`git show v1.0.0^{tree}`"
msgstr "`git show v1.0.0^{tree}`"

#. type: Plain text
#: en/git-show.txt:69
#, priority:240
msgid "Shows the tree pointed to by the tag `v1.0.0`."
msgstr "显示标签`v1.0.0`所指向的树。"

#. type: Labeled list
#: en/git-show.txt:70
#, fuzzy, no-wrap, priority:240
msgid "`git show -s --format=%s v1.0.0^{commit}`"
msgstr "`git show -s --format=%s v1.0.0^{commit}`"

#. type: Plain text
#: en/git-show.txt:73
#, priority:240
msgid "Shows the subject of the commit pointed to by the tag `v1.0.0`."
msgstr "显示由标签`v1.0.0`指向的提交的主题。"

#. type: Labeled list
#: en/git-show.txt:74
#, no-wrap, priority:240
msgid "`git show next~10:Documentation/README`"
msgstr "`git show next~10:Documentation/README`"

#. type: Plain text
#: en/git-show.txt:78
#, priority:240
msgid "Shows the contents of the file `Documentation/README` as they were current in the 10th last commit of the branch `next`."
msgstr "显示`Documentation/README`文件的内容，因为它们在分支`next`的最后10次提交中是当前的。"

#. type: Labeled list
#: en/git-show.txt:79
#, fuzzy, no-wrap, priority:240
msgid "`git show master:Makefile master:t/Makefile`"
msgstr "`git show master:Makefile master:t/Makefile`"

#. type: Plain text
#: en/git-show.txt:82
#, priority:240
msgid "Concatenates the contents of said Makefiles in the head of the branch `master`."
msgstr "将上述Makefiles的内容串联在分支`master`的头部。"

#. type: Title =
#: en/git-sh-setup.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-sh-setup(1)"
msgstr "git-sh-setup(1)"

#. type: Plain text
#: en/git-sh-setup.txt:7
#, fuzzy, priority:100
msgid "git-sh-setup - Common Git shell script setup code"
msgstr "git-sh-setup - Common Git shell script setup code"

#. type: Plain text
#: en/git-sh-setup.txt:12
#, fuzzy, no-wrap, priority:100
msgid "'. \"$(git --exec-path)/git-sh-setup\"'\n"
msgstr "'. \"$(git --exec-path)/git-sh-setup\"'\n"

#. type: Plain text
#: en/git-sh-setup.txt:23
#, fuzzy, priority:100
msgid "The 'git sh-setup' scriptlet is designed to be sourced (using `.`) by other shell scripts to set up some variables pointing at the normal Git directories and a few helper shell functions."
msgstr "The 'git sh-setup' scriptlet is designed to be sourced (using `.`) by other shell scripts to set up some variables pointing at the normal Git directories and a few helper shell functions."

#. type: Plain text
#: en/git-sh-setup.txt:29
#, priority:100
msgid "Before sourcing it, your script should set up a few variables; `USAGE` (and `LONG_USAGE`, if any) is used to define message given by `usage()` shell function.  `SUBDIRECTORY_OK` can be set if the script can run from a subdirectory of the working tree (some commands do not)."
msgstr ""

#. type: Plain text
#: en/git-sh-setup.txt:32
#, priority:100
msgid "The scriptlet sets `GIT_DIR` and `GIT_OBJECT_DIRECTORY` shell variables, but does *not* export them to the environment."
msgstr ""

#. type: Labeled list
#: en/git-sh-setup.txt:36
#, ignore-same, no-wrap, priority:100
msgid "die"
msgstr "die"

#. type: Plain text
#: en/git-sh-setup.txt:39
#, priority:100
msgid "exit after emitting the supplied error message to the standard error stream."
msgstr ""

#. type: Labeled list
#: en/git-sh-setup.txt:40
#, ignore-same, no-wrap, priority:100
msgid "usage"
msgstr "usage"

#. type: Plain text
#: en/git-sh-setup.txt:42
#, priority:100
msgid "die with the usage message."
msgstr ""

#. type: Labeled list
#: en/git-sh-setup.txt:43
#, ignore-same, no-wrap, priority:100
msgid "set_reflog_action"
msgstr "set_reflog_action"

#. type: Plain text
#: en/git-sh-setup.txt:49
#, priority:100
msgid "Set `GIT_REFLOG_ACTION` environment to a given string (typically the name of the program) unless it is already set.  Whenever the script runs a `git` command that updates refs, a reflog entry is created using the value of this string to leave the record of what command updated the ref."
msgstr ""

#. type: Labeled list
#: en/git-sh-setup.txt:50
#, ignore-same, no-wrap, priority:100
msgid "git_editor"
msgstr "git_editor"

#. type: Plain text
#: en/git-sh-setup.txt:54
#, priority:100
msgid "runs an editor of user's choice (GIT_EDITOR, core.editor, VISUAL or EDITOR) on a given file, but error out if no editor is specified and the terminal is dumb."
msgstr ""

#. type: Labeled list
#: en/git-sh-setup.txt:55
#, fuzzy, no-wrap, priority:100
msgid "is_bare_repository"
msgstr "is_bare_repository"

#. type: Plain text
#: en/git-sh-setup.txt:59
#, priority:100
msgid "outputs `true` or `false` to the standard output stream to indicate if the repository is a bare repository (i.e. without an associated working tree)."
msgstr ""

#. type: Labeled list
#: en/git-sh-setup.txt:60
#, ignore-same, no-wrap, priority:100
msgid "cd_to_toplevel"
msgstr "cd_to_toplevel"

#. type: Plain text
#: en/git-sh-setup.txt:62
#, priority:100
msgid "runs chdir to the toplevel of the working tree."
msgstr "运行 chdir 到工作树的顶层。"

#. type: Labeled list
#: en/git-sh-setup.txt:63
#, ignore-same, no-wrap, priority:100
msgid "require_work_tree"
msgstr "require_work_tree"

#. type: Plain text
#: en/git-sh-setup.txt:66
#, priority:100
msgid "checks if the current directory is within the working tree of the repository, and otherwise dies."
msgstr ""

#. type: Labeled list
#: en/git-sh-setup.txt:67
#, ignore-same, no-wrap, priority:100
msgid "require_work_tree_exists"
msgstr "require_work_tree_exists"

#. type: Plain text
#: en/git-sh-setup.txt:72
#, priority:100
msgid "checks if the working tree associated with the repository exists, and otherwise dies.  Often done before calling cd_to_toplevel, which is impossible to do if there is no working tree."
msgstr ""

#. type: Labeled list
#: en/git-sh-setup.txt:73
#, no-wrap, priority:100
msgid "require_clean_work_tree <action> [<hint>]"
msgstr ""

#. type: Plain text
#: en/git-sh-setup.txt:78
#, priority:100
msgid "checks that the working tree and index associated with the repository have no uncommitted changes to tracked files.  Otherwise it emits an error message of the form `Cannot <action>: <reason>. <hint>`, and dies.  Example:"
msgstr ""

#. type: delimited block -
#: en/git-sh-setup.txt:81
#, no-wrap, priority:100
msgid "require_clean_work_tree rebase \"Please commit or stash them.\"\n"
msgstr ""

#. type: Labeled list
#: en/git-sh-setup.txt:83
#, ignore-same, no-wrap, priority:100
msgid "get_author_ident_from_commit"
msgstr "get_author_ident_from_commit"

#. type: Plain text
#: en/git-sh-setup.txt:86
#, priority:100
msgid "outputs code for use with eval to set the GIT_AUTHOR_NAME, GIT_AUTHOR_EMAIL and GIT_AUTHOR_DATE variables for a given commit."
msgstr ""

#. type: Labeled list
#: en/git-sh-setup.txt:87
#, ignore-same, no-wrap, priority:100
msgid "create_virtual_base"
msgstr "create_virtual_base"

#. type: Plain text
#: en/git-sh-setup.txt:92
#, priority:100
msgid "modifies the first file so only lines in common with the second file remain. If there is insufficient common material, then the first file is left empty. The result is suitable as a virtual base input for a 3-way merge."
msgstr ""

#. type: Title =
#: en/git-stage.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-stage(1)"
msgstr "git-stage(1)"

#. type: Plain text
#: en/git-stage.txt:7
#, priority:100
msgid "git-stage - Add file contents to the staging area"
msgstr ""

#. type: Plain text
#: en/git-stage.txt:13
#, fuzzy, ignore-ellipsis, no-wrap, priority:100
msgid "'git stage' <arg>...\n"
msgstr "'git rev-parse' [<options>] <args>...\n"

#. type: Plain text
#: en/git-stage.txt:20
#, priority:100
msgid "This is a synonym for linkgit:git-add[1].  Please refer to the documentation of that command."
msgstr ""

#. type: Title =
#: en/git-stash.txt:2
#, ignore-same, no-wrap, priority:240
msgid "git-stash(1)"
msgstr "git-stash(1)"

#. type: Plain text
#: en/git-stash.txt:7
#, priority:240
msgid "git-stash - Stash the changes in a dirty working directory away"
msgstr "git-stash - 将变化藏在一个脏工作区中"

#. type: Plain text
#: en/git-stash.txt:26
#, fuzzy, ignore-ellipsis, no-wrap, priority:240
msgid ""
"'git stash' list [<log-options>]\n"
"'git stash' show [-u | --include-untracked | --only-untracked] [<diff-options>] [<stash>]\n"
"'git stash' drop [-q | --quiet] [<stash>]\n"
"'git stash' pop [--index] [-q | --quiet] [<stash>]\n"
"'git stash' apply [--index] [-q | --quiet] [<stash>]\n"
"'git stash' branch <branchname> [<stash>]\n"
"'git stash' [push [-p | --patch] [-S | --staged] [-k | --[no-]keep-index] [-q | --quiet]\n"
"\t     [-u | --include-untracked] [-a | --all] [(-m | --message) <message>]\n"
"\t     [--pathspec-from-file=<file> [--pathspec-file-nul]]\n"
"\t     [--] [<pathspec>...]]\n"
"'git stash' save [-p | --patch] [-S | --staged] [-k | --[no-]keep-index] [-q | --quiet]\n"
"\t     [-u | --include-untracked] [-a | --all] [<message>]\n"
"'git stash' clear\n"
"'git stash' create [<message>]\n"
"'git stash' store [(-m | --message) <message>] [-q | --quiet] <commit>\n"
msgstr ""
"'git stash' list [<log-options>]\n"
"'git stash' show [-u | --include-untracked | --only-untracked] [<diff-options>] [<stash>]\n"
"'git stash' drop [-q | --quiet] [<stash>]\n"
"'git stash' pop [--index] [-q | --quiet] [<stash>]\n"
"'git stash' apply [--index] [-q | --quiet] [<stash>]\n"
"'git stash' branch <branchname> [<stash>]\n"
"'git stash' [push [-p | --patch] [-S | --staged] [-k | --[no-]keep-index] [-q | --quiet]\n"
"\t     [-u | --include-untracked] [-a | --all] [(-m | --message) <message>]\n"
"\t     [--pathspec-from-file=<file> [--pathspec-file-nul]]\n"
"\t     [--] [<pathspec>...]]\n"
"'git stash' save [-p | --patch] [-S | --staged] [-k | --[no-]keep-index] [-q | --quiet]\n"
"\t     [-u | --include-untracked] [-a | --all] [<message>]\n"
"'git stash' clear\n"
"'git stash' create [<message>]\n"
"'git stash' store [(-m | --message) <message>] [-q | --quiet] <commit>\n"

#. type: Plain text
#: en/git-stash.txt:34
#, priority:240
msgid "Use `git stash` when you want to record the current state of the working directory and the index, but want to go back to a clean working directory.  The command saves your local modifications away and reverts the working directory to match the `HEAD` commit."
msgstr "当你想记录工作目录和索引的当前状态，但又想回到一个干净的工作目录时，请使用`git stash`。  该命令将你的本地修改保存起来，并将工作目录还原为与`HEAD`提交相匹配。"

#. type: Plain text
#: en/git-stash.txt:42
#, ignore-ellipsis, priority:240
msgid "The modifications stashed away by this command can be listed with `git stash list`, inspected with `git stash show`, and restored (potentially on top of a different commit) with `git stash apply`.  Calling `git stash` without any arguments is equivalent to `git stash push`.  A stash is by default listed as \"WIP on 'branchname' ...\", but you can give a more descriptive message on the command line when you create one."
msgstr "这个命令所存储的修改可以用`git stash list`列出，用`git stash show`检查，用`git stash apply`恢复（可能是在不同的提交之上）。  在没有任何参数的情况下调用`git stash`等同于`git stash push`。  默认情况下，储藏库被列为 \"WIP on 'branchname' ...\"，但你可以在创建储藏库时在命令行中给出更多描述性信息。"

#. type: Plain text
#: en/git-stash.txt:49
#, priority:240
msgid "The latest stash you created is stored in `refs/stash`; older stashes are found in the reflog of this reference and can be named using the usual reflog syntax (e.g. `stash@{0}` is the most recently created stash, `stash@{1}` is the one before it, `stash@{2.hours.ago}` is also possible). Stashes may also be referenced by specifying just the stash index (e.g. the integer `n` is equivalent to `stash@{n}`)."
msgstr "你最近创建的储藏库被保存在`refs/stash`中；旧的储藏库可以在这个引用的引用日志中找到，并且可以使用通常的引用日志语法来命名（例如，`stash@{0}`是最近创建的储藏库，`stash@{1}`是它之前的储藏库，`stash@{2.hours.ago}`也是可以的）。也可以通过指定储藏库的索引来引用储藏库（例如，整数`n`等同于`stash@{n}`）。"

#. type: Labeled list
#: en/git-stash.txt:53
#, fuzzy, ignore-ellipsis, no-wrap, priority:240
msgid "push [-p|--patch] [-S|--staged] [-k|--[no-]keep-index] [-u|--include-untracked] [-a|--all] [-q|--quiet] [(-m|--message) <message>] [--pathspec-from-file=<file> [--pathspec-file-nul]] [--] [<pathspec>...]"
msgstr "push [-p|--patch] [-S|--staged] [-k|--[no-]keep-index] [-u|--include-untracked] [-a|--all] [-q|--quiet] [-m|--message <message>] [--pathspec-from-file=<file> [--pathspec-file-nul]] [--] [<pathspec>...]"

#. type: Plain text
#: en/git-stash.txt:59
#, priority:240
msgid "Save your local modifications to a new 'stash entry' and roll them back to HEAD (in the working tree and in the index).  The <message> part is optional and gives the description along with the stashed state."
msgstr "将你的本地修改保存到一个新的 \"存储条目 \"中，并将它们回滚到 HEAD（在工作区和索引中）。  <信息>部分是可选的，它给出了描述和储藏的状态。"

#. type: Plain text
#: en/git-stash.txt:65
#, priority:240
msgid "For quickly making a snapshot, you can omit \"push\".  In this mode, non-option arguments are not allowed to prevent a misspelled subcommand from making an unwanted stash entry.  The two exceptions to this are `stash -p` which acts as alias for `stash push -p` and pathspec elements, which are allowed after a double hyphen `--` for disambiguation."
msgstr "为了快速制作快照，你可以省略 \"push\"。  在这种模式下，非选项参数是不允许的，以防止拼写错误的子命令产生不需要的储藏条目。  这方面的两个例外是`stash -p`，它作为`stash push -p`的别名，以及为消除歧义允许在双连字符`--`之后的路径规范元素。"

#. type: Labeled list
#: en/git-stash.txt:66
#, no-wrap, priority:240
msgid "save [-p|--patch] [-S|--staged] [-k|--[no-]keep-index] [-u|--include-untracked] [-a|--all] [-q|--quiet] [<message>]"
msgstr "save [-p|--patch] [-S|--staged] [-k|--[no-]keep-index] [-u|--include-untracked] [-a|--all] [-q|--quiet] [<信息>]"

#. type: Plain text
#: en/git-stash.txt:72
#, priority:240
msgid "This option is deprecated in favour of 'git stash push'.  It differs from \"stash push\" in that it cannot take pathspec.  Instead, all non-option arguments are concatenated to form the stash message."
msgstr "该选项已被弃用，改为 \"git stash push\"。  它与 \"stash push \"的不同之处在于，它不能接受路径规范。  取而代之的是，所有非选项的参数都被串联起来，形成储藏消息。"

#. type: Labeled list
#: en/git-stash.txt:73
#, no-wrap, priority:240
msgid "list [<log-options>]"
msgstr "list [<日志选项>]"

#. type: Plain text
#: en/git-stash.txt:80
#, priority:240
msgid "List the stash entries that you currently have.  Each 'stash entry' is listed with its name (e.g. `stash@{0}` is the latest entry, `stash@{1}` is the one before, etc.), the name of the branch that was current when the entry was made, and a short description of the commit the entry was based on."
msgstr "列出你目前拥有的储藏目录。  每个 \"储藏目录 \"都列出了它的名字（例如，`stash@{0}`是最新的条目，`stash@{1}`是之前的条目，等等），条目产生时的分支名称，以及该条目所基于的提交的简短描述。"

#. type: delimited block -
#: en/git-stash.txt:84
#, fuzzy, ignore-ellipsis, no-wrap, priority:240
msgid ""
"stash@{0}: WIP on submit: 6ebd0e2... Update git-stash documentation\n"
"stash@{1}: On master: 9cc0589... Add git-stash\n"
msgstr ""
"stash@{0}: WIP on submit: 6ebd0e2... Update git-stash documentation\n"
"stash@{1}: On master: 9cc0589... Add git-stash\n"

#. type: Plain text
#: en/git-stash.txt:88
#, priority:240
msgid "The command takes options applicable to the 'git log' command to control what is shown and how. See linkgit:git-log[1]."
msgstr "该命令采用适用于 'git log' 命令的选项来控制显示的内容和方式。参见 linkgit:git-log[1]。"

#. type: Labeled list
#: en/git-stash.txt:89
#, no-wrap, priority:240
msgid "show [-u|--include-untracked|--only-untracked] [<diff-options>] [<stash>]"
msgstr "show [-u|--include-untracked|--only-untracked] [<diff选项>] [<储藏目录>]"

#. type: Plain text
#: en/git-stash.txt:101
#, priority:240
msgid "Show the changes recorded in the stash entry as a diff between the stashed contents and the commit back when the stash entry was first created.  By default, the command shows the diffstat, but it will accept any format known to 'git diff' (e.g., `git stash show -p stash@{1}` to view the second most recent entry in patch form).  If no `<diff-option>` is provided, the default behavior will be given by the `stash.showStat`, and `stash.showPatch` config variables. You can also use `stash.showIncludeUntracked` to set whether `--include-untracked` is enabled by default."
msgstr "显示贮藏中记录的修改，作为贮藏内容与贮藏库条目首次创建时的提交之间的差异。  默认情况下，该命令显示diff统计，但它会接受 \"git diff \"已知的任何格式（例如，`git stash show -p stash@{1}`以补丁形式查看第二条最新条目）。  如果没有提供`<diff选项>`，默认行为将由`stash.showStat`和`stash.showPatch`配置变量给出。你也可以使用`stash.showIncludeUntracked`来设置是否默认启用`--include-untracked`。"

#. type: Labeled list
#: en/git-stash.txt:102
#, fuzzy, no-wrap, priority:240
msgid "pop [--index] [-q|--quiet] [<stash>]"
msgstr "pop [--index] [-q|--quiet] [<stash>]"

#. type: Plain text
#: en/git-stash.txt:108
#, priority:240
msgid "Remove a single stashed state from the stash list and apply it on top of the current working tree state, i.e., do the inverse operation of `git stash push`. The working directory must match the index."
msgstr "从贮藏库列表中移除一个单一的贮藏状态，并将其应用于当前工作区状态之上，也就是做`git stash push`的逆向操作。工作目录必须与索引匹配。"

#. type: Plain text
#: en/git-stash.txt:112
#, priority:240
msgid "Applying the state can fail with conflicts; in this case, it is not removed from the stash list. You need to resolve the conflicts by hand and call `git stash drop` manually afterwards."
msgstr "应用状态可能会因为冲突而失败；在这种情况下，它不会被从贮藏库列表中删除。你需要手动解决冲突，并在之后调用 `git stash drop`。"

#. type: Labeled list
#: en/git-stash.txt:113
#, fuzzy, no-wrap, priority:240
msgid "apply [--index] [-q|--quiet] [<stash>]"
msgstr "apply [--index] [-q|--quiet] [<stash>]"

#. type: Plain text
#: en/git-stash.txt:118
#, priority:240
msgid "Like `pop`, but do not remove the state from the stash list. Unlike `pop`, `<stash>` may be any commit that looks like a commit created by `stash push` or `stash create`."
msgstr "和 `pop` 一样，但不从贮藏库列表中删除该状态。与`pop`不同，`<贮藏项>`可以是任何看起来像由`stash push`或`stash create`创建的提交。"

#. type: Labeled list
#: en/git-stash.txt:119
#, no-wrap, priority:240
msgid "branch <branchname> [<stash>]"
msgstr "branch <分支名> [<贮藏项>]"

#. type: Plain text
#: en/git-stash.txt:126
#, priority:240
msgid "Creates and checks out a new branch named `<branchname>` starting from the commit at which the `<stash>` was originally created, applies the changes recorded in `<stash>` to the new working tree and index.  If that succeeds, and `<stash>` is a reference of the form `stash@{<revision>}`, it then drops the `<stash>`."
msgstr "创建并检查一个名为 `<分支名>` 的新分支，从最初创建 `<贮藏项>` 的提交开始，将 `<贮藏项>` 中记录的修改应用到新的工作树和索引。  如果成功了，并且`<贮藏项>`是`stash@{<版本>}`形式的引用，那么它将删除`<贮藏项>`。"

#. type: Plain text
#: en/git-stash.txt:132
#, priority:240
msgid "This is useful if the branch on which you ran `git stash push` has changed enough that `git stash apply` fails due to conflicts. Since the stash entry is applied on top of the commit that was HEAD at the time `git stash` was run, it restores the originally stashed state with no conflicts."
msgstr "如果你运行 `git stash push` 的分支发生了足够的变化，以至于 `git stash apply` 因冲突而失败，那么这就很有用。由于贮藏条目是在运行 `git stash` 时的当前分支提交之上应用的，它没有冲突地恢复了最初的贮藏状态。"

#. type: Labeled list
#: en/git-stash.txt:133
#, fuzzy, no-wrap, priority:240
msgid "clear"
msgstr "清除"

#. type: Plain text
#: en/git-stash.txt:137
#, priority:240
msgid "Remove all the stash entries. Note that those entries will then be subject to pruning, and may be impossible to recover (see 'Examples' below for a possible strategy)."
msgstr "删除所有的贮藏条目。直接切断任何联系，而且可能无法恢复（可能的策略见下面的 \"例子\"）。"

#. type: Labeled list
#: en/git-stash.txt:138
#, no-wrap, priority:240
msgid "drop [-q|--quiet] [<stash>]"
msgstr "Drop [-q|--quite] [<贮藏项>]"

#. type: Plain text
#: en/git-stash.txt:141
#, priority:240
msgid "Remove a single stash entry from the list of stash entries."
msgstr "从贮藏条目列表中删除一个单一的贮藏条目。"

#. type: Labeled list
#: en/git-stash.txt:142 en/git-update-ref.txt:108
#, ignore-same, no-wrap, priority:240
msgid "create"
msgstr "create"

#. type: Plain text
#: en/git-stash.txt:149
#, priority:240
msgid "Create a stash entry (which is a regular commit object) and return its object name, without storing it anywhere in the ref namespace.  This is intended to be useful for scripts.  It is probably not the command you want to use; see \"push\" above."
msgstr "创建一个贮藏条目（这是一个普通的提交对象），并返回其对象名称，而不将其存储在引用命名空间的任何地方。  这是为了对脚本有用。  你可能不想用这个命令；可以看看前面的 \"push\"。"

#. type: Labeled list
#: en/git-stash.txt:150
#, fuzzy, no-wrap, priority:240
msgid "store"
msgstr "商店"

#. type: Plain text
#: en/git-stash.txt:156
#, priority:240
msgid "Store a given stash created via 'git stash create' (which is a dangling merge commit) in the stash ref, updating the stash reflog.  This is intended to be useful for scripts.  It is probably not the command you want to use; see \"push\" above."
msgstr "将通过'git stash create'（这是一个悬空的合并提交）创建的特定贮藏库存储在贮藏库引用中，更新贮藏库参考文件。  这是为了对脚本有用。  这条命令可能不是你想要的；见上文\"push\"。"

#. type: Plain text
#: en/git-stash.txt:162 en/git-stash.txt:193 en/git-stash.txt:199 en/git-stash.txt:214
#, priority:240
msgid "This option is only valid for `push` and `save` commands."
msgstr "这个选项只对`push`和`save`命令有效。"

#. type: Plain text
#: en/git-stash.txt:165
#, priority:240
msgid "All ignored and untracked files are also stashed and then cleaned up with `git clean`."
msgstr "所有被忽略的和未被追踪的文件也被贮藏起来，然后用`git clean`来清理。"

#. type: Labeled list
#: en/git-stash.txt:167
#, ignore-same, no-wrap, priority:240
msgid "--include-untracked"
msgstr "--include-untracked"

#. type: Labeled list
#: en/git-stash.txt:168
#, ignore-same, no-wrap, priority:240
msgid "--no-include-untracked"
msgstr "--no-include-untracked"

#. type: Plain text
#: en/git-stash.txt:172
#, priority:240
msgid "When used with the `push` and `save` commands, all untracked files are also stashed and then cleaned up with `git clean`."
msgstr "当与`push`和`save`命令一起使用时，所有未被追踪的文件也被贮藏起来，然后用`git clean`来清理。"

#. type: Plain text
#: en/git-stash.txt:175
#, priority:240
msgid "When used with the `show` command, show the untracked files in the stash entry as part of the diff."
msgstr "当与`show`命令一起使用时，显示贮藏库条目中未被追踪的文件作为差异的一部分。"

#. type: Labeled list
#: en/git-stash.txt:176
#, ignore-same, no-wrap, priority:240
msgid "--only-untracked"
msgstr "--only-untracked"

#. type: Plain text
#: en/git-stash.txt:178
#, priority:240
msgid "This option is only valid for the `show` command."
msgstr "这个选项只对`show`命令有效。"

#. type: Plain text
#: en/git-stash.txt:180
#, priority:240
msgid "Show only the untracked files in the stash entry as part of the diff."
msgstr "只显示贮藏库条目中未被追踪的文件作为差异的一部分。"

#. type: Plain text
#: en/git-stash.txt:183
#, priority:240
msgid "This option is only valid for `pop` and `apply` commands."
msgstr "这个选项只对`pop`和`apply`命令有效。"

#. type: Plain text
#: en/git-stash.txt:188
#, priority:240
msgid "Tries to reinstate not only the working tree's changes, but also the index's ones. However, this can fail, when you have conflicts (which are stored in the index, where you therefore can no longer apply the changes as they were originally)."
msgstr "不仅试图恢复工作区的变化，而且恢复索引的变化。然而，这可能会在出现冲突时失败（这些冲突被存储在索引中，因此你不能再按原来的方式应用这些变化）。"

#. type: Labeled list
#: en/git-stash.txt:190
#, ignore-same, no-wrap, priority:240
msgid "--keep-index"
msgstr "--keep-index"

#. type: Labeled list
#: en/git-stash.txt:191
#, ignore-same, no-wrap, priority:240
msgid "--no-keep-index"
msgstr "--no-keep-index"

#. type: Plain text
#: en/git-stash.txt:195
#, priority:240
msgid "All changes already added to the index are left intact."
msgstr "所有已经添加到索引中的变化都保持原样。"

#. type: Plain text
#: en/git-stash.txt:207
#, priority:240
msgid "Interactively select hunks from the diff between HEAD and the working tree to be stashed.  The stash entry is constructed such that its index state is the same as the index state of your repository, and its worktree contains only the changes you selected interactively.  The selected changes are then rolled back from your worktree. See the ``Interactive Mode'' section of linkgit:git-add[1] to learn how to operate the `--patch` mode."
msgstr "交互式地从当前分支和工作区之间的差异中选择要存储的内容。  藏匿条目的构造是这样的：它的索引状态与你仓库的索引状态相同，它的工作区只包含你交互选择的变化。  被选中的修改会从你的工作区中回滚。参见 linkgit:git-add[1] 中的 ``互动模式''一节，了解如何操作`--patch`模式。"

#. type: Plain text
#: en/git-stash.txt:210
#, priority:240
msgid "The `--patch` option implies `--keep-index`.  You can use `--no-keep-index` to override this."
msgstr "选项`---patch`意味着`---keep-index`。  你可以使用`--no-keep-index`来覆盖它。"

#. type: Plain text
#: en/git-stash.txt:218
#, priority:240
msgid "Stash only the changes that are currently staged. This is similar to basic `git commit` except the state is committed to the stash instead of current branch."
msgstr "只存放当前分阶段的修改。这类似于基本的`git commit`，只不过是将状态提交到贮藏室而不是当前分支。"

#. type: Plain text
#: en/git-stash.txt:220
#, priority:240
msgid "The `--patch` option has priority over this one."
msgstr "`--patch`选项要优先于这个选项。"

#. type: Plain text
#: en/git-stash.txt:223 en/git-stash.txt:233 en/git-stash.txt:247 en/git-stash.txt:252
#, priority:240
msgid "This option is only valid for `push` command."
msgstr "这个选项只对`push`命令有效。"

#. type: Plain text
#: en/git-stash.txt:242
#, priority:240
msgid "This option is only valid for `apply`, `drop`, `pop`, `push`, `save`, `store` commands."
msgstr "这个选项只对`apply`、`drop`、`pop`、`push`、`save`、`store`命令有效。"

#. type: Plain text
#: en/git-stash.txt:249
#, priority:240
msgid "Separates pathspec from options for disambiguation purposes."
msgstr "为了消除歧义，将路径规范与选项分开。"

#. type: Plain text
#: en/git-stash.txt:257
#, priority:240
msgid "The new stash entry records the modified states only for the files that match the pathspec.  The index entries and working tree files are then rolled back to the state in HEAD only for these files, too, leaving files that do not match the pathspec intact."
msgstr "新的贮藏条目只记录了符合路径规范文件的修改状态。  然后索引条目和工作区文件也被回滚到当前分支中的状态，只留下不符合路径规范的文件。"

#. type: Labeled list
#: en/git-stash.txt:260
#, fuzzy, no-wrap, priority:240
msgid "<stash>"
msgstr "<stash>"

#. type: Plain text
#: en/git-stash.txt:263
#, priority:240
msgid "This option is only valid for `apply`, `branch`, `drop`, `pop`, `show` commands."
msgstr "这个选项只对`apply`、`branch`、`drop`、`pop`、`show`命令有效。"

#. type: Plain text
#: en/git-stash.txt:266
#, priority:240
msgid "A reference of the form `stash@{<revision>}`. When no `<stash>` is given, the latest stash is assumed (that is, `stash@{0}`)."
msgstr "一个形式为`stash@{<版本>}`的引用。如果没有给出`<贮藏项>`，则假定是最新的储藏库（即`stash@{0}`）。"

#. type: Plain text
#: en/git-stash.txt:275
#, priority:240
msgid "A stash entry is represented as a commit whose tree records the state of the working directory, and its first parent is the commit at `HEAD` when the entry was created.  The tree of the second parent records the state of the index when the entry is made, and it is made a child of the `HEAD` commit.  The ancestry graph looks like this:"
msgstr "一个贮藏库条目被表示为一个提交，它的目录树记录了工作目录的状态，它的第一个父节点是创建该条目时在`HEAD`的提交。  第二个父节点的树记录了条目生成时索引的状态，它是`HEAD`提交的一个子节点。  祖先图看起来像这样："

#. type: Plain text
#: en/git-stash.txt:279
#, no-wrap, priority:240
msgid ""
"            .----W\n"
"           /    /\n"
"     -----H----I\n"
msgstr ""
"            .----W\n"
"           /    /\n"
"     -----H----I\n"

#. type: Plain text
#: en/git-stash.txt:283
#, priority:240
msgid "where `H` is the `HEAD` commit, `I` is a commit that records the state of the index, and `W` is a commit that records the state of the working tree."
msgstr "其中`H`是`HEAD`提交，`I`是记录索引状态的提交，`W`是记录工作区状态的提交。"

#. type: Labeled list
#: en/git-stash.txt:288
#, no-wrap, priority:240
msgid "Pulling into a dirty tree"
msgstr "拉进一个脏目录树"

#. type: Plain text
#: en/git-stash.txt:294
#, priority:240
msgid "When you are in the middle of something, you learn that there are upstream changes that are possibly relevant to what you are doing.  When your local changes do not conflict with the changes in the upstream, a simple `git pull` will let you move forward."
msgstr "当你在做某件事的时候，你得知上游有一些变化可能与你正在做的事情有关。  当你的本地修改与上游的修改不冲突时，一个简单的`git pull'就可以让你继续前进。"

#. type: Plain text
#: en/git-stash.txt:299
#, priority:240
msgid "However, there are cases in which your local changes do conflict with the upstream changes, and `git pull` refuses to overwrite your changes.  In such a case, you can stash your changes away, perform a pull, and then unstash, like this:"
msgstr "然而，在有些情况下，你的本地修改确实与上游修改有冲突，而`git pull`拒绝覆盖你的修改。  在这种情况下，你可以把你的进度保存起来，执行一次拉取，然后再解开，像这样："

#. type: delimited block -
#: en/git-stash.txt:307
#, fuzzy, ignore-ellipsis, no-wrap, priority:240
msgid ""
"$ git pull\n"
" ...\n"
"file foobar not up to date, cannot merge.\n"
"$ git stash\n"
"$ git pull\n"
"$ git stash pop\n"
msgstr ""
"$ git pull\n"
" ...\n"
"file foobar not up to date, cannot merge.\n"
"$ git stash\n"
"$ git pull\n"
"$ git stash pop\n"

#. type: Plain text
#: en/git-stash.txt:315
#, priority:240
msgid "When you are in the middle of something, your boss comes in and demands that you fix something immediately.  Traditionally, you would make a commit to a temporary branch to store your changes away, and return to your original branch to make the emergency fix, like this:"
msgstr "当你正在做某件事的时候，你的老板来了，要求你立即修复某件事。  传统上，你会向一个临时分支提交，以储存你的修改，然后返回到你的原始分支进行紧急修复，就像这样："

#. type: delimited block -
#: en/git-stash.txt:326
#, ignore-ellipsis, no-wrap, priority:240
msgid ""
"# ... hack hack hack ...\n"
"$ git switch -c my_wip\n"
"$ git commit -a -m \"WIP\"\n"
"$ git switch master\n"
"$ edit emergency fix\n"
"$ git commit -a -m \"Fix in a hurry\"\n"
"$ git switch my_wip\n"
"$ git reset --soft HEAD^\n"
"# ... continue hacking ...\n"
msgstr ""
"# ... 嗨骇害 ...\n"
"$ git switch -c my_wip\n"
"$ git commit -a -m \"我待会还得写点东西\"\n"
"$ git switch master\n"
"$ edit emergency fix\n"
"$ git commit -a -m \"速速修复BUG\"\n"
"$ git switch my_wip\n"
"$ git reset --soft HEAD^\n"
"# ... 继续骇入 ...\n"

#. type: Plain text
#: en/git-stash.txt:329
#, priority:240
msgid "You can use 'git stash' to simplify the above, like this:"
msgstr "你可以用'git stash'来简化上述工作，像这样："

#. type: delimited block -
#: en/git-stash.txt:337
#, ignore-ellipsis, no-wrap, priority:240
msgid ""
"# ... hack hack hack ...\n"
"$ git stash\n"
"$ edit emergency fix\n"
"$ git commit -a -m \"Fix in a hurry\"\n"
"$ git stash pop\n"
"# ... continue hacking ...\n"
msgstr ""
"# ... 嗨骇害 ...\n"
"$ git stash\n"
"$ edit emergency fix\n"
"$ git commit -a -m \"紧急修复\"\n"
"$ git stash pop\n"
"# ... 继续骇入 ...\n"

#. type: Labeled list
#: en/git-stash.txt:339
#, fuzzy, no-wrap, priority:240
msgid "Testing partial commits"
msgstr "部分测试提交"

#. type: Plain text
#: en/git-stash.txt:344
#, priority:240
msgid "You can use `git stash push --keep-index` when you want to make two or more commits out of the changes in the work tree, and you want to test each change before committing:"
msgstr "当你想把工作区上的改动做两个或更多的提交，并且想在提交前测试每个改动时，你可以使用`git stash push --keep-index`："

#. type: delimited block -
#: en/git-stash.txt:355
#, ignore-ellipsis, no-wrap, priority:240
msgid ""
"# ... hack hack hack ...\n"
"$ git add --patch foo            # add just first part to the index\n"
"$ git stash push --keep-index    # save all other changes to the stash\n"
"$ edit/build/test first part\n"
"$ git commit -m 'First part'     # commit fully tested change\n"
"$ git stash pop                  # prepare to work on all other changes\n"
"# ... repeat above five steps until one commit remains ...\n"
"$ edit/build/test remaining parts\n"
"$ git commit foo -m 'Remaining parts'\n"
msgstr ""
"# ... 嗨骇害 ...\n"
"$ git add --patch foo # 仅将第一部分添加到索引中\n"
"$ git stash push --keep-index # 将所有其他改动保存到储藏室中\n"
"$ edit/build/test first part\n"
"$ git commit -m '第一个部分' # 提交完全测试过的改动\n"
"$ git stash pop # 准备处理所有其他改动\n"
"# ... 重复以上五个步骤，直到剩下一个提交...\n"
"$ 编辑/构建/测试剩余部分\n"
"$ git commit foo -m '剩余部分'。\n"

#. type: Labeled list
#: en/git-stash.txt:357
#, no-wrap, priority:240
msgid "Saving unrelated changes for future use"
msgstr "保存不相关的变化供将来使用"

#. type: Plain text
#: en/git-stash.txt:364
#, priority:240
msgid "When you are in the middle of massive changes and you find some unrelated issue that you don't want to forget to fix, you can do the change(s), stage them, and use `git stash push --staged` to stash them out for future use. This is similar to committing the staged changes, only the commit ends-up being in the stash and not on the current branch."
msgstr "当你在进行大规模修改时，发现一些不相关的问题，你不想忘记修复，你可以进行修改，将其分阶段，然后使用 `git stash push --staged` 将其存放起来，以便将来使用。这类似于提交阶段性修改，只是提交的结果是在贮藏库而不是在当前分支。"

#. type: delimited block -
#: en/git-stash.txt:373
#, fuzzy, ignore-ellipsis, no-wrap, priority:240
#| msgid ""
#| "# ... hack hack hack ...\n"
#| "$ git add --patch foo           # add unrelated changes to the index\n"
#| "$ git stash push --staged       # save these changes to the stash\n"
#| "# ... hack hack hack, finish curent changes ...\n"
#| "$ git commit -m 'Massive'       # commit fully tested changes\n"
#| "$ git switch fixup-branch       # switch to another branch\n"
#| "$ git stash pop                 # to finish work on the saved changes\n"
msgid ""
"# ... hack hack hack ...\n"
"$ git add --patch foo           # add unrelated changes to the index\n"
"$ git stash push --staged       # save these changes to the stash\n"
"# ... hack hack hack, finish current changes ...\n"
"$ git commit -m 'Massive'       # commit fully tested changes\n"
"$ git switch fixup-branch       # switch to another branch\n"
"$ git stash pop                 # to finish work on the saved changes\n"
msgstr ""
"# ... 嗨骇害 ...\n"
"$ git add --patch foo # 将不相关的改动添加到索引中\n"
"$ git stash push --staged # 将这些改动保存到储藏库中\n"
"# ... hack hack hack, finish curent changes ...\n"
"$ git commit -m '大规模测试' # 提交完全测试过的改动\n"
"$ git switch fixup-branch # 切换到另一个分支\n"
"$ git stash pop # 完成对保存的修改的工作\n"

#. type: Labeled list
#: en/git-stash.txt:375
#, no-wrap, priority:240
msgid "Recovering stash entries that were cleared/dropped erroneously"
msgstr "恢复被错误地清除/丢弃的贮藏库条目"

#. type: Plain text
#: en/git-stash.txt:381
#, priority:240
msgid "If you mistakenly drop or clear stash entries, they cannot be recovered through the normal safety mechanisms.  However, you can try the following incantation to get a list of stash entries that are still in your repository, but not reachable any more:"
msgstr "如果你错误地丢弃或清除了贮藏库条目，它们无法通过正常的安全机制恢复。  然而，你可以试试下面的咒语，以获得仍在你的版本库中，但无法到达的贮藏库条目列表："

#. type: delimited block -
#: en/git-stash.txt:386
#, no-wrap, priority:240
msgid ""
"git fsck --unreachable |\n"
"grep commit | cut -d\\  -f3 |\n"
"xargs git log --merges --no-walk --grep=WIP\n"
msgstr ""
"git fsck --unreachable |\n"
"grep commit | cut -d -f3 |\n"
"xargs git log --merges --no-walk --grep=WIP\n"

#. type: Plain text
#: en/git-stash.txt:403
#, ignore-same, priority:240
msgid "linkgit:git-checkout[1], linkgit:git-commit[1], linkgit:git-reflog[1], linkgit:git-reset[1], linkgit:git-switch[1]"
msgstr "linkgit:git-checkout[1], linkgit:git-commit[1], linkgit:git-reflog[1], linkgit:git-reset[1], linkgit:git-switch[1]"

#. type: Title =
#: en/git-status.txt:2
#, ignore-same, no-wrap, priority:280
msgid "git-status(1)"
msgstr "git-status(1)"

#. type: Plain text
#: en/git-status.txt:7
#, priority:280
msgid "git-status - Show the working tree status"
msgstr "git-status - 显示工作树状态"

#. type: Plain text
#: en/git-status.txt:13
#, fuzzy, ignore-ellipsis, no-wrap, priority:280
msgid "'git status' [<options>] [--] [<pathspec>...]\n"
msgstr "'git status' [<options>...] [--] [<pathspec>...]\n"

#. type: Plain text
#: en/git-status.txt:23
#, priority:280
msgid "Displays paths that have differences between the index file and the current HEAD commit, paths that have differences between the working tree and the index file, and paths in the working tree that are not tracked by Git (and are not ignored by linkgit:gitignore[5]). The first are what you _would_ commit by running `git commit`; the second and third are what you _could_ commit by running 'git add' before running `git commit`."
msgstr "显示索引文件和当前HEAD提交有差异的路径，工作树和索引文件有差异的路径，以及工作树中不被Git追踪的路径（也不被linkgit:gitignore[5]忽略）。前者是你通过运行 \"git commit \"会提交的东西；第二和第三者是你在运行 \"git commit \"之前通过运行 \"git add \"可以提交的东西。"

#. type: Plain text
#: en/git-status.txt:30
#, priority:280
msgid "Give the output in the short-format."
msgstr "以简短的形式给出输出。"

#. type: Labeled list
#: en/git-status.txt:35
#, ignore-same, no-wrap, priority:280
msgid "--show-stash"
msgstr "--show-stash"

#. type: Plain text
#: en/git-status.txt:37
#, priority:280
msgid "Show the number of entries currently stashed away."
msgstr "显示目前藏匿的条目数量。"

#. type: Labeled list
#: en/git-status.txt:38
#, fuzzy, no-wrap, priority:280
msgid "--porcelain[=<version>]"
msgstr "--porcelain[=<version>]"

#. type: Plain text
#: en/git-status.txt:43
#, priority:280
msgid "Give the output in an easy-to-parse format for scripts.  This is similar to the short output, but will remain stable across Git versions and regardless of user configuration. See below for details."
msgstr "以易于解析的格式给出脚本的输出。  这类似于简短的输出，但在不同的Git版本中，无论用户配置如何，都会保持稳定。详见下文。"

#. type: Plain text
#: en/git-status.txt:46
#, priority:280
msgid "The version parameter is used to specify the format version.  This is optional and defaults to the original version 'v1' format."
msgstr "版本参数用于指定格式版本。  这是可选的，默认为原始版本的 \"v1 \"格式。"

#. type: Plain text
#: en/git-status.txt:49
#, priority:280
msgid "Give the output in the long-format. This is the default."
msgstr "给出长格式的输出。这是默认的。"

#. type: Plain text
#: en/git-status.txt:57
#, priority:280
msgid "In addition to the names of files that have been changed, also show the textual changes that are staged to be committed (i.e., like the output of `git diff --cached`). If `-v` is specified twice, then also show the changes in the working tree that have not yet been staged (i.e., like the output of `git diff`)."
msgstr "除了显示被修改的文件名外，还显示被分阶段提交的文本修改（即，像`git diff --cached`的输出）。如果`-v`被指定了两次，那么也会显示工作树中尚未分阶段的变化（即，像`git diff`的输出）。"

#. type: Plain text
#: en/git-status.txt:66
#, priority:280
msgid "The mode parameter is used to specify the handling of untracked files.  It is optional: it defaults to 'all', and if specified, it must be stuck to the option (e.g. `-uno`, but not `-u no`)."
msgstr "模式参数用于指定对未跟踪文件的处理。  它是可选的：默认为 \"所有\"，如果指定，必须与选项卡在一起（例如，`-uno`，但不是`-u no`）。"

#. type: Plain text
#: en/git-status.txt:70
#, no-wrap, priority:280
msgid "'no'     - Show no untracked files.\n"
msgstr "'no' - 不显示未跟踪的文件。\n"

#. type: Plain text
#: en/git-status.txt:71
#, no-wrap, priority:280
msgid "'normal' - Shows untracked files and directories.\n"
msgstr "'normal' - 显示未被追踪的文件和目录。\n"

#. type: Plain text
#: en/git-status.txt:82
#, priority:280
msgid "When `-u` option is not used, untracked files and directories are shown (i.e. the same as specifying `normal`), to help you avoid forgetting to add newly created files.  Because it takes extra work to find untracked files in the filesystem, this mode may take some time in a large working tree.  Consider enabling untracked cache and split index if supported (see `git update-index --untracked-cache` and `git update-index --split-index`), Otherwise you can use `no` to have `git status` return more quickly without showing untracked files."
msgstr "当不使用`-u`选项时，将显示未跟踪的文件和目录（即与指定`normal`相同），以帮助你避免忘记添加新创建的文件。  因为在文件系统中寻找未跟踪的文件需要额外的工作，在一个大的工作树中，这种模式可能需要一些时间。  如果支持的话，考虑启用无痕缓存和分割索引（见`git upd-index --untracked-cache`和`git upd-index --split-index`），否则你可以使用`no`来让`git status`更快地返回而不显示无痕文件。"

#. type: Plain text
#: en/git-status.txt:101
#, priority:280
msgid "Ignore changes to submodules when looking for changes. <when> can be either \"none\", \"untracked\", \"dirty\" or \"all\", which is the default.  Using \"none\" will consider the submodule modified when it either contains untracked or modified files or its HEAD differs from the commit recorded in the superproject and can be used to override any settings of the 'ignore' option in linkgit:git-config[1] or linkgit:gitmodules[5]. When \"untracked\" is used submodules are not considered dirty when they only contain untracked content (but they are still scanned for modified content). Using \"dirty\" ignores all changes to the work tree of submodules, only changes to the commits stored in the superproject are shown (this was the behavior before 1.7.0). Using \"all\" hides all changes to submodules (and suppresses the output of submodule summaries when the config option `status.submoduleSummary` is set)."
msgstr "在寻找变化时忽略子模块的变化。<when>可以是 \"none\"、\"untracked\"、\"dirty \"或 \"all\"，这是默认的。  使用 \"none\"，當子模塊包含未被追蹤或修訂的檔案，或者它的頭部與超級工程中記錄的提交不同時，就會認為子模塊被修改了，可以用來覆蓋 linkgit:git-config[1] 或 linkgit:gitmodules[5] 中 \"忽略 \"選項的任何設定。当使用 \"untracked \"时，当子模块只包含未跟踪的内容时，不被认为是脏的（但它们仍然被扫描为修改的内容）。使用 \"dirty \"会忽略所有对子模块工作树的修改，只显示存储在超级项目中的提交的修改（这是1.7.0之前的行为）。使用 \"all \"会隐藏子模块的所有变化（当配置选项`status.submoduleSummary`被设置时，会抑制子模块摘要的输出）。"

#. type: Labeled list
#: en/git-status.txt:102
#, no-wrap, priority:280
msgid "--ignored[=<mode>]"
msgstr "--ignored[=<模式>]"

#. type: Plain text
#: en/git-status.txt:104
#, priority:280
msgid "Show ignored files as well."
msgstr "也显示忽略的文件。"

#. type: Plain text
#: en/git-status.txt:108
#, priority:280
msgid "The mode parameter is used to specify the handling of ignored files.  It is optional: it defaults to 'traditional'."
msgstr "模式参数用于指定对被忽略文件的处理。  它是可选的：默认为 \"传统\"。"

#. type: Plain text
#: en/git-status.txt:112
#, priority:280
msgid "'traditional' - Shows ignored files and directories, unless"
msgstr "'传统' - 显示被忽略的文件和目录，除非"

#. type: Plain text
#: en/git-status.txt:115
#, fuzzy, no-wrap, priority:280
msgid ""
"--untracked-files=all is specified, in which case\n"
"individual files in ignored directories are\n"
"displayed.\n"
msgstr ""
"--untracked-files=all is specified, in which case\n"
"individual files in ignored directories are\n"
"displayed.\n"

#. type: Plain text
#: en/git-status.txt:116
#, no-wrap, priority:280
msgid "'no'\t        - Show no ignored files.\n"
msgstr "'no' - 不显示被忽略的文件。\n"

#. type: Plain text
#: en/git-status.txt:117
#, no-wrap, priority:280
msgid "'matching'    - Shows ignored files and directories matching an\n"
msgstr "'matching' - 显示忽略的文件和目录，这些文件和目录符合\n"

#. type: Plain text
#: en/git-status.txt:118
#, no-wrap, priority:280
msgid "ignore pattern.\n"
msgstr "无视模式。\n"

#. type: Plain text
#: en/git-status.txt:124
#, priority:280
msgid "When 'matching' mode is specified, paths that explicitly match an ignored pattern are shown. If a directory matches an ignore pattern, then it is shown, but not paths contained in the ignored directory. If a directory does not match an ignore pattern, but all contents are ignored, then the directory is not shown, but all contents are shown."
msgstr "当指定 \"匹配 \"模式时，明确匹配忽略模式的路径会被显示。如果一个目录与忽略模式相匹配，那么它就会被显示，但不显示被忽略目录中包含的路径。如果一个目录不匹配忽略模式，但所有内容都被忽略，那么该目录不被显示，但所有内容被显示。"

#. type: Plain text
#: en/git-status.txt:129
#, priority:280
msgid "Terminate entries with NUL, instead of LF.  This implies the `--porcelain=v1` output format if no other format is given."
msgstr "用NUL而不是LF来终止条目。  如果没有给出其他格式，这就意味着`--porcelain=v1`的输出格式。"

#. type: Plain text
#: en/git-status.txt:136
#, priority:280
msgid "Display untracked files in columns. See configuration variable `column.status` for option syntax. `--column` and `--no-column` without options are equivalent to 'always' and 'never' respectively."
msgstr "在列中显示未跟踪的文件。选项语法见配置变量`column.status`。`--column`和`--no-column`没有选项，分别相当于'always'和'never'。"

#. type: Labeled list
#: en/git-status.txt:137
#, ignore-same, no-wrap, priority:280
msgid "--ahead-behind"
msgstr "--ahead-behind"

#. type: Labeled list
#: en/git-status.txt:138
#, ignore-same, no-wrap, priority:280
msgid "--no-ahead-behind"
msgstr "--no-ahead-behind"

#. type: Plain text
#: en/git-status.txt:141
#, priority:280
msgid "Display or do not display detailed ahead/behind counts for the branch relative to its upstream branch.  Defaults to true."
msgstr "显示或不显示该分支相对于其上游分支的详细超前/滞后计数。  默认为true。"

#. type: Labeled list
#: en/git-status.txt:142
#, ignore-same, no-wrap, priority:280
msgid "--renames"
msgstr "--renames"

#. type: Plain text
#: en/git-status.txt:146
#, priority:280
msgid "Turn on/off rename detection regardless of user configuration.  See also linkgit:git-diff[1] `--no-renames`."
msgstr "开启/关闭重名检测，不受用户配置影响。  参见linkgit:git-diff[1] `--no-renames`。"

#. type: Plain text
#: en/git-status.txt:151
#, priority:280
msgid "Turn on rename detection, optionally setting the similarity threshold.  See also linkgit:git-diff[1] `--find-renames`."
msgstr "开启重名检测，可选择设置相似度阈值。  参见 linkgit:git-diff[1] `--find-renames`。"

#. type: Plain text
#: en/git-status.txt:154
#, priority:280
msgid "See the 'pathspec' entry in linkgit:gitglossary[7]."
msgstr "参见 linkgit:gitglossary[7] 中的'pathspec'条目。"

#. type: Plain text
#: en/git-status.txt:162
#, priority:280
msgid "The output from this command is designed to be used as a commit template comment.  The default, long format, is designed to be human readable, verbose and descriptive.  Its contents and format are subject to change at any time."
msgstr "这个命令的输出是用来作为提交模板注释的。  默认的长篇格式是为了让人可读性强、言简意赅和描述性好。  其内容和格式可以随时更改。"

#. type: Plain text
#: en/git-status.txt:167
#, priority:280
msgid "The paths mentioned in the output, unlike many other Git commands, are made relative to the current directory if you are working in a subdirectory (this is on purpose, to help cutting and pasting). See the status.relativePaths config option below."
msgstr "与许多其他 Git 命令不同，如果你在子目录中工作，输出中提到的路径是相对于当前目录的（这是故意的，以帮助剪切和粘贴）。参见下面的 status.relativePaths 配置选项。"

#. type: Title ~
#: en/git-status.txt:169
#, no-wrap, priority:280
msgid "Short Format"
msgstr "简短格式"

#. type: Plain text
#: en/git-status.txt:173
#, priority:280
msgid "In the short-format, the status of each path is shown as one of these forms"
msgstr "在简短的格式中，每个路径的状态显示为以下形式之一"

#. type: Plain text
#: en/git-status.txt:176
#, fuzzy, no-wrap, priority:280
msgid ""
"\tXY PATH\n"
"\tXY ORIG_PATH -> PATH\n"
msgstr ""
"\tXY PATH\n"
"\tXY ORIG_PATH -> PATH\n"

#. type: Plain text
#: en/git-status.txt:180
#, priority:280
msgid "where `ORIG_PATH` is where the renamed/copied contents came from. `ORIG_PATH` is only shown when the entry is renamed or copied. The `XY` is a two-letter status code."
msgstr "其中`ORIG_PATH`是重命名/复制的内容的来源。`ORIG_PATH`只有在条目被重命名或复制时才会显示。`XY`是一个双字母的状态代码。"

#. type: Plain text
#: en/git-status.txt:186
#, priority:280
msgid "The fields (including the `->`) are separated from each other by a single space. If a filename contains whitespace or other nonprintable characters, that field will be quoted in the manner of a C string literal: surrounded by ASCII double quote (34) characters, and with interior special characters backslash-escaped."
msgstr "各个字段（包括`->`）之间用一个空格隔开。如果一个文件名包含空白或其他不可打印的字符，该字段将以C语言字符串字面的方式被引用：由ASCII双引号（34）字符包围，内部的特殊字符被反斜线省略。"

#. type: Plain text
#: en/git-status.txt:189
#, priority:280
msgid "There are three different types of states that are shown using this format, and each one uses the `XY` syntax differently:"
msgstr "有三种不同类型的状态是使用这种格式显示的，每一种都以不同的方式使用`XY`语法。"

#. type: Plain text
#: en/git-status.txt:191
#, priority:280
msgid "When a merge is occurring and the merge was successful, or outside of a merge"
msgstr "当一个合并正在发生并且合并成功时，或者在合并之外"

#. type: Plain text
#: en/git-status.txt:193
#, priority:280
msgid "situation, `X` shows the status of the index and `Y` shows the status of the working tree."
msgstr "情况，`X`显示索引的状态，`Y`显示工作树的状态。"

#. type: Plain text
#: en/git-status.txt:194
#, priority:280
msgid "When a merge conflict has occurred and has not yet been resolved, `X` and `Y`"
msgstr "当发生合并冲突且尚未解决时，\"X \"和 \"Y \"就会出现。"

#. type: Plain text
#: en/git-status.txt:196
#, priority:280
msgid "show the state introduced by each head of the merge, relative to the common ancestor. These paths are said to be _unmerged_."
msgstr "显示了相对于共同祖先而言，合并的每个头所引入的状态。这些路径被称为_未合并_。"

#. type: Plain text
#: en/git-status.txt:197
#, priority:280
msgid "When a path is untracked, `X` and `Y` are always the same, since they are"
msgstr "当一个路径没有被追踪时，`X`和`Y`总是相同的，因为它们是"

#. type: Plain text
#: en/git-status.txt:200
#, priority:280
msgid "unknown to the index. `??` is used for untracked paths. Ignored files are not listed unless `--ignored` is used; if it is, ignored files are indicated by `!!`."
msgstr "未知的索引。`??`用于未跟踪的路径。除非使用了`--ignored`，否则不列出被忽略的文件；如果使用了，则用`！！`表示被忽略的文件。"

#. type: Plain text
#: en/git-status.txt:203
#, priority:280
msgid "Note that the term _merge_ here also includes rebases using the default `--merge` strategy, cherry-picks, and anything else using the merge machinery."
msgstr "请注意，这里的_merge_也包括使用默认的`--merge`策略的rebases，cherry-pick，以及其他任何使用merge机制的东西。"

#. type: Plain text
#: en/git-status.txt:207
#, priority:280
msgid "In the following table, these three classes are shown in separate sections, and these characters are used for `X` and `Y` fields for the first two sections that show tracked paths:"
msgstr "在下面的表格中，这三个类别分别显示在不同的部分，这些字符用于显示跟踪路径的前两个部分的`X`和`Y`字段。"

#. type: Plain text
#: en/git-status.txt:209
#, priority:280
msgid "' ' = unmodified"
msgstr "'' = 未修改的"

#. type: Plain text
#: en/git-status.txt:210
#, priority:280
msgid "'M' = modified"
msgstr "'M' = 修改过的"

#. type: Plain text
#: en/git-status.txt:211
#, fuzzy, priority:280
msgid "'T' = file type changed (regular file, symbolic link or submodule)"
msgstr "'T' = 文件类型已更改（常规文件、符号链接或子模块）"

#. type: Plain text
#: en/git-status.txt:212
#, priority:280
msgid "'A' = added"
msgstr "'A'=添加"

#. type: Plain text
#: en/git-status.txt:213
#, priority:280
msgid "'D' = deleted"
msgstr "'D' = 删除"

#. type: Plain text
#: en/git-status.txt:214
#, priority:280
msgid "'R' = renamed"
msgstr "'R' = 重命名"

#. type: Plain text
#: en/git-status.txt:215
#, fuzzy, priority:280
msgid "'C' = copied (if config option status.renames is set to \"copies\")"
msgstr "'C' = 已复制（如果配置选项 status.renames 设置为“副本”）"

#. type: Plain text
#: en/git-status.txt:216
#, priority:280
msgid "'U' = updated but unmerged"
msgstr "'U'=更新但未合并"

#. type: delimited block .
#: en/git-status.txt:245
#, no-wrap, priority:280
msgid ""
"X          Y     Meaning\n"
"-------------------------------------------------\n"
"\t [AMD]   not updated\n"
"M        [ MTD]  updated in index\n"
"T        [ MTD]  type changed in index\n"
"A        [ MTD]  added to index\n"
"D                deleted from index\n"
"R        [ MTD]  renamed in index\n"
"C        [ MTD]  copied in index\n"
"[MTARC]          index and work tree matches\n"
"[ MTARC]    M    work tree changed since index\n"
"[ MTARC]    T    type changed in work tree since index\n"
"[ MTARC]    D    deleted in work tree\n"
"\t    R    renamed in work tree\n"
"\t    C    copied in work tree\n"
"-------------------------------------------------\n"
"D           D    unmerged, both deleted\n"
"A           U    unmerged, added by us\n"
"U           D    unmerged, deleted by them\n"
"U           A    unmerged, added by them\n"
"D           U    unmerged, deleted by us\n"
"A           A    unmerged, both added\n"
"U           U    unmerged, both modified\n"
"-------------------------------------------------\n"
"?           ?    untracked\n"
"!           !    ignored\n"
"-------------------------------------------------\n"
msgstr ""
"X Y的含义\n"
"-------------------------------------------------\n"
"\t [AMD]未更新\n"
"M [MTD] 在索引中更新\n"
"T [MTD] 类型在索引中有所改变\n"
"A [MTD] 添加到索引中\n"
"D 从索引中删除\n"
"R [MTD] 在索引中重新命名\n"
"C [MTD] 在索引中被复制\n"
"[MTARC] 索引和工作树匹配\n"
"[MTARC] 自索引以来，M工作树发生了变化\n"
"[MTARC] 工作树中的T类型自索引以来发生了变化\n"
"[MTARC] D在工作树中被删除\n"
"\t    R在工作树中重新命名\n"
"\t    C在工作树中被复制\n"
"-------------------------------------------------\n"
"D D未合并，均已删除\n"
"A U 未合并，由我们添加\n"
"U D未合并，被他人删除\n"
"U A 未合并，由他人添加\n"
"D U未合并，被我们删除\n"
"A A未合并，都被添加\n"
"U U未合并，都被修改\n"
"-------------------------------------------------\n"
"?           未被追踪的\n"
"!           忽略不计\n"
"-------------------------------------------------\n"

#. type: Plain text
#: en/git-status.txt:254
#, no-wrap, priority:280
msgid ""
"Submodules have more state and instead report\n"
"\t\tM    the submodule has a different HEAD than\n"
"\t\t     recorded in the index\n"
"\t\tm    the submodule has modified content\n"
"\t\t?    the submodule has untracked files\n"
"since modified content or untracked files in a submodule cannot be added\n"
"via `git add` in the superproject to prepare a commit.\n"
msgstr ""
"子模块有更多的状态，而是报告\n"
"\t\tM的子模块有一个不同的HEAD比\n"
"\t\t     记录在索引中\n"
"\t\tm 该子模块有修改的内容\n"
"\t\t该子模块有未跟踪的文件\n"
"因为子模块中的修改内容或未跟踪的文件不能被添加到\n"
"通过超级项目中的`git add`来准备提交。\n"

#. type: Plain text
#: en/git-status.txt:257
#, priority:280
msgid "'m' and '?' are applied recursively. For example if a nested submodule in a submodule contains an untracked file, this is reported as '?' as well."
msgstr "'m'和'?'是递归应用的。例如，如果一个子模块中的嵌套子模块包含一个未跟踪的文件，这也会报告为'?'"

#. type: Plain text
#: en/git-status.txt:259
#, priority:280
msgid "If -b is used the short-format status is preceded by a line"
msgstr "如果使用了-b，短格式的状态前面会有一行"

#. type: Plain text
#: en/git-status.txt:261
#, fuzzy, no-wrap, priority:280
msgid "    ## branchname tracking info\n"
msgstr "    ## branchname tracking info\n"

#. type: Title ~
#: en/git-status.txt:263
#, no-wrap, priority:280
msgid "Porcelain Format Version 1"
msgstr "瓷器格式版本1"

#. type: Plain text
#: en/git-status.txt:270
#, priority:280
msgid "Version 1 porcelain format is similar to the short format, but is guaranteed not to change in a backwards-incompatible way between Git versions or based on user configuration. This makes it ideal for parsing by scripts.  The description of the short format above also describes the porcelain format, with a few exceptions:"
msgstr "第1版的瓷器格式与短格式类似，但保证不会在Git版本之间以向后兼容的方式或基于用户配置而改变。这使得它成为脚本解析的理想选择。  上面对短格式的描述也是对瓷器格式的描述，但有一些例外。"

#. type: Plain text
#: en/git-status.txt:273
#, priority:280
msgid "The user's color.status configuration is not respected; color will always be off."
msgstr "用户的color.status配置不被尊重，颜色将永远是关闭的。"

#. type: Plain text
#: en/git-status.txt:276
#, priority:280
msgid "The user's status.relativePaths configuration is not respected; paths shown will always be relative to the repository root."
msgstr "用户的 status.relativePaths 配置不被尊重；显示的路径将总是相对于版本库根目录。"

#. type: Plain text
#: en/git-status.txt:286
#, priority:280
msgid "There is also an alternate -z format recommended for machine parsing. In that format, the status field is the same, but some other things change.  First, the '\\->' is omitted from rename entries and the field order is reversed (e.g 'from \\-> to' becomes 'to from'). Second, a NUL (ASCII 0) follows each filename, replacing space as a field separator and the terminating newline (but a space still separates the status field from the first filename).  Third, filenames containing special characters are not specially formatted; no quoting or backslash-escaping is performed."
msgstr "还有一种替代的-z格式，建议用于机器解析。在这种格式中，状态字段是相同的，但其他一些事情发生了变化。  首先，重命名条目中的\"\\->\"被省略，字段顺序被颠倒（例如 \"from\\-> to \"变成 \"to from\"）。第二，每个文件名后面都有一个NUL（ASCII 0），取代空格作为字段分隔符和终止换行符（但空格仍然将状态字段与第一个文件名分开）。  第三，包含特殊字符的文件名不被特别格式化；不进行引号或反斜线escaping。"

#. type: Plain text
#: en/git-status.txt:288
#, priority:280
msgid "Any submodule changes are reported as modified `M` instead of `m` or single `?`."
msgstr "任何子模块的变化都被报告为修改的`M'，而不是`m'或单一的`?'。"

#. type: Title ~
#: en/git-status.txt:290
#, no-wrap, priority:280
msgid "Porcelain Format Version 2"
msgstr "瓷器格式版本2"

#. type: Plain text
#: en/git-status.txt:295
#, priority:280
msgid "Version 2 format adds more detailed information about the state of the worktree and changed items.  Version 2 also defines an extensible set of easy to parse optional headers."
msgstr "第二版格式增加了关于工作树的状态和变化的项目的更多详细信息。  第2版还定义了一套可扩展的、易于解析的可选头文件。"

#. type: Plain text
#: en/git-status.txt:299
#, priority:280
msgid "Header lines start with \"#\" and are added in response to specific command line arguments.  Parsers should ignore headers they don't recognize."
msgstr "标头行以 \"#\"开头，是为响应特定的命令行参数而添加的。  解析器应该忽略他们不认识的标题。"

#. type: Title ^
#: en/git-status.txt:301
#, no-wrap, priority:280
msgid "Branch Headers"
msgstr "分支机构负责人"

#. type: Plain text
#: en/git-status.txt:305
#, priority:280
msgid "If `--branch` is given, a series of header lines are printed with information about the current branch."
msgstr "如果给了`--branch`，就会打印出一系列标题行，其中有关于当前分支的信息。"

#. type: delimited block .
#: en/git-status.txt:315
#, no-wrap, priority:280
msgid ""
"Line                                     Notes\n"
"------------------------------------------------------------\n"
"# branch.oid <commit> | (initial)        Current commit.\n"
"# branch.head <branch> | (detached)      Current branch.\n"
"# branch.upstream <upstream_branch>      If upstream is set.\n"
"# branch.ab +<ahead> -<behind>           If upstream is set and\n"
"\t\t\t\t\t the commit is present.\n"
"------------------------------------------------------------\n"
msgstr ""
"线路说明\n"
"------------------------------------------------------------\n"
"# branch.oid <commit> | (初始) 当前的提交。\n"
"# branch.head <branch> | (detached) 当前分支。\n"
"# branch.upstream <upstream_branch> 如果upstream被设置。\n"
"# branch.ab +<ahead> -<behind> 如果上游被设置且\n"
"\t\t\t\t\t 的提交是存在的。\n"
"------------------------------------------------------------\n"

#. type: Title ^
#: en/git-status.txt:318
#, fuzzy, no-wrap, priority:280
msgid "Stash Information"
msgstr "信息"

#. type: Plain text
#: en/git-status.txt:322
#, fuzzy, priority:280
msgid "If `--show-stash` is given, one line is printed showing the number of stash entries if non-zero:"
msgstr "如果给出了 `--show-stash`，则打印一行，如果非零，则显示存储条目的数量："

#. type: Plain text
#: en/git-status.txt:324
#, fuzzy, no-wrap, priority:280
#| msgid "    ? <path>\n"
msgid "    # stash <N>\n"
msgstr "    ?<路径>\n"

#. type: Title ^
#: en/git-status.txt:326
#, no-wrap, priority:280
msgid "Changed Tracked Entries"
msgstr "变更后的跟踪条目"

#. type: Plain text
#: en/git-status.txt:333
#, priority:280
msgid "Following the headers, a series of lines are printed for tracked entries.  One of three different line formats may be used to describe an entry depending on the type of change.  Tracked entries are printed in an undefined order; parsers should allow for a mixture of the 3 line types in any order."
msgstr "在页眉之后，一系列的行被打印出来，用于追踪条目。  根据变化的类型，三种不同的行格式之一可用于描述一个条目。  追踪条目是以未定义的顺序打印的；解析器应允许以任何顺序混合使用这三种行类型。"

#. type: Plain text
#: en/git-status.txt:335
#, priority:280
msgid "Ordinary changed entries have the following format:"
msgstr "普通更改的条目有以下格式。"

#. type: Plain text
#: en/git-status.txt:337
#, fuzzy, no-wrap, priority:280
msgid "    1 <XY> <sub> <mH> <mI> <mW> <hH> <hI> <path>\n"
msgstr "    1 <XY> <sub> <mH> <mI> <mW> <hH> <hI> <path>\n"

#. type: Plain text
#: en/git-status.txt:339
#, priority:280
msgid "Renamed or copied entries have the following format:"
msgstr "重命名或复制的条目有以下格式。"

#. type: Plain text
#: en/git-status.txt:341
#, no-wrap, priority:280
msgid "    2 <XY> <sub> <mH> <mI> <mW> <hH> <hI> <X><score> <path><sep><origPath>\n"
msgstr "    2 <XY> <sub> <mH> <mI> <mW> <hH> <hI> <X><score> <path><sep><origPath>\n"

#. type: delimited block .
#: en/git-status.txt:372
#, ignore-ellipsis, no-wrap, priority:280
msgid ""
"Field       Meaning\n"
"--------------------------------------------------------\n"
"<XY>        A 2 character field containing the staged and\n"
"\t    unstaged XY values described in the short format,\n"
"\t    with unchanged indicated by a \".\" rather than\n"
"\t    a space.\n"
"<sub>       A 4 character field describing the submodule state.\n"
"\t    \"N...\" when the entry is not a submodule.\n"
"\t    \"S<c><m><u>\" when the entry is a submodule.\n"
"\t    <c> is \"C\" if the commit changed; otherwise \".\".\n"
"\t    <m> is \"M\" if it has tracked changes; otherwise \".\".\n"
"\t    <u> is \"U\" if there are untracked changes; otherwise \".\".\n"
"<mH>        The octal file mode in HEAD.\n"
"<mI>        The octal file mode in the index.\n"
"<mW>        The octal file mode in the worktree.\n"
"<hH>        The object name in HEAD.\n"
"<hI>        The object name in the index.\n"
"<X><score>  The rename or copy score (denoting the percentage\n"
"\t    of similarity between the source and target of the\n"
"\t    move or copy). For example \"R100\" or \"C75\".\n"
"<path>      The pathname.  In a renamed/copied entry, this\n"
"\t    is the target path.\n"
"<sep>       When the `-z` option is used, the 2 pathnames are separated\n"
"\t    with a NUL (ASCII 0x00) byte; otherwise, a tab (ASCII 0x09)\n"
"\t    byte separates them.\n"
"<origPath>  The pathname in the commit at HEAD or in the index.\n"
"\t    This is only present in a renamed/copied entry, and\n"
"\t    tells where the renamed/copied contents came from.\n"
"--------------------------------------------------------\n"
msgstr ""
"领域含义\n"
"--------------------------------------------------------\n"
"<XY> 一个2个字符的字段，包含短格式中描述的阶段性和非阶段性XY值。\n"
"\t    阶段性和非阶段性的XY值。\n"
"\t    不变的用\". \"表示，而不是用空格。\n"
"\t    而不是空格。\n"
"<sub> 一个4个字符的字段，描述子模块的状态。\n"
"\t    \"N... \"当条目不是一个子模块时。\n"
"\t    \"S<c><m><u>\" 当条目是一个子模块。\n"
"\t    <c>是 \"C\"，如果提交改变了；否则是\".\"。\n"
"\t    <m> 如果它有跟踪的变化，则为 \"M\"；否则为\".\"。\n"
"\t    <u> 如果有未追踪的修改，则为 \"U\"；否则为\".\"。\n"
"<mH> HEAD中的八进制文件模式。\n"
"<mI> 索引中的八进制文件模式。\n"
"<mW> 工作树中的八进制文件模式。\n"
"<hH> HEAD中的对象名称。\n"
"<hI> 索引中的对象名称。\n"
"<X><score> 重命名或复制分数（表示源文件和目标文件之间的相似百分比）。\n"
"\t    源和目标之间的相似度）。\n"
"\t    移动或复制的目标之间的相似度）。)例如，\"R100 \"或 \"C75\"。\n"
"<path> 路径名。  在一个重命名/复制的条目中，这\n"
"\t    是目标路径。\n"
"<sep> 当使用`-z`选项时，两个路径名用NUL(ASCII 0x00)分隔。\n"
"\t    用一个NUL(ASCII 0x00)字节分开；否则，用一个TAB(ASCII 0x09)\n"
"\t    字节来分隔它们。\n"
"<origPath> 在HEAD或索引中提交的路径名。\n"
"\t    这只存在于重命名/复制的条目中，并且\n"
"\t    告诉你重命名/复制的内容来自哪里。\n"
"--------------------------------------------------------\n"

#. type: Plain text
#: en/git-status.txt:376
#, priority:280
msgid "Unmerged entries have the following format; the first character is a \"u\" to distinguish from ordinary changed entries."
msgstr "未合并的条目有以下格式；第一个字符是 \"u\"，以区别于普通的变更条目。"

#. type: Plain text
#: en/git-status.txt:378
#, fuzzy, no-wrap, priority:280
msgid "    u <XY> <sub> <m1> <m2> <m3> <mW> <h1> <h2> <h3> <path>\n"
msgstr "    u <xy> <sub> <m1> <m2> <m3> <mW> <h1> <h2> <h3> <path>\n"

#. type: delimited block .
#: en/git-status.txt:395
#, no-wrap, priority:280
msgid ""
"Field       Meaning\n"
"--------------------------------------------------------\n"
"<XY>        A 2 character field describing the conflict type\n"
"\t    as described in the short format.\n"
"<sub>       A 4 character field describing the submodule state\n"
"\t    as described above.\n"
"<m1>        The octal file mode in stage 1.\n"
"<m2>        The octal file mode in stage 2.\n"
"<m3>        The octal file mode in stage 3.\n"
"<mW>        The octal file mode in the worktree.\n"
"<h1>        The object name in stage 1.\n"
"<h2>        The object name in stage 2.\n"
"<h3>        The object name in stage 3.\n"
"<path>      The pathname.\n"
"--------------------------------------------------------\n"
msgstr ""
"领域含义\n"
"--------------------------------------------------------\n"
"<XY> 一个2个字符的字段，描述冲突类型\n"
"\t    描述冲突类型。\n"
"<sub> 一个4个字符的字段，描述子模块的状态\n"
"\t    如上所述。\n"
"<m1> 阶段1中的八进制文件模式。\n"
"<m2> 阶段2中的八进制文件模式。\n"
"<m3> 阶段3中的八进制文件模式。\n"
"<mW> 工作树中的八进制文件模式。\n"
"<h1> 阶段1中的对象名称。\n"
"<h2> 第二阶段的对象名称。\n"
"<h3> 第三阶段的对象名称。\n"
"<path> 路径名。\n"
"--------------------------------------------------------\n"

#. type: Title ^
#: en/git-status.txt:398
#, no-wrap, priority:280
msgid "Other Items"
msgstr "其他项目"

#. type: Plain text
#: en/git-status.txt:403
#, priority:280
msgid "Following the tracked entries (and if requested), a series of lines will be printed for untracked and then ignored items found in the worktree."
msgstr "在跟踪的条目之后（如果要求的话），将打印一系列未跟踪的行，然后是在工作树中发现的忽略的条目。"

#. type: Plain text
#: en/git-status.txt:405
#, priority:280
msgid "Untracked items have the following format:"
msgstr "未跟踪的项目有以下格式。"

#. type: Plain text
#: en/git-status.txt:407
#, no-wrap, priority:280
msgid "    ? <path>\n"
msgstr "    ?<路径>\n"

#. type: Plain text
#: en/git-status.txt:409
#, priority:280
msgid "Ignored items have the following format:"
msgstr "被忽略的项目有以下格式。"

#. type: Plain text
#: en/git-status.txt:411
#, no-wrap, priority:280
msgid "    ! <path>\n"
msgstr "    !<路径>的情况下\n"

#. type: Title ^
#: en/git-status.txt:413
#, no-wrap, priority:280
msgid "Pathname Format Notes and -z"
msgstr "路径名格式说明和-z"

#. type: Plain text
#: en/git-status.txt:418
#, priority:280
msgid "When the `-z` option is given, pathnames are printed as is and without any quoting and lines are terminated with a NUL (ASCII 0x00)  byte."
msgstr "当给定\"-z \"选项时，路径名将按原样打印，没有任何引号，并且以NUL（ASCII 0x00）字节结束行。"

#. type: Plain text
#: en/git-status.txt:422
#, priority:280
msgid "Without the `-z` option, pathnames with \"unusual\" characters are quoted as explained for the configuration variable `core.quotePath` (see linkgit:git-config[1])."
msgstr "如果没有`-z`选项，带有 \"不寻常 \"字符的路径名将被引用，正如对配置变量`core.quotePath`的解释（见linkgit:git-config[1]）。"

#. type: Plain text
#: en/git-status.txt:431
#, priority:280
msgid "The command honors `color.status` (or `status.color` -- they mean the same thing and the latter is kept for backward compatibility) and `color.status.<slot>` configuration variables to colorize its output."
msgstr "该命令使用`color.status`（或`status.color`--它们的意思是一样的，为了向后兼容，保留后者）和`color.status.<slot>`配置变量来为其输出着色。"

#. type: Plain text
#: en/git-status.txt:435
#, priority:280
msgid "If the config variable `status.relativePaths` is set to false, then all paths shown are relative to the repository root, not to the current directory."
msgstr "如果配置变量`status.relativePaths`被设置为false，那么所有显示的路径都是相对于版本库根目录的，而不是当前目录。"

#. type: Plain text
#: en/git-status.txt:446
#, priority:280
msgid "If `status.submoduleSummary` is set to a non zero number or true (identical to -1 or an unlimited number), the submodule summary will be enabled for the long format and a summary of commits for modified submodules will be shown (see --summary-limit option of linkgit:git-submodule[1]). Please note that the summary output from the status command will be suppressed for all submodules when `diff.ignoreSubmodules` is set to 'all' or only for those submodules where `submodule.<name>.ignore=all`. To also view the summary for ignored submodules you can either use the --ignore-submodules=dirty command line option or the 'git submodule summary' command, which shows a similar output but does not honor these settings."
msgstr "如果`status.submoduleSummary`被设置为一个非零的数字或true（与-1或无限制的数字相同），子模块摘要将启用长格式，并显示修改的子模块的提交摘要（见linkgit:git-submodule[1]的-summary-limit选项）。请注意，当`diff.ignoreSubmodules`被设置为'all'或仅为那些`submodule.<name>.ignore=all'的子模块，状态命令的摘要输出将被抑制。要查看被忽略的子模块的摘要，你可以使用 --ignore-submodules=dirty 命令行选项或 \"git submodule summary \"命令，它显示类似的输出，但不尊重这些设置。"

#. type: Title -
#: en/git-status.txt:448
#, no-wrap, priority:280
msgid "BACKGROUND REFRESH"
msgstr "背景刷新"

#. type: Plain text
#: en/git-status.txt:459
#, priority:280
msgid "By default, `git status` will automatically refresh the index, updating the cached stat information from the working tree and writing out the result. Writing out the updated index is an optimization that isn't strictly necessary (`status` computes the values for itself, but writing them out is just to save subsequent programs from repeating our computation). When `status` is run in the background, the lock held during the write may conflict with other simultaneous processes, causing them to fail. Scripts running `status` in the background should consider using `git --no-optional-locks status` (see linkgit:git[1] for details)."
msgstr "默认情况下，`git status`会自动刷新索引，更新工作树上缓存的状态信息，并将结果写出来。写出更新的索引是一种优化，严格来说并无必要（`status`为自己计算数值，但写出它们只是为了避免后续程序重复我们的计算）。当`status`在后台运行时，在写入过程中持有的锁可能与其他同时进行的进程发生冲突，导致它们失败。在后台运行`status`的脚本应该考虑使用`git --no-optional-locks status`（详见linkgit:git[1]）。"

#. type: Title -
#: en/git-status.txt:461
#, fuzzy, no-wrap, priority:280
msgid "UNTRACKED FILES AND PERFORMANCE"
msgstr "未跟踪的文件和性能"

#. type: Plain text
#: en/git-status.txt:472
#, priority:280
msgid "`git status` can be very slow in large worktrees if/when it needs to search for untracked files and directories. There are many configuration options available to speed this up by either avoiding the work or making use of cached results from previous Git commands. There is no single optimum set of settings right for everyone. We'll list a summary of the relevant options to help you, but before going into the list, you may want to run `git status` again, because your configuration may already be caching `git status` results, so it could be faster on subsequent runs."
msgstr "`git status`在大型工作树中，如果/当它需要搜索未被追踪的文件和目录时，速度会非常慢。有许多配置选项可以通过避免这种操作或是利用以前的 Git 命令的缓存结果来加快速度。但是没有一套适合所有人的最佳设置。我们将列出相关选项的摘要以帮助你，但在进入列表之前，你可能想再次运行`git status`，因为你的配置可能已经缓存了`git status`的结果，所以在随后的运行中可能会更快。"

#. type: Plain text
#: en/git-status.txt:474
#, fuzzy, priority:280
msgid "The `--untracked-files=no` flag or the"
msgstr "--untracked-files[=<mode>]"

#. type: Plain text
#: en/git-status.txt:479
#, priority:280
msgid "`status.showUntrackedfiles=false` config (see above for both): indicate that `git status` should not report untracked files. This is the fastest option. `git status` will not list the untracked files, so you need to be careful to remember if you create any new files and manually `git add` them."
msgstr "设置`status.showUntrackedfiles=false`：表示`git status`不应该报告未跟踪的文件。这是最快的选项。`git status`不会列出未跟踪的文件，所以你得注意，在创建任何新的文件后，需要手动`git add`它们。"

#. type: Plain text
#: en/git-status.txt:481
#, priority:280
msgid "`advice.statusUoption=false` (see linkgit:git-config[1]):"
msgstr "`advice.statusUoption=false`（见linkgit:git-config[1]）："

#. type: Plain text
#: en/git-status.txt:488
#, priority:280
msgid "setting this variable to `false` disables the warning message given when enumerating untracked files takes more than 2 seconds.  In a large project, it may take longer and the user may have already accepted the trade off (e.g. using \"-uno\" may not be an acceptable option for the user), in which case, there is no point issuing the warning message, and in such a case, disabling the warning may be the best."
msgstr "将此变量设置为 \"false\"，当列举未跟踪的文件需要超过2秒时，将禁用警告信息。  在一个大型项目中，可能需要更长的时间，而且用户可能已经接受了这种设置（例如，使用\"-uno\"可能不是用户可以接受的选项）。在这种情况下，发出警告信息没有意义，禁用警告可能是最好的。"

#. type: Plain text
#: en/git-status.txt:490
#, fuzzy, priority:280
#| msgid "linkgit:git-update-index[1]"
msgid "`core.untrackedCache=true` (see linkgit:git-update-index[1]):"
msgstr "linkgit:git-update-index[1]"

#. type: Plain text
#: en/git-status.txt:502
#, priority:280
msgid "enable the untracked cache feature and only search directories that have been modified since the previous `git status` command.  Git remembers the set of untracked files within each directory and assumes that if a directory has not been modified, then the set of untracked files within has not changed.  This is much faster than enumerating the contents of every directory, but still not without cost, because Git still has to search for the set of modified directories. The untracked cache is stored in the `.git/index` file. The reduced cost of searching for untracked files is offset slightly by the increased size of the index and the cost of keeping it up-to-date. That reduced search time is usually worth the additional size."
msgstr "启用未跟踪缓存功能，只搜索自上一个 `git status` 命令以来修改过的目录。 Git 会记住每个目录中的未跟踪文件集，并假定如果目录未被修改，则其中的未跟踪文件集不会更改。这比枚举每个目录的内容要快得多，但这依然有代价，因为 Git 仍然需要搜索修改目录的集合。未跟踪的缓存存储在 .git/index 文件中。搜索未跟踪文件的成本降低被索引大小的增加和保持最新的成本所抵消。缩短的搜索时间通常值得新增额外的大小。"

#. type: Plain text
#: en/git-status.txt:504
#, priority:280
msgid "`core.untrackedCache=true` and `core.fsmonitor=true` or"
msgstr "`core.untrackedCache=true`和`core.fsmonitor=true`或"

#. type: Plain text
#: en/git-status.txt:514
#, priority:280
msgid "`core.fsmonitor=<hook_command_pathname>` (see linkgit:git-update-index[1]): enable both the untracked cache and FSMonitor features and only search directories that have been modified since the previous `git status` command.  This is faster than using just the untracked cache alone because Git can also avoid searching for modified directories.  Git only has to enumerate the exact set of directories that have changed recently. While the FSMonitor feature can be enabled without the untracked cache, the benefits are greatly reduced in that case."
msgstr "`core.fsmonitor=<hook_command_pathname>`（见linkgit:git-update-index[1]）：同时启用无痕缓存和FSMonitor功能，只搜索自上一条`git status'命令以来被修改的目录。  这比单独使用无痕缓存要快，因为Git也可以避免搜索被修改的目录。  Git只需要列举出最近有变化的确切目录集。虽然FSMonitor功能可以在没有无痕缓存的情况下启用，但在这种情况下好处会大大减少。"

#. type: Plain text
#: en/git-status.txt:519
#, priority:280
msgid "Note that after you turn on the untracked cache and/or FSMonitor features it may take a few `git status` commands for the various caches to warm up before you see improved command times.  This is normal."
msgstr "请注意，在你打开无痕缓存和/或FSMonitor功能后，可能需要几个`git status'命令来让各种缓存活动起来，然后你才能看到命令耗时的改善，这很正常。"

#. type: Title =
#: en/git-stripspace.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-stripspace(1)"
msgstr "git-stripspace(1)"

#. type: Plain text
#: en/git-stripspace.txt:7
#, priority:100
msgid "git-stripspace - Remove unnecessary whitespace"
msgstr ""

#. type: Plain text
#: en/git-stripspace.txt:14
#, no-wrap, priority:100
msgid ""
"'git stripspace' [-s | --strip-comments]\n"
"'git stripspace' [-c | --comment-lines]\n"
msgstr ""

#. type: Plain text
#: en/git-stripspace.txt:21
#, priority:100
msgid "Read text, such as commit messages, notes, tags and branch descriptions, from the standard input and clean it in the manner used by Git."
msgstr ""

#. type: Plain text
#: en/git-stripspace.txt:23
#, priority:100
msgid "With no arguments, this will:"
msgstr ""

#. type: Plain text
#: en/git-stripspace.txt:25
#, priority:100
msgid "remove trailing whitespace from all lines"
msgstr ""

#. type: Plain text
#: en/git-stripspace.txt:26
#, priority:100
msgid "collapse multiple consecutive empty lines into one empty line"
msgstr ""

#. type: Plain text
#: en/git-stripspace.txt:27
#, priority:100
msgid "remove empty lines from the beginning and end of the input"
msgstr ""

#. type: Plain text
#: en/git-stripspace.txt:28
#, priority:100
msgid "add a missing '\\n' to the last line if necessary."
msgstr ""

#. type: Plain text
#: en/git-stripspace.txt:31
#, priority:100
msgid "In the case where the input consists entirely of whitespace characters, no output will be produced."
msgstr ""

#. type: Plain text
#: en/git-stripspace.txt:35
#, no-wrap, priority:100
msgid ""
"*NOTE*: This is intended for cleaning metadata, prefer the `--whitespace=fix`\n"
"mode of linkgit:git-apply[1] for correcting whitespace of patches or files in\n"
"the repository.\n"
msgstr ""

#. type: Labeled list
#: en/git-stripspace.txt:39
#, ignore-same, no-wrap, priority:100
msgid "--strip-comments"
msgstr "--strip-comments"

#. type: Plain text
#: en/git-stripspace.txt:41
#, priority:100
msgid "Skip and remove all lines starting with comment character (default '#')."
msgstr ""

#. type: Labeled list
#: en/git-stripspace.txt:43
#, ignore-same, no-wrap, priority:100
msgid "--comment-lines"
msgstr "--comment-lines"

#. type: Plain text
#: en/git-stripspace.txt:47
#, priority:100
msgid "Prepend comment character and blank to each line. Lines will automatically be terminated with a newline. On empty lines, only the comment character will be prepended."
msgstr ""

#. type: Plain text
#: en/git-stripspace.txt:52
#, priority:100
msgid "Given the following noisy input with '$' indicating the end of a line:"
msgstr ""

#. type: delimited block -
#: en/git-stripspace.txt:65
#, fuzzy, no-wrap, priority:100
msgid ""
"|A brief introduction   $\n"
"|   $\n"
"|$\n"
"|A new paragraph$\n"
"|# with a commented-out line    $\n"
"|explaining lots of stuff.$\n"
"|$\n"
"|# An old paragraph, also commented-out. $\n"
"|      $\n"
"|The end.$\n"
"|  $\n"
msgstr ""
"|A brief introduction   $\n"
"|   $\n"
"|$\n"
"|A new paragraph$\n"
"|# with a commented-out line    $\n"
"|explaining lots of stuff.$\n"
"|$\n"
"|# An old paragraph, also commented-out. $\n"
"|      $\n"
"|The end.$\n"
"|  $\n"

#. type: Plain text
#: en/git-stripspace.txt:68
#, priority:100
msgid "Use 'git stripspace' with no arguments to obtain:"
msgstr ""

#. type: delimited block -
#: en/git-stripspace.txt:79
#, fuzzy, no-wrap, priority:100
msgid ""
"|A brief introduction$\n"
"|$\n"
"|A new paragraph$\n"
"|# with a commented-out line$\n"
"|explaining lots of stuff.$\n"
"|$\n"
"|# An old paragraph, also commented-out.$\n"
"|$\n"
"|The end.$\n"
msgstr ""
"|A brief introduction$\n"
"|$\n"
"|A new paragraph$\n"
"|# with a commented-out line$\n"
"|explaining lots of stuff.$\n"
"|$\n"
"|# An old paragraph, also commented-out.$\n"
"|$\n"
"|The end.$\n"

#. type: Plain text
#: en/git-stripspace.txt:82
#, priority:100
msgid "Use 'git stripspace --strip-comments' to obtain:"
msgstr ""

#. type: delimited block -
#: en/git-stripspace.txt:90
#, fuzzy, no-wrap, priority:100
msgid ""
"|A brief introduction$\n"
"|$\n"
"|A new paragraph$\n"
"|explaining lots of stuff.$\n"
"|$\n"
"|The end.$\n"
msgstr ""
"|A brief introduction$\n"
"|$\n"
"|A new paragraph$\n"
"|explaining lots of stuff.$\n"
"|$\n"
"|The end.$\n"

#. type: Title =
#: en/git-submodule.txt:2
#, ignore-same, no-wrap, priority:220
msgid "git-submodule(1)"
msgstr "git-submodule(1)"

#. type: Plain text
#: en/git-submodule.txt:7
#, fuzzy, priority:220
msgid "git-submodule - Initialize, update or inspect submodules"
msgstr "git-submodule - Initialize, update or inspect submodules"

#. type: Plain text
#: en/git-submodule.txt:24
#, ignore-ellipsis, no-wrap, priority:220
msgid ""
"'git submodule' [--quiet] [--cached]\n"
"'git submodule' [--quiet] add [<options>] [--] <repository> [<path>]\n"
"'git submodule' [--quiet] status [--cached] [--recursive] [--] [<path>...]\n"
"'git submodule' [--quiet] init [--] [<path>...]\n"
"'git submodule' [--quiet] deinit [-f|--force] (--all|[--] <path>...)\n"
"'git submodule' [--quiet] update [<options>] [--] [<path>...]\n"
"'git submodule' [--quiet] set-branch [<options>] [--] <path>\n"
"'git submodule' [--quiet] set-url [--] <path> <newurl>\n"
"'git submodule' [--quiet] summary [<options>] [--] [<path>...]\n"
"'git submodule' [--quiet] foreach [--recursive] <command>\n"
"'git submodule' [--quiet] sync [--recursive] [--] [<path>...]\n"
"'git submodule' [--quiet] absorbgitdirs [--] [<path>...]\n"
msgstr ""
"'git submodule' [--quiet] [--cached]\n"
"'git submodule' [--quiet] add [<单/多个选项>] [--] <仓库> [<路径>]\n"
"'git submodule' [--quiet] status [--cached] [--recursive] [--] [<路径>...]\n"
"'git submodule' [--quiet] init [--] [<路径>...]\n"
"'git submodule' [--quiet] deinit [-f|--force] (--all|[--] <路径>...)\n"
"'git submodule' [--quiet] update [<单/多个选项>] [--] [<路径>...]\n"
"'git submodule' [--quiet] set-branch [<单/多个选项>] [--] <路径>\n"
"'git submodule' [--quiet] set-url [--] <路径> <newurl>\n"
"'git submodule' [--quiet] summary [<单/多个选项>] [--] [<路径>...]\n"
"'git submodule' [--quiet] foreach [--recursive] <命令>\n"
"'git submodule' [--quiet] sync [--recursive] [--] [<路径>...]\n"
"'git submodule' [--quiet] absorbgitdirs [--] [<路径>...]\n"

#. type: Plain text
#: en/git-submodule.txt:29
#, priority:220
msgid "Inspects, updates and manages submodules."
msgstr "检查、更新和管理子模块。"

#. type: Plain text
#: en/git-submodule.txt:31
#, priority:220
msgid "For more information about submodules, see linkgit:gitsubmodules[7]."
msgstr "关于子模块的更多信息，见 linkgit:gitsubmodules[7]。"

#. type: Plain text
#: en/git-submodule.txt:36
#, priority:220
msgid "With no arguments, shows the status of existing submodules.  Several subcommands are available to perform operations on the submodules."
msgstr "没有参数，显示现有子模块的状态。 有几个子命令可用于对子模块进行操作。"

#. type: Labeled list
#: en/git-submodule.txt:37
#, no-wrap, priority:220
msgid "add [-b <branch>] [-f|--force] [--name <name>] [--reference <repository>] [--depth <depth>] [--] <repository> [<path>]"
msgstr "add [-b <分支>] [-f|--force] [--name <名称>] [--reference <仓库>] [--depth <深度>] [--] <仓库> [<路径>]"

#. type: Plain text
#: en/git-submodule.txt:41
#, priority:220
msgid "Add the given repository as a submodule at the given path to the changeset to be committed next to the current project: the current project is termed the \"superproject\"."
msgstr "将给定的版本库作为子模块在给定的路径上添加到当前项目旁边要提交的变更集：当前项目被称为 \"父项目\"。"

#. type: Plain text
#: en/git-submodule.txt:50
#, priority:220
msgid "<repository> is the URL of the new submodule's origin repository.  This may be either an absolute URL, or (if it begins with ./ or ../), the location relative to the superproject's default remote repository (Please note that to specify a repository 'foo.git' which is located right next to a superproject 'bar.git', you'll have to use `../foo.git` instead of `./foo.git` - as one might expect when following the rules for relative URLs - because the evaluation of relative URLs in Git is identical to that of relative directories)."
msgstr "<仓库> 是新子模块仓库的 URL。 这可以是一个绝对 URL，或者（如果它以 ./ 或 ../ 开头），相对于父项目的默认远程仓库的位置（请注意，要指定一个紧挨着父项目 'bar.git' 的仓库 'foo.git'，你必须使用 `../foo.git` 而不是 `./foo.git` 正如人们在遵循相对 URL 的规则时可能期望的那样，因为 Git 中相对 URLs 的解释与相对目录是一样的）。"

#. type: Plain text
#: en/git-submodule.txt:57
#, priority:220
msgid "The default remote is the remote of the remote-tracking branch of the current branch. If no such remote-tracking branch exists or the HEAD is detached, \"origin\" is assumed to be the default remote.  If the superproject doesn't have a default remote configured the superproject is its own authoritative upstream and the current working directory is used instead."
msgstr "默认的远程是当前分支的远程跟踪分支的远程。如果没有这样的远程跟踪分支，或者 HEAD 被分离了，\"origin\" 就会被假定为默认远程。 如果父项目没有配置默认的远程，那么父项目就是它自己的权威上游，并使用当前工作目录代替。"

#. type: Plain text
#: en/git-submodule.txt:66
#, priority:220
msgid "The optional argument <path> is the relative location for the cloned submodule to exist in the superproject. If <path> is not given, the canonical part of the source repository is used (\"repo\" for \"/path/to/repo.git\" and \"foo\" for \"host.xz:foo/.git\"). If <path> exists and is already a valid Git repository, then it is staged for commit without cloning. The <path> is also used as the submodule's logical name in its configuration entries unless `--name` is used to specify a logical name."
msgstr "可选参数 <路径> 是克隆的子模块在父项目中存在的相对位置。如果没有给出 <路径>，则使用源仓库的规范部分（\"repo\" 表示 \"/path/to/repo.git\"，\"foo\" 表示 \"host.xz:foo/.git\"）。如果 <路径> 存在并且已经是一个有效的 Git 仓库，那么它将被暂存提交，而无需克隆。<路径> 也被用作子模块在其配置项中的逻辑名称，除非用 `--name` 来指定一个逻辑名称。"

#. type: Plain text
#: en/git-submodule.txt:74
#, priority:220
msgid "The given URL is recorded into `.gitmodules` for use by subsequent users cloning the superproject. If the URL is given relative to the superproject's repository, the presumption is the superproject and submodule repositories will be kept together in the same relative location, and only the superproject's URL needs to be provided.  git-submodule will correctly locate the submodule using the relative URL in `.gitmodules`."
msgstr "给定的 URL 被记录到 `.gitmodules` 中，供后续用户克隆父项目时使用。如果 URL 是相对于父项目的仓库给出的，则假定父项目和子模块仓库将被保存在同一相对位置，只需要提供父项目的URL。git-submodule 将使用 `.gitmodules` 中的相对 URL 正确定位子模块。"

#. type: Labeled list
#: en/git-submodule.txt:75
#, ignore-ellipsis, no-wrap, priority:220
msgid "status [--cached] [--recursive] [--] [<path>...]"
msgstr "status [--cached] [--recursive] [--] [<路径>...]"

#. type: Plain text
#: en/git-submodule.txt:83
#, priority:220
msgid "Show the status of the submodules. This will print the SHA-1 of the currently checked out commit for each submodule, along with the submodule path and the output of 'git describe' for the SHA-1. Each SHA-1 will possibly be prefixed with `-` if the submodule is not initialized, `+` if the currently checked out submodule commit does not match the SHA-1 found in the index of the containing repository and `U` if the submodule has merge conflicts."
msgstr "显示子模块的状态。这将打印每个子模块当前检出提交的 SHA-1，以及子模块的路径和 SHA-1 的 'git describe' 的输出。如果子模块没有被初始化，每个SHA-1 的前缀可能是 `-`；如果当前签出的子模块提交与包含仓库的索引中发现的 SHA-1 不匹配，则是 `+`；如果子模块有合并冲突，则是 `U`。"

#. type: Plain text
#: en/git-submodule.txt:86
#, priority:220
msgid "If `--cached` is specified, this command will instead print the SHA-1 recorded in the superproject for each submodule."
msgstr "如果指定了 `--cached`，这个命令将代替打印每个子模块父项目中记录的 SHA-1。"

#. type: Plain text
#: en/git-submodule.txt:89
#, priority:220
msgid "If `--recursive` is specified, this command will recurse into nested submodules, and show their status as well."
msgstr "如果指定了 `--recursive`，该命令将递归到嵌套的子模块，并显示它们的状态。"

#. type: Plain text
#: en/git-submodule.txt:94
#, priority:220
msgid "If you are only interested in changes of the currently initialized submodules with respect to the commit recorded in the index or the HEAD, linkgit:git-status[1] and linkgit:git-diff[1] will provide that information too (and can also report changes to a submodule's work tree)."
msgstr "如果你只对当前初始化的子模块相对于索引或 HEAD 中记录的提交的变化感兴趣，linkgit:git-status[1] 和 linkgit:git-diff[1] 也会提供这些信息（也可以报告一个子模块工作目录的变化）。"

#. type: Labeled list
#: en/git-submodule.txt:95
#, ignore-ellipsis, no-wrap, priority:220
msgid "init [--] [<path>...]"
msgstr "init [--] [<路径>...]"

#. type: Plain text
#: en/git-submodule.txt:102
#, fuzzy, priority:220
#| msgid "Initialize the submodules recorded in the index (which were added and committed elsewhere) by setting `submodule.$name.url` in .git/config. It uses the same setting from `.gitmodules` as a template. If the URL is relative, it will be resolved using the default remote. If there is no default remote, the current repository will be assumed to be upstream."
msgid "Initialize the submodules recorded in the index (which were added and committed elsewhere) by setting `submodule.$name.url` in `.git/config`, using the same setting from `.gitmodules` as a template. If the URL is relative, it will be resolved using the default remote. If there is no default remote, the current repository will be assumed to be upstream."
msgstr "通过在 .git/config 中设置 `submodule.$name.url` 来初始化索引中记录的子模块（这些子模块在其他地方被添加和提交）。它使用来自 `.gitmodules` 的相同设置作为模板。如果 URL 是相对的，它将使用默认的远程进行解析。如果没有默认的远程，当前的仓库将被假定为上游仓库。"

#. type: Plain text
#: en/git-submodule.txt:107
#, priority:220
msgid "Optional <path> arguments limit which submodules will be initialized.  If no path is specified and submodule.active has been configured, submodules configured to be active will be initialized, otherwise all submodules are initialized."
msgstr "可选的 <路径> 参数限制哪些子模块将被初始化。 如果没有指定路径，并且已经配置了 submodule.active，配置为激活的子模块将被初始化，否则所有的子模块都被初始化。"

#. type: Plain text
#: en/git-submodule.txt:112
#, priority:220
msgid "It will also copy the value of `submodule.$name.update`, if present in the `.gitmodules` file, to `.git/config`, but (1) this command does not alter existing information in `.git/config`, and (2) `submodule.$name.update` that is set to a custom command is *not* copied for security reasons."
msgstr ""

#. type: Plain text
#: en/git-submodule.txt:118
#, fuzzy, priority:220
#| msgid "When present, it will also copy the value of `submodule.$name.update`.  This command does not alter existing information in .git/config.  You can then customize the submodule clone URLs in .git/config for your local setup and proceed to `git submodule update`; you can also just use `git submodule update --init` without the explicit 'init' step if you do not intend to customize any submodule locations."
msgid "You can then customize the submodule clone URLs in `.git/config` for your local setup and proceed to `git submodule update`; you can also just use `git submodule update --init` without the explicit 'init' step if you do not intend to customize any submodule locations."
msgstr "当出现时，它也将复制 `submodule.$name.update` 的值。 这个命令不会改变 .git/config 中的现有信息。 然后你可以在 .git/config 中为你的本地设置定制子模块克隆 URLs，并继续运行 `git submodule update`；如果你不打算定制任何子模块的位置，你也可以直接使用 `git submodule update --init` 而不使用明确的 'init' 步驟。"

#. type: Plain text
#: en/git-submodule.txt:120
#, priority:220
msgid "See the add subcommand for the definition of default remote."
msgstr "关于默认远程的定义，请参见 add 的子命令。"

#. type: Labeled list
#: en/git-submodule.txt:121
#, ignore-ellipsis, no-wrap, priority:220
msgid "deinit [-f|--force] (--all|[--] <path>...)"
msgstr "deinit [-f|--force] (--all|[--] <路径>...)"

#. type: Plain text
#: en/git-submodule.txt:128
#, priority:220
msgid "Unregister the given submodules, i.e. remove the whole `submodule.$name` section from .git/config together with their work tree. Further calls to `git submodule update`, `git submodule foreach` and `git submodule sync` will skip any unregistered submodules until they are initialized again, so use this command if you don't want to have a local checkout of the submodule in your working tree anymore."
msgstr "取消注册给定的子模块，即从 .git/config 中删除整个 `submodule.$name` 部分以及它们的工作目录。进一步调用 `git submodule update`，`git submodule foreach` 和 `git submodule sync` 将跳过任何未注册的子模块，直到它们再次被初始化，所以如果你不想在你的工作区上有一个本地的子模块检出，请使用这个命令。"

#. type: Plain text
#: en/git-submodule.txt:131
#, priority:220
msgid "When the command is run without pathspec, it errors out, instead of deinit-ing everything, to prevent mistakes."
msgstr "当命令在没有路径规范的情况下运行时，它会出错，而不是删除所有内容，以防错误。"

#. type: Plain text
#: en/git-submodule.txt:134
#, priority:220
msgid "If `--force` is specified, the submodule's working tree will be removed even if it contains local modifications."
msgstr "如果指定了 `--force`，子模块的工作目录将被删除，即使它包含了本地的修改。"

#. type: Plain text
#: en/git-submodule.txt:138
#, priority:220
msgid "If you really want to remove a submodule from the repository and commit that use linkgit:git-rm[1] instead. See linkgit:gitsubmodules[7] for removal options."
msgstr "如果你真的想从仓库中删除一个子模块并提交，请使用 linkgit:git-rm[1] 代替。参见 linkgit:gitsubmodules[7] 的删除选项。"

#. type: Labeled list
#: en/git-submodule.txt:139
#, ignore-ellipsis, no-wrap, priority:220
msgid "update [--init] [--remote] [-N|--no-fetch] [--[no-]recommend-shallow] [-f|--force] [--checkout|--rebase|--merge] [--reference <repository>] [--depth <depth>] [--recursive] [--jobs <n>] [--[no-]single-branch] [--filter <filter spec>] [--] [<path>...]"
msgstr "update [--init] [--remote] [-N|--no-fetch] [--[no-]recommend-shallow] [-f|--force] [--checkout|--rebase|--merge] [--reference <仓库>] [--depth <深度>] [--recursive] [--jobs <数量>] [--[no-]single-branch] [--filter <过滤规范>] [--] [<路径>...]"

#. type: Plain text
#: en/git-submodule.txt:153
#, fuzzy, priority:220
#| msgid "Update the registered submodules to match what the superproject expects by cloning missing submodules, fetching missing commits in submodules and updating the working tree of the submodules. The \"updating\" can be done in several ways depending on command line options and the value of `submodule.<name>.update` configuration variable. The command line option takes precedence over the configuration variable. If neither is given, a 'checkout' is performed.  The 'update' procedures supported both from the command line as well as through the `submodule.<name>.update` configuration are:"
msgid "Update the registered submodules to match what the superproject expects by cloning missing submodules, fetching missing commits in submodules and updating the working tree of the submodules. The \"updating\" can be done in several ways depending on command line options and the value of `submodule.<name>.update` configuration variable. The command line option takes precedence over the configuration variable. If neither is given, a 'checkout' is performed.  (note: what is in `.gitmodules` file is irrelevant at this point; see `git submodule init` above for how `.gitmodules` is used).  The 'update' procedures supported both from the command line as well as through the `submodule.<name>.update` configuration are:"
msgstr "通过克隆缺失的子模块，获取子模块中缺失的提交，以及更新子模块的工作区，来更新注册的子模块，以符合父项目的期望。\"更新\" 可以通过几种方式进行，取决于命令行选项和 `submodule.<名称>.update` 配置变量的值。命令行选项优先于配置变量。如果两者都没有给出，就会执行 \"检查\"。 从命令行以及通过 `submodule.<名称>.update` 配置所支持的 'update' 程序是："

#. type: Labeled list
#: en/git-submodule.txt:154
#, fuzzy, no-wrap, priority:220
msgid "checkout"
msgstr "结账"

#. type: Plain text
#: en/git-submodule.txt:156
#, priority:220
msgid "the commit recorded in the superproject will be checked out in the submodule on a detached HEAD."
msgstr "在父项目中记录的提交将在分离的 HEAD 上的子模块中检出。"

#. type: Plain text
#: en/git-submodule.txt:161
#, priority:220
msgid "If `--force` is specified, the submodule will be checked out (using `git checkout --force`), even if the commit specified in the index of the containing repository already matches the commit checked out in the submodule."
msgstr "如果指定了 `--force` ，子模块将被检出（使用 `git checkout --force`），即使在包含仓库的索引中指定的提交已经与子模块中检出的提交匹配。"

#. type: Labeled list
#: en/git-submodule.txt:162
#, fuzzy, no-wrap, priority:220
msgid "rebase"
msgstr "--rebase"

#. type: Plain text
#: en/git-submodule.txt:164
#, priority:220
msgid "the current branch of the submodule will be rebased onto the commit recorded in the superproject."
msgstr "子模块的当前分支将被变基到父项目中记录的提交上。"

#. type: Plain text
#: en/git-submodule.txt:167
#, priority:220
msgid "the commit recorded in the superproject will be merged into the current branch in the submodule."
msgstr "父项目中记录的提交将被合并到子模块中的当前分支。"

#. type: Plain text
#: en/git-submodule.txt:169
#, priority:220
msgid "The following update procedures have additional limitations:"
msgstr ""

#. type: Labeled list
#: en/git-submodule.txt:170
#, no-wrap, priority:220
msgid "custom command"
msgstr "自定义命令"

#. type: Plain text
#: en/git-submodule.txt:177
#, priority:220
msgid "mechanism for running arbitrary commands with the commit ID as an argument. Specifically, if the `submodule.<name>.update` configuration variable is set to `!custom command`, the object name of the commit recorded in the superproject for the submodule is appended to the `custom command` string and executed. Note that this mechanism is not supported in the `.gitmodules` file or on the command line."
msgstr ""

#. type: Plain text
#: en/git-submodule.txt:180
#, priority:220
msgid "the submodule is not updated. This update procedure is not allowed on the command line."
msgstr ""

#. type: Plain text
#: en/git-submodule.txt:184
#, priority:220
msgid "If the submodule is not yet initialized, and you just want to use the setting as stored in `.gitmodules`, you can automatically initialize the submodule with the `--init` option."
msgstr "如果子模块还没有被初始化，而你只是想使用存储在 `.gitmodules` 中的设置，你可以用 `--init` 选项自动初始化子模块。"

#. type: Plain text
#: en/git-submodule.txt:187
#, priority:220
msgid "If `--recursive` is specified, this command will recurse into the registered submodules, and update any nested submodules within."
msgstr "如果指定了`--recursive`，该命令将递归到已注册的子模块中，并更新其中的任何嵌套子模块。"

#. type: Plain text
#: en/git-submodule.txt:191
#, priority:220
msgid "If `--filter <filter spec>` is specified, the given partial clone filter will be applied to the submodule. See linkgit:git-rev-list[1] for details on filter specifications."
msgstr "如果指定了 `--filter <过滤规范>`，给定的部分克隆过滤器将被应用于子模块。关于过滤器规格细节，见 linkgit:git-rev-list[1]。"

#. type: Labeled list
#: en/git-submodule.txt:192
#, no-wrap, priority:220
msgid "set-branch (-b|--branch) <branch> [--] <path>"
msgstr "set-branch (-b|--branch) <分支> [--] <路径>"

#. type: Labeled list
#: en/git-submodule.txt:193
#, no-wrap, priority:220
msgid "set-branch (-d|--default) [--] <path>"
msgstr "set-branch (-d|--default) [--] <路径>"

#. type: Plain text
#: en/git-submodule.txt:198
#, priority:220
msgid "Sets the default remote tracking branch for the submodule. The `--branch` option allows the remote branch to be specified. The `--default` option removes the submodule.<name>.branch configuration key, which causes the tracking branch to default to the remote 'HEAD'."
msgstr "设置子模块的默认远程跟踪分支。`--branch` 选项允许指定远程分支。`--default` 选项删除 submodule.<名称>.branch 配置键，使跟踪分支默认为远程 'HEAD'。"

#. type: Labeled list
#: en/git-submodule.txt:199
#, no-wrap, priority:220
msgid "set-url [--] <path> <newurl>"
msgstr "set-url [--] <路径> <新url>"

#. type: Plain text
#: en/git-submodule.txt:203
#, priority:220
msgid "Sets the URL of the specified submodule to <newurl>. Then, it will automatically synchronize the submodule's new remote URL configuration."
msgstr "将指定子模块的 URL 设置为 <新url>。然后，它将自动同步子模块的新远程 URL 配置。"

#. type: Labeled list
#: en/git-submodule.txt:204
#, ignore-ellipsis, no-wrap, priority:220
msgid "summary [--cached|--files] [(-n|--summary-limit) <n>] [commit] [--] [<path>...]"
msgstr "summary [--cached|--files] [(-n|--summary-limit) <数量>] [commit] [--] [<路径>...]"

#. type: Plain text
#: en/git-submodule.txt:213
#, priority:220
msgid "Show commit summary between the given commit (defaults to HEAD) and working tree/index. For a submodule in question, a series of commits in the submodule between the given super project commit and the index or working tree (switched by `--cached`) are shown. If the option `--files` is given, show the series of commits in the submodule between the index of the super project and the working tree of the submodule (this option doesn't allow to use the `--cached` option or to provide an explicit commit)."
msgstr "显示指定的提交（默认为 HEAD）和工作区/索引之间的提交摘要。对于一个相关的子模块，显示该子模块在给定的父项目提交和索引或工作区（由 `--cached` 切换）之间的一系列提交。如果给出选项 `--files`，则显示父项目的索引和子模块的工作区之间的一系列提交（这个选项不允许使用 `--cached` 选项或提供明确的提交）。"

#. type: Plain text
#: en/git-submodule.txt:216
#, priority:220
msgid "Using the `--submodule=log` option with linkgit:git-diff[1] will provide that information too."
msgstr "使用 linkgit:git-diff[1] 的 `--submodule=log` 选项也会提供这些信息。"

#. type: Labeled list
#: en/git-submodule.txt:217
#, no-wrap, priority:220
msgid "foreach [--recursive] <command>"
msgstr "foreach [--recursive] <命令>"

#. type: Plain text
#: en/git-submodule.txt:238
#, priority:220
msgid "Evaluates an arbitrary shell command in each checked out submodule.  The command has access to the variables $name, $sm_path, $displaypath, $sha1 and $toplevel: $name is the name of the relevant submodule section in `.gitmodules`, $sm_path is the path of the submodule as recorded in the immediate superproject, $displaypath contains the relative path from the current working directory to the submodules root directory, $sha1 is the commit as recorded in the immediate superproject, and $toplevel is the absolute path to the top-level of the immediate superproject.  Note that to avoid conflicts with '$PATH' on Windows, the '$path' variable is now a deprecated synonym of '$sm_path' variable.  Any submodules defined in the superproject but not checked out are ignored by this command. Unless given `--quiet`, foreach prints the name of each submodule before evaluating the command.  If `--recursive` is given, submodules are traversed recursively (i.e.  the given shell command is evaluated in nested submodules as well).  A non-zero return from the command in any submodule causes the processing to terminate. This can be overridden by adding '|| :' to the end of the command."
msgstr "在每个签出的子模块中评估一个任意的 shell 命令。 该命令可以访问变量 $name、$sm_path、$displaypath、$sha1 和 $toplevel：$name 是 `.gitmodules` 中相关子模块部分的名称，$sm_path 是即时父项目中记录的子模块的路径，$displaypath 包含从当前工作目录到子模块根目录的相对路径，$sha1 是即时父项目中记录的提交，而$toplevel 是即时父项目的顶级的绝对路径。 注意，为了避免与 Windows 上的 '$PATH' 冲突，'$path' 变量现在是 '$sm_path' 变量的一个废弃的同义词。 任何在父项目中定义但没有检查出来的子模块都会被这个命令忽略。除非给出 `--quiet`，否则 foreach 在评估命令前会打印出每个子模块的名字。 如果给定 `--recursive`，子模块将被递归遍历（即给定的 shel l命令在嵌套的子模块中也被评估）。 在任何子模块中，命令的非零返回将导致处理的终止。这可以通过在命令的末尾添加 '||:' 来覆盖。"

#. type: Plain text
#: en/git-submodule.txt:241
#, priority:220
msgid "As an example, the command below will show the path and currently checked out commit for each submodule:"
msgstr "作为一个例子，下面的命令将显示每个子模块的路径和当前检出的提交："

#. type: delimited block -
#: en/git-submodule.txt:244
#, fuzzy, no-wrap, priority:220
msgid "git submodule foreach 'echo $sm_path `git rev-parse HEAD`'\n"
msgstr "git submodule foreach 'echo $sm_path `git rev-parse HEAD`'\n"

#. type: Labeled list
#: en/git-submodule.txt:246
#, ignore-ellipsis, no-wrap, priority:220
msgid "sync [--recursive] [--] [<path>...]"
msgstr "sync [--recursive] [--] [<路径>...]"

#. type: Plain text
#: en/git-submodule.txt:253
#, priority:220
msgid "Synchronizes submodules' remote URL configuration setting to the value specified in `.gitmodules`. It will only affect those submodules which already have a URL entry in .git/config (that is the case when they are initialized or freshly added). This is useful when submodule URLs change upstream and you need to update your local repositories accordingly."
msgstr "将子模块的远程 URL 配置设置同步到 `.gitmodules` 中指定的值。它只会影响那些在 .git/config 中已经有一个 URL 条目的子模块（也就是当它们被初始化或新添加时的情况）。当子模块的 URL 在上游发生变化，你需要相应地更新你的本地仓库时，这很有用。"

#. type: Plain text
#: en/git-submodule.txt:256
#, priority:220
msgid "`git submodule sync` synchronizes all submodules while `git submodule sync -- A` synchronizes submodule \"A\" only."
msgstr "`git submodule sync` 同步所有子模块，而 `git submodule sync -- A` 只同步子模块 \"A\"。"

#. type: Plain text
#: en/git-submodule.txt:259
#, priority:220
msgid "If `--recursive` is specified, this command will recurse into the registered submodules, and sync any nested submodules within."
msgstr "如果指定了 `--recursive`，该命令将递归到已注册的子模块中，并同步其中的任何嵌套子模块。"

#. type: Labeled list
#: en/git-submodule.txt:260
#, no-wrap, priority:220
msgid "absorbgitdirs"
msgstr "吸附 gitdirs"

#. type: Plain text
#: en/git-submodule.txt:267
#, priority:220
msgid "If a git directory of a submodule is inside the submodule, move the git directory of the submodule into its superproject's `$GIT_DIR/modules` path and then connect the git directory and its working directory by setting the `core.worktree` and adding a .git file pointing to the git directory embedded in the superprojects git directory."
msgstr "如果一个子模块的 git 目录在子模块内部，将子模块的 git 目录移入其父项目的 `$GIT_DIR/modules` 路径，然后通过设置 `core.worktree` 连接 git 目录和其工作目录，并添加一个指向嵌入父项目 git 目录的 .git 文件。"

#. type: Plain text
#: en/git-submodule.txt:271
#, priority:220
msgid "A repository that was cloned independently and later added as a submodule or old setups have the submodules git directory inside the submodule instead of embedded into the superprojects git directory."
msgstr "一个独立克隆的仓库，后来被添加为子模块或旧的设置，其子模块的 git 目录在子模块内，而不是嵌入到父项目的 git 目录。"

#. type: Plain text
#: en/git-submodule.txt:273
#, priority:220
msgid "This command is recursive by default."
msgstr "这个命令默认是递归的。"

#. type: Plain text
#: en/git-submodule.txt:279
#, priority:220
msgid "Only print error messages."
msgstr "只打印出错误信息。"

#. type: Plain text
#: en/git-submodule.txt:286
#, priority:220
msgid "This option is only valid for add and update commands.  Progress status is reported on the standard error stream by default when it is attached to a terminal, unless -q is specified. This flag forces progress status even if the standard error stream is not directed to a terminal."
msgstr "这个选项只对添加和更新命令有效。 当标准错误流连接到终端时，除非指定了 -q，否则默认情况下进度状态会在标准错误流中报告。即使标准错误流没有指向终端，这个标志也会强制显示进度状态。"

#. type: Plain text
#: en/git-submodule.txt:290
#, priority:220
msgid "This option is only valid for the deinit command. Unregister all submodules in the working tree."
msgstr "这个选项只对 deinit 命令有效。取消工作区中所有子模块的注册。"

#. type: Labeled list
#: en/git-submodule.txt:291
#, no-wrap, priority:220
msgid "-b <branch>"
msgstr "-b <分支>"

#. type: Plain text
#: en/git-submodule.txt:299
#, priority:220
msgid "Branch of repository to add as submodule.  The name of the branch is recorded as `submodule.<name>.branch` in `.gitmodules` for `update --remote`.  A special value of `.` is used to indicate that the name of the branch in the submodule should be the same name as the current branch in the current repository.  If the option is not specified, it defaults to the remote 'HEAD'."
msgstr "仓库的分支，作为子模块添加。 分支的名称在 `.gitmodules` 中记录为 `submodule.<名称>.branch`，用于 `update --remote`。 一个特殊的值 `.` 用来表示子模块中的分支名称应该与当前版本库中的当前分支名称相同。 如果没有指定该选项，则默认为远程 'HEAD'。"

#. type: Plain text
#: en/git-submodule.txt:312
#, priority:220
msgid "This option is only valid for add, deinit and update commands.  When running add, allow adding an otherwise ignored submodule path.  When running deinit the submodule working trees will be removed even if they contain local changes.  When running update (only effective with the checkout procedure), throw away local changes in submodules when switching to a different commit; and always run a checkout operation in the submodule, even if the commit listed in the index of the containing repository matches the commit checked out in the submodule."
msgstr "这个选项只对 add、deinit 和 update 命令有效。 当运行 add 时，允许添加一个原本被忽略的子模块路径。 当运行 deinit 时，子模块的工作目录将被删除，即使它们包含本地的变化。 当运行 update（仅对 checkout 程序有效）时，当切换到不同的提交时，丢弃子模块中的本地修改；并且总是在子模块中运行 checkout 操作，即使在包含仓库的索引中列出的提交与子模块中签出的提交相匹配。"

#. type: Plain text
#: en/git-submodule.txt:317
#, priority:220
msgid "This option is only valid for status and summary commands.  These commands typically use the commit found in the submodule HEAD, but with this option, the commit stored in the index is used instead."
msgstr "这个选项只对状态和摘要命令有效。 这些命令通常使用在子模块 HEAD 中找到的提交，但有了这个选项，就会使用存储在索引中的提交。"

#. type: Labeled list
#: en/git-submodule.txt:318
#, ignore-same, no-wrap, priority:220
msgid "--files"
msgstr "--files"

#. type: Plain text
#: en/git-submodule.txt:322
#, priority:220
msgid "This option is only valid for the summary command. This command compares the commit in the index with that in the submodule HEAD when this option is used."
msgstr "这个选项只对 summary 命令有效。当使用这个选项时，该命令将索引中的提交与子模块 HEAD 中的提交进行比较。"

#. type: Labeled list
#: en/git-submodule.txt:324
#, ignore-same, no-wrap, priority:220
msgid "--summary-limit"
msgstr "--summary-limit"

#. type: Plain text
#: en/git-submodule.txt:330
#, priority:220
msgid "This option is only valid for the summary command.  Limit the summary size (number of commits shown in total).  Giving 0 will disable the summary; a negative number means unlimited (the default). This limit only applies to modified submodules. The size is always limited to 1 for added/deleted/typechanged submodules."
msgstr "这个选项只对 summary 命令有效。 限制摘要的大小（总共显示的提交数量）。 给予 0 将禁用摘要；负数意味着无限（默认）。这个限制只适用于修改过的子模块。对于新增/删除/类型改变的子模块，其大小总是限制为 1。"

#. type: Labeled list
#: en/git-submodule.txt:331
#, ignore-same, no-wrap, priority:220
msgid "--remote"
msgstr "--remote"

#. type: Plain text
#: en/git-submodule.txt:340
#, priority:220
msgid "This option is only valid for the update command.  Instead of using the superproject's recorded SHA-1 to update the submodule, use the status of the submodule's remote-tracking branch.  The remote used is branch's remote (`branch.<name>.remote`), defaulting to `origin`.  The remote branch used defaults to the remote `HEAD`, but the branch name may be overridden by setting the `submodule.<name>.branch` option in either `.gitmodules` or `.git/config` (with `.git/config` taking precedence)."
msgstr "这个选项只对更新命令有效。 不使用超级项目记录的 SHA-1 来更新子模块，而使用子模块的远程跟踪分支的状态。 使用的远程是分支的远程（`branch.<名称>.remote`），默认为 `origin`。 使用的远程分支默认为远程的 `HEAD`，但分支的名称可以通过在 `.gitmodules` 或 `.git/config` 中设置 `submodule.<名称>.branch` 选项来覆盖（以`.git/config`为先）。"

#. type: Plain text
#: en/git-submodule.txt:346
#, priority:220
msgid "This works for any of the supported update procedures (`--checkout`, `--rebase`, etc.).  The only change is the source of the target SHA-1.  For example, `submodule update --remote --merge` will merge upstream submodule changes into the submodules, while `submodule update --merge` will merge superproject gitlink changes into the submodules."
msgstr "这适用于任何支持的更新程序（`--checkout`，`--rebase`，等等）。  唯一的变化是目标 SHA-1 的来源。  例如，`submodule update --remote --merge` 将把上游子模块的变化合并到子模块中，而 `submodule update --merge` 将把父项目的 gitlink 变化合并到子模块。"

#. type: Plain text
#: en/git-submodule.txt:351
#, priority:220
msgid "In order to ensure a current tracking branch state, `update --remote` fetches the submodule's remote repository before calculating the SHA-1.  If you don't want to fetch, you should use `submodule update --remote --no-fetch`."
msgstr "为了确保当前的跟踪分支状态，`update --remote` 在计算 SHA-1 之前会获取子模块的远程仓库。  如果你不想获取，你应该使用`submodule update --remote --no-fetch`。"

#. type: Plain text
#: en/git-submodule.txt:361
#, priority:220
msgid "Use this option to integrate changes from the upstream subproject with your submodule's current HEAD.  Alternatively, you can run `git pull` from the submodule, which is equivalent except for the remote branch name: `update --remote` uses the default upstream repository and `submodule.<name>.branch`, while `git pull` uses the submodule's `branch.<name>.merge`.  Prefer `submodule.<name>.branch` if you want to distribute the default upstream branch with the superproject and `branch.<name>.merge` if you want a more native feel while working in the submodule itself."
msgstr "使用这个选项可以将上游子项目的变化与你的子模块的当前 HEAD 集成。 或者，你可以从子模块运行 `git pull`，除了远程分支名称外，其他都是一样的：`update --remote` 使用默认的上游仓库和 `submodule.<名称>.branch`，而 `git pull` 使用子模块的 `branch.<名称>.merge`。 如果你想和父项目一起发布默认的上游分支，那么首选 `submodule.<名称>.branch`，如果你想在子模块本身工作时有更多的本地感觉，那么首选 `branch.<名称>.merge`。"

#. type: Labeled list
#: en/git-submodule.txt:363
#, ignore-same, no-wrap, priority:220
msgid "--no-fetch"
msgstr "--no-fetch"

#. type: Plain text
#: en/git-submodule.txt:366
#, priority:220
msgid "This option is only valid for the update command.  Don't fetch new objects from the remote site."
msgstr "这个选项只对 update 命令有效。 不要从远程站点获取新对象。"

#. type: Labeled list
#: en/git-submodule.txt:367
#, ignore-same, no-wrap, priority:220
msgid "--checkout"
msgstr "--checkout"

#. type: Plain text
#: en/git-submodule.txt:375
#, priority:220
msgid "This option is only valid for the update command.  Checkout the commit recorded in the superproject on a detached HEAD in the submodule. This is the default behavior, the main use of this option is to override `submodule.$name.update` when set to a value other than `checkout`.  If the key `submodule.$name.update` is either not explicitly set or set to `checkout`, this option is implicit."
msgstr "这个选项只对 update 命令有效。 检出父项目中记录在子模块中的分离 HEAD 上的提交。这是默认行为，这个选项的主要用途是在设置为 `checkout` 以外的值时覆盖 `submodule.$name.update`。 如果键 `submodule.$name.update` 没有明确设置或设置为 `checkout`，这个选项是隐含的。"

#. type: Plain text
#: en/git-submodule.txt:385
#, priority:220
msgid "This option is only valid for the update command.  Merge the commit recorded in the superproject into the current branch of the submodule. If this option is given, the submodule's HEAD will not be detached. If a merge failure prevents this process, you will have to resolve the resulting conflicts within the submodule with the usual conflict resolution tools.  If the key `submodule.$name.update` is set to `merge`, this option is implicit."
msgstr "这个选项只对更新命令有效。 将父项目中记录的提交合并到子模块的当前分支中。如果给出这个选项，子模块的 HEAD 将不会被分离。如果合并失败阻止了这个过程，你将不得不用通常的冲突解决工具来解决子模块内产生的冲突。 如果键 `submodule.$name.update` 被设置为 `merge`，这个选项是隐含的。"

#. type: Labeled list
#: en/git-submodule.txt:386
#, ignore-same, no-wrap, priority:220
msgid "--rebase"
msgstr "--rebase"

#. type: Plain text
#: en/git-submodule.txt:394
#, priority:220
msgid "This option is only valid for the update command.  Rebase the current branch onto the commit recorded in the superproject. If this option is given, the submodule's HEAD will not be detached. If a merge failure prevents this process, you will have to resolve these failures with linkgit:git-rebase[1].  If the key `submodule.$name.update` is set to `rebase`, this option is implicit."
msgstr "这个选项只对 update 命令有效。 将当前分支重新归入超级项目中记录的提交。如果给了这个选项，子模块的 HEAD 将不会被分离。如果合并失败阻止了这个过程，你将不得不用 linkgit:git-rebase[1] 解决这些失败。 如果键 `submodule.$name.update` 被设置为 `rebase`，这个选项是隐含的。"

#. type: Labeled list
#: en/git-submodule.txt:395
#, ignore-same, no-wrap, priority:220
msgid "--init"
msgstr "--init"

#. type: Plain text
#: en/git-submodule.txt:399
#, priority:220
msgid "This option is only valid for the update command.  Initialize all submodules for which \"git submodule init\" has not been called so far before updating."
msgstr "这个选项只对 update 命令有效。 在更新前初始化所有到目前为止还没有调用过 \"git submodule init \" 的子模块。"

#. type: Labeled list
#: en/git-submodule.txt:400
#, ignore-same, no-wrap, priority:220
msgid "--name"
msgstr "--name"

#. type: Plain text
#: en/git-submodule.txt:404
#, priority:220
msgid "This option is only valid for the add command. It sets the submodule's name to the given string instead of defaulting to its path. The name must be valid as a directory name and may not end with a '/'."
msgstr "这个选项只对 add 命令有效。它将子模块的名称设置为给定的字符串，而不是默认为其路径。这个名字必须是有效的目录名，并且不能以 '/' 结尾。"

#. type: Labeled list
#: en/git-submodule.txt:405
#, fuzzy, no-wrap, priority:220
msgid "--reference <repository>"
msgstr "--reference <repository>"

#. type: Plain text
#: en/git-submodule.txt:409 en/git-submodule.txt:418
#, priority:220
msgid "This option is only valid for add and update commands.  These commands sometimes need to clone a remote repository. In this case, this option will be passed to the linkgit:git-clone[1] command."
msgstr "这个选项只对添加和更新命令有效。 这些命令有时需要克隆一个远程版本库。在这种情况下，这个选项将被传递给 linkgit:git-clone[1] 命令。"

#. type: Plain text
#: en/git-submodule.txt:413
#, no-wrap, priority:220
msgid ""
"*NOTE*: Do *not* use this option unless you have read the note\n"
"for linkgit:git-clone[1]'s `--reference`, `--shared`, and `--dissociate`\n"
"options carefully.\n"
msgstr ""
"*注意*： 请*不要*使用这个选项，除非你已经阅读了\n"
"linkgit:git-clone[1] 的 `--reference`, `--shared`, 和 `--dissociate` 选项前\n"
"谨慎使用这个选项。\n"

#. type: Plain text
#: en/git-submodule.txt:420
#, no-wrap, priority:220
msgid "*NOTE*: see the NOTE for the `--reference` option.\n"
msgstr "*注意*：参见 `--reference` 选项的说明。\n"

#. type: Plain text
#: en/git-submodule.txt:426
#, priority:220
msgid "This option is only valid for foreach, update, status and sync commands.  Traverse submodules recursively. The operation is performed not only in the submodules of the current repo, but also in any nested submodules inside those submodules (and so on)."
msgstr "这个选项只对 foreach、update、status 和 sync 命令有效。 递归地遍历子模块。该操作不仅在当前仓库的子模块中执行，而且在这些子模块内部的任何嵌套子模块中也执行（以此类推）。"

#. type: Labeled list
#: en/git-submodule.txt:427
#, ignore-same, no-wrap, priority:220
msgid "--depth"
msgstr "--depth"

#. type: Plain text
#: en/git-submodule.txt:431
#, priority:220
msgid "This option is valid for add and update commands. Create a 'shallow' clone with a history truncated to the specified number of revisions.  See linkgit:git-clone[1]"
msgstr "这个选项对 update 和 add 命令有效。创建一个 'shallow' 克隆，其历史被截断到指定的修订次数。 参见 linkgit:git-clone[1]"

#. type: Labeled list
#: en/git-submodule.txt:432
#, ignore-same, no-wrap, priority:220
msgid "--[no-]recommend-shallow"
msgstr "--[no-]recommend-shallow"

#. type: Plain text
#: en/git-submodule.txt:437
#, priority:220
msgid "This option is only valid for the update command.  The initial clone of a submodule will use the recommended `submodule.<name>.shallow` as provided by the `.gitmodules` file by default. To ignore the suggestions use `--no-recommend-shallow`."
msgstr "这个选项只对更新命令有效。 一个子模块的初始克隆将默认使用 `.gitmodules` 文件提供的推荐的 `submodule.<名称>.shallow`。要忽略这些建议，请使用 `--no-recommend-shallow`。"

#. type: Plain text
#: en/git-submodule.txt:443
#, priority:220
msgid "This option is only valid for the update command.  Clone new submodules in parallel with as many jobs.  Defaults to the `submodule.fetchJobs` option."
msgstr "这个选项只对更新命令有效。 克隆新的子模块与尽可能多的作业并行。 默认为 `submodule.fetchJobs` 选项。"

#. type: Plain text
#: en/git-submodule.txt:447
#, priority:220
msgid "This option is only valid for the update command.  Clone only one branch during update: HEAD or one specified by --branch."
msgstr "这个选项只对 update 命令有效。 在更新过程中只克隆一个分支：HEAD 或由 --branch 指定的一个分支。"

#. type: Plain text
#: en/git-submodule.txt:452
#, priority:220
msgid "Paths to submodule(s). When specified this will restrict the command to only operate on the submodules found at the specified paths.  (This argument is required with add)."
msgstr "子模块的路径。当指定时，这将限制该命令只对在指定路径上发现的子模块进行操作。 (这个参数在添加时是必需的）。"

#. type: Plain text
#: en/git-submodule.txt:460
#, priority:220
msgid "When initializing submodules, a `.gitmodules` file in the top-level directory of the containing repository is used to find the url of each submodule.  This file should be formatted in the same way as `$GIT_DIR/config`. The key to each submodule url is \"submodule.$name.url\".  See linkgit:gitmodules[5] for details."
msgstr "当初始化子模块时，在包含仓库的顶级目录中的 `.gitmodules` 文件被用来寻找每个子模块的 URL。 这个文件的格式应该与 `$GIT_DIR/config` 相同。每个子模块网址的键是 \"submodule.$name.url\"。 详情见 linkgit:gitmodules[5]。"

#. type: Plain text
#: en/git-submodule.txt:464
#, ignore-same, priority:220
msgid "linkgit:gitsubmodules[7], linkgit:gitmodules[5]."
msgstr "linkgit:gitsubmodules[7], linkgit:gitmodules[5]."

#. type: Title =
#: en/git-svn.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-svn(1)"
msgstr "git-svn(1)"

#. type: Plain text
#: en/git-svn.txt:7
#, fuzzy, priority:100
msgid "git-svn - Bidirectional operation between a Subversion repository and Git"
msgstr "git-svn - Bidirectional operation between a Subversion repository and Git"

#. type: Plain text
#: en/git-svn.txt:12
#, no-wrap, priority:100
msgid "'git svn' <command> [<options>] [<arguments>]\n"
msgstr ""

#. type: Plain text
#: en/git-svn.txt:18
#, fuzzy, priority:100
msgid "'git svn' is a simple conduit for changesets between Subversion and Git.  It provides a bidirectional flow of changes between a Subversion and a Git repository."
msgstr "'git svn' is a simple conduit for changesets between Subversion and Git.  It provides a bidirectional flow of changes between a Subversion and a Git repository."

#. type: Plain text
#: en/git-svn.txt:23
#, fuzzy, priority:100
msgid "'git svn' can track a standard Subversion repository, following the common \"trunk/branches/tags\" layout, with the --stdlayout option.  It can also follow branches and tags in any layout with the -T/-t/-b options (see options to 'init' below, and also the 'clone' command)."
msgstr "'git svn' can track a standard Subversion repository, following the common \"trunk/branches/tags\" layout, with the --stdlayout option.  It can also follow branches and tags in any layout with the -T/-t/-b options (see options to 'init' below, and also the 'clone' command)."

#. type: Plain text
#: en/git-svn.txt:27
#, fuzzy, priority:100
msgid "Once tracking a Subversion repository (with any of the above methods), the Git repository can be updated from Subversion by the 'fetch' command and Subversion updated from Git by the 'dcommit' command."
msgstr "跟踪 Subversion 仓库（使用上述任何方法）后，可以通过 'fetch' 命令从 Subversion 更新 Git 仓库，并通过 'dcommit' 命令从 Git 更新 Subversion 仓库。"

#. type: Labeled list
#: en/git-svn.txt:31
#, ignore-same, no-wrap, priority:100
msgid "'init'"
msgstr "'init'"

#. type: Plain text
#: en/git-svn.txt:39
#, fuzzy, priority:100
msgid "Initializes an empty Git repository with additional metadata directories for 'git svn'.  The Subversion URL may be specified as a command-line argument, or as full URL arguments to -T/-t/-b.  Optionally, the target directory to operate on can be specified as a second argument.  Normally this command initializes the current directory."
msgstr "为 'git svn' 初始化一个空的 Git 仓库，并添加元数据目录。  Subversion 的 URL 可以作为命令行参数，也可以作为 -T/-t/-b 的完整 URL 参数。  或者，可以指定要操作的目标目录作为第二参数。  通常情况下这个命令会在当前目录进行初始化。"

#. type: Labeled list
#: en/git-svn.txt:40
#, fuzzy, no-wrap, priority:100
msgid "-T<trunk_subdir>"
msgstr "-T<trunk_subdir>"

#. type: Labeled list
#: en/git-svn.txt:41
#, fuzzy, no-wrap, priority:100
msgid "--trunk=<trunk_subdir>"
msgstr "--trunk=<trunk_subdir>"

#. type: Labeled list
#: en/git-svn.txt:42
#, fuzzy, no-wrap, priority:100
msgid "-t<tags_subdir>"
msgstr "-t<tags_subdir>"

#. type: Labeled list
#: en/git-svn.txt:43
#, fuzzy, no-wrap, priority:100
msgid "--tags=<tags_subdir>"
msgstr "--tags=<tags_subdir>"

#. type: Labeled list
#: en/git-svn.txt:44
#, fuzzy, no-wrap, priority:100
msgid "-b<branches_subdir>"
msgstr "-b<branches_subdir>"

#. type: Labeled list
#: en/git-svn.txt:45
#, fuzzy, no-wrap, priority:100
msgid "--branches=<branches_subdir>"
msgstr "--branches=<branches_subdir>"

#. type: Labeled list
#: en/git-svn.txt:47
#, ignore-same, no-wrap, priority:100
msgid "--stdlayout"
msgstr "--stdlayout"

#. type: Plain text
#: en/git-svn.txt:58
#, fuzzy, priority:100
msgid "These are optional command-line options for init.  Each of these flags can point to a relative repository path (--tags=project/tags) or a full url (--tags=https://foo.org/project/tags).  You can specify more than one --tags and/or --branches options, in case your Subversion repository places tags or branches under multiple paths.  The option --stdlayout is a shorthand way of setting trunk,tags,branches as the relative paths, which is the Subversion default. If any of the other options are given as well, they take precedence."
msgstr "这些是用于 init 的可选命令行选项。  每个标志都可以指向相对的版本库路径 (-tags=project/tags) 或完整的 url (-tags=https://foo.org/project/tags)。  你可以指定多个 --tags 和/或 --branches 选项，以防你的 Subversion 仓库将标记或分支放在多个路径下。  选项 --stdlayout 是将 主干、标记、分支设置为相对路径的一种快捷方式，这是 Subversion 的默认设置。如果使用了其他的选项，它们将被优先考虑。"

#. type: Labeled list
#: en/git-svn.txt:58
#, ignore-same, no-wrap, priority:100
msgid "--no-metadata"
msgstr "--no-metadata"

#. type: Plain text
#: en/git-svn.txt:62
#, fuzzy, priority:100
msgid "Set the 'noMetadata' option in the [svn-remote] config.  This option is not recommended, please read the 'svn.noMetadata' section of this manpage before using this option."
msgstr "设置 [svn-remote] 配置的 'noMetadata' 选项。  不建议使用该选项，请在使用该选项前阅读本手册中 'svn.noMetadata' 部分。"

#. type: Labeled list
#: en/git-svn.txt:62
#, ignore-same, no-wrap, priority:100
msgid "--use-svm-props"
msgstr "--use-svm-props"

#. type: Plain text
#: en/git-svn.txt:64
#, fuzzy, priority:100
msgid "Set the 'useSvmProps' option in the [svn-remote] config."
msgstr "设置[svn-remote] 配置的 'useSvmProps' 选项。"

#. type: Labeled list
#: en/git-svn.txt:64
#, ignore-same, no-wrap, priority:100
msgid "--use-svnsync-props"
msgstr "--use-svnsync-props"

#. type: Plain text
#: en/git-svn.txt:66
#, fuzzy, priority:100
msgid "Set the 'useSvnsyncProps' option in the [svn-remote] config."
msgstr "设置 [svn-remote] 配置的 'useSvnsyncProps' 选项。"

#. type: Labeled list
#: en/git-svn.txt:66
#, fuzzy, no-wrap, priority:100
msgid "--rewrite-root=<URL>"
msgstr "--rewrite-root=<URL>"

#. type: Plain text
#: en/git-svn.txt:68
#, fuzzy, priority:100
msgid "Set the 'rewriteRoot' option in the [svn-remote] config."
msgstr "设置 [svn-remote] 配置的 'rewriteRoot' 选项。"

#. type: Labeled list
#: en/git-svn.txt:68
#, fuzzy, no-wrap, priority:100
msgid "--rewrite-uuid=<UUID>"
msgstr "--rewrite-uuid=<UUID>"

#. type: Plain text
#: en/git-svn.txt:70
#, fuzzy, priority:100
msgid "Set the 'rewriteUUID' option in the [svn-remote] config."
msgstr "设置 [svn-remote] 配置的 'rewriteUUID' 选项。"

#. type: Labeled list
#: en/git-svn.txt:70
#, fuzzy, no-wrap, priority:100
msgid "--username=<user>"
msgstr "--username=<user>"

#. type: Plain text
#: en/git-svn.txt:75
#, fuzzy, priority:100
msgid "For transports that SVN handles authentication for (http, https, and plain svn), specify the username.  For other transports (e.g. `svn+ssh://`), you must include the username in the URL, e.g. `svn+ssh://foo@svn.bar.com/project`"
msgstr "对于由 SVN 处理认证的传输类型（http、https和纯svn），请指定用户名。  对于其他的传输类型(例如`svn+ssh:///`)，你必须在URL中包含用户名，例如：`svn+ssh://foo@svn.bar.com/project`"

#. type: Plain text
#: en/git-svn.txt:90
#, priority:100
msgid "This allows one to specify a prefix which is prepended to the names of remotes if trunk/branches/tags are specified.  The prefix does not automatically include a trailing slash, so be sure you include one in the argument if that is what you want.  If --branches/-b is specified, the prefix must include a trailing slash.  Setting a prefix (with a trailing slash) is strongly encouraged in any case, as your SVN-tracking refs will then be located at \"refs/remotes/$prefix/*\", which is compatible with Git's own remote-tracking ref layout (refs/remotes/$remote/*). Setting a prefix is also useful if you wish to track multiple projects that share a common repository.  By default, the prefix is set to 'origin/'."
msgstr ""

#. type: Plain text
#: en/git-svn.txt:97
#, priority:100
msgid "Before Git v2.0, the default prefix was \"\" (no prefix). This meant that SVN-tracking refs were put at \"refs/remotes/*\", which is incompatible with how Git's own remote-tracking refs are organized.  If you still want the old default, you can get it by passing `--prefix \"\"` on the command line (`--prefix=\"\"` may not work if your Perl's Getopt::Long is < v2.37)."
msgstr ""

#. type: Labeled list
#: en/git-svn.txt:98 en/git-svn.txt:145
#, fuzzy, no-wrap, priority:100
msgid "--ignore-refs=<regex>"
msgstr "--ignore-refs=<regex>"

#. type: Plain text
#: en/git-svn.txt:102
#, priority:100
msgid "When passed to 'init' or 'clone' this regular expression will be preserved as a config key.  See 'fetch' for a description of `--ignore-refs`."
msgstr ""

#. type: Labeled list
#: en/git-svn.txt:102 en/git-svn.txt:157
#, fuzzy, no-wrap, priority:100
msgid "--ignore-paths=<regex>"
msgstr "--ignore-paths=<regex>"

#. type: Plain text
#: en/git-svn.txt:106
#, priority:100
msgid "When passed to 'init' or 'clone' this regular expression will be preserved as a config key.  See 'fetch' for a description of `--ignore-paths`."
msgstr ""

#. type: Labeled list
#: en/git-svn.txt:106 en/git-svn.txt:186
#, no-wrap, priority:100
msgid "--include-paths=<regex>"
msgstr ""

#. type: Plain text
#: en/git-svn.txt:110
#, priority:100
msgid "When passed to 'init' or 'clone' this regular expression will be preserved as a config key.  See 'fetch' for a description of `--include-paths`."
msgstr ""

#. type: Labeled list
#: en/git-svn.txt:110
#, ignore-same, no-wrap, priority:100
msgid "--no-minimize-url"
msgstr "--no-minimize-url"

#. type: Plain text
#: en/git-svn.txt:121
#, priority:100
msgid "When tracking multiple directories (using --stdlayout, --branches, or --tags options), git svn will attempt to connect to the root (or highest allowed level) of the Subversion repository.  This default allows better tracking of history if entire projects are moved within a repository, but may cause issues on repositories where read access restrictions are in place.  Passing `--no-minimize-url` will allow git svn to accept URLs as-is without attempting to connect to a higher level directory.  This option is off by default when only one URL/branch is tracked (it would do little good)."
msgstr ""

#. type: Labeled list
#: en/git-svn.txt:122
#, ignore-same, no-wrap, priority:100
msgid "'fetch'"
msgstr "'fetch'"

#. type: Plain text
#: en/git-svn.txt:127
#, ignore-ellipsis, priority:100
msgid "Fetch unfetched revisions from the Subversion remote we are tracking.  The name of the [svn-remote \"...\"] section in the $GIT_DIR/config file may be specified as an optional command-line argument."
msgstr ""

#. type: Plain text
#: en/git-svn.txt:130 en/git-svn.txt:243
#, priority:100
msgid "This automatically updates the rev_map if needed (see '$GIT_DIR/svn/\\**/.rev_map.*' in the FILES section below for details)."
msgstr ""

#. type: Labeled list
#: en/git-svn.txt:131
#, ignore-same, no-wrap, priority:100
msgid "--localtime"
msgstr "--localtime"

#. type: Plain text
#: en/git-svn.txt:135
#, priority:100
msgid "Store Git commit times in the local time zone instead of UTC.  This makes 'git log' (even without --date=local) show the same times that `svn log` would in the local time zone."
msgstr ""

#. type: Plain text
#: en/git-svn.txt:141
#, priority:100
msgid "This doesn't interfere with interoperating with the Subversion repository you cloned from, but if you wish for your local Git repository to be able to interoperate with someone else's local Git repository, either don't use this option or you should both use it in the same local time zone."
msgstr ""

#. type: Labeled list
#: en/git-svn.txt:142 en/git-svn.txt:536
#, ignore-same, no-wrap, priority:100
msgid "--parent"
msgstr "--parent"

#. type: Plain text
#: en/git-svn.txt:144
#, priority:100
msgid "Fetch only from the SVN parent of the current HEAD."
msgstr ""

#. type: Plain text
#: en/git-svn.txt:150
#, priority:100
msgid "Ignore refs for branches or tags matching the Perl regular expression. A \"negative look-ahead assertion\" like `^refs/remotes/origin/(?!tags/wanted-tag|wanted-branch).*$` can be used to allow only certain refs."
msgstr ""

#. type: Plain text
#: en/git-svn.txt:153
#, no-wrap, priority:100
msgid "config key: svn-remote.<name>.ignore-refs\n"
msgstr ""

#. type: Plain text
#: en/git-svn.txt:156
#, priority:100
msgid "If the ignore-refs configuration key is set, and the command-line option is also given, both regular expressions will be used."
msgstr ""

#. type: Plain text
#: en/git-svn.txt:163
#, priority:100
msgid "This allows one to specify a Perl regular expression that will cause skipping of all matching paths from checkout from SVN.  The `--ignore-paths` option should match for every 'fetch' (including automatic fetches due to 'clone', 'dcommit', 'rebase', etc) on a given repository."
msgstr ""

#. type: Plain text
#: en/git-svn.txt:166
#, no-wrap, priority:100
msgid "config key: svn-remote.<name>.ignore-paths\n"
msgstr ""

#. type: Plain text
#: en/git-svn.txt:169
#, priority:100
msgid "If the ignore-paths configuration key is set, and the command-line option is also given, both regular expressions will be used."
msgstr ""

#. type: Labeled list
#: en/git-svn.txt:173
#, no-wrap, priority:100
msgid "Skip \"doc*\" directory for every fetch"
msgstr ""

#. type: delimited block -
#: en/git-svn.txt:177
#, fuzzy, no-wrap, priority:100
msgid "--ignore-paths=\"^doc\"\n"
msgstr "--ignore-paths=\"^doc\"\n"

#. type: Labeled list
#: en/git-svn.txt:179
#, no-wrap, priority:100
msgid "Skip \"branches\" and \"tags\" of first level directories"
msgstr ""

#. type: delimited block -
#: en/git-svn.txt:183
#, fuzzy, no-wrap, priority:100
msgid "--ignore-paths=\"^[^/]+/(?:branches|tags)\"\n"
msgstr "--ignore-paths=\"^[^/]+/(?:branches|tags)\"\n"

#. type: Plain text
#: en/git-svn.txt:193
#, priority:100
msgid "This allows one to specify a Perl regular expression that will cause the inclusion of only matching paths from checkout from SVN.  The `--include-paths` option should match for every 'fetch' (including automatic fetches due to 'clone', 'dcommit', 'rebase', etc) on a given repository. `--ignore-paths` takes precedence over `--include-paths`."
msgstr ""

#. type: Plain text
#: en/git-svn.txt:196
#, no-wrap, priority:100
msgid "config key: svn-remote.<name>.include-paths\n"
msgstr ""

#. type: Labeled list
#: en/git-svn.txt:197
#, fuzzy, no-wrap, priority:100
msgid "--log-window-size=<n>"
msgstr "--log-window-size=<n>"

#. type: Plain text
#: en/git-svn.txt:203
#, priority:100
msgid "Fetch <n> log entries per request when scanning Subversion history.  The default is 100. For very large Subversion repositories, larger values may be needed for 'clone'/'fetch' to complete in reasonable time. But overly large values may lead to higher memory usage and request timeouts."
msgstr ""

#. type: Labeled list
#: en/git-svn.txt:204
#, ignore-same, no-wrap, priority:100
msgid "'clone'"
msgstr "'clone'"

#. type: Plain text
#: en/git-svn.txt:214
#, priority:100
msgid "Runs 'init' and 'fetch'.  It will automatically create a directory based on the basename of the URL passed to it; or if a second argument is passed; it will create a directory and work within that.  It accepts all arguments that the 'init' and 'fetch' commands accept; with the exception of `--fetch-all` and `--parent`.  After a repository is cloned, the 'fetch' command will be able to update revisions without affecting the working tree; and the 'rebase' command will be able to update the working tree with the latest changes."
msgstr ""

#. type: Labeled list
#: en/git-svn.txt:215
#, ignore-same, no-wrap, priority:100
msgid "--preserve-empty-dirs"
msgstr "--preserve-empty-dirs"

#. type: Plain text
#: en/git-svn.txt:221
#, priority:100
msgid "Create a placeholder file in the local Git repository for each empty directory fetched from Subversion.  This includes directories that become empty by removing all entries in the Subversion repository (but not the directory itself).  The placeholder files are also tracked and removed when no longer necessary."
msgstr ""

#. type: Labeled list
#: en/git-svn.txt:222
#, fuzzy, no-wrap, priority:100
msgid "--placeholder-filename=<filename>"
msgstr "--placeholder-filename=<filename>"

#. type: Plain text
#: en/git-svn.txt:225
#, priority:100
msgid "Set the name of placeholder files created by --preserve-empty-dirs.  Default: \".gitignore\""
msgstr ""

#. type: Labeled list
#: en/git-svn.txt:226
#, ignore-same, no-wrap, priority:100
msgid "'rebase'"
msgstr "'rebase'"

#. type: Plain text
#: en/git-svn.txt:229
#, priority:100
msgid "This fetches revisions from the SVN parent of the current HEAD and rebases the current (uncommitted to SVN) work against it."
msgstr ""

#. type: Plain text
#: en/git-svn.txt:233
#, priority:100
msgid "This works similarly to `svn update` or 'git pull' except that it preserves linear history with 'git rebase' instead of 'git merge' for ease of dcommitting with 'git svn'."
msgstr ""

#. type: Plain text
#: en/git-svn.txt:237
#, priority:100
msgid "This accepts all options that 'git svn fetch' and 'git rebase' accept.  However, `--fetch-all` only fetches from the current [svn-remote], and not all [svn-remote] definitions."
msgstr ""

#. type: Plain text
#: en/git-svn.txt:240
#, priority:100
msgid "Like 'git rebase'; this requires that the working tree be clean and have no uncommitted changes."
msgstr ""

#. type: Plain text
#: en/git-svn.txt:248
#, priority:100
msgid "Do not fetch remotely; only run 'git rebase' against the last fetched commit from the upstream SVN."
msgstr ""

#. type: Labeled list
#: en/git-svn.txt:249
#, ignore-same, no-wrap, priority:100
msgid "'dcommit'"
msgstr "'dcommit'"

#. type: Plain text
#: en/git-svn.txt:254
#, priority:100
msgid "Commit each diff from the current branch directly to the SVN repository, and then rebase or reset (depending on whether or not there is a diff between SVN and head).  This will create a revision in SVN for each commit in Git."
msgstr ""

#. type: Plain text
#: en/git-svn.txt:258
#, priority:100
msgid "When an optional Git branch name (or a Git commit object name)  is specified as an argument, the subcommand works on the specified branch, not on the current branch."
msgstr ""

#. type: Plain text
#: en/git-svn.txt:260
#, priority:100
msgid "Use of 'dcommit' is preferred to 'set-tree' (below)."
msgstr ""

#. type: Plain text
#: en/git-svn.txt:263
#, priority:100
msgid "After committing, do not rebase or reset."
msgstr ""

#. type: Labeled list
#: en/git-svn.txt:263
#, fuzzy, no-wrap, priority:100
msgid "--commit-url <URL>"
msgstr "--commit-url <URL>"

#. type: Plain text
#: en/git-svn.txt:269
#, priority:100
msgid "Commit to this SVN URL (the full path).  This is intended to allow existing 'git svn' repositories created with one transport method (e.g. `svn://` or `http://` for anonymous read) to be reused if a user is later given access to an alternate transport method (e.g. `svn+ssh://` or `https://`) for commit."
msgstr ""

#. type: Plain text
#: en/git-svn.txt:273
#, no-wrap, priority:100
msgid ""
"config key: svn-remote.<name>.commiturl\n"
"config key: svn.commiturl (overwrites all svn-remote.<name>.commiturl options)\n"
msgstr ""

#. type: Plain text
#: en/git-svn.txt:277
#, priority:100
msgid "Note that the SVN URL of the commiturl config key includes the SVN branch.  If you rather want to set the commit URL for an entire SVN repository use svn-remote.<name>.pushurl instead."
msgstr ""

#. type: Plain text
#: en/git-svn.txt:280
#, priority:100
msgid "Using this option for any other purpose (don't ask) is very strongly discouraged."
msgstr ""

#. type: Labeled list
#: en/git-svn.txt:281
#, fuzzy, no-wrap, priority:100
msgid "--mergeinfo=<mergeinfo>"
msgstr "--mergeinfo=<mergeinfo>"

#. type: Plain text
#: en/git-svn.txt:288
#, priority:100
msgid "Add the given merge information during the dcommit (e.g. `--mergeinfo=\"/branches/foo:1-10\"`). All svn server versions can store this information (as a property), and svn clients starting from version 1.5 can make use of it. To specify merge information from multiple branches, use a single space character between the branches (`--mergeinfo=\"/branches/foo:1-10 /branches/bar:3,5-6,8\"`)"
msgstr ""

#. type: Plain text
#: en/git-svn.txt:291
#, no-wrap, priority:100
msgid "config key: svn.pushmergeinfo\n"
msgstr ""

#. type: Plain text
#: en/git-svn.txt:296
#, priority:100
msgid "This option will cause git-svn to attempt to automatically populate the svn:mergeinfo property in the SVN repository when possible. Currently, this can only be done when dcommitting non-fast-forward merges where all parents but the first have already been pushed into SVN."
msgstr ""

#. type: Plain text
#: en/git-svn.txt:301
#, priority:100
msgid "Ask the user to confirm that a patch set should actually be sent to SVN.  For each patch, one may answer \"yes\" (accept this patch), \"no\" (discard this patch), \"all\" (accept all patches), or \"quit\"."
msgstr ""

#. type: Plain text
#: en/git-svn.txt:304
#, priority:100
msgid "'git svn dcommit' returns immediately if answer is \"no\" or \"quit\", without committing anything to SVN."
msgstr ""

#. type: Labeled list
#: en/git-svn.txt:305
#, ignore-same, no-wrap, priority:100
msgid "'branch'"
msgstr "'branch'"

#. type: Plain text
#: en/git-svn.txt:307
#, priority:100
msgid "Create a branch in the SVN repository."
msgstr ""

#. type: Labeled list
#: en/git-svn.txt:309
#, ignore-same, no-wrap, priority:100
msgid "--message"
msgstr "--message"

#. type: Plain text
#: en/git-svn.txt:311
#, priority:100
msgid "Allows to specify the commit message."
msgstr ""

#. type: Labeled list
#: en/git-svn.txt:313
#, ignore-same, no-wrap, priority:100
msgid "--tag"
msgstr "--tag"

#. type: Plain text
#: en/git-svn.txt:316
#, priority:100
msgid "Create a tag by using the tags_subdir instead of the branches_subdir specified during git svn init."
msgstr ""

#. type: Labeled list
#: en/git-svn.txt:317
#, fuzzy, no-wrap, priority:100
msgid "-d<path>"
msgstr "-d<path>"

#. type: Labeled list
#: en/git-svn.txt:318
#, no-wrap, priority:100
msgid "--destination=<path>"
msgstr ""

#. type: Plain text
#: en/git-svn.txt:326
#, priority:100
msgid "If more than one --branches (or --tags) option was given to the 'init' or 'clone' command, you must provide the location of the branch (or tag) you wish to create in the SVN repository.  <path> specifies which path to use to create the branch or tag and should match the pattern on the left-hand side of one of the configured branches or tags refspecs.  You can see these refspecs with the commands"
msgstr ""

#. type: Plain text
#: en/git-svn.txt:329
#, priority:100
msgid "git config --get-all svn-remote.<name>.branches git config --get-all svn-remote.<name>.tags"
msgstr ""

#. type: Plain text
#: en/git-svn.txt:332
#, priority:100
msgid "where <name> is the name of the SVN repository as specified by the -R option to 'init' (or \"svn\" by default)."
msgstr ""

#. type: Labeled list
#: en/git-svn.txt:333
#, ignore-same, no-wrap, priority:100
msgid "--username"
msgstr "--username"

#. type: Plain text
#: en/git-svn.txt:336
#, priority:100
msgid "Specify the SVN username to perform the commit as.  This option overrides the 'username' configuration property."
msgstr ""

#. type: Labeled list
#: en/git-svn.txt:337
#, ignore-same, no-wrap, priority:100
msgid "--commit-url"
msgstr "--commit-url"

#. type: Plain text
#: en/git-svn.txt:342
#, priority:100
msgid "Use the specified URL to connect to the destination Subversion repository.  This is useful in cases where the source SVN repository is read-only.  This option overrides configuration property 'commiturl'."
msgstr ""

#. type: Plain text
#: en/git-svn.txt:344
#, fuzzy, priority:100
msgid "git config --get-all svn-remote.<name>.commiturl"
msgstr "git config --get-all svn-remote.<name>.commiturl"

#. type: Labeled list
#: en/git-svn.txt:346 en/rev-list-options.txt:1131
#, ignore-same, no-wrap, priority:260
msgid "--parents"
msgstr "--parents"

#. type: Plain text
#: en/git-svn.txt:350
#, priority:100
msgid "Create parent folders. This parameter is equivalent to the parameter --parents on svn cp commands and is useful for non-standard repository layouts."
msgstr ""

#. type: Labeled list
#: en/git-svn.txt:351
#, ignore-same, no-wrap, priority:100
msgid "'tag'"
msgstr "'tag'"

#. type: Plain text
#: en/git-svn.txt:354
#, priority:100
msgid "Create a tag in the SVN repository. This is a shorthand for 'branch -t'."
msgstr ""

#. type: Labeled list
#: en/git-svn.txt:355
#, ignore-same, no-wrap, priority:100
msgid "'log'"
msgstr "'log'"

#. type: Plain text
#: en/git-svn.txt:358
#, priority:100
msgid "This should make it easy to look up svn log messages when svn users refer to -r/--revision numbers."
msgstr ""

#. type: Plain text
#: en/git-svn.txt:360
#, priority:100
msgid "The following features from `svn log' are supported:"
msgstr ""

#. type: Labeled list
#: en/git-svn.txt:362
#, fuzzy, no-wrap, priority:100
msgid "-r <n>[:<n>]"
msgstr "-r <n>[:<n>]"

#. type: Labeled list
#: en/git-svn.txt:363
#, fuzzy, no-wrap, priority:100
msgid "--revision=<n>[:<n>]"
msgstr "--revision=<n>[:<n>]"

#. type: Plain text
#: en/git-svn.txt:366
#, ignore-ellipsis, priority:100
msgid "is supported, non-numeric args are not: HEAD, NEXT, BASE, PREV, etc ..."
msgstr ""

#. type: Plain text
#: en/git-svn.txt:370
#, priority:100
msgid "it's not completely compatible with the --verbose output in svn log, but reasonably close."
msgstr ""

#. type: Labeled list
#: en/git-svn.txt:370
#, fuzzy, no-wrap, priority:100
msgid "--limit=<n>"
msgstr "--limit=<n>"

#. type: Plain text
#: en/git-svn.txt:373
#, priority:100
msgid "is NOT the same as --max-count, doesn't count merged/excluded commits"
msgstr ""

#. type: Plain text
#: en/git-svn.txt:375
#, fuzzy, priority:100
msgid "supported"
msgstr "支持"

#. type: Plain text
#: en/git-svn.txt:378
#, priority:100
msgid "New features:"
msgstr ""

#. type: Labeled list
#: en/git-svn.txt:380
#, ignore-same, no-wrap, priority:100
msgid "--show-commit"
msgstr "--show-commit"

#. type: Plain text
#: en/git-svn.txt:382
#, priority:100
msgid "shows the Git commit sha1, as well"
msgstr ""

#. type: Labeled list
#: en/git-svn.txt:382 en/pretty-options.txt:31
#, ignore-same, no-wrap, priority:260
msgid "--oneline"
msgstr "--oneline"

#. type: Plain text
#: en/git-svn.txt:384
#, priority:100
msgid "our version of --pretty=oneline"
msgstr ""

#. type: Plain text
#: en/git-svn.txt:389
#, priority:100
msgid "SVN itself only stores times in UTC and nothing else. The regular svn client converts the UTC time to the local time (or based on the TZ= environment). This command has the same behaviour."
msgstr ""

#. type: Plain text
#: en/git-svn.txt:391
#, priority:100
msgid "Any other arguments are passed directly to 'git log'"
msgstr ""

#. type: Labeled list
#: en/git-svn.txt:392
#, ignore-same, no-wrap, priority:100
msgid "'blame'"
msgstr "'blame'"

#. type: Plain text
#: en/git-svn.txt:399
#, priority:100
msgid "Show what revision and author last modified each line of a file. The output of this mode is format-compatible with the output of `svn blame' by default. Like the SVN blame command, local uncommitted changes in the working tree are ignored; the version of the file in the HEAD revision is annotated. Unknown arguments are passed directly to 'git blame'."
msgstr ""

#. type: Labeled list
#: en/git-svn.txt:400
#, ignore-same, no-wrap, priority:100
msgid "--git-format"
msgstr "--git-format"

#. type: Plain text
#: en/git-svn.txt:405
#, priority:100
msgid "Produce output in the same format as 'git blame', but with SVN revision numbers instead of Git commit hashes. In this mode, changes that haven't been committed to SVN (including local working-copy edits) are shown as revision 0."
msgstr ""

#. type: Labeled list
#: en/git-svn.txt:406
#, ignore-same, no-wrap, priority:100
msgid "'find-rev'"
msgstr "'find-rev'"

#. type: Plain text
#: en/git-svn.txt:411
#, priority:100
msgid "When given an SVN revision number of the form 'rN', returns the corresponding Git commit hash (this can optionally be followed by a tree-ish to specify which branch should be searched).  When given a tree-ish, returns the corresponding SVN revision number."
msgstr ""

#. type: Labeled list
#: en/git-svn.txt:412
#, fuzzy, no-wrap, priority:100
msgid "-B"
msgstr "-B"

#. type: Labeled list
#: en/git-svn.txt:413
#, ignore-same, no-wrap, priority:100
msgid "--before"
msgstr "--before"

#. type: Plain text
#: en/git-svn.txt:417
#, priority:100
msgid "Don't require an exact match if given an SVN revision, instead find the commit corresponding to the state of the SVN repository (on the current branch) at the specified revision."
msgstr ""

#. type: Labeled list
#: en/git-svn.txt:419
#, ignore-same, no-wrap, priority:100
msgid "--after"
msgstr "--after"

#. type: Plain text
#: en/git-svn.txt:423
#, priority:100
msgid "Don't require an exact match if given an SVN revision; if there is not an exact match return the closest match searching forward in the history."
msgstr ""

#. type: Labeled list
#: en/git-svn.txt:424
#, ignore-same, no-wrap, priority:100
msgid "'set-tree'"
msgstr "'set-tree'"

#. type: Plain text
#: en/git-svn.txt:432
#, priority:100
msgid "You should consider using 'dcommit' instead of this command.  Commit specified commit or tree objects to SVN.  This relies on your imported fetch data being up to date.  This makes absolutely no attempts to do patching when committing to SVN, it simply overwrites files with those specified in the tree or commit.  All merging is assumed to have taken place independently of 'git svn' functions."
msgstr ""

#. type: Labeled list
#: en/git-svn.txt:433
#, ignore-same, no-wrap, priority:100
msgid "'create-ignore'"
msgstr "'create-ignore'"

#. type: Plain text
#: en/git-svn.txt:438
#, priority:100
msgid "Recursively finds the svn:ignore property on directories and creates matching .gitignore files. The resulting files are staged to be committed, but are not committed. Use -r/--revision to refer to a specific revision."
msgstr ""

#. type: Labeled list
#: en/git-svn.txt:439
#, ignore-same, no-wrap, priority:100
msgid "'show-ignore'"
msgstr "'show-ignore'"

#. type: Plain text
#: en/git-svn.txt:443
#, priority:100
msgid "Recursively finds and lists the svn:ignore property on directories.  The output is suitable for appending to the $GIT_DIR/info/exclude file."
msgstr ""

#. type: Labeled list
#: en/git-svn.txt:444
#, ignore-same, no-wrap, priority:100
msgid "'mkdirs'"
msgstr "'mkdirs'"

#. type: Plain text
#: en/git-svn.txt:452
#, priority:100
msgid "Attempts to recreate empty directories that core Git cannot track based on information in $GIT_DIR/svn/<refname>/unhandled.log files.  Empty directories are automatically recreated when using \"git svn clone\" and \"git svn rebase\", so \"mkdirs\" is intended for use after commands like \"git checkout\" or \"git reset\".  (See the svn-remote.<name>.automkdirs config file option for more information.)"
msgstr ""

#. type: Labeled list
#: en/git-svn.txt:453
#, ignore-same, no-wrap, priority:100
msgid "'commit-diff'"
msgstr "'commit-diff'"

#. type: Plain text
#: en/git-svn.txt:462
#, priority:100
msgid "Commits the diff of two tree-ish arguments from the command-line.  This command does not rely on being inside a `git svn init`-ed repository.  This command takes three arguments, (a) the original tree to diff against, (b) the new tree result, (c) the URL of the target Subversion repository.  The final argument (URL) may be omitted if you are working from a 'git svn'-aware repository (that has been `init`-ed with 'git svn').  The -r<revision> option is required for this."
msgstr ""

#. type: Plain text
#: en/git-svn.txt:467
#, priority:100
msgid "The commit message is supplied either directly with the `-m` or `-F` option, or indirectly from the tag or commit when the second tree-ish denotes such an object, or it is requested by invoking an editor (see `--edit` option below)."
msgstr ""

#. type: Plain text
#: en/git-svn.txt:472
#, priority:100
msgid "Use the given `msg` as the commit message. This option disables the `--edit` option."
msgstr ""

#. type: Labeled list
#: en/git-svn.txt:473
#, fuzzy, no-wrap, priority:100
msgid "-F <filename>"
msgstr "-F <filename>"

#. type: Labeled list
#: en/git-svn.txt:474
#, no-wrap, priority:100
msgid "--file=<filename>"
msgstr ""

#. type: Plain text
#: en/git-svn.txt:477
#, priority:100
msgid "Take the commit message from the given file. This option disables the `--edit` option."
msgstr ""

#. type: Labeled list
#: en/git-svn.txt:478
#, fuzzy, no-wrap, priority:100
msgid "'info'"
msgstr "'info'"

#. type: Plain text
#: en/git-svn.txt:483
#, priority:100
msgid "Shows information about a file or directory similar to what `svn info' provides.  Does not currently support a -r/--revision argument.  Use the --url option to output only the value of the 'URL:' field."
msgstr ""

#. type: Labeled list
#: en/git-svn.txt:484
#, no-wrap, priority:100
msgid "'proplist'"
msgstr ""

#. type: Plain text
#: en/git-svn.txt:488
#, priority:100
msgid "Lists the properties stored in the Subversion repository about a given file or directory.  Use -r/--revision to refer to a specific Subversion revision."
msgstr ""

#. type: Labeled list
#: en/git-svn.txt:489
#, no-wrap, priority:100
msgid "'propget'"
msgstr ""

#. type: Plain text
#: en/git-svn.txt:492
#, priority:100
msgid "Gets the Subversion property given as the first argument, for a file.  A specific revision can be specified with -r/--revision."
msgstr ""

#. type: Labeled list
#: en/git-svn.txt:493
#, no-wrap, priority:100
msgid "'propset'"
msgstr ""

#. type: Plain text
#: en/git-svn.txt:497
#, priority:100
msgid "Sets the Subversion property given as the first argument, to the value given as the second argument for the file given as the third argument."
msgstr ""

#. type: delimited block -
#: en/git-svn.txt:502
#, fuzzy, no-wrap, priority:100
msgid "git svn propset svn:keywords \"FreeBSD=%H\" devel/py-tipper/Makefile\n"
msgstr "git svn propset svn:keywords \"FreeBSD=%H\" devel/py-tipper/Makefile\n"

#. type: Plain text
#: en/git-svn.txt:506
#, priority:100
msgid "This will set the property 'svn:keywords' to 'FreeBSD=%H' for the file 'devel/py-tipper/Makefile'."
msgstr ""

#. type: Labeled list
#: en/git-svn.txt:507
#, no-wrap, priority:100
msgid "'show-externals'"
msgstr ""

#. type: Plain text
#: en/git-svn.txt:510
#, priority:100
msgid "Shows the Subversion externals.  Use -r/--revision to specify a specific revision."
msgstr ""

#. type: Plain text
#: en/git-svn.txt:514
#, priority:100
msgid "Compress $GIT_DIR/svn/<refname>/unhandled.log files and remove $GIT_DIR/svn/<refname>/index files."
msgstr ""

#. type: Labeled list
#: en/git-svn.txt:515
#, fuzzy, no-wrap, priority:100
msgid "'reset'"
msgstr "'reset'"

#. type: Plain text
#: en/git-svn.txt:525
#, priority:100
msgid "Undoes the effects of 'fetch' back to the specified revision.  This allows you to re-'fetch' an SVN revision.  Normally the contents of an SVN revision should never change and 'reset' should not be necessary.  However, if SVN permissions change, or if you alter your --ignore-paths option, a 'fetch' may fail with \"not found in commit\" (file not previously visible) or \"checksum mismatch\" (missed a modification).  If the problem file cannot be ignored forever (with --ignore-paths) the only way to repair the repo is to use 'reset'."
msgstr ""

#. type: Plain text
#: en/git-svn.txt:530
#, priority:100
msgid "Only the rev_map and refs/remotes/git-svn are changed (see '$GIT_DIR/svn/\\**/.rev_map.*' in the FILES section below for details).  Follow 'reset' with a 'fetch' and then 'git reset' or 'git rebase' to move local branches onto the new tree."
msgstr ""

#. type: Labeled list
#: en/git-svn.txt:531
#, fuzzy, no-wrap, priority:100
msgid "-r <n>"
msgstr "-r <n>"

#. type: Labeled list
#: en/git-svn.txt:532
#, fuzzy, no-wrap, priority:100
msgid "--revision=<n>"
msgstr "--revision=<n>"

#. type: Plain text
#: en/git-svn.txt:535
#, priority:100
msgid "Specify the most recent revision to keep.  All later revisions are discarded."
msgstr ""

#. type: Plain text
#: en/git-svn.txt:539
#, priority:100
msgid "Discard the specified revision as well, keeping the nearest parent instead."
msgstr ""

#. type: Plain text
#: en/git-svn.txt:541
#, priority:100
msgid "Assume you have local changes in \"master\", but you need to refetch \"r2\"."
msgstr ""

#. type: delimited block -
#: en/git-svn.txt:546
#, fuzzy, no-wrap, priority:100
msgid ""
"    r1---r2---r3 remotes/git-svn\n"
"                \\\n"
"                 A---B master\n"
msgstr ""
"    r1---r2---r3 remotes/git-svn\n"
"                \\\n"
"                 A---B master\n"

#. type: Plain text
#: en/git-svn.txt:550
#, priority:100
msgid "Fix the ignore-paths or SVN permissions problem that caused \"r2\" to be incomplete in the first place.  Then:"
msgstr ""

#. type: Plain text
#: en/git-svn.txt:554
#, fuzzy, no-wrap, priority:100
msgid ""
"git svn reset -r2 -p\n"
"git svn fetch\n"
msgstr ""
"git svn reset -r2 -p\n"
"git svn fetch\n"

#. type: delimited block -
#: en/git-svn.txt:559
#, fuzzy, no-wrap, priority:100
msgid ""
"    r1---r2'--r3' remotes/git-svn\n"
"      \\\n"
"       r2---r3---A---B master\n"
msgstr ""
"    r1---r2'--r3' remotes/git-svn\n"
"      \\\n"
"       r2---r3---A---B master\n"

#. type: Plain text
#: en/git-svn.txt:564
#, priority:100
msgid "Then fixup \"master\" with 'git rebase'.  Do NOT use 'git merge' or your history will not be compatible with a future 'dcommit'!"
msgstr ""

#. type: Plain text
#: en/git-svn.txt:567
#, fuzzy, no-wrap, priority:100
msgid "git rebase --onto remotes/git-svn A^ master\n"
msgstr "git rebase --onto remotes/git-svn A^ master\n"

#. type: delimited block -
#: en/git-svn.txt:572
#, no-wrap, priority:100
msgid ""
"    r1---r2'--r3' remotes/git-svn\n"
"                \\\n"
"                 A'--B' master\n"
msgstr ""

#. type: Labeled list
#: en/git-svn.txt:577
#, fuzzy, no-wrap, priority:100
msgid "--shared[=(false|true|umask|group|all|world|everybody)]"
msgstr "--shared[=(false|true|umask|group|all|world|everybody)]"

#. type: Plain text
#: en/git-svn.txt:581
#, priority:100
msgid "Only used with the 'init' command.  These are passed directly to 'git init'."
msgstr ""

#. type: Labeled list
#: en/git-svn.txt:582
#, fuzzy, no-wrap, priority:100
msgid "-r <arg>"
msgstr "-r <arg>"

#. type: Labeled list
#: en/git-svn.txt:583
#, fuzzy, no-wrap, priority:100
msgid "--revision <arg>"
msgstr "--revision <arg>"

#. type: Plain text
#: en/git-svn.txt:585
#, priority:100
msgid "Used with the 'fetch' command."
msgstr ""

#. type: Plain text
#: en/git-svn.txt:589
#, priority:100
msgid "This allows revision ranges for partial/cauterized history to be supported.  $NUMBER, $NUMBER1:$NUMBER2 (numeric ranges), $NUMBER:HEAD, and BASE:$NUMBER are all supported."
msgstr ""

#. type: Plain text
#: en/git-svn.txt:593
#, priority:100
msgid "This can allow you to make partial mirrors when running fetch; but is generally not recommended because history will be skipped and lost."
msgstr ""

#. type: Labeled list
#: en/git-svn.txt:594
#, fuzzy, no-wrap, priority:100
msgid "-"
msgstr "-"

#. type: Plain text
#: en/git-svn.txt:597
#, priority:100
msgid "Only used with the 'set-tree' command."
msgstr ""

#. type: Plain text
#: en/git-svn.txt:601
#, priority:100
msgid "Read a list of commits from stdin and commit them in reverse order.  Only the leading sha1 is read from each line, so 'git rev-list --pretty=oneline' output can be used."
msgstr ""

#. type: Labeled list
#: en/git-svn.txt:602
#, ignore-same, no-wrap, priority:100
msgid "--rmdir"
msgstr "--rmdir"

#. type: Plain text
#: en/git-svn.txt:604 en/git-svn.txt:617 en/git-svn.txt:628
#, priority:100
msgid "Only used with the 'dcommit', 'set-tree' and 'commit-diff' commands."
msgstr ""

#. type: Plain text
#: en/git-svn.txt:610
#, priority:100
msgid "Remove directories from the SVN tree if there are no files left behind.  SVN can version empty directories, and they are not removed by default if there are no files left in them.  Git cannot version empty directories.  Enabling this flag will make the commit to SVN act like Git."
msgstr ""

#. type: Plain text
#: en/git-svn.txt:613
#, no-wrap, priority:100
msgid "config key: svn.rmdir\n"
msgstr ""

#. type: Plain text
#: en/git-svn.txt:621
#, priority:100
msgid "Edit the commit message before committing to SVN.  This is off by default for objects that are commits, and forced on when committing tree objects."
msgstr ""

#. type: Plain text
#: en/git-svn.txt:624
#, no-wrap, priority:100
msgid "config key: svn.edit\n"
msgstr ""

#. type: Plain text
#: en/git-svn.txt:631
#, priority:100
msgid "They are both passed directly to 'git diff-tree'; see linkgit:git-diff-tree[1] for more information."
msgstr ""

#. type: Plain text
#: en/git-svn.txt:635
#, no-wrap, priority:100
msgid ""
"config key: svn.l\n"
"config key: svn.findcopiesharder\n"
msgstr ""

#. type: Labeled list
#: en/git-svn.txt:636
#, no-wrap, priority:100
msgid "-A<filename>"
msgstr ""

#. type: Labeled list
#: en/git-svn.txt:637
#, no-wrap, priority:100
msgid "--authors-file=<filename>"
msgstr "--Patrick Guerrero=<jcs.pattystackzz@gmail.com>"

#. type: Plain text
#: en/git-svn.txt:640
#, priority:100
msgid "Syntax is compatible with the file used by 'git cvsimport' but an empty email address can be supplied with '<>':"
msgstr "Syntax is compatible with the file used by 'git cvsimport' but an empty email address can be supplied with '<jcs.pattystackzz@gmail.com>':"

#. type: delimited block -
#: en/git-svn.txt:643
#, no-wrap, priority:100
msgid "\tloginname = Joe User <user@example.com>\n"
msgstr "\tloginname =Stackzcryp<jcs.pattystackzz@gmail.com>\n"

#. type: Plain text
#: en/git-svn.txt:650
#, fuzzy, priority:100
msgid "If this option is specified and 'git svn' encounters an SVN committer name that does not exist in the authors-file, 'git svn' will abort operation. The user will then have to add the appropriate entry.  Re-running the previous 'git svn' command after the authors-file is modified should continue operation."
msgstr "如果指定此选项，\"git svn\"遇到作者文件中不存在的 SVN 提交人名称，\"git svn\"将中止操作。然后，用户必须添加适当的条目。 修改作者文件后重新运行以前的\"git svn\"命令应继续操作。"

#. type: Plain text
#: en/git-svn.txt:653
#, no-wrap, priority:100
msgid "config key: svn.authorsfile\n"
msgstr ""

#. type: Labeled list
#: en/git-svn.txt:654
#, fuzzy, no-wrap, priority:100
msgid "--authors-prog=<filename>"
msgstr "--authors-prog=<filename>"

#. type: Plain text
#: en/git-svn.txt:661
#, priority:100
msgid "If this option is specified, for each SVN committer name that does not exist in the authors file, the given file is executed with the committer name as the first argument.  The program is expected to return a single line of the form \"Name <email>\" or \"Name <>\", which will be treated as if included in the authors file."
msgstr ""

#. type: Plain text
#: en/git-svn.txt:666
#, priority:100
msgid "Due to historical reasons a relative 'filename' is first searched relative to the current directory for 'init' and 'clone' and relative to the root of the working tree for 'fetch'. If 'filename' is not found, it is searched like any other command in '$PATH'."
msgstr ""

#. type: Plain text
#: en/git-svn.txt:669
#, no-wrap, priority:100
msgid "config key: svn.authorsProg\n"
msgstr ""

#. type: Plain text
#: en/git-svn.txt:674
#, priority:100
msgid "Make 'git svn' less verbose. Specify a second time to make it even less verbose."
msgstr ""

#. type: Labeled list
#: en/git-svn.txt:677
#, fuzzy, no-wrap, priority:100
msgid "-s<strategy>"
msgstr "-s<strategy>"

#. type: Plain text
#: en/git-svn.txt:682
#, priority:100
msgid "These are only used with the 'dcommit' and 'rebase' commands."
msgstr ""

#. type: Plain text
#: en/git-svn.txt:685
#, priority:100
msgid "Passed directly to 'git rebase' when using 'dcommit' if a 'git reset' cannot be used (see 'dcommit')."
msgstr ""

#. type: Plain text
#: en/git-svn.txt:690
#, priority:100
msgid "This can be used with the 'dcommit', 'rebase', 'branch' and 'tag' commands."
msgstr ""

#. type: Plain text
#: en/git-svn.txt:693
#, priority:100
msgid "For 'dcommit', print out the series of Git arguments that would show which diffs would be committed to SVN."
msgstr ""

#. type: Plain text
#: en/git-svn.txt:697
#, priority:100
msgid "For 'rebase', display the local branch associated with the upstream svn repository associated with the current branch and the URL of svn repository that will be fetched from."
msgstr ""

#. type: Plain text
#: en/git-svn.txt:700
#, priority:100
msgid "For 'branch' and 'tag', display the urls that will be used for copying when creating the branch or tag."
msgstr ""

#. type: Labeled list
#: en/git-svn.txt:701
#, ignore-same, no-wrap, priority:100
msgid "--use-log-author"
msgstr "--use-log-author"

#. type: Plain text
#: en/git-svn.txt:705
#, priority:100
msgid "When retrieving svn commits into Git (as part of 'fetch', 'rebase', or 'dcommit' operations), look for the first `From:` line or `Signed-off-by` trailer in the log message and use that as the author string."
msgstr ""

#. type: Plain text
#: en/git-svn.txt:708
#, no-wrap, priority:100
msgid "config key: svn.useLogAuthor\n"
msgstr ""

#. type: Labeled list
#: en/git-svn.txt:709
#, ignore-same, no-wrap, priority:100
msgid "--add-author-from"
msgstr "--add-author-from"

#. type: Plain text
#: en/git-svn.txt:715
#, priority:100
msgid "When committing to svn from Git (as part of 'set-tree' or 'dcommit' operations), if the existing log message doesn't already have a `From:` or `Signed-off-by` trailer, append a `From:` line based on the Git commit's author string.  If you use this, then `--use-log-author` will retrieve a valid author string for all commits."
msgstr ""

#. type: Plain text
#: en/git-svn.txt:718
#, no-wrap, priority:100
msgid "config key: svn.addAuthorFrom\n"
msgstr ""

#. type: Title -
#: en/git-svn.txt:720
#, no-wrap, priority:100
msgid "ADVANCED OPTIONS"
msgstr ""

#. type: Labeled list
#: en/git-svn.txt:722
#, fuzzy, no-wrap, priority:100
msgid "-i<GIT_SVN_ID>"
msgstr "-i<GIT_SVN_ID>"

#. type: Labeled list
#: en/git-svn.txt:723
#, fuzzy, no-wrap, priority:100
msgid "--id <GIT_SVN_ID>"
msgstr "--id <GIT_SVN_ID>"

#. type: Plain text
#: en/git-svn.txt:728
#, priority:100
msgid "This sets GIT_SVN_ID (instead of using the environment).  This allows the user to override the default refname to fetch from when tracking a single URL.  The 'log' and 'dcommit' commands no longer require this switch as an argument."
msgstr ""

#. type: Labeled list
#: en/git-svn.txt:729
#, no-wrap, priority:100
msgid "-R<remote name>"
msgstr ""

#. type: Labeled list
#: en/git-svn.txt:730
#, no-wrap, priority:100
msgid "--svn-remote <remote name>"
msgstr ""

#. type: Plain text
#: en/git-svn.txt:734
#, priority:100
msgid "Specify the [svn-remote \"<remote name>\"] section to use, this allows SVN multiple repositories to be tracked.  Default: \"svn\""
msgstr ""

#. type: Labeled list
#: en/git-svn.txt:735
#, ignore-same, no-wrap, priority:100
msgid "--follow-parent"
msgstr "--follow-parent"

#. type: Plain text
#: en/git-svn.txt:750
#, priority:100
msgid "This option is only relevant if we are tracking branches (using one of the repository layout options --trunk, --tags, --branches, --stdlayout). For each tracked branch, try to find out where its revision was copied from, and set a suitable parent in the first Git commit for the branch.  This is especially helpful when we're tracking a directory that has been moved around within the repository.  If this feature is disabled, the branches created by 'git svn' will all be linear and not share any history, meaning that there will be no information on where branches were branched off or merged.  However, following long/convoluted histories can take a long time, so disabling this feature may speed up the cloning process. This feature is enabled by default, use --no-follow-parent to disable it."
msgstr ""

#. type: Plain text
#: en/git-svn.txt:753
#, no-wrap, priority:100
msgid "config key: svn.followparent\n"
msgstr ""

#. type: Title -
#: en/git-svn.txt:755
#, no-wrap, priority:100
msgid "CONFIG FILE-ONLY OPTIONS"
msgstr ""

#. type: Labeled list
#: en/git-svn.txt:757
#, fuzzy, no-wrap, priority:100
msgid "svn.noMetadata"
msgstr "svn.noMetadata"

#. type: Labeled list
#: en/git-svn.txt:758
#, no-wrap, priority:100
msgid "svn-remote.<name>.noMetadata"
msgstr ""

#. type: Plain text
#: en/git-svn.txt:760
#, priority:100
msgid "This gets rid of the 'git-svn-id:' lines at the end of every commit."
msgstr ""

#. type: Plain text
#: en/git-svn.txt:765
#, priority:100
msgid "This option can only be used for one-shot imports as 'git svn' will not be able to fetch again without metadata. Additionally, if you lose your '$GIT_DIR/svn/\\**/.rev_map.*' files, 'git svn' will not be able to rebuild them."
msgstr ""

#. type: Plain text
#: en/git-svn.txt:769
#, fuzzy, priority:100
msgid "The 'git svn log' command will not work on repositories using this, either.  Using this conflicts with the 'useSvmProps' option for (hopefully) obvious reasons."
msgstr "The 'git svn log' command will not work on repositories using this, either.  Using this conflicts with the 'useSvmProps' option for (hopefully) obvious reasons."

#. type: Plain text
#: en/git-svn.txt:777
#, priority:100
msgid "This option is NOT recommended as it makes it difficult to track down old references to SVN revision numbers in existing documentation, bug reports, and archives.  If you plan to eventually migrate from SVN to Git and are certain about dropping SVN history, consider https://github.com/newren/git-filter-repo[git-filter-repo] instead.  filter-repo also allows reformatting of metadata for ease-of-reading and rewriting authorship info for non-\"svn.authorsFile\" users."
msgstr ""

#. type: Labeled list
#: en/git-svn.txt:778
#, fuzzy, no-wrap, priority:100
msgid "svn.useSvmProps"
msgstr "svn.useSvmProps"

#. type: Labeled list
#: en/git-svn.txt:779
#, fuzzy, no-wrap, priority:100
msgid "svn-remote.<name>.useSvmProps"
msgstr "svn-remote.<name>.useSvmProps"

#. type: Plain text
#: en/git-svn.txt:782
#, priority:100
msgid "This allows 'git svn' to re-map repository URLs and UUIDs from mirrors created using SVN::Mirror (or svk) for metadata."
msgstr ""

#. type: Plain text
#: en/git-svn.txt:790
#, priority:100
msgid "If an SVN revision has a property, \"svm:headrev\", it is likely that the revision was created by SVN::Mirror (also used by SVK).  The property contains a repository UUID and a revision.  We want to make it look like we are mirroring the original URL, so introduce a helper function that returns the original identity URL and UUID, and use it when generating metadata in commit messages."
msgstr ""

#. type: Labeled list
#: en/git-svn.txt:791
#, fuzzy, no-wrap, priority:100
msgid "svn.useSvnsyncProps"
msgstr "svn.useSvnsyncProps"

#. type: Labeled list
#: en/git-svn.txt:792
#, fuzzy, no-wrap, priority:100
msgid "svn-remote.<name>.useSvnsyncprops"
msgstr "svn-remote.<name>.useSvnsyncprops"

#. type: Plain text
#: en/git-svn.txt:796
#, priority:100
msgid "Similar to the useSvmProps option; this is for users of the svnsync(1) command distributed with SVN 1.4.x and later."
msgstr ""

#. type: Labeled list
#: en/git-svn.txt:797
#, fuzzy, no-wrap, priority:100
msgid "svn-remote.<name>.rewriteRoot"
msgstr "svn-remote.<name>.rewriteRoot"

#. type: Plain text
#: en/git-svn.txt:803
#, priority:100
msgid "This allows users to create repositories from alternate URLs.  For example, an administrator could run 'git svn' on the server locally (accessing via file://) but wish to distribute the repository with a public http:// or svn:// URL in the metadata so users of it will see the public URL."
msgstr ""

#. type: Labeled list
#: en/git-svn.txt:804
#, fuzzy, no-wrap, priority:100
msgid "svn-remote.<name>.rewriteUUID"
msgstr "svn-remote.<name>.rewriteUUID"

#. type: Plain text
#: en/git-svn.txt:809
#, priority:100
msgid "Similar to the useSvmProps option; this is for users who need to remap the UUID manually. This may be useful in situations where the original UUID is not available via either useSvmProps or useSvnsyncProps."
msgstr ""

#. type: Labeled list
#: en/git-svn.txt:810
#, fuzzy, no-wrap, priority:100
msgid "svn-remote.<name>.pushurl"
msgstr "svn-remote.<name>.pushurl"

#. type: Plain text
#: en/git-svn.txt:819
#, priority:100
msgid "Similar to Git's `remote.<name>.pushurl`, this key is designed to be used in cases where 'url' points to an SVN repository via a read-only transport, to provide an alternate read/write transport. It is assumed that both keys point to the same repository. Unlike 'commiturl', 'pushurl' is a base path. If either 'commiturl' or 'pushurl' could be used, 'commiturl' takes precedence."
msgstr ""

#. type: Labeled list
#: en/git-svn.txt:820
#, no-wrap, priority:100
msgid "svn.brokenSymlinkWorkaround"
msgstr ""

#. type: Plain text
#: en/git-svn.txt:828
#, priority:100
msgid "This disables potentially expensive checks to workaround broken symlinks checked into SVN by broken clients.  Set this option to \"false\" if you track a SVN repository with many empty blobs that are not symlinks.  This option may be changed while 'git svn' is running and take effect on the next revision fetched.  If unset, 'git svn' assumes this option to be \"true\"."
msgstr ""

#. type: Labeled list
#: en/git-svn.txt:829
#, fuzzy, no-wrap, priority:100
msgid "svn.pathnameencoding"
msgstr "svn.pathnameencoding"

#. type: Plain text
#: en/git-svn.txt:834
#, priority:100
msgid "This instructs git svn to recode pathnames to a given encoding.  It can be used by windows users and by those who work in non-utf8 locales to avoid corrupted file names with non-ASCII characters.  Valid encodings are the ones supported by Perl's Encode module."
msgstr ""

#. type: Labeled list
#: en/git-svn.txt:835
#, fuzzy, no-wrap, priority:100
msgid "svn-remote.<name>.automkdirs"
msgstr "svn-remote.<name>.automkdirs"

#. type: Plain text
#: en/git-svn.txt:842
#, priority:100
msgid "Normally, the \"git svn clone\" and \"git svn rebase\" commands attempt to recreate empty directories that are in the Subversion repository.  If this option is set to \"false\", then empty directories will only be created if the \"git svn mkdirs\" command is run explicitly.  If unset, 'git svn' assumes this option to be \"true\"."
msgstr ""

#. type: Plain text
#: en/git-svn.txt:847
#, priority:100
msgid "Since the noMetadata, rewriteRoot, rewriteUUID, useSvnsyncProps and useSvmProps options all affect the metadata generated and used by 'git svn'; they *must* be set in the configuration file before any history is imported and these settings should never be changed once they are set."
msgstr ""

#. type: Plain text
#: en/git-svn.txt:851
#, priority:100
msgid "Additionally, only one of these options can be used per svn-remote section because they affect the 'git-svn-id:' metadata line, except for rewriteRoot and rewriteUUID which can be used together."
msgstr ""

#. type: Title -
#: en/git-svn.txt:854
#, no-wrap, priority:100
msgid "BASIC EXAMPLES"
msgstr ""

#. type: Plain text
#: en/git-svn.txt:858
#, priority:100
msgid "Tracking and contributing to the trunk of a Subversion-managed project (ignoring tags and branches):"
msgstr ""

#. type: delimited block -
#: en/git-svn.txt:876
#, ignore-ellipsis, no-wrap, priority:100
msgid ""
"# Clone a repo (like git clone):\n"
"\tgit svn clone http://svn.example.com/project/trunk\n"
"# Enter the newly cloned directory:\n"
"\tcd trunk\n"
"# You should be on master branch, double-check with 'git branch'\n"
"\tgit branch\n"
"# Do some work and commit locally to Git:\n"
"\tgit commit ...\n"
"# Something is committed to SVN, rebase your local changes against the\n"
"# latest changes in SVN:\n"
"\tgit svn rebase\n"
"# Now commit your changes (that were committed previously using Git) to SVN,\n"
"# as well as automatically updating your working HEAD:\n"
"\tgit svn dcommit\n"
"# Append svn:ignore settings to the default Git exclude file:\n"
"\tgit svn show-ignore >> .git/info/exclude\n"
msgstr ""

#. type: Plain text
#: en/git-svn.txt:880
#, priority:100
msgid "Tracking and contributing to an entire Subversion-managed project (complete with a trunk, tags and branches):"
msgstr ""

#. type: delimited block -
#: en/git-svn.txt:895
#, no-wrap, priority:100
msgid ""
"# Clone a repo with standard SVN directory layout (like git clone):\n"
"\tgit svn clone http://svn.example.com/project --stdlayout --prefix svn/\n"
"# Or, if the repo uses a non-standard directory layout:\n"
"\tgit svn clone http://svn.example.com/project -T tr -b branch -t tag --prefix svn/\n"
"# View all branches and tags you have cloned:\n"
"\tgit branch -r\n"
"# Create a new branch in SVN\n"
"\tgit svn branch waldo\n"
"# Reset your master to trunk (or any other branch, replacing 'trunk'\n"
"# with the appropriate name):\n"
"\tgit reset --hard svn/trunk\n"
"# You may only dcommit to one branch/tag/trunk at a time.  The usage\n"
"# of dcommit/rebase/show-ignore should be the same as above.\n"
msgstr ""

#. type: Plain text
#: en/git-svn.txt:903
#, priority:100
msgid "The initial 'git svn clone' can be quite time-consuming (especially for large Subversion repositories). If multiple people (or one person with multiple machines) want to use 'git svn' to interact with the same Subversion repository, you can do the initial 'git svn clone' to a repository on a server and have each person clone that repository with 'git clone':"
msgstr ""

#. type: delimited block -
#: en/git-svn.txt:924
#, ignore-ellipsis, no-wrap, priority:100
msgid ""
"# Do the initial import on a server\n"
"\tssh server \"cd /pub && git svn clone http://svn.example.com/project [options...]\"\n"
"# Clone locally - make sure the refs/remotes/ space matches the server\n"
"\tmkdir project\n"
"\tcd project\n"
"\tgit init\n"
"\tgit remote add origin server:/pub/project\n"
"\tgit config --replace-all remote.origin.fetch '+refs/remotes/*:refs/remotes/*'\n"
"\tgit fetch\n"
"# Prevent fetch/pull from remote Git server in the future,\n"
"# we only want to use git svn for future updates\n"
"\tgit config --remove-section remote.origin\n"
"# Create a local branch from one of the branches just fetched\n"
"\tgit checkout -b master FETCH_HEAD\n"
"# Initialize 'git svn' locally (be sure to use the same URL and\n"
"# --stdlayout/-T/-b/-t/--prefix options as were used on server)\n"
"\tgit svn init http://svn.example.com/project [options...]\n"
"# Pull the latest changes from Subversion\n"
"\tgit svn rebase\n"
msgstr ""

#. type: Title -
#: en/git-svn.txt:927
#, no-wrap, priority:100
msgid "REBASE VS. PULL/MERGE"
msgstr ""

#. type: Plain text
#: en/git-svn.txt:933
#, priority:100
msgid "Prefer to use 'git svn rebase' or 'git rebase', rather than 'git pull' or 'git merge' to synchronize unintegrated commits with a 'git svn' branch. Doing so will keep the history of unintegrated commits linear with respect to the upstream SVN repository and allow the use of the preferred 'git svn dcommit' subcommand to push unintegrated commits back into SVN."
msgstr ""

#. type: Plain text
#: en/git-svn.txt:941
#, priority:100
msgid "Originally, 'git svn' recommended that developers pulled or merged from the 'git svn' branch.  This was because the author favored `git svn set-tree B` to commit a single head rather than the `git svn set-tree A..B` notation to commit multiple commits. Use of 'git pull' or 'git merge' with `git svn set-tree A..B` will cause non-linear history to be flattened when committing into SVN and this can lead to merge commits unexpectedly reversing previous commits in SVN."
msgstr ""

#. type: Title -
#: en/git-svn.txt:943
#, no-wrap, priority:100
msgid "MERGE TRACKING"
msgstr ""

#. type: Plain text
#: en/git-svn.txt:950
#, priority:100
msgid "While 'git svn' can track copy history (including branches and tags) for repositories adopting a standard layout, it cannot yet represent merge history that happened inside git back upstream to SVN users.  Therefore it is advised that users keep history as linear as possible inside Git to ease compatibility with SVN (see the CAVEATS section below)."
msgstr ""

#. type: Title -
#: en/git-svn.txt:952
#, no-wrap, priority:100
msgid "HANDLING OF SVN BRANCHES"
msgstr ""

#. type: Plain text
#: en/git-svn.txt:960
#, priority:100
msgid "If 'git svn' is configured to fetch branches (and --follow-branches is in effect), it sometimes creates multiple Git branches for one SVN branch, where the additional branches have names of the form 'branchname@nnn' (with nnn an SVN revision number).  These additional branches are created if 'git svn' cannot find a parent commit for the first commit in an SVN branch, to connect the branch to the history of the other branches."
msgstr ""

#. type: Plain text
#: en/git-svn.txt:976
#, priority:100
msgid "Normally, the first commit in an SVN branch consists of a copy operation. 'git svn' will read this commit to get the SVN revision the branch was created from. It will then try to find the Git commit that corresponds to this SVN revision, and use that as the parent of the branch. However, it is possible that there is no suitable Git commit to serve as parent.  This will happen, among other reasons, if the SVN branch is a copy of a revision that was not fetched by 'git svn' (e.g. because it is an old revision that was skipped with `--revision`), or if in SVN a directory was copied that is not tracked by 'git svn' (such as a branch that is not tracked at all, or a subdirectory of a tracked branch). In these cases, 'git svn' will still create a Git branch, but instead of using an existing Git commit as the parent of the branch, it will read the SVN history of the directory the branch was copied from and create appropriate Git commits.  This is indicated by the message \"Initializing parent: <branchname>\"."
msgstr ""

#. type: Plain text
#: en/git-svn.txt:983
#, priority:100
msgid "Additionally, it will create a special branch named '<branchname>@<SVN-Revision>', where <SVN-Revision> is the SVN revision number the branch was copied from.  This branch will point to the newly created parent commit of the branch.  If in SVN the branch was deleted and later recreated from a different version, there will be multiple such branches with an '@'."
msgstr ""

#. type: Plain text
#: en/git-svn.txt:986
#, priority:100
msgid "Note that this may mean that multiple Git commits are created for a single SVN revision."
msgstr ""

#. type: Plain text
#: en/git-svn.txt:996
#, priority:100
msgid "An example: in an SVN repository with a standard trunk/tags/branches layout, a directory trunk/sub is created in r.100.  In r.200, trunk/sub is branched by copying it to branches/. 'git svn clone -s' will then create a branch 'sub'. It will also create new Git commits for r.100 through r.199 and use these as the history of branch 'sub'. Thus there will be two Git commits for each revision from r.100 to r.199 (one containing trunk/, one containing trunk/sub/). Finally, it will create a branch 'sub@200' pointing to the new parent commit of branch 'sub' (i.e. the commit for r.200 and trunk/sub/)."
msgstr ""

#. type: Plain text
#: en/git-svn.txt:1006
#, priority:100
msgid "For the sake of simplicity and interoperating with Subversion, it is recommended that all 'git svn' users clone, fetch and dcommit directly from the SVN server, and avoid all 'git clone'/'pull'/'merge'/'push' operations between Git repositories and branches.  The recommended method of exchanging code between Git branches and users is 'git format-patch' and 'git am', or just 'dcommit'ing to the SVN repository."
msgstr ""

#. type: Plain text
#: en/git-svn.txt:1012
#, priority:100
msgid "Running 'git merge' or 'git pull' is NOT recommended on a branch you plan to 'dcommit' from because Subversion users cannot see any merges you've made.  Furthermore, if you merge or pull from a Git branch that is a mirror of an SVN branch, 'dcommit' may commit to the wrong branch."
msgstr ""

#. type: Plain text
#: en/git-svn.txt:1015
#, priority:100
msgid "If you do merge, note the following rule: 'git svn dcommit' will attempt to commit on top of the SVN commit named in"
msgstr ""

#. type: delimited block -
#: en/git-svn.txt:1017
#, no-wrap, priority:100
msgid "git log --grep=^git-svn-id: --first-parent -1\n"
msgstr ""

#. type: Plain text
#: en/git-svn.txt:1022
#, priority:100
msgid "You 'must' therefore ensure that the most recent commit of the branch you want to dcommit to is the 'first' parent of the merge.  Chaos will ensue otherwise, especially if the first parent is an older commit on the same SVN branch."
msgstr ""

#. type: Plain text
#: en/git-svn.txt:1027
#, priority:100
msgid "'git clone' does not clone branches under the refs/remotes/ hierarchy or any 'git svn' metadata, or config.  So repositories created and managed with using 'git svn' should use 'rsync' for cloning, if cloning is to be done at all."
msgstr ""

#. type: Plain text
#: en/git-svn.txt:1032
#, priority:100
msgid "Since 'dcommit' uses rebase internally, any Git branches you 'git push' to before 'dcommit' on will require forcing an overwrite of the existing ref on the remote repository.  This is generally considered bad practice, see the linkgit:git-push[1] documentation for details."
msgstr ""

#. type: Plain text
#: en/git-svn.txt:1037
#, priority:100
msgid "Do not use the --amend option of linkgit:git-commit[1] on a change you've already dcommitted.  It is considered bad practice to --amend commits you've already pushed to a remote repository for other users, and dcommit with SVN is analogous to that."
msgstr ""

#. type: Plain text
#: en/git-svn.txt:1052
#, priority:100
msgid "When cloning an SVN repository, if none of the options for describing the repository layout is used (--trunk, --tags, --branches, --stdlayout), 'git svn clone' will create a Git repository with completely linear history, where branches and tags appear as separate directories in the working copy.  While this is the easiest way to get a copy of a complete repository, for projects with many branches it will lead to a working copy many times larger than just the trunk. Thus for projects using the standard directory structure (trunk/branches/tags), it is recommended to clone with option `--stdlayout`. If the project uses a non-standard structure, and/or if branches and tags are not required, it is easiest to only clone one directory (typically trunk), without giving any repository layout options.  If the full history with branches and tags is required, the options `--trunk` / `--branches` / `--tags` must be used."
msgstr ""

#. type: Plain text
#: en/git-svn.txt:1059
#, priority:100
msgid "When using multiple --branches or --tags, 'git svn' does not automatically handle name collisions (for example, if two branches from different paths have the same name, or if a branch and a tag have the same name).  In these cases, use 'init' to set up your Git repository then, before your first 'fetch', edit the $GIT_DIR/config file so that the branches and tags are associated with different name spaces.  For example:"
msgstr ""

#. type: Plain text
#: en/git-svn.txt:1062
#, no-wrap, priority:100
msgid ""
"\tbranches = stable/*:refs/remotes/svn/stable/*\n"
"\tbranches = debug/*:refs/remotes/svn/debug/*\n"
msgstr ""

#. type: Plain text
#: en/git-svn.txt:1073
#, priority:100
msgid "'git svn' stores [svn-remote] configuration information in the repository $GIT_DIR/config file.  It is similar the core Git [remote] sections except 'fetch' keys do not accept glob arguments; but they are instead handled by the 'branches' and 'tags' keys.  Since some SVN repositories are oddly configured with multiple projects glob expansions such those listed below are allowed:"
msgstr ""

#. type: delimited block -
#: en/git-svn.txt:1082
#, fuzzy, no-wrap, priority:100
msgid ""
"[svn-remote \"project-a\"]\n"
"\turl = http://server.org/svn\n"
"\tfetch = trunk/project-a:refs/remotes/project-a/trunk\n"
"\tbranches = branches/*/project-a:refs/remotes/project-a/branches/*\n"
"\tbranches = branches/release_*:refs/remotes/project-a/branches/release_*\n"
"\tbranches = branches/re*se:refs/remotes/project-a/branches/*\n"
"\ttags = tags/*/project-a:refs/remotes/project-a/tags/*\n"
msgstr ""
"[svn-remote \"project-a\"]\n"
"\turl = http://server.org/svn\n"
"\tfetch = trunk/project-a:refs/remotes/project-a/trunk\n"
"\tbranches = branches/*/project-a:refs/remotes/project-a/branches/*\n"
"\tbranches = branches/release_*:refs/remotes/project-a/branches/release_*\n"
"\tbranches = branches/re*se:refs/remotes/project-a/branches/*\n"
"\ttags = tags/*/project-a:refs/remotes/project-a/tags/*\n"

#. type: Plain text
#: en/git-svn.txt:1090
#, no-wrap, priority:100
msgid ""
"Keep in mind that the `*` (asterisk) wildcard of the local ref\n"
"(right of the `:`) *must* be the farthest right path component;\n"
"however the remote wildcard may be anywhere as long as it's an\n"
"independent path component (surrounded by `/` or EOL).   This\n"
"type of configuration is not automatically created by 'init' and\n"
"should be manually entered with a text-editor or using 'git config'.\n"
msgstr ""

#. type: Plain text
#: en/git-svn.txt:1092
#, priority:100
msgid "Also note that only one asterisk is allowed per word. For example:"
msgstr ""

#. type: Plain text
#: en/git-svn.txt:1094
#, no-wrap, priority:100
msgid "\tbranches = branches/re*se:refs/remotes/project-a/branches/*\n"
msgstr ""

#. type: Plain text
#: en/git-svn.txt:1096
#, priority:100
msgid "will match branches 'release', 'rese', 're123se', however"
msgstr ""

#. type: Plain text
#: en/git-svn.txt:1098
#, no-wrap, priority:100
msgid "\tbranches = branches/re*s*e:refs/remotes/project-a/branches/*\n"
msgstr ""

#. type: Plain text
#: en/git-svn.txt:1100
#, priority:100
msgid "will produce an error."
msgstr ""

#. type: Plain text
#: en/git-svn.txt:1103
#, priority:100
msgid "It is also possible to fetch a subset of branches or tags by using a comma-separated list of names within braces. For example:"
msgstr ""

#. type: delimited block -
#: en/git-svn.txt:1110
#, fuzzy, no-wrap, priority:100
msgid ""
"[svn-remote \"huge-project\"]\n"
"\turl = http://server.org/svn\n"
"\tfetch = trunk/src:refs/remotes/trunk\n"
"\tbranches = branches/{red,green}/src:refs/remotes/project-a/branches/*\n"
"\ttags = tags/{1.0,2.0}/src:refs/remotes/project-a/tags/*\n"
msgstr ""
"[svn-remote \"huge-project\"]\n"
"\turl = http://server.org/svn\n"
"\tfetch = trunk/src:refs/remotes/trunk\n"
"\tbranches = branches/{red,green}/src:refs/remotes/project-a/branches/*\n"
"\ttags = tags/{1.0,2.0}/src:refs/remotes/project-a/tags/*\n"

#. type: Plain text
#: en/git-svn.txt:1113
#, priority:100
msgid "Multiple fetch, branches, and tags keys are supported:"
msgstr ""

#. type: delimited block -
#: en/git-svn.txt:1122
#, fuzzy, no-wrap, priority:100
msgid ""
"[svn-remote \"messy-repo\"]\n"
"\turl = http://server.org/svn\n"
"\tfetch = trunk/project-a:refs/remotes/project-a/trunk\n"
"\tfetch = branches/demos/june-project-a-demo:refs/remotes/project-a/demos/june-demo\n"
"\tbranches = branches/server/*:refs/remotes/project-a/branches/*\n"
"\tbranches = branches/demos/2011/*:refs/remotes/project-a/2011-demos/*\n"
"\ttags = tags/server/*:refs/remotes/project-a/tags/*\n"
msgstr ""
"[svn-remote \"messy-repo\"]\n"
"\turl = http://server.org/svn\n"
"\tfetch = trunk/project-a:refs/remotes/project-a/trunk\n"
"\tfetch = branches/demos/june-project-a-demo:refs/remotes/project-a/demos/june-demo\n"
"\tbranches = branches/server/*:refs/remotes/project-a/branches/*\n"
"\tbranches = branches/demos/2011/*:refs/remotes/project-a/2011-demos/*\n"
"\ttags = tags/server/*:refs/remotes/project-a/tags/*\n"

#. type: Plain text
#: en/git-svn.txt:1126
#, priority:100
msgid "Creating a branch in such a configuration requires disambiguating which location to use using the -d or --destination flag:"
msgstr ""

#. type: delimited block -
#: en/git-svn.txt:1129
#, fuzzy, no-wrap, priority:100
msgid "$ git svn branch -d branches/server release-2-3-0\n"
msgstr "$ git svn branch -d branches/server release-2-3-0\n"

#. type: Plain text
#: en/git-svn.txt:1135
#, priority:100
msgid "Note that git-svn keeps track of the highest revision in which a branch or tag has appeared. If the subset of branches or tags is changed after fetching, then $GIT_DIR/svn/.metadata must be manually edited to remove (or reset) branches-maxRev and/or tags-maxRev as appropriate."
msgstr ""

#. type: Labeled list
#: en/git-svn.txt:1138
#, no-wrap, priority:100
msgid "$GIT_DIR/svn/\\**/.rev_map.*"
msgstr ""

#. type: Plain text
#: en/git-svn.txt:1144
#, priority:100
msgid "Mapping between Subversion revision numbers and Git commit names.  In a repository where the noMetadata option is not set, this can be rebuilt from the git-svn-id: lines that are at the end of every commit (see the 'svn.noMetadata' section above for details)."
msgstr ""

#. type: Plain text
#: en/git-svn.txt:1148
#, fuzzy, priority:100
msgid "'git svn fetch' and 'git svn rebase' automatically update the rev_map if it is missing or not up to date.  'git svn reset' automatically rewinds it."
msgstr "'git svn fetch' and 'git svn rebase' automatically update the rev_map if it is missing or not up to date.  'git svn reset' automatically rewinds it."

#. type: Plain text
#: en/git-svn.txt:1154
#, priority:100
msgid "We ignore all SVN properties except svn:executable.  Any unhandled properties are logged to $GIT_DIR/svn/<refname>/unhandled.log"
msgstr ""

#. type: Plain text
#: en/git-svn.txt:1161
#, priority:100
msgid "Renamed and copied directories are not detected by Git and hence not tracked when committing to SVN.  I do not plan on adding support for this as it's quite difficult and time-consuming to get working for all the possible corner cases (Git doesn't do it, either).  Committing renamed and copied files is fully supported if they're similar enough for Git to detect them."
msgstr ""

#. type: Plain text
#: en/git-svn.txt:1167
#, priority:100
msgid "In SVN, it is possible (though discouraged) to commit changes to a tag (because a tag is just a directory copy, thus technically the same as a branch). When cloning an SVN repository, 'git svn' cannot know if such a commit to a tag will happen in the future. Thus it acts conservatively and imports all SVN tags as branches, prefixing the tag name with 'tags/'."
msgstr ""

#. type: Title =
#: en/git-switch.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-switch(1)"
msgstr "git-switch(1)"

#. type: Plain text
#: en/git-switch.txt:7
#, priority:100
msgid "git-switch - Switch branches"
msgstr ""

#. type: Plain text
#: en/git-switch.txt:15
#, no-wrap, priority:100
msgid ""
"'git switch' [<options>] [--no-guess] <branch>\n"
"'git switch' [<options>] --detach [<start-point>]\n"
"'git switch' [<options>] (-c|-C) <new-branch> [<start-point>]\n"
"'git switch' [<options>] --orphan <new-branch>\n"
msgstr ""

#. type: Plain text
#: en/git-switch.txt:21
#, priority:100
msgid "Switch to a specified branch. The working tree and the index are updated to match the branch. All new commits will be added to the tip of this branch."
msgstr ""

#. type: Plain text
#: en/git-switch.txt:26
#, priority:100
msgid "Optionally a new branch could be created with either `-c`, `-C`, automatically from a remote branch of same name (see `--guess`), or detach the working tree from any branch with `--detach`, along with switching."
msgstr ""

#. type: Plain text
#: en/git-switch.txt:31
#, priority:100
msgid "Switching branches does not require a clean index and working tree (i.e. no differences compared to `HEAD`). The operation is aborted however if the operation leads to loss of local changes, unless told otherwise with `--discard-changes` or `--merge`."
msgstr ""

#. type: Plain text
#: en/git-switch.txt:38
#, priority:100
msgid "Branch to switch to."
msgstr ""

#. type: Plain text
#: en/git-switch.txt:48
#, priority:100
msgid "The starting point for the new branch. Specifying a `<start-point>` allows you to create a branch based on some other point in history than where HEAD currently points. (Or, in the case of `--detach`, allows you to inspect and detach from some other point.)"
msgstr ""

#. type: Plain text
#: en/git-switch.txt:54
#, priority:100
msgid "You can use the `@{-N}` syntax to refer to the N-th last branch/commit switched to using \"git switch\" or \"git checkout\" operation. You may also specify `-` which is synonymous to `@{-1}`.  This is often used to switch quickly between two branches, or to undo a branch switch by mistake."
msgstr ""

#. type: Labeled list
#: en/git-switch.txt:59
#, no-wrap, priority:100
msgid "-c <new-branch>"
msgstr ""

#. type: Labeled list
#: en/git-switch.txt:60
#, fuzzy, no-wrap, priority:100
msgid "--create <new-branch>"
msgstr "--create <new-branch>"

#. type: Plain text
#: en/git-switch.txt:64
#, priority:100
msgid "Create a new branch named `<new-branch>` starting at `<start-point>` before switching to the branch. This is a convenient shortcut for:"
msgstr ""

#. type: delimited block -
#: en/git-switch.txt:68
#, fuzzy, no-wrap, priority:100
msgid ""
"$ git branch <new-branch>\n"
"$ git switch <new-branch>\n"
msgstr ""
"$ git branch <new-branch>\n"
"$ git switch <new-branch>\n"

#. type: Labeled list
#: en/git-switch.txt:70
#, fuzzy, no-wrap, priority:100
msgid "-C <new-branch>"
msgstr "-C <new-branch>"

#. type: Labeled list
#: en/git-switch.txt:71
#, fuzzy, no-wrap, priority:100
msgid "--force-create <new-branch>"
msgstr "--force-create <new-branch>"

#. type: Plain text
#: en/git-switch.txt:75
#, priority:100
msgid "Similar to `--create` except that if `<new-branch>` already exists, it will be reset to `<start-point>`. This is a convenient shortcut for:"
msgstr ""

#. type: delimited block -
#: en/git-switch.txt:79
#, fuzzy, no-wrap, priority:100
msgid ""
"$ git branch -f <new-branch>\n"
"$ git switch <new-branch>\n"
msgstr ""
"$ git branch -f <new-branch>\n"
"$ git switch <new-branch>\n"

#. type: Plain text
#: en/git-switch.txt:86
#, priority:100
msgid "Switch to a commit for inspection and discardable experiments. See the \"DETACHED HEAD\" section in linkgit:git-checkout[1] for details."
msgstr ""

#. type: delimited block -
#: en/git-switch.txt:95
#, fuzzy, no-wrap, priority:100
msgid "$ git switch -c <branch> --track <remote>/<branch>\n"
msgstr "$ git switch -c <branch> --track <remote>/<branch>\n"

#. type: Plain text
#: en/git-switch.txt:113
#, priority:100
msgid "An alias for `--discard-changes`."
msgstr ""

#. type: Labeled list
#: en/git-switch.txt:114
#, ignore-same, no-wrap, priority:100
msgid "--discard-changes"
msgstr "--discard-changes"

#. type: Plain text
#: en/git-switch.txt:120
#, priority:100
msgid "Proceed even if the index or the working tree differs from `HEAD`. Both the index and working tree are restored to match the switching target. If `--recurse-submodules` is specified, submodule content is also restored to match the switching target. This is used to throw away local changes."
msgstr ""

#. type: Plain text
#: en/git-switch.txt:130
#, priority:100
msgid "If you have local modifications to one or more files that are different between the current branch and the branch to which you are switching, the command refuses to switch branches in order to preserve your modifications in context.  However, with this option, a three-way merge between the current branch, your working tree contents, and the new branch is done, and you will be on the new branch."
msgstr ""

#. type: Labeled list
#: en/git-switch.txt:154
#, no-wrap, priority:100
msgid "--track [direct|inherit]"
msgstr ""

#. type: Plain text
#: en/git-switch.txt:158
#, priority:100
msgid "When creating a new branch, set up \"upstream\" configuration.  `-c` is implied. See `--track` in linkgit:git-branch[1] for details."
msgstr ""

#. type: Plain text
#: en/git-switch.txt:168
#, priority:100
msgid "If no `-c` option is given, the name of the new branch will be derived from the remote-tracking branch, by looking at the local part of the refspec configured for the corresponding remote, and then stripping the initial part up to the \"*\".  This would tell us to use `hack` as the local branch when branching off of `origin/hack` (or `remotes/origin/hack`, or even `refs/remotes/origin/hack`).  If the given name has no slash, or the above guessing results in an empty name, the guessing is aborted.  You can explicitly give a name with `-c` in such a case."
msgstr ""

#. type: Plain text
#: en/git-switch.txt:176
#, priority:100
msgid "Create a new 'orphan' branch, named `<new-branch>`. All tracked files are removed."
msgstr ""

#. type: Plain text
#: en/git-switch.txt:182
#, priority:100
msgid "`git switch` refuses when the wanted ref is already checked out by another worktree. This option makes it check the ref out anyway. In other words, the ref can be held by more than one worktree."
msgstr ""

#. type: Plain text
#: en/git-switch.txt:191
#, priority:100
msgid "Using `--recurse-submodules` will update the content of all active submodules according to the commit recorded in the superproject. If nothing (or `--no-recurse-submodules`) is used, submodules working trees will not be updated. Just like linkgit:git-submodule[1], this will detach `HEAD` of the submodules."
msgstr ""

#. type: Plain text
#: en/git-switch.txt:196
#, priority:100
msgid "The following command switches to the \"master\" branch:"
msgstr ""

#. type: delimited block -
#: en/git-switch.txt:199
#, no-wrap, priority:100
msgid "$ git switch master\n"
msgstr ""

#. type: delimited block -
#: en/git-switch.txt:206
#, fuzzy, no-wrap, priority:100
msgid "$ git switch mytopic\n"
msgstr "$ git switch mytopic\n"

#. type: Plain text
#: en/git-switch.txt:211
#, priority:100
msgid "However, your \"wrong\" branch and correct \"mytopic\" branch may differ in files that you have modified locally, in which case the above switch would fail like this:"
msgstr ""

#. type: delimited block -
#: en/git-switch.txt:215
#, fuzzy, no-wrap, priority:100
msgid ""
"$ git switch mytopic\n"
"error: You have local changes to 'frotz'; not switching branches.\n"
msgstr ""
"$ git switch mytopic\n"
"error: You have local changes to 'frotz'; not switching branches.\n"

#. type: delimited block -
#: en/git-switch.txt:223
#, fuzzy, no-wrap, priority:100
msgid ""
"$ git switch -m mytopic\n"
"Auto-merging frotz\n"
msgstr ""
"$ git switch -m mytopic\n"
"Auto-merging frotz\n"

#. type: Plain text
#: en/git-switch.txt:231
#, priority:100
msgid "To switch back to the previous branch before we switched to mytopic (i.e. \"master\" branch):"
msgstr ""

#. type: delimited block -
#: en/git-switch.txt:234
#, fuzzy, no-wrap, priority:100
msgid "$ git switch -\n"
msgstr "$ git switch -\n"

#. type: Plain text
#: en/git-switch.txt:238
#, priority:100
msgid "You can grow a new branch from any commit. For example, switch to \"HEAD~3\" and create branch \"fixup\":"
msgstr ""

#. type: delimited block -
#: en/git-switch.txt:242
#, fuzzy, no-wrap, priority:100
msgid ""
"$ git switch -c fixup HEAD~3\n"
"Switched to a new branch 'fixup'\n"
msgstr ""
"$ git switch -c fixup HEAD~3\n"
"Switched to a new branch 'fixup'\n"

#. type: Plain text
#: en/git-switch.txt:246
#, priority:100
msgid "If you want to start a new branch from a remote branch of the same name:"
msgstr ""

#. type: delimited block -
#: en/git-switch.txt:251
#, fuzzy, no-wrap, priority:100
msgid ""
"$ git switch new-topic\n"
"Branch 'new-topic' set up to track remote branch 'new-topic' from 'origin'\n"
"Switched to a new branch 'new-topic'\n"
msgstr ""
"$ git switch new-topic\n"
"Branch 'new-topic' set up to track remote branch 'new-topic' from 'origin'\n"
"Switched to a new branch 'new-topic'\n"

#. type: Plain text
#: en/git-switch.txt:255
#, priority:100
msgid "To check out commit `HEAD~3` for temporary inspection or experiment without creating a new branch:"
msgstr ""

#. type: delimited block -
#: en/git-switch.txt:259
#, fuzzy, no-wrap, priority:100
msgid ""
"$ git switch --detach HEAD~3\n"
"HEAD is now at 9fc9555312 Merge branch 'cc/shared-index-permbits'\n"
msgstr ""
"$ git switch --detach HEAD~3\n"
"HEAD is now at 9fc9555312 Merge branch 'cc/shared-index-permbits'\n"

#. type: Plain text
#: en/git-switch.txt:263
#, priority:100
msgid "If it turns out whatever you have done is worth keeping, you can always create a new name for it (without switching away):"
msgstr ""

#. type: delimited block -
#: en/git-switch.txt:266
#, fuzzy, no-wrap, priority:100
msgid "$ git switch -c good-surprises\n"
msgstr "$ git switch -c good-surprises\n"

#. type: Plain text
#: en/git-switch.txt:279
#, ignore-same, priority:100
msgid "linkgit:git-checkout[1], linkgit:git-branch[1]"
msgstr "linkgit:git-checkout[1], linkgit:git-branch[1]"

#. type: Title =
#: en/git-symbolic-ref.txt:2
#, ignore-same, no-wrap, priority:80
msgid "git-symbolic-ref(1)"
msgstr "git-symbolic-ref(1)"

#. type: Plain text
#: en/git-symbolic-ref.txt:7
#, priority:80
msgid "git-symbolic-ref - Read, modify and delete symbolic refs"
msgstr ""

#. type: Plain text
#: en/git-symbolic-ref.txt:14
#, no-wrap, priority:80
msgid ""
"'git symbolic-ref' [-m <reason>] <name> <ref>\n"
"'git symbolic-ref' [-q] [--short] [--no-recurse] <name>\n"
"'git symbolic-ref' --delete [-q] <name>\n"
msgstr ""

#. type: Plain text
#: en/git-symbolic-ref.txt:21
#, priority:80
msgid "Given one argument, reads which branch head the given symbolic ref refers to and outputs its path, relative to the `.git/` directory.  Typically you would give `HEAD` as the <name> argument to see which branch your working tree is on."
msgstr ""

#. type: Plain text
#: en/git-symbolic-ref.txt:24
#, priority:80
msgid "Given two arguments, creates or updates a symbolic ref <name> to point at the given branch <ref>."
msgstr ""

#. type: Plain text
#: en/git-symbolic-ref.txt:27
#, priority:80
msgid "Given `--delete` and an additional argument, deletes the given symbolic ref."
msgstr ""

#. type: Plain text
#: en/git-symbolic-ref.txt:31
#, priority:80
msgid "A symbolic ref is a regular file that stores a string that begins with `ref: refs/`.  For example, your `.git/HEAD` is a regular file whose contents is `ref: refs/heads/master`."
msgstr ""

#. type: Plain text
#: en/git-symbolic-ref.txt:38
#, priority:80
msgid "Delete the symbolic ref <name>."
msgstr ""

#. type: Plain text
#: en/git-symbolic-ref.txt:44
#, priority:80
msgid "Do not issue an error message if the <name> is not a symbolic ref but a detached HEAD; instead exit with non-zero status silently."
msgstr ""

#. type: Plain text
#: en/git-symbolic-ref.txt:48
#, priority:80
msgid "When showing the value of <name> as a symbolic ref, try to shorten the value, e.g. from `refs/heads/master` to `master`."
msgstr ""

#. type: Labeled list
#: en/git-symbolic-ref.txt:49
#, ignore-same, no-wrap, priority:80
msgid "--recurse"
msgstr "--recurse"

#. type: Labeled list
#: en/git-symbolic-ref.txt:50
#, ignore-same, no-wrap, priority:80
msgid "--no-recurse"
msgstr "--no-recurse"

#. type: Plain text
#: en/git-symbolic-ref.txt:57
#, priority:80
msgid "When showing the value of <name> as a symbolic ref, if <name> refers to another symbolic ref, follow such a chain of symbolic refs until the result no longer points at a symbolic ref (`--recurse`, which is the default).  `--no-recurse` stops after dereferencing only a single level of symbolic ref."
msgstr ""

#. type: Plain text
#: en/git-symbolic-ref.txt:61
#, priority:80
msgid "Update the reflog for <name> with <reason>.  This is valid only when creating or updating a symbolic ref."
msgstr ""

#. type: Plain text
#: en/git-symbolic-ref.txt:71
#, priority:80
msgid "In the past, `.git/HEAD` was a symbolic link pointing at `refs/heads/master`.  When we wanted to switch to another branch, we did `ln -sf refs/heads/newbranch .git/HEAD`, and when we wanted to find out which branch we are on, we did `readlink .git/HEAD`.  But symbolic links are not entirely portable, so they are now deprecated and symbolic refs (as described above) are used by default."
msgstr ""

#. type: Plain text
#: en/git-symbolic-ref.txt:75
#, priority:80
msgid "'git symbolic-ref' will exit with status 0 if the contents of the symbolic ref were printed correctly, with status 1 if the requested name is not a symbolic ref, or 128 if another error occurs."
msgstr ""

#. type: Title =
#: en/git-tag.txt:2
#, ignore-same, no-wrap, priority:240
msgid "git-tag(1)"
msgstr "git-tag(1)"

#. type: Plain text
#: en/git-tag.txt:7
#, priority:240
msgid "git-tag - Create, list, delete or verify a tag object signed with GPG"
msgstr "git-tag - 创建、列出、删除或验证使用GPG签名的tag对象"

#. type: Plain text
#: en/git-tag.txt:20
#, ignore-ellipsis, no-wrap, priority:240
msgid ""
"'git tag' [-a | -s | -u <key-id>] [-f] [-m <msg> | -F <file>] [-e]\n"
"\t<tagname> [<commit> | <object>]\n"
"'git tag' -d <tagname>...\n"
"'git tag' [-n[<num>]] -l [--contains <commit>] [--no-contains <commit>]\n"
"\t[--points-at <object>] [--column[=<options>] | --no-column]\n"
"\t[--create-reflog] [--sort=<key>] [--format=<format>]\n"
"\t[--merged <commit>] [--no-merged <commit>] [<pattern>...]\n"
"'git tag' -v [--format=<format>] <tagname>...\n"
msgstr ""
"'git tag' [-a | -s | -u <键-id>] [-f] [-m <信息> | -F <文件>] [-e]\n"
"\t<标签名> [<提交> | <对象>]\n"
"'git tag' -d <标签名>...\n"
"'git tag' [-n[<数字>]] -l [--contains <提交>] [--no-contains <提交>]\n"
"\t[--points-at <对象>] [--column[=<选项>] | --no-column]\n"
"\t[--create-reflog] [--sort=<键>] [--format=<格式>]\n"
"\t[--merged <提交>] [--no-merged <提交>] [<模式>...]\n"
"'git tag' -v [--format=<format>] <标签名>...\n"

#. type: Plain text
#: en/git-tag.txt:26
#, priority:240
msgid "Add a tag reference in `refs/tags/`, unless `-d/-l/-v` is given to delete, list or verify tags."
msgstr "在`refs/tags/`中添加一个标签引用，除非给出`-d/-l/-v`来删除、列出或验证标签。"

#. type: Plain text
#: en/git-tag.txt:28
#, priority:240
msgid "Unless `-f` is given, the named tag must not yet exist."
msgstr "除非给出`-f`，否则命名的标签必须还不存在。"

#. type: Plain text
#: en/git-tag.txt:33
#, priority:240
msgid "If one of `-a`, `-s`, or `-u <key-id>` is passed, the command creates a 'tag' object, and requires a tag message.  Unless `-m <msg>` or `-F <file>` is given, an editor is started for the user to type in the tag message."
msgstr "如果传递了`-a', `-s', 或 `-u <key-id>`中的一个，该命令会创建一个'标签'对象，并要求提供一个标签信息。  除非给出`-m <信息>`或`-F <文件>`，否则会启动一个编辑器，让用户输入标签信息。"

#. type: Plain text
#: en/git-tag.txt:36
#, priority:240
msgid "If `-m <msg>` or `-F <file>` is given and `-a`, `-s`, and `-u <key-id>` are absent, `-a` is implied."
msgstr "如果给定了`-m <消息>`或`-F <文件>`，并且没有`-a`、`-s`和`-u <键-id>`，则默认为`-a`。"

#. type: Plain text
#: en/git-tag.txt:39
#, priority:240
msgid "Otherwise, a tag reference that points directly at the given object (i.e., a lightweight tag) is created."
msgstr "否则，就会创建一个直接指向给定对象的标签引用（即一个轻量级标签）。"

#. type: Plain text
#: en/git-tag.txt:45
#, priority:240
msgid "A GnuPG signed tag object will be created when `-s` or `-u <key-id>` is used.  When `-u <key-id>` is not used, the committer identity for the current user is used to find the GnuPG key for signing. \tThe configuration variable `gpg.program` is used to specify custom GnuPG binary."
msgstr "当使用`-s`或`-u <键-id>`时，将创建一个GnuPG签名标签对象。  当没有使用`-u <键-id>`时，当前用户的提交者身份会被用来寻找GnuPG密钥进行签名。 \t配置变量 `gpg.program` 用于指定自定义 GnuPG 二进制文件。"

#. type: Plain text
#: en/git-tag.txt:51
#, priority:240
msgid "Tag objects (created with `-a`, `-s`, or `-u`) are called \"annotated\" tags; they contain a creation date, the tagger name and e-mail, a tagging message, and an optional GnuPG signature. Whereas a \"lightweight\" tag is simply a name for an object (usually a commit object)."
msgstr "标签对象（用`-a`、`-s`或`-u`创建）被称为 \"注释 \"标签；它们包含创建日期、标记者姓名和电子邮件、标记信息和可选的GnuPG签名。而 \"轻量级 \"标签只是一个对象（通常是一个提交对象）的名称。"

#. type: Plain text
#: en/git-tag.txt:56
#, priority:240
msgid "Annotated tags are meant for release while lightweight tags are meant for private or temporary object labels. For this reason, some git commands for naming objects (like `git describe`) will ignore lightweight tags by default."
msgstr "注释性标签是用来发布的，而轻量级标签则是用于私人或临时对象的标签。由于这个原因，一些命名对象的git命令（如`git describe`）默认会忽略轻量级标签。"

#. type: Plain text
#: en/git-tag.txt:63
#, priority:240
msgid "Make an unsigned, annotated tag object"
msgstr "制作一个无符号、有注释的标签对象"

#. type: Labeled list
#: en/git-tag.txt:65
#, ignore-same, no-wrap, priority:240
msgid "--sign"
msgstr "--sign"

#. type: Plain text
#: en/git-tag.txt:70
#, priority:240
msgid "Make a GPG-signed tag, using the default e-mail address's key.  The default behavior of tag GPG-signing is controlled by `tag.gpgSign` configuration variable if it exists, or disabled otherwise.  See linkgit:git-config[1]."
msgstr "制作一个GPG签名的标签，使用默认电子邮件地址的密钥。  标签GPG签名的默认行为由`tag.gpgSign`配置变量控制（如果存在），否则禁用。  参见 linkgit:git-config[1]。"

#. type: Labeled list
#: en/git-tag.txt:71
#, ignore-same, no-wrap, priority:240
msgid "--no-sign"
msgstr "--no-sign"

#. type: Plain text
#: en/git-tag.txt:74
#, priority:240
msgid "Override `tag.gpgSign` configuration variable that is set to force each and every tag to be signed."
msgstr "覆盖`tag.gpgSign`配置变量，该变量被设置为强制每一个标签都被签名。"

#. type: Labeled list
#: en/git-tag.txt:75
#, fuzzy, no-wrap, priority:240
msgid "-u <key-id>"
msgstr "-u <keyid>"

#. type: Labeled list
#: en/git-tag.txt:76
#, fuzzy, no-wrap, priority:240
#| msgid "--sort=<key>"
msgid "--local-user=<key-id>"
msgstr "--排序=<键>"

#. type: Plain text
#: en/git-tag.txt:78
#, priority:240
msgid "Make a GPG-signed tag, using the given key."
msgstr "制作一个GPG签名的标签，使用给定的密钥。"

#. type: Plain text
#: en/git-tag.txt:82
#, priority:240
msgid "Replace an existing tag with the given name (instead of failing)"
msgstr "用给定的名称替换一个现有的标签（而不是失败）"

#. type: Plain text
#: en/git-tag.txt:86
#, priority:240
msgid "Delete existing tags with the given names."
msgstr "删除给定名字的现存标签。"

#. type: Plain text
#: en/git-tag.txt:90
#, priority:240
msgid "Verify the GPG signature of the given tag names."
msgstr "验证给定标签名称的GPG签名。"

#. type: Labeled list
#: en/git-tag.txt:91
#, fuzzy, no-wrap, priority:240
msgid "-n<num>"
msgstr "-n<num>"

#. type: Plain text
#: en/git-tag.txt:94
#, priority:240
msgid "<num> specifies how many lines from the annotation, if any, are printed when using -l. Implies `--list`."
msgstr "<数字>指定在使用-l时打印多少行注释，-l是指\"--list\"。"

#. type: Plain text
#: en/git-tag.txt:98
#, priority:240
msgid "The default is not to print any annotation lines.  If no number is given to `-n`, only the first line is printed.  If the tag is not annotated, the commit message is displayed instead."
msgstr "默认是不打印任何注释行。  如果没有给 `n `加上数字，则只打印第一行。  如果标签没有注释，则会显示提交信息。"

#. type: Plain text
#: en/git-tag.txt:103
#, ignore-ellipsis, priority:240
msgid "List tags. With optional `<pattern>...`, e.g. `git tag --list 'v-*'`, list only the tags that match the pattern(s)."
msgstr "列出标签。使用可选的`<模式>...`，例如`git tag --list 'v-*'`，只列出符合模式的标签。"

#. type: Plain text
#: en/git-tag.txt:107
#, priority:240
msgid "Running \"git tag\" without arguments also lists all tags. The pattern is a shell wildcard (i.e., matched using fnmatch(3)). Multiple patterns may be given; if any of them matches, the tag is shown."
msgstr "运行 \"git tag \"时不加参数也会列出所有标签。模式是一个shell通配符（即用fnmatch(3)匹配）。可以给出多个模式；如果其中任何一个匹配，就会显示该标签。"

#. type: Plain text
#: en/git-tag.txt:111
#, priority:240
msgid "This option is implicitly supplied if any other list-like option such as `--contains` is provided. See the documentation for each of those options for details."
msgstr "如果提供任何其他类似列表的选项，如`--contains`，则隐含地提供该选项。详情请参见这些选项的文档。"

#. type: Plain text
#: en/git-tag.txt:124
#, priority:240
msgid "Sort based on the key given.  Prefix `-` to sort in descending order of the value. You may use the --sort=<key> option multiple times, in which case the last key becomes the primary key. Also supports \"version:refname\" or \"v:refname\" (tag names are treated as versions). The \"version:refname\" sort order can also be affected by the \"versionsort.suffix\" configuration variable.  The keys supported are the same as those in `git for-each-ref`.  Sort order defaults to the value configured for the `tag.sort` variable if it exists, or lexicographic order otherwise. See linkgit:git-config[1]."
msgstr "根据给定的键进行排序。  前缀\"-\"表示按照数值的降序排序。你可以多次使用--sort=<键>选项，在这种情况下，最后一个键成为主键。也支持 \"version:refname \"或 \"v:refname\"（标签名被视为版本）。\"version:refname \"的排序顺序也可以由 \"versionort.senffix \"配置变量影响。  支持的键与`git for-each-ref`中的相同。  排序顺序默认为 \"tag.sort \"变量的配置值（如果存在的话），否则为词法顺序。见linkgit:git-config[1]。"

#. type: Plain text
#: en/git-tag.txt:133
#, priority:240
msgid "Sorting and filtering tags are case insensitive."
msgstr "排序和过滤标签不区分大小写。"

#. type: Plain text
#: en/git-tag.txt:143
#, priority:240
msgid "Display tag listing in columns. See configuration variable `column.tag` for option syntax. `--column` and `--no-column` without options are equivalent to 'always' and 'never' respectively."
msgstr "在列中显示标签列表。选项语法见配置变量`column.tag`。`--column`和`--no-column`没有选项，分别等同于'永远'和'从不'。"

#. type: Plain text
#: en/git-tag.txt:145
#, priority:240
msgid "This option is only applicable when listing tags without annotation lines."
msgstr "这个选项只适用于列出没有注释线的标签。"

#. type: Plain text
#: en/git-tag.txt:149
#, priority:240
msgid "Only list tags which contain the specified commit (HEAD if not specified). Implies `--list`."
msgstr "只列出包含指定提交内容的标签（如果没有指定则为当前分支）。暗指`--list`。"

#. type: Plain text
#: en/git-tag.txt:153
#, priority:240
msgid "Only list tags which don't contain the specified commit (HEAD if not specified). Implies `--list`."
msgstr "只列出包含指定提交内容的标签（如果没有指定则为当前分支）。暗指`--list`。"

#. type: Plain text
#: en/git-tag.txt:157
#, priority:240
msgid "Only list tags whose commits are reachable from the specified commit (`HEAD` if not specified)."
msgstr "只列出其提交可以从指定提交（如果没有指定则为`HEAD`）到达的标签。"

#. type: Plain text
#: en/git-tag.txt:161
#, priority:240
msgid "Only list tags whose commits are not reachable from the specified commit (`HEAD` if not specified)."
msgstr "只列出其提交可以从指定提交（如果没有指定则为`HEAD`）到达的标签。"

#. type: Plain text
#: en/git-tag.txt:165
#, priority:240
msgid "Only list tags of the given object (HEAD if not specified). Implies `--list`."
msgstr "只列出给定对象的标签（如果没有指定则为当前分支）。暗指`--list`。"

#. type: Plain text
#: en/git-tag.txt:173
#, fuzzy, priority:240
#| msgid "Use the given note message (instead of prompting).  If multiple `-m` options are given, their values are concatenated as separate paragraphs.  Lines starting with `#` and empty lines other than a single line between paragraphs will be stripped out."
msgid "Use the given tag message (instead of prompting).  If multiple `-m` options are given, their values are concatenated as separate paragraphs.  Implies `-a` if none of `-a`, `-s`, or `-u <key-id>` is given."
msgstr "使用给定的注释信息（而不是提示）。  如果给定了多个`-m`选项，它们的值将作为单独的段落串联起来。  以`#`开头的行和段落之间的单行以外的空行将被剥离出来。"

#. type: Plain text
#: en/git-tag.txt:180
#, fuzzy, priority:240
#| msgid "Take the commit message from the given file.  Use '-' to read the message from the standard input."
msgid "Take the tag message from the given file.  Use '-' to read the message from the standard input.  Implies `-a` if none of `-a`, `-s`, or `-u <key-id>` is given."
msgstr "从给定文件中获取提交信息。  使用'-'可以从标准输入中读取信息。"

#. type: Plain text
#: en/git-tag.txt:186
#, priority:240
msgid "The message taken from file with `-F` and command line with `-m` are usually used as the tag message unmodified.  This option lets you further edit the message taken from these sources."
msgstr "用`-F`从文件中获取的信息和用`-m`从命令行中获取的信息通常被用作未修改的标签信息。  这个选项可以让你进一步编辑从这些来源获取的信息。"

#. type: Plain text
#: en/git-tag.txt:193
#, priority:240
msgid "This option sets how the tag message is cleaned up.  The '<mode>' can be one of 'verbatim', 'whitespace' and 'strip'.  The 'strip' mode is default. The 'verbatim' mode does not change message at all, 'whitespace' removes just leading/trailing whitespace lines and 'strip' removes both whitespace and commentary."
msgstr "这个选项设置了标签信息的清理方式。  '<模式>'可以是'verbatim'（逐字记录）、'whitespace'（空白）和'strip'（剥离）中的一个。  其中，'strip'模式是默认的。'verbatim'模式完全不改变信息，'whitespace'只删除前导/后导的空白行，'strip'同时删除空白和注释。"

#. type: Plain text
#: en/git-tag.txt:200
#, priority:240
msgid "Create a reflog for the tag. To globally enable reflogs for tags, see `core.logAllRefUpdates` in linkgit:git-config[1].  The negated form `--no-create-reflog` only overrides an earlier `--create-reflog`, but currently does not negate the setting of `core.logAllRefUpdates`."
msgstr "为标签创建一个引用日志。要全局性地启用标签的引用日志，请参见 linkgit:git-config[1] 中的 `core.logAllRefUpdates`。  否定形式的 `--no-create-reflog` 会覆盖先前的 `--create-reflog` ，但目前不会否定 `core.logAllRefUpdates` 的设置。"

#. type: Plain text
#: en/git-tag.txt:206
#, priority:240
msgid "A string that interpolates `%(fieldname)` from a tag ref being shown and the object it points at.  The format is the same as that of linkgit:git-for-each-ref[1].  When unspecified, defaults to `%(refname:strip=2)`."
msgstr "一个字符串，从正在显示的标签引用和它所指向的对象中插值`%(fieldname)'。  其格式与linkgit:git-for-each-ref[1]相同。  当未指定时，默认为`%(refname:strip=2)`。"

#. type: Labeled list
#: en/git-tag.txt:207
#, fuzzy, no-wrap, priority:240
msgid "<tagname>"
msgstr "<tagname>"

#. type: Plain text
#: en/git-tag.txt:212
#, priority:240
msgid "The name of the tag to create, delete, or describe.  The new tag name must pass all checks defined by linkgit:git-check-ref-format[1].  Some of these checks may restrict the characters allowed in a tag name."
msgstr "要创建、删除或描述的标签的名称。  新标签名必须通过 linkgit:git-check-ref-format[1] 定义的所有检查。  其中一些检查可能限制了标签名称中允许的字符。"

#. type: Labeled list
#: en/git-tag.txt:213 en/git.txt:399
#, fuzzy, no-wrap, priority:240
msgid "<commit>"
msgstr "<commit>"

#. type: Plain text
#: en/git-tag.txt:217
#, priority:240
msgid "The object that the new tag will refer to, usually a commit.  Defaults to HEAD."
msgstr "新标签将引用的对象，通常是一个提交。  默认为当前分支。"

#. type: Plain text
#: en/git-tag.txt:224
#, priority:240
msgid "By default, 'git tag' in sign-with-default mode (-s) will use your committer identity (of the form `Your Name <your@email.address>`) to find a key.  If you want to use a different default key, you can specify it in the repository configuration as follows:"
msgstr "默认情况下，sign-with-default模式下的'git tag'（-s）会使用你的提交者身份（形式为`你的名字<your@email.address>`）来寻找一个密钥。  如果你想使用一个不同的默认密钥，你可以在仓库配置中指定它，如下："

#. type: delimited block -
#: en/git-tag.txt:228
#, fuzzy, no-wrap, priority:240
msgid ""
"[user]\n"
"    signingKey = <gpg-key_id>\n"
msgstr ""
"[user]\n"
"    signingKey = <gpg-keyid>\n"

#. type: Plain text
#: en/git-tag.txt:233
#, priority:240
msgid "`pager.tag` is only respected when listing tags, i.e., when `-l` is used or implied. The default is to use a pager.  See linkgit:git-config[1]."
msgstr "`pager.tag`只在列出标签时被尊重，即使用或暗示使用`-l`时。默认是使用分页器。  参见 linkgit:git-config[1]。"

#. type: Title ~
#: en/git-tag.txt:238
#, no-wrap, priority:240
msgid "On Re-tagging"
msgstr "关于重新打标签"

#. type: Plain text
#: en/git-tag.txt:242
#, priority:240
msgid "What should you do when you tag a wrong commit and you would want to re-tag?"
msgstr "当你标记了一个错误的提交，而你想重新标记时，你应该怎么做？"

#. type: Plain text
#: en/git-tag.txt:245
#, priority:240
msgid "If you never pushed anything out, just re-tag it. Use \"-f\" to replace the old one. And you're done."
msgstr "如果你从未推送到其他地方，只需重新标记。使用\"-f \"来替换旧的标签。然后你就完成了。"

#. type: Plain text
#: en/git-tag.txt:249
#, priority:240
msgid "But if you have pushed things out (or others could just read your repository directly), then others will have already seen the old tag. In that case you can do one of two things:"
msgstr "但如果你已经推送了（或者别人可以直接读取你的版本库），那么别人就已经看到了旧标签。在这种情况下，你可以在以下两种做法任选其一："

#. type: Plain text
#: en/git-tag.txt:256
#, priority:240
msgid "The sane thing.  Just admit you screwed up, and use a different name. Others have already seen one tag-name, and if you keep the same name, you may be in the situation that two people both have \"version X\", but they actually have 'different' \"X\"'s.  So just call it \"X.1\" and be done with it."
msgstr "理智的做法是。  只要承认你搞砸了，并使用一个不同的名字。其他人已经看到了一个标签名称，如果你保持相同的名称，你可能会出现这样的情况：两个人都有 \"X版\"，但他们实际上有 \"不同 \"的 \"X\"。  所以，只要叫它 \"X.1 \"就可以了。"

#. type: Plain text
#: en/git-tag.txt:261
#, priority:240
msgid "The insane thing.  You really want to call the new version \"X\" too, 'even though' others have already seen the old one. So just use 'git tag -f' again, as if you hadn't already published the old one."
msgstr "疯狂的做法。  你真的想把新版本也称为 \"X\"，⌊尽管⌉别人已经看到了旧版本。所以就再用'git tag -f'，就好像你还没有发布过旧版本一样。"

#. type: Plain text
#: en/git-tag.txt:266
#, priority:240
msgid "However, Git does *not* (and it should not) change tags behind users back. So if somebody already got the old tag, doing a 'git pull' on your tree shouldn't just make them overwrite the old one."
msgstr "然而，Git*不会*（也不应该）背着用户改变标签。所以如果有人已经得到了旧的标签，在你的树上做 \"git pull \"不应该让他们覆盖旧的标签。"

#. type: Plain text
#: en/git-tag.txt:273
#, priority:240
msgid "If somebody got a release tag from you, you cannot just change the tag for them by updating your own one. This is a big security issue, in that people MUST be able to trust their tag-names.  If you really want to do the insane thing, you need to just fess up to it, and tell people that you messed up. You can do that by making a very public announcement saying:"
msgstr "如果有人从你那里得到一个发布标签，你不能通过更新你自己的标签来为他们改变标签。这是一个很大的安全问题，因为人们必须能够信任他们的标签名。  如果你真的想做一件疯狂的事情，你需要承认这一点，并告诉人们你搞砸了。你可以通过发布一个非常公开的公告来做到这一点，比如说："

#. type: delimited block -
#: en/git-tag.txt:277
#, no-wrap, priority:240
msgid ""
"Ok, I messed up, and I pushed out an earlier version tagged as X. I\n"
"then fixed something, and retagged the *fixed* tree as X again.\n"
msgstr ""
"好吧，我搞砸了，我推送了一个标记为X的早期版本。\n"
"然后修复了一些东西，又把这个*修复的*目录树重新标记为X。\n"

#. type: delimited block -
#: en/git-tag.txt:280
#, no-wrap, priority:240
msgid ""
"If you got the wrong tag, and want the new one, please delete\n"
"the old one and fetch the new one by doing:\n"
msgstr ""
"如果你得到了错误的标签，并希望得到新的标签，\n"
"请删除旧的标签，并通过以下方式获取新的标签：\n"

#. type: delimited block -
#: en/git-tag.txt:283
#, no-wrap, priority:240
msgid ""
"\tgit tag -d X\n"
"\tgit fetch origin tag X\n"
msgstr ""
"\tgit tag -d X\n"
"\tgit fetch origin tag X\n"

#. type: delimited block -
#: en/git-tag.txt:285
#, no-wrap, priority:240
msgid "to get my updated tag.\n"
msgstr "以获得我的最新标签。\n"

#. type: delimited block -
#: en/git-tag.txt:287
#, no-wrap, priority:240
msgid "You can test which tag you have by doing\n"
msgstr "你可以通过以下方式测试你的标签\n"

#. type: delimited block -
#: en/git-tag.txt:289
#, fuzzy, no-wrap, priority:240
msgid "\tgit rev-parse X\n"
msgstr "\tgit rev-parse X\n"

#. type: delimited block -
#: en/git-tag.txt:291
#, no-wrap, priority:240
msgid "which should return 0123456789abcdef.. if you have the new version.\n"
msgstr "如果你有新的版本，应该返回0123456789abcdef。\n"

#. type: delimited block -
#: en/git-tag.txt:293
#, fuzzy, no-wrap, priority:240
msgid "Sorry for the inconvenience.\n"
msgstr "对于由此带来的不便,我们深感抱歉。\n"

#. type: Plain text
#: en/git-tag.txt:298
#, priority:240
msgid "Does this seem a bit complicated? It *should* be. There is no way that it would be correct to just \"fix\" it automatically.  People need to know that their tags might have been changed."
msgstr "这看起来是不是有点复杂？它*应该*是这样的。自动 \"修复 \"它是不可能的。  人们需要知道他们的标签可能已经被改变。"

#. type: Title ~
#: en/git-tag.txt:301
#, no-wrap, priority:240
msgid "On Automatic following"
msgstr "在下列情况下自动进行"

#. type: Plain text
#: en/git-tag.txt:306
#, priority:240
msgid "If you are following somebody else's tree, you are most likely using remote-tracking branches (eg. `refs/remotes/origin/master`).  You usually want the tags from the other end."
msgstr "如果你在跟踪别人的树目录，你很可能在使用远程跟踪的分支（例如：`refs/remotes/origin/master`）。  你通常希望得到另一端的标签。"

#. type: Plain text
#: en/git-tag.txt:313
#, priority:240
msgid "On the other hand, if you are fetching because you would want a one-shot merge from somebody else, you typically do not want to get tags from there.  This happens more often for people near the toplevel but not limited to them.  Mere mortals when pulling from each other do not necessarily want to automatically get private anchor point tags from the other person."
msgstr "另一方面，如果你是因为想从别人那里获得一次性合并而取的，你通常不希望从那里获得标签。  这种情况更经常发生在接近高层的人身上，但不限于他们。  普通人从对方那里取东西时，不一定想从对方那里自动获得私人锚点标签。"

#. type: Plain text
#: en/git-tag.txt:318
#, priority:240
msgid "Often, \"please pull\" messages on the mailing list just provide two pieces of information: a repo URL and a branch name; this is designed to be easily cut&pasted at the end of a 'git fetch' command line:"
msgstr "通常，邮件列表上的 \"请拉\"信息只提供了两条信息：一个 仓库URL 和一个分支名称；这被设计成可以轻松地剪切和粘贴在 \"git fetch \"命令行的末尾："

#. type: delimited block -
#: en/git-tag.txt:321
#, no-wrap, priority:240
msgid "Linus, please pull from\n"
msgstr "Linus，请从这里拉取\n"

#. type: delimited block -
#: en/git-tag.txt:323
#, fuzzy, ignore-ellipsis, no-wrap, priority:240
msgid "\tgit://git..../proj.git master\n"
msgstr "\tgit://git..../proj.git master\n"

#. type: delimited block -
#: en/git-tag.txt:325
#, ignore-ellipsis, no-wrap, priority:240
msgid "to get the following updates...\n"
msgstr "以获得以下更新...\n"

#. type: Plain text
#: en/git-tag.txt:328
#, priority:240
msgid "becomes:"
msgstr "成为："

#. type: delimited block -
#: en/git-tag.txt:331
#, fuzzy, ignore-ellipsis, no-wrap, priority:240
msgid "$ git pull git://git..../proj.git master\n"
msgstr "$ git pull git://git..../proj.git master\n"

#. type: Plain text
#: en/git-tag.txt:335
#, priority:240
msgid "In such a case, you do not want to automatically follow the other person's tags."
msgstr "在这种情况下，你不希望自动跟随对方的标签。"

#. type: Plain text
#: en/git-tag.txt:343
#, priority:240
msgid "One important aspect of Git is its distributed nature, which largely means there is no inherent \"upstream\" or \"downstream\" in the system.  On the face of it, the above example might seem to indicate that the tag namespace is owned by the upper echelon of people and that tags only flow downwards, but that is not the case.  It only shows that the usage pattern determines who are interested in whose tags."
msgstr "Git 的一个重要方面是它的分布式性质，这很大程度上意味着系统中没有固有的 \"上游 \"或 \"下游\"。  从表面上看，上面的例子似乎表明标签命名空间是由上层人士拥有的，而标签只能向下流动，但事实并非如此。  它只是表明，使用模式决定了谁对谁的标签感兴趣。"

#. type: Plain text
#: en/git-tag.txt:355
#, priority:240
msgid "A one-shot pull is a sign that a commit history is now crossing the boundary between one circle of people (e.g. \"people who are primarily interested in the networking part of the kernel\") who may have their own set of tags (e.g. \"this is the third release candidate from the networking group to be proposed for general consumption with 2.6.21 release\") to another circle of people (e.g. \"people who integrate various subsystem improvements\").  The latter are usually not interested in the detailed tags used internally in the former group (that is what \"internal\" means).  That is why it is desirable not to follow tags automatically in this case."
msgstr "一次性拉取是一个标志，表明一个提交历史正在跨越一个圈子（例如 \"主要对内核的网络部分感兴趣的人\"）和另一个圈子（例如 \"整合各种子系统改进的人\"）之间的界限，后者可能有自己的一套标签（例如 \"这是网络组的第三个候选版本，将在2.6.21版本中被建议用于一般消费\"）。  后者通常对前一组内部使用的详细标签不感兴趣（这就是 \"内部 \"的意思）。  这就是为什么在这种情况下最好不要自动跟随标签。"

#. type: Plain text
#: en/git-tag.txt:361
#, priority:240
msgid "It may well be that among networking people, they may want to exchange the tags internal to their group, but in that workflow they are most likely tracking each other's progress by having remote-tracking branches.  Again, the heuristic to automatically follow such tags is a good thing."
msgstr "在这个网络知州，他们可能想交换他们小组内部的标签，但在那个工作流程中，他们很可能是通过有远程跟踪的分支来跟踪对方的进展。  同样，自动跟踪这种标签的启发式方法也是一个好东西。"

#. type: Title ~
#: en/git-tag.txt:364
#, fuzzy, no-wrap, priority:240
msgid "On Backdating Tags"
msgstr "关于回溯标签"

#. type: Plain text
#: en/git-tag.txt:371
#, priority:240
msgid "If you have imported some changes from another VCS and would like to add tags for major releases of your work, it is useful to be able to specify the date to embed inside of the tag object; such data in the tag object affects, for example, the ordering of tags in the gitweb interface."
msgstr "如果你从另一个VCS导入了一些修改，并想为你工作的主要版本添加标签，能够指定嵌入标签对象内部的日期是很有用的；标签对象中的这种数据会产生影响，例如，gitweb界面中标签的排序。"

#. type: Plain text
#: en/git-tag.txt:375
#, priority:240
msgid "To set the date used in future tag objects, set the environment variable GIT_COMMITTER_DATE (see the later discussion of possible values; the most common form is \"YYYY-MM-DD HH:MM\")."
msgstr "要设置未来标签对象中使用的日期，请设置环境变量GIT_COMMITTER_DATE（见后面关于可能数值的讨论；最常见的形式是 \"YYY-MM-DD HH:MM\"）。"

#. type: delimited block -
#: en/git-tag.txt:380
#, fuzzy, no-wrap, priority:240
msgid "$ GIT_COMMITTER_DATE=\"2006-10-02 10:31\" git tag -s v1.0.1\n"
msgstr "$ GIT_COMMITTER_DATE=\"2006-10-02 10:31\" git tag -s v1.0.1\n"

#. type: Labeled list
#: en/git-tag.txt:387
#, fuzzy, no-wrap, priority:240
#| msgid "`$GIT_DIR/COMMIT_EDITMSG`"
msgid "`$GIT_DIR/TAG_EDITMSG`"
msgstr "`$git_dir/commit_editmsg`。"

#. type: Plain text
#: en/git-tag.txt:393
#, fuzzy, priority:240
#| msgid "This file contains the commit message of a commit in progress.  If `git commit` exits due to an error before creating a commit, any commit message that has been provided by the user (e.g., in an editor session) will be available in this file, but will be overwritten by the next invocation of `git commit`."
msgid "This file contains the message of an in-progress annotated tag. If `git tag` exits due to an error before creating an annotated tag then the tag message that has been provided by the user in an editor session will be available in this file, but may be overwritten by the next invocation of `git tag`."
msgstr "该文件包含正在进行的提交的提交信息。  如果`git commit`在创建提交前因错误而退出，任何由用户提供的提交信息（例如在编辑器会话中）都会在此文件中出现，但会被下次调用`git commit`时覆盖。"

#. type: Plain text
#: en/git-tag.txt:403
#, priority:240
msgid "linkgit:git-check-ref-format[1].  linkgit:git-config[1]."
msgstr "linkgit:git-check-ref-format[1].  linkgit:git-config[1]."

#. type: Title =
#: en/git.txt:2
#, fuzzy, no-wrap, priority:100
msgid "git(1)"
msgstr "git(1)"

#. type: Plain text
#: en/git.txt:7
#, priority:100
msgid "git - the stupid content tracker"
msgstr "git - 傻瓜式内容追踪器"

#. type: Plain text
#: en/git.txt:17
#, no-wrap, priority:100
msgid ""
"'git' [-v | --version] [-h | --help] [-C <path>] [-c <name>=<value>]\n"
"    [--exec-path[=<path>]] [--html-path] [--man-path] [--info-path]\n"
"    [-p|--paginate|-P|--no-pager] [--no-replace-objects] [--bare]\n"
"    [--git-dir=<path>] [--work-tree=<path>] [--namespace=<name>]\n"
"    [--config-env=<name>=<envvar>] <command> [<args>]\n"
msgstr ""
"'git' [-v | --version] [-h | --help] [-C <path>] [-c <name>=<value>]\n"
"    [--exec-path[=<path>]] [--html-path] [--man-path] [--info-path]\n"
"    [-p|--paginate|-P|--no-pager] [--no-replace-objects] [--bare]\n"
"    [--git-dir=<path>] [--work-tree=<path>] [--namespace=<name>]\n"
"    [--config-env=<name>=<envvar>] <command> [<args>]\n"

#. type: Plain text
#: en/git.txt:23
#, priority:100
msgid "Git is a fast, scalable, distributed revision control system with an unusually rich command set that provides both high-level operations and full access to internals."
msgstr "Git是一个快速、可扩展的分布式版本控制系统，它拥有异常丰富的命令集，可以提供高级操作和对内部的完全访问。"

#. type: Plain text
#: en/git.txt:28
#, priority:100
msgid "See linkgit:gittutorial[7] to get started, then see linkgit:giteveryday[7] for a useful minimum set of commands.  The link:user-manual.html[Git User's Manual] has a more in-depth introduction."
msgstr "请参阅 linkgit:gittutorial[7] 来开始,然后参阅 linkgit:giteveryday[7] 获取有用的最小命令集。  link:user-manual.html[Git用户手册] 中拥有更为深入的介绍。"

#. type: Plain text
#: en/git.txt:33
#, priority:100
msgid "After you mastered the basic concepts, you can come back to this page to learn what commands Git offers.  You can learn more about individual Git commands with \"git help command\".  linkgit:gitcli[7] manual page gives you an overview of the command-line command syntax."
msgstr "在掌握了基本概念之后，你可以回到本页了解Git提供的命令。  你可以通过“git help”命令了解更多关于单个Git命令的信息。  linkgit:gitcli[7] 手册页面为您提供了命令行命令语法的概述。"

#. type: Plain text
#: en/git.txt:37
#, priority:100
msgid "A formatted and hyperlinked copy of the latest Git documentation can be viewed at https://git.github.io/htmldocs/git.html or https://git-scm.com/docs."
msgstr "最新Git文档的格式化和超链接副本可以在 https://git.github.io/htmldocs/git.html 或 https://git-scm.com/docs上查看。"

#. type: Plain text
#: en/git.txt:44
#, priority:100
msgid "Prints the Git suite version that the 'git' program came from."
msgstr "打印‘git’程序的Git套件版本。"

#. type: Plain text
#: en/git.txt:48
#, ignore-ellipsis, priority:100
msgid "This option is internally converted to `git version ...` and accepts the same options as the linkgit:git-version[1] command. If `--help` is also given, it takes precedence over `--version`."
msgstr "此选项在内部转换为 `git version ...` 并接受与linkgit:git-version[1] 命令相同的选项。如果`--version`后接`--help` 选项，则会优先展示`--version`选项的帮助信息。"

#. type: Plain text
#: en/git.txt:55
#, priority:100
msgid "Prints the synopsis and a list of the most commonly used commands. If the option `--all` or `-a` is given then all available commands are printed. If a Git command is named this option will bring up the manual page for that command."
msgstr "打印概要和最常用的命令列表。如果给出选项`--all`或`--a`，则打印所有可用的命令。如果给出命令，该选项将调出该命令的手册页面。"

#. type: Plain text
#: en/git.txt:60
#, ignore-ellipsis, priority:100
msgid "Other options are available to control how the manual page is displayed. See linkgit:git-help[1] for more information, because `git --help ...` is converted internally into `git help ...`."
msgstr "还有其他选项可以控制手册页面的显示方式。参阅linkgit:git-help[1]获取更多信息，因为 `git --help ...` 会在内部转换为 `git help ...`。"

#. type: Labeled list
#: en/git.txt:61
#, fuzzy, no-wrap, priority:100
msgid "-C <path>"
msgstr "-C <path（文件路径）>"

#. type: Plain text
#: en/git.txt:67
#, priority:100
msgid "Run as if git was started in '<path>' instead of the current working directory.  When multiple `-C` options are given, each subsequent non-absolute `-C <path>` is interpreted relative to the preceding `-C <path>`.  If '<path>' is present but empty, e.g. `-C \"\"`, then the current working directory is left unchanged."
msgstr "运行时就像git在'<path>'而不是在当前工作目录下启动一样。  当给出多个`-C`选项时，每个后续的非绝对的`-C <path>`都是相对于前一个`-C <path>`解释的。  如果'<path>'存在但为空，例如`-C \"\"`，那么就在当前工作目录启动。"

#. type: Plain text
#: en/git.txt:72
#, priority:100
msgid "This option affects options that expect path name like `--git-dir` and `--work-tree` in that their interpretations of the path names would be made relative to the working directory caused by the `-C` option. For example the following invocations are equivalent:"
msgstr "这个选项会影响到像`--git-dir`和`--work-tree`这样的需要路径名的选项，因为它们会用`-C`选项设置的工作目录进行相对路径的解释。例如，下面的调用是等价的："

#. type: Plain text
#: en/git.txt:75
#, no-wrap, priority:100
msgid ""
"    git --git-dir=a.git --work-tree=b -C c status\n"
"    git --git-dir=c/a.git --work-tree=c/b status\n"
msgstr ""
"    git --git-dir=a.git --work-tree=b -C c status\n"
"    git --git-dir=c/a.git --work-tree=c/b status\n"

#. type: Labeled list
#: en/git.txt:76
#, fuzzy, no-wrap, priority:100
msgid "-c <name>=<value>"
msgstr "-c <name>=<value>"

#. type: Plain text
#: en/git.txt:81
#, priority:100
msgid "Pass a configuration parameter to the command. The value given will override values from configuration files.  The <name> is expected in the same format as listed by 'git config' (subkeys separated by dots)."
msgstr "向命令传递一个配置参数。给出的值将覆盖配置文件的值。  <name>的格式应与'git config'列出的格式相同（子键由`.`分隔）。"

#. type: Plain text
#: en/git.txt:87
#, fuzzy, ignore-ellipsis, priority:100
msgid "Note that omitting the `=` in `git -c foo.bar ...` is allowed and sets `foo.bar` to the boolean true value (just like `[foo]bar` would in a config file). Including the equals but with an empty value (like `git -c foo.bar= ...`) sets `foo.bar` to the empty string which `git config --type=bool` will convert to `false`."
msgstr "注意在`git -c foo.bar ...`中省略`=`是允许的，并将`foo.bar`设置为true（就像配置文件中的`[foo]bar`一样）。包括等号但有一个空值（如`git -c foo.bar= ...`）会将`foo.bar`设置为空字符串，如果`git config --type=bool`空值会转换为`false`。"

#. type: Labeled list
#: en/git.txt:88
#, fuzzy, no-wrap, priority:100
msgid "--config-env=<name>=<envvar>"
msgstr "--config-env=<name>=<envvar（环境变量）>"

#. type: Plain text
#: en/git.txt:97
#, priority:100
msgid "Like `-c <name>=<value>`, give configuration variable '<name>' a value, where <envvar> is the name of an environment variable from which to retrieve the value. Unlike `-c` there is no shortcut for directly setting the value to an empty string, instead the environment variable itself must be set to the empty string.  It is an error if the `<envvar>` does not exist in the environment. `<envvar>` may not contain an equals sign to avoid ambiguity with `<name>` containing one."
msgstr "像`-c <name>=<value>`一样，给配置变量'<name>'一个值，其中<envvar>是一个环境变量的名字，可以从中获取该环境变量的值。与`-c`不同的是，没有直接将值设置为空字符串的快捷方式，除非环境变量本身就设置为空字符串。  如果`<envvar>`在环境变量中不存在，则会报错。`<envvar>`可能不包含等号，以避免与包含等号的`<name>`产生歧义。"

#. type: Plain text
#: en/git.txt:104
#, priority:100
msgid "This is useful for cases where you want to pass transitory configuration options to git, but are doing so on OS's where other processes might be able to read your cmdline (e.g. `/proc/self/cmdline`), but not your environ (e.g. `/proc/self/environ`). That behavior is the default on Linux, but may not be on your system."
msgstr "这对于你想向git传递临时配置选项，在其他进程可能能够读取你的cmdline（如`/proc/self/cmdline`），但不能读取你的environ（如`/proc/self/environ`）的操作系统上这样做很有用。这种行为在Linux上是默认的，但在你的系统上可能不是这样。"

#. type: Plain text
#: en/git.txt:109
#, priority:100
msgid "Note that this might add security for variables such as `http.extraHeader` where the sensitive information is part of the value, but not e.g. `url.<base>.insteadOf` where the sensitive information can be part of the key."
msgstr "请注意，这可能会增加变量的安全性，例如`http.extraHeader`，因为他的敏感信息包含在值中，但并不会增加例如`url.<base>.insteadOf`这种变量的安全性，因为其敏感信息可能会包含在部分键中。"

#. type: Labeled list
#: en/git.txt:110
#, fuzzy, no-wrap, priority:100
msgid "--exec-path[=<path>]"
msgstr "--exec-path[=<path>]"

#. type: Plain text
#: en/git.txt:115
#, priority:100
msgid "Path to wherever your core Git programs are installed.  This can also be controlled by setting the GIT_EXEC_PATH environment variable. If no path is given, 'git' will print the current setting and then exit."
msgstr "安装Git核心程序的路径。  这也可以通过设置 GIT_EXEC_PATH 环境变量来控制。如果没有给出路径，'git'会打印当前的设置，然后退出。"

#. type: Labeled list
#: en/git.txt:116
#, ignore-same, no-wrap, priority:100
msgid "--html-path"
msgstr "--html-path"

#. type: Plain text
#: en/git.txt:119
#, priority:100
msgid "Print the path, without trailing slash, where Git's HTML documentation is installed and exit."
msgstr "打印Git的HTML文档的安装路径（尾部不带斜杠）然后退出。"

#. type: Labeled list
#: en/git.txt:120
#, ignore-same, no-wrap, priority:100
msgid "--man-path"
msgstr "--man-path"

#. type: Plain text
#: en/git.txt:123
#, priority:100
msgid "Print the manpath (see `man(1)`) for the man pages for this version of Git and exit."
msgstr "打印该版本Git man page的manpath（参阅`man(1)`），然后退出。"

#. type: Labeled list
#: en/git.txt:124
#, ignore-same, no-wrap, priority:100
msgid "--info-path"
msgstr "--info-path"

#. type: Plain text
#: en/git.txt:127
#, priority:100
msgid "Print the path where the Info files documenting this version of Git are installed and exit."
msgstr "打印记录该版本Git信息文件的安装路径并退出。"

#. type: Labeled list
#: en/git.txt:129
#, ignore-same, no-wrap, priority:100
msgid "--paginate"
msgstr "--paginate"

#. type: Plain text
#: en/git.txt:134
#, priority:100
msgid "Pipe all output into 'less' (or if set, $PAGER) if standard output is a terminal.  This overrides the `pager.<cmd>` configuration options (see the \"Configuration Mechanism\" section below)."
msgstr "如果标准输出是一个终端，则将所有的输出输出到'less（git默认的分页器）'（如果设置，则为$PAGER）中。  这会覆盖`pager.<cmd>`配置选项（参阅下面的 \"配置机制 \"部分）。"

#. type: Labeled list
#: en/git.txt:136
#, ignore-same, no-wrap, priority:100
msgid "--no-pager"
msgstr "--no-pager"

#. type: Plain text
#: en/git.txt:138
#, priority:100
msgid "Do not pipe Git output into a pager."
msgstr "不使用分页器进行Git的输出。"

#. type: Labeled list
#: en/git.txt:139
#, no-wrap, priority:100
msgid "--git-dir=<path>"
msgstr "--git-dir=<path（文件路径）>"

#. type: Plain text
#: en/git.txt:143
#, priority:100
msgid "Set the path to the repository (\".git\" directory). This can also be controlled by setting the `GIT_DIR` environment variable. It can be an absolute path or relative path to current working directory."
msgstr "设置存储库的路径（\".git \"目录）。这也可以通过设置`GIT_DIR`环境变量来控制。<path>可以是绝对路径或是当前工作目录的相对路径。"

#. type: Plain text
#: en/git.txt:154
#, priority:100
msgid "Specifying the location of the \".git\" directory using this option (or `GIT_DIR` environment variable) turns off the repository discovery that tries to find a directory with \".git\" subdirectory (which is how the repository and the top-level of the working tree are discovered), and tells Git that you are at the top level of the working tree.  If you are not at the top-level directory of the working tree, you should tell Git where the top-level of the working tree is, with the `--work-tree=<path>` option (or `GIT_WORK_TREE` environment variable)"
msgstr "使用该选项（或`GIT_DIR`环境变量）指定\".git \"目录的位置，这会关闭对带有\".git \"子目录仓库的扫描（这是找到仓库和顶级工作区的方式），并告诉 Git 当前在顶级工作区。  如果当前并不在工作区的顶级目录，你应该用`--work-tree=<path>`选项（或`GIT_WORK_TREE`环境变量）告诉Git顶级工作区在哪里。"

#. type: Plain text
#: en/git.txt:157
#, priority:100
msgid "If you just want to run git as if it was started in `<path>` then use `git -C <path>`."
msgstr "如果你只是想在`<path>`中运行Git，可以使用`git -C <path>`。"

#. type: Labeled list
#: en/git.txt:158
#, no-wrap, priority:100
msgid "--work-tree=<path>"
msgstr "--work-tree=<path（文件路径）>"

#. type: Plain text
#: en/git.txt:165
#, priority:100
msgid "Set the path to the working tree. It can be an absolute path or a path relative to the current working directory.  This can also be controlled by setting the GIT_WORK_TREE environment variable and the core.worktree configuration variable (see core.worktree in linkgit:git-config[1] for a more detailed discussion)."
msgstr "设置工作树的路径。<path>可以是一个绝对路径或与当前工作目录相对的路径。  这也可以通过设置 GIT_WORK_TREE 环境变量和 core.worktree 配置变量来控制（参阅linkgit:git-config[1] 中的 core.worktree获取更为详细的论述）。"

#. type: Labeled list
#: en/git.txt:166
#, no-wrap, priority:100
msgid "--namespace=<path>"
msgstr "--namespace=<path>"

#. type: Plain text
#: en/git.txt:170
#, priority:100
msgid "Set the Git namespace.  See linkgit:gitnamespaces[7] for more details.  Equivalent to setting the `GIT_NAMESPACE` environment variable."
msgstr "设置 Git 命名空间。  参阅 linkgit:gitnamespaces[7] 以了解更多细节。  这相当于设置 `GIT_NAMESPACE` 环境变量。"

#. type: Plain text
#: en/git.txt:175
#, priority:100
msgid "Treat the repository as a bare repository.  If GIT_DIR environment is not set, it is set to the current working directory."
msgstr "将该仓库视为裸仓库。  如果没有设置GIT_DIR环境变量，它将在当前工作目录生成仓库。"

#. type: Labeled list
#: en/git.txt:176
#, ignore-same, no-wrap, priority:100
msgid "--no-replace-objects"
msgstr "--no-replace-objects"

#. type: Plain text
#: en/git.txt:179
#, priority:100
msgid "Do not use replacement refs to replace Git objects. See linkgit:git-replace[1] for more information."
msgstr "不使用候补引用来替换 Git 对象。更多信息参阅 linkgit:git-replace[1]。"

#. type: Labeled list
#: en/git.txt:180
#, ignore-same, no-wrap, priority:100
msgid "--literal-pathspecs"
msgstr "--literal-pathspecs"

#. type: Plain text
#: en/git.txt:184
#, priority:100
msgid "Treat pathspecs literally (i.e. no globbing, no pathspec magic).  This is equivalent to setting the `GIT_LITERAL_PATHSPECS` environment variable to `1`."
msgstr "按字面意思处理路径规格（即不使用通配符，不使用路径规范功能）。  这相当于将`GIT_LITERAL_PATHSPECS`环境变量设置为`1`。"

#. type: Labeled list
#: en/git.txt:185
#, ignore-same, no-wrap, priority:100
msgid "--glob-pathspecs"
msgstr "--glob-pathspecs"

#. type: Plain text
#: en/git.txt:190
#, priority:100
msgid "Add \"glob\" magic to all pathspec. This is equivalent to setting the `GIT_GLOB_PATHSPECS` environment variable to `1`. Disabling globbing on individual pathspecs can be done using pathspec magic \":(literal)\""
msgstr "在所有的路径规范中添加 \"glob\"功能。这相当于将`GIT_GLOB_PATHSPECS`环境变量设置为`1`。在单个路径规格上禁用通配符可以用路径规范功能\":(literal) \"来完成。"

#. type: Labeled list
#: en/git.txt:191
#, ignore-same, no-wrap, priority:100
msgid "--noglob-pathspecs"
msgstr "--noglob-pathspecs"

#. type: Plain text
#: en/git.txt:196
#, priority:100
msgid "Add \"literal\" magic to all pathspec. This is equivalent to setting the `GIT_NOGLOB_PATHSPECS` environment variable to `1`. Enabling globbing on individual pathspecs can be done using pathspec magic \":(glob)\""
msgstr "在所有路径规范中添加 \"literal\"功能。这相当于将`GIT_NOGLOB_PATHSPECS`环境变量设为`1`。在单个路径规范上启用通配符功能，可以使用路径规范功能\":(glob) \"来完成。"

#. type: Labeled list
#: en/git.txt:197
#, ignore-same, no-wrap, priority:100
msgid "--icase-pathspecs"
msgstr "--icase-pathspecs"

#. type: Plain text
#: en/git.txt:200
#, priority:100
msgid "Add \"icase\" magic to all pathspec. This is equivalent to setting the `GIT_ICASE_PATHSPECS` environment variable to `1`."
msgstr "在所有的路径规范中添加 \"icase \"功能。这相当于将`GIT_ICASE_PATHSPECS`环境变量设置为`1`。"

#. type: Labeled list
#: en/git.txt:201
#, ignore-same, no-wrap, priority:100
msgid "--no-optional-locks"
msgstr "--no-optional-locks"

#. type: Plain text
#: en/git.txt:204
#, priority:100
msgid "Do not perform optional operations that require locks. This is equivalent to setting the `GIT_OPTIONAL_LOCKS` to `0`."
msgstr "禁止执行需要锁的可选操作。这相当于将`GIT_OPTIONAL_LOCKS`设置为`0'。"

#. type: Labeled list
#: en/git.txt:205
#, ignore-ellipsis, no-wrap, priority:100
msgid "--list-cmds=group[,group...]"
msgstr "--list-cmds=group[,group...]"

#. type: Plain text
#: en/git.txt:214
#, priority:100
msgid "List commands by group. This is an internal/experimental option and may change or be removed in the future. Supported groups are: builtins, parseopt (builtin commands that use parse-options), main (all commands in libexec directory), others (all other commands in `$PATH` that have git- prefix), list-<category> (see categories in command-list.txt), nohelpers (exclude helper commands), alias and config (retrieve command list from config variable completion.commands)"
msgstr "按组列出命令。这是一个内部/实验性的选项，将来可能会改变或删除。支持的组有：buildins、parseopt（使用parse-options的内置命令）、main（libexec目录下的所有命令）、others（`$PATH`中其他带有git-前缀的命令）、list-<category>（参阅command-list.txt中的目录【原文是这么说的，但是下面那个Git命令章节已经列出了所有命令列表】）、nohelpers（排除辅助命令）、alias和config（在配置completion.commands中检索命令列表）"

#. type: Labeled list
#: en/git.txt:215
#, fuzzy, no-wrap, priority:100
#| msgid "--source=<tree>"
msgid "--attr-source=<tree-ish>"
msgstr "--source=<tree>（来源）。"

#. type: Plain text
#: en/git.txt:219
#, fuzzy, priority:100
#| msgid "Set the Git namespace.  See linkgit:gitnamespaces[7] for more details.  Equivalent to setting the `GIT_NAMESPACE` environment variable."
msgid "Read gitattributes from <tree-ish> instead of the worktree. See linkgit:gitattributes[5]. This is equivalent to setting the `GIT_ATTR_SOURCE` environment variable."
msgstr "设置 Git 命名空间。  参阅 linkgit:gitnamespaces[7] 以了解更多细节。  这相当于设置 `GIT_NAMESPACE` 环境变量。"

#. type: Title -
#: en/git.txt:221
#, no-wrap, priority:100
msgid "GIT COMMANDS"
msgstr "Git命令"

#. type: Plain text
#: en/git.txt:225
#, priority:100
msgid "We divide Git into high level (\"porcelain\") commands and low level (\"plumbing\") commands."
msgstr "我们把Git分为上层封装命令（“瓷件”）和底层核心命令（“管件”）。"

#. type: Title -
#: en/git.txt:227
#, no-wrap, priority:100
msgid "High-level commands (porcelain)"
msgstr "上层封装命令（瓷件）"

#. type: Plain text
#: en/git.txt:231
#, priority:100
msgid "We separate the porcelain commands into the main commands and some ancillary user utilities."
msgstr "我们将瓷件命令分为主要命令和一些辅助性的用户工具。"

#. type: Title ~
#: en/git.txt:233
#, no-wrap, priority:100
msgid "Main porcelain commands"
msgstr "主要瓷件命令"

#. type: Title ~
#: en/git.txt:238
#, no-wrap, priority:100
msgid "Ancillary Commands"
msgstr "辅助命令"

#. type: Plain text
#: en/git.txt:240
#, priority:100
msgid "Manipulators:"
msgstr "控制相关："

#. type: Plain text
#: en/git.txt:244
#, priority:100
msgid "Interrogators:"
msgstr "审阅相关："

#. type: Title ~
#: en/git.txt:249
#, no-wrap, priority:100
msgid "Interacting with Others"
msgstr "与其他应用交互"

#. type: Plain text
#: en/git.txt:253
#, priority:100
msgid "These commands are to interact with foreign SCM and with other people via patch over e-mail."
msgstr "这些命令是为了与外部SCM（源代码管理工具）以及通过电子邮件与其他人进行交互。"

#. type: Title ~
#: en/git.txt:257
#, no-wrap, priority:100
msgid "Reset, restore and revert"
msgstr "重置、恢复和还原"

#. type: Plain text
#: en/git.txt:260
#, priority:100
msgid "There are three commands with similar names: `git reset`, `git restore` and `git revert`."
msgstr "包括了三个名称相似的命令：`git reset`、`git restore`和`git revert`。"

#. type: Plain text
#: en/git.txt:263
#, priority:100
msgid "linkgit:git-revert[1] is about making a new commit that reverts the changes made by other commits."
msgstr "linkgit:git-revert[1] 是关于进行新的提交，以还原其他提交所做的更改。"

#. type: Plain text
#: en/git.txt:268
#, priority:100
msgid "linkgit:git-restore[1] is about restoring files in the working tree from either the index or another commit. This command does not update your branch. The command can also be used to restore files in the index from another commit."
msgstr "linkgit:git-restore[1] 是有关从索引或其他提交中恢复工作区中文件的命令。这个命令不会更新你的分支。该命令也可以用来从另一个提交中恢复索引中的文件。"

#. type: Plain text
#: en/git.txt:272
#, priority:100
msgid "linkgit:git-reset[1] is about updating your branch, moving the tip in order to add or remove commits from the branch. This operation changes the commit history."
msgstr "linkgit:git-reset[1] 是有关更新分支、移动提示的命令，以便从分支中添加或删除提交。这个操作会修改提交历史。"

#. type: Plain text
#: en/git.txt:275
#, priority:100
msgid "`git reset` can also be used to restore the index, overlapping with `git restore`."
msgstr "`git reset`也可以用来恢复索引，这个功能`git restore`的功能有些重合。"

#. type: Title -
#: en/git.txt:278
#, no-wrap, priority:100
msgid "Low-level commands (plumbing)"
msgstr "底层核心命令（管件）"

#. type: Plain text
#: en/git.txt:285
#, priority:100
msgid "Although Git includes its own porcelain layer, its low-level commands are sufficient to support development of alternative porcelains.  Developers of such porcelains might start by reading about linkgit:git-update-index[1] and linkgit:git-read-tree[1]."
msgstr "尽管 Git 包含了它自己的瓷件层，但它的底层核心命令足以支持替代瓷件的开发。  此类瓷件开发者可以从阅读 linkgit:git-update-index[1] 和 linkgit:git-read-tree[1] 开始。"

#. type: Plain text
#: en/git.txt:292
#, priority:100
msgid "The interface (input, output, set of options and the semantics)  to these low-level commands are meant to be a lot more stable than Porcelain level commands, because these commands are primarily for scripted use.  The interface to Porcelain commands on the other hand are subject to change in order to improve the end user experience."
msgstr "这些底层命令的界面（输入、输出、选项集和语义）要比上层封装命令稳定得多，因为这些命令主要是用于脚本的使用。  另一方面，为了改善终端用户的体验，上层封装命令接口是可以改变的。"

#. type: Plain text
#: en/git.txt:298
#, priority:100
msgid "The following description divides the low-level commands into commands that manipulate objects (in the repository, index, and working tree), commands that interrogate and compare objects, and commands that move objects and references between repositories."
msgstr "下面的描述将底层核心命令分为操作对象（在存储库、索引和工作树中）的命令、审阅和比较对象的命令，以及在存储库之间移动对象和引用的命令。"

#. type: Title ~
#: en/git.txt:301
#, no-wrap, priority:100
msgid "Manipulation commands"
msgstr "控制命令"

#. type: Title ~
#: en/git.txt:307
#, no-wrap, priority:100
msgid "Interrogation commands"
msgstr "审阅命令"

#. type: Plain text
#: en/git.txt:313
#, priority:100
msgid "In general, the interrogate commands do not touch the files in the working tree."
msgstr "一般来说，审阅命令不接触工作区中的文件。"

#. type: Title ~
#: en/git.txt:316
#, no-wrap, priority:100
msgid "Syncing repositories"
msgstr "同步仓库"

#. type: Plain text
#: en/git.txt:322
#, priority:100
msgid "The following are helper commands used by the above; end users typically do not use them directly."
msgstr "以下是上面使用的辅助命令，终端用户一般不会直接使用这些命令。"

#. type: Title ~
#: en/git.txt:327
#, no-wrap, priority:100
msgid "Internal helper commands"
msgstr "内部辅助命令"

#. type: Plain text
#: en/git.txt:331
#, priority:100
msgid "These are internal helper commands used by other commands; end users typically do not use them directly."
msgstr "这些是其他命令使用的内部辅助命令；终端用户一般不会直接使用这些命令。"

#. type: Title -
#: en/git.txt:335
#, no-wrap, priority:100
msgid "Guides"
msgstr "指南"

#. type: Plain text
#: en/git.txt:338
#, priority:100
msgid "The following documentation pages are guides about Git concepts."
msgstr "以下文档页是关于Git概念的指南。"

#. type: Title -
#: en/git.txt:342
#, no-wrap, priority:100
msgid "Repository, command and file interfaces"
msgstr "仓库、命令和文件接口"

#. type: Plain text
#: en/git.txt:347
#, priority:100
msgid "This documentation discusses repository and command interfaces which users are expected to interact with directly. See `--user-formats` in linkgit:git-help[1] for more details on the criteria."
msgstr "本文档讨论了用户希望直接与之交互的仓库和命令接口。有关标准的更多细节，请参阅linkgit:git-help[1]中的`--user-formats`。"

#. type: Title -
#: en/git.txt:351
#, no-wrap, priority:100
msgid "File formats, protocols and other developer interfaces"
msgstr "文件格式、协议和其他开发者接口"

#. type: Plain text
#: en/git.txt:356
#, priority:100
msgid "This documentation discusses file formats, over-the-wire protocols and other git developer interfaces. See `--developer-interfaces` in linkgit:git-help[1]."
msgstr "本文档讨论了文件格式、线上协议和其他git开发者接口。参阅 linkgit:git-help[1] 中的`--developer-interfaces`。"

#. type: Title -
#: en/git.txt:360
#, no-wrap, priority:100
msgid "Configuration Mechanism"
msgstr "配置机制"

#. type: Plain text
#: en/git.txt:365
#, priority:100
msgid "Git uses a simple text format to store customizations that are per repository and are per user.  Such a configuration file may look like this:"
msgstr "Git 使用一种简单的文本格式来存储每个仓库和每个用户的定制内容。  这样的配置文件可能是像这样："

#. type: delimited block -
#: en/git.txt:370
#, no-wrap, priority:100
msgid ""
"#\n"
"# A '#' or ';' character indicates a comment.\n"
"#\n"
msgstr ""
"#\n"
"# 符号 '#' 或是 ';' 表示本行是注释信息\n"
"#\n"

#. type: delimited block -
#: en/git.txt:380
#, no-wrap, priority:100
msgid ""
"; user identity\n"
"[user]\n"
"\tname = \"Junio C Hamano\"\n"
"\temail = \"gitster@pobox.com\"\n"
msgstr ""
"; 用户身份信息\n"
"[user]\n"
"\tname = \"Junio C Hamano\"\n"
"\temail = \"gitster@pobox.com\"\n"

#. type: Plain text
#: en/git.txt:386
#, priority:100
msgid "Various commands read from the configuration file and adjust their operation accordingly.  See linkgit:git-config[1] for a list and more details about the configuration mechanism."
msgstr "各种命令从配置文件中读取并相应地调整其操作。有关配置机制的列表和更多细节，请参阅 linkgit:git-config[1]。"

#. type: Title -
#: en/git.txt:389
#, no-wrap, priority:100
msgid "Identifier Terminology"
msgstr "标识符术语"

#. type: Plain text
#: en/git.txt:392
#, priority:100
msgid "Indicates the object name for any type of object."
msgstr "表示任何类型的对象的名称。"

#. type: Labeled list
#: en/git.txt:393 en/git-unpack-file.txt:23
#, no-wrap, priority:100
msgid "<blob>"
msgstr "<blob>"

#. type: Plain text
#: en/git.txt:395
#, priority:100
msgid "Indicates a blob object name."
msgstr "表示一个数据对象的名称。"

#. type: Plain text
#: en/git.txt:398
#, priority:100
msgid "Indicates a tree object name."
msgstr "表示一个树对象名称。"

#. type: Plain text
#: en/git.txt:401
#, priority:100
msgid "Indicates a commit object name."
msgstr "表示一个提交对象名称。"

#. type: Plain text
#: en/git.txt:407
#, priority:100
msgid "Indicates a tree, commit or tag object name.  A command that takes a <tree-ish> argument ultimately wants to operate on a <tree> object but automatically dereferences <commit> and <tag> objects that point at a <tree>."
msgstr "表示一个树、提交或标签对象的名称。  一个需要<tree-ish>参数的命令最终会对<tree>对象进行操作，但会自动解除对指向<tree>对象的<commit>和<tag>对象的引用。"

#. type: Labeled list
#: en/git.txt:408
#, no-wrap, priority:100
msgid "<commit-ish>"
msgstr "<commit-ish>"

#. type: Plain text
#: en/git.txt:413
#, priority:100
msgid "Indicates a commit or tag object name.  A command that takes a <commit-ish> argument ultimately wants to operate on a <commit> object but automatically dereferences <tag> objects that point at a <commit>."
msgstr "表示一个提交或标记对象的名称。  一个需要<commit-ish>参数的命令最终要对<commit>对象进行操作，但会自动解除对指向<commit>的<tag>对象的引用。"

#. type: Plain text
#: en/git.txt:417
#, priority:100
msgid "Indicates that an object type is required.  Currently one of: `blob`, `tree`, `commit`, or `tag`."
msgstr "表示需要一个对象类型。  目前是其中之一：`blob`、`tree`、`commit`或`tag`。"

#. type: Plain text
#: en/git.txt:421
#, priority:100
msgid "Indicates a filename - almost always relative to the root of the tree structure `GIT_INDEX_FILE` describes."
msgstr "表示一个文件名——几乎总是相对于`GIT_INDEX_FILE`描述的树状结构的根部文件。"

#. type: Title -
#: en/git.txt:423
#, no-wrap, priority:100
msgid "Symbolic Identifiers"
msgstr "符号标识符"

#. type: Plain text
#: en/git.txt:426
#, priority:100
msgid "Any Git command accepting any <object> can also use the following symbolic notation:"
msgstr "任何接受任意<object>的Git命令也可以使用下面的符号表示法："

#. type: Plain text
#: en/git.txt:429
#, priority:100
msgid "indicates the head of the current branch."
msgstr "表示当前分支。"

#. type: Labeled list
#: en/git.txt:430
#, no-wrap, priority:100
msgid "<tag>"
msgstr "<tag>"

#. type: Plain text
#: en/git.txt:433
#, priority:100
msgid "a valid tag 'name' (i.e. a `refs/tags/<tag>` reference)."
msgstr "一个有效的标签 \"名称\"（即一个`refs/tags/<tag>`引用）。"

#. type: Plain text
#: en/git.txt:437
#, priority:100
msgid "a valid head 'name' (i.e. a `refs/heads/<head>` reference)."
msgstr "一个有效的分支 \"名称\"（即一个`refs/heads/<head>`引用）。"

#. type: Plain text
#: en/git.txt:440
#, priority:100
msgid "For a more complete list of ways to spell object names, see \"SPECIFYING REVISIONS\" section in linkgit:gitrevisions[7]."
msgstr "更完整的对象名称列表，请参阅 linkgit:gitrevisions[7] 中的 \"校正说明 \"部分。"

#. type: Title -
#: en/git.txt:443
#, no-wrap, priority:100
msgid "File/Directory Structure"
msgstr "文件/目录结构"

#. type: Plain text
#: en/git.txt:446
#, priority:100
msgid "Please see the linkgit:gitrepository-layout[5] document."
msgstr "请参阅 linkgit:gitrepository-layout[5] 文档。"

#. type: Plain text
#: en/git.txt:448
#, priority:100
msgid "Read linkgit:githooks[5] for more details about each hook."
msgstr "阅读 linkgit:githooks[5] 了解关于每个钩子的更多细节。"

#. type: Plain text
#: en/git.txt:451
#, priority:100
msgid "Higher level SCMs may provide and manage additional information in the `$GIT_DIR`."
msgstr "更高级别的源代码管理工具(SCM)可以在\"$GIT_DIR \"中提供和管理额外的信息。"

#. type: Title -
#: en/git.txt:454
#, no-wrap, priority:100
msgid "Terminology"
msgstr "术语"

#. type: Plain text
#: en/git.txt:456
#, priority:100
msgid "Please see linkgit:gitglossary[7]."
msgstr "请参阅linkgit:gitglossary[7]。"

#. type: Plain text
#: en/git.txt:464
#, priority:100
msgid "Various Git commands pay attention to environment variables and change their behavior.  The environment variables marked as \"Boolean\" take their values the same way as Boolean valued configuration variables, e.g.  \"true\", \"yes\", \"on\" and positive numbers are taken as \"yes\"."
msgstr "各种 Git 命令都会关注环境变量并改变它们的行为。  以\"布尔 值\"为标记的环境变量，其取值方式与布尔值配置变量相同，例如，\"true\"、\"yes\"、\"on \"和正数被视为 \"yes\"。"

#. type: Plain text
#: en/git.txt:466
#, priority:100
msgid "Here are the variables:"
msgstr "常规变量："

#. type: Title ~
#: en/git.txt:468
#, no-wrap, priority:100
msgid "The Git Repository"
msgstr "Git仓库"

#. type: Plain text
#: en/git.txt:472
#, priority:100
msgid "These environment variables apply to 'all' core Git commands. Nb: it is worth noting that they may be used/overridden by SCMS sitting above Git so take care if using a foreign front-end."
msgstr "这些环境变量适用于 \"所有 \"核心的 Git 命令。注：值得注意的是，它们可能被位于Git之上的SCMS使用/覆盖，所以如果之前使用过其他的源代码管理工具。"

#. type: Labeled list
#: en/git.txt:473
#, ignore-same, no-wrap, priority:100
msgid "`GIT_INDEX_FILE`"
msgstr "`GIT_INDEX_FILE`"

#. type: Plain text
#: en/git.txt:477
#, priority:100
msgid "This environment variable specifies an alternate index file. If not specified, the default of `$GIT_DIR/index` is used."
msgstr "这个环境变量指定了一个备用的索引文件。如果没有指定，则默认使用`$GIT_DIR/index`。"

#. type: Labeled list
#: en/git.txt:478
#, ignore-same, no-wrap, priority:100
msgid "`GIT_INDEX_VERSION`"
msgstr "`GIT_INDEX_VERSION`"

#. type: Plain text
#: en/git.txt:483
#, priority:100
msgid "This environment variable specifies what index version is used when writing the index file out.  It won't affect existing index files.  By default index file version 2 or 3 is used. See linkgit:git-update-index[1] for more information."
msgstr "这个环境变量指定在写出索引文件时使用什么版本。  它不会影响现有的索引文件。  默认情况下，索引文件的版本为 2 或 3。参见 linkgit:git-update-index[1] 获取更多信息。"

#. type: Labeled list
#: en/git.txt:484
#, ignore-same, no-wrap, priority:100
msgid "`GIT_OBJECT_DIRECTORY`"
msgstr "`GIT_OBJECT_DIRECTORY`"

#. type: Plain text
#: en/git.txt:489
#, priority:100
msgid "If the object storage directory is specified via this environment variable then the sha1 directories are created underneath - otherwise the default `$GIT_DIR/objects` directory is used."
msgstr "如果对象存储目录是通过这个环境变量指定的，那么sha1目录将在该目录下创建 - 否则将使用默认的`$GIT_DIR/objects`目录。"

#. type: Labeled list
#: en/git.txt:490
#, ignore-same, no-wrap, priority:100
msgid "`GIT_ALTERNATE_OBJECT_DIRECTORIES`"
msgstr "`GIT_ALTERNATE_OBJECT_DIRECTORIES`"

#. type: Plain text
#: en/git.txt:496
#, priority:100
msgid "Due to the immutable nature of Git objects, old objects can be archived into shared, read-only directories. This variable specifies a \":\" separated (on Windows \";\" separated) list of Git object directories which can be used to search for Git objects. New objects will not be written to these directories."
msgstr "由于Git对象的不可改变性，旧的对象可以被归档到共享的只读目录中。这个变量指定了一个由\": \"分隔（在Windows下为\"; \"分隔）的Git对象目录列表，可以用来搜索Git对象。新的对象将不会写入这些目录中。"

#. type: Plain text
#: en/git.txt:502
#, priority:100
msgid "Entries that begin with `\"` (double-quote) will be interpreted as C-style quoted paths, removing leading and trailing double-quotes and respecting backslash escapes. E.g., the value `\"path-with-\\\"-and-:-in-it\":vanilla-path` has two paths: `path-with-\"-and-:-in-it` and `vanilla-path`."
msgstr "以`\"`（双引号）开头的条目将被解释为C语言风格字符串路径，去掉前导和后导的双引号，并支持反斜杠转义。例如，`\"path-with-\\\"-and-:-in-it\":vanilla-path`有两个路径：`path-with-\"-and-:-in-it`和`vanilla-path`。"

#. type: Labeled list
#: en/git.txt:503
#, ignore-same, no-wrap, priority:100
msgid "`GIT_DIR`"
msgstr "`GIT_DIR`"

#. type: Plain text
#: en/git.txt:508
#, priority:100
msgid "If the `GIT_DIR` environment variable is set then it specifies a path to use instead of the default `.git` for the base of the repository.  The `--git-dir` command-line option also sets this value."
msgstr "如果设置了`GIT_DIR`环境变量，那么它指定了一个路径来代替默认的`.git`作为仓库库的基础。  `--git-dir`命令行选项也能够设置这个值。"

#. type: Labeled list
#: en/git.txt:509
#, ignore-same, no-wrap, priority:100
msgid "`GIT_WORK_TREE`"
msgstr "`GIT_WORK_TREE`"

#. type: Plain text
#: en/git.txt:513
#, priority:100
msgid "Set the path to the root of the working tree.  This can also be controlled by the `--work-tree` command-line option and the core.worktree configuration variable."
msgstr "设置到工作区的根部路径。  这也可以由`--work-tree`命令行选项和core.worktree配置变量设置。"

#. type: Labeled list
#: en/git.txt:514
#, ignore-same, no-wrap, priority:100
msgid "`GIT_NAMESPACE`"
msgstr "`GIT_NAMESPACE`"

#. type: Plain text
#: en/git.txt:517
#, priority:100
msgid "Set the Git namespace; see linkgit:gitnamespaces[7] for details.  The `--namespace` command-line option also sets this value."
msgstr "设置 Git 命名空间；详见 linkgit:gitnamespaces[7]。  `--namespace`命令行选项也可以设置这个值。"

#. type: Labeled list
#: en/git.txt:518
#, ignore-same, no-wrap, priority:100
msgid "`GIT_CEILING_DIRECTORIES`"
msgstr "`GIT_CEILING_DIRECTORIES`"

#. type: Plain text
#: en/git.txt:532
#, priority:100
msgid "This should be a colon-separated list of absolute paths.  If set, it is a list of directories that Git should not chdir up into while looking for a repository directory (useful for excluding slow-loading network directories).  It will not exclude the current working directory or a GIT_DIR set on the command line or in the environment.  Normally, Git has to read the entries in this list and resolve any symlink that might be present in order to compare them with the current directory.  However, if even this access is slow, you can add an empty entry to the list to tell Git that the subsequent entries are not symlinks and needn't be resolved; e.g., `GIT_CEILING_DIRECTORIES=/maybe/symlink::/very/slow/non/symlink`."
msgstr "这应该是一个用冒号分隔的绝对路径列表。  如果设置了，它是一个目录列表，在寻找仓库目录时，Git不应该向上改变目录(chidir)（对于排除缓慢加载的网络目录很有用）。  它不会排除当前工作目录或在命令行或环境中设置的GIT_DIR。  通常情况下，Git 需要读取这个列表中的条目，并解析任何可能存在的符号链接，以便将它们与当前目录进行比较。  然而，如果连这个访问都很慢，你可以在列表中添加一个空条目，告诉Git后面的条目不是符号链接，不需要解析；例如，`GIT_CEILING_DIRECTORIES=/maybe/symlink::/very/slow/non/symlink`。"

#. type: Labeled list
#: en/git.txt:533
#, ignore-same, no-wrap, priority:100
msgid "`GIT_DISCOVERY_ACROSS_FILESYSTEM`"
msgstr "`GIT_DISCOVERY_ACROSS_FILESYSTEM`"

#. type: Plain text
#: en/git.txt:542
#, priority:100
msgid "When run in a directory that does not have \".git\" repository directory, Git tries to find such a directory in the parent directories to find the top of the working tree, but by default it does not cross filesystem boundaries.  This Boolean environment variable can be set to true to tell Git not to stop at filesystem boundaries.  Like `GIT_CEILING_DIRECTORIES`, this will not affect an explicit repository directory set via `GIT_DIR` or on the command line."
msgstr "当在一个没有\".git \"仓库目录的目录下运行时，Git 会尝试在父目录中找到这样的目录来寻找工作区的顶端，但默认情况下它不会跨越文件系统的边界。  这个布尔环境变量可以被设置为 \"true\"，以告诉Git不要在文件系统边界处停止。  和`GIT_CEILING_DIRECTORIES`一样，这不会影响通过`GIT_DIR`或在命令行中设置的明确的仓库目录。"

#. type: Labeled list
#: en/git.txt:543
#, ignore-same, no-wrap, priority:100
msgid "`GIT_COMMON_DIR`"
msgstr "`GIT_COMMON_DIR`"

#. type: Plain text
#: en/git.txt:551
#, ignore-ellipsis, priority:100
msgid "If this variable is set to a path, non-worktree files that are normally in $GIT_DIR will be taken from this path instead. Worktree-specific files such as HEAD or index are taken from $GIT_DIR. See linkgit:gitrepository-layout[5] and linkgit:git-worktree[1] for details. This variable has lower precedence than other path variables such as GIT_INDEX_FILE, GIT_OBJECT_DIRECTORY..."
msgstr "如果这个变量被设置为一个路径，通常在$GIT_DIR中的非工作树文件将被从这个路径中取出。工作树中特定的文件，如 HEAD 或 index，则从 $GIT_DIR 取出。详情见 linkgit:gitrepository-layout[5] 和 linkgit:git-worktree[1]。这个变量的优先级低于其他路径变量，如 GIT_INDEX_FILE、GIT_OBJECT_DIRECTORY..."

#. type: Labeled list
#: en/git.txt:552
#, ignore-same, no-wrap, priority:100
msgid "`GIT_DEFAULT_HASH`"
msgstr "`GIT_DEFAULT_HASH`"

#. type: Plain text
#: en/git.txt:558
#, fuzzy, priority:100
#| msgid "If this variable is set, the default hash algorithm for new repositories will be set to this value. This value is currently ignored when cloning; the setting of the remote repository is used instead. The default is \"sha1\". THIS VARIABLE IS EXPERIMENTAL! See `--object-format` in linkgit:git-init[1]."
msgid "If this variable is set, the default hash algorithm for new repositories will be set to this value. This value is ignored when cloning and the setting of the remote repository is always used. The default is \"sha1\". THIS VARIABLE IS EXPERIMENTAL! See `--object-format` in linkgit:git-init[1]."
msgstr "如果这个变量被设置，新版本库的默认哈希算法将被设置为这个值。目前这个值在克隆时被忽略，而是使用远程版本库的设置。默认是 \"sha1\"。这 个 变 量 是 实 验 性 的 ！！！参见 linkgit:git-init[1] 中的 `--object-format`。"

#. type: Title ~
#: en/git.txt:560
#, no-wrap, priority:100
msgid "Git Commits"
msgstr "Git提交"

#. type: Labeled list
#: en/git.txt:561
#, ignore-same, no-wrap, priority:100
msgid "`GIT_AUTHOR_NAME`"
msgstr "`GIT_AUTHOR_NAME`"

#. type: Plain text
#: en/git.txt:565
#, priority:100
msgid "The human-readable name used in the author identity when creating commit or tag objects, or when writing reflogs. Overrides the `user.name` and `author.name` configuration settings."
msgstr "在创建提交、标签对象或在编写日志时，作者身份中使用的可读名称。这会覆盖`user.name`和`author.name`配置的值。"

#. type: Labeled list
#: en/git.txt:566
#, ignore-same, no-wrap, priority:100
msgid "`GIT_AUTHOR_EMAIL`"
msgstr "`GIT_AUTHOR_EMAIL`"

#. type: Plain text
#: en/git.txt:570
#, priority:100
msgid "The email address used in the author identity when creating commit or tag objects, or when writing reflogs. Overrides the `user.email` and `author.email` configuration settings."
msgstr "在创建提交、标签对象或在编写引用日志时，用以表明作者身份所使用的电子邮件地址。这会覆盖`user.email`和`author.email`的配置值。"

#. type: Labeled list
#: en/git.txt:571
#, ignore-same, no-wrap, priority:100
msgid "`GIT_AUTHOR_DATE`"
msgstr "`GIT_AUTHOR_DATE`"

#. type: Plain text
#: en/git.txt:574
#, priority:100
msgid "The date used for the author identity when creating commit or tag objects, or when writing reflogs. See linkgit:git-commit[1] for valid formats."
msgstr "在创建提交、标签对象或在编写引用日志时，用于标注作者修改的日期。有效格式见 linkgit:git-commit[1]。"

#. type: Labeled list
#: en/git.txt:575
#, ignore-same, no-wrap, priority:100
msgid "`GIT_COMMITTER_NAME`"
msgstr "`GIT_COMMITTER_NAME`"

#. type: Plain text
#: en/git.txt:579
#, priority:100
msgid "The human-readable name used in the committer identity when creating commit or tag objects, or when writing reflogs. Overrides the `user.name` and `committer.name` configuration settings."
msgstr "在创建提交、标签对象或在编写引用日志时，提交者身份中使用的可读名称。这会覆盖`user.name`和`committer.name`的配置值。"

#. type: Labeled list
#: en/git.txt:580
#, ignore-same, no-wrap, priority:100
msgid "`GIT_COMMITTER_EMAIL`"
msgstr "`GIT_COMMITTER_EMAIL`"

#. type: Plain text
#: en/git.txt:584
#, priority:100
msgid "The email address used in the author identity when creating commit or tag objects, or when writing reflogs. Overrides the `user.email` and `committer.email` configuration settings."
msgstr "在创建提交、标签对象或在编写引用日志时，用以表明提交者所使用的电子邮件地址。这会覆盖`user.email`和`author.email`的配置值。"

#. type: Labeled list
#: en/git.txt:585
#, ignore-same, no-wrap, priority:100
msgid "`GIT_COMMITTER_DATE`"
msgstr "`GIT_COMMITTER_DATE`"

#. type: Plain text
#: en/git.txt:588
#, priority:100
msgid "The date used for the committer identity when creating commit or tag objects, or when writing reflogs. See linkgit:git-commit[1] for valid formats."
msgstr "在创建提交、标签对象或在编写 reflogs 时，用于标注提交者所作修改的日期。有效格式见 linkgit:git-commit[1]。"

#. type: Labeled list
#: en/git.txt:589
#, ignore-same, no-wrap, priority:100
msgid "`EMAIL`"
msgstr "`EMAIL`"

#. type: Plain text
#: en/git.txt:592
#, priority:100
msgid "The email address used in the author and committer identities if no other relevant environment variable or configuration setting has been set."
msgstr "如果没有设置其他相关的环境变量或配置设置，作者和提交者的电子邮件地址会参考该值。"

#. type: Title ~
#: en/git.txt:594
#, no-wrap, priority:100
msgid "Git Diffs"
msgstr "Git差异比较(Diffs)"

#. type: Labeled list
#: en/git.txt:595
#, ignore-same, no-wrap, priority:100
msgid "`GIT_DIFF_OPTS`"
msgstr "`GIT_DIFF_OPTS`"

#. type: Plain text
#: en/git.txt:600
#, priority:100
msgid "Only valid setting is \"--unified=??\" or \"-u??\" to set the number of context lines shown when a unified diff is created.  This takes precedence over any \"-U\" or \"--unified\" option value passed on the Git diff command line."
msgstr "唯一有效的设置是\"--unified=?? \"或\"-u??\"，用于设置创建统一的差异时显示的文本行数。  这优先于 Git diff 命令行中传递的任何 \"-U\" 或 \"--unified\" 选项值。"

#. type: Labeled list
#: en/git.txt:601
#, ignore-same, no-wrap, priority:100
msgid "`GIT_EXTERNAL_DIFF`"
msgstr "`GIT_EXTERNAL_DIFF`"

#. type: Plain text
#: en/git.txt:607
#, priority:100
msgid "When the environment variable `GIT_EXTERNAL_DIFF` is set, the program named by it is called to generate diffs, and Git does not use its builtin diff machinery.  For a path that is added, removed, or modified, `GIT_EXTERNAL_DIFF` is called with 7 parameters:"
msgstr "当环境变量`GIT_EXTERNAL_DIFF`被设置时，由它命名的程序被调用来生成差异化文本，而不使用Git内置的diff工具。  对于一个被添加、删除或修改的操作，`GIT_EXTERNAL_DIFF`会被调用，一共接收7个参数："

#. type: Plain text
#: en/git.txt:609
#, priority:100
msgid "path old-file old-hex old-mode new-file new-hex new-mode"
msgstr "path old-file old-hex old-mode new-file new-hex new-mode"

#. type: Plain text
#: en/git.txt:611
#, priority:100
msgid "where:"
msgstr "使用："

#. type: Labeled list
#: en/git.txt:612
#, no-wrap, priority:100
msgid "<old|new>-file"
msgstr "<old|new>-file"

#. type: Plain text
#: en/git.txt:614
#, priority:100
msgid "are files GIT_EXTERNAL_DIFF can use to read the contents of <old|new>,"
msgstr "是GIT_EXTERNAL_DIFF用来读取<old|new>内容的文件，"

#. type: Labeled list
#: en/git.txt:614
#, no-wrap, priority:100
msgid "<old|new>-hex"
msgstr "<old|new>-hex"

#. type: Plain text
#: en/git.txt:615
#, priority:100
msgid "are the 40-hexdigit SHA-1 hashes,"
msgstr "是40个十六进制的SHA-1哈希值，"

#. type: Labeled list
#: en/git.txt:615
#, no-wrap, priority:100
msgid "<old|new>-mode"
msgstr "<old|new>-mode"

#. type: Plain text
#: en/git.txt:616
#, priority:100
msgid "are the octal representation of the file modes."
msgstr "是文件模式的八进制表示法。"

#. type: Plain text
#: en/git.txt:622
#, fuzzy, priority:100
#| msgid "The file parameters can point at the user's working file (e.g. `new-file` in \"git-diff-files\"), `/dev/null` (e.g. `old-file` when a new file is added), or a temporary file (e.g. `old-file` in the index).  `GIT_EXTERNAL_DIFF` should not worry about unlinking the temporary file --- it is removed when `GIT_EXTERNAL_DIFF` exits."
msgid "The file parameters can point at the user's working file (e.g. `new-file` in \"git-diff-files\"), `/dev/null` (e.g. `old-file` when a new file is added), or a temporary file (e.g. `old-file` in the index).  `GIT_EXTERNAL_DIFF` should not worry about unlinking the temporary file -- it is removed when `GIT_EXTERNAL_DIFF` exits."
msgstr "文件参数可以指向用户的工作文件（例如 \"git-diff-files \"中的`new-file`），`/dev/null`（例如在添加新文件时的`old-file`），或一个临时文件（例如索引中的`old-file`）。  无需担心`GIT_EXTERNAL_DIFF`对临时文件的链接是否解除——当`GIT_EXTERNAL_DIFF`退出时，它会被删除。"

#. type: Plain text
#: en/git.txt:625
#, priority:100
msgid "For a path that is unmerged, `GIT_EXTERNAL_DIFF` is called with 1 parameter, <path>."
msgstr "`GIT_EXTERNAL_DIFF`被调用时，对于未合并的路径可通过<path>进行设置。"

#. type: Plain text
#: en/git.txt:628
#, priority:100
msgid "For each path `GIT_EXTERNAL_DIFF` is called, two environment variables, `GIT_DIFF_PATH_COUNTER` and `GIT_DIFF_PATH_TOTAL` are set."
msgstr ""

#. type: Labeled list
#: en/git.txt:629
#, ignore-same, no-wrap, priority:100
msgid "`GIT_DIFF_PATH_COUNTER`"
msgstr "`GIT_DIFF_PATH_COUNTER`"

#. type: Plain text
#: en/git.txt:631
#, priority:100
msgid "A 1-based counter incremented by one for every path."
msgstr ""

#. type: Labeled list
#: en/git.txt:632
#, ignore-same, no-wrap, priority:100
msgid "`GIT_DIFF_PATH_TOTAL`"
msgstr "`GIT_DIFF_PATH_TOTAL`"

#. type: Plain text
#: en/git.txt:634
#, priority:100
msgid "The total number of paths."
msgstr ""

#. type: Title ~
#: en/git.txt:636
#, fuzzy, no-wrap, priority:100
msgid "other"
msgstr "其他"

#. type: Labeled list
#: en/git.txt:637
#, ignore-same, no-wrap, priority:100
msgid "`GIT_MERGE_VERBOSITY`"
msgstr "`GIT_MERGE_VERBOSITY`"

#. type: Plain text
#: en/git.txt:641
#, priority:100
msgid "A number controlling the amount of output shown by the recursive merge strategy.  Overrides merge.verbosity.  See linkgit:git-merge[1]"
msgstr ""

#. type: Labeled list
#: en/git.txt:642
#, ignore-same, no-wrap, priority:100
msgid "`GIT_PAGER`"
msgstr "`GIT_PAGER`"

#. type: Plain text
#: en/git.txt:647
#, priority:100
msgid "This environment variable overrides `$PAGER`. If it is set to an empty string or to the value \"cat\", Git will not launch a pager.  See also the `core.pager` option in linkgit:git-config[1]."
msgstr ""

#. type: Labeled list
#: en/git.txt:648
#, ignore-same, no-wrap, priority:100
msgid "`GIT_PROGRESS_DELAY`"
msgstr "`GIT_PROGRESS_DELAY`"

#. type: Plain text
#: en/git.txt:651
#, priority:100
msgid "A number controlling how many seconds to delay before showing optional progress indicators. Defaults to 2."
msgstr ""

#. type: Labeled list
#: en/git.txt:652
#, ignore-same, no-wrap, priority:100
msgid "`GIT_EDITOR`"
msgstr "`GIT_EDITOR`"

#. type: Plain text
#: en/git.txt:657
#, priority:100
msgid "This environment variable overrides `$EDITOR` and `$VISUAL`.  It is used by several Git commands when, on interactive mode, an editor is to be launched. See also linkgit:git-var[1] and the `core.editor` option in linkgit:git-config[1]."
msgstr ""

#. type: Labeled list
#: en/git.txt:658
#, ignore-same, no-wrap, priority:100
msgid "`GIT_SEQUENCE_EDITOR`"
msgstr "`GIT_SEQUENCE_EDITOR`"

#. type: Plain text
#: en/git.txt:663
#, priority:100
msgid "This environment variable overrides the configured Git editor when editing the todo list of an interactive rebase. See also linkgit:git-rebase[1] and the `sequence.editor` option in linkgit:git-config[1]."
msgstr ""

#. type: Labeled list
#: en/git.txt:664
#, ignore-same, no-wrap, priority:100
msgid "`GIT_SSH`"
msgstr "`GIT_SSH`"

#. type: Labeled list
#: en/git.txt:665
#, ignore-same, no-wrap, priority:100
msgid "`GIT_SSH_COMMAND`"
msgstr "`GIT_SSH_COMMAND`"

#. type: Plain text
#: en/git.txt:672
#, priority:100
msgid "If either of these environment variables is set then 'git fetch' and 'git push' will use the specified command instead of 'ssh' when they need to connect to a remote system.  The command-line parameters passed to the configured command are determined by the ssh variant.  See `ssh.variant` option in linkgit:git-config[1] for details."
msgstr ""

#. type: Plain text
#: en/git.txt:678
#, priority:100
msgid "`$GIT_SSH_COMMAND` takes precedence over `$GIT_SSH`, and is interpreted by the shell, which allows additional arguments to be included.  `$GIT_SSH` on the other hand must be just the path to a program (which can be a wrapper shell script, if additional arguments are needed)."
msgstr ""

#. type: Plain text
#: en/git.txt:682
#, priority:100
msgid "Usually it is easier to configure any desired options through your personal `.ssh/config` file.  Please consult your ssh documentation for further details."
msgstr ""

#. type: Labeled list
#: en/git.txt:683
#, ignore-same, no-wrap, priority:100
msgid "`GIT_SSH_VARIANT`"
msgstr "`GIT_SSH_VARIANT`"

#. type: Plain text
#: en/git.txt:688
#, priority:100
msgid "If this environment variable is set, it overrides Git's autodetection whether `GIT_SSH`/`GIT_SSH_COMMAND`/`core.sshCommand` refer to OpenSSH, plink or tortoiseplink. This variable overrides the config setting `ssh.variant` that serves the same purpose."
msgstr ""

#. type: Labeled list
#: en/git.txt:689
#, ignore-same, no-wrap, priority:100
msgid "`GIT_SSL_NO_VERIFY`"
msgstr "`GIT_SSL_NO_VERIFY`"

#. type: Plain text
#: en/git.txt:693
#, priority:100
msgid "Setting and exporting this environment variable to any value tells Git not to verify the SSL certificate when fetching or pushing over HTTPS."
msgstr ""

#. type: Labeled list
#: en/git.txt:694
#, ignore-same, no-wrap, priority:100
msgid "`GIT_ATTR_SOURCE`"
msgstr "`GIT_ATTR_SOURCE`"

#. type: Plain text
#: en/git.txt:696
#, priority:100
msgid "Sets the treeish that gitattributes will be read from."
msgstr ""

#. type: Labeled list
#: en/git.txt:697
#, ignore-same, no-wrap, priority:100
msgid "`GIT_ASKPASS`"
msgstr "`GIT_ASKPASS`"

#. type: Plain text
#: en/git.txt:703
#, priority:100
msgid "If this environment variable is set, then Git commands which need to acquire passwords or passphrases (e.g. for HTTP or IMAP authentication)  will call this program with a suitable prompt as command-line argument and read the password from its STDOUT. See also the `core.askPass` option in linkgit:git-config[1]."
msgstr ""

#. type: Labeled list
#: en/git.txt:704
#, ignore-same, no-wrap, priority:100
msgid "`GIT_TERMINAL_PROMPT`"
msgstr "`GIT_TERMINAL_PROMPT`"

#. type: Plain text
#: en/git.txt:707
#, priority:100
msgid "If this Boolean environment variable is set to false, git will not prompt on the terminal (e.g., when asking for HTTP authentication)."
msgstr ""

#. type: Labeled list
#: en/git.txt:708
#, ignore-same, no-wrap, priority:100
msgid "`GIT_CONFIG_GLOBAL`"
msgstr "`GIT_CONFIG_GLOBAL`"

#. type: Labeled list
#: en/git.txt:709
#, ignore-same, no-wrap, priority:100
msgid "`GIT_CONFIG_SYSTEM`"
msgstr "`GIT_CONFIG_SYSTEM`"

#. type: Plain text
#: en/git.txt:717
#, priority:100
msgid "Take the configuration from the given files instead from global or system-level configuration files. If `GIT_CONFIG_SYSTEM` is set, the system config file defined at build time (usually `/etc/gitconfig`)  will not be read. Likewise, if `GIT_CONFIG_GLOBAL` is set, neither `$HOME/.gitconfig` nor `$XDG_CONFIG_HOME/git/config` will be read. Can be set to `/dev/null` to skip reading configuration files of the respective level."
msgstr ""

#. type: Labeled list
#: en/git.txt:718
#, ignore-same, no-wrap, priority:100
msgid "`GIT_CONFIG_NOSYSTEM`"
msgstr "`GIT_CONFIG_NOSYSTEM`"

#. type: Plain text
#: en/git.txt:725
#, priority:100
msgid "Whether to skip reading settings from the system-wide `$(prefix)/etc/gitconfig` file.  This Boolean environment variable can be used along with `$HOME` and `$XDG_CONFIG_HOME` to create a predictable environment for a picky script, or you can set it to true to temporarily avoid using a buggy `/etc/gitconfig` file while waiting for someone with sufficient permissions to fix it."
msgstr ""

#. type: Labeled list
#: en/git.txt:726
#, ignore-same, no-wrap, priority:100
msgid "`GIT_FLUSH`"
msgstr "`GIT_FLUSH`"

#.  NEEDSWORK: make it into a usual Boolean environment variable
#. type: Plain text
#: en/git.txt:737
#, no-wrap, priority:100
msgid ""
"If this environment variable is set to \"1\", then commands such\n"
"as 'git blame' (in incremental mode), 'git rev-list', 'git log',\n"
"'git check-attr' and 'git check-ignore' will\n"
"force a flush of the output stream after each record have been\n"
"flushed. If this\n"
"variable is set to \"0\", the output of these commands will be done\n"
"using completely buffered I/O.   If this environment variable is\n"
"not set, Git will choose buffered or record-oriented flushing\n"
"based on whether stdout appears to be redirected to a file or not.\n"
msgstr ""

#. type: Labeled list
#: en/git.txt:738
#, ignore-same, no-wrap, priority:100
msgid "`GIT_TRACE`"
msgstr "`GIT_TRACE`"

#. type: Plain text
#: en/git.txt:741
#, priority:100
msgid "Enables general trace messages, e.g. alias expansion, built-in command execution and external command execution."
msgstr ""

#. type: Plain text
#: en/git.txt:745 en/git.txt:825
#, priority:100
msgid "If this variable is set to \"1\", \"2\" or \"true\" (comparison is case insensitive), trace messages will be printed to stderr."
msgstr ""

#. type: Plain text
#: en/git.txt:750 en/git.txt:830
#, priority:100
msgid "If the variable is set to an integer value greater than 2 and lower than 10 (strictly) then Git will interpret this value as an open file descriptor and will try to write the trace messages into this file descriptor."
msgstr ""

#. type: Plain text
#: en/git.txt:755
#, priority:100
msgid "Alternatively, if the variable is set to an absolute path (starting with a '/' character), Git will interpret this as a file path and will try to append the trace messages to it."
msgstr ""

#. type: Plain text
#: en/git.txt:758 en/git.txt:847
#, priority:100
msgid "Unsetting the variable, or setting it to empty, \"0\" or \"false\" (case insensitive) disables trace messages."
msgstr ""

#. type: Labeled list
#: en/git.txt:759
#, ignore-same, no-wrap, priority:100
msgid "`GIT_TRACE_FSMONITOR`"
msgstr "`GIT_TRACE_FSMONITOR`"

#. type: Plain text
#: en/git.txt:762
#, priority:100
msgid "Enables trace messages for the filesystem monitor extension.  See `GIT_TRACE` for available trace output options."
msgstr ""

#. type: Labeled list
#: en/git.txt:763
#, ignore-same, no-wrap, priority:100
msgid "`GIT_TRACE_PACK_ACCESS`"
msgstr "`GIT_TRACE_PACK_ACCESS`"

#. type: Plain text
#: en/git.txt:769
#, priority:100
msgid "Enables trace messages for all accesses to any packs. For each access, the pack file name and an offset in the pack is recorded. This may be helpful for troubleshooting some pack-related performance problems.  See `GIT_TRACE` for available trace output options."
msgstr ""

#. type: Labeled list
#: en/git.txt:770
#, ignore-same, no-wrap, priority:100
msgid "`GIT_TRACE_PACKET`"
msgstr "`GIT_TRACE_PACKET`"

#. type: Plain text
#: en/git.txt:776
#, priority:100
msgid "Enables trace messages for all packets coming in or out of a given program. This can help with debugging object negotiation or other protocol issues. Tracing is turned off at a packet starting with \"PACK\" (but see `GIT_TRACE_PACKFILE` below).  See `GIT_TRACE` for available trace output options."
msgstr ""

#. type: Labeled list
#: en/git.txt:777
#, ignore-same, no-wrap, priority:100
msgid "`GIT_TRACE_PACKFILE`"
msgstr "`GIT_TRACE_PACKFILE`"

#. type: Plain text
#: en/git.txt:784
#, priority:100
msgid "Enables tracing of packfiles sent or received by a given program. Unlike other trace output, this trace is verbatim: no headers, and no quoting of binary data. You almost certainly want to direct into a file (e.g., `GIT_TRACE_PACKFILE=/tmp/my.pack`) rather than displaying it on the terminal or mixing it with other trace output."
msgstr ""

#. type: Plain text
#: en/git.txt:787
#, priority:100
msgid "Note that this is currently only implemented for the client side of clones and fetches."
msgstr ""

#. type: Labeled list
#: en/git.txt:788
#, ignore-same, no-wrap, priority:100
msgid "`GIT_TRACE_PERFORMANCE`"
msgstr "`GIT_TRACE_PERFORMANCE`"

#. type: Plain text
#: en/git.txt:792
#, priority:100
msgid "Enables performance related trace messages, e.g. total execution time of each Git command.  See `GIT_TRACE` for available trace output options."
msgstr ""

#. type: Labeled list
#: en/git.txt:793
#, ignore-same, no-wrap, priority:100
msgid "`GIT_TRACE_REFS`"
msgstr "`GIT_TRACE_REFS`"

#. type: Plain text
#: en/git.txt:796
#, priority:100
msgid "Enables trace messages for operations on the ref database.  See `GIT_TRACE` for available trace output options."
msgstr ""

#. type: Labeled list
#: en/git.txt:797
#, ignore-same, no-wrap, priority:100
msgid "`GIT_TRACE_SETUP`"
msgstr "`GIT_TRACE_SETUP`"

#. type: Plain text
#: en/git.txt:801
#, priority:100
msgid "Enables trace messages printing the .git, working tree and current working directory after Git has completed its setup phase.  See `GIT_TRACE` for available trace output options."
msgstr ""

#. type: Labeled list
#: en/git.txt:802
#, ignore-same, no-wrap, priority:100
msgid "`GIT_TRACE_SHALLOW`"
msgstr "`GIT_TRACE_SHALLOW`"

#. type: Plain text
#: en/git.txt:806
#, priority:100
msgid "Enables trace messages that can help debugging fetching / cloning of shallow repositories.  See `GIT_TRACE` for available trace output options."
msgstr ""

#. type: Labeled list
#: en/git.txt:807
#, ignore-same, no-wrap, priority:100
msgid "`GIT_TRACE_CURL`"
msgstr "`GIT_TRACE_CURL`"

#. type: Plain text
#: en/git.txt:812
#, priority:100
msgid "Enables a curl full trace dump of all incoming and outgoing data, including descriptive information, of the git transport protocol.  This is similar to doing curl `--trace-ascii` on the command line.  See `GIT_TRACE` for available trace output options."
msgstr ""

#. type: Labeled list
#: en/git.txt:813
#, ignore-same, no-wrap, priority:100
msgid "`GIT_TRACE_CURL_NO_DATA`"
msgstr "`GIT_TRACE_CURL_NO_DATA`"

#. type: Plain text
#: en/git.txt:816
#, priority:100
msgid "When a curl trace is enabled (see `GIT_TRACE_CURL` above), do not dump data (that is, only dump info lines and headers)."
msgstr ""

#. type: Labeled list
#: en/git.txt:817
#, ignore-same, no-wrap, priority:100
msgid "`GIT_TRACE2`"
msgstr "`GIT_TRACE2`"

#. type: Plain text
#: en/git.txt:821
#, priority:100
msgid "Enables more detailed trace messages from the \"trace2\" library.  Output from `GIT_TRACE2` is a simple text-based format for human readability."
msgstr ""

#. type: Plain text
#: en/git.txt:839
#, priority:100
msgid "Alternatively, if the variable is set to an absolute path (starting with a '/' character), Git will interpret this as a file path and will try to append the trace messages to it.  If the path already exists and is a directory, the trace messages will be written to files (one per process)  in that directory, named according to the last component of the SID and an optional counter (to avoid filename collisions)."
msgstr ""

#. type: Plain text
#: en/git.txt:844
#, priority:100
msgid "In addition, if the variable is set to `af_unix:[<socket_type>:]<absolute-pathname>`, Git will try to open the path as a Unix Domain Socket.  The socket type can be either `stream` or `dgram`."
msgstr ""

#. type: Plain text
#: en/git.txt:850
#, priority:100
msgid "See link:technical/api-trace2.html[Trace2 documentation] for full details."
msgstr ""

#. type: Labeled list
#: en/git.txt:852
#, ignore-same, no-wrap, priority:100
msgid "`GIT_TRACE2_EVENT`"
msgstr "`GIT_TRACE2_EVENT`"

#. type: Plain text
#: en/git.txt:857
#, priority:100
msgid "This setting writes a JSON-based format that is suited for machine interpretation.  See `GIT_TRACE2` for available trace output options and link:technical/api-trace2.html[Trace2 documentation] for full details."
msgstr ""

#. type: Labeled list
#: en/git.txt:858
#, ignore-same, no-wrap, priority:100
msgid "`GIT_TRACE2_PERF`"
msgstr "`GIT_TRACE2_PERF`"

#. type: Plain text
#: en/git.txt:864
#, priority:100
msgid "In addition to the text-based messages available in `GIT_TRACE2`, this setting writes a column-based format for understanding nesting regions.  See `GIT_TRACE2` for available trace output options and link:technical/api-trace2.html[Trace2 documentation] for full details."
msgstr ""

#. type: Labeled list
#: en/git.txt:865
#, ignore-same, no-wrap, priority:100
msgid "`GIT_TRACE_REDACT`"
msgstr "`GIT_TRACE_REDACT`"

#. type: Plain text
#: en/git.txt:870
#, priority:100
msgid "By default, when tracing is activated, Git redacts the values of cookies, the \"Authorization:\" header, the \"Proxy-Authorization:\" header and packfile URIs. Set this Boolean environment variable to false to prevent this redaction."
msgstr ""

#. type: Labeled list
#: en/git.txt:871
#, ignore-same, no-wrap, priority:100
msgid "`GIT_LITERAL_PATHSPECS`"
msgstr "`GIT_LITERAL_PATHSPECS`"

#. type: Plain text
#: en/git.txt:879
#, priority:100
msgid "Setting this Boolean environment variable to true will cause Git to treat all pathspecs literally, rather than as glob patterns. For example, running `GIT_LITERAL_PATHSPECS=1 git log -- '*.c'` will search for commits that touch the path `*.c`, not any paths that the glob `*.c` matches. You might want this if you are feeding literal paths to Git (e.g., paths previously given to you by `git ls-tree`, `--raw` diff output, etc)."
msgstr ""

#. type: Labeled list
#: en/git.txt:880
#, ignore-same, no-wrap, priority:100
msgid "`GIT_GLOB_PATHSPECS`"
msgstr "`GIT_GLOB_PATHSPECS`"

#. type: Plain text
#: en/git.txt:883
#, priority:100
msgid "Setting this Boolean environment variable to true will cause Git to treat all pathspecs as glob patterns (aka \"glob\" magic)."
msgstr ""

#. type: Labeled list
#: en/git.txt:884
#, ignore-same, no-wrap, priority:100
msgid "`GIT_NOGLOB_PATHSPECS`"
msgstr "`GIT_NOGLOB_PATHSPECS`"

#. type: Plain text
#: en/git.txt:887
#, priority:100
msgid "Setting this Boolean environment variable to true will cause Git to treat all pathspecs as literal (aka \"literal\" magic)."
msgstr ""

#. type: Labeled list
#: en/git.txt:888
#, ignore-same, no-wrap, priority:100
msgid "`GIT_ICASE_PATHSPECS`"
msgstr "`GIT_ICASE_PATHSPECS`"

#. type: Plain text
#: en/git.txt:891
#, priority:100
msgid "Setting this Boolean environment variable to true will cause Git to treat all pathspecs as case-insensitive."
msgstr ""

#. type: Labeled list
#: en/git.txt:892
#, ignore-same, no-wrap, priority:100
msgid "`GIT_REFLOG_ACTION`"
msgstr "`GIT_REFLOG_ACTION`"

#. type: Plain text
#: en/git.txt:901
#, priority:100
msgid "When a ref is updated, reflog entries are created to keep track of the reason why the ref was updated (which is typically the name of the high-level command that updated the ref), in addition to the old and new values of the ref.  A scripted Porcelain command can use set_reflog_action helper function in `git-sh-setup` to set its name to this variable when it is invoked as the top level command by the end user, to be recorded in the body of the reflog."
msgstr ""

#. type: Labeled list
#: en/git.txt:902
#, ignore-same, no-wrap, priority:100
msgid "`GIT_REF_PARANOIA`"
msgstr "`GIT_REF_PARANOIA`"

#. type: Plain text
#: en/git.txt:913
#, priority:100
msgid "If this Boolean environment variable is set to false, ignore broken or badly named refs when iterating over lists of refs. Normally Git will try to include any such refs, which may cause some operations to fail. This is usually preferable, as potentially destructive operations (e.g., linkgit:git-prune[1]) are better off aborting rather than ignoring broken refs (and thus considering the history they point to as not worth saving). The default value is `1` (i.e., be paranoid about detecting and aborting all operations). You should not normally need to set this to `0`, but it may be useful when trying to salvage data from a corrupted repository."
msgstr ""

#. type: Labeled list
#: en/git.txt:914
#, ignore-same, no-wrap, priority:100
msgid "`GIT_ALLOW_PROTOCOL`"
msgstr "`GIT_ALLOW_PROTOCOL`"

#. type: Plain text
#: en/git.txt:920
#, priority:100
msgid "If set to a colon-separated list of protocols, behave as if `protocol.allow` is set to `never`, and each of the listed protocols has `protocol.<name>.allow` set to `always` (overriding any existing configuration). See the description of `protocol.allow` in linkgit:git-config[1] for more details."
msgstr ""

#. type: Labeled list
#: en/git.txt:921
#, ignore-same, no-wrap, priority:100
msgid "`GIT_PROTOCOL_FROM_USER`"
msgstr "`GIT_PROTOCOL_FROM_USER`"

#. type: Plain text
#: en/git.txt:927
#, priority:100
msgid "Set this Boolean environment variable to false to prevent protocols used by fetch/push/clone which are configured to the `user` state.  This is useful to restrict recursive submodule initialization from an untrusted repository or for programs which feed potentially-untrusted URLS to git commands.  See linkgit:git-config[1] for more details."
msgstr ""

#. type: Labeled list
#: en/git.txt:928 en/git-upload-pack.txt:53
#, ignore-same, no-wrap, priority:100
msgid "`GIT_PROTOCOL`"
msgstr "`GIT_PROTOCOL`"

#. type: Plain text
#: en/git.txt:933
#, priority:100
msgid "For internal use only.  Used in handshaking the wire protocol.  Contains a colon ':' separated list of keys with optional values 'key[=value]'.  Presence of unknown keys and values must be ignored."
msgstr ""

#. type: Plain text
#: en/git.txt:942
#, priority:100
msgid "Note that servers may need to be configured to allow this variable to pass over some transports. It will be propagated automatically when accessing local repositories (i.e., `file://` or a filesystem path), as well as over the `git://` protocol. For git-over-http, it should work automatically in most configurations, but see the discussion in linkgit:git-http-backend[1]. For git-over-ssh, the ssh server may need to be configured to allow clients to pass this variable (e.g., by using `AcceptEnv GIT_PROTOCOL` with OpenSSH)."
msgstr ""

#. type: Plain text
#: en/git.txt:948
#, priority:100
msgid "This configuration is optional. If the variable is not propagated, then clients will fall back to the original \"v0\" protocol (but may miss out on some performance improvements or features). This variable currently only affects clones and fetches; it is not yet used for pushes (but may be in the future)."
msgstr ""

#. type: Labeled list
#: en/git.txt:949
#, ignore-same, no-wrap, priority:100
msgid "`GIT_OPTIONAL_LOCKS`"
msgstr "`GIT_OPTIONAL_LOCKS`"

#. type: Plain text
#: en/git.txt:956
#, priority:100
msgid "If this Boolean environment variable is set to false, Git will complete any requested operation without performing any optional sub-operations that require taking a lock.  For example, this will prevent `git status` from refreshing the index as a side effect. This is useful for processes running in the background which do not want to cause lock contention with other operations on the repository.  Defaults to `1`."
msgstr ""

#. type: Labeled list
#: en/git.txt:957
#, ignore-same, no-wrap, priority:100
msgid "`GIT_REDIRECT_STDIN`"
msgstr "`GIT_REDIRECT_STDIN`"

#. type: Labeled list
#: en/git.txt:958
#, ignore-same, no-wrap, priority:100
msgid "`GIT_REDIRECT_STDOUT`"
msgstr "`GIT_REDIRECT_STDOUT`"

#. type: Labeled list
#: en/git.txt:959
#, ignore-same, no-wrap, priority:100
msgid "`GIT_REDIRECT_STDERR`"
msgstr "`GIT_REDIRECT_STDERR`"

#. type: Plain text
#: en/git.txt:969
#, priority:100
msgid "Windows-only: allow redirecting the standard input/output/error handles to paths specified by the environment variables. This is particularly useful in multi-threaded applications where the canonical way to pass standard handles via `CreateProcess()` is not an option because it would require the handles to be marked inheritable (and consequently *every* spawned process would inherit them, possibly blocking regular Git operations). The primary intended use case is to use named pipes for communication (e.g. `\\\\.\\pipe\\my-git-stdin-123`)."
msgstr ""

#. type: Plain text
#: en/git.txt:974
#, priority:100
msgid "Two special values are supported: `off` will simply close the corresponding standard handle, and if `GIT_REDIRECT_STDERR` is `2>&1`, standard error will be redirected to the same handle as standard output."
msgstr ""

#. type: Labeled list
#: en/git.txt:975
#, no-wrap, priority:100
msgid "`GIT_PRINT_SHA1_ELLIPSIS` (deprecated)"
msgstr ""

#. type: Plain text
#: en/git.txt:983
#, priority:100
msgid "If set to `yes`, print an ellipsis following an (abbreviated) SHA-1 value.  This affects indications of detached HEADs (linkgit:git-checkout[1]) and the raw diff output (linkgit:git-diff[1]).  Printing an ellipsis in the cases mentioned is no longer considered adequate and support for it is likely to be removed in the foreseeable future (along with the variable)."
msgstr ""

#. type: Title -
#: en/git.txt:985
#, no-wrap, priority:100
msgid "Discussion[[Discussion]]"
msgstr ""

#. type: Plain text
#: en/git.txt:990
#, priority:100
msgid "More detail on the following is available from the link:user-manual.html#git-concepts[Git concepts chapter of the user-manual] and linkgit:gitcore-tutorial[7]."
msgstr ""

#. type: Plain text
#: en/git.txt:997
#, priority:100
msgid "A Git project normally consists of a working directory with a \".git\" subdirectory at the top level.  The .git directory contains, among other things, a compressed object database representing the complete history of the project, an \"index\" file which links that history to the current contents of the working tree, and named pointers into that history such as tags and branch heads."
msgstr ""

#. type: Plain text
#: en/git.txt:1002
#, priority:100
msgid "The object database contains objects of three main types: blobs, which hold file data; trees, which point to blobs and other trees to build up directory hierarchies; and commits, which each reference a single tree and some number of parent commits."
msgstr ""

#. type: Plain text
#: en/git.txt:1007
#, priority:100
msgid "The commit, equivalent to what other systems call a \"changeset\" or \"version\", represents a step in the project's history, and each parent represents an immediately preceding step.  Commits with more than one parent represent merges of independent lines of development."
msgstr ""

#. type: Plain text
#: en/git.txt:1013
#, priority:100
msgid "All objects are named by the SHA-1 hash of their contents, normally written as a string of 40 hex digits.  Such names are globally unique.  The entire history leading up to a commit can be vouched for by signing just that commit.  A fourth object type, the tag, is provided for this purpose."
msgstr ""

#. type: Plain text
#: en/git.txt:1016
#, priority:100
msgid "When first created, objects are stored in individual files, but for efficiency may later be compressed together into \"pack files\"."
msgstr ""

#. type: Plain text
#: en/git.txt:1023
#, priority:100
msgid "Named pointers called refs mark interesting points in history.  A ref may contain the SHA-1 name of an object or the name of another ref.  Refs with names beginning `ref/head/` contain the SHA-1 name of the most recent commit (or \"head\") of a branch under development.  SHA-1 names of tags of interest are stored under `ref/tags/`.  A special ref named `HEAD` contains the name of the currently checked-out branch."
msgstr ""

#. type: Plain text
#: en/git.txt:1032
#, priority:100
msgid "The index file is initialized with a list of all paths and, for each path, a blob object and a set of attributes.  The blob object represents the contents of the file as of the head of the current branch.  The attributes (last modified time, size, etc.) are taken from the corresponding file in the working tree.  Subsequent changes to the working tree can be found by comparing these attributes.  The index may be updated with new content, and new commits may be created from the content stored in the index."
msgstr ""

#. type: Plain text
#: en/git.txt:1036
#, priority:100
msgid "The index is also capable of storing multiple entries (called \"stages\")  for a given pathname.  These stages are used to hold the various unmerged version of a file when a merge is in progress."
msgstr ""

#. type: Title -
#: en/git.txt:1038
#, no-wrap, priority:100
msgid "FURTHER DOCUMENTATION"
msgstr ""

#. type: Plain text
#: en/git.txt:1043
#, priority:100
msgid "See the references in the \"description\" section to get started using Git.  The following is probably more detail than necessary for a first-time user."
msgstr ""

#. type: Plain text
#: en/git.txt:1047
#, priority:100
msgid "The link:user-manual.html#git-concepts[Git concepts chapter of the user-manual] and linkgit:gitcore-tutorial[7] both provide introductions to the underlying Git architecture."
msgstr ""

#. type: Plain text
#: en/git.txt:1049
#, priority:100
msgid "See linkgit:gitworkflows[7] for an overview of recommended workflows."
msgstr ""

#. type: Plain text
#: en/git.txt:1052
#, priority:100
msgid "See also the link:howto-index.html[howto] documents for some useful examples."
msgstr ""

#. type: Plain text
#: en/git.txt:1055
#, priority:100
msgid "The internals are documented in the link:technical/api-index.html[Git API documentation]."
msgstr ""

#. type: Plain text
#: en/git.txt:1058
#, priority:100
msgid "Users migrating from CVS may also want to read linkgit:gitcvs-migration[7]."
msgstr ""

#. type: Title -
#: en/git.txt:1061
#, fuzzy, no-wrap, priority:100
msgid "Authors"
msgstr "作者"

#. type: Plain text
#: en/git.txt:1066
#, priority:100
msgid "Git was started by Linus Torvalds, and is currently maintained by Junio C Hamano. Numerous contributions have come from the Git mailing list <git@vger.kernel.org>.  http://www.openhub.net/p/git/contributors/summary gives you a more complete list of contributors."
msgstr ""

#. type: Plain text
#: en/git.txt:1070
#, priority:100
msgid "If you have a clone of git.git itself, the output of linkgit:git-shortlog[1] and linkgit:git-blame[1] can show you the authors for specific parts of the project."
msgstr ""

#. type: Title -
#: en/git.txt:1072
#, fuzzy, no-wrap, priority:100
msgid "Reporting Bugs"
msgstr "报告缺陷"

#. type: Plain text
#: en/git.txt:1079
#, priority:100
msgid "Report bugs to the Git mailing list <git@vger.kernel.org> where the development and maintenance is primarily done.  You do not have to be subscribed to the list to send a message there.  See the list archive at https://lore.kernel.org/git for previous bug reports and other discussions."
msgstr ""

#. type: Plain text
#: en/git.txt:1082
#, priority:100
msgid "Issues which are security relevant should be disclosed privately to the Git Security mailing list <git-security@googlegroups.com>."
msgstr ""

#. type: Plain text
#: en/git.txt:1090
#, priority:100
msgid "linkgit:gittutorial[7], linkgit:gittutorial-2[7], linkgit:giteveryday[7], linkgit:gitcvs-migration[7], linkgit:gitglossary[7], linkgit:gitcore-tutorial[7], linkgit:gitcli[7], link:user-manual.html[The Git User's Manual], linkgit:gitworkflows[7]"
msgstr ""

#. type: Title =
#: en/git-unpack-file.txt:2
#, ignore-same, no-wrap, priority:90
msgid "git-unpack-file(1)"
msgstr "git-unpack-file(1)"

#. type: Plain text
#: en/git-unpack-file.txt:7
#, priority:90
msgid "git-unpack-file - Creates a temporary file with a blob's contents"
msgstr ""

#. type: Plain text
#: en/git-unpack-file.txt:14
#, no-wrap, priority:90
msgid "'git unpack-file' <blob>\n"
msgstr ""

#. type: Plain text
#: en/git-unpack-file.txt:20
#, no-wrap, priority:90
msgid ""
"Creates a file holding the contents of the blob specified by sha1. It\n"
"returns the name of the temporary file in the following format:\n"
"\t.merge_file_XXXXX\n"
msgstr ""

#. type: Plain text
#: en/git-unpack-file.txt:25
#, priority:90
msgid "Must be a blob id"
msgstr ""

#. type: Title =
#: en/git-unpack-objects.txt:2
#, ignore-same, no-wrap, priority:90
msgid "git-unpack-objects(1)"
msgstr "git-unpack-objects(1)"

#. type: Plain text
#: en/git-unpack-objects.txt:7
#, priority:90
msgid "git-unpack-objects - Unpack objects from a packed archive"
msgstr ""

#. type: Plain text
#: en/git-unpack-objects.txt:13
#, no-wrap, priority:90
msgid "'git unpack-objects' [-n] [-q] [-r] [--strict]\n"
msgstr ""

#. type: Plain text
#: en/git-unpack-objects.txt:20
#, priority:90
msgid "Read a packed archive (.pack) from the standard input, expanding the objects contained within and writing them into the repository in \"loose\" (one object per file) format."
msgstr ""

#. type: Plain text
#: en/git-unpack-objects.txt:24
#, priority:90
msgid "Objects that already exist in the repository will *not* be unpacked from the packfile.  Therefore, nothing will be unpacked if you use this command on a packfile that exists within the target repository."
msgstr ""

#. type: Plain text
#: en/git-unpack-objects.txt:27
#, priority:90
msgid "See linkgit:git-repack[1] for options to generate new packs and replace existing ones."
msgstr ""

#. type: Plain text
#: en/git-unpack-objects.txt:33
#, priority:90
msgid "Dry run.  Check the pack file without actually unpacking the objects."
msgstr ""

#. type: Plain text
#: en/git-unpack-objects.txt:37
#, priority:90
msgid "The command usually shows percentage progress.  This flag suppresses it."
msgstr ""

#. type: Plain text
#: en/git-unpack-objects.txt:43
#, priority:90
msgid "When unpacking a corrupt packfile, the command dies at the first corruption.  This flag tells it to keep going and make the best effort to recover as many objects as possible."
msgstr ""

#. type: Plain text
#: en/git-unpack-objects.txt:46
#, priority:90
msgid "Don't write objects with broken content or links."
msgstr ""

#. type: Title =
#: en/git-update-index.txt:2
#, ignore-same, no-wrap, priority:80
msgid "git-update-index(1)"
msgstr "git-update-index(1)"

#. type: Plain text
#: en/git-update-index.txt:7
#, priority:80
msgid "git-update-index - Register file contents in the working tree to the index"
msgstr ""

#. type: Plain text
#: en/git-update-index.txt:30
#, ignore-ellipsis, no-wrap, priority:80
msgid ""
"'git update-index'\n"
"\t     [--add] [--remove | --force-remove] [--replace]\n"
"\t     [--refresh] [-q] [--unmerged] [--ignore-missing]\n"
"\t     [(--cacheinfo <mode>,<object>,<file>)...]\n"
"\t     [--chmod=(+|-)x]\n"
"\t     [--[no-]assume-unchanged]\n"
"\t     [--[no-]skip-worktree]\n"
"\t     [--[no-]ignore-skip-worktree-entries]\n"
"\t     [--[no-]fsmonitor-valid]\n"
"\t     [--ignore-submodules]\n"
"\t     [--[no-]split-index]\n"
"\t     [--[no-|test-|force-]untracked-cache]\n"
"\t     [--[no-]fsmonitor]\n"
"\t     [--really-refresh] [--unresolve] [--again | -g]\n"
"\t     [--info-only] [--index-info]\n"
"\t     [-z] [--stdin] [--index-version <n>]\n"
"\t     [--verbose]\n"
"\t     [--] [<file>...]\n"
msgstr ""

#. type: Plain text
#: en/git-update-index.txt:35
#, priority:80
msgid "Modifies the index. Each file mentioned is updated into the index and any 'unmerged' or 'needs updating' state is cleared."
msgstr ""

#. type: Plain text
#: en/git-update-index.txt:38
#, priority:80
msgid "See also linkgit:git-add[1] for a more user-friendly way to do some of the most common operations on the index."
msgstr ""

#. type: Plain text
#: en/git-update-index.txt:41
#, priority:80
msgid "The way 'git update-index' handles files it is told about can be modified using the various options:"
msgstr ""

#. type: Plain text
#: en/git-update-index.txt:48
#, priority:80
msgid "If a specified file isn't in the index already then it's added.  Default behaviour is to ignore new files."
msgstr ""

#. type: Labeled list
#: en/git-update-index.txt:49
#, ignore-same, no-wrap, priority:80
msgid "--remove"
msgstr "--remove"

#. type: Plain text
#: en/git-update-index.txt:53
#, priority:80
msgid "If a specified file is in the index but is missing then it's removed.  Default behavior is to ignore removed file."
msgstr ""

#. type: Plain text
#: en/git-update-index.txt:57
#, priority:80
msgid "Looks at the current index and checks to see if merges or updates are needed by checking stat() information."
msgstr ""

#. type: Plain text
#: en/git-update-index.txt:62
#, priority:80
msgid "Quiet.  If --refresh finds that the index needs an update, the default behavior is to error out.  This option makes 'git update-index' continue anyway."
msgstr ""

#. type: Labeled list
#: en/git-update-index.txt:63
#, ignore-same, no-wrap, priority:80
msgid "--ignore-submodules"
msgstr "--ignore-submodules"

#. type: Plain text
#: en/git-update-index.txt:66
#, priority:80
msgid "Do not try to update submodules.  This option is only respected when passed before --refresh."
msgstr ""

#. type: Plain text
#: en/git-update-index.txt:71
#, priority:80
msgid "If --refresh finds unmerged changes in the index, the default behavior is to error out.  This option makes 'git update-index' continue anyway."
msgstr ""

#. type: Plain text
#: en/git-update-index.txt:74
#, priority:80
msgid "Ignores missing files during a --refresh"
msgstr ""

#. type: Labeled list
#: en/git-update-index.txt:75
#, fuzzy, no-wrap, priority:80
msgid "--cacheinfo <mode>,<object>,<path>"
msgstr "--cacheinfo <mode>,<object>,<path>"

#. type: Labeled list
#: en/git-update-index.txt:76
#, fuzzy, no-wrap, priority:80
msgid "--cacheinfo <mode> <object> <path>"
msgstr "--cacheinfo <mode> <object> <path>"

#. type: Plain text
#: en/git-update-index.txt:81
#, priority:80
msgid "Directly insert the specified info into the index.  For backward compatibility, you can also give these three arguments as three separate parameters, but new users are encouraged to use a single-parameter form."
msgstr ""

#. type: Labeled list
#: en/git-update-index.txt:82
#, ignore-same, no-wrap, priority:80
msgid "--index-info"
msgstr "--index-info"

#. type: Plain text
#: en/git-update-index.txt:84
#, priority:80
msgid "Read index information from stdin."
msgstr ""

#. type: Plain text
#: en/git-update-index.txt:87
#, priority:80
msgid "Set the execute permissions on the updated files."
msgstr ""

#. type: Labeled list
#: en/git-update-index.txt:88
#, ignore-same, no-wrap, priority:80
msgid "--[no-]assume-unchanged"
msgstr "--[no-]assume-unchanged"

#. type: Plain text
#: en/git-update-index.txt:100
#, priority:80
msgid "When this flag is specified, the object names recorded for the paths are not updated.  Instead, this option sets/unsets the \"assume unchanged\" bit for the paths.  When the \"assume unchanged\" bit is on, the user promises not to change the file and allows Git to assume that the working tree file matches what is recorded in the index.  If you want to change the working tree file, you need to unset the bit to tell Git.  This is sometimes helpful when working with a big project on a filesystem that has very slow lstat(2) system call (e.g. cifs)."
msgstr ""

#. type: Plain text
#: en/git-update-index.txt:105
#, priority:80
msgid "Git will fail (gracefully) in case it needs to modify this file in the index e.g. when merging in a commit; thus, in case the assumed-untracked file is changed upstream, you will need to handle the situation manually."
msgstr ""

#. type: Labeled list
#: en/git-update-index.txt:106
#, ignore-same, no-wrap, priority:80
msgid "--really-refresh"
msgstr "--really-refresh"

#. type: Plain text
#: en/git-update-index.txt:109
#, priority:80
msgid "Like `--refresh`, but checks stat information unconditionally, without regard to the \"assume unchanged\" setting."
msgstr ""

#. type: Labeled list
#: en/git-update-index.txt:110
#, ignore-same, no-wrap, priority:80
msgid "--[no-]skip-worktree"
msgstr "--[no-]skip-worktree"

#. type: Plain text
#: en/git-update-index.txt:115
#, priority:80
msgid "When one of these flags is specified, the object name recorded for the paths are not updated. Instead, these options set and unset the \"skip-worktree\" bit for the paths. See section \"Skip-worktree bit\" below for more information."
msgstr ""

#. type: Labeled list
#: en/git-update-index.txt:117
#, ignore-same, no-wrap, priority:80
msgid "--[no-]ignore-skip-worktree-entries"
msgstr "--[no-]ignore-skip-worktree-entries"

#. type: Plain text
#: en/git-update-index.txt:120
#, priority:80
msgid "Do not remove skip-worktree (AKA \"index-only\") entries even when the `--remove` option was specified."
msgstr ""

#. type: Labeled list
#: en/git-update-index.txt:121
#, ignore-same, no-wrap, priority:80
msgid "--[no-]fsmonitor-valid"
msgstr "--[no-]fsmonitor-valid"

#. type: Plain text
#: en/git-update-index.txt:126
#, priority:80
msgid "When one of these flags is specified, the object name recorded for the paths are not updated. Instead, these options set and unset the \"fsmonitor valid\" bit for the paths. See section \"File System Monitor\" below for more information."
msgstr ""

#. type: Labeled list
#: en/git-update-index.txt:128
#, ignore-same, no-wrap, priority:80
msgid "--again"
msgstr "--again"

#. type: Plain text
#: en/git-update-index.txt:131
#, priority:80
msgid "Runs 'git update-index' itself on the paths whose index entries are different from those from the `HEAD` commit."
msgstr ""

#. type: Labeled list
#: en/git-update-index.txt:132
#, ignore-same, no-wrap, priority:80
msgid "--unresolve"
msgstr "--unresolve"

#. type: Plain text
#: en/git-update-index.txt:135
#, priority:80
msgid "Restores the 'unmerged' or 'needs updating' state of a file during a merge if it was cleared by accident."
msgstr ""

#. type: Labeled list
#: en/git-update-index.txt:136
#, ignore-same, no-wrap, priority:80
msgid "--info-only"
msgstr "--info-only"

#. type: Plain text
#: en/git-update-index.txt:140
#, priority:80
msgid "Do not create objects in the object database for all <file> arguments that follow this flag; just insert their object IDs into the index."
msgstr ""

#. type: Labeled list
#: en/git-update-index.txt:141
#, ignore-same, no-wrap, priority:80
msgid "--force-remove"
msgstr "--force-remove"

#. type: Plain text
#: en/git-update-index.txt:144
#, priority:80
msgid "Remove the file from the index even when the working directory still has such a file. (Implies --remove.)"
msgstr ""

#. type: Labeled list
#: en/git-update-index.txt:145
#, ignore-same, no-wrap, priority:80
msgid "--replace"
msgstr "--replace"

#. type: Plain text
#: en/git-update-index.txt:152
#, priority:80
msgid "By default, when a file `path` exists in the index, 'git update-index' refuses an attempt to add `path/file`.  Similarly if a file `path/file` exists, a file `path` cannot be added.  With --replace flag, existing entries that conflict with the entry being added are automatically removed with warning messages."
msgstr ""

#. type: Plain text
#: en/git-update-index.txt:160
#, priority:80
msgid "Report what is being added and removed from index."
msgstr ""

#. type: Labeled list
#: en/git-update-index.txt:161
#, fuzzy, no-wrap, priority:80
msgid "--index-version <n>"
msgstr "--index-version <n>"

#. type: Plain text
#: en/git-update-index.txt:166
#, priority:80
msgid "Write the resulting index out in the named on-disk format version.  Supported versions are 2, 3 and 4. The current default version is 2 or 3, depending on whether extra features are used, such as `git add -N`."
msgstr ""

#. type: Plain text
#: en/git-update-index.txt:172
#, priority:80
msgid "Version 4 performs a simple pathname compression that reduces index size by 30%-50% on large repositories, which results in faster load time. Version 4 is relatively young (first released in 1.8.0 in October 2012). Other Git implementations such as JGit and libgit2 may not support it yet."
msgstr ""

#. type: Plain text
#: en/git-update-index.txt:176
#, priority:80
msgid "Only meaningful with `--stdin` or `--index-info`; paths are separated with NUL character instead of LF."
msgstr ""

#. type: Labeled list
#: en/git-update-index.txt:177
#, ignore-same, no-wrap, priority:80
msgid "--split-index"
msgstr "--split-index"

#. type: Labeled list
#: en/git-update-index.txt:178
#, ignore-same, no-wrap, priority:80
msgid "--no-split-index"
msgstr "--no-split-index"

#. type: Plain text
#: en/git-update-index.txt:183
#, priority:80
msgid "Enable or disable split index mode. If split-index mode is already enabled and `--split-index` is given again, all changes in $GIT_DIR/index are pushed back to the shared index file."
msgstr ""

#. type: Plain text
#: en/git-update-index.txt:189
#, priority:80
msgid "These options take effect whatever the value of the `core.splitIndex` configuration variable (see linkgit:git-config[1]). But a warning is emitted when the change goes against the configured value, as the configured value will take effect next time the index is read and this will remove the intended effect of the option."
msgstr ""

#. type: Labeled list
#: en/git-update-index.txt:190
#, ignore-same, no-wrap, priority:80
msgid "--untracked-cache"
msgstr "--untracked-cache"

#. type: Labeled list
#: en/git-update-index.txt:191
#, ignore-same, no-wrap, priority:80
msgid "--no-untracked-cache"
msgstr "--no-untracked-cache"

#. type: Plain text
#: en/git-update-index.txt:194
#, priority:80
msgid "Enable or disable untracked cache feature. Please use `--test-untracked-cache` before enabling it."
msgstr ""

#. type: Plain text
#: en/git-update-index.txt:200
#, priority:80
msgid "These options take effect whatever the value of the `core.untrackedCache` configuration variable (see linkgit:git-config[1]). But a warning is emitted when the change goes against the configured value, as the configured value will take effect next time the index is read and this will remove the intended effect of the option."
msgstr ""

#. type: Labeled list
#: en/git-update-index.txt:201
#, ignore-same, no-wrap, priority:80
msgid "--test-untracked-cache"
msgstr "--test-untracked-cache"

#. type: Plain text
#: en/git-update-index.txt:210
#, priority:80
msgid "Only perform tests on the working directory to make sure untracked cache can be used. You have to manually enable untracked cache using `--untracked-cache` or `--force-untracked-cache` or the `core.untrackedCache` configuration variable afterwards if you really want to use it. If a test fails the exit code is 1 and a message explains what is not working as needed, otherwise the exit code is 0 and OK is printed."
msgstr ""

#. type: Labeled list
#: en/git-update-index.txt:211
#, ignore-same, no-wrap, priority:80
msgid "--force-untracked-cache"
msgstr "--force-untracked-cache"

#. type: Plain text
#: en/git-update-index.txt:216
#, priority:80
msgid "Same as `--untracked-cache`. Provided for backwards compatibility with older versions of Git where `--untracked-cache` used to imply `--test-untracked-cache` but this option would enable the extension unconditionally."
msgstr ""

#. type: Labeled list
#: en/git-update-index.txt:217
#, ignore-same, no-wrap, priority:80
msgid "--fsmonitor"
msgstr "--fsmonitor"

#. type: Labeled list
#: en/git-update-index.txt:218
#, ignore-same, no-wrap, priority:80
msgid "--no-fsmonitor"
msgstr "--no-fsmonitor"

#. type: Plain text
#: en/git-update-index.txt:225
#, priority:80
msgid "Enable or disable files system monitor feature. These options take effect whatever the value of the `core.fsmonitor` configuration variable (see linkgit:git-config[1]). But a warning is emitted when the change goes against the configured value, as the configured value will take effect next time the index is read and this will remove the intended effect of the option."
msgstr ""

#. type: Plain text
#: en/git-update-index.txt:235
#, priority:80
msgid "Files to act on.  Note that files beginning with '.' are discarded. This includes `./file` and `dir/./file`. If you don't want this, then use cleaner names.  The same applies to directories ending '/' and paths with '//'"
msgstr ""

#. type: Title -
#: en/git-update-index.txt:237
#, no-wrap, priority:80
msgid "USING --REFRESH"
msgstr ""

#. type: Plain text
#: en/git-update-index.txt:243
#, fuzzy, priority:80
msgid "`--refresh` does not calculate a new sha1 file or bring the index up to date for mode/content changes. But what it *does* do is to \"re-match\" the stat information of a file with the index, so that you can refresh the index for a file that hasn't been changed but where the stat entry is out of date."
msgstr "--refresh 不会计算新的 sha1 文件，也不会为模式/内容更改更新索引。但是，它要做的是将文件的统计信息与索引“重新匹配”，以便您可以刷新未更改但统计条目已过期的文件的索引。"

#. type: Plain text
#: en/git-update-index.txt:246
#, priority:80
msgid "For example, you'd want to do this after doing a 'git read-tree', to link up the stat index details with the proper files."
msgstr ""

#. type: Title -
#: en/git-update-index.txt:248
#, no-wrap, priority:80
msgid "USING --CACHEINFO OR --INFO-ONLY"
msgstr ""

#. type: Plain text
#: en/git-update-index.txt:252
#, priority:80
msgid "`--cacheinfo` is used to register a file that is not in the current working directory.  This is useful for minimum-checkout merging."
msgstr ""

#. type: Plain text
#: en/git-update-index.txt:254
#, priority:80
msgid "To pretend you have a file at path with mode and sha1, say:"
msgstr ""

#. type: delimited block -
#: en/git-update-index.txt:257
#, fuzzy, no-wrap, priority:80
msgid "$ git update-index --add --cacheinfo <mode>,<sha1>,<path>\n"
msgstr "$ git update-index --add --cacheinfo <mode>,<sha1>,<path>\n"

#. type: Plain text
#: en/git-update-index.txt:261
#, priority:80
msgid "`--info-only` is used to register files without placing them in the object database.  This is useful for status-only repositories."
msgstr ""

#. type: Plain text
#: en/git-update-index.txt:267
#, priority:80
msgid "Both `--cacheinfo` and `--info-only` behave similarly: the index is updated but the object database isn't.  `--cacheinfo` is useful when the object is in the database but the file isn't available locally.  `--info-only` is useful when the file is available, but you do not wish to update the object database."
msgstr ""

#. type: Title -
#: en/git-update-index.txt:270
#, no-wrap, priority:80
msgid "USING --INDEX-INFO"
msgstr ""

#. type: Plain text
#: en/git-update-index.txt:275
#, priority:80
msgid "`--index-info` is a more powerful mechanism that lets you feed multiple entry definitions from the standard input, and designed specifically for scripts.  It can take inputs of three formats:"
msgstr ""

#. type: Plain text
#: en/git-update-index.txt:277
#, no-wrap, priority:80
msgid "mode SP type SP sha1          TAB path\n"
msgstr ""

#. type: Plain text
#: en/git-update-index.txt:279
#, priority:80
msgid "This format is to stuff `git ls-tree` output into the index."
msgstr ""

#. type: Plain text
#: en/git-update-index.txt:281
#, no-wrap, priority:80
msgid "mode         SP sha1 SP stage TAB path\n"
msgstr ""

#. type: Plain text
#: en/git-update-index.txt:284
#, priority:80
msgid "This format is to put higher order stages into the index file and matches 'git ls-files --stage' output."
msgstr ""

#. type: Plain text
#: en/git-update-index.txt:286
#, no-wrap, priority:80
msgid "mode         SP sha1          TAB path\n"
msgstr ""

#. type: Plain text
#: en/git-update-index.txt:289
#, priority:80
msgid "This format is no longer produced by any Git command, but is and will continue to be supported by `update-index --index-info`."
msgstr ""

#. type: Plain text
#: en/git-update-index.txt:293
#, priority:80
msgid "To place a higher stage entry to the index, the path should first be removed by feeding a mode=0 entry for the path, and then feeding necessary input lines in the third format."
msgstr ""

#. type: Plain text
#: en/git-update-index.txt:295
#, priority:80
msgid "For example, starting with this index:"
msgstr ""

#. type: delimited block -
#: en/git-update-index.txt:299
#, fuzzy, no-wrap, priority:80
msgid ""
"$ git ls-files -s\n"
"100644 8a1218a1024a212bb3db30becd860315f9f3ac52 0       frotz\n"
msgstr ""
"$ git ls-files -s\n"
"100644 8a1218a1024a212bb3db30becd860315f9f3ac52 0       frotz\n"

#. type: Plain text
#: en/git-update-index.txt:302
#, priority:80
msgid "you can feed the following input to `--index-info`:"
msgstr ""

#. type: delimited block -
#: en/git-update-index.txt:308
#, fuzzy, no-wrap, priority:80
msgid ""
"$ git update-index --index-info\n"
"0 0000000000000000000000000000000000000000\tfrotz\n"
"100644 8a1218a1024a212bb3db30becd860315f9f3ac52 1\tfrotz\n"
"100755 8a1218a1024a212bb3db30becd860315f9f3ac52 2\tfrotz\n"
msgstr ""
"$ git update-index --index-info\n"
"0 0000000000000000000000000000000000000000\tfrotz\n"
"100644 8a1218a1024a212bb3db30becd860315f9f3ac52 1\tfrotz\n"
"100755 8a1218a1024a212bb3db30becd860315f9f3ac52 2\tfrotz\n"

#. type: Plain text
#: en/git-update-index.txt:314
#, priority:80
msgid "The first line of the input feeds 0 as the mode to remove the path; the SHA-1 does not matter as long as it is well formatted.  Then the second and third line feeds stage 1 and stage 2 entries for that path.  After the above, we would end up with this:"
msgstr ""

#. type: delimited block -
#: en/git-update-index.txt:319
#, fuzzy, no-wrap, priority:80
msgid ""
"$ git ls-files -s\n"
"100644 8a1218a1024a212bb3db30becd860315f9f3ac52 1\tfrotz\n"
"100755 8a1218a1024a212bb3db30becd860315f9f3ac52 2\tfrotz\n"
msgstr ""
"$ git ls-files -s\n"
"100644 8a1218a1024a212bb3db30becd860315f9f3ac52 1\tfrotz\n"
"100755 8a1218a1024a212bb3db30becd860315f9f3ac52 2\tfrotz\n"

#. type: Title -
#: en/git-update-index.txt:323
#, no-wrap, priority:80
msgid "USING ``ASSUME UNCHANGED'' BIT"
msgstr ""

#. type: Plain text
#: en/git-update-index.txt:338
#, priority:80
msgid "Many operations in Git depend on your filesystem to have an efficient `lstat(2)` implementation, so that `st_mtime` information for working tree files can be cheaply checked to see if the file contents have changed from the version recorded in the index file.  Unfortunately, some filesystems have inefficient `lstat(2)`.  If your filesystem is one of them, you can set \"assume unchanged\" bit to paths you have not changed to cause Git not to do this check.  Note that setting this bit on a path does not mean Git will check the contents of the file to see if it has changed -- it makes Git to omit any checking and assume it has *not* changed.  When you make changes to working tree files, you have to explicitly tell Git about it by dropping \"assume unchanged\" bit, either before or after you modify them."
msgstr ""

#. type: Plain text
#: en/git-update-index.txt:343
#, priority:80
msgid "In order to set \"assume unchanged\" bit, use `--assume-unchanged` option.  To unset, use `--no-assume-unchanged`. To see which files have the \"assume unchanged\" bit set, use `git ls-files -v` (see linkgit:git-ls-files[1])."
msgstr ""

#. type: Plain text
#: en/git-update-index.txt:353
#, ignore-ellipsis, priority:80
msgid "The command looks at `core.ignorestat` configuration variable.  When this is true, paths updated with `git update-index paths...` and paths updated with other Git commands that update both index and working tree (e.g. 'git apply --index', 'git checkout-index -u', and 'git read-tree -u') are automatically marked as \"assume unchanged\".  Note that \"assume unchanged\" bit is *not* set if `git update-index --refresh` finds the working tree file matches the index (use `git update-index --really-refresh` if you want to mark them as \"assume unchanged\")."
msgstr ""

#. type: Plain text
#: en/git-update-index.txt:357
#, priority:80
msgid "Sometimes users confuse the assume-unchanged bit with the skip-worktree bit.  See the final paragraph in the \"Skip-worktree bit\" section below for an explanation of the differences."
msgstr ""

#. type: Plain text
#: en/git-update-index.txt:362
#, priority:80
msgid "To update and refresh only the files already checked out:"
msgstr ""

#. type: Labeled list
#: en/git-update-index.txt:367
#, no-wrap, priority:80
msgid "On an inefficient filesystem with `core.ignorestat` set"
msgstr ""

#. type: delimited block -
#: en/git-update-index.txt:383
#, no-wrap, priority:80
msgid ""
"$ git update-index --really-refresh              <1>\n"
"$ git update-index --no-assume-unchanged foo.c   <2>\n"
"$ git diff --name-only                           <3>\n"
"$ edit foo.c\n"
"$ git diff --name-only                           <4>\n"
"M foo.c\n"
"$ git update-index foo.c                         <5>\n"
"$ git diff --name-only                           <6>\n"
"$ edit foo.c\n"
"$ git diff --name-only                           <7>\n"
"$ git update-index --no-assume-unchanged foo.c   <8>\n"
"$ git diff --name-only                           <9>\n"
"M foo.c\n"
msgstr ""

#. type: Plain text
#: en/git-update-index.txt:386
#, priority:80
msgid "forces lstat(2) to set \"assume unchanged\" bits for paths that match index."
msgstr ""

#. type: Plain text
#: en/git-update-index.txt:387
#, priority:80
msgid "mark the path to be edited."
msgstr ""

#. type: Plain text
#: en/git-update-index.txt:388
#, priority:80
msgid "this does lstat(2) and finds index matches the path."
msgstr ""

#. type: Plain text
#: en/git-update-index.txt:389
#, priority:80
msgid "this does lstat(2) and finds index does *not* match the path."
msgstr ""

#. type: Plain text
#: en/git-update-index.txt:390
#, priority:80
msgid "registering the new version to index sets \"assume unchanged\" bit."
msgstr ""

#. type: Plain text
#: en/git-update-index.txt:391
#, priority:80
msgid "and it is assumed unchanged."
msgstr ""

#. type: Plain text
#: en/git-update-index.txt:392
#, priority:80
msgid "even after you edit it."
msgstr ""

#. type: Plain text
#: en/git-update-index.txt:393
#, priority:80
msgid "you can tell about the change after the fact."
msgstr ""

#. type: Plain text
#: en/git-update-index.txt:394
#, priority:80
msgid "now it checks with lstat(2) and finds it has been changed."
msgstr ""

#. type: Title -
#: en/git-update-index.txt:397
#, no-wrap, priority:80
msgid "SKIP-WORKTREE BIT"
msgstr ""

#. type: Plain text
#: en/git-update-index.txt:403
#, priority:80
msgid "Skip-worktree bit can be defined in one (long) sentence: Tell git to avoid writing the file to the working directory when reasonably possible, and treat the file as unchanged when it is not present in the working directory."
msgstr ""

#. type: Plain text
#: en/git-update-index.txt:406
#, priority:80
msgid "Note that not all git commands will pay attention to this bit, and some only partially support it."
msgstr ""

#. type: Plain text
#: en/git-update-index.txt:415
#, priority:80
msgid "The update-index flags and the read-tree capabilities relating to the skip-worktree bit predated the introduction of the linkgit:git-sparse-checkout[1] command, which provides a much easier way to configure and handle the skip-worktree bits.  If you want to reduce your working tree to only deal with a subset of the files in the repository, we strongly encourage the use of linkgit:git-sparse-checkout[1] in preference to the low-level update-index and read-tree primitives."
msgstr ""

#. type: Plain text
#: en/git-update-index.txt:426
#, priority:80
msgid "The primary purpose of the skip-worktree bit is to enable sparse checkouts, i.e. to have working directories with only a subset of paths present.  When the skip-worktree bit is set, Git commands (such as `switch`, `pull`, `merge`) will avoid writing these files.  However, these commands will sometimes write these files anyway in important cases such as conflicts during a merge or rebase.  Git commands will also avoid treating the lack of such files as an intentional deletion; for example `git add -u` will not stage a deletion for these files and `git commit -a` will not make a commit deleting them either."
msgstr ""

#. type: Plain text
#: en/git-update-index.txt:440
#, priority:80
msgid "Although this bit looks similar to assume-unchanged bit, its goal is different.  The assume-unchanged bit is for leaving the file in the working tree but having Git omit checking it for changes and presuming that the file has not been changed (though if it can determine without stat'ing the file that it has changed, it is free to record the changes).  skip-worktree tells Git to ignore the absence of the file, avoid updating it when possible with commands that normally update much of the working directory (e.g. `checkout`, `switch`, `pull`, etc.), and not have its absence be recorded in commits.  Note that in sparse checkouts (setup by `git sparse-checkout` or by configuring core.sparseCheckout to true), if a file is marked as skip-worktree in the index but is found in the working tree, Git will clear the skip-worktree bit for that file."
msgstr ""

#. type: Title -
#: en/git-update-index.txt:442
#, fuzzy, no-wrap, priority:80
msgid "SPLIT INDEX"
msgstr "SPLIT INDEX"

#. type: Plain text
#: en/git-update-index.txt:446
#, priority:80
msgid "This mode is designed for repositories with very large indexes, and aims at reducing the time it takes to repeatedly write these indexes."
msgstr ""

#. type: Plain text
#: en/git-update-index.txt:451
#, priority:80
msgid "In this mode, the index is split into two files, $GIT_DIR/index and $GIT_DIR/sharedindex.<SHA-1>. Changes are accumulated in $GIT_DIR/index, the split index, while the shared index file contains all index entries and stays unchanged."
msgstr ""

#. type: Plain text
#: en/git-update-index.txt:456
#, priority:80
msgid "All changes in the split index are pushed back to the shared index file when the number of entries in the split index reaches a level specified by the splitIndex.maxPercentChange config variable (see linkgit:git-config[1])."
msgstr ""

#. type: Plain text
#: en/git-update-index.txt:461
#, priority:80
msgid "Each time a new shared index file is created, the old shared index files are deleted if their modification time is older than what is specified by the splitIndex.sharedIndexExpire config variable (see linkgit:git-config[1])."
msgstr ""

#. type: Plain text
#: en/git-update-index.txt:465
#, priority:80
msgid "To avoid deleting a shared index file that is still used, its modification time is updated to the current time every time a new split index based on the shared index file is either created or read from."
msgstr ""

#. type: Title -
#: en/git-update-index.txt:467
#, fuzzy, no-wrap, priority:80
msgid "UNTRACKED CACHE"
msgstr "UNTRACKED CACHE"

#. type: Plain text
#: en/git-update-index.txt:471
#, priority:80
msgid "This cache is meant to speed up commands that involve determining untracked files such as `git status`."
msgstr ""

#. type: Plain text
#: en/git-update-index.txt:478
#, priority:80
msgid "This feature works by recording the mtime of the working tree directories and then omitting reading directories and stat calls against files in those directories whose mtime hasn't changed. For this to work the underlying operating system and file system must change the `st_mtime` field of directories if files in the directory are added, modified or deleted."
msgstr ""

#. type: Plain text
#: en/git-update-index.txt:483
#, priority:80
msgid "You can test whether the filesystem supports that with the `--test-untracked-cache` option. The `--untracked-cache` option used to implicitly perform that test in older versions of Git, but that's no longer the case."
msgstr ""

#. type: Plain text
#: en/git-update-index.txt:491
#, priority:80
msgid "If you want to enable (or disable) this feature, it is easier to use the `core.untrackedCache` configuration variable (see linkgit:git-config[1]) than using the `--untracked-cache` option to `git update-index` in each repository, especially if you want to do so across all repositories you use, because you can set the configuration variable to `true` (or `false`) in your `$HOME/.gitconfig` just once and have it affect all repositories you touch."
msgstr ""

#. type: Plain text
#: en/git-update-index.txt:497
#, priority:80
msgid "When the `core.untrackedCache` configuration variable is changed, the untracked cache is added to or removed from the index the next time a command reads the index; while when `--[no-|force-]untracked-cache` are used, the untracked cache is immediately added to or removed from the index."
msgstr ""

#. type: Plain text
#: en/git-update-index.txt:504
#, priority:80
msgid "Before 2.17, the untracked cache had a bug where replacing a directory with a symlink to another directory could cause it to incorrectly show files tracked by git as untracked. See the \"status: add a failing test showing a core.untrackedCache bug\" commit to git.git. A workaround for that is (and this might work for other undiscovered bugs in the future):"
msgstr ""

#. type: delimited block -
#: en/git-update-index.txt:507
#, fuzzy, no-wrap, priority:80
msgid "$ git -c core.untrackedCache=false status\n"
msgstr "$ git -c core.untrackedCache=false status\n"

#. type: Plain text
#: en/git-update-index.txt:513
#, priority:80
msgid "This bug has also been shown to affect non-symlink cases of replacing a directory with a file when it comes to the internal structures of the untracked cache, but no case has been reported where this resulted in wrong \"git status\" output."
msgstr ""

#. type: Plain text
#: en/git-update-index.txt:519
#, priority:80
msgid "There are also cases where existing indexes written by git versions before 2.17 will reference directories that don't exist anymore, potentially causing many \"could not open directory\" warnings to be printed on \"git status\". These are new warnings for existing issues that were previously silently discarded."
msgstr ""

#. type: Plain text
#: en/git-update-index.txt:523
#, priority:80
msgid "As with the bug described above the solution is to one-off do a \"git status\" run with `core.untrackedCache=false` to flush out the leftover bad data."
msgstr ""

#. type: Title -
#: en/git-update-index.txt:525
#, no-wrap, priority:80
msgid "FILE SYSTEM MONITOR"
msgstr ""

#. type: Plain text
#: en/git-update-index.txt:529
#, priority:80
msgid "This feature is intended to speed up git operations for repos that have large working directories."
msgstr ""

#. type: Plain text
#: en/git-update-index.txt:536
#, priority:80
msgid "It enables git to work together with a file system monitor (see linkgit:git-fsmonitor{litdd}daemon[1] and the \"fsmonitor-watchman\" section of linkgit:githooks[5]) that can inform it as to what files have been modified. This enables git to avoid having to lstat() every file to find modified files."
msgstr ""

#. type: Plain text
#: en/git-update-index.txt:540
#, priority:80
msgid "When used in conjunction with the untracked cache, it can further improve performance by avoiding the cost of scanning the entire working directory looking for new files."
msgstr ""

#. type: Plain text
#: en/git-update-index.txt:548
#, priority:80
msgid "If you want to enable (or disable) this feature, it is easier to use the `core.fsmonitor` configuration variable (see linkgit:git-config[1]) than using the `--fsmonitor` option to `git update-index` in each repository, especially if you want to do so across all repositories you use, because you can set the configuration variable in your `$HOME/.gitconfig` just once and have it affect all repositories you touch."
msgstr ""

#. type: Plain text
#: en/git-update-index.txt:553
#, priority:80
msgid "When the `core.fsmonitor` configuration variable is changed, the file system monitor is added to or removed from the index the next time a command reads the index. When `--[no-]fsmonitor` are used, the file system monitor is immediately added to or removed from the index."
msgstr ""

#. type: Plain text
#: en/git-update-index.txt:564
#, no-wrap, priority:80
msgid ""
"The command honors `core.filemode` configuration variable.  If\n"
"your repository is on a filesystem whose executable bits are\n"
"unreliable, this should be set to 'false' (see linkgit:git-config[1]).\n"
"This causes the command to ignore differences in file modes recorded\n"
"in the index and the file mode on the filesystem if they differ only on\n"
"executable bit.   On such an unfortunate filesystem, you may\n"
"need to use 'git update-index --chmod='.\n"
msgstr ""

#. type: Plain text
#: en/git-update-index.txt:569
#, priority:80
msgid "Quite similarly, if `core.symlinks` configuration variable is set to 'false' (see linkgit:git-config[1]), symbolic links are checked out as plain files, and this command does not modify a recorded file mode from symbolic link to regular file."
msgstr ""

#. type: Plain text
#: en/git-update-index.txt:572
#, priority:80
msgid "The command looks at `core.ignorestat` configuration variable.  See 'Using \"assume unchanged\" bit' section above."
msgstr ""

#. type: Plain text
#: en/git-update-index.txt:577
#, priority:80
msgid "The command also looks at `core.trustctime` configuration variable.  It can be useful when the inode change time is regularly modified by something outside Git (file system crawlers and backup systems use ctime for marking files processed) (see linkgit:git-config[1])."
msgstr ""

#. type: Plain text
#: en/git-update-index.txt:581
#, priority:80
msgid "The untracked cache extension can be enabled by the `core.untrackedCache` configuration variable (see linkgit:git-config[1])."
msgstr ""

#. type: Plain text
#: en/git-update-index.txt:591
#, priority:80
msgid "Users often try to use the assume-unchanged and skip-worktree bits to tell Git to ignore changes to files that are tracked.  This does not work as expected, since Git may still check working tree files against the index when performing certain operations.  In general, Git does not provide a way to ignore changes to tracked files, so alternate solutions are recommended."
msgstr ""

#. type: Plain text
#: en/git-update-index.txt:597
#, priority:80
msgid "For example, if the file you want to change is some sort of config file, the repository can include a sample config file that can then be copied into the ignored name and modified.  The repository can even include a script to treat the sample file as a template, modifying and copying it automatically."
msgstr ""

#. type: Plain text
#: en/git-update-index.txt:603
#, ignore-same, priority:80
msgid "linkgit:git-config[1], linkgit:git-add[1], linkgit:git-ls-files[1]"
msgstr "linkgit:git-config[1], linkgit:git-add[1], linkgit:git-ls-files[1]"

#. type: Title =
#: en/git-update-ref.txt:2
#, ignore-same, no-wrap, priority:80
msgid "git-update-ref(1)"
msgstr "git-update-ref(1)"

#. type: Plain text
#: en/git-update-ref.txt:7
#, priority:80
msgid "git-update-ref - Update the object name stored in a ref safely"
msgstr ""

#. type: Plain text
#: en/git-update-ref.txt:12
#, no-wrap, priority:80
msgid "'git update-ref' [-m <reason>] [--no-deref] (-d <ref> [<oldvalue>] | [--create-reflog] <ref> <newvalue> [<oldvalue>] | --stdin [-z])\n"
msgstr ""

#. type: Plain text
#: en/git-update-ref.txt:18
#, priority:80
msgid "Given two arguments, stores the <newvalue> in the <ref>, possibly dereferencing the symbolic refs.  E.g. `git update-ref HEAD <newvalue>` updates the current branch head to the new object."
msgstr ""

#. type: Plain text
#: en/git-update-ref.txt:27
#, priority:80
msgid "Given three arguments, stores the <newvalue> in the <ref>, possibly dereferencing the symbolic refs, after verifying that the current value of the <ref> matches <oldvalue>.  E.g. `git update-ref refs/heads/master <newvalue> <oldvalue>` updates the master branch head to <newvalue> only if its current value is <oldvalue>.  You can specify 40 \"0\" or an empty string as <oldvalue> to make sure that the ref you are creating does not exist."
msgstr ""

#. type: Plain text
#: en/git-update-ref.txt:31
#, priority:80
msgid "It also allows a \"ref\" file to be a symbolic pointer to another ref file by starting with the four-byte header sequence of \"ref:\"."
msgstr ""

#. type: Plain text
#: en/git-update-ref.txt:39
#, priority:80
msgid "More importantly, it allows the update of a ref file to follow these symbolic pointers, whether they are symlinks or these \"regular file symbolic refs\".  It follows *real* symlinks only if they start with \"refs/\": otherwise it will just try to read them and update them as a regular file (i.e. it will allow the filesystem to follow them, but will overwrite such a symlink to somewhere else with a regular filename)."
msgstr ""

#. type: Plain text
#: en/git-update-ref.txt:42
#, priority:80
msgid "If --no-deref is given, <ref> itself is overwritten, rather than the result of following the symbolic pointers."
msgstr ""

#. type: Plain text
#: en/git-update-ref.txt:44
#, priority:80
msgid "In general, using"
msgstr ""

#. type: Plain text
#: en/git-update-ref.txt:46
#, no-wrap, priority:80
msgid "\tgit update-ref HEAD \"$head\"\n"
msgstr ""

#. type: Plain text
#: en/git-update-ref.txt:48
#, priority:80
msgid "should be a _lot_ safer than doing"
msgstr ""

#. type: Plain text
#: en/git-update-ref.txt:50
#, no-wrap, priority:80
msgid "\techo \"$head\" > \"$GIT_DIR/HEAD\"\n"
msgstr ""

#. type: Plain text
#: en/git-update-ref.txt:57
#, priority:80
msgid "both from a symlink following standpoint *and* an error checking standpoint.  The \"refs/\" rule for symlinks means that symlinks that point to \"outside\" the tree are safe: they'll be followed for reading but not for writing (so we'll never write through a ref symlink to some other tree, if you have copied a whole archive by creating a symlink tree)."
msgstr ""

#. type: Plain text
#: en/git-update-ref.txt:60
#, priority:80
msgid "With `-d` flag, it deletes the named <ref> after verifying it still contains <oldvalue>."
msgstr ""

#. type: Plain text
#: en/git-update-ref.txt:63
#, priority:80
msgid "With `--stdin`, update-ref reads instructions from standard input and performs all modifications together.  Specify commands of the form:"
msgstr ""

#. type: Plain text
#: en/git-update-ref.txt:73
#, no-wrap, priority:80
msgid ""
"\tupdate SP <ref> SP <newvalue> [SP <oldvalue>] LF\n"
"\tcreate SP <ref> SP <newvalue> LF\n"
"\tdelete SP <ref> [SP <oldvalue>] LF\n"
"\tverify SP <ref> [SP <oldvalue>] LF\n"
"\toption SP <opt> LF\n"
"\tstart LF\n"
"\tprepare LF\n"
"\tcommit LF\n"
"\tabort LF\n"
msgstr ""

#. type: Plain text
#: en/git-update-ref.txt:76
#, priority:80
msgid "With `--create-reflog`, update-ref will create a reflog for each ref even if one would not ordinarily be created."
msgstr ""

#. type: Plain text
#: en/git-update-ref.txt:81
#, priority:80
msgid "Quote fields containing whitespace as if they were strings in C source code; i.e., surrounded by double-quotes and with backslash escapes.  Use 40 \"0\" characters or the empty string to specify a zero value.  To specify a missing value, omit the value and its preceding SP entirely."
msgstr ""

#. type: Plain text
#: en/git-update-ref.txt:84
#, priority:80
msgid "Alternatively, use `-z` to specify in NUL-terminated format, without quoting:"
msgstr ""

#. type: Plain text
#: en/git-update-ref.txt:94
#, no-wrap, priority:80
msgid ""
"\tupdate SP <ref> NUL <newvalue> NUL [<oldvalue>] NUL\n"
"\tcreate SP <ref> NUL <newvalue> NUL\n"
"\tdelete SP <ref> NUL [<oldvalue>] NUL\n"
"\tverify SP <ref> NUL [<oldvalue>] NUL\n"
"\toption SP <opt> NUL\n"
"\tstart NUL\n"
"\tprepare NUL\n"
"\tcommit NUL\n"
"\tabort NUL\n"
msgstr ""

#. type: Plain text
#: en/git-update-ref.txt:97
#, priority:80
msgid "In this format, use 40 \"0\" to specify a zero value, and use the empty string to specify a missing value."
msgstr ""

#. type: Plain text
#: en/git-update-ref.txt:101
#, priority:80
msgid "In either format, values can be specified in any form that Git recognizes as an object name.  Commands in any other format or a repeated <ref> produce an error.  Command meanings are:"
msgstr ""

#. type: Plain text
#: en/git-update-ref.txt:107
#, priority:80
msgid "Set <ref> to <newvalue> after verifying <oldvalue>, if given.  Specify a zero <newvalue> to ensure the ref does not exist after the update and/or a zero <oldvalue> to make sure the ref does not exist before the update."
msgstr ""

#. type: Plain text
#: en/git-update-ref.txt:111
#, priority:80
msgid "Create <ref> with <newvalue> after verifying it does not exist.  The given <newvalue> may not be zero."
msgstr ""

#. type: Labeled list
#: en/git-update-ref.txt:112
#, ignore-same, no-wrap, priority:80
msgid "delete"
msgstr "delete"

#. type: Plain text
#: en/git-update-ref.txt:115
#, priority:80
msgid "Delete <ref> after verifying it exists with <oldvalue>, if given.  If given, <oldvalue> may not be zero."
msgstr ""

#. type: Labeled list
#: en/git-update-ref.txt:116
#, ignore-same, no-wrap, priority:80
msgid "verify"
msgstr "verify"

#. type: Plain text
#: en/git-update-ref.txt:119
#, priority:80
msgid "Verify <ref> against <oldvalue> but do not change it.  If <oldvalue> is zero or missing, the ref must not exist."
msgstr ""

#. type: Labeled list
#: en/git-update-ref.txt:120
#, ignore-same, no-wrap, priority:80
msgid "option"
msgstr "option"

#. type: Plain text
#: en/git-update-ref.txt:124
#, priority:80
msgid "Modify behavior of the next command naming a <ref>.  The only valid option is `no-deref` to avoid dereferencing a symbolic ref."
msgstr ""

#. type: Plain text
#: en/git-update-ref.txt:130
#, priority:80
msgid "Start a transaction. In contrast to a non-transactional session, a transaction will automatically abort if the session ends without an explicit commit. This command may create a new empty transaction when the current one has been committed or aborted already."
msgstr ""

#. type: Labeled list
#: en/git-update-ref.txt:131
#, fuzzy, no-wrap, priority:80
msgid "prepare"
msgstr "准备"

#. type: Plain text
#: en/git-update-ref.txt:135
#, priority:80
msgid "Prepare to commit the transaction. This will create lock files for all queued reference updates. If one reference could not be locked, the transaction will be aborted."
msgstr ""

#. type: Plain text
#: en/git-update-ref.txt:139
#, priority:80
msgid "Commit all reference updates queued for the transaction, ending the transaction."
msgstr ""

#. type: Labeled list
#: en/git-update-ref.txt:140
#, fuzzy, no-wrap, priority:80
#| msgid "--abort"
msgid "abort"
msgstr "中止"

#. type: Plain text
#: en/git-update-ref.txt:143
#, priority:80
msgid "Abort the transaction, releasing all locks if the transaction is in prepared state."
msgstr ""

#. type: Plain text
#: en/git-update-ref.txt:149
#, priority:80
msgid "If all <ref>s can be locked with matching <oldvalue>s simultaneously, all modifications are performed.  Otherwise, no modifications are performed.  Note that while each individual <ref> is updated or deleted atomically, a concurrent reader may still see a subset of the modifications."
msgstr ""

#. type: Title -
#: en/git-update-ref.txt:151
#, no-wrap, priority:80
msgid "LOGGING UPDATES"
msgstr ""

#. type: Plain text
#: en/git-update-ref.txt:159
#, priority:80
msgid "If config parameter \"core.logAllRefUpdates\" is true and the ref is one under \"refs/heads/\", \"refs/remotes/\", \"refs/notes/\", or a pseudoref like HEAD or ORIG_HEAD; or the file \"$GIT_DIR/logs/<ref>\" exists then `git update-ref` will append a line to the log file \"$GIT_DIR/logs/<ref>\" (dereferencing all symbolic refs before creating the log name) describing the change in ref value.  Log lines are formatted as:"
msgstr ""

#. type: Plain text
#: en/git-update-ref.txt:161
#, fuzzy, no-wrap, priority:80
msgid "    oldsha1 SP newsha1 SP committer LF\n"
msgstr "    oldsha1 SP newsha1 SP committer LF\n"

#. type: Plain text
#: en/git-update-ref.txt:166
#, priority:80
msgid "Where \"oldsha1\" is the 40 character hexadecimal value previously stored in <ref>, \"newsha1\" is the 40 character hexadecimal value of <newvalue> and \"committer\" is the committer's name, email address and date in the standard Git committer ident format."
msgstr ""

#. type: Plain text
#: en/git-update-ref.txt:168
#, priority:80
msgid "Optionally with -m:"
msgstr ""

#. type: Plain text
#: en/git-update-ref.txt:170
#, no-wrap, priority:80
msgid "    oldsha1 SP newsha1 SP committer TAB message LF\n"
msgstr ""

#. type: Plain text
#: en/git-update-ref.txt:173
#, priority:80
msgid "Where all fields are as described above and \"message\" is the value supplied to the -m option."
msgstr ""

#. type: Plain text
#: en/git-update-ref.txt:177
#, priority:80
msgid "An update will fail (without changing <ref>) if the current user is unable to create a new log file, append to the existing log file or does not have committer information available."
msgstr ""

#. type: Title =
#: en/git-update-server-info.txt:2
#, ignore-same, no-wrap, priority:90
msgid "git-update-server-info(1)"
msgstr "git-update-server-info(1)"

#. type: Plain text
#: en/git-update-server-info.txt:7
#, priority:90
msgid "git-update-server-info - Update auxiliary info file to help dumb servers"
msgstr ""

#. type: Plain text
#: en/git-update-server-info.txt:13
#, fuzzy, no-wrap, priority:90
msgid "'git update-server-info' [-f | --force]\n"
msgstr "'git update-server-info'\n"

#. type: Plain text
#: en/git-update-server-info.txt:21
#, priority:90
msgid "A dumb server that does not do on-the-fly pack generations must have some auxiliary information files in $GIT_DIR/info and $GIT_OBJECT_DIRECTORY/info directories to help clients discover what references and packs the server has.  This command generates such auxiliary files."
msgstr ""

#. type: Plain text
#: en/git-update-server-info.txt:27
#, priority:90
msgid "update the info files from scratch."
msgstr ""

#. type: Plain text
#: en/git-update-server-info.txt:34
#, priority:90
msgid "Currently the command updates the following files.  Please see linkgit:gitrepository-layout[5] for description of what they are for:"
msgstr ""

#. type: Plain text
#: en/git-update-server-info.txt:36
#, priority:90
msgid "objects/info/packs"
msgstr ""

#. type: Plain text
#: en/git-update-server-info.txt:38
#, priority:90
msgid "info/refs"
msgstr ""

#. type: Title =
#: en/git-upload-archive.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-upload-archive(1)"
msgstr "git-upload-archive(1)"

#. type: Plain text
#: en/git-upload-archive.txt:7
#, fuzzy, priority:100
msgid "git-upload-archive - Send archive back to git-archive"
msgstr "git-upload-archive - Send archive back to git-archive"

#. type: Plain text
#: en/git-upload-archive.txt:13
#, fuzzy, no-wrap, priority:100
msgid "'git upload-archive' <repository>\n"
msgstr "'git-receive-pack' <directory>\n"

#. type: Plain text
#: en/git-upload-archive.txt:18
#, priority:100
msgid "Invoked by 'git archive --remote' and sends a generated archive to the other end over the Git protocol."
msgstr ""

#. type: Plain text
#: en/git-upload-archive.txt:22
#, priority:100
msgid "This command is usually not invoked directly by the end user.  The UI for the protocol is on the 'git archive' side, and the program pair is meant to be used to get an archive from a remote repository."
msgstr ""

#. type: Title -
#: en/git-upload-archive.txt:24 en/transfer-data-leaks.txt:2
#, fuzzy, no-wrap, priority:220
msgid "SECURITY"
msgstr "安全性保护"

#. type: Plain text
#: en/git-upload-archive.txt:32
#, priority:100
msgid "In order to protect the privacy of objects that have been removed from history but may not yet have been pruned, `git-upload-archive` avoids serving archives for commits and trees that are not reachable from the repository's refs.  However, because calculating object reachability is computationally expensive, `git-upload-archive` implements a stricter but easier-to-check set of rules:"
msgstr ""

#. type: Plain text
#: en/git-upload-archive.txt:35
#, priority:100
msgid "Clients may request a commit or tree that is pointed to directly by a ref. E.g., `git archive --remote=origin v1.0`."
msgstr ""

#. type: Plain text
#: en/git-upload-archive.txt:38
#, priority:100
msgid "Clients may request a sub-tree within a commit or tree using the `ref:path` syntax. E.g., `git archive --remote=origin v1.0:Documentation`."
msgstr ""

#. type: Plain text
#: en/git-upload-archive.txt:43
#, priority:100
msgid "Clients may _not_ use other sha1 expressions, even if the end result is reachable. E.g., neither a relative commit like `master^` nor a literal sha1 like `abcd1234` is allowed, even if the result is reachable from the refs."
msgstr ""

#. type: Plain text
#: en/git-upload-archive.txt:48
#, priority:100
msgid "Note that rule 3 disallows many cases that do not have any privacy implications. These rules are subject to change in future versions of git, and the server accessed by `git archive --remote` may or may not follow these exact rules."
msgstr ""

#. type: Plain text
#: en/git-upload-archive.txt:54
#, priority:100
msgid "If the config option `uploadArchive.allowUnreachable` is true, these rules are ignored, and clients may use arbitrary sha1 expressions.  This is useful if you do not care about the privacy of unreachable objects, or if your object database is already publicly available for access via non-smart-http."
msgstr ""

#. type: Plain text
#: en/git-upload-archive.txt:59
#, priority:100
msgid "The repository to get a tar archive from."
msgstr ""

#. type: Title =
#: en/git-upload-pack.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-upload-pack(1)"
msgstr "git-upload-pack(1)"

#. type: Plain text
#: en/git-upload-pack.txt:7
#, fuzzy, priority:100
msgid "git-upload-pack - Send objects packed back to git-fetch-pack"
msgstr "git-upload-pack - Send objects packed back to git-fetch-pack"

#. type: Plain text
#: en/git-upload-pack.txt:14
#, no-wrap, priority:100
msgid ""
"'git-upload-pack' [--[no-]strict] [--timeout=<n>] [--stateless-rpc]\n"
"\t\t  [--advertise-refs] <directory>\n"
msgstr ""

#. type: Plain text
#: en/git-upload-pack.txt:19
#, priority:100
msgid "Invoked by 'git fetch-pack', learns what objects the other side is missing, and sends them after packing."
msgstr ""

#. type: Plain text
#: en/git-upload-pack.txt:24
#, priority:100
msgid "This command is usually not invoked directly by the end user.  The UI for the protocol is on the 'git fetch-pack' side, and the program pair is meant to be used to pull updates from a remote repository.  For push operations, see 'git send-pack'."
msgstr ""

#. type: Labeled list
#: en/git-upload-pack.txt:28
#, ignore-same, no-wrap, priority:100
msgid "--[no-]strict"
msgstr "--[no-]strict"

#. type: Plain text
#: en/git-upload-pack.txt:30
#, priority:100
msgid "Do not try <directory>/.git/ if <directory> is no Git directory."
msgstr "如果<directory>不是git目录，请不要尝试<directory>/.git/。"

#. type: Plain text
#: en/git-upload-pack.txt:33
#, priority:100
msgid "Interrupt transfer after <n> seconds of inactivity."
msgstr "<n> 秒不活动后中断传输。"

#. type: Labeled list
#: en/git-upload-pack.txt:34
#, ignore-same, no-wrap, priority:100
msgid "--stateless-rpc"
msgstr "--stateless-rpc"

#. type: Plain text
#: en/git-upload-pack.txt:38
#, priority:100
msgid "Perform only a single read-write cycle with stdin and stdout.  This fits with the HTTP POST request processing model where a program may read the request, write a response, and must exit."
msgstr ""

#. type: Plain text
#: en/git-upload-pack.txt:46
#, priority:100
msgid "Used by linkgit:git-http-backend[1] to serve up `$GIT_URL/info/refs?service=git-upload-pack` requests. See \"Smart Clients\" in linkgit:gitprotocol-http[5] and \"HTTP Transport\" in the linkgit:gitprotocol-v2[5] documentation. Also understood by linkgit:git-receive-pack[1]."
msgstr ""

#. type: Plain text
#: en/git-upload-pack.txt:49
#, priority:100
msgid "The repository to sync from."
msgstr ""

#. type: Plain text
#: en/git-upload-pack.txt:57
#, priority:100
msgid "Internal variable used for handshaking the wire protocol. Server admins may need to configure some transports to allow this variable to be passed. See the discussion in linkgit:git[1]."
msgstr ""

#. type: Title =
#: en/git-var.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-var(1)"
msgstr "git-var(1)"

#. type: Plain text
#: en/git-var.txt:7
#, priority:100
msgid "git-var - Show a Git logical variable"
msgstr ""

#. type: Plain text
#: en/git-var.txt:13
#, fuzzy, no-wrap, priority:100
msgid "'git var' (-l | <variable>)\n"
msgstr "'git var' ( -l | <variable> )\n"

#. type: Plain text
#: en/git-var.txt:18
#, priority:100
msgid "Prints a Git logical variable. Exits with code 1 if the variable has no value."
msgstr ""

#. type: Plain text
#: en/git-var.txt:26
#, priority:100
msgid "Cause the logical variables to be listed. In addition, all the variables of the Git configuration file .git/config are listed as well. (However, the configuration variables listing functionality is deprecated in favor of `git config -l`.)"
msgstr ""

#. type: Plain text
#: en/git-var.txt:31
#, fuzzy, no-wrap, priority:100
msgid ""
"\t$ git var GIT_AUTHOR_IDENT\n"
"\tEric W. Biederman <ebiederm@lnxi.com> 1121223278 -0600\n"
msgstr ""
"\t$ git var GIT_AUTHOR_IDENT\n"
"\tEric W. Biederman <ebiederm@lnxi.com> 1121223278 -0600\n"

#. type: Title -
#: en/git-var.txt:34
#, no-wrap, priority:100
msgid "VARIABLES"
msgstr ""

#. type: Labeled list
#: en/git-var.txt:35
#, ignore-same, no-wrap, priority:100
msgid "GIT_AUTHOR_IDENT"
msgstr "GIT_AUTHOR_IDENT"

#. type: Plain text
#: en/git-var.txt:37
#, priority:100
msgid "The author of a piece of code."
msgstr ""

#. type: Labeled list
#: en/git-var.txt:38
#, ignore-same, no-wrap, priority:100
msgid "GIT_COMMITTER_IDENT"
msgstr "GIT_COMMITTER_IDENT"

#. type: Plain text
#: en/git-var.txt:40
#, priority:100
msgid "The person who put a piece of code into Git."
msgstr ""

#. type: Labeled list
#: en/git-var.txt:41
#, ignore-same, no-wrap, priority:100
msgid "GIT_EDITOR"
msgstr "GIT_EDITOR"

#. type: Plain text
#: en/git-var.txt:49
#, priority:100
msgid "Text editor for use by Git commands.  The value is meant to be interpreted by the shell when it is used.  Examples: `~/bin/vi`, `$SOME_ENVIRONMENT_VARIABLE`, `\"C:\\Program Files\\Vim\\gvim.exe\" --nofork`.  The order of preference is the `$GIT_EDITOR` environment variable, then `core.editor` configuration, then `$VISUAL`, then `$EDITOR`, and then the default chosen at compile time, which is usually 'vi'."
msgstr ""

#. type: Plain text
#: en/git-var.txt:51
#, no-wrap, priority:100
msgid "    The build you are using chose '{git-default-editor}' as the default.\n"
msgstr ""

#. type: Labeled list
#: en/git-var.txt:53
#, ignore-same, no-wrap, priority:100
msgid "GIT_SEQUENCE_EDITOR"
msgstr "GIT_SEQUENCE_EDITOR"

#. type: Plain text
#: en/git-var.txt:60
#, priority:100
msgid "Text editor used to edit the 'todo' file while running `git rebase -i`. Like `GIT_EDITOR`, the value is meant to be interpreted by the shell when it is used. The order of preference is the `$GIT_SEQUENCE_EDITOR` environment variable, then `sequence.editor` configuration, and then the value of `git var GIT_EDITOR`."
msgstr ""

#. type: Labeled list
#: en/git-var.txt:61
#, ignore-same, no-wrap, priority:100
msgid "GIT_PAGER"
msgstr "GIT_PAGER"

#. type: Plain text
#: en/git-var.txt:67
#, priority:100
msgid "Text viewer for use by Git commands (e.g., 'less').  The value is meant to be interpreted by the shell.  The order of preference is the `$GIT_PAGER` environment variable, then `core.pager` configuration, then `$PAGER`, and then the default chosen at compile time (usually 'less')."
msgstr ""

#. type: Plain text
#: en/git-var.txt:69
#, no-wrap, priority:100
msgid "    The build you are using chose '{git-default-pager}' as the default.\n"
msgstr ""

#. type: Labeled list
#: en/git-var.txt:71
#, ignore-same, no-wrap, priority:100
msgid "GIT_DEFAULT_BRANCH"
msgstr "GIT_DEFAULT_BRANCH"

#. type: Plain text
#: en/git-var.txt:73
#, priority:100
msgid "The name of the first branch created in newly initialized repositories."
msgstr ""

#. type: Labeled list
#: en/git-var.txt:74
#, ignore-same, no-wrap, priority:100
msgid "GIT_SHELL_PATH"
msgstr "GIT_SHELL_PATH"

#. type: Plain text
#: en/git-var.txt:76
#, priority:100
msgid "The path of the binary providing the POSIX shell for commands which use the shell."
msgstr ""

#. type: Labeled list
#: en/git-var.txt:77
#, ignore-same, no-wrap, priority:100
msgid "GIT_ATTR_SYSTEM"
msgstr "GIT_ATTR_SYSTEM"

#. type: Plain text
#: en/git-var.txt:79
#, priority:100
msgid "The path to the system linkgit:gitattributes[5] file, if one is enabled."
msgstr ""

#. type: Labeled list
#: en/git-var.txt:80
#, ignore-same, no-wrap, priority:100
msgid "GIT_ATTR_GLOBAL"
msgstr "GIT_ATTR_GLOBAL"

#. type: Plain text
#: en/git-var.txt:82
#, priority:100
msgid "The path to the global (per-user) linkgit:gitattributes[5] file."
msgstr ""

#. type: Plain text
#: en/git-var.txt:85
#, priority:100
msgid "The path to the system configuration file, if one is enabled."
msgstr ""

#. type: Plain text
#: en/git-var.txt:88
#, priority:100
msgid "The path to the global (per-user) configuration files, if any."
msgstr ""

#. type: Plain text
#: en/git-var.txt:93
#, priority:100
msgid "Most path values contain only one value. However, some can contain multiple values, which are separated by newlines, and are listed in order from highest to lowest priority.  Callers should be prepared for any such path value to contain multiple items."
msgstr ""

#. type: Plain text
#: en/git-var.txt:96
#, priority:100
msgid "Note that paths are printed even if they do not exist, but not if they are disabled by other environment variables."
msgstr ""

#. type: Plain text
#: en/git-var.txt:102
#, ignore-same, priority:100
msgid "linkgit:git-commit-tree[1] linkgit:git-tag[1] linkgit:git-config[1]"
msgstr "linkgit:git-commit-tree[1] linkgit:git-tag[1] linkgit:git-config[1]"

#. type: Title =
#: en/git-verify-commit.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-verify-commit(1)"
msgstr "git-verify-commit(1)"

#. type: Plain text
#: en/git-verify-commit.txt:7
#, priority:100
msgid "git-verify-commit - Check the GPG signature of commits"
msgstr ""

#. type: Plain text
#: en/git-verify-commit.txt:12
#, fuzzy, ignore-ellipsis, no-wrap, priority:100
msgid "'git verify-commit' [-v | --verbose] [--raw] <commit>...\n"
msgstr "'git verify-commit' <commit>...\n"

#. type: Plain text
#: en/git-verify-commit.txt:16
#, priority:100
msgid "Validates the GPG signature created by 'git commit -S'."
msgstr ""

#. type: Plain text
#: en/git-verify-commit.txt:22 en/git-verify-tag.txt:22
#, priority:100
msgid "Print the raw gpg status output to standard error instead of the normal human-readable output."
msgstr ""

#. type: Plain text
#: en/git-verify-commit.txt:26
#, priority:100
msgid "Print the contents of the commit object before validating it."
msgstr ""

#. type: Plain text
#: en/git-verify-commit.txt:29
#, priority:100
msgid "SHA-1 identifiers of Git commit objects."
msgstr ""

#. type: Title =
#: en/git-verify-pack.txt:2
#, ignore-same, no-wrap, priority:80
msgid "git-verify-pack(1)"
msgstr "git-verify-pack(1)"

#. type: Plain text
#: en/git-verify-pack.txt:7
#, priority:80
msgid "git-verify-pack - Validate packed Git archive files"
msgstr ""

#. type: Plain text
#: en/git-verify-pack.txt:13
#, fuzzy, ignore-ellipsis, no-wrap, priority:80
msgid "'git verify-pack' [-v | --verbose] [-s | --stat-only] [--] <pack>.idx...\n"
msgstr "'git verify-pack' [-v|--verbose] [-s|--stat-only] [--] <pack>.idx ...\n"

#. type: Plain text
#: en/git-verify-pack.txt:20
#, priority:80
msgid "Reads given idx file for packed Git archive created with the 'git pack-objects' command and verifies idx file and the corresponding pack file."
msgstr ""

#. type: Labeled list
#: en/git-verify-pack.txt:23
#, fuzzy, ignore-ellipsis, no-wrap, priority:80
msgid "<pack>.idx ..."
msgstr "<pack>.idx ..."

#. type: Plain text
#: en/git-verify-pack.txt:25
#, priority:80
msgid "The idx files to verify."
msgstr ""

#. type: Plain text
#: en/git-verify-pack.txt:30
#, priority:80
msgid "After verifying the pack, show list of objects contained in the pack and a histogram of delta chain length."
msgstr ""

#. type: Labeled list
#: en/git-verify-pack.txt:32
#, ignore-same, no-wrap, priority:80
msgid "--stat-only"
msgstr "--stat-only"

#. type: Plain text
#: en/git-verify-pack.txt:35
#, priority:80
msgid "Do not verify the pack contents; only show the histogram of delta chain length.  With `--verbose`, list of objects is also shown."
msgstr ""

#. type: Title -
#: en/git-verify-pack.txt:40
#, no-wrap, priority:80
msgid "OUTPUT FORMAT"
msgstr ""

#. type: Plain text
#: en/git-verify-pack.txt:42
#, priority:80
msgid "When specifying the -v option the format used is:"
msgstr ""

#. type: Plain text
#: en/git-verify-pack.txt:44
#, no-wrap, priority:80
msgid "\tSHA-1 type size size-in-packfile offset-in-packfile\n"
msgstr ""

#. type: Plain text
#: en/git-verify-pack.txt:46
#, priority:80
msgid "for objects that are not deltified in the pack, and"
msgstr ""

#. type: Plain text
#: en/git-verify-pack.txt:48
#, no-wrap, priority:80
msgid "\tSHA-1 type size size-in-packfile offset-in-packfile depth base-SHA-1\n"
msgstr ""

#. type: Plain text
#: en/git-verify-pack.txt:50
#, priority:80
msgid "for objects that are deltified."
msgstr ""

#. type: Title =
#: en/git-verify-tag.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-verify-tag(1)"
msgstr "git-verify-tag(1)"

#. type: Plain text
#: en/git-verify-tag.txt:7
#, priority:100
msgid "git-verify-tag - Check the GPG signature of tags"
msgstr ""

#. type: Plain text
#: en/git-verify-tag.txt:12
#, fuzzy, ignore-ellipsis, no-wrap, priority:100
msgid "'git verify-tag' [-v | --verbose] [--format=<format>] [--raw] <tag>...\n"
msgstr "'git verify-tag' [--format=<format>] <tag>...\n"

#. type: Plain text
#: en/git-verify-tag.txt:16
#, priority:100
msgid "Validates the gpg signature created by 'git tag'."
msgstr ""

#. type: Plain text
#: en/git-verify-tag.txt:26
#, priority:100
msgid "Print the contents of the tag object before validating it."
msgstr ""

#. type: Labeled list
#: en/git-verify-tag.txt:27
#, ignore-ellipsis, no-wrap, priority:100
msgid "<tag>..."
msgstr ""

#. type: Plain text
#: en/git-verify-tag.txt:29
#, priority:100
msgid "SHA-1 identifiers of Git tag objects."
msgstr ""

#. type: Title =
#: en/git-web--browse.txt:2
#, no-wrap, priority:100
msgid "git-web{litdd}browse(1)"
msgstr ""

#. type: Plain text
#: en/git-web--browse.txt:7
#, fuzzy, priority:100
msgid "git-web--browse - Git helper script to launch a web browser"
msgstr "git-web--browse - Git helper script to launch a web browser"

#. type: Plain text
#: en/git-web--browse.txt:12
#, fuzzy, ignore-ellipsis, no-wrap, priority:100
msgid "'git web{litdd}browse' [<options>] (<URL>|<file>)...\n"
msgstr "'git rev-parse' [<options>] <args>...\n"

#. type: Plain text
#: en/git-web--browse.txt:19
#, priority:100
msgid "This script tries, as much as possible, to display the URLs and FILEs that are passed as arguments, as HTML pages in new tabs on an already opened web browser."
msgstr ""

#. type: Plain text
#: en/git-web--browse.txt:21
#, priority:100
msgid "The following browsers (or commands) are currently supported:"
msgstr ""

#. type: Plain text
#: en/git-web--browse.txt:23
#, priority:100
msgid "firefox (this is the default under X Window when not using KDE)"
msgstr ""

#. type: Plain text
#: en/git-web--browse.txt:24
#, priority:100
msgid "iceweasel"
msgstr ""

#. type: Plain text
#: en/git-web--browse.txt:25
#, fuzzy, priority:100
msgid "seamonkey"
msgstr "seamonkey"

#. type: Plain text
#: en/git-web--browse.txt:26
#, priority:100
msgid "iceape"
msgstr ""

#. type: Plain text
#: en/git-web--browse.txt:27
#, priority:100
msgid "chromium (also supported as chromium-browser)"
msgstr ""

#. type: Plain text
#: en/git-web--browse.txt:28
#, priority:100
msgid "google-chrome (also supported as chrome)"
msgstr ""

#. type: Plain text
#: en/git-web--browse.txt:29
#, priority:100
msgid "konqueror (this is the default under KDE, see 'Note about konqueror' below)"
msgstr ""

#. type: Plain text
#: en/git-web--browse.txt:30
#, fuzzy, priority:100
msgid "opera"
msgstr "歌剧"

#. type: Plain text
#: en/git-web--browse.txt:31
#, fuzzy, priority:100
msgid "w3m (this is the default outside graphical environments)"
msgstr "w3m (this is the default outside graphical environments)"

#. type: Plain text
#: en/git-web--browse.txt:32
#, priority:100
msgid "elinks"
msgstr ""

#. type: Plain text
#: en/git-web--browse.txt:33
#, fuzzy, priority:100
msgid "links"
msgstr "链接"

#. type: Plain text
#: en/git-web--browse.txt:34
#, fuzzy, priority:100
msgid "lynx"
msgstr "猞猁"

#. type: Plain text
#: en/git-web--browse.txt:35
#, priority:100
msgid "dillo"
msgstr ""

#. type: Plain text
#: en/git-web--browse.txt:36
#, priority:100
msgid "open (this is the default under Mac OS X GUI)"
msgstr ""

#. type: Plain text
#: en/git-web--browse.txt:37
#, priority:100
msgid "start (this is the default under MinGW)"
msgstr ""

#. type: Plain text
#: en/git-web--browse.txt:38
#, priority:100
msgid "cygstart (this is the default under Cygwin)"
msgstr ""

#. type: Plain text
#: en/git-web--browse.txt:39
#, fuzzy, priority:100
msgid "xdg-open"
msgstr "xdg-open"

#. type: Plain text
#: en/git-web--browse.txt:41
#, priority:100
msgid "Custom commands may also be specified."
msgstr ""

#. type: Labeled list
#: en/git-web--browse.txt:44
#, fuzzy, no-wrap, priority:100
msgid "-b <browser>"
msgstr "-b <browser>"

#. type: Labeled list
#: en/git-web--browse.txt:45
#, fuzzy, no-wrap, priority:100
msgid "--browser=<browser>"
msgstr "--browser=<browser>"

#. type: Plain text
#: en/git-web--browse.txt:48
#, priority:100
msgid "Use the specified browser. It must be in the list of supported browsers."
msgstr ""

#. type: Labeled list
#: en/git-web--browse.txt:49
#, fuzzy, no-wrap, priority:100
msgid "-t <browser>"
msgstr "-t <browser>"

#. type: Labeled list
#: en/git-web--browse.txt:50
#, fuzzy, no-wrap, priority:100
msgid "--tool=<browser>"
msgstr "--tool=<browser>"

#. type: Labeled list
#: en/git-web--browse.txt:53
#, no-wrap, priority:100
msgid "-c <conf.var>"
msgstr ""

#. type: Labeled list
#: en/git-web--browse.txt:54
#, fuzzy, no-wrap, priority:100
msgid "--config=<conf.var>"
msgstr "--config=<conf.var>"

#. type: Plain text
#: en/git-web--browse.txt:57
#, priority:100
msgid "CONF.VAR is looked up in the Git config files. If it's set, then its value specifies the browser that should be used."
msgstr ""

#. type: Title ~
#: en/git-web--browse.txt:62
#, no-wrap, priority:100
msgid "CONF.VAR (from -c option) and web.browser"
msgstr ""

#. type: Plain text
#: en/git-web--browse.txt:67
#, priority:100
msgid "The web browser can be specified using a configuration variable passed with the -c (or --config) command-line option, or the `web.browser` configuration variable if the former is not used."
msgstr ""

#. type: Title ~
#: en/git-web--browse.txt:69
#, no-wrap, priority:100
msgid "browser.<tool>.path"
msgstr ""

#. type: Plain text
#: en/git-web--browse.txt:76
#, priority:100
msgid "You can explicitly provide a full path to your preferred browser by setting the configuration variable `browser.<tool>.path`. For example, you can configure the absolute path to firefox by setting 'browser.firefox.path'. Otherwise, 'git web{litdd}browse' assumes the tool is available in PATH."
msgstr ""

#. type: Title ~
#: en/git-web--browse.txt:78
#, no-wrap, priority:100
msgid "browser.<tool>.cmd"
msgstr ""

#. type: Plain text
#: en/git-web--browse.txt:86
#, priority:100
msgid "When the browser, specified by options or configuration variables, is not among the supported ones, then the corresponding `browser.<tool>.cmd` configuration variable will be looked up. If this variable exists then 'git web{litdd}browse' will treat the specified tool as a custom command and will use a shell eval to run the command with the URLs passed as arguments."
msgstr ""

#. type: Title -
#: en/git-web--browse.txt:88
#, no-wrap, priority:100
msgid "NOTE ABOUT KONQUEROR"
msgstr ""

#. type: Plain text
#: en/git-web--browse.txt:93
#, priority:100
msgid "When 'konqueror' is specified by a command-line option or a configuration variable, we launch 'kfmclient' to try to open the HTML man page on an already opened konqueror in a new tab if possible."
msgstr ""

#. type: Plain text
#: en/git-web--browse.txt:97
#, priority:100
msgid "For consistency, we also try such a trick if 'browser.konqueror.path' is set to something like `A_PATH_TO/konqueror`. That means we will try to launch `A_PATH_TO/kfmclient` instead."
msgstr ""

#. type: delimited block -
#: en/git-web--browse.txt:104
#, fuzzy, no-wrap, priority:100
msgid ""
"\t[web]\n"
"\t\tbrowser = konq\n"
msgstr ""
"\t[web]\n"
"\t\tbrowser = konq\n"

#. type: delimited block -
#: en/git-web--browse.txt:107
#, fuzzy, no-wrap, priority:100
msgid ""
"\t[browser \"konq\"]\n"
"\t\tcmd = A_PATH_TO/konqueror\n"
msgstr ""
"\t[browser \"konq\"]\n"
"\t\tcmd = A_PATH_TO/konqueror\n"

#. type: Title ~
#: en/git-web--browse.txt:110
#, no-wrap, priority:100
msgid "Note about git-config --global"
msgstr ""

#. type: Plain text
#: en/git-web--browse.txt:114
#, priority:100
msgid "Note that these configuration variables should probably be set using the `--global` flag, for example like this:"
msgstr ""

#. type: delimited block -
#: en/git-web--browse.txt:117
#, fuzzy, no-wrap, priority:100
msgid "$ git config --global web.browser firefox\n"
msgstr "$ git config --global web.browser firefox\n"

#. type: Title =
#: en/git-whatchanged.txt:2
#, ignore-same, no-wrap, priority:100
msgid "git-whatchanged(1)"
msgstr "git-whatchanged(1)"

#. type: Plain text
#: en/git-whatchanged.txt:7
#, priority:100
msgid "git-whatchanged - Show logs with difference each commit introduces"
msgstr ""

#. type: Plain text
#: en/git-whatchanged.txt:13
#, ignore-ellipsis, no-wrap, priority:100
msgid "'git whatchanged' <option>...\n"
msgstr ""

#. type: Plain text
#: en/git-whatchanged.txt:18
#, priority:100
msgid "Shows commit logs and diff output each commit introduces."
msgstr ""

#. type: Plain text
#: en/git-whatchanged.txt:22
#, priority:100
msgid "New users are encouraged to use linkgit:git-log[1] instead.  The `whatchanged` command is essentially the same as linkgit:git-log[1] but defaults to show the raw format diff output and to skip merges."
msgstr ""

#. type: Plain text
#: en/git-whatchanged.txt:26
#, priority:100
msgid "The command is kept primarily for historical reasons; fingers of many people who learned Git long before `git log` was invented by reading Linux kernel mailing list are trained to type it."
msgstr ""

#. type: Labeled list
#: en/git-whatchanged.txt:30
#, fuzzy, no-wrap, priority:100
msgid "`git whatchanged -p v2.6.12.. include/scsi drivers/scsi`"
msgstr "`git whatchanged -p v2.6.12.. include/scsi drivers/scsi`"

#. type: Plain text
#: en/git-whatchanged.txt:34
#, priority:100
msgid "Show as patches the commits since version 'v2.6.12' that changed any file in the include/scsi or drivers/scsi subdirectories"
msgstr ""

#. type: Labeled list
#: en/git-whatchanged.txt:35
#, no-wrap, priority:100
msgid "`git whatchanged --since=\"2 weeks ago\" -- gitk`"
msgstr ""

#. type: Plain text
#: en/git-whatchanged.txt:40
#, priority:100
msgid "Show the changes during the last two weeks to the file 'gitk'.  The \"--\" is necessary to avoid confusion with the *branch* named 'gitk'"
msgstr ""

#. type: Title =
#: en/git-worktree.txt:2
#, ignore-same, no-wrap, priority:240
msgid "git-worktree(1)"
msgstr "git-worktree(1)"

#. type: Plain text
#: en/git-worktree.txt:7
#, priority:240
msgid "git-worktree - Manage multiple working trees"
msgstr "git-worktree - 管理多个工作区"

#. type: Plain text
#: en/git-worktree.txt:21
#, fuzzy, ignore-ellipsis, no-wrap, priority:240
#| msgid ""
#| "'git worktree add' [-f] [--detach] [--checkout] [--lock [--reason <string>]]\n"
#| "\t\t   [-b <new-branch>] <path> [<commit-ish>]\n"
#| "'git worktree list' [-v | --porcelain [-z]]\n"
#| "'git worktree lock' [--reason <string>] <worktree>\n"
#| "'git worktree move' <worktree> <new-path>\n"
#| "'git worktree prune' [-n] [-v] [--expire <expire>]\n"
#| "'git worktree remove' [-f] <worktree>\n"
#| "'git worktree repair' [<path>...]\n"
#| "'git worktree unlock' <worktree>\n"
msgid ""
"'git worktree add' [-f] [--detach] [--checkout] [--lock [--reason <string>]]\n"
"\t\t   [--orphan] [(-b | -B) <new-branch>] <path> [<commit-ish>]\n"
"'git worktree list' [-v | --porcelain [-z]]\n"
"'git worktree lock' [--reason <string>] <worktree>\n"
"'git worktree move' <worktree> <new-path>\n"
"'git worktree prune' [-n] [-v] [--expire <expire>]\n"
"'git worktree remove' [-f] <worktree>\n"
"'git worktree repair' [<path>...]\n"
"'git worktree unlock' <worktree>\n"
msgstr ""
"'git worktree add' [-f] [--detach] [--checkout] [--lock [--reason <字符串>]]\n"
"\t\t   [-b <新分支>] <路径> [<提交号>]\n"
"'git worktree list' [-v | --porcelain [-z]]\n"
"'git worktree lock' [--reason <字符串>] <工作区>\n"
"'git worktree move' <工作区> <新分支>\n"
"'git worktree prune' [-n] [-v] [--expire <到期>]\n"
"'git worktree remove' [-f] <工作区>\n"
"'git worktree repair' [<路径>...]\n"
"'git worktree unlock' <工作区>\n"

#. type: Plain text
#: en/git-worktree.txt:26
#, priority:240
msgid "Manage multiple working trees attached to the same repository."
msgstr "管理附属于同一仓库的多个工作区。"

#. type: Plain text
#: en/git-worktree.txt:32
#, priority:240
msgid "A git repository can support multiple working trees, allowing you to check out more than one branch at a time.  With `git worktree add` a new working tree is associated with the repository, along with additional metadata that differentiates that working tree from others in the same repository.  The working tree, along with this metadata, is called a \"worktree\"."
msgstr "一个 git 仓库可以支持多个工作区，允许你一次签出多个分支。  通过`git worktree add`，一个新的工作区与仓库相关联，同时还有额外的元数据，以区分该工作区与同一仓库中的其他工作区。  工作区目录树，连同这些元数据，被称为 \"工作区\"。"

#. type: Plain text
#: en/git-worktree.txt:38
#, priority:240
msgid "This new worktree is called a \"linked worktree\" as opposed to the \"main worktree\" prepared by linkgit:git-init[1] or linkgit:git-clone[1].  A repository has one main worktree (if it's not a bare repository) and zero or more linked worktrees. When you are done with a linked worktree, remove it with `git worktree remove`."
msgstr "这个新的工作区被称为 \"链接工作区\"，与 linkgit:git-init[1] 或 linkgit:git-clone[1] 所准备的 \"主工作区 \"相对应。  一个仓库有一个主工作区（如果它不是一个裸仓库）和零个或多个链接工作区。当你用完一个链接工作区后，用 `git worktree remove` 删除它。"

#. type: Plain text
#: en/git-worktree.txt:50
#, priority:240
msgid "In its simplest form, `git worktree add <path>` automatically creates a new branch whose name is the final component of `<path>`, which is convenient if you plan to work on a new topic. For instance, `git worktree add ../hotfix` creates new branch `hotfix` and checks it out at path `../hotfix`. To instead work on an existing branch in a new worktree, use `git worktree add <path> <branch>`. On the other hand, if you just plan to make some experimental changes or do testing without disturbing existing development, it is often convenient to create a 'throwaway' worktree not associated with any branch. For instance, `git worktree add -d <path>` creates a new worktree with a detached `HEAD` at the same commit as the current branch."
msgstr "在其最简单的形式中，`git worktree add <路径>`自动创建一个新的分支，其名称是`<路径>`的最后一个组成部分，如果你计划在一个新的主题上工作，这很方便。例如，`git worktree add .../hotfix`创建了新的分支`hotfix`，并在路径`.../hotfix`处签出它。如果要在一个新的工作区中处理现有的分支，可以使用`git worktree add <路径> <分支>`。另一方面，如果你只是打算做一些实验性的修改，或者在不影响现有开发的情况下进行测试，创建一个不与任何分支相关联的 \"抛弃式 \"工作区通常是很方便的。例如，`git worktree add -d <路径>`在与当前分支相同的提交中，创建一个带有分离`HEAD`的新工作区。"

#. type: Plain text
#: en/git-worktree.txt:57
#, priority:240
msgid "If a working tree is deleted without using `git worktree remove`, then its associated administrative files, which reside in the repository (see \"DETAILS\" below), will eventually be removed automatically (see `gc.worktreePruneExpire` in linkgit:git-config[1]), or you can run `git worktree prune` in the main or any linked worktree to clean up any stale administrative files."
msgstr "如果没有使用 `git worktree remove` 就删除了工作区，那么它的相关管理文件，即驻扎在仓库中的文件（见下面的 \"详细说明\"），最终会被自动删除（见 linkgit:git-config[1] 中的 `gc.worktreePruneExpire`），或者你可以在主工作区或任何链接工作区中运行`git worktree prune` 来清理任何过时的管理文件。"

#. type: Plain text
#: en/git-worktree.txt:63
#, priority:240
msgid "If the working tree for a linked worktree is stored on a portable device or network share which is not always mounted, you can prevent its administrative files from being pruned by issuing the `git worktree lock` command, optionally specifying `--reason` to explain why the worktree is locked."
msgstr "如果一个链接的工作区存储在便携设备或网络共享上，而这些设备并不总是被挂载，你可以通过发布`git worktree lock`命令来防止其管理文件被修剪，可以使用选项`--reason`来解释为什么工作树被锁定。"

#. type: Labeled list
#: en/git-worktree.txt:66
#, no-wrap, priority:240
msgid "add <path> [<commit-ish>]"
msgstr "add <路径> [<提交号>]"

#. type: Plain text
#: en/git-worktree.txt:72
#, priority:240
msgid "Create a worktree at `<path>` and checkout `<commit-ish>` into it. The new worktree is linked to the current repository, sharing everything except per-worktree files such as `HEAD`, `index`, etc. As a convenience, `<commit-ish>` may be a bare \"`-`\", which is synonymous with `@{-1}`."
msgstr "在`<路径>`创建一个工作树，并将`<提交号>`签入其中。新的工作区被链接到当前仓库，共享除每个工作区文件（如`HEAD`、`index`等）之外的一切。为了方便起见，`<提交号>`可以是一个光秃秃的\"`-`\"，它与`@{-1}`同义。"

#. type: Plain text
#: en/git-worktree.txt:77
#, priority:240
msgid "If `<commit-ish>` is a branch name (call it `<branch>`) and is not found, and neither `-b` nor `-B` nor `--detach` are used, but there does exist a tracking branch in exactly one remote (call it `<remote>`)  with a matching name, treat as equivalent to:"
msgstr "如果`<提交号>`是一个分支名称（称其为`<分支>`），并且没有找到，也没有使用`-b`或`-B`或`-detach`，但确实在正好一个远程仓库（称其为`<远程仓库>`）中存在一个名称匹配的跟踪分支，则视为等同于："

#. type: delimited block -
#: en/git-worktree.txt:80
#, fuzzy, no-wrap, priority:240
msgid "$ git worktree add --track -b <branch> <path> <remote>/<branch>\n"
msgstr "$ git worktree add --track -b <branch> <path> <remote>/<branch>\n"

#. type: Plain text
#: en/git-worktree.txt:90
#, priority:240
msgid "If the branch exists in multiple remotes and one of them is named by the `checkout.defaultRemote` configuration variable, we'll use that one for the purposes of disambiguation, even if the `<branch>` isn't unique across all remotes. Set it to e.g. `checkout.defaultRemote=origin` to always checkout remote branches from there if `<branch>` is ambiguous but exists on the `origin` remote. See also `checkout.defaultRemote` in linkgit:git-config[1]."
msgstr "如果该分支存在于多个远程仓库，并且其中一个是由`checkout.defaultRemote`配置变量命名的，为了消除歧义，我们将使用该变量，即使`<分支>`在所有远程中并不唯一。将其设置为例如 `checkout.defaultRemote=origin`，以便在`<分支>`不明确但存在于'origin'远程时，总是从那里签出远程分支。参见 linkgit:git-config[1] 中的 `checkout.defaultRemote`。"

#. type: Plain text
#: en/git-worktree.txt:98
#, priority:240
msgid "If `<commit-ish>` is omitted and neither `-b` nor `-B` nor `--detach` used, then, as a convenience, the new worktree is associated with a branch (call it `<branch>`) named after `$(basename <path>)`.  If `<branch>` doesn't exist, a new branch based on `HEAD` is automatically created as if `-b <branch>` was given.  If `<branch>` does exist, it will be checked out in the new worktree, if it's not checked out anywhere else, otherwise the command will refuse to create the worktree (unless `--force` is used)."
msgstr "如果省略了`<提交号>`，也没有使用`-b`或`-B`或`-detach`，那么作为一种方便，新的工作树将与一个以`$(basename <路径>)`命名的分支（称为`<分支>`）相关联。  如果`<分支>`不存在，一个基于`HEAD`的新分支将被自动创建，就像给出`-b <分支>`一样。  如果`<分支>`确实存在，它将在新的工作树中被签出，如果它没有在其他地方被签出，否则命令将拒绝创建工作区（除非使用`--force`）。"

#. type: Plain text
#: en/git-worktree.txt:108
#, priority:240
msgid "If `<commit-ish>` is omitted, neither `--detach`, or `--orphan` is used, and there are no valid local branches (or remote branches if `--guess-remote` is specified) then, as a convenience, the new worktree is associated with a new orphan branch named `<branch>` (after `$(basename <path>)` if neither `-b` or `-B` is used) as if `--orphan` was passed to the command. In the event the repository has a remote and `--guess-remote` is used, but no remote or local branches exist, then the command fails with a warning reminding the user to fetch from their remote first (or override by using `-f/--force`)."
msgstr ""

#. type: Plain text
#: en/git-worktree.txt:117
#, priority:240
msgid "List details of each worktree.  The main worktree is listed first, followed by each of the linked worktrees.  The output details include whether the worktree is bare, the revision currently checked out, the branch currently checked out (or \"detached HEAD\" if none), \"locked\" if the worktree is locked, \"prunable\" if the worktree can be pruned by the `prune` command."
msgstr "列出每个工作区的细节。  主工作区被首先列出，接着是每个链接工作区。  输出的细节包括该工作区是否为裸树，当前签出的修订版，当前检出的分支（如果没有则为 \"分离的HEAD\"），如果工作树被锁定则为 \"锁定\"，如果工作树可以被`prune`命令修剪则为 \"可修剪\"。"

#. type: Labeled list
#: en/git-worktree.txt:118
#, ignore-same, no-wrap, priority:240
msgid "lock"
msgstr "lock"

#. type: Plain text
#: en/git-worktree.txt:124
#, priority:240
msgid "If a worktree is on a portable device or network share which is not always mounted, lock it to prevent its administrative files from being pruned automatically. This also prevents it from being moved or deleted.  Optionally, specify a reason for the lock with `--reason`."
msgstr "如果一个工作区在便携式设备或网络共享上，而这个设备或网络共享并不总是被挂载，请锁定它以防止其管理文件被自动修剪。这也可以防止它被移动或删除。  可以选择用`--reason`选项来指定锁定的原因。"

#. type: Labeled list
#: en/git-worktree.txt:125
#, ignore-same, no-wrap, priority:240
msgid "move"
msgstr "move"

#. type: Plain text
#: en/git-worktree.txt:131
#, priority:240
msgid "Move a worktree to a new location. Note that the main worktree or linked worktrees containing submodules cannot be moved with this command. (The `git worktree repair` command, however, can reestablish the connection with linked worktrees if you move the main worktree manually.)"
msgstr "将一个工作区移动到一个新的位置。注意，主工作区或包含子模块的链接工作区不能用此命令移动。(然而，如果你手动移动主工作区，`git worktree repair`命令可以重新建立与链接工作区的连接。）"

#. type: Plain text
#: en/git-worktree.txt:135
#, priority:240
msgid "Prune worktree information in `$GIT_DIR/worktrees`."
msgstr "修剪`$GIT_DIR/worktrees`中的工作区信息。"

#. type: Plain text
#: en/git-worktree.txt:142
#, priority:240
msgid "Remove a worktree. Only clean worktrees (no untracked files and no modification in tracked files) can be removed. Unclean worktrees or ones with submodules can be removed with `--force`. The main worktree cannot be removed."
msgstr "移除一个工作区。只有干净的工作区（没有未跟踪的文件和未修改的跟踪文件）可以被删除。脏工作区或有子模块的工作区可以用 `--force` 删除。主工作区不能被删除。"

#. type: Labeled list
#: en/git-worktree.txt:143
#, ignore-ellipsis, no-wrap, priority:240
msgid "repair [<path>...]"
msgstr "repair [<路径>...]"

#. type: Plain text
#: en/git-worktree.txt:147
#, priority:240
msgid "Repair worktree administrative files, if possible, if they have become corrupted or outdated due to external factors."
msgstr "如果可能的话，修复工作区的管理文件，如果它们由于外部因素而变得损坏或过时。"

#. type: Plain text
#: en/git-worktree.txt:152
#, priority:240
msgid "For instance, if the main worktree (or bare repository) is moved, linked worktrees will be unable to locate it. Running `repair` in the main worktree will reestablish the connection from linked worktrees back to the main worktree."
msgstr "例如，如果主工作区（或裸仓库）被移动，链接工作区将无法找到它。在主工作区中运行 `repair` 将重新建立从链接工作区到主工作区的连接。"

#. type: Plain text
#: en/git-worktree.txt:159
#, priority:240
msgid "Similarly, if the working tree for a linked worktree is moved without using `git worktree move`, the main worktree (or bare repository) will be unable to locate it. Running `repair` within the recently-moved worktree will reestablish the connection. If multiple linked worktrees are moved, running `repair` from any worktree with each tree's new `<path>` as an argument, will reestablish the connection to all the specified paths."
msgstr "同样地，如果没有使用 `git worktree move` 就移动了链接工作区，主工作区（或裸仓库）将无法定位它。在最近移动的工作区中运行`repair`将重新建立连接。如果多个链接工作区被移动，在任何工作区中运行`repair`，以每个树的新`<路径>`作为参数，将重新建立与所有指定路径的连接。"

#. type: Plain text
#: en/git-worktree.txt:164
#, priority:240
msgid "If both the main worktree and linked worktrees have been moved manually, then running `repair` in the main worktree and specifying the new `<path>` of each linked worktree will reestablish all connections in both directions."
msgstr "如果主工作区和链接工作区都被手动移动，那么在主工作区中运行`repair`并指定每个链接工作树的新`<路径>`将重新建立两个方向的所有连接。"

#. type: Labeled list
#: en/git-worktree.txt:165
#, ignore-same, no-wrap, priority:240
msgid "unlock"
msgstr "unlock"

#. type: Plain text
#: en/git-worktree.txt:168
#, priority:240
msgid "Unlock a worktree, allowing it to be pruned, moved or deleted."
msgstr "解锁一个工作区，允许它被修剪、移动或删除。"

#. type: Plain text
#: en/git-worktree.txt:180
#, priority:240
msgid "By default, `add` refuses to create a new worktree when `<commit-ish>` is a branch name and is already checked out by another worktree, or if `<path>` is already assigned to some worktree but is missing (for instance, if `<path>` was deleted manually). This option overrides these safeguards. To add a missing but locked worktree path, specify `--force` twice."
msgstr "默认情况下，当`<提交号>`是一个分支名称，并且已经被另一个工作树签出，或者`<路径>`已经被分配给某个工作树，但丢失了（例如，如果`<路径>`被手动删除），`add`拒绝创建一个新的工作树。这个选项覆盖了这些保护措施。要添加一个缺失但锁定的工作区路径，请指定`--force`两次。"

#. type: Plain text
#: en/git-worktree.txt:185
#, priority:240
msgid "`move` refuses to move a locked worktree unless `--force` is specified twice. If the destination is already assigned to some other worktree but is missing (for instance, if `<new-path>` was deleted manually), then `--force` allows the move to proceed; use `--force` twice if the destination is locked."
msgstr "`move`拒绝移动一个被锁定的工作区，除非`--force`被指定两次。如果目的地已经被分配给其他工作区，但没有找到（例如，如果`<新路径>`被手动删除），那么`--force`允许移动；如果目的地被锁定，则使用`--force`两次。"

#. type: Plain text
#: en/git-worktree.txt:188
#, priority:240
msgid "`remove` refuses to remove an unclean worktree unless `--force` is used.  To remove a locked worktree, specify `--force` twice."
msgstr "`remove`拒绝删除一个脏工作区，除非使用`--force`。  要删除一个锁定的工作区，需要指定`--force`两次。"

#. type: Plain text
#: en/git-worktree.txt:197
#, priority:240
msgid "With `add`, create a new branch named `<new-branch>` starting at `<commit-ish>`, and check out `<new-branch>` into the new worktree.  If `<commit-ish>` is omitted, it defaults to `HEAD`.  By default, `-b` refuses to create a new branch if it already exists. `-B` overrides this safeguard, resetting `<new-branch>` to `<commit-ish>`."
msgstr "通过`add`，创建一个名为`<新分支>`的新分支，从`<提交号>`开始，并将`<新分支>`检出到新的工作树。  如果省略了`<提交号>`，则默认为`HEAD`。  默认情况下，如果一个新的分支已经存在，`-b`会拒绝创建它。`-B`则不会拒绝创建，将`<新分支>`重置为`<提交号>`。"

#. type: Plain text
#: en/git-worktree.txt:202
#, fuzzy, priority:240
msgid "With `add`, detach `HEAD` in the new worktree. See \"DETACHED HEAD\" in linkgit:git-checkout[1]."
msgstr "通过 `add`，在新的工作树中分离出 `HEAD`。参见 linkgit:git-checkout[1] 中的 \"DETACHED HEAD\"。"

#. type: Labeled list
#: en/git-worktree.txt:203
#, ignore-same, no-wrap, priority:240
msgid "--[no-]checkout"
msgstr "--[no-]checkout"

#. type: Plain text
#: en/git-worktree.txt:208
#, priority:240
msgid "By default, `add` checks out `<commit-ish>`, however, `--no-checkout` can be used to suppress checkout in order to make customizations, such as configuring sparse-checkout. See \"Sparse checkout\" in linkgit:git-read-tree[1]."
msgstr "默认情况下，`add`会检出`<提交号>`，然而，`--no-checkout`可以用来抑制检出，以便进行定制，比如配置稀疏检出。参见 linkgit:git-read-tree[1] 中的 \"稀疏检出\"。"

#. type: Labeled list
#: en/git-worktree.txt:209
#, ignore-same, no-wrap, priority:240
msgid "--[no-]guess-remote"
msgstr "--[no-]guess-remote"

#. type: Plain text
#: en/git-worktree.txt:215
#, priority:240
msgid "With `worktree add <path>`, without `<commit-ish>`, instead of creating a new branch from `HEAD`, if there exists a tracking branch in exactly one remote matching the basename of `<path>`, base the new branch on the remote-tracking branch, and mark the remote-tracking branch as \"upstream\" from the new branch."
msgstr "在`worktree add <路径>`下，如果没有`<提交号>`，则不从`HEAD`创建新的分支，而是在正好有一个与`<路径>`的基名相匹配的远程跟踪分支的情况下，将新的分支建立在远程跟踪分支上，并将远程跟踪分支标记为新分支的 \"上游\"。"

#. type: Plain text
#: en/git-worktree.txt:218
#, priority:240
msgid "This can also be set up as the default behaviour by using the `worktree.guessRemote` config option."
msgstr "这也可以通过使用`worktree.guessRemote`配置选项设置为默认行为。"

#. type: Labeled list
#: en/git-worktree.txt:219
#, ignore-same, no-wrap, priority:240
msgid "--[no-]track"
msgstr "--[no-]track"

#. type: Plain text
#: en/git-worktree.txt:224
#, priority:240
msgid "When creating a new branch, if `<commit-ish>` is a branch, mark it as \"upstream\" from the new branch.  This is the default if `<commit-ish>` is a remote-tracking branch.  See `--track` in linkgit:git-branch[1] for details."
msgstr "当创建一个新的分支时，如果 `<提交号>` 是一个分支，则将其标记为新分支的 \"上游\"。  默认认为 `<提交号>` 是一个远程跟踪分支。  详情见 linkgit:git-branch[1] 中的 `--track`。"

#. type: Labeled list
#: en/git-worktree.txt:225
#, ignore-same, no-wrap, priority:240
msgid "--lock"
msgstr "--lock"

#. type: Plain text
#: en/git-worktree.txt:229
#, priority:240
msgid "Keep the worktree locked after creation. This is the equivalent of `git worktree lock` after `git worktree add`, but without a race condition."
msgstr "在创建后保持工作区的锁定。这相当于在`git worktree add`之后执行`git worktree lock`，但没有资源竞争。"

#. type: Plain text
#: en/git-worktree.txt:234
#, priority:240
msgid "With `prune`, do not remove anything; just report what it would remove."
msgstr "在使用`prune`时，不会删除任何文件；只会报告它要删除的东西。"

#. type: Labeled list
#: en/git-worktree.txt:235
#, ignore-same, no-wrap, priority:240
msgid "--orphan"
msgstr "--orphan"

#. type: Plain text
#: en/git-worktree.txt:238
#, priority:240
msgid "With `add`, make the new worktree and index empty, associating the worktree with a new orphan/unborn branch named `<new-branch>`."
msgstr ""

#. type: Plain text
#: en/git-worktree.txt:244
#, fuzzy, priority:240
#| msgid "Give the output in an easy-to-parse format for scripts.  This is similar to the short output, but will remain stable across Git versions and regardless of user configuration. See below for details."
msgid "With `list`, output in an easy-to-parse format for scripts.  This format will remain stable across Git versions and regardless of user configuration.  It is recommended to combine this with `-z`.  See below for details."
msgstr "以易于解析的格式给出脚本的输出。  这类似于简短的输出，但在不同的Git版本中，无论用户配置如何，都会保持稳定。详见下文。"

#. type: Plain text
#: en/git-worktree.txt:250
#, priority:240
msgid "Terminate each line with a NUL rather than a newline when `--porcelain` is specified with `list`. This makes it possible to parse the output when a worktree path contains a newline character."
msgstr "当`--porcelain`与`list`一起指定时，用NUL而不是换行来结束每一行。这使得在工作区路径包含换行符时，可以解析输出。"

#. type: Plain text
#: en/git-worktree.txt:254
#, priority:240
msgid "With `add`, suppress feedback messages."
msgstr "用`add`，抑制反馈信息。"

#. type: Plain text
#: en/git-worktree.txt:258
#, priority:240
msgid "With `prune`, report all removals."
msgstr "使用`prune`，报告所有的移除情况。"

#. type: Plain text
#: en/git-worktree.txt:260
#, priority:240
msgid "With `list`, output additional information about worktrees (see below)."
msgstr "用`list`，输出关于工作区的额外信息（见下文）。"

#. type: Plain text
#: en/git-worktree.txt:263
#, priority:240
msgid "With `prune`, only expire unused worktrees older than `<time>`."
msgstr "使用 `prune`，只对超过`<时间>`未使用的工作区进行淘汰。"

#. type: Plain text
#: en/git-worktree.txt:266
#, priority:240
msgid "With `list`, annotate missing worktrees as prunable if they are older than `<time>`."
msgstr "使用`list`，如果丢失的工作区比`<时间>`早，则将其注释为可修剪。"

#. type: Labeled list
#: en/git-worktree.txt:267
#, fuzzy, no-wrap, priority:240
msgid "--reason <string>"
msgstr "--reason <string>"

#. type: Plain text
#: en/git-worktree.txt:270
#, priority:240
msgid "With `lock` or with `add --lock`, an explanation why the worktree is locked."
msgstr "用`lock`或用`add --lock`，解释为什么工作区被锁定。"

#. type: Labeled list
#: en/git-worktree.txt:271
#, fuzzy, no-wrap, priority:240
msgid "<worktree>"
msgstr "<worktree>"

#. type: Plain text
#: en/git-worktree.txt:273
#, priority:240
msgid "Worktrees can be identified by path, either relative or absolute."
msgstr "工作区可以通过相对或绝对路径来识别。"

#. type: Plain text
#: en/git-worktree.txt:278
#, priority:240
msgid "If the last path components in the worktree's path is unique among worktrees, it can be used to identify a worktree. For example if you only have two worktrees, at `/abc/def/ghi` and `/abc/def/ggg`, then `ghi` or `def/ghi` is enough to point to the former worktree."
msgstr "如果工作区路径中的后几个层次在工作树中是唯一的，则它可以用来识别一个工作树。例如，如果你只有两个工作区，在`/abc/def/ghi`和`/abc/def/ggg`，那么使用`ghi`或`def/ghi`就足以指向前一个工作区。"

#. type: Title -
#: en/git-worktree.txt:280
#, fuzzy, no-wrap, priority:240
msgid "REFS"
msgstr "参考"

#. type: Plain text
#: en/git-worktree.txt:285
#, priority:240
msgid "When using multiple worktrees, some refs are shared between all worktrees, but others are specific to an individual worktree. One example is `HEAD`, which is different for each worktree. This section is about the sharing rules and how to access refs of one worktree from another."
msgstr "当使用多个工作区时，一些引用在所有工作区之间共享，但其他引用是特定于单个工作区的。比如：`HEAD`，它对每个工作树都是不同的。本节是关于共享规则，以及如何从另一个工作区访问一个工作区的引用。"

#. type: Plain text
#: en/git-worktree.txt:290
#, priority:240
msgid "In general, all pseudo refs are per-worktree and all refs starting with `refs/` are shared. Pseudo refs are ones like `HEAD` which are directly under `$GIT_DIR` instead of inside `$GIT_DIR/refs`. There are exceptions, however: refs inside `refs/bisect` and `refs/worktree` are not shared."
msgstr "一般来说，所有的伪引用都是工作区特有的，所有以`refs/`开头的引用都是共享的。伪引用是像`HEAD`那样直接在`$GIT_DIR`下，而不是在`$GIT_DIR/refs`内的引用。但也有例外：`refs/bisect`和`refs/worktree`内的引用不被共享。"

#. type: Plain text
#: en/git-worktree.txt:295
#, priority:240
msgid "Refs that are per-worktree can still be accessed from another worktree via two special paths, `main-worktree` and `worktrees`. The former gives access to per-worktree refs of the main worktree, while the latter to all linked worktrees."
msgstr "每个工作区的引用仍然可以通过两个特殊的路径，即 `主工作区`和 `从工作区`，从另一个工作区访问。前者可以访问主工作区的每个工作区的引用，而后者可以访问所有链接的工作区。"

#. type: Plain text
#: en/git-worktree.txt:302
#, priority:240
msgid "For example, `main-worktree/HEAD` or `main-worktree/refs/bisect/good` resolve to the same value as the main worktree's `HEAD` and `refs/bisect/good` respectively. Similarly, `worktrees/foo/HEAD` or `worktrees/bar/refs/bisect/bad` are the same as `$GIT_COMMON_DIR/worktrees/foo/HEAD` and `$GIT_COMMON_DIR/worktrees/bar/refs/bisect/bad`."
msgstr "例如，`main-worktree/HEAD`或`main-worktree/refs/bisect/good`分别解析到与主工作区的`HEAD`和`refs/bisect/good`相同的值。类似地，`worktrees/foo/HEAD`或`worktrees/bar/refs/bisect/bad`与`$GIT_COMMON_DIR/worktrees/foo/HEAD`和`$GIT_COMMON_DIR/worktrees/bar/refs/bisect/bad`相同。"

#. type: Plain text
#: en/git-worktree.txt:306
#, priority:240
msgid "To access refs, it's best not to look inside `$GIT_DIR` directly. Instead use commands such as linkgit:git-rev-parse[1] or linkgit:git-update-ref[1] which will handle refs correctly."
msgstr "要访问引用，最好不要直接在 `$GIT_DIR` 中查找。相反，使用 linkgit:git-rev-parse[1] 或 linkgit:git-update-ref[1] 这样的命令可以正确处理引用。"

#. type: Plain text
#: en/git-worktree.txt:313
#, priority:240
msgid "By default, the repository `config` file is shared across all worktrees.  If the config variables `core.bare` or `core.worktree` are present in the common config file and `extensions.worktreeConfig` is disabled, then they will be applied to the main worktree only."
msgstr "默认情况下，资源库的`config`文件在所有工作区上共享。  如果配置变量`core.bare`或`core.worktree`存在于公共配置文件中，并且`extensions.worktreeConfig`被禁用，那么它们将只应用于主工作区。"

#. type: Plain text
#: en/git-worktree.txt:316
#, priority:240
msgid "In order to have worktree-specific configuration, you can turn on the `worktreeConfig` extension, e.g.:"
msgstr "为了对工作区进行特定配置，你可以打开`worktreeConfig`扩展，例如："

#. type: delimited block -
#: en/git-worktree.txt:319
#, fuzzy, no-wrap, priority:240
msgid "$ git config extensions.worktreeConfig true\n"
msgstr "$ git config extensions.worktreeConfig true\n"

#. type: Plain text
#: en/git-worktree.txt:325
#, priority:240
msgid "In this mode, specific configuration stays in the path pointed by `git rev-parse --git-path config.worktree`. You can add or update configuration in this file with `git config --worktree`. Older Git versions will refuse to access repositories with this extension."
msgstr "在这种模式下，特定的配置保持在`git rev-parse --git-path config.worktree`所指向的路径中。你可以用`git config --worktree`添加或更新该文件中的配置。旧版本的Git会拒绝访问带有这个扩展的仓库。"

#. type: Plain text
#: en/git-worktree.txt:331
#, priority:240
msgid "Note that in this file, the exception for `core.bare` and `core.worktree` is gone. If they exist in `$GIT_DIR/config`, you must move them to the `config.worktree` of the main worktree. You may also take this opportunity to review and move other configuration that you do not want to share to all worktrees:"
msgstr "注意，在这个文件中，`core.bare`和`core.worktree`的例外情况已经消失。如果它们存在于`$GIT_DIR/config`中，你必须把它们移到主工作区的`config.worktree`中。你也可以借此机会审查和移动其他你不想共享到所有工作区的配置："

#. type: Plain text
#: en/git-worktree.txt:333
#, priority:240
msgid "`core.worktree` should never be shared."
msgstr "`core.worktree`不应该被共享。"

#. type: Plain text
#: en/git-worktree.txt:335
#, priority:240
msgid "`core.bare` should not be shared if the value is `core.bare=true`."
msgstr "如果`core.bare`的值为`core.bare=true`，则不应共享。"

#. type: Plain text
#: en/git-worktree.txt:338
#, priority:240
msgid "`core.sparseCheckout` should not be shared, unless you are sure you always use sparse checkout for all worktrees."
msgstr "`core.sparseCheckout`不应该被共享，除非你确信你总是对所有工作区使用稀疏检出。"

#. type: Plain text
#: en/git-worktree.txt:341
#, priority:240
msgid "See the documentation of `extensions.worktreeConfig` in linkgit:git-config[1] for more details."
msgstr "更多细节请参见 linkgit:git-config[1] 中的 `extensions.worktreeConfig` 文档。"

#. type: Title -
#: en/git-worktree.txt:343
#, fuzzy, no-wrap, priority:240
msgid "DETAILS"
msgstr "细节"

#. type: Plain text
#: en/git-worktree.txt:352
#, priority:240
msgid "Each linked worktree has a private sub-directory in the repository's `$GIT_DIR/worktrees` directory.  The private sub-directory's name is usually the base name of the linked worktree's path, possibly appended with a number to make it unique.  For example, when `$GIT_DIR=/path/main/.git` the command `git worktree add /path/other/test-next next` creates the linked worktree in `/path/other/test-next` and also creates a `$GIT_DIR/worktrees/test-next` directory (or `$GIT_DIR/worktrees/test-next1` if `test-next` is already taken)."
msgstr "每个链接工作区在仓库的`$GIT_DIR/worktrees`目录下都有一个私有子目录。  私有子目录的名称通常是被链接的工作树路径的基本名称，但可能加上一个数字以使成为唯一目录。  例如，当`$GIT_DIR=/path/main/.git`时，命令`git worktree add /path/other/test-next next`会在`/path/other/test-next`中创建链接工作区，同时创建一个`$GIT_DIR/worktrees/test-next`目录（如果`test-next`已经被占用，则创建`$GIT_DIR/worktrees/test-next1`）。"

#. type: Plain text
#: en/git-worktree.txt:358
#, priority:240
msgid "Within a linked worktree, `$GIT_DIR` is set to point to this private directory (e.g. `/path/main/.git/worktrees/test-next` in the example) and `$GIT_COMMON_DIR` is set to point back to the main worktree's `$GIT_DIR` (e.g. `/path/main/.git`). These settings are made in a `.git` file located at the top directory of the linked worktree."
msgstr "在一个链接工作区中，`$GIT_DIR`设置为指向这个私有目录（例如，例子中的`/path/main/.git/worktrees/test-next`），`$GIT_COMMON_DIR`会被设置为指向主工作区的`$GIT_DIR`（例如，`/path/main/.git`）。这些设置是在位于链接工作区顶级目录的`.git`文件中进行的。"

#. type: Plain text
#: en/git-worktree.txt:368
#, priority:240
msgid "Path resolution via `git rev-parse --git-path` uses either `$GIT_DIR` or `$GIT_COMMON_DIR` depending on the path. For example, in the linked worktree `git rev-parse --git-path HEAD` returns `/path/main/.git/worktrees/test-next/HEAD` (not `/path/other/test-next/.git/HEAD` or `/path/main/.git/HEAD`) while `git rev-parse --git-path refs/heads/master` uses `$GIT_COMMON_DIR` and returns `/path/main/.git/refs/heads/master`, since refs are shared across all worktrees, except `refs/bisect` and `refs/worktree`."
msgstr "通过`git rev-parse --git-path`进行的路径解析使用`$GIT_DIR`或`$GIT_COMMON_DIR`，取决于路径。例如，在链接工作区中，`git rev-parse --git-path HEAD`命令返回`/path/main/.git/worktrees/test-next/HEAD`（而不是`/path/other/test-next/.git/HEAD`或者`/path/main/.git/HEAD`），而`git rev-parse --git-path refs/heads/master`则使用`$GIT_COMMON_DIR`并返回`/path/main/.git/refs/heads/master`，因为除了`refs/bisect`和`refs/worktree`，所有工作区都共享引用。"

#. type: Plain text
#: en/git-worktree.txt:373
#, priority:240
msgid "See linkgit:gitrepository-layout[5] for more information. The rule of thumb is do not make any assumption about whether a path belongs to `$GIT_DIR` or `$GIT_COMMON_DIR` when you need to directly access something inside `$GIT_DIR`. Use `git rev-parse --git-path` to get the final path."
msgstr "更多信息见 linkgit:gitrepository-layout[5]。经验法则是，当你需要直接访问`$GIT_DIR`或`$GIT_COMMON_DIR`内的东西时，不要对路径是否属于`$GIT_DIR`做出任何假设。使用`git rev-parse --git-path`来获得最终路径。"

#. type: Plain text
#: en/git-worktree.txt:381
#, priority:240
msgid "If you manually move a linked worktree, you need to update the `gitdir` file in the entry's directory. For example, if a linked worktree is moved to `/newpath/test-next` and its `.git` file points to `/path/main/.git/worktrees/test-next`, then update `/path/main/.git/worktrees/test-next/gitdir` to reference `/newpath/test-next` instead. Better yet, run `git worktree repair` to reestablish the connection automatically."
msgstr "如果你手动移动一个链接工作区，你需要更新该条目目录下的`gitdir`文件。例如，如果一个链接工作区被移到`/newpath/test-next`，而它的`.git`文件指向`/path/main/.git/worktrees/test-next`，那么更新`/path/main/.git/worktrees/test-next/gitdir`以引用`/newpath/test-next`。除此之外，更好的选择是，运行`git worktree repair`来自动重新建立连接。"

#. type: Plain text
#: en/git-worktree.txt:392
#, priority:240
msgid "To prevent a `$GIT_DIR/worktrees` entry from being pruned (which can be useful in some situations, such as when the entry's worktree is stored on a portable device), use the `git worktree lock` command, which adds a file named `locked` to the entry's directory. The file contains the reason in plain text. For example, if a linked worktree's `.git` file points to `/path/main/.git/worktrees/test-next` then a file named `/path/main/.git/worktrees/test-next/locked` will prevent the `test-next` entry from being pruned.  See linkgit:gitrepository-layout[5] for details."
msgstr "为了防止`$GIT_DIR/worktrees`条目被修剪（这在某些情况下很有用，比如该条目的工作区存储在便携设备上），使用`git worktree lock`命令，它会在条目的目录中添加一个名为`locked`的文件。该文件包含纯文本的原因。例如，如果一个链接工作区的`.git`文件指向`/path/main/.git/worktrees/test-next`，那么一个名为`/path/main/.git/worktrees/test-next/locked`的文件将阻止`test-next`条目被剪除。  详情见linkgit:gitrepository-layout[5]。"

#. type: Plain text
#: en/git-worktree.txt:395
#, priority:240
msgid "When `extensions.worktreeConfig` is enabled, the config file `.git/worktrees/<id>/config.worktree` is read after `.git/config` is."
msgstr "当`extensions.worktreeConfig`被启用时，在`.git/config`之后会读取`.git/worktrees/<id>/config.worktree`的配置文件。"

#. type: Title -
#: en/git-worktree.txt:397
#, no-wrap, priority:240
msgid "LIST OUTPUT FORMAT"
msgstr "列表输出格式"

#. type: Plain text
#: en/git-worktree.txt:400
#, priority:240
msgid "The `worktree list` command has two output formats. The default format shows the details on a single line with columns.  For example:"
msgstr "`worktree list` 命令有两种输出格式。默认的格式是在单行上显示细节，并带有列。  例如："

#. type: delimited block -
#: en/git-worktree.txt:406
#, fuzzy, no-wrap, priority:240
msgid ""
"$ git worktree list\n"
"/path/to/bare-source            (bare)\n"
"/path/to/linked-worktree        abcd1234 [master]\n"
"/path/to/other-linked-worktree  1234abc  (detached HEAD)\n"
msgstr ""
"$ git worktree list\n"
"/path/to/bare-source            (bare)\n"
"/path/to/linked-worktree        abcd1234 [master]\n"
"/path/to/other-linked-worktree  1234abc  (detached HEAD)\n"

#. type: Plain text
#: en/git-worktree.txt:410
#, priority:240
msgid "The command also shows annotations for each worktree, according to its state.  These annotations are:"
msgstr "该命令还根据每个工作区的状态，显示其注释。  这些注释是："

#. type: Plain text
#: en/git-worktree.txt:412
#, priority:240
msgid "`locked`, if the worktree is locked."
msgstr "`locked`，如果工作区被锁定。"

#. type: Plain text
#: en/git-worktree.txt:413
#, priority:240
msgid "`prunable`, if the worktree can be pruned via `git worktree prune`."
msgstr "`prunable`，如果工作区可以通过`git worktree prune`进行修剪。"

#. type: delimited block -
#: en/git-worktree.txt:419
#, fuzzy, no-wrap, priority:240
msgid ""
"$ git worktree list\n"
"/path/to/linked-worktree    abcd1234 [master]\n"
"/path/to/locked-worktree    acbd5678 (brancha) locked\n"
"/path/to/prunable-worktree  5678abc  (detached HEAD) prunable\n"
msgstr ""
"$ git worktree list\n"
"/path/to/bare-source            (bare)\n"
"/path/to/linked-worktree        abcd1234 [master]\n"
"/path/to/other-linked-worktree  1234abc  (detached HEAD)\n"

#. type: Plain text
#: en/git-worktree.txt:424
#, fuzzy, priority:240
msgid "For these annotations, a reason might also be available and this can be seen using the verbose mode. The annotation is then moved to the next line indented followed by the additional information."
msgstr "对于这些注释，也可能有一个原因，这可以通过verbose模式看到。然后注释被移到下一行缩进，后面是附加信息。"

#. type: delimited block -
#: en/git-worktree.txt:433
#, no-wrap, priority:240
msgid ""
"$ git worktree list --verbose\n"
"/path/to/linked-worktree              abcd1234 [master]\n"
"/path/to/locked-worktree-no-reason    abcd5678 (detached HEAD) locked\n"
"/path/to/locked-worktree-with-reason  1234abcd (brancha)\n"
"\tlocked: worktree path is mounted on a portable device\n"
"/path/to/prunable-worktree            5678abc1 (detached HEAD)\n"
"\tprunable: gitdir file points to non-existent location\n"
msgstr ""
"$ git worktree list --verbose\n"
"/path/to/linked-worktree                           abcd1234 [master]\n"
"/path/to/locked-worktree-no-reason    abcd5678 (分离的 HEAD) locked\n"
"/path/to/locked-worktree-with-reason  1234abcd (brancha)\n"
"\t锁定：工作区路径被安装在一个可移动设备上\n"
"/path/to/prunable-worktree            5678abc1 (分离的 HEAD)\n"
"\t可修剪：gitdir 文件指向不存在的位置\n"

#. type: Plain text
#: en/git-worktree.txt:438
#, priority:240
msgid "Note that the annotation is moved to the next line if the additional information is available, otherwise it stays on the same line as the worktree itself."
msgstr "注意，如果有额外的信息，注释将被移到下一行，否则它将与工作区本身保持在同一行。"

#. type: Title ~
#: en/git-worktree.txt:440
#, no-wrap, priority:240
msgid "Porcelain Format"
msgstr "上层命令格式"

#. type: Plain text
#: en/git-worktree.txt:449
#, priority:240
msgid "The porcelain format has a line per attribute.  If `-z` is given then the lines are terminated with NUL rather than a newline.  Attributes are listed with a label and value separated by a single space.  Boolean attributes (like `bare` and `detached`) are listed as a label only, and are present only if the value is true.  Some attributes (like `locked`) can be listed as a label only or with a value depending upon whether a reason is available.  The first attribute of a worktree is always `worktree`, an empty line indicates the end of the record.  For example:"
msgstr "上层命令的每个属性有一行。  如果给了`-z`，那么这几行将以NUL（空字符）而不是换行来结束。  属性以标签和值的形式列出，用一个空格隔开。  布尔属性（如`bare`和`detached`）仅作为标签列出，并且仅在值为真时出现。  一些属性（如`locked'）可以只作为标签列出，也可以根据是否有理由列出一个值。  工作区的第一个属性总是`工作树'，一个空行表示记录的结束。  比如说："

#. type: delimited block -
#: en/git-worktree.txt:454
#, fuzzy, no-wrap, priority:240
msgid ""
"$ git worktree list --porcelain\n"
"worktree /path/to/bare-source\n"
"bare\n"
msgstr ""
"$ git worktree list --porcelain\n"
"worktree /path/to/bare-source\n"
"bare\n"

#. type: delimited block -
#: en/git-worktree.txt:458
#, no-wrap, priority:240
msgid ""
"worktree /path/to/linked-worktree\n"
"HEAD abcd1234abcd1234abcd1234abcd1234abcd1234\n"
"branch refs/heads/master\n"
msgstr ""
"worktree /path/to/linked-worktree\n"
"HEAD abcd1234abcd1234abcd1234abcd1234abcd1234\n"
"branch refs/heads/master\n"

#. type: delimited block -
#: en/git-worktree.txt:462
#, no-wrap, priority:240
msgid ""
"worktree /path/to/other-linked-worktree\n"
"HEAD 1234abc1234abc1234abc1234abc1234abc1234a\n"
"detached\n"
msgstr ""
"worktree /path/to/other-linked-worktree\n"
"HEAD 1234abc1234abc1234abc1234abc1234abc1234a\n"
"detached\n"

#. type: delimited block -
#: en/git-worktree.txt:467
#, no-wrap, priority:240
msgid ""
"worktree /path/to/linked-worktree-locked-no-reason\n"
"HEAD 5678abc5678abc5678abc5678abc5678abc5678c\n"
"branch refs/heads/locked-no-reason\n"
"locked\n"
msgstr ""
"worktree /path/to/linked-worktree-locked-no-reason\n"
"HEAD 5678abc5678abc5678abc5678abc5678abc5678c\n"
"branch refs/heads/locked-no-reason\n"
"locked\n"

#. type: delimited block -
#: en/git-worktree.txt:472
#, no-wrap, priority:240
msgid ""
"worktree /path/to/linked-worktree-locked-with-reason\n"
"HEAD 3456def3456def3456def3456def3456def3456b\n"
"branch refs/heads/locked-with-reason\n"
"locked reason why is locked\n"
msgstr ""
"worktree /path/to/linked-worktree-locked-with-reason\n"
"HEAD 3456def3456def3456def3456def3456def3456b\n"
"branch refs/heads/locked-with-reason\n"
"locked reason why is locked\n"

#. type: delimited block -
#: en/git-worktree.txt:477
#, no-wrap, priority:240
msgid ""
"worktree /path/to/linked-worktree-prunable\n"
"HEAD 1233def1234def1234def1234def1234def1234b\n"
"detached\n"
"prunable gitdir file points to non-existent location\n"
msgstr ""
"worktree /path/to/linked-worktree-prunable\n"
"HEAD 1233def1234def1234def1234def1234def1234b\n"
"detached\n"
"修剪的gitdir文件指向不存在的位置\n"

#. type: Plain text
#: en/git-worktree.txt:484
#, priority:240
msgid "Unless `-z` is used any \"unusual\" characters in the lock reason such as newlines are escaped and the entire reason is quoted as explained for the configuration variable `core.quotePath` (see linkgit:git-config[1]).  For Example:"
msgstr "除非使用`-z`，否则锁定的原因中任何 \"不寻常\"的字符，如换行，都会被转义，并且整个原因被引用为配置变量`core.quotePath`（见linkgit:git-config[1]）。  举例来说："

#. type: delimited block -
#: en/git-worktree.txt:490
#, ignore-ellipsis, no-wrap, priority:240
msgid ""
"$ git worktree list --porcelain\n"
"...\n"
"locked \"reason\\nwhy is locked\"\n"
"...\n"
msgstr ""
"$ git worktree list --porcelain\n"
"…\n"
"locked \"reason\\nwhy is locked\"\n"
"…\n"

#. type: Plain text
#: en/git-worktree.txt:502
#, priority:240
msgid "You are in the middle of a refactoring session and your boss comes in and demands that you fix something immediately. You might typically use linkgit:git-stash[1] to store your changes away temporarily, however, your working tree is in such a state of disarray (with new, moved, and removed files, and other bits and pieces strewn around) that you don't want to risk disturbing any of it. Instead, you create a temporary linked worktree to make the emergency fix, remove it when done, and then resume your earlier refactoring session."
msgstr "你正在进行重构工作，你的老板进来了，要求你立即修复一些东西。你通常会使用linkgit:git-stash[1]来暂时存储你的修改，然而你的工作树处于如此混乱的状态（有新的、被移动的、被删除的文件，以及其他散落的碎片），你不想冒险去打扰它。相反，你创建了一个临时的链接工作树来进行紧急修复，完成后将其删除，然后继续你先前的重构会话。"

#. type: delimited block -
#: en/git-worktree.txt:510
#, ignore-ellipsis, no-wrap, priority:240
msgid ""
"$ git worktree add -b emergency-fix ../temp master\n"
"$ pushd ../temp\n"
"# ... hack hack hack ...\n"
"$ git commit -a -m 'emergency fix for boss'\n"
"$ popd\n"
"$ git worktree remove ../temp\n"
msgstr ""
"$ git worktree add -b emergency-fix ../temp master\n"
"$ pushd ../temp\n"
"# ... 嗨骇害 ...\n"
"$ git commit -a -m '老板让我赶紧修复的问题'\n"
"$ popd\n"
"$ git worktree remove ../temp\n"

#. type: Plain text
#: en/git-worktree.txt:517
#, priority:240
msgid "Multiple checkout in general is still experimental, and the support for submodules is incomplete. It is NOT recommended to make multiple checkouts of a superproject."
msgstr "多重检出总体上仍处于试验阶段，对子模块的支持也不完整。我们 ⌈不⌋ 建议对一个父项目进行多重检出。"

#. type: Title =
#: en/git-write-tree.txt:2
#, ignore-same, no-wrap, priority:80
msgid "git-write-tree(1)"
msgstr "git-write-tree(1)"

#. type: Plain text
#: en/git-write-tree.txt:7
#, fuzzy, priority:80
msgid "git-write-tree - Create a tree object from the current index"
msgstr "git-write-tree - Create a tree object from the current index"

#. type: Plain text
#: en/git-write-tree.txt:13
#, fuzzy, no-wrap, priority:80
msgid "'git write-tree' [--missing-ok] [--prefix=<prefix>/]\n"
msgstr "'git write-tree' [--missing-ok] [--prefix=<prefix>/]\n"

#. type: Plain text
#: en/git-write-tree.txt:18
#, priority:80
msgid "Creates a tree object using the current index. The name of the new tree object is printed to standard output."
msgstr ""

#. type: Plain text
#: en/git-write-tree.txt:20
#, priority:80
msgid "The index must be in a fully merged state."
msgstr ""

#. type: Plain text
#: en/git-write-tree.txt:26
#, priority:80
msgid "Conceptually, 'git write-tree' sync()s the current index contents into a set of tree files.  In order to have that match what is actually in your directory right now, you need to have done a 'git update-index' phase before you did the 'git write-tree'."
msgstr ""

#. type: Labeled list
#: en/git-write-tree.txt:30
#, ignore-same, no-wrap, priority:80
msgid "--missing-ok"
msgstr "--missing-ok"

#. type: Plain text
#: en/git-write-tree.txt:34
#, priority:80
msgid "Normally 'git write-tree' ensures that the objects referenced by the directory exist in the object database.  This option disables this check."
msgstr ""

#. type: Plain text
#: en/git-write-tree.txt:39
#, priority:80
msgid "Writes a tree object that represents a subdirectory `<prefix>`.  This can be used to write the tree object for a subproject that is in the named subdirectory."
msgstr ""

#. type: Title =
#: en/gitglossary.txt:2
#, ignore-same, no-wrap, priority:310
msgid "gitglossary(7)"
msgstr "gitglossary(7)"

#. type: Plain text
#: en/gitglossary.txt:7
#, priority:310
msgid "gitglossary - A Git Glossary"
msgstr "gitglossary - Git术语表"

#. type: Plain text
#: en/gitglossary.txt:11
#, no-wrap, priority:310
msgid "*\n"
msgstr "*\n"

#. type: Plain text
#: en/gitglossary.txt:24
#, priority:310
msgid "linkgit:gittutorial[7], linkgit:gittutorial-2[7], linkgit:gitcvs-migration[7], linkgit:giteveryday[7], link:user-manual.html[The Git User's Manual]"
msgstr "linkgit:gittutorial[7], linkgit:gittutorial-2[7], linkgit:gitcvs-migration[7], linkgit:giteveryday[7], link:user-manual.html [Git 用户手册]"

#. type: Labeled list
#: en/glossary-content.txt:1
#, no-wrap, priority:310
msgid "[[def_alternate_object_database]]alternate object database"
msgstr "[[def_alternate_object_database]] 轮替对象库(alternate object database)"

#. type: Plain text
#: en/glossary-content.txt:5
#, priority:310
msgid "Via the alternates mechanism, a <<def_repository,repository>> can inherit part of its <<def_object_database,object database>> from another object database, which is called an \"alternate\"."
msgstr "通过替代机制, 一个 <<def_repository,repository>> 能够从另一个对象库中继承 <<def_object_database,object database>> 的一部分对象, 这被称作“轮替”。"

#. type: Labeled list
#: en/glossary-content.txt:6
#, no-wrap, priority:310
msgid "[[def_bare_repository]]bare repository"
msgstr "[[def_bare_repository]]裸仓库(bare repository)"

#. type: Plain text
#: en/glossary-content.txt:16
#, priority:310
msgid "A bare repository is normally an appropriately named <<def_directory,directory>> with a `.git` suffix that does not have a locally checked-out copy of any of the files under revision control. That is, all of the Git administrative and control files that would normally be present in the hidden `.git` sub-directory are directly present in the `repository.git` directory instead, and no other files are present and checked out. Usually publishers of public repositories make bare repositories available."
msgstr "一个裸仓库通常是一个有适当命名的<<def_directory,directory>>，后缀为`.git`，它没有任何版本控制下的文件的本地检出副本。也就是说，所有通常存在于隐藏的`.git`子目录中的Git管理和控制文件都直接存在于`repository.git`目录中，而没有其他文件存在并被检出。通常，公共仓库的发布者会提供裸仓库。"

#. type: Labeled list
#: en/glossary-content.txt:17
#, no-wrap, priority:310
msgid "[[def_blob_object]]blob object"
msgstr "[[def_blob_object]] 数据对象 (blob object)"

#. type: Plain text
#: en/glossary-content.txt:19
#, priority:310
msgid "Untyped <<def_object,object>>, e.g. the contents of a file."
msgstr "无类型的<<def_object,对象>>，比如一个文件的内容。"

#. type: Labeled list
#: en/glossary-content.txt:20
#, no-wrap, priority:310
msgid "[[def_branch]]branch"
msgstr "[[def_branch]] 分支 (branch)"

#. type: Plain text
#: en/glossary-content.txt:30
#, priority:310
msgid "A \"branch\" is a line of development.  The most recent <<def_commit,commit>> on a branch is referred to as the tip of that branch.  The tip of the branch is <<def_ref,referenced>> by a branch <<def_head,head>>, which moves forward as additional development is done on the branch.  A single Git <<def_repository,repository>> can track an arbitrary number of branches, but your <<def_working_tree,working tree>> is associated with just one of them (the \"current\" or \"checked out\" branch), and <<def_HEAD,HEAD>> points to that branch."
msgstr "一个 \"分支 \"就是一条开发线。  一个分支上最近的<<def_commit,commit>>被称为该分支的顶端。  分支的顶端被<<def_ref,引用>>分支<<def_head,head>>引用，当分支上有更多的开发工作时，它就会向前移动。  一个Git<<def_repository,仓库>>可以跟踪任意数量的分支，但你的<<def_working_tree,工作区>>只与其中一个分支（\"当前(current) \"或 \"检出(checked out)\"分支）相关联，而<<def_HEAD,头指针>>指向该分支。"

#. type: Labeled list
#: en/glossary-content.txt:31
#, no-wrap, priority:310
msgid "[[def_cache]]cache"
msgstr "[[def_cache]] 缓存 (cache)"

#. type: Plain text
#: en/glossary-content.txt:33
#, priority:310
msgid "Obsolete for: <<def_index,index>>."
msgstr "已过时：<<def_index，索引>>。"

#. type: Labeled list
#: en/glossary-content.txt:34
#, no-wrap, priority:310
msgid "[[def_chain]]chain"
msgstr "[[def_chain]]（提交）链(chain)"

#. type: Plain text
#: en/glossary-content.txt:38
#, priority:310
msgid "A list of objects, where each <<def_object,object>> in the list contains a reference to its successor (for example, the successor of a <<def_commit,commit>> could be one of its <<def_parent,parents>>)."
msgstr "一个对象的列表，列表中的每个<<def_object,对象>>都包含对其继承者的引用（例如，一个<<def_commit,提交（commit）>>的继承者可以是其<<def_parent,父对象>>之一）。"

#. type: Labeled list
#: en/glossary-content.txt:39
#, no-wrap, priority:310
msgid "[[def_changeset]]changeset"
msgstr "[[def_changeset]] 变更集 (changeset)"

#. type: Plain text
#: en/glossary-content.txt:43
#, priority:310
msgid "BitKeeper/cvsps speak for \"<<def_commit,commit>>\". Since Git does not store changes, but states, it really does not make sense to use the term \"changesets\" with Git."
msgstr "BitKeeper/cvsps是指\"<<def_commit,提交>>\"。由于Git并不存储变化，而是存储状态，所以在Git中使用\"变化集（changesets）\"这个词真的没有意义。"

#. type: Labeled list
#: en/glossary-content.txt:44
#, no-wrap, priority:310
msgid "[[def_checkout]]checkout"
msgstr "[[def_checkout]] 检出 (checkout)"

#. type: Plain text
#: en/glossary-content.txt:51
#, priority:310
msgid "The action of updating all or part of the <<def_working_tree,working tree>> with a <<def_tree_object,tree object>> or <<def_blob_object,blob>> from the <<def_object_database,object database>>, and updating the <<def_index,index>> and <<def_HEAD,HEAD>> if the whole working tree has been pointed at a new <<def_branch,branch>>."
msgstr "用<<def_object_database,对象库>>中的<<def_tree_object,树对象>>或<<def_blob_object,blob>>更新全部或部分<<def_working_tree,工作区>>，如果整个工作树已经指向一个新<<def_branch,分支>>，就更新<<def_index,暂存区>>和<<def_HEAD,头指针>>。"

#. type: Labeled list
#: en/glossary-content.txt:52
#, no-wrap, priority:310
msgid "[[def_cherry-picking]]cherry-picking"
msgstr "[[def_cherry-picking]]拣选（cherry-picking）"

#. type: Plain text
#: en/glossary-content.txt:59
#, priority:310
msgid "In <<def_SCM,SCM>> jargon, \"cherry pick\" means to choose a subset of changes out of a series of changes (typically commits) and record them as a new series of changes on top of a different codebase. In Git, this is performed by the \"git cherry-pick\" command to extract the change introduced by an existing <<def_commit,commit>> and to record it based on the tip of the current <<def_branch,branch>> as a new commit."
msgstr "在<<def_SCM,SCM>>中，\"cherry pick\"意味着从一系列的修改（通常是提交）中选择一个子集，并将其记录为不同代码库之上的一系列新修改。在Git中，这是由\"git cherry-pick\"命令执行的，提取现有<<def_commit,提交>>引入的修改，并根据当前<<def_branch,分支>>的提示，将其记录为新提交。"

#. type: Labeled list
#: en/glossary-content.txt:60
#, no-wrap, priority:310
msgid "[[def_clean]]clean"
msgstr "[[def_clean]]干净（的工作区）"

#. type: Plain text
#: en/glossary-content.txt:64
#, priority:310
msgid "A <<def_working_tree,working tree>> is clean, if it corresponds to the <<def_revision,revision>> referenced by the current <<def_head,head>>. Also see \"<<def_dirty,dirty>>\"."
msgstr "如果一个<<def_working_tree,工作区>>对应于当前<<def_revision,版本>>所引用的<<def_head,头、分支>>，它就是干净的（clean）。另请参见\"<<def_dirty,脏（的工作区）>>\"。"

#. type: Labeled list
#: en/glossary-content.txt:65
#, no-wrap, priority:310
msgid "[[def_commit]]commit"
msgstr "[[def_commit]]提交"

#. type: Plain text
#: en/glossary-content.txt:72
#, priority:310
msgid "As a noun: A single point in the Git history; the entire history of a project is represented as a set of interrelated commits.  The word \"commit\" is often used by Git in the same places other revision control systems use the words \"revision\" or \"version\".  Also used as a short hand for <<def_commit_object,commit object>>."
msgstr "作为名词时，意为：Git 历史中的一个点；一个项目的整个历史被表示为一组相互关联的提交。  Git经常使用\"提交(commit)\"这个词，就像其他版本控制系统使用\"revision\"或\"version\"一样。  也被用作<<def_commit_object,提交对象>>的简称。"

#. type: Plain text
#: en/glossary-content.txt:77
#, priority:310
msgid "As a verb: The action of storing a new snapshot of the project's state in the Git history, by creating a new commit representing the current state of the <<def_index,index>> and advancing <<def_HEAD,HEAD>> to point at the new commit."
msgstr "作为动词时，意为：在 Git 历史中存储一个该项目状态的新快照，通过创建一个代表当前<<def_index,暂存区>>状态的提交，并移动<<def_HEAD,头指针>>指向此新提交。"

#. type: Labeled list
#: en/glossary-content.txt:78
#, no-wrap, priority:310
msgid "[[def_commit_graph_general]]commit graph concept, representations and usage"
msgstr "[[def_commit_graph_general]]提交图示(commit graph)的概念、结构表示和用途"

#. type: Plain text
#: en/glossary-content.txt:85
#, priority:310
msgid "A synonym for the <<def_DAG,DAG>> structure formed by the commits in the object database, <<def_ref,referenced>> by branch tips, using their <<def_chain,chain>> of linked commits.  This structure is the definitive commit graph. The graph can be represented in other ways, e.g. the <<def_commit_graph_file,\"commit-graph\" file>>."
msgstr "由对象数据库中的提交形成的<<def_DAG,有向无环图(DAG)>>，由被<<def_ref,引用>>的分支提示，使用其<<def_chain,对象链(chain)>>的链接提交。  这个结构就是明确的提交图。该图还有其他展示形式，例如<<def_commit_graph_file, \"提交图示\"文件>>。"

#. type: Labeled list
#: en/glossary-content.txt:86
#, no-wrap, priority:310
msgid "[[def_commit_graph_file]]commit-graph file"
msgstr "[[def_commit_graph_file]]提交图示(commit-graph)文件"

#. type: Plain text
#: en/glossary-content.txt:92
#, priority:310
msgid "The \"commit-graph\" (normally hyphenated) file is a supplemental representation of the <<def_commit_graph_general,commit graph>> which accelerates commit graph walks. The \"commit-graph\" file is stored either in the .git/objects/info directory or in the info directory of an alternate object database."
msgstr "“提交图示(ommit-graph)”（通常是连字符）文件是<<def_commit_graph_general,提交图(commit graph)>>的补充表示，可以加速提交图的生成。“提交图示”文件存储在.git/objects/info目录下，或者存储在另一个对象数据库的info目录下。"

#. type: Labeled list
#: en/glossary-content.txt:93
#, no-wrap, priority:310
msgid "[[def_commit_object]]commit object"
msgstr "[[def_commit_object]]提交对象(commit object)"

#. type: Plain text
#: en/glossary-content.txt:99
#, priority:310
msgid "An <<def_object,object>> which contains the information about a particular <<def_revision,revision>>, such as <<def_parent,parents>>, committer, author, date and the <<def_tree_object,tree object>> which corresponds to the top <<def_directory,directory>> of the stored revision."
msgstr "一个<<def_object,对象 >>包含了关于某个特定<<def_revision,版本>>的信息，例如<<def_parent,父提交>>、提交者、作者、日期和<<def_tree_object, 树对象>>（对应于保存的版本顶部<<def_directory,目录>>）。"

#. type: Labeled list
#: en/glossary-content.txt:100
#, no-wrap, priority:310
msgid "[[def_commit-ish]]commit-ish (also committish)"
msgstr "[[def_commit-ish]]提交号[commit-ish (also committish)]"

#. type: Plain text
#: en/glossary-content.txt:111
#, priority:310
msgid "A <<def_commit_object,commit object>> or an <<def_object,object>> that can be recursively dereferenced to a commit object.  The following are all commit-ishes: a commit object, a <<def_tag_object,tag object>> that points to a commit object, a tag object that points to a tag object that points to a commit object, etc."
msgstr "一个<<def_commit_object,提交对象>>或一个<<def_object,对象>>可以递归反向引用到一个提交对象。这些都与提交号(commit-ish)有关：提交对象、指向提交对象的<<def_tag_object,标签对象>>、指向，指向提交对象的标签对象，的标签对象，等等。"

#. type: Labeled list
#: en/glossary-content.txt:112
#, no-wrap, priority:310
msgid "[[def_core_git]]core Git"
msgstr "[[def_core_git]]Git核心(core Git)"

#. type: Plain text
#: en/glossary-content.txt:115
#, priority:310
msgid "Fundamental data structures and utilities of Git. Exposes only limited source code management tools."
msgstr "Git 的基本数据结构和实用工具。只暴露了有限的源代码管理工具。"

#. type: Labeled list
#: en/glossary-content.txt:116
#, no-wrap, priority:310
msgid "[[def_DAG]]DAG"
msgstr "[[def_DAG]]有向无环图(DAG)"

#. type: Plain text
#: en/glossary-content.txt:121
#, priority:310
msgid "Directed acyclic graph. The <<def_commit_object,commit objects>> form a directed acyclic graph, because they have parents (directed), and the graph of commit objects is acyclic (there is no <<def_chain,chain>> which begins and ends with the same <<def_object,object>>)."
msgstr "有向无环图。<<def_commit_object,提交对象>>形成了一个有向无环图，因为它们有父提交（有向），而且提交对象的图是无环的（没有<<def_chain,对象链>>以同一个<<def_object,对象>>开始和结束）。"

#. type: Labeled list
#: en/glossary-content.txt:122
#, no-wrap, priority:310
msgid "[[def_dangling_object]]dangling object"
msgstr "[[def_dangling_object]]悬空对象"

#. type: Plain text
#: en/glossary-content.txt:127
#, priority:310
msgid "An <<def_unreachable_object,unreachable object>> which is not <<def_reachable,reachable>> even from other unreachable objects; a dangling object has no references to it from any reference or <<def_object,object>> in the <<def_repository,repository>>."
msgstr "一个<<def_unreachable_object,不可达对象>>，即使从其他无法可达对象也无法<<def_reachable,可达>>；一个悬空对象在<<def_repository,仓库>>中没有任何引用或<<def_object,对象>>。"

#. type: Labeled list
#: en/glossary-content.txt:128
#, no-wrap, priority:310
msgid "[[def_detached_HEAD]]detached HEAD"
msgstr "[[def_detached_HEAD]分离的头指针(detached HEAD)"

#. type: Plain text
#: en/glossary-content.txt:137
#, priority:310
msgid "Normally the <<def_HEAD,HEAD>> stores the name of a <<def_branch,branch>>, and commands that operate on the history HEAD represents operate on the history leading to the tip of the branch the HEAD points at.  However, Git also allows you to <<def_checkout,check out>> an arbitrary <<def_commit,commit>> that isn't necessarily the tip of any particular branch.  The HEAD in such a state is called \"detached\"."
msgstr "通常，<<def_HEAD,HEAD>>存储的是一个<<def_branch,分支>>的名称，对 HEAD 所代表的历史进行操作的命令会对HEAD所指向的分支的顶端的历史进行操作。然而，Git 也允许你<<def_checkout,签出>>到一个任意的<<def_commit,提交>>，不一定是任何特定分支的顶端。处于这种状态的 HEAD 被称为“分离”。"

#. type: Plain text
#: en/glossary-content.txt:146
#, priority:310
msgid "Note that commands that operate on the history of the current branch (e.g. `git commit` to build a new history on top of it) still work while the HEAD is detached. They update the HEAD to point at the tip of the updated history without affecting any branch.  Commands that update or inquire information _about_ the current branch (e.g. `git branch --set-upstream-to` that sets what remote-tracking branch the current branch integrates with) obviously do not work, as there is no (real) current branch to ask about in this state."
msgstr "请注意，当 HEAD 分离时，对当前分支的历史进行操作的命令（例如，`git commit`在其上建立一个新的历史）仍然有效。它们会更新 HEAD，使其指向更新的历史记录的顶端，而不影响任何分支。更新或查询关于当前分支的信息的命令（例如，`git branch --set-upstream-to`，设置当前分支与哪个远程跟踪分支集成）显然不起作用，因为在这种状态下没有（真正的）当前分支可以查询。"

#. type: Labeled list
#: en/glossary-content.txt:147
#, no-wrap, priority:310
msgid "[[def_directory]]directory"
msgstr "[[def_directory]]目录"

#. type: Plain text
#: en/glossary-content.txt:149
#, priority:310
msgid "The list you get with \"ls\" :-)"
msgstr "你用 \"ls\" 命令得到的列表(─‿‿─)"

#. type: Labeled list
#: en/glossary-content.txt:150
#, no-wrap, priority:310
msgid "[[def_dirty]]dirty"
msgstr "[[def_dirty]]脏（的工作区）(dirty)"

#. type: Plain text
#: en/glossary-content.txt:154
#, priority:310
msgid "A <<def_working_tree,working tree>> is said to be \"dirty\" if it contains modifications which have not been <<def_commit,committed>> to the current <<def_branch,branch>>."
msgstr "如果<<def_working_tree,工作区>>包含的修改没有被<<def_commit,提交>>到当前的<<def_branch,分支>>，就被认为是 \"dirty\" 的。"

#. type: Labeled list
#: en/glossary-content.txt:155
#, no-wrap, priority:310
msgid "[[def_evil_merge]]evil merge"
msgstr "[[def_evil_merge]]坏合并（合并引入了父提交没有的修改）(evil merge)"

#. type: Plain text
#: en/glossary-content.txt:158
#, priority:310
msgid "An evil merge is a <<def_merge,merge>> that introduces changes that do not appear in any <<def_parent,parent>>."
msgstr "一个坏合并，指引入了没有出现在任何<<def_parent,父提交>>中修改的<<def_merge,合并>>。"

#. type: Labeled list
#: en/glossary-content.txt:159
#, no-wrap, priority:310
msgid "[[def_fast_forward]]fast-forward"
msgstr "[[def_fast_forward]]快速合并"

#. type: Plain text
#: en/glossary-content.txt:168
#, priority:310
msgid "A fast-forward is a special type of <<def_merge,merge>> where you have a <<def_revision,revision>> and you are \"merging\" another <<def_branch,branch>>'s changes that happen to be a descendant of what you have. In such a case, you do not make a new <<def_merge,merge>> <<def_commit,commit>> but instead just update your branch to point at the same revision as the branch you are merging. This will happen frequently on a <<def_remote_tracking_branch,remote-tracking branch>> of a remote <<def_repository,repository>>."
msgstr "快速合并是<<def_merge,合并>>的一种特殊类型，即你有一个<<def_revision,版本>>而你正在“合并”另一个<<def_branch,分支>>的修改，这些修改恰好是你的后续提交。在这种情况下，你不需要添加一个新的<<def_merge,合并>> <<def_commit,提交>>而只是更新你的分支，使其指向与你要合并的分支相同的版本。这种情况会经常发生在一个远程<<def_remote_tracking_branch,远程跟踪分支>>的<<def_repository,仓库>>。"

#. type: Labeled list
#: en/glossary-content.txt:169
#, no-wrap, priority:310
msgid "[[def_fetch]]fetch"
msgstr "[[def_fetch]]获取(fetch)"

#. type: Plain text
#: en/glossary-content.txt:175
#, priority:310
msgid "Fetching a <<def_branch,branch>> means to get the branch's <<def_head_ref,head ref>> from a remote <<def_repository,repository>>, to find out which objects are missing from the local <<def_object_database,object database>>, and to get them, too.  See also linkgit:git-fetch[1]."
msgstr "获取一个<<def_branch,分支>>意味着从远程<<def_repository,仓库>>获取该分支的<<def_head_ref,头引用>>，找出本地<<def_object_database,对象库>>中缺失的对象，并获取这些对象。另见 linkgit:git-fetch[1]。"

#. type: Labeled list
#: en/glossary-content.txt:176
#, no-wrap, priority:310
msgid "[[def_file_system]]file system"
msgstr "[[def_file_system]]文件系统"

#. type: Plain text
#: en/glossary-content.txt:180
#, priority:310
msgid "Linus Torvalds originally designed Git to be a user space file system, i.e. the infrastructure to hold files and directories. That ensured the efficiency and speed of Git."
msgstr "Linus Torvalds （林纳斯·本纳第克特·托瓦兹；Git的作者、Linux之父）最初将 Git 设计为用户空间文件系统，即用于保存文件和目录的基础结构。这确保了 Git 的效率和速度。"

#. type: Labeled list
#: en/glossary-content.txt:181
#, no-wrap, priority:310
msgid "[[def_git_archive]]Git archive"
msgstr "[[def_git_archive]]仓库（对于arch用户）(Git archive)"

#. type: Plain text
#: en/glossary-content.txt:183
#, priority:310
msgid "Synonym for <<def_repository,repository>> (for arch people)."
msgstr "与<<def_repository,仓库>> 同义(对于arch用户)。"

#. type: Labeled list
#: en/glossary-content.txt:184
#, no-wrap, priority:310
msgid "[[def_gitfile]]gitfile"
msgstr "[[def_gitfile]]gitfile（仓库链接文件）"

#. type: Plain text
#: en/glossary-content.txt:187
#, priority:310
msgid "A plain file `.git` at the root of a working tree that points at the directory that is the real repository."
msgstr "在工作区根部的普通文件 `.git`，指向真正的版本库目录。"

#. type: Labeled list
#: en/glossary-content.txt:188
#, no-wrap, priority:310
msgid "[[def_grafts]]grafts"
msgstr "[[def_grafts]]（提交）移植(grafts)"

#. type: Plain text
#: en/glossary-content.txt:194
#, priority:310
msgid "Grafts enables two otherwise different lines of development to be joined together by recording fake ancestry information for commits. This way you can make Git pretend the set of <<def_parent,parents>> a <<def_commit,commit>> has is different from what was recorded when the commit was created. Configured via the `.git/info/grafts` file."
msgstr "移植（Grafts）通过记录提交的虚假祖先信息，使两条原本不同的开发线连接在一起。这样你就可以让 Git 假装<<def_commit,提交>>的一组<<def_parent,父提交>>与创建提交(commit)时的记录不同。通过 `.git/info/grafts` 文件进行配置。"

#. type: Plain text
#: en/glossary-content.txt:198
#, priority:310
msgid "Note that the grafts mechanism is outdated and can lead to problems transferring objects between repositories; see linkgit:git-replace[1] for a more flexible and robust system to do the same thing."
msgstr "请注意，移植（Grafts）机制已经过时了，可能会导致在仓库之间转移对象的问题；参见 linkgit:git-replace[1] ，这是一个更灵活更强大的系统，可以做同样的事情。"

#. type: Labeled list
#: en/glossary-content.txt:199
#, no-wrap, priority:310
msgid "[[def_hash]]hash"
msgstr "[[def_hash]]哈希（hash）"

#. type: Plain text
#: en/glossary-content.txt:201
#, priority:310
msgid "In Git's context, synonym for <<def_object_name,object name>>."
msgstr "在 Git 的上下文中，是<<def_object_name,对象名称>>的同义词。"

#. type: Labeled list
#: en/glossary-content.txt:202
#, no-wrap, priority:310
msgid "[[def_head]]head"
msgstr "[[def_head]]头/分支(head)"

#. type: Plain text
#: en/glossary-content.txt:207
#, priority:310
msgid "A <<def_ref,named reference>> to the <<def_commit,commit>> at the tip of a <<def_branch,branch>>.  Heads are stored in a file in `$GIT_DIR/refs/heads/` directory, except when using packed refs. (See linkgit:git-pack-refs[1].)"
msgstr "一个<<def_ref,命名引用>>到<<def_commit,提交>>在<<def_branch,分支>>的顶端。头部存储在 `$GIT_DIR/refs/heads/` 目录下的一个文件中，除非使用打包的 refs（参见 linkgit:git-pack-refs[1]）。"

#. type: Labeled list
#: en/glossary-content.txt:208
#, no-wrap, priority:310
msgid "[[def_HEAD]]HEAD"
msgstr "[[def_HEAD]]HEAD（头指针，亦即当前分支）"

#. type: Plain text
#: en/glossary-content.txt:215
#, priority:310
msgid "The current <<def_branch,branch>>.  In more detail: Your <<def_working_tree, working tree>> is normally derived from the state of the tree referred to by HEAD.  HEAD is a reference to one of the <<def_head,heads>> in your repository, except when using a <<def_detached_HEAD,detached HEAD>>, in which case it directly references an arbitrary commit."
msgstr "当前<<def_branch,分支>>。详细地讲，你的<<def_working_tree,工作区>>通常是由 HEAD 所指的树的状态衍生出来的。HEAD 是对你的版本库中的一个<<def_head,头>>的引用，除非使用<<def_detached_HEAD,分离的 HEAD>>，这种情况下它直接引用一个任意的提交。"

#. type: Labeled list
#: en/glossary-content.txt:216
#, no-wrap, priority:310
msgid "[[def_head_ref]]head ref"
msgstr "[[def_head_ref]]头引用"

#. type: Plain text
#: en/glossary-content.txt:218
#, priority:310
msgid "A synonym for <<def_head,head>>."
msgstr "<<def_head,头>>的同义词。"

#. type: Labeled list
#: en/glossary-content.txt:219
#, no-wrap, priority:310
msgid "[[def_hook]]hook"
msgstr "[[def_hook]钩子"

#. type: Plain text
#: en/glossary-content.txt:228
#, priority:310
msgid "During the normal execution of several Git commands, call-outs are made to optional scripts that allow a developer to add functionality or checking. Typically, the hooks allow for a command to be pre-verified and potentially aborted, and allow for a post-notification after the operation is done. The hook scripts are found in the `$GIT_DIR/hooks/` directory, and are enabled by simply removing the `.sample` suffix from the filename. In earlier versions of Git you had to make them executable."
msgstr "在几个 Git 命令的正常执行过程中，会对可选的脚本进行调用，允许开发者添加功能或检查。通常情况下，钩子允许一个命令被预先验证并可能中止执行，并允许在操作完成后发出通知。钩子脚本可以在 `$GIT_DIR/hooks/` 目录下找到，只需将文件名中的 `.sample` 后缀去掉即可启用。在早期版本的 Git 中，你必须将它们设置为可执行。"

#. type: Labeled list
#: en/glossary-content.txt:229
#, no-wrap, priority:310
msgid "[[def_index]]index"
msgstr "[[def_index]]索引"

#. type: Plain text
#: en/glossary-content.txt:235
#, priority:310
msgid "A collection of files with stat information, whose contents are stored as objects. The index is a stored version of your <<def_working_tree,working tree>>. Truth be told, it can also contain a second, and even a third version of a working tree, which are used when <<def_merge,merging>>."
msgstr "一个带有统计信息的文件集合，其内容以对象形式存储。索引是你的<<def_working_tree,工作区>>的一个存储版本。事实上它也可以包含第二个，甚至第三个版本的工作区，这些在<<def_merge,合并>>时使用。"

#. type: Labeled list
#: en/glossary-content.txt:236
#, no-wrap, priority:310
msgid "[[def_index_entry]]index entry"
msgstr "[[def_index_entry]]索引项"

#. type: Plain text
#: en/glossary-content.txt:241
#, priority:310
msgid "The information regarding a particular file, stored in the <<def_index,index>>. An index entry can be unmerged, if a <<def_merge,merge>> was started, but not yet finished (i.e. if the index contains multiple versions of that file)."
msgstr "关于某个特定文件的信息，存储在<<def_index,索引/暂存区>>。如果<<def_merge,合并>>已经开始，但尚未完成（即如果索引包含该文件的多个版本），则索引条目可以取消合并。"

#. type: Labeled list
#: en/glossary-content.txt:242
#, no-wrap, priority:310
msgid "[[def_master]]master"
msgstr "[[def_master]]master（默认分支名）"

#. type: Plain text
#: en/glossary-content.txt:248
#, priority:310
msgid "The default development <<def_branch,branch>>. Whenever you create a Git <<def_repository,repository>>, a branch named \"master\" is created, and becomes the active branch. In most cases, this contains the local development, though that is purely by convention and is not required."
msgstr "默认的开发<<def_branch,分支 >>。每当你创建一个 Git <<def_repository,仓库>>，就会创建一个名为 \"master\" 的分支，并成为活动分支。在大多数情况下，它包含了本地的开发内容，但这纯粹是惯例，并不是必须的。"

#. type: Labeled list
#: en/glossary-content.txt:249
#, no-wrap, priority:310
msgid "[[def_merge]]merge"
msgstr "[[def_merge]合并"

#. type: Plain text
#: en/glossary-content.txt:262
#, priority:310
msgid "As a verb: To bring the contents of another <<def_branch,branch>> (possibly from an external <<def_repository,repository>>) into the current branch.  In the case where the merged-in branch is from a different repository, this is done by first <<def_fetch,fetching>> the remote branch and then merging the result into the current branch.  This combination of fetch and merge operations is called a <<def_pull,pull>>.  Merging is performed by an automatic process that identifies changes made since the branches diverged, and then applies all those changes together.  In cases where changes conflict, manual intervention may be required to complete the merge."
msgstr "作为动词。将另一个<<def_branch,分支>>（可能来自外部<<def_repository,仓库>>）的内容引入当前分支。在被合并的分支来自不同的仓库的情况下，这是通过首先<<def_fetch,抓取>>远程分支，然后将结果合并到当前分支来实现的。这种获取和合并操作的组合被称为<<def_pull,拉取>>。合并是由一个自动过程进行的，该过程会识别自分支分歧以来的变化，然后将所有这些变化应用在一起。在变化发生冲突的情况下，可能需要人工干预来完成合并。"

#. type: Plain text
#: en/glossary-content.txt:269
#, priority:310
msgid "As a noun: unless it is a <<def_fast_forward,fast-forward>>, a successful merge results in the creation of a new <<def_commit,commit>> representing the result of the merge, and having as <<def_parent,parents>> the tips of the merged <<def_branch,branches>>.  This commit is referred to as a \"merge commit\", or sometimes just a \"merge\"."
msgstr "作为名词，除非是<<def_fast_forward,快速合并>>，否则一个成功的合并会产生一个新的<<def_commit,提交>>，代表合并的结果，并且有<<def_parent,父提交>>与<<def_branch,分支>> 合并的提示。这种提交被称为\"合并提交\"，或者有时只是\"合并\"。"

#. type: Labeled list
#: en/glossary-content.txt:270
#, no-wrap, priority:310
msgid "[[def_object]]object"
msgstr "[[def_object]]对象"

#. type: Plain text
#: en/glossary-content.txt:274
#, priority:310
msgid "The unit of storage in Git. It is uniquely identified by the <<def_SHA1,SHA-1>> of its contents. Consequently, an object cannot be changed."
msgstr "Git中的存储单位。它由其内容的<<def_SHA1,SHA-1>>作为唯一的标识。因此，一个对象不能被改变。"

#. type: Labeled list
#: en/glossary-content.txt:275
#, no-wrap, priority:310
msgid "[[def_object_database]]object database"
msgstr "[[def_object_database]对象库"

#. type: Plain text
#: en/glossary-content.txt:279
#, priority:310
msgid "Stores a set of \"objects\", and an individual <<def_object,object>> is identified by its <<def_object_name,object name>>. The objects usually live in `$GIT_DIR/objects/`."
msgstr "存储一组\"对象\"，一个单独的<<def_object,对象>>由其<<def_object_name,对象名称>>标识。这些对象通常存在于`$GIT_DIR/objects/`中。"

#. type: Labeled list
#: en/glossary-content.txt:280
#, no-wrap, priority:310
msgid "[[def_object_identifier]]object identifier (oid)"
msgstr "[[def_object_identifier]]对象标识符[object identifier (oid)]"

#. type: Plain text
#: en/glossary-content.txt:282
#, priority:310
msgid "Synonym for <<def_object_name,object name>>."
msgstr "<<def_object_name,对象名称>>的同义词。"

#. type: Labeled list
#: en/glossary-content.txt:283
#, no-wrap, priority:310
msgid "[[def_object_name]]object name"
msgstr "[[def_object_name]]对象名称"

#. type: Plain text
#: en/glossary-content.txt:287
#, priority:310
msgid "The unique identifier of an <<def_object,object>>.  The object name is usually represented by a 40 character hexadecimal string.  Also colloquially called <<def_SHA1,SHA-1>>."
msgstr "一个<<def_object,对象>>的唯一标识。对象名称通常由40个字符的十六进制字符串表示。也被称为<<def_SHA1,SHA-1>>。"

#. type: Labeled list
#: en/glossary-content.txt:288
#, no-wrap, priority:310
msgid "[[def_object_type]]object type"
msgstr "[[def_object_type]]对象类型"

#. type: Plain text
#: en/glossary-content.txt:293
#, priority:310
msgid "One of the identifiers \"<<def_commit_object,commit>>\", \"<<def_tree_object,tree>>\", \"<<def_tag_object,tag>>\" or \"<<def_blob_object,blob>>\" describing the type of an <<def_object,object>>."
msgstr "其中一个标识符\"<<def_commit_object,提交>>\", \"<<def_tree_object,树>>\", \"<<def_tag_object,标签>>\"或\"<<def_blob_object,blob>>\"描述一个<<def_object,对象>的类型。"

#. type: Labeled list
#: en/glossary-content.txt:294
#, no-wrap, priority:310
msgid "[[def_octopus]]octopus"
msgstr "[[def_octopus]]章鱼式合并（两分支以上的合并）(octopus)"

#. type: Plain text
#: en/glossary-content.txt:296
#, priority:310
msgid "To <<def_merge,merge>> more than two <<def_branch,branches>>."
msgstr "<<def_merge,合并>>两个以上的<<def_branch,分支>>。"

#. type: Labeled list
#: en/glossary-content.txt:297
#, no-wrap, priority:310
msgid "[[def_origin]]origin"
msgstr "[[def_origin]]origin（默认的远程名称）"

#. type: Plain text
#: en/glossary-content.txt:304
#, priority:310
msgid "The default upstream <<def_repository,repository>>. Most projects have at least one upstream project which they track. By default 'origin' is used for that purpose. New upstream updates will be fetched into <<def_remote_tracking_branch,remote-tracking branches>> named origin/name-of-upstream-branch, which you can see using `git branch -r`."
msgstr "默认的上游<<def_repository,仓库>>。大多数项目至少有一个上游项目，它们会对其进行跟踪。默认情况下，'origin'被用于此目的。新的上游更新会被拉取到<<def_remote_tracking_branch,远程跟踪分支>>，名为origin/name-of-upstream-branch，你可以用`git branch -r`看到。"

#. type: Labeled list
#: en/glossary-content.txt:305
#, no-wrap, priority:310
msgid "[[def_overlay]]overlay"
msgstr "[[def_overlay]]覆盖(overlay)"

#. type: Plain text
#: en/glossary-content.txt:313
#, priority:310
msgid "Only update and add files to the working directory, but don't delete them, similar to how 'cp -R' would update the contents in the destination directory.  This is the default mode in a <<def_checkout,checkout>> when checking out files from the <<def_index,index>> or a <<def_tree-ish,tree-ish>>.  In contrast, no-overlay mode also deletes tracked files not present in the source, similar to 'rsync --delete'."
msgstr "只更新和添加文件到工作目录，但不删除它们，类似于'cp -R'会更新目标目录中的内容。这是<<def_checkout,检出>>中的默认模式，当从<<def_index,暂存区>>或<<def_tree-ish,树对象(tree-ish)>>中检出文件时。相反，非覆盖模式也会删除源文件中不存在的跟踪文件，类似于'rsync --delete'。"

#. type: Labeled list
#: en/glossary-content.txt:314
#, no-wrap, priority:310
msgid "[[def_pack]]pack"
msgstr "[[def_pack]包(pack)"

#. type: Plain text
#: en/glossary-content.txt:317
#, priority:310
msgid "A set of objects which have been compressed into one file (to save space or to transmit them efficiently)."
msgstr "一组被压缩成一个文件的对象（以节省空间或有效传输）。"

#. type: Labeled list
#: en/glossary-content.txt:318
#, no-wrap, priority:310
msgid "[[def_pack_index]]pack index"
msgstr "[[def_pack_index]]包索引(pack index)"

#. type: Plain text
#: en/glossary-content.txt:322
#, priority:310
msgid "The list of identifiers, and other information, of the objects in a <<def_pack,pack>>, to assist in efficiently accessing the contents of a pack."
msgstr "<<def_pack,包>>中的对象的标识符和其他信息的列表，以协助有效地访问一个包的内容。"

#. type: Labeled list
#: en/glossary-content.txt:323
#, no-wrap, priority:310
msgid "[[def_pathspec]]pathspec"
msgstr "[[def_pathspec]]路径规范(pathspec)"

#. type: Plain text
#: en/glossary-content.txt:325
#, priority:310
msgid "Pattern used to limit paths in Git commands."
msgstr "用来限制Git命令中的路径的模式。"

#. type: Plain text
#: en/glossary-content.txt:333
#, priority:310
msgid "Pathspecs are used on the command line of \"git ls-files\", \"git ls-tree\", \"git add\", \"git grep\", \"git diff\", \"git checkout\", and many other commands to limit the scope of operations to some subset of the tree or working tree.  See the documentation of each command for whether paths are relative to the current directory or toplevel.  The pathspec syntax is as follows:"
msgstr "在 \"git ls-files\"、\"git ls-tree\"、\"git add\"、\"git grep\"、\"git diff\"、\"git checkout \"和许多其他命令的命令行中，路径规格被用来将操作范围限制在树或工作区的某个子集。  关于路径是相对于当前目录还是顶层，请参阅每个命令的文档。  pathspec的语法如下："

#. type: Plain text
#: en/glossary-content.txt:337
#, priority:310
msgid "any path matches itself"
msgstr "任何路径都与自己匹配"

#. type: Plain text
#: en/glossary-content.txt:340
#, priority:310
msgid "the pathspec up to the last slash represents a directory prefix.  The scope of that pathspec is limited to that subtree."
msgstr "到最后一个斜线的路径规范代表一个目录前缀。  该路径规范的范围只限于该子树。"

#. type: Plain text
#: en/glossary-content.txt:344
#, priority:310
msgid "the rest of the pathspec is a pattern for the remainder of the pathname.  Paths relative to the directory prefix will be matched against that pattern using fnmatch(3); in particular, '*' and '?' _can_ match directory separators."
msgstr "路径规范的其余部分是路径名其余部分的模式。  相对于目录前缀的路径将使用fnmatch(3)（匹配函数）与该模式进行匹配；特别是，‘*’和‘?’_可以_匹配目录分隔符。"

#. type: Plain text
#: en/glossary-content.txt:350
#, priority:310
msgid "For example, Documentation/*.jpg will match all .jpg files in the Documentation subtree, including Documentation/chapter_1/figure_1.jpg."
msgstr "例如，Documentation/*.jpg将匹配Documentation子树中的所有.jpg文件，包括Documentation/chapter_1/figure_1.jpg。"

#. type: Plain text
#: en/glossary-content.txt:360
#, priority:310
msgid "A pathspec that begins with a colon `:` has special meaning.  In the short form, the leading colon `:` is followed by zero or more \"magic signature\" letters (which optionally is terminated by another colon `:`), and the remainder is the pattern to match against the path.  The \"magic signature\" consists of ASCII symbols that are neither alphanumeric, glob, regex special characters nor colon.  The optional colon that terminates the \"magic signature\" can be omitted if the pattern begins with a character that does not belong to \"magic signature\" symbol set and is not a colon."
msgstr "以冒号`:`开头的路径规范有特殊含义。  在简短的形式中，前面的冒号`:`后面是0个或更多的 “魔术签名(magic signature)”（可以选择以另一个冒号`:`结束），剩下的部分是与路径匹配的模式。  “魔术签名”由ASCII符号组成，这些符号既不是字母数字、glob、regex特殊字符也不是冒号。  如果模式以不属于“魔术签名”符号集的字符开始，并且不是冒号，那么结束“魔术签名”的可选冒号就可以省略。"

#. type: Plain text
#: en/glossary-content.txt:365
#, priority:310
msgid "In the long form, the leading colon `:` is followed by an open parenthesis `(`, a comma-separated list of zero or more \"magic words\", and a close parentheses `)`, and the remainder is the pattern to match against the path."
msgstr "在较长规范中，前面的冒号`:`后面是一个开放的小括号`(`，一个用逗号分隔的0个或多个 “魔术单词”列表，以及一个封闭的小括号`)`，其余部分是要与路径匹配的模式。"

#. type: Plain text
#: en/glossary-content.txt:368
#, priority:310
msgid "A pathspec with only a colon means \"there is no pathspec\". This form should not be combined with other pathspec."
msgstr "一个只有冒号的路径规范意味着 “不使用路径规范”。这种形式不应该与其他路径规范结合。"

#. type: Labeled list
#: en/glossary-content.txt:370
#, no-wrap, priority:310
msgid "top"
msgstr "顶部(top)"

#. type: Plain text
#: en/glossary-content.txt:374
#, priority:310
msgid "The magic word `top` (magic signature: `/`) makes the pattern match from the root of the working tree, even when you are running the command from inside a subdirectory."
msgstr "魔术词`top`（魔术签名：`/`）使模式从工作区的根目录开始匹配，即使你从子目录内运行命令。"

#. type: Labeled list
#: en/glossary-content.txt:375
#, no-wrap, priority:310
msgid "literal"
msgstr "字面量(literal)"

#. type: Plain text
#: en/glossary-content.txt:378
#, priority:310
msgid "Wildcards in the pattern such as `*` or `?` are treated as literal characters."
msgstr "模式中的通配符，如`*`或`?`被视为字面量字符。"

#. type: Labeled list
#: en/glossary-content.txt:379
#, no-wrap, priority:310
msgid "icase"
msgstr "不敏感匹配(icase)"

#. type: Plain text
#: en/glossary-content.txt:381
#, priority:310
msgid "Case insensitive match."
msgstr "不区分大小写的匹配。"

#. type: Labeled list
#: en/glossary-content.txt:382
#, no-wrap, priority:310
msgid "glob"
msgstr "通配符"

#. type: Plain text
#: en/glossary-content.txt:389
#, priority:310
msgid "Git treats the pattern as a shell glob suitable for consumption by fnmatch(3) with the FNM_PATHNAME flag: wildcards in the pattern will not match a / in the pathname.  For example, \"Documentation/{asterisk}.html\" matches \"Documentation/git.html\" but not \"Documentation/ppc/ppc.html\" or \"tools/perf/Documentation/perf.html\"."
msgstr "Git将模式视为适合fnmatch(3)（匹配函数）使用shell的glob模式（shell 所使用的简化了的正则表达式），带有FNM_PATHNAME标志:模式中的通配符将不匹配路径名中的/（即不对子目录或上级目录进行匹配）。例如，\"Documentation/{asterisk}.html\"匹配\"Documentation/git.html\"，而不是\"Documentation/ppc/ppc.html\"或\"tools/perf/Documentation/perff.html\"。"

#. type: Plain text
#: en/glossary-content.txt:392
#, priority:310
msgid "Two consecutive asterisks (\"`**`\") in patterns matched against full pathname may have special meaning:"
msgstr "在与全路径名匹配的模式中，两个连续的星号（\"`**`\"）可能有特殊含义："

#. type: Plain text
#: en/glossary-content.txt:398
#, priority:310
msgid "A leading \"`**`\" followed by a slash means match in all directories. For example, \"`**/foo`\" matches file or directory \"`foo`\" anywhere, the same as pattern \"`foo`\". \"`**/foo/bar`\" matches file or directory \"`bar`\" anywhere that is directly under directory \"`foo`\"."
msgstr "\"`**`\"在带斜杠目录之前，表示在所有目录中匹配。例如，\"`**/foo`\"匹配任何文件或目录的\"`foo`\"，与模式\"`foo`\"相同。\"`**/foo/bar`\"匹配任何文件或目录中直接位于目录\"`foo`\"之下的\"`bar`\"。"

#. type: Plain text
#: en/glossary-content.txt:402
#, priority:310
msgid "A trailing \"`/**`\" matches everything inside. For example, \"`abc/**`\" matches all files inside directory \"abc\", relative to the location of the `.gitignore` file, with infinite depth."
msgstr "路径后跟有\"`/**`\"表示匹配这个目录里面的所有文件。例如，\"`abc/**`\"匹配相对于`.gitignore`文件的位置中目录 \"abc \"内的所有文件，深度无限。"

#. type: Plain text
#: en/glossary-content.txt:406
#, priority:310
msgid "A slash followed by two consecutive asterisks then a slash matches zero or more directories. For example, \"`a/**/b`\" matches \"`a/b`\", \"`a/x/b`\", \"`a/x/y/b`\" and so on."
msgstr "一个斜杠后面是两个连续的星号再接上一个斜杠，匹配零个或多个目录。例如，\"`a/**/b`\" 匹配 \"`a/b`\"、\"`a/x/b`\"、\"`a/x/y/b`\"，等等，依此类推。"

#. type: Plain text
#: en/glossary-content.txt:408
#, priority:310
msgid "Other consecutive asterisks are considered invalid."
msgstr "其他连续的星号是无效的。"

#. type: Plain text
#: en/glossary-content.txt:410
#, priority:310
msgid "Glob magic is incompatible with literal magic."
msgstr "通配符魔术词(glob)与字面量魔术词(literal)是不相容的。"

#. type: Labeled list
#: en/glossary-content.txt:411
#, no-wrap, priority:310
msgid "attr"
msgstr "属性匹配"

#. type: Plain text
#: en/glossary-content.txt:417
#, priority:310
msgid "After `attr:` comes a space separated list of \"attribute requirements\", all of which must be met in order for the path to be considered a match; this is in addition to the usual non-magic pathspec pattern matching.  See linkgit:gitattributes[5]."
msgstr "在`attr:` 之后是一个空格分隔的“属性要求”列表，所有这些都必须满足才能被认为是匹配的路径;这是在通常的非魔法路径规范模式匹配之外的。参见linkgit:gitattributes[5]。"

#. type: Plain text
#: en/glossary-content.txt:420
#, priority:310
msgid "Each of the attribute requirements for the path takes one of these forms:"
msgstr "以下包含了路径的每个属性要求："

#. type: Plain text
#: en/glossary-content.txt:422
#, priority:310
msgid "\"`ATTR`\" requires that the attribute `ATTR` be set."
msgstr "\"`ATTR`\"表示要求设置`ATTR`属性。"

#. type: Plain text
#: en/glossary-content.txt:424
#, priority:310
msgid "\"`-ATTR`\" requires that the attribute `ATTR` be unset."
msgstr "\"`-ATTR`\"要求属性`ATTR`没有设置。"

#. type: Plain text
#: en/glossary-content.txt:427
#, priority:310
msgid "\"`ATTR=VALUE`\" requires that the attribute `ATTR` be set to the string `VALUE`."
msgstr "\"`ATTR=VALUE`\"要求将属性`ATTR`设置为字符串`VALUE`。"

#. type: Plain text
#: en/glossary-content.txt:430
#, priority:310
msgid "\"`!ATTR`\" requires that the attribute `ATTR` be unspecified."
msgstr "\"`!ATTR`\"要求属性`ATTR`是未指定的。"

#. type: Plain text
#: en/glossary-content.txt:433
#, priority:310
msgid "Note that when matching against a tree object, attributes are still obtained from working tree, not from the given tree object."
msgstr "注意，当与树对象进行匹配时，属性仍然是从工作区中获得的，而不是从给定的树对象中获得。"

#. type: Labeled list
#: en/glossary-content.txt:434
#, no-wrap, priority:310
msgid "exclude"
msgstr "排除匹配(exclude)"

#. type: Plain text
#: en/glossary-content.txt:440
#, priority:310
msgid "After a path matches any non-exclude pathspec, it will be run through all exclude pathspecs (magic signature: `!` or its synonym `^`). If it matches, the path is ignored.  When there is no non-exclude pathspec, the exclusion is applied to the result set as if invoked without any pathspec."
msgstr "当一个路径匹配了任何规则之外的(non-exclude)路径规范后，它将遍历所有的排除性路径规范（魔术签名：`！`或其同义词`^`）。如果匹配，该路径将被忽略。  当没有规则之外路径规范时，排除法将应用于结果集，就像在没有任何路径规范的情况下调用。"

#. type: Labeled list
#: en/glossary-content.txt:442
#, no-wrap, priority:310
msgid "[[def_parent]]parent"
msgstr "[[def_parent]]父提交(parent)"

#. type: Plain text
#: en/glossary-content.txt:446
#, priority:310
msgid "A <<def_commit_object,commit object>> contains a (possibly empty) list of the logical predecessor(s) in the line of development, i.e. its parents."
msgstr "一个<<def_commit_object,提交对象>>包含一个开发中的逻辑前驱列表（可能是空的），即其父提交。"

#. type: Labeled list
#: en/glossary-content.txt:447
#, no-wrap, priority:310
msgid "[[def_pickaxe]]pickaxe"
msgstr "[[def_pickaxe]]挖掘(pickaxe)"

#. type: Plain text
#: en/glossary-content.txt:453
#, priority:310
msgid "The term <<def_pickaxe,pickaxe>> refers to an option to the diffcore routines that help select changes that add or delete a given text string. With the `--pickaxe-all` option, it can be used to view the full <<def_changeset,changeset>> that introduced or removed, say, a particular line of text. See linkgit:git-diff[1]."
msgstr "术语<<def_pickaxe,挖掘>>指的是diff核心例程(diffcore)的一个选项，辅助选择增加或删除特定文本字符串的变化。通过`--pickaxe-all`选项，它可以用来查看引入或删除的全部<<def_changeset,变更集>>，例如某一行文字。参见linkgit:git-diff[1]。"

#. type: Labeled list
#: en/glossary-content.txt:454
#, no-wrap, priority:310
msgid "[[def_plumbing]]plumbing"
msgstr "[[def_plumbing]]管件(plumbing)"

#. type: Plain text
#: en/glossary-content.txt:456
#, priority:310
msgid "Cute name for <<def_core_git,core Git>>."
msgstr "<<def_core_git,Git核心>>的昵称。"

#. type: Labeled list
#: en/glossary-content.txt:457
#, no-wrap, priority:310
msgid "[[def_porcelain]]porcelain"
msgstr "[[def_porcelain]]瓷件(porcelain)"

#. type: Plain text
#: en/glossary-content.txt:462
#, priority:310
msgid "Cute name for programs and program suites depending on <<def_core_git,core Git>>, presenting a high level access to core Git. Porcelains expose more of a <<def_SCM,SCM>> interface than the <<def_plumbing,plumbing>>."
msgstr "依靠<<def_core_git,Git核心>>的程序和程序套件的昵称，是对Git核心上层封装。与<<def_plumbing,管件>>相比，瓷件暴露了更多<<def_SCM,SCM>>接口。"

#. type: Labeled list
#: en/glossary-content.txt:463
#, no-wrap, priority:310
msgid "[[def_per_worktree_ref]]per-worktree ref"
msgstr "[[def_per_worktree_ref]]工作区引用(per-worktree ref)"

#. type: Plain text
#: en/glossary-content.txt:468
#, priority:310
msgid "Refs that are per-<<def_worktree,worktree>>, rather than global.  This is presently only <<def_HEAD,HEAD>> and any refs that start with `refs/bisect/`, but might later include other unusual refs."
msgstr "相比于全局引用，它是对每个<<def_worktree,工作区>>的引用。  目前只有<<def_HEAD,HEAD>>和任何以`refs/bisect/`开头的引用，但以后可能包括其他不寻常的引用。"

#. type: Labeled list
#: en/glossary-content.txt:469
#, no-wrap, priority:310
msgid "[[def_pseudoref]]pseudoref"
msgstr "[[def_pseudoref]]伪引用(pseudoref)"

#. type: Plain text
#: en/glossary-content.txt:484
#, priority:310
msgid "Pseudorefs are a class of files under `$GIT_DIR` which behave like refs for the purposes of rev-parse, but which are treated specially by git.  Pseudorefs both have names that are all-caps, and always start with a line consisting of a <<def_SHA1,SHA-1>> followed by whitespace.  So, HEAD is not a pseudoref, because it is sometimes a symbolic ref.  They might optionally contain some additional data.  `MERGE_HEAD` and `CHERRY_PICK_HEAD` are examples.  Unlike <<def_per_worktree_ref,per-worktree refs>>, these files cannot be symbolic refs, and never have reflogs.  They also cannot be updated through the normal ref update machinery.  Instead, they are updated by directly writing to the files.  However, they can be read as if they were refs, so `git rev-parse MERGE_HEAD` will work."
msgstr "伪引用是`$GIT_DIR`下的一类文件，其行为与修订-剖析(rev-parse)中的引用一样，但被Git区分对待。  伪引用的名字一般是由由一行<<def_SHA1,SHA-1>>开始，然后是空格。  所以，HEAD并不是一个伪引用，因为它有时是一个符号性引用。  它可能选择性地包含一些额外的数据。  比如`MERGE_HEAD`和`CHERRY_PICK_HEAD`。  与<<def_per_worktree_ref,工作区引用>>不同，这些文件不能是符号引用，也没有引用日志。  它们也不能通过正常的引用更新机制进行更新。  相反，它们是通过直接写入文件来更新的。  不过，它们可以被当作引用读取，所以 `git rev-parse MERGE_HEAD` 仍可以运行。"

#. type: Labeled list
#: en/glossary-content.txt:485
#, no-wrap, priority:310
msgid "[[def_pull]]pull"
msgstr "[[def_pull]]拉取(pull)"

#. type: Plain text
#: en/glossary-content.txt:488
#, priority:310
msgid "Pulling a <<def_branch,branch>> means to <<def_fetch,fetch>> it and <<def_merge,merge>> it.  See also linkgit:git-pull[1]."
msgstr "拉取一个<<def_branch,分支>>意味着<<def_fetch,获取>>一个分支并且<<def_merge,合并>>这个分支。  另见 linkgit:git-pull[1]。"

#. type: Labeled list
#: en/glossary-content.txt:489
#, no-wrap, priority:310
msgid "[[def_push]]push"
msgstr "[[def_push]]推送(push)"

#. type: Plain text
#: en/glossary-content.txt:500
#, priority:310
msgid "Pushing a <<def_branch,branch>> means to get the branch's <<def_head_ref,head ref>> from a remote <<def_repository,repository>>, find out if it is an ancestor to the branch's local head ref, and in that case, putting all objects, which are <<def_reachable,reachable>> from the local head ref, and which are missing from the remote repository, into the remote <<def_object_database,object database>>, and updating the remote head ref. If the remote <<def_head,head>> is not an ancestor to the local head, the push fails."
msgstr "推送一个<<def_branch,分支>>意味着从远程的<<def_repository,仓库>>获取该分支的<<def_head_ref,头引用>>，找出它是否是该分支的本地分支引用的一个祖先。在这种情况下，将所有从本地分支引用<<def_reachable,可达>>的对象，以及从远程仓库中丢失的对象，放入远程<<def_object_database,对象库>>，并更新远程分支引用。如果远程<<def_head,头/分支>>不是本地分支的祖先，则推送失败。"

#. type: Labeled list
#: en/glossary-content.txt:501
#, no-wrap, priority:310
msgid "[[def_reachable]]reachable"
msgstr "[[def_reachable]]可达的（reachable）"

#. type: Plain text
#: en/glossary-content.txt:510
#, priority:310
msgid "All of the ancestors of a given <<def_commit,commit>> are said to be \"reachable\" from that commit. More generally, one <<def_object,object>> is reachable from another if we can reach the one from the other by a <<def_chain,chain>> that follows <<def_tag,tags>> to whatever they tag, <<def_commit_object,commits>> to their parents or trees, and <<def_tree_object,trees>> to the trees or <<def_blob_object,blobs>> that they contain."
msgstr "一个给定的<<def_commit,提交>>的所有祖先都被称为可以从该提交 “到达”。更一般地说，如果一个<<def_object,对象>>可以通过<<def_chain,对象链>>从一个<<def_tag,标签>>到达任意一个对象链标记的<<def_tag,标签>>，那么该对象就是可达的，<<def_commit_object,提交>>到它们的父提交或树，以及<<def_tree_object,树>>到它们所包含的树或<<def_blob_object,二进制对象>>。"

#. type: Labeled list
#: en/glossary-content.txt:511
#, no-wrap, priority:310
msgid "[[def_reachability_bitmap]]reachability bitmaps"
msgstr "[[def_reachability_bitmap]]可达性位图"

#. type: Plain text
#: en/glossary-content.txt:518
#, priority:310
msgid "Reachability bitmaps store information about the <<def_reachable,reachability>> of a selected set of commits in a packfile, or a multi-pack index (MIDX), to speed up object search.  The bitmaps are stored in a \".bitmap\" file. A repository may have at most one bitmap file in use. The bitmap file may belong to either one pack, or the repository's multi-pack index (if it exists)."
msgstr "可达性位图存储了包文件或多包索引（MIDX）中选定的一组提交的<<def_reachable,可达性>>的信息，以加快对象搜索。  位图被存储在\".bitmap \"文件中。一个版本库最多可以有一个位图文件在使用。这个位图文件可以属于一个包，也可以属于版本库的多包索引（如果有的话）。"

#. type: Labeled list
#: en/glossary-content.txt:519
#, no-wrap, priority:310
msgid "[[def_rebase]]rebase"
msgstr "[[def_rebase]]变基(rebase)"

#. type: Plain text
#: en/glossary-content.txt:523
#, priority:310
msgid "To reapply a series of changes from a <<def_branch,branch>> to a different base, and reset the <<def_head,head>> of that branch to the result."
msgstr "将<<def_branch,分支>>的一系列修改重新应用于不同的分支上，并将<<def_head,头>>指针重置为该分支。"

#. type: Labeled list
#: en/glossary-content.txt:524
#, no-wrap, priority:310
msgid "[[def_ref]]ref"
msgstr "[[def_ref]]引用(ref)"

#. type: Plain text
#: en/glossary-content.txt:532
#, priority:310
msgid "A name that begins with `refs/` (e.g. `refs/heads/master`)  that points to an <<def_object_name,object name>> or another ref (the latter is called a <<def_symref,symbolic ref>>).  For convenience, a ref can sometimes be abbreviated when used as an argument to a Git command; see linkgit:gitrevisions[7] for details.  Refs are stored in the <<def_repository,repository>>."
msgstr "一个以`refs/`开头的名字（例如`refs/heads/master`），它指向一个<<def_object_name,对象名称>>或另一个引用（后者被称为<<def_symref,符号引用>>）。  为方便起见，当作为 Git 命令的参数时，引用可以使用缩写；参见 linkgit:gitrevisions[7] 。  引用保存在<<def_repository,仓库>>中。"

#. type: Plain text
#: en/glossary-content.txt:536
#, priority:310
msgid "The ref namespace is hierarchical.  Different subhierarchies are used for different purposes (e.g. the `refs/heads/` hierarchy is used to represent local branches)."
msgstr "引用的命名空间是分层次的。  不同的子层次表示不同的情况（例如，`refs/heads/`层次用于代表本地分支）。"

#. type: Plain text
#: en/glossary-content.txt:539
#, priority:310
msgid "There are a few special-purpose refs that do not begin with `refs/`.  The most notable example is `HEAD`."
msgstr "有一些特殊意义的引用不以`refs/`开头。  最经典的例子就是`HEAD`。"

#. type: Labeled list
#: en/glossary-content.txt:540
#, no-wrap, priority:310
msgid "[[def_reflog]]reflog"
msgstr "[[def_reflog]]引用日志(reflog)"

#. type: Plain text
#: en/glossary-content.txt:545
#, priority:310
msgid "A reflog shows the local \"history\" of a ref.  In other words, it can tell you what the 3rd last revision in _this_ repository was, and what was the current state in _this_ repository, yesterday 9:14pm.  See linkgit:git-reflog[1] for details."
msgstr "引用日志显示一个引用的本地 \"历史\"。  换句话说，它可以告诉你，在昨天下午9:14，_这个_版本库的最后三次修订是什么，以及_这个_版本库的当前状态是什么。  详情见 linkgit:git-reflog[1]。"

#. type: Labeled list
#: en/glossary-content.txt:546
#, no-wrap, priority:310
msgid "[[def_refspec]]refspec"
msgstr "[[def_refspec]]引用规范(refspec)"

#. type: Plain text
#: en/glossary-content.txt:550
#, priority:310
msgid "A \"refspec\" is used by <<def_fetch,fetch>> and <<def_push,push>> to describe the mapping between remote <<def_ref,ref>> and local ref."
msgstr "“引用规范”是<<def_fetch,获取>>和<<def_push,推送>>用以描述远程<<def_ref,引用>>和本地引用之间的映射关系。"

#. type: Labeled list
#: en/glossary-content.txt:551
#, no-wrap, priority:310
msgid "[[def_remote]]remote repository"
msgstr "[[def_remote]]远程仓库"

#. type: Plain text
#: en/glossary-content.txt:555
#, priority:310
msgid "A <<def_repository,repository>> which is used to track the same project but resides somewhere else. To communicate with remotes, see <<def_fetch,fetch>> or <<def_push,push>>."
msgstr "一个部署在其他地方但用于跟踪同一个项目的<<def_repository,仓库>>。要与远程通信，请参阅<<def_fetch,获取>>或<<def_push,推送>>。"

#. type: Labeled list
#: en/glossary-content.txt:556
#, no-wrap, priority:310
msgid "[[def_remote_tracking_branch]]remote-tracking branch"
msgstr "[[def_remote_tracking_branch]]远程跟踪分支(remote-tracking branch)"

#. type: Plain text
#: en/glossary-content.txt:564
#, priority:310
msgid "A <<def_ref,ref>> that is used to follow changes from another <<def_repository,repository>>. It typically looks like 'refs/remotes/foo/bar' (indicating that it tracks a branch named 'bar' in a remote named 'foo'), and matches the right-hand-side of a configured fetch <<def_refspec,refspec>>. A remote-tracking branch should not contain direct modifications or have local commits made to it."
msgstr "一个用来跟踪另一个<<def_repository,仓库>>变化的<<def_ref,引用>>。它通常看起来像'refs/remotes/foo/bar'（表示它跟踪一个名为'foo'的远程中名为'bar'的分支），并对配置好的fetch<<def_refspec,引用规范>>右侧进行匹配。一个远程跟踪分支不应该由直接的修改或是本地的提交构成。"

#. type: Labeled list
#: en/glossary-content.txt:565
#, no-wrap, priority:310
msgid "[[def_repository]]repository"
msgstr "[[def_repository]仓库"

#. type: Plain text
#: en/glossary-content.txt:572
#, priority:310
msgid "A collection of <<def_ref,refs>> together with an <<def_object_database,object database>> containing all objects which are <<def_reachable,reachable>> from the refs, possibly accompanied by meta data from one or more <<def_porcelain,porcelains>>. A repository can share an object database with other repositories via <<def_alternate_object_database,alternates mechanism>>."
msgstr "一个<<def_ref,引用>>的集合和一个<<def_object_database,对象库>>的集合，包含了引用中所有的<<def_reachable,可达的>>对象，可能还有一个或多个<<def_porcelain,瓷件>>元数据。一个仓库可以通过<<def_alternate_object_database,轮替对象库>>与其他存储库共享对象数据库。"

#. type: Labeled list
#: en/glossary-content.txt:573
#, no-wrap, priority:310
msgid "[[def_resolve]]resolve"
msgstr "[[def_resolve]]解决"

#. type: Plain text
#: en/glossary-content.txt:576
#, priority:310
msgid "The action of fixing up manually what a failed automatic <<def_merge,merge>> left behind."
msgstr "手动修复由自动<<def_merge,合并>>产生的遗留错误。"

#. type: Labeled list
#: en/glossary-content.txt:577
#, no-wrap, priority:310
msgid "[[def_revision]]revision"
msgstr "[[def_revision]]版本"

#. type: Plain text
#: en/glossary-content.txt:579
#, priority:310
msgid "Synonym for <<def_commit,commit>> (the noun)."
msgstr "与<<def_commit,提交>>（名词形式）同义。"

#. type: Labeled list
#: en/glossary-content.txt:580
#, no-wrap, priority:310
msgid "[[def_rewind]]rewind"
msgstr "[[def_rewind]]回退"

#. type: Plain text
#: en/glossary-content.txt:583
#, priority:310
msgid "To throw away part of the development, i.e. to assign the <<def_head,head>> to an earlier <<def_revision,revision>>."
msgstr "删除一部分数据，即把<<def_head,头>>指针指向较早的<<def_revision,版本>>。"

#. type: Labeled list
#: en/glossary-content.txt:584
#, no-wrap, priority:310
msgid "[[def_SCM]]SCM"
msgstr "[[def_SCM]]SCM（源代码管理工具）"

#. type: Plain text
#: en/glossary-content.txt:586
#, priority:310
msgid "Source code management (tool)."
msgstr "源代码管理（工具）。"

#. type: Labeled list
#: en/glossary-content.txt:587
#, no-wrap, priority:310
msgid "[[def_SHA1]]SHA-1"
msgstr "[[def_SHA1]]SHA-1"

#. type: Plain text
#: en/glossary-content.txt:590
#, priority:310
msgid "\"Secure Hash Algorithm 1\"; a cryptographic hash function.  In the context of Git used as a synonym for <<def_object_name,object name>>."
msgstr "\"安全哈希算法1\"；一个加密哈希函数。  在Git的上下文中是<<def_object_name,对象名>>的同义词。"

#. type: Labeled list
#: en/glossary-content.txt:591
#, no-wrap, priority:310
msgid "[[def_shallow_clone]]shallow clone"
msgstr "[[def_shallow_clone]]浅克隆(shallow clone)"

#. type: Plain text
#: en/glossary-content.txt:595
#, ignore-ellipsis, priority:310
msgid "Mostly a synonym to <<def_shallow_repository,shallow repository>> but the phrase makes it more explicit that it was created by running `git clone --depth=...` command."
msgstr "大部分是指<<def_shallow_repository,浅仓库>>，但它更明确地表明其是通过运行`git clone --depth=...`命令创建的。"

#. type: Labeled list
#: en/glossary-content.txt:596
#, no-wrap, priority:310
msgid "[[def_shallow_repository]]shallow repository"
msgstr "[[def_shallow_repository]浅仓库(shallow repository)"

#. type: Plain text
#: en/glossary-content.txt:606
#, priority:310
msgid "A shallow <<def_repository,repository>> has an incomplete history some of whose <<def_commit,commits>> have <<def_parent,parents>> cauterized away (in other words, Git is told to pretend that these commits do not have the parents, even though they are recorded in the <<def_commit_object,commit object>>). This is sometimes useful when you are interested only in the recent history of a project even though the real history recorded in the upstream is much larger. A shallow repository is created by giving the `--depth` option to linkgit:git-clone[1], and its history can be later deepened with linkgit:git-fetch[1]."
msgstr "一个浅<<def_repository,仓库>>不会记录完整的提交历史，其中一些<<def_commit,提交>>的<<def_parent,父>>提交被销毁了（换句话说，Git被告知假装这些提交没有父提交，尽管在<<def_commit_object,提交对象>>中有记录）。当你只对一个项目的近期历史感兴趣时，这是很有用的，尽管上游记录的真实历史要大得多。通过给 linkgit:git-clone[1]提供 `--depth` 选项，可以创建一个浅层的仓库，之后可以用 linkgit:git-fetch[1] 深掘它的历史。"

#. type: Labeled list
#: en/glossary-content.txt:607
#, no-wrap, priority:310
msgid "[[def_stash]]stash entry"
msgstr "[[def_stash]]贮藏项"

#. type: Plain text
#: en/glossary-content.txt:610
#, priority:310
msgid "An <<def_object,object>> used to temporarily store the contents of a <<def_dirty,dirty>> working directory and the index for future reuse."
msgstr "一个<<def_object,对象>>，用于临时存储<<def_dirty,脏>>工作目录的内容和索引，以便将来重新使用。"

#. type: Labeled list
#: en/glossary-content.txt:611
#, no-wrap, priority:310
msgid "[[def_submodule]]submodule"
msgstr "[[def_submodule]]子模块(submodule)"

#. type: Plain text
#: en/glossary-content.txt:615
#, priority:310
msgid "A <<def_repository,repository>> that holds the history of a separate project inside another repository (the latter of which is called <<def_superproject, superproject>>)."
msgstr "一个<<def_repository,仓库>>保存着另一个库内的独立项目的历史（后者被称为<<def_superproject, 父工程>>）。"

#. type: Labeled list
#: en/glossary-content.txt:616
#, no-wrap, priority:310
msgid "[[def_superproject]]superproject"
msgstr "[[def_superproject]]父工程(superproject)"

#. type: Plain text
#: en/glossary-content.txt:621
#, priority:310
msgid "A <<def_repository,repository>> that references repositories of other projects in its working tree as <<def_submodule,submodules>>.  The superproject knows about the names of (but does not hold copies of) commit objects of the contained submodules."
msgstr "一个<<def_repository,仓库>>在其工作区中引用其他项目的仓库，作为<<def_submodule,子模块>>。  父工程包含子模块的提交对象的名称（但不持有其副本）。"

#. type: Labeled list
#: en/glossary-content.txt:622
#, no-wrap, priority:310
msgid "[[def_symref]]symref"
msgstr "[[def_symref]]符号引用"

#. type: Plain text
#: en/glossary-content.txt:629
#, priority:310
msgid "Symbolic reference: instead of containing the <<def_SHA1,SHA-1>> id itself, it is of the format 'ref: refs/some/thing' and when referenced, it recursively dereferences to this reference.  '<<def_HEAD,HEAD>>' is a prime example of a symref. Symbolic references are manipulated with the linkgit:git-symbolic-ref[1] command."
msgstr "符号引用：它不包含<<def_SHA1,SHA-1>>id，而是采用'ref: refs/some/thing'的格式，当被引用时，它会递归到这个引用。'<<def_HEAD,HEAD>>'是一个符号引用的典型例子。符号引用可通过linkgit:git-symbolic-ref[1]命令对其进行操作。"

#. type: Labeled list
#: en/glossary-content.txt:630
#, no-wrap, priority:310
msgid "[[def_tag]]tag"
msgstr "[[def_tag]]标签(tag)"

#. type: Plain text
#: en/glossary-content.txt:639
#, priority:310
msgid "A <<def_ref,ref>> under `refs/tags/` namespace that points to an object of an arbitrary type (typically a tag points to either a <<def_tag_object,tag>> or a <<def_commit_object,commit object>>).  In contrast to a <<def_head,head>>, a tag is not updated by the `commit` command. A Git tag has nothing to do with a Lisp tag (which would be called an <<def_object_type,object type>> in Git's context). A tag is most typically used to mark a particular point in the commit ancestry <<def_chain,chain>>."
msgstr "在`refs/tags/`命名空间下的一个<<def_ref,引用>>，指向一个任意类型的对象（通常一个标签指向一个<<def_tag_object,标签>>对象或者一个<<def_commit_object,提交对象>>）。  与<<def_head,head>>标记相比，标签不会被`commit`命令更新。Git的标签与Lisp的标签（在Git的上下文中称为<<def_object_type,对象类型>>）毫无关系。标签最常用的是标记祖先提交中的一个特定<<def_chain,对象链>>。"

#. type: Labeled list
#: en/glossary-content.txt:640
#, no-wrap, priority:310
msgid "[[def_tag_object]]tag object"
msgstr "[[def_tag_object]]标签对象"

#. type: Plain text
#: en/glossary-content.txt:645
#, priority:310
msgid "An <<def_object,object>> containing a <<def_ref,ref>> pointing to another object, which can contain a message just like a <<def_commit_object,commit object>>. It can also contain a (PGP)  signature, in which case it is called a \"signed tag object\"."
msgstr "一个<<def_object,对象>>包含一个指向另一个对象的<<def_ref,引用>>，它可以像<<def_commit_object,提交对象>>那样包含一个消息。它也可以包含一个（PGP）签名，这种情况下PGP被称为： \"有签名的标签对象\"(signed tag object)。"

#. type: Labeled list
#: en/glossary-content.txt:646
#, no-wrap, priority:310
msgid "[[def_topic_branch]]topic branch"
msgstr "[[def_topic_branch]]主题分支"

#. type: Plain text
#: en/glossary-content.txt:652
#, priority:310
msgid "A regular Git <<def_branch,branch>> that is used by a developer to identify a conceptual line of development. Since branches are very easy and inexpensive, it is often desirable to have several small branches that each contain very well defined concepts or small incremental yet related changes."
msgstr "一个常规的 Git <<def_branch,分支>>，被开发者用来确定一个概念性的开发路线。由于新建一个分支通常需要很小的代价，所以通常开发中会包含几个小的分支，每个分支都有着非常明确的概念或小的增量但相关的变化。"

#. type: Labeled list
#: en/glossary-content.txt:653
#, no-wrap, priority:310
msgid "[[def_tree]]tree"
msgstr "[[def_tree]]树/目录树(tree)"

#. type: Plain text
#: en/glossary-content.txt:657
#, priority:310
msgid "Either a <<def_working_tree,working tree>>, or a <<def_tree_object,tree object>> together with the dependent <<def_blob_object,blob>> and tree objects (i.e. a stored representation of a working tree)."
msgstr "要么是一个<<def_working_tree,工作区>>，要么是一个<<def_tree_object,树对象>>连同附属的<<def_blob_object,二进制文件>>对对象和对象树（即一个工作区的存储表示）。"

#. type: Labeled list
#: en/glossary-content.txt:658
#, no-wrap, priority:310
msgid "[[def_tree_object]]tree object"
msgstr "[[def_tree_object]]树对象"

#. type: Plain text
#: en/glossary-content.txt:662
#, priority:310
msgid "An <<def_object,object>> containing a list of file names and modes along with refs to the associated blob and/or tree objects. A <<def_tree,tree>> is equivalent to a <<def_directory,directory>>."
msgstr "一个<<def_object,对象>>包含一个文件名和模式的列表，以及相关的二进制文件和/或对象树的引用。一个<<def_tree,树>>等同于一个<<def_directory,目录>>。"

#. type: Labeled list
#: en/glossary-content.txt:663
#, no-wrap, priority:310
msgid "[[def_tree-ish]]tree-ish (also treeish)"
msgstr "[[def_tree-ish]]树状对象[tree-ish (also treeish)]"

#. type: Plain text
#: en/glossary-content.txt:676
#, priority:310
msgid "A <<def_tree_object,tree object>> or an <<def_object,object>> that can be recursively dereferenced to a tree object.  Dereferencing a <<def_commit_object,commit object>> yields the tree object corresponding to the <<def_revision,revision>>'s top <<def_directory,directory>>.  The following are all tree-ishes: a <<def_commit-ish,commit-ish>>, a tree object, a <<def_tag_object,tag object>> that points to a tree object, a tag object that points to a tag object that points to a tree object, etc."
msgstr "一个<<def_tree_object,树对象>>或者一个<<def_object,对象>>可以递归推断出一个树状对象。  递归一个<<def_commit_object,提交对象>>可以得到对应于<<def_revision,版本>>的顶层<<def_directory,目录>>树。  以下都是树状对象：<<def_commit-ish,提交号>>、树对象、指向树对象的<<def_tag_object,标签对象>>、指向树对象标签对象的标签对象，等等。"

#. type: Labeled list
#: en/glossary-content.txt:677
#, no-wrap, priority:310
msgid "[[def_unmerged_index]]unmerged index"
msgstr "[[def_unmerged_index]未合并暂存区"

#. type: Plain text
#: en/glossary-content.txt:680
#, priority:310
msgid "An <<def_index,index>> which contains unmerged <<def_index_entry,index entries>>."
msgstr "一个<<def_index,暂存区>>，包含未合并的<<def_index_entry,索引项>>。"

#. type: Labeled list
#: en/glossary-content.txt:681
#, no-wrap, priority:310
msgid "[[def_unreachable_object]]unreachable object"
msgstr "[[def_unreachable_object]]不可达对象(unreachable object)"

#. type: Plain text
#: en/glossary-content.txt:684
#, priority:310
msgid "An <<def_object,object>> which is not <<def_reachable,reachable>> from a <<def_branch,branch>>, <<def_tag,tag>>, or any other reference."
msgstr "一个从<<def_branch,分支>>、<<def_tag,标签>>或任何其他引用中都不<<def_reachable,可达的>><<def_object,对象>>。"

#. type: Labeled list
#: en/glossary-content.txt:685
#, no-wrap, priority:310
msgid "[[def_upstream_branch]]upstream branch"
msgstr "[[def_upstream_branch]]上游分支"

#. type: Plain text
#: en/glossary-content.txt:690
#, priority:310
msgid "The default <<def_branch,branch>> that is merged into the branch in question (or the branch in question is rebased onto). It is configured via branch.<name>.remote and branch.<name>.merge. If the upstream branch of 'A' is 'origin/B' sometimes we say \"'A' is tracking 'origin/B'\"."
msgstr "默认的 <<def_branch,分支>> 会被合并到相关的分支中（或相关的变基(rebase)分支）。它是通过 `branch.<name>.remote` 和 `branch.<name>.merge` 配置的。如果'A'的上游分支是'origin/B'，这有时会称作“'A'正在跟踪'origin/B'”。"

#. type: Labeled list
#: en/glossary-content.txt:691
#, no-wrap, priority:310
msgid "[[def_working_tree]]working tree"
msgstr "[[def_working_tree]]工作区(working tree)"

#. type: Plain text
#: en/glossary-content.txt:695
#, priority:310
msgid "The tree of actual checked out files.  The working tree normally contains the contents of the <<def_HEAD,HEAD>> commit's tree, plus any local changes that you have made but not yet committed."
msgstr "实际检查出来的文件树。  工作区通常包含<<def_HEAD,HEAD>>提交树的内容，和一些你已经做了但还没有提交的本地修改。"

#. type: Labeled list
#: en/glossary-content.txt:696
#, no-wrap, priority:310
msgid "[[def_worktree]]worktree"
msgstr "[[def_worktree]]工作树(worktree)"

#. type: Plain text
#: en/glossary-content.txt:703
#, priority:310
msgid "A repository can have zero (i.e. bare repository) or one or more worktrees attached to it. One \"worktree\" consists of a \"working tree\" and repository metadata, most of which are shared among other worktrees of a single repository, and some of which are maintained separately per worktree (e.g. the index, HEAD and pseudorefs like MERGE_HEAD, per-worktree refs and per-worktree configuration file)."
msgstr "一个仓库可以没有（即裸仓库），也可以有一个或多个工作树附属于它。一个 “工作树 ”由 “工作区”和版本库元数据组成，其中大部分元数据在单个仓库的其他工作树中共享，有些元数据在每个工作树中单独维护（例如：索引、HEAD 和像MERGE_HEAD这样的伪引用 、每个工作树索引件和每个工作树）。"

#. type: Plain text
#: en/i18n.txt:2
#, priority:280
msgid "Git is to some extent character encoding agnostic."
msgstr "Git在某种程度上是与字符编码无关的。"

#. type: Plain text
#: en/i18n.txt:6
#, priority:280
msgid "The contents of the blob objects are uninterpreted sequences of bytes.  There is no encoding translation at the core level."
msgstr "blob对象的内容是未经解释的字节序列。  在核心层没有编码转换。"

#. type: Plain text
#: en/i18n.txt:13
#, priority:280
msgid "Path names are encoded in UTF-8 normalization form C. This applies to tree objects, the index file, ref names, as well as path names in command line arguments, environment variables and config files (`.git/config` (see linkgit:git-config[1]), linkgit:gitignore[5], linkgit:gitattributes[5] and linkgit:gitmodules[5])."
msgstr "路径名以UTF-8规范化形式C编码，这适用于树对象、索引文件、参考名称，以及命令行参数、环境变量和配置文件（`.git/config`（见linkgit:git-config[1]），linkgit:gitignore[5]，linkgit:gitattributes[5] 和linkgit:gitmodules[5]）中的路径名。"

#. type: Plain text
#: en/i18n.txt:23
#, priority:280
msgid "Note that Git at the core level treats path names simply as sequences of non-NUL bytes, there are no path name encoding conversions (except on Mac and Windows). Therefore, using non-ASCII path names will mostly work even on platforms and file systems that use legacy extended ASCII encodings. However, repositories created on such systems will not work properly on UTF-8-based systems (e.g. Linux, Mac, Windows) and vice versa.  Additionally, many Git-based tools simply assume path names to be UTF-8 and will fail to display other encodings correctly."
msgstr "请注意，Git 在核心层将路径名简单地视为非 NUL 字节的序列，没有路径名编码的转换（除了 Mac 和 Windows）。因此，即使在使用传统的扩展ASCII编码的平台和文件系统上，使用非ASCII的路径名大多也能工作。然而，在这种系统上创建的仓库在基于UTF-8的系统（如Linux、Mac、Windows）上将无法正常工作，反之亦然。  此外，许多基于Git的工具简单地认为路径名称是UTF-8，而不能正确显示其他编码。"

#. type: Plain text
#: en/i18n.txt:29
#, priority:280
msgid "Commit log messages are typically encoded in UTF-8, but other extended ASCII encodings are also supported. This includes ISO-8859-x, CP125x and many others, but _not_ UTF-16/32, EBCDIC and CJK multi-byte encodings (GBK, Shift-JIS, Big5, EUC-x, CP9xx etc.)."
msgstr "提交日志信息通常以UTF-8编码，但也支持其他扩展ASCII编码。这包括ISO-8859-x、CP125x和其他许多编码，但不包括UTF-16/32、EBCDIC和CJK多字节编码（GBK、Shift-JIS、Big5、EUC-x、CP9xx等）。"

#. type: Plain text
#: en/i18n.txt:36
#, priority:280
msgid "Although we encourage that the commit log messages are encoded in UTF-8, both the core and Git Porcelain are designed not to force UTF-8 on projects.  If all participants of a particular project find it more convenient to use legacy encodings, Git does not forbid it.  However, there are a few things to keep in mind."
msgstr "尽管我们鼓励提交日志信息使用UTF-8编码，但核心系统和Git Porcelain的设计并不强制要求项目使用UTF-8。  如果某个项目的所有参与者都认为使用传统编码更方便，Git也不会禁止。  然而，有几件事需要注意。"

#. type: Plain text
#: en/i18n.txt:42
#, priority:280
msgid "'git commit' and 'git commit-tree' issues a warning if the commit log message given to it does not look like a valid UTF-8 string, unless you explicitly say your project uses a legacy encoding.  The way to say this is to have `i18n.commitEncoding` in `.git/config` file, like this:"
msgstr "git commit \"和 \"git commit-tree \"如果收到的提交日志信息不像是有效的UTF-8字符串，就会发出警告，除非你明确表示你的项目使用的是传统编码。  说这个的方法是在`.git/config`文件中设置`i18n.commitEncoding`，像这样。"

#. type: delimited block -
#: en/i18n.txt:46
#, fuzzy, no-wrap, priority:280
msgid ""
"[i18n]\n"
"\tcommitEncoding = ISO-8859-1\n"
msgstr ""
"[i18n]\n"
"\tcommitEncoding = ISO-8859-1\n"

#. type: Plain text
#: en/i18n.txt:52
#, priority:280
msgid "Commit objects created with the above setting record the value of `i18n.commitEncoding` in its `encoding` header.  This is to help other people who look at them later.  Lack of this header implies that the commit log message is encoded in UTF-8."
msgstr "用上述设置创建的提交对象在其`encoding`头中记录了`i18n.commitEncoding`的值。  这是为了帮助以后看这些对象的人。  缺少这个头意味着提交日志信息是以UTF-8编码的。"

#. type: Plain text
#: en/i18n.txt:58
#, fuzzy, priority:280
msgid "'git log', 'git show', 'git blame' and friends look at the `encoding` header of a commit object, and try to re-code the log message into UTF-8 unless otherwise specified.  You can specify the desired output encoding with `i18n.logOutputEncoding` in `.git/config` file, like this:"
msgstr "'git log', 'git show', 'git blame' and friends look at the `encoding` header of a commit object, and try to re-code the log message into UTF-8 unless otherwise specified.  You can specify the desired output encoding with `i18n.logOutputEncoding` in `.git/config` file, like this:"

#. type: delimited block -
#: en/i18n.txt:62
#, no-wrap, priority:280
msgid ""
"[i18n]\n"
"\tlogOutputEncoding = ISO-8859-1\n"
msgstr ""
"[i18n]\n"
"\tlogOutputEncoding = ISO-8859-1\n"

#. type: Plain text
#: en/i18n.txt:66
#, priority:280
msgid "If you do not have this configuration variable, the value of `i18n.commitEncoding` is used instead."
msgstr "如果你没有这个配置变量，则使用`i18n.commitEncoding`的值来代替。"

#. type: Plain text
#: en/i18n.txt:70
#, priority:280
msgid "Note that we deliberately chose not to re-code the commit log message when a commit is made to force UTF-8 at the commit object level, because re-coding to UTF-8 is not necessarily a reversible operation."
msgstr "请注意，我们特意选择在提交对象层面上，不对提交日志信息进行重新编码，因为重新编码为UTF-8不一定是一个可逆的操作。"

#. type: Plain text
#: en/includes/cmd-config-section-all.txt:3
#, priority:300
msgid "Everything below this line in this section is selectively included from the linkgit:git-config[1] documentation. The content is the same as what's found there:"
msgstr "本节中这一行以下的内容都是从 linkgit:git-config[1] 文档中摘录的。其内容与那里的内容相同："

#. type: Plain text
#: en/includes/cmd-config-section-rest.txt:3
#, priority:280
msgid "Everything above this line in this section isn't included from the linkgit:git-config[1] documentation. The content that follows is the same as what's found there:"
msgstr "本节中这一行以上的内容并不包括在 linkgit:git-config[1] 文档中。下面的内容与那里的内容相同："

#. type: Plain text
#: en/line-range-format.txt:2
#, priority:260
msgid "'<start>' and '<end>' can take one of these forms:"
msgstr "'<开始>'和'<结束>'可以采取这些形式之一。"

#. type: Plain text
#: en/line-range-format.txt:4
#, fuzzy, priority:260
msgid "number"
msgstr "数目"

#. type: Plain text
#: en/line-range-format.txt:7
#, priority:260
msgid "If '<start>' or '<end>' is a number, it specifies an absolute line number (lines count from 1)."
msgstr "如果'<开始>'或'<结束>'是一个数字，它指定了一个绝对行数（行数从1开始计算）。"

#. type: Plain text
#: en/line-range-format.txt:10
#, fuzzy, priority:260
msgid "`/regex/`"
msgstr "/regex/"

#. type: Plain text
#: en/line-range-format.txt:17
#, priority:260
msgid "This form will use the first line matching the given POSIX regex. If '<start>' is a regex, it will search from the end of the previous `-L` range, if any, otherwise from the start of file.  If '<start>' is `^/regex/`, it will search from the start of file.  If '<end>' is a regex, it will search starting at the line given by '<start>'."
msgstr "这种形式将使用与给定的POSIX regex匹配的第一行。如果'<start>'是一个重词，它将从前一个`-L'范围的末尾开始搜索，如果有的话，则从文件的开始。  如果'<start>'是`^/regex/`，它将从文件的开始搜索。  如果'<end>'是一个regex，它将从'<start>'所给的行开始搜索。"

#. type: Plain text
#: en/line-range-format.txt:20
#, priority:260
msgid "+offset or -offset"
msgstr "+offset或-offset"

#. type: Plain text
#: en/line-range-format.txt:23
#, priority:260
msgid "This is only valid for '<end>' and will specify a number of lines before or after the line given by '<start>'."
msgstr "这只对'<end>'有效，将指定'<start>'所给的行前或行后的数量。"

#. type: Plain text
#: en/line-range-format.txt:32
#, priority:260
msgid "If `:<funcname>` is given in place of '<start>' and '<end>', it is a regular expression that denotes the range from the first funcname line that matches '<funcname>', up to the next funcname line. `:<funcname>` searches from the end of the previous `-L` range, if any, otherwise from the start of file. `^:<funcname>` searches from the start of file. The function names are determined in the same way as `git diff` works out patch hunk headers (see 'Defining a custom hunk-header' in linkgit:gitattributes[5])."
msgstr "如果`:<funcname>`代替了'<start>'和'<end>'，它是一个正则表达式，表示从第一个匹配'<funcname>'的funcname行开始，直到下一个funcname行的范围。`:<funcname>`从上一个`-L'范围的末尾开始搜索，如果有的话，则从文件的开始搜索。`^:<funcname>`从文件的开始搜索。函数名的确定方式与 `git diff`确定补丁组头的方式相同（见 linkgit:gitattributes[5] 中的'定义自定义组头'）。"

#. type: Labeled list
#: en/line-range-options.txt:1
#, fuzzy, no-wrap, priority:260
#| msgid "-L <start>,<end>"
msgid "-L<start>,<end>:<file>"
msgstr "-L <start>,<end>"

#. type: Labeled list
#: en/line-range-options.txt:2
#, fuzzy, no-wrap, priority:260
msgid "-L:<funcname>:<file>"
msgstr "-L :<funcname>:<file>"

#. type: Plain text
#: en/line-range-options.txt:14
#, priority:260
msgid "Trace the evolution of the line range given by '<start>,<end>', or by the function name regex '<funcname>', within the '<file>'. You may not give any pathspec limiters.  This is currently limited to a walk starting from a single revision, i.e., you may only give zero or one positive revision arguments, and '<start>' and '<end>' (or '<funcname>') must exist in the starting revision.  You can specify this option more than once. Implies `--patch`.  Patch output can be suppressed using `--no-patch`, but other diff formats (namely `--raw`, `--numstat`, `--shortstat`, `--dirstat`, `--summary`, `--name-only`, `--name-status`, `--check`) are not currently implemented."
msgstr "追踪由'<start>,<end>'给出的行的范围，或由函数名称重合词'<funcname>'给出的行的演变，在'<file>'中。你不能给出任何pathspec限制条件。  目前这只限于从一个修订版开始的行走，也就是说，你只能给出零或一个正的修订版参数，而且'<start>'和'<end>'（或'<funcname>'）必须存在于起始修订版中。  你可以多次指定这个选项。  补丁输出可以用`--no-patch`来抑制，但其他差异格式（即`--raw`、`-numstat`、`-shortstat`、`-dirstat`、`-summary`、`-name-only`、`-name-status`、`-check`）目前没有实现。"

#. type: Plain text
#: en/merge-options.txt:5
#, priority:240
msgid "Perform the merge and commit the result. This option can be used to override --no-commit."
msgstr "执行合并并提交结果。这个选项可以用来覆盖 --no-commit。"

#. type: Plain text
#: en/merge-options.txt:7 en/merge-options.txt:100 en/merge-options.txt:141
#, no-wrap, priority:240
msgid "\tOnly useful when merging.\n"
msgstr "\t只有在合并的时候才有用。\n"

#. type: Plain text
#: en/merge-options.txt:12
#, priority:240
msgid "With --no-commit perform the merge and stop just before creating a merge commit, to give the user a chance to inspect and further tweak the merge result before committing."
msgstr "用 --no-commit 来执行合并，并在创建合并提交前停止，以便让用户有机会在提交前检查和进一步调整合并结果。"

#. type: Plain text
#: en/merge-options.txt:17
#, priority:240
msgid "Note that fast-forward updates do not create a merge commit and therefore there is no way to stop those merges with --no-commit.  Thus, if you want to ensure your branch is not changed or updated by the merge command, use --no-ff with --no-commit."
msgstr "请注意，快进更新并不产生合并提交，因此没有办法用 --no-commit 停止这些合并。  因此，如果你想确保你的分支不被合并命令改变或更新，请一起使用 --no-ff 和 --no-commit选项。"

#. type: Plain text
#: en/merge-options.txt:26
#, priority:240
msgid "Invoke an editor before committing successful mechanical merge to further edit the auto-generated merge message, so that the user can explain and justify the merge. The `--no-edit` option can be used to accept the auto-generated message (this is generally discouraged)."
msgstr "在提交成功的机械合并之前，调用一个编辑器来进一步编辑自动生成的合并信息，以便用户可以解释和证明合并的合理性。可以使用`--no-edit`选项来接受自动生成的信息（但是不鼓励亲这么做）。"

#. type: Plain text
#: en/merge-options.txt:30
#, priority:240
msgid "The `--edit` (or `-e`) option is still useful if you are giving a draft message with the `-m` option from the command line and want to edit it in the editor."
msgstr "如果你在命令行中用`-m`选项给出一个草稿信息，并想在编辑器中编辑它，`--edit`（或`-e`）选项仍然有用。"

#. type: Plain text
#: en/merge-options.txt:37
#, priority:240
msgid "Older scripts may depend on the historical behaviour of not allowing the user to edit the merge log message. They will see an editor opened when they run `git merge`. To make it easier to adjust such scripts to the updated behaviour, the environment variable `GIT_MERGE_AUTOEDIT` can be set to `no` at the beginning of them."
msgstr "旧的脚本可能依赖于不允许用户编辑合并日志信息的历史行为。他们会在运行`git merge`时看到一个编辑器被打开。为了使这些脚本更容易调整到最新的行为，可以在脚本的开头将环境变量`GIT_MERGE_AUTOEDIT`设置为`no`。"

#. type: Plain text
#: en/merge-options.txt:44
#, priority:240
msgid "This option determines how the merge message will be cleaned up before committing. See linkgit:git-commit[1] for more details. In addition, if the '<mode>' is given a value of `scissors`, scissors will be appended to `MERGE_MSG` before being passed on to the commit machinery in the case of a merge conflict."
msgstr "这个选项决定了在提交前如何清理合并信息。更多细节见linkgit:git-commit[1]。此外，如果`<模式>`的值为 `scissors`，在发生合并冲突时，scissors将被附加到 \"MERGE_MSG \"上，然后传递给提交机制。"

#. type: Labeled list
#: en/merge-options.txt:48 en/merge-options.txt:56
#, ignore-same, no-wrap, priority:240
msgid "--ff-only"
msgstr "--ff-only"

#. type: Plain text
#: en/merge-options.txt:54
#, priority:240
msgid "Specifies how a merge is handled when the merged-in history is already a descendant of the current history.  `--ff` is the default unless merging an annotated (and possibly signed) tag that is not stored in its natural place in the `refs/tags/` hierarchy, in which case `--no-ff` is assumed."
msgstr "指定当被合并的历史已经是当前历史的后代时，如何处理合并的问题。  默认为`--ff`，除非合并的是一个有注释的（可能是有签名的）标签，在这种情况下，`--no-ff`假设这个标签并没有存储在`refs/tags/`层次结构中的自然位置。"

#. type: Plain text
#: en/merge-options.txt:60
#, priority:240
msgid "Only update to the new history if there is no divergent local history.  This is the default when no method for reconciling divergent histories is provided (via the --rebase=* flags)."
msgstr "只有在没有分歧的本地历史时才更新到新的历史。  当没有提供调和分歧历史的方法时（通过--rebase=*标志），这是默认的。"

#. type: Plain text
#: en/merge-options.txt:69
#, priority:240
msgid "When merging rather than rebasing, specifies how a merge is handled when the merged-in history is already a descendant of the current history.  If merging is requested, `--ff` is the default unless merging an annotated (and possibly signed) tag that is not stored in its natural place in the `refs/tags/` hierarchy, in which case `--no-ff` is assumed."
msgstr "当合并而不是变基时，指定当被合并的历史已经是当前历史的后代时如何处理合并。  如果要求合并，`--ff`是默认的，除非合并的是一个有注释的（可能是有签名的）标签，而这个标签没有存储在`refs/tags/`层次结构中的自然位置，在这种情况下，假定`--no-ff`。"

#. type: Plain text
#: en/merge-options.txt:75
#, priority:240
msgid "With `--ff`, when possible resolve the merge as a fast-forward (only update the branch pointer to match the merged branch; do not create a merge commit).  When not possible (when the merged-in history is not a descendant of the current history), create a merge commit."
msgstr "如果使用 `--ff`，可能的话，以快进方式解决合并问题（只更新分支指针以匹配合并后的分支；不创建合并提交）。  当不可能时（当合并的历史不是当前历史的后代），创建一个合并提交。"

#. type: Plain text
#: en/merge-options.txt:78
#, priority:240
msgid "With `--no-ff`, create a merge commit in all cases, even when the merge could instead be resolved as a fast-forward."
msgstr "使用`--no-ff`，在所有情况下都创建一个合并提交，即使该合并可以作为一个快进解决。"

#. type: Plain text
#: en/merge-options.txt:82
#, priority:240
msgid "With `--ff-only`, resolve the merge as a fast-forward when possible.  When not possible, refuse to merge and exit with a non-zero status."
msgstr "使用`--ff-only`，在可能的情况下，以快进的方式解决合并的问题。  当不可能时，拒绝合并并以非零状态退出。"

#. type: Plain text
#: en/merge-options.txt:92
#, priority:240
msgid "GPG-sign the resulting merge commit. The `keyid` argument is optional and defaults to the committer identity; if specified, it must be stuck to the option without a space. `--no-gpg-sign` is useful to countermand both `commit.gpgSign` configuration variable, and earlier `--gpg-sign`."
msgstr "对合并后的提交进行 GPG 签名。`keyid` 参数是可选的，默认为提交者的身份；如果指定，它必须与选项连在一起，不能有空格。`--no-gpg-sign` 对于反命令 `commit.gpgSign` 配置变量和早期的 `--gpg-sign` 都很有用。"

#. type: Plain text
#: en/merge-options.txt:98
#, priority:240
msgid "In addition to branch names, populate the log message with one-line descriptions from at most <n> actual commits that are being merged. See also linkgit:git-fmt-merge-msg[1]."
msgstr "除了分支名称外，在日志信息中最多只用<n>个正在合并的实际提交的单行描述来填充。参见 linkgit:git-fmt-merge-msg[1]。"

#. type: Plain text
#: en/merge-options.txt:104
#, priority:240
msgid "With --no-log do not list one-line descriptions from the actual commits being merged."
msgstr "如果使用 --no-log，则不列出被合并的实际提交内容的单行描述。"

#. type: Plain text
#: en/merge-options.txt:112
#, priority:240
msgid "Show a diffstat at the end of the merge. The diffstat is also controlled by the configuration option merge.stat."
msgstr "在合并结束时显示一个差异状态。差异状态也由配置选项merge.stat控制。"

#. type: Plain text
#: en/merge-options.txt:115
#, priority:240
msgid "With -n or --no-stat do not show a diffstat at the end of the merge."
msgstr "使用-n或--no-stat，在合并结束时不显示差异状态。"

#. type: Labeled list
#: en/merge-options.txt:116
#, ignore-same, no-wrap, priority:240
msgid "--squash"
msgstr "--squash"

#. type: Labeled list
#: en/merge-options.txt:117
#, ignore-same, no-wrap, priority:240
msgid "--no-squash"
msgstr "--no-squash"

#. type: Plain text
#: en/merge-options.txt:125
#, priority:240
msgid "Produce the working tree and index state as if a real merge happened (except for the merge information), but do not actually make a commit, move the `HEAD`, or record `$GIT_DIR/MERGE_HEAD` (to cause the next `git commit` command to create a merge commit).  This allows you to create a single commit on top of the current branch whose effect is the same as merging another branch (or more in case of an octopus)."
msgstr "产生工作区和索引状态，就像发生了真正的合并一样（除了合并信息），但不实际提交，不移动`HEAD`，也不记录`$GIT_DIR/Merge_HEAD`（以导致下一个`git commit`命令创建一个合并提交）。  这允许你在当前分支的基础上创建一个单一的提交，其效果与合并另一个分支相同（如果是多路分支，则更多）。"

#. type: Plain text
#: en/merge-options.txt:128
#, priority:240
msgid "With --no-squash perform the merge and commit the result. This option can be used to override --squash."
msgstr "使用 --no-squash 进行合并并提交结果。这个选项可以用来覆盖 --quash 选项。"

#. type: Plain text
#: en/merge-options.txt:130
#, priority:240
msgid "With --squash, --commit is not allowed, and will fail."
msgstr "使用 --squash，--commit 是不允许的，而且会失败。"

#. type: Plain text
#: en/merge-options.txt:133 en/merge-options.txt:166 en/merge-options.txt:210
#, priority:240
msgid "Only useful when merging."
msgstr "只有在合并的时候才有用。"

#. type: Plain text
#: en/merge-options.txt:139
#, priority:240
msgid "By default, the pre-merge and commit-msg hooks are run.  When `--no-verify` is given, these are bypassed.  See also linkgit:githooks[5]."
msgstr "默认情况下，会运行 pre-merge 和 commit-msg 事件hook。  当给定 `--no-verify`时，这些将不会执行。  参见 linkgit:githooks[5]。"

#. type: Plain text
#: en/merge-options.txt:150
#, priority:240
msgid "Use the given merge strategy; can be supplied more than once to specify them in the order they should be tried.  If there is no `-s` option, a built-in list of strategies is used instead (`ort` when merging a single head, `octopus` otherwise)."
msgstr "使用给定的合并策略；可以多次提供，以指定它们应该被尝试的顺序。  如果没有`-s`选项，则使用一个内置的策略列表（当合并单个头时使用`ort`，否则使用`octopus`）。"

#. type: Labeled list
#: en/merge-options.txt:151
#, no-wrap, priority:240
msgid "-X <option>"
msgstr "-X <选项>"

#. type: Plain text
#: en/merge-options.txt:155
#, priority:240
msgid "Pass merge strategy specific option through to the merge strategy."
msgstr "将合并策略的特定选项传递给合并策略。"

#. type: Labeled list
#: en/merge-options.txt:156
#, ignore-same, no-wrap, priority:240
msgid "--verify-signatures"
msgstr "--verify-signatures"

#. type: Labeled list
#: en/merge-options.txt:157
#, ignore-same, no-wrap, priority:240
msgid "--no-verify-signatures"
msgstr "--no-verify-signatures"

#. type: Plain text
#: en/merge-options.txt:163
#, priority:240
msgid "Verify that the tip commit of the side branch being merged is signed with a valid key, i.e. a key that has a valid uid: in the default trust model, this means the signing key has been signed by a trusted key.  If the tip commit of the side branch is not signed with a valid key, the merge is aborted."
msgstr "验证被合并的侧边分支的提示提交是否用有效的密钥签署，即一个具有有效uid的密钥：在默认的信任模型中，这意味着签署密钥是由一个受信任的密钥签署。  如果侧边分支的提示提交没有用有效的密钥签名，则合并被终止。"

#. type: Labeled list
#: en/merge-options.txt:169
#, ignore-same, no-wrap, priority:240
msgid "--no-summary"
msgstr "--no-summary"

#. type: Plain text
#: en/merge-options.txt:172
#, priority:240
msgid "Synonyms to --stat and --no-stat; these are deprecated and will be removed in the future."
msgstr "与 --stat 和 --no-stat 同义；这些都弃用了，将来会被删除。"

#. type: Plain text
#: en/merge-options.txt:177
#, priority:240
msgid "Operate quietly. Implies --no-progress."
msgstr "安静地操作。暗指 --no-progress。"

#. type: Plain text
#: en/merge-options.txt:188
#, priority:240
msgid "Turn progress on/off explicitly. If neither is specified, progress is shown if standard error is connected to a terminal.  Note that not all merge strategies may support progress reporting."
msgstr "明确地打开/关闭进度。如果两者都没有指定，如果标准错误连接到终端，就会显示进度。  注意，并非所有的合并策略都支持进度报告。"

#. type: Plain text
#: en/merge-options.txt:199
#, fuzzy, priority:240
#| msgid "When set to true, automatically create a temporary stash entry before the operation begins, and apply it after the operation ends.  This means that you can run merge on a dirty worktree.  However, use with care: the final stash application after a successful merge might result in non-trivial conflicts.  This option can be overridden by the `--no-autostash` and `--autostash` options of linkgit:git-merge[1].  Defaults to false."
msgid "Automatically create a temporary stash entry before the operation begins, record it in the special ref `MERGE_AUTOSTASH` and apply it after the operation ends.  This means that you can run the operation on a dirty worktree.  However, use with care: the final stash application after a successful merge might result in non-trivial conflicts."
msgstr "当设置为 \"true \"时，在操作开始前自动创建一个临时的储藏库条目，并在操作结束后应用它。  这意味着你可以在一个肮脏的工作树上运行merge。  然而，要小心使用：在成功的合并之后，最后的储藏库应用可能会导致非实质性的冲突。  这个选项可以被 linkgit:git-merge[1] 的 `--no-autostash` 和 `--autostash` 选项覆盖。  默认为false。"

#. type: Plain text
#: en/merge-options.txt:207
#, priority:240
msgid "By default, `git merge` command refuses to merge histories that do not share a common ancestor.  This option can be used to override this safety when merging histories of two projects that started their lives independently. As that is a very rare occasion, no configuration variable to enable this by default exists and will not be added."
msgstr "默认情况下，`git merge`命令拒绝合并那些没有共同祖先的历史。  当合并两个独立开始的项目的历史时，这个选项可以用来覆盖这个安全性。由于这是一个非常罕见的情况，没有配置变量来默认启用，也不会被添加。"

#. type: Title -
#: en/merge-strategies.txt:2
#, no-wrap, priority:240
msgid "MERGE STRATEGIES"
msgstr "合并战略"

#. type: Plain text
#: en/merge-strategies.txt:8
#, priority:240
msgid "The merge mechanism (`git merge` and `git pull` commands) allows the backend 'merge strategies' to be chosen with `-s` option.  Some strategies can also take their own options, which can be passed by giving `-X<option>` arguments to `git merge` and/or `git pull`."
msgstr "合并机制（`git merge`和`git pull`命令）允许用`s`选项来选择后端'合并策略'。  一些策略也可以采取自己的选项，可以通过给`git merge`和/或`git pull`的`-X<选项>`参数来传递。"

#. type: Labeled list
#: en/merge-strategies.txt:9
#, fuzzy, no-wrap, priority:240
msgid "ort"
msgstr "或"

#. type: Plain text
#: en/merge-strategies.txt:24
#, priority:240
msgid "This is the default merge strategy when pulling or merging one branch.  This strategy can only resolve two heads using a 3-way merge algorithm.  When there is more than one common ancestor that can be used for 3-way merge, it creates a merged tree of the common ancestors and uses that as the reference tree for the 3-way merge.  This has been reported to result in fewer merge conflicts without causing mismerges by tests done on actual merge commits taken from Linux 2.6 kernel development history.  Additionally this strategy can detect and handle merges involving renames.  It does not make use of detected copies.  The name for this algorithm is an acronym (\"Ostensibly Recursive's Twin\") and came from the fact that it was written as a replacement for the previous default algorithm, `recursive`."
msgstr "这是拉取或合并一个分支时的默认合并策略。  这个策略只能使用三方合并算法解决两个头。  当有一个以上的共同祖先可用于三方合并时，它会创建一个共同祖先的合并树，并将其作为三方合并的参考树。  据报道，通过对Linux 2.6内核开发历史中的实际合并提交的测试，这导致了较少的合并冲突，而不会引起错误的合并。  此外，这个策略可以检测并处理涉及重命名的合并。  它并不使用检测到的副本。  这个算法的名字是一个缩写（\"Ostensibly Recursive's Twin\"），来自于它是作为以前的默认算法`recursive`的替代而编写的。"

#. type: Plain text
#: en/merge-strategies.txt:26
#, priority:240
msgid "The 'ort' strategy can take the following options:"
msgstr "'ort' 策略可以采取以下选项："

#. type: Labeled list
#: en/merge-strategies.txt:27 en/merge-strategies.txt:132
#, ignore-same, no-wrap, priority:240
msgid "ours"
msgstr "ours"

#. type: Plain text
#: en/merge-strategies.txt:32
#, priority:240
msgid "This option forces conflicting hunks to be auto-resolved cleanly by favoring 'our' version.  Changes from the other tree that do not conflict with our side are reflected in the merge result.  For a binary file, the entire contents are taken from our side."
msgstr "这个选项通过倾向于 \"我们\" 的版本，迫使冲突的猎物被自动解决。  另一棵目录树上与我们这边不冲突的变化会反映在合并结果中。  对于一个二进制文件，整个内容都来自我们这边。"

#. type: Plain text
#: en/merge-strategies.txt:36
#, priority:240
msgid "This should not be confused with the 'ours' merge strategy, which does not even look at what the other tree contains at all.  It discards everything the other tree did, declaring 'our' history contains all that happened in it."
msgstr "这不应该与 \"我们的\" 合并策略相混淆，后者甚至根本不看另一棵目录树包含了什么。  它抛弃了其他树所做的一切，宣布 \"我们的\" 历史包含了其中所发生的一切。"

#. type: Labeled list
#: en/merge-strategies.txt:37
#, ignore-same, no-wrap, priority:240
msgid "theirs"
msgstr "theirs"

#. type: Plain text
#: en/merge-strategies.txt:40
#, priority:240
msgid "This is the opposite of 'ours'; note that, unlike 'ours', there is no 'theirs' merge strategy to confuse this merge option with."
msgstr "这与 \"我们的\" 相反；注意，与 \"我们的\" 不同，没有 \"他们的\" 合并策略来混淆这个合并选项。"

#. type: Labeled list
#: en/merge-strategies.txt:44
#, ignore-same, no-wrap, priority:240
msgid "ignore-cr-at-eol"
msgstr "ignore-cr-at-eol"

#. type: Plain text
#: en/merge-strategies.txt:50
#, priority:240
msgid "Treats lines with the indicated type of whitespace change as unchanged for the sake of a three-way merge.  Whitespace changes mixed with other changes to a line are not ignored.  See also linkgit:git-diff[1] `-b`, `-w`, `--ignore-space-at-eol`, and `--ignore-cr-at-eol`."
msgstr "为了进行三方合并，将具有指定类型的空白变化的行视为没有变化。  但混合了其他改动的行的空白改动不会被忽略。  参见linkgit:git-diff[1] `-b`, `-w`, `-ignore-space-at-eol`, 和 `-ignore-cr-at-eol`。"

#. type: Plain text
#: en/merge-strategies.txt:53
#, priority:240
msgid "If 'their' version only introduces whitespace changes to a line, 'our' version is used;"
msgstr "如果 \"他们的\" 版本只在一行中引入了空白的变化，则使用 \"我们的\" 版本；"

#. type: Plain text
#: en/merge-strategies.txt:55
#, priority:240
msgid "If 'our' version introduces whitespace changes but 'their' version includes a substantial change, 'their' version is used;"
msgstr "如果 \"我们的\" 版本引入了空白的变化，但 \"他们的\" 版本包括一个实质性的变化，则使用 \"他们的\" 版本;"

#. type: Plain text
#: en/merge-strategies.txt:56
#, priority:240
msgid "Otherwise, the merge proceeds in the usual way."
msgstr "否则，合并将以常规方式进行。"

#. type: Labeled list
#: en/merge-strategies.txt:57
#, ignore-same, no-wrap, priority:240
msgid "renormalize"
msgstr "renormalize"

#. type: Plain text
#: en/merge-strategies.txt:64
#, priority:240
msgid "This runs a virtual check-out and check-in of all three stages of a file when resolving a three-way merge.  This option is meant to be used when merging branches with different clean filters or end-of-line normalization rules.  See \"Merging branches with differing checkin/checkout attributes\" in linkgit:gitattributes[5] for details."
msgstr "在解决三方合并时，这将对一个文件的所有三个阶段运行虚拟检出和检入。  这个选项是为了在合并具有不同清洁过滤器或行末规范化规则的分支时使用。  详情见 linkgit:gitattributes[5] 中的 \"合并具有不同检入/检出属性的分支\"。"

#. type: Labeled list
#: en/merge-strategies.txt:65
#, ignore-same, no-wrap, priority:240
msgid "no-renormalize"
msgstr "no-renormalize"

#. type: Plain text
#: en/merge-strategies.txt:68
#, priority:240
msgid "Disables the `renormalize` option.  This overrides the `merge.renormalize` configuration variable."
msgstr "禁用 `renormalize` 选项。  这覆盖了 `merge.renormalize` 配置变量。"

#. type: Labeled list
#: en/merge-strategies.txt:69
#, fuzzy, no-wrap, priority:240
msgid "find-renames[=<n>]"
msgstr "find-renames[=<n>]"

#. type: Plain text
#: en/merge-strategies.txt:74
#, priority:240
msgid "Turn on rename detection, optionally setting the similarity threshold.  This is the default. This overrides the 'merge.renames' configuration variable.  See also linkgit:git-diff[1] `--find-renames`."
msgstr "开启重名检测，可选择设置相似度阈值。  这是默认的。这覆盖了 'merge.renames' 配置变量。  参见linkgit:git-diff[1] `--find-renames`。"

#. type: Labeled list
#: en/merge-strategies.txt:75
#, no-wrap, priority:240
msgid "rename-threshold=<n>"
msgstr "rename-threshold=<n>"

#. type: Plain text
#: en/merge-strategies.txt:77
#, priority:240
msgid "Deprecated synonym for `find-renames=<n>`."
msgstr "废弃的，`find-renames=<n>` 的同义词。"

#. type: Labeled list
#: en/merge-strategies.txt:78
#, no-wrap, priority:240
msgid "subtree[=<path>]"
msgstr "subtree[=<路径>]"

#. type: Plain text
#: en/merge-strategies.txt:84
#, priority:240
msgid "This option is a more advanced form of 'subtree' strategy, where the strategy makes a guess on how two trees must be shifted to match with each other when merging.  Instead, the specified path is prefixed (or stripped from the beginning) to make the shape of two trees to match."
msgstr "这个选项是 '子树' 策略的更高级形式，该策略对两棵树在合并时必须如何移位以相互匹配进行猜测。  相反，指定的路径是前缀（或从开始剥离），以使两棵树的形状相匹配。"

#. type: Labeled list
#: en/merge-strategies.txt:85
#, ignore-same, no-wrap, priority:240
msgid "recursive"
msgstr "recursive"

#. type: Plain text
#: en/merge-strategies.txt:98
#, priority:240
msgid "This can only resolve two heads using a 3-way merge algorithm.  When there is more than one common ancestor that can be used for 3-way merge, it creates a merged tree of the common ancestors and uses that as the reference tree for the 3-way merge.  This has been reported to result in fewer merge conflicts without causing mismerges by tests done on actual merge commits taken from Linux 2.6 kernel development history.  Additionally this can detect and handle merges involving renames.  It does not make use of detected copies.  This was the default strategy for resolving two heads from Git v0.99.9k until v2.33.0."
msgstr "这只能用三方合并算法解决两个头。  当有一个以上的共同祖先可用于三方合并时，它会创建一个共同祖先的合并树，并使用它作为三方合并的参考树。  据报道，通过对Linux 2.6内核开发历史中的实际合并提交的测试，这导致了较少的合并冲突，而不会引起错误的合并。  此外，它可以检测并处理涉及重命名的合并。  它并不使用检测到的副本。  从Git v0.99.9k到v2.33.0，这是解决双头的默认策略。"

#. type: Plain text
#: en/merge-strategies.txt:102
#, priority:240
msgid "The 'recursive' strategy takes the same options as 'ort'.  However, there are three additional options that 'ort' ignores (not documented above) that are potentially useful with the 'recursive' strategy:"
msgstr "'recursive'  策略采用与 'ort' 相同的选项。  然而，有三个 'ort' 忽略的额外选项（上面没有记录），对 'recursive' 策略有潜在的作用："

#. type: Labeled list
#: en/merge-strategies.txt:103
#, ignore-same, no-wrap, priority:240
msgid "patience"
msgstr "patience"

#. type: Plain text
#: en/merge-strategies.txt:105
#, priority:240
msgid "Deprecated synonym for `diff-algorithm=patience`."
msgstr "废弃的，`diff-algorithm=patience` 的同义词。"

#. type: Labeled list
#: en/merge-strategies.txt:106
#, ignore-same, no-wrap, priority:240
msgid "diff-algorithm=[patience|minimal|histogram|myers]"
msgstr "diff-algorithm=[patience|minimal|histogram|myers]"

#. type: Plain text
#: en/merge-strategies.txt:113
#, priority:240
msgid "Use a different diff algorithm while merging, which can help avoid mismerges that occur due to unimportant matching lines (such as braces from distinct functions).  See also linkgit:git-diff[1] `--diff-algorithm`.  Note that `ort` specifically uses `diff-algorithm=histogram`, while `recursive` defaults to the `diff.algorithm` config setting."
msgstr "在合并时使用不同的差异算法，这可以帮助避免由于不重要的匹配行（比如不同函数的大括号）而发生的错误合并。  参见linkgit:git-diff[1] `--diff-algorithm`。  注意，`ort` 特定 `diff-algorithm=histogram`，而`recursive`默认为`diff.algorithm`配置设置。"

#. type: Labeled list
#: en/merge-strategies.txt:114
#, ignore-same, no-wrap, priority:240
msgid "no-renames"
msgstr "no-renames"

#. type: Plain text
#: en/merge-strategies.txt:118
#, priority:240
msgid "Turn off rename detection. This overrides the `merge.renames` configuration variable.  See also linkgit:git-diff[1] `--no-renames`."
msgstr "关闭重名检测。这覆盖了 `merge.renames` 的配置变量。  参见linkgit:git-diff[1] `--no-renames`。"

#. type: Labeled list
#: en/merge-strategies.txt:119
#, ignore-same, no-wrap, priority:240
msgid "resolve"
msgstr "resolve"

#. type: Plain text
#: en/merge-strategies.txt:124
#, priority:240
msgid "This can only resolve two heads (i.e. the current branch and another branch you pulled from) using a 3-way merge algorithm.  It tries to carefully detect criss-cross merge ambiguities.  It does not handle renames."
msgstr "这只能用三方合并算法解决两个头（即当前分支和你拉来的另一个分支）。  它试图仔细检测纵横交错的合并歧义。  它不处理重名。"

#. type: Labeled list
#: en/merge-strategies.txt:125
#, ignore-same, no-wrap, priority:240
msgid "octopus"
msgstr "octopus"

#. type: Plain text
#: en/merge-strategies.txt:131
#, priority:240
msgid "This resolves cases with more than two heads, but refuses to do a complex merge that needs manual resolution.  It is primarily meant to be used for bundling topic branch heads together.  This is the default merge strategy when pulling or merging more than one branch."
msgstr "这可以解决有两个以上头的情况，但拒绝做复杂的合并，需要手动解决。  它主要是用于将主题分支头捆绑在一起。  当拉动或合并一个以上的分支时，这是默认的合并策略。"

#. type: Plain text
#: en/merge-strategies.txt:139
#, priority:240
msgid "This resolves any number of heads, but the resulting tree of the merge is always that of the current branch head, effectively ignoring all changes from all other branches.  It is meant to be used to supersede old development history of side branches.  Note that this is different from the -Xours option to the 'recursive' merge strategy."
msgstr "这可以解决任何数量的头，但合并的结果总是当前分支头的树，有效地忽略了所有其他分支的变化。  它是用来取代侧边分支的旧开发历史的。  注意，这与 'recursive' 合并策略的-Xours选项不同。"

#. type: Labeled list
#: en/merge-strategies.txt:140
#, ignore-same, no-wrap, priority:240
msgid "subtree"
msgstr "subtree"

#. type: Plain text
#: en/merge-strategies.txt:146
#, priority:240
msgid "This is a modified `ort` strategy. When merging trees A and B, if B corresponds to a subtree of A, B is first adjusted to match the tree structure of A, instead of reading the trees at the same level. This adjustment is also done to the common ancestor tree."
msgstr "这是一个修正的 `ort` 策略。当合并树A和B时，如果B对应于A的子树，B首先被调整为与A的树结构相匹配，而不是在同一级别读取树。这种调整也是针对共同祖先树进行的。"

#. type: Plain text
#: en/merge-strategies.txt:153
#, priority:240
msgid "With the strategies that use 3-way merge (including the default, 'ort'), if a change is made on both branches, but later reverted on one of the branches, that change will be present in the merged result; some people find this behavior confusing.  It occurs because only the heads and the merge base are considered when performing a merge, not the individual commits.  The merge algorithm therefore considers the reverted change as no change at all, and substitutes the changed version instead."
msgstr "对于使用三方合并的策略（包括默认的 'ort' 策略），如果在两个分支上都做了修改，但后来在其中一个分支上被撤销，那么这个修改就会出现在合并后的结果中；有些人觉得这种行为令人困惑。  出现这种情况是因为在执行合并时只考虑头部和合并基数，而不是单个提交。  因此，合并算法认为被恢复的修改根本就没有变化，而是用被修改的版本来代替。"

#. type: Labeled list
#: en/mergetools-merge.txt:1
#, ignore-same, no-wrap, priority:100
msgid "`araxis`"
msgstr "`araxis`"

#. type: Plain text
#: en/mergetools-merge.txt:2
#, priority:100
msgid "Use Araxis Merge (requires a graphical session)"
msgstr ""

#. type: Labeled list
#: en/mergetools-merge.txt:2
#, ignore-same, no-wrap, priority:100
msgid "`bc`"
msgstr "`bc`"

#. type: Plain text
#: en/mergetools-merge.txt:3 en/mergetools-merge.txt:4 en/mergetools-merge.txt:5
#, priority:100
msgid "Use Beyond Compare (requires a graphical session)"
msgstr ""

#. type: Labeled list
#: en/mergetools-merge.txt:3
#, no-wrap, priority:100
msgid "`bc3`"
msgstr ""

#. type: Labeled list
#: en/mergetools-merge.txt:4
#, no-wrap, priority:100
msgid "`bc4`"
msgstr ""

#. type: Labeled list
#: en/mergetools-merge.txt:5
#, ignore-same, no-wrap, priority:100
msgid "`codecompare`"
msgstr "`codecompare`"

#. type: Plain text
#: en/mergetools-merge.txt:6
#, priority:100
msgid "Use Code Compare (requires a graphical session)"
msgstr ""

#. type: Labeled list
#: en/mergetools-merge.txt:6
#, ignore-same, no-wrap, priority:100
msgid "`deltawalker`"
msgstr "`deltawalker`"

#. type: Plain text
#: en/mergetools-merge.txt:7
#, priority:100
msgid "Use DeltaWalker (requires a graphical session)"
msgstr ""

#. type: Labeled list
#: en/mergetools-merge.txt:7
#, ignore-same, no-wrap, priority:100
msgid "`diffmerge`"
msgstr "`diffmerge`"

#. type: Plain text
#: en/mergetools-merge.txt:8
#, priority:100
msgid "Use DiffMerge (requires a graphical session)"
msgstr ""

#. type: Labeled list
#: en/mergetools-merge.txt:8
#, ignore-same, no-wrap, priority:100
msgid "`diffuse`"
msgstr "`diffuse`"

#. type: Plain text
#: en/mergetools-merge.txt:9
#, priority:100
msgid "Use Diffuse (requires a graphical session)"
msgstr ""

#. type: Labeled list
#: en/mergetools-merge.txt:9
#, ignore-same, no-wrap, priority:100
msgid "`ecmerge`"
msgstr "`ecmerge`"

#. type: Plain text
#: en/mergetools-merge.txt:10
#, priority:100
msgid "Use ECMerge (requires a graphical session)"
msgstr ""

#. type: Labeled list
#: en/mergetools-merge.txt:10
#, ignore-same, no-wrap, priority:100
msgid "`emerge`"
msgstr "`emerge`"

#. type: Plain text
#: en/mergetools-merge.txt:11
#, priority:100
msgid "Use Emacs' Emerge"
msgstr ""

#. type: Labeled list
#: en/mergetools-merge.txt:11
#, ignore-same, no-wrap, priority:100
msgid "`examdiff`"
msgstr "`examdiff`"

#. type: Plain text
#: en/mergetools-merge.txt:12
#, priority:100
msgid "Use ExamDiff Pro (requires a graphical session)"
msgstr ""

#. type: Labeled list
#: en/mergetools-merge.txt:12
#, ignore-same, no-wrap, priority:100
msgid "`guiffy`"
msgstr "`guiffy`"

#. type: Plain text
#: en/mergetools-merge.txt:13
#, priority:100
msgid "Use Guiffy's Diff Tool (requires a graphical session)"
msgstr ""

#. type: Labeled list
#: en/mergetools-merge.txt:13
#, ignore-same, no-wrap, priority:100
msgid "`gvimdiff`"
msgstr "`gvimdiff`"

#. type: Plain text
#: en/mergetools-merge.txt:14
#, priority:100
msgid "Use gVim (requires a graphical session) with a custom layout (see `git help mergetool`'s `BACKEND SPECIFIC HINTS` section)"
msgstr ""

#. type: Labeled list
#: en/mergetools-merge.txt:14
#, fuzzy, no-wrap, priority:100
#| msgid "gvimdiff1"
msgid "`gvimdiff1`"
msgstr "gvimdiff1"

#. type: Plain text
#: en/mergetools-merge.txt:15
#, priority:100
msgid "Use gVim (requires a graphical session) with a 2 panes layout (LOCAL and REMOTE)"
msgstr ""

#. type: Labeled list
#: en/mergetools-merge.txt:15
#, fuzzy, no-wrap, priority:100
#| msgid "gvimdiff2"
msgid "`gvimdiff2`"
msgstr "gvimdiff2"

#. type: Plain text
#: en/mergetools-merge.txt:16
#, priority:100
msgid "Use gVim (requires a graphical session) with a 3 panes layout (LOCAL, MERGED and REMOTE)"
msgstr ""

#. type: Labeled list
#: en/mergetools-merge.txt:16
#, fuzzy, no-wrap, priority:100
#| msgid "gvimdiff3"
msgid "`gvimdiff3`"
msgstr "gvimdiff3"

#. type: Plain text
#: en/mergetools-merge.txt:17
#, priority:100
msgid "Use gVim (requires a graphical session) where only the MERGED file is shown"
msgstr ""

#. type: Labeled list
#: en/mergetools-merge.txt:17
#, fuzzy, no-wrap, priority:100
#| msgid "kdiff3"
msgid "`kdiff3`"
msgstr "kdiff3"

#. type: Plain text
#: en/mergetools-merge.txt:18
#, priority:100
msgid "Use KDiff3 (requires a graphical session)"
msgstr ""

#. type: Labeled list
#: en/mergetools-merge.txt:18
#, ignore-same, no-wrap, priority:100
msgid "`meld`"
msgstr "`meld`"

#. type: Plain text
#: en/mergetools-merge.txt:19
#, priority:100
msgid "Use Meld (requires a graphical session) with optional `auto merge` (see `git help mergetool`'s `CONFIGURATION` section)"
msgstr ""

#. type: Labeled list
#: en/mergetools-merge.txt:19
#, ignore-same, no-wrap, priority:100
msgid "`nvimdiff`"
msgstr "`nvimdiff`"

#. type: Plain text
#: en/mergetools-merge.txt:20
#, priority:100
msgid "Use Neovim with a custom layout (see `git help mergetool`'s `BACKEND SPECIFIC HINTS` section)"
msgstr ""

#. type: Labeled list
#: en/mergetools-merge.txt:20
#, fuzzy, no-wrap, priority:100
#| msgid "nvimdiff1"
msgid "`nvimdiff1`"
msgstr "nvimdiff1"

#. type: Plain text
#: en/mergetools-merge.txt:21
#, priority:100
msgid "Use Neovim with a 2 panes layout (LOCAL and REMOTE)"
msgstr ""

#. type: Labeled list
#: en/mergetools-merge.txt:21
#, fuzzy, no-wrap, priority:100
#| msgid "nvimdiff2"
msgid "`nvimdiff2`"
msgstr "nvimdiff2"

#. type: Plain text
#: en/mergetools-merge.txt:22
#, priority:100
msgid "Use Neovim with a 3 panes layout (LOCAL, MERGED and REMOTE)"
msgstr ""

#. type: Labeled list
#: en/mergetools-merge.txt:22
#, fuzzy, no-wrap, priority:100
#| msgid "nvimdiff3"
msgid "`nvimdiff3`"
msgstr "nvimdiff3"

#. type: Plain text
#: en/mergetools-merge.txt:23
#, priority:100
msgid "Use Neovim where only the MERGED file is shown"
msgstr ""

#. type: Labeled list
#: en/mergetools-merge.txt:23
#, ignore-same, no-wrap, priority:100
msgid "`opendiff`"
msgstr "`opendiff`"

#. type: Plain text
#: en/mergetools-merge.txt:24
#, priority:100
msgid "Use FileMerge (requires a graphical session)"
msgstr ""

#. type: Labeled list
#: en/mergetools-merge.txt:24
#, fuzzy, no-wrap, priority:100
#| msgid "p4merge"
msgid "`p4merge`"
msgstr "p4merge"

#. type: Plain text
#: en/mergetools-merge.txt:25
#, priority:100
msgid "Use HelixCore P4Merge (requires a graphical session)"
msgstr ""

#. type: Labeled list
#: en/mergetools-merge.txt:25
#, ignore-same, no-wrap, priority:100
msgid "`smerge`"
msgstr "`smerge`"

#. type: Plain text
#: en/mergetools-merge.txt:26
#, priority:100
msgid "Use Sublime Merge (requires a graphical session)"
msgstr ""

#. type: Labeled list
#: en/mergetools-merge.txt:26
#, ignore-same, no-wrap, priority:100
msgid "`tkdiff`"
msgstr "`tkdiff`"

#. type: Plain text
#: en/mergetools-merge.txt:27
#, priority:100
msgid "Use TkDiff (requires a graphical session)"
msgstr ""

#. type: Labeled list
#: en/mergetools-merge.txt:27
#, ignore-same, no-wrap, priority:100
msgid "`tortoisemerge`"
msgstr "`tortoisemerge`"

#. type: Plain text
#: en/mergetools-merge.txt:28
#, priority:100
msgid "Use TortoiseMerge (requires a graphical session)"
msgstr ""

#. type: Labeled list
#: en/mergetools-merge.txt:28
#, ignore-same, no-wrap, priority:100
msgid "`vimdiff`"
msgstr "`vimdiff`"

#. type: Plain text
#: en/mergetools-merge.txt:29
#, priority:100
msgid "Use Vim with a custom layout (see `git help mergetool`'s `BACKEND SPECIFIC HINTS` section)"
msgstr ""

#. type: Labeled list
#: en/mergetools-merge.txt:29
#, fuzzy, no-wrap, priority:100
#| msgid "vimdiff1"
msgid "`vimdiff1`"
msgstr "vimdiff1"

#. type: Plain text
#: en/mergetools-merge.txt:30
#, priority:100
msgid "Use Vim with a 2 panes layout (LOCAL and REMOTE)"
msgstr ""

#. type: Labeled list
#: en/mergetools-merge.txt:30
#, fuzzy, no-wrap, priority:100
#| msgid "vimdiff2"
msgid "`vimdiff2`"
msgstr "vimdiff2"

#. type: Plain text
#: en/mergetools-merge.txt:31
#, priority:100
msgid "Use Vim with a 3 panes layout (LOCAL, MERGED and REMOTE)"
msgstr ""

#. type: Labeled list
#: en/mergetools-merge.txt:31
#, fuzzy, no-wrap, priority:100
#| msgid "vimdiff3"
msgid "`vimdiff3`"
msgstr "vimdiff3"

#. type: Plain text
#: en/mergetools-merge.txt:32
#, priority:100
msgid "Use Vim where only the MERGED file is shown"
msgstr ""

#. type: Labeled list
#: en/mergetools-merge.txt:32
#, ignore-same, no-wrap, priority:100
msgid "`winmerge`"
msgstr "`winmerge`"

#. type: Plain text
#: en/mergetools-merge.txt:33
#, priority:100
msgid "Use WinMerge (requires a graphical session)"
msgstr ""

#. type: Labeled list
#: en/mergetools-merge.txt:33
#, ignore-same, no-wrap, priority:100
msgid "`xxdiff`"
msgstr "`xxdiff`"

#. type: Plain text
#: en/mergetools-merge.txt:33
#, priority:100
msgid "Use xxdiff (requires a graphical session)"
msgstr ""

#. type: Plain text
#: en/object-format-disclaimer.txt:6
#, priority:300
msgid "THIS OPTION IS EXPERIMENTAL! SHA-256 support is experimental and still in an early stage.  A SHA-256 repository will in general not be able to share work with \"regular\" SHA-1 repositories.  It should be assumed that, e.g., Git internal file formats in relation to SHA-256 repositories may change in backwards-incompatible ways.  Only use `--object-format=sha256` for testing purposes."
msgstr "此选项是实验性的！SHA-256 支持是实验性的，仍然处于早期阶段。一般来说，SHA-256 仓库不能与 \"常规\" SHA-1 仓库共同工作。应该假定，例如，与 SHA-256 仓库有关的 Git 内部文件格式可能会以向后不兼容的方式改变。仅在测试时使用 `--object-format=sha256` 选项。"

#. type: Title -
#: en/pretty-formats.txt:2
#, no-wrap, priority:260
msgid "PRETTY FORMATS"
msgstr "漂亮的格式"

#. type: Plain text
#: en/pretty-formats.txt:13
#, priority:260
msgid "If the commit is a merge, and if the pretty-format is not 'oneline', 'email' or 'raw', an additional line is inserted before the 'Author:' line.  This line begins with \"Merge: \" and the hashes of ancestral commits are printed, separated by spaces.  Note that the listed commits may not necessarily be the list of the *direct* parent commits if you have limited your view of history: for example, if you are only interested in changes related to a certain directory or file."
msgstr "如果提交是一个合并，并且如果pretty-format不是 \"oneline\"、\"email \"或 \"raw\"，那么在 \"Author: \"一行之前会插入一个附加行。  这一行的开头是 \"Merge:这一行以 \"Merge: \"开头，并打印出祖先提交的哈希值，用空格分隔。  请注意，如果你限制了你的历史视图，那么列出的提交不一定是*直接*父级提交的列表：例如，如果你只对与某个目录或文件有关的修改感兴趣。"

#. type: Plain text
#: en/pretty-formats.txt:20
#, priority:260
msgid "There are several built-in formats, and you can define additional formats by setting a pretty.<name> config option to either another format name, or a 'format:' string, as described below (see linkgit:git-config[1]). Here are the details of the built-in formats:"
msgstr "有几种内置的格式，你可以通过将 pretty.<name> 配置选项设置为另一种格式名称或 \"format: \"字符串来定义额外的格式，如下所述（见 linkgit:git-config[1] ）。下面是内置格式的细节。"

#. type: Plain text
#: en/pretty-formats.txt:22
#, ignore-same, priority:260
msgid "'oneline'"
msgstr "'oneline'"

#. type: Plain text
#: en/pretty-formats.txt:24
#, fuzzy, no-wrap, priority:260
msgid "<hash> <title-line>\n"
msgstr "<hash> <title line>\n"

#. type: Plain text
#: en/pretty-formats.txt:26
#, priority:260
msgid "This is designed to be as compact as possible."
msgstr "这个设计是为了尽可能的紧凑。"

#. type: Plain text
#: en/pretty-formats.txt:28
#, ignore-same, priority:260
msgid "'short'"
msgstr "'short'"

#. type: Plain text
#: en/pretty-formats.txt:31
#, no-wrap, priority:260
msgid ""
"commit <hash>\n"
"Author: <author>\n"
msgstr ""
"承诺<hash>\n"
"作者。<作者>的情况\n"

#. type: Plain text
#: en/pretty-formats.txt:33 en/pretty-formats.txt:41 en/pretty-formats.txt:51 en/pretty-formats.txt:63
#, fuzzy, no-wrap, priority:260
msgid "<title-line>\n"
msgstr "<title line>\n"

#. type: Plain text
#: en/pretty-formats.txt:35
#, ignore-same, priority:260
msgid "'medium'"
msgstr "'medium'"

#. type: Plain text
#: en/pretty-formats.txt:39
#, fuzzy, no-wrap, priority:260
#| msgid ""
#| "commit <hash>\n"
#| "Author: <author>\n"
#| "Date:   <author date>\n"
msgid ""
"commit <hash>\n"
"Author: <author>\n"
"Date:   <author-date>\n"
msgstr ""
"承诺<hash>\n"
"作者。<作者>的情况\n"
"日期。   <作者>日期\n"

#. type: Plain text
#: en/pretty-formats.txt:43 en/pretty-formats.txt:53 en/pretty-formats.txt:65 en/pretty-formats.txt:85
#, fuzzy, priority:260
#| msgid "<full commit message>"
msgid "<full-commit-message>"
msgstr "<完整的提交信息"

#. type: Plain text
#: en/pretty-formats.txt:45
#, ignore-same, priority:260
msgid "'full'"
msgstr "'full'"

#. type: Plain text
#: en/pretty-formats.txt:49
#, no-wrap, priority:260
msgid ""
"commit <hash>\n"
"Author: <author>\n"
"Commit: <committer>\n"
msgstr ""
"承诺<hash>\n"
"作者。< Author>\n"
"承诺。<committer>（提交者）。\n"

#. type: Plain text
#: en/pretty-formats.txt:55
#, ignore-same, priority:260
msgid "'fuller'"
msgstr "'fuller'"

#. type: Plain text
#: en/pretty-formats.txt:61
#, fuzzy, no-wrap, priority:260
#| msgid ""
#| "commit <hash>\n"
#| "Author:     <author>\n"
#| "AuthorDate: <author date>\n"
#| "Commit:     <committer>\n"
#| "CommitDate: <committer date>\n"
msgid ""
"commit <hash>\n"
"Author:     <author>\n"
"AuthorDate: <author-date>\n"
"Commit:     <committer>\n"
"CommitDate: <committer-date>\n"
msgstr ""
"承诺<hash>\n"
"作者。     <作者>的情况\n"
"作者日期。<作者日期>。\n"
"承诺。     <承诺者>\n"
"提交日期。<提交者日期>\n"

#. type: Plain text
#: en/pretty-formats.txt:67
#, fuzzy, priority:260
#| msgid "--dereference"
msgid "'reference'"
msgstr "--dereference"

#. type: Plain text
#: en/pretty-formats.txt:69
#, fuzzy, no-wrap, priority:260
#| msgid "<abbrev hash> (<title line>, <short author date>)\n"
msgid "<abbrev-hash> (<title-line>, <short-author-date>)\n"
msgstr "<abbrev hash>（<标题行>，<简短的作者日期>）。\n"

#. type: Plain text
#: en/pretty-formats.txt:76
#, priority:260
msgid "This format is used to refer to another commit in a commit message and is the same as `--pretty='format:%C(auto)%h (%s, %ad)'`.  By default, the date is formatted with `--date=short` unless another `--date` option is explicitly specified.  As with any `format:` with format placeholders, its output is not affected by other options like `--decorate` and `--walk-reflogs`."
msgstr "这种格式用于在提交信息中引用另一个提交，与`--pretty='format:%C(auto)%h (%s, %ad)'相同。  默认情况下，日期的格式为`--date=short`，除非明确指定其他`--date`选项。  与任何带有格式占位符的`format:`一样，其输出不受其他选项的影响，如`--decorate`和`--walk-reflogs`。"

#. type: Plain text
#: en/pretty-formats.txt:78
#, ignore-same, priority:260
msgid "'email'"
msgstr "'email'"

#. type: Plain text
#: en/pretty-formats.txt:83
#, fuzzy, no-wrap, priority:260
#| msgid ""
#| "From <hash> <date>\n"
#| "From: <author>\n"
#| "Date: <author date>\n"
#| "Subject: [PATCH] <title line>\n"
msgid ""
"From <hash> <date>\n"
"From: <author>\n"
"Date: <author-date>\n"
"Subject: [PATCH] <title-line>\n"
msgstr ""
"来自<hash><date>的信息\n"
"来自。<作者\n"
"日期。<作者>日期\n"
"主题。[PATCH] <标题行\n"

#. type: Plain text
#: en/pretty-formats.txt:87
#, fuzzy, priority:260
#| msgid "--mboxrd"
msgid "'mboxrd'"
msgstr "'mboxrd'"

#. type: Plain text
#: en/pretty-formats.txt:91
#, priority:260
msgid "Like 'email', but lines in the commit message starting with \"From \" (preceded by zero or more \">\") are quoted with \">\" so they aren't confused as starting a new commit."
msgstr "和 \"email \"一样，但提交信息中以 \"From \"开头的行（前面有零个或多个\">\"）用\">\"引出，这样就不会被混淆为开始了一个新的提交。"

#. type: Plain text
#: en/pretty-formats.txt:93
#, ignore-same, priority:260
msgid "'raw'"
msgstr "'raw'"

#. type: Plain text
#: en/pretty-formats.txt:103
#, priority:260
msgid "The 'raw' format shows the entire commit exactly as stored in the commit object.  Notably, the hashes are displayed in full, regardless of whether --abbrev or --no-abbrev are used, and 'parents' information show the true parent commits, without taking grafts or history simplification into account. Note that this format affects the way commits are displayed, but not the way the diff is shown e.g. with `git log --raw`. To get full object names in a raw diff format, use `--no-abbrev`."
msgstr "原始 \"格式显示的是整个提交对象中存储的内容。  值得注意的是，无论是否使用了 --abbrev 或 --no-abbrev，哈希值都会被完整地显示出来，而'parent'信息会显示真正的父级提交，不会考虑移花接木或历史简化。注意，这种格式会影响提交的显示方式，但不会影响diff的显示方式，比如用`git log --raw`来显示。要获得原始差异格式的完整对象名称，请使用`--no-abbrev`。"

#. type: Plain text
#: en/pretty-formats.txt:105
#, fuzzy, priority:260
#| msgid "'format:<string>'"
msgid "'format:<format-string>'"
msgstr "'format:<string>'"

#. type: Plain text
#: en/pretty-formats.txt:110
#, fuzzy, priority:260
#| msgid "The 'format:<string>' format allows you to specify which information you want to show. It works a little bit like printf format, with the notable exception that you get a newline with '%n' instead of '\\n'."
msgid "The 'format:<format-string>' format allows you to specify which information you want to show. It works a little bit like printf format, with the notable exception that you get a newline with '%n' instead of '\\n'."
msgstr "format:<string>\"格式允许你指定你想显示的信息。它的工作原理有点像printf格式，值得注意的是，你得到的换行是'%n'而不是'\\n'。"

#. type: Plain text
#: en/pretty-formats.txt:113
#, priority:260
msgid "E.g, 'format:\"The author of %h was %an, %ar%nThe title was >>%s<<%n\"' would show something like this:"
msgstr "例如，'format: \"The author of %h was %an, %ar%nThe title was >>%s<<%n\"'会显示这样的内容。"

#. type: delimited block -
#: en/pretty-formats.txt:117
#, no-wrap, priority:260
msgid ""
"The author of fe6e0ee was Junio C Hamano, 23 hours ago\n"
"The title was >>t4119: test autocomputing -p<n> for traditional diff input.<<\n"
msgstr ""
"fe6e0ee的作者是Junio C Hamano, 23小时前\n"
"标题是 >>t4119: 测试传统diff输入的自动计算-p<n>。\n"

#. type: Plain text
#: en/pretty-formats.txt:121
#, priority:260
msgid "The placeholders are:"
msgstr "占位符是。"

#. type: Plain text
#: en/pretty-formats.txt:123
#, priority:260
msgid "Placeholders that expand to a single literal character:"
msgstr "占位符，可扩展为一个字面字符。"

#. type: Labeled list
#: en/pretty-formats.txt:123
#, ignore-same, no-wrap, priority:260
msgid "'%n'"
msgstr "'%n'"

#. type: Plain text
#: en/pretty-formats.txt:124
#, priority:260
msgid "newline"
msgstr "换行"

#. type: Plain text
#: en/pretty-formats.txt:125
#, priority:260
msgid "a raw '%'"
msgstr "一个原始的'%'"

#. type: Labeled list
#: en/pretty-formats.txt:125
#, fuzzy, no-wrap, priority:260
msgid "'%x00'"
msgstr "'%x00'"

#. type: Plain text
#: en/pretty-formats.txt:126
#, priority:260
msgid "print a byte from a hex code"
msgstr "打印十六进制代码中的一个字节"

#. type: Plain text
#: en/pretty-formats.txt:128
#, priority:260
msgid "Placeholders that affect formatting of later placeholders:"
msgstr "影响后面占位符的格式化的占位符。"

#. type: Labeled list
#: en/pretty-formats.txt:128
#, ignore-same, no-wrap, priority:260
msgid "'%Cred'"
msgstr "'%Cred'"

#. type: Plain text
#: en/pretty-formats.txt:129
#, priority:260
msgid "switch color to red"
msgstr "切换颜色为红色"

#. type: Labeled list
#: en/pretty-formats.txt:129
#, ignore-same, no-wrap, priority:260
msgid "'%Cgreen'"
msgstr "'%Cgreen'"

#. type: Plain text
#: en/pretty-formats.txt:130
#, priority:260
msgid "switch color to green"
msgstr "切换颜色为绿色"

#. type: Labeled list
#: en/pretty-formats.txt:130
#, ignore-same, no-wrap, priority:260
msgid "'%Cblue'"
msgstr "'%Cblue'"

#. type: Plain text
#: en/pretty-formats.txt:131
#, priority:260
msgid "switch color to blue"
msgstr "将颜色改为蓝色"

#. type: Labeled list
#: en/pretty-formats.txt:131
#, ignore-same, no-wrap, priority:260
msgid "'%Creset'"
msgstr "'%Creset'"

#. type: Plain text
#: en/pretty-formats.txt:132
#, priority:260
msgid "reset color"
msgstr "重置颜色"

#. type: Labeled list
#: en/pretty-formats.txt:132
#, ignore-ellipsis, no-wrap, priority:260
msgid "'%C(...)'"
msgstr "'%C(...)'"

#. type: Plain text
#: en/pretty-formats.txt:146
#, ignore-ellipsis, priority:260
msgid "color specification, as described under Values in the \"CONFIGURATION FILE\" section of linkgit:git-config[1].  By default, colors are shown only when enabled for log output (by `color.diff`, `color.ui`, or `--color`, and respecting the `auto` settings of the former if we are going to a terminal). `%C(auto,...)` is accepted as a historical synonym for the default (e.g., `%C(auto,red)`). Specifying `%C(always,...)` will show the colors even when color is not otherwise enabled (though consider just using `--color=always` to enable color for the whole output, including this format and anything else git might color).  `auto` alone (i.e. `%C(auto)`) will turn on auto coloring on the next placeholders until the color is switched again."
msgstr "颜色规范，如linkgit:git-config[1]的 \"配置文件 \"部分中的数值描述。  默认情况下，只有在启用日志输出时才会显示颜色（通过 `color.diff`, `color.ui`, 或 `-color`, 如果我们要去终端，要尊重前者的`auto`设置）。`%C(auto,...)`被接受为默认的历史同义词（例如，`%C(auto,red)`）。指定`%C(always,...)`将显示颜色，即使没有启用颜色（尽管考虑使用`-color=always`来启用整个输出的颜色，包括这个格式和其他任何git可能的颜色）。  `auto`单独使用（即`%C(auto)`）将在下一个占位符上开启自动着色，直到再次切换颜色。"

#. type: Labeled list
#: en/pretty-formats.txt:146
#, ignore-same, no-wrap, priority:260
msgid "'%m'"
msgstr "'%m'"

#. type: Plain text
#: en/pretty-formats.txt:147
#, priority:260
msgid "left (`<`), right (`>`) or boundary (`-`) mark"
msgstr "左（`<`）、右（`>`）或边界（`-`）标记"

#. type: Labeled list
#: en/pretty-formats.txt:147
#, no-wrap, priority:260
msgid "'%w([<w>[,<i1>[,<i2>]]])'"
msgstr "'%w([<w>[,<i1>[,<i2>]]])'"

#. type: Plain text
#: en/pretty-formats.txt:149
#, priority:260
msgid "switch line wrapping, like the -w option of linkgit:git-shortlog[1]."
msgstr "开关包行，就像 linkgit:git-shortlog[1] 的 -w 选项。"

#. type: Labeled list
#: en/pretty-formats.txt:149
#, fuzzy, no-wrap, priority:260
msgid "'%<( <N> [,trunc|ltrunc|mtrunc])'"
msgstr "'%<(<N>[,trunc|ltrunc|mtrunc])'"

#. type: Plain text
#: en/pretty-formats.txt:165
#, fuzzy, priority:260
#| msgid "make the next placeholder take at least N columns, padding spaces on the right if necessary.  Optionally truncate at the beginning (ltrunc), the middle (mtrunc) or the end (trunc) if the output is longer than N columns.  Note that truncating only works correctly with N >= 2."
msgid "make the next placeholder take at least N column widths, padding spaces on the right if necessary.  Optionally truncate (with ellipsis '..') at the left (ltrunc) `..ft`, the middle (mtrunc) `mi..le`, or the end (trunc) `rig..`, if the output is longer than N columns.  Note 1: that truncating only works correctly with N >= 2.  Note 2: spaces around the N and M (see below)  values are optional.  Note 3: Emojis and other wide characters will take two display columns, which may over-run column boundaries.  Note 4: decomposed character combining marks may be misplaced at padding boundaries."
msgstr "使下一个占位符至少占用N列，必要时在右边填充空格。  如果输出超过N列，可以选择在开头（ltrunc）、中间（mtrunc）或结尾（trunc）进行截断。  注意，只有在N>=2的情况下，截断才会正常工作。"

#. type: Labeled list
#: en/pretty-formats.txt:165
#, fuzzy, no-wrap, priority:260
msgid "'%<|( <M> )'"
msgstr "'%<|(<N>)'"

#. type: Plain text
#: en/pretty-formats.txt:169
#, fuzzy, priority:260
#| msgid "make the next placeholder take at least until Nth columns, padding spaces on the right if necessary"
msgid "make the next placeholder take at least until Mth display column, padding spaces on the right if necessary.  Use negative M values for column positions measured from the right hand edge of the terminal window."
msgstr "使下一个占位符至少到第N列，必要时在右边填充空格"

#. type: Labeled list
#: en/pretty-formats.txt:169
#, fuzzy, no-wrap, priority:260
msgid "'%>( <N> )', '%>|( <M> )'"
msgstr "'%>(<N>)', '%>|(<N>)'"

#. type: Plain text
#: en/pretty-formats.txt:171
#, fuzzy, priority:260
msgid "similar to '%<( <N> )', '%<|( <M> )' respectively, but padding spaces on the left"
msgstr "'%><(<N>)', '%><|(<N>)'"

#. type: Labeled list
#: en/pretty-formats.txt:171
#, fuzzy, no-wrap, priority:260
msgid "'%>>( <N> )', '%>>|( <M> )'"
msgstr "'%>>(<N>)', '%>>|(<N>)'"

#. type: Plain text
#: en/pretty-formats.txt:176
#, fuzzy, priority:260
#| msgid "similar to '%>(<N>)', '%>|(<N>)' respectively, except that if the next placeholder takes more spaces than given and there are spaces on its left, use those spaces"
msgid "similar to '%>( <N> )', '%>|( <M> )' respectively, except that if the next placeholder takes more spaces than given and there are spaces on its left, use those spaces"
msgstr "分别类似于'%>(<N>)'、'%>|(<N>)'，只是如果下一个占位符占用的空间比给定的多，并且其左侧有空格，则使用这些空格。"

#. type: Labeled list
#: en/pretty-formats.txt:176
#, fuzzy, no-wrap, priority:260
msgid "'%><( <N> )', '%><|( <M> )'"
msgstr "'%><(<N>)', '%><|(<N>)'"

#. type: Plain text
#: en/pretty-formats.txt:179
#, fuzzy, priority:260
msgid "similar to '%<( <N> )', '%<|( <M> )' respectively, but padding both sides (i.e. the text is centered)"
msgstr "'%><(<N>)', '%><|(<N>)'"

#. type: Plain text
#: en/pretty-formats.txt:181
#, priority:260
msgid "Placeholders that expand to information extracted from the commit:"
msgstr "占位符，扩展到从提交中提取的信息。"

#. type: Labeled list
#: en/pretty-formats.txt:181
#, ignore-same, no-wrap, priority:260
msgid "'%H'"
msgstr "'%H'"

#. type: Plain text
#: en/pretty-formats.txt:182
#, fuzzy, priority:260
msgid "commit hash"
msgstr "提交哈希"

#. type: Labeled list
#: en/pretty-formats.txt:182
#, ignore-same, no-wrap, priority:260
msgid "'%h'"
msgstr "'%h'"

#. type: Plain text
#: en/pretty-formats.txt:183
#, priority:260
msgid "abbreviated commit hash"
msgstr "简称提交哈希"

#. type: Labeled list
#: en/pretty-formats.txt:183
#, ignore-same, no-wrap, priority:260
msgid "'%T'"
msgstr "'%T'"

#. type: Plain text
#: en/pretty-formats.txt:184
#, fuzzy, priority:260
msgid "tree hash"
msgstr "tree hash"

#. type: Labeled list
#: en/pretty-formats.txt:184
#, ignore-same, no-wrap, priority:260
msgid "'%t'"
msgstr "'%t'"

#. type: Plain text
#: en/pretty-formats.txt:185
#, priority:260
msgid "abbreviated tree hash"
msgstr "简称树形哈希"

#. type: Labeled list
#: en/pretty-formats.txt:185
#, ignore-same, no-wrap, priority:260
msgid "'%P'"
msgstr "'%P'"

#. type: Plain text
#: en/pretty-formats.txt:186
#, priority:260
msgid "parent hashes"
msgstr "父类哈希值"

#. type: Labeled list
#: en/pretty-formats.txt:186
#, ignore-same, no-wrap, priority:260
msgid "'%p'"
msgstr "'%p'"

#. type: Plain text
#: en/pretty-formats.txt:187
#, priority:260
msgid "abbreviated parent hashes"
msgstr "缩写的父母哈希值"

#. type: Labeled list
#: en/pretty-formats.txt:187
#, ignore-same, no-wrap, priority:260
msgid "'%an'"
msgstr "'%an'"

#. type: Plain text
#: en/pretty-formats.txt:188
#, fuzzy, priority:260
msgid "author name"
msgstr "提交人"

#. type: Labeled list
#: en/pretty-formats.txt:188
#, ignore-same, no-wrap, priority:260
msgid "'%aN'"
msgstr "'%aN'"

#. type: Plain text
#: en/pretty-formats.txt:190
#, fuzzy, priority:260
#| msgid "linkgit:git-checkout[1], linkgit:git-branch[1]"
msgid "author name (respecting .mailmap, see linkgit:git-shortlog[1] or linkgit:git-blame[1])"
msgstr "linkgit:git-checkout[1], linkgit:git-branch[1]"

#. type: Labeled list
#: en/pretty-formats.txt:190
#, ignore-same, no-wrap, priority:260
msgid "'%ae'"
msgstr "'%ae'"

#. type: Plain text
#: en/pretty-formats.txt:191
#, fuzzy, priority:260
msgid "author email"
msgstr "作者电子邮箱"

#. type: Labeled list
#: en/pretty-formats.txt:191
#, ignore-same, no-wrap, priority:260
msgid "'%aE'"
msgstr "'%aE'"

#. type: Plain text
#: en/pretty-formats.txt:193
#, fuzzy, priority:260
#| msgid "linkgit:git-checkout[1], linkgit:git-branch[1]"
msgid "author email (respecting .mailmap, see linkgit:git-shortlog[1] or linkgit:git-blame[1])"
msgstr "linkgit:git-checkout[1], linkgit:git-branch[1]"

#. type: Labeled list
#: en/pretty-formats.txt:193
#, ignore-same, no-wrap, priority:260
msgid "'%al'"
msgstr "'%al'"

#. type: Plain text
#: en/pretty-formats.txt:194
#, priority:260
msgid "author email local-part (the part before the '@' sign)"
msgstr "作者电子邮件的本地部分（\"@\"符号之前的部分）。"

#. type: Labeled list
#: en/pretty-formats.txt:194
#, ignore-same, no-wrap, priority:260
msgid "'%aL'"
msgstr "'%aL'"

#. type: Plain text
#: en/pretty-formats.txt:196
#, fuzzy, priority:260
#| msgid "linkgit:git-checkout[1], linkgit:git-branch[1]"
msgid "author local-part (see '%al') respecting .mailmap, see linkgit:git-shortlog[1] or linkgit:git-blame[1])"
msgstr "linkgit:git-checkout[1], linkgit:git-branch[1]"

#. type: Labeled list
#: en/pretty-formats.txt:196
#, ignore-same, no-wrap, priority:260
msgid "'%ad'"
msgstr "'%ad'"

#. type: Plain text
#: en/pretty-formats.txt:197
#, priority:260
msgid "author date (format respects --date= option)"
msgstr "作者日期（格式尊重--date=选项"

#. type: Labeled list
#: en/pretty-formats.txt:197
#, ignore-same, no-wrap, priority:260
msgid "'%aD'"
msgstr "'%aD'"

#. type: Plain text
#: en/pretty-formats.txt:198
#, priority:260
msgid "author date, RFC2822 style"
msgstr "作者日期，RFC2822风格"

#. type: Labeled list
#: en/pretty-formats.txt:198
#, ignore-same, no-wrap, priority:260
msgid "'%ar'"
msgstr "'%ar'"

#. type: Plain text
#: en/pretty-formats.txt:199
#, priority:260
msgid "author date, relative"
msgstr "作者日期，相对"

#. type: Labeled list
#: en/pretty-formats.txt:199
#, ignore-same, no-wrap, priority:260
msgid "'%at'"
msgstr "'%at'"

#. type: Plain text
#: en/pretty-formats.txt:200
#, priority:260
msgid "author date, UNIX timestamp"
msgstr "作者日期，UNIX时间戳"

#. type: Labeled list
#: en/pretty-formats.txt:200
#, ignore-same, no-wrap, priority:260
msgid "'%ai'"
msgstr "'%ai'"

#. type: Plain text
#: en/pretty-formats.txt:201
#, priority:260
msgid "author date, ISO 8601-like format"
msgstr "作者日期，类似ISO 8601的格式"

#. type: Labeled list
#: en/pretty-formats.txt:201
#, ignore-same, no-wrap, priority:260
msgid "'%aI'"
msgstr "'%aI'"

#. type: Plain text
#: en/pretty-formats.txt:202
#, priority:260
msgid "author date, strict ISO 8601 format"
msgstr "作者日期，严格的ISO 8601格式"

#. type: Labeled list
#: en/pretty-formats.txt:202
#, ignore-same, no-wrap, priority:260
msgid "'%as'"
msgstr "'%as'"

#. type: Plain text
#: en/pretty-formats.txt:203
#, priority:260
msgid "author date, short format (`YYYY-MM-DD`)"
msgstr "作者日期，短格式（`YYYY-MM-DD`）。"

#. type: Labeled list
#: en/pretty-formats.txt:203
#, ignore-same, no-wrap, priority:260
msgid "'%ah'"
msgstr "'%ah'"

#. type: Plain text
#: en/pretty-formats.txt:205
#, priority:260
msgid "author date, human style (like the `--date=human` option of linkgit:git-rev-list[1])"
msgstr "作者日期，人类风格（就像linkgit:git-rev-list[1]的`--date=human`选项）。"

#. type: Labeled list
#: en/pretty-formats.txt:205
#, ignore-same, no-wrap, priority:260
msgid "'%cn'"
msgstr "'%cn'"

#. type: Plain text
#: en/pretty-formats.txt:206
#, fuzzy, priority:260
msgid "committer name"
msgstr "committer name"

#. type: Labeled list
#: en/pretty-formats.txt:206
#, ignore-same, no-wrap, priority:260
msgid "'%cN'"
msgstr "'%cN'"

#. type: Plain text
#: en/pretty-formats.txt:208
#, fuzzy, priority:260
#| msgid "linkgit:git-checkout[1], linkgit:git-branch[1]"
msgid "committer name (respecting .mailmap, see linkgit:git-shortlog[1] or linkgit:git-blame[1])"
msgstr "linkgit:git-checkout[1], linkgit:git-branch[1]"

#. type: Labeled list
#: en/pretty-formats.txt:208
#, ignore-same, no-wrap, priority:260
msgid "'%ce'"
msgstr "'%ce'"

#. type: Plain text
#: en/pretty-formats.txt:209
#, fuzzy, priority:260
msgid "committer email"
msgstr "committer email"

#. type: Labeled list
#: en/pretty-formats.txt:209
#, ignore-same, no-wrap, priority:260
msgid "'%cE'"
msgstr "'%cE'"

#. type: Plain text
#: en/pretty-formats.txt:211
#, fuzzy, priority:260
#| msgid "linkgit:git-checkout[1], linkgit:git-branch[1]"
msgid "committer email (respecting .mailmap, see linkgit:git-shortlog[1] or linkgit:git-blame[1])"
msgstr "linkgit:git-checkout[1], linkgit:git-branch[1]"

#. type: Labeled list
#: en/pretty-formats.txt:211
#, ignore-same, no-wrap, priority:260
msgid "'%cl'"
msgstr "'%cl'"

#. type: Plain text
#: en/pretty-formats.txt:212
#, priority:260
msgid "committer email local-part (the part before the '@' sign)"
msgstr "承诺人电子邮件的本地部分（\"@\"符号之前的部分）。"

#. type: Labeled list
#: en/pretty-formats.txt:212
#, ignore-same, no-wrap, priority:260
msgid "'%cL'"
msgstr "'%cL'"

#. type: Plain text
#: en/pretty-formats.txt:214
#, fuzzy, priority:260
#| msgid "linkgit:git-checkout[1], linkgit:git-branch[1]"
msgid "committer local-part (see '%cl') respecting .mailmap, see linkgit:git-shortlog[1] or linkgit:git-blame[1])"
msgstr "linkgit:git-checkout[1], linkgit:git-branch[1]"

#. type: Labeled list
#: en/pretty-formats.txt:214
#, ignore-same, no-wrap, priority:260
msgid "'%cd'"
msgstr "'%cd'"

#. type: Plain text
#: en/pretty-formats.txt:215
#, priority:260
msgid "committer date (format respects --date= option)"
msgstr "承诺人日期（格式尊重--date=选项"

#. type: Labeled list
#: en/pretty-formats.txt:215
#, ignore-same, no-wrap, priority:260
msgid "'%cD'"
msgstr "'%cD'"

#. type: Plain text
#: en/pretty-formats.txt:216
#, priority:260
msgid "committer date, RFC2822 style"
msgstr "承诺人日期，RFC2822风格"

#. type: Labeled list
#: en/pretty-formats.txt:216
#, ignore-same, no-wrap, priority:260
msgid "'%cr'"
msgstr "'%cr'"

#. type: Plain text
#: en/pretty-formats.txt:217
#, priority:260
msgid "committer date, relative"
msgstr "承诺人日期，相对"

#. type: Labeled list
#: en/pretty-formats.txt:217
#, ignore-same, no-wrap, priority:260
msgid "'%ct'"
msgstr "'%ct'"

#. type: Plain text
#: en/pretty-formats.txt:218
#, priority:260
msgid "committer date, UNIX timestamp"
msgstr "提交者日期，UNIX时间戳"

#. type: Labeled list
#: en/pretty-formats.txt:218
#, ignore-same, no-wrap, priority:260
msgid "'%ci'"
msgstr "'%ci'"

#. type: Plain text
#: en/pretty-formats.txt:219
#, priority:260
msgid "committer date, ISO 8601-like format"
msgstr "承诺人日期，类似ISO 8601的格式"

#. type: Labeled list
#: en/pretty-formats.txt:219
#, ignore-same, no-wrap, priority:260
msgid "'%cI'"
msgstr "'%cI'"

#. type: Plain text
#: en/pretty-formats.txt:220
#, priority:260
msgid "committer date, strict ISO 8601 format"
msgstr "承诺人日期，严格的ISO 8601格式"

#. type: Labeled list
#: en/pretty-formats.txt:220
#, ignore-same, no-wrap, priority:260
msgid "'%cs'"
msgstr "'%cs'"

#. type: Plain text
#: en/pretty-formats.txt:221
#, priority:260
msgid "committer date, short format (`YYYY-MM-DD`)"
msgstr "承诺人日期，短格式（`YYYY-MM-DD`）。"

#. type: Labeled list
#: en/pretty-formats.txt:221
#, ignore-same, no-wrap, priority:260
msgid "'%ch'"
msgstr "'%ch'"

#. type: Plain text
#: en/pretty-formats.txt:223
#, priority:260
msgid "committer date, human style (like the `--date=human` option of linkgit:git-rev-list[1])"
msgstr "提交者的日期，人类风格（就像linkgit:git-rev-list[1]的`--date=human`选项）。"

#. type: Labeled list
#: en/pretty-formats.txt:223
#, ignore-same, no-wrap, priority:260
msgid "'%d'"
msgstr "'%d'"

#. type: Plain text
#: en/pretty-formats.txt:224
#, priority:260
msgid "ref names, like the --decorate option of linkgit:git-log[1]"
msgstr "ref名称，就像linkgit:git-log[1]的-decorate选项。"

#. type: Labeled list
#: en/pretty-formats.txt:224
#, ignore-same, no-wrap, priority:260
msgid "'%D'"
msgstr "'%D'"

#. type: Plain text
#: en/pretty-formats.txt:225
#, priority:260
msgid "ref names without the \" (\", \")\" wrapping."
msgstr "没有\"（\"、\"）\"包装的参考文献名称。"

#. type: Labeled list
#: en/pretty-formats.txt:225
#, no-wrap, priority:260
msgid "'%(describe[:options])'"
msgstr "'%(description[:options])'"

#. type: Plain text
#: en/pretty-formats.txt:232
#, priority:260
msgid "human-readable name, like linkgit:git-describe[1]; empty string for undescribable commits.  The `describe` string may be followed by a colon and zero or more comma-separated options.  Descriptions can be inconsistent when tags are added or removed at the same time."
msgstr "人类可读的名字，像linkgit:git-describe[1]；空字符串表示不可描述的提交。  `describe`字符串后面可以有冒号和零个或多个逗号分隔的选项。  当标签同时被添加或删除时，描述可能不一致。"

#. type: Plain text
#: en/pretty-formats.txt:235
#, priority:260
msgid "'tags[=<bool-value>]': Instead of only considering annotated tags, consider lightweight tags as well."
msgstr "'tags[=<bool-value>]'：不仅考虑带注释的标签，还考虑轻量级标签。"

#. type: Plain text
#: en/pretty-formats.txt:239
#, fuzzy, priority:260
#| msgid "Instead of using the default number of hexadecimal digits (which will vary according to the number of objects in the repository with a default of 7) of the abbreviated object name, use <n> digits, or as many digits as needed to form a unique object name. An <n> of 0 will suppress long format, only showing the closest tag."
msgid "'abbrev=<number>': Instead of using the default number of hexadecimal digits (which will vary according to the number of objects in the repository with a default of 7) of the abbreviated object name, use <number> digits, or as many digits as needed to form a unique object name."
msgstr "不要使用缩写对象名称的默认十六进制数字（根据存储库中对象的数量而变化，默认为7），而是使用<n>数字，或根据需要使用任意多的数字来形成唯一的对象名称。<n>为0将抑制长格式，仅显示最近的标记。"

#. type: Plain text
#: en/pretty-formats.txt:241
#, priority:260
msgid "'match=<pattern>': Only consider tags matching the given `glob(7)` pattern, excluding the \"refs/tags/\" prefix."
msgstr "'match=<pattern>':只考虑与给定的`glob(7)`模式匹配的标签，不包括 \"refs/tags/\"前缀。"

#. type: Plain text
#: en/pretty-formats.txt:243
#, priority:260
msgid "'exclude=<pattern>': Do not consider tags matching the given `glob(7)` pattern, excluding the \"refs/tags/\" prefix."
msgstr "'exclude=<pattern>':不考虑匹配给定`glob(7)`模式的标签，排除 \"refs/tags/\"前缀。"

#. type: Plain text
#: en/pretty-formats.txt:246
#, priority:260
msgid "ref name given on the command line by which the commit was reached (like `git log --source`), only works with `git log`"
msgstr "在命令行中给出的提交名称（如`git log --source`），只对`git log`起作用。"

#. type: Labeled list
#: en/pretty-formats.txt:246
#, ignore-same, no-wrap, priority:260
msgid "'%e'"
msgstr "'%e'"

#. type: Plain text
#: en/pretty-formats.txt:247
#, fuzzy, priority:260
msgid "encoding"
msgstr "编码方式"

#. type: Plain text
#: en/pretty-formats.txt:248
#, fuzzy, priority:260
msgid "subject"
msgstr "主题"

#. type: Labeled list
#: en/pretty-formats.txt:248
#, ignore-same, no-wrap, priority:260
msgid "'%f'"
msgstr "'%f'"

#. type: Plain text
#: en/pretty-formats.txt:249
#, priority:260
msgid "sanitized subject line, suitable for a filename"
msgstr "经过消毒的主题行，适合于文件名"

#. type: Labeled list
#: en/pretty-formats.txt:249
#, ignore-same, no-wrap, priority:260
msgid "'%b'"
msgstr "'%b'"

#. type: Plain text
#: en/pretty-formats.txt:250
#, fuzzy, priority:260
msgid "body"
msgstr "body"

#. type: Labeled list
#: en/pretty-formats.txt:250
#, ignore-same, no-wrap, priority:260
msgid "'%B'"
msgstr "'%B'"

#. type: Plain text
#: en/pretty-formats.txt:251
#, priority:260
msgid "raw body (unwrapped subject and body)"
msgstr "原始体（未包装的主题和体）。"

#. type: Labeled list
#: en/pretty-formats.txt:252
#, ignore-same, no-wrap, priority:260
msgid "'%N'"
msgstr "'%N'"

#. type: Plain text
#: en/pretty-formats.txt:253
#, priority:260
msgid "commit notes"
msgstr "承诺说明"

#. type: Labeled list
#: en/pretty-formats.txt:254
#, ignore-same, no-wrap, priority:260
msgid "'%GG'"
msgstr "'%GG'"

#. type: Plain text
#: en/pretty-formats.txt:255
#, priority:260
msgid "raw verification message from GPG for a signed commit"
msgstr "来自GPG的签名提交的原始验证信息"

#. type: Labeled list
#: en/pretty-formats.txt:255
#, fuzzy, no-wrap, priority:260
msgid "'%G?'"
msgstr "'%G?'"

#. type: Plain text
#: en/pretty-formats.txt:263
#, priority:260
msgid "show \"G\" for a good (valid) signature, \"B\" for a bad signature, \"U\" for a good signature with unknown validity, \"X\" for a good signature that has expired, \"Y\" for a good signature made by an expired key, \"R\" for a good signature made by a revoked key, \"E\" if the signature cannot be checked (e.g. missing key)  and \"N\" for no signature"
msgstr "显示 \"G \"代表一个好的（有效的）签名，\"B \"代表一个坏的签名，\"U \"代表一个有效性未知的好的签名，\"X \"代表一个已经过期的好的签名，\"Y \"代表一个由过期的钥匙制作的好的签名，\"R \"代表一个由撤销的钥匙制作的好的签名，\"E \"如果不能检查签名（如缺少钥匙），\"N \"代表没有签名。"

#. type: Labeled list
#: en/pretty-formats.txt:263
#, ignore-same, no-wrap, priority:260
msgid "'%GS'"
msgstr "'%GS'"

#. type: Plain text
#: en/pretty-formats.txt:264
#, priority:260
msgid "show the name of the signer for a signed commit"
msgstr "显示已签名的提交的签名者的名字"

#. type: Labeled list
#: en/pretty-formats.txt:264
#, ignore-same, no-wrap, priority:260
msgid "'%GK'"
msgstr "'%GK'"

#. type: Plain text
#: en/pretty-formats.txt:265
#, priority:260
msgid "show the key used to sign a signed commit"
msgstr "显示用于签署已签名的承诺的密钥"

#. type: Labeled list
#: en/pretty-formats.txt:265
#, ignore-same, no-wrap, priority:260
msgid "'%GF'"
msgstr "'%GF'"

#. type: Plain text
#: en/pretty-formats.txt:266
#, priority:260
msgid "show the fingerprint of the key used to sign a signed commit"
msgstr "显示用于签署已签名提交文件的密钥的指纹。"

#. type: Labeled list
#: en/pretty-formats.txt:266
#, ignore-same, no-wrap, priority:260
msgid "'%GP'"
msgstr "'%GP'"

#. type: Plain text
#: en/pretty-formats.txt:268
#, priority:260
msgid "show the fingerprint of the primary key whose subkey was used to sign a signed commit"
msgstr "显示主键的指纹，该主键的子键被用来签署一个已签署的提交。"

#. type: Labeled list
#: en/pretty-formats.txt:268
#, ignore-same, no-wrap, priority:260
msgid "'%GT'"
msgstr "'%GT'"

#. type: Plain text
#: en/pretty-formats.txt:269
#, priority:260
msgid "show the trust level for the key used to sign a signed commit"
msgstr "显示用于签署已签名的承诺的密钥的信任级别"

#. type: Labeled list
#: en/pretty-formats.txt:269
#, ignore-same, no-wrap, priority:260
msgid "'%gD'"
msgstr "'%gD'"

#. type: Plain text
#: en/pretty-formats.txt:274
#, priority:260
msgid "reflog selector, e.g., `refs/stash@{1}` or `refs/stash@{2 minutes ago}`; the format follows the rules described for the `-g` option. The portion before the `@` is the refname as given on the command line (so `git log -g refs/heads/master` would yield `refs/heads/master@{0}`)."
msgstr "reflog选择器，例如，`refs/stash@{1}`或`refs/stash@{2分钟前}`；其格式遵循`-g`选项的规则。`@'前面的部分是命令行上给出的参考文献名称（所以`git log -g refs/heads/master`会产生`refs/heads/master@{0}`）。"

#. type: Labeled list
#: en/pretty-formats.txt:274
#, ignore-same, no-wrap, priority:260
msgid "'%gd'"
msgstr "'%gd'"

#. type: Plain text
#: en/pretty-formats.txt:277
#, priority:260
msgid "shortened reflog selector; same as `%gD`, but the refname portion is shortened for human readability (so `refs/heads/master` becomes just `master`)."
msgstr "简化的 reflog 选择器；与 `%gD` 相同，但 refname 部分被缩短以利于人类阅读（因此 `refs/heads/master` 变成了 `master`）。"

#. type: Labeled list
#: en/pretty-formats.txt:277
#, ignore-same, no-wrap, priority:260
msgid "'%gn'"
msgstr "'%gn'"

#. type: Plain text
#: en/pretty-formats.txt:278
#, priority:260
msgid "reflog identity name"
msgstr "记录身份名称"

#. type: Labeled list
#: en/pretty-formats.txt:278
#, ignore-same, no-wrap, priority:260
msgid "'%gN'"
msgstr "'%gN'"

#. type: Plain text
#: en/pretty-formats.txt:280
#, fuzzy, priority:260
#| msgid "linkgit:git-checkout[1], linkgit:git-branch[1]"
msgid "reflog identity name (respecting .mailmap, see linkgit:git-shortlog[1] or linkgit:git-blame[1])"
msgstr "linkgit:git-checkout[1], linkgit:git-branch[1]"

#. type: Labeled list
#: en/pretty-formats.txt:280
#, ignore-same, no-wrap, priority:260
msgid "'%ge'"
msgstr "'%ge'"

#. type: Plain text
#: en/pretty-formats.txt:281
#, priority:260
msgid "reflog identity email"
msgstr "重新记录身份邮件"

#. type: Labeled list
#: en/pretty-formats.txt:281
#, ignore-same, no-wrap, priority:260
msgid "'%gE'"
msgstr "'%gE'"

#. type: Plain text
#: en/pretty-formats.txt:283
#, fuzzy, priority:260
#| msgid "linkgit:git-checkout[1], linkgit:git-branch[1]"
msgid "reflog identity email (respecting .mailmap, see linkgit:git-shortlog[1] or linkgit:git-blame[1])"
msgstr "linkgit:git-checkout[1], linkgit:git-branch[1]"

#. type: Labeled list
#: en/pretty-formats.txt:283
#, ignore-same, no-wrap, priority:260
msgid "'%gs'"
msgstr "'%gs'"

#. type: Plain text
#: en/pretty-formats.txt:284
#, priority:260
msgid "reflog subject"
msgstr "记录主题"

#. type: Labeled list
#: en/pretty-formats.txt:284
#, no-wrap, priority:260
msgid "'%(trailers[:options])'"
msgstr "'%(trailer[:options])'"

#. type: Plain text
#: en/pretty-formats.txt:291
#, priority:260
msgid "display the trailers of the body as interpreted by linkgit:git-interpret-trailers[1]. The `trailers` string may be followed by a colon and zero or more comma-separated options.  If any option is provided multiple times the last occurrence wins."
msgstr "显示由linkgit:git-interpret-trailers[1]解释的正文的预告片。`trailers`字符串后面可以有冒号和零个或多个逗号分隔的选项。  如果任何选项被多次提供，则最后出现的选项获胜。"

#. type: Plain text
#: en/pretty-formats.txt:300
#, fuzzy, priority:260
#| msgid "'key=<K>': only show trailers with specified key. Matching is done case-insensitively and trailing colon is optional. If option is given multiple times trailer lines matching any of the keys are shown. This option automatically enables the `only` option so that non-trailer lines in the trailer block are hidden. If that is not desired it can be disabled with `only=false`.  E.g., `%(trailers:key=Reviewed-by)` shows trailer lines with key `Reviewed-by`."
msgid "'key=<key>': only show trailers with specified <key>. Matching is done case-insensitively and trailing colon is optional. If option is given multiple times trailer lines matching any of the keys are shown. This option automatically enables the `only` option so that non-trailer lines in the trailer block are hidden. If that is not desired it can be disabled with `only=false`.  E.g., `%(trailers:key=Reviewed-by)` shows trailer lines with key `Reviewed-by`."
msgstr "'key=<K>'：只显示具有指定密钥的拖车。匹配是不分大小写的，后面的冒号是可选的。如果多次给出选项，则显示与任何键匹配的拖车行。该选项自动启用 \"only \"选项，使拖车块中的非拖车行被隐藏。如果不希望这样，可以用`only=false`禁用。  例如，`%(trailers:key=Reviewed-by)`显示键为`Reviewed-by'的拖车行。"

#. type: Plain text
#: en/pretty-formats.txt:302
#, fuzzy, priority:260
#| msgid "'only[=<BOOL>]': select whether non-trailer lines from the trailer block should be included."
msgid "'only[=<bool>]': select whether non-trailer lines from the trailer block should be included."
msgstr "only[=<BOOL>]\"：选择是否应该包括来自拖车块的非拖车行。"

#. type: Plain text
#: en/pretty-formats.txt:310
#, fuzzy, priority:260
#| msgid "'separator=<SEP>': specify a separator inserted between trailer lines. When this option is not given each trailer line is terminated with a line feed character. The string SEP may contain the literal formatting codes described above. To use comma as separator one must use `%x2C` as it would otherwise be parsed as next option. E.g., `%(trailers:key=Ticket,separator=%x2C )` shows all trailer lines whose key is \"Ticket\" separated by a comma and a space."
msgid "'separator=<sep>': specify a separator inserted between trailer lines. When this option is not given each trailer line is terminated with a line feed character. The string <sep> may contain the literal formatting codes described above. To use comma as separator one must use `%x2C` as it would otherwise be parsed as next option. E.g., `%(trailers:key=Ticket,separator=%x2C )` shows all trailer lines whose key is \"Ticket\" separated by a comma and a space."
msgstr "separator=<SEP>'：指定在拖车行之间插入一个分隔符。当没有给出这个选项时，每个拖车行都以换行字符结束。字符串SEP可以包含上述的字面格式化代码。要使用逗号作为分隔符，必须使用`%x2C`，否则它将被解析为下一个选项。例如，`%(trailers:key=Ticket,separator=%x2C )`显示所有密钥为 \"Ticket \"的拖车行，用逗号和空格分隔。"

#. type: Plain text
#: en/pretty-formats.txt:313
#, fuzzy, priority:260
#| msgid "'unfold[=<BOOL>]': make it behave as if interpret-trailer's `--unfold` option was given. E.g., `%(trailers:only,unfold=true)` unfolds and shows all trailer lines."
msgid "'unfold[=<bool>]': make it behave as if interpret-trailer's `--unfold` option was given. E.g., `%(trailers:only,unfold=true)` unfolds and shows all trailer lines."
msgstr "unfold[=<BOOL>]\"：使它的行为就像 interpret-trailer 的 `--unfold` 选项被给出一样。例如，`%(trailers:only,unfold=true)`会展开并显示所有的拖车行。"

#. type: Plain text
#: en/pretty-formats.txt:314
#, fuzzy, priority:260
#| msgid "'keyonly[=<BOOL>]': only show the key part of the trailer."
msgid "'keyonly[=<bool>]': only show the key part of the trailer."
msgstr "keyonly[=<BOOL>]\"：只显示拖车的关键部分。"

#. type: Plain text
#: en/pretty-formats.txt:315
#, fuzzy, priority:260
#| msgid "'valueonly[=<BOOL>]': only show the value part of the trailer."
msgid "'valueonly[=<bool>]': only show the value part of the trailer."
msgstr "'valueonly[=<BOOL>]'：只显示拖车的值部分。"

#. type: Plain text
#: en/pretty-formats.txt:319
#, fuzzy, priority:260
#| msgid "'key_value_separator=<SEP>': specify a separator inserted between trailer lines. When this option is not given each trailer key-value pair is separated by \": \". Otherwise it shares the same semantics as 'separator=<SEP>' above."
msgid "'key_value_separator=<sep>': specify a separator inserted between trailer lines. When this option is not given each trailer key-value pair is separated by \": \". Otherwise it shares the same semantics as 'separator=<sep>' above."
msgstr "'key_value_separator=<SEP>'：指定在拖车行之间插入一个分隔符。当这个选项没有给出时，每个预告片的键值对都用\": \"分开。 否则，它的语义与上面的'separator=<SEP>'相同。"

#. type: Plain text
#: en/pretty-formats.txt:326
#, priority:260
msgid "Some placeholders may depend on other options given to the revision traversal engine. For example, the `%g*` reflog options will insert an empty string unless we are traversing reflog entries (e.g., by `git log -g`). The `%d` and `%D` placeholders will use the \"short\" decoration format if `--decorate` was not already provided on the command line."
msgstr "一些占位符可能取决于给修订版遍历引擎的其他选项。例如，`%g*` reflog选项将插入一个空字符串，除非我们正在遍历reflog条目（例如，通过`git log -g`）。`%d`和`%D`占位符将使用 \"短 \"装饰格式，如果`--decorate`没有在命令行上提供。"

#. type: Plain text
#: en/pretty-formats.txt:331
#, fuzzy, priority:260
#| msgid "The boolean options accept an optional value `[=<BOOL>]`. The values `true`, `false`, `on`, `off` etc. are all accepted. See the \"boolean\" sub-section in \"EXAMPLES\" in linkgit:git-config[1]. If a boolean option is given with no value, it's enabled."
msgid "The boolean options accept an optional value `[=<bool-value>]`. The values `true`, `false`, `on`, `off` etc. are all accepted. See the \"boolean\" sub-section in \"EXAMPLES\" in linkgit:git-config[1]. If a boolean option is given with no value, it's enabled."
msgstr "布尔选项接受一个可选的值`[=<BOOL>]`。`true`, `false`, `on`, `off`等值都可以接受。参见linkgit:git-config[1]中 \"示例 \"的 \"布尔 \"子章节。如果一个布尔选项没有给出值，它就被启用。"

#. type: Plain text
#: en/pretty-formats.txt:335
#, priority:260
msgid "If you add a `+` (plus sign) after '%' of a placeholder, a line-feed is inserted immediately before the expansion if and only if the placeholder expands to a non-empty string."
msgstr "如果你在占位符的'%'后面加了一个`+'（加号），当且仅当占位符扩展为一个非空字符串时，在扩展前会立即插入换行符。"

#. type: Plain text
#: en/pretty-formats.txt:339
#, priority:260
msgid "If you add a `-` (minus sign) after '%' of a placeholder, all consecutive line-feeds immediately preceding the expansion are deleted if and only if the placeholder expands to an empty string."
msgstr "如果你在占位符的'%'后面加了一个`-'（减号），如果且仅当占位符扩展为空字符串时，紧接着扩展前的所有连续换行将被删除。"

#. type: Plain text
#: en/pretty-formats.txt:343
#, priority:260
msgid "If you add a ` ` (space) after '%' of a placeholder, a space is inserted immediately before the expansion if and only if the placeholder expands to a non-empty string."
msgstr "如果你在占位符的'%'后面加了一个``（空格），当且仅当占位符扩展到一个非空字符串时，空格就会紧接着插入扩展。"

#. type: Plain text
#: en/pretty-formats.txt:345
#, fuzzy, priority:260
msgid "'tformat:'"
msgstr "'tformat:'"

#. type: Plain text
#: en/pretty-formats.txt:353
#, priority:260
msgid "The 'tformat:' format works exactly like 'format:', except that it provides \"terminator\" semantics instead of \"separator\" semantics. In other words, each commit has the message terminator character (usually a newline) appended, rather than a separator placed between entries.  This means that the final entry of a single-line format will be properly terminated with a new line, just as the \"oneline\" format does.  For example:"
msgstr "tformat: \"格式的工作原理与 \"format: \"完全一样，只是它提供了 \"终止符 \"语义，而不是 \"分隔符 \"语义。换句话说，每个提交都附加了信息结束符（通常是换行符），而不是在条目之间放置一个分隔符。  这意味着单行格式的最后一个条目将正确地以新行结束，就像 \"单行 \"格式那样。  比如说"

#. type: delimited block -
#: en/pretty-formats.txt:359
#, fuzzy, no-wrap, priority:260
msgid ""
"$ git log -2 --pretty=format:%h 4da45bef \\\n"
"  | perl -pe '$_ .= \" -- NO NEWLINE\\n\" unless /\\n/'\n"
"4da45be\n"
"7134973 -- NO NEWLINE\n"
msgstr ""
"$ git log -2 --pretty=format:%h 4da45bef \\\n"
"  | perl -pe '$_ .= \" -- NO NEWLINE\\n\" unless /\\n/'\n"
"4da45be\n"
"7134973 -- NO NEWLINE\n"

#. type: delimited block -
#: en/pretty-formats.txt:364
#, fuzzy, no-wrap, priority:260
msgid ""
"$ git log -2 --pretty=tformat:%h 4da45bef \\\n"
"  | perl -pe '$_ .= \" -- NO NEWLINE\\n\" unless /\\n/'\n"
"4da45be\n"
"7134973\n"
msgstr ""
"$ git log -2 --pretty=tformat:%h 4da45bef \\\n"
"  | perl -pe '$_ .= \" -- NO NEWLINE\\n\" unless /\\n/'\n"
"4da45be\n"
"7134973\n"

#. type: Plain text
#: en/pretty-formats.txt:369
#, priority:260
msgid "In addition, any unrecognized string that has a `%` in it is interpreted as if it has `tformat:` in front of it.  For example, these two are equivalent:"
msgstr "此外，任何未被识别的字符串，如果其中有`%`，将被解释为前面有`tformat:`。  例如，这两个是等同的。"

#. type: delimited block -
#: en/pretty-formats.txt:373
#, fuzzy, no-wrap, priority:260
msgid ""
"$ git log -2 --pretty=tformat:%h 4da45bef\n"
"$ git log -2 --pretty=%h 4da45bef\n"
msgstr ""
"$ git log -2 --pretty=tformat:%h 4da45bef\n"
"$ git log -2 --pretty=%h 4da45bef\n"

#. type: Labeled list
#: en/pretty-options.txt:1
#, fuzzy, no-wrap, priority:260
msgid "--pretty[=<format>]"
msgstr "--pretty[=<format>]"

#. type: Plain text
#: en/pretty-options.txt:10
#, priority:260
msgid "Pretty-print the contents of the commit logs in a given format, where '<format>' can be one of 'oneline', 'short', 'medium', 'full', 'fuller', 'reference', 'email', 'raw', 'format:<string>' and 'tformat:<string>'.  When '<format>' is none of the above, and has '%placeholder' in it, it acts as if '--pretty=tformat:<format>' were given."
msgstr "以指定的格式打印提交日志的内容，其中'<format>'可以是'oneline'、'short'、'medium'、'full'、'fuller'、'reference'、'email'、'raw'、'format:<string>'和'tformat:<string>'之一。  当'<format>'不是上述任何一种，并且其中有'%placeholder'时，它的作用就像给出'--pretty=tformat:<format>'一样。"

#. type: Plain text
#: en/pretty-options.txt:13
#, priority:260
msgid "See the \"PRETTY FORMATS\" section for some additional details for each format.  When '=<format>' part is omitted, it defaults to 'medium'."
msgstr "参见 \"PRETTY FORMATS \"部分，了解每种格式的一些额外细节。  当'=<格式>'部分被省略时，它默认为'中等'。"

#. type: Plain text
#: en/pretty-options.txt:16
#, priority:260
msgid "Note: you can specify the default pretty format in the repository configuration (see linkgit:git-config[1])."
msgstr "注意：你可以在版本库配置中指定默认的漂亮格式（见linkgit:git-config[1]）。"

#. type: Labeled list
#: en/pretty-options.txt:17
#, ignore-same, no-wrap, priority:260
msgid "--abbrev-commit"
msgstr "--abbrev-commit"

#. type: Plain text
#: en/pretty-options.txt:22
#, priority:260
msgid "Instead of showing the full 40-byte hexadecimal commit object name, show a prefix that names the object uniquely.  \"--abbrev=<n>\" (which also modifies diff output, if it is displayed)  option can be used to specify the minimum length of the prefix."
msgstr "不要显示完整的40字节的十六进制提交对象名称，而是显示一个前缀，以唯一的方式命名该对象。  \"--abbrev=<n>\"选项可以用来指定前缀的最小长度（如果显示的话，它也会修改diff输出）。"

#. type: Plain text
#: en/pretty-options.txt:25
#, priority:260
msgid "This should make \"--pretty=oneline\" a whole lot more readable for people using 80-column terminals."
msgstr "这应该使\"--pretty=oneline \"对于使用80列终端的人来说更容易阅读。"

#. type: Labeled list
#: en/pretty-options.txt:26
#, ignore-same, no-wrap, priority:260
msgid "--no-abbrev-commit"
msgstr "--no-abbrev-commit"

#. type: Plain text
#: en/pretty-options.txt:30
#, priority:260
msgid "Show the full 40-byte hexadecimal commit object name. This negates `--abbrev-commit`, either explicit or implied by other options such as \"--oneline\". It also overrides the `log.abbrevCommit` variable."
msgstr "显示完整的40字节十六进制的提交对象名称。这否定了`--abbrev-commit`，无论是明确的还是由其他选项如\"--oneline \"暗示的。它还覆盖了`log.abbrevCommit`变量。"

#. type: Plain text
#: en/pretty-options.txt:34
#, priority:260
msgid "This is a shorthand for \"--pretty=oneline --abbrev-commit\" used together."
msgstr "这是\"--pretty=oneline --abbrev-commit \"的简写，一起使用。"

#. type: Plain text
#: en/pretty-options.txt:46
#, fuzzy, priority:260
#| msgid "The commit objects record the encoding used for the log message in their encoding header; this option can be used to tell the command to re-code the commit log message in the encoding preferred by the user.  For non plumbing commands this defaults to UTF-8. Note that if an object claims to be encoded in `X` and we are outputting in `X`, we will output the object verbatim; this means that invalid sequences in the original commit may be copied to the output."
msgid "Commit objects record the character encoding used for the log message in their encoding header; this option can be used to tell the command to re-code the commit log message in the encoding preferred by the user.  For non plumbing commands this defaults to UTF-8. Note that if an object claims to be encoded in `X` and we are outputting in `X`, we will output the object verbatim; this means that invalid sequences in the original commit may be copied to the output. Likewise, if iconv(3) fails to convert the commit, we will quietly output the original object verbatim."
msgstr "提交对象在其编码头中记录了日志信息所使用的编码；这个选项可以用来告诉命令以用户喜欢的编码来重新编码提交日志信息。  对于非管道命令，默认为UTF-8。请注意，如果一个对象声称是以`X`编码的，而我们是以`X`输出的，我们将逐字输出该对象；这意味着原始提交中的无效序列可能会被复制到输出中。"

#. type: Labeled list
#: en/pretty-options.txt:47
#, fuzzy, no-wrap, priority:260
msgid "--expand-tabs=<n>"
msgstr "--expand-tabs=<n>"

#. type: Labeled list
#: en/pretty-options.txt:48
#, ignore-same, no-wrap, priority:260
msgid "--expand-tabs"
msgstr "--expand-tabs"

#. type: Labeled list
#: en/pretty-options.txt:49
#, ignore-same, no-wrap, priority:260
msgid "--no-expand-tabs"
msgstr "--no-expand-tabs"

#. type: Plain text
#: en/pretty-options.txt:56
#, priority:260
msgid "Perform a tab expansion (replace each tab with enough spaces to fill to the next display column that is multiple of '<n>')  in the log message before showing it in the output.  `--expand-tabs` is a short-hand for `--expand-tabs=8`, and `--no-expand-tabs` is a short-hand for `--expand-tabs=0`, which disables tab expansion."
msgstr "在输出中显示之前，在日志信息中进行标签扩展（用足够的空格替换每个标签，以填充到下一个显示列的'<n>'的倍数）。  `--expand-tabs`是`--expand-tabs=8`的简写，`--no-expand-tabs`是`--expand-tabs=0`的简写，它禁止标签扩展。"

#. type: Plain text
#: en/pretty-options.txt:60
#, priority:260
msgid "By default, tabs are expanded in pretty formats that indent the log message by 4 spaces (i.e.  'medium', which is the default, 'full', and 'fuller')."
msgstr "默认情况下，标签会以漂亮的格式展开，将日志信息缩进4个空格（即 \"中\"，这是默认的，\"全\"，和 \"更全\"）。"

#. type: Plain text
#: en/pretty-options.txt:68
#, priority:260
msgid "Show the notes (see linkgit:git-notes[1]) that annotate the commit, when showing the commit log message.  This is the default for `git log`, `git show` and `git whatchanged` commands when there is no `--pretty`, `--format`, or `--oneline` option given on the command line."
msgstr "在显示提交日志信息时，显示注释提交的说明（见linkgit:git-notes[1]）。  这是`git log`、`git show`和`git whatchanged`命令的默认设置，当命令行中没有给出`--pretty`、`--format`或`--oneline`选项时。"

#. type: Plain text
#: en/pretty-options.txt:72
#, priority:260
msgid "By default, the notes shown are from the notes refs listed in the `core.notesRef` and `notes.displayRef` variables (or corresponding environment overrides). See linkgit:git-config[1] for more details."
msgstr "默认情况下，显示的注释来自于`core.notesRef`和`notes.displayRef`变量（或相应的环境覆盖）中列出的注释参考。更多细节见linkgit:git-config[1]。"

#. type: Plain text
#: en/pretty-options.txt:77
#, priority:260
msgid "With an optional '<ref>' argument, use the ref to find the notes to display.  The ref can specify the full refname when it begins with `refs/notes/`; when it begins with `notes/`, `refs/` and otherwise `refs/notes/` is prefixed to form a full name of the ref."
msgstr "有了一个可选的'<ref>'参数，就可以使用ref来寻找要显示的笔记。  当ref以`refs/notes/`开头时，可以指定完整的ref名称；当它以`notes/`开头时，`refs/`，否则`refs/notes/`前缀，形成ref的全名。"

#. type: Plain text
#: en/pretty-options.txt:82
#, priority:260
msgid "Multiple --notes options can be combined to control which notes are being displayed. Examples: \"--notes=foo\" will show only notes from \"refs/notes/foo\"; \"--notes=foo --notes\" will show both notes from \"refs/notes/foo\" and from the default notes ref(s)."
msgstr "多个--音符选项可以组合起来，控制哪些音符被显示。例如。\"--notes=foo \"将只显示来自 \"refs/notes/foo \"的注释；\"--notes=foo --notes \"将同时显示来自 \"refs/notes/foo \"和默认注释的注释。"

#. type: Plain text
#: en/pretty-options.txt:89
#, priority:260
msgid "Do not show notes. This negates the above `--notes` option, by resetting the list of notes refs from which notes are shown.  Options are parsed in the order given on the command line, so e.g.  \"--notes --notes=foo --no-notes --notes=bar\" will only show notes from \"refs/notes/bar\"."
msgstr "不显示注释。这否定了上面的`--notes`选项，因为它重新设置了显示注释的注释列表。  选项按照命令行给出的顺序进行解析，因此，例如\"--notes --notes=foo --no-notes --notes=bar \"将只显示来自 \"refs/notes/bar \"的注释。"

#. type: Labeled list
#: en/pretty-options.txt:90
#, fuzzy, no-wrap, priority:260
#| msgid "--shallow-since=<date>"
msgid "--show-notes[=<ref>]"
msgstr "--show-notes[=<ref>]"

#. type: Labeled list
#: en/pretty-options.txt:91
#, ignore-same, no-wrap, priority:260
msgid "--[no-]standard-notes"
msgstr "--[no-]standard-notes"

#. type: Plain text
#: en/pretty-options.txt:94
#, priority:260
msgid "These options are deprecated. Use the above --notes/--no-notes options instead."
msgstr "这些选项已被废弃。请使用上面的 --notes/-no-notes 选项来代替。"

#. type: Labeled list
#: en/pretty-options.txt:96
#, ignore-same, no-wrap, priority:260
msgid "--show-signature"
msgstr "--show-signature"

#. type: Plain text
#: en/pretty-options.txt:98
#, priority:260
msgid "Check the validity of a signed commit object by passing the signature to `gpg --verify` and show the output."
msgstr "通过将签名传递给 `gpg --verify` 来检查已签名的提交对象的有效性，并显示输出。"

#. type: Plain text
#: en/pull-fetch-param.txt:6
#, priority:220
msgid "The \"remote\" repository that is the source of a fetch or pull operation.  This parameter can be either a URL (see the section <<URLS,GIT URLS>> below) or the name of a remote (see the section <<REMOTES,REMOTES>> below)."
msgstr "作为获取或拉动操作的来源的 \"remote\" 仓库。 这个参数可以是一个 URL（见下面 <<URLS,GIT URLS>> 一节），也可以是一个远程仓库的名称（见下面 <<远程,REMOTES>> 一节）。"

#. type: Labeled list
#: en/pull-fetch-param.txt:8
#, no-wrap, priority:220
msgid "<group>"
msgstr "<组>"

#. type: Plain text
#: en/pull-fetch-param.txt:12
#, priority:220
msgid "A name referring to a list of repositories as the value of remotes.<group> in the configuration file.  (See linkgit:git-config[1])."
msgstr "指向仓库列表的名称，作为配置文件中 remotes.<组> 的值。 (参见 linkgit:git-config[1]）。"

#. type: Labeled list
#: en/pull-fetch-param.txt:14
#, fuzzy, no-wrap, priority:220
msgid "<refspec>"
msgstr "<refspec>"

#. type: Plain text
#: en/pull-fetch-param.txt:18
#, priority:220
msgid "Specifies which refs to fetch and which local refs to update.  When no <refspec>s appear on the command line, the refs to fetch are read from `remote.<repository>.fetch` variables instead"
msgstr "指定要获取哪些引用，以及要更新哪些本地引用。 当命令行上没有出现 <引用规范> 时，将从`remote.<仓库>.fetch` 变量中读取要获取的引用"

#. type: Plain text
#: en/pull-fetch-param.txt:20
#, fuzzy, no-wrap, priority:220
msgid "\t(see <<CRTB,CONFIGURED REMOTE-TRACKING BRANCHES>> below).\n"
msgstr "\t(see <<CRTB,CONFIGURED REMOTE-TRACKING BRANCHES>> below).\n"

#. type: Plain text
#: en/pull-fetch-param.txt:24
#, no-wrap, priority:220
msgid ""
"\t(see the section \"CONFIGURED REMOTE-TRACKING BRANCHES\"\n"
"\tin linkgit:git-fetch[1]).\n"
msgstr ""
"\t(参见 linkgit:git-fetch[1] 中\n"
"\t “配置远程跟踪分支” 一节）。\n"

#. type: Plain text
#: en/pull-fetch-param.txt:32
#, priority:220
msgid "The format of a <refspec> parameter is an optional plus `+`, followed by the source <src>, followed by a colon `:`, followed by the destination ref <dst>.  The colon can be omitted when <dst> is empty.  <src> is typically a ref, but it can also be a fully spelled hex object name."
msgstr "<引用规范> 参数的格式是一个可选的加号 `+` ，后面是源 <src>，后面是冒号 `:`，后面是目标引用 <dst>。 当 <dst> 为空时，冒号可以被省略。 <src> 通常是一个引用，但它也可以是一个完全拼写的十六进制对象名称。"

#. type: Plain text
#: en/pull-fetch-param.txt:38
#, priority:220
msgid "A <refspec> may contain a `*` in its <src> to indicate a simple pattern match. Such a refspec functions like a glob that matches any ref with the same prefix. A pattern <refspec> must have a `*` in both the <src> and <dst>. It will map refs to the destination by replacing the `*` with the contents matched from the source."
msgstr "一个 <引用规范> 可以在其<src>中包含一个`*'来表示一个简单的模式匹配。这样的 refspec 的功能就像一个 glob，可以匹配任何具有相同前缀的 ref。匹配 <引用规范> 必须在 <src> 和 <dst> 中都有一个 `*`。它将通过把 `*` 替换成从源头匹配的内容来把引用映射到目的地。"

#. type: Plain text
#: en/pull-fetch-param.txt:48
#, priority:220
msgid "If a refspec is prefixed by `^`, it will be interpreted as a negative refspec. Rather than specifying which refs to fetch or which local refs to update, such a refspec will instead specify refs to exclude. A ref will be considered to match if it matches at least one positive refspec, and does not match any negative refspec. Negative refspecs can be useful to restrict the scope of a pattern refspec so that it will not include specific refs.  Negative refspecs can themselves be pattern refspecs. However, they may only contain a <src> and do not specify a <dst>. Fully spelled out hex object names are also not supported."
msgstr "如果一个 引用规范的前缀是 `^`，它将被解释为一个负向引用规范。这样的引用规范不是指定要获取哪些引用或更新哪些本地引用，而是指定要排除的引用。如果一个引用至少与一个正向引用规范匹配，并且不与任何负向引用规范匹配，那么该引用将被视为匹配。负向引用规范可以用来限制引用规范匹配的范围，使其不包括特定的引用。 负向引用规范本身可以是模式引用规范。然而，它们可能只包含一个 <src>，而不指定一个 <dst>。完全拼出的十六进制对象名称也不被支持。"

#. type: Plain text
#: en/pull-fetch-param.txt:51
#, priority:220
msgid "`tag <tag>` means the same as `refs/tags/<tag>:refs/tags/<tag>`; it requests fetching everything up to the given tag."
msgstr "`tag <标签>`的意思与`refs/tags/<标签>:refs/tags/<标签>` 相同；它要求获取到给定标签的所有内容。"

#. type: Plain text
#: en/pull-fetch-param.txt:55
#, priority:220
msgid "The remote ref that matches <src> is fetched, and if <dst> is not an empty string, an attempt is made to update the local ref that matches it."
msgstr "获取与 <src> 相匹配的远程引用，如果 <dst> 不是一个空字符串，就会尝试更新与之相匹配的本地引用。"

#. type: Plain text
#: en/pull-fetch-param.txt:62
#, ignore-ellipsis, priority:220
msgid "Whether that update is allowed without `--force` depends on the ref namespace it's being fetched to, the type of object being fetched, and whether the update is considered to be a fast-forward. Generally, the same rules apply for fetching as when pushing, see the `<refspec>...` section of linkgit:git-push[1] for what those are. Exceptions to those rules particular to 'git fetch' are noted below."
msgstr "该更新是否允许不使用 `--force`，取决于它被获取的引用命名空间、被获取的对象的类型，以及该更新是否被认为是一个快速合并。一般来说，获取的规则与推送的规则相同，参见 linkgit:git-push[1] 的 `<引用规范>...' 部分。以下是 \"git fetch\" 特殊规则的例外情况。"

#. type: Plain text
#: en/pull-fetch-param.txt:70
#, priority:220
msgid "Until Git version 2.20, and unlike when pushing with linkgit:git-push[1], any updates to `refs/tags/*` would be accepted without `+` in the refspec (or `--force`). When fetching, we promiscuously considered all tag updates from a remote to be forced fetches.  Since Git version 2.20, fetching to update `refs/tags/*` works the same way as when pushing. I.e. any updates will be rejected without `+` in the refspec (or `--force`)."
msgstr "在 Git 2.20 版本之前，与使用 linkgit:git-push[1] 推送时不同，任何对 `refs/tags/*` 的更新都会被接受，在引用规范中没有 `+`（或`--force`）。在获取的时候，我们把所有来自远程的标签更新都视为强制获取。 从 Git 2.20 版本开始，获取更新 `refs/tags/*` 的方式与推送时相同。也就是说，任何在引用规范中没有 `+` 的更新都会被拒绝（或`--force`）。"

#. type: Plain text
#: en/pull-fetch-param.txt:76
#, priority:220
msgid "Unlike when pushing with linkgit:git-push[1], any updates outside of `refs/{tags,heads}/*` will be accepted without `+` in the refspec (or `--force`), whether that's swapping e.g. a tree object for a blob, or a commit for another commit that's doesn't have the previous commit as an ancestor etc."
msgstr "与使用 linkgit:git-push[1] 推送时不同，任何在 `refs/{tags,heads}/*` 之外的更新都会被接受，在引用规范中没有 `+`（或`--force`），无论是将树对象换成二进制文件，还是将一个提交换成另一个没有前一个提交作为祖先的提交等等。"

#. type: Plain text
#: en/pull-fetch-param.txt:80
#, priority:220
msgid "Unlike when pushing with linkgit:git-push[1], there is no configuration which'll amend these rules, and nothing like a `pre-fetch` hook analogous to the `pre-receive` hook."
msgstr "与使用 linkgit:git-push[1] 推送时不同，没有任何配置可以修改这些规则，也没有类似于 `pre-receive` 的 `pre-fetch` 钩子。"

#. type: Plain text
#: en/pull-fetch-param.txt:87
#, priority:220
msgid "As with pushing with linkgit:git-push[1], all of the rules described above about what's not allowed as an update can be overridden by adding an the optional leading `+` to a refspec (or using `--force` command line option). The only exception to this is that no amount of forcing will make the `refs/heads/*` namespace accept a non-commit object."
msgstr "就像用 linkgit:git-push[1] 推送一样，上面描述的所有关于不允许更新的规则都可以通过在引用规范中添加一个可选的前导词 `+` 来覆盖（或者使用 `--force` 命令行选项）。唯一的例外是，无论如何强制都不能使 `refs/heads/*` 命名空间接受一个非提交对象。"

#. type: Plain text
#: en/pull-fetch-param.txt:99
#, priority:220
msgid "When the remote branch you want to fetch is known to be rewound and rebased regularly, it is expected that its new tip will not be descendant of its previous tip (as stored in your remote-tracking branch the last time you fetched).  You would want to use the `+` sign to indicate non-fast-forward updates will be needed for such branches.  There is no way to determine or declare that a branch will be made available in a repository with this behavior; the pulling user simply must know this is the expected usage pattern for a branch."
msgstr "当你想获取的远程分支已知会被定期回溯和重定向时，预计它的新提示不会是其先前提示的后代（如你上次获取时存储在远程跟踪分支中的提示）。  你应该使用 `+` 号来表示对这类分支需要进行非快速合并式更新。  没有办法确定或声明一个分支将以这种行为在仓库中提供；拉取的用户只是必须知道这是一个分支的预期使用模式。"

#. type: Plain text
#: en/pull-fetch-param.txt:119
#, priority:220
msgid "There is a difference between listing multiple <refspec> directly on 'git pull' command line and having multiple `remote.<repository>.fetch` entries in your configuration for a <repository> and running a 'git pull' command without any explicit <refspec> parameters.  <refspec>s listed explicitly on the command line are always merged into the current branch after fetching.  In other words, if you list more than one remote ref, 'git pull' will create an Octopus merge.  On the other hand, if you do not list any explicit <refspec> parameter on the command line, 'git pull' will fetch all the <refspec>s it finds in the `remote.<repository>.fetch` configuration and merge only the first <refspec> found into the current branch.  This is because making an Octopus from remote refs is rarely done, while keeping track of multiple remote heads in one-go by fetching more than one is often useful."
msgstr "在 'git pull' 命令行上直接列出多个 <引用规范> 和在 <仓库> 的配置中拥有多个`remote.<仓库>.fetch` 条目以及在没有任何明确的 <引用规范> 参数的情况下运行 'git pull' 命令是有区别的。 在命令行上明确列出的 <引用规范> 在获取后总是被合并到当前分支。  换句话说，如果你列出一个以上的远程引用，'git pull' 将创建一个多路合并。  另一方面，如果你没有在命令行中列出任何明确的 <引用规范> 参数，'git pull' 将获取它在 `remote.<仓库>.fetch` 配置中发现的所有 <引用规范>，并且只将发现的第一个<引用规范> 合并到当前分支。  这是因为很少有人从远程引用中多路合并，而通过获取多个远程头来一次性跟踪多个远程头往往是有用的。"

#. type: Plain text
#: en/ref-reachability-filters.txt:4
#, priority:260
msgid "When combining multiple `--contains` and `--no-contains` filters, only references that contain at least one of the `--contains` commits and contain none of the `--no-contains` commits are shown."
msgstr "当组合多个\"---包含 \"和\"---不包含 \"过滤器时，只显示至少包含一个\"---包含 \"的提交，并且不包含\"---不包含 \"的提交的参考。"

#. type: Plain text
#: en/ref-reachability-filters.txt:7
#, priority:260
msgid "When combining multiple `--merged` and `--no-merged` filters, only references that are reachable from at least one of the `--merged` commits and from none of the `--no-merged` commits are shown."
msgstr "当结合多个 \"合并 \"和 \"未合并 \"过滤器时，只显示至少有一个 \"合并 \"提交和没有 \"未合并 \"提交的引用。"

#. type: Labeled list
#: en/rerere-options.txt:1
#, ignore-same, no-wrap, priority:240
msgid "--rerere-autoupdate"
msgstr "--rerere-autoupdate"

#. type: Labeled list
#: en/rerere-options.txt:2
#, ignore-same, no-wrap, priority:240
msgid "--no-rerere-autoupdate"
msgstr "--no-rerere-autoupdate"

#. type: Plain text
#: en/rerere-options.txt:9
#, priority:240
msgid "After the rerere mechanism reuses a recorded resolution on the current conflict to update the files in the working tree, allow it to also update the index with the result of resolution.  `--no-rerere-autoupdate` is a good way to double-check what `rerere` did and catch potential mismerges, before committing the result to the index with a separate `git add`."
msgstr "在 rerere 机制重用当前冲突的记录解析来更新工作树中的文件后，允许它也用解析的结果来更新索引。  `--no-rerere-auto-oupdate`是一个很好的方法，在用单独的 `git add` 提交结果到索引之前，可以反复检查 `rerere` 所做的事情，并抓住潜在的错误合并。"

#. type: Title -
#: en/revisions.txt:2
#, no-wrap, priority:100
msgid "SPECIFYING REVISIONS"
msgstr ""

#. type: Plain text
#: en/revisions.txt:9
#, priority:100
msgid "A revision parameter '<rev>' typically, but not necessarily, names a commit object.  It uses what is called an 'extended SHA-1' syntax.  Here are various ways to spell object names.  The ones listed near the end of this list name trees and blobs contained in a commit."
msgstr ""

#. type: Plain text
#: en/revisions.txt:13
#, priority:100
msgid "This document shows the \"raw\" syntax as seen by git. The shell and other UIs might require additional quoting to protect special characters and to avoid word splitting."
msgstr ""

#. type: Labeled list
#: en/revisions.txt:14
#, no-wrap, priority:100
msgid "'<sha1>', e.g. 'dae86e1950b1277e545cee180551750029cfe735', 'dae86e'"
msgstr ""

#. type: Plain text
#: en/revisions.txt:20
#, priority:100
msgid "The full SHA-1 object name (40-byte hexadecimal string), or a leading substring that is unique within the repository.  E.g. dae86e1950b1277e545cee180551750029cfe735 and dae86e both name the same commit object if there is no other object in your repository whose object name starts with dae86e."
msgstr ""

#. type: Labeled list
#: en/revisions.txt:21
#, no-wrap, priority:100
msgid "'<describeOutput>', e.g. 'v1.7.4.2-679-g3bee7fb'"
msgstr ""

#. type: Plain text
#: en/revisions.txt:25
#, priority:100
msgid "Output from `git describe`; i.e. a closest tag, optionally followed by a dash and a number of commits, followed by a dash, a 'g', and an abbreviated object name."
msgstr ""

#. type: Labeled list
#: en/revisions.txt:26
#, no-wrap, priority:100
msgid "'<refname>', e.g. 'master', 'heads/master', 'refs/heads/master'"
msgstr ""

#. type: Plain text
#: en/revisions.txt:33
#, priority:100
msgid "A symbolic ref name.  E.g. 'master' typically means the commit object referenced by 'refs/heads/master'.  If you happen to have both 'heads/master' and 'tags/master', you can explicitly say 'heads/master' to tell Git which one you mean.  When ambiguous, a '<refname>' is disambiguated by taking the first match in the following rules:"
msgstr ""

#. type: Plain text
#: en/revisions.txt:38
#, priority:100
msgid "If '$GIT_DIR/<refname>' exists, that is what you mean (this is usually useful only for `HEAD`, `FETCH_HEAD`, `ORIG_HEAD`, `MERGE_HEAD`, `REBASE_HEAD`, `REVERT_HEAD`, `CHERRY_PICK_HEAD`, `BISECT_HEAD` and `AUTO_MERGE`);"
msgstr ""

#. type: Plain text
#: en/revisions.txt:40
#, priority:100
msgid "otherwise, 'refs/<refname>' if it exists;"
msgstr ""

#. type: Plain text
#: en/revisions.txt:42
#, priority:100
msgid "otherwise, 'refs/tags/<refname>' if it exists;"
msgstr ""

#. type: Plain text
#: en/revisions.txt:44
#, priority:100
msgid "otherwise, 'refs/heads/<refname>' if it exists;"
msgstr ""

#. type: Plain text
#: en/revisions.txt:46
#, priority:100
msgid "otherwise, 'refs/remotes/<refname>' if it exists;"
msgstr ""

#. type: Plain text
#: en/revisions.txt:48
#, priority:100
msgid "otherwise, 'refs/remotes/<refname>/HEAD' if it exists."
msgstr ""

#. type: Labeled list
#: en/revisions.txt:50
#, ignore-same, no-wrap, priority:100
msgid "`HEAD`"
msgstr "`HEAD`"

#. type: Plain text
#: en/revisions.txt:52
#, fuzzy, no-wrap, priority:100
#| msgid "In general, the interrogate commands do not touch the files in the working tree."
msgid "names the commit on which you based the changes in the working tree.\n"
msgstr "一般来说，审阅命令不接触工作区中的文件。"

#. type: Labeled list
#: en/revisions.txt:52
#, ignore-same, no-wrap, priority:100
msgid "`FETCH_HEAD`"
msgstr "`FETCH_HEAD`"

#. type: Plain text
#: en/revisions.txt:55
#, no-wrap, priority:100
msgid ""
"records the branch which you fetched from a remote repository with\n"
"your last `git fetch` invocation.\n"
msgstr ""

#. type: Labeled list
#: en/revisions.txt:55
#, ignore-same, no-wrap, priority:100
msgid "`ORIG_HEAD`"
msgstr "`ORIG_HEAD`"

#. type: Plain text
#: en/revisions.txt:60
#, no-wrap, priority:100
msgid ""
"is created by commands that move your `HEAD` in a drastic way (`git\n"
"am`, `git merge`, `git rebase`, `git reset`), to record the position\n"
"of the `HEAD` before their operation, so that you can easily change\n"
"the tip of the branch back to the state before you ran them.\n"
msgstr ""

#. type: Labeled list
#: en/revisions.txt:60
#, ignore-same, no-wrap, priority:100
msgid "`MERGE_HEAD`"
msgstr "`MERGE_HEAD`"

#. type: Plain text
#: en/revisions.txt:63
#, no-wrap, priority:100
msgid ""
"records the commit(s) which you are merging into your branch when you\n"
"run `git merge`.\n"
msgstr ""

#. type: Labeled list
#: en/revisions.txt:63
#, ignore-same, no-wrap, priority:100
msgid "`REBASE_HEAD`"
msgstr "`REBASE_HEAD`"

#. type: Plain text
#: en/revisions.txt:67
#, no-wrap, priority:100
msgid ""
"during a rebase, records the commit at which the operation is\n"
"currently stopped, either because of conflicts or an `edit` command in\n"
"an interactive rebase.\n"
msgstr ""

#. type: Labeled list
#: en/revisions.txt:67
#, ignore-same, no-wrap, priority:100
msgid "`REVERT_HEAD`"
msgstr "`REVERT_HEAD`"

#. type: Plain text
#: en/revisions.txt:69
#, no-wrap, priority:100
msgid "records the commit which you are reverting when you run `git revert`.\n"
msgstr ""

#. type: Labeled list
#: en/revisions.txt:69
#, ignore-same, no-wrap, priority:100
msgid "`CHERRY_PICK_HEAD`"
msgstr "`CHERRY_PICK_HEAD`"

#. type: Plain text
#: en/revisions.txt:72
#, no-wrap, priority:100
msgid ""
"records the commit which you are cherry-picking when you run `git\n"
"cherry-pick`.\n"
msgstr ""

#. type: Labeled list
#: en/revisions.txt:72
#, ignore-same, no-wrap, priority:100
msgid "`BISECT_HEAD`"
msgstr "`BISECT_HEAD`"

#. type: Plain text
#: en/revisions.txt:75
#, no-wrap, priority:100
msgid ""
"records the current commit to be tested when you run `git bisect\n"
"--no-checkout`.\n"
msgstr ""

#. type: Labeled list
#: en/revisions.txt:75
#, ignore-same, no-wrap, priority:100
msgid "`AUTO_MERGE`"
msgstr "`AUTO_MERGE`"

#. type: Plain text
#: en/revisions.txt:79
#, no-wrap, priority:100
msgid ""
"records a tree object corresponding to the state the\n"
"'ort' merge strategy wrote to the working tree when a merge operation\n"
"resulted in conflicts.\n"
msgstr ""

#. type: Plain text
#: en/revisions.txt:85
#, priority:100
msgid "Note that any of the 'refs/*' cases above may come either from the `$GIT_DIR/refs` directory or from the `$GIT_DIR/packed-refs` file.  While the ref name encoding is unspecified, UTF-8 is preferred as some output processing may assume ref names in UTF-8."
msgstr ""

#. type: Labeled list
#: en/revisions.txt:86
#, fuzzy, no-wrap, priority:100
msgid "'@'"
msgstr "'@'"

#. type: Plain text
#: en/revisions.txt:88
#, priority:100
msgid "'@' alone is a shortcut for `HEAD`."
msgstr ""

#. type: Labeled list
#: en/revisions.txt:89
#, no-wrap, priority:100
msgid "'[<refname>]@{<date>}', e.g. 'master@\\{yesterday\\}', 'HEAD@{5 minutes ago}'"
msgstr ""

#. type: Plain text
#: en/revisions.txt:100
#, priority:100
msgid "A ref followed by the suffix '@' with a date specification enclosed in a brace pair (e.g. '\\{yesterday\\}', '{1 month 2 weeks 3 days 1 hour 1 second ago}' or '{1979-02-26 18:30:00}') specifies the value of the ref at a prior point in time.  This suffix may only be used immediately following a ref name and the ref must have an existing log ('$GIT_DIR/logs/<ref>'). Note that this looks up the state of your *local* ref at a given time; e.g., what was in your local 'master' branch last week. If you want to look at commits made during certain times, see `--since` and `--until`."
msgstr ""

#. type: Labeled list
#: en/revisions.txt:101
#, no-wrap, priority:100
msgid "'<refname>@{<n>}', e.g. 'master@\\{1\\}'"
msgstr ""

#. type: Plain text
#: en/revisions.txt:109
#, priority:100
msgid "A ref followed by the suffix '@' with an ordinal specification enclosed in a brace pair (e.g. '\\{1\\}', '\\{15\\}') specifies the n-th prior value of that ref.  For example 'master@\\{1\\}' is the immediate prior value of 'master' while 'master@\\{5\\}' is the 5th prior value of 'master'. This suffix may only be used immediately following a ref name and the ref must have an existing log ('$GIT_DIR/logs/<refname>')."
msgstr ""

#. type: Labeled list
#: en/revisions.txt:110
#, no-wrap, priority:100
msgid "'@{<n>}', e.g. '@\\{1\\}'"
msgstr ""

#. type: Plain text
#: en/revisions.txt:114
#, priority:100
msgid "You can use the '@' construct with an empty ref part to get at a reflog entry of the current branch. For example, if you are on branch 'blabla' then '@\\{1\\}' means the same as 'blabla@\\{1\\}'."
msgstr ""

#. type: Labeled list
#: en/revisions.txt:115
#, no-wrap, priority:100
msgid "'@{-<n>}', e.g. '@{-1}'"
msgstr ""

#. type: Plain text
#: en/revisions.txt:118
#, priority:100
msgid "The construct '@{-<n>}' means the <n>th branch/commit checked out before the current one."
msgstr ""

#. type: Labeled list
#: en/revisions.txt:119
#, no-wrap, priority:100
msgid "'[<branchname>]@\\{upstream\\}', e.g. 'master@\\{upstream\\}', '@\\{u\\}'"
msgstr ""

#. type: Plain text
#: en/revisions.txt:124
#, priority:100
msgid "A branch B may be set up to build on top of a branch X (configured with `branch.<name>.merge`) at a remote R (configured with `branch.<name>.remote`). B@{u} refers to the remote-tracking branch for the branch X taken from remote R, typically found at `refs/remotes/R/X`."
msgstr ""

#. type: Labeled list
#: en/revisions.txt:125
#, no-wrap, priority:100
msgid "'[<branchname>]@\\{push\\}', e.g. 'master@\\{push\\}', '@\\{push\\}'"
msgstr ""

#. type: Plain text
#: en/revisions.txt:130
#, priority:100
msgid "The suffix '@\\{push}' reports the branch \"where we would push to\" if `git push` were run while `branchname` was checked out (or the current `HEAD` if no branchname is specified). Like for '@\\{upstream\\}', we report the remote-tracking branch that corresponds to that branch at the remote."
msgstr ""

#. type: Plain text
#: en/revisions.txt:132
#, priority:100
msgid "Here's an example to make it more clear:"
msgstr ""

#. type: delimited block -
#: en/revisions.txt:137
#, fuzzy, no-wrap, priority:100
msgid ""
"$ git config push.default current\n"
"$ git config remote.pushdefault myfork\n"
"$ git switch -c mybranch origin/master\n"
msgstr ""
"$ git config push.default current\n"
"$ git config remote.pushdefault myfork\n"
"$ git switch -c mybranch origin/master\n"

#. type: delimited block -
#: en/revisions.txt:140
#, fuzzy, no-wrap, priority:100
msgid ""
"$ git rev-parse --symbolic-full-name @{upstream}\n"
"refs/remotes/origin/master\n"
msgstr ""
"$ git rev-parse --symbolic-full-name @{upstream}\n"
"refs/remotes/origin/master\n"

#. type: delimited block -
#: en/revisions.txt:143
#, fuzzy, no-wrap, priority:100
msgid ""
"$ git rev-parse --symbolic-full-name @{push}\n"
"refs/remotes/myfork/mybranch\n"
msgstr ""
"$ git rev-parse --symbolic-full-name @{push}\n"
"refs/remotes/myfork/mybranch\n"

#. type: Plain text
#: en/revisions.txt:148
#, priority:100
msgid "Note in the example that we set up a triangular workflow, where we pull from one location and push to another. In a non-triangular workflow, '@\\{push}' is the same as '@\\{upstream}', and there is no need for it."
msgstr ""

#. type: Plain text
#: en/revisions.txt:151
#, priority:100
msgid "This suffix is also accepted when spelled in uppercase, and means the same thing no matter the case."
msgstr ""

#. type: Labeled list
#: en/revisions.txt:152
#, no-wrap, priority:100
msgid "'<rev>{caret}[<n>]', e.g. 'HEAD{caret}, v1.5.1{caret}0'"
msgstr ""

#. type: Plain text
#: en/revisions.txt:159
#, priority:100
msgid "A suffix '{caret}' to a revision parameter means the first parent of that commit object.  '{caret}<n>' means the <n>th parent (i.e.  '<rev>{caret}' is equivalent to '<rev>{caret}1').  As a special rule, '<rev>{caret}0' means the commit itself and is used when '<rev>' is the object name of a tag object that refers to a commit object."
msgstr ""

#. type: Labeled list
#: en/revisions.txt:160
#, fuzzy, no-wrap, priority:100
msgid "'<rev>{tilde}[<n>]', e.g. 'HEAD{tilde}, master{tilde}3'"
msgstr "'<rev>{tilde}[<n>]', e.g. 'HEAD{tilde}, master{tilde}3'"

#. type: Plain text
#: en/revisions.txt:169
#, priority:100
msgid "A suffix '{tilde}' to a revision parameter means the first parent of that commit object.  A suffix '{tilde}<n>' to a revision parameter means the commit object that is the <n>th generation ancestor of the named commit object, following only the first parents.  I.e. '<rev>{tilde}3' is equivalent to '<rev>{caret}{caret}{caret}' which is equivalent to '<rev>{caret}1{caret}1{caret}1'.  See below for an illustration of the usage of this form."
msgstr ""

#. type: Labeled list
#: en/revisions.txt:170
#, no-wrap, priority:100
msgid "'<rev>{caret}{<type>}', e.g. 'v0.99.8{caret}\\{commit\\}'"
msgstr ""

#. type: Plain text
#: en/revisions.txt:181
#, priority:100
msgid "A suffix '{caret}' followed by an object type name enclosed in brace pair means dereference the object at '<rev>' recursively until an object of type '<type>' is found or the object cannot be dereferenced anymore (in which case, barf).  For example, if '<rev>' is a commit-ish, '<rev>{caret}\\{commit\\}' describes the corresponding commit object.  Similarly, if '<rev>' is a tree-ish, '<rev>{caret}\\{tree\\}' describes the corresponding tree object.  '<rev>{caret}0' is a short-hand for '<rev>{caret}\\{commit\\}'."
msgstr ""

#. type: Plain text
#: en/revisions.txt:186
#, priority:100
msgid "'<rev>{caret}\\{object\\}' can be used to make sure '<rev>' names an object that exists, without requiring '<rev>' to be a tag, and without dereferencing '<rev>'; because a tag is already an object, it does not have to be dereferenced even once to get to an object."
msgstr ""

#. type: Plain text
#: en/revisions.txt:189
#, priority:100
msgid "'<rev>{caret}\\{tag\\}' can be used to ensure that '<rev>' identifies an existing tag object."
msgstr ""

#. type: Labeled list
#: en/revisions.txt:190
#, fuzzy, no-wrap, priority:100
msgid "'<rev>{caret}{}', e.g. 'v0.99.8{caret}{}'"
msgstr "'<rev>{caret}{}', e.g. 'v0.99.8{caret}{}'"

#. type: Plain text
#: en/revisions.txt:195
#, priority:100
msgid "A suffix '{caret}' followed by an empty brace pair means the object could be a tag, and dereference the tag recursively until a non-tag object is found."
msgstr ""

#. type: Labeled list
#: en/revisions.txt:196
#, no-wrap, priority:100
msgid "'<rev>{caret}{/<text>}', e.g. 'HEAD^{/fix nasty bug}'"
msgstr ""

#. type: Plain text
#: en/revisions.txt:202
#, priority:100
msgid "A suffix '{caret}' to a revision parameter, followed by a brace pair that contains a text led by a slash, is the same as the ':/fix nasty bug' syntax below except that it returns the youngest matching commit which is reachable from the '<rev>' before '{caret}'."
msgstr ""

#. type: Labeled list
#: en/revisions.txt:203
#, no-wrap, priority:100
msgid "':/<text>', e.g. ':/fix nasty bug'"
msgstr ""

#. type: Plain text
#: en/revisions.txt:216
#, priority:100
msgid "A colon, followed by a slash, followed by a text, names a commit whose commit message matches the specified regular expression.  This name returns the youngest matching commit which is reachable from any ref, including HEAD.  The regular expression can match any part of the commit message. To match messages starting with a string, one can use e.g. ':/^foo'. The special sequence ':/!' is reserved for modifiers to what is matched. ':/!-foo' performs a negative match, while ':/!!foo' matches a literal '!' character, followed by 'foo'. Any other sequence beginning with ':/!' is reserved for now.  Depending on the given text, the shell's word splitting rules might require additional quoting."
msgstr ""

#. type: Labeled list
#: en/revisions.txt:217
#, no-wrap, priority:100
msgid "'<rev>:<path>', e.g. 'HEAD:README', 'master:./README'"
msgstr ""

#. type: Plain text
#: en/revisions.txt:225
#, priority:100
msgid "A suffix ':' followed by a path names the blob or tree at the given path in the tree-ish object named by the part before the colon.  A path starting with './' or '../' is relative to the current working directory.  The given path will be converted to be relative to the working tree's root directory.  This is most useful to address a blob or tree from a commit or tree that has the same tree structure as the working tree."
msgstr ""

#. type: Labeled list
#: en/revisions.txt:226
#, fuzzy, no-wrap, priority:100
msgid "':[<n>:]<path>', e.g. ':0:README', ':README'"
msgstr "':[<n>:]<path>', e.g. ':0:README', ':README'"

#. type: Plain text
#: en/revisions.txt:234
#, priority:100
msgid "A colon, optionally followed by a stage number (0 to 3) and a colon, followed by a path, names a blob object in the index at the given path. A missing stage number (and the colon that follows it) names a stage 0 entry. During a merge, stage 1 is the common ancestor, stage 2 is the target branch's version (typically the current branch), and stage 3 is the version from the branch which is being merged."
msgstr ""

#. type: Plain text
#: en/revisions.txt:238
#, priority:100
msgid "Here is an illustration, by Jon Loeliger.  Both commit nodes B and C are parents of commit node A.  Parent commits are ordered left-to-right."
msgstr ""

#. type: delimited block .
#: en/revisions.txt:250
#, no-wrap, priority:100
msgid ""
"G   H   I   J\n"
" \\ /     \\ /\n"
"  D   E   F\n"
"   \\  |  / \\\n"
"    \\ | /   |\n"
"     \\|/    |\n"
"      B     C\n"
"       \\   /\n"
"        \\ /\n"
"         A\n"
msgstr ""

#. type: Plain text
#: en/revisions.txt:262
#, no-wrap, priority:100
msgid ""
"    A =      = A^0\n"
"    B = A^   = A^1     = A~1\n"
"    C =      = A^2\n"
"    D = A^^  = A^1^1   = A~2\n"
"    E = B^2  = A^^2\n"
"    F = B^3  = A^^3\n"
"    G = A^^^ = A^1^1^1 = A~3\n"
"    H = D^2  = B^^2    = A^^^2  = A~2^2\n"
"    I = F^   = B^3^    = A^^3^\n"
"    J = F^2  = B^3^2   = A^^3^2\n"
msgstr ""

#. type: Plain text
#: en/revisions.txt:269
#, priority:100
msgid "History traversing commands such as `git log` operate on a set of commits, not just a single commit."
msgstr ""

#. type: Plain text
#: en/revisions.txt:274
#, priority:100
msgid "For these commands, specifying a single revision, using the notation described in the previous section, means the set of commits `reachable` from the given commit."
msgstr ""

#. type: Plain text
#: en/revisions.txt:277
#, priority:100
msgid "Specifying several revisions means the set of commits reachable from any of the given commits."
msgstr ""

#. type: Plain text
#: en/revisions.txt:280
#, priority:100
msgid "A commit's reachable set is the commit itself and the commits in its ancestry chain."
msgstr ""

#. type: Plain text
#: en/revisions.txt:283
#, priority:100
msgid "There are several notations to specify a set of connected commits (called a \"revision range\"), illustrated below."
msgstr ""

#. type: Title ~
#: en/revisions.txt:286
#, no-wrap, priority:100
msgid "Commit Exclusions"
msgstr ""

#. type: Labeled list
#: en/revisions.txt:288
#, no-wrap, priority:100
msgid "'{caret}<rev>' (caret) Notation"
msgstr ""

#. type: Plain text
#: en/revisions.txt:293
#, priority:100
msgid "To exclude commits reachable from a commit, a prefix '{caret}' notation is used.  E.g. '{caret}r1 r2' means commits reachable from 'r2' but exclude the ones reachable from 'r1' (i.e. 'r1' and its ancestors)."
msgstr ""

#. type: Title ~
#: en/revisions.txt:295
#, no-wrap, priority:100
msgid "Dotted Range Notations"
msgstr ""

#. type: Labeled list
#: en/revisions.txt:297
#, no-wrap, priority:100
msgid "The '..' (two-dot) Range Notation"
msgstr ""

#. type: Plain text
#: en/revisions.txt:303
#, priority:100
msgid "The '{caret}r1 r2' set operation appears so often that there is a shorthand for it.  When you have two commits 'r1' and 'r2' (named according to the syntax explained in SPECIFYING REVISIONS above), you can ask for commits that are reachable from r2 excluding those that are reachable from r1 by '{caret}r1 r2' and it can be written as 'r1..r2'."
msgstr ""

#. type: Labeled list
#: en/revisions.txt:304
#, ignore-ellipsis, no-wrap, priority:100
msgid "The '\\...' (three-dot) Symmetric Difference Notation"
msgstr ""

#. type: Plain text
#: en/revisions.txt:310
#, ignore-ellipsis, priority:100
msgid "A similar notation 'r1\\...r2' is called symmetric difference of 'r1' and 'r2' and is defined as 'r1 r2 --not $(git merge-base --all r1 r2)'.  It is the set of commits that are reachable from either one of 'r1' (left side) or 'r2' (right side) but not from both."
msgstr ""

#. type: Plain text
#: en/revisions.txt:317
#, priority:100
msgid "In these two shorthand notations, you can omit one end and let it default to HEAD.  For example, 'origin..' is a shorthand for 'origin..HEAD' and asks \"What did I do since I forked from the origin branch?\" Similarly, '..origin' is a shorthand for 'HEAD..origin' and asks \"What did the origin do since I forked from them?\" Note that '..' would mean 'HEAD..HEAD' which is an empty range that is both reachable and unreachable from HEAD."
msgstr ""

#. type: Plain text
#: en/revisions.txt:324
#, priority:100
msgid "Commands that are specifically designed to take two distinct ranges (e.g. \"git range-diff R1 R2\" to compare two ranges) do exist, but they are exceptions.  Unless otherwise noted, all \"git\" commands that operate on a set of commits work on a single revision range.  In other words, writing two \"two-dot range notation\" next to each other, e.g."
msgstr ""

#. type: Plain text
#: en/revisions.txt:326
#, no-wrap, priority:100
msgid "    $ git log A..B C..D\n"
msgstr ""

#. type: Plain text
#: en/revisions.txt:331
#, priority:100
msgid "does *not* specify two revision ranges for most commands.  Instead it will name a single connected set of commits, i.e. those that are reachable from either B or D but are reachable from neither A or C.  In a linear history like this:"
msgstr ""

#. type: Plain text
#: en/revisions.txt:333
#, fuzzy, no-wrap, priority:100
msgid "    ---A---B---o---o---C---D\n"
msgstr "    ---A---B---o---o---C---D\n"

#. type: Plain text
#: en/revisions.txt:336
#, priority:100
msgid "because A and B are reachable from C, the revision range specified by these two dotted ranges is a single commit D."
msgstr ""

#. type: Title ~
#: en/revisions.txt:339
#, no-wrap, priority:100
msgid "Other <rev>{caret} Parent Shorthand Notations"
msgstr ""

#. type: Plain text
#: en/revisions.txt:342
#, priority:100
msgid "Three other shorthands exist, particularly useful for merge commits, for naming a set that is formed by a commit and its parent commits."
msgstr ""

#. type: Plain text
#: en/revisions.txt:344
#, priority:100
msgid "The 'r1{caret}@' notation means all parents of 'r1'."
msgstr ""

#. type: Plain text
#: en/revisions.txt:347
#, priority:100
msgid "The 'r1{caret}!' notation includes commit 'r1' but excludes all of its parents.  By itself, this notation denotes the single commit 'r1'."
msgstr ""

#. type: Plain text
#: en/revisions.txt:354
#, priority:100
msgid "The '<rev>{caret}-[<n>]' notation includes '<rev>' but excludes the <n>th parent (i.e. a shorthand for '<rev>{caret}<n>..<rev>'), with '<n>' = 1 if not given. This is typically useful for merge commits where you can just pass '<commit>{caret}-' to get all the commits in the branch that was merged in merge commit '<commit>' (including '<commit>' itself)."
msgstr ""

#. type: Plain text
#: en/revisions.txt:358
#, priority:100
msgid "While '<rev>{caret}<n>' was about specifying a single commit parent, these three notations also consider its parents. For example you can say 'HEAD{caret}2{caret}@', however you cannot say 'HEAD{caret}@{caret}2'."
msgstr ""

#. type: Title -
#: en/revisions.txt:360
#, no-wrap, priority:100
msgid "Revision Range Summary"
msgstr ""

#. type: Labeled list
#: en/revisions.txt:362
#, fuzzy, no-wrap, priority:100
msgid "'<rev>'"
msgstr "'<rev>'"

#. type: Plain text
#: en/revisions.txt:365
#, priority:100
msgid "Include commits that are reachable from <rev> (i.e. <rev> and its ancestors)."
msgstr ""

#. type: Labeled list
#: en/revisions.txt:366
#, no-wrap, priority:100
msgid "'{caret}<rev>'"
msgstr ""

#. type: Plain text
#: en/revisions.txt:369
#, priority:100
msgid "Exclude commits that are reachable from <rev> (i.e. <rev> and its ancestors)."
msgstr ""

#. type: Labeled list
#: en/revisions.txt:370
#, fuzzy, no-wrap, priority:100
msgid "'<rev1>..<rev2>'"
msgstr "'<rev1>..<rev2>'"

#. type: Plain text
#: en/revisions.txt:374
#, priority:100
msgid "Include commits that are reachable from <rev2> but exclude those that are reachable from <rev1>.  When either <rev1> or <rev2> is omitted, it defaults to `HEAD`."
msgstr ""

#. type: Labeled list
#: en/revisions.txt:375
#, ignore-ellipsis, no-wrap, priority:100
msgid "'<rev1>\\...<rev2>'"
msgstr ""

#. type: Plain text
#: en/revisions.txt:379
#, priority:100
msgid "Include commits that are reachable from either <rev1> or <rev2> but exclude those that are reachable from both.  When either <rev1> or <rev2> is omitted, it defaults to `HEAD`."
msgstr ""

#. type: Labeled list
#: en/revisions.txt:380
#, fuzzy, no-wrap, priority:100
msgid "'<rev>{caret}@', e.g. 'HEAD{caret}@'"
msgstr "'<rev>{caret}@', e.g. 'HEAD{caret}@'"

#. type: Plain text
#: en/revisions.txt:384
#, priority:100
msgid "A suffix '{caret}' followed by an at sign is the same as listing all parents of '<rev>' (meaning, include anything reachable from its parents, but not the commit itself)."
msgstr ""

#. type: Labeled list
#: en/revisions.txt:385
#, no-wrap, priority:100
msgid "'<rev>{caret}!', e.g. 'HEAD{caret}!'"
msgstr ""

#. type: Plain text
#: en/revisions.txt:389
#, priority:100
msgid "A suffix '{caret}' followed by an exclamation mark is the same as giving commit '<rev>' and all its parents prefixed with '{caret}' to exclude them (and their ancestors)."
msgstr ""

#. type: Labeled list
#: en/revisions.txt:390
#, no-wrap, priority:100
msgid "'<rev>{caret}-<n>', e.g. 'HEAD{caret}-, HEAD{caret}-2'"
msgstr ""

#. type: Plain text
#: en/revisions.txt:393
#, priority:100
msgid "Equivalent to '<rev>{caret}<n>..<rev>', with '<n>' = 1 if not given."
msgstr ""

#. type: Plain text
#: en/revisions.txt:397
#, priority:100
msgid "Here are a handful of examples using the Loeliger illustration above, with each step in the notation's expansion and selection carefully spelt out:"
msgstr ""

#. type: delimited block .
#: en/revisions.txt:421
#, ignore-ellipsis, no-wrap, priority:100
msgid ""
"   Args   Expanded arguments    Selected commits\n"
"   D                            G H D\n"
"   D F                          G H I J D F\n"
"   ^G D                         H D\n"
"   ^D B                         E I J F B\n"
"   ^D B C                       E I J F B C\n"
"   C                            I J F C\n"
"   B..C   = ^B C                C\n"
"   B...C  = B ^F C              G H D E B C\n"
"   B^-    = B^..B\n"
"\t  = ^B^1 B              E I J F B\n"
"   C^@    = C^1\n"
"\t  = F                   I J F\n"
"   B^@    = B^1 B^2 B^3\n"
"\t  = D E F               D G H E F I J\n"
"   C^!    = C ^C^@\n"
"\t  = C ^C^1\n"
"\t  = C ^F                C\n"
"   B^!    = B ^B^@\n"
"\t  = B ^B^1 ^B^2 ^B^3\n"
"\t  = B ^D ^E ^F          B\n"
"   F^! D  = F ^I ^J D           G H D F\n"
msgstr ""

#. type: Plain text
#: en/rev-list-description.txt:5
#, priority:260
msgid "List commits that are reachable by following the `parent` links from the given commit(s), but exclude commits that are reachable from the one(s)  given with a '{caret}' in front of them.  The output is given in reverse chronological order by default."
msgstr "列出可以从给定的提交中通过 \"父 \"链接到达的提交，但不包括可以从前面有\"{caret}\"的提交中到达的提交。  默认情况下，输出结果是按时间顺序倒置的。"

#. type: Plain text
#: en/rev-list-description.txt:12
#, priority:260
msgid "You can think of this as a set operation. Commits reachable from any of the commits given on the command line form a set, and then commits reachable from any of the ones given with '{caret}' in front are subtracted from that set.  The remaining commits are what comes out in the command's output.  Various other options and paths parameters can be used to further limit the result."
msgstr "你可以把它看成是一个集合操作。从命令行上给出的任何一个提交中可以到达的提交形成一个集合，然后从这个集合中减去任何一个前面带有'{caret}'的提交。  剩下的提交内容就是命令的输出结果。  其他各种选项和路径参数也可以用来进一步限制结果。"

#. type: Plain text
#: en/rev-list-description.txt:14
#, fuzzy, priority:260
msgid "Thus, the following command:"
msgstr "支持以下日期格式："

#. type: delimited block -
#: en/rev-list-description.txt:18
#, fuzzy, no-wrap, priority:260
msgid "$ git rev-list foo bar ^baz\n"
msgstr "\t$ git rev-list --bisect foo ^bar ^baz\n"

#. type: delimited block -
#: en/rev-list-description.txt:23
#, fuzzy, no-wrap, priority:260
msgid "$ git log foo bar ^baz\n"
msgstr "\t$ git rev-list --bisect foo ^bar ^baz\n"

#. type: Plain text
#: en/rev-list-description.txt:28
#, priority:260
msgid "means \"list all the commits which are reachable from 'foo' or 'bar', but not from 'baz'\"."
msgstr "意思是 \"列出所有可以从'foo'或'bar'，但不能从'baz'到达的提交\"。"

#. type: Plain text
#: en/rev-list-description.txt:32
#, priority:260
msgid "A special notation \"'<commit1>'..'<commit2>'\" can be used as a short-hand for \"^'<commit1>' '<commit2>'\". For example, either of the following may be used interchangeably:"
msgstr "一个特殊的符号\"'<commit1>'...'<commit2>'\"可以作为\"^'<commit1>' '<commit2>'\"的简称。例如，以下两种情况可以互换使用。"

#. type: delimited block -
#: en/rev-list-description.txt:37
#, fuzzy, no-wrap, priority:260
msgid ""
"$ git rev-list origin..HEAD\n"
"$ git rev-list HEAD ^origin\n"
msgstr ""
"$ git fetch origin\n"
"$ git merge origin/next\n"

#. type: delimited block -
#: en/rev-list-description.txt:43
#, fuzzy, no-wrap, priority:260
msgid ""
"$ git log origin..HEAD\n"
"$ git log HEAD ^origin\n"
msgstr ""
"$ git fetch origin\n"
"$ git merge origin/next\n"

#. type: Plain text
#: en/rev-list-description.txt:49
#, ignore-ellipsis, priority:260
msgid "Another special notation is \"'<commit1>'...'<commit2>'\" which is useful for merges.  The resulting set of commits is the symmetric difference between the two operands.  The following two commands are equivalent:"
msgstr "另一个特殊的符号是\"'<commit1>'...'<commit2>'\"，对合并很有用。  由此产生的提交集合是两个操作数之间的对称差。  以下两个命令是等价的。"

#. type: delimited block -
#: en/rev-list-description.txt:54
#, ignore-ellipsis, no-wrap, priority:260
msgid ""
"$ git rev-list A B --not $(git merge-base --all A B)\n"
"$ git rev-list A...B\n"
msgstr ""
"$ git rev-list A B --not $(git merge-base --all A B)\n"
"$ git rev-list A...B\n"

#. type: delimited block -
#: en/rev-list-description.txt:60
#, ignore-ellipsis, no-wrap, priority:260
msgid ""
"$ git log A B --not $(git merge-base --all A B)\n"
"$ git log A...B\n"
msgstr ""
"$ git log A B --not $(git merge-base --all A B)\n"
"$ git log A...B\n"

#. type: Title ~
#: en/rev-list-options.txt:2
#, no-wrap, priority:260
msgid "Commit Limiting"
msgstr "承诺限制"

#. type: Plain text
#: en/rev-list-options.txt:7
#, priority:260
msgid "Besides specifying a range of commits that should be listed using the special notations explained in the description, additional commit limiting may be applied."
msgstr "除了使用描述中解释的特殊符号指定应列出的提交范围，还可以应用额外的提交限制。"

#. type: Plain text
#: en/rev-list-options.txt:12
#, priority:260
msgid "Using more options generally further limits the output (e.g.  `--since=<date1>` limits to commits newer than `<date1>`, and using it with `--grep=<pattern>` further limits to commits whose log message has a line that matches `<pattern>`), unless otherwise noted."
msgstr "使用更多的选项通常会进一步限制输出（例如，`--since=<date1>`限制在比`<date1>`新的提交，与`--grep=<pattern>`一起使用会进一步限制在日志信息中有一行符合`<pattern>`的提交），除非另有说明。"

#. type: Plain text
#: en/rev-list-options.txt:15
#, priority:260
msgid "Note that these are applied before commit ordering and formatting options, such as `--reverse`."
msgstr "请注意，这些都是在提交排序和格式化选项之前应用的，如`--反转`。"

#. type: Labeled list
#: en/rev-list-options.txt:17
#, fuzzy, no-wrap, priority:260
msgid "-n <number>"
msgstr "-n <number>"

#. type: Labeled list
#: en/rev-list-options.txt:18
#, no-wrap, priority:260
msgid "--max-count=<number>"
msgstr "--max-count=<number>"

#. type: Plain text
#: en/rev-list-options.txt:20
#, priority:260
msgid "Limit the number of commits to output."
msgstr "限制输出的提交数量。"

#. type: Labeled list
#: en/rev-list-options.txt:21
#, fuzzy, no-wrap, priority:260
msgid "--skip=<number>"
msgstr "--skip=<number>"

#. type: Plain text
#: en/rev-list-options.txt:23
#, priority:260
msgid "Skip 'number' commits before starting to show the commit output."
msgstr "在开始显示提交输出之前，跳过'数'的提交。"

#. type: Labeled list
#: en/rev-list-options.txt:24
#, fuzzy, no-wrap, priority:260
msgid "--since=<date>"
msgstr "--since=<date>"

#. type: Labeled list
#: en/rev-list-options.txt:25
#, no-wrap, priority:260
msgid "--after=<date>"
msgstr "--after=<日期>"

#. type: Plain text
#: en/rev-list-options.txt:27
#, priority:260
msgid "Show commits more recent than a specific date."
msgstr "显示比某一特定日期更近的提交。"

#. type: Labeled list
#: en/rev-list-options.txt:28
#, fuzzy, no-wrap, priority:260
msgid "--since-as-filter=<date>"
msgstr "--since=<date>"

#. type: Plain text
#: en/rev-list-options.txt:32
#, priority:260
msgid "Show all commits more recent than a specific date. This visits all commits in the range, rather than stopping at the first commit which is older than a specific date."
msgstr "显示所有比指定日期更近的提交。这将访问该范围内的所有提交，而不是停在第一个比指定日期更早的提交。"

#. type: Labeled list
#: en/rev-list-options.txt:33
#, no-wrap, priority:260
msgid "--until=<date>"
msgstr "--until=<日期>"

#. type: Labeled list
#: en/rev-list-options.txt:34
#, fuzzy, no-wrap, priority:260
msgid "--before=<date>"
msgstr "--before=<date>"

#. type: Plain text
#: en/rev-list-options.txt:36
#, priority:260
msgid "Show commits older than a specific date."
msgstr "显示超过特定日期的提交。"

#. type: Labeled list
#: en/rev-list-options.txt:38
#, fuzzy, no-wrap, priority:260
msgid "--max-age=<timestamp>"
msgstr "--max-age=<timestamp>"

#. type: Labeled list
#: en/rev-list-options.txt:39
#, fuzzy, no-wrap, priority:260
msgid "--min-age=<timestamp>"
msgstr "--min-age=<timestamp>"

#. type: Plain text
#: en/rev-list-options.txt:41
#, priority:260
msgid "Limit the commits output to specified time range."
msgstr "将提交的结果限制在指定的时间范围内。"

#. type: Labeled list
#: en/rev-list-options.txt:43
#, fuzzy, no-wrap, priority:260
msgid "--author=<pattern>"
msgstr "--author=<pattern>"

#. type: Labeled list
#: en/rev-list-options.txt:44
#, fuzzy, no-wrap, priority:260
msgid "--committer=<pattern>"
msgstr "--committer=<pattern>"

#. type: Plain text
#: en/rev-list-options.txt:50
#, priority:260
msgid "Limit the commits output to ones with author/committer header lines that match the specified pattern (regular expression).  With more than one `--author=<pattern>`, commits whose author matches any of the given patterns are chosen (similarly for multiple `--committer=<pattern>`)."
msgstr "将提交文件的输出限制在作者/提交人标题行符合指定模式（正则表达式）的文件。  如果有多个`--author=<pattern>`，则会选择作者符合任何一个给定模式的提交（对于多个`--committer=<pattern>`也是如此）。"

#. type: Labeled list
#: en/rev-list-options.txt:51
#, fuzzy, no-wrap, priority:260
msgid "--grep-reflog=<pattern>"
msgstr "--grep-reflog=<pattern>"

#. type: Plain text
#: en/rev-list-options.txt:57
#, priority:260
msgid "Limit the commits output to ones with reflog entries that match the specified pattern (regular expression). With more than one `--grep-reflog`, commits whose reflog message matches any of the given patterns are chosen.  It is an error to use this option unless `--walk-reflogs` is in use."
msgstr "将提交文件的输出限制在有符合指定模式（正则表达式）的reflog条目的提交文件。如果有多个 `--grep-reflog`，则会选择那些 reflog 信息符合任何指定模式的提交。  除非使用了`--walk-reflogs`，否则使用此选项是错误的。"

#. type: Labeled list
#: en/rev-list-options.txt:58
#, fuzzy, no-wrap, priority:260
msgid "--grep=<pattern>"
msgstr "--grep=<pattern>"

#. type: Plain text
#: en/rev-list-options.txt:64
#, priority:260
msgid "Limit the commits output to ones with log message that matches the specified pattern (regular expression).  With more than one `--grep=<pattern>`, commits whose message matches any of the given patterns are chosen (but see `--all-match`)."
msgstr "将提交结果限制在日志信息与指定模式（正则表达式）相匹配的提交。  如果有多个`--grep=<pattern>`，则会选择那些日志信息与任何指定模式相匹配的提交（但见`--all-match`）。"

#. type: Plain text
#: en/rev-list-options.txt:68
#, priority:260
msgid "When `--notes` is in effect, the message from the notes is matched as if it were part of the log message."
msgstr "当`--笔记`生效时，笔记中的信息被匹配，就像它是日志信息的一部分。"

#. type: Plain text
#: en/rev-list-options.txt:73
#, priority:260
msgid "Limit the commits output to ones that match all given `--grep`, instead of ones that match at least one."
msgstr "将输出的提交限制在符合所有给定`--grep`的提交，而不是至少符合一个的提交。"

#. type: Labeled list
#: en/rev-list-options.txt:74
#, ignore-same, no-wrap, priority:260
msgid "--invert-grep"
msgstr "--invert-grep"

#. type: Plain text
#: en/rev-list-options.txt:77
#, priority:260
msgid "Limit the commits output to ones with log message that do not match the pattern specified with `--grep=<pattern>`."
msgstr "限定输出的提交信息与`--grep=<pattern>指定的模式不匹配。"

#. type: Labeled list
#: en/rev-list-options.txt:79
#, ignore-same, no-wrap, priority:260
msgid "--regexp-ignore-case"
msgstr "--regexp-ignore-case"

#. type: Plain text
#: en/rev-list-options.txt:82
#, priority:260
msgid "Match the regular expression limiting patterns without regard to letter case."
msgstr "匹配正则表达式的限制模式，不考虑字母大小写。"

#. type: Plain text
#: en/rev-list-options.txt:86
#, priority:260
msgid "Consider the limiting patterns to be basic regular expressions; this is the default."
msgstr "将限制性模式视为基本的正则表达式；这是默认的。"

#. type: Plain text
#: en/rev-list-options.txt:91
#, priority:260
msgid "Consider the limiting patterns to be extended regular expressions instead of the default basic regular expressions."
msgstr "将限制性模式视为扩展的正则表达式，而不是默认的基本正则表达式。"

#. type: Plain text
#: en/rev-list-options.txt:96
#, priority:260
msgid "Consider the limiting patterns to be fixed strings (don't interpret pattern as a regular expression)."
msgstr "将限制性模式视为固定字符串（不要将模式解释为正则表达式）。"

#. type: Plain text
#: en/rev-list-options.txt:101
#, priority:260
msgid "Consider the limiting patterns to be Perl-compatible regular expressions."
msgstr "将限制性模式视为与Perl兼容的正则表达式。"

#. type: Labeled list
#: en/rev-list-options.txt:106
#, ignore-same, no-wrap, priority:260
msgid "--remove-empty"
msgstr "--remove-empty"

#. type: Plain text
#: en/rev-list-options.txt:108
#, priority:260
msgid "Stop when a given path disappears from the tree."
msgstr "当一个给定的路径从树上消失时停止。"

#. type: Labeled list
#: en/rev-list-options.txt:109
#, ignore-same, no-wrap, priority:260
msgid "--merges"
msgstr "--merges"

#. type: Plain text
#: en/rev-list-options.txt:111
#, priority:260
msgid "Print only merge commits. This is exactly the same as `--min-parents=2`."
msgstr "只打印合并后的提交。这与`--min-parents=2`完全相同。"

#. type: Labeled list
#: en/rev-list-options.txt:112
#, ignore-same, no-wrap, priority:260
msgid "--no-merges"
msgstr "--no-merges"

#. type: Plain text
#: en/rev-list-options.txt:115
#, priority:260
msgid "Do not print commits with more than one parent. This is exactly the same as `--max-parents=1`."
msgstr "不打印有一个以上父级的提交。这与`--max-parents=1`完全相同。"

#. type: Labeled list
#: en/rev-list-options.txt:116
#, fuzzy, no-wrap, priority:260
msgid "--min-parents=<number>"
msgstr "--min-parents=<number>"

#. type: Labeled list
#: en/rev-list-options.txt:117
#, fuzzy, no-wrap, priority:260
msgid "--max-parents=<number>"
msgstr "--max-parents=<number>"

#. type: Labeled list
#: en/rev-list-options.txt:118
#, ignore-same, no-wrap, priority:260
msgid "--no-min-parents"
msgstr "--no-min-parents"

#. type: Labeled list
#: en/rev-list-options.txt:119
#, ignore-same, no-wrap, priority:260
msgid "--no-max-parents"
msgstr "--no-max-parents"

#. type: Plain text
#: en/rev-list-options.txt:124
#, priority:260
msgid "Show only commits which have at least (or at most) that many parent commits. In particular, `--max-parents=1` is the same as `--no-merges`, `--min-parents=2` is the same as `--merges`.  `--max-parents=0` gives all root commits and `--min-parents=3` all octopus merges."
msgstr "只显示至少（或最多）有那么多父提交的提交。特别是，`--max-parents=1`等同于`--no-merges`，`--min-parents=2`等同于`--merges`。  `--max-parents=0`给出所有根提交，`--min-parents=3`给出所有章鱼合并。"

#. type: Plain text
#: en/rev-list-options.txt:128
#, fuzzy, priority:260
msgid "`--no-min-parents` and `--no-max-parents` reset these limits (to no limit)  again.  Equivalent forms are `--min-parents=0` (any commit has 0 or more parents) and `--max-parents=-1` (negative numbers denote no upper limit)."
msgstr "`--no-min-parents` and `--no-max-parents` reset these limits (to no limit)  again.  Equivalent forms are `--min-parents=0` (any commit has 0 or more parents) and `--max-parents=-1` (negative numbers denote no upper limit)."

#. type: Plain text
#: en/rev-list-options.txt:138
#, fuzzy, priority:260
#| msgid "Follow only the first parent commit upon seeing a merge commit.  This option can give a better overview when viewing the evolution of a particular topic branch, because merges into a topic branch tend to be only about adjusting to updated upstream from time to time, and this option allows you to ignore the individual commits brought in to your history by such a merge."
msgid "When finding commits to include, follow only the first parent commit upon seeing a merge commit.  This option can give a better overview when viewing the evolution of a particular topic branch, because merges into a topic branch tend to be only about adjusting to updated upstream from time to time, and this option allows you to ignore the individual commits brought in to your history by such a merge."
msgstr "在看到一个合并提交时，只关注第一个父提交。  在查看某个主题分支的演变时，这个选项可以提供一个更好的概览，因为合并到一个主题分支往往只是为了适应不时更新的上游，而这个选项可以让你忽略这种合并给你的历史带来的个别提交。"

#. type: Plain text
#: en/rev-list-options.txt:142
#, priority:260
msgid "This option also changes default diff format for merge commits to `first-parent`, see `--diff-merges=first-parent` for details."
msgstr "这个选项也改变了合并提交的默认差异格式为 \"first-parent\"，详见\"-diff-merges=first-parent\"。"

#. type: Labeled list
#: en/rev-list-options.txt:144
#, ignore-same, no-wrap, priority:260
msgid "--exclude-first-parent-only"
msgstr "--exclude-first-parent-only"

#. type: Plain text
#: en/rev-list-options.txt:150
#, priority:260
msgid "When finding commits to exclude (with a '{caret}'), follow only the first parent commit upon seeing a merge commit.  This can be used to find the set of changes in a topic branch from the point where it diverged from the remote branch, given that arbitrary merges can be valid topic branch changes."
msgstr "在寻找要排除的提交（用'{caret}'）时，在看到合并提交时只跟随第一个父提交。  考虑到任意的合并都可以成为有效的主题分支变化，这可以用来查找主题分支中从它与远程分支的分歧点开始的变化集合。"

#. type: Plain text
#: en/rev-list-options.txt:154
#, priority:260
msgid "Reverses the meaning of the '{caret}' prefix (or lack thereof)  for all following revision specifiers, up to the next `--not`."
msgstr "颠倒\"{caret}\"前缀（或没有前缀）对所有后续修订指定符的意义，直到下一个`--not`。"

#. type: Plain text
#: en/rev-list-options.txt:158
#, priority:260
msgid "Pretend as if all the refs in `refs/`, along with `HEAD`, are listed on the command line as '<commit>'."
msgstr "假设`refs/`中的所有参考文献，连同`HEAD`一起，在命令行中被列为'<commit>'。"

#. type: Labeled list
#: en/rev-list-options.txt:159
#, no-wrap, priority:260
msgid "--branches[=<pattern>]"
msgstr "--支部[=<模式>]"

#. type: Plain text
#: en/rev-list-options.txt:164
#, priority:260
msgid "Pretend as if all the refs in `refs/heads` are listed on the command line as '<commit>'. If '<pattern>' is given, limit branches to ones matching given shell glob. If pattern lacks '?', '{asterisk}', or '[', '/{asterisk}' at the end is implied."
msgstr "假设`refs/heads`中的所有 refs 在命令行中被列为 '<commit>'。如果给出了'<pattern>'，将分支限制在与给定的shell glob相匹配的分支。如果pattern缺少'?'、'{asterisk}'或'['，则末尾的'/{asterisk}'是暗示的。"

#. type: Labeled list
#: en/rev-list-options.txt:165
#, fuzzy, no-wrap, priority:260
msgid "--tags[=<pattern>]"
msgstr "--tags[=<pattern>]"

#. type: Plain text
#: en/rev-list-options.txt:170
#, priority:260
msgid "Pretend as if all the refs in `refs/tags` are listed on the command line as '<commit>'. If '<pattern>' is given, limit tags to ones matching given shell glob. If pattern lacks '?', '{asterisk}', or '[', '/{asterisk}' at the end is implied."
msgstr "假设`refs/tags`中的所有参考文献在命令行中被列为'<commit>'。如果给出了'<pattern>'，将标签限制在与给定的shell glob相匹配的标签。如果pattern缺少'?'、'{asterisk}'或'['，则暗示最后的'/{asterisk}'。"

#. type: Labeled list
#: en/rev-list-options.txt:171
#, fuzzy, no-wrap, priority:260
msgid "--remotes[=<pattern>]"
msgstr "--remotes[=<pattern>]"

#. type: Plain text
#: en/rev-list-options.txt:176
#, priority:260
msgid "Pretend as if all the refs in `refs/remotes` are listed on the command line as '<commit>'. If '<pattern>' is given, limit remote-tracking branches to ones matching given shell glob.  If pattern lacks '?', '{asterisk}', or '[', '/{asterisk}' at the end is implied."
msgstr "假设`refs/remotes`中的所有 refs 在命令行中被列为 '<commit>'。如果给出了'<pattern>'，将远程跟踪分支限制在与给定的shell glob相匹配的分支。  如果pattern缺少'?'、'{asterisk}'或'['，则末尾的'/{asterisk}'是暗示的。"

#. type: Labeled list
#: en/rev-list-options.txt:177
#, fuzzy, no-wrap, priority:260
msgid "--glob=<glob-pattern>"
msgstr "--glob=<glob-pattern>"

#. type: Plain text
#: en/rev-list-options.txt:182
#, priority:260
msgid "Pretend as if all the refs matching shell glob '<glob-pattern>' are listed on the command line as '<commit>'. Leading 'refs/', is automatically prepended if missing. If pattern lacks '?', '{asterisk}', or '[', '/{asterisk}' at the end is implied."
msgstr "假设所有与shell glob '<glob-pattern>相匹配的refs在命令行中被列为'<commit>'。前面的'refs/'，如果缺少的话会自动预加。如果模式中缺少'?'、'{asterisk}'或'['，则在结尾处隐含'/{asterisk}'。"

#. type: Labeled list
#: en/rev-list-options.txt:206
#, ignore-same, no-wrap, priority:260
msgid "--reflog"
msgstr "--reflog"

#. type: Plain text
#: en/rev-list-options.txt:209
#, priority:260
msgid "Pretend as if all objects mentioned by reflogs are listed on the command line as `<commit>`."
msgstr "假设reflogs提到的所有对象都在命令行中被列为`<commit>`。"

#. type: Labeled list
#: en/rev-list-options.txt:210
#, ignore-same, no-wrap, priority:260
msgid "--alternate-refs"
msgstr "--alternate-refs"

#. type: Plain text
#: en/rev-list-options.txt:217
#, priority:260
msgid "Pretend as if all objects mentioned as ref tips of alternate repositories were listed on the command line. An alternate repository is any repository whose object directory is specified in `objects/info/alternates`.  The set of included objects may be modified by `core.alternateRefsCommand`, etc. See linkgit:git-config[1]."
msgstr "假设所有提到的作为备用仓库的参考提示的对象都列在命令行上。备用资源库是任何资源库，其对象目录在`objects/info/alternates`中指定。  包含的对象集可以通过`core.alternateRefsCommand`等修改。见linkgit:git-config[1]。"

#. type: Plain text
#: en/rev-list-options.txt:225
#, priority:260
msgid "By default, all working trees will be examined by the following options when there are more than one (see linkgit:git-worktree[1]): `--all`, `--reflog` and `--indexed-objects`.  This option forces them to examine the current working tree only."
msgstr "默认情况下，当有多个工作树时，所有工作树都会被以下选项检查（见linkgit:git-worktree[1]）：`--all`，`--reflog`和`--indexed-objects`。  这个选项强制它们只检查当前的工作树。"

#. type: Plain text
#: en/rev-list-options.txt:229
#, priority:260
msgid "Upon seeing an invalid object name in the input, pretend as if the bad input was not given."
msgstr "在看到输入中无效的对象名称时，假装没有给出坏的输入。"

#. type: Labeled list
#: en/rev-list-options.txt:231 en/rev-list-options.txt:786
#, ignore-same, no-wrap, priority:260
msgid "--bisect"
msgstr "--bisect"

#. type: Plain text
#: en/rev-list-options.txt:236
#, priority:260
msgid "Pretend as if the bad bisection ref `refs/bisect/bad` was listed and as if it was followed by `--not` and the good bisection refs `refs/bisect/good-*` on the command line."
msgstr "假设坏的二分法参考文献`refs/bisect/bad`被列出，并且在命令行中假设它后面是`--not`和好的二分法参考文献`refs/bisect/good-*`。"

#. type: Plain text
#: en/rev-list-options.txt:244
#, fuzzy, priority:260
#| msgid "In addition to the '<commit>' listed on the command line, read them from the standard input. If a `--` separator is seen, stop reading commits and start reading paths to limit the result."
msgid "In addition to getting arguments from the command line, read them for standard input as well. This accepts commits and pseudo-options like `--all` and `--glob=`. When a `--` separator is seen, the following input is treated as paths and used to limit the result."
msgstr "除了命令行上列出的'<commit>'之外，还要从标准输入中读取它们。如果看到`--`分隔符，就停止读取提交，开始读取路径以限制结果。"

#. type: Plain text
#: en/rev-list-options.txt:252
#, priority:260
msgid "Don't print anything to standard output.  This form is primarily meant to allow the caller to test the exit status to see if a range of objects is fully connected (or not).  It is faster than redirecting stdout to `/dev/null` as the output does not have to be formatted."
msgstr "不要打印任何东西到标准输出。  这种形式主要是为了让调用者测试退出状态，看看一系列的对象是否完全连接（或没有）。  它比将stdout重定向到`/dev/null`要快，因为输出不需要被格式化。"

#. type: Labeled list
#: en/rev-list-options.txt:253
#, ignore-same, no-wrap, priority:260
msgid "--disk-usage"
msgstr "--disk-usage"

#. type: Labeled list
#: en/rev-list-options.txt:254
#, fuzzy, no-wrap, priority:260
#| msgid "--disk-usage"
msgid "--disk-usage=human"
msgstr "--disk-usage"

#. type: Plain text
#: en/rev-list-options.txt:264
#, fuzzy, priority:260
#| msgid "Suppress normal output; instead, print the sum of the bytes used for on-disk storage by the selected commits or objects. This is equivalent to piping the output into `git cat-file --batch-check='%(objectsize:disk)'`, except that it runs much faster (especially with `--use-bitmap-index`). See the `CAVEATS` section in linkgit:git-cat-file[1] for the limitations of what \"on-disk storage\" means."
msgid "Suppress normal output; instead, print the sum of the bytes used for on-disk storage by the selected commits or objects. This is equivalent to piping the output into `git cat-file --batch-check='%(objectsize:disk)'`, except that it runs much faster (especially with `--use-bitmap-index`). See the `CAVEATS` section in linkgit:git-cat-file[1] for the limitations of what \"on-disk storage\" means.  With the optional value `human`, on-disk storage size is shown in human-readable string(e.g. 12.24 Kib, 3.50 Mib)."
msgstr "抑制正常输出；相反，打印所选提交或对象用于磁盘存储的字节数之和。这相当于用管道将输出写入 `git cat-file --batch-check='%(objectsize:disk)'，只是它的运行速度要快得多（尤其是在使用 `--use-bitmap-index'时）。参见 linkgit:git-cat-file[1] 中的 `CAVEATS` 部分，了解 \"磁盘存储 \"的限制。"

#. type: Labeled list
#: en/rev-list-options.txt:266
#, ignore-same, no-wrap, priority:260
msgid "--cherry-mark"
msgstr "--cherry-mark"

#. type: Plain text
#: en/rev-list-options.txt:269
#, priority:260
msgid "Like `--cherry-pick` (see below) but mark equivalent commits with `=` rather than omitting them, and inequivalent ones with `+`."
msgstr "就像`--cherry-pick`（见下文），但用`=`标记同等的提交，而不是省略，用`+`标记不同等的提交。"

#. type: Labeled list
#: en/rev-list-options.txt:270
#, ignore-same, no-wrap, priority:260
msgid "--cherry-pick"
msgstr "--cherry-pick"

#. type: Plain text
#: en/rev-list-options.txt:274
#, priority:260
msgid "Omit any commit that introduces the same change as another commit on the ``other side'' when the set of commits are limited with symmetric difference."
msgstr "当提交的集合有对称差异时，省略任何与 \"另一边 \"的另一个提交相同的提交。"

#. type: Plain text
#: en/rev-list-options.txt:282
#, priority:260
msgid "For example, if you have two branches, `A` and `B`, a usual way to list all commits on only one side of them is with `--left-right` (see the example below in the description of the `--left-right` option). However, it shows the commits that were cherry-picked from the other branch (for example, ``3rd on b'' may be cherry-picked from branch A). With this option, such pairs of commits are excluded from the output."
msgstr "例如，如果你有两个分支，`A`和`B`，通常的方法是用`--左--右`列出其中一边的所有提交（见下面关于`--左--右`选项的描述）。然而，它显示的是从另一个分支中偷梁换柱的提交（例如，\"3rd on b \"可能是从分支A中偷梁换柱的）。有了这个选项，这样的提交对将从输出中排除。"

#. type: Plain text
#: en/rev-list-options.txt:288
#, priority:260
msgid "List only commits on the respective side of a symmetric difference, i.e. only those which would be marked `<` resp. `>` by `--left-right`."
msgstr "只列出对称性差异各自一侧的提交，即只列出那些通过\"--左--右 \"标记的\"<\"或\">\"。"

#. type: Plain text
#: en/rev-list-options.txt:294
#, ignore-ellipsis, priority:260
msgid "For example, `--cherry-pick --right-only A...B` omits those commits from `B` which are in `A` or are patch-equivalent to a commit in `A`. In other words, this lists the `+` commits from `git cherry A B`.  More precisely, `--cherry-pick --right-only --no-merges` gives the exact list."
msgstr "例如，`--cherry-pick --right-only A...B`省略了`B`中那些在`A`中的提交或与`A`中的提交相等的补丁。换句话说，它列出了 \"git cherry A B \"的 \"+\"的提交。  更准确地说，`--cherry-pick --right-only --no-merges`可以得到准确的列表。"

#. type: Labeled list
#: en/rev-list-options.txt:295
#, ignore-same, no-wrap, priority:260
msgid "--cherry"
msgstr "--cherry"

#. type: Plain text
#: en/rev-list-options.txt:301
#, ignore-ellipsis, priority:260
msgid "A synonym for `--right-only --cherry-mark --no-merges`; useful to limit the output to the commits on our side and mark those that have been applied to the other side of a forked history with `git log --cherry upstream...mybranch`, similar to `git cherry upstream mybranch`."
msgstr "`--right-only --cherry-mark --no-merges`的同义词；有助于将输出限制在我们这边的提交，并标记那些已经应用到分叉历史的另一边的提交，`git log --cherry upstream...mybranch`，类似于`git cherry upstream mybranch`。"

#. type: Labeled list
#: en/rev-list-options.txt:303
#, ignore-same, no-wrap, priority:260
msgid "--walk-reflogs"
msgstr "--walk-reflogs"

#. type: Plain text
#: en/rev-list-options.txt:309
#, ignore-ellipsis, priority:260
msgid "Instead of walking the commit ancestry chain, walk reflog entries from the most recent one to older ones.  When this option is used you cannot specify commits to exclude (that is, '{caret}commit', 'commit1..commit2', and 'commit1\\...commit2' notations cannot be used)."
msgstr "不走提交祖先链，而走从最近的提交到更早的提交的reflog条目。  使用这个选项时，你不能指定要排除的提交（也就是说，不能使用'{caret}commit'、'commit1...commit2'和'commit1/...commit2'的符号）。"

#. type: Plain text
#: en/rev-list-options.txt:316
#, priority:260
msgid "With `--pretty` format other than `oneline` and `reference` (for obvious reasons), this causes the output to have two extra lines of information taken from the reflog.  The reflog designator in the output may be shown as `ref@{Nth}` (where `Nth` is the reverse-chronological index in the reflog) or as `ref@{timestamp}` (with the timestamp for that entry), depending on a few rules:"
msgstr "在`--pretty`格式下，除了`oneline`和`reference`（由于明显的原因），这将导致输出有两行额外的信息来自reflog。  输出中的reflog代号可以显示为`ref@{Nth}`（其中`Nth`是reflog中的逆序索引）或`ref@{timestamp}`（带有该条目的时间戳），取决于一些规则。"

#. type: Plain text
#: en/rev-list-options.txt:320
#, priority:260
msgid "If the starting point is specified as `ref@{Nth}`, show the index format."
msgstr "如果起点被指定为`ref@{Nth}`，显示索引格式。"

#. type: Plain text
#: en/rev-list-options.txt:323
#, priority:260
msgid "If the starting point was specified as `ref@{now}`, show the timestamp format."
msgstr "如果起点被指定为`ref@{now}`，显示时间戳格式。"

#. type: Plain text
#: en/rev-list-options.txt:326
#, priority:260
msgid "If neither was used, but `--date` was given on the command line, show the timestamp in the format requested by `--date`."
msgstr "如果两者都没有使用，但在命令行中给出了`--date`，则按照`--date`所要求的格式显示时间戳。"

#. type: Plain text
#: en/rev-list-options.txt:328
#, priority:260
msgid "Otherwise, show the index format."
msgstr "否则，显示索引格式。"

#. type: Plain text
#: en/rev-list-options.txt:334
#, priority:260
msgid "Under `--pretty=oneline`, the commit message is prefixed with this information on the same line.  This option cannot be combined with `--reverse`.  See also linkgit:git-reflog[1]."
msgstr "在`--pretty=oneline`下，提交信息的前缀是同一行中的这些信息。  这个选项不能与 `--reverse`结合使用。  参见 linkgit:git-reflog[1]。"

#. type: Plain text
#: en/rev-list-options.txt:336
#, priority:260
msgid "Under `--pretty=reference`, this information will not be shown at all."
msgstr "在`--pretty=reference`下，这些信息将完全不显示。"

#. type: Plain text
#: en/rev-list-options.txt:340
#, priority:260
msgid "After a failed merge, show refs that touch files having a conflict and don't exist on all heads to merge."
msgstr "在合并失败后，显示触及有冲突的文件且不存在于所有要合并的头的参考文件。"

#. type: Labeled list
#: en/rev-list-options.txt:341
#, ignore-same, no-wrap, priority:260
msgid "--boundary"
msgstr "--boundary"

#. type: Plain text
#: en/rev-list-options.txt:344
#, priority:260
msgid "Output excluded boundary commits. Boundary commits are prefixed with `-`."
msgstr "输出排除的边界提交。边界提交的前缀是\"-\"。"

#. type: Labeled list
#: en/rev-list-options.txt:346
#, ignore-same, no-wrap, priority:260
msgid "--use-bitmap-index"
msgstr "--use-bitmap-index"

#. type: Plain text
#: en/rev-list-options.txt:351
#, priority:260
msgid "Try to speed up the traversal using the pack bitmap index (if one is available). Note that when traversing with `--objects`, trees and blobs will not have their associated path printed."
msgstr "尝试使用包位图索引（如果有的话）来加快遍历的速度。注意，当使用`--对象`进行遍历时，树和blobs不会打印出它们的相关路径。"

#. type: Labeled list
#: en/rev-list-options.txt:352
#, no-wrap, priority:260
msgid "--progress=<header>"
msgstr "--progress=<header>。"

#. type: Plain text
#: en/rev-list-options.txt:355
#, priority:260
msgid "Show progress reports on stderr as objects are considered. The `<header>` text will be printed with each progress update."
msgstr "在考虑对象时在stderr上显示进度报告。`<标题>`文本将在每次进度更新时打印。"

#. type: Title ~
#: en/rev-list-options.txt:358
#, no-wrap, priority:260
msgid "History Simplification"
msgstr "简化历史"

#. type: Plain text
#: en/rev-list-options.txt:364
#, priority:260
msgid "Sometimes you are only interested in parts of the history, for example the commits modifying a particular <path>. But there are two parts of 'History Simplification', one part is selecting the commits and the other is how to do it, as there are various strategies to simplify the history."
msgstr "有时你只对历史的一部分感兴趣，例如修改某个<路径>的提交。但 \"历史简化 \"有两部分，一部分是选择提交，另一部分是如何做，因为有各种策略来简化历史。"

#. type: Plain text
#: en/rev-list-options.txt:366
#, priority:260
msgid "The following options select the commits to be shown:"
msgstr "以下选项选择要显示的提交。"

#. type: Labeled list
#: en/rev-list-options.txt:367
#, no-wrap, priority:260
msgid "<paths>"
msgstr "<paths>"

#. type: Plain text
#: en/rev-list-options.txt:369
#, priority:260
msgid "Commits modifying the given <paths> are selected."
msgstr "修改给定<路径>的提交会被选中。"

#. type: Labeled list
#: en/rev-list-options.txt:370
#, ignore-same, no-wrap, priority:260
msgid "--simplify-by-decoration"
msgstr "--simplify-by-decoration"

#. type: Plain text
#: en/rev-list-options.txt:372
#, priority:260
msgid "Commits that are referred by some branch or tag are selected."
msgstr "被某个分支或标签引用的提交被选中。"

#. type: Plain text
#: en/rev-list-options.txt:374
#, priority:260
msgid "Note that extra commits can be shown to give a meaningful history."
msgstr "请注意，可以显示额外的提交，以提供一个有意义的历史。"

#. type: Plain text
#: en/rev-list-options.txt:376
#, priority:260
msgid "The following options affect the way the simplification is performed:"
msgstr "以下选项会影响简化的执行方式。"

#. type: Labeled list
#: en/rev-list-options.txt:377 en/rev-list-options.txt:459
#, fuzzy, no-wrap, priority:260
msgid "Default mode"
msgstr "默认模式"

#. type: Plain text
#: en/rev-list-options.txt:382
#, priority:260
msgid "Simplifies the history to the simplest history explaining the final state of the tree. Simplest because it prunes some side branches if the end result is the same (i.e. merging branches with the same content)"
msgstr "将历史简化为解释树的最终状态的最简单的历史。最简单的原因是，如果最终结果相同，它会修剪一些侧枝（即合并具有相同内容的分支）。"

#. type: Labeled list
#: en/rev-list-options.txt:383 en/rev-list-options.txt:737
#, ignore-same, no-wrap, priority:260
msgid "--show-pulls"
msgstr "--show-pulls"

#. type: Plain text
#: en/rev-list-options.txt:388
#, priority:260
msgid "Include all commits from the default mode, but also any merge commits that are not TREESAME to the first parent but are TREESAME to a later parent. This mode is helpful for showing the merge commits that \"first introduced\" a change to a branch."
msgstr "包括默认模式下的所有提交，但也包括任何与第一个父分支不相干但与后来的父分支相干的合并提交。这种模式有助于显示 \"首次引入 \"某个分支的合并提交。"

#. type: Labeled list
#: en/rev-list-options.txt:389
#, ignore-same, no-wrap, priority:260
msgid "--full-history"
msgstr "--full-history"

#. type: Plain text
#: en/rev-list-options.txt:391
#, priority:260
msgid "Same as the default mode, but does not prune some history."
msgstr "与默认模式相同，但不修剪一些历史记录。"

#. type: Labeled list
#: en/rev-list-options.txt:392 en/rev-list-options.txt:527
#, ignore-same, no-wrap, priority:260
msgid "--dense"
msgstr "--dense"

#. type: Plain text
#: en/rev-list-options.txt:395
#, priority:260
msgid "Only the selected commits are shown, plus some to have a meaningful history."
msgstr "只显示所选的提交，再加上一些才有意义的历史。"

#. type: Plain text
#: en/rev-list-options.txt:398
#, priority:260
msgid "All commits in the simplified history are shown."
msgstr "简化历史中的所有提交都会显示出来。"

#. type: Labeled list
#: en/rev-list-options.txt:399 en/rev-list-options.txt:538
#, ignore-same, no-wrap, priority:260
msgid "--simplify-merges"
msgstr "--simplify-merges"

#. type: Plain text
#: en/rev-list-options.txt:403
#, priority:260
msgid "Additional option to `--full-history` to remove some needless merges from the resulting history, as there are no selected commits contributing to this merge."
msgstr "为`--full-history`增加了一个选项，可以从结果的历史中删除一些不必要的合并，因为没有选定的提交对这次合并有贡献。"

#. type: Labeled list
#: en/rev-list-options.txt:404 en/rev-list-options.txt:585
#, fuzzy, no-wrap, priority:260
#| msgid "--ancestry-path"
msgid "--ancestry-path[=<commit>]"
msgstr "--ancestry-path"

#. type: Plain text
#: en/rev-list-options.txt:412
#, fuzzy, priority:260
#| msgid "When given a range of commits to display (e.g. 'commit1..commit2' or 'commit2 {caret}commit1'), only display commits that exist directly on the ancestry chain between the 'commit1' and 'commit2', i.e. commits that are both descendants of 'commit1', and ancestors of 'commit2'."
msgid "When given a range of commits to display (e.g. 'commit1..commit2' or 'commit2 {caret}commit1'), only display commits in that range that are ancestors of <commit>, descendants of <commit>, or <commit> itself.  If no commit is specified, use 'commit1' (the excluded part of the range) as <commit>.  Can be passed multiple times; if so, a commit is included if it is any of the commits given or if it is an ancestor or descendant of one of them."
msgstr "当给定一个要显示的提交范围（例如 \"commit1...commit2 \"或 \"commit2 {caret}commit1\"）时，只显示直接存在于 \"commit1 \"和 \"commit2 \"之间的祖先链的提交，即既是 \"commit1 \"的后代，又是 \"commit2 \"的祖先的提交。"

#. type: Plain text
#: en/rev-list-options.txt:414
#, priority:260
msgid "A more detailed explanation follows."
msgstr "以下是更详细的解释。"

#. type: Plain text
#: en/rev-list-options.txt:418
#, priority:260
msgid "Suppose you specified `foo` as the <paths>.  We shall call commits that modify `foo` !TREESAME, and the rest TREESAME.  (In a diff filtered for `foo`, they look different and equal, respectively.)"
msgstr "假设你指定了`foo`作为<paths>。  我们将把修改`foo`的提交称为 !TREESAME，其余的称为 TREESAME。  (在为`foo`过滤的diff中，它们看起来分别是不同的和相同的)。"

#. type: Plain text
#: en/rev-list-options.txt:422
#, priority:260
msgid "In the following, we will always refer to the same example history to illustrate the differences between simplification settings.  We assume that you are filtering for a file `foo` in this commit graph:"
msgstr "在下文中，我们将始终引用同一个历史实例来说明简化设置之间的差异。  我们假设你在这个提交图中过滤的是一个文件`foo`。"

#. type: delimited block -
#: en/rev-list-options.txt:428
#, fuzzy, no-wrap, priority:260
msgid ""
"\t  .-A---M---N---O---P---Q\n"
"\t /     /   /   /   /   /\n"
"\tI     B   C   D   E   Y\n"
"\t \\   /   /   /   /   /\n"
"\t  `-------------'   X\n"
msgstr ""
"\t  .-A---M---N---O---P---Q\n"
"\t /     /   /   /   /   /\n"
"\tI     B   C   D   E   Y\n"
"\t \\   /   /   /   /   /\n"
"\t  `-------------'   X\n"

#. type: Plain text
#: en/rev-list-options.txt:431
#, priority:260
msgid "The horizontal line of history A---Q is taken to be the first parent of each merge.  The commits are:"
msgstr "历史A---Q的横线被认为是每次合并的第一个父本。  这些提交是"

#. type: Plain text
#: en/rev-list-options.txt:435
#, priority:260
msgid "`I` is the initial commit, in which `foo` exists with contents ``asdf'', and a file `quux` exists with contents ``quux''. Initial commits are compared to an empty tree, so `I` is !TREESAME."
msgstr "`I`是初始提交，其中`foo`存在，内容是`asdf''，文件`quux`存在，内容是`quux''。初始提交与空树比较，所以`I`是！`TREESAME。"

#. type: Plain text
#: en/rev-list-options.txt:437
#, priority:260
msgid "In `A`, `foo` contains just ``foo''."
msgstr "在`A`中，`foo`只包含`foo''。"

#. type: Plain text
#: en/rev-list-options.txt:440
#, priority:260
msgid "`B` contains the same change as `A`.  Its merge `M` is trivial and hence TREESAME to all parents."
msgstr "`B`包含与`A`相同的变化。  它的合并`M`是微不足道的，因此对所有父类来说是TREESAME。"

#. type: Plain text
#: en/rev-list-options.txt:443
#, priority:260
msgid "`C` does not change `foo`, but its merge `N` changes it to ``foobar'', so it is not TREESAME to any parent."
msgstr "`C`没有改变`foo`，但是它的合并`N`将其改为`foobar''，所以它与任何父类都不存在TREESAME。"

#. type: Plain text
#: en/rev-list-options.txt:446
#, priority:260
msgid "`D` sets `foo` to ``baz''. Its merge `O` combines the strings from `N` and `D` to ``foobarbaz''; i.e., it is not TREESAME to any parent."
msgstr "`D`将`foo`设置为`baz''。它的合并项`O`将`N`和`D`的字符串合并为`foobarbaz''；也就是说，它与任何父类都不是TREESAME。"

#. type: Plain text
#: en/rev-list-options.txt:449
#, priority:260
msgid "`E` changes `quux` to ``xyzzy'', and its merge `P` combines the strings to ``quux xyzzy''. `P` is TREESAME to `O`, but not to `E`."
msgstr "`E`将`quux`改为`xyzzy''，其合并的`P`将这些字符串合并为`quux xyzzy''。`P'与`O'的关系是TREESAME，但与`E'不是。"

#. type: Plain text
#: en/rev-list-options.txt:453
#, priority:260
msgid "`X` is an independent root commit that added a new file `side`, and `Y` modified it. `Y` is TREESAME to `X`. Its merge `Q` added `side` to `P`, and `Q` is TREESAME to `P`, but not to `Y`."
msgstr "`X`是一个独立的根提交，添加了一个新文件`side`，`Y`修改了它。`Y`与`X`同为TREESAME。它的合并文件`Q`在`P`上添加了`side`，`Q`与`P`是同源，但与`Y`不是同源。"

#. type: Plain text
#: en/rev-list-options.txt:458
#, priority:260
msgid "`rev-list` walks backwards through history, including or excluding commits based on whether `--full-history` and/or parent rewriting (via `--parents` or `--children`) are used. The following settings are available."
msgstr "`rev-list`在历史中倒退，根据是否使用`--full-history`和/或父代重写（通过`--parents`或`--children`），包括或排除提交。以下设置是可用的。"

#. type: Plain text
#: en/rev-list-options.txt:466
#, priority:260
msgid "Commits are included if they are not TREESAME to any parent (though this can be changed, see `--sparse` below).  If the commit was a merge, and it was TREESAME to one parent, follow only that parent.  (Even if there are several TREESAME parents, follow only one of them.)  Otherwise, follow all parents."
msgstr "如果提交的内容与任何父类不相干，则被包括在内（当然这一点可以改变，见下面的`--sparse`）。  如果该提交是一个合并，并且它与一个父类是同源的，则只跟随该父类。  (即使有几个TREESAME父类，也只跟随其中一个。) 否则，跟随所有父类。"

#. type: Plain text
#: en/rev-list-options.txt:468
#, fuzzy, priority:260
msgid "This results in:"
msgstr "这将实现："

#. type: delimited block -
#: en/rev-list-options.txt:473
#, fuzzy, no-wrap, priority:260
msgid ""
"\t  .-A---N---O\n"
"\t /     /   /\n"
"\tI---------D\n"
msgstr ""
"\t  .-A---N---O\n"
"\t /     /   /\n"
"\tI---------D\n"

#. type: Plain text
#: en/rev-list-options.txt:479
#, priority:260
msgid "Note how the rule to only follow the TREESAME parent, if one is available, removed `B` from consideration entirely.  `C` was considered via `N`, but is TREESAME.  Root commits are compared to an empty tree, so `I` is !TREESAME."
msgstr "请注意，如果有TREESAME父类的话，只遵循TREESAME父类的规则，将`B'完全排除在考虑之外。  `C`是通过`N`考虑的，但也是TREESAME。  根提交是与空树比较的，所以`I`是!!TREESAME。"

#. type: Plain text
#: en/rev-list-options.txt:483
#, priority:260
msgid "Parent/child relations are only visible with `--parents`, but that does not affect the commits selected in default mode, so we have shown the parent lines."
msgstr "父/子关系只有在`--父母`的情况下才能看到，但这并不影响在默认模式下选择的提交，所以我们显示了父行。"

#. type: Labeled list
#: en/rev-list-options.txt:484
#, fuzzy, no-wrap, priority:260
msgid "--full-history without parent rewriting"
msgstr "--full-history without parent rewriting"

#. type: Plain text
#: en/rev-list-options.txt:490
#, priority:260
msgid "This mode differs from the default in one point: always follow all parents of a merge, even if it is TREESAME to one of them.  Even if more than one side of the merge has commits that are included, this does not imply that the merge itself is! In the example, we get"
msgstr "这种模式与默认模式有一点不同：总是跟随一个合并的所有父本，即使它与其中一个父本是TREESAME。  即使合并的一方有多个提交被包括在内，这也不意味着合并本身也是如此在这个例子中，我们得到"

#. type: delimited block -
#: en/rev-list-options.txt:493
#, fuzzy, no-wrap, priority:260
msgid "\tI  A  B  N  D  O  P  Q\n"
msgstr "\tI  A  B  N  D  O  P  Q\n"

#. type: Plain text
#: en/rev-list-options.txt:498
#, priority:260
msgid "`M` was excluded because it is TREESAME to both parents.  `E`, `C` and `B` were all walked, but only `B` was !TREESAME, so the others do not appear."
msgstr "`M'被排除在外，因为它与父母都是TREESAME。  `E'、`C'和`B'都走了，但只有`B'是！\"TREESAME\"，所以其他的都没有出现。"

#. type: Plain text
#: en/rev-list-options.txt:502
#, priority:260
msgid "Note that without parent rewriting, it is not really possible to talk about the parent/child relationships between the commits, so we show them disconnected."
msgstr "请注意，如果没有父子重写，其实是不可能谈论提交之间的父子关系的，所以我们显示它们是不相连的。"

#. type: Labeled list
#: en/rev-list-options.txt:503
#, fuzzy, no-wrap, priority:260
msgid "--full-history with parent rewriting"
msgstr "--full-history with parent rewriting"

#. type: Plain text
#: en/rev-list-options.txt:506
#, priority:260
msgid "Ordinary commits are only included if they are !TREESAME (though this can be changed, see `--sparse` below)."
msgstr "普通的提交只有当它们是！TREESAME时才会被包括在内（尽管这一点可以改变，见下面的`--sparse`）。"

#. type: Plain text
#: en/rev-list-options.txt:510
#, priority:260
msgid "Merges are always included.  However, their parent list is rewritten: Along each parent, prune away commits that are not included themselves.  This results in"
msgstr "合并总是被包括在内。  然而，他们的父级列表会被重写。沿着每个父级，修剪掉那些不包括自己的提交。  这样做的结果是"

#. type: delimited block -
#: en/rev-list-options.txt:517
#, fuzzy, no-wrap, priority:260
msgid ""
"\t  .-A---M---N---O---P---Q\n"
"\t /     /   /   /   /\n"
"\tI     B   /   D   /\n"
"\t \\   /   /   /   /\n"
"\t  `-------------'\n"
msgstr ""
"\t  .-A---M---N---O---P---Q\n"
"\t /     /   /   /   /\n"
"\tI     B   /   D   /\n"
"\t \\   /   /   /   /\n"
"\t  `-------------'\n"

#. type: Plain text
#: en/rev-list-options.txt:523
#, priority:260
msgid "Compare to `--full-history` without rewriting above.  Note that `E` was pruned away because it is TREESAME, but the parent list of P was rewritten to contain `E`'s parent `I`.  The same happened for `C` and `N`, and `X`, `Y` and `Q`."
msgstr "与上面的`--full-history`相比，没有重写。  请注意，`E`被修剪掉了，因为它是TREESAME，但是P的父列表被改写为包含`E`的父`I`。  同样的情况发生在`C`和`N`，以及`X`、`Y`和`Q`。"

#. type: Plain text
#: en/rev-list-options.txt:526
#, priority:260
msgid "In addition to the above settings, you can change whether TREESAME affects inclusion:"
msgstr "除了上述设置外，你还可以改变TRESAME是否会影响收录。"

#. type: Plain text
#: en/rev-list-options.txt:530
#, priority:260
msgid "Commits that are walked are included if they are not TREESAME to any parent."
msgstr "如果不与任何父类有TREESAME关系，则包括走过的承诺。"

#. type: Plain text
#: en/rev-list-options.txt:533
#, priority:260
msgid "All commits that are walked are included."
msgstr "所有走过的提交都包括在内。"

#. type: Plain text
#: en/rev-list-options.txt:537
#, priority:260
msgid "Note that without `--full-history`, this still simplifies merges: if one of the parents is TREESAME, we follow only that one, so the other sides of the merge are never walked."
msgstr "请注意，如果没有`--full-history`，这仍然可以简化合并：如果父代之一是TREESAME，我们只跟随这个父代，所以合并的其他方面永远不会被走。"

#. type: Plain text
#: en/rev-list-options.txt:541
#, priority:260
msgid "First, build a history graph in the same way that `--full-history` with parent rewriting does (see above)."
msgstr "首先，按照`--full-history`与父级改写的相同方式建立一个历史图（见上文）。"

#. type: Plain text
#: en/rev-list-options.txt:544
#, priority:260
msgid "Then simplify each commit `C` to its replacement `C'` in the final history according to the following rules:"
msgstr "然后根据以下规则将每个提交的`C'简化为最终历史中的替换`C'。"

#. type: Plain text
#: en/rev-list-options.txt:547
#, priority:260
msgid "Set `C'` to `C`."
msgstr "将 \"C \"设为 \"C\"。"

#. type: Plain text
#: en/rev-list-options.txt:552
#, priority:260
msgid "Replace each parent `P` of `C'` with its simplification `P'`.  In the process, drop parents that are ancestors of other parents or that are root commits TREESAME to an empty tree, and remove duplicates, but take care to never drop all parents that we are TREESAME to."
msgstr "将`C'`的每个父类`P'替换成其简化的`P'`。  在这个过程中，放弃那些是其他父类的祖先的父类，或者是根部提交TREESAME的空树，并删除重复的父类，但注意不要放弃所有我们是TREESAME的父类。"

#. type: Plain text
#: en/rev-list-options.txt:556
#, priority:260
msgid "If after this parent rewriting, `C'` is a root or merge commit (has zero or >1 parents), a boundary commit, or !TREESAME, it remains.  Otherwise, it is replaced with its only parent."
msgstr "如果在这次父级改写之后，`C'`是一个根或合并提交（有0个或>1个父级），一个边界提交，或！TREESAME，那么它将被保留。  否则，它将被替换为其唯一的父类。"

#. type: Plain text
#: en/rev-list-options.txt:560
#, priority:260
msgid "The effect of this is best shown by way of comparing to `--full-history` with parent rewriting.  The example turns into:"
msgstr "通过与`--full-history`的父级改写进行比较，可以最好地显示其效果。  这个例子变成了。"

#. type: delimited block -
#: en/rev-list-options.txt:567
#, fuzzy, no-wrap, priority:260
msgid ""
"\t  .-A---M---N---O\n"
"\t /     /       /\n"
"\tI     B       D\n"
"\t \\   /       /\n"
"\t  `---------'\n"
msgstr ""
"\t  .-A---M---N---O\n"
"\t /     /       /\n"
"\tI     B       D\n"
"\t \\   /       /\n"
"\t  `---------'\n"

#. type: Plain text
#: en/rev-list-options.txt:570
#, priority:260
msgid "Note the major differences in `N`, `P`, and `Q` over `--full-history`:"
msgstr "注意`N'、`P'和`Q'与`--full-history'的主要区别。"

#. type: Plain text
#: en/rev-list-options.txt:574
#, priority:260
msgid "`N`'s parent list had `I` removed, because it is an ancestor of the other parent `M`.  Still, `N` remained because it is !TREESAME."
msgstr "`N`的父列表中删除了`I`，因为它是另一个父`M`的一个祖先。  但是，`N`仍然存在，因为它是!TREESAME。"

#. type: Plain text
#: en/rev-list-options.txt:577
#, priority:260
msgid "`P`'s parent list similarly had `I` removed.  `P` was then removed completely, because it had one parent and is TREESAME."
msgstr "`P`的父级列表也同样删除了`I`。  然后`P`被完全删除，因为它有一个父本，并且是TREESAME。"

#. type: Plain text
#: en/rev-list-options.txt:581
#, priority:260
msgid "`Q`'s parent list had `Y` simplified to `X`. `X` was then removed, because it was a TREESAME root. `Q` was then removed completely, because it had one parent and is TREESAME."
msgstr "`Q`的父列表中有`Y`简化为`X`。然后`X`被删除，因为它是一个TREESAME根。然后`Q`被完全删除，因为它有一个父级，是TREESAME。"

#. type: Plain text
#: en/rev-list-options.txt:584
#, priority:260
msgid "There is another simplification mode available:"
msgstr "还有一种简化模式可用。"

#. type: Plain text
#: en/rev-list-options.txt:589
#, priority:260
msgid "Limit the displayed commits to those which are an ancestor of <commit>, or which are a descendant of <commit>, or are <commit> itself."
msgstr "将显示的提交限制在<提交>的祖先，或<提交>的后代，或<提交>本身。"

#. type: Plain text
#: en/rev-list-options.txt:591
#, priority:260
msgid "As an example use case, consider the following commit history:"
msgstr "作为一个用例，请考虑以下提交历史："

#. type: delimited block -
#: en/rev-list-options.txt:598
#, no-wrap, priority:260
msgid ""
"\t    D---E-------F\n"
"\t   /     \\       \\\n"
"\t  B---C---G---H---I---J\n"
"\t /                     \\\n"
"\tA-------K---------------L--M\n"
msgstr ""
"\t    D--E-------F\n"
"\t   / \\ \\\n"
"\t  B---C---G---H---I---J\n"
"\t / \\\n"
"\tA-------K---------------L--M\n"

#. type: Plain text
#: en/rev-list-options.txt:606
#, priority:260
msgid "A regular 'D..M' computes the set of commits that are ancestors of `M`, but excludes the ones that are ancestors of `D`. This is useful to see what happened to the history leading to `M` since `D`, in the sense that ``what does `M` have that did not exist in `D`''. The result in this example would be all the commits, except `A` and `B` (and `D` itself, of course)."
msgstr "有规律的 \"D...M \"会计算出作为`M`的祖先的提交集合，但不包括作为`D`的祖先的提交。这对了解`M'的历史在`D'之后发生了什么很有用，也就是说`M'有什么东西是`D'没有的'。这个例子中的结果是所有的提交，除了`A`和`B`（当然还有`D`本身）。"

#. type: Plain text
#: en/rev-list-options.txt:612
#, priority:260
msgid "When we want to find out what commits in `M` are contaminated with the bug introduced by `D` and need fixing, however, we might want to view only the subset of 'D..M' that are actually descendants of `D`, i.e.  excluding `C` and `K`. This is exactly what the `--ancestry-path` option does. Applied to the 'D..M' range, it results in:"
msgstr "然而，当我们想找出`M'中哪些提交被`D'引入的错误所污染而需要修复时，我们可能只想查看'D...M'中实际上是`D'的后代的子集，即排除`C'和`K'。这正是`--ancestry-path`选项的作用。应用于'D...M'范围，它的结果是："

#. type: delimited block -
#: en/rev-list-options.txt:619
#, no-wrap, priority:260
msgid ""
"\t\tE-------F\n"
"\t\t \\       \\\n"
"\t\t  G---H---I---J\n"
"\t\t\t       \\\n"
"\t\t\t\tL--M\n"
msgstr ""
"\t\tE-------F\n"
"\t\t \\ \\\n"
"\t\t  G--H--I--J\n"
"\t\t\t       \\\n"
"\t\t\t\tL--M\n"

#. type: Plain text
#: en/rev-list-options.txt:624
#, priority:260
msgid "We can also use `--ancestry-path=D` instead of `--ancestry-path` which means the same thing when applied to the 'D..M' range but is just more explicit."
msgstr "我们也可以用`--ancestry-path=D`来代替`--ancestry-path`，这在应用于'D...M'范围时意思相同，只是更加明确。"

#. type: Plain text
#: en/rev-list-options.txt:629
#, priority:260
msgid "If we instead are interested in a given topic within this range, and all commits affected by that topic, we may only want to view the subset of `D..M` which contain that topic in their ancestry path.  So, using `--ancestry-path=H D..M` for example would result in:"
msgstr "如果我们感兴趣的是这个范围内的某个主题，以及受该主题影响的所有提交，我们可能只想查看祖先路径中包含该主题的`D...M`子集。  因此，以`--ancestry-path=H D...M`为例，会形成以下结果："

#. type: delimited block -
#: en/rev-list-options.txt:636
#, no-wrap, priority:260
msgid ""
"\t\tE\n"
"\t\t \\\n"
"\t\t  G---H---I---J\n"
"\t\t\t       \\\n"
"\t\t\t\tL--M\n"
msgstr ""
"\t\tE\n"
"\t\t \\\n"
"\t\t  G---H---I---J\n"
"\t\t\t       \\\n"
"\t\t\t\tL--M\n"

#. type: Plain text
#: en/rev-list-options.txt:639
#, priority:260
msgid "Whereas `--ancestry-path=K D..M` would result in"
msgstr "而`--ancestry-path=K D...M`会形成以下结果"

#. type: delimited block -
#: en/rev-list-options.txt:642
#, no-wrap, priority:260
msgid "\t\tK---------------L--M\n"
msgstr "\t\tK---------------L--M\n"

#. type: Plain text
#: en/rev-list-options.txt:646
#, priority:260
msgid "Before discussing another option, `--show-pulls`, we need to create a new example history."
msgstr "在讨论另一个选项，`--show-pulls`之前，我们需要创建一个新的历史实例。"

#. type: Plain text
#: en/rev-list-options.txt:651
#, priority:260
msgid "A common problem users face when looking at simplified history is that a commit they know changed a file somehow does not appear in the file's simplified history. Let's demonstrate a new example and show how options such as `--full-history` and `--simplify-merges` works in that case:"
msgstr "用户在查看简化的提交历史时经常遇到的一个问题是，他们知道的对某个文件的修改提交并没有出现在该文件的简史中。让我们演示一个新的例子，并说明`--full-history`和`--simplify-merges`等选项在这种情况下是如何工作的："

#. type: delimited block -
#: en/rev-list-options.txt:659
#, no-wrap, priority:260
msgid ""
"\t  .-A---M-----C--N---O---P\n"
"\t /     / \\  \\  \\/   /   /\n"
"\tI     B   \\  R-'`-Z'   /\n"
"\t \\   /     \\/         /\n"
"\t  \\ /      /\\        /\n"
"\t   `---X--'  `---Y--'\n"
msgstr ""
"\t  .-A---M-----C--N---O---P\n"
"\t /     / \\  \\  \\/   /   /\n"
"\tI     B   \\  R-'`-Z'   /\n"
"\t \\   /     \\/         /\n"
"\t  \\ /      /\\        /\n"
"\t   `---X--'  `---Y--'\n"

#. type: Plain text
#: en/rev-list-options.txt:672
#, priority:260
msgid "For this example, suppose `I` created `file.txt` which was modified by `A`, `B`, and `X` in different ways. The single-parent commits `C`, `Z`, and `Y` do not change `file.txt`. The merge commit `M` was created by resolving the merge conflict to include both changes from `A` and `B` and hence is not TREESAME to either. The merge commit `R`, however, was created by ignoring the contents of `file.txt` at `M` and taking only the contents of `file.txt` at `X`. Hence, `R` is TREESAME to `X` but not `M`. Finally, the natural merge resolution to create `N` is to take the contents of `file.txt` at `R`, so `N` is TREESAME to `R` but not `C`.  The merge commits `O` and `P` are TREESAME to their first parents, but not to their second parents, `Z` and `Y` respectively."
msgstr "在这个例子中，假设`I`创建了`file.txt`，并被`A`、`B`和`X`以不同方式修改。单亲提交的`C`、`Z`和`Y`没有修改`file.txt`。合并提交 `M`是通过解决合并冲突而产生的，包括了 `A `和 `B `的修改，因此与其中任何一个都不是同源的。然而，合并提交`R`是通过忽略`M`处的`file.txt`的内容，而只采用`X`处的`file.txt`的内容而产生的。因此，`R`与`X`是同源的，但不是`M`。最后，创建`N'的自然合并决议是取`file.txt`在`R'的内容，所以`N'与`R`是同源的，但不是`C`。  合并提交的  `O` 和 `P` 与它们的第一代父母是同源的，但与它们的第二代父母 `Z` 和 `Y `则不是同源的。"

#. type: Plain text
#: en/rev-list-options.txt:676
#, priority:260
msgid "When using the default mode, `N` and `R` both have a TREESAME parent, so those edges are walked and the others are ignored. The resulting history graph is:"
msgstr "当使用默认模式时，`N'和`R`都有一个TREESAME父级，所以这些边被展示出来，其他边被忽略。由此产生的历史图是："

#. type: delimited block -
#: en/rev-list-options.txt:679
#, no-wrap, priority:260
msgid "\tI---X\n"
msgstr "\tI--X\n"

#. type: Plain text
#: en/rev-list-options.txt:684
#, priority:260
msgid "When using `--full-history`, Git walks every edge. This will discover the commits `A` and `B` and the merge `M`, but also will reveal the merge commits `O` and `P`. With parent rewriting, the resulting graph is:"
msgstr "当使用`--full-history`时，Git会行走每条边。这将发现提交`A`和`B`以及合并`M`，但也将揭示合并提交`O`和`P`。通过父级改写，得到的图是。"

#. type: delimited block -
#: en/rev-list-options.txt:692
#, fuzzy, no-wrap, priority:260
msgid ""
"\t  .-A---M--------N---O---P\n"
"\t /     / \\  \\  \\/   /   /\n"
"\tI     B   \\  R-'`--'   /\n"
"\t \\   /     \\/         /\n"
"\t  \\ /      /\\        /\n"
"\t   `---X--'  `------'\n"
msgstr ""
"\t  .-A---M--------N---O---P\n"
"\t /     / \\  \\  \\/   /   /\n"
"\tI     B   \\  R-'`--'   /\n"
"\t \\   /     \\/         /\n"
"\t  \\ /      /\\        /\n"
"\t   `---X--'  `------'\n"

#. type: Plain text
#: en/rev-list-options.txt:700
#, fuzzy, priority:260
#| msgid "Here, the merge commits `O` and `P` contribute extra noise, as they did not actually contribute a change to `file.txt`. They only merged a topic that was based on an older version of `file.txt`. This is a common issue in repositories using a workflow where many contributors work in parallel and merge their topic branches along a single trunk: manu unrelated merges appear in the `--full-history` results."
msgid "Here, the merge commits `O` and `P` contribute extra noise, as they did not actually contribute a change to `file.txt`. They only merged a topic that was based on an older version of `file.txt`. This is a common issue in repositories using a workflow where many contributors work in parallel and merge their topic branches along a single trunk: many unrelated merges appear in the `--full-history` results."
msgstr "这里，合并提交`O`和`P`带来了额外的噪音，因为它们实际上并没有对`file.txt`做出改变。他们只是合并了一个基于 \"file.txt \"旧版本的主题。这是在使用工作流程的仓库中常见的问题，在工作流程中，许多贡献者并行工作，并沿着一个主干合并他们的主题分支：不相关的合并出现在`--full-history`结果中。"

#. type: Plain text
#: en/rev-list-options.txt:707
#, priority:260
msgid "When using the `--simplify-merges` option, the commits `O` and `P` disappear from the results. This is because the rewritten second parents of `O` and `P` are reachable from their first parents. Those edges are removed and then the commits look like single-parent commits that are TREESAME to their parent. This also happens to the commit `N`, resulting in a history view as follows:"
msgstr "当使用`--简化合并`选项时，提交的`O`和`P`从结果中消失。这是因为 \"O \"和 \"P \"重写的第二父本可以从它们的第一父本到达。这些边被移除，然后这些提交看起来就像与它们的父类一样的单亲提交。这也发生在提交`N`上，导致历史视图如下。"

#. type: delimited block -
#: en/rev-list-options.txt:715
#, fuzzy, no-wrap, priority:260
msgid ""
"\t  .-A---M--.\n"
"\t /     /    \\\n"
"\tI     B      R\n"
"\t \\   /      /\n"
"\t  \\ /      /\n"
"\t   `---X--'\n"
msgstr ""
"\t  .-A---M--.\n"
"\t /     /    \\\n"
"\tI     B      R\n"
"\t \\   /      /\n"
"\t  \\ /      /\n"
"\t   `---X--'\n"

#. type: Plain text
#: en/rev-list-options.txt:722
#, priority:260
msgid "In this view, we see all of the important single-parent changes from `A`, `B`, and `X`. We also see the carefully-resolved merge `M` and the not-so-carefully-resolved merge `R`. This is usually enough information to determine why the commits `A` and `B` \"disappeared\" from history in the default view. However, there are a few issues with this approach."
msgstr "在这个视图中，我们看到了所有来自`A`，`B`和`X`的重要单亲变化。我们还可以看到仔细解决的合并`M`和不那么仔细解决的合并`R`。这些信息通常足以确定为什么`A`和`B`的提交在默认视图中从历史中 \"消失 \"了。然而，这种方法也有一些问题。"

#. type: Plain text
#: en/rev-list-options.txt:727
#, priority:260
msgid "The first issue is performance. Unlike any previous option, the `--simplify-merges` option requires walking the entire commit history before returning a single result. This can make the option difficult to use for very large repositories."
msgstr "第一个问题是性能。与之前的任何选项不同，`--简化合并'选项需要在返回一个结果之前走完整个提交历史。这可能使该选项难以用于非常大的仓库。"

#. type: Plain text
#: en/rev-list-options.txt:736
#, priority:260
msgid "The second issue is one of auditing. When many contributors are working on the same repository, it is important which merge commits introduced a change into an important branch. The problematic merge `R` above is not likely to be the merge commit that was used to merge into an important branch. Instead, the merge `N` was used to merge `R` and `X` into the important branch. This commit may have information about why the change `X` came to override the changes from `A` and `B` in its commit message."
msgstr "第二个问题是审计的问题。当许多贡献者在同一个版本库中工作时，哪些合并提交将一个变化引入到一个重要的分支是很重要的。上面有问题的合并`R`不可能是用来合并到一个重要分支的合并提交。相反，`N'是用来将`R'和`X'合并到重要分支的。这个提交可能有关于为什么`X'会覆盖`A'和`B'的修改的信息，在其提交信息中。"

#. type: Plain text
#: en/rev-list-options.txt:741
#, priority:260
msgid "In addition to the commits shown in the default history, show each merge commit that is not TREESAME to its first parent but is TREESAME to a later parent."
msgstr "除了在默认历史中显示的提交之外，还要显示每一个与第一个父本不相同但与后来的父本相同的合并提交。"

#. type: Plain text
#: en/rev-list-options.txt:746
#, priority:260
msgid "When a merge commit is included by `--show-pulls`, the merge is treated as if it \"pulled\" the change from another branch. When using `--show-pulls` on this example (and no other options) the resulting graph is:"
msgstr "当一个合并提交被`--show-pulls`包含时，该合并被视为从另一个分支 \"拉 \"来的修改。在这个例子中使用`--show-pulls`时（没有其他选项），得到的图表是。"

#. type: delimited block -
#: en/rev-list-options.txt:749
#, no-wrap, priority:260
msgid "\tI---X---R---N\n"
msgstr "\tI--X--R--N\n"

#. type: Plain text
#: en/rev-list-options.txt:755
#, priority:260
msgid "Here, the merge commits `R` and `N` are included because they pulled the commits `X` and `R` into the base branch, respectively. These merges are the reason the commits `A` and `B` do not appear in the default history."
msgstr "这里，合并后的提交`R`和`N`被包括在内，因为它们分别将提交`X`和`R`拉到了基础分支。这些合并是`A`和`B`的提交没有出现在默认历史中的原因。"

#. type: Plain text
#: en/rev-list-options.txt:758
#, priority:260
msgid "When `--show-pulls` is paired with `--simplify-merges`, the graph includes all of the necessary information:"
msgstr "当`--show-pulls`与`--simplify-merges`配对时，该图包括所有必要的信息。"

#. type: delimited block -
#: en/rev-list-options.txt:766
#, fuzzy, no-wrap, priority:260
msgid ""
"\t  .-A---M--.   N\n"
"\t /     /    \\ /\n"
"\tI     B      R\n"
"\t \\   /      /\n"
"\t  \\ /      /\n"
"\t   `---X--'\n"
msgstr ""
"\t  .-A---M--.   N\n"
"\t /     /    \\ /\n"
"\tI     B      R\n"
"\t \\   /      /\n"
"\t  \\ /      /\n"
"\t   `---X--'\n"

#. type: Plain text
#: en/rev-list-options.txt:772
#, priority:260
msgid "Notice that since `M` is reachable from `R`, the edge from `N` to `M` was simplified away. However, `N` still appears in the history as an important commit because it \"pulled\" the change `R` into the main branch."
msgstr "请注意，由于`M`可以从`R`到达，从`N`到`M`的边被简化掉了。然而，`N`仍然作为一个重要的提交出现在历史中，因为它把`R`的修改 \"拉 \"进了主分支。"

#. type: Plain text
#: en/rev-list-options.txt:780
#, priority:260
msgid "The `--simplify-by-decoration` option allows you to view only the big picture of the topology of the history, by omitting commits that are not referenced by tags.  Commits are marked as !TREESAME (in other words, kept after history simplification rules described above) if (1) they are referenced by tags, or (2) they change the contents of the paths given on the command line.  All other commits are marked as TREESAME (subject to be simplified away)."
msgstr "`--按装饰简化'选项允许你只查看历史拓扑的全貌，省略那些没有被标签引用的提交。  如果(1)提交被标签引用，或者(2)提交改变了命令行上给出的路径内容，则被标记为！TREESAME（换句话说，按照上述历史简化规则保留）。  所有其他的提交都被标记为TREESAME（会被简化掉）。"

#. type: Title ~
#: en/rev-list-options.txt:784
#, no-wrap, priority:260
msgid "Bisection Helpers"
msgstr "剖腹产助手"

#. type: Plain text
#: en/rev-list-options.txt:793
#, priority:260
msgid "Limit output to the one commit object which is roughly halfway between included and excluded commits. Note that the bad bisection ref `refs/bisect/bad` is added to the included commits (if it exists) and the good bisection refs `refs/bisect/good-*` are added to the excluded commits (if they exist). Thus, supposing there are no refs in `refs/bisect/`, if"
msgstr "将输出限制在一个提交对象上，该对象大致在包含和排除的提交之间。请注意，坏的分界参考`refs/bisect/bad`会被添加到包含的提交中（如果它存在的话），好的分界参考`refs/bisect/good-*`会被添加到排除的提交中（如果它们存在的话）。因此，假设`refs/bisect/`中没有参考文献，如果"

#. type: delimited block -
#: en/rev-list-options.txt:796
#, fuzzy, no-wrap, priority:260
msgid "\t$ git rev-list --bisect foo ^bar ^baz\n"
msgstr "\t$ git rev-list --bisect foo ^bar ^baz\n"

#. type: Plain text
#: en/rev-list-options.txt:799
#, priority:260
msgid "outputs 'midpoint', the output of the two commands"
msgstr "输出'midpoint'，即两个命令的输出。"

#. type: delimited block -
#: en/rev-list-options.txt:803
#, fuzzy, no-wrap, priority:260
msgid ""
"\t$ git rev-list foo ^midpoint\n"
"\t$ git rev-list midpoint ^bar ^baz\n"
msgstr ""
"\t$ git rev-list foo ^midpoint\n"
"\t$ git rev-list midpoint ^bar ^baz\n"

#. type: Plain text
#: en/rev-list-options.txt:809
#, priority:260
msgid "would be of roughly the same length.  Finding the change which introduces a regression is thus reduced to a binary search: repeatedly generate and test new 'midpoint's until the commit chain is of length one."
msgstr "的长度大致相同。  因此，找到引入回归的变化就变成了一个二进制搜索：反复生成和测试新的 \"中点\"，直到提交链的长度为1。"

#. type: Labeled list
#: en/rev-list-options.txt:810
#, ignore-same, no-wrap, priority:260
msgid "--bisect-vars"
msgstr "--bisect-vars"

#. type: Plain text
#: en/rev-list-options.txt:821
#, priority:260
msgid "This calculates the same as `--bisect`, except that refs in `refs/bisect/` are not used, and except that this outputs text ready to be eval'ed by the shell. These lines will assign the name of the midpoint revision to the variable `bisect_rev`, and the expected number of commits to be tested after `bisect_rev` is tested to `bisect_nr`, the expected number of commits to be tested if `bisect_rev` turns out to be good to `bisect_good`, the expected number of commits to be tested if `bisect_rev` turns out to be bad to `bisect_bad`, and the number of commits we are bisecting right now to `bisect_all`."
msgstr "这与`--bisect`的计算方法相同，只是不使用`refs/bisect/`中的参考文献，而且输出的文本可以被shell评估。这几行将把中点修订的名称分配给变量`bisect_rev`，并把`bisect_rev`测试后的预期提交数分配给`bisect_nr`。如果`bisect_rev'结果是好的，预计测试的提交数量为`bisect_good'，如果`bisect_rev'结果是坏的，预计测试的提交数量为`bisect_bad'，以及我们现在正在分叉的提交数量为`bisect_all'。"

#. type: Labeled list
#: en/rev-list-options.txt:822
#, ignore-same, no-wrap, priority:260
msgid "--bisect-all"
msgstr "--bisect-all"

#. type: Plain text
#: en/rev-list-options.txt:828
#, priority:260
msgid "This outputs all the commit objects between the included and excluded commits, ordered by their distance to the included and excluded commits. Refs in `refs/bisect/` are not used. The farthest from them is displayed first. (This is the only one displayed by `--bisect`.)"
msgstr "这将输出包含的提交和排除的提交之间的所有提交对象，按照它们与包含的提交和排除的提交的距离排序。`refs/bisect/`中的参考文献不被使用。离它们最远的会先显示出来。这也是`--bisect`唯一显示的对象）。"

#. type: Plain text
#: en/rev-list-options.txt:832
#, priority:260
msgid "This is useful because it makes it easy to choose a good commit to test when you want to avoid to test some of them for some reason (they may not compile for example)."
msgstr "这很有用，因为当你因为某些原因想避免测试某些提交时（例如，它们可能无法编译），可以很容易地选择一个好的提交来测试。"

#. type: Plain text
#: en/rev-list-options.txt:836
#, priority:260
msgid "This option can be used along with `--bisect-vars`, in this case, after all the sorted commit objects, there will be the same text as if `--bisect-vars` had been used alone."
msgstr "这个选项可以和`--bisect-vars`一起使用，在这种情况下，在所有排序的提交对象之后，会有和`--bisect-vars`单独使用一样的文本。"

#. type: Title ~
#: en/rev-list-options.txt:841
#, no-wrap, priority:260
msgid "Commit Ordering"
msgstr "承诺订购"

#. type: Plain text
#: en/rev-list-options.txt:844
#, priority:260
msgid "By default, the commits are shown in reverse chronological order."
msgstr "默认情况下，提交的内容是按时间顺序倒序显示的。"

#. type: Plain text
#: en/rev-list-options.txt:848
#, priority:260
msgid "Show no parents before all of its children are shown, but otherwise show commits in the commit timestamp order."
msgstr "在显示所有子代之前不显示父代，否则按提交时间戳顺序显示提交。"

#. type: Labeled list
#: en/rev-list-options.txt:849
#, ignore-same, no-wrap, priority:260
msgid "--author-date-order"
msgstr "--author-date-order"

#. type: Plain text
#: en/rev-list-options.txt:852
#, priority:260
msgid "Show no parents before all of its children are shown, but otherwise show commits in the author timestamp order."
msgstr "在显示所有子代之前不显示父代，否则按作者时间戳顺序显示提交。"

#. type: Plain text
#: en/rev-list-options.txt:857
#, priority:260
msgid "Show no parents before all of its children are shown, and avoid showing commits on multiple lines of history intermixed."
msgstr "在显示所有子代之前不显示父代，并避免显示多行历史交错的提交。"

#. type: Plain text
#: en/rev-list-options.txt:859
#, priority:260
msgid "For example, in a commit history like this:"
msgstr "例如，在这样的一个提交历史中。"

#. type: delimited block -
#: en/rev-list-options.txt:865
#, fuzzy, no-wrap, priority:260
msgid ""
"    ---1----2----4----7\n"
"\t\\\t       \\\n"
"\t 3----5----6----8---\n"
msgstr ""
"    ---1----2----4----7\n"
"\t\\\t       \\\n"
"\t 3----5----6----8---\n"

#. type: Plain text
#: en/rev-list-options.txt:871
#, priority:260
msgid "where the numbers denote the order of commit timestamps, `git rev-list` and friends with `--date-order` show the commits in the timestamp order: 8 7 6 5 4 3 2 1."
msgstr "其中数字表示提交时间戳的顺序，`git rev-list`和带有`--date-order`的朋友显示提交的时间戳顺序。8 7 6 5 4 3 2 1."

#. type: Plain text
#: en/rev-list-options.txt:876
#, priority:260
msgid "With `--topo-order`, they would show 8 6 5 3 7 4 2 1 (or 8 7 4 2 6 5 3 1); some older commits are shown before newer ones in order to avoid showing the commits from two parallel development track mixed together."
msgstr "如果使用`--topo-order`，它们会显示8 6 5 3 7 4 2 1（或8 7 4 2 6 5 3 1）；一些较早的提交会显示在较新的提交之前，以避免显示两个平行开发轨道的提交混在一起。"

#. type: Plain text
#: en/rev-list-options.txt:881
#, priority:260
msgid "Output the commits chosen to be shown (see Commit Limiting section above) in reverse order. Cannot be combined with `--walk-reflogs`."
msgstr "以相反的顺序输出选择显示的提交（见上面的提交限制部分）。不能与`--walk-reflogs`结合使用。"

#. type: Title ~
#: en/rev-list-options.txt:885
#, no-wrap, priority:260
msgid "Object Traversal"
msgstr "对象遍历"

#. type: Plain text
#: en/rev-list-options.txt:888
#, priority:260
msgid "These options are mostly targeted for packing of Git repositories."
msgstr "这些选项主要是针对Git存储库的打包。"

#. type: Labeled list
#: en/rev-list-options.txt:890
#, ignore-same, no-wrap, priority:260
msgid "--objects"
msgstr "--objects"

#. type: Plain text
#: en/rev-list-options.txt:895
#, fuzzy, priority:260
#| msgid "Print the object IDs of any object referenced by the listed commits.  `--objects foo ^bar` thus means ``send me all object IDs which I need to download if I have the commit object _bar_ but not _foo_''."
msgid "Print the object IDs of any object referenced by the listed commits.  `--objects foo ^bar` thus means ``send me all object IDs which I need to download if I have the commit object _bar_ but not _foo_''. See also `--object-names` below."
msgstr "打印列出的提交对象所引用的任何对象的ID。  `--objects foo ^bar`因此意味着`给我发送所有我需要下载的对象ID，如果我有提交对象_bar_但没有_foo_的话'。"

#. type: Labeled list
#: en/rev-list-options.txt:896
#, ignore-same, no-wrap, priority:260
msgid "--in-commit-order"
msgstr "--in-commit-order"

#. type: Plain text
#: en/rev-list-options.txt:900
#, priority:260
msgid "Print tree and blob ids in order of the commits. The tree and blob ids are printed after they are first referenced by a commit."
msgstr "按照提交的顺序打印树和blob的id。树和blob的id会在它们第一次被提交者引用后打印。"

#. type: Labeled list
#: en/rev-list-options.txt:901
#, ignore-same, no-wrap, priority:260
msgid "--objects-edge"
msgstr "--objects-edge"

#. type: Plain text
#: en/rev-list-options.txt:907
#, priority:260
msgid "Similar to `--objects`, but also print the IDs of excluded commits prefixed with a ``-'' character.  This is used by linkgit:git-pack-objects[1] to build a ``thin'' pack, which records objects in deltified form based on objects contained in these excluded commits to reduce network traffic."
msgstr "类似于 `--objects`，但也会打印被排除的提交物的 ID，前缀为 `-''字符。  这被 linkgit:git-pack-objects[1] 用来建立一个 \"瘦身 \"包，它基于这些被排除的提交中包含的对象，以删除的形式记录对象，以减少网络流量。"

#. type: Labeled list
#: en/rev-list-options.txt:908
#, ignore-same, no-wrap, priority:260
msgid "--objects-edge-aggressive"
msgstr "--objects-edge-aggressive"

#. type: Plain text
#: en/rev-list-options.txt:912
#, priority:260
msgid "Similar to `--objects-edge`, but it tries harder to find excluded commits at the cost of increased time.  This is used instead of `--objects-edge` to build ``thin'' packs for shallow repositories."
msgstr "类似于 `--objects-edge`，但它更努力地寻找被排除的提交，代价是增加时间。  它被用来代替`--objects-edge`，为浅层仓库建立 \"薄 \"的包。"

#. type: Labeled list
#: en/rev-list-options.txt:913
#, ignore-same, no-wrap, priority:260
msgid "--indexed-objects"
msgstr "--indexed-objects"

#. type: Plain text
#: en/rev-list-options.txt:917
#, priority:260
msgid "Pretend as if all trees and blobs used by the index are listed on the command line.  Note that you probably want to use `--objects`, too."
msgstr "假设索引使用的所有树和blobs都列在命令行中。  注意，你可能也想使用`--objects`。"

#. type: Plain text
#: en/rev-list-options.txt:921
#, priority:260
msgid "Only useful with `--objects`; print the object IDs that are not in packs."
msgstr "只对`---对象`有用；打印不在包中的对象ID。"

#. type: Labeled list
#: en/rev-list-options.txt:922
#, ignore-same, no-wrap, priority:260
msgid "--object-names"
msgstr "--object-names"

#. type: Plain text
#: en/rev-list-options.txt:930
#, priority:260
msgid "Only useful with `--objects`; print the names of the object IDs that are found. This is the default behavior. Note that the \"name\" of each object is ambiguous, and mostly intended as a hint for packing objects. In particular: no distinction is made between the names of tags, trees, and blobs; path names may be modified to remove newlines; and if an object would appear multiple times with different names, only one name is shown."
msgstr "只对 `--objects` 有用；打印找到的对象ID的名称。这是默认的行为。注意，每个对象的 \"名字\" 是模糊的，主要是作为打包对象的提示。特别是：标签、树和二进制文件的名字不作区分；路径名称可以被修改以删除换行；如果一个对象会以不同的名字出现多次，则只显示一个名字。"

#. type: Labeled list
#: en/rev-list-options.txt:931
#, ignore-same, no-wrap, priority:260
msgid "--no-object-names"
msgstr "--no-object-names"

#. type: Plain text
#: en/rev-list-options.txt:936
#, priority:260
msgid "Only useful with `--objects`; does not print the names of the object IDs that are found. This inverts `--object-names`. This flag allows the output to be more easily parsed by commands such as linkgit:git-cat-file[1]."
msgstr "只对`--对象`有用；不打印找到的对象ID的名称。这与`--object-names`相反。这个标志允许输出更容易被linkgit:git-cat-file[1]等命令解析。"

#. type: Plain text
#: en/rev-list-options.txt:941
#, priority:260
msgid "Only useful with one of the `--objects*`; omits objects (usually blobs) from the list of printed objects.  The '<filter-spec>' may be one of the following:"
msgstr "只对其中一个`--objects*`有用；从打印对象列表中省略对象（通常是blobs）。  <filter-spec>'可以是下列之一。"

#. type: Plain text
#: en/rev-list-options.txt:943
#, priority:260
msgid "The form '--filter=blob:none' omits all blobs."
msgstr "'--filter=blob:none'的形式可以省略所有的blob。"

#. type: Plain text
#: en/rev-list-options.txt:948
#, priority:260
msgid "The form '--filter=blob:limit=<n>[kmg]' omits blobs larger than n bytes or units.  n may be zero.  The suffixes k, m, and g can be used to name units in KiB, MiB, or GiB.  For example, 'blob:limit=1k' is the same as 'blob:limit=1024'."
msgstr "'--filter=blob:limit=<n>[kmg]'的形式可以省略大于n个字节或单位的blob，n可以是0。  后缀k、m和g可以用来命名KiB、MiB或GiB等单位。  例如，'blob:limit=1k'和'blob:limit=1024'是一样的。"

#. type: Plain text
#: en/rev-list-options.txt:951
#, priority:260
msgid "The form '--filter=object:type=(tag|commit|tree|blob)' omits all objects which are not of the requested type."
msgstr "'--filter=object:type=(tag|commit|tree|blob)'的形式会省略所有不属于请求类型的对象。"

#. type: Plain text
#: en/rev-list-options.txt:956
#, fuzzy, priority:260
#| msgid "The form '--filter=sparse:oid=<blob-ish>' uses a sparse-checkout specification contained in the blob (or blob-expression) '<blob-ish>' to omit blobs that would not be not required for a sparse checkout on the requested refs."
msgid "The form '--filter=sparse:oid=<blob-ish>' uses a sparse-checkout specification contained in the blob (or blob-expression) '<blob-ish>' to omit blobs that would not be required for a sparse checkout on the requested refs."
msgstr "形式'--filter=sparse:oid=<blob-ish>'使用包含在blob（或blob表达式）'<blob-ish>'中的稀疏检出规范来省略那些对请求的 refs 进行稀疏检出时不需要的 blobs。"

#. type: Plain text
#: en/rev-list-options.txt:966
#, priority:260
msgid "The form '--filter=tree:<depth>' omits all blobs and trees whose depth from the root tree is >= <depth> (minimum depth if an object is located at multiple depths in the commits traversed). <depth>=0 will not include any trees or blobs unless included explicitly in the command-line (or standard input when --stdin is used). <depth>=1 will include only the tree and blobs which are referenced directly by a commit reachable from <commit> or an explicitly-given object. <depth>=2 is like <depth>=1 while also including trees and blobs one more level removed from an explicitly-given commit or tree."
msgstr "'--filter=tree:<depth>'的形式省略了所有从根树开始深度>=<depth>（如果一个对象在所穿越的提交中位于多个深度，则为最小深度）的blobs和树。<depth>=0 将不包括任何树或blobs，除非在命令行中明确包括（或使用-stdin时的标准输入）。<depth>=1 将只包括由<commit>或明确指定的对象所能到达的提交直接引用的树和blobs。<深度>=2与<深度>=1类似，同时也包括从明确给出的提交或树中移出的多一级的树和blobs。"

#. type: Plain text
#: en/rev-list-options.txt:970
#, priority:260
msgid "Note that the form '--filter=sparse:path=<path>' that wants to read from an arbitrary path on the filesystem has been dropped for security reasons."
msgstr "注意，出于安全原因，想要从文件系统上的任意路径读取的'--过滤器=sparse:path=<path>'形式已经被放弃了。"

#. type: Plain text
#: en/rev-list-options.txt:973
#, priority:260
msgid "Multiple '--filter=' flags can be specified to combine filters. Only objects which are accepted by every filter are included."
msgstr "可以指定多个'--过滤器='标志来组合过滤器。只有那些被每个过滤器接受的对象才会被包括在内。"

#. type: Plain text
#: en/rev-list-options.txt:982
#, ignore-ellipsis, priority:260
msgid "The form '--filter=combine:<filter1>+<filter2>+...<filterN>' can also be used to combined several filters, but this is harder than just repeating the '--filter' flag and is usually not necessary. Filters are joined by '{plus}' and individual filters are %-encoded (i.e. URL-encoded).  Besides the '{plus}' and '%' characters, the following characters are reserved and also must be encoded: `~!@#$^&*()[]{}\\;\",<>?`+&#39;&#96;+ as well as all characters with ASCII code &lt;= `0x20`, which includes space and newline."
msgstr "'--filter=combine:<filter1>+<filter2>+...<filterN>'的形式也可以用来组合几个过滤器，但这比重复'--filter'标志要难，通常没有必要。过滤器用'{plus}'连接，单个过滤器用%编码（即用URL编码）。  除了'{plus}'和'%'字符，以下字符是保留字符，也必须进行编码：`~！@#$^&*()[]{}/;\",<>?`+&#39;&#96;+以及所有ASCII代码为&lt;=`0x20`的字符，其中包括空格和换行。"

#. type: Plain text
#: en/rev-list-options.txt:986
#, priority:260
msgid "Other arbitrary characters can also be encoded. For instance, 'combine:tree:3+blob:none' and 'combine:tree%3A3+blob%3Anone' are equivalent."
msgstr "其他任意的字符也可以被编码。例如，'combined:tree:3+blob:none'和'combined:tree%3A3+blob%3Anone'是等同的。"

#. type: Plain text
#: en/rev-list-options.txt:989
#, priority:260
msgid "Turn off any previous `--filter=` argument."
msgstr "关掉之前的任何`--filter=`参数。"

#. type: Labeled list
#: en/rev-list-options.txt:990
#, ignore-same, no-wrap, priority:260
msgid "--filter-provided-objects"
msgstr "--filter-provided-objects"

#. type: Plain text
#: en/rev-list-options.txt:994
#, priority:260
msgid "Filter the list of explicitly provided objects, which would otherwise always be printed even if they did not match any of the filters. Only useful with `--filter=`."
msgstr "过滤明确提供的对象的列表，否则，即使它们不符合任何过滤器，也会被打印出来。只对`--filter=`有用。"

#. type: Labeled list
#: en/rev-list-options.txt:995
#, ignore-same, no-wrap, priority:260
msgid "--filter-print-omitted"
msgstr "--filter-print-omitted"

#. type: Plain text
#: en/rev-list-options.txt:998
#, priority:260
msgid "Only useful with `--filter=`; prints a list of the objects omitted by the filter.  Object IDs are prefixed with a ``~'' character."
msgstr "只对`--filter=`有用；打印出被过滤器省略的对象的列表。  对象ID的前缀是``~''字符。"

#. type: Plain text
#: en/rev-list-options.txt:1005
#, priority:260
msgid "The form '--missing=error' requests that rev-list stop with an error if a missing object is encountered.  This is the default action."
msgstr "形式'--missing=error'要求rev-list在遇到丢失的对象时以错误方式停止。  这是默认动作。"

#. type: Plain text
#: en/rev-list-options.txt:1009
#, priority:260
msgid "The form '--missing=allow-any' will allow object traversal to continue if a missing object is encountered.  Missing objects will silently be omitted from the results."
msgstr "'--missing=allow-any'的形式将允许在遇到缺失对象时继续进行对象遍历。  缺少的对象将被默默地从结果中省略掉。"

#. type: Plain text
#: en/rev-list-options.txt:1013
#, priority:260
msgid "The form '--missing=allow-promisor' is like 'allow-any', but will only allow object traversal to continue for EXPECTED promisor missing objects.  Unexpected missing objects will raise an error."
msgstr "'--missing=allow-promisor'的形式与'allow-any'相似，但只允许对预期的promisor缺失对象继续进行遍历。  意外的缺失对象将引发一个错误。"

#. type: Plain text
#: en/rev-list-options.txt:1016
#, priority:260
msgid "The form '--missing=print' is like 'allow-any', but will also print a list of the missing objects.  Object IDs are prefixed with a ``?'' character."
msgstr "'--missing=print'的形式与'allow-any'相似，但也会打印出遗失对象的列表。  对象ID的前缀是\"？\"。"

#. type: Plain text
#: en/rev-list-options.txt:1023
#, priority:260
msgid "(For internal use only.)  Prefilter object traversal at promisor boundary.  This is used with partial clone.  This is stronger than `--missing=allow-promisor` because it limits the traversal, rather than just silencing errors about missing objects."
msgstr "仅供内部使用。）在希望者边界预过滤对象的遍历。  这是与部分克隆一起使用的。  这比`--missing=allow-promisor`更强，因为它限制了遍历，而不仅仅是消除了关于丢失对象的错误。"

#. type: Labeled list
#: en/rev-list-options.txt:1025
#, fuzzy, no-wrap, priority:260
msgid "--no-walk[=(sorted|unsorted)]"
msgstr "--no-walk[=(sorted|unsorted)]"

#. type: Plain text
#: en/rev-list-options.txt:1033
#, fuzzy, priority:260
#| msgid "Only show the given commits, but do not traverse their ancestors.  This has no effect if a range is specified. If the argument `unsorted` is given, the commits are shown in the order they were given on the command line. Otherwise (if `sorted` or no argument was given), the commits are shown in reverse chronological order by commit time.  Cannot be combined with `--graph`."
msgid "Only show the given commits, but do not traverse their ancestors.  This has no effect if a range is specified. If the argument `unsorted` is given, the commits are shown in the order they were given on the command line. Otherwise (if `sorted` or no argument was given), the commits are shown in reverse chronological order by commit time.  Cannot be combined with `--graph`."
msgstr "只显示给定的提交，但不遍历其祖先。  如果指定了范围，这一点就没有影响。如果给了参数`unsorted`，提交会按照命令行上的顺序显示。否则（如果`sorted`或者没有给出参数），提交将按照提交时间的倒序显示。  不能与`--graph`结合使用。"

#. type: Labeled list
#: en/rev-list-options.txt:1034
#, ignore-same, no-wrap, priority:260
msgid "--do-walk"
msgstr "--do-walk"

#. type: Plain text
#: en/rev-list-options.txt:1036
#, priority:260
msgid "Overrides a previous `--no-walk`."
msgstr "覆盖之前的`--不走'。"

#. type: Title ~
#: en/rev-list-options.txt:1040
#, no-wrap, priority:260
msgid "Commit Formatting"
msgstr "承诺格式化"

#. type: Plain text
#: en/rev-list-options.txt:1046
#, priority:260
msgid "Using these options, linkgit:git-rev-list[1] will act similar to the more specialized family of commit log tools: linkgit:git-log[1], linkgit:git-show[1], and linkgit:git-whatchanged[1]"
msgstr "使用这些选项，linkgit:git-rev-list[1] 的作用类似于更专业的提交日志工具系列：linkgit:git-log[1]，linkgit:git-show[1]，和linkgit:git-whatchanged[1] 。"

#. type: Labeled list
#: en/rev-list-options.txt:1050
#, ignore-same, no-wrap, priority:260
msgid "--relative-date"
msgstr "--relative-date"

#. type: Plain text
#: en/rev-list-options.txt:1052
#, priority:260
msgid "Synonym for `--date=relative`."
msgstr "`--date=relative`的同义词。"

#. type: Plain text
#: en/rev-list-options.txt:1060
#, priority:260
msgid "Only takes effect for dates shown in human-readable format, such as when using `--pretty`. `log.date` config variable sets a default value for the log command's `--date` option. By default, dates are shown in the original time zone (either committer's or author's). If `-local` is appended to the format (e.g., `iso-local`), the user's local time zone is used instead."
msgstr "只对以人类可读格式显示的日期生效，例如使用`--pretty`时。`log.date`配置变量为日志命令的`--date`选项设置默认值。默认情况下，日期显示在原始时区（提交者或作者的时区）。如果`-local`被附加到格式中（例如，`iso-local`），就会使用用户的本地时区。"

#. type: Plain text
#: en/rev-list-options.txt:1065
#, priority:260
msgid "`--date=relative` shows dates relative to the current time, e.g. ``2 hours ago''. The `-local` option has no effect for `--date=relative`."
msgstr "`--date=relative`显示相对于当前时间的日期，例如：`2小时前''。`--local`选项对`--date=relative`没有影响。"

#. type: Plain text
#: en/rev-list-options.txt:1067
#, priority:260
msgid "`--date=local` is an alias for `--date=default-local`."
msgstr "`--date=local`是`--date=default-local`的一个别名。"

#. type: Plain text
#: en/rev-list-options.txt:1070
#, priority:260
msgid "`--date=iso` (or `--date=iso8601`) shows timestamps in a ISO 8601-like format.  The differences to the strict ISO 8601 format are:"
msgstr "`--date=iso`（或`--date=iso8601`）以类似ISO 8601的格式显示时间戳。  与严格的ISO 8601格式的区别是。"

#. type: Plain text
#: en/rev-list-options.txt:1072
#, priority:260
msgid "a space instead of the `T` date/time delimiter"
msgstr "用空格代替`T`日期/时间分隔符"

#. type: Plain text
#: en/rev-list-options.txt:1073
#, priority:260
msgid "a space between time and time zone"
msgstr "时间和时区之间的空间"

#. type: Plain text
#: en/rev-list-options.txt:1074
#, priority:260
msgid "no colon between hours and minutes of the time zone"
msgstr "时区的小时和分钟之间没有冒号"

#. type: Plain text
#: en/rev-list-options.txt:1077
#, priority:260
msgid "`--date=iso-strict` (or `--date=iso8601-strict`) shows timestamps in strict ISO 8601 format."
msgstr "`--date=iso-strict`（或`--date=iso8601-strict`）显示严格的ISO 8601格式的时间戳。"

#. type: Plain text
#: en/rev-list-options.txt:1080
#, priority:260
msgid "`--date=rfc` (or `--date=rfc2822`) shows timestamps in RFC 2822 format, often found in email messages."
msgstr "`--date=rfc`（或`--date=rfc2822`）显示RFC 2822格式的时间戳，经常出现在电子邮件中。"

#. type: Plain text
#: en/rev-list-options.txt:1082
#, priority:260
msgid "`--date=short` shows only the date, but not the time, in `YYYY-MM-DD` format."
msgstr "`--date=short`只显示日期，而不是时间，格式为`YYYY-MM-DD`。"

#. type: Plain text
#: en/rev-list-options.txt:1091
#, priority:260
msgid "`--date=raw` shows the date as seconds since the epoch (1970-01-01 00:00:00 UTC), followed by a space, and then the timezone as an offset from UTC (a `+` or `-` with four digits; the first two are hours, and the second two are minutes). I.e., as if the timestamp were formatted with `strftime(\"%s %z\")`).  Note that the `-local` option does not affect the seconds-since-epoch value (which is always measured in UTC), but does switch the accompanying timezone value."
msgstr "`--date=raw`显示日期为自纪元以来的秒数（1970-01-01 00:00:00 UTC），后面是空格，然后是时区为UTC的偏移量（一个`+`或`-`的四位数字；前两位是小时，后两位是分钟）。也就是说，就像时间戳的格式为`strftime(\"%s %z\")`)。  请注意，`-local`选项不影响自始至终的秒数值（它总是以UTC为单位），但会切换伴随的时区值。"

#. type: Plain text
#: en/rev-list-options.txt:1098
#, priority:260
msgid "`--date=human` shows the timezone if the timezone does not match the current time-zone, and doesn't print the whole date if that matches (ie skip printing year for dates that are \"this year\", but also skip the whole date itself if it's in the last few days and we can just say what weekday it was).  For older dates the hour and minute is also omitted."
msgstr "`--date=human`如果时区与当前时区不匹配，则显示时区，如果匹配则不打印整个日期（即对于 \"今年 \"的日期，跳过打印年份，但如果是最近几天的日期，也跳过整个日期本身，我们可以只说是哪个工作日）。  对于较早的日期，小时和分钟也被省略了。"

#. type: Plain text
#: en/rev-list-options.txt:1102
#, priority:260
msgid "`--date=unix` shows the date as a Unix epoch timestamp (seconds since 1970).  As with `--raw`, this is always in UTC and therefore `-local` has no effect."
msgstr "`--date=unix`显示日期为Unix纪元时间戳（自1970年以来的秒数）。  与`--raw`一样，这总是以UTC为单位，因此`--local`没有影响。"

#. type: Plain text
#: en/rev-list-options.txt:1109
#, fuzzy, ignore-ellipsis, priority:260
msgid "`--date=format:...` feeds the format `...` to your system `strftime`, except for %s, %z, and %Z, which are handled internally.  Use `--date=format:%c` to show the date in your system locale's preferred format.  See the `strftime` manual for a complete list of format placeholders. When using `-local`, the correct syntax is `--date=format-local:...`."
msgstr "`--date=format:...` feeds the format `...` to your system `strftime`, except for %z and %Z, which are handled internally.  Use `--date=format:%c` to show the date in your system locale's preferred format.  See the `strftime` manual for a complete list of format placeholders. When using `-local`, the correct syntax is `--date=format-local:...`."

#. type: Plain text
#: en/rev-list-options.txt:1115
#, priority:260
msgid "`--date=default` is the default format, and is based on ctime(3)  output.  It shows a single line with three-letter day of the week, three-letter month, day-of-month, hour-minute-seconds in \"HH:MM:SS\" format, followed by 4-digit year, plus timezone information, unless the local time zone is used, e.g. `Thu Jan 1 00:00:00 1970 +0000`."
msgstr "`--date=default`是默认格式，基于ctime(3)输出。  它仅仅在一行中显示缩写的星期、缩写的月份、一月中的第几天、\"HH:MM:SS \"格式的小时-分钟-秒，然后是年份，除非使用本地时区，在末尾都会加上时区信息，例如`Thu Jan 1 00:00:00 1970 +0000`。"

#. type: Labeled list
#: en/rev-list-options.txt:1118
#, ignore-same, no-wrap, priority:260
msgid "--header"
msgstr "--header"

#. type: Plain text
#: en/rev-list-options.txt:1121
#, priority:260
msgid "Print the contents of the commit in raw-format; each record is separated with a NUL character."
msgstr "以原始格式打印提交的内容；每条记录用NUL字符分隔。"

#. type: Labeled list
#: en/rev-list-options.txt:1122
#, ignore-same, no-wrap, priority:260
msgid "--no-commit-header"
msgstr "--no-commit-header"

#. type: Plain text
#: en/rev-list-options.txt:1126
#, priority:260
msgid "Suppress the header line containing \"commit\" and the object ID printed before the specified format.  This has no effect on the built-in formats; only custom formats are affected."
msgstr "抑制包含“提交”的标题行和在指定格式之前打印的对象 ID。这对内置格式没有影响；只有自定义格式会受到影响。"

#. type: Labeled list
#: en/rev-list-options.txt:1127
#, ignore-same, no-wrap, priority:260
msgid "--commit-header"
msgstr "--commit-header"

#. type: Plain text
#: en/rev-list-options.txt:1129
#, fuzzy, priority:260
#| msgid "Overrides a previous `--no-walk`."
msgid "Overrides a previous `--no-commit-header`."
msgstr "覆盖之前的`--不走'。"

#. type: Plain text
#: en/rev-list-options.txt:1134
#, ignore-ellipsis, priority:260
msgid "Print also the parents of the commit (in the form \"commit parent...\").  Also enables parent rewriting, see 'History Simplification' above."
msgstr "也可以打印提交的父类（以 \"提交父类... \"的形式）。  也可以启用父级改写，见上面的 \"历史简化\"。"

#. type: Labeled list
#: en/rev-list-options.txt:1135
#, ignore-same, no-wrap, priority:260
msgid "--children"
msgstr "--children"

#. type: Plain text
#: en/rev-list-options.txt:1138
#, ignore-ellipsis, priority:260
msgid "Print also the children of the commit (in the form \"commit child...\").  Also enables parent rewriting, see 'History Simplification' above."
msgstr "同时打印提交的子项（以 \"提交子项... \"的形式）。  也可以启用父级改写，见上面的 \"历史简化\"。"

#. type: Labeled list
#: en/rev-list-options.txt:1140
#, ignore-same, no-wrap, priority:260
msgid "--timestamp"
msgstr "--timestamp"

#. type: Plain text
#: en/rev-list-options.txt:1142
#, priority:260
msgid "Print the raw commit timestamp."
msgstr "打印原始提交时间戳。"

#. type: Labeled list
#: en/rev-list-options.txt:1144
#, ignore-same, no-wrap, priority:260
msgid "--left-right"
msgstr "--left-right"

#. type: Plain text
#: en/rev-list-options.txt:1149
#, priority:260
msgid "Mark which side of a symmetric difference a commit is reachable from.  Commits from the left side are prefixed with `<` and those from the right with `>`.  If combined with `--boundary`, those commits are prefixed with `-`."
msgstr "标明提交可以从对称性差异的哪一边到达。  左边的提交以`<`为前缀，右边的则以`>`为前缀。  如果与\"--边界 \"结合，这些提交的前缀为\"-\"。"

#. type: Plain text
#: en/rev-list-options.txt:1151
#, priority:260
msgid "For example, if you have this topology:"
msgstr "例如，如果你有这样的拓扑结构。"

#. type: delimited block -
#: en/rev-list-options.txt:1158
#, fuzzy, no-wrap, priority:260
msgid ""
"\t     y---b---b  branch B\n"
"\t    / \\ /\n"
"\t   /   .\n"
"\t  /   / \\\n"
"\t o---x---a---a  branch A\n"
msgstr ""
"\t     y---b---b  branch B\n"
"\t    / \\ /\n"
"\t   /   .\n"
"\t  /   / \\\n"
"\t o---x---a---a  branch A\n"

#. type: Plain text
#: en/rev-list-options.txt:1161
#, priority:260
msgid "you would get an output like this:"
msgstr "你会得到这样的输出。"

#. type: delimited block -
#: en/rev-list-options.txt:1164
#, fuzzy, ignore-ellipsis, no-wrap, priority:260
msgid "\t$ git rev-list --left-right --boundary --pretty=oneline A...B\n"
msgstr "\t$ git rev-list --left-right --boundary --pretty=oneline A...B\n"

#. type: delimited block -
#: en/rev-list-options.txt:1171
#, fuzzy, ignore-ellipsis, no-wrap, priority:260
msgid ""
"\t>bbbbbbb... 3rd on b\n"
"\t>bbbbbbb... 2nd on b\n"
"\t<aaaaaaa... 3rd on a\n"
"\t<aaaaaaa... 2nd on a\n"
"\t-yyyyyyy... 1st on b\n"
"\t-xxxxxxx... 1st on a\n"
msgstr ""
"\t>bbbbbbb... 3rd on b\n"
"\t>bbbbbbb... 2nd on b\n"
"\t<aaaaaaa... 3rd on a\n"
"\t<aaaaaaa... 2nd on a\n"
"\t-yyyyyyy... 1st on b\n"
"\t-xxxxxxx... 1st on a\n"

#. type: Labeled list
#: en/rev-list-options.txt:1173
#, ignore-same, no-wrap, priority:260
msgid "--graph"
msgstr "--graph"

#. type: Plain text
#: en/rev-list-options.txt:1179
#, priority:260
msgid "Draw a text-based graphical representation of the commit history on the left hand side of the output.  This may cause extra lines to be printed in between commits, in order for the graph history to be drawn properly.  Cannot be combined with `--no-walk`."
msgstr "在输出的左手边绘制基于文本的提交历史图表。  这可能会导致在提交之间打印出额外的行，以便正确地绘制图形历史。  不能与`--no-walk`结合使用。"

#. type: Plain text
#: en/rev-list-options.txt:1181
#, priority:260
msgid "This enables parent rewriting, see 'History Simplification' above."
msgstr "这可以使父代改写，见上面的'历史简化'。"

#. type: Plain text
#: en/rev-list-options.txt:1184
#, priority:260
msgid "This implies the `--topo-order` option by default, but the `--date-order` option may also be specified."
msgstr "这意味着默认情况下是`--topo-order`选项，但也可以指定`--date-order`选项。"

#. type: Labeled list
#: en/rev-list-options.txt:1185
#, fuzzy, no-wrap, priority:260
msgid "--show-linear-break[=<barrier>]"
msgstr "--show-linear-break[=<barrier>]"

#. type: Plain text
#: en/rev-list-options.txt:1191
#, priority:260
msgid "When --graph is not used, all history branches are flattened which can make it hard to see that the two consecutive commits do not belong to a linear branch. This option puts a barrier in between them in that case. If `<barrier>` is specified, it is the string that will be shown instead of the default one."
msgstr "如果不使用 --graph，所有的历史分支都会被压扁，这就很难看出两个连续的提交并不属于一个线性分支。在这种情况下，该选项会在它们之间设置一个障碍。如果指定了\"<barrier>\"，就会显示这个字符串，而不是默认的。"

#. type: Plain text
#: en/rev-list-options.txt:1201
#, priority:260
msgid "Print a number stating how many commits would have been listed, and suppress all other output.  When used together with `--left-right`, instead print the counts for left and right commits, separated by a tab. When used together with `--cherry-mark`, omit patch equivalent commits from these counts and print the count for equivalent commits separated by a tab."
msgstr "打印一个数字，说明有多少提交会被列出，并抑制所有其他输出。  当与`--左--右'一起使用时，会打印左和右的提交计数，用制表符分开。当与`--cherry-mark`一起使用时，从这些计数中省略补丁等价提交，而打印等价提交的计数，用tab分隔。"

#. type: Plain text
#: en/sequencer.txt:5
#, priority:100
msgid "Continue the operation in progress using the information in `.git/sequencer`.  Can be used to continue after resolving conflicts in a failed cherry-pick or revert."
msgstr "使用`.git/sequencer`中的信息继续进行中的操作。  可以用来在解决拣选或还原失败的冲突后继续执行。"

#. type: Plain text
#: en/sequencer.txt:9
#, priority:100
msgid "Skip the current commit and continue with the rest of the sequence."
msgstr "跳过当前的提交，继续进行队列中其余的命令。"

#. type: Plain text
#: en/sequencer.txt:14
#, priority:100
msgid "Forget about the current operation in progress.  Can be used to clear the sequencer state after a failed cherry-pick or revert."
msgstr "忽略当前正在进行的操作。  可以用来在拣选或还原失败之后清除序列器的状态。"

#. type: Plain text
#: en/sequencer.txt:16
#, priority:100
msgid "Cancel the operation and return to the pre-sequence state."
msgstr "取消操作并返回到预排序状态。"

#. type: Labeled list
#: en/signoff-option.txt:5
#, ignore-same, no-wrap, priority:280
msgid "--no-signoff"
msgstr "--no-signoff"

#. type: Plain text
#: en/signoff-option.txt:16
#, priority:280
msgid "Add a `Signed-off-by` trailer by the committer at the end of the commit log message.  The meaning of a signoff depends on the project to which you're committing.  For example, it may certify that the committer has the rights to submit the work under the project's license or agrees to some contributor representation, such as a Developer Certificate of Origin.  (See http://developercertificate.org for the one used by the Linux kernel and Git projects.)  Consult the documentation or leadership of the project to which you're contributing to understand how the signoffs are used in that project."
msgstr "在提交日志信息的末尾添加提交者的 \"Signed-off-by \"预告片。  签名的意义取决于你所提交的项目。  例如，它可以证明提交者有权利在项目许可下提交作品，或者同意一些贡献者的陈述，如开发者的原产地证书。  关于Linux内核和Git项目使用的证书，请参见http://developercertificate.org）。  请查阅你要贡献的项目的文档或领导层，以了解该项目如何使用签名。"

#. type: Plain text
#: en/signoff-option.txt:18
#, priority:280
msgid "The --no-signoff option can be used to countermand an earlier --signoff option on the command line."
msgstr "--no-signoff选项可以用来反驳先前在命令行上的-signoff选项。"

#. type: Plain text
#: en/transfer-data-leaks.txt:11
#, priority:220
msgid "The fetch and push protocols are not designed to prevent one side from stealing data from the other repository that was not intended to be shared. If you have private data that you need to protect from a malicious peer, your best option is to store it in another repository. This applies to both clients and servers. In particular, namespaces on a server are not effective for read access control; you should only grant read access to a namespace to clients that you would trust with read access to the entire repository."
msgstr "获取和推送协议并不是为了防止一方从另一个版本库窃取不打算共享的数据。如果你有需要保护的私人数据不被恶意的同行窃取，你最好的选择是把它存储在另一个资源库中。这同时适用于客户端和服务器。特别是，服务器上的命名空间对于读取访问控制是无效的；你应该只将命名空间的读取访问权授予那些你信任的可以读取整个版本库的客户。"

#. type: Plain text
#: en/transfer-data-leaks.txt:13
#, priority:220
msgid "The known attack vectors are as follows:"
msgstr "已知的攻击媒介如下："

#. type: Plain text
#: en/transfer-data-leaks.txt:26
#, priority:220
msgid "The victim sends \"have\" lines advertising the IDs of objects it has that are not explicitly intended to be shared but can be used to optimize the transfer if the peer also has them. The attacker chooses an object ID X to steal and sends a ref to X, but isn't required to send the content of X because the victim already has it. Now the victim believes that the attacker has X, and it sends the content of X back to the attacker later. (This attack is most straightforward for a client to perform on a server, by creating a ref to X in the namespace the client has access to and then fetching it. The most likely way for a server to perform it on a client is to \"merge\" X into a public branch and hope that the user does additional work on this branch and pushes it back to the server without noticing the merge.)"
msgstr "受害者发送 \"have\" 行，宣传它所拥有的对象的 ID，这些对象并没有明确地打算被共享，但如果对等体也有这些对象，就可以用来优化传输。攻击者选择了一个对象 ID X 来窃取，并向 X 发送了一个引用，但不需要发送 X 的内容，因为受害者已经拥有它。现在，受害者认为攻击者拥有 X，它稍后将 X 的内容发回给攻击者。(这种攻击对于客户端来说在服务器上执行是最直接的，通过在客户端可以访问的命名空间中创建一个 X 的引用，然后获取它。服务器最可能在客户端执行的方式是将 X \"合并\" 到一个公共分支，并希望用户在这个分支上做额外的工作，然后在没有注意到合并的情况下将其推回给服务器。）"

#. type: Plain text
#: en/transfer-data-leaks.txt:30
#, priority:220
msgid "As in #1, the attacker chooses an object ID X to steal. The victim sends an object Y that the attacker already has, and the attacker falsely claims to have X and not Y, so the victim sends Y as a delta against X.  The delta reveals regions of X that are similar to Y to the attacker."
msgstr "和 #1 一样，攻击者选择了一个对象 ID X 来偷窃。受害者发送了一个攻击者已经拥有的对象 Y，攻击者谎称拥有 X 而没有 Y，因此受害者发送 Y 作为对 X 的d elta，delta 向攻击者显示了 X 中与 Y 相似的区域。"

#. type: Title -
#: en/urls-remotes.txt:4
#, no-wrap, priority:220
msgid "REMOTES[[REMOTES]]"
msgstr "REMOTES[[REMOTES]"

#. type: Plain text
#: en/urls-remotes.txt:8
#, priority:220
msgid "The name of one of the following can be used instead of a URL as `<repository>` argument:"
msgstr "可以用下面的一个名称代替URL作为`<repository>`的参数："

#. type: Plain text
#: en/urls-remotes.txt:10
#, priority:220
msgid "a remote in the Git configuration file: `$GIT_DIR/config`,"
msgstr "一个远端的配置文件在此仓库的git配置文件： `$GIT_DIR/config`、"

#. type: Plain text
#: en/urls-remotes.txt:11
#, priority:220
msgid "a file in the `$GIT_DIR/remotes` directory, or"
msgstr "这个文件在`$GIT_DIR/remotes`目录下，或者"

#. type: Plain text
#: en/urls-remotes.txt:12
#, fuzzy, priority:220
#| msgid "a file in the `$GIT_DIR/branches` directory"
msgid "a file in the `$GIT_DIR/branches` directory."
msgstr "这个文件在`$GIT_DIR/branches`目录下。"

#. type: Plain text
#: en/urls-remotes.txt:15
#, priority:220
msgid "All of these also allow you to omit the refspec from the command line because they each contain a refspec which git will use by default."
msgstr "所有这些也允许你从命令行中省略refspec，因为它们都包含一个git默认使用的refspec。"

#. type: Title ~
#: en/urls-remotes.txt:17
#, no-wrap, priority:220
msgid "Named remote in configuration file"
msgstr "在配置文件中命名为 remote"

#. type: Plain text
#: en/urls-remotes.txt:26
#, priority:220
msgid "You can choose to provide the name of a remote which you had previously configured using linkgit:git-remote[1], linkgit:git-config[1] or even by a manual edit to the `$GIT_DIR/config` file.  The URL of this remote will be used to access the repository.  The refspec of this remote will be used by default when you do not provide a refspec on the command line.  The entry in the config file would appear like this:"
msgstr "你可以选择提供你之前用 linkgit:git-remote[1]、linkgit:git-config[1] 或甚至通过手动编辑 `$GIT_DIR/config` 文件配置的远程名称。  这个远程的 URL 将被用来访问仓库。  当你没有在命令行上提供引用规范时，这个远程仓库的引用规范将被默认使用。  配置文件中的条目会像这样："

#. type: delimited block -
#: en/urls-remotes.txt:33
#, fuzzy, no-wrap, priority:220
msgid ""
"\t[remote \"<name>\"]\n"
"\t\turl = <URL>\n"
"\t\tpushurl = <pushurl>\n"
"\t\tpush = <refspec>\n"
"\t\tfetch = <refspec>\n"
msgstr ""
"\t[remote \"<name>\"]\n"
"\t\turl = <url>\n"
"\t\tpushurl = <pushurl>\n"
"\t\tpush = <refspec>\n"
"\t\tfetch = <refspec>\n"

#. type: Plain text
#: en/urls-remotes.txt:39
#, fuzzy, priority:220
#| msgid "The `<pushurl>` is used for pushes only. It is optional and defaults to `<URL>`. Pushing to a remote affects all defined pushurls or to all defined urls if no pushurls are defined. Fetch, however, will only fetch from the first defined url if muliple urls are defined."
msgid "The `<pushurl>` is used for pushes only. It is optional and defaults to `<URL>`. Pushing to a remote affects all defined pushurls or to all defined urls if no pushurls are defined. Fetch, however, will only fetch from the first defined url if multiple urls are defined."
msgstr "`<pushurl>` 仅用于推送。它是可选的，默认为 `<URL>`。向远程推送会影响所有定义的推送urls，如果没有定义推送urls，则推送到所有定义的url。然而，如果定义了多个 URL，fetch 将只从第一个定义的 URL 获取。"

#. type: Title ~
#: en/urls-remotes.txt:41
#, no-wrap, priority:220
msgid "Named file in `$GIT_DIR/remotes`"
msgstr "`$GIT_DIR/remotes` 中的命名文件"

#. type: Plain text
#: en/urls-remotes.txt:49
#, priority:220
msgid "You can choose to provide the name of a file in `$GIT_DIR/remotes`.  The URL in this file will be used to access the repository.  The refspec in this file will be used as default when you do not provide a refspec on the command line.  This file should have the following format:"
msgstr "你可以选择提供 `$GIT_DIR/remotes` 中的文件名。  这个文件中的 URL 将被用来访问仓库。  当你没有在命令行上提供引用规范时，该文件中的引用规范将被作为默认使用。  这个文件应该有以下格式："

#. type: delimited block -
#: en/urls-remotes.txt:54
#, no-wrap, priority:220
msgid ""
"\tURL: one of the above URL format\n"
"\tPush: <refspec>\n"
"\tPull: <refspec>\n"
msgstr ""
"\tURL: one of the above URL format\n"
"\tPush: <引用规范>\n"
"\tPull: <引用规范>\n"

#. type: Plain text
#: en/urls-remotes.txt:61
#, priority:220
msgid "`Push:` lines are used by 'git push' and `Pull:` lines are used by 'git pull' and 'git fetch'.  Multiple `Push:` and `Pull:` lines may be specified for additional branch mappings."
msgstr "`Push:` 行被 'git push' 使用，`Pull:` 行被 'git pull' 和 'git fetch' 使用。  可以为额外的分支映射指定多个 `Push:` 和 `Pull:` 行。"

#. type: Title ~
#: en/urls-remotes.txt:63
#, no-wrap, priority:220
msgid "Named file in `$GIT_DIR/branches`"
msgstr "`$GIT_DIR/branches` 中的命名文件"

#. type: Plain text
#: en/urls-remotes.txt:69
#, priority:220
msgid "You can choose to provide the name of a file in `$GIT_DIR/branches`.  The URL in this file will be used to access the repository.  This file should have the following format:"
msgstr "你可以选择提供 `$GIT_DIR/branches` 中的文件名。  这个文件中的 URL 将被用来访问仓库。  这个文件应该有以下格式："

#. type: delimited block -
#: en/urls-remotes.txt:73
#, fuzzy, no-wrap, priority:220
msgid "\t<URL>#<head>\n"
msgstr "\t<url>#<head>\n"

#. type: Plain text
#: en/urls-remotes.txt:76
#, priority:220
msgid "`<URL>` is required; `#<head>` is optional."
msgstr "`<URL>` 是必须的；`#<head>` 是可选的。"

#. type: Plain text
#: en/urls-remotes.txt:81
#, priority:220
msgid "Depending on the operation, git will use one of the following refspecs, if you don't provide one on the command line.  `<branch>` is the name of this file in `$GIT_DIR/branches` and `<head>` defaults to `master`."
msgstr "根据不同的操作，如果你没有在命令行上提供一个引用规范，git 会使用以下其中一个。  `<分支>` 是该文件在 `$GIT_DIR/branches` 中的名称，`<头分支>` 默认为 `master`。"

#. type: Plain text
#: en/urls-remotes.txt:83
#, priority:220
msgid "git fetch uses:"
msgstr "git fetch 使用："

#. type: delimited block -
#: en/urls-remotes.txt:86
#, no-wrap, priority:220
msgid "\trefs/heads/<head>:refs/heads/<branch>\n"
msgstr "\trefs/heads/<头分支>:refs/heads/<分支>。\n"

#. type: Plain text
#: en/urls-remotes.txt:89
#, fuzzy, priority:220
msgid "git push uses:"
msgstr "git push uses:"

#. type: delimited block -
#: en/urls-remotes.txt:92
#, no-wrap, priority:220
msgid "\tHEAD:refs/heads/<head>\n"
msgstr "\tHEAD:refs/heads/<头分支>。\n"

#. type: Title -
#: en/urls.txt:2
#, fuzzy, no-wrap, priority:300
msgid "GIT URLS[[URLS]]"
msgstr "GIT URLS[[URLS]]"

#. type: Plain text
#: en/urls.txt:8
#, fuzzy, priority:300
msgid "In general, URLs contain information about the transport protocol, the address of the remote server, and the path to the repository.  Depending on the transport protocol, some of this information may be absent."
msgstr "通常，URL 包含有关传输协议，远程服务器的地址以及存储库路径的信息。对于某些传输协议，一些信息可能会缺失。"

#. type: Plain text
#: en/urls.txt:12
#, fuzzy, priority:300
msgid "Git supports ssh, git, http, and https protocols (in addition, ftp, and ftps can be used for fetching, but this is inefficient and deprecated; do not use it)."
msgstr "Git 支持 ssh，git，http 和 https 协议（此外，可以使用 ftp 和 ftps 进行抓取，但这效率低下且不建议使用；请勿使用）。"

#. type: Plain text
#: en/urls.txt:15
#, fuzzy, priority:300
msgid "The native transport (i.e. git:// URL) does no authentication and should be used with caution on unsecured networks."
msgstr "本地传输（即 git:// URL）不进行身份验证，在不安全的网络上应谨慎使用。"

#. type: Plain text
#: en/urls.txt:17
#, fuzzy, priority:300
msgid "The following syntaxes may be used with them:"
msgstr "以下是上述几个传输协议的格式："

#. type: Plain text
#: en/urls.txt:19
#, fuzzy, priority:300
msgid "ssh://{startsb}user@{endsb}host.xz{startsb}:port{endsb}/path/to/repo.git/"
msgstr "ssh://{startsb}user@{endsb}host.xz{startsb}:port{endsb}/path/to/repo.git/"

#. type: Plain text
#: en/urls.txt:20
#, fuzzy, priority:300
msgid "git://host.xz{startsb}:port{endsb}/path/to/repo.git/"
msgstr "git://host.xz{startsb}:port{endsb}/path/to/repo.git/"

#. type: Plain text
#: en/urls.txt:21
#, fuzzy, priority:300
msgid "http{startsb}s{endsb}://host.xz{startsb}:port{endsb}/path/to/repo.git/"
msgstr "http{startsb}s{endsb}://host.xz{startsb}:port{endsb}/path/to/repo.git/"

#. type: Plain text
#: en/urls.txt:22
#, fuzzy, priority:300
msgid "ftp{startsb}s{endsb}://host.xz{startsb}:port{endsb}/path/to/repo.git/"
msgstr "ftp{startsb}s{endsb}://host.xz{startsb}:port{endsb}/path/to/repo.git/"

#. type: Plain text
#: en/urls.txt:24
#, fuzzy, priority:300
msgid "An alternative scp-like syntax may also be used with the ssh protocol:"
msgstr "ssh 协议也可以使用类似 scp 的语法："

#. type: Plain text
#: en/urls.txt:26
#, fuzzy, priority:300
msgid "{startsb}user@{endsb}host.xz:path/to/repo.git/"
msgstr "{startsb}user@{endsb}host.xz:path/to/repo.git/"

#. type: Plain text
#: en/urls.txt:32
#, fuzzy, priority:300
msgid "This syntax is only recognized if there are no slashes before the first colon. This helps differentiate a local path that contains a colon. For example the local path `foo:bar` could be specified as an absolute path or `./foo:bar` to avoid being misinterpreted as an ssh url."
msgstr "仅当第一个冒号之前没有斜杠时才能识别此语法。这有助于区分包含冒号的本地路径。例如，可以将本地路径 `foo:bar` 指定为绝对路径，或者将 `./foo:bar` 指定为绝对路径，以避免被误识别为 ssh url。"

#. type: Plain text
#: en/urls.txt:34
#, fuzzy, priority:300
msgid "The ssh and git protocols additionally support ~username expansion:"
msgstr "ssh 和 git 协议还支持 ~username 扩展："

#. type: Plain text
#: en/urls.txt:36
#, fuzzy, priority:300
msgid "ssh://{startsb}user@{endsb}host.xz{startsb}:port{endsb}/~{startsb}user{endsb}/path/to/repo.git/"
msgstr "ssh://{startsb}user@{endsb}host.xz{startsb}:port{endsb}/~{startsb}user{endsb}/path/to/repo.git/"

#. type: Plain text
#: en/urls.txt:37
#, fuzzy, priority:300
msgid "git://host.xz{startsb}:port{endsb}/~{startsb}user{endsb}/path/to/repo.git/"
msgstr "git://host.xz{startsb}:port{endsb}/~{startsb}user{endsb}/path/to/repo.git/"

#. type: Plain text
#: en/urls.txt:38
#, fuzzy, priority:300
msgid "{startsb}user@{endsb}host.xz:/~{startsb}user{endsb}/path/to/repo.git/"
msgstr "{startsb}user@{endsb}host.xz:/~{startsb}user{endsb}/path/to/repo.git/"

#. type: Plain text
#: en/urls.txt:41
#, fuzzy, priority:300
msgid "For local repositories, also supported by Git natively, the following syntaxes may be used:"
msgstr "对于本地存储库（Git 本身也支持），可以使用以下语法："

#. type: Plain text
#: en/urls.txt:43
#, fuzzy, priority:300
msgid "/path/to/repo.git/"
msgstr "/path/to/repo.git/"

#. type: Plain text
#: en/urls.txt:44
#, fuzzy, priority:300
msgid "\\file:///path/to/repo.git/"
msgstr "\\file:///path/to/repo.git/"

#. type: Plain text
#: en/urls.txt:49
#, fuzzy, priority:300
msgid "These two syntaxes are mostly equivalent, except when cloning, when the former implies --local option. See linkgit:git-clone[1] for details."
msgstr "这两种语法几乎是等效的，除了在克隆时，前者暗含 --local 选项。有关详细信息，请参阅 linkgit:git-clone[1]。"

#. type: Plain text
#: en/urls.txt:54
#, fuzzy, priority:300
msgid "These two syntaxes are mostly equivalent, except the former implies --local option."
msgstr "这两种语法几乎是等效的，除了前者暗含 --local 选项。"

#. type: Plain text
#: en/urls.txt:58
#, fuzzy, priority:300
msgid "'git clone', 'git fetch' and 'git pull', but not 'git push', will also accept a suitable bundle file. See linkgit:git-bundle[1]."
msgstr "'git clone', 'git fetch' and 'git pull', but not 'git push', will also accept a suitable bundle file. See linkgit:git-bundle[1]."

#. type: Plain text
#: en/urls.txt:63
#, fuzzy, priority:300
msgid "When Git doesn't know how to handle a certain transport protocol, it attempts to use the 'remote-<transport>' remote helper, if one exists. To explicitly request a remote helper, the following syntax may be used:"
msgstr "当 Git 不知道如何处理某种传输协议时，它会尝试使用 'remote- <传输方式>' 远程帮助程序（如果存在）。要显式请求远程帮助程序，可以使用以下语法："

#. type: Plain text
#: en/urls.txt:65
#, fuzzy, priority:300
msgid "<transport>::<address>"
msgstr "<transport>::<address>"

#. type: Plain text
#: en/urls.txt:69
#, fuzzy, priority:300
msgid "where <address> may be a path, a server and path, or an arbitrary URL-like string recognized by the specific remote helper being invoked. See linkgit:gitremote-helpers[7] for details."
msgstr "其中，<地址> 可以是路径，服务器与路径，也可以是可被调用的特定远程帮助程序识别的类似于 URL 的任意字符串。有关详细信息，请参阅 linkgit:gitremote-helpers[7]。"

#. type: Plain text
#: en/urls.txt:74
#, fuzzy, priority:300
msgid "If there are a large number of similarly-named remote repositories and you want to use a different format for them (such that the URLs you use will be rewritten into URLs that work), you can create a configuration section of the form:"
msgstr "如果存在大量类似名称的远程存储库，并且您要为其使用不同的格式（这样，您使用的 URL 将被重写为有效的 URL），则可以创建以下形式的配置："

#. type: delimited block -
#: en/urls.txt:78
#, no-wrap, priority:300
msgid ""
"\t[url \"<actual url base>\"]\n"
"\t\tinsteadOf = <other url base>\n"
msgstr ""
"\t[url \"<actual url base>\"]\n"
"\t\tinsteadOf = <other url base>\n"

#. type: Plain text
#: en/urls.txt:81 en/urls.txt:100
#, fuzzy, priority:300
msgid "For example, with this:"
msgstr "例如，有如下："

#. type: delimited block -
#: en/urls.txt:86
#, fuzzy, no-wrap, priority:300
msgid ""
"\t[url \"git://git.host.xz/\"]\n"
"\t\tinsteadOf = host.xz:/path/to/\n"
"\t\tinsteadOf = work:\n"
msgstr ""
"\t[url \"git://git.host.xz/\"]\n"
"\t\tinsteadOf = host.xz:/path/to/\n"
"\t\tinsteadOf = work:\n"

#. type: Plain text
#: en/urls.txt:90
#, fuzzy, priority:300
msgid "a URL like \"work:repo.git\" or like \"host.xz:/path/to/repo.git\" will be rewritten in any context that takes a URL to be \"git://git.host.xz/repo.git\"."
msgstr "URL 诸如 \"work:repo.git\" 或 \"host.xz:/path/to/repo.git\" 会在任何 URL 类似于 \"git://git.host.xz/repo\" 的上下文中重写。"

#. type: Plain text
#: en/urls.txt:93
#, fuzzy, priority:300
msgid "If you want to rewrite URLs for push only, you can create a configuration section of the form:"
msgstr "如果要重写仅用于推送的 URL，可以创建表单的配置部分："

#. type: delimited block -
#: en/urls.txt:97
#, no-wrap, priority:300
msgid ""
"\t[url \"<actual url base>\"]\n"
"\t\tpushInsteadOf = <other url base>\n"
msgstr ""
"\t[url \"<actual url base>\"]\n"
"\t\tpushInsteadOf = <other url base>\n"

#. type: delimited block -
#: en/urls.txt:104
#, fuzzy, no-wrap, priority:300
msgid ""
"\t[url \"ssh://example.org/\"]\n"
"\t\tpushInsteadOf = git://example.org/\n"
msgstr ""
"\t[url \"ssh://example.org/\"]\n"
"\t\tpushInsteadOf = git://example.org/\n"

#. type: Plain text
#: en/urls.txt:108
#, fuzzy, priority:300
msgid "a URL like \"git://example.org/path/to/repo.git\" will be rewritten to \"ssh://example.org/path/to/repo.git\" for pushes, but pulls will still use the original URL."
msgstr "类似于 \"git://example.org/path/to/repo.git\" 的 URL 会被重写为 \"ssh://example.org/path/to/repo.git\"，用于推送。但拉取代码时仍然使用原始的 URL。"

#. type: Title =
#: en/git-bisect-lk2009.txt:2
#, no-wrap, priority:100
msgid "Fighting regressions with git bisect"
msgstr "用Git二分查找解决回退问题"

#. type: Title -
#: en/git-bisect-lk2009.txt:8
#, fuzzy, no-wrap, priority:100
msgid "Abstract"
msgstr "摘要"

#. type: Plain text
#: en/git-bisect-lk2009.txt:17
#, priority:100
msgid "\"git bisect\" enables software users and developers to easily find the commit that introduced a regression. We show why it is important to have good tools to fight regressions. We describe how \"git bisect\" works from the outside and the algorithms it uses inside. Then we explain how to take advantage of \"git bisect\" to improve current practices. And we discuss how \"git bisect\" could improve in the future."
msgstr "\"Git二分查找\"使软件用户和开发者能够轻松找到引入回退的提交。我们展示了为什么拥有好的工具来解决回退是很重要的。我们描述了 \"Git二分查找 \"从外部如何工作，以及它在内部使用的算法。然后我们解释如何利用 \"Git二分查找\"来改进当前的体验。我们还讨论了 \"Git二分查找\"在未来可以如何改进。"

#. type: Title -
#: en/git-bisect-lk2009.txt:20
#, fuzzy, no-wrap, priority:100
msgid "Introduction to \"git bisect\""
msgstr "\"git bisect\"简介"

#. type: Plain text
#: en/git-bisect-lk2009.txt:24
#, priority:100
msgid "Git is a Distributed Version Control system (DVCS) created by Linus Torvalds and maintained by Junio Hamano."
msgstr "Git是一个分布式版本控制系统（DVCS），由Linus Torvalds（一般指 林纳斯·本纳第克特·托瓦兹；Linux之父）创建，由Junio Hamano（ Junio C Hamano；滨野 纯）维护。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:30
#, priority:100
msgid "In Git like in many other Version Control Systems (VCS), the different states of the data that is managed by the system are called commits. And, as VCS are mostly used to manage software source code, sometimes \"interesting\" changes of behavior in the software are introduced in some commits."
msgstr "在Git中，像许多其他版本控制系统（VCS）一样，由系统管理的数据的不同状态被称为提交。而且，由于版本控制系统主要用于管理软件源代码，有时会在一些提交中引入软件中 \"有趣 \"的行为变化。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:37
#, priority:100
msgid "In fact people are specially interested in commits that introduce a \"bad\" behavior, called a bug or a regression. They are interested in these commits because a commit (hopefully) contains a very small set of source code changes. And it's much easier to understand and properly fix a problem when you only need to check a very small set of changes, than when you don't know where look in the first place."
msgstr "事实上，人们对那些引入 \"坏 \"行为的提交特别感兴趣，这些行为被称为错误或回归。他们之所以对这些提交感兴趣，是因为一个提交（希望）只包含一组非常小的源代码改动。当你只需要检查很小的改动时，理解和正确修复一个问题要比你不知道从哪里找问题容易得多。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:45
#, priority:100
msgid "So to help people find commits that introduce a \"bad\" behavior, the \"git bisect\" set of commands was invented. And it follows of course that in \"git bisect\" parlance, commits where the \"interesting behavior\" is present are called \"bad\" commits, while other commits are called \"good\" commits. And a commit that introduce the behavior we are interested in is called a \"first bad commit\". Note that there could be more than one \"first bad commit\" in the commit space we are searching."
msgstr "所以为了帮助人们找到引入 \"坏 \"行为的提交，发明了 \"Git二分查找\"命令集。当然，在 \"Git二分查找\"的说法中，存在 \"有趣行为 \"的提交被称为 \"坏 \"提交，而其他提交被称为 \"好 \"提交。而引入我们感兴趣的行为的提交被称为 \"第一个坏提交\"。请注意，在我们搜索的提交空间中，可能存在不止一个 \"第一个坏提交\"。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:48
#, priority:100
msgid "So \"git bisect\" is designed to help find a \"first bad commit\". And to be as efficient as possible, it tries to perform a binary search."
msgstr "因此，\"Git二分查找\"被设计用来帮助找到 \"第一个坏提交\"。为了尽可能的高效，它试图进行二分查找。"

#. type: Title -
#: en/git-bisect-lk2009.txt:51
#, no-wrap, priority:100
msgid "Fighting regressions overview"
msgstr "解决回退概述"

#. type: Title ~
#: en/git-bisect-lk2009.txt:54
#, no-wrap, priority:100
msgid "Regressions: a big problem"
msgstr "回退：一个大问题"

#. type: Plain text
#: en/git-bisect-lk2009.txt:58
#, priority:100
msgid "Regressions are a big problem in the software industry. But it's difficult to put some real numbers behind that claim."
msgstr "回退是软件行业的一个大问题。但是很难用数字来说明这个问题。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:61
#, priority:100
msgid "There are some numbers about bugs in general, like a NIST study in 2002 <<1>> that said:"
msgstr "有一些关于一般bug的数字，比如2002年NIST的一项研究<<1>>写道："

#. type: delimited block _
#: en/git-bisect-lk2009.txt:78
#, priority:100
msgid "Software bugs, or errors, are so prevalent and so detrimental that they cost the U.S. economy an estimated $59.5 billion annually, or about 0.6 percent of the gross domestic product, according to a newly released study commissioned by the Department of Commerce's National Institute of Standards and Technology (NIST). At the national level, over half of the costs are borne by software users and the remainder by software developers/vendors.  The study also found that, although all errors cannot be removed, more than a third of these costs, or an estimated $22.2 billion, could be eliminated by an improved testing infrastructure that enables earlier and more effective identification and removal of software defects. These are the savings associated with finding an increased percentage (but not 100 percent) of errors closer to the development stages in which they are introduced. Currently, over half of all errors are not found until \"downstream\" in the development process or during post-sale software use."
msgstr "根据美国商务部国家标准与技术研究所（NIST）新近发布的一项研究，软件缺陷或错误是非常普遍且是灾难性的，以至于它们每年给美国经济造成约595亿美元的损失，或约占国内生产总值的0.6%。在全国范围内，超过一半的成本由软件用户承担，其余的由软件开发商/供应商承担。  该研究还发现，尽管所有的错误都无法消除，但通过改进测试基础架构，能够更早、更有效地识别和消除软件缺陷，可以消除这些成本的三分之一以上，即估计为222亿美元。这些都是在更接近错误发生的开发阶段发现更高比例（但不是100%）的错误所带来的节约。目前，超过一半的错误是在开发过程的 \"下游 \"或售后软件使用期间才被发现的。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:81
#, priority:100
msgid "And then:"
msgstr "然后："

#. type: delimited block _
#: en/git-bisect-lk2009.txt:87
#, priority:100
msgid "Software developers already spend approximately 80 percent of development costs on identifying and correcting defects, and yet few products of any type other than software are shipped with such high levels of errors."
msgstr "软件开发人员已经将大约80%的开发成本用于识别和纠正缺陷，然而，除了软件之外，很少有其他类型的产品在出厂时出现如此高的错误。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:90
#, priority:100
msgid "Eventually the conclusion started with:"
msgstr "最终结论是："

#. type: delimited block _
#: en/git-bisect-lk2009.txt:94
#, priority:100
msgid "The path to higher software quality is significantly improved software testing."
msgstr "改善软件测试是通往更高的软件质量的道路最为有效的方式。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:98
#, priority:100
msgid "There are other estimates saying that 80% of the cost related to software is about maintenance <<2>>."
msgstr "还有人估计说，与软件有关的成本中有80%是关于维护的<<2>>。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:100
#, priority:100
msgid "Though, according to Wikipedia <<3>>:"
msgstr "尽管，根据维基百科<<3>>的说法："

#. type: delimited block _
#: en/git-bisect-lk2009.txt:108
#, priority:100
msgid "A common perception of maintenance is that it is merely fixing bugs. However, studies and surveys over the years have indicated that the majority, over 80%, of the maintenance effort is used for non-corrective actions (Pigosky 1997). This perception is perpetuated by users submitting problem reports that in reality are functionality enhancements to the system."
msgstr "人们对维护工作的普遍看法是，它仅仅是在修复错误。然而，多年来的研究和调查表明，大部分（超过80%）的维护工作都是用于非纠正性的行动（Pigosky 1997）。用户提交的问题报告实际上是对系统功能的提升，这使得这种看法得以延续。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:113
#, priority:100
msgid "But we can guess that improving on existing software is very costly because you have to watch out for regressions. At least this would make the above studies consistent among themselves."
msgstr "但我们可以猜测，在现有软件上进行改进的代价是非常昂贵的，因为你必须注意功能退步的问题。至少这可以使上述研究之间保持一致。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:121
#, priority:100
msgid "Of course some kind of software is developed, then used during some time without being improved on much, and then finally thrown away. In this case, of course, regressions may not be a big problem. But on the other hand, there is a lot of big software that is continually developed and maintained during years or even tens of years by a lot of people. And as there are often many people who depend (sometimes critically) on such software, regressions are a really big problem."
msgstr "当然，有些软件被开发出来，然后在一段时间内使用中，没有得到很大的改进，最后被废弃。当然，在这种情况下，退步可能不是一个大问题。但另一方面，有很多大型软件是由很多人在几年甚至几十几年的时间里不断开发和维护的。由于经常有许多人依赖这种软件（有时是关键性的），所以回退是一个真正的大问题。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:128
#, priority:100
msgid "One such software is the Linux kernel. And if we look at the Linux kernel, we can see that a lot of time and effort is spent to fight regressions. The release cycle start with a 2 weeks long merge window. Then the first release candidate (rc) version is tagged. And after that about 7 or 8 more rc versions will appear with around one week between each of them, before the final release."
msgstr "Linux内核就是这样一个软件。如果我们看一下Linux内核，我们可以看到花了大量的时间和精力来对抗退步。发布周期从2周的合并窗口开始。然后，第一个候选版本（rc）被标记。在那之后，在最终发布之前，大约还有7到8个rc版本会出现，每个版本之间相隔一周左右。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:134
#, priority:100
msgid "The time between the first rc release and the final release is supposed to be used to test rc versions and fight bugs and especially regressions. And this time is more than 80% of the release cycle time. But this is not the end of the fight yet, as of course it continues after the release."
msgstr "从第一个rc版本到最终版本之间的时间应该是用来测试rc版本和解决bug，特别是回退问题。而这段时间占到了发布周期的80%以上。发布并不意味着战斗结束，因为bug在发布后还会继续出现。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:137
#, priority:100
msgid "And then this is what Ingo Molnar (a well known Linux kernel developer) says about his use of git bisect:"
msgstr "然后这是Ingo Molnar（一位知名的Linux内核开发者）对他正在使用的Git二分查找的评价："

#. type: delimited block _
#: en/git-bisect-lk2009.txt:143
#, priority:100
msgid "I most actively use it during the merge window (when a lot of trees get merged upstream and when the influx of bugs is the highest) - and yes, there have been cases that i used it multiple times a day. My average is roughly once a day."
msgstr "我在合并窗口期最积极地使用它（当大量的树被合并到上游时，也是bug涌入最多的时候），有一些情况下，我一天要多次使用。我的平均使用频率大约是每天一次。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:149
#, priority:100
msgid "So regressions are fought all the time by developers, and indeed it is well known that bugs should be fixed as soon as possible, so as soon as they are found. That's why it is interesting to have good tools for this purpose."
msgstr "因此，开发人员一直在与回退作斗争，事实上，众所周知，错误应该被尽快修复，所以一旦发现就应该尽快修复。这就是为什么有好的工具来达到这个目的是很有趣的。"

#. type: Title ~
#: en/git-bisect-lk2009.txt:151
#, no-wrap, priority:100
msgid "Other tools to fight regressions"
msgstr "解决回退的其他工具"

#. type: Plain text
#: en/git-bisect-lk2009.txt:156
#, priority:100
msgid "So what are the tools used to fight regressions? They are nearly the same as those used to fight regular bugs. The only specific tools are test suites and tools similar as \"git bisect\"."
msgstr "那么，用于解决回退的工具是什么呢？它们几乎与那些用来对付常规bug的工具相同。唯一特殊的工具是测试套件和类似于 \"Git二分查找\"的工具。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:162
#, priority:100
msgid "Test suites are very nice. But when they are used alone, they are supposed to be used so that all the tests are checked after each commit. This means that they are not very efficient, because many tests are run for no interesting result, and they suffer from combinatorial explosion."
msgstr "测试套件是非常好的。但当它们被单独使用时，它们应该被用来在每次提交后检查所有的测试。这意味着它们的效率并不高，因为许多测试的运行并没有意外的结果，而且它们会受到组合的影响。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:167
#, priority:100
msgid "In fact the problem is that big software often has many different configuration options and that each test case should pass for each configuration after each commit. So if you have for each release: N configurations, M commits and T test cases, you should perform:"
msgstr "事实上，问题在于大型软件通常有许多不同的配置选项，每次提交后，每个测试用例都应该通过每个配置。因此，如果你对每个版本有N个配置，M个提交，T个测试用例，你应该执行："

#. type: delimited block -
#: en/git-bisect-lk2009.txt:170
#, no-wrap, priority:100
msgid "N * M * T tests\n"
msgstr "N * M * T 个测试\n"

#. type: Plain text
#: en/git-bisect-lk2009.txt:173
#, priority:100
msgid "where N, M and T are all growing with the size your software."
msgstr "其中N、M和T都是随着你的软件大小而增长的。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:175
#, priority:100
msgid "So very soon it will not be possible to completely test everything."
msgstr "因此，很快就不可能对所有的东西进行测试。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:182
#, priority:100
msgid "And if some bugs slip through your test suite, then you can add a test to your test suite. But if you want to use your new improved test suite to find where the bug slipped in, then you will either have to emulate a bisection process or you will perhaps bluntly test each commit backward starting from the \"bad\" commit you have which may be very wasteful."
msgstr "而如果有些bug在你的测试套件中溜走了，那么你可以在你的测试套件中增加一个测试。但是，如果你想用你新改进的测试套件来找到bug溜进去的地方，那么你将不得不模仿一分为二的过程，或者你也许会直截了当地从你的 \"坏 \"提交开始向后测试每个提交，这可能是非常浪费的。"

#. type: Title -
#: en/git-bisect-lk2009.txt:184
#, fuzzy, no-wrap, priority:100
msgid "\"git bisect\" overview"
msgstr "\"git bisect\" overview"

#. type: Title ~
#: en/git-bisect-lk2009.txt:187
#, no-wrap, priority:100
msgid "Starting a bisection"
msgstr "开始二分"

#. type: Plain text
#: en/git-bisect-lk2009.txt:194
#, priority:100
msgid "The first \"git bisect\" subcommand to use is \"git bisect start\" to start the search. Then bounds must be set to limit the commit space. This is done usually by giving one \"bad\" and at least one \"good\" commit. They can be passed in the initial call to \"git bisect start\" like this:"
msgstr "第一个要使用的 \"Git二分查找\"子命令是 \"git bisect start \"来开始搜索。然后必须设置边界来限制提交空间。这通常是通过给出一个 \"坏 \"和至少一个 \"好 \"的提交来实现的。它们可以像这样在初始调用 \"git bisect start \"时传递："

#. type: delimited block -
#: en/git-bisect-lk2009.txt:197
#, fuzzy, ignore-ellipsis, no-wrap, priority:100
msgid "$ git bisect start [BAD [GOOD...]]\n"
msgstr "$ git bisect start [BAD [GOOD...]]\n"

#. type: Plain text
#: en/git-bisect-lk2009.txt:200
#, priority:100
msgid "or they can be set using:"
msgstr "或者可以用以下方式设置："

#. type: delimited block -
#: en/git-bisect-lk2009.txt:203
#, fuzzy, no-wrap, priority:100
msgid "$ git bisect bad [COMMIT]\n"
msgstr "$ git bisect bad [COMMIT]\n"

#. type: Plain text
#: en/git-bisect-lk2009.txt:206
#, fuzzy, priority:100
msgid "and:"
msgstr "与："

#. type: delimited block -
#: en/git-bisect-lk2009.txt:209
#, fuzzy, ignore-ellipsis, no-wrap, priority:100
msgid "$ git bisect good [COMMIT...]\n"
msgstr "$ git bisect good [COMMIT...]\n"

#. type: Plain text
#: en/git-bisect-lk2009.txt:213
#, priority:100
msgid "where BAD, GOOD and COMMIT are all names that can be resolved to a commit."
msgstr "其中BAD、GOOD和COMMIT都可以解析为提交的名称。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:216
#, priority:100
msgid "Then \"git bisect\" will checkout a commit of its choosing and ask the user to test it, like this:"
msgstr "然后 \"git bisect \"会给出它所选择的一个提交，并要求用户测试它，就像这样："

#. type: delimited block -
#: en/git-bisect-lk2009.txt:221
#, no-wrap, priority:100
msgid ""
"$ git bisect start v2.6.27 v2.6.25\n"
"Bisecting: 10928 revisions left to test after this (roughly 14 steps)\n"
"[2ec65f8b89ea003c27ff7723525a2ee335a2b393] x86: clean up using max_low_pfn on 32-bit\n"
msgstr ""
"$ git bisect start v2.6.27 v2.6.25\n"
"Bisecting: 10928 revisions left to test after this (roughly 14 steps)\n"
"[2ec65f8b89ea003c27ff7723525a2ee335a2b393] x86: clean up using max_low_pfn on 32-bit\n"

#. type: Plain text
#: en/git-bisect-lk2009.txt:229
#, priority:100
msgid "Note that the example that we will use is really a toy example, we will be looking for the first commit that has a version like \"2.6.26-something\", that is the commit that has a \"SUBLEVEL = 26\" line in the top level Makefile. This is a toy example because there are better ways to find this commit with Git than using \"git bisect\" (for example \"git blame\" or \"git log -S<string>\")."
msgstr "请注意，我们将使用的例子实际上是一个小型例子，我们将寻找第一个版本为 \"2.6.26-something \"的提交，即在顶层 Makefile 中有 \"SUBLEVEL = 26 \"行的提交。这只是一个小型例子，因为除了使用 \"git bisect\"，还有更好的方法来找到这个提交（例如 \"git blame \"或 \"git log -S<string>\"）。"

#. type: Title ~
#: en/git-bisect-lk2009.txt:231
#, no-wrap, priority:100
msgid "Driving a bisection manually"
msgstr ""

#. type: Plain text
#: en/git-bisect-lk2009.txt:236
#, priority:100
msgid "At this point there are basically 2 ways to drive the search. It can be driven manually by the user or it can be driven automatically by a script or a command."
msgstr "在这一点上，基本上有两种方式来驱动搜索。它可以由用户手动驱动，也可以由一个脚本或命令自动驱动。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:241
#, priority:100
msgid "If the user is driving it, then at each step of the search, the user will have to test the current commit and say if it is \"good\" or \"bad\" using the \"git bisect good\" or \"git bisect bad\" commands respectively that have been described above. For example:"
msgstr "如果由用户来驱动，那么在搜索的每一步，用户都必须测试当前的提交，并分别使用上文所述的 \"git bisect good \"或 \"git bisect bad \"命令说它是 \"好 \"还是 \"坏\"。比如："

#. type: delimited block -
#: en/git-bisect-lk2009.txt:246
#, no-wrap, priority:100
msgid ""
"$ git bisect bad\n"
"Bisecting: 5480 revisions left to test after this (roughly 13 steps)\n"
"[66c0b394f08fd89236515c1c84485ea712a157be] KVM: kill file->f_count abuse in kvm\n"
msgstr ""
"$ git bisect bad\n"
"Bisecting: 5480 revisions left to test after this (roughly 13 steps)\n"
"[66c0b394f08fd89236515c1c84485ea712a157be] KVM: kill file->f_count abuse in kvm\n"

#. type: Plain text
#: en/git-bisect-lk2009.txt:250
#, priority:100
msgid "And after a few more steps like that, \"git bisect\" will eventually find a first bad commit:"
msgstr "继续这样做，\"git bisect \"最终会找到第一个坏提交："

#. type: delimited block -
#: en/git-bisect-lk2009.txt:257
#, fuzzy, no-wrap, priority:100
msgid ""
"$ git bisect bad\n"
"2ddcca36c8bcfa251724fe342c8327451988be0d is the first bad commit\n"
"commit 2ddcca36c8bcfa251724fe342c8327451988be0d\n"
"Author: Linus Torvalds <torvalds@linux-foundation.org>\n"
"Date:   Sat May 3 11:59:44 2008 -0700\n"
msgstr ""
"$ git bisect bad\n"
"2ddcca36c8bcfa251724fe342c8327451988be0d is the first bad commit\n"
"commit 2ddcca36c8bcfa251724fe342c8327451988be0d\n"
"Author: Linus Torvalds <torvalds@linux-foundation.org>\n"
"Date:   Sat May 3 11:59:44 2008 -0700\n"

#. type: delimited block -
#: en/git-bisect-lk2009.txt:259 en/git-bisect-lk2009.txt:273 en/git-bisect-lk2009.txt:333
#, fuzzy, no-wrap, priority:100
msgid "    Linux 2.6.26-rc1\n"
msgstr "    Linux 2.6.26-rc1\n"

#. type: delimited block -
#: en/git-bisect-lk2009.txt:261
#, ignore-ellipsis, no-wrap, priority:100
msgid ":100644 100644 5cf82581... 4492984e... M      Makefile\n"
msgstr ":100644 100644 5cf82581... 4492984e... M      Makefile\n"

#. type: Plain text
#: en/git-bisect-lk2009.txt:265
#, priority:100
msgid "At this point we can see what the commit does, check it out (if it's not already checked out) or tinker with it, for example:"
msgstr "在这一点上，我们可以看到提交的内容，检查（如果它还没有被检查出来）或修补它，比如："

#. type: delimited block -
#: en/git-bisect-lk2009.txt:271
#, fuzzy, no-wrap, priority:100
msgid ""
"$ git show HEAD\n"
"commit 2ddcca36c8bcfa251724fe342c8327451988be0d\n"
"Author: Linus Torvalds <torvalds@linux-foundation.org>\n"
"Date:   Sat May 3 11:59:44 2008 -0700\n"
msgstr ""
"$ git show HEAD\n"
"commit 2ddcca36c8bcfa251724fe342c8327451988be0d\n"
"Author: Linus Torvalds <torvalds@linux-foundation.org>\n"
"Date:   Sat May 3 11:59:44 2008 -0700\n"

#. type: delimited block -
#: en/git-bisect-lk2009.txt:286
#, no-wrap, priority:100
msgid ""
"diff --git a/Makefile b/Makefile\n"
"index 5cf8258..4492984 100644\n"
"--- a/Makefile\n"
"+++ b/Makefile\n"
"@@ -1,7 +1,7 @@\n"
" VERSION = 2\n"
" PATCHLEVEL = 6\n"
"-SUBLEVEL = 25\n"
"-EXTRAVERSION =\n"
"+SUBLEVEL = 26\n"
"+EXTRAVERSION = -rc1\n"
" NAME = Funky Weasel is Jiggy wit it\n"
msgstr ""
"diff --git a/Makefile b/Makefile\n"
"index 5cf8258..4492984 100644\n"
"--- a/Makefile\n"
"+++ b/Makefile\n"
"@@ -1,7 +1,7 @@\n"
" VERSION = 2\n"
" PATCHLEVEL = 6\n"
"-SUBLEVEL = 25\n"
"-EXTRAVERSION =\n"
"+SUBLEVEL = 26\n"
"+EXTRAVERSION = -rc1\n"
" NAME = Funky Weasel is Jiggy wit it\n"

#. type: delimited block -
#: en/git-bisect-lk2009.txt:288
#, no-wrap, priority:100
msgid " # *DOCUMENTATION*\n"
msgstr " # *文档*\n"

#. type: Plain text
#: en/git-bisect-lk2009.txt:292
#, priority:100
msgid "And when we are finished we can use \"git bisect reset\" to go back to the branch we were in before we started bisecting:"
msgstr "当我们完成后，我们可以使用 \"git bisect reset \"回到我们开始二分前所在的分支："

#. type: delimited block -
#: en/git-bisect-lk2009.txt:298
#, ignore-ellipsis, no-wrap, priority:100
msgid ""
"$ git bisect reset\n"
"Checking out files: 100% (21549/21549), done.\n"
"Previous HEAD position was 2ddcca3... Linux 2.6.26-rc1\n"
"Switched to branch 'master'\n"
msgstr ""
"$ git bisect reset\n"
"Checking out files: 100% (21549/21549), done.\n"
"Previous HEAD position was 2ddcca3... Linux 2.6.26-rc1\n"
"Switched to branch 'master'\n"

#. type: Title ~
#: en/git-bisect-lk2009.txt:301
#, no-wrap, priority:100
msgid "Driving a bisection automatically"
msgstr "自动驱动一个二分查找"

#. type: Plain text
#: en/git-bisect-lk2009.txt:307
#, priority:100
msgid "The other way to drive the bisection process is to tell \"git bisect\" to launch a script or command at each bisection step to know if the current commit is \"good\" or \"bad\". To do that, we use the \"git bisect run\" command. For example:"
msgstr "另一种驱动分界进程的方法是告诉 \"git bisect \"在每个分界步骤启动一个脚本或命令，以了解当前提交是 \"好 \"还是 \"坏\"。要做到这一点，我们使用 \"git bisect run \"命令。比如说："

#. type: delimited block -
#: en/git-bisect-lk2009.txt:331
#, ignore-ellipsis, no-wrap, priority:100
msgid ""
"$ git bisect start v2.6.27 v2.6.25\n"
"Bisecting: 10928 revisions left to test after this (roughly 14 steps)\n"
"[2ec65f8b89ea003c27ff7723525a2ee335a2b393] x86: clean up using max_low_pfn on 32-bit\n"
"$\n"
"$ git bisect run grep '^SUBLEVEL = 25' Makefile\n"
"running grep ^SUBLEVEL = 25 Makefile\n"
"Bisecting: 5480 revisions left to test after this (roughly 13 steps)\n"
"[66c0b394f08fd89236515c1c84485ea712a157be] KVM: kill file->f_count abuse in kvm\n"
"running grep ^SUBLEVEL = 25 Makefile\n"
"SUBLEVEL = 25\n"
"Bisecting: 2740 revisions left to test after this (roughly 12 steps)\n"
"[671294719628f1671faefd4882764886f8ad08cb] V4L/DVB(7879): Adding cx18 Support for mxl5005s\n"
"...\n"
"...\n"
"running grep ^SUBLEVEL = 25 Makefile\n"
"Bisecting: 0 revisions left to test after this (roughly 0 steps)\n"
"[2ddcca36c8bcfa251724fe342c8327451988be0d] Linux 2.6.26-rc1\n"
"running grep ^SUBLEVEL = 25 Makefile\n"
"2ddcca36c8bcfa251724fe342c8327451988be0d is the first bad commit\n"
"commit 2ddcca36c8bcfa251724fe342c8327451988be0d\n"
"Author: Linus Torvalds <torvalds@linux-foundation.org>\n"
"Date:   Sat May 3 11:59:44 2008 -0700\n"
msgstr ""
"$ git bisect start v2.6.27 v2.6.25\n"
"Bisecting: 10928 revisions left to test after this (roughly 14 steps)\n"
"[2ec65f8b89ea003c27ff7723525a2ee335a2b393] x86: clean up using max_low_pfn on 32-bit\n"
"$\n"
"$ git bisect run grep '^SUBLEVEL = 25' Makefile\n"
"running grep ^SUBLEVEL = 25 Makefile\n"
"Bisecting: 5480 revisions left to test after this (roughly 13 steps)\n"
"[66c0b394f08fd89236515c1c84485ea712a157be] KVM: kill file->f_count abuse in kvm\n"
"running grep ^SUBLEVEL = 25 Makefile\n"
"SUBLEVEL = 25\n"
"Bisecting: 2740 revisions left to test after this (roughly 12 steps)\n"
"[671294719628f1671faefd4882764886f8ad08cb] V4L/DVB(7879): Adding cx18 Support for mxl5005s\n"
"...\n"
"...\n"
"running grep ^SUBLEVEL = 25 Makefile\n"
"Bisecting: 0 revisions left to test after this (roughly 0 steps)\n"
"[2ddcca36c8bcfa251724fe342c8327451988be0d] Linux 2.6.26-rc1\n"
"running grep ^SUBLEVEL = 25 Makefile\n"
"2ddcca36c8bcfa251724fe342c8327451988be0d is the first bad commit\n"
"commit 2ddcca36c8bcfa251724fe342c8327451988be0d\n"
"Author: Linus Torvalds <torvalds@linux-foundation.org>\n"
"Date:   Sat May 3 11:59:44 2008 -0700\n"

#. type: delimited block -
#: en/git-bisect-lk2009.txt:336
#, ignore-ellipsis, no-wrap, priority:100
msgid ""
":100644 100644 5cf82581... 4492984e... M      Makefile\n"
"bisect run success\n"
msgstr ""
":100644 100644 5cf82581... 4492984e... M      Makefile\n"
"bisect run success\n"

#. type: Plain text
#: en/git-bisect-lk2009.txt:345
#, priority:100
msgid "In this example, we passed \"grep '^SUBLEVEL = 25' Makefile\" as parameter to \"git bisect run\". This means that at each step, the grep command we passed will be launched. And if it exits with code 0 (that means success) then git bisect will mark the current state as \"good\". If it exits with code 1 (or any code between 1 and 127 included, except the special code 125), then the current state will be marked as \"bad\"."
msgstr "在这个例子中，我们把 \"grep '^SUBLEVEL = 25' Makefile \"作为参数传给 \"git bisect run\"。这意味着在每个步骤中，我们传递的grep命令将被启动。如果它以代码0退出（这意味着成功），那么git bisect将把当前状态标记为 \"好\"。如果它以代码1退出（或者包括1到127之间的任何代码，除了特殊代码125），那么当前状态将被标记为 \"坏\"。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:350
#, priority:100
msgid "Exit code between 128 and 255 are special to \"git bisect run\". They make it stop immediately the bisection process. This is useful for example if the command passed takes too long to complete, because you can kill it with a signal and it will stop the bisection process."
msgstr "128和255之间的退出代码是 \"git bisect run \"的特殊代码。它们可以让它立即停止二分查找进程。例如，如果传递的命令需要很长时间才能完成，这很有用，因为你可以用一个信号杀掉该进程，它就会停止二分查找。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:353
#, priority:100
msgid "It can also be useful in scripts passed to \"git bisect run\" to \"exit 255\" if some very abnormal situation is detected."
msgstr "在传递给 \"git bisect run \"的脚本中，如果检测到一些极端不正常的情况，它也可以起到 \"exit 255 \"的作用。"

#. type: Title ~
#: en/git-bisect-lk2009.txt:355
#, no-wrap, priority:100
msgid "Avoiding untestable commits"
msgstr "避免不稳定的提交"

#. type: Plain text
#: en/git-bisect-lk2009.txt:362
#, priority:100
msgid "Sometimes it happens that the current state cannot be tested, for example if it does not compile because there was a bug preventing it at that time. This is what the special exit code 125 is for. It tells \"git bisect run\" that the current commit should be marked as untestable and that another one should be chosen and checked out."
msgstr "有时会发生当前状态无法测试的情况，例如，因为当时有一个错误阻止了它的编译。这就是特殊退出代码125的作用。它告诉 \"git bisect run\"，当前的提交应该被标记为不可测试，应该选择另一个提交并进行检查。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:366
#, priority:100
msgid "If the bisection process is driven manually, you can use \"git bisect skip\" to do the same thing. (In fact the special exit code 125 makes \"git bisect run\" use \"git bisect skip\" in the background.)"
msgstr "如果e=二分查找过程是手动驱动的，你可以使用 \"git bisect skip \"来做同样的事情。(事实上，特殊的退出代码125使 \"git bisect run \"在后台使用 \"git bisect skip\"）。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:371
#, priority:100
msgid "Or if you want more control, you can inspect the current state using for example \"git bisect visualize\". It will launch gitk (or \"git log\" if the `DISPLAY` environment variable is not set) to help you find a better bisection point."
msgstr "或者如果你想要更多的控制，你可以使用 \"git bisect visualize \"检查当前状态。它将启动gitk（如果没有设置`DISPLAY`环境变量，则启动 \"git log\"）来帮助你找到一个更好的分界点。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:376
#, priority:100
msgid "Either way, if you have a string of untestable commits, it might happen that the regression you are looking for has been introduced by one of these untestable commits. In this case it's not possible to tell for sure which commit introduced the regression."
msgstr "无论如何，如果你有一串不可测试的提交，你要找的回退可能是由其中一个不可测试的提交引入的。在这种情况下，我们不可能确定是哪个提交引入了回退。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:379
#, priority:100
msgid "So if you used \"git bisect skip\" (or the run script exited with special code 125) you could get a result like this:"
msgstr "因此，如果你使用 \"git bisect skip\"（或者运行脚本以特殊代码125退出），你可以得到这样的结果："

#. type: delimited block -
#: en/git-bisect-lk2009.txt:388
#, no-wrap, priority:100
msgid ""
"There are only 'skip'ped commits left to test.\n"
"The first bad commit could be any of:\n"
"15722f2fa328eaba97022898a305ffc8172db6b1\n"
"78e86cf3e850bd755bb71831f42e200626fbd1e0\n"
"e15b73ad3db9b48d7d1ade32f8cd23a751fe0ace\n"
"070eab2303024706f2924822bfec8b9847e4ac1b\n"
"We cannot bisect more!\n"
msgstr ""
"There are only 'skip'ped commits left to test.\n"
"The first bad commit could be any of:\n"
"15722f2fa328eaba97022898a305ffc8172db6b1\n"
"78e86cf3e850bd755bb71831f42e200626fbd1e0\n"
"e15b73ad3db9b48d7d1ade32f8cd23a751fe0ace\n"
"070eab2303024706f2924822bfec8b9847e4ac1b\n"
"We cannot bisect more!\n"

#. type: Title ~
#: en/git-bisect-lk2009.txt:391
#, no-wrap, priority:100
msgid "Saving a log and replaying it"
msgstr "保存日志并重新展示"

#. type: Plain text
#: en/git-bisect-lk2009.txt:395
#, priority:100
msgid "If you want to show other people your bisection process, you can get a log using for example:"
msgstr "如果你想向其他人展示你的查找过程，你可以用以下的示例得到一个日志："

#. type: delimited block -
#: en/git-bisect-lk2009.txt:398
#, fuzzy, no-wrap, priority:100
msgid "$ git bisect log > bisect_log.txt\n"
msgstr "$ git bisect log > bisect_log.txt\n"

#. type: Plain text
#: en/git-bisect-lk2009.txt:401
#, priority:100
msgid "And it is possible to replay it using:"
msgstr "而且可以重新展示："

#. type: delimited block -
#: en/git-bisect-lk2009.txt:404
#, fuzzy, no-wrap, priority:100
msgid "$ git bisect replay bisect_log.txt\n"
msgstr "$ git bisect replay bisect_log.txt\n"

#. type: Title -
#: en/git-bisect-lk2009.txt:408
#, fuzzy, no-wrap, priority:100
msgid "\"git bisect\" details"
msgstr "\"git bisect\" details"

#. type: Title ~
#: en/git-bisect-lk2009.txt:411
#, no-wrap, priority:100
msgid "Bisection algorithm"
msgstr "二分算法"

#. type: Plain text
#: en/git-bisect-lk2009.txt:417
#, priority:100
msgid "As the Git commits form a directed acyclic graph (DAG), finding the best bisection commit to test at each step is not so simple. Anyway Linus found and implemented a \"truly stupid\" algorithm, later improved by Junio Hamano, that works quite well."
msgstr "由于Git提交形成了一个有向无环图（DAG），在每一步找到最佳的分界提交来测试并不那么简单。不管怎样，Linus发现并实现了一种 \"非常傻瓜\"的算法，后来被Junio Hamano改进，效果相当好。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:420
#, priority:100
msgid "So the algorithm used by \"git bisect\" to find the best bisection commit when there are no skipped commits is the following:"
msgstr "因此，当没有跳过的提交时，\"git bisect \"用来寻找最佳分界提交的算法如下："

#. type: Plain text
#: en/git-bisect-lk2009.txt:422
#, priority:100
msgid "keep only the commits that:"
msgstr "只保留以下的提交："

#. type: Plain text
#: en/git-bisect-lk2009.txt:424
#, priority:100
msgid "are ancestor of the \"bad\" commit (including the \"bad\" commit itself),"
msgstr "是\"坏 \"提交的祖先（包括 \"坏 \"提交本身），"

#. type: Plain text
#: en/git-bisect-lk2009.txt:425
#, priority:100
msgid "are not ancestor of a \"good\" commit (excluding the \"good\" commits)."
msgstr "非\"好 \"提交的祖先（不包括 \"好 \"提交）。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:427
#, priority:100
msgid "This means that we get rid of the uninteresting commits in the DAG."
msgstr "这意味着我们摆脱了DAG中无趣的提交。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:429
#, priority:100
msgid "For example if we start with a graph like this:"
msgstr "例如，如果我们从一个这样的图开始："

#. type: delimited block -
#: en/git-bisect-lk2009.txt:438
#, no-wrap, priority:100
msgid ""
"G-Y-G-W-W-W-X-X-X-X\n"
"\t   \\ /\n"
"\t    W-W-B\n"
"\t   /\n"
"Y---G-W---W\n"
" \\ /   \\\n"
"Y-Y     X-X-X-X\n"
msgstr ""
"G-Y-G-W-W-W-X-X-X-X\n"
"\t   \\ /\n"
"\t    W-W-B\n"
"\t   /\n"
"Y---G-W---W\n"
" \\ /   \\\n"
"Y-Y     X-X-X-X\n"

#. type: delimited block -
#: en/git-bisect-lk2009.txt:440
#, fuzzy, no-wrap, priority:100
msgid "-> time goes this way ->\n"
msgstr "-> 走这条路 ->\n"

#. type: Plain text
#: en/git-bisect-lk2009.txt:445
#, priority:100
msgid "where B is the \"bad\" commit, \"G\" are \"good\" commits and W, X, and Y are other commits, we will get the following graph after this first step:"
msgstr "其中B是 \"坏 \"的提交，\"G \"是 \"好 \"的提交，W、X、Y是其他的提交，经过这第一步，我们会得到以下的图："

#. type: delimited block -
#: en/git-bisect-lk2009.txt:452
#, fuzzy, no-wrap, priority:100
msgid ""
"W-W-W\n"
"     \\\n"
"      W-W-B\n"
"     /\n"
"W---W\n"
msgstr ""
"W-W-W\n"
"     \\\n"
"      W-W-B\n"
"     /\n"
"W---W\n"

#. type: Plain text
#: en/git-bisect-lk2009.txt:457
#, priority:100
msgid "So only the W and B commits will be kept. Because commits X and Y will have been removed by rules a) and b) respectively, and because commits G are removed by rule b) too."
msgstr "所以只有W和B的提交会被保留。因为X和Y的提交将分别被规则a)和b)所删除，而且G的提交也被规则b)所删除。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:460
#, priority:100
msgid "Note for Git users, that it is equivalent as keeping only the commit given by:"
msgstr "请注意，对于Git用户来说，这相当于只保留了所给的这些提交："

#. type: delimited block -
#: en/git-bisect-lk2009.txt:463
#, fuzzy, ignore-ellipsis, no-wrap, priority:100
msgid "git rev-list BAD --not GOOD1 GOOD2...\n"
msgstr "git rev-list BAD --not GOOD1 GOOD2...\n"

#. type: Plain text
#: en/git-bisect-lk2009.txt:468
#, priority:100
msgid "Also note that we don't require the commits that are kept to be descendants of a \"good\" commit. So in the following example, commits W and Z will be kept:"
msgstr "另外请注意，我们并不要求被保留的提交必须是 \"好 \"提交的后代。所以在下面的例子中，W和Z的提交将被保留："

#. type: delimited block -
#: en/git-bisect-lk2009.txt:473
#, no-wrap, priority:100
msgid ""
"G-W-W-W-B\n"
"   /\n"
"Z-Z\n"
msgstr ""
"G-W-W-W-B\n"
"   /\n"
"Z-Z\n"

#. type: Plain text
#: en/git-bisect-lk2009.txt:477
#, priority:100
msgid "starting from the \"good\" ends of the graph, associate to each commit the number of ancestors it has plus one"
msgstr "从图中 \"好 \"的两端开始，将每个提交的祖先数量加上一个并与之相关联"

#. type: Plain text
#: en/git-bisect-lk2009.txt:480
#, priority:100
msgid "For example with the following graph where H is the \"bad\" commit and A and D are some parents of some \"good\" commits:"
msgstr "例如，下图中H是 \"坏 \"的提交，A和D是一些 \"好 \"的提交的父提交："

#. type: delimited block -
#: en/git-bisect-lk2009.txt:487
#, no-wrap, priority:100
msgid ""
"A-B-C\n"
"     \\\n"
"      F-G-H\n"
"     /\n"
"D---E\n"
msgstr ""
"A-B-C\n"
"     \\\n"
"      F-G-H\n"
"     /\n"
"D---E\n"

#. type: Plain text
#: en/git-bisect-lk2009.txt:490
#, priority:100
msgid "this will give:"
msgstr "这将给出："

#. type: delimited block -
#: en/git-bisect-lk2009.txt:498
#, fuzzy, no-wrap, priority:100
msgid ""
"1 2 3\n"
"A-B-C\n"
"     \\6 7 8\n"
"      F-G-H\n"
"1   2/\n"
"D---E\n"
msgstr ""
"1 2 3\n"
"A-B-C\n"
"     \\6 7 8\n"
"      F-G-H\n"
"1   2/\n"
"D---E\n"

#. type: Plain text
#: en/git-bisect-lk2009.txt:501
#, priority:100
msgid "associate to each commit: min(X, N - X)"
msgstr "关联到每个提交： min（X， N - X）"

#. type: Plain text
#: en/git-bisect-lk2009.txt:504
#, priority:100
msgid "where X is the value associated to the commit in step 2) and N is the total number of commits in the graph."
msgstr "其中X是与步骤2中的提交相关的数值，N是图中的提交总数。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:506
#, priority:100
msgid "In the above example we have N = 8, so this will give:"
msgstr "在上面的例子中，我们有N=8，所以这将得到："

#. type: delimited block -
#: en/git-bisect-lk2009.txt:514
#, fuzzy, no-wrap, priority:100
msgid ""
"1 2 3\n"
"A-B-C\n"
"     \\2 1 0\n"
"      F-G-H\n"
"1   2/\n"
"D---E\n"
msgstr ""
"1 2 3\n"
"A-B-C\n"
"     \\2 1 0\n"
"      F-G-H\n"
"1   2/\n"
"D---E\n"

#. type: Plain text
#: en/git-bisect-lk2009.txt:518
#, priority:100
msgid "the best bisection point is the commit with the highest associated number"
msgstr "最佳分界点是具有最高关联数的提交"

#. type: Plain text
#: en/git-bisect-lk2009.txt:520
#, priority:100
msgid "So in the above example the best bisection point is commit C."
msgstr "所以在上面的例子中，最好的分界点是C。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:522
#, priority:100
msgid "note that some shortcuts are implemented to speed up the algorithm"
msgstr "请注意，这里实施了一些快捷方式以加速算法"

#. type: Plain text
#: en/git-bisect-lk2009.txt:528
#, priority:100
msgid "As we know N from the beginning, we know that min(X, N - X) can't be greater than N/2. So during steps 2) and 3), if we would associate N/2 to a commit, then we know this is the best bisection point. So in this case we can just stop processing any other commit and return the current commit."
msgstr "由于我们从一开始就知道N，所以知道min(X, N - X)不可能大于N/2。所以在步骤2）和3）中，如果我们将N/2与一个提交相关联，那么我们就知道这是一个最佳的分界点。所以在这种情况下，我们可以直接停止处理任何其他的提交，并返回当前的提交。"

#. type: Title ~
#: en/git-bisect-lk2009.txt:530
#, no-wrap, priority:100
msgid "Bisection algorithm debugging"
msgstr "二分法算法调试"

#. type: Plain text
#: en/git-bisect-lk2009.txt:534
#, priority:100
msgid "For any commit graph, you can see the number associated with each commit using \"git rev-list --bisect-all\"."
msgstr "对于任何提交图，你可以用 \"git rev-list --bisect-all \"查看与每个提交相关的数字。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:536
#, priority:100
msgid "For example, for the above graph, a command like:"
msgstr "例如，对于上面的图表，使用如下命令："

#. type: delimited block -
#: en/git-bisect-lk2009.txt:539
#, fuzzy, no-wrap, priority:100
msgid "$ git rev-list --bisect-all BAD --not GOOD1 GOOD2\n"
msgstr "$ git rev-list --bisect-all BAD --not GOOD1 GOOD2\n"

#. type: Plain text
#: en/git-bisect-lk2009.txt:542
#, priority:100
msgid "would output something like:"
msgstr "会输出类似的内容："

#. type: delimited block -
#: en/git-bisect-lk2009.txt:552
#, no-wrap, priority:100
msgid ""
"e15b73ad3db9b48d7d1ade32f8cd23a751fe0ace (dist=3)\n"
"15722f2fa328eaba97022898a305ffc8172db6b1 (dist=2)\n"
"78e86cf3e850bd755bb71831f42e200626fbd1e0 (dist=2)\n"
"a1939d9a142de972094af4dde9a544e577ddef0e (dist=2)\n"
"070eab2303024706f2924822bfec8b9847e4ac1b (dist=1)\n"
"a3864d4f32a3bf5ed177ddef598490a08760b70d (dist=1)\n"
"a41baa717dd74f1180abf55e9341bc7a0bb9d556 (dist=1)\n"
"9e622a6dad403b71c40979743bb9d5be17b16bd6 (dist=0)\n"
msgstr ""
"e15b73ad3db9b48d7d1ade32f8cd23a751fe0ace (dist=3)\n"
"15722f2fa328eaba97022898a305ffc8172db6b1 (dist=2)\n"
"78e86cf3e850bd755bb71831f42e200626fbd1e0 (dist=2)\n"
"a1939d9a142de972094af4dde9a544e577ddef0e (dist=2)\n"
"070eab2303024706f2924822bfec8b9847e4ac1b (dist=1)\n"
"a3864d4f32a3bf5ed177ddef598490a08760b70d (dist=1)\n"
"a41baa717dd74f1180abf55e9341bc7a0bb9d556 (dist=1)\n"
"9e622a6dad403b71c40979743bb9d5be17b16bd6 (dist=0)\n"

#. type: Title ~
#: en/git-bisect-lk2009.txt:555
#, no-wrap, priority:100
msgid "Bisection algorithm discussed"
msgstr "讨论二分算法"

#. type: Plain text
#: en/git-bisect-lk2009.txt:561
#, priority:100
msgid "First let's define \"best bisection point\". We will say that a commit X is a best bisection point or a best bisection commit if knowing its state (\"good\" or \"bad\") gives as much information as possible whether the state of the commit happens to be \"good\" or \"bad\"."
msgstr "首先让我们定义“最佳二分点”。如果知道一个提交的状态(“好”或“坏”)能尽可能多地提供提交状态是“好”还是“坏”的信息，我们就称它为最佳二分点或最佳二分提交。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:564
#, priority:100
msgid "This means that the best bisection commits are the commits where the following function is maximum:"
msgstr "这意味着最好的二分提交是以下函数最大的提交："

#. type: delimited block -
#: en/git-bisect-lk2009.txt:567
#, no-wrap, priority:100
msgid "f(X) = min(information_if_good(X), information_if_bad(X))\n"
msgstr "f(X) = min(information_if_good(X), information_if_bad(X))\n"

#. type: Plain text
#: en/git-bisect-lk2009.txt:571
#, priority:100
msgid "where information_if_good(X) is the information we get if X is good and information_if_bad(X) is the information we get if X is bad."
msgstr "其中information_if_good（X）是X好时我们获得的信息，information_if_bad（X）是X坏时我们得到的信息。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:580
#, priority:100
msgid "Now we will suppose that there is only one \"first bad commit\". This means that all its descendants are \"bad\" and all the other commits are \"good\". And we will suppose that all commits have an equal probability of being good or bad, or of being the first bad commit, so knowing the state of c commits gives always the same amount of information wherever these c commits are on the graph and whatever c is. (So we suppose that these commits being for example on a branch or near a good or a bad commit does not give more or less information)."
msgstr "现在我们假设只有一次“第一次错误提交”。这意味着它的所有后代都是“坏的”，而所有其他提交都是“好的”。我们假设所有的提交都有相同的概率是好的或坏的，或者是第一个错误的提交，所以知道c提交的状态给出的信息总是相同的无论这些c提交在图上的哪个位置，无论c是什么。(所以我们假设这些提交是在一个分支上，或者在一个好的或坏的提交附近，不会给出更多或更少的信息)。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:582
#, priority:100
msgid "Let's also suppose that we have a cleaned up graph like one after step"
msgstr "我们还假设我们有一个清理过的图表，例如一个步骤后"

#. type: Plain text
#: en/git-bisect-lk2009.txt:585
#, priority:100
msgid "in the bisection algorithm above. This means that we can measure the information we get in terms of number of commit we can remove from the graph.."
msgstr "在上面的二分算法中。这意味着我们可以根据可以从图中删除的提交数量来衡量我们获得的信息。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:587
#, priority:100
msgid "And let's take a commit X in the graph."
msgstr "让我们在图中提交一个 X。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:590
#, priority:100
msgid "If X is found to be \"good\", then we know that its ancestors are all \"good\", so we want to say that:"
msgstr "如果发现X是“好”的，那么我们知道它的祖先都是“好”的，所以我们想说："

#. type: delimited block -
#: en/git-bisect-lk2009.txt:593
#, no-wrap, priority:100
msgid "information_if_good(X) = number_of_ancestors(X)  (TRUE)\n"
msgstr "information_if_good（X） = number_of_ancestors（X） （TRUE）\n"

#. type: Plain text
#: en/git-bisect-lk2009.txt:597
#, priority:100
msgid "And this is true because at step 1) b) we remove the ancestors of the \"good\" commits."
msgstr "这是真的，因为在步骤 1） b） 我们删除了“好”提交的祖先。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:600
#, priority:100
msgid "If X is found to be \"bad\", then we know that its descendants are all \"bad\", so we want to say that:"
msgstr "如果发现 X 是“坏”的，那么我们知道它的后代都是“坏的”，所以我们想说："

#. type: delimited block -
#: en/git-bisect-lk2009.txt:603
#, no-wrap, priority:100
msgid "information_if_bad(X) = number_of_descendants(X)  (WRONG)\n"
msgstr "information_if_bad（X） = number_of_descendants（X） （WRONG）\n"

#. type: Plain text
#: en/git-bisect-lk2009.txt:612
#, priority:100
msgid "But this is wrong because at step 1) a) we keep only the ancestors of the bad commit. So we get more information when a commit is marked as \"bad\", because we also know that the ancestors of the previous \"bad\" commit that are not ancestors of the new \"bad\" commit are not the first bad commit. We don't know if they are good or bad, but we know that they are not the first bad commit because they are not ancestor of the new \"bad\" commit."
msgstr "但这是错误的，因为在步骤1）a）我们只保留错误承诺的祖先。因此，当提交被标记为“坏”时，我们会得到更多信息，因为我们也知道，不是新“坏”提交的祖先的上一个“坏”提交的祖先不是第一个错误提交。我们不知道它们是好是坏，但我们知道它们不是第一个错误提交，因为它们不是新“坏”提交的祖先。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:616
#, priority:100
msgid "So when a commit is marked as \"bad\" we know we can remove all the commits in the graph except those that are ancestors of the new \"bad\" commit. This means that:"
msgstr "因此，当一个提交被标记为“坏”时，我们知道我们可以删除图形中的所有提交，除了那些是新“坏”提交的祖先。这意味着："

#. type: delimited block -
#: en/git-bisect-lk2009.txt:619
#, no-wrap, priority:100
msgid "information_if_bad(X) = N - number_of_ancestors(X)  (TRUE)\n"
msgstr "information_if_bad（X） = N - number_of_ancestors（X） （TRUE）\n"

#. type: Plain text
#: en/git-bisect-lk2009.txt:622
#, priority:100
msgid "where N is the number of commits in the (cleaned up) graph."
msgstr "其中 N 是（清理的）图中的提交数。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:625
#, priority:100
msgid "So in the end this means that to find the best bisection commits we should maximize the function:"
msgstr "所以最后这意味着要找到最好的二分提交，我们应该最大化函数："

#. type: delimited block -
#: en/git-bisect-lk2009.txt:628
#, no-wrap, priority:100
msgid "f(X) = min(number_of_ancestors(X), N - number_of_ancestors(X))\n"
msgstr "f(X) = min(number_of_ancestors(X), N - number_of_ancestors(X))\n"

#. type: Plain text
#: en/git-bisect-lk2009.txt:632
#, priority:100
msgid "And this is nice because at step 2) we compute number_of_ancestors(X)  and so at step 3) we compute f(X)."
msgstr "这很好，因为在步骤2）我们计算number_of_ancestors(X)，所以在步骤3）我们计算f(X)。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:634
#, priority:100
msgid "Let's take the following graph as an example:"
msgstr "让我们以下图为例："

#. type: delimited block -
#: en/git-bisect-lk2009.txt:641
#, no-wrap, priority:100
msgid ""
"            G-H-I-J\n"
"           /       \\\n"
"A-B-C-D-E-F         O\n"
"           \\       /\n"
"            K-L-M-N\n"
msgstr ""
"            G-H-I-J\n"
"           /       \\\n"
"A-B-C-D-E-F         O\n"
"           \\       /\n"
"            K-L-M-N\n"

#. type: Plain text
#: en/git-bisect-lk2009.txt:644
#, priority:100
msgid "If we compute the following non optimal function on it:"
msgstr "如果我们在其上计算以下非最优函数："

#. type: delimited block -
#: en/git-bisect-lk2009.txt:647
#, no-wrap, priority:100
msgid "g(X) = min(number_of_ancestors(X), number_of_descendants(X))\n"
msgstr "g(X) = min(number_of_ancestors(X), number_of_descendants(X))\n"

#. type: Plain text
#: en/git-bisect-lk2009.txt:650
#, priority:100
msgid "we get:"
msgstr "我们得到："

#. type: delimited block -
#: en/git-bisect-lk2009.txt:659
#, no-wrap, priority:100
msgid ""
"            4 3 2 1\n"
"            G-H-I-J\n"
"1 2 3 4 5 6/       \\0\n"
"A-B-C-D-E-F         O\n"
"           \\       /\n"
"            K-L-M-N\n"
"            4 3 2 1\n"
msgstr ""
"            4 3 2 1\n"
"            G-H-I-J\n"
"1 2 3 4 5 6/       \\0\n"
"A-B-C-D-E-F         O\n"
"           \\       /\n"
"            K-L-M-N\n"
"            4 3 2 1\n"

#. type: Plain text
#: en/git-bisect-lk2009.txt:662
#, priority:100
msgid "but with the algorithm used by git bisect we get:"
msgstr "但是使用Git二分查找算法，我们得到："

#. type: delimited block -
#: en/git-bisect-lk2009.txt:671
#, no-wrap, priority:100
msgid ""
"            7 7 6 5\n"
"            G-H-I-J\n"
"1 2 3 4 5 6/       \\0\n"
"A-B-C-D-E-F         O\n"
"           \\       /\n"
"            K-L-M-N\n"
"            7 7 6 5\n"
msgstr ""
"            7 7 6 5\n"
"            G-H-I-J\n"
"1 2 3 4 5 6/       \\0\n"
"A-B-C-D-E-F         O\n"
"           \\       /\n"
"            K-L-M-N\n"
"            7 7 6 5\n"

#. type: Plain text
#: en/git-bisect-lk2009.txt:678
#, priority:100
msgid "So we chose G, H, K or L as the best bisection point, which is better than F. Because if for example L is bad, then we will know not only that L, M and N are bad but also that G, H, I and J are not the first bad commit (since we suppose that there is only one first bad commit and it must be an ancestor of L)."
msgstr "因此，我们选择G、H、K或L作为最佳平分点，这比F更好。因为，如果L是坏的，那么我们不仅知道L、M和N是坏的，而且还知道G、H、I和J不是第一个坏提交(因为我们假设只有一个第一个坏提交，而且它必须是L的祖先)。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:681
#, priority:100
msgid "So the current algorithm seems to be the best possible given what we initially supposed."
msgstr "因此，鉴于我们最初假设的算法，当前的算法似乎是最好的。"

#. type: Title ~
#: en/git-bisect-lk2009.txt:683
#, no-wrap, priority:100
msgid "Skip algorithm"
msgstr "跳过算法"

#. type: Plain text
#: en/git-bisect-lk2009.txt:688
#, priority:100
msgid "When some commits have been skipped (using \"git bisect skip\"), then the bisection algorithm is the same for step 1) to 3). But then we use roughly the following steps:"
msgstr "当跳过一些提交（使用“git bisect skip”）时，步骤 1 到 3 的二分算法是相同的）。但是，让我们来使用以下步骤："

#. type: Plain text
#: en/git-bisect-lk2009.txt:690
#, priority:100
msgid "sort the commit by decreasing associated value"
msgstr "通过减少关联值对提交进行排序"

#. type: Plain text
#: en/git-bisect-lk2009.txt:693
#, priority:100
msgid "if the first commit has not been skipped, we can return it and stop here"
msgstr "如果没有跳过第一次提交，我们可以返回它并在此处停止"

#. type: Plain text
#: en/git-bisect-lk2009.txt:695
#, priority:100
msgid "otherwise filter out all the skipped commits in the sorted list"
msgstr "否则过滤掉排序列表中所有跳过的提交"

#. type: Plain text
#: en/git-bisect-lk2009.txt:698
#, priority:100
msgid "use a pseudo random number generator (PRNG) to generate a random number between 0 and 1"
msgstr "使用伪随机数生成器 （PRNG） 生成介于 0 和 1 之间的随机数"

#. type: Plain text
#: en/git-bisect-lk2009.txt:701
#, priority:100
msgid "multiply this random number with its square root to bias it toward 0"
msgstr "将此随机数与其平方根相乘，使其偏向 0"

#. type: Plain text
#: en/git-bisect-lk2009.txt:704
#, priority:100
msgid "multiply the result by the number of commits in the filtered list to get an index into this list"
msgstr "将结果乘以过滤后的列表中的提交数量，得到该列表的索引"

#. type: Plain text
#: en/git-bisect-lk2009.txt:706
#, priority:100
msgid "return the commit at the computed index"
msgstr "返回计算出的索引处的提交"

#. type: Title ~
#: en/git-bisect-lk2009.txt:708
#, no-wrap, priority:100
msgid "Skip algorithm discussed"
msgstr "跳过算法讨论"

#. type: Plain text
#: en/git-bisect-lk2009.txt:715
#, priority:100
msgid "After step 7) (in the skip algorithm), we could check if the second commit has been skipped and return it if it is not the case. And in fact that was the algorithm we used from when \"git bisect skip\" was developed in Git version 1.5.4 (released on February 1st 2008) until Git version 1.6.4 (released July 29th 2009)."
msgstr "在步骤7）（跳过算法中）之后，我们可以检查第二次提交是否已经被跳过，如果不是这样，则返回它。事实上，这就是我们从Git 1.5.4版本（2008年2月1日发布）开发 \"git bisect skip \"时开始使用的算法，直到Git 1.6.4版本（2009年7月29日发布）。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:721
#, priority:100
msgid "But Ingo Molnar and H. Peter Anvin (another well known linux kernel developer) both complained that sometimes the best bisection points all happened to be in an area where all the commits are untestable. And in this case the user was asked to test many untestable commits, which could be very inefficient."
msgstr "但是Ingo Molnar和H. Peter Anvin（另一个著名的Linux内核开发者）都抱怨说，有时最好的分界点都碰巧在一个所有提交都无法测试的区域。而在这种情况下，用户被要求测试许多不可测试的提交，这可能是非常低效的。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:725
#, priority:100
msgid "Indeed untestable commits are often untestable because a breakage was introduced at one time, and that breakage was fixed only after many other commits were introduced."
msgstr "事实上，不可测试的提交往往是因为某次引入了一个破绽，而这个破绽是在引入了许多其他的提交之后才被修复的。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:729
#, priority:100
msgid "This breakage is of course most of the time unrelated to the breakage we are trying to locate in the commit graph. But it prevents us to know if the interesting \"bad behavior\" is present or not."
msgstr "当然，这种破坏在大多数时候与我们试图在提交图中定位的破坏无关。但它却让我们无法知道有趣的 \"坏行为 \"是否存在。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:733
#, priority:100
msgid "So it is a fact that commits near an untestable commit have a high probability of being untestable themselves. And the best bisection commits are often found together too (due to the bisection algorithm)."
msgstr "因此，在不可测试的提交附近的提交，其本身也有很大可能是不可测试的。而且，最好的分界线提交也经常被发现在一起（由于二分算法的原因）。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:736
#, priority:100
msgid "This is why it is a bad idea to just chose the next best unskipped bisection commit when the first one has been skipped."
msgstr "这就是为什么当第一个分界线被跳过时，直接选择下一个最好的未跳过的分界线提交是个坏主意。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:741
#, priority:100
msgid "We found that most commits on the graph may give quite a lot of information when they are tested. And the commits that will not on average give a lot of information are the one near the good and bad commits."
msgstr "我们发现，图中的大多数提交在被测试时可能会提供相当多的信息。而那些平均来说不会提供大量信息的提交是靠近好的和坏的提交。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:744
#, priority:100
msgid "So using a PRNG with a bias to favor commits away from the good and bad commits looked like a good choice."
msgstr "因此，使用一个有偏向性的PRNG来偏向于远离好的和坏的提交，看起来是一个不错的选择。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:751
#, priority:100
msgid "One obvious improvement to this algorithm would be to look for a commit that has an associated value near the one of the best bisection commit, and that is on another branch, before using the PRNG. Because if such a commit exists, then it is not very likely to be untestable too, so it will probably give more information than a nearly randomly chosen one."
msgstr "这个算法的一个明显的改进是，在使用PRNG之前，寻找一个与最佳分叉提交的值接近的提交，而且是在另一个分支上。因为如果这样的提交存在，那么它也不太可能是不可测试的，所以它可能会比几乎随机选择的提交提供更多信息。"

#. type: Title ~
#: en/git-bisect-lk2009.txt:753
#, no-wrap, priority:100
msgid "Checking merge bases"
msgstr "检查合并基础"

#. type: Plain text
#: en/git-bisect-lk2009.txt:757
#, priority:100
msgid "There is another tweak in the bisection algorithm that has not been described in the \"bisection algorithm\" above."
msgstr "分割算法中还有一个调整，在上面的 \"二分算法 \"中没有描述。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:761
#, priority:100
msgid "We supposed in the previous examples that the \"good\" commits were ancestors of the \"bad\" commit. But this is not a requirement of \"git bisect\"."
msgstr "在前面的例子中，我们认为 \"好 \"的提交是 \"坏 \"的提交的祖先。但这并不是 \"git bisect \"的要求。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:769
#, priority:100
msgid "Of course the \"bad\" commit cannot be an ancestor of a \"good\" commit, because the ancestors of the good commits are supposed to be \"good\". And all the \"good\" commits must be related to the bad commit.  They cannot be on a branch that has no link with the branch of the \"bad\" commit. But it is possible for a good commit to be related to a bad commit and yet not be neither one of its ancestor nor one of its descendants."
msgstr "当然，\"坏 \"提交不可能是 \"好 \"提交的祖先，因为好提交的祖先应该是 \"好 \"的。而所有 \"好 \"的提交必须与坏的提交有关。  它们不可能在一个与 \"坏 \"提交的分支没有联系的分支上。但是，一个好的提交有可能与一个坏的提交有关系，但既不是它的祖先，也不是它的后代。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:772
#, priority:100
msgid "For example, there can be a \"main\" branch, and a \"dev\" branch that was forked of the main branch at a commit named \"D\" like this:"
msgstr "例如，可以有一个 \"main\"分支和一个 \"dev\"分支，后者是从main分支中提交名为 \"D\"的提交克隆出来的，如下所示："

#. type: delimited block -
#: en/git-bisect-lk2009.txt:777
#, no-wrap, priority:100
msgid ""
"A-B-C-D-E-F-G  <--main\n"
"       \\\n"
"        H-I-J  <--dev\n"
msgstr ""
"A-B-C-D-E-F-G  <--main\n"
"       \\\n"
"        H-I-J  <--dev\n"

#. type: Plain text
#: en/git-bisect-lk2009.txt:781
#, priority:100
msgid "The commit \"D\" is called a \"merge base\" for branch \"main\" and \"dev\" because it's the best common ancestor for these branches for a merge."
msgstr "提交 \"D \"被称为 \"main \"和 \"dev \"分支的 \"合并基础\"，因为它是这些分支可以进行合并的最佳共同祖先。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:785
#, priority:100
msgid "Now let's suppose that commit J is bad and commit G is good and that we apply the bisection algorithm like it has been previously described."
msgstr "现在我们假设提交J是坏的，提交G是好的，并且我们像之前描述的那样应用二分法。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:789
#, priority:100
msgid "As described in step 1) b) of the bisection algorithm, we remove all the ancestors of the good commits because they are supposed to be good too."
msgstr "正如一分为二算法的步骤1）b）所描述的那样，我们移除所有好提交的祖先，因为他们也应该是好的。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:791
#, priority:100
msgid "So we would be left with only:"
msgstr "因此，我们将只剩下："

#. type: delimited block -
#: en/git-bisect-lk2009.txt:794
#, fuzzy, no-wrap, priority:100
msgid "H-I-J\n"
msgstr "H-I-J\n"

#. type: Plain text
#: en/git-bisect-lk2009.txt:798
#, priority:100
msgid "But what happens if the first bad commit is \"B\" and if it has been fixed in the \"main\" branch by commit \"F\"?"
msgstr "但如果第一个坏的提交是 \"B\"，而在 \"main\"分支中已经被提交 \"F \"修复，会发生什么？"

#. type: Plain text
#: en/git-bisect-lk2009.txt:801
#, priority:100
msgid "The result of such a bisection would be that we would find that H is the first bad commit, when in fact it's B. So that would be wrong!"
msgstr "这样一分为二后，我们会发现H是第一个坏提交，但实际上第一个坏提交是B，所以这将造成错误的结果！"

#. type: Plain text
#: en/git-bisect-lk2009.txt:807
#, priority:100
msgid "And yes it can happen in practice that people working on one branch are not aware that people working on another branch fixed a bug! It could also happen that F fixed more than one bug or that it is a revert of some big development effort that was not ready to be released."
msgstr "在实践中可能会发生这样的情况：在一个分支上工作的人不知道在另一个分支上工作的人修复了一个bug！也可能发生的情况是，F修复了不止一个bug，或者是对一些尚未准备好发布的大型开发工作进行了恢复。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:813
#, priority:100
msgid "In fact development teams often maintain both a development branch and a maintenance branch, and it would be quite easy for them if \"git bisect\" just worked when they want to bisect a regression on the development branch that is not on the maintenance branch. They should be able to start bisecting using:"
msgstr "事实上，开发团队经常同时维护一个开发分支和一个维护分支，如果 \"git bisect \"只是在他们想对开发分支上的回归进行分流而不在维护分支上的时候发挥作用，那对他们来说会很容易。他们应该可以用以下方法开始二分："

#. type: delimited block -
#: en/git-bisect-lk2009.txt:816
#, fuzzy, no-wrap, priority:100
msgid "$ git bisect start dev main\n"
msgstr "$ git bisect start dev main\n"

#. type: Plain text
#: en/git-bisect-lk2009.txt:823
#, priority:100
msgid "To enable that additional nice feature, when a bisection is started and when some good commits are not ancestors of the bad commit, we first compute the merge bases between the bad and the good commits and we chose these merge bases as the first commits that will be checked out and tested."
msgstr "为了实现这个额外的功能，当一个分界开始，一些好的提交不是坏的提交的祖先时，我们首先计算坏的提交和好的提交之间的合并基数，我们选择这些合并基数作为第一个将被检查和测试的提交。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:826
#, priority:100
msgid "If it happens that one merge base is bad, then the bisection process is stopped with a message like:"
msgstr "如果有一个合并基数是坏的，那么二分过程就会停止，并发出类似的信息："

#. type: delimited block -
#: en/git-bisect-lk2009.txt:830
#, ignore-ellipsis, no-wrap, priority:100
msgid ""
"The merge base BBBBBB is bad.\n"
"This means the bug has been fixed between BBBBBB and [GGGGGG,...].\n"
msgstr ""
"合并基础BBBBB是坏的。\n"
"这意味着BBBBB和[GGGGG,...]之间的错误已经被修复。\n"

#. type: Plain text
#: en/git-bisect-lk2009.txt:834
#, ignore-ellipsis, priority:100
msgid "where BBBBBB is the sha1 hash of the bad merge base and [GGGGGG,...] is a comma separated list of the sha1 of the good commits."
msgstr "其中BBBBBB是坏合并基础的sha1哈希值，[GGGGG,...]是好提交的sha1的逗号分隔列表。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:838
#, priority:100
msgid "If some of the merge bases are skipped, then the bisection process continues, but the following message is printed for each skipped merge base:"
msgstr "如果一些合并基点被跳过，那么二分过程将继续进行，但对于每一个被跳过的合并基点都会打印出以下信息："

#. type: delimited block -
#: en/git-bisect-lk2009.txt:843
#, ignore-ellipsis, no-wrap, priority:100
msgid ""
"Warning: the merge base between BBBBBB and [GGGGGG,...] must be skipped.\n"
"So we cannot be sure the first bad commit is between MMMMMM and BBBBBB.\n"
"We continue anyway.\n"
msgstr ""
"警告：BBBBB和[GGGGG,...]之间的合并基数必须被跳过。\n"
"所以我们不能确定第一个坏提交是在MMMMMM和BBBBB之间。\n"
"我们会继续操作。\n"

#. type: Plain text
#: en/git-bisect-lk2009.txt:848
#, ignore-ellipsis, priority:100
msgid "where BBBBBB is the sha1 hash of the bad commit, MMMMMM is the sha1 hash of the merge base that is skipped and [GGGGGG,...] is a comma separated list of the sha1 of the good commits."
msgstr "其中BBBBB是坏提交的sha1哈希值，MMMMM是被跳过的合并基础的sha1哈希值，[GGGGG,...]是好提交的sha1的逗号分隔列表。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:851
#, priority:100
msgid "So if there is no bad merge base, the bisection process continues as usual after this step."
msgstr "因此，如果没有坏的合并基础，在这一步之后，二分过程照常进行。"

#. type: Title -
#: en/git-bisect-lk2009.txt:853
#, no-wrap, priority:100
msgid "Best bisecting practices"
msgstr "最佳的二分做法"

#. type: Title ~
#: en/git-bisect-lk2009.txt:856
#, no-wrap, priority:100
msgid "Using test suites and git bisect together"
msgstr "测试套件和git bisect一起使用"

#. type: Plain text
#: en/git-bisect-lk2009.txt:863
#, priority:100
msgid "If you both have a test suite and use git bisect, then it becomes less important to check that all tests pass after each commit. Though of course it is probably a good idea to have some checks to avoid breaking too many things because it could make bisecting other bugs more difficult."
msgstr "如果你有一个测试套件并使用git bisect，那么在每次提交后检查所有测试是否通过就变得不那么重要。当然，为了避免破坏太多的东西，有一些检查可能是个好的做法，因为这可能会使二分其他bug更加困难。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:868
#, priority:100
msgid "You can focus your efforts to check at a few points (for example rc and beta releases) that all the T test cases pass for all the N configurations. And when some tests don't pass you can use \"git bisect\" (or better \"git bisect run\"). So you should perform roughly:"
msgstr "你可以集中精力在几个点上检查（例如rc和beta版本），所有的T测试用例在所有的N个配置下都能通过。当一些测试没有通过时，你可以使用 \"git bisect\"（当然\"git bisect run\"更好）。所以你应该大致上执行："

#. type: delimited block -
#: en/git-bisect-lk2009.txt:871
#, no-wrap, priority:100
msgid "c * N * T + b * M * log2(M) tests\n"
msgstr "c * N * T + b * M * log2(M) tests\n"

#. type: Plain text
#: en/git-bisect-lk2009.txt:875
#, priority:100
msgid "where c is the number of rounds of test (so a small constant) and b is the ratio of bug per commit (hopefully a small constant too)."
msgstr "其中c是测试的轮数（所以是一个小常数），b是每次提交的bug比例（希望也是一个小常数）。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:878
#, priority:100
msgid "So of course it's much better as it's O(N * T) vs O(N * T * M) if you would test everything after each commit."
msgstr "所以，如果你在每次提交后都测试所有内容，O(N * T)当然比O(N * T * M)要好得多 。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:883
#, priority:100
msgid "This means that test suites are good to prevent some bugs from being committed and they are also quite good to tell you that you have some bugs. But they are not so good to tell you where some bugs have been introduced. To tell you that efficiently, git bisect is needed."
msgstr "这意味着测试套件对于防止一些bug被提交是很好的，它们对于告诉你有一些bug也是很好的。但它们并不能很好地告诉你一些错误是在哪里被引入的。所以需要git bisect告诉你这些信息。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:890
#, priority:100
msgid "The other nice thing with test suites, is that when you have one, you already know how to test for bad behavior. So you can use this knowledge to create a new test case for \"git bisect\" when it appears that there is a regression. So it will be easier to bisect the bug and fix it. And then you can add the test case you just created to your test suite."
msgstr "测试套件的另一个好处是，当你有一个测试套件时，你已经知道如何测试不良行为。因此，当出现类似问题时，你可以使用这些知识来创建一个新的 \"git bisect \"测试案例。这样就能更容易地将bug二分并修复它。然后你就可以把你刚创建的测试用例添加到你的测试套件中。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:893
#, priority:100
msgid "So if you know how to create test cases and how to bisect, you will be subject to a virtuous circle:"
msgstr "因此，如果你知道如何创建测试用例和二分，你就会受到良性循环的影响："

#. type: Plain text
#: en/git-bisect-lk2009.txt:895
#, priority:100
msgid "more tests => easier to create tests => easier to bisect => more tests"
msgstr "更多的测试 => 更容易创建测试 => 更容易二分 => 更多的测试"

#. type: Plain text
#: en/git-bisect-lk2009.txt:898
#, priority:100
msgid "So test suites and \"git bisect\" are complementary tools that are very powerful and efficient when used together."
msgstr "因此，测试套件和 \"git bisect \"是互补的工具，一起使用时非常强大和高效。"

#. type: Title ~
#: en/git-bisect-lk2009.txt:900
#, no-wrap, priority:100
msgid "Bisecting build failures"
msgstr "对构建失败的二分"

#. type: Plain text
#: en/git-bisect-lk2009.txt:904
#, priority:100
msgid "You can very easily automatically bisect broken builds using something like:"
msgstr "你可以非常容易地使用类似的东西来自动划分破碎的构建："

#. type: delimited block -
#: en/git-bisect-lk2009.txt:908
#, fuzzy, no-wrap, priority:100
msgid ""
"$ git bisect start BAD GOOD\n"
"$ git bisect run make\n"
msgstr ""
"$ git bisect start BAD GOOD\n"
"$ git bisect run make\n"

#. type: Title ~
#: en/git-bisect-lk2009.txt:911
#, no-wrap, priority:100
msgid "Passing sh -c \"some commands\" to \"git bisect run\""
msgstr "将sh -c \"一些命令 \"传递给 \"git bisect运行\""

#. type: delimited block -
#: en/git-bisect-lk2009.txt:917
#, fuzzy, no-wrap, priority:100
msgid "$ git bisect run sh -c \"make || exit 125; ./my_app | grep 'good output'\"\n"
msgstr "$ git bisect run sh -c \"make || exit 125; ./my_app | grep 'good output'\"\n"

#. type: Plain text
#: en/git-bisect-lk2009.txt:921
#, priority:100
msgid "On the other hand if you do this often, then it can be worth having scripts to avoid too much typing."
msgstr "另一方面，如果你经常这样做，那么就值得用脚本来避免过多的输入。"

#. type: Title ~
#: en/git-bisect-lk2009.txt:923
#, no-wrap, priority:100
msgid "Finding performance regressions"
msgstr "寻找性能回归"

#. type: Plain text
#: en/git-bisect-lk2009.txt:927
#, priority:100
msgid "Here is an example script that comes slightly modified from a real world script used by Junio Hamano <<4>>."
msgstr "这里有一个例子，它是由Junio Hamano使用真实案例的脚本稍加修改而成的<<4>>。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:930
#, priority:100
msgid "This script can be passed to \"git bisect run\" to find the commit that introduced a performance regression:"
msgstr "这个脚本可以传递给 \"git bisect run\"，以找到引入性能回归的提交："

#. type: delimited block -
#: en/git-bisect-lk2009.txt:936
#, no-wrap, priority:100
msgid ""
"# Build errors are not what I am interested in.\n"
"make my_app || exit 255\n"
msgstr ""
"# 我并不关心构建中的错误。\n"
"make my_app || exit 255\n"

#. type: delimited block -
#: en/git-bisect-lk2009.txt:939
#, ignore-ellipsis, no-wrap, priority:100
msgid ""
"# We are checking if it stops in a reasonable amount of time, so\n"
"# let it run in the background...\n"
msgstr ""
"# 我们要检查它是否在合理的时间内停止，所以\n"
"# 让它在后台运行...\n"

#. type: delimited block -
#: en/git-bisect-lk2009.txt:941
#, fuzzy, no-wrap, priority:100
msgid "./my_app >log 2>&1 &\n"
msgstr "./my_app >log 2>&1 &\n"

#. type: delimited block -
#: en/git-bisect-lk2009.txt:944
#, ignore-ellipsis, no-wrap, priority:100
msgid ""
"# ... and grab its process ID.\n"
"pid=$!\n"
msgstr ""
"# ... 并抓取其进程ID。\n"
"pid=$!\n"

#. type: delimited block -
#: en/git-bisect-lk2009.txt:947
#, ignore-ellipsis, no-wrap, priority:100
msgid ""
"# ... and then wait for sufficiently long.\n"
"sleep $NORMAL_TIME\n"
msgstr ""
"# ... 然后等待足够长的时间。\n"
"sleep $NORMAL_TIME\n"

#. type: delimited block -
#: en/git-bisect-lk2009.txt:959
#, ignore-ellipsis, no-wrap, priority:100
msgid ""
"# ... and then see if the process is still there.\n"
"if kill -0 $pid\n"
"then\n"
"\t# It is still running -- that is bad.\n"
"\tkill $pid; sleep 1; kill $pid;\n"
"\texit 1\n"
"else\n"
"\t# It has already finished (the $pid process was no more),\n"
"\t# and we are happy.\n"
"\texit 0\n"
"fi\n"
msgstr ""
"# ... 然后看看这个进程是否还在那里。\n"
"if kill -0 $pid\n"
"then\n"
"\t# 它仍然在运行 -- 有点失望。\n"
"\tkill $pid; sleep 1; kill $pid；\n"
"\texit 1\n"
"else\n"
"\t# 它已经结束了（$pid进程不再存在）,\n"
"\t# 皆大欢喜。\n"
"\texit 0\n"
"fi\n"

#. type: Title ~
#: en/git-bisect-lk2009.txt:962
#, no-wrap, priority:100
msgid "Following general best practices"
msgstr "遵循一般的最佳做法"

#. type: Plain text
#: en/git-bisect-lk2009.txt:967
#, priority:100
msgid "It is obviously a good idea not to have commits with changes that knowingly break things, even if some other commits later fix the breakage."
msgstr "显然，不要在提交时明知故犯是最好的，即使后来有其他的提交修复了错误。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:970
#, priority:100
msgid "It is also a good idea when using any VCS to have only one small logical change in each commit."
msgstr "在使用任何VCS时，最好是每次提交只有一个小的逻辑变化。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:975
#, priority:100
msgid "The smaller the changes in your commit, the most effective \"git bisect\" will be. And you will probably need \"git bisect\" less in the first place, as small changes are easier to review even if they are only reviewed by the committer."
msgstr "你的提交中的改动越小，\"git bisect \"就越有效。并且你可能一开始就不太需要 \"git bisect\"，因为即使只有提交者审查，小改动也更容易审查。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:978
#, priority:100
msgid "Another good idea is to have good commit messages. They can be very helpful to understand why some changes were made."
msgstr "另一个好的办法是要有一个明确的提交信息。它们对于理解为什么要做一些改动是非常有帮助的。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:980
#, priority:100
msgid "These general best practices are very helpful if you bisect often."
msgstr "如果你经常进行二分操作，一般这些最佳实践是非常有帮助的。"

#. type: Title ~
#: en/git-bisect-lk2009.txt:982
#, no-wrap, priority:100
msgid "Avoiding bug prone merges"
msgstr "避免容易出错的合并"

#. type: Plain text
#: en/git-bisect-lk2009.txt:988
#, priority:100
msgid "First merges by themselves can introduce some regressions even when the merge needs no source code conflict resolution. This is because a semantic change can happen in one branch while the other branch is not aware of it."
msgstr "即便合并不需要解决源代码冲突，但一次合并本身就会带来一些回归问题。这是因为语义变化可能发生在一个分支，而另一个分支并不知道该变化。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:991
#, priority:100
msgid "For example one branch can change the semantic of a function while the other branch add more calls to the same function."
msgstr "例如，一个分支可以改变一个函数的语义，而另一个分支则对同一个函数增加更多的调用。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:998
#, priority:100
msgid "This is made much worse if many files have to be fixed to resolve conflicts. That's why such merges are called \"evil merges\". They can make regressions very difficult to track down. It can even be misleading to know the first bad commit if it happens to be such a merge, because people might think that the bug comes from bad conflict resolution when it comes from a semantic change in one branch."
msgstr "如果为了解决冲突而不得不修复许多文件，情况就会变得更糟。这就是为什么这种合并被称为 \"邪恶合并\"。它们会使回归变得非常难以追踪。如果恰好合并了一个这样的坏提交，就很可能会产生误会，因为人们可能会认为这个错误来自于糟糕的冲突解决，但事实上它来自于一个分支的语义变化。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:1004
#, priority:100
msgid "Anyway \"git rebase\" can be used to linearize history. This can be used either to avoid merging in the first place. Or it can be used to bisect on a linear history instead of the non linear one, as this should give more information in case of a semantic change in one branch."
msgstr "无论如何，\"git rebase \"可以用来线性化历史。这也可以用来一开始就避免错误的合并。或者，它可以用来在线性历史上进行二分，而不是在非线性历史上进行二分，因为这在一个分支发生语义变化的情况下会提供更多信息。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:1007
#, priority:100
msgid "Merges can be also made simpler by using smaller branches or by using many topic branches instead of only long version related branches."
msgstr "通过使用较小的分支或使用许多主题分支而不是只使用一个非常长的分支，也可以使合并更简单。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:1010
#, priority:100
msgid "And testing can be done more often in special integration branches like linux-next for the linux kernel."
msgstr "而测试可以在特殊的集成分支中更频繁地进行，比如linux-next的linux内核。"

#. type: Title ~
#: en/git-bisect-lk2009.txt:1012
#, no-wrap, priority:100
msgid "Adapting your work-flow"
msgstr "调整你的工作流程"

#. type: Plain text
#: en/git-bisect-lk2009.txt:1015
#, priority:100
msgid "A special work-flow to process regressions can give great results."
msgstr "一个处理回归的特殊工作流程可以带来好的结果。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:1017
#, priority:100
msgid "Here is an example of a work-flow used by Andreas Ericsson:"
msgstr "比如，以下是Andreas Ericsson使用的一个工作流程："

#. type: Plain text
#: en/git-bisect-lk2009.txt:1019
#, priority:100
msgid "write, in the test suite, a test script that exposes the regression"
msgstr "在测试套件中，写一个测试脚本，暴露出回归的问题"

#. type: Plain text
#: en/git-bisect-lk2009.txt:1020
#, fuzzy, priority:100
msgid "use \"git bisect run\" to find the commit that introduced it"
msgstr "使用 \"git bisect run\" 查找引入它的提交"

#. type: Plain text
#: en/git-bisect-lk2009.txt:1021
#, priority:100
msgid "fix the bug that is often made obvious by the previous step"
msgstr "修复由上一步骤暴露出来的错误"

#. type: Plain text
#: en/git-bisect-lk2009.txt:1022
#, priority:100
msgid "commit both the fix and the test script (and if needed more tests)"
msgstr "提交修复和测试脚本（如果需要更多测试）"

#. type: Plain text
#: en/git-bisect-lk2009.txt:1024
#, priority:100
msgid "And here is what Andreas said about this work-flow <<5>>:"
msgstr "这里是Andreas对这个工作流程的评价<<5>>："

#. type: delimited block _
#: en/git-bisect-lk2009.txt:1034
#, priority:100
msgid "To give some hard figures, we used to have an average report-to-fix cycle of 142.6 hours (according to our somewhat weird bug-tracker which just measures wall-clock time). Since we moved to Git, we've lowered that to 16.2 hours. Primarily because we can stay on top of the bug fixing now, and because everyone's jockeying to get to fix bugs (we're quite proud of how lazy we are to let Git find the bugs for us). Each new release results in ~40% fewer bugs (almost certainly due to how we now feel about writing tests)."
msgstr "我们曾经有142.6小时的平均报告到修复周期（由我们只是测量时钟时间的错误跟踪器统计出）。自从我们转移到Git后，我们已经把这个时间降低到了16.2小时。主要是因为我们现在可以保持在最开始进行错误修复，也因为每个人都在争先恐后地修复错误（我们对自己懒得让Git为我们找到错误感到很自豪）。每个新的版本都会减少40%的bug（出于我们现在对编写测试的感觉，这个结果非常可信）。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:1039
#, priority:100
msgid "Clearly this work-flow uses the virtuous circle between test suites and \"git bisect\". In fact it makes it the standard procedure to deal with regression."
msgstr "显然，这个工作流程使用了测试套件和 \"git bisect \"之间的良性循环。事实上，也正是因此它才成为为处理回归的标准程序。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:1044
#, ignore-ellipsis, priority:100
msgid "In other messages Andreas says that they also use the \"best practices\" described above: small logical commits, topic branches, no evil merge,... These practices all improve the bisectability of the commit graph, by making it easier and more useful to bisect."
msgstr "在其他信息中，Andreas说他们也使用了上述的 \"最佳实践\"：小的逻辑提交，主题分支，没有邪恶的合并，......。这些做法都提高了提交图的可分性，使之更容易、更有用。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:1047
#, priority:100
msgid "So a good work-flow should be designed around the above points. That is making bisecting easier, more useful and standard."
msgstr "因此，一个好的工作流程应该围绕以上几点来设计。这就是让分界线变得更容易、更有用和更标准。"

#. type: Title ~
#: en/git-bisect-lk2009.txt:1049
#, no-wrap, priority:100
msgid "Involving QA people and if possible end users"
msgstr "让QA人员参与进来，如果可能的话，让终端用户参与进来"

#. type: Plain text
#: en/git-bisect-lk2009.txt:1055
#, priority:100
msgid "One nice about \"git bisect\" is that it is not only a developer tool. It can effectively be used by QA people or even end users (if they have access to the source code or if they can get access to all the builds)."
msgstr "关于 \"git bisect \"的一个好处是，它不仅仅是一个开发者工具。它可以有效地被QA人员甚至终端用户使用（如果他们能够访问源代码或者能够获得所有构建的权限）。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:1059
#, priority:100
msgid "There was a discussion at one point on the linux kernel mailing list of whether it was ok to always ask end user to bisect, and very good points were made to support the point of view that it is ok."
msgstr "在linux内核邮件列表中曾一度讨论过总是要求终端用户进行分割是否可行，并提出了非常好的观点来支持可以这样做的观点。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:1061
#, priority:100
msgid "For example David Miller wrote <<6>>:"
msgstr "例如，David Miller写道<<6>>："

#. type: delimited block _
#: en/git-bisect-lk2009.txt:1068
#, priority:100
msgid "What people don't get is that this is a situation where the \"end node principle\" applies. When you have limited resources (here: developers)  you don't push the bulk of the burden upon them. Instead you push things out to the resource you have a lot of, the end nodes (here: users), so that the situation actually scales."
msgstr "人们不明白的是，这是一个适用 \"终端节点原则 \"的情况。当你拥有有限的资源时（这里是指开发人员），你不会把大部分的负担推给他们。相反，你要把事情推给你拥有的大量资源，即终端节点（这里：用户），这样情况才会有实际的扩展。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:1072
#, priority:100
msgid "This means that it is often \"cheaper\" if QA people or end users can do it."
msgstr "这意味着，如果QA人员或终端用户能够做到这一点，往往会 \"更便宜\"。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:1079
#, priority:100
msgid "What is interesting too is that end users that are reporting bugs (or QA people that reproduced a bug) have access to the environment where the bug happens. So they can often more easily reproduce a regression. And if they can bisect, then more information will be extracted from the environment where the bug happens, which means that it will be easier to understand and then fix the bug."
msgstr "有趣的是，报告错误的终端用户（或重现错误的QA人员）可以进入发生错误的环境。所以他们通常可以更容易地重现一个回归。如果他们能进行二分法，那么就可以从发生错误的环境中提取更多的信息，这意味着将更容易理解，然后修复错误。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:1083
#, priority:100
msgid "For open source projects it can be a good way to get more useful contributions from end users, and to introduce them to QA and development activities."
msgstr "对于开源项目来说，这可能是一个很好的方法，可以从终端用户那里获得更多有用的贡献，并将他们引入QA和开发活动。"

#. type: Title ~
#: en/git-bisect-lk2009.txt:1085
#, no-wrap, priority:100
msgid "Using complex scripts"
msgstr "使用复杂脚本"

#. type: Plain text
#: en/git-bisect-lk2009.txt:1089
#, priority:100
msgid "In some cases like for kernel development it can be worth developing complex scripts to be able to fully automate bisecting."
msgstr "在某些情况下，如内核开发，值得开发复杂的脚本，以便能够完全自动化地进行二分。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:1091
#, priority:100
msgid "Here is what Ingo Molnar says about that <<7>>:"
msgstr "以下是Ingo Molnar对此的评价<<7>>："

#. type: delimited block _
#: en/git-bisect-lk2009.txt:1101
#, priority:100
msgid "i have a fully automated bootup-hang bisection script. It is based on \"git-bisect run\". I run the script, it builds and boots kernels fully automatically, and when the bootup fails (the script notices that via the serial log, which it continuously watches - or via a timeout, if the system does not come up within 10 minutes it's a \"bad\" kernel), the script raises my attention via a beep and i power cycle the test box. (yeah, i should make use of a managed power outlet to 100% automate it)"
msgstr "我有一个完全自动化启动并挂起的二分脚本。它是基于 \"git-bisect run \"的。我运行这个脚本，它完全自动地构建和启动内核，当启动失败时（脚本通过连续观察的串行日志注意到这一点或者是通过超时判断，如果系统在10分钟内没有启动，就是一个 \"坏 \"内核），脚本通过嘟嘟声引起我的注意，我就给测试机断电。(的确，我应该使用一个可管理的电源插座来实现100%的自动化）"

#. type: Title ~
#: en/git-bisect-lk2009.txt:1104
#, no-wrap, priority:100
msgid "Combining test suites, git bisect and other systems together"
msgstr "将测试组件、git bisect 和其他系统组合在一起"

#. type: Plain text
#: en/git-bisect-lk2009.txt:1109
#, priority:100
msgid "We have seen that test suites and git bisect are very powerful when used together. It can be even more powerful if you can combine them with other systems."
msgstr "我们已经看到，测试套件和git bisect一起使用时已经非常强大了。如果你能把它们和其他系统结合起来，那将更加强大。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:1116
#, priority:100
msgid "For example some test suites could be run automatically at night with some unusual (or even random) configurations. And if a regression is found by a test suite, then \"git bisect\" can be automatically launched, and its result can be emailed to the author of the first bad commit found by \"git bisect\", and perhaps other people too. And a new entry in the bug tracking system could be automatically created too."
msgstr "例如，一些测试套件可以在晚上以一些不寻常（甚至是随机）的配置自动运行。如果测试套件发现了一个回归问题，那么 \"git bisect \"可以自动启动，其结果可以通过电子邮件发给 \"git bisect\"发现的第一个坏提交的作者，也许还有其他人。并且在错误跟踪系统中自动创建一个新条目。"

#. type: Title -
#: en/git-bisect-lk2009.txt:1119
#, no-wrap, priority:100
msgid "The future of bisecting"
msgstr "未来的二分算法"

#. type: Title ~
#: en/git-bisect-lk2009.txt:1122
#, fuzzy, no-wrap, priority:100
#| msgid "git-replace(1)"
msgid "\"git replace\""
msgstr "\"git replace\""

#. type: Plain text
#: en/git-bisect-lk2009.txt:1128
#, priority:100
msgid "We saw earlier that \"git bisect skip\" is now using a PRNG to try to avoid areas in the commit graph where commits are untestable. The problem is that sometimes the first bad commit will be in an untestable area."
msgstr "之前，我们发现，\"git bisect skip\"目前使用PRNG来试图避免提交图中不可测试的区域。但问题是，有时第一个坏的提交恰恰在一个无法测试的区域。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:1134
#, priority:100
msgid "To simplify the discussion we will suppose that the untestable area is a simple string of commits and that it was created by a breakage introduced by one commit (let's call it BBC for bisect breaking commit) and later fixed by another one (let's call it BFC for bisect fixing commit)."
msgstr "为了简化这个话题，我们将假设不可测试区是一串简单的提交，它是由一个提交（我们称它为BBC，意为双断裂提交）引起的断裂，后来被另一个提交修复（我们称它为BFC，意为双断裂修复提交）。"

#. type: delimited block -
#: en/git-bisect-lk2009.txt:1139
#, ignore-ellipsis, no-wrap, priority:100
msgid "...-Y-BBC-X1-X2-X3-X4-X5-X6-BFC-Z-...\n"
msgstr "...-Y-BBC-X1-X2-X3-X4-X5-X6-BFC-Z-...\n"

#. type: Plain text
#: en/git-bisect-lk2009.txt:1143
#, priority:100
msgid "where we know that Y is good and BFC is bad, and where BBC and X1 to X6 are untestable."
msgstr "其中，我们知道Y是好的，BFC是坏的，而BBC和X1到X6不可测试。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:1150
#, priority:100
msgid "In this case if you are bisecting manually, what you can do is create a special branch that starts just before the BBC. The first commit in this branch should be the BBC with the BFC squashed into it. And the other commits in the branch should be the commits between BBC and BFC rebased on the first commit of the branch and then the commit after BFC also rebased on."
msgstr "在这种情况下，如果你是手动二分，你可以在BBC开始之前创建一个特殊的分支。这个分支的第一次提交应该是将 BFC 与BBC压缩到一起的。分支中的其他提交应该是在BBC和BFC之间的提交，以该分支的第一次提交为基础，然后再以BFC之后的提交为基础。"

#. type: delimited block -
#: en/git-bisect-lk2009.txt:1157
#, fuzzy, ignore-ellipsis, no-wrap, priority:100
msgid ""
"      (BBC+BFC)-X1'-X2'-X3'-X4'-X5'-X6'-Z'\n"
"     /\n"
"...-Y-BBC-X1-X2-X3-X4-X5-X6-BFC-Z-...\n"
msgstr ""
"      (BBC+BFC)-X1'-X2'-X3'-X4'-X5'-X6'-Z'\n"
"     /\n"
"...-Y-BBC-X1-X2-X3-X4-X5-X6-BFC-Z-...\n"

#. type: Plain text
#: en/git-bisect-lk2009.txt:1160
#, priority:100
msgid "where commits quoted with ' have been rebased."
msgstr "其中以引号 ' 括起来的的提交已被变基。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:1162
#, priority:100
msgid "You can easily create such a branch with Git using interactive rebase."
msgstr "你能够很轻松地用Git的交互式变基来创建这样的分支。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:1164
#, priority:100
msgid "For example using:"
msgstr "例如："

#. type: delimited block -
#: en/git-bisect-lk2009.txt:1167
#, no-wrap, priority:100
msgid "$ git rebase -i Y Z\n"
msgstr "$ git rebase -i Y Z\n"

#. type: Plain text
#: en/git-bisect-lk2009.txt:1170
#, priority:100
msgid "and then moving BFC after BBC and squashing it."
msgstr "然后BFC移动到BBC之后并压缩。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:1173
#, priority:100
msgid "After that you can start bisecting as usual in the new branch and you should eventually find the first bad commit."
msgstr "之后，你可以像往常一样在新的分支中开始二分，最终你应该能找到第一个坏的提交。"

#. type: delimited block -
#: en/git-bisect-lk2009.txt:1178
#, fuzzy, no-wrap, priority:100
msgid "$ git bisect start Z' Y\n"
msgstr "$ git bisect start Z' Y\n"

#. type: Plain text
#: en/git-bisect-lk2009.txt:1189
#, priority:100
msgid "If you are using \"git bisect run\", you can use the same manual fix up as above, and then start another \"git bisect run\" in the special branch. Or as the \"git bisect\" man page says, the script passed to \"git bisect run\" can apply a patch before it compiles and test the software <<8>>. The patch should turn a current untestable commits into a testable one. So the testing will result in \"good\" or \"bad\" and \"git bisect\" will be able to find the first bad commit. And the script should not forget to remove the patch once the testing is done before exiting from the script."
msgstr "如果你使用命令 \"git bisect run\"，你可以使用与上述相同的手段进行修复，然后在特殊分支中启动另一个 \"git bisect run\"。或者如 \"git bisect\"手册所说，作为\"git bisect run\"的脚本可以在编译和测试软件之前添加一个补丁<<8>>。这个补丁需要把当前不可测试的提交变成可测试的。这样，\"git bisect \"将能够找到第一个坏提交，所以测试的结果是 \"好 \"或 \"坏\"。但脚本应当在测试完成后退出脚本前删除补丁。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:1194
#, priority:100
msgid "(Note that instead of a patch you can use \"git cherry-pick BFC\" to apply the fix, and in this case you should use \"git reset --hard HEAD^\" to revert the cherry-pick after testing and before returning from the script.)"
msgstr "(注意，你可以用 \"git cherry-pick BFC\"代替补丁来应用修复，在这种情况下，你应该用 \"git reset --hard HEAD^\"来在测试后和从脚本返回前恢复甄选（cherry-pick））"

#. type: Plain text
#: en/git-bisect-lk2009.txt:1202
#, priority:100
msgid "But the above ways to work around untestable areas are a little bit clunky. Using special branches is nice because these branches can be shared by developers like usual branches, but the risk is that people will get many such branches. And it disrupts the normal \"git bisect\" work-flow. So, if you want to use \"git bisect run\" completely automatically, you have to add special code in your script to restart bisection in the special branches."
msgstr "但上述绕过不可测试区域的方法有点笨拙。使用特殊分支是最好的，因为这些分支可以像普通分支一样被开发者共享，但风险是会创建很多这样的分支。并且它破坏了正常的 \"git bisect \"工作流程。因此，如果你想完全自动地使用 \"git bisect run\"，你必须在你的脚本中添加特殊的代码，以重新启动特殊分支的二分流程。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:1207
#, priority:100
msgid "Anyway one can notice in the above special branch example that the Z' and Z commits should point to the same source code state (the same \"tree\" in git parlance). That's because Z' result from applying the same changes as Z just in a slightly different order."
msgstr "总之，我们可以注意到，在上述特殊分支的例子中，Z'和Z的提交应该指向相同的源代码状态（用git术语说是相同的 \"树\"）。这是因为Z'的结果是应用了与Z相同的修改，只是顺序略有不同。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:1211
#, priority:100
msgid "So if we could just \"replace\" Z by Z' when we bisect, then we would not need to add anything to a script. It would just work for anyone in the project sharing the special branches and the replacements."
msgstr "因此，如果我们可以在二分时用Z'来 \"替换\"Z，那么我们就不需要在脚本中添加任何东西。它将对项目中任何共享特殊和替换分支的人起作用。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:1213
#, priority:100
msgid "With the example above that would give:"
msgstr "通过上面的例子，可以看出："

#. type: delimited block -
#: en/git-bisect-lk2009.txt:1218
#, fuzzy, ignore-ellipsis, no-wrap, priority:100
msgid ""
"      (BBC+BFC)-X1'-X2'-X3'-X4'-X5'-X6'-Z'-...\n"
"     /\n"
"...-Y-BBC-X1-X2-X3-X4-X5-X6-BFC-Z\n"
msgstr ""
"      (BBC+BFC)-X1'-X2'-X3'-X4'-X5'-X6'-Z'-...\n"
"     /\n"
"...-Y-BBC-X1-X2-X3-X4-X5-X6-BFC-Z\n"

#. type: Plain text
#: en/git-bisect-lk2009.txt:1225
#, priority:100
msgid "That's why the \"git replace\" command was created. Technically it stores replacements \"refs\" in the \"refs/replace/\" hierarchy. These \"refs\" are like branches (that are stored in \"refs/heads/\") or tags (that are stored in \"refs/tags\"), and that means that they can automatically be shared like branches or tags among developers."
msgstr "这就是\"git replace\"命令出现的原因。技术层面，它在 \"refs/replace/\"目录中存储替换的 \"refs\"。这些 \"ref \"就像分支（存储在 \"refs/heads/\"中）或标签（存储在 \"refs/tags \"中），所以它们可以像分支或标签一样自动地在开发者之间共享。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:1230
#, priority:100
msgid "\"git replace\" is a very powerful mechanism. It can be used to fix commits in already released history, for example to change the commit message or the author. And it can also be used instead of git \"grafts\" to link a repository with another old repository."
msgstr "\"git replace\"拥有非常强大的机制。它可以用来修复发布历史中的提交，例如改变提交的信息或作者。它也可以用来代替git \"grafts\"，将一个仓库与另一个旧仓库连接起来。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:1234
#, priority:100
msgid "In fact it's this last feature that \"sold\" it to the Git community, so it is now in the \"master\" branch of Git's Git repository and it should be released in Git 1.6.5 in October or November 2009."
msgstr "事实上，正是这最后一个功能把它\"卖\"给了Git社区，所以它目前在Git仓库的\"master\"分支中，应该是在2009年10月或11月的Git 1.6.5版本中发布的。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:1241
#, priority:100
msgid "One problem with \"git replace\" is that currently it stores all the replacements refs in \"refs/replace/\", but it would be perhaps better if the replacement refs that are useful only for bisecting would be in \"refs/replace/bisect/\". This way the replacement refs could be used only for bisecting, while other refs directly in \"refs/replace/\" would be used nearly all the time."
msgstr "\"git replace\"存在的一个问题是，目前它把所有替换的引用都存放在 \"refs/replace/\"中，但如果把只对二分有用的替换引用放在 \"refs/replace/bisect/\"中，也许会更好。这样一来，替换的引用就可以只用于二分，而直接存储在 \"refs/replace/\"中的其他引用则几乎一直在使用。"

#. type: Title ~
#: en/git-bisect-lk2009.txt:1243
#, no-wrap, priority:100
msgid "Bisecting sporadic bugs"
msgstr "查找零星的漏洞"

#. type: Plain text
#: en/git-bisect-lk2009.txt:1248
#, priority:100
msgid "Another possible improvement to \"git bisect\" would be to optionally add some redundancy to the tests performed so that it would be more reliable when tracking sporadic bugs."
msgstr "对 \"git bisect\"的另一个可能的改进是，在所进行的测试中选择性地增加一些冗余，这样在跟踪零星的bug时就会更可靠。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:1252
#, priority:100
msgid "This has been requested by some kernel developers because some bugs called sporadic bugs do not appear in all the kernel builds because they are very dependent on the compiler output."
msgstr "这是由一些内核开发者提出的要求，因为一些被称为零星漏洞的漏洞不会出现在所有的内核构建过程中，因为发现它们非常依赖于编译器输出。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:1261
#, priority:100
msgid "The idea is that every 3 test for example, \"git bisect\" could ask the user to test a commit that has already been found to be \"good\" or \"bad\" (because one of its descendants or one of its ancestors has been found to be \"good\" or \"bad\" respectively). If it happens that a commit has been previously incorrectly classified then the bisection can be aborted early, hopefully before too many mistakes have been made. Then the user will have to look at what happened and then restart the bisection using a fixed bisect log."
msgstr "我们的想法是，每3次测试，\"git bisect\"可以要求用户测试一个已经被标记为 \"好 \"或 \"坏 \"的提交（因为它的一个后代或一个祖先已经被视为 \"好 \"或 \"坏\"提交）。如果错误地分类了一个提交，那么可以在酿成大祸之前中止这个过程。接着，用户将不得不查看发生了什么，最后使用固定的日志重新启动二分操作。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:1265
#, priority:100
msgid "There is already a project called BBChop created by Ealdwulf Wuffinga on Github that does something like that using Bayesian Search Theory <<9>>:"
msgstr "目前，Github上已经有一个由Ealdwulf Wuffinga创建的名为BBChop的项目，其使用贝叶斯搜索理论做了类似的事情<<9>>："

#. type: delimited block _
#: en/git-bisect-lk2009.txt:1272
#, priority:100
msgid "BBChop is like 'git bisect' (or equivalent), but works when your bug is intermittent. That is, it works in the presence of false negatives (when a version happens to work this time even though it contains the bug). It assumes that there are no false positives (in principle, the same approach would work, but adding it may be non-trivial)."
msgstr "BBChop就像'git bisect'（或就是），但当存在间歇性漏洞的时候，它就会起作用。也就是说，它在存在假阴性的情况下也能工作（尽管这个版本包含了这个漏洞，但也可以运行）。它假定不存在假阳性（原则上，同样的方法也可以，但这可能不容易）。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:1276
#, priority:100
msgid "But BBChop is independent of any VCS and it would be easier for Git users to have something integrated in Git."
msgstr "但BBChop是独立于任何VCS的，并且对于Git用户来说，在Git中集成一些东西非常容易。"

#. type: Title -
#: en/git-bisect-lk2009.txt:1278
#, fuzzy, no-wrap, priority:100
msgid "Conclusion"
msgstr "结论"

#. type: Plain text
#: en/git-bisect-lk2009.txt:1285
#, priority:100
msgid "We have seen that regressions are an important problem, and that \"git bisect\" has nice features that complement very well practices and other tools, especially test suites, that are generally used to fight regressions. But it might be needed to change some work-flows and (bad) habits to get the most out of it."
msgstr "我们已经了解到，回归是一个重要的问题，\"git bisect\"有强大的功能，同时也可以很好地补充和应用到其他工具中，尤其是通常被用来解决回归问题测试套件。但也需要改变一些工作流程和改正坏习惯，以获得它的最大效益。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:1292
#, priority:100
msgid "Some improvements to the algorithms inside \"git bisect\" are possible and some new features could help in some cases, but overall \"git bisect\" works already very well, is used a lot, and is already very useful. To back up that last claim, let's give the final word to Ingo Molnar when he was asked by the author how much time does he think \"git bisect\" saves him when he uses it:"
msgstr "\"git bisect\"内部的算法可以进行改进，并且新的功能在特殊情况下也会有帮助，但总的来说，\"git bisect \"已经被大量使用并且非常优秀。Ingo Molnar的发言是最后一个说法的有力支撑，作者问他认为使用 \"git bisect\"能够节省他多少时间："

#. type: delimited block _
#: en/git-bisect-lk2009.txt:1295
#, fuzzy, priority:100
msgid "a _lot_."
msgstr "a _lot_."

#. type: delimited block _
#: en/git-bisect-lk2009.txt:1300
#, priority:100
msgid "About ten years ago did i do my first 'bisection' of a Linux patch queue. That was prior the Git (and even prior the BitKeeper) days. I literally days spent sorting out patches, creating what in essence were standalone commits that i guessed to be related to that bug."
msgstr "大约十年前，我第一次对Linux补丁队列进行了 \"二分算法\"。那是在Git（甚至在BitKeeper）出现之前。我真的花了好几天时间来整理补丁，创建了一些我猜测与该错误有关的独立提交。"

#. type: delimited block _
#: en/git-bisect-lk2009.txt:1303
#, priority:100
msgid "It was a tool of absolute last resort. I'd rather spend days looking at printk output than do a manual 'patch bisection'."
msgstr "这是一个万不得已的情况下使用的工具。我宁愿花几天时间看printk输出，也不愿意进行手动 的\"补丁分割\"。"

#. type: delimited block _
#: en/git-bisect-lk2009.txt:1308
#, priority:100
msgid "With Git bisect it's a breeze: in the best case i can get a ~15 step kernel bisection done in 20-30 minutes, in an automated way. Even with manual help or when bisecting multiple, overlapping bugs, it's rarely more than an hour."
msgstr "使用Git bisect很容易：在最好的情况下，我可以在20-30分钟内以自动化的方式完成约15个步骤的内核分割。即使需要人工帮助，或者在对多个重叠的bug进行分割时，也很少超过一个小时。"

#. type: delimited block _
#: en/git-bisect-lk2009.txt:1314
#, priority:100
msgid "In fact it's invaluable because there are bugs i would never even _try_ to debug if it wasn't for git bisect. In the past there were bug patterns that were immediately hopeless for me to debug - at best i could send the crash/bug signature to lkml and hope that someone else can think of something."
msgstr "事实上，它是非常有价值的，因为如果没有git bisect，有些漏洞我甚至不会尝试去调试。在过去，有些漏洞对我来说基本就没有希望进行调试——我最多只能把崩溃/漏洞签名发给lkml，希望别人能想到一些东西。"

#. type: delimited block _
#: en/git-bisect-lk2009.txt:1318
#, priority:100
msgid "And even if a bisection fails today it tells us something valuable about the bug: that it's non-deterministic - timing or kernel image layout dependent."
msgstr "即使是在运行失败的情况下，它也会告诉我们关于这个漏洞一些有价值的东西：它是非决定性的——与时间或内核图像布局有关。"

#. type: delimited block _
#: en/git-bisect-lk2009.txt:1321
#, priority:100
msgid "So git bisect is unconditional goodness - and feel free to quote that ;-)"
msgstr "因此，git bisect的善良不求回报——请随意引用这句话;-)"

#. type: Title -
#: en/git-bisect-lk2009.txt:1324
#, fuzzy, no-wrap, priority:100
msgid "Acknowledgments"
msgstr "致谢"

#. type: Plain text
#: en/git-bisect-lk2009.txt:1330
#, priority:100
msgid "Many thanks to Junio Hamano for his help in reviewing this paper, for reviewing the patches I sent to the Git mailing list, for discussing some ideas and helping me improve them, for improving \"git bisect\" a lot and for his awesome work in maintaining and developing Git."
msgstr "非常感谢Junio Hamano在审阅本文时提供的帮助，感谢他审阅我发给Git邮件列表的补丁，感谢他讨论一些想法并帮助我改进，感谢他对 \"git bisect\"的大量改进，感谢他在维护和开发Git方面的出色工作。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:1335
#, priority:100
msgid "Many thanks to Ingo Molnar for giving me very useful information that appears in this paper, for commenting on this paper, for his suggestions to improve \"git bisect\" and for evangelizing \"git bisect\" on the linux kernel mailing lists."
msgstr "非常感谢Ingo Molnar给本文提供非常有用的信息，感谢他对本文的评论，感谢他对 \"git bisect\"的改进建议，感谢他在linux内核邮件列表中对\"git bisect\"的宣传。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:1338
#, priority:100
msgid "Many thanks to Linus Torvalds for inventing, developing and evangelizing \"git bisect\", Git and Linux."
msgstr "非常感谢Linus Torvalds对 \"git bisect\"、Git和Linux的发明、开发和宣传。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:1343
#, priority:100
msgid "Many thanks to the many other great people who helped one way or another when I worked on Git, especially to Andreas Ericsson, Johannes Schindelin, H. Peter Anvin, Daniel Barkalow, Bill Lear, John Hawley, Shawn O. Pierce, Jeff King, Sam Vilain, Jon Seymour."
msgstr "非常感谢其他许多在我从事Git工作时以这种或那种方式提供帮助的伟大人物，特别是Andreas Ericsson, Johannes Schindelin, H. Peter Anvin, Daniel Barkalow, Bill Lear, John Hawley, Shawn O. Pierce, Jeff King, Sam Vilain, Jon Seymour。"

#. type: Plain text
#: en/git-bisect-lk2009.txt:1346
#, priority:100
msgid "Many thanks to the Linux-Kongress program committee for choosing the author to given a talk and for publishing this paper."
msgstr "非常感谢Linux-Kongress计划委员会选择作者进行演讲并发表这篇论文。"

#. type: Title -
#: en/git-bisect-lk2009.txt:1348
#, fuzzy, no-wrap, priority:100
#| msgid "--dereference"
msgid "References"
msgstr "位号"

#. type: Plain text
#: en/git-bisect-lk2009.txt:1351
#, priority:100
msgid "[[[1]]] https://web.archive.org/web/20091206032101/http://www.nist.gov/public_affairs/releases/n02-10.htm['Software Errors Cost U.S. Economy $59.5 Billion Annually'. Nist News Release.] See also https://www.nist.gov/system/files/documents/director/planning/report02-3.pdf['The Economic Impacts of Inadequate Infratructure for Software Testing'.  Nist Planning Report 02-3], Executive Summary and Chapter 8."
msgstr "[[[1]]] https://web.archive.org/web/20091206032101/http://www.nist.gov/public_affairs/releases/n02-10.htm['Software Errors Cost U.S. Economy $59.5 Billion Annually'. Nist News Release.] See also https://www.nist.gov/system/files/documents/director/planning/report02-3.pdf['The Economic Impacts of Inadequate Infratructure for Software Testing'.  Nist Planning Report 02-3], Executive Summary and Chapter 8."

#. type: Plain text
#: en/git-bisect-lk2009.txt:1352
#, fuzzy, priority:100
msgid "[[[2]]] https://www.oracle.com/java/technologies/javase/codeconventions-introduction.html['Code Conventions for the Java Programming Language: 1. Introduction'. Sun Microsystems.]"
msgstr "[[[2]]] http://www.oracle.com/technetwork/java/codeconvtoc-136057.html['Code Conventions for the Java Programming Language'. Sun Microsystems.]"

#. type: Plain text
#: en/git-bisect-lk2009.txt:1353
#, fuzzy, priority:100
msgid "[[[3]]] https://en.wikipedia.org/wiki/Software_maintenance['Software maintenance'. Wikipedia.]"
msgstr "[[[3]]] https://en.wikipedia.org/wiki/Software_maintenance['Software maintenance'. Wikipedia.]"

#. type: Plain text
#: en/git-bisect-lk2009.txt:1354
#, fuzzy, priority:100
msgid "[[[4]]] https://lore.kernel.org/git/7vps5xsbwp.fsf_-_@assigned-by-dhcp.cox.net/[Junio C Hamano. 'Automated bisect success story'.]"
msgstr "[[[4]]] https://lore.kernel.org/git/7vps5xsbwp.fsf_-_@assigned-by-dhcp.cox.net/[Junio C Hamano. 'Automated bisect success story'.]"

#. type: Plain text
#: en/git-bisect-lk2009.txt:1355
#, fuzzy, priority:100
msgid "[[[5]]] https://lwn.net/Articles/317154/[Christian Couder. 'Fully automated bisecting with \"git bisect run\"'. LWN.net.]"
msgstr "[[[5]]] https://lwn.net/Articles/317154/[Christian Couder. 'Fully automated bisecting with \"git bisect run\"'. LWN.net.]"

#. type: Plain text
#: en/git-bisect-lk2009.txt:1356
#, fuzzy, priority:100
msgid "[[[6]]] https://lwn.net/Articles/277872/[Jonathan Corbet. 'Bisection divides users and developers'. LWN.net.]"
msgstr "[[[6]]] https://lwn.net/Articles/277872/[Jonathan Corbet. 'Bisection divides users and developers'. LWN.net.]"

#. type: Plain text
#: en/git-bisect-lk2009.txt:1357
#, fuzzy, priority:100
msgid "[[[7]]] https://lore.kernel.org/lkml/20071207113734.GA14598@elte.hu/[Ingo Molnar. 'Re: BUG 2.6.23-rc3 can't see sd partitions on Alpha'. Linux-kernel mailing list.]"
msgstr "[[[7]]] https://lore.kernel.org/lkml/20071207113734.GA14598@elte.hu/[Ingo Molnar. 'Re: BUG 2.6.23-rc3 can't see sd partitions on Alpha'. Linux-kernel mailing list.]"

#. type: Plain text
#: en/git-bisect-lk2009.txt:1358
#, fuzzy, priority:100
msgid "[[[8]]] https://www.kernel.org/pub/software/scm/git/docs/git-bisect.html[Junio C Hamano and the git-list. 'git-bisect(1) Manual Page'. Linux Kernel Archives.]"
msgstr "[[[8]]] https://www.kernel.org/pub/software/scm/git/docs/git-bisect.html[Junio C Hamano and the git-list. 'git-bisect(1) Manual Page'. Linux Kernel Archives.]"

#. type: Plain text
#: en/git-bisect-lk2009.txt:1358
#, fuzzy, priority:100
msgid "[[[9]]] https://github.com/Ealdwulf/bbchop[Ealdwulf. 'bbchop'. GitHub.]"
msgstr "[[[9]]] https://github.com/Ealdwulf/bbchop[Ealdwulf. 'bbchop'. GitHub.]"

#~ msgid "Just in case you are doing something exotic, it should be noted that all of the <commit> in the above description, except in the `--merge-base` case and in the last two forms that use `..` notations, can be any <tree>."
#~ msgstr "为了防止你做一些奇怪的事情，应该注意到，除了`--merge-base`的情况和最后两种使用`...`符号的形式，上述描述中的所有<commit>都可以是任何<tree>。"

#~ msgid "Otherwise, this command applies the arguments passed using the `--trailer` option, if any, to the commit message part of each input file. The result is emitted on the standard output."
#~ msgstr "否则，该命令将使用 `--trailer` 选项传递的参数（如果有的话）应用于每个输入文件的提交信息部分。其结果将在标准输出中发出。"

#~ msgid "This means that the trimmed <token> and <value> will be separated by `': '` (one colon followed by one space)."
#~ msgstr "这意味着修剪后的 <token> 和 <值> 将被 `': '`（一个冒号，后面是一个空格）分开。"

#, fuzzy, no-wrap
#~ msgid "message\n"
#~ msgstr "消息\n"

#, no-wrap
#~ msgid ""
#~ "$ git ls-remote --tags .\n"
#~ "d6602ec5194c87b0fc87103ca4d67251c76f233a\trefs/tags/v0.99\n"
#~ "f25a265a342aed6041ab0cc484224d9ca54b6f41\trefs/tags/v0.99.1\n"
#~ "7ceca275d047c90c0c7d5afb13ab97efdf51bd6e\trefs/tags/v0.99.3\n"
#~ "c5db5456ae3b0873fc659c19fafdde22313cc441\trefs/tags/v0.99.2\n"
#~ "0918385dbd9656cab0d1d81ba7453d49bbc16250\trefs/tags/junio-gpg-pub\n"
#~ msgstr ""
#~ "$ git ls-remote --tags .\n"
#~ "d6602ec5194c87b0fc87103ca4d67251c76f233a\trefs/tags/v0.99\n"
#~ "f25a265a342aed6041ab0cc484224d9ca54b6f41\trefs/tags/v0.99.1\n"
#~ "7ceca275d047c90c0c7d5afb13ab97efdf51bd6e\trefs/tags/v0.99.3\n"
#~ "c5db5456ae3b0873fc659c19fafdde22313cc441\trefs/tags/v0.99.2\n"
#~ "0918385dbd9656cab0d1d81ba7453d49bbc16250\trefs/tags/junio-gpg-pub\n"

#, no-wrap
#~ msgid ""
#~ "$ git remote add korg http://www.kernel.org/pub/scm/git/git.git\n"
#~ "$ git ls-remote --tags korg v\\*\n"
#~ "d6602ec5194c87b0fc87103ca4d67251c76f233a\trefs/tags/v0.99\n"
#~ "f25a265a342aed6041ab0cc484224d9ca54b6f41\trefs/tags/v0.99.1\n"
#~ "c5db5456ae3b0873fc659c19fafdde22313cc441\trefs/tags/v0.99.2\n"
#~ "7ceca275d047c90c0c7d5afb13ab97efdf51bd6e\trefs/tags/v0.99.3\n"
#~ msgstr ""
#~ "$ git remote add korg http://www.kernel.org/pub/scm/git/git.git\n"
#~ "$ git ls-remote --tags korg v\\*\n"
#~ "d6602ec5194c87b0fc87103ca4d67251c76f233a\trefs/tags/v0.99\n"
#~ "f25a265a342aed6041ab0cc484224d9ca54b6f41\trefs/tags/v0.99.1\n"
#~ "c5db5456ae3b0873fc659c19fafdde22313cc441\trefs/tags/v0.99.2\n"
#~ "7ceca275d047c90c0c7d5afb13ab97efdf51bd6e\trefs/tags/v0.99.3\n"

#~ msgid "Append to the notes of an existing object (defaults to HEAD).  Creates a new notes object if needed."
#~ msgstr "附加到一个现有对象的注释中（默认为HEAD）。  如果需要的话，会创建一个新的注释对象。"

#~ msgid "Take the given blob object (for example, another note) as the note message. (Use `git notes copy <object>` instead to copy notes between objects.)"
#~ msgstr "将给定的blob对象（例如，另一个笔记）作为笔记信息。(使用`git notes copy <object>`来代替在对象之间复制注释)。"

#~ msgid "The following 'update' procedures are only available via the `submodule.<name>.update` configuration variable:"
#~ msgstr "以下 'update' 程序仅通过 `submodule.<名称>.update` 配置变量可用："

#~ msgid "arbitrary shell command that takes a single argument (the sha1 of the commit recorded in the superproject) is executed. When `submodule.<name>.update` is set to '!command', the remainder after the exclamation mark is the custom command."
#~ msgstr "执行任意的 shell 命令，该命令需要一个参数（父项目中记录的提交的 sha1）。当 `submodule.<名称>.update` 被设置为 '!command' 时，惊叹号后的剩余部分就是自定义命令。"

#~ msgid "the submodule is not updated."
#~ msgstr "该子模块不被更新。"

#, ignore-same, no-wrap
#~ msgid "linkgit:gitcli[7]"
#~ msgstr "linkgit:gitcli[7]"

#, ignore-same, no-wrap
#~ msgid "linkgit:githooks[5]"
#~ msgstr "linkgit:githooks[5]"

#, ignore-same, no-wrap
#~ msgid "linkgit:gitmailmap[5]"
#~ msgstr "linkgit:gitmailmap[5]"

#, ignore-same, no-wrap
#~ msgid "linkgit:gitmodules[5]"
#~ msgstr "linkgit:gitmodules[5]"

#, ignore-same, no-wrap
#~ msgid "linkgit:gitrepository-layout[5]"
#~ msgstr "linkgit:gitrepository-layout[5]"

#, fuzzy
#~ msgid "Git Repository Layout."
#~ msgstr "The Git Repository"

#, ignore-same, no-wrap
#~ msgid "linkgit:gitrevisions[7]"
#~ msgstr "linkgit:gitrevisions[7]"

#, ignore-same
#~ msgid "linkgit:git-apply[1]."
#~ msgstr "linkgit:git-apply[1]."

#, ignore-same
#~ msgid "bc"
#~ msgstr "bc"

#, ignore-same
#~ msgid "bc3"
#~ msgstr "bc3"

#, ignore-same
#~ msgid "bc4"
#~ msgstr "bc4"

#, ignore-same
#~ msgid "emerge"
#~ msgstr "emerge"

#, ignore-same
#~ msgid "smerge"
#~ msgstr "smerge"

#~ msgid "Only useful with `--objects`; print the names of the object IDs that are found. This is the default behavior."
#~ msgstr "只对`---对象`有用；打印找到的对象ID的名称。这是默认行为。"

#, fuzzy
#~ msgid "cached"
#~ msgstr "已缓存"

#, fuzzy
#~ msgid "skip-worktree"
#~ msgstr "跳过工作树"

#, fuzzy
#~ msgid "unmerged"
#~ msgstr "未合并"

#, fuzzy
#~ msgid "to be killed"
#~ msgstr "将被终止"

#, ignore-same
#~ msgid "--[no-]autosquash"
#~ msgstr "--[no-]autosquash"

#, no-wrap
#~ msgid "--super-prefix=<path>"
#~ msgstr "--super-prefix=<path>"

#~ msgid "Currently for internal use only.  Set a prefix which gives a path from above a repository down to its root.  One use is to give submodules context about the superproject that invoked it."
#~ msgstr "目前只供内部使用。  设置一个前缀，提供一个从仓库到其根目录的路径。  一个用途是给子模块提供关于调用它父模块的上下文。"

#, fuzzy
#~ msgid "Prints a Git logical variable."
#~ msgstr "Git"

#~ msgid "`--date=default` is the default format, and is similar to `--date=rfc2822`, with a few exceptions:"
#~ msgstr "`--date=default`是默认格式，与`--date=rfc2822`类似，但有一些例外。"

#~ msgid "there is no comma after the day-of-week"
#~ msgstr "在星期的后面没有逗号"

#~ msgid "the time zone is omitted when the local time zone is used"
#~ msgstr "使用本地时区时省略时区"

#, ignore-ellipsis, no-wrap
#~ msgid "'git mv' <options>... <args>...\n"
#~ msgstr "'git mv' <options>...<args>...\n"

#, fuzzy, no-wrap
#~ msgid "'git reflog' <subcommand> <options>\n"
#~ msgstr "'git reflog' <subcommand> <options>\n"

#, ignore-same, no-wrap
#~ msgid "apply.ignoreWhitespace"
#~ msgstr "apply.ignoreWhitespace"

#, ignore-same, no-wrap
#~ msgid "apply.whitespace"
#~ msgstr "apply.whitespace"

#, ignore-same, no-wrap
#~ msgid "diff.tool"
#~ msgstr "diff.tool"

#, ignore-same, no-wrap
#~ msgid "diff.guitool"
#~ msgstr "diff.guitool"

#, ignore-same, no-wrap
#~ msgid "difftool.prompt"
#~ msgstr "difftool.prompt"

#, ignore-same, no-wrap
#~ msgid "difftool.trustExitCode"
#~ msgstr "difftool.trustExitCode"

#, fuzzy, no-wrap
#~ msgid "grep.patternType"
#~ msgstr "grep.patternType"

#, fuzzy, no-wrap
#~ msgid "grep.extendedRegexp"
#~ msgstr "grep.extendedRegexp"

#, fuzzy, no-wrap
#~ msgid "grep.fullName"
#~ msgstr "grep.fullName"

#, fuzzy, no-wrap
#~ msgid "grep.fallbackToNoIndex"
#~ msgstr "grep.fallbackToNoIndex"

#, ignore-same, no-wrap
#~ msgid "log.date"
#~ msgstr "log.date"

#~ msgid "Default format for human-readable dates.  (Compare the `--date` option.)  Defaults to \"default\", which means to write dates like `Sat May 8 19:35:34 2010 -0500`."
#~ msgstr "人类可读日期的默认格式。  (比较`--date`选项。)默认为 \"default\"，即写成`Sat May 8 19:35:34 2010 -0500`这样的日期。"

#~ msgid "If the format is set to \"auto:foo\" and the pager is in use, format \"foo\" will be the used for the date format. Otherwise \"default\" will be used."
#~ msgstr "如果格式被设置为 \"auto:foo\"，并且正在使用呼叫器，那么格式 \"foo \"将被用于日期格式。否则将使用 \"默认\"。"

#, ignore-same, no-wrap
#~ msgid "log.follow"
#~ msgstr "log.follow"

#~ msgid "If `true`, `git log` will act as if the `--follow` option was used when a single <path> is given.  This has the same limitations as `--follow`, i.e. it cannot be used to follow multiple files and does not work well on non-linear history."
#~ msgstr "如果为`true`，`git log`将像使用`--follow`选项一样，当给出一个<路径>时。  这与`--follow`有相同的限制，即它不能用于跟踪多个文件，并且在非线性历史上不能很好地工作。"

#, ignore-same, no-wrap
#~ msgid "log.showRoot"
#~ msgstr "log.showRoot"

#~ msgid "If `false`, `git log` and related commands will not treat the initial commit as a big creation event.  Any root commits in `git log -p` output would be shown without a diff attached.  The default is `true`."
#~ msgstr "如果为`false`，`git log`和相关命令将不把初始提交作为一个大的创建事件。  `git log -p`输出中的任何根提交都会被显示出来，而不附加差异。  默认是`true`。"

#, ignore-same, no-wrap
#~ msgid "log.showSignature"
#~ msgstr "log.showSignature"

#~ msgid "If `true`, `git log` and related commands will act as if the `--show-signature` option was passed to them."
#~ msgstr "如果 \"true\"，\"git log \"和相关命令将像\"--显示签名 \"选项一样行事。"

#, fuzzy, no-wrap
#~ msgid "mailmap.*"
#~ msgstr "邮件地图.*"

#, fuzzy
#~ msgid "See linkgit:git-shortlog[1]."
#~ msgstr "请查看 linkgit:git-shortlog[1]."

#, no-wrap
#~ msgid "notes.displayRef"
#~ msgstr "笔记.displayRef"

#~ msgid "Which refs, in addition to the default set by `core.notesRef` or `GIT_NOTES_REF`, to read notes from when showing commit messages with the `log` family of commands.  See linkgit:git-notes[1]."
#~ msgstr "除了由`core.notesRef`或`GIT_NOTES_REF`设置的默认值外，在用`log`系列命令显示提交信息时，还要从哪些参考文献中读取注释。  参见linkgit:git-notes[1]。"

#~ msgid "May be an unabbreviated ref name or a glob and may be specified multiple times.  A warning will be issued for refs that do not exist, but a glob that does not match any refs is silently ignored."
#~ msgstr "可以是一个非缩写的 ref 名称或一个 glob，并且可以多次指定。  对于不存在的参考文献将发出警告，但不匹配任何参考文献的glob将被沉默地忽略。"

#~ msgid "This setting can be disabled by the `--no-notes` option, overridden by the `GIT_NOTES_DISPLAY_REF` environment variable, and overridden by the `--notes=<ref>` option."
#~ msgstr "这个设置可以由`--no-notes`选项禁用，由`GIT_NOTES_DISPLAY_REF`环境变量覆盖，并由`--notes=<ref>`选项覆盖。"

#, no-wrap
#~ msgid "notes.mergeStrategy"
#~ msgstr "笔记.合并策略"

#~ msgid "Which merge strategy to choose by default when resolving notes conflicts.  Must be one of `manual`, `ours`, `theirs`, `union`, or `cat_sort_uniq`.  Defaults to `manual`.  See \"NOTES MERGE STRATEGIES\" section above for more information on each strategy."
#~ msgstr "在解决笔记冲突时，默认选择哪种合并策略。  必须是`manual`, `ours`, `theirs`, `union`, 或 `cat_sort_uniq`之一。  默认为 \"手动\"。  关于每种策略的更多信息，请看上面的 \"Notes MERGE STRATEGIES \"部分。"

#~ msgid "This setting can be overridden by passing the `--strategy` option."
#~ msgstr "这个设置可以通过传递`--策略`选项来覆盖。"

#, no-wrap
#~ msgid "notes.<name>.mergeStrategy"
#~ msgstr "笔记.<名称>.合并策略"

#~ msgid "Which merge strategy to choose when doing a notes merge into refs/notes/<name>.  This overrides the more general \"notes.mergeStrategy\".  See the \"NOTES MERGE STRATEGIES\" section above for more information on each available strategy."
#~ msgstr "当进行笔记合并到 refs/notes/<name>时，选择哪种合并策略。  这覆盖了更一般的 \"notes.mergeStrategy\"。  关于每个可用策略的更多信息，请参见上面的 \"笔记合并策略 \"部分。"

#~ msgid "Which ref (or refs, if a glob or specified more than once), in addition to the default set by `core.notesRef` or `GIT_NOTES_REF`, to read notes from when showing commit messages with the 'git log' family of commands.  This setting can be overridden on the command line or by the `GIT_NOTES_DISPLAY_REF` environment variable.  See linkgit:git-log[1]."
#~ msgstr "除了`core.notesRef`或`GIT_NOTES_REF`设置的默认值外，在用'git log'系列命令显示提交信息时，还要从哪个参考文献（或参考文献，如果一个glob或指定多个）中读取。  这个设置可以在命令行或`GIT_NOTES_DISPLAY_REF`环境变量中被覆盖。  参见 linkgit:git-log[1]。"

#, no-wrap
#~ msgid "notes.rewrite.<command>"
#~ msgstr "笔记.重写.<命令>"

#~ msgid "When rewriting commits with <command> (currently `amend` or `rebase`), if this variable is `false`, git will not copy notes from the original to the rewritten commit.  Defaults to `true`.  See also \"`notes.rewriteRef`\" below."
#~ msgstr "当用<command>重写提交时（目前是`amend`或`rebase`），如果这个变量是`false`，git将不会从原始提交中复制注释到重写的提交中。  默认为`true`。  参见下面的\"`notes.rewriteRef`\"。"

#~ msgid "This setting can be overridden by the `GIT_NOTES_REWRITE_REF` environment variable."
#~ msgstr "这个设置可以被`GIT_NOTES_REWRITE_REF`环境变量所覆盖。"

#, no-wrap
#~ msgid "notes.rewriteMode"
#~ msgstr "笔记.重写模式"

#~ msgid "When copying notes during a rewrite, what to do if the target commit already has a note.  Must be one of `overwrite`, `concatenate`, `cat_sort_uniq`, or `ignore`.  Defaults to `concatenate`."
#~ msgstr "在重写过程中复制注释时，如果目标提交已经有一个注释，该如何处理。  必须是`overwrite`, `concatenate`, `cat_sort_uniq`, 或 `ignore`之一。  默认为 \"concatenate\"。"

#~ msgid "This setting can be overridden with the `GIT_NOTES_REWRITE_MODE` environment variable."
#~ msgstr "这个设置可以用`GIT_NOTES_REWRITE_MODE`环境变量覆盖。"

#, no-wrap
#~ msgid "notes.rewriteRef"
#~ msgstr "笔记.重写参考"

#~ msgid "When copying notes during a rewrite, specifies the (fully qualified) ref whose notes should be copied.  May be a glob, in which case notes in all matching refs will be copied.  You may also specify this configuration several times."
#~ msgstr "当在重写过程中复制注释时，指定应该被复制的（完全合格的）注释。  可以是一个glob，在这种情况下，所有匹配的参考文献中的注释都会被复制。  你也可以多次指定这个配置。"

#~ msgid "Does not have a default value; you must configure this variable to enable note rewriting."
#~ msgstr "没有默认值；你必须配置这个变量以启用注释重写。"

#~ msgid "Can be overridden with the `GIT_NOTES_REWRITE_REF` environment variable."
#~ msgstr "可以用`GIT_NOTES_REWRITE_REF`环境变量覆盖。"

#, ignore-same, no-wrap
#~ msgid "sendemail.aliasesFile"
#~ msgstr "sendemail.aliasesFile"

#, ignore-same, no-wrap
#~ msgid "sendemail.aliasFileType"
#~ msgstr "sendemail.aliasFileType"

#, fuzzy, no-wrap
#~ msgid "sendmail"
#~ msgstr "sendmail"

#, ignore-same, no-wrap
#~ msgid "sendemail.multiEdit"
#~ msgstr "sendemail.multiEdit"

#, ignore-same, no-wrap
#~ msgid "sendemail.confirm"
#~ msgstr "sendemail.confirm"

#~ msgid "Limit the displayed commits to those directly on the ancestry chain between the ``from'' and ``to'' commits in the given commit range. I.e. only display commits that are ancestor of the ``to'' commit and descendants of the ``from'' commit."
#~ msgstr "将显示的提交限制在给定提交范围内 \"from \"和 \"to \"提交之间的直接祖先链上。也就是说，只显示 \"to \"提交的祖先和 \"from \"提交的后代的提交。"

#, fuzzy
#~ msgid "`--track=direct` is the default when the start point is a remote-tracking branch.  Set the branch.autoSetupMerge configuration variable to `false` if you want `git switch`, `git checkout` and `git branch` to always behave as if `--no-track` were given. Set it to `always` if you want this behavior when the start-point is either a local or remote-tracking branch. Set it to `inherit` if you want to copy the tracking configuration from the branch point."
#~ msgstr "当起点是一个远程跟踪的分支时，这种行为是默认的。  如果你想让 \"git switch\"、\"git checkout \"和 \"git branch \"总是表现得像\"--no-track \"一样，就把 branch.autoSetupMerge 配置变量设为 \"false\"。如果你想在起始点是本地或远程跟踪的分支时有这种行为，则将其设置为`always`。"

#, fuzzy, no-wrap
#~ msgid "        <mode> SP <type> SP <object> TAB <file>\n"
#~ msgstr "        <mode> SP <type> SP <object> TAB <file>\n"

#, fuzzy, no-wrap
#~ msgid "        <mode> SP <type> SP <object> SP <object size> TAB <file>\n"
#~ msgstr "        <mode> SP <type> SP <object> SP <object size> TAB <file>\n"

#, ignore-same, no-wrap
#~ msgid "--no-quiet"
#~ msgstr "--no-quiet"

#~ msgid "Be quiet, only report errors. The default behavior is set by the `reset.quiet` config option. `--quiet` and `--no-quiet` will override the default behavior."
#~ msgstr "保持安静，只报告错误。默认行为是由`reset.quiet`配置选项设置的。`--quiet`和`--no-quiet`将覆盖默认行为。"

#, ignore-same, no-wrap
#~ msgid "--track"
#~ msgstr "--track"

#, fuzzy, no-wrap
#~ msgid "--orphan <new_branch>"
#~ msgstr "--orphan <new_branch>"

#~ msgid "This option bypasses the pre-commit and commit-msg hooks.  See also linkgit:githooks[5]."
#~ msgstr "这个选项绕过了pre-commit和commit-msg钩子。  参见 linkgit:githooks[5]。"

#, fuzzy, no-wrap
#~ msgid "--shared[=(false|true|umask|group|all|world|everybody|0xxx)]"
#~ msgstr "--shared[=(false|true|umask|group|all|world|everybody|0xxx)]"

#, fuzzy, no-wrap
#~ msgid "'0xxx'"
#~ msgstr "'0xxx'"

#, fuzzy, no-wrap
#~ msgid "<url>"
#~ msgstr "<url>"

#, ignore-same, no-wrap
#~ msgid "--unsorted-input"
#~ msgstr "--unsorted-input"

#, ignore-same, no-wrap
#~ msgid "-9"
#~ msgstr "-9"

#, fuzzy
#~ msgid "The 'git bundle' command packages objects and references in an archive at the originating machine, which can then be imported into another repository using 'git fetch', 'git pull', or 'git clone', after moving the archive by some means (e.g., by sneakernet)."
#~ msgstr "The 'git bundle' command packages objects and references in an archive at the originating machine, which can then be imported into another repository using 'git fetch', 'git pull', or 'git clone', after moving the archive by some means (e.g., by sneakernet)."

#, fuzzy, no-wrap
#~ msgid "--nl=<N>"
#~ msgstr "--nl=<N>"

#, fuzzy, no-wrap
#~ msgid "--exclude-per-directory=<gitignore>"
#~ msgstr "--exclude-per-directory=<gitignore>"

#, ignore-same, no-wrap
#~ msgid "--preserve-merges"
#~ msgstr "--preserve-merges"

#, fuzzy
#~ msgid "[DEPRECATED: use `--rebase-merges` instead] Recreate merge commits instead of flattening the history by replaying commits a merge commit introduces. Merge conflict resolutions or manual amendments to merge commits are not preserved."
#~ msgstr "[DEPRECATED: use `--rebase-merges` instead] Recreate merge commits instead of flattening the history by replaying commits a merge commit introduces. Merge conflict resolutions or manual amendments to merge commits are not preserved."

#, fuzzy
#~ msgid "--preserve-merges and --rebase-merges"
#~ msgstr "--preserve-merges and --rebase-merges"

#, fuzzy
#~ msgid "--preserve-merges and --empty="
#~ msgstr "--preserve-merges and --empty="

#, fuzzy
#~ msgid "--preserve-merges and --ignore-whitespace"
#~ msgstr "--preserve-merges and --ignore-whitespace"

#, fuzzy
#~ msgid "--preserve-merges and --committer-date-is-author-date"
#~ msgstr "--preserve-merges and --committer-date-is-author-date"

#, fuzzy
#~ msgid "--preserve-merges and --ignore-date"
#~ msgstr "--preserve-merges and --ignore-date"

#, fuzzy, no-wrap
#~ msgid "1 --- 2 --- 3 --- 4 --- 5\n"
#~ msgstr "1 --- 2 --- 3 --- 4 --- 5\n"

#, fuzzy, no-wrap
#~ msgid "1 --- 2 --- 4 --- 3 --- 5\n"
#~ msgstr "1 --- 2 --- 4 --- 3 --- 5\n"

#~ msgid "'C' = copied"
#~ msgstr "'C'=复制的"

#, fuzzy, no-wrap
#~ msgid "--preserve-merges (DEPRECATED)"
#~ msgstr "--preserve-merges (DEPRECATED)"

#, ignore-same, no-wrap
#~ msgid "--advertise-refs"
#~ msgstr "--advertise-refs"

#~ msgid "The `-M` and `-C` options require O(n^2) processing time where n is the number of potential rename/copy targets.  This option prevents rename/copy detection from running if the number of rename/copy targets exceeds the specified number."
#~ msgstr "`-M` 和 `-C` 选项需要 O(n^2) 的处理时间，其中 n 是潜在的重命名/复制目标数量。如果重命名/复制目标的数量超过了指定的数量，该选项可防止重命名/复制检测运行。"

#, ignore-ellipsis, no-wrap
#~ msgid "'git diff' [<options>] <commit> [--] [<path>...]"
#~ msgstr "'git diff' [<options>] <commit> [--] [<path>...] 。"

#, fuzzy, no-wrap
#~ msgid "--no-diff-merges:"
#~ msgstr "--no-diff-merges"

#, fuzzy, no-wrap
#~ msgid "-m:"
#~ msgstr "-m"

#, fuzzy, no-wrap
#~ msgid "-c:"
#~ msgstr "-c"

#, fuzzy, no-wrap
#~ msgid "--cc:"
#~ msgstr "--cc"

#, fuzzy
#~ msgid "Show only names of changed files."
#~ msgstr "仅显示已更改文件的名称。"

#, fuzzy, no-wrap
#~ msgid "show [<diff-options>] [<stash>]"
#~ msgstr "'git show' [<options>] [<object>...]\n"

#, ignore-same, no-wrap
#~ msgid "linkgit:git-parse-remote[1]"
#~ msgstr "linkgit:git-parse-remote[1]"

#, ignore-same
#~ msgid "git-parse-remote(1)"
#~ msgstr "git-parse-remote(1)"

#, fuzzy
#~ msgid "git-parse-remote - Routines to help parsing remote repository access parameters"
#~ msgstr "git-parse-remote - Routines to help parsing remote repository access parameters"

#, fuzzy
#~ msgid "'. \"$(git --exec-path)/git-parse-remote\"'\n"
#~ msgstr "'. \"$(git --exec-path)/git-parse-remote\"'\n"

#, fuzzy
#~ msgid ""
#~ "Context\n"
#~ "~~~~~~~\n"
#~ msgstr "上下文"

#, fuzzy
#~ msgid "NOTES\n"
#~ msgstr "注释"

#, fuzzy
#~ msgid "contents of <old|new>,\n"
#~ msgstr "--contents <file>"

#, ignore-same
#~ msgid "linkgit:git-shortlog[1]."
#~ msgstr "linkgit:git-shortlog[1]."

#, fuzzy
#~ msgid "similar to '%>(<N>)', '%>|(<N>)'"
#~ msgstr "'%>(<N>)', '%>|(<N>)'"

#, fuzzy
#~ msgid "similar to '%<(<N>)', '%<|(<N>)'"
#~ msgstr "'%><(<N>)', '%><|(<N>)'"

#, fuzzy
#~ msgid "or linkgit:git-blame[1])"
#~ msgstr "linkgit:git-blame[1]"

#, fuzzy
#~ msgid "to sign a signed commit"
#~ msgstr "--origin <commit>"

#, fuzzy
#~ msgid "'git show-index'\n"
#~ msgstr "git-show-index(1)"

#, ignore-same
#~ msgid "`GIT_REDACT_COOKIES`"
#~ msgstr "`GIT_REDACT_COOKIES`"

#, fuzzy
#~ msgid "see linkgit:git-commit-tree[1]"
#~ msgstr "linkgit:git-commit-tree[1]"
